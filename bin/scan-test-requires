#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Attribute/Constant.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ATTRIBUTE_CONSTANT';
  package Attribute::Constant;
  use 5.008001;
  use warnings;
  use strict;
  our $VERSION = sprintf "%d.%02d", q$Revision: 1.1 $ =~ /(\d+)/g;
  use Attribute::Handlers;
  use Data::Lock ();
  
  sub UNIVERSAL::Constant : ATTR {
      my ( $pkg, $sym, $ref, $attr, $data, $phase ) = @_;
      (
            ref $ref eq 'HASH'  ? %$ref
          : ref $ref eq 'ARRAY' ? @$ref
          :                       ($$ref)
        )
        = ref $data
        ? ref $data eq 'ARRAY'
            ? @$data    # perl 5.10.x
            : $data
        : $data;        # perl 5.8.x
      Data::Lock::dlock($ref);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Attribute::Constant - Make read-only variables via attribute
  
  =head1 VERSION
  
  $Id: Constant.pm,v 1.1 2013/04/03 14:37:57 dankogai Exp $
  
  =head1 SYNOPSIS
  
   use Attribute::Constant;
   my $sv : Constant( $initial_value );
   my @av : Constant( @values );
   my %hv : Constant( key => value, key => value, ...);
  
  =head1 DESCRIPTION
  
  This module uses L<Data::Lock> to make the variable read-only.  Check
  the document and source of L<Data::Lock> for its mechanism.
  
  =head1 ATTRIBUTES
  
  This module adds only one attribute, C<Constant>.  You give its
  initial value as shown.  Unlike L<Readonly>, parantheses cannot be
  ommited but it is semantically more elegant and thanks to
  L<Data::Lock>, it imposes almost no performance penalty.
  
  =head1 CAVEAT
  
  =head2 Multi-line attributes
  
  Multi-line attributes are not allowed in Perl 5.8.x.
  
    my $o : Constant(Foo->new(one=>1,two=>2,three=>3));    # ok
    my $p : Constant(Bar->new(
                              one   =>1,
                              two   =>2,
                              three =>3
                             )
                   ); # needs Perl 5.10
  
  In which case you can use L<Data::Lock> instead:
  
    dlock(my $p = Bar->new(
          one   => 1,
          two   => 2,
          three => 3
      )
    );
  
  After all, this module is a wrapper to L<Data::Lock>;
  
  =head2 Constants from Variables
  
  You may be surprised the following code B<DOES NOT> work as you expected:
  
    #!/usr/bin/perl
    use strict;
    use warnings;
    use Attribute::Constant;
    use Data::Dumper;
    {
      package MyClass;
      sub new {
          my ( $class, %params ) = @_;
          return bless \%params, $class;
      }
    }
    my $o = MyClass->new( a => 1, b => 2 );
    my $x : Constant($o);
    print Dumper( $o, $x );
  
  Which outputs:
  
    $VAR1 = bless( {
                   'a' => 1,
                   'b' => 2
                 }, 'MyClass' );
    $VAR2 = undef;
  
  Why?  Because C< $x : Constant($o) > happens B<before>
  C<< $o = Myclass->new() >>.
  
  On the other hand, the following works.
  
    my $y : Constant(MyClass->new(a => 1,b => 2));
    print Dumper( $o, $y );
  
  Rule of the thumb is do not feed variables to constant because
  varialbes change after the attribute invocation.
  
  Or simply use C<Data::Lock::dlock>.
  
    use Data::Lock qw/dlock/;
    dlock my $z = $o;
    print Dumper( $o, $y );
  
  =head1 SEE ALSO
  
  L<Data::Lock>, L<constant>
  
  =head1 AUTHOR
  
  Dan Kogai, C<< <dankogai+cpan at gmail.com> >>
  
  =head1 BUGS & SUPPORT
  
  See L<Data::Lock>.
  
  =head1 ACKNOWLEDGEMENTS
  
  L<Readonly>
  
  =head1 COPYRIGHT & LICENSE
  
  Copyright 2008-2013 Dan Kogai, all rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
ATTRIBUTE_CONSTANT

$fatpacked{"Class/Accessor/Lite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_ACCESSOR_LITE';
  package Class::Accessor::Lite;
  
  use strict;
  
  our $VERSION = '0.08';
  
  sub croak {require Carp; Carp::croak(@_)}
  
  sub import {
      shift;
      my %args = @_;
      my $pkg = caller(0);
      my %key_ctor = (
          rw => \&_mk_accessors,
          ro => \&_mk_ro_accessors,
          wo => \&_mk_wo_accessors,
      );
      for my $key (sort keys %key_ctor) {
          if (defined $args{$key}) {
              croak("value of the '$key' parameter should be an arrayref")
                  unless ref($args{$key}) eq 'ARRAY';
              $key_ctor{$key}->($pkg, @{$args{$key}});
          }
      }
      _mk_new($pkg)
          if $args{new};
      1;
  }
  
  sub mk_new_and_accessors {
      (undef, my @properties) = @_;
      my $pkg = caller(0);
      _mk_new($pkg);
      _mk_accessors($pkg, @properties);
  }
  
  sub mk_new {
      my $pkg = caller(0);
      _mk_new($pkg);
  }
  
  sub mk_accessors {
      (undef, my @properties) = @_;
      my $pkg = caller(0);
      _mk_accessors($pkg, @properties);
  }
  
  sub mk_ro_accessors {
      (undef, my @properties) = @_;
      my $pkg = caller(0);
      _mk_ro_accessors($pkg, @properties);
  }
  
  sub mk_wo_accessors {
      (undef, my @properties) = @_;
      my $pkg = caller(0);
      _mk_wo_accessors($pkg, @properties);
  }
  
  sub _mk_new {
      my $pkg = shift;
      no strict 'refs';
      *{$pkg . '::new'} = __m_new($pkg);
  }
  
  sub _mk_accessors {
      my $pkg = shift;
      no strict 'refs';
      for my $n (@_) {
          *{$pkg . '::' . $n} = __m($n);
      }
  }
  
  sub _mk_ro_accessors {
      my $pkg = shift;
      no strict 'refs';
      for my $n (@_) {
          *{$pkg . '::' . $n} = __m_ro($pkg, $n);
      }
  }
  
  sub _mk_wo_accessors {
      my $pkg = shift;
      no strict 'refs';
      for my $n (@_) {
          *{$pkg . '::' . $n} = __m_wo($pkg, $n);
      }
  }
  
  sub __m_new {
      my $pkg = shift;
      no strict 'refs';
      return sub {
          my $klass = shift;
          bless {
              (@_ == 1 && ref($_[0]) eq 'HASH' ? %{$_[0]} : @_),
          }, $klass;
      };
  }
  
  sub __m {
      my $n = shift;
      sub {
          return $_[0]->{$n} if @_ == 1;
          return $_[0]->{$n} = $_[1] if @_ == 2;
          shift->{$n} = \@_;
      };
  }
  
  sub __m_ro {
      my ($pkg, $n) = @_;
      sub {
          if (@_ == 1) {
              return $_[0]->{$n} if @_ == 1;
          } else {
              my $caller = caller(0);
              croak("'$caller' cannot access the value of '$n' on objects of class '$pkg'");
          }
      };
  }
  
  sub __m_wo {
      my ($pkg, $n) = @_;
      sub {
          if (@_ == 1) {
              my $caller = caller(0);
              croak("'$caller' cannot alter the value of '$n' on objects of class '$pkg'")
          } else {
              return $_[0]->{$n} = $_[1] if @_ == 2;
              shift->{$n} = \@_;
          }
      };
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::Accessor::Lite - a minimalistic variant of Class::Accessor
  
  =head1 SYNOPSIS
  
      package MyPackage;
  
      use Class::Accessor::Lite (
          new => 1,
          rw  => [ qw(foo bar) ],
          ro  => [ qw(baz) ],
          wo  => [ qw(hoge) ],
      );
  
  =head1 DESCRIPTION
  
  The module is a variant of C<Class::Accessor>.  It is fast and requires less typing, has no dependencies to other modules, and does not mess up the @ISA.
  
  =head1 THE USE STATEMENT
  
  The use statement (i.e. the C<import> function) of the module takes a single hash as an argument that specifies the types and the names of the properties.  Recognises the following keys.
  
  =over 4
  
  =item new => $true_or_false
  
  the default constructor is created if the value evaluates to true, otherwise nothing is done (the default behaviour)
  
  =item rw => \@name_of_the_properties
  
  creates a read / write accessor for the name of the properties passed through as an arrayref
  
  =item ro => \@name_of_the_properties
  
  creates a read-only accessor for the name of the properties passed through as an arrayref
  
  =item wo => \@name_of_the_properties
  
  creates a write-only accessor for the name of the properties passed through as an arrayref
  
  =back
  
  For more detailed explanation read the following section describing the behaviour of each function that actually creates the accessors.
  
  =head1 FUNCTIONS
  
  As of version 0.04 the properties can be specified as the arguments to the C<use> statement (as can be seen in the SYNOPSIS) which is now the recommended way of using the module, but for compatibility the following functions are provided as well.
  
  =head2 Class::Accessor::Lite->mk_accessors(@name_of_the_properties)
  
  Creates an accessor in current package under the name specified by the arguments that access the properties (of a hashref) with the same name.
  
  =head2 Class::Accessor::Lite->mk_ro_accessors(@name_of_the_properties)
  
  Same as mk_accessors() except it will generate read-only accessors (i.e. true accessors).  If you attempt to set a value with these accessors it will throw an exception.
  
  =head2 Class::Accessor::Lite->mk_wo_accessors(@name_of_the_properties)
  
  Same as mk_accessors() except it will generate write-only accessors (i.e. mutators).  If you attempt to read a value with these accessors it will throw an exception.
  
  =head2 Class::Accessor::Lite->mk_new()
  
  Creates the C<new> function that accepts a hash or a hashref as the initial properties of the object.
  
  =head2 Class::Accessor::Lite->mk_new_and_accessors(@name_of_the_properties)
  
  DEPRECATED.  Use the new "use Class::Accessor::Lite (...)" style.
  
  =head1 FAQ
  
  =head2 Can I use C<Class::Accessor::Lite> in an inherited module?
  
  Yes in most cases, when the class object in the super class is implemented using a hashref.  However you _should_ _not_ create the constructor for the inherited class by calling C<<Class::Accessor::Lite->new()>> or by C<<use Class::Accessor::Lite (new => 1)>>.  The only other thing that C<Class::Accessor::Lite> does is to set up the accessor functions for given property names through a blessed hashref.
  
  =head2 What happens when passing more than one arguments to the accessor?
  
  When the accessor built by Class::Accessor::Lite is given more than one arguments, a reference to the arguments will be saved as an arrayref.  This behaviour might not be necessary but is implemented as is to maintain compatibility with L<Class::Accessor::Fast>.
  
      my @data = (1, 2, 3);
      $obj->someproperty(@data);
  
      $obj->someproperty->[2]++; # $data[3] is incremented
  
  In general, you should pass an arrayref to set an arrayref to a property.
  
      my @data = (1, 2, 3);
      $obj->someproperty([ @data ]); # save a copy using arrayref
  
      $obj->someproper->[2]++; # @data is not modified
  
  =head1 SEE ALSO
  
  L<Class::Accessor>
  
  L<Class::Accessor::Lite>
  
  =head1 AUTHORS
  
  Copyright (C) 2008 - 2010 Kazuho Oku
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself, either Perl version 5.8.6 or, at your option, any later version of Perl 5 you may have available.
  
  =cut
  
CLASS_ACCESSOR_LITE

$fatpacked{"Const/Common.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONST_COMMON';
  package Const::Common;
  use 5.008005;
  use strict;
  use warnings;
  
  our $VERSION = "0.01";
  
  require Exporter;
  use Data::Lock;
  
  sub import {
      my $pkg   = caller;
      shift;
      my %constants = @_ == 1 ? %{ $_[0] } : @_;
  
      Data::Lock::dlock my $locked = \%constants;
      {
          no strict 'refs';
          ${ "$pkg\::_constants" } = $locked;
          for my $method (qw/const constants constant_names/) {
              *{ "$pkg\::$method" } = \&{ __PACKAGE__ . "::$method" };
          }
          push @{"$pkg\::ISA"}, ('Exporter');
          push @{"$pkg\::EXPORT"}, (keys %$locked);
      }
  
      require constant;
      @_ = ('constant', $locked);
      goto constant->can('import');
  }
  
  sub const {
      my ($pkg, $constant_name) = @_;
      $pkg->constants->{$constant_name};
  }
  
  sub constants {
      no strict 'refs';
      my $pkg = shift;
      ${ "$pkg\::_constants" };
  }
  
  sub constant_names {
      my $pkg = shift;
      sort keys %{ $pkg->constants };
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Const::Common - Yet another constant definition module
  
  =head1 SYNOPSIS
  
      package MyApp::Const;
      use Const::Common (
          BAR => 'BAZ',
          HASH => {
              HOGE => 'hoge',
          },
      );
      __END__
  
      use MyApp::Const;
      print BAR; # BAZ
      print HASH->{HOGE}; # hoge;
      HASH->{HOGE} = 10;  # ERROR!
  
  =head1 DESCRIPTION
  
  Const::Common is a module to define common constants in your project.
  
  =head1 METHOD
  
  =head2 C<< $hashref = $class->constants >>
  
  =head2 C<< $array = $class->constant_names >>
  
  =head2 C<< $value = $class->const($const_name) >>
  
  =head1 LICENSE
  
  Copyright (C) Songmu.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Songmu E<lt>y.songmu@gmail.comE<gt>
  
  =cut
CONST_COMMON

$fatpacked{"Data/Lock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_LOCK';
  package Data::Lock;
  use 5.008001;
  use warnings;
  use strict;
  our $VERSION = sprintf "%d.%02d", q$Revision: 1.3 $ =~ /(\d+)/g;
  
  use Attribute::Handlers;
  use Scalar::Util ();
  
  use base 'Exporter';
  our @EXPORT_OK = qw/dlock dunlock/;
  
  #my @builtin_types = 
  #    qw/SCALAR ARRAY HASH CODE REF GLOB LVALUE FORMAT IO VSTRING Regexp/;
  
  for my $locked ( 0, 1 ) {
      my $subname = $locked ? 'dlock' : 'dunlock';
      no strict 'refs';
      *{$subname} = sub {
          no warnings "uninitialized";
          return if $_[1] and Internals::SvREADONLY( $_[0]) == $locked;
          Internals::SvREADONLY( $_[0], $locked );
          return unless my $type = Scalar::Util::reftype( $_[0] );
          for (
                $type eq 'ARRAY' ? @{ $_[0] }
              : $type eq 'HASH'  ? values %{ $_[0] }
              : $type ne 'CODE'  ? ${ $_[0] }
              :                    ()
            )
          {
              &$subname($_, 1) if ref $_;
              Internals::SvREADONLY( $_, $locked );
          }
              $type eq 'ARRAY' ? Internals::SvREADONLY( @{ $_[0] }, $locked )
            : $type eq 'HASH'  ? Internals::SvREADONLY( %{ $_[0] }, $locked )
            : $type ne 'CODE'  ? Internals::SvREADONLY( ${ $_[0] }, $locked )
            :                    undef;
      };
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Data::Lock - makes variables (im)?mutable
  
  =head1 VERSION
  
  $Id: Lock.pm,v 1.3 2014/03/07 18:24:43 dankogai Exp dankogai $
  
  =head1 SYNOPSIS
  
     use Data::Lock qw/dlock dunlock/;
  
     dlock my $sv = $initial_value;
     dlock my $ar = [@values];
     dlock my $hr = { key => value, key => value, ... };
     dunlock $sv;
     dunlock $ar; dunlock \@av;
     dunlock $hr; dunlock \%hv;
  
  =head1 DESCRIPTION
  
  C<dlock> makes the specified variable immutable like L<Readonly>.
  Unlike L<Readonly> which implements immutability via C<tie>, C<dlock>
  makes use of the internal flag of perl SV so it imposes almost no
  penalty.
  
  Like L<Readonly>, C<dlock> locks not only the variable itself but also
  elements therein.
  
  As of verion 0.03, you can C<dlock> objects as well.  Below is an
  example constructor that returns an immutable object:
  
    sub new {
        my $pkg = shift;
        my $self = { @_ };
        bless $self, $pkg;
        dlock($self);
        $self;
    }
  
  Or consider using L<Moose>.
  
  =head1 EXPORT
  
  Like L<List::Util> and L<Scalar::Util>, functions are exported only
  explicitly. This module comes with C<dlock> and C<dunlock>.
  
    use Data::Lock;                   # nothing imported;
    use Data::Lock qw/dlock dunlock/; # imports dlock() and dunlock()
  
  =head1 FUNCTIONS
  
  =head2 dlock
  
    dlock($scalar);
  
  Locks $scalar and if $scalar is a reference, recursively locks referents.
  
  =head2 dunlock
  
  Does the opposite of C<dlock>.
  
  =head1 BENCHMARK
  
  Here I have benchmarked like this.
  
    1.  Create an immutable variable.
    2.  try to change it and see if it raises exception
    3.  make sure the value stored remains unchanged.
  
  See F<t/benchmark.pl> for details.
  
  =over 2
  
  =item Simple scalar
  
                  Rate  Readonly Attribute      glob     dlock
    Readonly   11987/s        --      -98%      -98%      -98%
    Attribute 484562/s     3943%        --       -1%       -4%
    glob      487239/s     3965%        1%        --       -3%
    dlock     504247/s     4107%        4%        3%        --
  
  =item Array with 1000 entries
  
                  Rate  Readonly     dlock Attribute
    Readonly   12396/s        --      -97%      -97%
    dlock     444703/s     3488%        --       -6%
    Attribute 475557/s     3736%        7%        --
  
  =item Hash with 1000 key/value pairs
  
                  Rate  Readonly     dlock Attribute
    Readonly   10855/s        --      -97%      -97%
    dlock     358867/s     3206%        --       -5%
    Attribute 377087/s     3374%        5%        --
  
  =back
  
  =head1 SEE ALSO
  
  L<Readonly>, L<perlguts>, L<perlapi>
  
  =head1 AUTHOR
  
  Dan Kogai, C<< <dankogai+gmail at gmail.com> >>
  
  =head1 BUGS
  
  Please report any bugs or feature requests to C<bug-data-lock at
  rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Data-Lock>.  I will
  be notified, and then you'll automatically be notified of progress on
  your bug as I make changes.
  
  =head1 SUPPORT
  
  You can find documentation for this module with the perldoc command.
  
      perldoc Data::Lock
  
  You can also look for information at:
  
  =over 4
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Data-Lock>
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/Data-Lock>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Data-Lock>
  
  =item * Search CPAN
  
  L<http://search.cpan.org/dist/Data-Lock>
  
  =back
  
  =head1 COPYRIGHT & LICENSE
  
  Copyright 2008-2013 Dan Kogai, all rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
DATA_LOCK

$fatpacked{"File/Zglob.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_ZGLOB';
  package File::Zglob;
  use strict;
  use warnings 'all', FATAL => 'recursion';
  use 5.008008;
  our $VERSION = '0.11';
  use base qw(Exporter);
  
  our @EXPORT = qw(zglob);
  
  use File::Basename;
  
  our $SEPCHAR    = '/';
  our $NOCASE = $^O =~ /^(?:MSWin32|VMS|os2|dos|riscos|MacOS|darwin)$/ ? 1 : 0;
  our $DIRFLAG = \"DIR?";
  our $DEEPFLAG = \"**";
  our $PARENTFLAG = \"..";
  our $DEBUG = 0;
  our $STRICT_LEADING_DOT    = 1;
  our $STRICT_WILDCARD_SLASH = 1;
  
  sub zglob {
      my ($pattern) = @_;
      #dbg("FOLDING: $pattern");
      # support ~tokuhirom/
      if ($^O eq 'MSWin32') {
          require Win32;
          $pattern =~ s!^(\~[^$SEPCHAR]*)!Win32::GetLongPathName([glob($1)]->[0])!e;
      } else {
          $pattern =~ s!^(\~[^$SEPCHAR]*)![glob($1)]->[0]!e;
      }
      my ($node, $matcher) = glob_prepare_pattern($pattern);
      # $node : \0 if absolute path, \1 if relative.
  
      #dbg("pattern: ", $node, $matcher);
      return _rec($node, $matcher, []);
  }
  
  sub dbg(@) {
      return unless $DEBUG;
      my ($pkg, $filename, $line, $sub) = caller(1);
      my $i = 0;
      while (caller($i++)) { 1 }
      my $msg;
      $msg .= ('-' x ($i-5));
      $msg .= " [$sub] ";
      for (@_) {
          $msg .= ' ';
          if (not defined $_) {
              $msg .= '<<undef>>';
          } elsif (ref $_) {
              require Data::Dumper;
              local $Data::Dumper::Terse = 1;
              local $Data::Dumper::Indent = 0;
              $msg .= Data::Dumper::Dumper($_);
          } else {
              $msg .= $_;
          }
      }
      $msg .= " at $filename line $line\n";
      print($msg);
  }
  
  sub _recstar {
      my ($node, $matcher) = @_;
      #dbg("recstar: ", $node, $matcher, $seed);
      return (
          _rec( $node, $matcher ),
          (
              map { _recstar( $_, $matcher ) }
                glob_fs_fold( $node, qr{^[^.].*$}, 1 )
          )
      );
  }
  
  sub _rec {
      my ($node, $matcher) = @_;
      # $matcher: ArrayRef[Any]
  
      my ($current, @rest) = @{$matcher};
      if (!defined $current) {
          #dbg("FINISHED");
          return ();
      } elsif (ref($current) eq 'SCALAR' && $current == $DEEPFLAG) {
          #dbg("** mode");
          return _recstar($node, \@rest);
      } elsif (ref($current) eq 'SCALAR' && $current == $PARENTFLAG) {
          if (ref($node) eq 'SCALAR' && $$node eq 1) { #t
              die "You cannot get a parent directory of root dir.";
          } elsif (ref($node) eq 'SCALAR' && $$node eq 0) { #f
              return _rec("..", \@rest);
          } else {
              return _rec("$node$SEPCHAR..", \@rest);
          }
      } elsif (@rest == 0) {
          #dbg("file name");
          # (folder proc seed node (car matcher) #f)
          return glob_fs_fold($node, $current, 0);
      } else {
          return glob_fs_fold($node, $current, 1, \@rest);
      }
  }
  
  
  # /^home$/ のような固定の文字列の場合に高速化をはかるための最適化予定地なので、とりあえず undef をかえしておいても問題がない
  sub fixed_regexp_p {
      return undef;
      die "TBI"
  }
  
  # returns arrayref of seeds.
  sub glob_fs_fold {
      my ($node, $regexp, $non_leaf_p, $rest) = @_;
  
      my $prefix = do {
          if (ref $node eq 'SCALAR') {
              if ($$node eq 1) { #t
                  $SEPCHAR
              } elsif ($$node eq '0') { #f
                  '';
              } else {
                  die "FATAL";
              }
          } elsif ($node !~ m{/$}) {
              $node . '/';
          } else {
              $node;
          }
      };
      dbg("prefix: $prefix");
      dbg("regxp: ", $regexp);
      if ($^O eq 'MSWin32' && ref $regexp eq 'SCALAR' && $$regexp =~ /^[a-zA-Z]\:$/) {
          return _rec($$regexp . '/', $rest);
      }
      if (ref $regexp eq 'SCALAR' && $regexp == $DIRFLAG) {
          if ($rest) {
              return _rec($prefix, $rest);
          } else {
              return ($prefix);
          }
  #   } elsif (my $string_portion = fixed_regexp_p($regexp)) { # /^path$/
  #       die "TBI";
  #       my $full = $prefix . $string_portion;
  #       if (-e $full && (!$non_leaf_p || -d $full)) {
  #           $proc->($full, $seed);
  #       } else {
  #           $proc;
  #       }
      } else { # normal regexp
          #dbg("normal regexp");
          my $dir = do {
              if (ref($node) eq 'SCALAR' && $$node eq 1) {
                  $SEPCHAR
              } elsif (ref($node) eq 'SCALAR' && $$node eq 0) {
                  '.';
              } else {
                  $node;
              }
          };
          #dbg("dir: $dir");
          opendir my $dirh, $dir or do {
              #dbg("cannot open dir: $dir: $!");
              return ();
          };
          my @ret;
          while (defined(my $child = readdir($dirh))) {
              next if $child eq '.' or $child eq '..';
              my $full;
              #dbg("non-leaf: ", $non_leaf_p);
              if (($child =~ $regexp) && ($full = $prefix . $child) && (!$non_leaf_p || -d $full)) {
                  #dbg("matched: ", $regexp, $child, $full);
                  if ($rest) {
                      push @ret, _rec($full, $rest);
                  } else {
                      push @ret, $full;
                  }
            # } else {
                  #dbg("Don't match: $child");
              }
          }
          return @ret;
      }
  }
  
  sub glob_prepare_pattern {
      my ($pattern) = @_;
      my @path = split $SEPCHAR, $pattern;
  
      my $is_absolute = $path[0] eq '' ? 1 : 0;
      if ($is_absolute) {
          shift @path;
      }
      if ($^O eq 'MSWin32' && $path[0] =~ /^[a-zA-Z]\:$/) {
          $is_absolute = 1;
      }
  
      @path = map {
          if ($_ eq '**') {
              $DEEPFLAG
          } elsif ($_ eq '') {
              $DIRFLAG
          } elsif ($_ eq '.') {
              ()
          } elsif ($_ eq '..') {
              $PARENTFLAG
          } elsif ($^O eq 'MSWin32' && $_ =~ '^[a-zA-Z]\:$') {
              \$_
          } else {
              glob_to_regex($_) # TODO: replace with original implementation?
          }
      } @path;
  
      return ( \$is_absolute, \@path );
  }
  
  # this is not a private function. '**' was handled at glob_prepare_pattern() function.
  sub glob_to_regex {
      my $glob = shift;
      my $regex = glob_to_regex_string($glob);
      return $NOCASE ? qr/^$regex$/i : qr/^$regex$/;
  }
  
  sub glob_to_regex_string {
      my $glob = shift;
      my ($regex, $in_curlies, $escaping);
      local $_;
      my $first_byte = 1;
      for ($glob =~ m/(.)/gs) {
          if ($first_byte) {
              if ($STRICT_LEADING_DOT) {
                  $regex .= '(?=[^\.])' unless $_ eq '.';
              }
              $first_byte = 0;
          }
          if ($_ eq '/') {
              $first_byte = 1;
          }
          if ($_ eq '.' || $_ eq '(' || $_ eq ')' || $_ eq '|' ||
              $_ eq '+' || $_ eq '^' || $_ eq '$' || $_ eq '@' || $_ eq '%' ) {
              $regex .= "\\$_";
          }
          elsif ($_ eq '*') {
              $regex .= $escaping ? "\\*" :
                $STRICT_WILDCARD_SLASH ? "[^/]*" : ".*";
          }
          elsif ($_ eq '?') {
              $regex .= $escaping ? "\\?" :
                $STRICT_WILDCARD_SLASH ? "[^/]" : ".";
          }
          elsif ($_ eq '{') {
              $regex .= $escaping ? "\\{" : "(";
              ++$in_curlies unless $escaping;
          }
          elsif ($_ eq '}' && $in_curlies) {
              $regex .= $escaping ? "}" : ")";
              --$in_curlies unless $escaping;
          }
          elsif ($_ eq ',' && $in_curlies) {
              $regex .= $escaping ? "," : "|";
          }
          elsif ($_ eq "\\") {
              if ($escaping) {
                  $regex .= "\\\\";
                  $escaping = 0;
              }
              else {
                  $escaping = 1;
              }
              next;
          }
          else {
              $regex .= $_;
              $escaping = 0;
          }
          $escaping = 0;
      }
  
      return $regex;
  }
  
  1;
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  File::Zglob - Extended globs.
  
  =head1 SYNOPSIS
  
      use File::Zglob;
  
      my @files = zglob('**/*.{pm,pl}');
  
  =head1 DESCRIPTION
  
  B<WARNINGS: THIS IS ALPHA VERSION. API MAY CHANGE WITHOUT NOTICE>
  
  Provides a traditional Unix glob(3) functionality; returns a list of pathnames that matches the given pattern.
  
  File::Zglob provides extended glob. It supports C<< **/*.pm >> form.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item zglob($pattern) # => list of matched files
  
      my @files = zglob('**/*.[ch]');
  
  Unlike shell's glob, if there's no matching pathnames, () is returned.
  
  =back
  
  =head1 Special chars
  
  A glob pattern also consists of components and separator characters. In a component, following characters/syntax have special meanings.
  
  =over 4
  
  =item C<< * >>
  
  When it appears at the beginning of a component, it matches zero or more characters except a period (.). And it won't match if the component of the input string begins with a period.
  
  Otherwise, it matches zero or more sequence of any characters.
  
  =item C<< ** >>
  
  If a component is just **, it matches zero or more number of components that match *. For example, src/**/*.h matches all of the following patterns.
  
      src/*.h
      src/*/*.h
      src/*/*/*.h
      src/*/*/*/*.h
      ...
  
  =item C<< ? >>
  
  When it appears at the beginning of a component, it matches a character except a period (.). Otherwise, it matches any single character.
  
  =item C<< [chars] >>
  
  Specifies a character set. Matches any one of the set. The syntax of chars is the same as perl's character set syntax. 
  
  =item C<< {pm,pl} >>
  
  There is alternation.
  
  "example.{foo,bar,baz}" matches "example.foo", "example.bar", and "example.baz"
  
  =back
  
  =head1 zglob and deep recursion
  
  C<< **/* >> form makes deep recursion by soft link. zglob throw exception if it's deep recursion.
  
  =head1 PORTABILITY
  
  =over 4
  
  =item Win32
  
  Zglob supports Win32. zglob() only uses '/' as a path separator. Since zglob() accepts non-utf8 strings. CP932 contains '\' character as a second byte of multibyte chars.
  
  =back
  
  =head1 LIMITATIONS
  
  =over 4
  
  =item File order is not compatible with shells.
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno E<lt>tokuhirom AAJKLFJEF GMAIL COME<gt>
  
  =head1 THANKS TO
  
  Most code was translated from gauche's fileutil.scm.
  
  glob_to_regex function is taken from L<Text::Glob>.
  
  =head1 SEE ALSO
  
  L<File::DosGlob>, L<Text::Glob>, gauche's fileutil.scm
  
  =head1 LICENSE
  
  Copyright (C) Tokuhiro Matsuno
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
FILE_ZGLOB

$fatpacked{"Test/Requires/Scanner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_REQUIRES_SCANNER';
  package Test::Requires::Scanner;
  use 5.008001;
  use strict;
  use warnings;
  
  our $VERSION = "0.01";
  
  use Compiler::Lexer;
  
  use Test::Requires::Scanner::Constants;
  use Test::Requires::Scanner::Walker;
  use Test::Requires::Scanner::Result;
  
  sub scan_file {
      my ($class, $file) = @_;
  
      my $content = do {
          local $/;
          open my $fh, '<', $file or die $!;
          <$fh>;
      };
  
     $class->scan_string($content);
  }
  
  sub scan_files {
      my ($class, @files) = @_;
  
      my $result = Test::Requires::Scanner::Result->new;
  
      for my $file (@files) {
          my $ret = Test::Requires::Scanner->scan_file($file);
          $result->save_module($_, $ret->{$_}) for keys %$ret;
      }
  
      $result->modules;
  }
  
  sub scan_string {
      my ($class, $string) = @_;
  
      my $lexer = Compiler::Lexer->new;
      my $tokens = $lexer->tokenize($string);
  
      $class->scan_tokens($tokens);
  }
  
  sub scan_tokens {
      my ($class, $tokens) = @_;
  
      my $walker = Test::Requires::Scanner::Walker->new;
      my $result = Test::Requires::Scanner::Result->new;
      for my $token (@$tokens) {
          my $token_type = $token->{type};
  
          # For use statement
          if ($token_type == USE_DECL) {
              $walker->is_in_usedecl(1);
              $walker->is_prev_module_name(1);
              next;
          }
          if ($walker->is_in_usedecl) {
              # e.g.
              #   use Foo;
              if (
                  $token_type == USED_NAME ||  # e.g. use Foo
                  $token_type == SEMI_COLON    # End of declare of use statement
              ) {
                  $walker->reset;
                  next;
              }
  
              # e.g.
              #   use Foo::Bar;
              if ( ($token_type == NAMESPACE || $token_type == NAMESPACE_RESOLVER) && $walker->is_prev_module_name) {
                  $walker->{module_name} .= $token->{data};
                  if ($walker->module_name =~ /^Test(?:\:\:(?:Requires)?)?$/) {
                      $walker->is_prev_module_name(1);
                      $walker->is_in_test_requires($walker->module_name eq 'Test::Requires');
                  }
                  else {
                      $walker->reset;
                  }
                  next;
              }
  
              if (!$walker->module_name && !$walker->does_garbage_exist && _looks_like_version($token_type)) {
                  # For perl version
                  # e.g.
                  #   use 5.012;
                  $walker->reset;
                  next;
              }
  
              # Section for Test::Requires
              if ($walker->is_in_test_requires) {
                  $walker->is_prev_module_name(0);
  
                  # For qw() notation
                  # e.g.
                  #   use Test::Requires qw/Foo Bar/;
                  if ($token_type == REG_LIST) {
                      $walker->is_in_reglist(1);
                  }
                  elsif ($walker->is_in_reglist) {
                      # skip regdelim
                      if ($token_type == REG_EXP) {
                          for my $_module_name (split /\s+/, $token->{data}) {
                              $result->save_module($_module_name);
                          }
                          $walker->is_in_reglist(0);
                      }
                  }
  
                  # For simply list
                  # e.g.
                  #   use Test::Requires ('Foo', 'Bar');
                  elsif ($token_type == LEFT_PAREN) {
                      $walker->is_in_list(1);
                  }
                  elsif ($token_type == RIGHT_PAREN) {
                      $walker->is_in_list(0);
                  }
                  elsif ($walker->is_in_list) {
                      if ($token_type == STRING || $token_type == RAW_STRING) {
                          $result->save_module($token->{data});
                      }
                  }
  
                  # For braced list
                  # e.g.
                  #   use Test::Requires {'Foo' => 1, 'Bar' => 2};
                  elsif ($token_type == LEFT_BRACE ) {
                      $walker->is_in_hash(1);
                      $walker->hash_count(0);
                  }
                  elsif ($token_type == RIGHT_BRACE ) {
                      $walker->is_in_hash(0);
                  }
                  elsif ($walker->is_in_hash) {
                      if ( _is_string($token_type) || $token_type == KEY || _looks_like_version($token_type) ) {
                          $walker->{hash_count}++;
  
                          if ($walker->hash_count % 2) {
                              $walker->stashed_module($token->{data});
                          }
                          else {
                              # store version
                              $result->save_module($walker->stashed_module, $token->{data});
                              $walker->stashed_module('');
                          }
                      }
                  }
  
                  # For string
                  # e.g.
                  #   use Test::Requires "Foo"
                  elsif (_is_string($token_type)) {
                      $result->save_module($token->{data});
                  }
                  next;
              }
  
              if ($token_type != WHITESPACE) {
                  $walker->does_garbage_exist(1);
                  $walker->is_prev_module_name(0);
              }
              next;
          }
      }
  
      $result->modules;
  }
  
  
  sub _is_string {
      my $token_type = shift;
      $token_type == STRING || $token_type == RAW_STRING;
  }
  
  sub _looks_like_version {
      my $token_type = shift;
      $token_type == DOUBLE || $token_type == INT || $token_type == VERSION_STRING;
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Test::Requires::Scanner - retrieve modules specified by Test::Requires
  
  =head1 SYNOPSIS
  
      use Test::Requires::Scanner;
      my $modules2version_hashref = Test::Requires::Scanner->scan_files('t/hoge.t', 't/fuga.t');
  
  =head1 DESCRIPTION
  
  App::TestRequires::Scanner is to retrieve modules specified by L<Test::Requires> in
  test files. It is useful for CPAN module maintainer.
  
  =head2 METHODS
  
  =over
  
  =item C<< $hashref = Test::Requires::Scanner->scan_string($str) >>
  
  =item C<< $hashref = Test::Requires::Scanner->scan_file($file) >>
  
  =item C<< $hashref = Test::Requires::Scanner->scan_files(@files) >>
  
  A key of C<$hashref> is module name and a value is version.
  
  =back
  
  =head1 LICENSE
  
  Copyright (C) Songmu.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Songmu E<lt>y.songmu@gmail.comE<gt>
  
  =cut
  
TEST_REQUIRES_SCANNER

$fatpacked{"Test/Requires/Scanner/CLI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_REQUIRES_SCANNER_CLI';
  package Test::Requires::Scanner::CLI;
  use strict;
  use warnings;
  use utf8;
  
  use Test::Requires::Scanner;
  
  use File::Zglob;
  
  sub run {
      my @argv = @_;
  
      my @files = zglob('{t,xt}/**/*.t');
      my $result = Test::Requires::Scanner->scan_files(@files);
      print "$_\n" for sort keys %$result;
  }
  
  1;
TEST_REQUIRES_SCANNER_CLI

$fatpacked{"Test/Requires/Scanner/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_REQUIRES_SCANNER_CONSTANTS';
  package Test::Requires::Scanner::Constants;
  use strict;
  use warnings;
  
  use Compiler::Lexer::Constants;
  
  use Const::Common (
      NAMESPACE_RESOLVER => Compiler::Lexer::TokenType::T_NamespaceResolver,
      NAMESPACE          => Compiler::Lexer::TokenType::T_Namespace,
      SEMI_COLON         => Compiler::Lexer::TokenType::T_SemiColon,
      USE_DECL           => Compiler::Lexer::TokenType::T_UseDecl,
      USED_NAME          => Compiler::Lexer::TokenType::T_UsedName,
      REG_LIST           => Compiler::Lexer::TokenType::T_RegList,
      REG_EXP            => Compiler::Lexer::TokenType::T_RegExp,
      STRING             => Compiler::Lexer::TokenType::T_String,
      RAW_STRING         => Compiler::Lexer::TokenType::T_RawString,
      VERSION_STRING     => Compiler::Lexer::TokenType::T_VersionString,
      INT                => Compiler::Lexer::TokenType::T_Int,
      DOUBLE             => Compiler::Lexer::TokenType::T_Double,
      KEY                => Compiler::Lexer::TokenType::T_Key,
      WHITESPACE         => Compiler::Lexer::TokenType::T_WhiteSpace,
  
      LEFT_PAREN   => Compiler::Lexer::TokenType::T_LeftParenthesis,
      RIGHT_PAREN  => Compiler::Lexer::TokenType::T_RightParenthesis,
      LEFT_BRACE   => Compiler::Lexer::TokenType::T_LeftBrace,
      RIGHT_BRACE  => Compiler::Lexer::TokenType::T_RightBrace,
  );
  
  1;
TEST_REQUIRES_SCANNER_CONSTANTS

$fatpacked{"Test/Requires/Scanner/Result.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_REQUIRES_SCANNER_RESULT';
  package Test::Requires::Scanner::Result;
  use strict;
  use warnings;
  
  use version 0.77 ();
  
  use Class::Accessor::Lite (
      new => 1,
  );
  
  sub modules {
      shift->{modules} ||= {};
  }
  
  sub save_module {
      my ($self, $module, $version) = @_;
  
      if (exists $self->modules->{$module}) {
          return unless $version;
  
          my $stored_version = $self->modules->{$module};
  
          if (
              !$stored_version ||
              version->parse($version) > version->parse($stored_version)
          ) {
              $self->modules->{$module} = $version;
          }
      }
      else {
          $self->modules->{$module} = $version;
      }
  }
  
  1;
TEST_REQUIRES_SCANNER_RESULT

$fatpacked{"Test/Requires/Scanner/Walker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_REQUIRES_SCANNER_WALKER';
  package Test::Requires::Scanner::Walker;
  use strict;
  use warnings;
  
  use Class::Accessor::Lite (
      new => 1,
      rw  => [qw/
          module_name
          is_in_usedecl
          is_in_test_requires
          is_in_reglist
          is_prev_module_name
          is_in_list
          is_in_hash
          does_garbage_exist
          hash_count
          stashed_module
      /],
  );
  
  sub reset {
      my $self = shift;
  
      $self->module_name('');
      $self->stashed_module('');
  
      for my $accessor (qw/
          is_in_usedecl
          is_in_test_requires
          is_in_reglist
          is_prev_module_name
          is_in_list
          is_in_hash
          does_garbage_exist
          hash_count
      /) {
          $self->$accessor(0);
      }
  }
  
  1;
TEST_REQUIRES_SCANNER_WALKER

$fatpacked{"x86_64-linux/Compiler/Lexer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_COMPILER_LEXER';
  package Compiler::Lexer;
  use strict;
  use warnings;
  use 5.008_001;
  use File::Find;
  use Compiler::Lexer::Token;
  use Compiler::Lexer::Constants;
  
  require Exporter;
  our @ISA = qw(Exporter);
  our %EXPORT_TAGS = ( 'all' => [ qw() ] );
  our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );
  our @EXPORT = qw();
  our $VERSION = '0.22';
  require XSLoader;
  XSLoader::load(__PACKAGE__, $VERSION);
  
  my $inc;
  
  sub new {
      my ($class, $args) = @_;
      my $options = +{};
      if (ref $args eq 'HASH') {
          $options = $args;
      } elsif (ref $args eq 'SCALAR') {
          $options->{filename} = $args;
      }
      $options->{filename} ||= '-';
      $options->{verbose}  ||= 0;
      return $class->_new($options);
  }
  
  sub set_library_path {
      my ($self, $_inc) = @_;
      $inc = $_inc;
  }
  
  sub load_module {
      my ($self, $name) = @_;
      $name =~ s|::|/|g;
      my @include_path = ($inc) ? @$inc : @INC;
      my $module_path = '';
      foreach my $path (@include_path) {
          next unless -e $path;
          find(sub {
              return if ($module_path);
              my $absolute_path = $File::Find::name;
              if ($absolute_path =~ "$name.pm") {
                  $module_path = $absolute_path;
              }
          }, $path);
          last if ($module_path);
      }
      return undef unless $module_path;
      open my $fh, '<', $module_path;
      return do { local $/; <$fh> };
  }
  
  sub recursive_tokenize {
      my ($self, $script) = @_;
      my %results;
      $self->__recursive_tokenize(\%results, $script);
      $results{main} = $self->tokenize($script);
      return \%results;
  }
  
  sub __recursive_tokenize {
      my ($self, $results, $script) = @_;
      my $modules = $self->get_used_modules($script);
      foreach my $module (@$modules) {
          my $name = $module->{name};
          next if (defined $results->{$name});
          $results->{$name} ||= [];
          my $code = $self->load_module($name);
          next unless ($code);
          $results->{$name} = $self->tokenize($code);
          $self->__recursive_tokenize($results, $code);
      }
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Compiler::Lexer - Lexical Analyzer for Perl5
  
  =head1 SYNOPSIS
  
    use Compiler::Lexer;
    use Data::Dumper;
  
    my $filename = $ARGV[0];
    open my $fh, '<', $filename or die "Cannot open $filename: $!";
    my $script = do { local $/; <$fh> };
  
    my $lexer = Compiler::Lexer->new($filename);
    my $tokens = $lexer->tokenize($script);
    print Dumper $tokens;
  
    my $modules = $lexer->get_used_modules($script);
    print Dumper $modules;
  
  =head1 METHODS
  
  =over 4
  
  =item my $lexer = Compiler::Lexer->new($options);
  
  create new instance.
  You can create object from $options in hash reference.
  
  B<options list>
  
  =over 4
  
  =item filename
  
  =item verbose : includes token of Pod, Comment and WhiteSpace
  
  =back
  
  =item $lexer->tokenize($script);
  
  get token objects includes parameter of 'name' or 'type' or 'line' and so on.
  This method requires perl source code in string.
  
  =item $lexer->set_library_path(['path1', 'path2' ...])
  
  set libraries path for reading recursively. Default paths are @INC.
  
  =item $lexer->recursive_tokenize($script)
  
  get hash reference like { 'module_nameA' => [], 'module_nameB' => [] ... }.
  This method requires per source code in string.
  
  =item $lexer->get_used_modules($script);
  
  get names of used module.
  This method requires perl source code in string.
  
  =back
  
  =head1 AUTHOR
  
  Masaaki Goshima (goccy) E<lt>goccy(at)cpan.orgE<gt>
  
  =head1 CONTRIBUTORS
  
  tokuhirom: Tokuhiro Matsuno
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright (c) 2013, Masaaki Goshima (goccy). All rights reserved.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_COMPILER_LEXER

$fatpacked{"x86_64-linux/Compiler/Lexer/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_COMPILER_LEXER_CONSTANTS';
  use strict;
  use warnings;
  
  package Compiler::Lexer::TokenType;
  use constant {
      T_Return => 0,
      T_Add => 1,
      T_Sub => 2,
      T_Mul => 3,
      T_Div => 4,
      T_Mod => 5,
      T_ThreeTermOperator => 6,
      T_Greater => 7,
      T_Less => 8,
      T_StringAdd => 9,
      T_Ref => 10,
      T_Glob => 11,
      T_BitNot => 12,
      T_BitOr => 13,
      T_AlphabetOr => 14,
      T_BitAnd => 15,
      T_AlphabetAnd => 16,
      T_BitXOr => 17,
      T_AlphabetXOr => 18,
      T_StringMul => 19,
      T_AddEqual => 20,
      T_SubEqual => 21,
      T_MulEqual => 22,
      T_DivEqual => 23,
      T_ModEqual => 24,
      T_StringAddEqual => 25,
      T_LeftShiftEqual => 26,
      T_RightShiftEqual => 27,
      T_StringMulEqual => 28,
      T_GreaterEqual => 29,
      T_LessEqual => 30,
      T_EqualEqual => 31,
      T_Diamond => 32,
      T_Compare => 33,
      T_PolymorphicCompare => 34,
      T_RegOK => 35,
      T_RegNot => 36,
      T_NotEqual => 37,
      T_StringLess => 38,
      T_StringLessEqual => 39,
      T_StringGreater => 40,
      T_StringGreaterEqual => 41,
      T_StringEqual => 42,
      T_StringNotEqual => 43,
      T_StringCompare => 44,
      T_Inc => 45,
      T_Dec => 46,
      T_Exp => 47,
      T_PowerEqual => 48,
      T_DefaultEqual => 49,
      T_LeftShift => 50,
      T_RightShift => 51,
      T_And => 52,
      T_Or => 53,
      T_AndBitEqual => 54,
      T_OrBitEqual => 55,
      T_NotBitEqual => 56,
      T_OrEqual => 57,
      T_AndEqual => 58,
      T_Slice => 59,
      T_DefaultOperator => 60,
      T_ToDo => 61,
      T_VarDecl => 62,
      T_FunctionDecl => 63,
      T_Method => 64,
      T_Assign => 65,
      T_ArraySize => 66,
      T_Is => 67,
      T_Not => 68,
      T_AlphabetNot => 69,
      T_BuiltinFunc => 70,
      T_RequireDecl => 71,
      T_Import => 72,
      T_SpecificKeyword => 73,
      T_DataWord => 74,
      T_ModWord => 75,
      T_AUTOLOAD => 76,
      T_CORE => 77,
      T_DESTROY => 78,
      T_STDIN => 79,
      T_STDOUT => 80,
      T_STDERR => 81,
      T_Redo => 82,
      T_Next => 83,
      T_Last => 84,
      T_Goto => 85,
      T_Continue => 86,
      T_Do => 87,
      T_Break => 88,
      T_Handle => 89,
      T_LocalDecl => 90,
      T_OurDecl => 91,
      T_StateDecl => 92,
      T_UseDecl => 93,
      T_UsedName => 94,
      T_RequiredName => 95,
      T_IfStmt => 96,
      T_ElseStmt => 97,
      T_ElsifStmt => 98,
      T_UnlessStmt => 99,
      T_UntilStmt => 100,
      T_WhenStmt => 101,
      T_GivenStmt => 102,
      T_DefaultStmt => 103,
      T_Comma => 104,
      T_Colon => 105,
      T_SemiColon => 106,
      T_LeftParenthesis => 107,
      T_RightParenthesis => 108,
      T_LeftBrace => 109,
      T_RightBrace => 110,
      T_LeftBracket => 111,
      T_RightBracket => 112,
      T_ArrayDereference => 113,
      T_HashDereference => 114,
      T_ScalarDereference => 115,
      T_CodeDereference => 116,
      T_ShortScalarDereference => 117,
      T_ShortArrayDereference => 118,
      T_ShortHashDereference => 119,
      T_ShortCodeDereference => 120,
      T_ArraySizeDereference => 121,
      T_Key => 122,
      T_BareWord => 123,
      T_Arrow => 124,
      T_Pointer => 125,
      T_NamespaceResolver => 126,
      T_Namespace => 127,
      T_Package => 128,
      T_Class => 129,
      T_CallDecl => 130,
      T_CodeRef => 131,
      T_WhileStmt => 132,
      T_ForStmt => 133,
      T_ForeachStmt => 134,
      T_Annotation => 135,
      T_ArgumentArray => 136,
      T_SpecificValue => 137,
      T_ConstValue => 138,
      T_ProgramArgument => 139,
      T_LibraryDirectories => 140,
      T_Environment => 141,
      T_Include => 142,
      T_Signal => 143,
      T_RegOpt => 144,
      T_RegQuote => 145,
      T_RegDoubleQuote => 146,
      T_RegList => 147,
      T_RegExec => 148,
      T_RegDecl => 149,
      T_RegMatch => 150,
      T_RegDelim => 151,
      T_HandleDelim => 152,
      T_RegMiddleDelim => 153,
      T_RegAllReplace => 154,
      T_RegReplace => 155,
      T_RegReplaceFrom => 156,
      T_RegReplaceTo => 157,
      T_FieldDecl => 158,
      T_TypeRef => 159,
      T_LabelRef => 160,
      T_LocalVarDecl => 161,
      T_GlobalVarDecl => 162,
      T_MultiLocalVarDecl => 163,
      T_MultiGlobalVarDecl => 164,
      T_Prototype => 165,
      T_Var => 166,
      T_CodeVar => 167,
      T_ArrayVar => 168,
      T_HashVar => 169,
      T_Int => 170,
      T_Double => 171,
      T_String => 172,
      T_RawString => 173,
      T_ExecString => 174,
      T_VersionString => 175,
      T_HereDocumentTag => 176,
      T_HereDocumentRawTag => 177,
      T_HereDocumentExecTag => 178,
      T_HereDocumentBareTag => 179,
      T_RawHereDocument => 180,
      T_HereDocument => 181,
      T_HereDocumentEnd => 182,
      T_FormatDecl => 183,
      T_Format => 184,
      T_FormatEnd => 185,
      T_Object => 186,
      T_RegExp => 187,
      T_Array => 188,
      T_Hash => 189,
      T_Operator => 190,
      T_LocalVar => 191,
      T_LocalArrayVar => 192,
      T_LocalHashVar => 193,
      T_GlobalVar => 194,
      T_GlobalArrayVar => 195,
      T_GlobalHashVar => 196,
      T_ArrayRef => 197,
      T_HashRef => 198,
      T_ArrayAt => 199,
      T_HashAt => 200,
      T_ArraySet => 201,
      T_HashSet => 202,
      T_Function => 203,
      T_Call => 204,
      T_Argument => 205,
      T_List => 206,
      T_Default => 207,
      T_Pod => 208,
      T_Comment => 209,
      T_WhiteSpace => 210,
      T_Undefined => 211,
      T_PostDeref => 212,
      T_PostDerefStar => 213,
      T_PostDerefArraySliceOpenBracket => 214,
      T_PostDerefArraySliceCloseBracket => 215,
      T_PostDerefHashSliceOpenBrace => 216,
      T_PostDerefHashSliceCloseBrace => 217,
      T_PostDerefCodeOpenParen => 218,
      T_PostDerefCodeCloseParen => 219
  };
  
  package Compiler::Lexer::SyntaxType;
  use constant {
      T_Value => 0,
      T_Term => 1,
      T_Expr => 2,
      T_Stmt => 3,
      T_BlockStmt => 4
  };
  
  package Compiler::Lexer::Kind;
  use constant {
      T_Return => 0,
      T_Operator => 1,
      T_Assign => 2,
      T_Decl => 3,
      T_Function => 4,
      T_SingleTerm => 5,
      T_Import => 6,
      T_SpecificKeyword => 7,
      T_DataWord => 8,
      T_ModWord => 9,
      T_AUTOLOAD => 10,
      T_CORE => 11,
      T_DESTROY => 12,
      T_Handle => 13,
      T_Control => 14,
      T_Do => 15,
      T_Module => 16,
      T_Stmt => 17,
      T_DefaultStmt => 18,
      T_Comma => 19,
      T_Colon => 20,
      T_StmtEnd => 21,
      T_Symbol => 22,
      T_Modifier => 23,
      T_Term => 24,
      T_Namespace => 25,
      T_Package => 26,
      T_Class => 27,
      T_Annotation => 28,
      T_RegOpt => 29,
      T_RegPrefix => 30,
      T_RegReplacePrefix => 31,
      T_Ref => 32,
      T_Get => 33,
      T_Set => 34,
      T_Verbose => 35,
      T_Undefined => 36
  };
  
  1;
X86_64-LINUX_COMPILER_LEXER_CONSTANTS

$fatpacked{"x86_64-linux/Compiler/Lexer/Token.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_COMPILER_LEXER_TOKEN';
  package Compiler::Lexer::Token;
  use strict;
  use warnings;
  
  my $FIELDS = [qw/
      stype
      type
      kind
      line
      name
      data
      has_warnings
  /];
  
  {
      no strict 'refs';
      foreach my $field (@$FIELDS) {
          *{__PACKAGE__ . '::' . $field} = sub {
              my ($self, $value) = @_;
              return $self->{$field} unless defined $value;
              $self->{$field} = $value;
          };
      }
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =for stopwords stype
  
  =head1 NAME
  
  Compiler::Lexer::Token
  
  =head1 SYNOPSIS
  
  Compiler::Lexer::Token includes the following members.
  
  =over
  
  =item stype
  
  constant of Compiler::Lexer::SyntaxType
  
  =item type
  
  constant of Compiler::Lexer::TokenType
  
  =item kind
  
  constant of Compiler::Lexer::Kind
  
  =item name
  
  name of Compiler::Lexer::TokenType
  
  =item data
  
  raw data
  
  =item has_warnings
  
  flag of whether unknown keyword or not
  
  =back
  
  =head1 METHODS
  
  support simple get/set accessors like Class::Accessor::Fast
  
  example:
  
    my $type = $token->type;                            # get accessor
    $token->type(Compiler::Lexer::TokenType::T_RegExp); # set accessor
  
  =head1 AUTHOR
  
  Masaaki Goshima (goccy) E<lt>goccy(at)cpan.orgE<gt>
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright (c) 2013, Masaaki Goshima (goccy). All rights reserved.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_COMPILER_LEXER_TOKEN

$fatpacked{"x86_64-linux/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle uniq uniqnum uniqstr
    head tail pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.50";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first
  
        max maxstr min minstr product sum sum0
  
        pairs unpairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniq uniqnum uniqstr
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  Note also that multiple IEEE C<NaN> values are treated as duplicates of
  each other, regardless of any differences in their payloads, and despite
  the fact that C<< 0+'NaN' == 0+'NaN' >> yields false.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head2 head
  
      my @values = head $size, @list;
  
  Returns the first C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the last C<$size> elements from C<@list>.
  
      @result = head 2, qw( foo bar baz );
      # foo, bar
  
      @result = head -2, qw( foo bar baz );
      # foo
  
  =head2 tail
  
      my @values = tail $size, @list;
  
  Returns the last C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the first C<$size> elements from C<@list>.
  
      @result = tail 2, qw( foo bar baz );
      # bar, baz
  
      @result = tail -2, qw( foo bar baz );
      # baz
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
X86_64-LINUX_LIST_UTIL

$fatpacked{"x86_64-linux/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.50";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_LIST_UTIL_XS

$fatpacked{"x86_64-linux/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.50";
  $VERSION   = eval $VERSION;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be a dual-valued variable, it is
  actually implemented as a magical variable inside the interpreter:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use L</isweak> or L</weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_SCALAR_UTIL

$fatpacked{"x86_64-linux/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.50";
  $VERSION   = eval $VERSION;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If a name has been set using L</set_subname>, this name will
  be returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.*?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
X86_64-LINUX_SUB_UTIL

$fatpacked{"x86_64-linux/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_VERSION';
  #!perl -w
  package version;
  
  use 5.006002;
  use strict;
  use warnings::register;
  if ($] >= 5.015) {
      warnings::register_categories(qw/version/);
  }
  
  our $VERSION = 0.9924;
  our $CLASS = 'version';
  our (@ISA, $STRICT, $LAX);
  
  # !!!!Delete this next block completely when adding to Perl core!!!!
  {
      local $SIG{'__DIE__'};
      eval "use version::vxs $VERSION";
      if ( $@ ) { # don't have the XS version installed
  	eval "use version::vpp $VERSION"; # don't tempt fate
  	die "$@" if ( $@ );
  	push @ISA, "version::vpp";
  	local $^W;
  	*version::qv = \&version::vpp::qv;
  	*version::declare = \&version::vpp::declare;
  	*version::_VERSION = \&version::vpp::_VERSION;
  	*version::vcmp = \&version::vpp::vcmp;
  	*version::new = \&version::vpp::new;
  	*version::numify = \&version::vpp::numify;
  	*version::normal = \&version::vpp::normal;
  	if ($] >= 5.009000) {
  	    no strict 'refs';
  	    *version::stringify = \&version::vpp::stringify;
  	    *{'version::(""'} = \&version::vpp::stringify;
  	    *{'version::(<=>'} = \&version::vpp::vcmp;
  	    *{'version::(cmp'} = \&version::vpp::vcmp;
  	    *version::parse = \&version::vpp::parse;
  	}
      }
      else { # use XS module
  	push @ISA, "version::vxs";
  	local $^W;
  	*version::declare = \&version::vxs::declare;
  	*version::qv = \&version::vxs::qv;
  	*version::_VERSION = \&version::vxs::_VERSION;
  	*version::vcmp = \&version::vxs::VCMP;
  	*version::new = \&version::vxs::new;
  	*version::numify = \&version::vxs::numify;
  	*version::normal = \&version::vxs::normal;
  	if ($] >= 5.009000) {
  	    no strict 'refs';
  	    *version::stringify = \&version::vxs::stringify;
  	    *{'version::(""'} = \&version::vxs::stringify;
  	    *{'version::(<=>'} = \&version::vxs::VCMP;
  	    *{'version::(cmp'} = \&version::vxs::VCMP;
  	    *version::parse = \&version::vxs::parse;
  	}
      }
  }
  
  # avoid using Exporter
  require version::regex;
  *version::is_lax = \&version::regex::is_lax;
  *version::is_strict = \&version::regex::is_strict;
  *LAX = \$version::regex::LAX;
  *LAX_DECIMAL_VERSION = \$version::regex::LAX_DECIMAL_VERSION;
  *LAX_DOTTED_DECIMAL_VERSION = \$version::regex::LAX_DOTTED_DECIMAL_VERSION;
  *STRICT = \$version::regex::STRICT;
  *STRICT_DECIMAL_VERSION = \$version::regex::STRICT_DECIMAL_VERSION;
  *STRICT_DOTTED_DECIMAL_VERSION = \$version::regex::STRICT_DOTTED_DECIMAL_VERSION;
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	local $^W;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  
  1;
X86_64-LINUX_VERSION

$fatpacked{"x86_64-linux/version/regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_VERSION_REGEX';
  package version::regex;
  
  use strict;
  
  our $VERSION = 0.9924;
  
  #--------------------------------------------------------------------------#
  # Version regexp components
  #--------------------------------------------------------------------------#
  
  # Fraction part of a decimal version number.  This is a common part of
  # both strict and lax decimal versions
  
  my $FRACTION_PART = qr/\.[0-9]+/;
  
  # First part of either decimal or dotted-decimal strict version number.
  # Unsigned integer with no leading zeroes (except for zero itself) to
  # avoid confusion with octal.
  
  my $STRICT_INTEGER_PART = qr/0|[1-9][0-9]*/;
  
  # First part of either decimal or dotted-decimal lax version number.
  # Unsigned integer, but allowing leading zeros.  Always interpreted
  # as decimal.  However, some forms of the resulting syntax give odd
  # results if used as ordinary Perl expressions, due to how perl treats
  # octals.  E.g.
  #   version->new("010" ) == 10
  #   version->new( 010  ) == 8
  #   version->new( 010.2) == 82  # "8" . "2"
  
  my $LAX_INTEGER_PART = qr/[0-9]+/;
  
  # Second and subsequent part of a strict dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.
  # Limited to three digits to avoid overflow when converting to decimal
  # form and also avoid problematic style with excessive leading zeroes.
  
  my $STRICT_DOTTED_DECIMAL_PART = qr/\.[0-9]{1,3}/;
  
  # Second and subsequent part of a lax dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.  No
  # limit on the numerical value or number of digits, so there is the
  # possibility of overflow when converting to decimal form.
  
  my $LAX_DOTTED_DECIMAL_PART = qr/\.[0-9]+/;
  
  # Alpha suffix part of lax version number syntax.  Acts like a
  # dotted-decimal part.
  
  my $LAX_ALPHA_PART = qr/_[0-9]+/;
  
  #--------------------------------------------------------------------------#
  # Strict version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Strict decimal version number.
  
  our $STRICT_DECIMAL_VERSION =
      qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;
  
  # Strict dotted-decimal version number.  Must have both leading "v" and
  # at least three parts, to avoid confusion with decimal syntax.
  
  our $STRICT_DOTTED_DECIMAL_VERSION =
      qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;
  
  # Complete strict version number syntax -- should generally be used
  # anchored: qr/ \A $STRICT \z /x
  
  our $STRICT =
      qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  # Lax version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Lax decimal version number.  Just like the strict one except for
  # allowing an alpha suffix or allowing a leading or trailing
  # decimal-point
  
  our $LAX_DECIMAL_VERSION =
      qr/ $LAX_INTEGER_PART (?: $FRACTION_PART | \. )? $LAX_ALPHA_PART?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;
  
  # Lax dotted-decimal version number.  Distinguished by having either
  # leading "v" or at least three non-alpha parts.  Alpha part is only
  # permitted if there are at least two non-alpha parts. Strangely
  # enough, without the leading "v", Perl takes .1.2 to mean v0.1.2,
  # so when there is no "v", the leading part is optional
  
  our $LAX_DOTTED_DECIMAL_VERSION =
      qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;
  
  # Complete lax version number syntax -- should generally be used
  # anchored: qr/ \A $LAX \z /x
  #
  # The string 'undef' is a special case to make for easier handling
  # of return values from ExtUtils::MM->parse_version
  
  our $LAX =
      qr/ undef | $LAX_DOTTED_DECIMAL_VERSION | $LAX_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  
  # Preloaded methods go here.
  sub is_strict	{ defined $_[0] && $_[0] =~ qr/ \A $STRICT \z /x }
  sub is_lax	{ defined $_[0] && $_[0] =~ qr/ \A $LAX \z /x }
  
  1;
X86_64-LINUX_VERSION_REGEX

$fatpacked{"x86_64-linux/version/vpp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_VERSION_VPP';
  package charstar;
  # a little helper class to emulate C char* semantics in Perl
  # so that prescan_version can use the same code as in C
  
  use overload (
      '""'	=> \&thischar,
      '0+'	=> \&thischar,
      '++'	=> \&increment,
      '--'	=> \&decrement,
      '+'		=> \&plus,
      '-'		=> \&minus,
      '*'		=> \&multiply,
      'cmp'	=> \&cmp,
      '<=>'	=> \&spaceship,
      'bool'	=> \&thischar,
      '='		=> \&clone,
  );
  
  sub new {
      my ($self, $string) = @_;
      my $class = ref($self) || $self;
  
      my $obj = {
  	string  => [split(//,$string)],
  	current => 0,
      };
      return bless $obj, $class;
  }
  
  sub thischar {
      my ($self) = @_;
      my $last = $#{$self->{string}};
      my $curr = $self->{current};
      if ($curr >= 0 && $curr <= $last) {
  	return $self->{string}->[$curr];
      }
      else {
  	return '';
      }
  }
  
  sub increment {
      my ($self) = @_;
      $self->{current}++;
  }
  
  sub decrement {
      my ($self) = @_;
      $self->{current}--;
  }
  
  sub plus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} += $offset;
      return $rself;
  }
  
  sub minus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} -= $offset;
      return $rself;
  }
  
  sub multiply {
      my ($left, $right, $swapped) = @_;
      my $char = $left->thischar();
      return $char * $right;
  }
  
  sub spaceship {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	$right = $left->new($right);
      }
      return $left->{current} <=> $right->{current};
  }
  
  sub cmp {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	if (length($right) == 1) { # comparing single character only
  	    return $left->thischar cmp $right;
  	}
  	$right = $left->new($right);
      }
      return $left->currstr cmp $right->currstr;
  }
  
  sub bool {
      my ($self) = @_;
      my $char = $self->thischar;
      return ($char ne '');
  }
  
  sub clone {
      my ($left, $right, $swapped) = @_;
      $right = {
  	string  => [@{$left->{string}}],
  	current => $left->{current},
      };
      return bless $right, ref($left);
  }
  
  sub currstr {
      my ($self, $s) = @_;
      my $curr = $self->{current};
      my $last = $#{$self->{string}};
      if (defined($s) && $s->{current} < $last) {
  	$last = $s->{current};
      }
  
      my $string = join('', @{$self->{string}}[$curr..$last]);
      return $string;
  }
  
  package version::vpp;
  
  use 5.006002;
  use strict;
  use warnings::register;
  
  use Config;
  
  our $VERSION = 0.9924;
  our $CLASS = 'version::vpp';
  our ($LAX, $STRICT, $WARN_CATEGORY);
  
  if ($] > 5.015) {
      warnings::register_categories(qw/version/);
      $WARN_CATEGORY = 'version';
  } else {
      $WARN_CATEGORY = 'numeric';
  }
  
  require version::regex;
  *version::vpp::is_strict = \&version::regex::is_strict;
  *version::vpp::is_lax = \&version::regex::is_lax;
  *LAX = \$version::regex::LAX;
  *STRICT = \$version::regex::STRICT;
  
  use overload (
      '""'       => \&stringify,
      '0+'       => \&numify,
      'cmp'      => \&vcmp,
      '<=>'      => \&vcmp,
      'bool'     => \&vbool,
      '+'        => \&vnoop,
      '-'        => \&vnoop,
      '*'        => \&vnoop,
      '/'        => \&vnoop,
      '+='        => \&vnoop,
      '-='        => \&vnoop,
      '*='        => \&vnoop,
      '/='        => \&vnoop,
      'abs'      => \&vnoop,
  );
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	no warnings qw/redefine/;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  my $VERSION_MAX = 0x7FFFFFFF;
  
  # implement prescan_version as closely to the C version as possible
  use constant TRUE  => 1;
  use constant FALSE => 0;
  
  sub isDIGIT {
      my ($char) = shift->thischar();
      return ($char =~ /\d/);
  }
  
  sub isALPHA {
      my ($char) = shift->thischar();
      return ($char =~ /[a-zA-Z]/);
  }
  
  sub isSPACE {
      my ($char) = shift->thischar();
      return ($char =~ /\s/);
  }
  
  sub BADVERSION {
      my ($s, $errstr, $error) = @_;
      if ($errstr) {
  	$$errstr = $error;
      }
      return $s;
  }
  
  sub prescan_version {
      my ($s, $strict, $errstr, $sqv, $ssaw_decimal, $swidth, $salpha) = @_;
      my $qv          = defined $sqv          ? $$sqv          : FALSE;
      my $saw_decimal = defined $ssaw_decimal ? $$ssaw_decimal : 0;
      my $width       = defined $swidth       ? $$swidth       : 3;
      my $alpha       = defined $salpha       ? $$salpha       : FALSE;
  
      my $d = $s;
  
      if ($qv && isDIGIT($d)) {
  	goto dotted_decimal_version;
      }
  
      if ($d eq 'v') { # explicit v-string
  	$d++;
  	if (isDIGIT($d)) {
  	    $qv = TRUE;
  	}
  	else { # degenerate v-string
  	    # requires v1.2.3
  	    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	}
  
  dotted_decimal_version:
  	if ($strict && $d eq '0' && isDIGIT($d+1)) {
  	    # no leading zeros allowed
  	    return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	}
  
  	while (isDIGIT($d)) { 	# integer part
  	    $d++;
  	}
  
  	if ($d eq '.')
  	{
  	    $saw_decimal++;
  	    $d++; 		# decimal point
  	}
  	else
  	{
  	    if ($strict) {
  		# require v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	    else {
  		goto version_prescan_finish;
  	    }
  	}
  
  	{
  	    my $i = 0;
  	    my $j = 0;
  	    while (isDIGIT($d)) {	# just keep reading
  		$i++;
  		while (isDIGIT($d)) {
  		    $d++; $j++;
  		    # maximum 3 digits between decimal
  		    if ($strict && $j > 3) {
  			return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)");
  		    }
  		}
  		if ($d eq '_') {
  		    if ($strict) {
  			return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		    }
  		    if ( $alpha ) {
  			return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		    }
  		    $d++;
  		    $alpha = TRUE;
  		}
  		elsif ($d eq '.') {
  		    if ($alpha) {
  			return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		    }
  		    $saw_decimal++;
  		    $d++;
  		}
  		elsif (!isDIGIT($d)) {
  		    last;
  		}
  		$j = 0;
  	    }
  
  	    if ($strict && $i < 2) {
  		# requires v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	}
      } 					# end if dotted-decimal
      else
      {					# decimal versions
  	my $j = 0;
  	# special $strict case for leading '.' or '0'
  	if ($strict) {
  	    if ($d eq '.') {
  		return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)");
  	    }
  	    if ($d eq '0' && isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	    }
  	}
  
  	# and we never support negative version numbers
  	if ($d eq '-') {
  	    return BADVERSION($s,$errstr,"Invalid version format (negative version number)");
  	}
  
  	# consume all of the integer part
  	while (isDIGIT($d)) {
  	    $d++;
  	}
  
  	# look for a fractional part
  	if ($d eq '.') {
  	    # we found it, so consume it
  	    $saw_decimal++;
  	    $d++;
  	}
  	elsif (!$d || $d eq ';' || isSPACE($d) || $d eq '}') {
  	    if ( $d == $s ) {
  		# found nothing
  		return BADVERSION($s,$errstr,"Invalid version format (version required)");
  	    }
  	    # found just an integer
  	    goto version_prescan_finish;
  	}
  	elsif ( $d == $s ) {
  	    # didn't find either integer or period
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  	elsif ($d eq '_') {
  	    # underscore can't come after integer part
  	    if ($strict) {
  		return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  	    }
  	    elsif (isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)");
  	    }
  	    else {
  		return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  	    }
  	}
  	elsif ($d) {
  	    # anything else after integer part is just invalid data
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  
  	# scan the fractional part after the decimal point
  	if ($d && !isDIGIT($d) && ($strict || ! ($d eq ';' || isSPACE($d) || $d eq '}') )) {
  		# $strict or lax-but-not-the-end
  		return BADVERSION($s,$errstr,"Invalid version format (fractional part required)");
  	}
  
  	while (isDIGIT($d)) {
  	    $d++; $j++;
  	    if ($d eq '.' && isDIGIT($d-1)) {
  		if ($alpha) {
  		    return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		}
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')");
  		}
  		$d = $s; # start all over again
  		$qv = TRUE;
  		goto dotted_decimal_version;
  	    }
  	    if ($d eq '_') {
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		}
  		if ( $alpha ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		}
  		if ( ! isDIGIT($d+1) ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  		}
  		$width = $j;
  		$d++;
  		$alpha = TRUE;
  	    }
  	}
      }
  
  version_prescan_finish:
      while (isSPACE($d)) {
  	$d++;
      }
  
      if ($d && !isDIGIT($d) && (! ($d eq ';' || $d eq '}') )) {
  	# trailing non-numeric data
  	return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
      }
      if ($saw_decimal > 1 && ($d-1) eq '.') {
  	# no trailing period allowed
  	return BADVERSION($s,$errstr,"Invalid version format (trailing decimal)");
      }
  
      if (defined $sqv) {
  	$$sqv = $qv;
      }
      if (defined $swidth) {
  	$$swidth = $width;
      }
      if (defined $ssaw_decimal) {
  	$$ssaw_decimal = $saw_decimal;
      }
      if (defined $salpha) {
  	$$salpha = $alpha;
      }
      return $d;
  }
  
  sub scan_version {
      my ($s, $rv, $qv) = @_;
      my $start;
      my $pos;
      my $last;
      my $errstr;
      my $saw_decimal = 0;
      my $width = 3;
      my $alpha = FALSE;
      my $vinf = FALSE;
      my @av;
  
      $s = new charstar $s;
  
      while (isSPACE($s)) { # leading whitespace is OK
  	$s++;
      }
  
      $last = prescan_version($s, FALSE, \$errstr, \$qv, \$saw_decimal,
  	\$width, \$alpha);
  
      if ($errstr) {
  	# 'undef' is a special case and not an error
  	if ( $s ne 'undef') {
  	    require Carp;
  	    Carp::croak($errstr);
  	}
      }
  
      $start = $s;
      if ($s eq 'v') {
  	$s++;
      }
      $pos = $s;
  
      if ( $qv ) {
  	$$rv->{qv} = $qv;
      }
      if ( $alpha ) {
  	$$rv->{alpha} = $alpha;
      }
      if ( !$qv && $width < 3 ) {
  	$$rv->{width} = $width;
      }
  
      while (isDIGIT($pos) || $pos eq '_') {
  	$pos++;
      }
      if (!isALPHA($pos)) {
  	my $rev;
  
  	for (;;) {
  	    $rev = 0;
  	    {
    		# this is atoi() that delimits on underscores
    		my $end = $pos;
    		my $mult = 1;
  		my $orev;
  
  		#  the following if() will only be true after the decimal
  		#  point of a version originally created with a bare
  		#  floating point number, i.e. not quoted in any way
  		#
   		if ( !$qv && $s > $start && $saw_decimal == 1 ) {
  		    $mult *= 100;
   		    while ( $s < $end ) {
  			next if $s eq '_';
  			$orev = $rev;
   			$rev += $s * $mult;
   			$mult /= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version %d",
  					   $VERSION_MAX);
  			    $s = $end - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   			$s++;
  			if ( $s eq '_' ) {
  			    $s++;
  			}
   		    }
    		}
   		else {
   		    while (--$end >= $s) {
  			next if $end eq '_';
  			$orev = $rev;
   			$rev += $end * $mult;
   			$mult *= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version");
  			    $end = $s - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   		    }
   		}
    	    }
  
    	    # Append revision
  	    push @av, $rev;
  	    if ( $vinf ) {
  		$s = $last;
  		last;
  	    }
  	    elsif ( $pos eq '.' ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq '_' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq ',' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( isDIGIT($pos) ) {
  		$s = $pos;
  	    }
  	    else {
  		$s = $pos;
  		last;
  	    }
  	    if ( $qv ) {
  		while ( isDIGIT($pos) || $pos eq '_') {
  		    $pos++;
  		}
  	    }
  	    else {
  		my $digits = 0;
  		while ( ( isDIGIT($pos) || $pos eq '_' ) && $digits < 3 ) {
  		    if ( $pos ne '_' ) {
  			$digits++;
  		    }
  		    $pos++;
  		}
  	    }
  	}
      }
      if ( $qv ) { # quoted versions always get at least three terms
  	my $len = $#av;
  	#  This for loop appears to trigger a compiler bug on OS X, as it
  	#  loops infinitely. Yes, len is negative. No, it makes no sense.
  	#  Compiler in question is:
  	#  gcc version 3.3 20030304 (Apple Computer, Inc. build 1640)
  	#  for ( len = 2 - len; len > 0; len-- )
  	#  av_push(MUTABLE_AV(sv), newSViv(0));
  	#
  	$len = 2 - $len;
  	while ($len-- > 0) {
  	    push @av, 0;
  	}
      }
  
      # need to save off the current version string for later
      if ( $vinf ) {
  	$$rv->{original} = "v.Inf";
  	$$rv->{vinf} = 1;
      }
      elsif ( $s > $start ) {
  	$$rv->{original} = $start->currstr($s);
  	if ( $qv && $saw_decimal == 1 && $start ne 'v' ) {
  	    # need to insert a v to be consistent
  	    $$rv->{original} = 'v' . $$rv->{original};
  	}
      }
      else {
  	$$rv->{original} = '0';
  	push(@av, 0);
      }
  
      # And finally, store the AV in the hash
      $$rv->{version} = \@av;
  
      # fix RT#19517 - special case 'undef' as string
      if ($s eq 'undef') {
  	$s += 5;
      }
  
      return $s;
  }
  
  sub new {
      my $class = shift;
      unless (defined $class or $#_ > 1) {
  	require Carp;
  	Carp::croak('Usage: version::new(class, version)');
      }
  
      my $self = bless ({}, ref ($class) || $class);
      my $qv = FALSE;
  
      if ( $#_ == 1 ) { # must be CVS-style
  	$qv = TRUE;
      }
      my $value = pop; # always going to be the last element
  
      if ( ref($value) && eval('$value->isa("version")') ) {
  	# Can copy the elements directly
  	$self->{version} = [ @{$value->{version} } ];
  	$self->{qv} = 1 if $value->{qv};
  	$self->{alpha} = 1 if $value->{alpha};
  	$self->{original} = ''.$value->{original};
  	return $self;
      }
  
      if ( not defined $value or $value =~ /^undef$/ ) {
  	# RT #19517 - special case for undef comparison
  	# or someone forgot to pass a value
  	push @{$self->{version}}, 0;
  	$self->{original} = "0";
  	return ($self);
      }
  
  
      if (ref($value) =~ m/ARRAY|HASH/) {
  	require Carp;
  	Carp::croak("Invalid version format (non-numeric data)");
      }
  
      $value = _un_vstring($value);
  
      if ($Config{d_setlocale}) {
  	use POSIX qw/locale_h/;
  	use if $Config{d_setlocale}, 'locale';
  	my $currlocale = setlocale(LC_ALL);
  
  	# if the current locale uses commas for decimal points, we
  	# just replace commas with decimal places, rather than changing
  	# locales
  	if ( localeconv()->{decimal_point} eq ',' ) {
  	    $value =~ tr/,/./;
  	}
      }
  
      # exponential notation
      if ( $value =~ /\d+.?\d*e[-+]?\d+/ ) {
  	$value = sprintf("%.9f",$value);
  	$value =~ s/(0+)$//; # trim trailing zeros
      }
  
      my $s = scan_version($value, \$self, $qv);
  
      if ($s) { # must be something left over
  	warn(sprintf "Version string '%s' contains invalid data; "
  		   ."ignoring: '%s'", $value, $s);
      }
  
      return ($self);
  }
  
  *parse = \&new;
  
  sub numify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      my $alpha = $self->{alpha} || "";
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("%d.", $digit );
  
      if ($alpha and warnings::enabled()) {
  	warnings::warn($WARN_CATEGORY, 'alpha->numify() is lossy');
      }
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf("%03d", $digit);
      }
  
      if ( $len == 0 ) {
  	$string .= sprintf("000");
      }
  
      return $string;
  }
  
  sub normal {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
  
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("v%d", $digit );
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf(".%d", $digit);
      }
  
      if ( $len <= 2 ) {
  	for ( $len = 2 - $len; $len != 0; $len-- ) {
  	    $string .= sprintf(".%0d", 0);
  	}
      }
  
      return $string;
  }
  
  sub stringify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      return exists $self->{original}
      	? $self->{original}
  	: exists $self->{qv}
  	    ? $self->normal
  	    : $self->numify;
  }
  
  sub vcmp {
      my ($left,$right,$swap) = @_;
      my $class = ref($left);
      unless ( UNIVERSAL::isa($right, $class) ) {
  	$right = $class->new($right);
      }
  
      if ( $swap ) {
  	($left, $right) = ($right, $left);
      }
      unless (_verify($left)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      unless (_verify($right)) {
  	require Carp;
  	Carp::croak("Invalid version format");
      }
      my $l = $#{$left->{version}};
      my $r = $#{$right->{version}};
      my $m = $l < $r ? $l : $r;
      my $lalpha = $left->is_alpha;
      my $ralpha = $right->is_alpha;
      my $retval = 0;
      my $i = 0;
      while ( $i <= $m && $retval == 0 ) {
  	$retval = $left->{version}[$i] <=> $right->{version}[$i];
  	$i++;
      }
  
      # possible match except for trailing 0's
      if ( $retval == 0 && $l != $r ) {
  	if ( $l < $r ) {
  	    while ( $i <= $r && $retval == 0 ) {
  		if ( $right->{version}[$i] != 0 ) {
  		    $retval = -1; # not a match after all
  		}
  		$i++;
  	    }
  	}
  	else {
  	    while ( $i <= $l && $retval == 0 ) {
  		if ( $left->{version}[$i] != 0 ) {
  		    $retval = +1; # not a match after all
  		}
  		$i++;
  	    }
  	}
      }
  
      return $retval;
  }
  
  sub vbool {
      my ($self) = @_;
      return vcmp($self,$self->new("0"),1);
  }
  
  sub vnoop {
      require Carp;
      Carp::croak("operation not supported with version object");
  }
  
  sub is_alpha {
      my ($self) = @_;
      return (exists $self->{alpha});
  }
  
  sub qv {
      my $value = shift;
      my $class = $CLASS;
      if (@_) {
  	$class = ref($value) || $value;
  	$value = shift;
      }
  
      $value = _un_vstring($value);
      $value = 'v'.$value unless $value =~ /(^v|\d+\.\d+\.\d)/;
      my $obj = $CLASS->new($value);
      return bless $obj, $class;
  }
  
  *declare = \&qv;
  
  sub is_qv {
      my ($self) = @_;
      return (exists $self->{qv});
  }
  
  
  sub _verify {
      my ($self) = @_;
      if ( ref($self)
  	&& eval { exists $self->{version} }
  	&& ref($self->{version}) eq 'ARRAY'
  	) {
  	return 1;
      }
      else {
  	return 0;
      }
  }
  
  sub _is_non_alphanumeric {
      my $s = shift;
      $s = new charstar $s;
      while ($s) {
  	return 0 if isSPACE($s); # early out
  	return 1 unless (isALPHA($s) || isDIGIT($s) || $s =~ /[.-]/);
  	$s++;
      }
      return 0;
  }
  
  sub _un_vstring {
      my $value = shift;
      # may be a v-string
      if ( length($value) >= 1 && $value !~ /[,._]/
  	&& _is_non_alphanumeric($value)) {
  	my $tvalue;
  	if ( $] >= 5.008_001 ) {
  	    $tvalue = _find_magic_vstring($value);
  	    $value = $tvalue if length $tvalue;
  	}
  	elsif ( $] >= 5.006_000 ) {
  	    $tvalue = sprintf("v%vd",$value);
  	    if ( $tvalue =~ /^v\d+(\.\d+)*$/ ) {
  		# must be a v-string
  		$value = $tvalue;
  	    }
  	}
      }
      return $value;
  }
  
  sub _find_magic_vstring {
      my $value = shift;
      my $tvalue = '';
      require B;
      my $sv = B::svref_2object(\$value);
      my $magic = ref($sv) eq 'B::PVMG' ? $sv->MAGIC : undef;
      while ( $magic ) {
  	if ( $magic->TYPE eq 'V' ) {
  	    $tvalue = $magic->PTR;
  	    $tvalue =~ s/^v?(.+)$/v$1/;
  	    last;
  	}
  	else {
  	    $magic = $magic->MOREMAGIC;
  	}
      }
      $tvalue =~ tr/_//d;
      return $tvalue;
  }
  
  sub _VERSION {
      my ($obj, $req) = @_;
      my $class = ref($obj) || $obj;
  
      no strict 'refs';
      if ( exists $INC{"$class.pm"} and not %{"$class\::"} and $] >= 5.008) {
  	 # file but no package
  	require Carp;
  	Carp::croak( "$class defines neither package nor VERSION"
  	    ."--version check failed");
      }
  
      my $version = eval "\$$class\::VERSION";
      if ( defined $version ) {
  	local $^W if $] <= 5.008;
  	$version = version::vpp->new($version);
      }
  
      if ( defined $req ) {
  	unless ( defined $version ) {
  	    require Carp;
  	    my $msg =  $] < 5.006
  	    ? "$class version $req required--this is only version "
  	    : "$class does not define \$$class\::VERSION"
  	      ."--version check failed";
  
  	    if ( $ENV{VERSION_DEBUG} ) {
  		Carp::confess($msg);
  	    }
  	    else {
  		Carp::croak($msg);
  	    }
  	}
  
  	$req = version::vpp->new($req);
  
  	if ( $req > $version ) {
  	    require Carp;
  	    if ( $req->is_qv ) {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->normal, $version->normal)
  		);
  	    }
  	    else {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->stringify, $version->stringify)
  		);
  	    }
  	}
      }
  
      return defined $version ? $version->stringify : undef;
  }
  
  1; #this line is important and will help the module return a true value
X86_64-LINUX_VERSION_VPP

$fatpacked{"x86_64-linux/version/vxs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_VERSION_VXS';
  #!perl -w
  package version::vxs;
  
  use v5.10;
  use strict;
  
  our $VERSION = 0.9924;
  our $CLASS = 'version::vxs';
  our @ISA;
  
  eval {
      require XSLoader;
      local $^W; # shut up the 'redefined' warning for UNIVERSAL::VERSION
      XSLoader::load('version::vxs', $VERSION);
      1;
  } or do {
      require DynaLoader;
      push @ISA, 'DynaLoader'; 
      local $^W; # shut up the 'redefined' warning for UNIVERSAL::VERSION
      bootstrap version::vxs $VERSION;
  };
  
  # Preloaded methods go here.
  
  1;
X86_64-LINUX_VERSION_VXS

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/home/gugod/perl5/perlbrew/perls/v18/bin/perl
use strict;
use warnings;
use Test::Requires::Scanner::CLI;
Test::Requires::Scanner::CLI->run(@ARGV);

__END__

=head1 SYNOPSIS

    % scan-test-requires

=head1 DESCRIPTION

scan t/ and xt/ files and list the modules specified by Test::Requires.

=head1 AUTHORS

Masayuki Matsuki
