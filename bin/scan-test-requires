#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Attribute/Constant.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ATTRIBUTE_CONSTANT';
  package Attribute::Constant;
  use 5.008001;
  use warnings;
  use strict;
  our $VERSION = sprintf "%d.%02d", q$Revision: 1.1 $ =~ /(\d+)/g;
  use Attribute::Handlers;
  use Data::Lock ();
  
  sub UNIVERSAL::Constant : ATTR {
      my ( $pkg, $sym, $ref, $attr, $data, $phase ) = @_;
      (
            ref $ref eq 'HASH'  ? %$ref
          : ref $ref eq 'ARRAY' ? @$ref
          :                       ($$ref)
        )
        = ref $data
        ? ref $data eq 'ARRAY'
            ? @$data    # perl 5.10.x
            : $data
        : $data;        # perl 5.8.x
      Data::Lock::dlock($ref);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Attribute::Constant - Make read-only variables via attribute
  
  =head1 VERSION
  
  $Id: Constant.pm,v 1.1 2013/04/03 14:37:57 dankogai Exp $
  
  =head1 SYNOPSIS
  
   use Attribute::Constant;
   my $sv : Constant( $initial_value );
   my @av : Constant( @values );
   my %hv : Constant( key => value, key => value, ...);
  
  =head1 DESCRIPTION
  
  This module uses L<Data::Lock> to make the variable read-only.  Check
  the document and source of L<Data::Lock> for its mechanism.
  
  =head1 ATTRIBUTES
  
  This module adds only one attribute, C<Constant>.  You give its
  initial value as shown.  Unlike L<Readonly>, parantheses cannot be
  ommited but it is semantically more elegant and thanks to
  L<Data::Lock>, it imposes almost no performance penalty.
  
  =head1 CAVEAT
  
  =head2 Multi-line attributes
  
  Multi-line attributes are not allowed in Perl 5.8.x.
  
    my $o : Constant(Foo->new(one=>1,two=>2,three=>3));    # ok
    my $p : Constant(Bar->new(
                              one   =>1,
                              two   =>2,
                              three =>3
                             )
                   ); # needs Perl 5.10
  
  In which case you can use L<Data::Lock> instead:
  
    dlock(my $p = Bar->new(
          one   => 1,
          two   => 2,
          three => 3
      )
    );
  
  After all, this module is a wrapper to L<Data::Lock>;
  
  =head2 Constants from Variables
  
  You may be surprised the following code B<DOES NOT> work as you expected:
  
    #!/usr/bin/perl
    use strict;
    use warnings;
    use Attribute::Constant;
    use Data::Dumper;
    {
      package MyClass;
      sub new {
          my ( $class, %params ) = @_;
          return bless \%params, $class;
      }
    }
    my $o = MyClass->new( a => 1, b => 2 );
    my $x : Constant($o);
    print Dumper( $o, $x );
  
  Which outputs:
  
    $VAR1 = bless( {
                   'a' => 1,
                   'b' => 2
                 }, 'MyClass' );
    $VAR2 = undef;
  
  Why?  Because C< $x : Constant($o) > happens B<before>
  C<< $o = Myclass->new() >>.
  
  On the other hand, the following works.
  
    my $y : Constant(MyClass->new(a => 1,b => 2));
    print Dumper( $o, $y );
  
  Rule of the thumb is do not feed variables to constant because
  varialbes change after the attribute invocation.
  
  Or simply use C<Data::Lock::dlock>.
  
    use Data::Lock qw/dlock/;
    dlock my $z = $o;
    print Dumper( $o, $y );
  
  =head1 SEE ALSO
  
  L<Data::Lock>, L<constant>
  
  =head1 AUTHOR
  
  Dan Kogai, C<< <dankogai+cpan at gmail.com> >>
  
  =head1 BUGS & SUPPORT
  
  See L<Data::Lock>.
  
  =head1 ACKNOWLEDGEMENTS
  
  L<Readonly>
  
  =head1 COPYRIGHT & LICENSE
  
  Copyright 2008-2013 Dan Kogai, all rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
ATTRIBUTE_CONSTANT

$fatpacked{"Class/Accessor/Lite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_ACCESSOR_LITE';
  package Class::Accessor::Lite;
  
  use strict;
  
  our $VERSION = '0.08';
  
  sub croak {require Carp; Carp::croak(@_)}
  
  sub import {
      shift;
      my %args = @_;
      my $pkg = caller(0);
      my %key_ctor = (
          rw => \&_mk_accessors,
          ro => \&_mk_ro_accessors,
          wo => \&_mk_wo_accessors,
      );
      for my $key (sort keys %key_ctor) {
          if (defined $args{$key}) {
              croak("value of the '$key' parameter should be an arrayref")
                  unless ref($args{$key}) eq 'ARRAY';
              $key_ctor{$key}->($pkg, @{$args{$key}});
          }
      }
      _mk_new($pkg)
          if $args{new};
      1;
  }
  
  sub mk_new_and_accessors {
      (undef, my @properties) = @_;
      my $pkg = caller(0);
      _mk_new($pkg);
      _mk_accessors($pkg, @properties);
  }
  
  sub mk_new {
      my $pkg = caller(0);
      _mk_new($pkg);
  }
  
  sub mk_accessors {
      (undef, my @properties) = @_;
      my $pkg = caller(0);
      _mk_accessors($pkg, @properties);
  }
  
  sub mk_ro_accessors {
      (undef, my @properties) = @_;
      my $pkg = caller(0);
      _mk_ro_accessors($pkg, @properties);
  }
  
  sub mk_wo_accessors {
      (undef, my @properties) = @_;
      my $pkg = caller(0);
      _mk_wo_accessors($pkg, @properties);
  }
  
  sub _mk_new {
      my $pkg = shift;
      no strict 'refs';
      *{$pkg . '::new'} = __m_new($pkg);
  }
  
  sub _mk_accessors {
      my $pkg = shift;
      no strict 'refs';
      for my $n (@_) {
          *{$pkg . '::' . $n} = __m($n);
      }
  }
  
  sub _mk_ro_accessors {
      my $pkg = shift;
      no strict 'refs';
      for my $n (@_) {
          *{$pkg . '::' . $n} = __m_ro($pkg, $n);
      }
  }
  
  sub _mk_wo_accessors {
      my $pkg = shift;
      no strict 'refs';
      for my $n (@_) {
          *{$pkg . '::' . $n} = __m_wo($pkg, $n);
      }
  }
  
  sub __m_new {
      my $pkg = shift;
      no strict 'refs';
      return sub {
          my $klass = shift;
          bless {
              (@_ == 1 && ref($_[0]) eq 'HASH' ? %{$_[0]} : @_),
          }, $klass;
      };
  }
  
  sub __m {
      my $n = shift;
      sub {
          return $_[0]->{$n} if @_ == 1;
          return $_[0]->{$n} = $_[1] if @_ == 2;
          shift->{$n} = \@_;
      };
  }
  
  sub __m_ro {
      my ($pkg, $n) = @_;
      sub {
          if (@_ == 1) {
              return $_[0]->{$n} if @_ == 1;
          } else {
              my $caller = caller(0);
              croak("'$caller' cannot access the value of '$n' on objects of class '$pkg'");
          }
      };
  }
  
  sub __m_wo {
      my ($pkg, $n) = @_;
      sub {
          if (@_ == 1) {
              my $caller = caller(0);
              croak("'$caller' cannot alter the value of '$n' on objects of class '$pkg'")
          } else {
              return $_[0]->{$n} = $_[1] if @_ == 2;
              shift->{$n} = \@_;
          }
      };
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::Accessor::Lite - a minimalistic variant of Class::Accessor
  
  =head1 SYNOPSIS
  
      package MyPackage;
  
      use Class::Accessor::Lite (
          new => 1,
          rw  => [ qw(foo bar) ],
          ro  => [ qw(baz) ],
          wo  => [ qw(hoge) ],
      );
  
  =head1 DESCRIPTION
  
  The module is a variant of C<Class::Accessor>.  It is fast and requires less typing, has no dependencies to other modules, and does not mess up the @ISA.
  
  =head1 THE USE STATEMENT
  
  The use statement (i.e. the C<import> function) of the module takes a single hash as an argument that specifies the types and the names of the properties.  Recognises the following keys.
  
  =over 4
  
  =item new => $true_or_false
  
  the default constructor is created if the value evaluates to true, otherwise nothing is done (the default behaviour)
  
  =item rw => \@name_of_the_properties
  
  creates a read / write accessor for the name of the properties passed through as an arrayref
  
  =item ro => \@name_of_the_properties
  
  creates a read-only accessor for the name of the properties passed through as an arrayref
  
  =item wo => \@name_of_the_properties
  
  creates a write-only accessor for the name of the properties passed through as an arrayref
  
  =back
  
  For more detailed explanation read the following section describing the behaviour of each function that actually creates the accessors.
  
  =head1 FUNCTIONS
  
  As of version 0.04 the properties can be specified as the arguments to the C<use> statement (as can be seen in the SYNOPSIS) which is now the recommended way of using the module, but for compatibility the following functions are provided as well.
  
  =head2 Class::Accessor::Lite->mk_accessors(@name_of_the_properties)
  
  Creates an accessor in current package under the name specified by the arguments that access the properties (of a hashref) with the same name.
  
  =head2 Class::Accessor::Lite->mk_ro_accessors(@name_of_the_properties)
  
  Same as mk_accessors() except it will generate read-only accessors (i.e. true accessors).  If you attempt to set a value with these accessors it will throw an exception.
  
  =head2 Class::Accessor::Lite->mk_wo_accessors(@name_of_the_properties)
  
  Same as mk_accessors() except it will generate write-only accessors (i.e. mutators).  If you attempt to read a value with these accessors it will throw an exception.
  
  =head2 Class::Accessor::Lite->mk_new()
  
  Creates the C<new> function that accepts a hash or a hashref as the initial properties of the object.
  
  =head2 Class::Accessor::Lite->mk_new_and_accessors(@name_of_the_properties)
  
  DEPRECATED.  Use the new "use Class::Accessor::Lite (...)" style.
  
  =head1 FAQ
  
  =head2 Can I use C<Class::Accessor::Lite> in an inherited module?
  
  Yes in most cases, when the class object in the super class is implemented using a hashref.  However you _should_ _not_ create the constructor for the inherited class by calling C<<Class::Accessor::Lite->new()>> or by C<<use Class::Accessor::Lite (new => 1)>>.  The only other thing that C<Class::Accessor::Lite> does is to set up the accessor functions for given property names through a blessed hashref.
  
  =head2 What happens when passing more than one arguments to the accessor?
  
  When the accessor built by Class::Accessor::Lite is given more than one arguments, a reference to the arguments will be saved as an arrayref.  This behaviour might not be necessary but is implemented as is to maintain compatibility with L<Class::Accessor::Fast>.
  
      my @data = (1, 2, 3);
      $obj->someproperty(@data);
  
      $obj->someproperty->[2]++; # $data[3] is incremented
  
  In general, you should pass an arrayref to set an arrayref to a property.
  
      my @data = (1, 2, 3);
      $obj->someproperty([ @data ]); # save a copy using arrayref
  
      $obj->someproper->[2]++; # @data is not modified
  
  =head1 SEE ALSO
  
  L<Class::Accessor>
  
  L<Class::Accessor::Lite>
  
  =head1 AUTHORS
  
  Copyright (C) 2008 - 2010 Kazuho Oku
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself, either Perl version 5.8.6 or, at your option, any later version of Perl 5 you may have available.
  
  =cut
  
CLASS_ACCESSOR_LITE

$fatpacked{"Const/Common.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONST_COMMON';
  package Const::Common;
  use 5.008005;
  use strict;
  use warnings;
  
  our $VERSION = "0.01";
  
  require Exporter;
  use Data::Lock;
  
  sub import {
      my $pkg   = caller;
      shift;
      my %constants = @_ == 1 ? %{ $_[0] } : @_;
  
      Data::Lock::dlock my $locked = \%constants;
      {
          no strict 'refs';
          ${ "$pkg\::_constants" } = $locked;
          for my $method (qw/const constants constant_names/) {
              *{ "$pkg\::$method" } = \&{ __PACKAGE__ . "::$method" };
          }
          push @{"$pkg\::ISA"}, ('Exporter');
          push @{"$pkg\::EXPORT"}, (keys %$locked);
      }
  
      require constant;
      @_ = ('constant', $locked);
      goto constant->can('import');
  }
  
  sub const {
      my ($pkg, $constant_name) = @_;
      $pkg->constants->{$constant_name};
  }
  
  sub constants {
      no strict 'refs';
      my $pkg = shift;
      ${ "$pkg\::_constants" };
  }
  
  sub constant_names {
      my $pkg = shift;
      sort keys %{ $pkg->constants };
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Const::Common - Yet another constant definition module
  
  =head1 SYNOPSIS
  
      package MyApp::Const;
      use Const::Common (
          BAR => 'BAZ',
          HASH => {
              HOGE => 'hoge',
          },
      );
      __END__
  
      use MyApp::Const;
      print BAR; # BAZ
      print HASH->{HOGE}; # hoge;
      HASH->{HOGE} = 10;  # ERROR!
  
  =head1 DESCRIPTION
  
  Const::Common is a module to define common constants in your project.
  
  =head1 METHOD
  
  =head2 C<< $hashref = $class->constants >>
  
  =head2 C<< $array = $class->constant_names >>
  
  =head2 C<< $value = $class->const($const_name) >>
  
  =head1 LICENSE
  
  Copyright (C) Songmu.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Songmu E<lt>y.songmu@gmail.comE<gt>
  
  =cut
CONST_COMMON

$fatpacked{"Data/Lock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_LOCK';
  package Data::Lock;
  use 5.008001;
  use warnings;
  use strict;
  our $VERSION = sprintf "%d.%02d", q$Revision: 1.3 $ =~ /(\d+)/g;
  
  use Attribute::Handlers;
  use Scalar::Util ();
  
  use base 'Exporter';
  our @EXPORT_OK = qw/dlock dunlock/;
  
  #my @builtin_types = 
  #    qw/SCALAR ARRAY HASH CODE REF GLOB LVALUE FORMAT IO VSTRING Regexp/;
  
  for my $locked ( 0, 1 ) {
      my $subname = $locked ? 'dlock' : 'dunlock';
      no strict 'refs';
      *{$subname} = sub {
          no warnings "uninitialized";
          return if $_[1] and Internals::SvREADONLY( $_[0]) == $locked;
          Internals::SvREADONLY( $_[0], $locked );
          return unless my $type = Scalar::Util::reftype( $_[0] );
          for (
                $type eq 'ARRAY' ? @{ $_[0] }
              : $type eq 'HASH'  ? values %{ $_[0] }
              : $type ne 'CODE'  ? ${ $_[0] }
              :                    ()
            )
          {
              &$subname($_, 1) if ref $_;
              Internals::SvREADONLY( $_, $locked );
          }
              $type eq 'ARRAY' ? Internals::SvREADONLY( @{ $_[0] }, $locked )
            : $type eq 'HASH'  ? Internals::SvREADONLY( %{ $_[0] }, $locked )
            : $type ne 'CODE'  ? Internals::SvREADONLY( ${ $_[0] }, $locked )
            :                    undef;
      };
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Data::Lock - makes variables (im)?mutable
  
  =head1 VERSION
  
  $Id: Lock.pm,v 1.3 2014/03/07 18:24:43 dankogai Exp dankogai $
  
  =head1 SYNOPSIS
  
     use Data::Lock qw/dlock dunlock/;
  
     dlock my $sv = $initial_value;
     dlock my $ar = [@values];
     dlock my $hr = { key => value, key => value, ... };
     dunlock $sv;
     dunlock $ar; dunlock \@av;
     dunlock $hr; dunlock \%hv;
  
  =head1 DESCRIPTION
  
  C<dlock> makes the specified variable immutable like L<Readonly>.
  Unlike L<Readonly> which implements immutability via C<tie>, C<dlock>
  makes use of the internal flag of perl SV so it imposes almost no
  penalty.
  
  Like L<Readonly>, C<dlock> locks not only the variable itself but also
  elements therein.
  
  As of verion 0.03, you can C<dlock> objects as well.  Below is an
  example constructor that returns an immutable object:
  
    sub new {
        my $pkg = shift;
        my $self = { @_ };
        bless $self, $pkg;
        dlock($self);
        $self;
    }
  
  Or consider using L<Moose>.
  
  =head1 EXPORT
  
  Like L<List::Util> and L<Scalar::Util>, functions are exported only
  explicitly. This module comes with C<dlock> and C<dunlock>.
  
    use Data::Lock;                   # nothing imported;
    use Data::Lock qw/dlock dunlock/; # imports dlock() and dunlock()
  
  =head1 FUNCTIONS
  
  =head2 dlock
  
    dlock($scalar);
  
  Locks $scalar and if $scalar is a reference, recursively locks referents.
  
  =head2 dunlock
  
  Does the opposite of C<dlock>.
  
  =head1 BENCHMARK
  
  Here I have benchmarked like this.
  
    1.  Create an immutable variable.
    2.  try to change it and see if it raises exception
    3.  make sure the value stored remains unchanged.
  
  See F<t/benchmark.pl> for details.
  
  =over 2
  
  =item Simple scalar
  
                  Rate  Readonly Attribute      glob     dlock
    Readonly   11987/s        --      -98%      -98%      -98%
    Attribute 484562/s     3943%        --       -1%       -4%
    glob      487239/s     3965%        1%        --       -3%
    dlock     504247/s     4107%        4%        3%        --
  
  =item Array with 1000 entries
  
                  Rate  Readonly     dlock Attribute
    Readonly   12396/s        --      -97%      -97%
    dlock     444703/s     3488%        --       -6%
    Attribute 475557/s     3736%        7%        --
  
  =item Hash with 1000 key/value pairs
  
                  Rate  Readonly     dlock Attribute
    Readonly   10855/s        --      -97%      -97%
    dlock     358867/s     3206%        --       -5%
    Attribute 377087/s     3374%        5%        --
  
  =back
  
  =head1 SEE ALSO
  
  L<Readonly>, L<perlguts>, L<perlapi>
  
  =head1 AUTHOR
  
  Dan Kogai, C<< <dankogai+gmail at gmail.com> >>
  
  =head1 BUGS
  
  Please report any bugs or feature requests to C<bug-data-lock at
  rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Data-Lock>.  I will
  be notified, and then you'll automatically be notified of progress on
  your bug as I make changes.
  
  =head1 SUPPORT
  
  You can find documentation for this module with the perldoc command.
  
      perldoc Data::Lock
  
  You can also look for information at:
  
  =over 4
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Data-Lock>
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/Data-Lock>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Data-Lock>
  
  =item * Search CPAN
  
  L<http://search.cpan.org/dist/Data-Lock>
  
  =back
  
  =head1 COPYRIGHT & LICENSE
  
  Copyright 2008-2013 Dan Kogai, all rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
DATA_LOCK

$fatpacked{"File/Zglob.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_ZGLOB';
  package File::Zglob;
  use strict;
  use warnings 'all', FATAL => 'recursion';
  use 5.008008;
  our $VERSION = '0.11';
  use base qw(Exporter);
  
  our @EXPORT = qw(zglob);
  
  use File::Basename;
  
  our $SEPCHAR    = '/';
  our $NOCASE = $^O =~ /^(?:MSWin32|VMS|os2|dos|riscos|MacOS|darwin)$/ ? 1 : 0;
  our $DIRFLAG = \"DIR?";
  our $DEEPFLAG = \"**";
  our $PARENTFLAG = \"..";
  our $DEBUG = 0;
  our $STRICT_LEADING_DOT    = 1;
  our $STRICT_WILDCARD_SLASH = 1;
  
  sub zglob {
      my ($pattern) = @_;
      #dbg("FOLDING: $pattern");
      # support ~tokuhirom/
      if ($^O eq 'MSWin32') {
          require Win32;
          $pattern =~ s!^(\~[^$SEPCHAR]*)!Win32::GetLongPathName([glob($1)]->[0])!e;
      } else {
          $pattern =~ s!^(\~[^$SEPCHAR]*)![glob($1)]->[0]!e;
      }
      my ($node, $matcher) = glob_prepare_pattern($pattern);
      # $node : \0 if absolute path, \1 if relative.
  
      #dbg("pattern: ", $node, $matcher);
      return _rec($node, $matcher, []);
  }
  
  sub dbg(@) {
      return unless $DEBUG;
      my ($pkg, $filename, $line, $sub) = caller(1);
      my $i = 0;
      while (caller($i++)) { 1 }
      my $msg;
      $msg .= ('-' x ($i-5));
      $msg .= " [$sub] ";
      for (@_) {
          $msg .= ' ';
          if (not defined $_) {
              $msg .= '<<undef>>';
          } elsif (ref $_) {
              require Data::Dumper;
              local $Data::Dumper::Terse = 1;
              local $Data::Dumper::Indent = 0;
              $msg .= Data::Dumper::Dumper($_);
          } else {
              $msg .= $_;
          }
      }
      $msg .= " at $filename line $line\n";
      print($msg);
  }
  
  sub _recstar {
      my ($node, $matcher) = @_;
      #dbg("recstar: ", $node, $matcher, $seed);
      return (
          _rec( $node, $matcher ),
          (
              map { _recstar( $_, $matcher ) }
                glob_fs_fold( $node, qr{^[^.].*$}, 1 )
          )
      );
  }
  
  sub _rec {
      my ($node, $matcher) = @_;
      # $matcher: ArrayRef[Any]
  
      my ($current, @rest) = @{$matcher};
      if (!defined $current) {
          #dbg("FINISHED");
          return ();
      } elsif (ref($current) eq 'SCALAR' && $current == $DEEPFLAG) {
          #dbg("** mode");
          return _recstar($node, \@rest);
      } elsif (ref($current) eq 'SCALAR' && $current == $PARENTFLAG) {
          if (ref($node) eq 'SCALAR' && $$node eq 1) { #t
              die "You cannot get a parent directory of root dir.";
          } elsif (ref($node) eq 'SCALAR' && $$node eq 0) { #f
              return _rec("..", \@rest);
          } else {
              return _rec("$node$SEPCHAR..", \@rest);
          }
      } elsif (@rest == 0) {
          #dbg("file name");
          # (folder proc seed node (car matcher) #f)
          return glob_fs_fold($node, $current, 0);
      } else {
          return glob_fs_fold($node, $current, 1, \@rest);
      }
  }
  
  
  # /^home$/ のような固定の文字列の場合に高速化をはかるための最適化予定地なので、とりあえず undef をかえしておいても問題がない
  sub fixed_regexp_p {
      return undef;
      die "TBI"
  }
  
  # returns arrayref of seeds.
  sub glob_fs_fold {
      my ($node, $regexp, $non_leaf_p, $rest) = @_;
  
      my $prefix = do {
          if (ref $node eq 'SCALAR') {
              if ($$node eq 1) { #t
                  $SEPCHAR
              } elsif ($$node eq '0') { #f
                  '';
              } else {
                  die "FATAL";
              }
          } elsif ($node !~ m{/$}) {
              $node . '/';
          } else {
              $node;
          }
      };
      dbg("prefix: $prefix");
      dbg("regxp: ", $regexp);
      if ($^O eq 'MSWin32' && ref $regexp eq 'SCALAR' && $$regexp =~ /^[a-zA-Z]\:$/) {
          return _rec($$regexp . '/', $rest);
      }
      if (ref $regexp eq 'SCALAR' && $regexp == $DIRFLAG) {
          if ($rest) {
              return _rec($prefix, $rest);
          } else {
              return ($prefix);
          }
  #   } elsif (my $string_portion = fixed_regexp_p($regexp)) { # /^path$/
  #       die "TBI";
  #       my $full = $prefix . $string_portion;
  #       if (-e $full && (!$non_leaf_p || -d $full)) {
  #           $proc->($full, $seed);
  #       } else {
  #           $proc;
  #       }
      } else { # normal regexp
          #dbg("normal regexp");
          my $dir = do {
              if (ref($node) eq 'SCALAR' && $$node eq 1) {
                  $SEPCHAR
              } elsif (ref($node) eq 'SCALAR' && $$node eq 0) {
                  '.';
              } else {
                  $node;
              }
          };
          #dbg("dir: $dir");
          opendir my $dirh, $dir or do {
              #dbg("cannot open dir: $dir: $!");
              return ();
          };
          my @ret;
          while (defined(my $child = readdir($dirh))) {
              next if $child eq '.' or $child eq '..';
              my $full;
              #dbg("non-leaf: ", $non_leaf_p);
              if (($child =~ $regexp) && ($full = $prefix . $child) && (!$non_leaf_p || -d $full)) {
                  #dbg("matched: ", $regexp, $child, $full);
                  if ($rest) {
                      push @ret, _rec($full, $rest);
                  } else {
                      push @ret, $full;
                  }
            # } else {
                  #dbg("Don't match: $child");
              }
          }
          return @ret;
      }
  }
  
  sub glob_prepare_pattern {
      my ($pattern) = @_;
      my @path = split $SEPCHAR, $pattern;
  
      my $is_absolute = $path[0] eq '' ? 1 : 0;
      if ($is_absolute) {
          shift @path;
      }
      if ($^O eq 'MSWin32' && $path[0] =~ /^[a-zA-Z]\:$/) {
          $is_absolute = 1;
      }
  
      @path = map {
          if ($_ eq '**') {
              $DEEPFLAG
          } elsif ($_ eq '') {
              $DIRFLAG
          } elsif ($_ eq '.') {
              ()
          } elsif ($_ eq '..') {
              $PARENTFLAG
          } elsif ($^O eq 'MSWin32' && $_ =~ '^[a-zA-Z]\:$') {
              \$_
          } else {
              glob_to_regex($_) # TODO: replace with original implementation?
          }
      } @path;
  
      return ( \$is_absolute, \@path );
  }
  
  # this is not a private function. '**' was handled at glob_prepare_pattern() function.
  sub glob_to_regex {
      my $glob = shift;
      my $regex = glob_to_regex_string($glob);
      return $NOCASE ? qr/^$regex$/i : qr/^$regex$/;
  }
  
  sub glob_to_regex_string {
      my $glob = shift;
      my ($regex, $in_curlies, $escaping);
      local $_;
      my $first_byte = 1;
      for ($glob =~ m/(.)/gs) {
          if ($first_byte) {
              if ($STRICT_LEADING_DOT) {
                  $regex .= '(?=[^\.])' unless $_ eq '.';
              }
              $first_byte = 0;
          }
          if ($_ eq '/') {
              $first_byte = 1;
          }
          if ($_ eq '.' || $_ eq '(' || $_ eq ')' || $_ eq '|' ||
              $_ eq '+' || $_ eq '^' || $_ eq '$' || $_ eq '@' || $_ eq '%' ) {
              $regex .= "\\$_";
          }
          elsif ($_ eq '*') {
              $regex .= $escaping ? "\\*" :
                $STRICT_WILDCARD_SLASH ? "[^/]*" : ".*";
          }
          elsif ($_ eq '?') {
              $regex .= $escaping ? "\\?" :
                $STRICT_WILDCARD_SLASH ? "[^/]" : ".";
          }
          elsif ($_ eq '{') {
              $regex .= $escaping ? "\\{" : "(";
              ++$in_curlies unless $escaping;
          }
          elsif ($_ eq '}' && $in_curlies) {
              $regex .= $escaping ? "}" : ")";
              --$in_curlies unless $escaping;
          }
          elsif ($_ eq ',' && $in_curlies) {
              $regex .= $escaping ? "," : "|";
          }
          elsif ($_ eq "\\") {
              if ($escaping) {
                  $regex .= "\\\\";
                  $escaping = 0;
              }
              else {
                  $escaping = 1;
              }
              next;
          }
          else {
              $regex .= $_;
              $escaping = 0;
          }
          $escaping = 0;
      }
  
      return $regex;
  }
  
  1;
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  File::Zglob - Extended globs.
  
  =head1 SYNOPSIS
  
      use File::Zglob;
  
      my @files = zglob('**/*.{pm,pl}');
  
  =head1 DESCRIPTION
  
  B<WARNINGS: THIS IS ALPHA VERSION. API MAY CHANGE WITHOUT NOTICE>
  
  Provides a traditional Unix glob(3) functionality; returns a list of pathnames that matches the given pattern.
  
  File::Zglob provides extended glob. It supports C<< **/*.pm >> form.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item zglob($pattern) # => list of matched files
  
      my @files = zglob('**/*.[ch]');
  
  Unlike shell's glob, if there's no matching pathnames, () is returned.
  
  =back
  
  =head1 Special chars
  
  A glob pattern also consists of components and separator characters. In a component, following characters/syntax have special meanings.
  
  =over 4
  
  =item C<< * >>
  
  When it appears at the beginning of a component, it matches zero or more characters except a period (.). And it won't match if the component of the input string begins with a period.
  
  Otherwise, it matches zero or more sequence of any characters.
  
  =item C<< ** >>
  
  If a component is just **, it matches zero or more number of components that match *. For example, src/**/*.h matches all of the following patterns.
  
      src/*.h
      src/*/*.h
      src/*/*/*.h
      src/*/*/*/*.h
      ...
  
  =item C<< ? >>
  
  When it appears at the beginning of a component, it matches a character except a period (.). Otherwise, it matches any single character.
  
  =item C<< [chars] >>
  
  Specifies a character set. Matches any one of the set. The syntax of chars is the same as perl's character set syntax. 
  
  =item C<< {pm,pl} >>
  
  There is alternation.
  
  "example.{foo,bar,baz}" matches "example.foo", "example.bar", and "example.baz"
  
  =back
  
  =head1 zglob and deep recursion
  
  C<< **/* >> form makes deep recursion by soft link. zglob throw exception if it's deep recursion.
  
  =head1 PORTABILITY
  
  =over 4
  
  =item Win32
  
  Zglob supports Win32. zglob() only uses '/' as a path separator. Since zglob() accepts non-utf8 strings. CP932 contains '\' character as a second byte of multibyte chars.
  
  =back
  
  =head1 LIMITATIONS
  
  =over 4
  
  =item File order is not compatible with shells.
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno E<lt>tokuhirom AAJKLFJEF GMAIL COME<gt>
  
  =head1 THANKS TO
  
  Most code was translated from gauche's fileutil.scm.
  
  glob_to_regex function is taken from L<Text::Glob>.
  
  =head1 SEE ALSO
  
  L<File::DosGlob>, L<Text::Glob>, gauche's fileutil.scm
  
  =head1 LICENSE
  
  Copyright (C) Tokuhiro Matsuno
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
FILE_ZGLOB

$fatpacked{"Test/Requires/Scanner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_REQUIRES_SCANNER';
  package Test::Requires::Scanner;
  use 5.008001;
  use strict;
  use warnings;
  
  our $VERSION = "0.01";
  
  use Compiler::Lexer;
  
  use Test::Requires::Scanner::Constants;
  use Test::Requires::Scanner::Walker;
  use Test::Requires::Scanner::Result;
  
  sub scan_file {
      my ($class, $file) = @_;
  
      my $content = do {
          local $/;
          open my $fh, '<', $file or die $!;
          <$fh>;
      };
  
     $class->scan_string($content);
  }
  
  sub scan_files {
      my ($class, @files) = @_;
  
      my $result = Test::Requires::Scanner::Result->new;
  
      for my $file (@files) {
          my $ret = Test::Requires::Scanner->scan_file($file);
          $result->save_module($_, $ret->{$_}) for keys %$ret;
      }
  
      $result->modules;
  }
  
  sub scan_string {
      my ($class, $string) = @_;
  
      my $lexer = Compiler::Lexer->new;
      my $tokens = $lexer->tokenize($string);
  
      $class->scan_tokens($tokens);
  }
  
  sub scan_tokens {
      my ($class, $tokens) = @_;
  
      my $walker = Test::Requires::Scanner::Walker->new;
      my $result = Test::Requires::Scanner::Result->new;
      for my $token (@$tokens) {
          my $token_type = $token->{type};
  
          # For use statement
          if ($token_type == USE_DECL) {
              $walker->is_in_usedecl(1);
              $walker->is_prev_module_name(1);
              next;
          }
          if ($walker->is_in_usedecl) {
              # e.g.
              #   use Foo;
              if (
                  $token_type == USED_NAME ||  # e.g. use Foo
                  $token_type == SEMI_COLON    # End of declare of use statement
              ) {
                  $walker->reset;
                  next;
              }
  
              # e.g.
              #   use Foo::Bar;
              if ( ($token_type == NAMESPACE || $token_type == NAMESPACE_RESOLVER) && $walker->is_prev_module_name) {
                  $walker->{module_name} .= $token->{data};
                  if ($walker->module_name =~ /^Test(?:\:\:(?:Requires)?)?$/) {
                      $walker->is_prev_module_name(1);
                      $walker->is_in_test_requires($walker->module_name eq 'Test::Requires');
                  }
                  else {
                      $walker->reset;
                  }
                  next;
              }
  
              if (!$walker->module_name && !$walker->does_garbage_exist && _looks_like_version($token_type)) {
                  # For perl version
                  # e.g.
                  #   use 5.012;
                  $walker->reset;
                  next;
              }
  
              # Section for Test::Requires
              if ($walker->is_in_test_requires) {
                  $walker->is_prev_module_name(0);
  
                  # For qw() notation
                  # e.g.
                  #   use Test::Requires qw/Foo Bar/;
                  if ($token_type == REG_LIST) {
                      $walker->is_in_reglist(1);
                  }
                  elsif ($walker->is_in_reglist) {
                      # skip regdelim
                      if ($token_type == REG_EXP) {
                          for my $_module_name (split /\s+/, $token->{data}) {
                              $result->save_module($_module_name);
                          }
                          $walker->is_in_reglist(0);
                      }
                  }
  
                  # For simply list
                  # e.g.
                  #   use Test::Requires ('Foo', 'Bar');
                  elsif ($token_type == LEFT_PAREN) {
                      $walker->is_in_list(1);
                  }
                  elsif ($token_type == RIGHT_PAREN) {
                      $walker->is_in_list(0);
                  }
                  elsif ($walker->is_in_list) {
                      if ($token_type == STRING || $token_type == RAW_STRING) {
                          $result->save_module($token->{data});
                      }
                  }
  
                  # For braced list
                  # e.g.
                  #   use Test::Requires {'Foo' => 1, 'Bar' => 2};
                  elsif ($token_type == LEFT_BRACE ) {
                      $walker->is_in_hash(1);
                      $walker->hash_count(0);
                  }
                  elsif ($token_type == RIGHT_BRACE ) {
                      $walker->is_in_hash(0);
                  }
                  elsif ($walker->is_in_hash) {
                      if ( _is_string($token_type) || $token_type == KEY || _looks_like_version($token_type) ) {
                          $walker->{hash_count}++;
  
                          if ($walker->hash_count % 2) {
                              $walker->stashed_module($token->{data});
                          }
                          else {
                              # store version
                              $result->save_module($walker->stashed_module, $token->{data});
                              $walker->stashed_module('');
                          }
                      }
                  }
  
                  # For string
                  # e.g.
                  #   use Test::Requires "Foo"
                  elsif (_is_string($token_type)) {
                      $result->save_module($token->{data});
                  }
                  next;
              }
  
              if ($token_type != WHITESPACE) {
                  $walker->does_garbage_exist(1);
                  $walker->is_prev_module_name(0);
              }
              next;
          }
      }
  
      $result->modules;
  }
  
  
  sub _is_string {
      my $token_type = shift;
      $token_type == STRING || $token_type == RAW_STRING;
  }
  
  sub _looks_like_version {
      my $token_type = shift;
      $token_type == DOUBLE || $token_type == INT || $token_type == VERSION_STRING;
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Test::Requires::Scanner - retrieve modules specified by Test::Requires
  
  =head1 SYNOPSIS
  
      use Test::Requires::Scanner;
      my $modules2version_hashref = Test::Requires::Scanner->scan_files('t/hoge.t', 't/fuga.t');
  
  =head1 DESCRIPTION
  
  App::TestRequires::Scanner is to retrieve modules specified by L<Test::Requires> in
  test files. It is useful for CPAN module maintainer.
  
  =head2 METHODS
  
  =over
  
  =item C<< $hashref = Test::Requires::Scanner->scan_string($str) >>
  
  =item C<< $hashref = Test::Requires::Scanner->scan_file($file) >>
  
  =item C<< $hashref = Test::Requires::Scanner->scan_files(@files) >>
  
  A key of C<$hashref> is module name and a value is version.
  
  =back
  
  =head1 LICENSE
  
  Copyright (C) Songmu.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Songmu E<lt>y.songmu@gmail.comE<gt>
  
  =cut
  
TEST_REQUIRES_SCANNER

$fatpacked{"Test/Requires/Scanner/CLI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_REQUIRES_SCANNER_CLI';
  package Test::Requires::Scanner::CLI;
  use strict;
  use warnings;
  use utf8;
  
  use Test::Requires::Scanner;
  
  use File::Zglob;
  
  sub run {
      my @argv = @_;
  
      my @files = zglob('{t,xt}/**/*.t');
      my $result = Test::Requires::Scanner->scan_files(@files);
      print "$_\n" for sort keys %$result;
  }
  
  1;
TEST_REQUIRES_SCANNER_CLI

$fatpacked{"Test/Requires/Scanner/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_REQUIRES_SCANNER_CONSTANTS';
  package Test::Requires::Scanner::Constants;
  use strict;
  use warnings;
  
  use Compiler::Lexer::Constants;
  
  use Const::Common (
      NAMESPACE_RESOLVER => Compiler::Lexer::TokenType::T_NamespaceResolver,
      NAMESPACE          => Compiler::Lexer::TokenType::T_Namespace,
      SEMI_COLON         => Compiler::Lexer::TokenType::T_SemiColon,
      USE_DECL           => Compiler::Lexer::TokenType::T_UseDecl,
      USED_NAME          => Compiler::Lexer::TokenType::T_UsedName,
      REG_LIST           => Compiler::Lexer::TokenType::T_RegList,
      REG_EXP            => Compiler::Lexer::TokenType::T_RegExp,
      STRING             => Compiler::Lexer::TokenType::T_String,
      RAW_STRING         => Compiler::Lexer::TokenType::T_RawString,
      VERSION_STRING     => Compiler::Lexer::TokenType::T_VersionString,
      INT                => Compiler::Lexer::TokenType::T_Int,
      DOUBLE             => Compiler::Lexer::TokenType::T_Double,
      KEY                => Compiler::Lexer::TokenType::T_Key,
      WHITESPACE         => Compiler::Lexer::TokenType::T_WhiteSpace,
  
      LEFT_PAREN   => Compiler::Lexer::TokenType::T_LeftParenthesis,
      RIGHT_PAREN  => Compiler::Lexer::TokenType::T_RightParenthesis,
      LEFT_BRACE   => Compiler::Lexer::TokenType::T_LeftBrace,
      RIGHT_BRACE  => Compiler::Lexer::TokenType::T_RightBrace,
  );
  
  1;
TEST_REQUIRES_SCANNER_CONSTANTS

$fatpacked{"Test/Requires/Scanner/Result.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_REQUIRES_SCANNER_RESULT';
  package Test::Requires::Scanner::Result;
  use strict;
  use warnings;
  
  use version 0.77 ();
  
  use Class::Accessor::Lite (
      new => 1,
  );
  
  sub modules {
      shift->{modules} ||= {};
  }
  
  sub save_module {
      my ($self, $module, $version) = @_;
  
      if (exists $self->modules->{$module}) {
          return unless $version;
  
          my $stored_version = $self->modules->{$module};
  
          if (
              !$stored_version ||
              version->parse($version) > version->parse($stored_version)
          ) {
              $self->modules->{$module} = $version;
          }
      }
      else {
          $self->modules->{$module} = $version;
      }
  }
  
  1;
TEST_REQUIRES_SCANNER_RESULT

$fatpacked{"Test/Requires/Scanner/Walker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_REQUIRES_SCANNER_WALKER';
  package Test::Requires::Scanner::Walker;
  use strict;
  use warnings;
  
  use Class::Accessor::Lite (
      new => 1,
      rw  => [qw/
          module_name
          is_in_usedecl
          is_in_test_requires
          is_in_reglist
          is_prev_module_name
          is_in_list
          is_in_hash
          does_garbage_exist
          hash_count
          stashed_module
      /],
  );
  
  sub reset {
      my $self = shift;
  
      $self->module_name('');
      $self->stashed_module('');
  
      for my $accessor (qw/
          is_in_usedecl
          is_in_test_requires
          is_in_reglist
          is_prev_module_name
          is_in_list
          is_in_hash
          does_garbage_exist
          hash_count
      /) {
          $self->$accessor(0);
      }
  }
  
  1;
TEST_REQUIRES_SCANNER_WALKER

$fatpacked{"darwin-2level/Compiler/Lexer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_COMPILER_LEXER';
  package Compiler::Lexer;
  use strict;
  use warnings;
  use 5.008_001;
  use File::Find;
  use Compiler::Lexer::Token;
  use Compiler::Lexer::Constants;
  
  require Exporter;
  our @ISA = qw(Exporter);
  our %EXPORT_TAGS = ( 'all' => [ qw() ] );
  our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );
  our @EXPORT = qw();
  our $VERSION = '0.22';
  require XSLoader;
  XSLoader::load(__PACKAGE__, $VERSION);
  
  my $inc;
  
  sub new {
      my ($class, $args) = @_;
      my $options = +{};
      if (ref $args eq 'HASH') {
          $options = $args;
      } elsif (ref $args eq 'SCALAR') {
          $options->{filename} = $args;
      }
      $options->{filename} ||= '-';
      $options->{verbose}  ||= 0;
      return $class->_new($options);
  }
  
  sub set_library_path {
      my ($self, $_inc) = @_;
      $inc = $_inc;
  }
  
  sub load_module {
      my ($self, $name) = @_;
      $name =~ s|::|/|g;
      my @include_path = ($inc) ? @$inc : @INC;
      my $module_path = '';
      foreach my $path (@include_path) {
          next unless -e $path;
          find(sub {
              return if ($module_path);
              my $absolute_path = $File::Find::name;
              if ($absolute_path =~ "$name.pm") {
                  $module_path = $absolute_path;
              }
          }, $path);
          last if ($module_path);
      }
      return undef unless $module_path;
      open my $fh, '<', $module_path;
      return do { local $/; <$fh> };
  }
  
  sub recursive_tokenize {
      my ($self, $script) = @_;
      my %results;
      $self->__recursive_tokenize(\%results, $script);
      $results{main} = $self->tokenize($script);
      return \%results;
  }
  
  sub __recursive_tokenize {
      my ($self, $results, $script) = @_;
      my $modules = $self->get_used_modules($script);
      foreach my $module (@$modules) {
          my $name = $module->{name};
          next if (defined $results->{$name});
          $results->{$name} ||= [];
          my $code = $self->load_module($name);
          next unless ($code);
          $results->{$name} = $self->tokenize($code);
          $self->__recursive_tokenize($results, $code);
      }
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Compiler::Lexer - Lexical Analyzer for Perl5
  
  =head1 SYNOPSIS
  
    use Compiler::Lexer;
    use Data::Dumper;
  
    my $filename = $ARGV[0];
    open my $fh, '<', $filename or die "Cannot open $filename: $!";
    my $script = do { local $/; <$fh> };
  
    my $lexer = Compiler::Lexer->new($filename);
    my $tokens = $lexer->tokenize($script);
    print Dumper $tokens;
  
    my $modules = $lexer->get_used_modules($script);
    print Dumper $modules;
  
  =head1 METHODS
  
  =over 4
  
  =item my $lexer = Compiler::Lexer->new($options);
  
  create new instance.
  You can create object from $options in hash reference.
  
  B<options list>
  
  =over 4
  
  =item filename
  
  =item verbose : includes token of Pod, Comment and WhiteSpace
  
  =back
  
  =item $lexer->tokenize($script);
  
  get token objects includes parameter of 'name' or 'type' or 'line' and so on.
  This method requires perl source code in string.
  
  =item $lexer->set_library_path(['path1', 'path2' ...])
  
  set libraries path for reading recursively. Default paths are @INC.
  
  =item $lexer->recursive_tokenize($script)
  
  get hash reference like { 'module_nameA' => [], 'module_nameB' => [] ... }.
  This method requires per source code in string.
  
  =item $lexer->get_used_modules($script);
  
  get names of used module.
  This method requires perl source code in string.
  
  =back
  
  =head1 AUTHOR
  
  Masaaki Goshima (goccy) E<lt>goccy(at)cpan.orgE<gt>
  
  =head1 CONTRIBUTORS
  
  tokuhirom: Tokuhiro Matsuno
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright (c) 2013, Masaaki Goshima (goccy). All rights reserved.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_COMPILER_LEXER

$fatpacked{"darwin-2level/Compiler/Lexer/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_COMPILER_LEXER_CONSTANTS';
  use strict;
  use warnings;
  
  package Compiler::Lexer::TokenType;
  use constant {
      T_Return => 0,
      T_Add => 1,
      T_Sub => 2,
      T_Mul => 3,
      T_Div => 4,
      T_Mod => 5,
      T_ThreeTermOperator => 6,
      T_Greater => 7,
      T_Less => 8,
      T_StringAdd => 9,
      T_Ref => 10,
      T_Glob => 11,
      T_BitNot => 12,
      T_BitOr => 13,
      T_AlphabetOr => 14,
      T_BitAnd => 15,
      T_AlphabetAnd => 16,
      T_BitXOr => 17,
      T_AlphabetXOr => 18,
      T_StringMul => 19,
      T_AddEqual => 20,
      T_SubEqual => 21,
      T_MulEqual => 22,
      T_DivEqual => 23,
      T_ModEqual => 24,
      T_StringAddEqual => 25,
      T_LeftShiftEqual => 26,
      T_RightShiftEqual => 27,
      T_StringMulEqual => 28,
      T_GreaterEqual => 29,
      T_LessEqual => 30,
      T_EqualEqual => 31,
      T_Diamond => 32,
      T_Compare => 33,
      T_PolymorphicCompare => 34,
      T_RegOK => 35,
      T_RegNot => 36,
      T_NotEqual => 37,
      T_StringLess => 38,
      T_StringLessEqual => 39,
      T_StringGreater => 40,
      T_StringGreaterEqual => 41,
      T_StringEqual => 42,
      T_StringNotEqual => 43,
      T_StringCompare => 44,
      T_Inc => 45,
      T_Dec => 46,
      T_Exp => 47,
      T_PowerEqual => 48,
      T_DefaultEqual => 49,
      T_LeftShift => 50,
      T_RightShift => 51,
      T_And => 52,
      T_Or => 53,
      T_AndBitEqual => 54,
      T_OrBitEqual => 55,
      T_NotBitEqual => 56,
      T_OrEqual => 57,
      T_AndEqual => 58,
      T_Slice => 59,
      T_DefaultOperator => 60,
      T_ToDo => 61,
      T_VarDecl => 62,
      T_FunctionDecl => 63,
      T_Method => 64,
      T_Assign => 65,
      T_ArraySize => 66,
      T_Is => 67,
      T_Not => 68,
      T_AlphabetNot => 69,
      T_BuiltinFunc => 70,
      T_RequireDecl => 71,
      T_Import => 72,
      T_SpecificKeyword => 73,
      T_DataWord => 74,
      T_ModWord => 75,
      T_AUTOLOAD => 76,
      T_CORE => 77,
      T_DESTROY => 78,
      T_STDIN => 79,
      T_STDOUT => 80,
      T_STDERR => 81,
      T_Redo => 82,
      T_Next => 83,
      T_Last => 84,
      T_Goto => 85,
      T_Continue => 86,
      T_Do => 87,
      T_Break => 88,
      T_Handle => 89,
      T_LocalDecl => 90,
      T_OurDecl => 91,
      T_StateDecl => 92,
      T_UseDecl => 93,
      T_UsedName => 94,
      T_RequiredName => 95,
      T_IfStmt => 96,
      T_ElseStmt => 97,
      T_ElsifStmt => 98,
      T_UnlessStmt => 99,
      T_UntilStmt => 100,
      T_WhenStmt => 101,
      T_GivenStmt => 102,
      T_DefaultStmt => 103,
      T_Comma => 104,
      T_Colon => 105,
      T_SemiColon => 106,
      T_LeftParenthesis => 107,
      T_RightParenthesis => 108,
      T_LeftBrace => 109,
      T_RightBrace => 110,
      T_LeftBracket => 111,
      T_RightBracket => 112,
      T_ArrayDereference => 113,
      T_HashDereference => 114,
      T_ScalarDereference => 115,
      T_CodeDereference => 116,
      T_ShortScalarDereference => 117,
      T_ShortArrayDereference => 118,
      T_ShortHashDereference => 119,
      T_ShortCodeDereference => 120,
      T_ArraySizeDereference => 121,
      T_Key => 122,
      T_BareWord => 123,
      T_Arrow => 124,
      T_Pointer => 125,
      T_NamespaceResolver => 126,
      T_Namespace => 127,
      T_Package => 128,
      T_Class => 129,
      T_CallDecl => 130,
      T_CodeRef => 131,
      T_WhileStmt => 132,
      T_ForStmt => 133,
      T_ForeachStmt => 134,
      T_Annotation => 135,
      T_ArgumentArray => 136,
      T_SpecificValue => 137,
      T_ConstValue => 138,
      T_ProgramArgument => 139,
      T_LibraryDirectories => 140,
      T_Environment => 141,
      T_Include => 142,
      T_Signal => 143,
      T_RegOpt => 144,
      T_RegQuote => 145,
      T_RegDoubleQuote => 146,
      T_RegList => 147,
      T_RegExec => 148,
      T_RegDecl => 149,
      T_RegMatch => 150,
      T_RegDelim => 151,
      T_HandleDelim => 152,
      T_RegMiddleDelim => 153,
      T_RegAllReplace => 154,
      T_RegReplace => 155,
      T_RegReplaceFrom => 156,
      T_RegReplaceTo => 157,
      T_FieldDecl => 158,
      T_TypeRef => 159,
      T_LabelRef => 160,
      T_LocalVarDecl => 161,
      T_GlobalVarDecl => 162,
      T_MultiLocalVarDecl => 163,
      T_MultiGlobalVarDecl => 164,
      T_Prototype => 165,
      T_Var => 166,
      T_CodeVar => 167,
      T_ArrayVar => 168,
      T_HashVar => 169,
      T_Int => 170,
      T_Double => 171,
      T_String => 172,
      T_RawString => 173,
      T_ExecString => 174,
      T_VersionString => 175,
      T_HereDocumentTag => 176,
      T_HereDocumentRawTag => 177,
      T_HereDocumentExecTag => 178,
      T_HereDocumentBareTag => 179,
      T_RawHereDocument => 180,
      T_HereDocument => 181,
      T_HereDocumentEnd => 182,
      T_FormatDecl => 183,
      T_Format => 184,
      T_FormatEnd => 185,
      T_Object => 186,
      T_RegExp => 187,
      T_Array => 188,
      T_Hash => 189,
      T_Operator => 190,
      T_LocalVar => 191,
      T_LocalArrayVar => 192,
      T_LocalHashVar => 193,
      T_GlobalVar => 194,
      T_GlobalArrayVar => 195,
      T_GlobalHashVar => 196,
      T_ArrayRef => 197,
      T_HashRef => 198,
      T_ArrayAt => 199,
      T_HashAt => 200,
      T_ArraySet => 201,
      T_HashSet => 202,
      T_Function => 203,
      T_Call => 204,
      T_Argument => 205,
      T_List => 206,
      T_Default => 207,
      T_Pod => 208,
      T_Comment => 209,
      T_WhiteSpace => 210,
      T_Undefined => 211,
      T_PostDeref => 212,
      T_PostDerefStar => 213,
      T_PostDerefArraySliceOpenBracket => 214,
      T_PostDerefArraySliceCloseBracket => 215,
      T_PostDerefHashSliceOpenBrace => 216,
      T_PostDerefHashSliceCloseBrace => 217,
      T_PostDerefCodeOpenParen => 218,
      T_PostDerefCodeCloseParen => 219
  };
  
  package Compiler::Lexer::SyntaxType;
  use constant {
      T_Value => 0,
      T_Term => 1,
      T_Expr => 2,
      T_Stmt => 3,
      T_BlockStmt => 4
  };
  
  package Compiler::Lexer::Kind;
  use constant {
      T_Return => 0,
      T_Operator => 1,
      T_Assign => 2,
      T_Decl => 3,
      T_Function => 4,
      T_SingleTerm => 5,
      T_Import => 6,
      T_SpecificKeyword => 7,
      T_DataWord => 8,
      T_ModWord => 9,
      T_AUTOLOAD => 10,
      T_CORE => 11,
      T_DESTROY => 12,
      T_Handle => 13,
      T_Control => 14,
      T_Do => 15,
      T_Module => 16,
      T_Stmt => 17,
      T_DefaultStmt => 18,
      T_Comma => 19,
      T_Colon => 20,
      T_StmtEnd => 21,
      T_Symbol => 22,
      T_Modifier => 23,
      T_Term => 24,
      T_Namespace => 25,
      T_Package => 26,
      T_Class => 27,
      T_Annotation => 28,
      T_RegOpt => 29,
      T_RegPrefix => 30,
      T_RegReplacePrefix => 31,
      T_Ref => 32,
      T_Get => 33,
      T_Set => 34,
      T_Verbose => 35,
      T_Undefined => 36
  };
  
  1;
DARWIN-2LEVEL_COMPILER_LEXER_CONSTANTS

$fatpacked{"darwin-2level/Compiler/Lexer/Token.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_COMPILER_LEXER_TOKEN';
  package Compiler::Lexer::Token;
  use strict;
  use warnings;
  
  my $FIELDS = [qw/
      stype
      type
      kind
      line
      name
      data
      has_warnings
  /];
  
  {
      no strict 'refs';
      foreach my $field (@$FIELDS) {
          *{__PACKAGE__ . '::' . $field} = sub {
              my ($self, $value) = @_;
              return $self->{$field} unless defined $value;
              $self->{$field} = $value;
          };
      }
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =for stopwords stype
  
  =head1 NAME
  
  Compiler::Lexer::Token
  
  =head1 SYNOPSIS
  
  Compiler::Lexer::Token includes the following members.
  
  =over
  
  =item stype
  
  constant of Compiler::Lexer::SyntaxType
  
  =item type
  
  constant of Compiler::Lexer::TokenType
  
  =item kind
  
  constant of Compiler::Lexer::Kind
  
  =item name
  
  name of Compiler::Lexer::TokenType
  
  =item data
  
  raw data
  
  =item has_warnings
  
  flag of whether unknown keyword or not
  
  =back
  
  =head1 METHODS
  
  support simple get/set accessors like Class::Accessor::Fast
  
  example:
  
    my $type = $token->type;                            # get accessor
    $token->type(Compiler::Lexer::TokenType::T_RegExp); # set accessor
  
  =head1 AUTHOR
  
  Masaaki Goshima (goccy) E<lt>goccy(at)cpan.orgE<gt>
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright (c) 2013, Masaaki Goshima (goccy). All rights reserved.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_COMPILER_LEXER_TOKEN

$fatpacked{"darwin-2level/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_VERSION';
  #!perl -w
  package version;
  
  use 5.006002;
  use strict;
  use warnings::register;
  if ($] >= 5.015) {
      warnings::register_categories(qw/version/);
  }
  
  our $VERSION = 0.9924;
  our $CLASS = 'version';
  our (@ISA, $STRICT, $LAX);
  
  # !!!!Delete this next block completely when adding to Perl core!!!!
  {
      local $SIG{'__DIE__'};
      eval "use version::vxs $VERSION";
      if ( $@ ) { # don't have the XS version installed
  	eval "use version::vpp $VERSION"; # don't tempt fate
  	die "$@" if ( $@ );
  	push @ISA, "version::vpp";
  	local $^W;
  	*version::qv = \&version::vpp::qv;
  	*version::declare = \&version::vpp::declare;
  	*version::_VERSION = \&version::vpp::_VERSION;
  	*version::vcmp = \&version::vpp::vcmp;
  	*version::new = \&version::vpp::new;
  	*version::numify = \&version::vpp::numify;
  	*version::normal = \&version::vpp::normal;
  	if ($] >= 5.009000) {
  	    no strict 'refs';
  	    *version::stringify = \&version::vpp::stringify;
  	    *{'version::(""'} = \&version::vpp::stringify;
  	    *{'version::(<=>'} = \&version::vpp::vcmp;
  	    *{'version::(cmp'} = \&version::vpp::vcmp;
  	    *version::parse = \&version::vpp::parse;
  	}
      }
      else { # use XS module
  	push @ISA, "version::vxs";
  	local $^W;
  	*version::declare = \&version::vxs::declare;
  	*version::qv = \&version::vxs::qv;
  	*version::_VERSION = \&version::vxs::_VERSION;
  	*version::vcmp = \&version::vxs::VCMP;
  	*version::new = \&version::vxs::new;
  	*version::numify = \&version::vxs::numify;
  	*version::normal = \&version::vxs::normal;
  	if ($] >= 5.009000) {
  	    no strict 'refs';
  	    *version::stringify = \&version::vxs::stringify;
  	    *{'version::(""'} = \&version::vxs::stringify;
  	    *{'version::(<=>'} = \&version::vxs::VCMP;
  	    *{'version::(cmp'} = \&version::vxs::VCMP;
  	    *version::parse = \&version::vxs::parse;
  	}
      }
  }
  
  # avoid using Exporter
  require version::regex;
  *version::is_lax = \&version::regex::is_lax;
  *version::is_strict = \&version::regex::is_strict;
  *LAX = \$version::regex::LAX;
  *LAX_DECIMAL_VERSION = \$version::regex::LAX_DECIMAL_VERSION;
  *LAX_DOTTED_DECIMAL_VERSION = \$version::regex::LAX_DOTTED_DECIMAL_VERSION;
  *STRICT = \$version::regex::STRICT;
  *STRICT_DECIMAL_VERSION = \$version::regex::STRICT_DECIMAL_VERSION;
  *STRICT_DOTTED_DECIMAL_VERSION = \$version::regex::STRICT_DOTTED_DECIMAL_VERSION;
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	local $^W;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  
  1;
DARWIN-2LEVEL_VERSION

$fatpacked{"darwin-2level/version/regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_VERSION_REGEX';
  package version::regex;
  
  use strict;
  
  our $VERSION = 0.9924;
  
  #--------------------------------------------------------------------------#
  # Version regexp components
  #--------------------------------------------------------------------------#
  
  # Fraction part of a decimal version number.  This is a common part of
  # both strict and lax decimal versions
  
  my $FRACTION_PART = qr/\.[0-9]+/;
  
  # First part of either decimal or dotted-decimal strict version number.
  # Unsigned integer with no leading zeroes (except for zero itself) to
  # avoid confusion with octal.
  
  my $STRICT_INTEGER_PART = qr/0|[1-9][0-9]*/;
  
  # First part of either decimal or dotted-decimal lax version number.
  # Unsigned integer, but allowing leading zeros.  Always interpreted
  # as decimal.  However, some forms of the resulting syntax give odd
  # results if used as ordinary Perl expressions, due to how perl treats
  # octals.  E.g.
  #   version->new("010" ) == 10
  #   version->new( 010  ) == 8
  #   version->new( 010.2) == 82  # "8" . "2"
  
  my $LAX_INTEGER_PART = qr/[0-9]+/;
  
  # Second and subsequent part of a strict dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.
  # Limited to three digits to avoid overflow when converting to decimal
  # form and also avoid problematic style with excessive leading zeroes.
  
  my $STRICT_DOTTED_DECIMAL_PART = qr/\.[0-9]{1,3}/;
  
  # Second and subsequent part of a lax dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.  No
  # limit on the numerical value or number of digits, so there is the
  # possibility of overflow when converting to decimal form.
  
  my $LAX_DOTTED_DECIMAL_PART = qr/\.[0-9]+/;
  
  # Alpha suffix part of lax version number syntax.  Acts like a
  # dotted-decimal part.
  
  my $LAX_ALPHA_PART = qr/_[0-9]+/;
  
  #--------------------------------------------------------------------------#
  # Strict version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Strict decimal version number.
  
  our $STRICT_DECIMAL_VERSION =
      qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;
  
  # Strict dotted-decimal version number.  Must have both leading "v" and
  # at least three parts, to avoid confusion with decimal syntax.
  
  our $STRICT_DOTTED_DECIMAL_VERSION =
      qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;
  
  # Complete strict version number syntax -- should generally be used
  # anchored: qr/ \A $STRICT \z /x
  
  our $STRICT =
      qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  # Lax version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Lax decimal version number.  Just like the strict one except for
  # allowing an alpha suffix or allowing a leading or trailing
  # decimal-point
  
  our $LAX_DECIMAL_VERSION =
      qr/ $LAX_INTEGER_PART (?: $FRACTION_PART | \. )? $LAX_ALPHA_PART?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;
  
  # Lax dotted-decimal version number.  Distinguished by having either
  # leading "v" or at least three non-alpha parts.  Alpha part is only
  # permitted if there are at least two non-alpha parts. Strangely
  # enough, without the leading "v", Perl takes .1.2 to mean v0.1.2,
  # so when there is no "v", the leading part is optional
  
  our $LAX_DOTTED_DECIMAL_VERSION =
      qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;
  
  # Complete lax version number syntax -- should generally be used
  # anchored: qr/ \A $LAX \z /x
  #
  # The string 'undef' is a special case to make for easier handling
  # of return values from ExtUtils::MM->parse_version
  
  our $LAX =
      qr/ undef | $LAX_DOTTED_DECIMAL_VERSION | $LAX_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  
  # Preloaded methods go here.
  sub is_strict	{ defined $_[0] && $_[0] =~ qr/ \A $STRICT \z /x }
  sub is_lax	{ defined $_[0] && $_[0] =~ qr/ \A $LAX \z /x }
  
  1;
DARWIN-2LEVEL_VERSION_REGEX

$fatpacked{"darwin-2level/version/vpp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_VERSION_VPP';
  package charstar;
  # a little helper class to emulate C char* semantics in Perl
  # so that prescan_version can use the same code as in C
  
  use overload (
      '""'	=> \&thischar,
      '0+'	=> \&thischar,
      '++'	=> \&increment,
      '--'	=> \&decrement,
      '+'		=> \&plus,
      '-'		=> \&minus,
      '*'		=> \&multiply,
      'cmp'	=> \&cmp,
      '<=>'	=> \&spaceship,
      'bool'	=> \&thischar,
      '='		=> \&clone,
  );
  
  sub new {
      my ($self, $string) = @_;
      my $class = ref($self) || $self;
  
      my $obj = {
  	string  => [split(//,$string)],
  	current => 0,
      };
      return bless $obj, $class;
  }
  
  sub thischar {
      my ($self) = @_;
      my $last = $#{$self->{string}};
      my $curr = $self->{current};
      if ($curr >= 0 && $curr <= $last) {
  	return $self->{string}->[$curr];
      }
      else {
  	return '';
      }
  }
  
  sub increment {
      my ($self) = @_;
      $self->{current}++;
  }
  
  sub decrement {
      my ($self) = @_;
      $self->{current}--;
  }
  
  sub plus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} += $offset;
      return $rself;
  }
  
  sub minus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} -= $offset;
      return $rself;
  }
  
  sub multiply {
      my ($left, $right, $swapped) = @_;
      my $char = $left->thischar();
      return $char * $right;
  }
  
  sub spaceship {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	$right = $left->new($right);
      }
      return $left->{current} <=> $right->{current};
  }
  
  sub cmp {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	if (length($right) == 1) { # comparing single character only
  	    return $left->thischar cmp $right;
  	}
  	$right = $left->new($right);
      }
      return $left->currstr cmp $right->currstr;
  }
  
  sub bool {
      my ($self) = @_;
      my $char = $self->thischar;
      return ($char ne '');
  }
  
  sub clone {
      my ($left, $right, $swapped) = @_;
      $right = {
  	string  => [@{$left->{string}}],
  	current => $left->{current},
      };
      return bless $right, ref($left);
  }
  
  sub currstr {
      my ($self, $s) = @_;
      my $curr = $self->{current};
      my $last = $#{$self->{string}};
      if (defined($s) && $s->{current} < $last) {
  	$last = $s->{current};
      }
  
      my $string = join('', @{$self->{string}}[$curr..$last]);
      return $string;
  }
  
  package version::vpp;
  
  use 5.006002;
  use strict;
  use warnings::register;
  
  use Config;
  
  our $VERSION = 0.9924;
  our $CLASS = 'version::vpp';
  our ($LAX, $STRICT, $WARN_CATEGORY);
  
  if ($] > 5.015) {
      warnings::register_categories(qw/version/);
      $WARN_CATEGORY = 'version';
  } else {
      $WARN_CATEGORY = 'numeric';
  }
  
  require version::regex;
  *version::vpp::is_strict = \&version::regex::is_strict;
  *version::vpp::is_lax = \&version::regex::is_lax;
  *LAX = \$version::regex::LAX;
  *STRICT = \$version::regex::STRICT;
  
  use overload (
      '""'       => \&stringify,
      '0+'       => \&numify,
      'cmp'      => \&vcmp,
      '<=>'      => \&vcmp,
      'bool'     => \&vbool,
      '+'        => \&vnoop,
      '-'        => \&vnoop,
      '*'        => \&vnoop,
      '/'        => \&vnoop,
      '+='        => \&vnoop,
      '-='        => \&vnoop,
      '*='        => \&vnoop,
      '/='        => \&vnoop,
      'abs'      => \&vnoop,
  );
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	no warnings qw/redefine/;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  my $VERSION_MAX = 0x7FFFFFFF;
  
  # implement prescan_version as closely to the C version as possible
  use constant TRUE  => 1;
  use constant FALSE => 0;
  
  sub isDIGIT {
      my ($char) = shift->thischar();
      return ($char =~ /\d/);
  }
  
  sub isALPHA {
      my ($char) = shift->thischar();
      return ($char =~ /[a-zA-Z]/);
  }
  
  sub isSPACE {
      my ($char) = shift->thischar();
      return ($char =~ /\s/);
  }
  
  sub BADVERSION {
      my ($s, $errstr, $error) = @_;
      if ($errstr) {
  	$$errstr = $error;
      }
      return $s;
  }
  
  sub prescan_version {
      my ($s, $strict, $errstr, $sqv, $ssaw_decimal, $swidth, $salpha) = @_;
      my $qv          = defined $sqv          ? $$sqv          : FALSE;
      my $saw_decimal = defined $ssaw_decimal ? $$ssaw_decimal : 0;
      my $width       = defined $swidth       ? $$swidth       : 3;
      my $alpha       = defined $salpha       ? $$salpha       : FALSE;
  
      my $d = $s;
  
      if ($qv && isDIGIT($d)) {
  	goto dotted_decimal_version;
      }
  
      if ($d eq 'v') { # explicit v-string
  	$d++;
  	if (isDIGIT($d)) {
  	    $qv = TRUE;
  	}
  	else { # degenerate v-string
  	    # requires v1.2.3
  	    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	}
  
  dotted_decimal_version:
  	if ($strict && $d eq '0' && isDIGIT($d+1)) {
  	    # no leading zeros allowed
  	    return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	}
  
  	while (isDIGIT($d)) { 	# integer part
  	    $d++;
  	}
  
  	if ($d eq '.')
  	{
  	    $saw_decimal++;
  	    $d++; 		# decimal point
  	}
  	else
  	{
  	    if ($strict) {
  		# require v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	    else {
  		goto version_prescan_finish;
  	    }
  	}
  
  	{
  	    my $i = 0;
  	    my $j = 0;
  	    while (isDIGIT($d)) {	# just keep reading
  		$i++;
  		while (isDIGIT($d)) {
  		    $d++; $j++;
  		    # maximum 3 digits between decimal
  		    if ($strict && $j > 3) {
  			return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)");
  		    }
  		}
  		if ($d eq '_') {
  		    if ($strict) {
  			return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		    }
  		    if ( $alpha ) {
  			return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		    }
  		    $d++;
  		    $alpha = TRUE;
  		}
  		elsif ($d eq '.') {
  		    if ($alpha) {
  			return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		    }
  		    $saw_decimal++;
  		    $d++;
  		}
  		elsif (!isDIGIT($d)) {
  		    last;
  		}
  		$j = 0;
  	    }
  
  	    if ($strict && $i < 2) {
  		# requires v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	}
      } 					# end if dotted-decimal
      else
      {					# decimal versions
  	my $j = 0;
  	# special $strict case for leading '.' or '0'
  	if ($strict) {
  	    if ($d eq '.') {
  		return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)");
  	    }
  	    if ($d eq '0' && isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	    }
  	}
  
  	# and we never support negative version numbers
  	if ($d eq '-') {
  	    return BADVERSION($s,$errstr,"Invalid version format (negative version number)");
  	}
  
  	# consume all of the integer part
  	while (isDIGIT($d)) {
  	    $d++;
  	}
  
  	# look for a fractional part
  	if ($d eq '.') {
  	    # we found it, so consume it
  	    $saw_decimal++;
  	    $d++;
  	}
  	elsif (!$d || $d eq ';' || isSPACE($d) || $d eq '}') {
  	    if ( $d == $s ) {
  		# found nothing
  		return BADVERSION($s,$errstr,"Invalid version format (version required)");
  	    }
  	    # found just an integer
  	    goto version_prescan_finish;
  	}
  	elsif ( $d == $s ) {
  	    # didn't find either integer or period
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  	elsif ($d eq '_') {
  	    # underscore can't come after integer part
  	    if ($strict) {
  		return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  	    }
  	    elsif (isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)");
  	    }
  	    else {
  		return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  	    }
  	}
  	elsif ($d) {
  	    # anything else after integer part is just invalid data
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  
  	# scan the fractional part after the decimal point
  	if ($d && !isDIGIT($d) && ($strict || ! ($d eq ';' || isSPACE($d) || $d eq '}') )) {
  		# $strict or lax-but-not-the-end
  		return BADVERSION($s,$errstr,"Invalid version format (fractional part required)");
  	}
  
  	while (isDIGIT($d)) {
  	    $d++; $j++;
  	    if ($d eq '.' && isDIGIT($d-1)) {
  		if ($alpha) {
  		    return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		}
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')");
  		}
  		$d = $s; # start all over again
  		$qv = TRUE;
  		goto dotted_decimal_version;
  	    }
  	    if ($d eq '_') {
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		}
  		if ( $alpha ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		}
  		if ( ! isDIGIT($d+1) ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  		}
  		$width = $j;
  		$d++;
  		$alpha = TRUE;
  	    }
  	}
      }
  
  version_prescan_finish:
      while (isSPACE($d)) {
  	$d++;
      }
  
      if ($d && !isDIGIT($d) && (! ($d eq ';' || $d eq '}') )) {
  	# trailing non-numeric data
  	return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
      }
      if ($saw_decimal > 1 && ($d-1) eq '.') {
  	# no trailing period allowed
  	return BADVERSION($s,$errstr,"Invalid version format (trailing decimal)");
      }
  
      if (defined $sqv) {
  	$$sqv = $qv;
      }
      if (defined $swidth) {
  	$$swidth = $width;
      }
      if (defined $ssaw_decimal) {
  	$$ssaw_decimal = $saw_decimal;
      }
      if (defined $salpha) {
  	$$salpha = $alpha;
      }
      return $d;
  }
  
  sub scan_version {
      my ($s, $rv, $qv) = @_;
      my $start;
      my $pos;
      my $last;
      my $errstr;
      my $saw_decimal = 0;
      my $width = 3;
      my $alpha = FALSE;
      my $vinf = FALSE;
      my @av;
  
      $s = new charstar $s;
  
      while (isSPACE($s)) { # leading whitespace is OK
  	$s++;
      }
  
      $last = prescan_version($s, FALSE, \$errstr, \$qv, \$saw_decimal,
  	\$width, \$alpha);
  
      if ($errstr) {
  	# 'undef' is a special case and not an error
  	if ( $s ne 'undef') {
  	    require Carp;
  	    Carp::croak($errstr);
  	}
      }
  
      $start = $s;
      if ($s eq 'v') {
  	$s++;
      }
      $pos = $s;
  
      if ( $qv ) {
  	$$rv->{qv} = $qv;
      }
      if ( $alpha ) {
  	$$rv->{alpha} = $alpha;
      }
      if ( !$qv && $width < 3 ) {
  	$$rv->{width} = $width;
      }
  
      while (isDIGIT($pos) || $pos eq '_') {
  	$pos++;
      }
      if (!isALPHA($pos)) {
  	my $rev;
  
  	for (;;) {
  	    $rev = 0;
  	    {
    		# this is atoi() that delimits on underscores
    		my $end = $pos;
    		my $mult = 1;
  		my $orev;
  
  		#  the following if() will only be true after the decimal
  		#  point of a version originally created with a bare
  		#  floating point number, i.e. not quoted in any way
  		#
   		if ( !$qv && $s > $start && $saw_decimal == 1 ) {
  		    $mult *= 100;
   		    while ( $s < $end ) {
  			next if $s eq '_';
  			$orev = $rev;
   			$rev += $s * $mult;
   			$mult /= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version %d",
  					   $VERSION_MAX);
  			    $s = $end - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   			$s++;
  			if ( $s eq '_' ) {
  			    $s++;
  			}
   		    }
    		}
   		else {
   		    while (--$end >= $s) {
  			next if $end eq '_';
  			$orev = $rev;
   			$rev += $end * $mult;
   			$mult *= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version");
  			    $end = $s - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   		    }
   		}
    	    }
  
    	    # Append revision
  	    push @av, $rev;
  	    if ( $vinf ) {
  		$s = $last;
  		last;
  	    }
  	    elsif ( $pos eq '.' ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq '_' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq ',' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( isDIGIT($pos) ) {
  		$s = $pos;
  	    }
  	    else {
  		$s = $pos;
  		last;
  	    }
  	    if ( $qv ) {
  		while ( isDIGIT($pos) || $pos eq '_') {
  		    $pos++;
  		}
  	    }
  	    else {
  		my $digits = 0;
  		while ( ( isDIGIT($pos) || $pos eq '_' ) && $digits < 3 ) {
  		    if ( $pos ne '_' ) {
  			$digits++;
  		    }
  		    $pos++;
  		}
  	    }
  	}
      }
      if ( $qv ) { # quoted versions always get at least three terms
  	my $len = $#av;
  	#  This for loop appears to trigger a compiler bug on OS X, as it
  	#  loops infinitely. Yes, len is negative. No, it makes no sense.
  	#  Compiler in question is:
  	#  gcc version 3.3 20030304 (Apple Computer, Inc. build 1640)
  	#  for ( len = 2 - len; len > 0; len-- )
  	#  av_push(MUTABLE_AV(sv), newSViv(0));
  	#
  	$len = 2 - $len;
  	while ($len-- > 0) {
  	    push @av, 0;
  	}
      }
  
      # need to save off the current version string for later
      if ( $vinf ) {
  	$$rv->{original} = "v.Inf";
  	$$rv->{vinf} = 1;
      }
      elsif ( $s > $start ) {
  	$$rv->{original} = $start->currstr($s);
  	if ( $qv && $saw_decimal == 1 && $start ne 'v' ) {
  	    # need to insert a v to be consistent
  	    $$rv->{original} = 'v' . $$rv->{original};
  	}
      }
      else {
  	$$rv->{original} = '0';
  	push(@av, 0);
      }
  
      # And finally, store the AV in the hash
      $$rv->{version} = \@av;
  
      # fix RT#19517 - special case 'undef' as string
      if ($s eq 'undef') {
  	$s += 5;
      }
  
      return $s;
  }
  
  sub new {
      my $class = shift;
      unless (defined $class or $#_ > 1) {
  	require Carp;
  	Carp::croak('Usage: version::new(class, version)');
      }
  
      my $self = bless ({}, ref ($class) || $class);
      my $qv = FALSE;
  
      if ( $#_ == 1 ) { # must be CVS-style
  	$qv = TRUE;
      }
      my $value = pop; # always going to be the last element
  
      if ( ref($value) && eval('$value->isa("version")') ) {
  	# Can copy the elements directly
  	$self->{version} = [ @{$value->{version} } ];
  	$self->{qv} = 1 if $value->{qv};
  	$self->{alpha} = 1 if $value->{alpha};
  	$self->{original} = ''.$value->{original};
  	return $self;
      }
  
      if ( not defined $value or $value =~ /^undef$/ ) {
  	# RT #19517 - special case for undef comparison
  	# or someone forgot to pass a value
  	push @{$self->{version}}, 0;
  	$self->{original} = "0";
  	return ($self);
      }
  
  
      if (ref($value) =~ m/ARRAY|HASH/) {
  	require Carp;
  	Carp::croak("Invalid version format (non-numeric data)");
      }
  
      $value = _un_vstring($value);
  
      if ($Config{d_setlocale}) {
  	use POSIX qw/locale_h/;
  	use if $Config{d_setlocale}, 'locale';
  	my $currlocale = setlocale(LC_ALL);
  
  	# if the current locale uses commas for decimal points, we
  	# just replace commas with decimal places, rather than changing
  	# locales
  	if ( localeconv()->{decimal_point} eq ',' ) {
  	    $value =~ tr/,/./;
  	}
      }
  
      # exponential notation
      if ( $value =~ /\d+.?\d*e[-+]?\d+/ ) {
  	$value = sprintf("%.9f",$value);
  	$value =~ s/(0+)$//; # trim trailing zeros
      }
  
      my $s = scan_version($value, \$self, $qv);
  
      if ($s) { # must be something left over
  	warn(sprintf "Version string '%s' contains invalid data; "
  		   ."ignoring: '%s'", $value, $s);
      }
  
      return ($self);
  }
  
  *parse = \&new;
  
  sub numify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      my $alpha = $self->{alpha} || "";
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("%d.", $digit );
  
      if ($alpha and warnings::enabled()) {
  	warnings::warn($WARN_CATEGORY, 'alpha->numify() is lossy');
      }
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf("%03d", $digit);
      }
  
      if ( $len == 0 ) {
  	$string .= sprintf("000");
      }
  
      return $string;
  }
  
  sub normal {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
  
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("v%d", $digit );
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf(".%d", $digit);
      }
  
      if ( $len <= 2 ) {
  	for ( $len = 2 - $len; $len != 0; $len-- ) {
  	    $string .= sprintf(".%0d", 0);
  	}
      }
  
      return $string;
  }
  
  sub stringify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      return exists $self->{original}
      	? $self->{original}
  	: exists $self->{qv}
  	    ? $self->normal
  	    : $self->numify;
  }
  
  sub vcmp {
      my ($left,$right,$swap) = @_;
      my $class = ref($left);
      unless ( UNIVERSAL::isa($right, $class) ) {
  	$right = $class->new($right);
      }
  
      if ( $swap ) {
  	($left, $right) = ($right, $left);
      }
      unless (_verify($left)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      unless (_verify($right)) {
  	require Carp;
  	Carp::croak("Invalid version format");
      }
      my $l = $#{$left->{version}};
      my $r = $#{$right->{version}};
      my $m = $l < $r ? $l : $r;
      my $lalpha = $left->is_alpha;
      my $ralpha = $right->is_alpha;
      my $retval = 0;
      my $i = 0;
      while ( $i <= $m && $retval == 0 ) {
  	$retval = $left->{version}[$i] <=> $right->{version}[$i];
  	$i++;
      }
  
      # possible match except for trailing 0's
      if ( $retval == 0 && $l != $r ) {
  	if ( $l < $r ) {
  	    while ( $i <= $r && $retval == 0 ) {
  		if ( $right->{version}[$i] != 0 ) {
  		    $retval = -1; # not a match after all
  		}
  		$i++;
  	    }
  	}
  	else {
  	    while ( $i <= $l && $retval == 0 ) {
  		if ( $left->{version}[$i] != 0 ) {
  		    $retval = +1; # not a match after all
  		}
  		$i++;
  	    }
  	}
      }
  
      return $retval;
  }
  
  sub vbool {
      my ($self) = @_;
      return vcmp($self,$self->new("0"),1);
  }
  
  sub vnoop {
      require Carp;
      Carp::croak("operation not supported with version object");
  }
  
  sub is_alpha {
      my ($self) = @_;
      return (exists $self->{alpha});
  }
  
  sub qv {
      my $value = shift;
      my $class = $CLASS;
      if (@_) {
  	$class = ref($value) || $value;
  	$value = shift;
      }
  
      $value = _un_vstring($value);
      $value = 'v'.$value unless $value =~ /(^v|\d+\.\d+\.\d)/;
      my $obj = $CLASS->new($value);
      return bless $obj, $class;
  }
  
  *declare = \&qv;
  
  sub is_qv {
      my ($self) = @_;
      return (exists $self->{qv});
  }
  
  
  sub _verify {
      my ($self) = @_;
      if ( ref($self)
  	&& eval { exists $self->{version} }
  	&& ref($self->{version}) eq 'ARRAY'
  	) {
  	return 1;
      }
      else {
  	return 0;
      }
  }
  
  sub _is_non_alphanumeric {
      my $s = shift;
      $s = new charstar $s;
      while ($s) {
  	return 0 if isSPACE($s); # early out
  	return 1 unless (isALPHA($s) || isDIGIT($s) || $s =~ /[.-]/);
  	$s++;
      }
      return 0;
  }
  
  sub _un_vstring {
      my $value = shift;
      # may be a v-string
      if ( length($value) >= 1 && $value !~ /[,._]/
  	&& _is_non_alphanumeric($value)) {
  	my $tvalue;
  	if ( $] >= 5.008_001 ) {
  	    $tvalue = _find_magic_vstring($value);
  	    $value = $tvalue if length $tvalue;
  	}
  	elsif ( $] >= 5.006_000 ) {
  	    $tvalue = sprintf("v%vd",$value);
  	    if ( $tvalue =~ /^v\d+(\.\d+)*$/ ) {
  		# must be a v-string
  		$value = $tvalue;
  	    }
  	}
      }
      return $value;
  }
  
  sub _find_magic_vstring {
      my $value = shift;
      my $tvalue = '';
      require B;
      my $sv = B::svref_2object(\$value);
      my $magic = ref($sv) eq 'B::PVMG' ? $sv->MAGIC : undef;
      while ( $magic ) {
  	if ( $magic->TYPE eq 'V' ) {
  	    $tvalue = $magic->PTR;
  	    $tvalue =~ s/^v?(.+)$/v$1/;
  	    last;
  	}
  	else {
  	    $magic = $magic->MOREMAGIC;
  	}
      }
      $tvalue =~ tr/_//d;
      return $tvalue;
  }
  
  sub _VERSION {
      my ($obj, $req) = @_;
      my $class = ref($obj) || $obj;
  
      no strict 'refs';
      if ( exists $INC{"$class.pm"} and not %{"$class\::"} and $] >= 5.008) {
  	 # file but no package
  	require Carp;
  	Carp::croak( "$class defines neither package nor VERSION"
  	    ."--version check failed");
      }
  
      my $version = eval "\$$class\::VERSION";
      if ( defined $version ) {
  	local $^W if $] <= 5.008;
  	$version = version::vpp->new($version);
      }
  
      if ( defined $req ) {
  	unless ( defined $version ) {
  	    require Carp;
  	    my $msg =  $] < 5.006
  	    ? "$class version $req required--this is only version "
  	    : "$class does not define \$$class\::VERSION"
  	      ."--version check failed";
  
  	    if ( $ENV{VERSION_DEBUG} ) {
  		Carp::confess($msg);
  	    }
  	    else {
  		Carp::croak($msg);
  	    }
  	}
  
  	$req = version::vpp->new($req);
  
  	if ( $req > $version ) {
  	    require Carp;
  	    if ( $req->is_qv ) {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->normal, $version->normal)
  		);
  	    }
  	    else {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->stringify, $version->stringify)
  		);
  	    }
  	}
      }
  
      return defined $version ? $version->stringify : undef;
  }
  
  1; #this line is important and will help the module return a true value
DARWIN-2LEVEL_VERSION_VPP

$fatpacked{"darwin-2level/version/vxs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_VERSION_VXS';
  #!perl -w
  package version::vxs;
  
  use v5.10;
  use strict;
  
  our $VERSION = 0.9924;
  our $CLASS = 'version::vxs';
  our @ISA;
  
  eval {
      require XSLoader;
      local $^W; # shut up the 'redefined' warning for UNIVERSAL::VERSION
      XSLoader::load('version::vxs', $VERSION);
      1;
  } or do {
      require DynaLoader;
      push @ISA, 'DynaLoader'; 
      local $^W; # shut up the 'redefined' warning for UNIVERSAL::VERSION
      bootstrap version::vxs $VERSION;
  };
  
  # Preloaded methods go here.
  
  1;
DARWIN-2LEVEL_VERSION_VXS

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/Users/st21277/perl5/perlbrew/perls/perl-5.18.4/bin/perl
use strict;
use warnings;
use Test::Requires::Scanner::CLI;
Test::Requires::Scanner::CLI->run(@ARGV);

__END__

=head1 SYNOPSIS

    % scan-test-requires

=head1 DESCRIPTION

scan t/ and xt/ files and list the modules specified by Test::Requires.

=head1 AUTHORS

Masayuki Matsuki
