#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"IO/All.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL';
  use strict; use warnings;
  package IO::All;
  our $VERSION = '0.87';
  
  require Carp;
  # So one can use Carp::carp "$message" - without the parenthesis.
  sub Carp::carp;
  
  use IO::All::Base -base;
  
  use File::Spec();
  use Symbol();
  use Fcntl;
  use Cwd ();
  
  our @EXPORT = qw(io);
  
  #===============================================================================
  # Object creation and setup methods
  #===============================================================================
  my $autoload = {
      qw(
          touch file
  
          dir_handle dir
          All dir
          all_files dir
          All_Files dir
          all_dirs dir
          All_Dirs dir
          all_links dir
          All_Links dir
          mkdir dir
          mkpath dir
          next dir
  
          stdin stdio
          stdout stdio
          stderr stdio
  
          socket_handle socket
          accept socket
          shutdown socket
  
          readlink link
          symlink link
      )
  };
  
  # XXX - These should die if the given argument exists but is not a
  # link, dbm, etc.
  sub link  { require IO::All::Link;  goto &IO::All::Link::link; }
  sub dbm   { require IO::All::DBM;   goto &IO::All::DBM::dbm; }
  sub mldbm { require IO::All::MLDBM; goto &IO::All::MLDBM::mldbm; }
  
  sub autoload { my $self = shift; $autoload; }
  
  sub AUTOLOAD {
      my $self = shift;
      my $method = $IO::All::AUTOLOAD;
      $method =~ s/.*:://;
      my $pkg = ref($self) || $self;
      $self->throw(qq{Can't locate object method "$method" via package "$pkg"})
        if $pkg ne $self->_package;
      my $class = $self->_autoload_class($method);
      my $foo = "$self";
      bless $self, $class;
      $self->$method(@_);
  }
  
  sub _autoload_class {
      my $self = shift;
      my $method = shift;
      my $class_id = $self->autoload->{$method} || $method;
      my $ucfirst_class_name = 'IO::All::' . ucfirst($class_id);
      my $ucfirst_class_fn = "IO/All/" . ucfirst($class_id) . ".pm";
      return $ucfirst_class_name if $INC{$ucfirst_class_fn};
      return "IO::All::\U$class_id" if $INC{"IO/All/\U$class_id\E.pm"};
      require IO::All::Temp;
      if (eval "require $ucfirst_class_name; 1") {
          my $class = $ucfirst_class_name;
          my $return = $class->can('new')
          ? $class
          : do { # (OS X hack)
              my $value = $INC{$ucfirst_class_fn};
              delete $INC{$ucfirst_class_fn};
              $INC{"IO/All/\U$class_id\E.pm"} = $value;
              "IO::All::\U$class_id";
          };
          return $return;
      }
      elsif (eval "require IO::All::\U$class_id; 1") {
          return "IO::All::\U$class_id";
      }
      $self->throw("Can't find a class for method '$method'");
  }
  
  sub new {
      my $self = shift;
      my $package = ref($self) || $self;
      my $new = bless Symbol::gensym(), $package;
      $new->_package($package);
      $new->_copy_from($self) if ref($self);
      my $name = shift;
      return $name if UNIVERSAL::isa($name, 'IO::All');
      return $new->_init unless defined $name;
      return $new->handle($name)
        if UNIVERSAL::isa($name, 'GLOB') or ref(\ $name) eq 'GLOB';
      # WWW - link is first because a link to a dir returns true for
      # both -l and -d.
      return $new->link($name)	if -l $name;
      return $new->file($name)	if -f $name;
      return $new->dir($name)	if -d $name;
      return $new->$1($name)	if $name =~ /^([a-z]{3,8}):/;
      return $new->socket($name)	if $name =~ /^[\w\-\.]*:\d{1,5}$/;
      return $new->pipe($name)	if $name =~ s/^\s*\|\s*// or $name =~ s/\s*\|\s*$//;
      return $new->string		if $name eq '$';
      return $new->stdio		if $name eq '-';
      return $new->stderr		if $name eq '=';
      return $new->temp		if $name eq '?';
      $new->name($name);
      $new->_init;
  }
  
  sub _copy_from {
      my $self = shift;
      my $other = shift;
      for (keys(%{*$other})) {
          # XXX Need to audit exclusions here
          next if /^(_handle|io_handle|is_open)$/;
          *$self->{$_} = *$other->{$_};
      }
  }
  
  sub handle {
      my $self = shift;
      $self->_handle(shift) if @_;
      return $self->_init;
  }
  
  #===============================================================================
  # Overloading support
  #===============================================================================
  my $old_warn_handler = $SIG{__WARN__};
  $SIG{__WARN__} = sub {
      if ($_[0] !~ /^Useless use of .+ \(.+\) in void context/) {
          goto &$old_warn_handler if $old_warn_handler;
          warn(@_);
      }
  };
  
  use overload '""'  => '_overload_stringify';
  use overload '|'   => '_overload_bitwise_or';
  use overload '<<'  => '_overload_left_bitshift';
  use overload '>>'  => '_overload_right_bitshift';
  use overload '<'   => '_overload_less_than';
  use overload '>'   => '_overload_greater_than';
  use overload 'cmp' => '_overload_cmp';
  use overload '${}' => '_overload_string_deref';
  use overload '@{}' => '_overload_array_deref';
  use overload '%{}' => '_overload_hash_deref';
  use overload '&{}' => '_overload_code_deref';
  
  sub _overload_bitwise_or	{ shift->_overload_handler(@_, '|' ); }
  sub _overload_left_bitshift	{ shift->_overload_handler(@_, '<<'); }
  sub _overload_right_bitshift	{ shift->_overload_handler(@_, '>>'); }
  sub _overload_less_than		{ shift->_overload_handler(@_, '<' ); }
  sub _overload_greater_than	{ shift->_overload_handler(@_, '>' ); }
  sub _overload_string_deref	{ shift->_overload_handler(@_, '${}'); }
  sub _overload_array_deref	{ shift->_overload_handler(@_, '@{}'); }
  sub _overload_hash_deref	{ shift->_overload_handler(@_, '%{}'); }
  sub _overload_code_deref	{ shift->_overload_handler(@_, '&{}'); }
  
  sub _overload_handler {
      my ($self) = @_;
      my $method = $self->_get_overload_method(@_);
      $self->$method(@_);
  }
  
  my $op_swap = {
      '>' => '<', '>>' => '<<',
      '<' => '>', '<<' => '>>',
  };
  
  sub _overload_table {
      my $self = shift;
      (
          '* > *' => '_overload_any_to_any',
          '* < *' => '_overload_any_from_any',
          '* >> *' => '_overload_any_addto_any',
          '* << *' => '_overload_any_addfrom_any',
  
          '* < scalar' => '_overload_scalar_to_any',
          '* > scalar' => '_overload_any_to_scalar',
          '* << scalar' => '_overload_scalar_addto_any',
          '* >> scalar' => '_overload_any_addto_scalar',
      )
  };
  
  sub _get_overload_method {
      my ($self, $arg1, $arg2, $swap, $operator) = @_;
      if ($swap) {
          $operator = $op_swap->{$operator} || $operator;
      }
      my $arg1_type = $self->_get_argument_type($arg1);
      my $table1 = { $arg1->_overload_table };
  
      if ($operator =~ /\{\}$/) {
          my $key = "$operator $arg1_type";
          return $table1->{$key} || $self->_overload_undefined($key);
      }
  
      my $arg2_type = $self->_get_argument_type($arg2);
      my @table2 = UNIVERSAL::isa($arg2, "IO::All")
      ? ($arg2->_overload_table)
      : ();
      my $table = { %$table1, @table2 };
  
      my @keys = (
          "$arg1_type $operator $arg2_type",
          "* $operator $arg2_type",
      );
      push @keys, "$arg1_type $operator *", "* $operator *"
        unless $arg2_type =~ /^(scalar|array|hash|code|ref)$/;
  
      for (@keys) {
          return $table->{$_}
            if defined $table->{$_};
      }
  
      return $self->_overload_undefined($keys[0]);
  }
  
  sub _get_argument_type {
      my $self = shift;
      my $argument = shift;
      my $ref = ref($argument);
      return 'scalar' unless $ref;
      return 'code' if $ref eq 'CODE';
      return 'array' if $ref eq 'ARRAY';
      return 'hash' if $ref eq 'HASH';
      return 'ref' unless $argument->isa('IO::All');
      $argument->file
        if defined $argument->pathname and not $argument->type;
      return $argument->type || 'unknown';
  }
  
  sub _overload_cmp {
      my ($self, $other, $swap) = @_;
      $self = defined($self) ? $self.'' : $self;
      ($self, $other) = ($other, $self) if $swap;
      $self cmp $other;
  }
  
  sub _overload_stringify {
      my $self = shift;
      my $name = $self->pathname;
      return defined($name) ? $name : overload::StrVal($self);
  }
  
  sub _overload_undefined {
      my $self = shift;
      require Carp;
      my $key = shift;
      Carp::carp "Undefined behavior for overloaded IO::All operation: '$key'"
        if $^W;
      return '_overload_noop';
  }
  
  sub _overload_noop {
      my $self = shift;
      return;
  }
  
  sub _overload_any_addfrom_any {
      $_[1]->append($_[2]->all);
      $_[1];
  }
  
  sub _overload_any_addto_any {
      $_[2]->append($_[1]->all);
      $_[2];
  }
  
  sub _overload_any_from_any {
      $_[1]->close if $_[1]->is_file and $_[1]->is_open;
      $_[1]->print($_[2]->all);
      $_[1];
  }
  
  sub _overload_any_to_any {
      $_[2]->close if $_[2]->is_file and $_[2]->is_open;
      $_[2]->print($_[1]->all);
      $_[2];
  }
  
  sub _overload_any_to_scalar {
      $_[2] = $_[1]->all;
  }
  
  sub _overload_any_addto_scalar {
      $_[2] .= $_[1]->all;
      $_[2];
  }
  
  sub _overload_scalar_addto_any {
      $_[1]->append($_[2]);
      $_[1];
  }
  
  sub _overload_scalar_to_any {
      local $\;
      $_[1]->close if $_[1]->is_file and $_[1]->is_open;
      $_[1]->print($_[2]);
      $_[1];
  }
  
  #===============================================================================
  # Private Accessors
  #===============================================================================
  field '_package';
  field _strict => undef;
  field _layers => [];
  field _handle => undef;
  field _constructor => undef;
  field _partial_spec_class => undef;
  
  #===============================================================================
  # Public Accessors
  #===============================================================================
  chain block_size => 1024;
  chain errors => undef;
  field io_handle => undef;
  field is_open => 0;
  chain mode => undef;
  chain name => undef;
  chain perms => undef;
  chain separator => $/;
  field type => '';
  
  sub _spec_class {
     my $self = shift;
  
     my $ret = 'File::Spec';
     if (my $partial = $self->_partial_spec_class(@_)) {
        $ret .= '::' . $partial;
        eval "require $ret";
     }
  
     return $ret
  }
  
  sub pathname {my $self = shift; $self->name(@_) }
  
  #===============================================================================
  # Chainable option methods (write only)
  #===============================================================================
  option 'assert';
  option 'autoclose' => 1;
  option 'backwards';
  option 'chomp';
  option 'confess';
  option 'lock';
  option 'rdonly';
  option 'rdwr';
  option 'strict';
  
  #===============================================================================
  # IO::Handle proxy methods
  #===============================================================================
  proxy 'autoflush';
  proxy 'eof';
  proxy 'fileno';
  proxy 'stat';
  proxy 'tell';
  proxy 'truncate';
  
  #===============================================================================
  # IO::Handle proxy methods that open the handle if needed
  #===============================================================================
  proxy_open print => '>';
  proxy_open printf => '>';
  proxy_open sysread => O_RDONLY;
  proxy_open syswrite => O_CREAT | O_WRONLY;
  proxy_open seek => $^O eq 'MSWin32' ? '<' : '+<';
  proxy_open 'getc';
  
  #===============================================================================
  # Tie Interface
  #===============================================================================
  sub tie { my $self = shift; tie *$self, $self; }
  
  sub TIEHANDLE {
      return $_[0] if ref $_[0];
      my $class = shift;
      my $self = bless Symbol::gensym(), $class;
      $self->init(@_);
  }
  
  sub READLINE {
      goto &getlines if wantarray;
      goto &getline;
  }
  
  
  sub DESTROY {
      my $self = shift;
      no warnings;
      unless ( $] < 5.008 ) {
          untie *$self if tied *$self;
      }
      $self->close if $self->is_open;
  }
  
  sub BINMODE { my $self = shift; CORE::binmode *$self->io_handle; }
  
  {
      no warnings;
      *GETC   = \&getc;
      *PRINT  = \&print;
      *PRINTF = \&printf;
      *READ   = \&read;
      *WRITE  = \&write;
      *SEEK   = \&seek;
      *TELL   = \&getpos;
      *EOF    = \&eof;
      *CLOSE  = \&close;
      *FILENO = \&fileno;
  }
  
  #===============================================================================
  # File::Spec Interface
  #===============================================================================
  sub canonpath {
     my $self = shift;
     eval { Cwd::abs_path($self->pathname); 0 } ||
        File::Spec->canonpath($self->pathname)
  }
  
  sub catdir {
      my $self = shift;
      my @args = grep defined, $self->name, @_;
      $self->_constructor->()->dir(File::Spec->catdir(@args));
  }
  sub catfile {
      my $self = shift;
      my @args = grep defined, $self->name, @_;
      $self->_constructor->()->file(File::Spec->catfile(@args));
  }
  sub join	{ shift->catfile(@_); }
  sub curdir	{ shift->_constructor->()->dir(File::Spec->curdir); }
  sub devnull	{ shift->_constructor->()->file(File::Spec->devnull); }
  sub rootdir	{ shift->_constructor->()->dir(File::Spec->rootdir); }
  sub tmpdir	{ shift->_constructor->()->dir(File::Spec->tmpdir); }
  sub updir	{ shift->_constructor->()->dir(File::Spec->updir); }
  sub case_tolerant{File::Spec->case_tolerant; }
  sub is_absolute	{ File::Spec->file_name_is_absolute(shift->pathname); }
  sub path	{ my $self = shift; map { $self->_constructor->()->dir($_) } File::Spec->path; }
  sub splitpath	{ File::Spec->splitpath(shift->pathname); }
  sub splitdir	{ File::Spec->splitdir(shift->pathname); }
  sub catpath	{ my $self=shift; $self->_constructor->(File::Spec->catpath(@_)); }
  sub abs2rel	{ File::Spec->abs2rel(shift->pathname, @_); }
  sub rel2abs	{ File::Spec->rel2abs(shift->pathname, @_); }
  
  #===============================================================================
  # Public IO Action Methods
  #===============================================================================
  sub absolute {
      my $self = shift;
      $self->pathname(File::Spec->rel2abs($self->pathname))
        unless $self->is_absolute;
      $self->is_absolute(1);
      return $self;
  }
  
  sub all {
      my $self = shift;
      $self->_assert_open('<');
      local $/;
      my $all = $self->io_handle->getline;
      $self->_error_check;
      $self->_autoclose && $self->close;
      return $all;
  }
  
  sub append {
      my $self = shift;
      $self->_assert_open('>>');
      $self->print(@_);
  }
  
  sub appendln {
      my $self = shift;
      $self->_assert_open('>>');
      $self->println(@_);
  }
  
  sub binary {
      my $self = shift;
      CORE::binmode($self->io_handle) if $self->is_open;
      push @{$self->_layers}, ":raw";
      return $self;
  }
  
  sub binmode {
      my $self = shift;
      my $layer = shift;
      $self->_sane_binmode($layer) if $self->is_open;
      push @{$self->_layers}, $layer;
      return $self;
  }
  
  sub _sane_binmode {
      my ($self, $layer) = @_;
      $layer
      ? CORE::binmode($self->io_handle, $layer)
      : CORE::binmode($self->io_handle);
  }
  
  sub buffer {
      my $self = shift;
      if (not @_) {
          *$self->{buffer} = do {my $x = ''; \ $x}
            unless exists *$self->{buffer};
          return *$self->{buffer};
      }
      my $buffer_ref = ref($_[0]) ? $_[0] : \ $_[0];
      $$buffer_ref = '' unless defined $$buffer_ref;
      *$self->{buffer} = $buffer_ref;
      return $self;
  }
  
  sub clear {
      my $self = shift;
      my $buffer = *$self->{buffer};
      $$buffer = '';
      return $self;
  }
  
  sub close {
      my $self = shift;
      return unless $self->is_open;
      $self->is_open(0);
      my $io_handle = $self->io_handle;
      $self->io_handle(undef);
      $self->mode(undef);
      $io_handle->close(@_)
        if defined $io_handle;
      return $self;
  }
  
  sub empty {
      my $self = shift;
      my $message =
        "Can't call empty on an object that is neither file nor directory";
      $self->throw($message);
  }
  
  sub exists {my $self = shift; -e $self->pathname }
  
  sub getline {
      my $self = shift;
      return $self->getline_backwards
        if $self->_backwards;
      $self->_assert_open('<');
      my $line;
      {
          local $/ = @_ ? shift(@_) : $self->separator;
          $line = $self->io_handle->getline;
          chomp($line) if $self->_chomp and defined $line;
      }
      $self->_error_check;
      return $line if defined $line;
      $self->close if $self->_autoclose;
      return undef;
  }
  
  sub getlines {
      my $self = shift;
      return $self->getlines_backwards
        if $self->_backwards;
      $self->_assert_open('<');
      my @lines;
      {
          local $/ = @_ ? shift(@_) : $self->separator;
          @lines = $self->io_handle->getlines;
          if ($self->_chomp) {
              chomp for @lines;
          }
      }
      $self->_error_check;
      return @lines if @lines;
      $self->close if $self->_autoclose;
      return ();
  }
  
  sub is_dir	{ UNIVERSAL::isa(shift, 'IO::All::Dir');	}
  sub is_dbm	{ UNIVERSAL::isa(shift, 'IO::All::DBM');	}
  sub is_file	{ UNIVERSAL::isa(shift, 'IO::All::File');	}
  sub is_link	{ UNIVERSAL::isa(shift, 'IO::All::Link');	}
  sub is_mldbm	{ UNIVERSAL::isa(shift, 'IO::All::MLDBM');	}
  sub is_socket	{ UNIVERSAL::isa(shift, 'IO::All::Socket');	}
  sub is_stdio	{ UNIVERSAL::isa(shift, 'IO::All::STDIO');	}
  sub is_string	{ UNIVERSAL::isa(shift, 'IO::All::String');	}
  sub is_temp	{ UNIVERSAL::isa(shift, 'IO::All::Temp');	}
  sub length	{ length ${shift->buffer};			}
  
  sub open {
      my $self = shift;
      return $self if $self->is_open;
      $self->is_open(1);
      my ($mode, $perms) = @_;
      $self->mode($mode) if defined $mode;
      $self->mode('<') unless defined $self->mode;
      $self->perms($perms) if defined $perms;
      my @args;
      unless ($self->is_dir) {
          push @args, $self->mode;
          push @args, $self->perms if defined $self->perms;
      }
      if (defined $self->pathname and not $self->type) {
          $self->file;
          return $self->open(@args);
      }
      elsif (defined $self->_handle and
             not $self->io_handle->opened
            ) {
          # XXX Not tested
          $self->io_handle->fdopen($self->_handle, @args);
      }
      $self->_set_binmode;
  }
  
  sub println {
      my $self = shift;
      $self->print(map {/\n\z/ ? ($_) : ($_, "\n")} @_);
  }
  
  sub read {
      my $self = shift;
      $self->_assert_open('<');
      my $length = (@_ or $self->type eq 'dir')
      ? $self->io_handle->read(@_)
      : $self->io_handle->read(
          ${$self->buffer},
          $self->block_size,
          $self->length,
      );
      $self->_error_check;
      return $length || $self->_autoclose && $self->close && 0;
  }
  
  {
      no warnings;
      *readline = \&getline;
  }
  
  # deprecated
  sub scalar {
      my $self = shift;
      $self->all(@_);
  }
  
  sub slurp {
      my $self = shift;
      my $slurp = $self->all;
      return $slurp unless wantarray;
      my $separator = $self->separator;
      if ($self->_chomp) {
          local $/ = $separator;
          map {chomp; $_} split /(?<=\Q$separator\E)/, $slurp;
      }
      else {
          split /(?<=\Q$separator\E)/, $slurp;
      }
  }
  
  sub utf8 {
      my $self = shift;
      if ($] < 5.008) {
          die "IO::All -utf8 not supported on Perl older than 5.8";
      }
      $self->encoding('UTF-8');
      return $self;
  }
  
  sub _has_utf8 {
      grep { $_ eq ':encoding(UTF-8)' } @{shift->_layers}
  }
  
  sub encoding {
      my $self = shift;
      my $encoding = shift;
      if ($] < 5.008) {
          die "IO::All -encoding not supported on Perl older than 5.8";
      }
      die "No valid encoding string sent" if !$encoding;
      $self->_set_encoding($encoding) if $self->is_open and $encoding;
      push @{$self->_layers}, ":encoding($encoding)";
      return $self;
  }
  
  sub _set_encoding {
      my ($self, $encoding) = @_;
      return CORE::binmode($self->io_handle, ":encoding($encoding)");
  }
  
  sub write {
      my $self = shift;
      $self->_assert_open('>');
      my $length = @_
      ? $self->io_handle->write(@_)
      : $self->io_handle->write(${$self->buffer}, $self->length);
      $self->_error_check;
      $self->clear unless @_;
      return $length;
  }
  
  #===============================================================================
  # Implementation methods. Subclassable.
  #===============================================================================
  sub throw {
      my $self = shift;
      require Carp;
      ;
      return &{$self->errors}(@_)
        if $self->errors;
      return Carp::confess(@_)
        if $self->_confess;
      return Carp::croak(@_);
  }
  
  #===============================================================================
  # Private instance methods
  #===============================================================================
  sub _assert_dirpath {
      my $self = shift;
      my $dir_name = shift;
      return $dir_name if ((! CORE::length($dir_name)) or
        -d $dir_name or
        CORE::mkdir($dir_name, $self->perms || 0755) or
        do {
            require File::Path;
            File::Path::mkpath($dir_name, 0, $self->perms || 0755 );
        } or
        $self->throw("Can't make $dir_name"));
  }
  
  sub _assert_open {
      my $self = shift;
      return if $self->is_open;
      $self->file unless $self->type;
      return $self->open(@_);
  }
  
  sub _error_check {
      my $self = shift;
      my $saved_error = $!;
      return unless $self->io_handle->can('error');
      return unless $self->io_handle->error;
      $self->throw($saved_error);
  }
  
  sub _set_binmode {
      my $self = shift;
      $self->_sane_binmode($_) for @{$self->_layers};
      return $self;
  }
  
  #===============================================================================
  # Stat Methods
  #===============================================================================
  BEGIN {
      no strict 'refs';
      my @stat_fields = qw(
          device inode modes nlink uid gid device_id size atime mtime
          ctime blksize blocks
      );
      foreach my $stat_field_idx (0 .. $#stat_fields)
      {
          my $idx = $stat_field_idx;
          my $name = $stat_fields[$idx];
  
          *$name = sub {
              my $self = shift;
              return (stat($self->io_handle || $self->pathname))[$idx];
          };
      }
  }
  
IO_ALL

$fatpacked{"IO/All/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_BASE';
  use strict; use warnings;
  package IO::All::Base;
  
  use Fcntl;
  
  sub import {
      my $class = shift;
      my $flag = $_[0] || '';
      my $package = caller;
      no strict 'refs';
      if ($flag eq '-base') {
          push @{$package . "::ISA"}, $class;
          *{$package . "::$_"} = \&$_
            for qw'field const option chain proxy proxy_open';
      }
      elsif ($flag eq -mixin) {
          mixin_import(scalar(caller(0)), $class, @_);
      }
      else {
          my @flags = @_;
          for my $export (@{$class . '::EXPORT'}) {
              *{$package . "::$export"} = $export eq 'io'
              ? $class->_generate_constructor(@flags)
              : \&{$class . "::$export"};
          }
      }
  }
  
  sub _generate_constructor {
      my $class = shift;
      my (@flags, %flags, $key);
      for (@_) {
          if (s/^-//) {
              push @flags, $_;
              $flags{$_} = 1;
              $key = $_;
          }
          else {
              $flags{$key} = $_ if $key;
          }
      }
      my $constructor;
      $constructor = sub {
          my $self = $class->new(@_);
          for (@flags) {
              $self->$_($flags{$_});
          }
          $self->_constructor($constructor);
          return $self;
      }
  }
  
  sub _init {
      my $self = shift;
      $self->io_handle(undef);
      $self->is_open(0);
      return $self;
  }
  
  #===============================================================================
  # Closure generating functions
  #===============================================================================
  sub option {
      my $package = caller;
      my ($field, $default) = @_;
      $default ||= 0;
      field("_$field", $default);
      no strict 'refs';
      *{"${package}::$field"} =
        sub {
            my $self = shift;
            *$self->{"_$field"} = @_ ? shift(@_) : 1;
            return $self;
        };
  }
  
  sub chain {
      my $package = caller;
      my ($field, $default) = @_;
      no strict 'refs';
      *{"${package}::$field"} =
        sub {
            my $self = shift;
            if (@_) {
                *$self->{$field} = shift;
                return $self;
            }
            return $default unless exists *$self->{$field};
            return *$self->{$field};
        };
  }
  
  sub field {
      my $package = caller;
      my ($field, $default) = @_;
      no strict 'refs';
      return if defined &{"${package}::$field"};
      *{"${package}::$field"} =
        sub {
            my $self = shift;
            unless (exists *$self->{$field}) {
                *$self->{$field} =
                  ref($default) eq 'ARRAY' ? [] :
                  ref($default) eq 'HASH' ? {} :
                  $default;
            }
            return *$self->{$field} unless @_;
            *$self->{$field} = shift;
        };
  }
  
  sub const {
      my $package = caller;
      my ($field, $default) = @_;
      no strict 'refs';
      return if defined &{"${package}::$field"};
      *{"${package}::$field"} = sub { $default };
  }
  
  sub proxy {
      my $package = caller;
      my ($proxy) = @_;
      no strict 'refs';
      return if defined &{"${package}::$proxy"};
      *{"${package}::$proxy"} =
        sub {
            my $self = shift;
            my @return = $self->io_handle->$proxy(@_);
            $self->_error_check;
            wantarray ? @return : $return[0];
        };
  }
  
  sub proxy_open {
      my $package = caller;
      my ($proxy, @args) = @_;
      no strict 'refs';
      return if defined &{"${package}::$proxy"};
      my $method = sub {
          my $self = shift;
          $self->_assert_open(@args);
          my @return = $self->io_handle->$proxy(@_);
          $self->_error_check;
          wantarray ? @return : $return[0];
      };
      *{"$package\::$proxy"} =
      (@args and $args[0] eq '>') ?
      sub {
          my $self = shift;
          $self->$method(@_);
          return $self;
      }
      : $method;
  }
  
  sub mixin_import {
      my $target_class = shift;
      $target_class = caller(0)
        if $target_class eq 'mixin';
      my $mixin_class = shift
        or die "Nothing to mixin";
      eval "require $mixin_class";
      my $pseudo_class = CORE::join '-', $target_class, $mixin_class;
      my %methods = mixin_methods($mixin_class);
      no strict 'refs';
      no warnings;
      @{"$pseudo_class\::ISA"} = @{"$target_class\::ISA"};
      @{"$target_class\::ISA"} = ($pseudo_class);
      for (keys %methods) {
          *{"$pseudo_class\::$_"} = $methods{$_};
      }
  }
  
  sub mixin_methods {
      my $mixin_class = shift;
      no strict 'refs';
      my %methods = all_methods($mixin_class);
      map {
          $methods{$_}
            ? ($_, \ &{"$methods{$_}\::$_"})
            : ($_, \ &{"$mixin_class\::$_"})
      } (keys %methods);
  }
  
  sub all_methods {
      no strict 'refs';
      my $class = shift;
      my %methods = map {
          ($_, $class)
      } grep {
          defined &{"$class\::$_"} and not /^_/
      } keys %{"$class\::"};
      return (%methods);
  }
  
  1;
IO_ALL_BASE

$fatpacked{"IO/All/DBM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_DBM';
  use strict; use warnings;
  package IO::All::DBM;
  
  use IO::All::File -base;
  use Fcntl;
  
  field _dbm_list => [];
  field '_dbm_class';
  field _dbm_extra => [];
  
  sub dbm {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->_dbm_list([@_]);
      return $self;
  }
  
  sub _assert_open {
      my $self = shift;
      return $self->tied_file
        if $self->tied_file;
      $self->open;
  }
  
  sub assert_filepath {
      my $self = shift;
      $self->SUPER::assert_filepath(@_);
      if ($self->_rdonly and not -e $self->pathname) {
          my $rdwr = $self->_rdwr;
          $self->assert(0)->rdwr(1)->rdonly(0)->open;
          $self->close;
          $self->assert(1)->rdwr($rdwr)->rdonly(1);
      }
  }
  
  sub open {
      my $self = shift;
      $self->is_open(1);
      return $self->tied_file if $self->tied_file;
      $self->assert_filepath if $self->_assert;
      my $dbm_list = $self->_dbm_list;
      my @dbm_list = @$dbm_list ? @$dbm_list :
        (qw(DB_File GDBM_File NDBM_File ODBM_File SDBM_File));
      my $dbm_class;
      for my $module (@dbm_list) {
          (my $file = "$module.pm") =~ s{::}{/}g;
          if (defined $INC{$file} || eval "eval 'use $module; 1'") {
              $self->_dbm_class($module);
              last;
          }
      }
      $self->throw("No module available for IO::All DBM operation")
        unless defined $self->_dbm_class;
      my $mode = $self->_rdonly ? O_RDONLY : O_RDWR;
      if ($self->_dbm_class eq 'DB_File::Lock') {
          $self->_dbm_class->import;
          my $type = eval '$DB_HASH'; die $@ if $@;
          # XXX Not sure about this warning
          warn "Using DB_File::Lock in IO::All without the rdonly or rdwr method\n"
            if not ($self->_rdwr or $self->_rdonly);
          my $flag = $self->_rdwr ? 'write' : 'read';
          $mode = $self->_rdwr ? O_RDWR : O_RDONLY;
          $self->_dbm_extra([$type, $flag]);
      }
      $mode |= O_CREAT if $mode & O_RDWR;
      $self->mode($mode);
      $self->perms(0666) unless defined $self->perms;
      return $self->tie_dbm;
  }
  
  sub tie_dbm {
      my $self = shift;
      my $hash;
      my $filename = $self->name;
      my $db = tie %$hash, $self->_dbm_class, $filename, $self->mode, $self->perms,
          @{$self->_dbm_extra}
        or $self->throw("Can't open '$filename' as DBM file:\n$!");
      $self->add_utf8_dbm_filter($db)
        if $self->_has_utf8;
      $self->tied_file($hash);
  }
  
  sub add_utf8_dbm_filter {
      my $self = shift;
      my $db = shift;
      $db->filter_store_key(sub { utf8::encode($_) });
      $db->filter_store_value(sub { utf8::encode($_) });
      $db->filter_fetch_key(sub { utf8::decode($_) });
      $db->filter_fetch_value(sub { utf8::decode($_) });
  }
  
  1;
IO_ALL_DBM

$fatpacked{"IO/All/Dir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_DIR';
  use strict; use warnings;
  package IO::All::Dir;
  
  use Scalar::Util 'blessed';
  use File::Glob 'bsd_glob';
  use IO::All::Filesys -base;
  use IO::All -base;
  use IO::Dir;
  
  #===============================================================================
  const type => 'dir';
  option 'sort' => 1;
  chain filter => undef;
  option 'deep';
  field 'chdir_from';
  
  #===============================================================================
  sub dir {
      my $self = shift;
      my $had_prev = blessed($self) && $self->pathname;
  
      bless $self, __PACKAGE__ unless $had_prev;
      if (@_ && @_ > 1 || @_ && $had_prev) {
         $self->name(
             $self->_spec_class->catdir(
                 ($self->pathname ? ($self->pathname) : () ),
                 @_,
             )
         )
      } elsif (@_) {
         $self->name($_[0])
      }
      return $self->_init;
  }
  
  sub dir_handle {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->_handle(shift) if @_;
      return $self->_init;
  }
  
  #===============================================================================
  sub _assert_open {
      my $self = shift;
      return if $self->is_open;
      $self->open;
  }
  
  sub open {
      my $self = shift;
      $self->is_open(1);
      $self->_assert_dirpath($self->pathname)
        if $self->pathname and $self->_assert;
      my $handle = IO::Dir->new;
      $self->io_handle($handle);
      $handle->open($self->pathname)
        or $self->throw($self->open_msg);
      return $self;
  }
  
  sub open_msg {
      my $self = shift;
      my $name = defined $self->pathname
        ? " '" . $self->pathname . "'"
        : '';
      return qq{Can't open directory$name:\n$!};
  }
  
  sub exists { -d shift->pathname }
  
  #===============================================================================
  sub All {
      my $self = shift;
      $self->all(0);
  }
  
  sub all {
      my $self = shift;
      my $depth = @_ ? shift(@_) : $self->_deep ? 0 : 1;
      my $first = not @_;
      my @all;
      while (my $io = $self->next) {
          push @all, $io;
          push(@all, $io->all($depth - 1, 1))
            if $depth != 1 and $io->is_dir;
      }
      @all = grep {&{$self->filter}} @all
        if $self->filter;
      return @all unless $first and $self->_sort;
      return sort {$a->pathname cmp $b->pathname} @all;
  }
  
  sub All_Dirs {
      my $self = shift;
      $self->all_dirs(0);
  }
  
  sub all_dirs {
      my $self = shift;
      grep {$_->is_dir} $self->all(@_);
  }
  
  sub All_Files {
      my $self = shift;
      $self->all_files(0);
  }
  
  sub all_files {
      my $self = shift;
      grep {$_->is_file} $self->all(@_);
  }
  
  sub All_Links {
   my $self = shift;
   $self->all_links(0);
  }
  
  sub all_links {
      my $self = shift;
      grep {$_->is_link} $self->all(@_);
  }
  
  sub chdir {
      my $self = shift;
      require Cwd;
      $self->chdir_from(Cwd::cwd());
      CORE::chdir($self->pathname);
      return $self;
  }
  
  sub empty {
      my $self = shift;
      my $dh;
      opendir($dh, $self->pathname) or die;
      while (my $dir = readdir($dh)) {
         return 0 unless $dir =~ /^\.{1,2}$/;
      }
      return 1;
  }
  
  sub mkdir {
      my $self = shift;
      defined($self->perms)
      ? (CORE::mkdir($self->pathname, $self->perms) or die "mkdir failed: $!")
      : (CORE::mkdir($self->pathname) or die "mkdir failed: $!");
      return $self;
  }
  
  sub mkpath {
      my $self = shift;
      require File::Path;
      File::Path::mkpath($self->pathname, @_);
      return $self;
  }
  
  sub file {
      my ($self, @rest) = @_;
  
      return $self->_constructor->()->file($self->pathname, @rest)
  }
  
  sub next {
      my $self = shift;
      $self->_assert_open;
      my $name = $self->readdir;
      return unless defined $name;
      my $io = $self->_constructor->(File::Spec->catfile($self->pathname, $name));
      $io->absolute if $self->is_absolute;
      return $io;
  }
  
  sub readdir {
      my $self = shift;
      $self->_assert_open;
      if (wantarray) {
          my @return = grep {
              not /^\.{1,2}$/
          } $self->io_handle->read;
          $self->close;
          if ($self->_has_utf8) { utf8::decode($_) for (@return) }
          return @return;
      }
      my $name = '.';
      while ($name =~ /^\.{1,2}$/) {
          $name = $self->io_handle->read;
          unless (defined $name) {
              $self->close;
              return;
          }
      }
      if ($self->_has_utf8) { utf8::decode($name) }
      return $name;
  }
  
  sub rmdir {
      my $self = shift;
      rmdir $self->pathname;
  }
  
  sub rmtree {
      my $self = shift;
      require File::Path;
      File::Path::rmtree($self->pathname, @_);
  }
  
  sub glob {
     my ($self, @rest) = @_;
  
     map {;
        my $ret = $self->_constructor->($_);
        $ret->absolute if $self->is_absolute;
        $ret
     } bsd_glob $self->_spec_class->catdir( $self->pathname, @rest );
  }
  
  sub copy {
      my ($self, $new) = @_;
  
      require File::Copy::Recursive;
  
      File::Copy::Recursive::dircopy($self->name, $new)
          or die "failed to copy $self to $new: $!";
       $self->_constructor->($new)
  }
  
  sub DESTROY {
      my $self = shift;
      CORE::chdir($self->chdir_from)
        if $self->chdir_from;
        # $self->SUPER::DESTROY(@_);
  }
  
  #===============================================================================
  sub _overload_table {
      (
          '${} dir' => '_overload_as_scalar',
          '@{} dir' => '_overload_as_array',
          '%{} dir' => '_overload_as_hash',
      )
  }
  
  sub _overload_as_scalar {
      \ $_[1];
  }
  
  sub _overload_as_array {
      [ $_[1]->all ];
  }
  
  sub _overload_as_hash {
      +{
          map {
              (my $name = $_->pathname) =~ s/.*[\/\\]//;
              ($name, $_);
          } $_[1]->all
      };
  }
  
  1;
IO_ALL_DIR

$fatpacked{"IO/All/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_FILE';
  use strict; use warnings;
  package IO::All::File;
  
  use IO::All::Filesys -base;
  use IO::All -base;
  use IO::File;
  use File::Copy ();
  
  #===============================================================================
  const type => 'file';
  field tied_file => undef;
  
  #===============================================================================
  sub file {
      my $self = shift;
      bless $self, __PACKAGE__;
      # should we die here if $self->name is already set and there are args?
      if (@_ && @_ > 1) {
          $self->name( $self->_spec_class->catfile( @_ ) )
      } elsif (@_) {
          $self->name($_[0])
      }
      return $self->_init;
  }
  
  sub file_handle {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->_handle(shift) if @_;
      return $self->_init;
  }
  
  #===============================================================================
  sub assert_filepath {
      my $self = shift;
      my $name = $self->pathname
        or return;
      my $directory;
      (undef, $directory) = File::Spec->splitpath($self->pathname);
      $self->_assert_dirpath($directory);
  }
  
  sub assert_open_backwards {
      my $self = shift;
      return if $self->is_open;
      require File::ReadBackwards;
      my $file_name = $self->pathname;
      my $io_handle = File::ReadBackwards->new($file_name)
        or $self->throw("Can't open $file_name for backwards:\n$!");
      $self->io_handle($io_handle);
      $self->is_open(1);
  }
  
  sub _assert_open {
      my $self = shift;
      return if $self->is_open;
      $self->mode(shift) unless $self->mode;
      $self->open;
  }
  
  sub assert_tied_file {
      my $self = shift;
      return $self->tied_file || do {
          eval {require Tie::File};
          $self->throw("Tie::File required for file array operations:\n$@")
            if $@;
          my $array_ref = do { my @array; \@array };
          my $name = $self->pathname;
          my @options = $self->_rdonly ? (mode => O_RDONLY) : ();
          push @options, (recsep => $self->separator);
          tie @$array_ref, 'Tie::File', $name, @options;
          $self->throw("Can't tie 'Tie::File' to '$name':\n$!")
            unless tied @$array_ref;
          $self->tied_file($array_ref);
      };
  }
  
  sub open {
      my $self = shift;
      $self->is_open(1);
      $self->assert_filepath if $self->_assert;
      my ($mode, $perms) = @_;
      $self->mode($mode) if defined $mode;
      $self->mode('<') unless defined $self->mode;
      $self->perms($perms) if defined $perms;
      my @args = ($self->mode);
      push @args, $self->perms if defined $self->perms;
      if (defined $self->pathname) {
          $self->io_handle(IO::File->new);
          $self->io_handle->open($self->pathname, @args)
            or $self->throw($self->open_msg);
      }
      elsif (defined $self->_handle and
             not $self->io_handle->opened
            ) {
          # XXX Not tested
          $self->io_handle->fdopen($self->_handle, @args);
      }
      $self->set_lock;
      $self->_set_binmode;
  }
  
  sub exists { -f shift->pathname }
  
  my %mode_msg = (
      '>' => 'output',
      '<' => 'input',
      '>>' => 'append',
  );
  sub open_msg {
      my $self = shift;
      my $name = defined $self->pathname
        ? " '" . $self->pathname . "'"
        : '';
      my $direction = defined $mode_msg{$self->mode}
        ? ' for ' . $mode_msg{$self->mode}
        : '';
      return qq{Can't open file$name$direction:\n$!};
  }
  
  #===============================================================================
  sub copy {
      my ($self, $new) = @_;
  
      File::Copy::copy($self->name, $new)
          or die "failed to copy $self to $new: $!";
      $self->file($new)
  }
  
  sub close {
      my $self = shift;
      return unless $self->is_open;
      $self->is_open(0);
      my $io_handle = $self->io_handle;
      $self->unlock;
      $self->io_handle(undef);
      $self->mode(undef);
      if (my $tied_file = $self->tied_file) {
          if (ref($tied_file) eq 'ARRAY') {
              untie @$tied_file;
          }
          else {
              untie %$tied_file;
          }
          $self->tied_file(undef);
          return 1;
      }
      $io_handle->close(@_)
        if defined $io_handle;
      return $self;
  }
  
  sub empty {
      my $self = shift;
      -z $self->pathname;
  }
  
  sub filepath {
      my $self = shift;
      my ($volume, $path) = $self->splitpath;
      return File::Spec->catpath($volume, $path, '');
  }
  
  sub getline_backwards {
      my $self = shift;
      $self->assert_open_backwards;
      return $self->io_handle->readline;
  }
  
  sub getlines_backwards {
      my $self = shift;
      my @lines;
      while (defined (my $line = $self->getline_backwards)) {
          push @lines, $line;
      }
      return @lines;
  }
  
  sub head {
      my $self = shift;
      my $lines = shift || 10;
      my @return;
      $self->close;
  
      LINES:
      while ($lines--) {
          if (defined (my $l = $self->getline)) {
              push @return, $l;
          }
          else {
              last LINES;
          }
      }
  
      $self->close;
      return wantarray ? @return : join '', @return;
  }
  
  sub tail {
      my $self = shift;
      my $lines = shift || 10;
      my @return;
      $self->close;
      while ($lines--) {
          unshift @return, ($self->getline_backwards or last);
      }
      $self->close;
      return wantarray ? @return : join '', @return;
  }
  
  sub touch {
      my $self = shift;
      return $self->SUPER::touch(@_)
        if -e $self->pathname;
      return $self if $self->is_open;
      my $mode = $self->mode;
      $self->mode('>>')->open->close;
      $self->mode($mode);
      return $self;
  }
  
  sub unlink {
      my $self = shift;
      unlink $self->pathname;
  }
  
  #===============================================================================
  sub _overload_table {
      my $self = shift;
      (
          $self->SUPER::_overload_table(@_),
          'file > file' => '_overload_file_to_file',
          'file < file' => '_overload_file_from_file',
          '${} file' => '_overload_file_as_scalar',
          '@{} file' => '_overload_file_as_array',
          '%{} file' => '_overload_file_as_dbm',
      )
  }
  
  sub _overload_file_to_file {
      require File::Copy;
      File::Copy::copy($_[1]->pathname, $_[2]->pathname);
      $_[2];
  }
  
  sub _overload_file_from_file {
      require File::Copy;
      File::Copy::copy($_[2]->pathname, $_[1]->pathname);
      $_[1];
  }
  
  sub _overload_file_as_array {
      $_[1]->assert_tied_file;
  }
  
  sub _overload_file_as_dbm {
      $_[1]->dbm
        unless $_[1]->isa('IO::All::DBM');
      $_[1]->_assert_open;
  }
  
  sub _overload_file_as_scalar {
      my $scalar = $_[1]->scalar;
      return \$scalar;
  }
  
  1;
IO_ALL_FILE

$fatpacked{"IO/All/Filesys.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_FILESYS';
  use strict; use warnings;
  package IO::All::Filesys;
  
  use IO::All::Base -base;
  use Fcntl qw(:flock);
  
  my %spec_map = (
      unix  => 'Unix',
      win32 => 'Win32',
      vms   => 'VMS',
      mac   => 'Mac',
      os2   => 'OS2',
  );
  sub os {
      my ($self, $type) = @_;
  
      my ($v, $d, $f) = $self->_spec_class->splitpath($self->name);
      my @d = $self->_spec_class->splitdir($d);
  
      $self->_spec_class($spec_map{$type});
  
      $self->name( $self->_spec_class->catfile( @d, $f ) );
  
      return $self
  }
  
  sub exists { my $self = shift; -e $self->name }
  
  sub filename {
      my $self = shift;
      my $filename;
      (undef, undef, $filename) = $self->splitpath;
      return $filename;
  }
  
  sub ext {
     my $self = shift;
  
     return $1 if $self->filename =~ m/\.([^\.]+)$/
  }
  {
      no warnings 'once';
      *extension = \&ext;
  }
  
  sub mimetype {
     require File::MimeInfo;
     return File::MimeInfo::mimetype($_[0]->filename)
  }
  
  sub is_absolute {
      my $self = shift;
      return *$self->{is_absolute} = shift if @_;
      return *$self->{is_absolute}
        if defined *$self->{is_absolute};
      *$self->{is_absolute} = IO::All::is_absolute($self) ? 1 : 0;
  }
  
  sub is_executable { my $self = shift; -x $self->name }
  sub is_readable { my $self = shift; -r $self->name }
  sub is_writable { my $self = shift; -w $self->name }
  {
      no warnings 'once';
      *is_writeable = \&is_writable;
  }
  
  sub pathname {
      my $self = shift;
      return *$self->{pathname} = shift if @_;
      return *$self->{pathname} if defined *$self->{pathname};
      return $self->name;
  }
  
  sub relative {
      my $self = shift;
      if (my $base = $_[0]) {
         $self->pathname(File::Spec->abs2rel($self->pathname, $base))
      } elsif ($self->is_absolute) {
         $self->pathname(File::Spec->abs2rel($self->pathname))
      }
      $self->is_absolute(0);
      return $self;
  }
  
  sub rename {
      my $self = shift;
      my $new = shift;
      rename($self->name, "$new")
        ? UNIVERSAL::isa($new, 'IO::All')
          ? $new
          : $self->_constructor->($new)
        : undef;
  }
  
  sub set_lock {
      my $self = shift;
      return unless $self->_lock;
      my $io_handle = $self->io_handle;
      my $flag = $self->mode =~ /^>>?$/
      ? LOCK_EX
      : LOCK_SH;
      flock $io_handle, $flag;
  }
  
  sub stat {
      my $self = shift;
      return IO::All::stat($self, @_)
        if $self->is_open;
        CORE::stat($self->pathname);
  }
  
  sub touch {
      my $self = shift;
      $self->utime;
  }
  
  sub unlock {
      my $self = shift;
      flock $self->io_handle, LOCK_UN
        if $self->_lock;
  }
  
  sub utime {
      my $self = shift;
      my $atime = shift;
      my $mtime = shift;
      $atime = time unless defined $atime;
      $mtime = $atime unless defined $mtime;
      utime($atime, $mtime, $self->name);
      return $self;
  }
  
  1;
IO_ALL_FILESYS

$fatpacked{"IO/All/Link.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_LINK';
  use strict; use warnings;
  package IO::All::Link;
  
  use IO::All::File -base;
  
  const type => 'link';
  
  sub link {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->name(shift) if @_;
      $self->_init;
  }
  
  sub readlink {
      my $self = shift;
      $self->_constructor->(CORE::readlink($self->name));
  }
  
  sub symlink {
      my $self = shift;
      my $target = shift;
      $self->assert_filepath if $self->_assert;
      CORE::symlink($target, $self->pathname);
  }
  
  sub AUTOLOAD {
      my $self = shift;
      our $AUTOLOAD;
      (my $method = $AUTOLOAD) =~ s/.*:://;
      my $target = $self->target;
      unless ($target) {
          $self->throw("Can't call $method on symlink");
          return;
      }
      $target->$method(@_);
  }
  
  sub target {
      my $self = shift;
      return *$self->{target} if *$self->{target};
      my %seen;
      my $link = $self;
      my $new;
      while ($new = $link->readlink) {
          my $type = $new->type or return;
          last if $type eq 'file';
          last if $type eq 'dir';
          return unless $type eq 'link';
          return if $seen{$new->name}++;
          $link = $new;
      }
      *$self->{target} = $new;
  }
  
  sub exists { -l shift->pathname }
  
  1;
IO_ALL_LINK

$fatpacked{"IO/All/MLDBM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_MLDBM';
  use strict; use warnings;
  package IO::All::MLDBM;
  
  use IO::All::DBM -base;
  
  field _serializer => 'Data::Dumper';
  
  sub mldbm {
      my $self = shift;
      bless $self, __PACKAGE__;
      my ($serializer) = grep { /^(Storable|Data::Dumper|FreezeThaw)$/ } @_;
      $self->_serializer($serializer) if defined $serializer;
      my @dbm_list = grep { not /^(Storable|Data::Dumper|FreezeThaw)$/ } @_;
      $self->_dbm_list([@dbm_list]);
      return $self;
  }
  
  sub tie_dbm {
      my $self = shift;
      my $filename = $self->name;
      my $dbm_class = $self->_dbm_class;
      my $serializer = $self->_serializer;
      eval "use MLDBM qw($dbm_class $serializer)";
      $self->throw("Can't open '$filename' as MLDBM:\n$@") if $@;
      my $hash;
      my $db = tie %$hash, 'MLDBM', $filename, $self->mode, $self->perms,
          @{$self->_dbm_extra}
        or $self->throw("Can't open '$filename' as MLDBM file:\n$!");
      $self->add_utf8_dbm_filter($db)
        if $self->_has_utf8;
      $self->tied_file($hash);
  }
  
  1;
IO_ALL_MLDBM

$fatpacked{"IO/All/Pipe.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_PIPE';
  use strict; use warnings;
  package IO::All::Pipe;
  
  use IO::All -base;
  use IO::File;
  
  const type => 'pipe';
  
  sub pipe {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->name(shift) if @_;
      return $self->_init;
  }
  
  sub _assert_open {
      my $self = shift;
      return if $self->is_open;
      $self->mode(shift) unless $self->mode;
      $self->open;
  }
  
  sub open {
      my $self = shift;
      $self->is_open(1);
      require IO::Handle;
      $self->io_handle(IO::Handle->new)
        unless defined $self->io_handle;
      my $command = $self->name;
      $command =~ s/(^\||\|$)//;
      my $mode = shift || $self->mode || '<';
      my $pipe_mode =
        $mode eq '>' ? '|-' :
        $mode eq '<' ? '-|' :
        $self->throw("Invalid usage mode '$mode' for pipe");
      CORE::open($self->io_handle, $pipe_mode, $command);
      $self->_set_binmode;
  }
  
  my %mode_msg = (
      '>' => 'output',
      '<' => 'input',
      '>>' => 'append',
  );
  sub open_msg {
      my $self = shift;
      my $name = defined $self->name
        ? " '" . $self->name . "'"
        : '';
      my $direction = defined $mode_msg{$self->mode}
        ? ' for ' . $mode_msg{$self->mode}
        : '';
      return qq{Can't open pipe$name$direction:\n$!};
  }
  
  1;
IO_ALL_PIPE

$fatpacked{"IO/All/STDIO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_STDIO';
  use strict; use warnings;
  package IO::All::STDIO;
  
  use IO::All -base;
  use IO::File;
  
  const type => 'stdio';
  
  sub stdio {
      my $self = shift;
      bless $self, __PACKAGE__;
      return $self->_init;
  }
  
  sub stdin {
      my $self = shift;
      $self->open('<');
      return $self;
  }
  
  sub stdout {
      my $self = shift;
      $self->open('>');
      return $self;
  }
  
  sub stderr {
      my $self = shift;
      $self->open_stderr;
      return $self;
  }
  
  sub open {
      my $self = shift;
      $self->is_open(1);
      my $mode = shift || $self->mode || '<';
      my $fileno = $mode eq '>'
      ? fileno(STDOUT)
      : fileno(STDIN);
      $self->io_handle(IO::File->new);
      $self->io_handle->fdopen($fileno, $mode);
      $self->_set_binmode;
  }
  
  sub open_stderr {
      my $self = shift;
      $self->is_open(1);
      $self->io_handle(IO::File->new);
      $self->io_handle->fdopen(fileno(STDERR), '>') ? $self : 0;
  }
  
  # XXX Add overload support
  
  1;
IO_ALL_STDIO

$fatpacked{"IO/All/Socket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_SOCKET';
  use strict; use warnings;
  package IO::All::Socket;
  
  use IO::All -base;
  use IO::Socket;
  
  const type => 'socket';
  field _listen => undef;
  option 'fork';
  const domain_default => 'localhost';
  chain domain => undef;
  chain port => undef;
  proxy_open 'recv';
  proxy_open 'send';
  
  sub socket {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->name(shift) if @_;
      return $self->_init;
  }
  
  sub socket_handle {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->_handle(shift) if @_;
      return $self->_init;
  }
  
  sub accept {
      my $self = shift;
      use POSIX ":sys_wait_h";
      sub REAPER {
          while (waitpid(-1, WNOHANG) > 0) {}
          $SIG{CHLD} = \&REAPER;
      }
      local $SIG{CHLD};
      $self->_listen(1);
      $self->_assert_open;
      my $server = $self->io_handle;
      my $socket;
      while (1) {
          $socket = $server->accept;
          last unless $self->_fork;
          next unless defined $socket;
          $SIG{CHLD} = \&REAPER;
          my $pid = CORE::fork;
          $self->throw("Unable to fork for IO::All::accept")
            unless defined $pid;
          last unless $pid;
          close $socket;
          undef $socket;
      }
      close $server if $self->_fork;
      my $io = ref($self)->new->socket_handle($socket);
      $io->io_handle($socket);
      $io->is_open(1);
      return $io;
  }
  
  sub shutdown {
      my $self = shift;
      my $how = @_ ? shift : 2;
      my $handle = $self->io_handle;
      $handle->shutdown(2)
        if defined $handle;
  }
  
  sub _assert_open {
      my $self = shift;
      return if $self->is_open;
      $self->mode(shift) unless $self->mode;
      $self->open;
  }
  
  sub open {
      my $self = shift;
      return if $self->is_open;
      $self->is_open(1);
      $self->get_socket_domain_port;
      my @args = $self->_listen
      ? (
          LocalAddr => $self->domain,
          LocalPort => $self->port,
          Proto => 'tcp',
          Listen => 1,
          Reuse => 1,
      )
      : (
          PeerAddr => $self->domain,
          PeerPort => $self->port,
          Proto => 'tcp',
      );
      my $socket = IO::Socket::INET->new(@args)
        or $self->throw("Can't open socket");
      $self->io_handle($socket);
      $self->_set_binmode;
  }
  
  sub get_socket_domain_port {
      my $self = shift;
      my ($domain, $port);
      ($domain, $port) = split /:/, $self->name
        if defined $self->name;
      $self->domain($domain) unless defined $self->domain;
      $self->domain($self->domain_default) unless $self->domain;
      $self->port($port) unless defined $self->port;
      return $self;
  }
  
  sub _overload_table {
      my $self = shift;
      (
          $self->SUPER::_overload_table(@_),
          '&{} socket' => '_overload_socket_as_code',
      )
  }
  
  sub _overload_socket_as_code {
      my $self = shift;
      sub {
          my $coderef = shift;
          while ($self->is_open) {
              $_ = $self->getline;
              &$coderef($self);
          }
      }
  }
  
  sub _overload_any_from_any {
      my $self = shift;
      $self->SUPER::_overload_any_from_any(@_);
      $self->close;
  }
  
  sub _overload_any_to_any {
      my $self = shift;
      $self->SUPER::_overload_any_to_any(@_);
      $self->close;
  }
  
  1;
IO_ALL_SOCKET

$fatpacked{"IO/All/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_STRING';
  use strict; use warnings;
  package IO::All::String;
  
  use IO::All -base;
  
  const type => 'string';
  
  sub string_ref {
     my ($self, $ref) = @_;
  
     no strict 'refs';
     *$self->{ref} = $ref if exists $_[1];
  
     return *$self->{ref}
  }
  
  sub string {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->_init;
  }
  
  sub open {
      my $self = shift;
      my $str = '';
      my $ref = \$str;
      $self->string_ref($ref);
      open my $fh, '+<', $ref;
      $self->io_handle($fh);
      $self->_set_binmode;
      $self->is_open(1);
  }
  
  1;
IO_ALL_STRING

$fatpacked{"IO/All/Temp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_ALL_TEMP';
  use strict; use warnings;
  package IO::All::Temp;
  
  use IO::All::File -base;
  
  sub temp {
      my $self = shift;
      bless $self, __PACKAGE__;
      my $temp_file = IO::File::new_tmpfile()
        or $self->throw("Can't create temporary file");
      $self->io_handle($temp_file);
      $self->_error_check;
      $self->autoclose(0);
      $self->is_open(1);
      return $self;
  }
  
  1;
IO_ALL_TEMP

$fatpacked{"Mo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO';
  package Mo;
  $Mo::VERSION = '0.40';
  $VERSION='0.40';
  no warnings;my$M=__PACKAGE__.'::';*{$M.Object::new}=sub{my$c=shift;my$s=bless{@_},$c;my%n=%{$c.'::'.':E'};map{$s->{$_}=$n{$_}->()if!exists$s->{$_}}keys%n;$s};*{$M.import}=sub{import warnings;$^H|=1538;my($P,%e,%o)=caller.'::';shift;eval"no Mo::$_",&{$M.$_.::e}($P,\%e,\%o,\@_)for@_;return if$e{M};%e=(extends,sub{eval"no $_[0]()";@{$P.ISA}=$_[0]},has,sub{my$n=shift;my$m=sub{$#_?$_[0]{$n}=$_[1]:$_[0]{$n}};@_=(default,@_)if!($#_%2);$m=$o{$_}->($m,$n,@_)for sort keys%o;*{$P.$n}=$m},%e,);*{$P.$_}=$e{$_}for keys%e;@{$P.ISA}=$M.Object};
MO

$fatpacked{"Mo/Golf.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_GOLF';
  ##
  # name:      Mo::Golf
  # abstract:  Module for Compacting Mo Modules
  # author:    Ingy döt Net <ingy@ingy.net>
  # license:   perl
  # copyright: 2011
  # see:
  # - Mo
  
  use strict;
  use warnings;
  package Mo::Golf;
  
  our $VERSION='0.40';
  
  use PPI;
  
  # This is the mapping of common names to shorter forms that still make some
  # sense.
  my %short_names = (
      (
          map {($_, substr($_, 0, 1))}
          qw(
              args builder class default exports features
              generator import is_lazy method MoPKG name
              nonlazy_defaults options reftype self
          )
      ),
      build_subs => 'B',
      old_constructor => 'C',
      caller_pkg => 'P',
  );
  
  my %short_barewords = ( EAGERINIT => q{':E'}, NONLAZY => q{':N'} );
  
  my %hands_off = map {($_,1)} qw'&import *import';
  
  sub import {
      return unless @_ == 2 and $_[1] eq 'golf';
      binmode STDOUT;
      my $text = do { local $/; <> };
      print STDOUT golf( $text );
  };
  
  sub golf {
      my ( $text ) = @_;
  
      my $tree = PPI::Document->new( \$text );
  
      my %finder_subs = _finder_subs();
  
      my @order = qw( comments duplicate_whitespace whitespace trailing_whitespace );
  
      for my $name ( @order ) {
          my $elements = $tree->find( $finder_subs{$name} );
          die $@ if !defined $elements;
          $_->delete for @{ $elements || [] };
      }
  
      $tree->find( $finder_subs{$_} )
        for qw( del_superfluous_concat del_last_semicolon_in_block separate_version shorten_var_names shorten_barewords );
      die $@ if $@;
  
      for my $name ( 'double_semicolon' ) {
          my $elements = $tree->find( $finder_subs{$name} );
          die $@ if !defined $elements;
          $_->delete for @{ $elements || [] };
      }
  
      return $tree->serialize . "\n";
  }
  
  sub tok { "PPI::Token::$_[0]" }
  
  sub _finder_subs {
      return (
          comments => sub { $_[1]->isa( tok 'Comment' ) },
  
          duplicate_whitespace => sub {
              my ( $top, $current ) = @_;
              return 0 if !$current->isa( tok 'Whitespace' );
  
              $current->set_content(' ') if 1 < length $current->content;
  
              return 0 if !$current->next_token;
              return 0 if !$current->next_token->isa( tok 'Whitespace' );
              return 1;
          },
  
          whitespace => sub {
              my ( $top, $current ) = @_;
              return 0 if !$current->isa( tok 'Whitespace' );
              my $prev = $current->previous_token;
              my $next = $current->next_token;
  
              return 1 if $prev->isa( tok 'Number' ) and $next->isa( tok 'Operator' ) and $next->content =~ /^\W/; # my $P
              return 1 if $prev->isa( tok 'Word' )   and $next->isa( tok 'Operator' ) and $next->content =~ /^\W/; # my $P
              return 1 if $prev->isa( tok 'Symbol' ) and $next->isa( tok 'Operator' ) and $next->content =~ /^\W/; # $VERSION =  but not $v and
  
              return 1 if $prev->isa( tok 'Operator' ) and $next->isa( tok 'Quote::Single' ) and $next->content =~ /^\W/; # eq ''
              return 1 if $prev->isa( tok 'Operator' ) and $next->isa( tok 'Quote::Double' ) and $next->content =~ /^\W/; # eq ""
              return 1 if $prev->isa( tok 'Operator' ) and $next->isa( tok 'Symbol' )        and $next->content =~ /^\W/; # eq $v
              return 1 if $prev->isa( tok 'Operator' ) and $next->isa( tok 'Structure' )     and $next->content =~ /^\W/; # eq (
  
              return 1 if $prev->isa( tok 'Word' )       and $next->isa( tok 'Symbol' );           # my $P
              return 1 if $prev->isa( tok 'Word' )       and $next->isa( tok 'Structure' );        # sub {
              return 1 if $prev->isa( tok 'Word' )       and $next->isa( tok 'Quote::Double' );    # eval "
              return 1 if $prev->isa( tok 'Symbol' )     and $next->isa( tok 'Structure' );        # %a )
              return 1 if $prev->isa( tok 'ArrayIndex' ) and $next->isa( tok 'Operator' );         # $#_ ?
              return 1 if $prev->isa( tok 'Word' )       and $next->isa( tok 'Cast' );             # exists &$_
              return 0;
          },
  
          trailing_whitespace => sub {
              my ( $top, $current ) = @_;
              return 0 if !$current->isa( tok 'Whitespace' );
              my $prev = $current->previous_token;
  
              return 1 if $prev->isa( tok 'Structure' );                                           # ;[\n\s]
              return 1 if $prev->isa( tok 'Operator' ) and $prev->content =~ /\W$/;                # = 0.24
              return 1 if $prev->isa( tok 'Quote::Double' );                                       # " .
              return 1 if $prev->isa( tok 'Quote::Single' );                                       # ' }
  
              return 0;
          },
  
          double_semicolon => sub {
              my ( $top, $current ) = @_;
              return 0 if !$current->isa( tok 'Structure' );
              return 0 if $current->content ne ';';
  
              my $prev = $current->previous_token;
  
              return 0 if !$prev->isa( tok 'Structure' );
              return 0 if $prev->content ne ';';
  
              return 1;
          },
  
          del_last_semicolon_in_block => sub {
              my ( $top, $current ) = @_;
              return 0 if !$current->isa( 'PPI::Structure::Block' );
  
              my $last = $current->last_token;
  
              return 0 if !$last->isa( tok 'Structure' );
              return 0 if $last->content ne '}';
  
              my $maybe_semi = $last->previous_token;
  
              return 0 if !$maybe_semi->isa( tok 'Structure' );
              return 0 if $maybe_semi->content ne ';';
  
              $maybe_semi->delete;
  
              return 1;
          },
  
          del_superfluous_concat => sub {
              my ( $top, $current ) = @_;
              return 0 if !$current->isa( tok 'Operator' );
  
              my $prev = $current->previous_token;
              my $next = $current->next_token;
  
              return 0 if $current->content ne '.';
              return 0 if !$prev->isa( tok 'Quote::Double' );
              return 0 if !$next->isa( tok 'Quote::Double' );
  
              $current->delete;
              $prev->set_content( $prev->{separator} . $prev->string . $next->string . $prev->{separator} );
              $next->delete;
  
              return 1;
          },
  
          separate_version => sub {
              my ( $top, $current ) = @_;
              return 0 if !$current->isa( 'PPI::Statement' );
  
              my $first = $current->first_token;
              return 0 if $first->content ne '$VERSION';
  
              $current->$_( PPI::Token::Whitespace->new( "\n" ) ) for qw( insert_before insert_after );
  
              return 1;
          },
  
          shorten_var_names => sub {
              my ( $top, $current ) = @_;
              return 0 if !$current->isa( tok 'Symbol' );
  
              my $long_name = $current->canonical;
  
              return 1 if $hands_off{$long_name};
              (my $name = $long_name) =~ s/^([\$\@\%])// or die $long_name;
              my $sigil = $1;
              die "variable $long_name conflicts with shortened var name"
                  if grep {
                      $name eq $_
                  } values %short_names;
  
              my $short_name = $short_names{$name};
              $current->set_content( "$sigil$short_name" ) if $short_name;
  
              return 1;
          },
  
          shorten_barewords => sub {
              my ( $top, $current ) = @_;
              return 0 if !$current->isa( tok 'Word' );
  
              my $name = $current->content;
  
              die "bareword $name conflicts with shortened bareword"
                  if grep {
                      $name eq $_
                  } values %short_barewords;
  
              my $short_name = $short_barewords{$name};
              $current->set_content( $short_name ) if $short_name;
  
              return 1;
          },
      );
  }
  
  =head1 SYNOPSIS
  
      perl -MMo::Golf=golf < src/Mo/foo.pm > lib/Mo/foo.pm
  
  =head1 DESCRIPTION
  
  This is the module that is responsible for taking Mo code (which is
  documented and fairly readable) and reducing it to a single undecipherable
  line.
MO_GOLF

$fatpacked{"Mo/Inline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_INLINE';
  ##
  # name:      Mo::Inline
  # abstract:  Inline Mo and Features into your package
  # author:    Ingy döt Net <ingy@ingy.net>
  # license:   perl
  # copyright: 2011
  # see:
  # - Mo
  
  package Mo::Inline;
  use Mo;
  
  our $VERSION='0.40';
  
  use IO::All;
  
  my $matcher = qr/((?m:^#\s*use Mo(\s.*)?;.*\n))(?:#.*\n)*(?:.{400,}\n)?/;
  
  sub run {
      my $self = shift;
      my @files;
      if (not @_ and -d 'lib') {
          print "Searching the 'lib' directory for a Mo to inline:\n";
          @_ = 'lib';
      }
      if (not @_ or @_ == 1 and $_[0] =~ /^(?:-\?|-h|--help)$/) {
          print usage();
          return 0;
      }
      for my $name (@_) {
          die "No file or directory called '$name'"
              unless -e $name;
          die "'$name' is not a Perl module"
              if -f $name and $name !~ /\.pm$/;
          if (-f $name) {
              push @files, $name;
          }
          elsif (-d $name) {
              push @_, grep /\.pm$/, map { "$_" } io($name)->All_Files;
          }
      }
  
      die "No .pm files specified"
          unless @files;
  
      for my $file (@files) {
          my $text = io($file)->all;
          if ($text !~ $matcher) {
              print "Ignoring $file - No Mo to Inline!\n";
              next;
          }
          $self->inline($file, 1);
      }
  }
  
  sub inline {
      my ($self, $file, $noisy) = @_;
      my $text = io($file)->all;
      $text =~ s/$matcher/"$1" . &inliner($2)/eg;
      io($file)->print($text);
      print "Mo Inlined $file\n"
          if $noisy;
  }
  
  sub inliner {
      my $mo = shift;
      require Mo;
      my @features = grep {$_ ne 'qw'} ($mo =~ /(\w+)/g);
      for (@features) {
          eval "require Mo::$_; 1" or die $@;
      }
      my $inline = '';
      $inline .= $_ for map {
          my $module = $_;
          $module .= '.pm';
          my @lines = io($INC{$module})->chomp->getlines;
          $lines[-1];
      } ('Mo', map { s!::!/!g; "Mo/$_" } @features);
      return <<"...";
  #   The following line of code was produced from the previous line by
  #   Mo::Inline version $VERSION
  $inline\@f=qw[@features];use strict;use warnings;
  ...
  }
  
  sub usage {
      <<'...';
  Usage: mo-linline <perl module files or directories>
  
  ...
  }
  
  1;
  
  =head1 SYNOPSIS
  
  In your Mo module:
  
      # This is effectively your own private Mo(ose) setup
      package MyModule::Mo;
      # use Mo qw'build builder default import';
      1;
  
  From the command line:
  
      > mo-inline lib/MyModule/Mo.pm
  
  or:
  
      > mo-inline lib/
  
  or (if you are really lazy):
  
      > mo-inline
  
  Then from another module:
  
      package MyModule::Foo;
      use MyModule::Mo;       # gets build, builder and default automatically
  
  =head1 DESCRIPTION
  
  Mo is so small that you can easily inline it, along with any feature modules.
  Mo provides a script called C<mo-inline> that will do it for you.
  
  All you need to do is comment out the line that uses Mo, and run C<mo-inline>
  on the file. C<mo-inline> will find such comments and do the inlining for you.
  It will also replace any old inlined Mo with the latest version.
  
  What Mo could you possibly want?
  
  =head1 AUTOMATIC FEATURES
  
  By using the L<Mo::import> feature, all uses of your Mo class will turn on all
  the features you specified. You can override it if you want, but that will be
  the default.
  
  =head1 REAL WORLD EXAMPLES
  
  For real world examples of Mo inlined using C<mo-inline>, see L<YAML::Mo>,
  L<Pegex::Mo> and L<TestML::Mo>.
MO_INLINE

$fatpacked{"Mo/Moose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_MOOSE';
  package Mo::Moose;
  $Mo::Moose::VERSION = '0.40';$M="Mo::";
  $VERSION='0.40';
  *{$M.'Moose::e'}=sub{my($P,$e)=@_;$P=~s/::$//;%$e=(M=>1);require Moose;Moose->import({into=>$P});Moose::Util::MetaRole::apply_metaroles(for=>$P,class_metaroles=>{attribute=>['Attr::Trait']},)};BEGIN{package Attr::Trait;
  $Attr::Trait::VERSION = '0.40';use Moose::Role;around _process_options=>sub{my$orig=shift;my$c=shift;my($n,$o)=@_;$o->{is}||='rw';$o->{lazy}||=1 if defined$o->{default}or defined$o->{builder};$c->$orig(@_)};$INC{'Attr/Trait.pm'}=1}
MO_MOOSE

$fatpacked{"Mo/Mouse.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_MOUSE';
  package Mo::Mouse;
  $Mo::Mouse::VERSION = '0.40';$M="Mo::";
  $VERSION='0.40';
  *{$M.'Mouse::e'}=sub{my($P,$e)=@_;$P=~s/::$//;%$e=(M=>1);require Mouse;require Mouse::Util::MetaRole;Mouse->import({into=>$P});Mouse::Util::MetaRole::apply_metaroles(for=>$P,class_metaroles=>{attribute=>['Attr::Trait']},)};BEGIN{package Attr::Trait;
  $Attr::Trait::VERSION = '0.40';use Mouse::Role;around _process_options=>sub{my$orig=shift;my$c=shift;my($n,$o)=@_;$o->{is}||='rw';$o->{lazy}||=1 if defined$o->{default}or defined$o->{builder};$c->$orig(@_)};$INC{'Attr/Trait.pm'}=1}
MO_MOUSE

$fatpacked{"Mo/build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_BUILD';
  package Mo::build;
  $Mo::build::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  *{$M.'build::e'}=sub{my($P,$e)=@_;$e->{new}=sub{$c=shift;my$s=&{$M.Object::new}($c,@_);my@B;do{@B=($c.::BUILD,@B)}while($c)=@{$c.::ISA};exists&$_&&&$_($s)for@B;$s}};
MO_BUILD

$fatpacked{"Mo/builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_BUILDER';
  package Mo::builder;
  $Mo::builder::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  *{$M.'builder::e'}=sub{my($P,$e,$o)=@_;$o->{builder}=sub{my($m,$n,%a)=@_;my$b=$a{builder}or return$m;my$i=exists$a{lazy}?$a{lazy}:!${$P.':N'};$i or ${$P.':E'}{$n}=\&{$P.$b}and return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$_[0]->$b:$m->(@_)}}};
MO_BUILDER

$fatpacked{"Mo/chain.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_CHAIN';
  package Mo::chain;
  $Mo::chain::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  *{$M.'chain::e'}=sub{my($P,$e,$o)=@_;$o->{chain}=sub{my($m,$n,%a)=@_;$a{chain}or return$m;sub{$#_?($m->(@_),return$_[0]):$m->(@_)}}};
MO_CHAIN

$fatpacked{"Mo/coerce.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_COERCE';
  package Mo::coerce;
  $Mo::coerce::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  *{$M.'coerce::e'}=sub{my($P,$e,$o)=@_;$o->{coerce}=sub{my($m,$n,%a)=@_;$a{coerce}or return$m;sub{$#_?$m->($_[0],$a{coerce}->($_[1])):$m->(@_)}};my$C=$e->{new}||*{$M.Object::new}{CODE};$e->{new}=sub{my$s=$C->(@_);$s->$_($s->{$_})for keys%$s;$s}};
MO_COERCE

$fatpacked{"Mo/default.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_DEFAULT';
  package Mo::default;
  $Mo::default::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  *{$M.'default::e'}=sub{my($P,$e,$o)=@_;$o->{default}=sub{my($m,$n,%a)=@_;exists$a{default}or return$m;my($d,$r)=$a{default};my$g='HASH'eq($r=ref$d)?sub{+{%$d}}:'ARRAY'eq$r?sub{[@$d]}:'CODE'eq$r?$d:sub{$d};my$i=exists$a{lazy}?$a{lazy}:!${$P.':N'};$i or ${$P.':E'}{$n}=$g and return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$g->(@_):$m->(@_)}}};
MO_DEFAULT

$fatpacked{"Mo/exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_EXPORTER';
  package Mo::exporter;
  $Mo::exporter::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  *{$M.'exporter::e'}=sub{my($P)=@_;if(@{$M.EXPORT}){*{$P.$_}=\&{$M.$_}for@{$M.EXPORT}}};
MO_EXPORTER

$fatpacked{"Mo/import.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_IMPORT';
  package Mo::import;
  $Mo::import::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  my$i=\&import;*{$M.import}=sub{(@_==2 and not$_[1])?pop@_:@_==1?push@_,grep!/import/,@f:();goto&$i};
MO_IMPORT

$fatpacked{"Mo/importer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_IMPORTER';
  package Mo::importer;
  $Mo::importer::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  *{$M.'importer::e'}=sub{my($P,$e,$o,$f)=@_;(my$pkg=$P)=~s/::$//;&{$P.'importer'}($pkg,@$f)if defined&{$P.'importer'}};
MO_IMPORTER

$fatpacked{"Mo/is.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_IS';
  package Mo::is;
  $Mo::is::VERSION = '0.40';$M="Mo::";
  $VERSION='0.40';
  *{$M.'is::e'}=sub{my($P,$e,$o)=@_;$o->{is}=sub{my($m,$n,%a)=@_;$a{is}or return$m;sub{$#_&&$a{is}eq'ro'&&caller ne'Mo::coerce'?die$n.' is ro':$m->(@_)}}};
MO_IS

$fatpacked{"Mo/nonlazy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_NONLAZY';
  package Mo::nonlazy;
  $Mo::nonlazy::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  *{$M.'nonlazy::e'}=sub{${shift().':N'}=1};
MO_NONLAZY

$fatpacked{"Mo/option.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_OPTION';
  package Mo::option;
  $Mo::option::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  *{$M.'option::e'}=sub{my($P,$e,$o)=@_;$o->{option}=sub{my($m,$n,%a)=@_;$a{option}or return$m;my$n2=$n;*{$P."read_$n2"}=sub{$_[0]->{$n2}};sub{$#_?$m->(@_):$m->(@_,1);$_[0]}}};
MO_OPTION

$fatpacked{"Mo/required.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_REQUIRED';
  package Mo::required;
  $Mo::required::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  *{$M.'required::e'}=sub{my($P,$e,$o)=@_;$o->{required}=sub{my($m,$n,%a)=@_;if($a{required}){my$C=*{$P."new"}{CODE}||*{$M.Object::new}{CODE};no warnings 'redefine';*{$P."new"}=sub{my$s=$C->(@_);my%a=@_[1..$#_];die$n." required"if!exists$a{$n};$s}}$m}};
MO_REQUIRED

$fatpacked{"Mo/xs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_XS';
  package Mo::xs;
  $Mo::xs::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  require Class::XSAccessor;*{$M.'xs::e'}=sub{my($P,$e,$o,$f)=@_;$P=~s/::$//;$e->{has}=sub{my($n,%a)=@_;Class::XSAccessor->import(class=>$P,accessors=>{$n=>$n})}if!grep!/^xs$/,@$f};
MO_XS

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/home/gugod/perl5/perlbrew/perls/v18/bin/perl

use Mo::Inline;
exit Mo::Inline->new->run(@ARGV);
