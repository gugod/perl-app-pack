#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Class/Load.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_LOAD';
  use strict;
  use warnings;
  package Class::Load; # git description: v0.24-5-g22a44fd
  # ABSTRACT: A working (require "Class::Name") and more
  # KEYWORDS: class module load require use runtime
  
  our $VERSION = '0.25';
  
  use base 'Exporter';
  use Data::OptList 0.110 ();
  use Module::Implementation 0.04;
  use Module::Runtime 0.012 ();
  use Try::Tiny;
  
  {
      my $loader = Module::Implementation::build_loader_sub(
          implementations => [ 'XS', 'PP' ],
          symbols         => ['is_class_loaded'],
      );
  
      $loader->();
  }
  
  our @EXPORT_OK = qw/load_class load_optional_class try_load_class is_class_loaded load_first_existing_class/;
  our %EXPORT_TAGS = (
      all => \@EXPORT_OK,
  );
  
  our $ERROR;
  
  sub load_class {
      my $class   = shift;
      my $options = shift;
  
      my ($res, $e) = try_load_class($class, $options);
      return $class if $res;
  
      _croak($e);
  }
  
  sub load_first_existing_class {
      my $classes = Data::OptList::mkopt(\@_)
          or return;
  
      foreach my $class (@{$classes}) {
          Module::Runtime::check_module_name($class->[0]);
      }
  
      for my $class (@{$classes}) {
          my ($name, $options) = @{$class};
  
          # We need to be careful not to pass an undef $options to this sub,
          # since the XS version will blow up if that happens.
          return $name if is_class_loaded($name, ($options ? $options : ()));
  
          my ($res, $e) = try_load_class($name, $options);
  
          return $name if $res;
  
          my $file = Module::Runtime::module_notional_filename($name);
  
          next if $e =~ /^Can't locate \Q$file\E in \@INC/;
          next
              if $options
                  && defined $options->{-version}
                  && $e =~ _version_fail_re($name, $options->{-version});
  
          _croak("Couldn't load class ($name) because: $e");
      }
  
      my @list = map {
          $_->[0]
              . ( $_->[1] && defined $_->[1]{-version}
              ? " (version >= $_->[1]{-version})"
              : q{} )
      } @{$classes};
  
      my $err
          .= q{Can't locate }
          . _or_list(@list)
          . " in \@INC (\@INC contains: @INC).";
      _croak($err);
  }
  
  sub _version_fail_re {
      my $name = shift;
      my $vers = shift;
  
      return qr/\Q$name\E version \Q$vers\E required--this is only version/;
  }
  
  sub _nonexistent_fail_re {
      my $name = shift;
  
      my $file = Module::Runtime::module_notional_filename($name);
      return qr/Can't locate \Q$file\E in \@INC/;
  }
  
  sub _or_list {
      return $_[0] if @_ == 1;
  
      return join ' or ', @_ if @_ ==2;
  
      my $last = pop;
  
      my $list = join ', ', @_;
      $list .= ', or ' . $last;
  
      return $list;
  }
  
  sub load_optional_class {
      my $class   = shift;
      my $options = shift;
  
      Module::Runtime::check_module_name($class);
  
      my ($res, $e) = try_load_class($class, $options);
      return 1 if $res;
  
      return 0
          if $options
              && defined $options->{-version}
              && $e =~ _version_fail_re($class, $options->{-version});
  
      return 0
          if $e =~ _nonexistent_fail_re($class);
  
      _croak($e);
  }
  
  sub try_load_class {
      my $class   = shift;
      my $options = shift;
  
      Module::Runtime::check_module_name($class);
  
      local $@;
      undef $ERROR;
  
      if (is_class_loaded($class)) {
          # We need to check this here rather than in is_class_loaded() because
          # we want to return the error message for a failed version check, but
          # is_class_loaded just returns true/false.
          return 1 unless $options && defined $options->{-version};
          return try {
              $class->VERSION($options->{-version});
              1;
          }
          catch {
              _error($_);
          };
      }
  
      my $file = Module::Runtime::module_notional_filename($class);
      # This says "our diagnostics of the package
      # say perl's INC status about the file being loaded are
      # wrong", so we delete it from %INC, so when we call require(),
      # perl will *actually* try reloading the file.
      #
      # If the file is already in %INC, it won't retry,
      # And on 5.8, it won't fail either!
      #
      # The extra benefit of this trick, is it helps even on
      # 5.10, as instead of dying with "Compilation failed",
      # it will die with the actual error, and that's a win-win.
      delete $INC{$file};
      return try {
          local $SIG{__DIE__} = 'DEFAULT';
          if ($options && defined $options->{-version}) {
              Module::Runtime::use_module($class, $options->{-version});
          }
          else {
              Module::Runtime::require_module($class);
          }
          1;
      }
      catch {
          _error($_);
      };
  }
  
  sub _error {
      my $e = shift;
  
      $e =~ s/ at .+?Runtime\.pm line [0-9]+\.$//;
      chomp $e;
  
      $ERROR = $e;
      return 0 unless wantarray;
      return 0, $ERROR;
  }
  
  sub _croak {
      require Carp;
      local $Carp::CarpLevel = $Carp::CarpLevel + 2;
      Carp::croak(shift);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::Load - A working (require "Class::Name") and more
  
  =head1 VERSION
  
  version 0.25
  
  =head1 SYNOPSIS
  
      use Class::Load ':all';
  
      try_load_class('Class::Name')
          or plan skip_all => "Class::Name required to run these tests";
  
      load_class('Class::Name');
  
      is_class_loaded('Class::Name');
  
      my $baseclass = load_optional_class('Class::Name::MightExist')
          ? 'Class::Name::MightExist'
          : 'Class::Name::Default';
  
  =head1 DESCRIPTION
  
  C<require EXPR> only accepts C<Class/Name.pm> style module names, not
  C<Class::Name>. How frustrating! For that, we provide
  C<load_class 'Class::Name'>.
  
  It's often useful to test whether a module can be loaded, instead of throwing
  an error when it's not available. For that, we provide
  C<try_load_class 'Class::Name'>.
  
  Finally, sometimes we need to know whether a particular class has been loaded.
  Asking C<%INC> is an option, but that will miss inner packages and any class
  for which the filename does not correspond to the package name. For that, we
  provide C<is_class_loaded 'Class::Name'>.
  
  =head1 FUNCTIONS
  
  =head2 load_class Class::Name, \%options
  
  C<load_class> will load C<Class::Name> or throw an error, much like C<require>.
  
  If C<Class::Name> is already loaded (checked with C<is_class_loaded>) then it
  will not try to load the class. This is useful when you have inner packages
  which C<require> does not check.
  
  The C<%options> hash currently accepts one key, C<-version>. If you specify a
  version, then this subroutine will call C<< Class::Name->VERSION(
  $options{-version} ) >> internally, which will throw an error if the class's
  version is not equal to or greater than the version you requested.
  
  This method will return the name of the class on success.
  
  =head2 try_load_class Class::Name, \%options -> (0|1, error message)
  
  Returns 1 if the class was loaded, 0 if it was not. If the class was not
  loaded, the error will be returned as a second return value in list context.
  
  Again, if C<Class::Name> is already loaded (checked with C<is_class_loaded>)
  then it will not try to load the class. This is useful when you have inner
  packages which C<require> does not check.
  
  Like C<load_class>, you can pass a C<-version> in C<%options>. If the version
  is not sufficient, then this subroutine will return false.
  
  =head2 is_class_loaded Class::Name, \%options -> 0|1
  
  This uses a number of heuristics to determine if the class C<Class::Name> is
  loaded. There heuristics were taken from L<Class::MOP>'s old pure-perl
  implementation.
  
  Like C<load_class>, you can pass a C<-version> in C<%options>. If the version
  is not sufficient, then this subroutine will return false.
  
  =head2 load_first_existing_class Class::Name, \%options, ...
  
  This attempts to load the first loadable class in the list of classes
  given. Each class name can be followed by an options hash reference.
  
  If any one of the classes loads and passes the optional version check, that
  class name will be returned. If I<none> of the classes can be loaded (or none
  pass their version check), then an error will be thrown.
  
  If, when attempting to load a class, it fails to load because of a syntax
  error, then an error will be thrown immediately.
  
  =head2 load_optional_class Class::Name, \%options -> 0|1
  
  C<load_optional_class> is a lot like C<try_load_class>, but also a lot like
  C<load_class>.
  
  If the class exists, and it works, then it will return 1. If you specify a
  version in C<%options>, then the version check must succeed or it will return
  0.
  
  If the class doesn't exist, and it appears to not exist on disk either, it
  will return 0.
  
  If the class exists on disk, but loading from disk results in an error
  (e.g.: a syntax error), then it will C<croak> with that error.
  
  This is useful for using if you want a fallback module system, i.e.:
  
      my $class = load_optional_class($foo) ? $foo : $default;
  
  That way, if $foo does exist, but can't be loaded due to error, you won't
  get the behaviour of it simply not existing.
  
  =head1 CAVEATS
  
  Because of some of the heuristics that this module uses to infer whether a
  module has been loaded, some false positives may occur in C<is_class_loaded>
  checks (which are also performed internally in other interfaces) -- if a class
  has started to be loaded but then dies, it may appear that it has already been
  loaded, which can cause other things to make the wrong decision.
  L<Module::Runtime> doesn't have this issue, but it also doesn't do some things
  that this module does -- for example gracefully handle packages that have been
  defined inline in the same file as another package.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<http://blog.fox.geek.nz/2010/11/searching-design-spec-for-ultimate.html>
  
  This blog post is a good overview of the current state of the existing modules
  for loading other modules in various ways.
  
  =item L<http://blog.fox.geek.nz/2010/11/handling-optional-requirements-with.html>
  
  This blog post describes how to handle optional modules with L<Class::Load>.
  
  =item L<http://d.hatena.ne.jp/tokuhirom/20110202/1296598578>
  
  This Japanese blog post describes why L<DBIx::Skinny> now uses L<Class::Load>
  over its competitors.
  
  =item L<Moose>, L<Jifty>, L<Prophet>, etc
  
  This module was designed to be used anywhere you have
  C<if (eval "require $module"; 1)>, which occurs in many large projects.
  
  =item L<Module::Runtime>
  
  A leaner approach to loading modules
  
  =back
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Class-Load>
  (or L<bug-Class-Load@rt.cpan.org|mailto:bug-Class-Load@rt.cpan.org>).
  
  There is also a mailing list available for users of this distribution, at
  L<http://lists.perl.org/list/moose.html>.
  
  There is also an irc channel available for users of this distribution, at
  L<C<#moose> on C<irc.perl.org>|irc://irc.perl.org/#moose>.
  
  =head1 AUTHOR
  
  Shawn M Moore <sartak at bestpractical.com>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Dave Rolsky Karen Etheridge Shawn Moore Jesse Luehrs Kent Fredric Paul Howarth Olivier Mengué Caleb Cushing
  
  =over 4
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Shawn Moore <sartak@bestpractical.com>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Kent Fredric <kentfredric@gmail.com>
  
  =item *
  
  Paul Howarth <paul@city-fan.org>
  
  =item *
  
  Olivier Mengué <dolmen@cpan.org>
  
  =item *
  
  Caleb Cushing <xenoterracide@gmail.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2008 by Shawn M Moore.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
CLASS_LOAD

$fatpacked{"Class/Load/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_LOAD_PP';
  use strict;
  use warnings;
  package Class::Load::PP;
  
  our $VERSION = '0.25';
  
  use Module::Runtime ();
  use Package::Stash 0.14;
  use Scalar::Util ();
  use Try::Tiny;
  
  sub is_class_loaded {
      my $class   = shift;
      my $options = shift;
  
      my $loaded = _is_class_loaded($class);
  
      return $loaded if ! $loaded;
      return $loaded unless $options && $options->{-version};
  
      return try {
          $class->VERSION($options->{-version});
          1;
      }
      catch {
          0;
      };
  }
  
  sub _is_class_loaded {
      my $class = shift;
  
      return 0 unless Module::Runtime::is_module_name($class);
  
      my $stash = Package::Stash->new($class);
  
      if ($stash->has_symbol('$VERSION')) {
          my $version = ${ $stash->get_symbol('$VERSION') };
          if (defined $version) {
              return 1 if ! ref $version;
              # Sometimes $VERSION ends up as a reference to undef (weird)
              return 1 if ref $version && Scalar::Util::reftype $version eq 'SCALAR' && defined ${$version};
              # a version object
              return 1 if Scalar::Util::blessed $version;
          }
      }
  
      if ($stash->has_symbol('@ISA')) {
          return 1 if @{ $stash->get_symbol('@ISA') };
      }
  
      # check for any method
      return 1 if $stash->list_all_symbols('CODE');
  
      # fail
      return 0;
  }
  
  1;
CLASS_LOAD_PP

$fatpacked{"Data/OptList.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_OPTLIST';
  use strict;
  use warnings;
  package Data::OptList;
  # ABSTRACT: parse and validate simple name/value option pairs
  $Data::OptList::VERSION = '0.110';
  use List::Util ();
  use Params::Util ();
  use Sub::Install 0.921 ();
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   use Data::OptList;
  #pod
  #pod   my $options = Data::OptList::mkopt([
  #pod     qw(key1 key2 key3 key4),
  #pod     key5 => { ... },
  #pod     key6 => [ ... ],
  #pod     key7 => sub { ... },
  #pod     key8 => { ... },
  #pod     key8 => [ ... ],
  #pod   ]);
  #pod
  #pod ...is the same thing, more or less, as:
  #pod
  #pod   my $options = [
  #pod     [ key1 => undef,        ],
  #pod     [ key2 => undef,        ],
  #pod     [ key3 => undef,        ],
  #pod     [ key4 => undef,        ],
  #pod     [ key5 => { ... },      ],
  #pod     [ key6 => [ ... ],      ],
  #pod     [ key7 => sub { ... },  ],
  #pod     [ key8 => { ... },      ],
  #pod     [ key8 => [ ... ],      ],
  #pod   ]);
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod Hashes are great for storing named data, but if you want more than one entry
  #pod for a name, you have to use a list of pairs.  Even then, this is really boring
  #pod to write:
  #pod
  #pod   $values = [
  #pod     foo => undef,
  #pod     bar => undef,
  #pod     baz => undef,
  #pod     xyz => { ... },
  #pod   ];
  #pod
  #pod Just look at all those undefs!  Don't worry, we can get rid of those:
  #pod
  #pod   $values = [
  #pod     map { $_ => undef } qw(foo bar baz),
  #pod     xyz => { ... },
  #pod   ];
  #pod
  #pod Aaaauuugh!  We've saved a little typing, but now it requires thought to read,
  #pod and thinking is even worse than typing... and it's got a bug!  It looked right,
  #pod didn't it?  Well, the C<< xyz => { ... } >> gets consumed by the map, and we
  #pod don't get the data we wanted.
  #pod
  #pod With Data::OptList, you can do this instead:
  #pod
  #pod   $values = Data::OptList::mkopt([
  #pod     qw(foo bar baz),
  #pod     xyz => { ... },
  #pod   ]);
  #pod
  #pod This works by assuming that any defined scalar is a name and any reference
  #pod following a name is its value.
  #pod
  #pod =func mkopt
  #pod
  #pod   my $opt_list = Data::OptList::mkopt($input, \%arg);
  #pod
  #pod Valid arguments are:
  #pod
  #pod   moniker        - a word used in errors to describe the opt list; encouraged
  #pod   require_unique - if true, no name may appear more than once
  #pod   must_be        - types to which opt list values are limited (described below)
  #pod   name_test      - a coderef used to test whether a value can be a name
  #pod                    (described below, but you probably don't want this)
  #pod
  #pod This produces an array of arrays; the inner arrays are name/value pairs.
  #pod Values will be either "undef" or a reference.
  #pod
  #pod Positional parameters may be used for compatibility with the old C<mkopt>
  #pod interface:
  #pod
  #pod   my $opt_list = Data::OptList::mkopt($input, $moniker, $req_uni, $must_be);
  #pod
  #pod Valid values for C<$input>:
  #pod
  #pod  undef    -> []
  #pod  hashref  -> [ [ key1 => value1 ] ... ] # non-ref values become undef
  #pod  arrayref -> every name followed by a non-name becomes a pair: [ name => ref ]
  #pod              every name followed by undef becomes a pair: [ name => undef ]
  #pod              otherwise, it becomes [ name => undef ] like so:
  #pod              [ "a", "b", [ 1, 2 ] ] -> [ [ a => undef ], [ b => [ 1, 2 ] ] ]
  #pod
  #pod By default, a I<name> is any defined non-reference.  The C<name_test> parameter
  #pod can be a code ref that tests whether the argument passed it is a name or not.
  #pod This should be used rarely.  Interactions between C<require_unique> and
  #pod C<name_test> are not yet particularly elegant, as C<require_unique> just tests
  #pod string equality.  B<This may change.>
  #pod
  #pod The C<must_be> parameter is either a scalar or array of scalars; it defines
  #pod what kind(s) of refs may be values.  If an invalid value is found, an exception
  #pod is thrown.  If no value is passed for this argument, any reference is valid.
  #pod If C<must_be> specifies that values must be CODE, HASH, ARRAY, or SCALAR, then
  #pod Params::Util is used to check whether the given value can provide that
  #pod interface.  Otherwise, it checks that the given value is an object of the kind.
  #pod
  #pod In other words:
  #pod
  #pod   [ qw(SCALAR HASH Object::Known) ]
  #pod
  #pod Means:
  #pod
  #pod   _SCALAR0($value) or _HASH($value) or _INSTANCE($value, 'Object::Known')
  #pod
  #pod =cut
  
  my %test_for;
  BEGIN {
    %test_for = (
      CODE   => \&Params::Util::_CODELIKE,  ## no critic
      HASH   => \&Params::Util::_HASHLIKE,  ## no critic
      ARRAY  => \&Params::Util::_ARRAYLIKE, ## no critic
      SCALAR => \&Params::Util::_SCALAR0,   ## no critic
    );
  }
  
  sub mkopt {
    my ($opt_list) = shift;
  
    my ($moniker, $require_unique, $must_be); # the old positional args
    my ($name_test, $is_a);
  
    if (@_) {
      if (@_ == 1 and Params::Util::_HASHLIKE($_[0])) {
        ($moniker, $require_unique, $must_be, $name_test)
          = @{$_[0]}{ qw(moniker require_unique must_be name_test) };
      } else {
        ($moniker, $require_unique, $must_be) = @_;
      }
  
      # Transform the $must_be specification into a closure $is_a
      # that will check if a value matches the spec
  
      if (defined $must_be) {
        $must_be = [ $must_be ] unless ref $must_be;
        my @checks = map {
            my $class = $_;
            $test_for{$_}
            || sub { $_[1] = $class; goto \&Params::Util::_INSTANCE }
        } @$must_be;
  
        $is_a = (@checks == 1)
              ? $checks[0]
              : sub {
                  my $value = $_[0];
                  List::Util::first { defined($_->($value)) } @checks
                };
  
        $moniker = 'unnamed' unless defined $moniker;
      }
    }
  
    return [] unless $opt_list;
  
    $name_test ||= sub { ! ref $_[0] };
  
    $opt_list = [
      map { $_ => (ref $opt_list->{$_} ? $opt_list->{$_} : ()) } keys %$opt_list
    ] if ref $opt_list eq 'HASH';
  
    my @return;
    my %seen;
  
    for (my $i = 0; $i < @$opt_list; $i++) { ## no critic
      my $name = $opt_list->[$i];
  
      if ($require_unique) {
        Carp::croak "multiple definitions provided for $name" if $seen{$name}++;
      }
  
      my $value;
  
      if ($i < $#$opt_list) {
        if (not defined $opt_list->[$i+1]) {
          $i++
        } elsif (! $name_test->($opt_list->[$i+1])) {
          $value = $opt_list->[++$i];
          if ($is_a && !$is_a->($value)) {
            my $ref = ref $value;
            Carp::croak "$ref-ref values are not valid in $moniker opt list";
          }
        }
      }
  
      push @return, [ $name => $value ];
    }
  
    return \@return;
  }
  
  #pod =func mkopt_hash
  #pod
  #pod   my $opt_hash = Data::OptList::mkopt_hash($input, $moniker, $must_be);
  #pod
  #pod Given valid C<L</mkopt>> input, this routine returns a reference to a hash.  It
  #pod will throw an exception if any name has more than one value.
  #pod
  #pod =cut
  
  sub mkopt_hash {
    my ($opt_list, $moniker, $must_be) = @_;
    return {} unless $opt_list;
  
    $opt_list = mkopt($opt_list, $moniker, 1, $must_be);
    my %hash = map { $_->[0] => $_->[1] } @$opt_list;
    return \%hash;
  }
  
  #pod =head1 EXPORTS
  #pod
  #pod Both C<mkopt> and C<mkopt_hash> may be exported on request.
  #pod
  #pod =cut
  
  BEGIN {
    *import = Sub::Install::exporter {
      exports => [qw(mkopt mkopt_hash)],
    };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Data::OptList - parse and validate simple name/value option pairs
  
  =head1 VERSION
  
  version 0.110
  
  =head1 SYNOPSIS
  
    use Data::OptList;
  
    my $options = Data::OptList::mkopt([
      qw(key1 key2 key3 key4),
      key5 => { ... },
      key6 => [ ... ],
      key7 => sub { ... },
      key8 => { ... },
      key8 => [ ... ],
    ]);
  
  ...is the same thing, more or less, as:
  
    my $options = [
      [ key1 => undef,        ],
      [ key2 => undef,        ],
      [ key3 => undef,        ],
      [ key4 => undef,        ],
      [ key5 => { ... },      ],
      [ key6 => [ ... ],      ],
      [ key7 => sub { ... },  ],
      [ key8 => { ... },      ],
      [ key8 => [ ... ],      ],
    ]);
  
  =head1 DESCRIPTION
  
  Hashes are great for storing named data, but if you want more than one entry
  for a name, you have to use a list of pairs.  Even then, this is really boring
  to write:
  
    $values = [
      foo => undef,
      bar => undef,
      baz => undef,
      xyz => { ... },
    ];
  
  Just look at all those undefs!  Don't worry, we can get rid of those:
  
    $values = [
      map { $_ => undef } qw(foo bar baz),
      xyz => { ... },
    ];
  
  Aaaauuugh!  We've saved a little typing, but now it requires thought to read,
  and thinking is even worse than typing... and it's got a bug!  It looked right,
  didn't it?  Well, the C<< xyz => { ... } >> gets consumed by the map, and we
  don't get the data we wanted.
  
  With Data::OptList, you can do this instead:
  
    $values = Data::OptList::mkopt([
      qw(foo bar baz),
      xyz => { ... },
    ]);
  
  This works by assuming that any defined scalar is a name and any reference
  following a name is its value.
  
  =head1 FUNCTIONS
  
  =head2 mkopt
  
    my $opt_list = Data::OptList::mkopt($input, \%arg);
  
  Valid arguments are:
  
    moniker        - a word used in errors to describe the opt list; encouraged
    require_unique - if true, no name may appear more than once
    must_be        - types to which opt list values are limited (described below)
    name_test      - a coderef used to test whether a value can be a name
                     (described below, but you probably don't want this)
  
  This produces an array of arrays; the inner arrays are name/value pairs.
  Values will be either "undef" or a reference.
  
  Positional parameters may be used for compatibility with the old C<mkopt>
  interface:
  
    my $opt_list = Data::OptList::mkopt($input, $moniker, $req_uni, $must_be);
  
  Valid values for C<$input>:
  
   undef    -> []
   hashref  -> [ [ key1 => value1 ] ... ] # non-ref values become undef
   arrayref -> every name followed by a non-name becomes a pair: [ name => ref ]
               every name followed by undef becomes a pair: [ name => undef ]
               otherwise, it becomes [ name => undef ] like so:
               [ "a", "b", [ 1, 2 ] ] -> [ [ a => undef ], [ b => [ 1, 2 ] ] ]
  
  By default, a I<name> is any defined non-reference.  The C<name_test> parameter
  can be a code ref that tests whether the argument passed it is a name or not.
  This should be used rarely.  Interactions between C<require_unique> and
  C<name_test> are not yet particularly elegant, as C<require_unique> just tests
  string equality.  B<This may change.>
  
  The C<must_be> parameter is either a scalar or array of scalars; it defines
  what kind(s) of refs may be values.  If an invalid value is found, an exception
  is thrown.  If no value is passed for this argument, any reference is valid.
  If C<must_be> specifies that values must be CODE, HASH, ARRAY, or SCALAR, then
  Params::Util is used to check whether the given value can provide that
  interface.  Otherwise, it checks that the given value is an object of the kind.
  
  In other words:
  
    [ qw(SCALAR HASH Object::Known) ]
  
  Means:
  
    _SCALAR0($value) or _HASH($value) or _INSTANCE($value, 'Object::Known')
  
  =head2 mkopt_hash
  
    my $opt_hash = Data::OptList::mkopt_hash($input, $moniker, $must_be);
  
  Given valid C<L</mkopt>> input, this routine returns a reference to a hash.  It
  will throw an exception if any name has more than one value.
  
  =head1 EXPORTS
  
  Both C<mkopt> and C<mkopt_hash> may be exported on request.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Olivier Mengué Ricardo SIGNES
  
  =over 4
  
  =item *
  
  Olivier Mengué <dolmen@cpan.org>
  
  =item *
  
  Ricardo SIGNES <rjbs@codesimply.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DATA_OPTLIST

$fatpacked{"Devel/GlobalDestruction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_GLOBALDESTRUCTION';
  package Devel::GlobalDestruction;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.14';
  
  use Sub::Exporter::Progressive -setup => {
    exports => [ qw(in_global_destruction) ],
    groups  => { default => [ -all ] },
  };
  
  # we run 5.14+ - everything is in core
  #
  if (defined ${^GLOBAL_PHASE}) {
    eval 'sub in_global_destruction () { ${^GLOBAL_PHASE} eq q[DESTRUCT] }; 1'
      or die $@;
  }
  # try to load the xs version if it was compiled
  #
  elsif (eval {
    require Devel::GlobalDestruction::XS;
    no warnings 'once';
    *in_global_destruction = \&Devel::GlobalDestruction::XS::in_global_destruction;
    1;
  }) {
    # the eval already installed everything, nothing to do
  }
  else {
    # internally, PL_main_cv is set to Nullcv immediately before entering
    # global destruction and we can use B to detect that.  B::main_cv will
    # only ever be a B::CV or a B::SPECIAL that is a reference to 0
    require B;
    eval 'sub in_global_destruction () { ${B::main_cv()} == 0 }; 1'
      or die $@;
  }
  
  1;  # keep require happy
  
  
  __END__
  
  =head1 NAME
  
  Devel::GlobalDestruction - Provides function returning the equivalent of
  C<${^GLOBAL_PHASE} eq 'DESTRUCT'> for older perls.
  
  =head1 SYNOPSIS
  
      package Foo;
      use Devel::GlobalDestruction;
  
      use namespace::clean; # to avoid having an "in_global_destruction" method
  
      sub DESTROY {
          return if in_global_destruction;
  
          do_something_a_little_tricky();
      }
  
  =head1 DESCRIPTION
  
  Perl's global destruction is a little tricky to deal with WRT finalizers
  because it's not ordered and objects can sometimes disappear.
  
  Writing defensive destructors is hard and annoying, and usually if global
  destruction is happening you only need the destructors that free up non
  process local resources to actually execute.
  
  For these constructors you can avoid the mess by simply bailing out if global
  destruction is in effect.
  
  =head1 EXPORTS
  
  This module uses L<Sub::Exporter::Progressive> so the exports may be renamed,
  aliased, etc. if L<Sub::Exporter> is present.
  
  =over 4
  
  =item in_global_destruction
  
  Returns true if the interpreter is in global destruction. In perl 5.14+, this
  returns C<${^GLOBAL_PHASE} eq 'DESTRUCT'>, and on earlier perls, detects it using
  the value of C<PL_main_cv> or C<PL_dirty>.
  
  =back
  
  =head1 AUTHORS
  
  Yuval Kogman E<lt>nothingmuch@woobling.orgE<gt>
  
  Florian Ragwitz E<lt>rafl@debian.orgE<gt>
  
  Jesse Luehrs E<lt>doy@tozt.netE<gt>
  
  Peter Rabbitson E<lt>ribasushi@cpan.orgE<gt>
  
  Arthur Axel 'fREW' Schmidt E<lt>frioux@gmail.comE<gt>
  
  Elizabeth Mattijsen E<lt>liz@dijkmat.nlE<gt>
  
  Greham Knop E<lt>haarg@haarg.orgE<gt>
  
  =head1 COPYRIGHT
  
      Copyright (c) 2008 Yuval Kogman. All rights reserved
      This program is free software; you can redistribute
      it and/or modify it under the same terms as Perl itself.
  
  =cut
DEVEL_GLOBALDESTRUCTION

$fatpacked{"Devel/OverloadInfo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_OVERLOADINFO';
  package Devel::OverloadInfo;
  $Devel::OverloadInfo::VERSION = '0.005';
  # ABSTRACT: introspect overloaded operators
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Devel::OverloadInfo returns information about L<overloaded|overload>
  #pod operators for a given class (or object), including where in the
  #pod inheritance hierarchy the overloads are declared and where the code
  #pod implementing them is.
  #pod
  #pod =cut
  
  use strict;
  use warnings;
  use overload ();
  use Scalar::Util qw(blessed);
  use Sub::Identify qw(sub_fullname);
  use Package::Stash 0.14;
  use MRO::Compat;
  
  use Exporter 5.57 qw(import);
  our @EXPORT_OK = qw(overload_info overload_op_info is_overloaded);
  
  sub stash_with_symbol {
      my ($class, $symbol) = @_;
  
      for my $package (@{mro::get_linear_isa($class)}) {
          my $stash = Package::Stash->new($package);
          my $value_ref = $stash->get_symbol($symbol);
          return ($stash, $value_ref) if $value_ref;
      }
      return;
  }
  
  #pod =func is_overloaded
  #pod
  #pod    if (is_overloaded($class_or_object)) { ... }
  #pod
  #pod Returns a boolean indicating whether the given class or object has any
  #pod overloading declared.  Note that a bare C<use overload;> with no
  #pod actual operators counts as being overloaded.
  #pod
  #pod Equivalent to
  #pod L<overload::Overloaded()|overload/overload::Overloaded(arg)>, but
  #pod doesn't trigger various bugs associated with it in versions of perl
  #pod before 5.16.
  #pod
  #pod =cut
  
  sub is_overloaded {
      my $class = blessed($_[0]) || $_[0];
  
      # Perl before 5.16 seems to corrupt inherited overload info if
      # there's a lone dereference overload and overload::Overloaded()
      # is called before any object has been blessed into the class.
      return !!("$]" >= 5.016
          ? overload::Overloaded($class)
          : stash_with_symbol($class, '&()')
      );
  }
  
  #pod =func overload_op_info
  #pod
  #pod     my $info = overload_op_info($class_or_object, $op);
  #pod
  #pod Returns a hash reference with information about the specified
  #pod overloaded operator of the named class or blessed object.
  #pod
  #pod Returns C<undef> if the operator is not overloaded.
  #pod
  #pod See L<overload/Overloadable Operations> for the available operators.
  #pod
  #pod The keys in the returned hash are as follows:
  #pod
  #pod =over
  #pod
  #pod =item class
  #pod
  #pod The name of the class in which the operator overloading was declared.
  #pod
  #pod =item code
  #pod
  #pod A reference to the function implementing the overloaded operator.
  #pod
  #pod =item code_name
  #pod
  #pod The name of the function implementing the overloaded operator, as
  #pod returned by C<sub_fullname> in L<Sub::Identify>.
  #pod
  #pod =item method_name (optional)
  #pod
  #pod The name of the method implementing the overloaded operator, if the
  #pod overloading was specified as a named method, e.g. C<< use overload $op
  #pod => 'method'; >>.
  #pod
  #pod =item code_class (optional)
  #pod
  #pod The name of the class in which the method specified by C<method_name>
  #pod was found.
  #pod
  #pod =item value (optional)
  #pod
  #pod For the special C<fallback> key, the value it was given in C<class>.
  #pod
  #pod =back
  #pod
  #pod =cut
  
  sub overload_op_info {
      my ($class, $op) = @_;
      $class = blessed($class) || $class;
  
      return undef unless is_overloaded($class);
      my $op_method = $op eq 'fallback' ? "()" : "($op";
      my ($stash, $func) = stash_with_symbol($class, "&$op_method")
          or return undef;
      my $info = {
          class => $stash->name,
      };
      if ($func == \&overload::nil) {
          # Named method or fallback, stored in the scalar slot
          if (my $value_ref = $stash->get_symbol("\$$op_method")) {
              my $value = $$value_ref;
              if ($op eq 'fallback') {
                  $info->{value} = $value;
              } else {
                  $info->{method_name} = $value;
                  if (my ($impl_stash, $impl_func) = stash_with_symbol($class, "&$value")) {
                      $info->{code_class} = $impl_stash->name;
                      $info->{code} = $impl_func;
                  }
              }
          }
      } else {
          $info->{code} = $func;
      }
      $info->{code_name} = sub_fullname($info->{code})
          if exists $info->{code};
  
      return $info;
  }
  
  #pod =func overload_info
  #pod
  #pod     my $info = overload_info($class_or_object);
  #pod
  #pod Returns a hash reference with information about all the overloaded
  #pod operators of specified class name or blessed object.  The keys are the
  #pod overloaded operators, as specified in C<%overload::ops> (see
  #pod L<overload/Overloadable Operations>), and the values are the hashes
  #pod returned by L</overload_op_info>.
  #pod
  #pod =cut
  
  sub overload_info {
      my $class = blessed($_[0]) || $_[0];
  
      return {} unless is_overloaded($class);
  
      my (%overloaded);
      for my $op (map split(/\s+/), values %overload::ops) {
          my $info = overload_op_info($class, $op)
              or next;
          $overloaded{$op} = $info
      }
      return \%overloaded;
  }
  
  #pod =head1 CAVEATS
  #pod
  #pod Whether the C<fallback> key exists when it has its default value of
  #pod C<undef> varies between perl versions: Before 5.18 it's there, in
  #pod later versions it's not.
  #pod
  #pod =cut
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Devel::OverloadInfo - introspect overloaded operators
  
  =head1 VERSION
  
  version 0.005
  
  =head1 DESCRIPTION
  
  Devel::OverloadInfo returns information about L<overloaded|overload>
  operators for a given class (or object), including where in the
  inheritance hierarchy the overloads are declared and where the code
  implementing them is.
  
  =head1 FUNCTIONS
  
  =head2 is_overloaded
  
     if (is_overloaded($class_or_object)) { ... }
  
  Returns a boolean indicating whether the given class or object has any
  overloading declared.  Note that a bare C<use overload;> with no
  actual operators counts as being overloaded.
  
  Equivalent to
  L<overload::Overloaded()|overload/overload::Overloaded(arg)>, but
  doesn't trigger various bugs associated with it in versions of perl
  before 5.16.
  
  =head2 overload_op_info
  
      my $info = overload_op_info($class_or_object, $op);
  
  Returns a hash reference with information about the specified
  overloaded operator of the named class or blessed object.
  
  Returns C<undef> if the operator is not overloaded.
  
  See L<overload/Overloadable Operations> for the available operators.
  
  The keys in the returned hash are as follows:
  
  =over
  
  =item class
  
  The name of the class in which the operator overloading was declared.
  
  =item code
  
  A reference to the function implementing the overloaded operator.
  
  =item code_name
  
  The name of the function implementing the overloaded operator, as
  returned by C<sub_fullname> in L<Sub::Identify>.
  
  =item method_name (optional)
  
  The name of the method implementing the overloaded operator, if the
  overloading was specified as a named method, e.g. C<< use overload $op
  => 'method'; >>.
  
  =item code_class (optional)
  
  The name of the class in which the method specified by C<method_name>
  was found.
  
  =item value (optional)
  
  For the special C<fallback> key, the value it was given in C<class>.
  
  =back
  
  =head2 overload_info
  
      my $info = overload_info($class_or_object);
  
  Returns a hash reference with information about all the overloaded
  operators of specified class name or blessed object.  The keys are the
  overloaded operators, as specified in C<%overload::ops> (see
  L<overload/Overloadable Operations>), and the values are the hashes
  returned by L</overload_op_info>.
  
  =head1 CAVEATS
  
  Whether the C<fallback> key exists when it has its default value of
  C<undef> varies between perl versions: Before 5.18 it's there, in
  later versions it's not.
  
  =head1 AUTHOR
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Dagfinn Ilmari Mannsåker.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DEVEL_OVERLOADINFO

$fatpacked{"Devel/StackTrace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_STACKTRACE';
  package Devel::StackTrace;
  
  use 5.006;
  
  use strict;
  use warnings;
  
  our $VERSION = '2.03';
  
  use Devel::StackTrace::Frame;
  use File::Spec;
  use Scalar::Util qw( blessed );
  
  use overload
      '""'     => \&as_string,
      fallback => 1;
  
  sub new {
      my $class = shift;
      my %p     = @_;
  
      $p{unsafe_ref_capture} = !delete $p{no_refs}
          if exists $p{no_refs};
  
      my $self = bless {
          index  => undef,
          frames => [],
          raw    => [],
          %p,
      }, $class;
  
      $self->_record_caller_data;
  
      return $self;
  }
  
  sub _record_caller_data {
      my $self = shift;
  
      my $filter = $self->{filter_frames_early} && $self->_make_frame_filter;
  
      # We exclude this method by starting at least one frame back.
      my $x = 1 + ( $self->{skip_frames} || 0 );
  
      while (
          my @c
          = $self->{no_args}
          ? caller( $x++ )
          : do {
              ## no critic (Modules::ProhibitMultiplePackages, Variables::ProhibitPackageVars)
              package    # the newline keeps dzil from adding a version here
                  DB;
              @DB::args = ();
              caller( $x++ );
          }
          ) {
  
          my @args;
  
          ## no critic (Variables::ProhibitPackageVars)
          @args = $self->{no_args} ? () : @DB::args;
          ## use critic
  
          my $raw = {
              caller => \@c,
              args   => \@args,
          };
  
          next if $filter && !$filter->($raw);
  
          unless ( $self->{unsafe_ref_capture} ) {
              $raw->{args} = [ map { ref $_ ? $self->_ref_to_string($_) : $_ }
                      @{ $raw->{args} } ];
          }
  
          push @{ $self->{raw} }, $raw;
      }
  }
  
  sub _ref_to_string {
      my $self = shift;
      my $ref  = shift;
  
      return overload::AddrRef($ref)
          if blessed $ref && $ref->isa('Exception::Class::Base');
  
      return overload::AddrRef($ref) unless $self->{respect_overload};
  
      ## no critic (Variables::RequireInitializationForLocalVars)
      local $@;
      local $SIG{__DIE__};
      ## use critic
  
      my $str = eval { $ref . q{} };
  
      return $@ ? overload::AddrRef($ref) : $str;
  }
  
  sub _make_frames {
      my $self = shift;
  
      my $filter = !$self->{filter_frames_early} && $self->_make_frame_filter;
  
      my $raw = delete $self->{raw};
      for my $r ( @{$raw} ) {
          next if $filter && !$filter->($r);
  
          $self->_add_frame( $r->{caller}, $r->{args} );
      }
  }
  
  my $default_filter = sub {1};
  
  sub _make_frame_filter {
      my $self = shift;
  
      my ( @i_pack_re, %i_class );
      if ( $self->{ignore_package} ) {
          ## no critic (Variables::RequireInitializationForLocalVars)
          local $@;
          local $SIG{__DIE__};
          ## use critic
  
          $self->{ignore_package} = [ $self->{ignore_package} ]
              unless eval { @{ $self->{ignore_package} } };
  
          @i_pack_re
              = map { ref $_ ? $_ : qr/^\Q$_\E$/ } @{ $self->{ignore_package} };
      }
  
      my $p = __PACKAGE__;
      push @i_pack_re, qr/^\Q$p\E$/;
  
      if ( $self->{ignore_class} ) {
          $self->{ignore_class} = [ $self->{ignore_class} ]
              unless ref $self->{ignore_class};
          %i_class = map { $_ => 1 } @{ $self->{ignore_class} };
      }
  
      my $user_filter = $self->{frame_filter};
  
      return sub {
          return 0 if grep { $_[0]{caller}[0] =~ /$_/ } @i_pack_re;
          return 0 if grep { $_[0]{caller}[0]->isa($_) } keys %i_class;
  
          if ($user_filter) {
              return $user_filter->( $_[0] );
          }
  
          return 1;
      };
  }
  
  sub _add_frame {
      my $self = shift;
      my $c    = shift;
      my $p    = shift;
  
      # eval and is_require are only returned when applicable under 5.00503.
      push @$c, ( undef, undef ) if scalar @$c == 6;
  
      push @{ $self->{frames} },
          Devel::StackTrace::Frame->new(
          $c,
          $p,
          $self->{respect_overload},
          $self->{max_arg_length},
          $self->{message},
          $self->{indent}
          );
  }
  
  sub next_frame {
      my $self = shift;
  
      # reset to top if necessary.
      $self->{index} = -1 unless defined $self->{index};
  
      my @f = $self->frames;
      if ( defined $f[ $self->{index} + 1 ] ) {
          return $f[ ++$self->{index} ];
      }
      else {
          $self->{index} = undef;
          ## no critic (Subroutines::ProhibitExplicitReturnUndef)
          return undef;
      }
  }
  
  sub prev_frame {
      my $self = shift;
  
      my @f = $self->frames;
  
      # reset to top if necessary.
      $self->{index} = scalar @f unless defined $self->{index};
  
      if ( defined $f[ $self->{index} - 1 ] && $self->{index} >= 1 ) {
          return $f[ --$self->{index} ];
      }
      else {
          ## no critic (Subroutines::ProhibitExplicitReturnUndef)
          $self->{index} = undef;
          return undef;
      }
  }
  
  sub reset_pointer {
      my $self = shift;
  
      $self->{index} = undef;
  
      return;
  }
  
  sub frames {
      my $self = shift;
  
      if (@_) {
          die
              "Devel::StackTrace->frames can only take Devel::StackTrace::Frame args\n"
              if grep { !$_->isa('Devel::StackTrace::Frame') } @_;
  
          $self->{frames} = \@_;
          delete $self->{raw};
      }
      else {
          $self->_make_frames if $self->{raw};
      }
  
      return @{ $self->{frames} };
  }
  
  sub frame {
      my $self = shift;
      my $i    = shift;
  
      return unless defined $i;
  
      return ( $self->frames )[$i];
  }
  
  sub frame_count {
      my $self = shift;
  
      return scalar( $self->frames );
  }
  
  sub message { $_[0]->{message} }
  
  sub as_string {
      my $self = shift;
      my $p    = shift;
  
      my @frames = $self->frames;
      if (@frames) {
          my $st    = q{};
          my $first = 1;
          for my $f (@frames) {
              $st .= $f->as_string( $first, $p ) . "\n";
              $first = 0;
          }
  
          return $st;
      }
  
      my $msg = $self->message;
      return $msg if defined $msg;
  
      return 'Trace begun';
  }
  
  {
      ## no critic (Modules::ProhibitMultiplePackages, ClassHierarchies::ProhibitExplicitISA)
      package    # hide from PAUSE
          Devel::StackTraceFrame;
  
      our @ISA = 'Devel::StackTrace::Frame';
  }
  
  1;
  
  # ABSTRACT: An object representing a stack trace
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Devel::StackTrace - An object representing a stack trace
  
  =head1 VERSION
  
  version 2.03
  
  =head1 SYNOPSIS
  
    use Devel::StackTrace;
  
    my $trace = Devel::StackTrace->new;
  
    print $trace->as_string; # like carp
  
    # from top (most recent) of stack to bottom.
    while ( my $frame = $trace->next_frame ) {
        print "Has args\n" if $frame->hasargs;
    }
  
    # from bottom (least recent) of stack to top.
    while ( my $frame = $trace->prev_frame ) {
        print "Sub: ", $frame->subroutine, "\n";
    }
  
  =head1 DESCRIPTION
  
  The C<Devel::StackTrace> module contains two classes, C<Devel::StackTrace> and
  L<Devel::StackTrace::Frame>. These objects encapsulate the information that
  can retrieved via Perl's C<caller> function, as well as providing a simple
  interface to this data.
  
  The C<Devel::StackTrace> object contains a set of C<Devel::StackTrace::Frame>
  objects, one for each level of the stack. The frames contain all the data
  available from C<caller>.
  
  This code was created to support my L<Exception::Class::Base> class (part of
  L<Exception::Class>) but may be useful in other contexts.
  
  =head1 'TOP' AND 'BOTTOM' OF THE STACK
  
  When describing the methods of the trace object, I use the words 'top' and
  'bottom'. In this context, the 'top' frame on the stack is the most recent
  frame and the 'bottom' is the least recent.
  
  Here's an example:
  
    foo();  # bottom frame is here
  
    sub foo {
       bar();
    }
  
    sub bar {
       Devel::StackTrace->new;  # top frame is here.
    }
  
  =head1 METHODS
  
  This class provide the following methods:
  
  =head2 Devel::StackTrace->new(%named_params)
  
  Returns a new Devel::StackTrace object.
  
  Takes the following parameters:
  
  =over 4
  
  =item * frame_filter => $sub
  
  By default, Devel::StackTrace will include all stack frames before the call to
  its constructor.
  
  However, you may want to filter out some frames with more granularity than
  'ignore_package' or 'ignore_class' allow.
  
  You can provide a subroutine which is called with the raw frame data for each
  frame. This is a hash reference with two keys, "caller", and "args", both of
  which are array references. The "caller" key is the raw data as returned by
  Perl's C<caller> function, and the "args" key are the subroutine arguments
  found in C<@DB::args>.
  
  The filter should return true if the frame should be included, or false if it
  should be skipped.
  
  =item * filter_frames_early => $boolean
  
  If this parameter is true, C<frame_filter> will be called as soon as the
  stacktrace is created, and before refs are stringified (if
  C<unsafe_ref_capture> is not set), rather than being filtered lazily when
  L<Devel::StackTrace::Frame> objects are first needed.
  
  This is useful if you want to filter based on the frame's arguments and want
  to be able to examine object properties, for example.
  
  =item * ignore_package => $package_name OR \@package_names
  
  Any frames where the package is one of these packages will not be on the
  stack.
  
  =item * ignore_class => $package_name OR \@package_names
  
  Any frames where the package is a subclass of one of these packages (or is the
  same package) will not be on the stack.
  
  Devel::StackTrace internally adds itself to the 'ignore_package' parameter,
  meaning that the Devel::StackTrace package is B<ALWAYS> ignored. However, if
  you create a subclass of Devel::StackTrace it will not be ignored.
  
  =item * skip_frames => $integer
  
  This will cause this number of stack frames to be excluded from top of the
  stack trace. This prevents the frames from being captured at all, and applies
  before the C<frame_filter>, C<ignore_package>, or C<ignore_class> options,
  even with C<filter_frames_early>.
  
  =item * unsafe_ref_capture => $boolean
  
  If this parameter is true, then Devel::StackTrace will store references
  internally when generating stacktrace frames.
  
  B<This option is very dangerous, and should never be used with exception
  objects>. Using this option will keep any objects or references alive past
  their normal lifetime, until the stack trace object goes out of scope. It can
  keep objects alive even after their C<DESTROY> sub is called, resulting it it
  being called multiple times on the same object.
  
  If not set, Devel::StackTrace replaces any references with their stringified
  representation.
  
  =item * no_args => $boolean
  
  If this parameter is true, then Devel::StackTrace will not store caller
  arguments in stack trace frames at all.
  
  =item * respect_overload => $boolean
  
  By default, Devel::StackTrace will call C<overload::AddrRef> to get the
  underlying string representation of an object, instead of respecting the
  object's stringification overloading. If you would prefer to see the
  overloaded representation of objects in stack traces, then set this parameter
  to true.
  
  =item * max_arg_length => $integer
  
  By default, Devel::StackTrace will display the entire argument for each
  subroutine call. Setting this parameter causes truncates each subroutine
  argument's string representation if it is longer than this number of
  characters.
  
  =item * message => $string
  
  By default, Devel::StackTrace will use 'Trace begun' as the message for the
  first stack frame when you call C<as_string>. You can supply an alternative
  message using this option.
  
  =item * indent => $boolean
  
  If this parameter is true, each stack frame after the first will start with a
  tab character, just like C<Carp::confess>.
  
  =back
  
  =head2 $trace->next_frame
  
  Returns the next L<Devel::StackTrace::Frame> object on the stack, going
  down. If this method hasn't been called before it returns the first frame. It
  returns C<undef> when it reaches the bottom of the stack and then resets its
  pointer so the next call to C<< $trace->next_frame >> or C<<
  $trace->prev_frame >> will work properly.
  
  =head2 $trace->prev_frame
  
  Returns the next L<Devel::StackTrace::Frame> object on the stack, going up. If
  this method hasn't been called before it returns the last frame. It returns
  undef when it reaches the top of the stack and then resets its pointer so the
  next call to C<< $trace->next_frame >> or C<< $trace->prev_frame >> will work
  properly.
  
  =head2 $trace->reset_pointer
  
  Resets the pointer so that the next call to C<< $trace->next_frame >> or C<<
  $trace->prev_frame >> will start at the top or bottom of the stack, as
  appropriate.
  
  =head2 $trace->frames
  
  When this method is called with no arguments, it returns a list of
  L<Devel::StackTrace::Frame> objects. They are returned in order from top (most
  recent) to bottom.
  
  This method can also be used to set the object's frames if you pass it a list
  of L<Devel::StackTrace::Frame> objects.
  
  This is useful if you want to filter the list of frames in ways that are more
  complex than can be handled by the C<< $trace->filter_frames >> method:
  
    $stacktrace->frames( my_filter( $stacktrace->frames ) );
  
  =head2 $trace->frame($index)
  
  Given an index, this method returns the relevant frame, or undef if there is
  no frame at that index. The index is exactly like a Perl array. The first
  frame is 0 and negative indexes are allowed.
  
  =head2 $trace->frame_count
  
  Returns the number of frames in the trace object.
  
  =head2 $trace->as_string(\%p)
  
  Calls C<< $frame->as_string >> on each frame from top to bottom, producing
  output quite similar to the Carp module's cluck/confess methods.
  
  The optional C<\%p> parameter only has one option. The C<max_arg_length>
  parameter truncates each subroutine argument's string representation if it is
  longer than this number of characters.
  
  If all the frames in a trace are skipped then this just returns the C<message>
  passed to the constructor or the string C<"Trace begun">.
  
  =head2 $trace->message
  
  Returns the message passed to the constructor. If this wasn't passed then this
  method returns C<undef>.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Devel-StackTrace/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Devel-StackTrace can be found at L<https://github.com/houseabsolute/Devel-StackTrace>.
  
  =head1 DONATIONS
  
  If you'd like to thank me for the work I've done on this module, please
  consider making a "donation" to me via PayPal. I spend a lot of free time
  creating free software, and would appreciate any support you'd care to offer.
  
  Please note that B<I am not suggesting that you must do this> in order for me
  to continue working on this particular software. I will continue to do so,
  inasmuch as I have in the past, for as long as it interests me.
  
  Similarly, a donation made in this way will probably not make me work on this
  software much more, unless I get so many donations that I can consider working
  on free software full time (let's all have a chuckle at that together).
  
  To donate, log into PayPal and send money to autarch@urth.org, or use the
  button at L<http://www.urth.org/~autarch/fs-donation.html>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Dagfinn Ilmari Mannsåker David Cantrell Graham Knop Ivan Bessarabov Mark Fowler Ricardo Signes
  
  =over 4
  
  =item *
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =item *
  
  David Cantrell <david@cantrell.org.uk>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Ivan Bessarabov <ivan@bessarabov.ru>
  
  =item *
  
  Mark Fowler <mark@twoshortplanks.com>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2000 - 2017 by David Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
DEVEL_STACKTRACE

$fatpacked{"Devel/StackTrace/Frame.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_STACKTRACE_FRAME';
  package Devel::StackTrace::Frame;
  
  use strict;
  use warnings;
  
  our $VERSION = '2.03';
  
  # Create accessor routines
  BEGIN {
      ## no critic (TestingAndDebugging::ProhibitNoStrict)
      no strict 'refs';
  
      my @attrs = qw(
          package
          filename
          line
          subroutine
          hasargs
          wantarray
          evaltext
          is_require
          hints
          bitmask
      );
  
      for my $a (@attrs) {
          *{$a} = sub { my $s = shift; return $s->{$a} };
      }
  }
  
  {
      my @args = qw(
          package
          filename
          line
          subroutine
          hasargs
          wantarray
          evaltext
          is_require
          hints
          bitmask
      );
  
      sub new {
          my $proto = shift;
          my $class = ref $proto || $proto;
  
          my $self = bless {}, $class;
  
          @{$self}{@args} = @{ shift() };
          $self->{args}             = shift;
          $self->{respect_overload} = shift;
          $self->{max_arg_length}   = shift;
          $self->{message}          = shift;
          $self->{indent}           = shift;
  
          # fixup unix-style paths on win32
          $self->{filename} = File::Spec->canonpath( $self->{filename} );
  
          return $self;
      }
  }
  
  sub args {
      my $self = shift;
  
      return @{ $self->{args} };
  }
  
  sub as_string {
      my $self  = shift;
      my $first = shift;
      my $p     = shift;
  
      my $sub = $self->subroutine;
  
      # This code stolen straight from Carp.pm and then tweaked. All
      # errors are probably my fault  -dave
      if ($first) {
          $sub
              = defined $self->{message}
              ? $self->{message}
              : 'Trace begun';
      }
      else {
  
          # Build a string, $sub, which names the sub-routine called.
          # This may also be "require ...", "eval '...' or "eval {...}"
          if ( my $eval = $self->evaltext ) {
              if ( $self->is_require ) {
                  $sub = "require $eval";
              }
              else {
                  $eval =~ s/([\\\'])/\\$1/g;
                  $sub = "eval '$eval'";
              }
          }
          elsif ( $sub eq '(eval)' ) {
              $sub = 'eval {...}';
          }
  
          # if there are any arguments in the sub-routine call, format
          # them according to the format variables defined earlier in
          # this file and join them onto the $sub sub-routine string
          #
          # We copy them because they're going to be modified.
          #
          if ( my @a = $self->args ) {
              for (@a) {
  
                  # set args to the string "undef" if undefined
                  unless ( defined $_ ) {
                      $_ = 'undef';
                      next;
                  }
  
                  # hack!
                  ## no critic (Subroutines::ProtectPrivateSubs)
                  $_ = $self->Devel::StackTrace::_ref_to_string($_)
                      if ref $_;
                  ## use critic;
  
                  ## no critic (Variables::RequireInitializationForLocalVars)
                  local $SIG{__DIE__};
                  local $@;
                  ## use critic;
  
                  ## no critic (ErrorHandling::RequireCheckingReturnValueOfEval)
                  eval {
                      my $max_arg_length
                          = exists $p->{max_arg_length}
                          ? $p->{max_arg_length}
                          : $self->{max_arg_length};
  
                      if ( $max_arg_length
                          && length $_ > $max_arg_length ) {
                          ## no critic (BuiltinFunctions::ProhibitLvalueSubstr)
                          substr( $_, $max_arg_length ) = '...';
                      }
  
                      s/'/\\'/g;
  
                      # 'quote' arg unless it looks like a number
                      $_ = "'$_'" unless /^-?[\d.]+$/;
  
                      # print control/high ASCII chars as 'M-<char>' or '^<char>'
                      s/([\200-\377])/sprintf("M-%c",ord($1)&0177)/eg;
                      s/([\0-\37\177])/sprintf("^%c",ord($1)^64)/eg;
                  };
                  ## use critic
  
                  if ( my $e = $@ ) {
                      $_ = $e =~ /malformed utf-8/i ? '(bad utf-8)' : '?';
                  }
              }
  
              # append ('all', 'the', 'arguments') to the $sub string
              $sub .= '(' . join( ', ', @a ) . ')';
              $sub .= ' called';
          }
      }
  
      # If the user opted into indentation (a la Carp::confess), pre-add a tab
      my $tab = $self->{indent} && !$first ? "\t" : q{};
  
      return "${tab}$sub at " . $self->filename . ' line ' . $self->line;
  }
  
  1;
  
  # ABSTRACT: A single frame in a stack trace
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Devel::StackTrace::Frame - A single frame in a stack trace
  
  =head1 VERSION
  
  version 2.03
  
  =head1 DESCRIPTION
  
  See L<Devel::StackTrace> for details.
  
  =for Pod::Coverage new
  
  =head1 METHODS
  
  See Perl's C<caller> documentation for more information on what these
  methods return.
  
  =head2 $frame->package
  
  =head2 $frame->filename
  
  =head2 $frame->line
  
  =head2 $frame->subroutine
  
  =head2 $frame->hasargs
  
  =head2 $frame->wantarray
  
  =head2 $frame->evaltext
  
  Returns undef if the frame was not part of an eval.
  
  =head2 $frame->is_require
  
  Returns undef if the frame was not part of a require.
  
  =head2 $frame->args
  
  Returns the arguments passed to the frame. Note that any arguments that are
  references are returned as references, not copies.
  
  =head2 $frame->hints
  
  =head2 $frame->bitmask
  
  =head2 $frame->as_string
  
  Returns a string containing a description of the frame.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Devel-StackTrace/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Devel-StackTrace can be found at L<https://github.com/houseabsolute/Devel-StackTrace>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2000 - 2017 by David Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
DEVEL_STACKTRACE_FRAME

$fatpacked{"Dist/CheckConflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_CHECKCONFLICTS';
  package Dist::CheckConflicts;
  BEGIN {
    $Dist::CheckConflicts::AUTHORITY = 'cpan:DOY';
  }
  $Dist::CheckConflicts::VERSION = '0.11';
  use strict;
  use warnings;
  use 5.006;
  # ABSTRACT: declare version conflicts for your dist
  
  use base 'Exporter';
  our @EXPORT = our @EXPORT_OK = (
      qw(conflicts check_conflicts calculate_conflicts dist)
  );
  
  use Carp;
  use Module::Runtime 0.009 'module_notional_filename', 'require_module';
  
  
  my %CONFLICTS;
  my %HAS_CONFLICTS;
  my %DISTS;
  
  sub import {
      my $pkg = shift;
      my $for = caller;
  
      my ($conflicts, $alsos, $dist);
      ($conflicts, @_) = _strip_opt('-conflicts' => @_);
      ($alsos, @_)     = _strip_opt('-also' => @_);
      ($dist, @_)      = _strip_opt('-dist' => @_);
  
      my %conflicts = %{ $conflicts || {} };
      for my $also (@{ $alsos || [] }) {
          eval { require_module($also) } or next;
          if (!exists $CONFLICTS{$also}) {
              $also .= '::Conflicts';
              eval { require_module($also) } or next;
          }
          if (!exists $CONFLICTS{$also}) {
              next;
          }
          my %also_confs = $also->conflicts;
          for my $also_conf (keys %also_confs) {
              $conflicts{$also_conf} = $also_confs{$also_conf}
                  if !exists $conflicts{$also_conf}
                  || $conflicts{$also_conf} lt $also_confs{$also_conf};
          }
      }
  
      $CONFLICTS{$for} = \%conflicts;
      $DISTS{$for}     = $dist || $for;
  
      if (grep { $_ eq ':runtime' } @_) {
          for my $conflict (keys %conflicts) {
              $HAS_CONFLICTS{$conflict} ||= [];
              push @{ $HAS_CONFLICTS{$conflict} }, $for;
          }
  
          # warn for already loaded things...
          for my $conflict (keys %conflicts) {
              if (exists $INC{module_notional_filename($conflict)}) {
                  _check_version([$for], $conflict);
              }
          }
  
          # and warn for subsequently loaded things...
          @INC = grep {
              !(ref($_) eq 'ARRAY' && @$_ > 1 && $_->[1] == \%CONFLICTS)
          } @INC;
          unshift @INC, [
              sub {
                  my ($sub, $file) = @_;
  
                  (my $mod = $file) =~ s{\.pm$}{};
                  $mod =~ s{/}{::}g;
                  return unless $mod =~ /[\w:]+/;
  
                  return unless defined $HAS_CONFLICTS{$mod};
  
                  {
                      local $HAS_CONFLICTS{$mod};
                      require $file;
                  }
  
                  _check_version($HAS_CONFLICTS{$mod}, $mod);
  
                  # the previous require already handled it
                  my $called;
                  return sub {
                      return 0 if $called;
                      $_ = "1;";
                      $called = 1;
                      return 1;
                  };
              },
              \%CONFLICTS, # arbitrary but unique, see above
          ];
      }
  
      $pkg->export_to_level(1, @_);
  }
  
  sub _strip_opt {
      my ($opt, @args) = @_;
  
      my $val;
      for my $idx ( 0 .. $#args - 1 ) {
          if (defined $args[$idx] && $args[$idx] eq $opt) {
              $val = (splice @args, $idx, 2)[1];
              last;
          }
      }
  
      return ( $val, @args );
  }
  
  sub _check_version {
      my ($fors, $mod) = @_;
  
      for my $for (@$fors) {
          my $conflict_ver = $CONFLICTS{$for}{$mod};
          my $version = do {
              no strict 'refs';
              ${ ${ $mod . '::' }{VERSION} };
          };
  
          if ($version le $conflict_ver) {
              warn <<EOF;
  Conflict detected for $DISTS{$for}:
    $mod is version $version, but must be greater than version $conflict_ver
  EOF
              return;
          }
      }
  }
  
  
  sub conflicts {
      my $package = shift;
      return %{ $CONFLICTS{ $package } };
  }
  
  
  sub dist {
      my $package = shift;
      return $DISTS{ $package };
  }
  
  
  sub check_conflicts {
      my $package = shift;
      my $dist = $package->dist;
      my @conflicts = $package->calculate_conflicts;
      return unless @conflicts;
  
      my $err = "Conflicts detected for $dist:\n";
      for my $conflict (@conflicts) {
          $err .= "  $conflict->{package} is version "
                  . "$conflict->{installed}, but must be greater than version "
                  . "$conflict->{required}\n";
      }
      die $err;
  }
  
  
  sub calculate_conflicts {
      my $package = shift;
      my %conflicts = $package->conflicts;
  
      my @ret;
  
  
      CONFLICT:
      for my $conflict (keys %conflicts) {
          my $success = do {
              local $SIG{__WARN__} = sub {};
              eval { require_module($conflict) };
          };
          my $error = $@;
          my $file = module_notional_filename($conflict);
          next if not $success and $error =~ /Can't locate \Q$file\E in \@INC/;
  
          warn "Warning: $conflict did not compile" if not $success;
          my $installed = $success ? $conflict->VERSION : 'unknown';
          push @ret, {
              package   => $conflict,
              installed => $installed,
              required  => $conflicts{$conflict},
          } if not $success or $installed le $conflicts{$conflict};
      }
  
      return sort { $a->{package} cmp $b->{package} } @ret;
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::CheckConflicts - declare version conflicts for your dist
  
  =head1 VERSION
  
  version 0.11
  
  =head1 SYNOPSIS
  
      use Dist::CheckConflicts
          -dist => 'Class-MOP',
          -conflicts => {
              'Moose'                => '1.14',
              'namespace::autoclean' => '0.08',
          },
          -also => [
              'Package::Stash::Conflicts',
          ];
  
      __PACKAGE__->check_conflicts;
  
  =head1 DESCRIPTION
  
  One shortcoming of the CPAN clients that currently exist is that they have no
  way of specifying conflicting downstream dependencies of modules. This module
  attempts to work around this issue by allowing you to specify conflicting
  versions of modules separately, and deal with them after the module is done
  installing.
  
  For instance, say you have a module C<Foo>, and some other module C<Bar> uses
  C<Foo>. If C<Foo> were to change its API in a non-backwards-compatible way,
  this would cause C<Bar> to break until it is updated to use the new API. C<Foo>
  can't just depend on the fixed version of C<Bar>, because this will cause a
  circular dependency (because C<Bar> is already depending on C<Foo>), and this
  doesn't express intent properly anyway - C<Foo> doesn't use C<Bar> at all. The
  ideal solution would be for there to be a way to specify conflicting versions
  of modules in a way that would let CPAN clients update conflicting modules
  automatically after an existing module is upgraded, but until that happens,
  this module will allow users to do this manually.
  
  This module accepts a hash of options passed to its C<use> statement, with
  these keys being valid:
  
  =over 4
  
  =item -conflicts
  
  A hashref of conflict specifications, where keys are module names, and values
  are the last broken version - any version greater than the specified version
  should work.
  
  =item -also
  
  Additional modules to get conflicts from (potentially recursively). This should
  generally be a list of modules which use Dist::CheckConflicts, which correspond
  to the dists that your dist depends on. (In an ideal world, this would be
  intuited directly from your dependency list, but the dependency list isn't
  available outside of build time).
  
  =item -dist
  
  The name of the distribution, to make the error message from check_conflicts
  more user-friendly.
  
  =back
  
  The methods listed below are exported by this module into the module that uses
  it, so you should call these methods on your module, not Dist::CheckConflicts.
  
  As an example, this command line can be used to update your modules, after
  installing the C<Foo> dist (assuming that C<Foo::Conflicts> is the module in
  the C<Foo> dist which uses Dist::CheckConflicts):
  
      perl -MFoo::Conflicts -e'print "$_\n"
          for map { $_->{package} } Foo::Conflicts->calculate_conflicts' | cpanm
  
  As an added bonus, loading your conflicts module will provide warnings at
  runtime if conflicting modules are detected (regardless of whether they are
  loaded before or afterwards).
  
  =head1 METHODS
  
  =head2 conflicts
  
  Returns the conflict specification (the C<-conflicts> parameter to
  C<import()>), as a hash.
  
  =head2 dist
  
  Returns the dist name (either as specified by the C<-dist> parameter to
  C<import()>, or the package name which C<use>d this module).
  
  =head2 check_conflicts
  
  Examine the modules that are currently installed, and throw an exception with
  useful information if any modules are at versions which conflict with the dist.
  
  =head2 calculate_conflicts
  
  Examine the modules that are currently installed, and return a list of modules
  which conflict with the dist. The modules will be returned as a list of
  hashrefs, each containing C<package>, C<installed>, and C<required> keys.
  
  =head1 BUGS
  
  No known bugs.
  
  Please report any bugs to GitHub Issues at
  L<https://github.com/doy/dist-checkconflicts/issues>.
  
  =head1 SEE ALSO
  
  L<Module::Install::CheckConflicts>
  
  L<Dist::Zilla::Plugin::Conflicts>
  
  =head1 SUPPORT
  
  You can find this documentation for this module with the perldoc command.
  
      perldoc Dist::CheckConflicts
  
  You can also look for information at:
  
  =over 4
  
  =item * MetaCPAN
  
  L<https://metacpan.org/release/Dist-CheckConflicts>
  
  =item * Github
  
  L<https://github.com/doy/dist-checkconflicts>
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Dist-CheckConflicts>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Dist-CheckConflicts>
  
  =back
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy@tozt.net>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_CHECKCONFLICTS

$fatpacked{"Eval/Closure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EVAL_CLOSURE';
  package Eval::Closure;
  BEGIN {
    $Eval::Closure::AUTHORITY = 'cpan:DOY';
  }
  $Eval::Closure::VERSION = '0.14';
  use strict;
  use warnings;
  # ABSTRACT: safely and cleanly create closures via string eval
  
  use Exporter 'import';
  @Eval::Closure::EXPORT = @Eval::Closure::EXPORT_OK = 'eval_closure';
  
  use Carp;
  use overload ();
  use Scalar::Util qw(reftype);
  
  use constant HAS_LEXICAL_SUBS => $] >= 5.018;
  
  
  
  sub eval_closure {
      my (%args) = @_;
  
      # default to copying environment
      $args{alias} = 0 if !exists $args{alias};
  
      $args{source} = _canonicalize_source($args{source});
      _validate_env($args{environment} ||= {});
  
      $args{source} = _line_directive(@args{qw(line description)})
                    . $args{source}
          if defined $args{description} && !($^P & 0x10);
  
      my ($code, $e) = _clean_eval_closure(@args{qw(source environment alias)});
  
      if (!$code) {
          if ($args{terse_error}) {
              die "$e\n";
          }
          else {
              croak("Failed to compile source: $e\n\nsource:\n$args{source}")
          }
      }
  
      return $code;
  }
  
  sub _canonicalize_source {
      my ($source) = @_;
  
      if (defined($source)) {
          if (ref($source)) {
              if (reftype($source) eq 'ARRAY'
               || overload::Method($source, '@{}')) {
                  return join "\n", @$source;
              }
              elsif (overload::Method($source, '""')) {
                  return "$source";
              }
              else {
                  croak("The 'source' parameter to eval_closure must be a "
                      . "string or array reference");
              }
          }
          else {
              return $source;
          }
      }
      else {
          croak("The 'source' parameter to eval_closure is required");
      }
  }
  
  sub _validate_env {
      my ($env) = @_;
  
      croak("The 'environment' parameter must be a hashref")
          unless reftype($env) eq 'HASH';
  
      for my $var (keys %$env) {
          if (HAS_LEXICAL_SUBS) {
              croak("Environment key '$var' should start with \@, \%, \$, or \&")
                  if index('$@%&', substr($var, 0, 1)) < 0;
          }
          else {
              croak("Environment key '$var' should start with \@, \%, or \$")
                  if index('$@%', substr($var, 0, 1)) < 0;
          }
          croak("Environment values must be references, not $env->{$var}")
              unless ref($env->{$var});
      }
  }
  
  sub _line_directive {
      my ($line, $description) = @_;
  
      $line = 1 unless defined($line);
  
      return qq{#line $line "$description"\n};
  }
  
  sub _clean_eval_closure {
      my ($source, $captures, $alias) = @_;
  
      my @capture_keys = keys %$captures;
  
      if ($ENV{EVAL_CLOSURE_PRINT_SOURCE}) {
          _dump_source(_make_compiler_source($source, $alias, @capture_keys));
      }
  
      my ($compiler, $e) = _make_compiler($source, $alias, @capture_keys);
      return (undef, $e) unless defined $compiler;
  
      my $code = $compiler->(@$captures{@capture_keys});
  
      if (!defined $code) {
          return (
              undef,
              "The 'source' parameter must return a subroutine reference, "
              . "not undef"
          )
      }
      if (!ref($code) || ref($code) ne 'CODE') {
          return (
              undef,
              "The 'source' parameter must return a subroutine reference, not "
              . ref($code)
          )
      }
  
      if ($alias) {
          require Devel::LexAlias;
          Devel::LexAlias::lexalias($code, $_, $captures->{$_})
              for grep substr($_, 0, 1) ne '&', @capture_keys;
      }
  
      return ($code, $e);
  }
  
  sub _make_compiler {
      my $source = _make_compiler_source(@_);
  
      _clean_eval($source)
  }
  
  sub _clean_eval {
      local $@;
      local $SIG{__DIE__};
      my $compiler = eval $_[0];
      my $e = $@;
      ( $compiler, $e )
  }
  
  $Eval::Closure::SANDBOX_ID = 0;
  
  sub _make_compiler_source {
      my ($source, $alias, @capture_keys) = @_;
      $Eval::Closure::SANDBOX_ID++;
      my $i = 0;
      return join "\n", (
          "package Eval::Closure::Sandbox_$Eval::Closure::SANDBOX_ID;",
          'sub {',
              (map { _make_lexical_assignment($_, $i++, $alias) } @capture_keys),
              $source,
          '}',
      );
  }
  
  sub _make_lexical_assignment {
      my ($key, $index, $alias) = @_;
      my $sigil = substr($key, 0, 1);
      my $name = substr($key, 1);
      if (HAS_LEXICAL_SUBS && $sigil eq '&') {
          my $tmpname = '$__' . $name . '__' . $index;
          return 'use feature "lexical_subs"; '
               . 'no warnings "experimental::lexical_subs"; '
               . 'my ' . $tmpname . ' = $_[' . $index . ']; '
               . 'my sub ' . $name . ' { goto ' . $tmpname . ' }';
      }
      if ($alias) {
          return 'my ' . $key . ';';
      }
      else {
          return 'my ' . $key . ' = ' . $sigil . '{$_[' . $index . ']};';
      }
  }
  
  sub _dump_source {
      my ($source) = @_;
  
      my $output;
      local $@;
      if (eval { require Perl::Tidy; 1 }) {
          Perl::Tidy::perltidy(
              source      => \$source,
              destination => \$output,
              argv        => [],
          );
      }
      else {
          $output = $source;
      }
  
      warn "$output\n";
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Eval::Closure - safely and cleanly create closures via string eval
  
  =head1 VERSION
  
  version 0.14
  
  =head1 SYNOPSIS
  
    use Eval::Closure;
  
    my $code = eval_closure(
        source      => 'sub { $foo++ }',
        environment => {
            '$foo' => \1,
        },
    );
  
    warn $code->(); # 1
    warn $code->(); # 2
  
    my $code2 = eval_closure(
        source => 'sub { $code->() }',
    ); # dies, $code isn't in scope
  
  =head1 DESCRIPTION
  
  String eval is often used for dynamic code generation. For instance, C<Moose>
  uses it heavily, to generate inlined versions of accessors and constructors,
  which speeds code up at runtime by a significant amount. String eval is not
  without its issues however - it's difficult to control the scope it's used in
  (which determines which variables are in scope inside the eval), and it's easy
  to miss compilation errors, since eval catches them and sticks them in $@
  instead.
  
  This module attempts to solve these problems. It provides an C<eval_closure>
  function, which evals a string in a clean environment, other than a fixed list
  of specified variables. Compilation errors are rethrown automatically.
  
  =head1 FUNCTIONS
  
  =head2 eval_closure(%args)
  
  This function provides the main functionality of this module. It is exported by
  default. It takes a hash of parameters, with these keys being valid:
  
  =over 4
  
  =item source
  
  The string to be evaled. It should end by returning a code reference. It can
  access any variable declared in the C<environment> parameter (and only those
  variables). It can be either a string, or an arrayref of lines (which will be
  joined with newlines to produce the string).
  
  =item environment
  
  The environment to provide to the eval. This should be a hashref, mapping
  variable names (including sigils) to references of the appropriate type. For
  instance, a valid value for environment would be C<< { '@foo' => [] } >> (which
  would allow the generated function to use an array named C<@foo>). Generally,
  this is used to allow the generated function to access externally defined
  variables (so you would pass in a reference to a variable that already exists).
  
  In perl 5.18 and greater, the environment hash can contain variables with a
  sigil of C<&>. This will create a lexical sub in the evaluated code (see
  L<feature/The 'lexical_subs' feature>). Using a C<&> sigil on perl versions
  before lexical subs were available will throw an error.
  
  =item alias
  
  If set to true, the coderef returned closes over the variables referenced in
  the environment hashref. (This feature requires L<Devel::LexAlias>.) If set to
  false, the coderef closes over a I<< shallow copy >> of the variables.
  
  If this argument is omitted, Eval::Closure will currently assume false, but
  this assumption may change in a future version.
  
  =item description
  
  This lets you provide a bit more information in backtraces. Normally, when a
  function that was generated through string eval is called, that stack frame
  will show up as "(eval n)", where 'n' is a sequential identifier for every
  string eval that has happened so far in the program. Passing a C<description>
  parameter lets you override that to something more useful (for instance,
  L<Moose> overrides the description for accessors to something like "accessor
  foo at MyClass.pm, line 123").
  
  =item line
  
  This lets you override the particular line number that appears in backtraces,
  much like the C<description> option. The default is 1.
  
  =item terse_error
  
  Normally, this function appends the source code that failed to compile, and
  prepends some explanatory text. Setting this option to true suppresses that
  behavior so you get only the compilation error that Perl actually reported.
  
  =back
  
  =head1 BUGS
  
  No known bugs.
  
  Please report any bugs to GitHub Issues at
  L<https://github.com/doy/eval-closure/issues>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Class::MOP::Method::Accessor>
  
  This module is a factoring out of code that used to live here
  
  =back
  
  =head1 SUPPORT
  
  You can find this documentation for this module with the perldoc command.
  
      perldoc Eval::Closure
  
  You can also look for information at:
  
  =over 4
  
  =item * MetaCPAN
  
  L<https://metacpan.org/release/Eval-Closure>
  
  =item * Github
  
  L<https://github.com/doy/eval-closure>
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Eval-Closure>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Eval-Closure>
  
  =back
  
  =head1 NOTES
  
  Based on code from L<Class::MOP::Method::Accessor>, by Stevan Little and the
  Moose Cabal.
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy@tozt.net>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
EVAL_CLOSURE

$fatpacked{"Getopt/Long.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG';
  #! perl
  
  # Getopt::Long.pm -- Universal options parsing
  # Author          : Johan Vromans
  # Created On      : Tue Sep 11 15:00:12 1990
  # Last Modified By: Johan Vromans
  # Last Modified On: Sat May 27 12:11:39 2017
  # Update Count    : 1715
  # Status          : Released
  
  ################ Module Preamble ################
  
  use 5.004;
  
  use strict;
  use warnings;
  
  package Getopt::Long;
  
  use vars qw($VERSION);
  $VERSION        =  2.50;
  # For testing versions only.
  use vars qw($VERSION_STRING);
  $VERSION_STRING = "2.50";
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  # Exported subroutines.
  sub GetOptions(@);		# always
  sub GetOptionsFromArray(@);	# on demand
  sub GetOptionsFromString(@);	# on demand
  sub Configure(@);		# on demand
  sub HelpMessage(@);		# on demand
  sub VersionMessage(@);		# in demand
  
  BEGIN {
      # Init immediately so their contents can be used in the 'use vars' below.
      @EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
      @EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
  		    &GetOptionsFromArray &GetOptionsFromString);
  }
  
  # User visible variables.
  use vars @EXPORT, @EXPORT_OK;
  use vars qw($error $debug $major_version $minor_version);
  # Deprecated visible variables.
  use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
  	    $passthrough);
  # Official invisible variables.
  use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
  
  # Really invisible variables.
  my $bundling_values;
  
  # Public subroutines.
  sub config(@);			# deprecated name
  
  # Private subroutines.
  sub ConfigDefaults();
  sub ParseOptionSpec($$);
  sub OptCtl($);
  sub FindOption($$$$$);
  sub ValidValue ($$$$$);
  
  ################ Local Variables ################
  
  # $requested_version holds the version that was mentioned in the 'use'
  # or 'require', if any. It can be used to enable or disable specific
  # features.
  my $requested_version = 0;
  
  ################ Resident subroutines ################
  
  sub ConfigDefaults() {
      # Handle POSIX compliancy.
      if ( defined $ENV{"POSIXLY_CORRECT"} ) {
  	$genprefix = "(--|-)";
  	$autoabbrev = 0;		# no automatic abbrev of options
  	$bundling = 0;			# no bundling of single letter switches
  	$getopt_compat = 0;		# disallow '+' to start options
  	$order = $REQUIRE_ORDER;
      }
      else {
  	$genprefix = "(--|-|\\+)";
  	$autoabbrev = 1;		# automatic abbrev of options
  	$bundling = 0;			# bundling off by default
  	$getopt_compat = 1;		# allow '+' to start options
  	$order = $PERMUTE;
      }
      # Other configurable settings.
      $debug = 0;			# for debugging
      $error = 0;			# error tally
      $ignorecase = 1;		# ignore case when matching options
      $passthrough = 0;		# leave unrecognized options alone
      $gnu_compat = 0;		# require --opt=val if value is optional
      $longprefix = "(--)";       # what does a long prefix look like
      $bundling_values = 0;	# no bundling of values
  }
  
  # Override import.
  sub import {
      my $pkg = shift;		# package
      my @syms = ();		# symbols to import
      my @config = ();		# configuration
      my $dest = \@syms;		# symbols first
      for ( @_ ) {
  	if ( $_ eq ':config' ) {
  	    $dest = \@config;	# config next
  	    next;
  	}
  	push(@$dest, $_);	# push
      }
      # Hide one level and call super.
      local $Exporter::ExportLevel = 1;
      push(@syms, qw(&GetOptions)) if @syms; # always export GetOptions
      $requested_version = 0;
      $pkg->SUPER::import(@syms);
      # And configure.
      Configure(@config) if @config;
  }
  
  ################ Initialization ################
  
  # Values for $order. See GNU getopt.c for details.
  ($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
  # Version major/minor numbers.
  ($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;
  
  ConfigDefaults();
  
  ################ OO Interface ################
  
  package Getopt::Long::Parser;
  
  # Store a copy of the default configuration. Since ConfigDefaults has
  # just been called, what we get from Configure is the default.
  my $default_config = do {
      Getopt::Long::Configure ()
  };
  
  sub new {
      my $that = shift;
      my $class = ref($that) || $that;
      my %atts = @_;
  
      # Register the callers package.
      my $self = { caller_pkg => (caller)[0] };
  
      bless ($self, $class);
  
      # Process config attributes.
      if ( defined $atts{config} ) {
  	my $save = Getopt::Long::Configure ($default_config, @{$atts{config}});
  	$self->{settings} = Getopt::Long::Configure ($save);
  	delete ($atts{config});
      }
      # Else use default config.
      else {
  	$self->{settings} = $default_config;
      }
  
      if ( %atts ) {		# Oops
  	die(__PACKAGE__.": unhandled attributes: ".
  	    join(" ", sort(keys(%atts)))."\n");
      }
  
      $self;
  }
  
  sub configure {
      my ($self) = shift;
  
      # Restore settings, merge new settings in.
      my $save = Getopt::Long::Configure ($self->{settings}, @_);
  
      # Restore orig config and save the new config.
      $self->{settings} = Getopt::Long::Configure ($save);
  }
  
  sub getoptions {
      my ($self) = shift;
  
      return $self->getoptionsfromarray(\@ARGV, @_);
  }
  
  sub getoptionsfromarray {
      my ($self) = shift;
  
      # Restore config settings.
      my $save = Getopt::Long::Configure ($self->{settings});
  
      # Call main routine.
      my $ret = 0;
      $Getopt::Long::caller = $self->{caller_pkg};
  
      eval {
  	# Locally set exception handler to default, otherwise it will
  	# be called implicitly here, and again explicitly when we try
  	# to deliver the messages.
  	local ($SIG{__DIE__}) = 'DEFAULT';
  	$ret = Getopt::Long::GetOptionsFromArray (@_);
      };
  
      # Restore saved settings.
      Getopt::Long::Configure ($save);
  
      # Handle errors and return value.
      die ($@) if $@;
      return $ret;
  }
  
  package Getopt::Long;
  
  ################ Back to Normal ################
  
  # Indices in option control info.
  # Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
  use constant CTL_TYPE    => 0;
  #use constant   CTL_TYPE_FLAG   => '';
  #use constant   CTL_TYPE_NEG    => '!';
  #use constant   CTL_TYPE_INCR   => '+';
  #use constant   CTL_TYPE_INT    => 'i';
  #use constant   CTL_TYPE_INTINC => 'I';
  #use constant   CTL_TYPE_XINT   => 'o';
  #use constant   CTL_TYPE_FLOAT  => 'f';
  #use constant   CTL_TYPE_STRING => 's';
  
  use constant CTL_CNAME   => 1;
  
  use constant CTL_DEFAULT => 2;
  
  use constant CTL_DEST    => 3;
   use constant   CTL_DEST_SCALAR => 0;
   use constant   CTL_DEST_ARRAY  => 1;
   use constant   CTL_DEST_HASH   => 2;
   use constant   CTL_DEST_CODE   => 3;
  
  use constant CTL_AMIN    => 4;
  use constant CTL_AMAX    => 5;
  
  # FFU.
  #use constant CTL_RANGE   => ;
  #use constant CTL_REPEAT  => ;
  
  # Rather liberal patterns to match numbers.
  use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
  use constant PAT_XINT  =>
    "(?:".
  	  "[-+]?_*[1-9][0-9_]*".
    "|".
  	  "0x_*[0-9a-f][0-9a-f_]*".
    "|".
  	  "0b_*[01][01_]*".
    "|".
  	  "0[0-7_]*".
    ")";
  use constant PAT_FLOAT =>
    "[-+]?".			# optional sign
    "(?=[0-9.])".			# must start with digit or dec.point
    "[0-9_]*".			# digits before the dec.point
    "(\.[0-9_]+)?".		# optional fraction
    "([eE][-+]?[0-9_]+)?";	# optional exponent
  
  sub GetOptions(@) {
      # Shift in default array.
      unshift(@_, \@ARGV);
      # Try to keep caller() and Carp consistent.
      goto &GetOptionsFromArray;
  }
  
  sub GetOptionsFromString(@) {
      my ($string) = shift;
      require Text::ParseWords;
      my $args = [ Text::ParseWords::shellwords($string) ];
      $caller ||= (caller)[0];	# current context
      my $ret = GetOptionsFromArray($args, @_);
      return ( $ret, $args ) if wantarray;
      if ( @$args ) {
  	$ret = 0;
  	warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n");
      }
      $ret;
  }
  
  sub GetOptionsFromArray(@) {
  
      my ($argv, @optionlist) = @_;	# local copy of the option descriptions
      my $argend = '--';		# option list terminator
      my %opctl = ();		# table of option specs
      my $pkg = $caller || (caller)[0];	# current context
  				# Needed if linkage is omitted.
      my @ret = ();		# accum for non-options
      my %linkage;		# linkage
      my $userlinkage;		# user supplied HASH
      my $opt;			# current option
      my $prefix = $genprefix;	# current prefix
  
      $error = '';
  
      if ( $debug ) {
  	# Avoid some warnings if debugging.
  	local ($^W) = 0;
  	print STDERR
  	  ("Getopt::Long $Getopt::Long::VERSION ",
  	   "called from package \"$pkg\".",
  	   "\n  ",
  	   "argv: ",
  	   defined($argv)
  	   ? UNIVERSAL::isa( $argv, 'ARRAY' ) ? "(@$argv)" : $argv
  	   : "<undef>",
  	   "\n  ",
  	   "autoabbrev=$autoabbrev,".
  	   "bundling=$bundling,",
  	   "bundling_values=$bundling_values,",
  	   "getopt_compat=$getopt_compat,",
  	   "gnu_compat=$gnu_compat,",
  	   "order=$order,",
  	   "\n  ",
  	   "ignorecase=$ignorecase,",
  	   "requested_version=$requested_version,",
  	   "passthrough=$passthrough,",
  	   "genprefix=\"$genprefix\",",
  	   "longprefix=\"$longprefix\".",
  	   "\n");
      }
  
      # Check for ref HASH as first argument.
      # First argument may be an object. It's OK to use this as long
      # as it is really a hash underneath.
      $userlinkage = undef;
      if ( @optionlist && ref($optionlist[0]) and
  	 UNIVERSAL::isa($optionlist[0],'HASH') ) {
  	$userlinkage = shift (@optionlist);
  	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
      }
  
      # See if the first element of the optionlist contains option
      # starter characters.
      # Be careful not to interpret '<>' as option starters.
      if ( @optionlist && $optionlist[0] =~ /^\W+$/
  	 && !($optionlist[0] eq '<>'
  	      && @optionlist > 0
  	      && ref($optionlist[1])) ) {
  	$prefix = shift (@optionlist);
  	# Turn into regexp. Needs to be parenthesized!
  	$prefix =~ s/(\W)/\\$1/g;
  	$prefix = "([" . $prefix . "])";
  	print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
      }
  
      # Verify correctness of optionlist.
      %opctl = ();
      while ( @optionlist ) {
  	my $opt = shift (@optionlist);
  
  	unless ( defined($opt) ) {
  	    $error .= "Undefined argument in option spec\n";
  	    next;
  	}
  
  	# Strip leading prefix so people can specify "--foo=i" if they like.
  	$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  
  	if ( $opt eq '<>' ) {
  	    if ( (defined $userlinkage)
  		&& !(@optionlist > 0 && ref($optionlist[0]))
  		&& (exists $userlinkage->{$opt})
  		&& ref($userlinkage->{$opt}) ) {
  		unshift (@optionlist, $userlinkage->{$opt});
  	    }
  	    unless ( @optionlist > 0
  		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
  		$error .= "Option spec <> requires a reference to a subroutine\n";
  		# Kill the linkage (to avoid another error).
  		shift (@optionlist)
  		  if @optionlist && ref($optionlist[0]);
  		next;
  	    }
  	    $linkage{'<>'} = shift (@optionlist);
  	    next;
  	}
  
  	# Parse option spec.
  	my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  	unless ( defined $name ) {
  	    # Failed. $orig contains the error message. Sorry for the abuse.
  	    $error .= $orig;
  	    # Kill the linkage (to avoid another error).
  	    shift (@optionlist)
  	      if @optionlist && ref($optionlist[0]);
  	    next;
  	}
  
  	# If no linkage is supplied in the @optionlist, copy it from
  	# the userlinkage if available.
  	if ( defined $userlinkage ) {
  	    unless ( @optionlist > 0 && ref($optionlist[0]) ) {
  		if ( exists $userlinkage->{$orig} &&
  		     ref($userlinkage->{$orig}) ) {
  		    print STDERR ("=> found userlinkage for \"$orig\": ",
  				  "$userlinkage->{$orig}\n")
  			if $debug;
  		    unshift (@optionlist, $userlinkage->{$orig});
  		}
  		else {
  		    # Do nothing. Being undefined will be handled later.
  		    next;
  		}
  	    }
  	}
  
  	# Copy the linkage. If omitted, link to global variable.
  	if ( @optionlist > 0 && ref($optionlist[0]) ) {
  	    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  		if $debug;
  	    my $rl = ref($linkage{$orig} = shift (@optionlist));
  
  	    if ( $rl eq "ARRAY" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  	    }
  	    elsif ( $rl eq "HASH" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
  	    }
  	    elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
  #		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  #		    my $t = $linkage{$orig};
  #		    $$t = $linkage{$orig} = [];
  #		}
  #		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  #		}
  #		else {
  		    # Ok.
  #		}
  	    }
  	    elsif ( $rl eq "CODE" ) {
  		# Ok.
  	    }
  	    else {
  		$error .= "Invalid option linkage for \"$opt\"\n";
  	    }
  	}
  	else {
  	    # Link to global $opt_XXX variable.
  	    # Make sure a valid perl identifier results.
  	    my $ov = $orig;
  	    $ov =~ s/\W/_/g;
  	    if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  		print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;");
  	    }
  	    elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  		print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
  	    }
  	    else {
  		print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
  	    }
  	}
  
  	if ( $opctl{$name}[CTL_TYPE] eq 'I'
  	     && ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY
  		  || $opctl{$name}[CTL_DEST] == CTL_DEST_HASH )
  	   ) {
  	    $error .= "Invalid option linkage for \"$opt\"\n";
  	}
  
      }
  
      $error .= "GetOptionsFromArray: 1st parameter is not an array reference\n"
        unless $argv && UNIVERSAL::isa( $argv, 'ARRAY' );
  
      # Bail out if errors found.
      die ($error) if $error;
      $error = 0;
  
      # Supply --version and --help support, if needed and allowed.
      if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{version}) ) {
  	    $opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
  	    $linkage{version} = \&VersionMessage;
  	}
  	$auto_version = 1;
      }
      if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
  	    $opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
  	    $linkage{help} = \&HelpMessage;
  	}
  	$auto_help = 1;
      }
  
      # Show the options tables if debugging.
      if ( $debug ) {
  	my ($arrow, $k, $v);
  	$arrow = "=> ";
  	while ( ($k,$v) = each(%opctl) ) {
  	    print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
  	    $arrow = "   ";
  	}
      }
  
      # Process argument list
      my $goon = 1;
      while ( $goon && @$argv > 0 ) {
  
  	# Get next argument.
  	$opt = shift (@$argv);
  	print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  
  	# Double dash is option list terminator.
  	if ( defined($opt) && $opt eq $argend ) {
  	  push (@ret, $argend) if $passthrough;
  	  last;
  	}
  
  	# Look it up.
  	my $tryopt = $opt;
  	my $found;		# success status
  	my $key;		# key (if hash type)
  	my $arg;		# option argument
  	my $ctl;		# the opctl entry
  
  	($found, $opt, $ctl, $arg, $key) =
  	  FindOption ($argv, $prefix, $argend, $opt, \%opctl);
  
  	if ( $found ) {
  
  	    # FindOption undefines $opt in case of errors.
  	    next unless defined $opt;
  
  	    my $argcnt = 0;
  	    while ( defined $arg ) {
  
  		# Get the canonical name.
  		print STDERR ("=> cname for \"$opt\" is ") if $debug;
  		$opt = $ctl->[CTL_CNAME];
  		print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  
  		if ( defined $linkage{$opt} ) {
  		    print STDERR ("=> ref(\$L{$opt}) -> ",
  				  ref($linkage{$opt}), "\n") if $debug;
  
  		    if ( ref($linkage{$opt}) eq 'SCALAR'
  			 || ref($linkage{$opt}) eq 'REF' ) {
  			if ( $ctl->[CTL_TYPE] eq '+' ) {
  			    print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
  			      if $debug;
  			    if ( defined ${$linkage{$opt}} ) {
  			        ${$linkage{$opt}} += $arg;
  			    }
  		            else {
  			        ${$linkage{$opt}} = $arg;
  			    }
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to ARRAY\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = [];
  			    print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			      if $debug;
  			    push (@{$linkage{$opt}}, $arg);
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to HASH\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = {};
  			    print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			      if $debug;
  			    $linkage{$opt}->{$key} = $arg;
  			}
  			else {
  			    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  			      if $debug;
  			    ${$linkage{$opt}} = $arg;
  		        }
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
  			print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			    if $debug;
  			push (@{$linkage{$opt}}, $arg);
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
  			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$linkage{$opt}->{$key} = $arg;
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
  			print STDERR ("=> &L{$opt}(\"$opt\"",
  				      $ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
  				      ", \"$arg\")\n")
  			    if $debug;
  			my $eval_error = do {
  			    local $@;
  			    local $SIG{__DIE__}  = 'DEFAULT';
  			    eval {
  				&{$linkage{$opt}}
  				  (Getopt::Long::CallBack->new
  				   (name    => $opt,
  				    ctl     => $ctl,
  				    opctl   => \%opctl,
  				    linkage => \%linkage,
  				    prefix  => $prefix,
  				   ),
  				   $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
  				   $arg);
  			    };
  			    $@;
  			};
  			print STDERR ("=> die($eval_error)\n")
  			  if $debug && $eval_error ne '';
  			if ( $eval_error =~ /^!/ ) {
  			    if ( $eval_error =~ /^!FINISH\b/ ) {
  				$goon = 0;
  			    }
  			}
  			elsif ( $eval_error ne '' ) {
  			    warn ($eval_error);
  			    $error++;
  			}
  		    }
  		    else {
  			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
  				      "\" in linkage\n");
  			die("Getopt::Long -- internal error!\n");
  		    }
  		}
  		# No entry in linkage means entry in userlinkage.
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")
  			    if $debug;
  			push (@{$userlinkage->{$opt}}, $arg);
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
  			    if $debug;
  			$userlinkage->{$opt} = [$arg];
  		    }
  		}
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$userlinkage->{$opt}->{$key} = $arg;
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
  			    if $debug;
  			$userlinkage->{$opt} = {$key => $arg};
  		    }
  		}
  		else {
  		    if ( $ctl->[CTL_TYPE] eq '+' ) {
  			print STDERR ("=> \$L{$opt} += \"$arg\"\n")
  			  if $debug;
  			if ( defined $userlinkage->{$opt} ) {
  			    $userlinkage->{$opt} += $arg;
  			}
  			else {
  			    $userlinkage->{$opt} = $arg;
  			}
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
  			$userlinkage->{$opt} = $arg;
  		    }
  		}
  
  		$argcnt++;
  		last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  		undef($arg);
  
  		# Need more args?
  		if ( $argcnt < $ctl->[CTL_AMIN] ) {
  		    if ( @$argv ) {
  			if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
  			    $arg = shift(@$argv);
  			    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  				$arg =~ tr/_//d;
  				$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  				  ? oct($arg)
  				  : 0+$arg
  			    }
  			    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  			      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  			    next;
  			}
  			warn("Value \"$$argv[0]\" invalid for option $opt\n");
  			$error++;
  		    }
  		    else {
  			warn("Insufficient arguments for option $opt\n");
  			$error++;
  		    }
  		}
  
  		# Any more args?
  		if ( @$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
  		    $arg = shift(@$argv);
  		    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  			$arg =~ tr/_//d;
  			$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  			  ? oct($arg)
  			  : 0+$arg
  		    }
  		    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  		      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  		    next;
  		}
  	    }
  	}
  
  	# Not an option. Save it if we $PERMUTE and don't have a <>.
  	elsif ( $order == $PERMUTE ) {
  	    # Try non-options call-back.
  	    my $cb;
  	    if ( defined ($cb = $linkage{'<>'}) ) {
  		print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
  		  if $debug;
  		my $eval_error = do {
  		    local $@;
  		    local $SIG{__DIE__}  = 'DEFAULT';
  		    eval {
  			# The arg to <> cannot be the CallBack object
  			# since it may be passed to other modules that
  			# get confused (e.g., Archive::Tar). Well,
  			# it's not relevant for this callback anyway.
  			&$cb($tryopt);
  		    };
  		    $@;
  		};
  		print STDERR ("=> die($eval_error)\n")
  		  if $debug && $eval_error ne '';
  		if ( $eval_error =~ /^!/ ) {
  		    if ( $eval_error =~ /^!FINISH\b/ ) {
  			$goon = 0;
  		    }
  		}
  		elsif ( $eval_error ne '' ) {
  		    warn ($eval_error);
  		    $error++;
  		}
  	    }
  	    else {
  		print STDERR ("=> saving \"$tryopt\" ",
  			      "(not an option, may permute)\n") if $debug;
  		push (@ret, $tryopt);
  	    }
  	    next;
  	}
  
  	# ...otherwise, terminate.
  	else {
  	    # Push this one back and exit.
  	    unshift (@$argv, $tryopt);
  	    return ($error == 0);
  	}
  
      }
  
      # Finish.
      if ( @ret && $order == $PERMUTE ) {
  	#  Push back accumulated arguments
  	print STDERR ("=> restoring \"", join('" "', @ret), "\"\n")
  	    if $debug;
  	unshift (@$argv, @ret);
      }
  
      return ($error == 0);
  }
  
  # A readable representation of what's in an optbl.
  sub OptCtl ($) {
      my ($v) = @_;
      my @v = map { defined($_) ? ($_) : ("<undef>") } @$v;
      "[".
        join(",",
  	   "\"$v[CTL_TYPE]\"",
  	   "\"$v[CTL_CNAME]\"",
  	   "\"$v[CTL_DEFAULT]\"",
  	   ("\$","\@","\%","\&")[$v[CTL_DEST] || 0],
  	   $v[CTL_AMIN] || '',
  	   $v[CTL_AMAX] || '',
  #	   $v[CTL_RANGE] || '',
  #	   $v[CTL_REPEAT] || '',
  	  ). "]";
  }
  
  # Parse an option specification and fill the tables.
  sub ParseOptionSpec ($$) {
      my ($opt, $opctl) = @_;
  
      # Match option spec.
      if ( $opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Alias names, or "?"
  		     (?: \| (?: \? | \w[-\w]* ) )*
  		     # Aliases
  		     (?: \| (?: [^-|!+=:][^|!+=:]* )? )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x ) {
  	return (undef, "Error in option spec: \"$opt\"\n");
      }
  
      my ($names, $spec) = ($1, $2);
      $spec = '' unless defined $spec;
  
      # $orig keeps track of the primary name the user specified.
      # This name will be used for the internal or external linkage.
      # In other words, if the user specifies "FoO|BaR", it will
      # match any case combinations of 'foo' and 'bar', but if a global
      # variable needs to be set, it will be $opt_FoO in the exact case
      # as specified.
      my $orig;
  
      my @names;
      if ( defined $names ) {
  	@names =  split (/\|/, $names);
  	$orig = $names[0];
      }
      else {
  	@names = ('');
  	$orig = '';
      }
  
      # Construct the opctl entries.
      my $entry;
      if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
  	# Fields are hard-wired here.
  	$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
      }
      elsif ( $spec =~ /^:(-?\d+|\+)([@%])?$/ ) {
  	my $def = $1;
  	my $dest = $2;
  	my $type = $def eq '+' ? 'I' : 'i';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,$def eq '+' ? undef : $def,
  		  $dest,0,1];
      }
      else {
  	my ($mand, $type, $dest) =
  	  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
  	return (undef, "Cannot repeat while bundling: \"$opt\"\n")
  	  if $bundling && defined($4);
  	my ($mi, $cm, $ma) = ($5, $6, $7);
  	return (undef, "{0} is useless in option spec: \"$opt\"\n")
  	  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
  
  	$type = 'i' if $type eq 'n';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Default minargs to 1/0 depending on mand status.
  	$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
  	# Adjust mand status according to minargs.
  	$mand = $mi ? '=' : ':';
  	# Adjust maxargs.
  	$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
  	return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
  	  if defined($ma) && !$ma;
  	return (undef, "Max less than min in option spec: \"$opt\"\n")
  	  if defined($ma) && $ma < $mi;
  
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
      }
  
      # Process all names. First is canonical, the rest are aliases.
      my $dups = '';
      foreach ( @names ) {
  
  	$_ = lc ($_)
  	  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
  
  	if ( exists $opctl->{$_} ) {
  	    $dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
  	}
  
  	if ( $spec eq '!' ) {
  	    $opctl->{"no$_"} = $entry;
  	    $opctl->{"no-$_"} = $entry;
  	    $opctl->{$_} = [@$entry];
  	    $opctl->{$_}->[CTL_TYPE] = '';
  	}
  	else {
  	    $opctl->{$_} = $entry;
  	}
      }
  
      if ( $dups && $^W ) {
  	foreach ( split(/\n+/, $dups) ) {
  	    warn($_."\n");
  	}
      }
      ($names[0], $orig);
  }
  
  # Option lookup.
  sub FindOption ($$$$$) {
  
      # returns (1, $opt, $ctl, $arg, $key) if okay,
      # returns (1, undef) if option in error,
      # returns (0) otherwise.
  
      my ($argv, $prefix, $argend, $opt, $opctl) = @_;
  
      print STDERR ("=> find \"$opt\"\n") if $debug;
  
      return (0) unless defined($opt);
      return (0) unless $opt =~ /^($prefix)(.*)$/s;
      return (0) if $opt eq "-" && !defined $opctl->{''};
  
      $opt = substr( $opt, length($1) ); # retain taintedness
      my $starter = $1;
  
      print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
  
      my $optarg;			# value supplied with --opt=value
      my $rest;			# remainder from unbundling
  
      # If it is a long option, it may include the value.
      # With getopt_compat, only if not bundling.
      if ( ($starter=~/^$longprefix$/
  	  || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
  	 && (my $oppos = index($opt, '=', 1)) > 0) {
  	my $optorg = $opt;
  	$opt = substr($optorg, 0, $oppos);
  	$optarg = substr($optorg, $oppos + 1); # retain tainedness
  	print STDERR ("=> option \"", $opt,
  		      "\", optarg = \"$optarg\"\n") if $debug;
      }
  
      #### Look it up ###
  
      my $tryopt = $opt;		# option to try
  
      if ( ( $bundling || $bundling_values ) && $starter eq '-' ) {
  
  	# To try overrides, obey case ignore.
  	$tryopt = $ignorecase ? lc($opt) : $opt;
  
  	# If bundling == 2, long options can override bundles.
  	if ( $bundling == 2 && length($tryopt) > 1
  	     && defined ($opctl->{$tryopt}) ) {
  	    print STDERR ("=> $starter$tryopt overrides unbundling\n")
  	      if $debug;
  	}
  
  	# If bundling_values, option may be followed by the value.
  	elsif ( $bundling_values ) {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    # Whatever remains may not be considered an option.
  	    $optarg = $rest eq '' ? undef : $rest;
  	    $rest = undef;
  	}
  
  	# Split off a single letter and leave the rest for
  	# further processing.
  	else {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    $rest = undef unless $rest ne '';
  	}
      }
  
      # Try auto-abbreviation.
      elsif ( $autoabbrev && $opt ne "" ) {
  	# Sort the possible long option names.
  	my @names = sort(keys (%$opctl));
  	# Downcase if allowed.
  	$opt = lc ($opt) if $ignorecase;
  	$tryopt = $opt;
  	# Turn option name into pattern.
  	my $pat = quotemeta ($opt);
  	# Look up in option names.
  	my @hits = grep (/^$pat/, @names);
  	print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
  		      "out of ", scalar(@names), "\n") if $debug;
  
  	# Check for ambiguous results.
  	unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
  	    # See if all matches are for the same option.
  	    my %hit;
  	    foreach ( @hits ) {
  		my $hit = $opctl->{$_}->[CTL_CNAME]
  		  if defined $opctl->{$_}->[CTL_CNAME];
  		$hit = "no" . $hit if $opctl->{$_}->[CTL_TYPE] eq '!';
  		$hit{$hit} = 1;
  	    }
  	    # Remove auto-supplied options (version, help).
  	    if ( keys(%hit) == 2 ) {
  		if ( $auto_version && exists($hit{version}) ) {
  		    delete $hit{version};
  		}
  		elsif ( $auto_help && exists($hit{help}) ) {
  		    delete $hit{help};
  		}
  	    }
  	    # Now see if it really is ambiguous.
  	    unless ( keys(%hit) == 1 ) {
  		return (0) if $passthrough;
  		warn ("Option ", $opt, " is ambiguous (",
  		      join(", ", @hits), ")\n");
  		$error++;
  		return (1, undef);
  	    }
  	    @hits = keys(%hit);
  	}
  
  	# Complete the option name, if appropriate.
  	if ( @hits == 1 && $hits[0] ne $opt ) {
  	    $tryopt = $hits[0];
  	    $tryopt = lc ($tryopt)
  	      if $ignorecase > (($bundling && length($tryopt) == 1) ? 1 : 0);
  	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
  		if $debug;
  	}
      }
  
      # Map to all lowercase if ignoring case.
      elsif ( $ignorecase ) {
  	$tryopt = lc ($opt);
      }
  
      # Check validity by fetching the info.
      my $ctl = $opctl->{$tryopt};
      unless  ( defined $ctl ) {
  	return (0) if $passthrough;
  	# Pretend one char when bundling.
  	if ( $bundling == 1 && length($starter) == 1 ) {
  	    $opt = substr($opt,0,1);
              unshift (@$argv, $starter.$rest) if defined $rest;
  	}
  	if ( $opt eq "" ) {
  	    warn ("Missing option after ", $starter, "\n");
  	}
  	else {
  	    warn ("Unknown option: ", $opt, "\n");
  	}
  	$error++;
  	return (1, undef);
      }
      # Apparently valid.
      $opt = $tryopt;
      print STDERR ("=> found ", OptCtl($ctl),
  		  " for \"", $opt, "\"\n") if $debug;
  
      #### Determine argument status ####
  
      # If it is an option w/o argument, we're almost finished with it.
      my $type = $ctl->[CTL_TYPE];
      my $arg;
  
      if ( $type eq '' || $type eq '!' || $type eq '+' ) {
  	if ( defined $optarg ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " does not take an argument\n");
  	    $error++;
  	    undef $opt;
  	    undef $optarg if $bundling_values;
  	}
  	elsif ( $type eq '' || $type eq '+' ) {
  	    # Supply explicit value.
  	    $arg = 1;
  	}
  	else {
  	    $opt =~ s/^no-?//i;	# strip NO prefix
  	    $arg = 0;		# supply explicit value
  	}
  	unshift (@$argv, $starter.$rest) if defined $rest;
  	return (1, $opt, $ctl, $arg);
      }
  
      # Get mandatory status and type info.
      my $mand = $ctl->[CTL_AMIN];
  
      # Check if there is an option argument available.
      if ( $gnu_compat ) {
  	my $optargtype = 0; # none, 1 = empty, 2 = nonempty, 3 = aux
  	if ( defined($optarg) ) {
  	    $optargtype = (length($optarg) == 0) ? 1 : 2;
  	}
  	elsif ( defined $rest || @$argv > 0 ) {
  	    # GNU getopt_long() does not accept the (optional)
  	    # argument to be passed to the option without = sign.
  	    # We do, since not doing so breaks existing scripts.
  	    $optargtype = 3;
  	}
  	if(($optargtype == 0) && !$mand) {
  	    my $val
  	      = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT]
  	      : $type eq 's'                 ? ''
  	      :                                0;
  	    return (1, $opt, $ctl, $val);
  	}
  	return (1, $opt, $ctl, $type eq 's' ? '' : 0)
  	  if $optargtype == 1;  # --foo=  -> return nothing
      }
  
      # Check if there is an option argument available.
      if ( defined $optarg
  	 ? ($optarg eq '')
  	 : !(defined $rest || @$argv > 0) ) {
  	# Complain if this option needs an argument.
  #	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
  	if ( $mand ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " requires an argument\n");
  	    $error++;
  	    return (1, undef);
  	}
  	if ( $type eq 'I' ) {
  	    # Fake incremental type.
  	    my @c = @$ctl;
  	    $c[CTL_TYPE] = '+';
  	    return (1, $opt, \@c, 1);
  	}
  	return (1, $opt, $ctl,
  		defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  		$type eq 's' ? '' : 0);
      }
  
      # Get (possibly optional) argument.
      $arg = (defined $rest ? $rest
  	    : (defined $optarg ? $optarg : shift (@$argv)));
  
      # Get key if this is a "name=value" pair for a hash option.
      my $key;
      if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
  	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
  	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  	     ($mand ? undef : ($type eq 's' ? "" : 1)));
  	if (! defined $arg) {
  	    warn ("Option $opt, key \"$key\", requires a value\n");
  	    $error++;
  	    # Push back.
  	    unshift (@$argv, $starter.$rest) if defined $rest;
  	    return (1, undef);
  	}
      }
  
      #### Check if the argument is valid for this option ####
  
      my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1, $opt, $ctl, $arg, $key) if $mand;
  
  	# Same for optional string as a hash value
  	return (1, $opt, $ctl, $arg, $key)
  	  if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  
  	# An optional string takes almost anything.
  	return (1, $opt, $ctl, $arg, $key)
  	  if defined $optarg || defined $rest;
  	return (1, $opt, $ctl, $arg, $key) if $arg eq "-"; # ??
  
  	# Check for option or option list terminator.
  	if ($arg eq $argend ||
  	    $arg =~ /^$prefix.+/) {
  	    # Push back.
  	    unshift (@$argv, $arg);
  	    # Supply empty value.
  	    $arg = '';
  	}
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  
  	if ( $bundling && defined $rest
  	     && $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/si ) {
  	    $arg =~ tr/_//d;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (",
  		      $type eq 'o' ? "extended " : '',
  		      "number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		if ( $type eq 'I' ) {
  		    # Fake incremental type.
  		    my @c = @$ctl;
  		    $c[CTL_TYPE] = '+';
  		    return (1, $opt, \@c, 1);
  		}
  		# Supply default value.
  		$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
  	    }
  	}
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	if ( $bundling && defined $rest &&
  	     $rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
  	    $arg =~ tr/_//d;
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/ ) {
  	    $arg =~ tr/_//d;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (real number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		# Supply default value.
  		$arg = 0.0;
  	    }
  	}
      }
      else {
  	die("Getopt::Long internal error (Can't happen)\n");
      }
      return (1, $opt, $ctl, $arg, $key);
  }
  
  sub ValidValue ($$$$$) {
      my ($ctl, $arg, $mand, $argend, $prefix) = @_;
  
      if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  	return 0 unless $arg =~ /[^=]+=(.*)/;
  	$arg = $1;
      }
  
      my $type = $ctl->[CTL_TYPE];
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1) if $mand;
  
  	return (1) if $arg eq "-";
  
  	# Check for option or option list terminator.
  	return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
  	return 1;
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  	return $arg =~ /^$o_valid$/si;
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	return $arg =~ /^$o_valid$/;
      }
      die("ValidValue: Cannot happen\n");
  }
  
  # Getopt::Long Configuration.
  sub Configure (@) {
      my (@options) = @_;
  
      my $prevconfig =
        [ $error, $debug, $major_version, $minor_version, $caller,
  	$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	$longprefix, $bundling_values ];
  
      if ( ref($options[0]) eq 'ARRAY' ) {
  	( $error, $debug, $major_version, $minor_version, $caller,
  	  $autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	  $longprefix, $bundling_values ) = @{shift(@options)};
      }
  
      my $opt;
      foreach $opt ( @options ) {
  	my $try = lc ($opt);
  	my $action = 1;
  	if ( $try =~ /^no_?(.*)$/s ) {
  	    $action = 0;
  	    $try = $+;
  	}
  	if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
  	    ConfigDefaults ();
  	}
  	elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
  	    local $ENV{POSIXLY_CORRECT};
  	    $ENV{POSIXLY_CORRECT} = 1 if $action;
  	    ConfigDefaults ();
  	}
  	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
  	    $autoabbrev = $action;
  	}
  	elsif ( $try eq 'getopt_compat' ) {
  	    $getopt_compat = $action;
              $genprefix = $action ? "(--|-|\\+)" : "(--|-)";
  	}
  	elsif ( $try eq 'gnu_getopt' ) {
  	    if ( $action ) {
  		$gnu_compat = 1;
  		$bundling = 1;
  		$getopt_compat = 0;
                  $genprefix = "(--|-)";
  		$order = $PERMUTE;
  		$bundling_values = 0;
  	    }
  	}
  	elsif ( $try eq 'gnu_compat' ) {
  	    $gnu_compat = $action;
  	    $bundling = 0;
  	    $bundling_values = 1;
  	}
  	elsif ( $try =~ /^(auto_?)?version$/ ) {
  	    $auto_version = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?help$/ ) {
  	    $auto_help = $action;
  	}
  	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
  	    $ignorecase = $action;
  	}
  	elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
  	    $ignorecase = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'bundling' ) {
  	    $bundling = $action;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_override' ) {
  	    $bundling = $action ? 2 : 0;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_values' ) {
  	    $bundling_values = $action;
  	    $bundling = 0 if $action;
  	}
  	elsif ( $try eq 'require_order' ) {
  	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
  	}
  	elsif ( $try eq 'permute' ) {
  	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
  	}
  	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
  	    $passthrough = $action;
  	}
  	elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Turn into regexp. Needs to be parenthesized!
  	    $genprefix = "(" . quotemeta($genprefix) . ")";
  	    eval { '' =~ /$genprefix/; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Parenthesize if needed.
  	    $genprefix = "(" . $genprefix . ")"
  	      unless $genprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$genprefix"; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
  	    $longprefix = $1;
  	    # Parenthesize if needed.
  	    $longprefix = "(" . $longprefix . ")"
  	      unless $longprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$longprefix"; };
  	    die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n") if $@;
  	}
  	elsif ( $try eq 'debug' ) {
  	    $debug = $action;
  	}
  	else {
  	    die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")
  	}
      }
      $prevconfig;
  }
  
  # Deprecated name.
  sub config (@) {
      Configure (@_);
  }
  
  # Issue a standard message for --version.
  #
  # The arguments are mostly the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub VersionMessage(@) {
      # Massage args.
      my $pa = setup_pa_args("version", @_);
  
      my $v = $main::VERSION;
      my $fh = $pa->{-output} ||
        ( ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR );
  
      print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
  	       $0, defined $v ? " version $v" : (),
  	       "\n",
  	       "(", __PACKAGE__, "::", "GetOptions",
  	       " version ",
  	       defined($Getopt::Long::VERSION_STRING)
  	         ? $Getopt::Long::VERSION_STRING : $VERSION, ";",
  	       " Perl version ",
  	       $] >= 5.006 ? sprintf("%vd", $^V) : $],
  	       ")\n");
      exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
  }
  
  # Issue a standard message for --help.
  #
  # The arguments are the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub HelpMessage(@) {
      eval {
  	require Pod::Usage;
  	import Pod::Usage;
  	1;
      } || die("Cannot provide help: cannot load Pod::Usage\n");
  
      # Note that pod2usage will issue a warning if -exitval => NOEXIT.
      pod2usage(setup_pa_args("help", @_));
  
  }
  
  # Helper routine to set up a normalized hash ref to be used as
  # argument to pod2usage.
  sub setup_pa_args($@) {
      my $tag = shift;		# who's calling
  
      # If called by direct binding to an option, it will get the option
      # name and value as arguments. Remove these, if so.
      @_ = () if @_ == 2 && $_[0] eq $tag;
  
      my $pa;
      if ( @_ > 1 ) {
  	$pa = { @_ };
      }
      else {
  	$pa = shift || {};
      }
  
      # At this point, $pa can be a number (exit value), string
      # (message) or hash with options.
  
      if ( UNIVERSAL::isa($pa, 'HASH') ) {
  	# Get rid of -msg vs. -message ambiguity.
  	$pa->{-message} = $pa->{-msg};
  	delete($pa->{-msg});
      }
      elsif ( $pa =~ /^-?\d+$/ ) {
  	$pa = { -exitval => $pa };
      }
      else {
  	$pa = { -message => $pa };
      }
  
      # These are _our_ defaults.
      $pa->{-verbose} = 0 unless exists($pa->{-verbose});
      $pa->{-exitval} = 0 unless exists($pa->{-exitval});
      $pa;
  }
  
  # Sneak way to know what version the user requested.
  sub VERSION {
      $requested_version = $_[1];
      shift->SUPER::VERSION(@_);
  }
  
  package Getopt::Long::CallBack;
  
  sub new {
      my ($pkg, %atts) = @_;
      bless { %atts }, $pkg;
  }
  
  sub name {
      my $self = shift;
      ''.$self->{name};
  }
  
  use overload
    # Treat this object as an ordinary string for legacy API.
    '""'	   => \&name,
    fallback => 1;
  
  1;
  
  ################ Documentation ################
  
  =head1 NAME
  
  Getopt::Long - Extended processing of command line options
  
  =head1 SYNOPSIS
  
    use Getopt::Long;
    my $data   = "file.dat";
    my $length = 24;
    my $verbose;
    GetOptions ("length=i" => \$length,    # numeric
                "file=s"   => \$data,      # string
                "verbose"  => \$verbose)   # flag
    or die("Error in command line arguments\n");
  
  =head1 DESCRIPTION
  
  The Getopt::Long module implements an extended getopt function called
  GetOptions(). It parses the command line from C<@ARGV>, recognizing
  and removing specified options and their possible values.
  
  This function adheres to the POSIX syntax for command
  line options, with GNU extensions. In general, this means that options
  have long names instead of single letters, and are introduced with a
  double dash "--". Support for bundling of command line options, as was
  the case with the more traditional single-letter approach, is provided
  but not enabled by default.
  
  =head1 Command Line Options, an Introduction
  
  Command line operated programs traditionally take their arguments from
  the command line, for example filenames or other information that the
  program needs to know. Besides arguments, these programs often take
  command line I<options> as well. Options are not necessary for the
  program to work, hence the name 'option', but are used to modify its
  default behaviour. For example, a program could do its job quietly,
  but with a suitable option it could provide verbose information about
  what it did.
  
  Command line options come in several flavours. Historically, they are
  preceded by a single dash C<->, and consist of a single letter.
  
      -l -a -c
  
  Usually, these single-character options can be bundled:
  
      -lac
  
  Options can have values, the value is placed after the option
  character. Sometimes with whitespace in between, sometimes not:
  
      -s 24 -s24
  
  Due to the very cryptic nature of these options, another style was
  developed that used long names. So instead of a cryptic C<-l> one
  could use the more descriptive C<--long>. To distinguish between a
  bundle of single-character options and a long one, two dashes are used
  to precede the option name. Early implementations of long options used
  a plus C<+> instead. Also, option values could be specified either
  like
  
      --size=24
  
  or
  
      --size 24
  
  The C<+> form is now obsolete and strongly deprecated.
  
  =head1 Getting Started with Getopt::Long
  
  Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was the
  first Perl module that provided support for handling the new style of
  command line options, in particular long option names, hence the Perl5
  name Getopt::Long. This module also supports single-character options
  and bundling.
  
  To use Getopt::Long from a Perl program, you must include the
  following line in your Perl program:
  
      use Getopt::Long;
  
  This will load the core of the Getopt::Long module and prepare your
  program for using it. Most of the actual Getopt::Long code is not
  loaded until you really call one of its functions.
  
  In the default configuration, options names may be abbreviated to
  uniqueness, case does not matter, and a single dash is sufficient,
  even for long option names. Also, options may be placed between
  non-option arguments. See L<Configuring Getopt::Long> for more
  details on how to configure Getopt::Long.
  
  =head2 Simple options
  
  The most simple options are the ones that take no values. Their mere
  presence on the command line enables the option. Popular examples are:
  
      --all --verbose --quiet --debug
  
  Handling simple options is straightforward:
  
      my $verbose = '';	# option variable with default value (false)
      my $all = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose, 'all' => \$all);
  
  The call to GetOptions() parses the command line arguments that are
  present in C<@ARGV> and sets the option variable to the value C<1> if
  the option did occur on the command line. Otherwise, the option
  variable is not touched. Setting the option value to true is often
  called I<enabling> the option.
  
  The option name as specified to the GetOptions() function is called
  the option I<specification>. Later we'll see that this specification
  can contain more than just the option name. The reference to the
  variable is called the option I<destination>.
  
  GetOptions() will return a true value if the command line could be
  processed successfully. Otherwise, it will write error messages using
  die() and warn(), and return a false result.
  
  =head2 A little bit less simple options
  
  Getopt::Long supports two useful variants of simple options:
  I<negatable> options and I<incremental> options.
  
  A negatable option is specified with an exclamation mark C<!> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose!' => \$verbose);
  
  Now, using C<--verbose> on the command line will enable C<$verbose>,
  as expected. But it is also allowed to use C<--noverbose>, which will
  disable C<$verbose> by setting its value to C<0>. Using a suitable
  default value, the program can find out whether C<$verbose> is false
  by default, or disabled by using C<--noverbose>.
  
  An incremental option is specified with a plus C<+> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose+' => \$verbose);
  
  Using C<--verbose> on the command line will increment the value of
  C<$verbose>. This way the program can keep track of how many times the
  option occurred on the command line. For example, each occurrence of
  C<--verbose> could increase the verbosity level of the program.
  
  =head2 Mixing command line option with other arguments
  
  Usually programs take command line options as well as other arguments,
  for example, file names. It is good practice to always specify the
  options first, and the other arguments last. Getopt::Long will,
  however, allow the options and arguments to be mixed and 'filter out'
  all the options before passing the rest of the arguments to the
  program. To stop Getopt::Long from processing further arguments,
  insert a double dash C<--> on the command line:
  
      --size 24 -- --all
  
  In this example, C<--all> will I<not> be treated as an option, but
  passed to the program unharmed, in C<@ARGV>.
  
  =head2 Options with values
  
  For options that take values it must be specified whether the option
  value is required or not, and what kind of value the option expects.
  
  Three kinds of values are supported: integer numbers, floating point
  numbers, and strings.
  
  If the option value is required, Getopt::Long will take the
  command line argument that follows the option and assign this to the
  option variable. If, however, the option value is specified as
  optional, this will only be done if that value does not look like a
  valid command line option itself.
  
      my $tag = '';	# option variable with default value
      GetOptions ('tag=s' => \$tag);
  
  In the option specification, the option name is followed by an equals
  sign C<=> and the letter C<s>. The equals sign indicates that this
  option requires a value. The letter C<s> indicates that this value is
  an arbitrary string. Other possible value types are C<i> for integer
  values, and C<f> for floating point values. Using a colon C<:> instead
  of the equals sign indicates that the option value is optional. In
  this case, if no suitable value is supplied, string valued options get
  an empty string C<''> assigned, while numeric options are set to C<0>.
  
  =head2 Options with multiple values
  
  Options sometimes take several values. For example, a program could
  use multiple directories to search for library files:
  
      --library lib/stdlib --library lib/extlib
  
  To accomplish this behaviour, simply specify an array reference as the
  destination for the option:
  
      GetOptions ("library=s" => \@libfiles);
  
  Alternatively, you can specify that the option can have multiple
  values by adding a "@", and pass a reference to a scalar as the
  destination:
  
      GetOptions ("library=s@" => \$libfiles);
  
  Used with the example above, C<@libfiles> c.q. C<@$libfiles> would
  contain two strings upon completion: C<"lib/stdlib"> and
  C<"lib/extlib">, in that order. It is also possible to specify that
  only integer or floating point numbers are acceptable values.
  
  Often it is useful to allow comma-separated lists of values as well as
  multiple occurrences of the options. This is easy using Perl's split()
  and join() operators:
  
      GetOptions ("library=s" => \@libfiles);
      @libfiles = split(/,/,join(',',@libfiles));
  
  Of course, it is important to choose the right separator string for
  each purpose.
  
  Warning: What follows is an experimental feature.
  
  Options can take multiple values at once, for example
  
      --coordinates 52.2 16.4 --rgbcolor 255 255 149
  
  This can be accomplished by adding a repeat specifier to the option
  specification. Repeat specifiers are very similar to the C<{...}>
  repeat specifiers that can be used with regular expression patterns.
  For example, the above command line would be handled as follows:
  
      GetOptions('coordinates=f{2}' => \@coor, 'rgbcolor=i{3}' => \@color);
  
  The destination for the option must be an array or array reference.
  
  It is also possible to specify the minimal and maximal number of
  arguments an option takes. C<foo=s{2,4}> indicates an option that
  takes at least two and at most 4 arguments. C<foo=s{1,}> indicates one
  or more values; C<foo:s{,}> indicates zero or more option values.
  
  =head2 Options with hash values
  
  If the option destination is a reference to a hash, the option will
  take, as value, strings of the form I<key>C<=>I<value>. The value will
  be stored with the specified key in the hash.
  
      GetOptions ("define=s" => \%defines);
  
  Alternatively you can use:
  
      GetOptions ("define=s%" => \$defines);
  
  When used with command line options:
  
      --define os=linux --define vendor=redhat
  
  the hash C<%defines> (or C<%$defines>) will contain two keys, C<"os">
  with value C<"linux"> and C<"vendor"> with value C<"redhat">. It is
  also possible to specify that only integer or floating point numbers
  are acceptable values. The keys are always taken to be strings.
  
  =head2 User-defined subroutines to handle options
  
  Ultimate control over what should be done when (actually: each time)
  an option is encountered on the command line can be achieved by
  designating a reference to a subroutine (or an anonymous subroutine)
  as the option destination. When GetOptions() encounters the option, it
  will call the subroutine with two or three arguments. The first
  argument is the name of the option. (Actually, it is an object that
  stringifies to the name of the option.) For a scalar or array destination,
  the second argument is the value to be stored. For a hash destination,
  the second argument is the key to the hash, and the third argument
  the value to be stored. It is up to the subroutine to store the value,
  or do whatever it thinks is appropriate.
  
  A trivial application of this mechanism is to implement options that
  are related to each other. For example:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose,
  	        'quiet'   => sub { $verbose = 0 });
  
  Here C<--verbose> and C<--quiet> control the same variable
  C<$verbose>, but with opposite values.
  
  If the subroutine needs to signal an error, it should call die() with
  the desired error message as its argument. GetOptions() will catch the
  die(), issue the error message, and record that an error result must
  be returned upon completion.
  
  If the text of the error message starts with an exclamation mark C<!>
  it is interpreted specially by GetOptions(). There is currently one
  special command implemented: C<die("!FINISH")> will cause GetOptions()
  to stop processing options, as if it encountered a double dash C<-->.
  
  In version 2.37 the first argument to the callback function was
  changed from string to object. This was done to make room for
  extensions and more detailed control. The object stringifies to the
  option name so this change should not introduce compatibility
  problems.
  
  Here is an example of how to access the option name and value from within
  a subroutine:
  
      GetOptions ('opt=i' => \&handler);
      sub handler {
          my ($opt_name, $opt_value) = @_;
          print("Option name is $opt_name and value is $opt_value\n");
      }
  
  =head2 Options with multiple names
  
  Often it is user friendly to supply alternate mnemonic names for
  options. For example C<--height> could be an alternate name for
  C<--length>. Alternate names can be included in the option
  specification, separated by vertical bar C<|> characters. To implement
  the above example:
  
      GetOptions ('length|height=f' => \$length);
  
  The first name is called the I<primary> name, the other names are
  called I<aliases>. When using a hash to store options, the key will
  always be the primary name.
  
  Multiple alternate names are possible.
  
  =head2 Case and abbreviations
  
  Without additional configuration, GetOptions() will ignore the case of
  option names, and allow the options to be abbreviated to uniqueness.
  
      GetOptions ('length|height=f' => \$length, "head" => \$head);
  
  This call will allow C<--l> and C<--L> for the length option, but
  requires a least C<--hea> and C<--hei> for the head and height options.
  
  =head2 Summary of Option Specifications
  
  Each option specifier consists of two parts: the name specification
  and the argument specification.
  
  The name specification contains the name of the option, optionally
  followed by a list of alternative names separated by vertical bar
  characters.
  
      length	      option name is "length"
      length|size|l     name is "length", aliases are "size" and "l"
  
  The argument specification is optional. If omitted, the option is
  considered boolean, a value of 1 will be assigned when the option is
  used on the command line.
  
  The argument specification can be
  
  =over 4
  
  =item !
  
  The option does not take an argument and may be negated by prefixing
  it with "no" or "no-". E.g. C<"foo!"> will allow C<--foo> (a value of
  1 will be assigned) as well as C<--nofoo> and C<--no-foo> (a value of
  0 will be assigned). If the option has aliases, this applies to the
  aliases as well.
  
  Using negation on a single letter option when bundling is in effect is
  pointless and will result in a warning.
  
  =item +
  
  The option does not take an argument and will be incremented by 1
  every time it appears on the command line. E.g. C<"more+">, when used
  with C<--more --more --more>, will increment the value three times,
  resulting in a value of 3 (provided it was 0 or undefined at first).
  
  The C<+> specifier is ignored if the option destination is not a scalar.
  
  =item = I<type> [ I<desttype> ] [ I<repeat> ]
  
  The option requires an argument of the given type. Supported types
  are:
  
  =over 4
  
  =item s
  
  String. An arbitrary sequence of characters. It is valid for the
  argument to start with C<-> or C<-->.
  
  =item i
  
  Integer. An optional leading plus or minus sign, followed by a
  sequence of digits.
  
  =item o
  
  Extended integer, Perl style. This can be either an optional leading
  plus or minus sign, followed by a sequence of digits, or an octal
  string (a zero, optionally followed by '0', '1', .. '7'), or a
  hexadecimal string (C<0x> followed by '0' .. '9', 'a' .. 'f', case
  insensitive), or a binary string (C<0b> followed by a series of '0'
  and '1').
  
  =item f
  
  Real number. For example C<3.14>, C<-6.23E24> and so on.
  
  =back
  
  The I<desttype> can be C<@> or C<%> to specify that the option is
  list or a hash valued. This is only needed when the destination for
  the option value is not otherwise specified. It should be omitted when
  not needed.
  
  The I<repeat> specifies the number of values this option takes per
  occurrence on the command line. It has the format C<{> [ I<min> ] [ C<,> [ I<max> ] ] C<}>.
  
  I<min> denotes the minimal number of arguments. It defaults to 1 for
  options with C<=> and to 0 for options with C<:>, see below. Note that
  I<min> overrules the C<=> / C<:> semantics.
  
  I<max> denotes the maximum number of arguments. It must be at least
  I<min>. If I<max> is omitted, I<but the comma is not>, there is no
  upper bound to the number of argument values taken.
  
  =item : I<type> [ I<desttype> ]
  
  Like C<=>, but designates the argument as optional.
  If omitted, an empty string will be assigned to string values options,
  and the value zero to numeric options.
  
  Note that if a string argument starts with C<-> or C<-->, it will be
  considered an option on itself.
  
  =item : I<number> [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the I<number> will be assigned.
  
  =item : + [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the current value for the
  option will be incremented.
  
  =back
  
  =head1 Advanced Possibilities
  
  =head2 Object oriented interface
  
  Getopt::Long can be used in an object oriented way as well:
  
      use Getopt::Long;
      $p = Getopt::Long::Parser->new;
      $p->configure(...configuration options...);
      if ($p->getoptions(...options descriptions...)) ...
      if ($p->getoptionsfromarray( \@array, ...options descriptions...)) ...
  
  Configuration options can be passed to the constructor:
  
      $p = new Getopt::Long::Parser
               config => [...configuration options...];
  
  =head2 Thread Safety
  
  Getopt::Long is thread safe when using ithreads as of Perl 5.8.  It is
  I<not> thread safe when using the older (experimental and now
  obsolete) threads implementation that was added to Perl 5.005.
  
  =head2 Documentation and help texts
  
  Getopt::Long encourages the use of Pod::Usage to produce help
  messages. For example:
  
      use Getopt::Long;
      use Pod::Usage;
  
      my $man = 0;
      my $help = 0;
  
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-exitval => 0, -verbose => 2) if $man;
  
      __END__
  
      =head1 NAME
  
      sample - Using Getopt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 8
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  See L<Pod::Usage> for details.
  
  =head2 Parsing options from an arbitrary array
  
  By default, GetOptions parses the options that are present in the
  global array C<@ARGV>. A special entry C<GetOptionsFromArray> can be
  used to parse options from an arbitrary array.
  
      use Getopt::Long qw(GetOptionsFromArray);
      $ret = GetOptionsFromArray(\@myopts, ...);
  
  When used like this, options and their possible values are removed
  from C<@myopts>, the global C<@ARGV> is not touched at all.
  
  The following two calls behave identically:
  
      $ret = GetOptions( ... );
      $ret = GetOptionsFromArray(\@ARGV, ... );
  
  This also means that a first argument hash reference now becomes the
  second argument:
  
      $ret = GetOptions(\%opts, ... );
      $ret = GetOptionsFromArray(\@ARGV, \%opts, ... );
  
  =head2 Parsing options from an arbitrary string
  
  A special entry C<GetOptionsFromString> can be used to parse options
  from an arbitrary string.
  
      use Getopt::Long qw(GetOptionsFromString);
      $ret = GetOptionsFromString($string, ...);
  
  The contents of the string are split into arguments using a call to
  C<Text::ParseWords::shellwords>. As with C<GetOptionsFromArray>, the
  global C<@ARGV> is not touched.
  
  It is possible that, upon completion, not all arguments in the string
  have been processed. C<GetOptionsFromString> will, when called in list
  context, return both the return status and an array reference to any
  remaining arguments:
  
      ($ret, $args) = GetOptionsFromString($string, ... );
  
  If any arguments remain, and C<GetOptionsFromString> was not called in
  list context, a message will be given and C<GetOptionsFromString> will
  return failure.
  
  As with GetOptionsFromArray, a first argument hash reference now
  becomes the second argument.
  
  =head2 Storing options values in a hash
  
  Sometimes, for example when there are a lot of options, having a
  separate variable for each of them can be cumbersome. GetOptions()
  supports, as an alternative mechanism, storing options values in a
  hash.
  
  To obtain this, a reference to a hash must be passed I<as the first
  argument> to GetOptions(). For each option that is specified on the
  command line, the option value will be stored in the hash with the
  option name as key. Options that are not actually used on the command
  line will not be put in the hash, on other words,
  C<exists($h{option})> (or defined()) can be used to test if an option
  was used. The drawback is that warnings will be issued if the program
  runs under C<use strict> and uses C<$h{option}> without testing with
  exists() or defined() first.
  
      my %h = ();
      GetOptions (\%h, 'length=i');	# will store in $h{length}
  
  For options that take list or hash values, it is necessary to indicate
  this by appending an C<@> or C<%> sign after the type:
  
      GetOptions (\%h, 'colours=s@');	# will push to @{$h{colours}}
  
  To make things more complicated, the hash may contain references to
  the actual destinations, for example:
  
      my $len = 0;
      my %h = ('length' => \$len);
      GetOptions (\%h, 'length=i');	# will store in $len
  
  This example is fully equivalent with:
  
      my $len = 0;
      GetOptions ('length=i' => \$len);	# will store in $len
  
  Any mixture is possible. For example, the most frequently used options
  could be stored in variables while all other options get stored in the
  hash:
  
      my $verbose = 0;			# frequently referred
      my $debug = 0;			# frequently referred
      my %h = ('verbose' => \$verbose, 'debug' => \$debug);
      GetOptions (\%h, 'verbose', 'debug', 'filter', 'size=i');
      if ( $verbose ) { ... }
      if ( exists $h{filter} ) { ... option 'filter' was specified ... }
  
  =head2 Bundling
  
  With bundling it is possible to set several single-character options
  at once. For example if C<a>, C<v> and C<x> are all valid options,
  
      -vax
  
  will set all three.
  
  Getopt::Long supports three styles of bundling. To enable bundling, a
  call to Getopt::Long::Configure is required.
  
  The simplest style of bundling can be enabled with:
  
      Getopt::Long::Configure ("bundling");
  
  Configured this way, single-character options can be bundled but long
  options B<must> always start with a double dash C<--> to avoid
  ambiguity. For example, when C<vax>, C<a>, C<v> and C<x> are all valid
  options,
  
      -vax
  
  will set C<a>, C<v> and C<x>, but
  
      --vax
  
  will set C<vax>.
  
  The second style of bundling lifts this restriction. It can be enabled
  with:
  
      Getopt::Long::Configure ("bundling_override");
  
  Now, C<-vax> will set the option C<vax>.
  
  In all of the above cases, option values may be inserted in the
  bundle. For example:
  
      -h24w80
  
  is equivalent to
  
      -h 24 -w 80
  
  A third style of bundling allows only values to be bundled with
  options. It can be enabled with:
  
      Getopt::Long::Configure ("bundling_values");
  
  Now, C<-h24> will set the option C<h> to C<24>, but option bundles
  like C<-vxa> and C<-h24w80> are flagged as errors.
  
  Enabling C<bundling_values> will disable the other two styles of
  bundling.
  
  When configured for bundling, single-character options are matched
  case sensitive while long options are matched case insensitive. To
  have the single-character options matched case insensitive as well,
  use:
  
      Getopt::Long::Configure ("bundling", "ignorecase_always");
  
  It goes without saying that bundling can be quite confusing.
  
  =head2 The lonesome dash
  
  Normally, a lone dash C<-> on the command line will not be considered
  an option. Option processing will terminate (unless "permute" is
  configured) and the dash will be left in C<@ARGV>.
  
  It is possible to get special treatment for a lone dash. This can be
  achieved by adding an option specification with an empty name, for
  example:
  
      GetOptions ('' => \$stdio);
  
  A lone dash on the command line will now be a legal option, and using
  it will set variable C<$stdio>.
  
  =head2 Argument callback
  
  A special option 'name' C<< <> >> can be used to designate a subroutine
  to handle non-option arguments. When GetOptions() encounters an
  argument that does not look like an option, it will immediately call this
  subroutine and passes it one parameter: the argument name. Well, actually
  it is an object that stringifies to the argument name.
  
  For example:
  
      my $width = 80;
      sub process { ... }
      GetOptions ('width=i' => \$width, '<>' => \&process);
  
  When applied to the following command line:
  
      arg1 --width=72 arg2 --width=60 arg3
  
  This will call
  C<process("arg1")> while C<$width> is C<80>,
  C<process("arg2")> while C<$width> is C<72>, and
  C<process("arg3")> while C<$width> is C<60>.
  
  This feature requires configuration option B<permute>, see section
  L<Configuring Getopt::Long>.
  
  =head1 Configuring Getopt::Long
  
  Getopt::Long can be configured by calling subroutine
  Getopt::Long::Configure(). This subroutine takes a list of quoted
  strings, each specifying a configuration option to be enabled, e.g.
  C<ignore_case>, or disabled, e.g. C<no_ignore_case>. Case does not
  matter. Multiple calls to Configure() are possible.
  
  Alternatively, as of version 2.24, the configuration options may be
  passed together with the C<use> statement:
  
      use Getopt::Long qw(:config no_ignore_case bundling);
  
  The following options are available:
  
  =over 12
  
  =item default
  
  This option causes all configuration options to be reset to their
  default values.
  
  =item posix_default
  
  This option causes all configuration options to be reset to their
  default values as if the environment variable POSIXLY_CORRECT had
  been set.
  
  =item auto_abbrev
  
  Allow option names to be abbreviated to uniqueness.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is disabled.
  
  =item getopt_compat
  
  Allow C<+> to start options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<getopt_compat> is disabled.
  
  =item gnu_compat
  
  C<gnu_compat> controls whether C<--opt=> is allowed, and what it should
  do. Without C<gnu_compat>, C<--opt=> gives an error. With C<gnu_compat>,
  C<--opt=> will give option C<opt> and empty value.
  This is the way GNU getopt_long() does it.
  
  Note that C<--opt value> is still accepted, even though GNU
  getopt_long() doesn't.
  
  =item gnu_getopt
  
  This is a short way of setting C<gnu_compat> C<bundling> C<permute>
  C<no_getopt_compat>. With C<gnu_getopt>, command line handling should be
  reasonably compatible with GNU getopt_long().
  
  =item require_order
  
  Whether command line arguments are allowed to be mixed with options.
  Default is disabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<require_order> is enabled.
  
  See also C<permute>, which is the opposite of C<require_order>.
  
  =item permute
  
  Whether command line arguments are allowed to be mixed with options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<permute> is disabled.
  Note that C<permute> is the opposite of C<require_order>.
  
  If C<permute> is enabled, this means that
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo --bar arg1 arg2 arg3
  
  If an argument callback routine is specified, C<@ARGV> will always be
  empty upon successful return of GetOptions() since all options have been
  processed. The only exception is when C<--> is used:
  
      --foo arg1 --bar arg2 -- arg3
  
  This will call the callback routine for arg1 and arg2, and then
  terminate GetOptions() leaving C<"arg3"> in C<@ARGV>.
  
  If C<require_order> is enabled, options processing
  terminates when the first non-option is encountered.
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo -- arg1 --bar arg2 arg3
  
  If C<pass_through> is also enabled, options processing will terminate
  at the first unrecognized option, or non-option, whichever comes
  first.
  
  =item bundling (default: disabled)
  
  Enabling this option will allow single-character options to be
  bundled. To distinguish bundles from long option names, long options
  I<must> be introduced with C<--> and bundles with C<->.
  
  Note that, if you have options C<a>, C<l> and C<all>, and
  auto_abbrev enabled, possible arguments and option settings are:
  
      using argument               sets option(s)
      ------------------------------------------
      -a, --a                      a
      -l, --l                      l
      -al, -la, -ala, -all,...     a, l
      --al, --all                  all
  
  The surprising part is that C<--a> sets option C<a> (due to auto
  completion), not C<all>.
  
  Note: disabling C<bundling> also disables C<bundling_override>.
  
  =item bundling_override (default: disabled)
  
  If C<bundling_override> is enabled, bundling is enabled as with
  C<bundling> but now long option names override option bundles.
  
  Note: disabling C<bundling_override> also disables C<bundling>.
  
  B<Note:> Using option bundling can easily lead to unexpected results,
  especially when mixing long options and bundles. Caveat emptor.
  
  =item ignore_case  (default: enabled)
  
  If enabled, case is ignored when matching option names. If, however,
  bundling is enabled as well, single character options will be treated
  case-sensitive.
  
  With C<ignore_case>, option specifications for options that only
  differ in case, e.g., C<"foo"> and C<"Foo">, will be flagged as
  duplicates.
  
  Note: disabling C<ignore_case> also disables C<ignore_case_always>.
  
  =item ignore_case_always (default: disabled)
  
  When bundling is in effect, case is ignored on single-character
  options also.
  
  Note: disabling C<ignore_case_always> also disables C<ignore_case>.
  
  =item auto_version (default:disabled)
  
  Automatically provide support for the B<--version> option if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a standard version message that includes the
  program name, its version (if $main::VERSION is defined), and the
  versions of Getopt::Long and Perl. The message will be written to
  standard output and processing will terminate.
  
  C<auto_version> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item auto_help (default:disabled)
  
  Automatically provide support for the B<--help> and B<-?> options if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a help message using module L<Pod::Usage>. The
  message, derived from the SYNOPSIS POD section, will be written to
  standard output and processing will terminate.
  
  C<auto_help> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item pass_through (default: disabled)
  
  With C<pass_through> anything that is unknown, ambiguous or supplied with
  an invalid option will not be flagged as an error. Instead the unknown
  option(s) will be passed to the catchall C<< <> >> if present, otherwise
  through to C<@ARGV>. This makes it possible to write wrapper scripts that
  process only part of the user supplied command line arguments, and pass the
  remaining options to some other program.
  
  If C<require_order> is enabled, options processing will terminate at the
  first unrecognized option, or non-option, whichever comes first and all
  remaining arguments are passed to C<@ARGV> instead of the catchall
  C<< <> >> if present.  However, if C<permute> is enabled instead, results
  can become confusing.
  
  Note that the options terminator (default C<-->), if present, will
  also be passed through in C<@ARGV>.
  
  =item prefix
  
  The string that starts options. If a constant string is not
  sufficient, see C<prefix_pattern>.
  
  =item prefix_pattern
  
  A Perl pattern that identifies the strings that introduce options.
  Default is C<--|-|\+> unless environment variable
  POSIXLY_CORRECT has been set, in which case it is C<--|->.
  
  =item long_prefix_pattern
  
  A Perl pattern that allows the disambiguation of long and short
  prefixes. Default is C<-->.
  
  Typically you only need to set this if you are using nonstandard
  prefixes and want some or all of them to have the same semantics as
  '--' does under normal circumstances.
  
  For example, setting prefix_pattern to C<--|-|\+|\/> and
  long_prefix_pattern to C<--|\/> would add Win32 style argument
  handling.
  
  =item debug (default: disabled)
  
  Enable debugging output.
  
  =back
  
  =head1 Exportable Methods
  
  =over
  
  =item VersionMessage
  
  This subroutine provides a standard version message. Its argument can be:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the standard message.
  
  =item *
  
  A numeric value corresponding to the desired exit status.
  
  =item *
  
  A reference to a hash.
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message>
  
  =item C<-msg>
  
  The text of a message to print immediately prior to printing the
  program's usage message.
  
  =item C<-exitval>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string "NOEXIT" to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-output>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =back
  
  You cannot tie this routine directly to an option, e.g.:
  
      GetOptions("version" => \&VersionMessage);
  
  Use this instead:
  
      GetOptions("version" => sub { VersionMessage() });
  
  =item HelpMessage
  
  This subroutine produces a standard help message, derived from the
  program's POD section SYNOPSIS using L<Pod::Usage>. It takes the same
  arguments as VersionMessage(). In particular, you cannot tie it
  directly to an option, e.g.:
  
      GetOptions("help" => \&HelpMessage);
  
  Use this instead:
  
      GetOptions("help" => sub { HelpMessage() });
  
  =back
  
  =head1 Return values and Errors
  
  Configuration errors and errors in the option definitions are
  signalled using die() and will terminate the calling program unless
  the call to Getopt::Long::GetOptions() was embedded in C<eval { ...
  }>, or die() was trapped using C<$SIG{__DIE__}>.
  
  GetOptions returns true to indicate success.
  It returns false when the function detected one or more errors during
  option parsing. These errors are signalled using warn() and can be
  trapped with C<$SIG{__WARN__}>.
  
  =head1 Legacy
  
  The earliest development of C<newgetopt.pl> started in 1990, with Perl
  version 4. As a result, its development, and the development of
  Getopt::Long, has gone through several stages. Since backward
  compatibility has always been extremely important, the current version
  of Getopt::Long still supports a lot of constructs that nowadays are
  no longer necessary or otherwise unwanted. This section describes
  briefly some of these 'features'.
  
  =head2 Default destinations
  
  When no destination is specified for an option, GetOptions will store
  the resultant value in a global variable named C<opt_>I<XXX>, where
  I<XXX> is the primary name of this option. When a program executes
  under C<use strict> (recommended), these variables must be
  pre-declared with our() or C<use vars>.
  
      our $opt_length = 0;
      GetOptions ('length=i');	# will store in $opt_length
  
  To yield a usable Perl variable, characters that are not part of the
  syntax for variables are translated to underscores. For example,
  C<--fpp-struct-return> will set the variable
  C<$opt_fpp_struct_return>. Note that this variable resides in the
  namespace of the calling program, not necessarily C<main>. For
  example:
  
      GetOptions ("size=i", "sizes=i@");
  
  with command line "-size 10 -sizes 24 -sizes 48" will perform the
  equivalent of the assignments
  
      $opt_size = 10;
      @opt_sizes = (24, 48);
  
  =head2 Alternative option starters
  
  A string of alternative option starter characters may be passed as the
  first argument (or the first argument after a leading hash reference
  argument).
  
      my $len = 0;
      GetOptions ('/', 'length=i' => $len);
  
  Now the command line may look like:
  
      /length 24 -- arg
  
  Note that to terminate options processing still requires a double dash
  C<-->.
  
  GetOptions() will not interpret a leading C<< "<>" >> as option starters
  if the next argument is a reference. To force C<< "<" >> and C<< ">" >> as
  option starters, use C<< "><" >>. Confusing? Well, B<using a starter
  argument is strongly deprecated> anyway.
  
  =head2 Configuration variables
  
  Previous versions of Getopt::Long used variables for the purpose of
  configuring. Although manipulating these variables still work, it is
  strongly encouraged to use the C<Configure> routine that was introduced
  in version 2.17. Besides, it is much easier.
  
  =head1 Tips and Techniques
  
  =head2 Pushing multiple values in a hash option
  
  Sometimes you want to combine the best of hashes and arrays. For
  example, the command line:
  
    --list add=first --list add=second --list add=third
  
  where each successive 'list add' option will push the value of add
  into array ref $list->{'add'}. The result would be like
  
    $list->{add} = [qw(first second third)];
  
  This can be accomplished with a destination routine:
  
    GetOptions('list=s%' =>
                 sub { push(@{$list{$_[1]}}, $_[2]) });
  
  =head1 Troubleshooting
  
  =head2 GetOptions does not return a false result when an option is not supplied
  
  That's why they're called 'options'.
  
  =head2 GetOptions does not split the command line correctly
  
  The command line is not split by GetOptions, but by the command line
  interpreter (CLI). On Unix, this is the shell. On Windows, it is
  COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.
  
  It is important to know that these CLIs may behave different when the
  command line contains special characters, in particular quotes or
  backslashes. For example, with Unix shells you can use single quotes
  (C<'>) and double quotes (C<">) to group words together. The following
  alternatives are equivalent on Unix:
  
      "two words"
      'two words'
      two\ words
  
  In case of doubt, insert the following statement in front of your Perl
  program:
  
      print STDERR (join("|",@ARGV),"\n");
  
  to verify how your CLI passes the arguments to the program.
  
  =head2 Undefined subroutine &main::GetOptions called
  
  Are you running Windows, and did you write
  
      use GetOpt::Long;
  
  (note the capital 'O')?
  
  =head2 How do I put a "-?" option into a Getopt::Long?
  
  You can only obtain this using an alias, and Getopt::Long of at least
  version 2.13.
  
      use Getopt::Long;
      GetOptions ("help|?");    # -help and -? will both set $opt_help
  
  Other characters that can't appear in Perl identifiers are also supported
  as aliases with Getopt::Long of at least version 2.39.
  
  As of version 2.32 Getopt::Long provides auto-help, a quick and easy way
  to add the options --help and -? to your program, and handle them.
  
  See C<auto_help> in section L<Configuring Getopt::Long>.
  
  =head1 AUTHOR
  
  Johan Vromans <jvromans@squirrel.nl>
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  This program is Copyright 1990,2015 by Johan Vromans.
  This program is free software; you can redistribute it and/or
  modify it under the terms of the Perl Artistic License or the
  GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any
  later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  If you do not have a copy of the GNU General Public License write to
  the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
  MA 02139, USA.
  
  =cut
  
GETOPT_LONG

$fatpacked{"MRO/Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MRO_COMPAT';
  package MRO::Compat;
  use strict;
  use warnings;
  require 5.006_000;
  
  # Keep this < 1.00, so people can tell the fake
  #  mro.pm from the real one
  our $VERSION = '0.13';
  
  BEGIN {
      # Alias our private functions over to
      # the mro:: namespace and load
      # Class::C3 if Perl < 5.9.5
      if($] < 5.009_005) {
          $mro::VERSION # to fool Module::Install when generating META.yml
              = $VERSION;
          $INC{'mro.pm'} = __FILE__;
          *mro::import            = \&__import;
          *mro::get_linear_isa    = \&__get_linear_isa;
          *mro::set_mro           = \&__set_mro;
          *mro::get_mro           = \&__get_mro;
          *mro::get_isarev        = \&__get_isarev;
          *mro::is_universal      = \&__is_universal;
          *mro::method_changed_in = \&__method_changed_in;
          *mro::invalidate_all_method_caches
                                  = \&__invalidate_all_method_caches;
          require Class::C3;
          if($Class::C3::XS::VERSION && $Class::C3::XS::VERSION > 0.03) {
              *mro::get_pkg_gen   = \&__get_pkg_gen_c3xs;
          }
          else {
              *mro::get_pkg_gen   = \&__get_pkg_gen_pp;
          }
      }
  
      # Load mro.pm and provide no-op Class::C3::.*initialize() funcs for 5.9.5+
      else {
          require mro;
          no warnings 'redefine';
          *Class::C3::initialize = sub { 1 };
          *Class::C3::reinitialize = sub { 1 };
          *Class::C3::uninitialize = sub { 1 };
      }
  }
  
  =head1 NAME
  
  MRO::Compat - mro::* interface compatibility for Perls < 5.9.5
  
  =head1 SYNOPSIS
  
     package PPP;      use base qw/Exporter/;
     package X;        use base qw/PPP/;
     package Y;        use base qw/PPP/;
     package Z;        use base qw/PPP/;
  
     package FooClass; use base qw/X Y Z/;
  
     package main;
     use MRO::Compat;
     my $linear = mro::get_linear_isa('FooClass');
     print join(q{, }, @$linear);
  
     # Prints: FooClass, X, PPP, Exporter, Y, Z
  
  =head1 DESCRIPTION
  
  The "mro" namespace provides several utilities for dealing
  with method resolution order and method caching in general
  in Perl 5.9.5 and higher.
  
  This module provides those interfaces for
  earlier versions of Perl (back to 5.6.0 anyways).
  
  It is a harmless no-op to use this module on 5.9.5+.  That
  is to say, code which properly uses L<MRO::Compat> will work
  unmodified on both older Perls and 5.9.5+.
  
  If you're writing a piece of software that would like to use
  the parts of 5.9.5+'s mro:: interfaces that are supported
  here, and you want compatibility with older Perls, this
  is the module for you.
  
  Some parts of this code will work better and/or faster with
  L<Class::C3::XS> installed (which is an optional prereq
  of L<Class::C3>, which is in turn a prereq of this
  package), but it's not a requirement.
  
  This module never exports any functions.  All calls must
  be fully qualified with the C<mro::> prefix.
  
  The interface documentation here serves only as a quick
  reference of what the function basically does, and what
  differences between L<MRO::Compat> and 5.9.5+ one should
  look out for.  The main docs in 5.9.5's L<mro> are the real
  interface docs, and contain a lot of other useful information.
  
  =head1 Functions
  
  =head2 mro::get_linear_isa($classname[, $type])
  
  Returns an arrayref which is the linearized "ISA" of the given class.
  Uses whichever MRO is currently in effect for that class by default,
  or the given MRO (either C<c3> or C<dfs> if specified as C<$type>).
  
  The linearized ISA of a class is a single ordered list of all of the
  classes that would be visited in the process of resolving a method
  on the given class, starting with itself.  It does not include any
  duplicate entries.
  
  Note that C<UNIVERSAL> (and any members of C<UNIVERSAL>'s MRO) are not
  part of the MRO of a class, even though all classes implicitly inherit
  methods from C<UNIVERSAL> and its parents.
  
  =cut
  
  sub __get_linear_isa_dfs {
      no strict 'refs';
  
      my $classname = shift;
  
      my @lin = ($classname);
      my %stored;
      foreach my $parent (@{"$classname\::ISA"}) {
          my $plin = __get_linear_isa_dfs($parent);
          foreach (@$plin) {
              next if exists $stored{$_};
              push(@lin, $_);
              $stored{$_} = 1;
          }
      }
      return \@lin;
  }
  
  sub __get_linear_isa {
      my ($classname, $type) = @_;
      die "mro::get_mro requires a classname" if !defined $classname;
  
      $type ||= __get_mro($classname);
      if($type eq 'dfs') {
          return __get_linear_isa_dfs($classname);
      }
      elsif($type eq 'c3') {
          return [Class::C3::calculateMRO($classname)];
      }
      die "type argument must be 'dfs' or 'c3'";
  }
  
  =head2 mro::import
  
  This allows the C<use mro 'dfs'> and
  C<use mro 'c3'> syntaxes, providing you
  L<use MRO::Compat> first.  Please see the
  L</USING C3> section for additional details.
  
  =cut
  
  sub __import {
      if($_[1]) {
          goto &Class::C3::import if $_[1] eq 'c3';
          __set_mro(scalar(caller), $_[1]);
      }
  }
  
  =head2 mro::set_mro($classname, $type)
  
  Sets the mro of C<$classname> to one of the types
  C<dfs> or C<c3>.  Please see the L</USING C3>
  section for additional details.
  
  =cut
  
  sub __set_mro {
      my ($classname, $type) = @_;
  
      if(!defined $classname || !$type) {
          die q{Usage: mro::set_mro($classname, $type)};
      }
  
      if($type eq 'c3') {
          eval "package $classname; use Class::C3";
          die $@ if $@;
      }
      elsif($type eq 'dfs') {
          # In the dfs case, check whether we need to undo C3
          if(defined $Class::C3::MRO{$classname}) {
              Class::C3::_remove_method_dispatch_table($classname);
          }
          delete $Class::C3::MRO{$classname};
      }
      else {
          die qq{Invalid mro type "$type"};
      }
  
      return;
  }
  
  =head2 mro::get_mro($classname)
  
  Returns the MRO of the given class (either C<c3> or C<dfs>).
  
  It considers any Class::C3-using class to have C3 MRO
  even before L<Class::C3::initialize()> is called.
  
  =cut
  
  sub __get_mro {
      my $classname = shift;
      die "mro::get_mro requires a classname" if !defined $classname;
      return 'c3' if exists $Class::C3::MRO{$classname};
      return 'dfs';
  }
  
  =head2 mro::get_isarev($classname)
  
  Returns an arrayref of classes who are subclasses of the
  given classname.  In other words, classes in whose @ISA
  hierarchy we appear, no matter how indirectly.
  
  This is much slower on pre-5.9.5 Perls with MRO::Compat
  than it is on 5.9.5+, as it has to search the entire
  package namespace.
  
  =cut
  
  sub __get_all_pkgs_with_isas {
      no strict 'refs';
      no warnings 'recursion';
  
      my @retval;
  
      my $search = shift;
      my $pfx;
      my $isa;
      if(defined $search) {
          $isa = \@{"$search\::ISA"};
          $pfx = "$search\::";
      }
      else {
          $search = 'main';
          $isa = \@main::ISA;
          $pfx = '';
      }
  
      push(@retval, $search) if scalar(@$isa);
  
      foreach my $cand (keys %{"$search\::"}) {
          if($cand =~ s/::$//) {
              next if $cand eq $search; # skip self-reference (main?)
              push(@retval, @{__get_all_pkgs_with_isas($pfx . $cand)});
          }
      }
  
      return \@retval;
  }
  
  sub __get_isarev_recurse {
      no strict 'refs';
  
      my ($class, $all_isas, $level) = @_;
  
      die "Recursive inheritance detected" if $level > 100;
  
      my %retval;
  
      foreach my $cand (@$all_isas) {
          my $found_me;
          foreach (@{"$cand\::ISA"}) {
              if($_ eq $class) {
                  $found_me = 1;
                  last;
              }
          }
          if($found_me) {
              $retval{$cand} = 1;
              map { $retval{$_} = 1 }
                  @{__get_isarev_recurse($cand, $all_isas, $level+1)};
          }
      }
      return [keys %retval];
  }
  
  sub __get_isarev {
      my $classname = shift;
      die "mro::get_isarev requires a classname" if !defined $classname;
  
      __get_isarev_recurse($classname, __get_all_pkgs_with_isas(), 0);
  }
  
  =head2 mro::is_universal($classname)
  
  Returns a boolean status indicating whether or not
  the given classname is either C<UNIVERSAL> itself,
  or one of C<UNIVERSAL>'s parents by C<@ISA> inheritance.
  
  Any class for which this function returns true is
  "universal" in the sense that all classes potentially
  inherit methods from it.
  
  =cut
  
  sub __is_universal {
      my $classname = shift;
      die "mro::is_universal requires a classname" if !defined $classname;
  
      my $lin = __get_linear_isa('UNIVERSAL');
      foreach (@$lin) {
          return 1 if $classname eq $_;
      }
  
      return 0;
  }
  
  =head2 mro::invalidate_all_method_caches
  
  Increments C<PL_sub_generation>, which invalidates method
  caching in all packages.
  
  Please note that this is rarely necessary, unless you are
  dealing with a situation which is known to confuse Perl's
  method caching.
  
  =cut
  
  sub __invalidate_all_method_caches {
      # Super secret mystery code :)
      @f845a9c1ac41be33::ISA = @f845a9c1ac41be33::ISA;
      return;
  }
  
  =head2 mro::method_changed_in($classname)
  
  Invalidates the method cache of any classes dependent on the
  given class.  In L<MRO::Compat> on pre-5.9.5 Perls, this is
  an alias for C<mro::invalidate_all_method_caches> above, as
  pre-5.9.5 Perls have no other way to do this.  It will still
  enforce the requirement that you pass it a classname, for
  compatibility.
  
  Please note that this is rarely necessary, unless you are
  dealing with a situation which is known to confuse Perl's
  method caching.
  
  =cut
  
  sub __method_changed_in {
      my $classname = shift;
      die "mro::method_changed_in requires a classname" if !defined $classname;
  
      __invalidate_all_method_caches();
  }
  
  =head2 mro::get_pkg_gen($classname)
  
  Returns an integer which is incremented every time a local
  method of or the C<@ISA> of the given package changes on
  Perl 5.9.5+.  On earlier Perls with this L<MRO::Compat> module,
  it will probably increment a lot more often than necessary.
  
  =cut
  
  {
      my $__pkg_gen = 2;
      sub __get_pkg_gen_pp {
          my $classname = shift;
          die "mro::get_pkg_gen requires a classname" if !defined $classname;
          return $__pkg_gen++;
      }
  }
  
  sub __get_pkg_gen_c3xs {
      my $classname = shift;
      die "mro::get_pkg_gen requires a classname" if !defined $classname;
  
      return Class::C3::XS::_plsubgen();
  }
  
  =head1 USING C3
  
  While this module makes the 5.9.5+ syntaxes
  C<use mro 'c3'> and C<mro::set_mro("Foo", 'c3')> available
  on older Perls, it does so merely by passing off the work
  to L<Class::C3>.
  
  It does not remove the need for you to call
  C<Class::C3::initialize()>, C<Class::C3::reinitialize()>, and/or
  C<Class::C3::uninitialize()> at the appropriate times
  as documented in the L<Class::C3> docs.  These three functions
  are always provided by L<MRO::Compat>, either via L<Class::C3>
  itself on older Perls, or directly as no-ops on 5.9.5+.
  
  =head1 SEE ALSO
  
  L<Class::C3>
  
  L<mro>
  
  =head1 AUTHOR
  
  Brandon L. Black, E<lt>blblack@gmail.comE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2008 Brandon L. Black E<lt>blblack@gmail.comE<gt>
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
  1;
MRO_COMPAT

$fatpacked{"Module/Implementation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_IMPLEMENTATION';
  package Module::Implementation;
  # git description: v0.08-2-gd599347
  $Module::Implementation::VERSION = '0.09';
  
  use strict;
  use warnings;
  
  use Module::Runtime 0.012 qw( require_module );
  use Try::Tiny;
  
  # This is needed for the benefit of Test::CleanNamespaces, which in turn loads
  # Package::Stash, which in turn loads this module and expects a minimum
  # version.
  unless ( exists $Module::Implementation::{VERSION}
      && ${ $Module::Implementation::{VERSION} } ) {
  
      $Module::Implementation::{VERSION} = \42;
  }
  
  my %Implementation;
  
  sub build_loader_sub {
      my $caller = caller();
  
      return _build_loader( $caller, @_ );
  }
  
  sub _build_loader {
      my $package = shift;
      my %args    = @_;
  
      my @implementations = @{ $args{implementations} };
      my @symbols = @{ $args{symbols} || [] };
  
      my $implementation;
      my $env_var = uc $package;
      $env_var =~ s/::/_/g;
      $env_var .= '_IMPLEMENTATION';
  
      return sub {
          my ( $implementation, $loaded ) = _load_implementation(
              $package,
              $ENV{$env_var},
              \@implementations,
          );
  
          $Implementation{$package} = $implementation;
  
          _copy_symbols( $loaded, $package, \@symbols );
  
          return $loaded;
      };
  }
  
  sub implementation_for {
      my $package = shift;
  
      return $Implementation{$package};
  }
  
  sub _load_implementation {
      my $package         = shift;
      my $env_value       = shift;
      my $implementations = shift;
  
      if ($env_value) {
          die "$env_value is not a valid implementation for $package"
              unless grep { $_ eq $env_value } @{$implementations};
  
          my $requested = "${package}::$env_value";
  
          # Values from the %ENV hash are tainted. We know it's safe to untaint
          # this value because the value was one of our known implementations.
          ($requested) = $requested =~ /^(.+)$/;
  
          try {
              require_module($requested);
          }
          catch {
              require Carp;
              Carp::croak("Could not load $requested: $_");
          };
  
          return ( $env_value, $requested );
      }
      else {
          my $err;
          for my $possible ( @{$implementations} ) {
              my $try = "${package}::$possible";
  
              my $ok;
              try {
                  require_module($try);
                  $ok = 1;
              }
              catch {
                  $err .= $_ if defined $_;
              };
  
              return ( $possible, $try ) if $ok;
          }
  
          require Carp;
          if ( defined $err && length $err ) {
              Carp::croak(
                  "Could not find a suitable $package implementation: $err");
          }
          else {
              Carp::croak(
                  'Module::Runtime failed to load a module but did not throw a real error. This should never happen. Something is very broken'
              );
          }
      }
  }
  
  sub _copy_symbols {
      my $from_package = shift;
      my $to_package   = shift;
      my $symbols      = shift;
  
      for my $sym ( @{$symbols} ) {
          my $type = $sym =~ s/^([\$\@\%\&\*])// ? $1 : '&';
  
          my $from = "${from_package}::$sym";
          my $to   = "${to_package}::$sym";
  
          {
              no strict 'refs';
              no warnings 'once';
  
              # Copied from Exporter
              *{$to}
                  = $type eq '&' ? \&{$from}
                  : $type eq '$' ? \${$from}
                  : $type eq '@' ? \@{$from}
                  : $type eq '%' ? \%{$from}
                  : $type eq '*' ? *{$from}
                  : die
                  "Can't copy symbol from $from_package to $to_package: $type$sym";
          }
      }
  }
  
  1;
  
  # ABSTRACT: Loads one of several alternate underlying implementations for a module
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Module::Implementation - Loads one of several alternate underlying implementations for a module
  
  =head1 VERSION
  
  version 0.09
  
  =head1 SYNOPSIS
  
    package Foo::Bar;
  
    use Module::Implementation;
  
    BEGIN {
        my $loader = Module::Implementation::build_loader_sub(
            implementations => [ 'XS',  'PurePerl' ],
            symbols         => [ 'run', 'check' ],
        );
  
        $loader->();
    }
  
    package Consumer;
  
    # loads the first viable implementation
    use Foo::Bar;
  
  =head1 DESCRIPTION
  
  This module abstracts out the process of choosing one of several underlying
  implementations for a module. This can be used to provide XS and pure Perl
  implementations of a module, or it could be used to load an implementation for
  a given OS or any other case of needing to provide multiple implementations.
  
  This module is only useful when you know all the implementations ahead of
  time. If you want to load arbitrary implementations then you probably want
  something like a plugin system, not this module.
  
  =head1 API
  
  This module provides two subroutines, neither of which are exported.
  
  =head2 Module::Implementation::build_loader_sub(...)
  
  This subroutine takes the following arguments.
  
  =over 4
  
  =item * implementations
  
  This should be an array reference of implementation names. Each name should
  correspond to a module in the caller's namespace.
  
  In other words, using the example in the L</SYNOPSIS>, this module will look
  for the C<Foo::Bar::XS> and C<Foo::Bar::PurePerl> modules.
  
  This argument is required.
  
  =item * symbols
  
  A list of symbols to copy from the implementation package to the calling
  package.
  
  These can be prefixed with a variable type: C<$>, C<@>, C<%>, C<&>, or
  C<*)>. If no prefix is given, the symbol is assumed to be a subroutine.
  
  This argument is optional.
  
  =back
  
  This subroutine I<returns> the implementation loader as a sub reference.
  
  It is up to you to call this loader sub in your code.
  
  I recommend that you I<do not> call this loader in an C<import()> sub. If a
  caller explicitly requests no imports, your C<import()> sub will not be run at
  all, which can cause weird breakage.
  
  =head2 Module::Implementation::implementation_for($package)
  
  Given a package name, this subroutine returns the implementation that was
  loaded for the package. This is not a full package name, just the suffix that
  identifies the implementation. For the L</SYNOPSIS> example, this subroutine
  would be called as C<Module::Implementation::implementation_for('Foo::Bar')>,
  and it would return "XS" or "PurePerl".
  
  =head1 HOW THE IMPLEMENTATION LOADER WORKS
  
  The implementation loader works like this ...
  
  First, it checks for an C<%ENV> var specifying the implementation to load. The
  env var is based on the package name which loads the implementations. The
  C<::> package separator is replaced with C<_>, and made entirely
  upper-case. Finally, we append "_IMPLEMENTATION" to this name.
  
  So in our L</SYNOPSIS> example, the corresponding C<%ENV> key would be
  C<FOO_BAR_IMPLEMENTATION>.
  
  If this is set, then the loader will B<only> try to load this one
  implementation.
  
  If the env var requests an implementation which doesn't match one of the
  implementations specified when the loader was created, an error is thrown.
  
  If this one implementation fails to load then loader throws an error. This is
  useful for testing. You can request a specific implementation in a test file
  by writing something like this:
  
    BEGIN { $ENV{FOO_BAR_IMPLEMENTATION} = 'XS' }
    use Foo::Bar;
  
  If the environment variable is I<not> set, then the loader simply tries the
  implementations originally passed to C<Module::Implementation>. The
  implementations are tried in the order in which they were originally passed.
  
  The loader will use the first implementation that loads without an error. It
  will copy any requested symbols from this implementation.
  
  If none of the implementations can be loaded, then the loader throws an
  exception.
  
  The loader returns the name of the package it loaded.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
MODULE_IMPLEMENTATION

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  =head1 NAME
  
  Module::Runtime - runtime module handling
  
  =head1 SYNOPSIS
  
      use Module::Runtime qw(
  	$module_name_rx is_module_name check_module_name
  	module_notional_filename require_module);
  
      if($module_name =~ /\A$module_name_rx\z/o) { ...
      if(is_module_name($module_name)) { ...
      check_module_name($module_name);
  
      $notional_filename = module_notional_filename($module_name);
      require_module($module_name);
  
      use Module::Runtime qw(use_module use_package_optimistically);
  
      $bi = use_module("Math::BigInt", 1.31)->new("1_234");
      $widget = use_package_optimistically("Local::Widget")->new;
  
      use Module::Runtime qw(
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec check_module_spec
  	compose_module_name);
  
      if($spec =~ /\A$top_module_spec_rx\z/o) { ...
      if($spec =~ /\A$sub_module_spec_rx\z/o) { ...
      if(is_module_spec("Standard::Prefix", $spec)) { ...
      check_module_spec("Standard::Prefix", $spec);
  
      $module_name = compose_module_name("Standard::Prefix", $spec);
  
  =head1 DESCRIPTION
  
  The functions exported by this module deal with runtime handling of
  Perl modules, which are normally handled at compile time.  This module
  avoids using any other modules, so that it can be used in low-level
  infrastructure.
  
  The parts of this module that work with module names apply the same syntax
  that is used for barewords in Perl source.  In principle this syntax
  can vary between versions of Perl, and this module applies the syntax of
  the Perl on which it is running.  In practice the usable syntax hasn't
  changed yet.  There's some intent for Unicode module names to be supported
  in the future, but this hasn't yet amounted to any consistent facility.
  
  The functions of this module whose purpose is to load modules include
  workarounds for three old Perl core bugs regarding C<require>.  These
  workarounds are applied on any Perl version where the bugs exist, except
  for a case where one of the bugs cannot be adequately worked around in
  pure Perl.
  
  =head2 Module name syntax
  
  The usable module name syntax has not changed from Perl 5.000 up to
  Perl 5.19.8.  The syntax is composed entirely of ASCII characters.
  From Perl 5.6 onwards there has been some attempt to allow the use of
  non-ASCII Unicode characters in Perl source, but it was fundamentally
  broken (like the entirety of Perl 5.6's Unicode handling) and remained
  pretty much entirely unusable until it got some attention in the Perl
  5.15 series.  Although Unicode is now consistently accepted by the
  parser in some places, it remains broken for module names.  Furthermore,
  there has not yet been any work on how to map Unicode module names into
  filenames, so in that respect also Unicode module names are unusable.
  
  The module name syntax is, precisely: the string must consist of one or
  more segments separated by C<::>; each segment must consist of one or more
  identifier characters (ASCII alphanumerics plus "_"); the first character
  of the string must not be a digit.  Thus "C<IO::File>", "C<warnings>",
  and "C<foo::123::x_0>" are all valid module names, whereas "C<IO::>"
  and "C<1foo::bar>" are not.  C<'> separators are not permitted by this
  module, though they remain usable in Perl source, being translated to
  C<::> in the parser.
  
  =head2 Core bugs worked around
  
  The first bug worked around is core bug [perl #68590], which causes
  lexical state in one file to leak into another that is C<require>d/C<use>d
  from it.  This bug is present from Perl 5.6 up to Perl 5.10, and is
  fixed in Perl 5.11.0.  From Perl 5.9.4 up to Perl 5.10.0 no satisfactory
  workaround is possible in pure Perl.  The workaround means that modules
  loaded via this module don't suffer this pollution of their lexical
  state.  Modules loaded in other ways, or via this module on the Perl
  versions where the pure Perl workaround is impossible, remain vulnerable.
  The module L<Lexical::SealRequireHints> provides a complete workaround
  for this bug.
  
  The second bug worked around causes some kinds of failure in module
  loading, principally compilation errors in the loaded module, to be
  recorded in C<%INC> as if they were successful, so later attempts to load
  the same module immediately indicate success.  This bug is present up
  to Perl 5.8.9, and is fixed in Perl 5.9.0.  The workaround means that a
  compilation error in a module loaded via this module won't be cached as
  a success.  Modules loaded in other ways remain liable to produce bogus
  C<%INC> entries, and if a bogus entry exists then it will mislead this
  module if it is used to re-attempt loading.
  
  The third bug worked around causes the wrong context to be seen at
  file scope of a loaded module, if C<require> is invoked in a location
  that inherits context from a higher scope.  This bug is present up to
  Perl 5.11.2, and is fixed in Perl 5.11.3.  The workaround means that
  a module loaded via this module will always see the correct context.
  Modules loaded in other ways remain vulnerable.
  
  =cut
  
  package Module::Runtime;
  
  # Don't "use 5.006" here, because Perl 5.15.6 will load feature.pm if
  # the version check is done that way.
  BEGIN { require 5.006; }
  # Don't "use warnings" here, to avoid dependencies.  Do standardise the
  # warning status by lexical override; unfortunately the only safe bitset
  # to build in is the empty set, equivalent to "no warnings".
  BEGIN { ${^WARNING_BITS} = ""; }
  # Don't "use strict" here, to avoid dependencies.
  
  our $VERSION = "0.016";
  
  # Don't use Exporter here, to avoid dependencies.
  our @EXPORT_OK = qw(
  	$module_name_rx is_module_name is_valid_module_name check_module_name
  	module_notional_filename require_module
  	use_module use_package_optimistically
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec is_valid_module_spec check_module_spec
  	compose_module_name
  );
  my %export_ok = map { ($_ => undef) } @EXPORT_OK;
  sub import {
  	my $me = shift;
  	my $callpkg = caller(0);
  	my $errs = "";
  	foreach(@_) {
  		if(exists $export_ok{$_}) {
  			# We would need to do "no strict 'refs'" here
  			# if we had enabled strict at file scope.
  			if(/\A\$(.*)\z/s) {
  				*{$callpkg."::".$1} = \$$1;
  			} else {
  				*{$callpkg."::".$_} = \&$_;
  			}
  		} else {
  			$errs .= "\"$_\" is not exported by the $me module\n";
  		}
  	}
  	if($errs ne "") {
  		die "${errs}Can't continue after import errors ".
  			"at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n";
  	}
  }
  
  # Logic duplicated from Params::Classify.  Duplicating it here avoids
  # an extensive and potentially circular dependency graph.
  sub _is_string($) {
  	my($arg) = @_;
  	return defined($arg) && ref(\$arg) eq "SCALAR";
  }
  
  =head1 REGULAR EXPRESSIONS
  
  These regular expressions do not include any anchors, so to check
  whether an entire string matches a syntax item you must supply the
  anchors yourself.
  
  =over
  
  =item $module_name_rx
  
  Matches a valid Perl module name in bareword syntax.
  
  =cut
  
  our $module_name_rx = qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;
  
  =item $top_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where no prefix is being used.
  
  =cut
  
  my $qual_module_spec_rx =
  	qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  my $unqual_top_module_spec_rx =
  	qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $top_module_spec_rx = qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;
  
  =item $sub_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where a prefix is being used.
  
  =cut
  
  my $unqual_sub_module_spec_rx = qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $sub_module_spec_rx = qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 Basic module handling
  
  =over
  
  =item is_module_name(ARG)
  
  Returns a truth value indicating whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  
  =cut
  
  sub is_module_name($) { _is_string($_[0]) && $_[0] =~ /\A$module_name_rx\z/o }
  
  =item is_valid_module_name(ARG)
  
  Deprecated alias for L</is_module_name>.
  
  =cut
  
  *is_valid_module_name = \&is_module_name;
  
  =item check_module_name(ARG)
  
  Check whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_name($) {
  	unless(&is_module_name) {
  		die +(_is_string($_[0]) ? "`$_[0]'" : "argument").
  			" is not a module name\n";
  	}
  }
  
  =item module_notional_filename(NAME)
  
  Generates a notional relative filename for a module, which is used in
  some Perl core interfaces.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The notional filename for the named module is generated and returned.
  This filename is always in Unix style, with C</> directory separators
  and a C<.pm> suffix.  This kind of filename can be used as an argument to
  C<require>, and is the key that appears in C<%INC> to identify a module,
  regardless of actual local filename syntax.
  
  =cut
  
  sub module_notional_filename($) {
  	&check_module_name;
  	my($name) = @_;
  	$name =~ s!::!/!g;
  	return $name.".pm";
  }
  
  =item require_module(NAME)
  
  This is essentially the bareword form of C<require>, in runtime form.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The module specified by I<NAME> is loaded, if it hasn't been already,
  in the manner of the bareword form of C<require>.  That means that a
  search through C<@INC> is performed, and a byte-compiled form of the
  module will be used if available.
  
  The return value is as for C<require>.  That is, it is the value returned
  by the module itself if the module is loaded anew, or C<1> if the module
  was already loaded.
  
  =cut
  
  # Don't "use constant" here, to avoid dependencies.
  BEGIN {
  	*_WORK_AROUND_HINT_LEAKAGE =
  		"$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
  			? sub(){1} : sub(){0};
  	*_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
  }
  
  BEGIN { if(_WORK_AROUND_BROKEN_MODULE_STATE) { eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  }; die $@ if $@ ne ""; } }
  
  sub require_module($) {
  	# Localise %^H to work around [perl #68590], where the bug exists
  	# and this is a satisfactory workaround.  The bug consists of
  	# %^H state leaking into each required module, polluting the
  	# module's lexical state.
  	local %^H if _WORK_AROUND_HINT_LEAKAGE;
  	if(_WORK_AROUND_BROKEN_MODULE_STATE) {
  		my $notional_filename = &module_notional_filename;
  		my $guard = bless([ $notional_filename ],
  				"Module::Runtime::__GUARD__");
  		my $result = CORE::require($notional_filename);
  		pop @$guard;
  		return $result;
  	} else {
  		return scalar(CORE::require(&module_notional_filename));
  	}
  }
  
  =back
  
  =head2 Structured module use
  
  =over
  
  =item use_module(NAME[, VERSION])
  
  This is essentially C<use> in runtime form, but without the importing
  feature (which is fundamentally a compile-time thing).  The I<NAME> is
  handled just like in C<require_module> above: it must be a module name,
  and the named module is loaded as if by the bareword form of C<require>.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded module is
  called with the specified I<VERSION> as an argument.  This normally serves to
  ensure that the version loaded is at least the version required.  This is
  the same functionality provided by the I<VERSION> parameter of C<use>.
  
  On success, the name of the module is returned.  This is unlike
  L</require_module>, and is done so that the entire call to L</use_module>
  can be used as a class name to call a constructor, as in the example in
  the synopsis.
  
  =cut
  
  sub use_module($;$) {
  	my($name, $version) = @_;
  	require_module($name);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =item use_package_optimistically(NAME[, VERSION])
  
  This is an analogue of L</use_module> for the situation where there is
  uncertainty as to whether a package/class is defined in its own module
  or by some other means.  It attempts to arrange for the named package to
  be available, either by loading a module or by doing nothing and hoping.
  
  An attempt is made to load the named module (as if by the bareword form
  of C<require>).  If the module cannot be found then it is assumed that
  the package was actually already loaded by other means, and no error
  is signalled.  That's the optimistic bit.
  
  I<Warning:> this optional module loading is liable to cause unreliable
  behaviour, including security problems.  It interacts especially badly
  with having C<.> in C<@INC>, which was the default state of affairs in
  Perls prior to 5.25.11.  If a package is actually defined by some means
  other than a module, then applying this function to it causes a spurious
  attempt to load a module that is expected to be non-existent.  If a
  module actually exists under that name then it will be unintentionally
  loaded.  If C<.> is in C<@INC> and this code is ever run with the current
  directory being one writable by a malicious user (such as F</tmp>), then
  the malicious user can easily cause the victim to run arbitrary code, by
  creating a module file under the predictable spuriously-loaded name in the
  writable directory.  Generally, optional module loading should be avoided.
  
  This is mostly the same operation that is performed by the L<base> pragma
  to ensure that the specified base classes are available.  The behaviour
  of L<base> was simplified in version 2.18, and later improved in version
  2.20, and on both occasions this function changed to match.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded package is
  called with the specified I<VERSION> as an argument.  This normally serves
  to ensure that the version loaded is at least the version required.
  On success, the name of the package is returned.  These aspects of the
  function work just like L</use_module>.
  
  =cut
  
  sub use_package_optimistically($;$) {
  	my($name, $version) = @_;
  	my $fn = module_notional_filename($name);
  	eval { local $SIG{__DIE__}; require_module($name); };
  	die $@ if $@ ne "" &&
  		($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s ||
  		 $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =back
  
  =head2 Module name composition
  
  =over
  
  =item is_module_spec(PREFIX, SPEC)
  
  Returns a truth value indicating
  whether I<SPEC> is valid input for L</compose_module_name>.
  See below for what that entails.  Whether a I<PREFIX> is supplied affects
  the validity of I<SPEC>, but the exact value of the prefix is unimportant,
  so this function treats I<PREFIX> as a truth value.
  
  =cut
  
  sub is_module_spec($$) {
  	my($prefix, $spec) = @_;
  	return _is_string($spec) &&
  		$spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o :
  				    qr/\A$top_module_spec_rx\z/o);
  }
  
  =item is_valid_module_spec(PREFIX, SPEC)
  
  Deprecated alias for L</is_module_spec>.
  
  =cut
  
  *is_valid_module_spec = \&is_module_spec;
  
  =item check_module_spec(PREFIX, SPEC)
  
  Check whether I<SPEC> is valid input for L</compose_module_name>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_spec($$) {
  	unless(&is_module_spec) {
  		die +(_is_string($_[1]) ? "`$_[1]'" : "argument").
  			" is not a module specification\n";
  	}
  }
  
  =item compose_module_name(PREFIX, SPEC)
  
  This function is intended to make it more convenient for a user to specify
  a Perl module name at runtime.  Users have greater need for abbreviations
  and context-sensitivity than programmers, and Perl module names get a
  little unwieldy.  I<SPEC> is what the user specifies, and this function
  translates it into a module name in standard form, which it returns.
  
  I<SPEC> has syntax approximately that of a standard module name: it
  should consist of one or more name segments, each of which consists
  of one or more identifier characters.  However, C</> is permitted as a
  separator, in addition to the standard C<::>.  The two separators are
  entirely interchangeable.
  
  Additionally, if I<PREFIX> is not C<undef> then it must be a module
  name in standard form, and it is prefixed to the user-specified name.
  The user can inhibit the prefix addition by starting I<SPEC> with a
  separator (either C</> or C<::>).
  
  =cut
  
  sub compose_module_name($$) {
  	my($prefix, $spec) = @_;
  	check_module_name($prefix) if defined $prefix;
  	&check_module_spec;
  	if($spec =~ s#\A(?:/|::)##) {
  		# OK
  	} else {
  		$spec = $prefix."::".$spec if defined $prefix;
  	}
  	$spec =~ s#/#::#g;
  	return $spec;
  }
  
  =back
  
  =head1 BUGS
  
  On Perl versions 5.7.2 to 5.8.8, if C<require> is overridden by the
  C<CORE::GLOBAL> mechanism, it is likely to break the heuristics used by
  L</use_package_optimistically>, making it signal an error for a missing
  module rather than assume that it was already loaded.  From Perl 5.8.9
  onwards, and on 5.7.1 and earlier, this module can avoid being confused
  by such an override.  On the affected versions, a C<require> override
  might be installed by L<Lexical::SealRequireHints>, if something requires
  its bugfix but for some reason its XS implementation isn't available.
  
  =head1 SEE ALSO
  
  L<Lexical::SealRequireHints>,
  L<base>,
  L<perlfunc/require>,
  L<perlfunc/use>
  
  =head1 AUTHOR
  
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2004, 2006, 2007, 2009, 2010, 2011, 2012, 2014, 2017
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
MODULE_RUNTIME

$fatpacked{"Module/Runtime/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME_CONFLICTS';
  use strict;
  use warnings;
  package Module::Runtime::Conflicts; # git description: v0.002-9-gc4cd9f2
  # vim: set ts=8 sts=4 sw=4 tw=115 et :
  # ABSTRACT: Provide information on conflicts for Module::Runtime
  # KEYWORDS: conflicts breaks modules prerequisites upgrade
  
  our $VERSION = '0.003';
  
  use Module::Runtime ();
  use Dist::CheckConflicts
      -dist      => 'Module::Runtime',
      -conflicts => {
          # listed modules are the highest *non-working* version when used in
          # combination with the indicated version of Module::Runtime
  
          eval { Module::Runtime->VERSION('0.014'); 1 } ? (
              'Moose' => '2.1202',
              'MooseX::NonMoose' => '0.24',
              'Elasticsearch' => '1.00',
          ) : (),
      },
      -also => [
          'Package::Stash::Conflicts',
          'Moose::Conflicts',
      ];
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Module::Runtime::Conflicts - Provide information on conflicts for Module::Runtime
  
  =head1 VERSION
  
  version 0.003
  
  =head1 SYNOPSIS
  
      `moose-outdated`
  
  or
  
      use Module::Runtime::Conflicts;
      Module::Runtime::Conflicts->check_conflicts;
  
  =head1 DESCRIPTION
  
  This module provides conflicts checking for L<Module::Runtime>, which had a
  recent release that broke some versions of L<Moose>. It is called from
  L<Moose::Conflicts> and C<moose-outdated>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<Dist::CheckConflicts>
  
  =item *
  
  L<Moose::Conflicts>
  
  =item *
  
  L<Dist::Zilla::Plugin::Breaks>
  
  =item *
  
  L<Dist::Zilla::Plugin::Test::CheckBreaks>
  
  =back
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Module-Runtime-Conflicts>
  (or L<bug-Module-Runtime-Conflicts@rt.cpan.org|mailto:bug-Module-Runtime-Conflicts@rt.cpan.org>).
  
  There is also a mailing list available for users of this distribution, at
  L<http://lists.perl.org/list/cpan-workers.html>.
  
  There is also an irc channel available for users of this distribution, at
  L<C<#toolchain> on C<irc.perl.org>|irc://irc.perl.org/#toolchain>.
  
  I am also usually active on irc, as 'ether' at C<irc.perl.org>.
  
  =head1 AUTHOR
  
  Karen Etheridge <ether@cpan.org>
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2014 by Karen Etheridge.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
MODULE_RUNTIME_CONFLICTS

$fatpacked{"Package/Stash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH';
  package Package::Stash;
  BEGIN {
    $Package::Stash::AUTHORITY = 'cpan:DOY';
  }
  $Package::Stash::VERSION = '0.37';
  use strict;
  use warnings;
  use 5.008001;
  # ABSTRACT: routines for manipulating stashes
  
  our $IMPLEMENTATION;
  
  use Module::Implementation 0.06;
  
  BEGIN {
      local $ENV{PACKAGE_STASH_IMPLEMENTATION} = $IMPLEMENTATION
        if ( $IMPLEMENTATION and not $ENV{PACKAGE_STASH_IMPLEMENTATION} );
  
      Module::Implementation::build_loader_sub(
          implementations => [ 'XS', 'PP' ],
          symbols         => [qw(
              new
              name
              namespace
              add_symbol
              remove_glob
              has_symbol
              get_symbol
              get_or_add_symbol
              remove_symbol
              list_all_symbols
              get_all_symbols
          )],
      )->();
      $IMPLEMENTATION = Module::Implementation::implementation_for(__PACKAGE__);
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Package::Stash - routines for manipulating stashes
  
  =head1 VERSION
  
  version 0.37
  
  =head1 SYNOPSIS
  
    my $stash = Package::Stash->new('Foo');
    $stash->add_symbol('%foo', {bar => 1});
    # $Foo::foo{bar} == 1
    $stash->has_symbol('$foo') # false
    my $namespace = $stash->namespace;
    *{ $namespace->{foo} }{HASH} # {bar => 1}
  
  =head1 DESCRIPTION
  
  Manipulating stashes (Perl's symbol tables) is occasionally necessary, but
  incredibly messy, and easy to get wrong. This module hides all of that behind a
  simple API.
  
  NOTE: Most methods in this class require a variable specification that includes
  a sigil. If this sigil is absent, it is assumed to represent the IO slot.
  
  Due to limitations in the typeglob API available to perl code, and to typeglob
  manipulation in perl being quite slow, this module provides two
  implementations - one in pure perl, and one using XS. The XS implementation is
  to be preferred for most usages; the pure perl one is provided for cases where
  XS modules are not a possibility. The current implementation in use can be set
  by setting C<$ENV{PACKAGE_STASH_IMPLEMENTATION}> or
  C<$Package::Stash::IMPLEMENTATION> before loading Package::Stash (with the
  environment variable taking precedence), otherwise, it will use the XS
  implementation if possible, falling back to the pure perl one.
  
  =head1 METHODS
  
  =head2 new $package_name
  
  Creates a new C<Package::Stash> object, for the package given as the only
  argument.
  
  =head2 name
  
  Returns the name of the package that this object represents.
  
  =head2 namespace
  
  Returns the raw stash itself.
  
  =head2 add_symbol $variable $value %opts
  
  Adds a new package symbol, for the symbol given as C<$variable>, and optionally
  gives it an initial value of C<$value>. C<$variable> should be the name of
  variable including the sigil, so
  
    Package::Stash->new('Foo')->add_symbol('%foo')
  
  will create C<%Foo::foo>.
  
  Valid options (all optional) are C<filename>, C<first_line_num>, and
  C<last_line_num>.
  
  C<$opts{filename}>, C<$opts{first_line_num}>, and C<$opts{last_line_num}> can
  be used to indicate where the symbol should be regarded as having been defined.
  Currently these values are only used if the symbol is a subroutine ('C<&>'
  sigil) and only if C<$^P & 0x10> is true, in which case the special C<%DB::sub>
  hash is updated to record the values of C<filename>, C<first_line_num>, and
  C<last_line_num> for the subroutine. If these are not passed, their values are
  inferred (as much as possible) from C<caller> information.
  
  This is especially useful for debuggers and profilers, which use C<%DB::sub> to
  determine where the source code for a subroutine can be found.  See
  L<http://perldoc.perl.org/perldebguts.html#Debugger-Internals> for more
  information about C<%DB::sub>.
  
  =head2 remove_glob $name
  
  Removes all package variables with the given name, regardless of sigil.
  
  =head2 has_symbol $variable
  
  Returns whether or not the given package variable (including sigil) exists.
  
  =head2 get_symbol $variable
  
  Returns the value of the given package variable (including sigil).
  
  =head2 get_or_add_symbol $variable
  
  Like C<get_symbol>, except that it will return an empty hashref or
  arrayref if the variable doesn't exist.
  
  =head2 remove_symbol $variable
  
  Removes the package variable described by C<$variable> (which includes the
  sigil); other variables with the same name but different sigils will be
  untouched.
  
  =head2 list_all_symbols $type_filter
  
  Returns a list of package variable names in the package, without sigils. If a
  C<type_filter> is passed, it is used to select package variables of a given
  type, where valid types are the slots of a typeglob ('SCALAR', 'CODE', 'HASH',
  etc). Note that if the package contained any C<BEGIN> blocks, perl will leave
  an empty typeglob in the C<BEGIN> slot, so this will show up if no filter is
  used (and similarly for C<INIT>, C<END>, etc).
  
  =head2 get_all_symbols $type_filter
  
  Returns a hashref, keyed by the variable names in the package. If
  C<$type_filter> is passed, the hash will contain every variable of that type in
  the package as values, otherwise, it will contain the typeglobs corresponding
  to the variable names (basically, a clone of the stash).
  
  =head1 WORKING WITH VARIABLES
  
  It is important to note, that when working with scalar variables, the default
  behavior is to B<copy> values.
  
    my $stash = Package::Stash->new('Some::Namespace');
    my $variable = 1;
    # $Some::Namespace::name is a copy of $variable
    $stash->add_symbol('$name', $variable);
    $variable++
    # $Some::Namespace::name == 1 , $variable == 2
  
  This will likely confuse people who expect it to work the same as typeglob
  assignment, which simply creates new references to existing variables.
  
    my $variable = 1;
    {
        no strict 'refs';
        # assign $Package::Stash::name = $variable
        *{'Package::Stash::name'} = \$variable;
    }
    $variable++ # affects both names
  
  If this behaviour is desired when working with Package::Stash, simply pass
  Package::Stash a scalar ref:
  
    my $stash = Package::Stash->new('Some::Namespace');
    my $variable = 1;
    # $Some::Namespace::name is now $variable
    $stash->add_symbol('$name', \$variable);
    $variable++
    # $Some::Namespace::name == 2 , $variable == 2
  
  This will be what you want as well if you're ever working with L<Readonly>
  variables:
  
    use Readonly;
    Readonly my $value, 'hello';
  
    $stash->add_symbol('$name', \$value); # reference
    print $Some::Namespace::name; # hello
    # Tries to modify the read-only 'hello' and dies.
    $Some::Namespace::name .= " world";
  
    $stash->add_symbol('$name', $value); # copy
    print $Some::Namespace::name; # hello
    # No problem, modifying a copy, not the original
    $Some::Namespace::name .= " world";
  
  =head1 BUGS / CAVEATS
  
  =over 4
  
  =item * Prior to perl 5.10, scalar slots are only considered to exist if they are defined
  
  This is due to a shortcoming within perl itself. See
  L<perlref/Making References> point 7 for more information.
  
  =item * GLOB and FORMAT variables are not (yet) accessible through this module.
  
  =item * Also, see the BUGS section for the specific backends (L<Package::Stash::XS> and L<Package::Stash::PP>)
  
  =back
  
  Please report any bugs to GitHub Issues at
  L<https://github.com/doy/package-stash/issues>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Class::MOP::Package>
  
  This module is a factoring out of code that used to live here
  
  =back
  
  =head1 SUPPORT
  
  You can find this documentation for this module with the perldoc command.
  
      perldoc Package::Stash
  
  You can also look for information at:
  
  =over 4
  
  =item * MetaCPAN
  
  L<https://metacpan.org/release/Package-Stash>
  
  =item * Github
  
  L<https://github.com/doy/package-stash>
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Package-Stash>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Package-Stash>
  
  =back
  
  =head1 HISTORY
  
  Based on code from L<Class::MOP::Package>, by Stevan Little and the Moose
  Cabal.
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy@tozt.net>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PACKAGE_STASH

$fatpacked{"Package/Stash/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH_CONFLICTS';
  package # hide from PAUSE
      Package::Stash::Conflicts;
  
  use strict;
  use warnings;
  
  # this module was generated with Dist::Zilla::Plugin::Conflicts 0.16
  
  use Dist::CheckConflicts
      -dist      => 'Package::Stash',
      -conflicts => {
          'Class::MOP' => '1.08',
          'MooseX::Method::Signatures' => '0.36',
          'MooseX::Role::WithOverloading' => '0.08',
          'namespace::clean' => '0.18',
      },
      -also => [ qw(
          B
          Carp
          Dist::CheckConflicts
          Getopt::Long
          Module::Implementation
          Scalar::Util
          Symbol
          constant
          strict
          warnings
      ) ],
  
  ;
  
  1;
  
  # ABSTRACT: Provide information on conflicts for Package::Stash
  # Dist::Zilla: -PodWeaver
PACKAGE_STASH_CONFLICTS

$fatpacked{"Package/Stash/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH_PP';
  package Package::Stash::PP;
  BEGIN {
    $Package::Stash::PP::AUTHORITY = 'cpan:DOY';
  }
  $Package::Stash::PP::VERSION = '0.37';
  use strict;
  use warnings;
  # ABSTRACT: pure perl implementation of the Package::Stash API
  
  use B;
  use Carp qw(confess);
  use Scalar::Util qw(blessed reftype weaken);
  use Symbol;
  # before 5.12, assigning to the ISA glob would make it lose its magical ->isa
  # powers
  use constant BROKEN_ISA_ASSIGNMENT => ($] < 5.012);
  # before 5.10, stashes don't ever seem to drop to a refcount of zero, so
  # weakening them isn't helpful
  use constant BROKEN_WEAK_STASH     => ($] < 5.010);
  # before 5.10, the scalar slot was always treated as existing if the
  # glob existed
  use constant BROKEN_SCALAR_INITIALIZATION => ($] < 5.010);
  # add_method on anon stashes triggers rt.perl #1804 otherwise
  # fixed in perl commit v5.13.3-70-g0fe688f
  use constant BROKEN_GLOB_ASSIGNMENT => ($] < 5.013004);
  # pre-5.10, ->isa lookups were cached in the ::ISA::CACHE:: slot
  use constant HAS_ISA_CACHE => ($] < 5.010);
  
  
  sub new {
      my $class = shift;
      my ($package) = @_;
  
      if (!defined($package) || (ref($package) && reftype($package) ne 'HASH')) {
          confess "Package::Stash->new must be passed the name of the "
                . "package to access";
      }
      elsif (ref($package) && reftype($package) eq 'HASH') {
          confess "The PP implementation of Package::Stash does not support "
                . "anonymous stashes before perl 5.14"
              if BROKEN_GLOB_ASSIGNMENT;
  
          return bless {
              'namespace' => $package,
          }, $class;
      }
      elsif ($package =~ /\A[0-9A-Z_a-z]+(?:::[0-9A-Z_a-z]+)*\z/) {
          return bless {
              'package' => $package,
          }, $class;
      }
      else {
          confess "$package is not a module name";
      }
  
  }
  
  sub name {
      confess "Can't call name as a class method"
          unless blessed($_[0]);
      confess "Can't get the name of an anonymous package"
          unless defined($_[0]->{package});
      return $_[0]->{package};
  }
  
  sub namespace {
      confess "Can't call namespace as a class method"
          unless blessed($_[0]);
  
      if (BROKEN_WEAK_STASH) {
          no strict 'refs';
          return \%{$_[0]->name . '::'};
      }
      else {
          return $_[0]->{namespace} if defined $_[0]->{namespace};
  
          {
              no strict 'refs';
              $_[0]->{namespace} = \%{$_[0]->name . '::'};
          }
  
          weaken($_[0]->{namespace});
  
          return $_[0]->{namespace};
      }
  }
  
  {
      my %SIGIL_MAP = (
          '$' => 'SCALAR',
          '@' => 'ARRAY',
          '%' => 'HASH',
          '&' => 'CODE',
          ''  => 'IO',
      );
  
      sub _deconstruct_variable_name {
          my ($variable) = @_;
  
          my @ret;
          if (ref($variable) eq 'HASH') {
              @ret = @{$variable}{qw[name sigil type]};
          }
          else {
              (defined $variable && length $variable)
                  || confess "You must pass a variable name";
  
              my $sigil = substr($variable, 0, 1, '');
  
              if (exists $SIGIL_MAP{$sigil}) {
                  @ret = ($variable, $sigil, $SIGIL_MAP{$sigil});
              }
              else {
                  @ret = ("${sigil}${variable}", '', $SIGIL_MAP{''});
              }
          }
  
          # XXX in pure perl, this will access things in inner packages,
          # in xs, this will segfault - probably look more into this at
          # some point
          ($ret[0] !~ /::/)
              || confess "Variable names may not contain ::";
  
          return @ret;
      }
  }
  
  sub _valid_for_type {
      my ($value, $type) = @_;
      if ($type eq 'HASH' || $type eq 'ARRAY'
       || $type eq 'IO'   || $type eq 'CODE') {
          return reftype($value) eq $type;
      }
      else {
          my $ref = reftype($value);
          return !defined($ref) || $ref eq 'SCALAR' || $ref eq 'REF' || $ref eq 'LVALUE' || $ref eq 'REGEXP' || $ref eq 'VSTRING';
      }
  }
  
  sub add_symbol {
      my ($self, $variable, $initial_value, %opts) = @_;
  
      my ($name, $sigil, $type) = _deconstruct_variable_name($variable);
  
      if (@_ > 2) {
          _valid_for_type($initial_value, $type)
              || confess "$initial_value is not of type $type";
  
          # cheap fail-fast check for PERLDBf_SUBLINE and '&'
          if ($^P and $^P & 0x10 && $sigil eq '&') {
              my $filename = $opts{filename};
              my $first_line_num = $opts{first_line_num};
  
              (undef, $filename, $first_line_num) = caller
                  if not defined $filename;
  
              my $last_line_num = $opts{last_line_num} || ($first_line_num ||= 0);
  
              # http://perldoc.perl.org/perldebguts.html#Debugger-Internals
              $DB::sub{$self->name . '::' . $name} = "$filename:$first_line_num-$last_line_num";
          }
      }
  
      if (BROKEN_GLOB_ASSIGNMENT) {
          if (@_ > 2) {
              no strict 'refs';
              no warnings 'redefine';
              *{ $self->name . '::' . $name } = ref $initial_value
                  ? $initial_value : \$initial_value;
          }
          else {
              no strict 'refs';
              if (BROKEN_ISA_ASSIGNMENT && $name eq 'ISA') {
                  *{ $self->name . '::' . $name };
              }
              else {
                  my $undef = _undef_ref_for_type($type);
                  *{ $self->name . '::' . $name } = $undef;
              }
          }
      }
      else {
          my $namespace = $self->namespace;
          {
              # using glob aliasing instead of Symbol::gensym, because otherwise,
              # magic doesn't get applied properly.
              # see <20120710063744.19360.qmail@lists-nntp.develooper.com> on p5p
              local *__ANON__:: = $namespace;
              no strict 'refs';
              no warnings 'void';
              no warnings 'once';
              *{"__ANON__::$name"};
          }
  
          if (@_ > 2) {
              no warnings 'redefine';
              *{ $namespace->{$name} } = ref $initial_value
                  ? $initial_value : \$initial_value;
          }
          else {
              return if BROKEN_ISA_ASSIGNMENT && $name eq 'ISA';
              *{ $namespace->{$name} } = _undef_ref_for_type($type);
          }
      }
  }
  
  sub _undef_ref_for_type {
      my ($type) = @_;
  
      if ($type eq 'ARRAY') {
          return [];
      }
      elsif ($type eq 'HASH') {
          return {};
      }
      elsif ($type eq 'SCALAR') {
          return \undef;
      }
      elsif ($type eq 'IO') {
          return Symbol::geniosym;
      }
      elsif ($type eq 'CODE') {
          confess "Don't know how to vivify CODE variables";
      }
      else {
          confess "Unknown type $type in vivication";
      }
  }
  
  sub remove_glob {
      my ($self, $name) = @_;
      delete $self->namespace->{$name};
  }
  
  sub has_symbol {
      my ($self, $variable) = @_;
  
      my ($name, $sigil, $type) = _deconstruct_variable_name($variable);
  
      my $namespace = $self->namespace;
  
      return unless exists $namespace->{$name};
  
      my $entry_ref = \$namespace->{$name};
      if (reftype($entry_ref) eq 'GLOB') {
          if ($type eq 'SCALAR') {
              if (BROKEN_SCALAR_INITIALIZATION) {
                  return defined ${ *{$entry_ref}{$type} };
              }
              else {
                  my $sv = B::svref_2object($entry_ref)->SV;
                  return $sv->isa('B::SV')
                      || ($sv->isa('B::SPECIAL')
                       && $B::specialsv_name[$$sv] ne 'Nullsv');
              }
          }
          else {
              return defined *{$entry_ref}{$type};
          }
      }
      else {
          # a symbol table entry can be -1 (stub), string (stub with prototype),
          # or reference (constant)
          return $type eq 'CODE';
      }
  }
  
  sub get_symbol {
      my ($self, $variable, %opts) = @_;
  
      my ($name, $sigil, $type) = _deconstruct_variable_name($variable);
  
      my $namespace = $self->namespace;
  
      if (!exists $namespace->{$name}) {
          if ($opts{vivify}) {
              $self->add_symbol($variable);
          }
          else {
              return undef;
          }
      }
  
      my $entry_ref = \$namespace->{$name};
  
      if (ref($entry_ref) eq 'GLOB') {
          return *{$entry_ref}{$type};
      }
      else {
          if ($type eq 'CODE') {
              if (BROKEN_GLOB_ASSIGNMENT || defined($self->{package})) {
                  no strict 'refs';
                  return \&{ $self->name . '::' . $name };
              }
  
              # XXX we should really be able to support arbitrary anonymous
              # stashes here... (not just via Package::Anon)
              if (blessed($namespace) && $namespace->isa('Package::Anon')) {
                  # ->can will call gv_init for us, which inflates the glob
                  # don't know how to do this in general
                  $namespace->bless(\(my $foo))->can($name);
              }
              else {
                  confess "Don't know how to inflate a " . ref($entry_ref)
                        . " into a full coderef (perhaps you could use"
                        . " Package::Anon instead of a bare stash?)"
              }
  
              return *{ $namespace->{$name} }{CODE};
          }
          else {
              return undef;
          }
      }
  }
  
  sub get_or_add_symbol {
      my $self = shift;
      $self->get_symbol(@_, vivify => 1);
  }
  
  sub remove_symbol {
      my ($self, $variable) = @_;
  
      my ($name, $sigil, $type) = _deconstruct_variable_name($variable);
  
      # FIXME:
      # no doubt this is grossly inefficient and
      # could be done much easier and faster in XS
  
      my %desc = (
          SCALAR => { sigil => '$', type => 'SCALAR', name => $name },
          ARRAY  => { sigil => '@', type => 'ARRAY',  name => $name },
          HASH   => { sigil => '%', type => 'HASH',   name => $name },
          CODE   => { sigil => '&', type => 'CODE',   name => $name },
          IO     => { sigil => '',  type => 'IO',     name => $name },
      );
      confess "This should never ever ever happen" if !$desc{$type};
  
      my @types_to_store = grep { $type ne $_ && $self->has_symbol($desc{$_}) }
                                keys %desc;
      my %values = map { $_, $self->get_symbol($desc{$_}) } @types_to_store;
  
      $values{SCALAR} = $self->get_symbol($desc{SCALAR})
        if !defined $values{SCALAR}
          && $type ne 'SCALAR'
          && BROKEN_SCALAR_INITIALIZATION;
  
      $self->remove_glob($name);
  
      $self->add_symbol($desc{$_} => $values{$_})
          for grep { defined $values{$_} } keys %values;
  }
  
  sub list_all_symbols {
      my ($self, $type_filter) = @_;
  
      my $namespace = $self->namespace;
      if (HAS_ISA_CACHE) {
          return grep { $_ ne '::ISA::CACHE::' } keys %{$namespace}
              unless defined $type_filter;
      }
      else {
          return keys %{$namespace}
              unless defined $type_filter;
      }
  
      # NOTE:
      # or we can filter based on
      # type (SCALAR|ARRAY|HASH|CODE)
      if ($type_filter eq 'CODE') {
          return grep {
              # any non-typeglob in the symbol table is a constant or stub
              ref(\$namespace->{$_}) ne 'GLOB'
                  # regular subs are stored in the CODE slot of the typeglob
                  || defined(*{$namespace->{$_}}{CODE})
          } keys %{$namespace};
      }
      elsif ($type_filter eq 'SCALAR') {
          return grep {
              !(HAS_ISA_CACHE && $_ eq '::ISA::CACHE::') &&
              (BROKEN_SCALAR_INITIALIZATION
                  ? (ref(\$namespace->{$_}) eq 'GLOB'
                        && defined(${*{$namespace->{$_}}{'SCALAR'}}))
                  : (do {
                        my $entry = \$namespace->{$_};
                        ref($entry) eq 'GLOB'
                            && B::svref_2object($entry)->SV->isa('B::SV')
                    }))
          } keys %{$namespace};
      }
      else {
          return grep {
              ref(\$namespace->{$_}) eq 'GLOB'
                  && defined(*{$namespace->{$_}}{$type_filter})
          } keys %{$namespace};
      }
  }
  
  sub get_all_symbols {
      my ($self, $type_filter) = @_;
  
      my $namespace = $self->namespace;
      return { %{$namespace} } unless defined $type_filter;
  
      return {
          map { $_ => $self->get_symbol({name => $_, type => $type_filter}) }
              $self->list_all_symbols($type_filter)
      }
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Package::Stash::PP - pure perl implementation of the Package::Stash API
  
  =head1 VERSION
  
  version 0.37
  
  =head1 SYNOPSIS
  
    use Package::Stash;
  
  =head1 DESCRIPTION
  
  This is a backend for L<Package::Stash> implemented in pure perl, for those without a compiler or who would like to use this inline in scripts.
  
  =head1 BUGS
  
  =over 4
  
  =item * remove_symbol also replaces the associated typeglob
  
  This can cause unexpected behavior when doing manipulation at compile time -
  removing subroutines will still allow them to be called from within the package
  as subroutines (although they will not be available as methods). This can be
  considered a feature in some cases (this is how L<namespace::clean> works, for
  instance), but should not be relied upon - use C<remove_glob> directly if you
  want this behavior.
  
  =item * Some minor memory leaks
  
  The pure perl implementation has a couple minor memory leaks (see the TODO
  tests in t/20-leaks.t) that I'm having a hard time tracking down - these may be
  core perl bugs, it's hard to tell.
  
  =back
  
  Please report any bugs through RT: email
  C<bug-package-stash at rt.cpan.org>, or browse to
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Package-Stash>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Class::MOP::Package>
  
  This module is a factoring out of code that used to live here
  
  =back
  
  =head1 SUPPORT
  
  You can find this documentation for this module with the perldoc command.
  
      perldoc Package::Stash
  
  You can also look for information at:
  
  =over 4
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/Package-Stash>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Package-Stash>
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Package-Stash>
  
  =item * Search CPAN
  
  L<http://search.cpan.org/dist/Package-Stash>
  
  =back
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy at tozt dot net>
  
  Mostly copied from code from L<Class::MOP::Package>, by Stevan Little and the
  Moose Cabal.
  
  =for Pod::Coverage BROKEN_ISA_ASSIGNMENT
  add_symbol
  get_all_symbols
  get_or_add_symbol
  get_symbol
  has_symbol
  list_all_symbols
  name
  namespace
  new
  remove_glob
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy@tozt.net>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PACKAGE_STASH_PP

$fatpacked{"Sub/Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER';
  use 5.006;
  use strict;
  use warnings;
  package Sub::Exporter;
  {
    $Sub::Exporter::VERSION = '0.987';
  }
  # ABSTRACT: a sophisticated exporter for custom-built routines
  
  use Carp ();
  use Data::OptList 0.100 ();
  use Params::Util 0.14 (); # _CODELIKE
  use Sub::Install 0.92 ();
  
  
  # Given a potential import name, this returns the group name -- if it's got a
  # group prefix.
  sub _group_name {
    my ($name) = @_;
  
    return if (index q{-:}, (substr $name, 0, 1)) == -1;
    return substr $name, 1;
  }
  
  # \@groups is a canonicalized opt list of exports and groups this returns
  # another canonicalized opt list with groups replaced with relevant exports.
  # \%seen is groups we've already expanded and can ignore.
  # \%merge is merged options from the group we're descending through.
  sub _expand_groups {
    my ($class, $config, $groups, $collection, $seen, $merge) = @_;
    $seen  ||= {};
    $merge ||= {};
    my @groups = @$groups;
  
    for my $i (reverse 0 .. $#groups) {
      if (my $group_name = _group_name($groups[$i][0])) {
        my $seen = { %$seen }; # faux-dynamic scoping
  
        splice @groups, $i, 1,
          _expand_group($class, $config, $groups[$i], $collection, $seen, $merge);
      } else {
        # there's nothing to munge in this export's args
        next unless my %merge = %$merge;
  
        # we have things to merge in; do so
        my $prefix = (delete $merge{-prefix}) || '';
        my $suffix = (delete $merge{-suffix}) || '';
  
        if (
          Params::Util::_CODELIKE($groups[$i][1]) ## no critic Private
          or
          Params::Util::_SCALAR0($groups[$i][1]) ## no critic Private
        ) {
          # this entry was build by a group generator
          $groups[$i][0] = $prefix . $groups[$i][0] . $suffix;
        } else {
          my $as
            = ref $groups[$i][1]{-as} ? $groups[$i][1]{-as}
            :     $groups[$i][1]{-as} ? $prefix . $groups[$i][1]{-as} . $suffix
            :                           $prefix . $groups[$i][0]      . $suffix;
  
          $groups[$i][1] = { %{ $groups[$i][1] }, %merge, -as => $as };
        }
      }
    }
  
    return \@groups;
  }
  
  # \@group is a name/value pair from an opt list.
  sub _expand_group {
    my ($class, $config, $group, $collection, $seen, $merge) = @_;
    $merge ||= {};
  
    my ($group_name, $group_arg) = @$group;
    $group_name = _group_name($group_name);
  
    Carp::croak qq(group "$group_name" is not exported by the $class module)
      unless exists $config->{groups}{$group_name};
  
    return if $seen->{$group_name}++;
  
    if (ref $group_arg) {
      my $prefix = (delete $merge->{-prefix}||'') . ($group_arg->{-prefix}||'');
      my $suffix = ($group_arg->{-suffix}||'') . (delete $merge->{-suffix}||'');
      $merge = {
        %$merge,
        %$group_arg,
        ($prefix ? (-prefix => $prefix) : ()),
        ($suffix ? (-suffix => $suffix) : ()),
      };
    }
  
    my $exports = $config->{groups}{$group_name};
  
    if (
      Params::Util::_CODELIKE($exports) ## no critic Private
      or
      Params::Util::_SCALAR0($exports) ## no critic Private
    ) {
      # I'm not very happy with this code for hiding -prefix and -suffix, but
      # it's needed, and I'm not sure, offhand, how to make it better.
      # -- rjbs, 2006-12-05
      my $group_arg = $merge ? { %$merge } : {};
      delete $group_arg->{-prefix};
      delete $group_arg->{-suffix};
  
      my $group = Params::Util::_CODELIKE($exports) ## no critic Private
                ? $exports->($class, $group_name, $group_arg, $collection)
                : $class->$$exports($group_name, $group_arg, $collection);
  
      Carp::croak qq(group generator "$group_name" did not return a hashref)
        if ref $group ne 'HASH';
  
      my $stuff = [ map { [ $_ => $group->{$_} ] } keys %$group ];
      return @{
        _expand_groups($class, $config, $stuff, $collection, $seen, $merge)
      };
    } else {
      $exports
        = Data::OptList::mkopt($exports, "$group_name exports");
  
      return @{
        _expand_groups($class, $config, $exports, $collection, $seen, $merge)
      };
    }
  }
  
  sub _mk_collection_builder {
    my ($col, $etc) = @_;
    my ($config, $import_args, $class, $into) = @$etc;
  
    my %seen;
    sub {
      my ($collection) = @_;
      my ($name, $value) = @$collection;
  
      Carp::croak "collection $name provided multiple times in import"
        if $seen{ $name }++;
  
      if (ref(my $hook = $config->{collectors}{$name})) {
        my $arg = {
          name        => $name,
          config      => $config,
          import_args => $import_args,
          class       => $class,
          into        => $into,
        };
  
        my $error_msg = "collection $name failed validation";
        if (Params::Util::_SCALAR0($hook)) { ## no critic Private
          Carp::croak $error_msg unless $class->$$hook($value, $arg);
        } else {
          Carp::croak $error_msg unless $hook->($value, $arg);
        }
      }
  
      $col->{ $name } = $value;
    }
  }
  
  # Given a config and pre-canonicalized importer args, remove collections from
  # the args and return them.
  sub _collect_collections {
    my ($config, $import_args, $class, $into) = @_;
  
    my @collections
      = map  { splice @$import_args, $_, 1 }
        grep { exists $config->{collectors}{ $import_args->[$_][0] } }
        reverse 0 .. $#$import_args;
  
    unshift @collections, [ INIT => {} ] if $config->{collectors}{INIT};
  
    my $col = {};
    my $builder = _mk_collection_builder($col, \@_);
    for my $collection (@collections) {
      $builder->($collection)
    }
  
    return $col;
  }
  
  
  sub setup_exporter {
    my ($config)  = @_;
  
    Carp::croak 'into and into_level may not both be supplied to exporter'
      if exists $config->{into} and exists $config->{into_level};
  
    my $as   = delete $config->{as}   || 'import';
    my $into
      = exists $config->{into}       ? delete $config->{into}
      : exists $config->{into_level} ? caller(delete $config->{into_level})
      :                                caller(0);
  
    my $import = build_exporter($config);
  
    Sub::Install::reinstall_sub({
      code => $import,
      into => $into,
      as   => $as,
    });
  }
  
  
  sub _key_intersection {
    my ($x, $y) = @_;
    my %seen = map { $_ => 1 } keys %$x;
    my @names = grep { $seen{$_} } keys %$y;
  }
  
  # Given the config passed to setup_exporter, which contains sugary opt list
  # data, rewrite the opt lists into hashes, catch a few kinds of invalid
  # configurations, and set up defaults.  Since the config is a reference, it's
  # rewritten in place.
  my %valid_config_key;
  BEGIN {
    %valid_config_key =
      map { $_ => 1 }
      qw(as collectors installer generator exports groups into into_level),
      qw(exporter), # deprecated
  }
  
  sub _assert_collector_names_ok {
    my ($collectors) = @_;
  
    for my $reserved_name (grep { /\A[_A-Z]+\z/ } keys %$collectors) {
      Carp::croak "unknown reserved collector name: $reserved_name"
        if $reserved_name ne 'INIT';
    }
  }
  
  sub _rewrite_build_config {
    my ($config) = @_;
  
    if (my @keys = grep { not exists $valid_config_key{$_} } keys %$config) {
      Carp::croak "unknown options (@keys) passed to Sub::Exporter";
    }
  
    Carp::croak q(into and into_level may not both be supplied to exporter)
      if exists $config->{into} and exists $config->{into_level};
  
    # XXX: Remove after deprecation period.
    if ($config->{exporter}) {
      Carp::cluck "'exporter' argument to build_exporter is deprecated. Use 'installer' instead; the semantics are identical.";
      $config->{installer} = delete $config->{exporter};
    }
  
    Carp::croak q(into and into_level may not both be supplied to exporter)
      if exists $config->{into} and exists $config->{into_level};
  
    for (qw(exports collectors)) {
      $config->{$_} = Data::OptList::mkopt_hash(
        $config->{$_},
        $_,
        [ 'CODE', 'SCALAR' ],
      );
    }
  
    _assert_collector_names_ok($config->{collectors});
  
    if (my @names = _key_intersection(@$config{qw(exports collectors)})) {
      Carp::croak "names (@names) used in both collections and exports";
    }
  
    $config->{groups} = Data::OptList::mkopt_hash(
        $config->{groups},
        'groups',
        [
          'HASH',   # standard opt list
          'ARRAY',  # standard opt list
          'CODE',   # group generator
          'SCALAR', # name of group generation method
        ]
      );
  
    # by default, export nothing
    $config->{groups}{default} ||= [];
  
    # by default, build an all-inclusive 'all' group
    $config->{groups}{all} ||= [ keys %{ $config->{exports} } ];
  
    $config->{generator} ||= \&default_generator;
    $config->{installer} ||= \&default_installer;
  }
  
  sub build_exporter {
    my ($config) = @_;
  
    _rewrite_build_config($config);
  
    my $import = sub {
      my ($class) = shift;
  
      # XXX: clean this up -- rjbs, 2006-03-16
      my $special = (ref $_[0]) ? shift(@_) : {};
      Carp::croak q(into and into_level may not both be supplied to exporter)
        if exists $special->{into} and exists $special->{into_level};
  
      if ($special->{exporter}) {
        Carp::cluck "'exporter' special import argument is deprecated. Use 'installer' instead; the semantics are identical.";
        $special->{installer} = delete $special->{exporter};
      }
  
      my $into
        = defined $special->{into}       ? delete $special->{into}
        : defined $special->{into_level} ? caller(delete $special->{into_level})
        : defined $config->{into}        ? $config->{into}
        : defined $config->{into_level}  ? caller($config->{into_level})
        :                                  caller(0);
  
      my $generator = delete $special->{generator} || $config->{generator};
      my $installer = delete $special->{installer} || $config->{installer};
  
      # this builds a AOA, where the inner arrays are [ name => value_ref ]
      my $import_args = Data::OptList::mkopt([ @_ ]);
  
      # is this right?  defaults first or collectors first? -- rjbs, 2006-06-24
      $import_args = [ [ -default => undef ] ] unless @$import_args;
  
      my $collection = _collect_collections($config, $import_args, $class, $into);
  
      my $to_import = _expand_groups($class, $config, $import_args, $collection);
  
      # now, finally $import_arg is really the "to do" list
      _do_import(
        {
          class     => $class,
          col       => $collection,
          config    => $config,
          into      => $into,
          generator => $generator,
          installer => $installer,
        },
        $to_import,
      );
    };
  
    return $import;
  }
  
  sub _do_import {
    my ($arg, $to_import) = @_;
  
    my @todo;
  
    for my $pair (@$to_import) {
      my ($name, $import_arg) = @$pair;
  
      my ($generator, $as);
  
      if ($import_arg and Params::Util::_CODELIKE($import_arg)) { ## no critic
        # This is the case when a group generator has inserted name/code pairs.
        $generator = sub { $import_arg };
        $as = $name;
      } else {
        $import_arg = { $import_arg ? %$import_arg : () };
  
        Carp::croak qq("$name" is not exported by the $arg->{class} module)
          unless exists $arg->{config}{exports}{$name};
  
        $generator = $arg->{config}{exports}{$name};
  
        $as = exists $import_arg->{-as} ? (delete $import_arg->{-as}) : $name;
      }
  
      my $code = $arg->{generator}->(
        { 
          class     => $arg->{class},
          name      => $name,
          arg       => $import_arg,
          col       => $arg->{col},
          generator => $generator,
        }
      );
  
      push @todo, $as, $code;
    }
  
    $arg->{installer}->(
      {
        class => $arg->{class},
        into  => $arg->{into},
        col   => $arg->{col},
      },
      \@todo,
    );
  }
  
  ## Cute idea, possibly for future use: also supply an "unimport" for:
  ## no Module::Whatever qw(arg arg arg);
  # sub _unexport {
  #   my (undef, undef, undef, undef, undef, $as, $into) = @_;
  # 
  #   if (ref $as eq 'SCALAR') {
  #     undef $$as;
  #   } elsif (ref $as) {
  #     Carp::croak "invalid reference type for $as: " . ref $as;
  #   } else {
  #     no strict 'refs';
  #     delete &{$into . '::' . $as};
  #   }
  # }
  
  
  sub default_generator {
    my ($arg) = @_;
    my ($class, $name, $generator) = @$arg{qw(class name generator)};
  
    if (not defined $generator) {
      my $code = $class->can($name)
        or Carp::croak "can't locate exported subroutine $name via $class";
      return $code;
    }
  
    # I considered making this "$class->$generator(" but it seems that
    # overloading precedence would turn an overloaded-as-code generator object
    # into a string before code. -- rjbs, 2006-06-11
    return $generator->($class, $name, $arg->{arg}, $arg->{col})
      if Params::Util::_CODELIKE($generator); ## no critic Private
  
    # This "must" be a scalar reference, to a generator method name.
    # -- rjbs, 2006-12-05
    return $class->$$generator($name, $arg->{arg}, $arg->{col});
  }
  
  
  sub default_installer {
    my ($arg, $to_export) = @_;
  
    for (my $i = 0; $i < @$to_export; $i += 2) {
      my ($as, $code) = @$to_export[ $i, $i+1 ];
  
      # Allow as isa ARRAY to push onto an array?
      # Allow into isa HASH to install name=>code into hash?
  
      if (ref $as eq 'SCALAR') {
        $$as = $code;
      } elsif (ref $as) {
        Carp::croak "invalid reference type for $as: " . ref $as;
      } else {
        Sub::Install::reinstall_sub({
          code => $code,
          into => $arg->{into},
          as   => $as
        });
      }
    }
  }
  
  sub default_exporter {
    Carp::cluck "default_exporter is deprecated; call default_installer instead; the semantics are identical";
    goto &default_installer;
  }
  
  
  setup_exporter({
    exports => [
      qw(setup_exporter build_exporter),
      _import => sub { build_exporter($_[2]) },
    ],
    groups  => {
      all   => [ qw(setup_exporter build_export) ],
    },
    collectors => { -setup => \&_setup },
  });
  
  sub _setup {
    my ($value, $arg) = @_;
  
    if (ref $value eq 'HASH') {
      push @{ $arg->{import_args} }, [ _import => { -as => 'import', %$value } ];
      return 1;
    } elsif (ref $value eq 'ARRAY') {
      push @{ $arg->{import_args} },
        [ _import => { -as => 'import', exports => $value } ];
      return 1;
    }
    return;
  }
  
  
  
  "jn8:32"; # <-- magic true value
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Sub::Exporter - a sophisticated exporter for custom-built routines
  
  =head1 VERSION
  
  version 0.987
  
  =head1 SYNOPSIS
  
  Sub::Exporter must be used in two places.  First, in an exporting module:
  
    # in the exporting module:
    package Text::Tweaker;
    use Sub::Exporter -setup => {
      exports => [
        qw(squish titlecase), # always works the same way
        reformat => \&build_reformatter, # generator to build exported function
        trim     => \&build_trimmer,
        indent   => \&build_indenter,
      ],
      collectors => [ 'defaults' ],
    };
  
  Then, in an importing module:
  
    # in the importing module:
    use Text::Tweaker
      'squish',
      indent   => { margin => 5 },
      reformat => { width => 79, justify => 'full', -as => 'prettify_text' },
      defaults => { eol => 'CRLF' };
  
  With this setup, the importing module ends up with three routines: C<squish>,
  C<indent>, and C<prettify_text>.  The latter two have been built to the
  specifications of the importer -- they are not just copies of the code in the
  exporting package.
  
  =head1 DESCRIPTION
  
  B<ACHTUNG!>  If you're not familiar with Exporter or exporting, read
  L<Sub::Exporter::Tutorial> first!
  
  =head2 Why Generators?
  
  The biggest benefit of Sub::Exporter over existing exporters (including the
  ubiquitous Exporter.pm) is its ability to build new coderefs for export, rather
  than to simply export code identical to that found in the exporting package.
  
  If your module's consumers get a routine that works like this:
  
    use Data::Analyze qw(analyze);
    my $value = analyze($data, $tolerance, $passes);
  
  and they constantly pass only one or two different set of values for the
  non-C<$data> arguments, your code can benefit from Sub::Exporter.  By writing a
  simple generator, you can let them do this, instead:
  
    use Data::Analyze
      analyze => { tolerance => 0.10, passes => 10, -as => analyze10 },
      analyze => { tolerance => 0.15, passes => 50, -as => analyze50 };
  
    my $value = analyze10($data);
  
  The package with the generator for that would look something like this:
  
    package Data::Analyze;
    use Sub::Exporter -setup => {
      exports => [
        analyze => \&build_analyzer,
      ],
    };
  
    sub build_analyzer {
      my ($class, $name, $arg) = @_;
  
      return sub {
        my $data      = shift;
        my $tolerance = shift || $arg->{tolerance}; 
        my $passes    = shift || $arg->{passes}; 
  
        analyze($data, $tolerance, $passes);
      }
    }
  
  Your module's user now has to do less work to benefit from it -- and remember,
  you're often your own user!  Investing in customized subroutines is an
  investment in future laziness.
  
  This also avoids a common form of ugliness seen in many modules: package-level
  configuration.  That is, you might have seen something like the above
  implemented like so:
  
    use Data::Analyze qw(analyze);
    $Data::Analyze::default_tolerance = 0.10;
    $Data::Analyze::default_passes    = 10;
  
  This might save time, until you have multiple modules using Data::Analyze.
  Because there is only one global configuration, they step on each other's toes
  and your code begins to have mysterious errors.
  
  Generators can also allow you to export class methods to be called as
  subroutines:
  
    package Data::Methodical;
    use Sub::Exporter -setup => { exports => { some_method => \&_curry_class } };
  
    sub _curry_class {
      my ($class, $name) = @_;
      sub { $class->$name(@_); };
    }
  
  Because of the way that exporters and Sub::Exporter work, any package that
  inherits from Data::Methodical can inherit its exporter and override its
  C<some_method>.  If a user imports C<some_method> from that package, he'll
  receive a subroutine that calls the method on the subclass, rather than on
  Data::Methodical itself.
  
  =head2 Other Customizations
  
  Building custom routines with generators isn't the only way that Sub::Exporters
  allows the importing code to refine its use of the exported routines.  They may
  also be renamed to avoid naming collisions.
  
  Consider the following code:
  
    # this program determines to which circle of Hell you will be condemned
    use Morality qw(sin virtue); # for calculating viciousness
    use Math::Trig qw(:all);     # for dealing with circles
  
  The programmer has inadvertently imported two C<sin> routines.  The solution,
  in Exporter.pm-based modules, would be to import only one and then call the
  other by its fully-qualified name.  Alternately, the importer could write a
  routine that did so, or could mess about with typeglobs.
  
  How much easier to write:
  
    # this program determines to which circle of Hell you will be condemned
    use Morality qw(virtue), sin => { -as => 'offense' };
    use Math::Trig -all => { -prefix => 'trig_' };
  
  and to have at one's disposal C<offense> and C<trig_sin> -- not to mention
  C<trig_cos> and C<trig_tan>.
  
  =head1 EXPORTER CONFIGURATION
  
  You can configure an exporter for your package by using Sub::Exporter like so:
  
    package Tools;
    use Sub::Exporter
      -setup => { exports => [ qw(function1 function2 function3) ] };
  
  This is the simplest way to use the exporter, and is basically equivalent to
  this:
  
    package Tools;
    use base qw(Exporter);
    our @EXPORT_OK = qw(function1 function2 function3);
  
  Any basic use of Sub::Exporter will look like this:
  
    package Tools;
    use Sub::Exporter -setup => \%config;
  
  The following keys are valid in C<%config>:
  
    exports - a list of routines to provide for exporting; each routine may be
              followed by generator
    groups  - a list of groups to provide for exporting; each must be followed by
              either (a) a list of exports, possibly with arguments for each
              export, or (b) a generator
  
    collectors - a list of names into which values are collected for use in
                 routine generation; each name may be followed by a validator
  
  In addition to the basic options above, a few more advanced options may be
  passed:
  
    into_level - how far up the caller stack to look for a target (default 0)
    into       - an explicit target (package) into which to export routines
  
  In other words: Sub::Exporter installs a C<import> routine which, when called,
  exports routines to the calling namespace.  The C<into> and C<into_level>
  options change where those exported routines are installed.
  
    generator  - a callback used to produce the code that will be installed
                 default: Sub::Exporter::default_generator
  
    installer  - a callback used to install the code produced by the generator
                 default: Sub::Exporter::default_installer
  
  For information on how these callbacks are used, see the documentation for
  C<L</default_generator>> and C<L</default_installer>>.
  
  =head2 Export Configuration
  
  The C<exports> list may be provided as an array reference or a hash reference.
  The list is processed in such a way that the following are equivalent:
  
    { exports => [ qw(foo bar baz), quux => \&quux_generator ] }
  
    { exports =>
      { foo => undef, bar => undef, baz => undef, quux => \&quux_generator } }
  
  Generators are code that return coderefs.  They are called with four
  parameters:
  
    $class - the class whose exporter has been called (the exporting class)
    $name  - the name of the export for which the routine is being build
   \%arg   - the arguments passed for this export
   \%col   - the collections for this import
  
  Given the configuration in the L</SYNOPSIS>, the following C<use> statement:
  
    use Text::Tweaker
      reformat => { -as => 'make_narrow', width => 33 },
      defaults => { eol => 'CR' };
  
  would result in the following call to C<&build_reformatter>:
  
    my $code = build_reformatter(
      'Text::Tweaker',
      'reformat',
      { width => 33 }, # note that -as is not passed in
      { defaults => { eol => 'CR' } },
    );
  
  The returned coderef (C<$code>) would then be installed as C<make_narrow> in the
  calling package.
  
  Instead of providing a coderef in the configuration, a reference to a method
  name may be provided.  This method will then be called on the invocant of the
  C<import> method.  (In this case, we do not pass the C<$class> parameter, as it
  would be redundant.)
  
  =head2 Group Configuration
  
  The C<groups> list can be passed in the same forms as C<exports>.  Groups must
  have values to be meaningful, which may either list exports that make up the
  group (optionally with arguments) or may provide a way to build the group.
  
  The simpler case is the first: a group definition is a list of exports.  Here's
  the example that could go in exporter in the L</SYNOPSIS>.
  
    groups  => {
      default    => [ qw(reformat) ],
      shorteners => [ qw(squish trim) ],
      email_safe => [
        'indent',
        reformat => { -as => 'email_format', width => 72 }
      ],
    },
  
  Groups are imported by specifying their name prefixed be either a dash or a
  colon.  This line of code would import the C<shorteners> group:
  
    use Text::Tweaker qw(-shorteners);
  
  Arguments passed to a group when importing are merged into the groups options
  and passed to any relevant generators.  Groups can contain other groups, but
  looping group structures are ignored.
  
  The other possible value for a group definition, a coderef, allows one
  generator to build several exportable routines simultaneously.  This is useful
  when many routines must share enclosed lexical variables.  The coderef must
  return a hash reference.  The keys will be used as export names and the values
  are the subs that will be exported.
  
  This example shows a simple use of the group generator.
  
    package Data::Crypto;
    use Sub::Exporter -setup => { groups => { cipher => \&build_cipher_group } };
  
    sub build_cipher_group {
      my ($class, $group, $arg) = @_;
      my ($encode, $decode) = build_codec($arg->{secret});
      return { cipher => $encode, decipher => $decode };
    }
  
  The C<cipher> and C<decipher> routines are built in a group because they are
  built together by code which encloses their secret in their environment.
  
  =head3 Default Groups
  
  If a module that uses Sub::Exporter is C<use>d with no arguments, it will try
  to export the group named C<default>.  If that group has not been specifically
  configured, it will be empty, and nothing will happen.
  
  Another group is also created if not defined: C<all>.  The C<all> group
  contains all the exports from the exports list.
  
  =head2 Collector Configuration
  
  The C<collectors> entry in the exporter configuration gives names which, when
  found in the import call, have their values collected and passed to every
  generator.
  
  For example, the C<build_analyzer> generator that we saw above could be
  rewritten as:
  
   sub build_analyzer {
     my ($class, $name, $arg, $col) = @_;
  
     return sub {
       my $data      = shift;
       my $tolerance = shift || $arg->{tolerance} || $col->{defaults}{tolerance}; 
       my $passes    = shift || $arg->{passes}    || $col->{defaults}{passes}; 
  
       analyze($data, $tolerance, $passes);
     }
   }
  
  That would allow the importer to specify global defaults for his imports:
  
    use Data::Analyze
      'analyze',
      analyze  => { tolerance => 0.10, -as => analyze10 },
      analyze  => { tolerance => 0.15, passes => 50, -as => analyze50 },
      defaults => { passes => 10 };
  
    my $A = analyze10($data);     # equivalent to analyze($data, 0.10, 10);
    my $C = analyze50($data);     # equivalent to analyze($data, 0.15, 50);
    my $B = analyze($data, 0.20); # equivalent to analyze($data, 0.20, 10);
  
  If values are provided in the C<collectors> list during exporter setup, they
  must be code references, and are used to validate the importer's values.  The
  validator is called when the collection is found, and if it returns false, an
  exception is thrown.  We could ensure that no one tries to set a global data
  default easily:
  
    collectors => { defaults => sub { return (exists $_[0]->{data}) ? 0 : 1 } }
  
  Collector coderefs can also be used as hooks to perform arbitrary actions
  before anything is exported.
  
  When the coderef is called, it is passed the value of the collection and a
  hashref containing the following entries:
  
    name        - the name of the collector
    config      - the exporter configuration (hashref)
    import_args - the arguments passed to the exporter, sans collections (aref)
    class       - the package on which the importer was called
    into        - the package into which exports will be exported
  
  Collectors with all-caps names (that is, made up of underscore or capital A
  through Z) are reserved for special use.  The only currently implemented
  special collector is C<INIT>, whose hook (if present in the exporter
  configuration) is always run before any other hook.
  
  =head1 CALLING THE EXPORTER
  
  Arguments to the exporter (that is, the arguments after the module name in a
  C<use> statement) are parsed as follows:
  
  First, the collectors gather any collections found in the arguments.  Any
  reference type may be given as the value for a collector.  For each collection
  given in the arguments, its validator (if any) is called.  
  
  Next, groups are expanded.  If the group is implemented by a group generator,
  the generator is called.  There are two special arguments which, if given to a
  group, have special meaning:
  
    -prefix - a string to prepend to any export imported from this group
    -suffix - a string to append to any export imported from this group
  
  Finally, individual export generators are called and all subs, generated or
  otherwise, are installed in the calling package.  There is only one special
  argument for export generators:
  
    -as     - where to install the exported sub
  
  Normally, C<-as> will contain an alternate name for the routine.  It may,
  however, contain a reference to a scalar.  If that is the case, a reference the
  generated routine will be placed in the scalar referenced by C<-as>.  It will
  not be installed into the calling package.
  
  =head2 Special Exporter Arguments
  
  The generated exporter accept some special options, which may be passed as the
  first argument, in a hashref.
  
  These options are:
  
    into_level
    into
    generator
    installer
  
  These override the same-named configuration options described in L</EXPORTER
  CONFIGURATION>.
  
  =head1 SUBROUTINES
  
  =head2 setup_exporter
  
  This routine builds and installs an C<import> routine.  It is called with one
  argument, a hashref containing the exporter configuration.  Using this, it
  builds an exporter and installs it into the calling package with the name
  "import."  In addition to the normal exporter configuration, a few named
  arguments may be passed in the hashref:
  
    into       - into what package should the exporter be installed
    into_level - into what level up the stack should the exporter be installed
    as         - what name should the installed exporter be given
  
  By default the exporter is installed with the name C<import> into the immediate
  caller of C<setup_exporter>.  In other words, if your package calls
  C<setup_exporter> without providing any of the three above arguments, it will
  have an C<import> routine installed.
  
  Providing both C<into> and C<into_level> will cause an exception to be thrown.
  
  The exporter is built by C<L</build_exporter>>.
  
  =head2 build_exporter
  
  Given a standard exporter configuration, this routine builds and returns an
  exporter -- that is, a subroutine that can be installed as a class method to
  perform exporting on request.
  
  Usually, this method is called by C<L</setup_exporter>>, which then installs
  the exporter as a package's import routine.
  
  =head2 default_generator
  
  This is Sub::Exporter's default generator.  It takes bits of configuration that
  have been gathered during the import and turns them into a coderef that can be
  installed.
  
    my $code = default_generator(\%arg);
  
  Passed arguments are:
  
    class - the class on which the import method was called
    name  - the name of the export being generated
    arg   - the arguments to the generator
    col   - the collections
  
    generator - the generator to be used to build the export (code or scalar ref)
  
  =head2 default_installer
  
  This is Sub::Exporter's default installer.  It does what Sub::Exporter
  promises: it installs code into the target package.
  
    default_installer(\%arg, \@to_export);
  
  Passed arguments are:
  
    into - the package into which exports should be delivered
  
  C<@to_export> is a list of name/value pairs.  The default exporter assigns code
  (the values) to named slots (the names) in the given package.  If the name is a
  scalar reference, the scalar reference is made to point to the code reference
  instead.
  
  =head1 EXPORTS
  
  Sub::Exporter also offers its own exports: the C<setup_exporter> and
  C<build_exporter> routines described above.  It also provides a special "setup"
  collector, which will set up an exporter using the parameters passed to it.
  
  Note that the "setup" collector (seen in examples like the L</SYNOPSIS> above)
  uses C<build_exporter>, not C<setup_exporter>.  This means that the special
  arguments like "into" and "as" for C<setup_exporter> are not accepted here.
  Instead, you may write something like:
  
    use Sub::Exporter
      { into => 'Target::Package' },
      -setup => {
        -as     => 'do_import',
        exports => [ ... ],
      }
    ;
  
  Finding a good reason for wanting to do this is left as an exercise for the
  reader.
  
  =head1 COMPARISONS
  
  There are a whole mess of exporters on the CPAN.  The features included in
  Sub::Exporter set it apart from any existing Exporter.  Here's a summary of
  some other exporters and how they compare.
  
  =over
  
  =item * L<Exporter> and co.
  
  This is the standard Perl exporter.  Its interface is a little clunky, but it's
  fast and ubiquitous.  It can do some things that Sub::Exporter can't:  it can
  export things other than routines, it can import "everything in this group
  except this symbol," and some other more esoteric things.  These features seem
  to go nearly entirely unused.
  
  It always exports things exactly as they appear in the exporting module; it
  can't rename or customize routines.  Its groups ("tags") can't be nested.
  
  L<Exporter::Lite> is a whole lot like Exporter, but it does significantly less:
  it supports exporting symbols, but not groups, pattern matching, or negation.
  
  The fact that Sub::Exporter can't export symbols other than subroutines is
  a good idea, not a missing feature.
  
  For simple uses, setting up Sub::Exporter is about as easy as Exporter.  For
  complex uses, Sub::Exporter makes hard things possible, which would not be
  possible with Exporter. 
  
  When using a module that uses Sub::Exporter, users familiar with Exporter will
  probably see no difference in the basics.  These two lines do about the same
  thing in whether the exporting module uses Exporter or Sub::Exporter.
  
    use Some::Module qw(foo bar baz);
    use Some::Module qw(foo :bar baz);
  
  The definition for exporting in Exporter.pm might look like this:
  
    package Some::Module;
    use base qw(Exporter);
    our @EXPORT_OK   = qw(foo bar baz quux);
    our %EXPORT_TAGS = (bar => [ qw(bar baz) ]);
  
  Using Sub::Exporter, it would look like this:
  
    package Some::Module;
    use Sub::Exporter -setup => {
      exports => [ qw(foo bar baz quux) ],
      groups  => { bar => [ qw(bar baz) ]}
    };
  
  Sub::Exporter respects inheritance, so that a package may export inherited
  routines, and will export the most inherited version.  Exporting methods
  without currying away the invocant is a bad idea, but Sub::Exporter allows you
  to do just that -- and anyway, there are other uses for this feature, like
  packages of exported subroutines which use inheritance specifically to allow
  more specialized, but similar, packages.
  
  L<Exporter::Easy> provides a wrapper around the standard Exporter.  It makes it
  simpler to build groups, but doesn't provide any more functionality.  Because
  it is a front-end to Exporter, it will store your exporter's configuration in
  global package variables.
  
  =item * Attribute-Based Exporters
  
  Some exporters use attributes to mark variables to export.  L<Exporter::Simple>
  supports exporting any kind of symbol, and supports groups.  Using a module
  like Exporter or Sub::Exporter, it's easy to look at one place and see what is
  exported, but it's impossible to look at a variable definition and see whether
  it is exported by that alone.  Exporter::Simple makes this trade in reverse:
  each variable's declaration includes its export definition, but there is no one
  place to look to find a manifest of exports.
  
  More importantly, Exporter::Simple does not add any new features to those of
  Exporter.  In fact, like Exporter::Easy, it is just a front-end to Exporter, so
  it ends up storing its configuration in global package variables.  (This means
  that there is one place to look for your exporter's manifest, actually.  You
  can inspect the C<@EXPORT> package variables, and other related package
  variables, at runtime.)
  
  L<Perl6::Export> isn't actually attribute based, but looks similar.  Its syntax
  is borrowed from Perl 6, and implemented by a source filter.  It is a prototype
  of an interface that is still being designed.  It should probably be avoided
  for production work.  On the other hand, L<Perl6::Export::Attrs> implements
  Perl 6-like exporting, but translates it into Perl 5 by providing attributes.
  
  =item * Other Exporters
  
  L<Exporter::Renaming> wraps the standard Exporter to allow it to export symbols
  with changed names.
  
  L<Class::Exporter> performs a special kind of routine generation, giving each
  importing package an instance of your class, and then exporting the instance's
  methods as normal routines.  (Sub::Exporter, of course, can easily emulate this
  behavior, as shown above.)
  
  L<Exporter::Tidy> implements a form of renaming (using its C<_map> argument)
  and of prefixing, and implements groups.  It also avoids using package
  variables for its configuration.
  
  =back
  
  =head1 TODO
  
  =over
  
  =item * write a set of longer, more demonstrative examples
  
  =item * solidify the "custom exporter" interface (see C<&default_exporter>)
  
  =item * add an "always" group
  
  =back
  
  =head1 THANKS
  
  Hans Dieter Pearcey provided helpful advice while I was writing Sub::Exporter.
  Ian Langworth and Shawn Sorichetti asked some good questions and helped me
  improve my documentation quite a bit.  Yuval Kogman helped me find a bunch of
  little problems.
  
  Thanks, guys! 
  
  =head1 BUGS
  
  Please report any bugs or feature requests through the web interface at
  L<http://rt.cpan.org>. I will be notified, and then you'll automatically be
  notified of progress on your bug as I make changes.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2007 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_EXPORTER

$fatpacked{"Sub/Exporter/Progressive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;
  $Sub::Exporter::Progressive::VERSION = '0.001013';
  use strict;
  use warnings;
  
  # ABSTRACT: Only use Sub::Exporter if you need it
  
  sub _croak {
    require Carp;
    &Carp::croak;
  }
  
  sub import {
     my ($self, @args) = @_;
  
     my $inner_target = caller;
     my $export_data = sub_export_options($inner_target, @args);
  
     my $full_exporter;
     no strict 'refs';
     no warnings 'once';
     @{"${inner_target}::EXPORT_OK"} = @{$export_data->{exports}};
     @{"${inner_target}::EXPORT"} = @{$export_data->{defaults}};
     %{"${inner_target}::EXPORT_TAGS"} = %{$export_data->{tags}};
     *{"${inner_target}::import"} = sub {
        use strict;
        my ($self, @args) = @_;
  
        if ( grep {
           length ref $_
              or
           $_ !~ / \A [:-]? \w+ \z /xm
        } @args ) {
           _croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed'
              unless eval { require Sub::Exporter };
           $full_exporter ||= Sub::Exporter::build_exporter($export_data->{original});
  
           goto $full_exporter;
        } elsif ( defined( (my ($num) = grep { m/^\d/ } @args)[0] ) ) {
           _croak "cannot export symbols with a leading digit: '$num'";
        } else {
           require Exporter;
           s/ \A - /:/xm for @args;
           @_ = ($self, @args);
           goto \&Exporter::import;
        }
     };
     return;
  }
  
  my $too_complicated = <<'DEATH';
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
  
  sub sub_export_options {
     my ($inner_target, $setup, $options) = @_;
  
     my @exports;
     my @defaults;
     my %tags;
  
     if ( ($setup||'') eq '-setup') {
        my %options = %$options;
  
        OPTIONS:
        for my $opt (keys %options) {
           if ($opt eq 'exports') {
  
              _croak $too_complicated if ref $options{exports} ne 'ARRAY';
              @exports = @{$options{exports}};
              _croak $too_complicated if grep { length ref $_ } @exports;
  
           } elsif ($opt eq 'groups') {
              %tags = %{$options{groups}};
              for my $tagset (values %tags) {
                 _croak $too_complicated if grep {
                    length ref $_
                       or
                    $_ =~ / \A - (?! all \b ) /x
                 } @{$tagset};
              }
              @defaults = @{$tags{default} || [] };
           } else {
              _croak $too_complicated;
           }
        }
        @{$_} = map { / \A  [:-] all \z /x ? @exports : $_ } @{$_} for \@defaults, values %tags;
        $tags{all} ||= [ @exports ];
        my %exports = map { $_ => 1 } @exports;
        my @errors = grep { not $exports{$_} } @defaults;
        _croak join(', ', @errors) . " is not exported by the $inner_target module\n" if @errors;
     }
  
     return {
        exports => \@exports,
        defaults => \@defaults,
        original => $options,
        tags => \%tags,
     };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Sub::Exporter::Progressive - Only use Sub::Exporter if you need it
  
  =head1 VERSION
  
  version 0.001013
  
  =head1 SYNOPSIS
  
   package Syntax::Keyword::Gather;
  
   use Sub::Exporter::Progressive -setup => {
     exports => [qw( break gather gathered take )],
     groups => {
       default => [qw( break gather gathered take )],
     },
   };
  
   # elsewhere
  
   # uses Exporter for speed
   use Syntax::Keyword::Gather;
  
   # somewhere else
  
   # uses Sub::Exporter for features
   use Syntax::Keyword::Gather 'gather', take => { -as => 'grab' };
  
  =head1 DESCRIPTION
  
  L<Sub::Exporter> is an incredibly powerful module, but with that power comes
  great responsibility, er- as well as some runtime penalties.  This module
  is a C<Sub::Exporter> wrapper that will let your users just use L<Exporter>
  if all they are doing is picking exports, but use C<Sub::Exporter> if your
  users try to use C<Sub::Exporter>'s more advanced features, like
  renaming exports, if they try to use them.
  
  Note that this module will export C<@EXPORT>, C<@EXPORT_OK> and
  C<%EXPORT_TAGS> package variables for C<Exporter> to work.  Additionally, if
  your package uses advanced C<Sub::Exporter> features like currying, this module
  will only ever use C<Sub::Exporter>, so you might as well use it directly.
  
  =head1 CONTRIBUTORS
  
  ilmari - Dagfinn Ilmari Mannsåker (cpan:ILMARI) <ilmari@ilmari.org>
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  leont - Leon Timmermans (cpan:LEONT) <leont@cpan.org>
  
  =head1 AUTHOR
  
  Arthur Axel "fREW" Schmidt <Sub-Exporter-Progressive@afoolishmanifesto.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Arthur Axel "fREW" Schmidt.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"Sub/Exporter/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_UTIL';
  use strict;
  use warnings;
  package Sub::Exporter::Util;
  {
    $Sub::Exporter::Util::VERSION = '0.987';
  }
  # ABSTRACT: utilities to make Sub::Exporter easier
  
  use Data::OptList ();
  use Params::Util ();
  
  
  sub curry_method {
    my $override_name = shift;
    sub {
      my ($class, $name) = @_;
      $name = $override_name if defined $override_name;
      sub { $class->$name(@_); };
    }
  }
  
  BEGIN { *curry_class = \&curry_method; }
  
  
  sub curry_chain {
    # In the future, we can make \%arg an optional prepend, like the "special"
    # args to the default Sub::Exporter-generated import routine.
    my (@opt_list) = @_;
  
    my $pairs = Data::OptList::mkopt(\@opt_list, 'args', 'ARRAY');
  
    sub {
      my ($class) = @_;
  
      sub {
        my $next = $class;
  
        for my $i (0 .. $#$pairs) {
          my $pair = $pairs->[ $i ];
          
          unless (Params::Util::_INVOCANT($next)) { ## no critic Private
            my $str = defined $next ? "'$next'" : 'undef';
            Carp::croak("can't call $pair->[0] on non-invocant $str")
          }
  
          my ($method, $args) = @$pair;
  
          if ($i == $#$pairs) {
            return $next->$method($args ? @$args : ());
          } else {
            $next = $next->$method($args ? @$args : ());
          }
        }
      };
    }
  }
  
  # =head2 name_map
  # 
  # This utility returns an list to be used in specify export generators.  For
  # example, the following:
  # 
  #   exports => {
  #     name_map(
  #       '_?_gen'  => [ qw(fee fie) ],
  #       '_make_?' => [ qw(foo bar) ],
  #     ),
  #   }
  # 
  # is equivalent to:
  # 
  #   exports => {
  #     name_map(
  #       fee => \'_fee_gen',
  #       fie => \'_fie_gen',
  #       foo => \'_make_foo',
  #       bar => \'_make_bar',
  #     ),
  #   }
  # 
  # This can save a lot of typing, when providing many exports with similarly-named
  # generators.
  # 
  # =cut
  # 
  # sub name_map {
  #   my (%groups) = @_;
  # 
  #   my %map;
  # 
  #   while (my ($template, $names) = each %groups) {
  #     for my $name (@$names) {
  #       (my $export = $template) =~ s/\?/$name/
  #         or Carp::croak 'no ? found in name_map template';
  # 
  #       $map{ $name } = \$export;
  #     }
  #   }
  # 
  #   return %map;
  # }
  
  
  sub merge_col {
    my (%groups) = @_;
  
    my %merged;
  
    while (my ($default_name, $group) = each %groups) {
      while (my ($export_name, $gen) = each %$group) {
        $merged{$export_name} = sub {
          my ($class, $name, $arg, $col) = @_;
  
          my $merged_arg = exists $col->{$default_name}
                         ? { %{ $col->{$default_name} }, %$arg }
                         : $arg;
  
          if (Params::Util::_CODELIKE($gen)) { ## no critic Private
            $gen->($class, $name, $merged_arg, $col);
          } else {
            $class->$$gen($name, $merged_arg, $col);
          }
        }
      }
    }
  
    return %merged;
  }
  
  
  sub __mixin_class_for {
    my ($class, $mix_into) = @_;
    require Package::Generator;
    my $mixin_class = Package::Generator->new_package({
      base => "$class\:\:__mixin__",
    });
  
    ## no critic (ProhibitNoStrict)
    no strict 'refs';
    if (ref $mix_into) {
      unshift @{"$mixin_class" . "::ISA"}, ref $mix_into;
    } else {
      unshift @{"$mix_into" . "::ISA"}, $mixin_class;
    }
    return $mixin_class;
  }
  
  sub mixin_installer {
    sub {
      my ($arg, $to_export) = @_;
  
      my $mixin_class = __mixin_class_for($arg->{class}, $arg->{into});
      bless $arg->{into} => $mixin_class if ref $arg->{into};
  
      Sub::Exporter::default_installer(
        { %$arg, into => $mixin_class },
        $to_export,
      );
    };
  }
  
  sub mixin_exporter {
    Carp::cluck "mixin_exporter is deprecated; use mixin_installer instead; it behaves identically";
    return mixin_installer;
  }
  
  
  sub like {
    sub {
      my ($value, $arg) = @_;
      Carp::croak "no regex supplied to regex group generator" unless $value;
  
      # Oh, qr//, how you bother me!  See the p5p thread from around now about
      # fixing this problem... too bad it won't help me. -- rjbs, 2006-04-25
      my @values = eval { $value->isa('Regexp') } ? ($value, undef)
                 :                                  @$value;
  
      while (my ($re, $opt) = splice @values, 0, 2) {
        Carp::croak "given pattern for regex group generater is not a Regexp"
          unless eval { $re->isa('Regexp') };
        my @exports  = keys %{ $arg->{config}->{exports} };
        my @matching = grep { $_ =~ $re } @exports;
  
        my %merge = $opt ? %$opt : ();
        my $prefix = (delete $merge{-prefix}) || '';
        my $suffix = (delete $merge{-suffix}) || '';
  
        for my $name (@matching) {
          my $as = $prefix . $name . $suffix;
          push @{ $arg->{import_args} }, [ $name => { %merge, -as => $as } ];
        }
      }
  
      1;
    }
  }
  
  use Sub::Exporter -setup => {
    exports => [ qw(
      like
      name_map
      merge_col
      curry_method curry_class
      curry_chain
      mixin_installer mixin_exporter
    ) ]
  };
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Sub::Exporter::Util - utilities to make Sub::Exporter easier
  
  =head1 VERSION
  
  version 0.987
  
  =head1 DESCRIPTION
  
  This module provides a number of utility functions for performing common or
  useful operations when setting up a Sub::Exporter configuration.  All of the
  utilities may be exported, but none are by default.
  
  =head1 THE UTILITIES
  
  =head2 curry_method
  
    exports => {
      some_method => curry_method,
    }
  
  This utility returns a generator which will produce an invocant-curried version
  of a method.  In other words, it will export a method call with the exporting
  class built in as the invocant.
  
  A module importing the code some the above example might do this:
  
    use Some::Module qw(some_method);
  
    my $x = some_method;
  
  This would be equivalent to:
  
    use Some::Module;
  
    my $x = Some::Module->some_method;
  
  If Some::Module is subclassed and the subclass's import method is called to
  import C<some_method>, the subclass will be curried in as the invocant.
  
  If an argument is provided for C<curry_method> it is used as the name of the
  curried method to export.  This means you could export a Widget constructor
  like this:
  
    exports => { widget => curry_method('new') }
  
  This utility may also be called as C<curry_class>, for backwards compatibility.
  
  =head2 curry_chain
  
  C<curry_chain> behaves like C<L</curry_method>>, but is meant for generating
  exports that will call several methods in succession.
  
    exports => {
      reticulate => curry_chain(
        new => gather_data => analyze => [ detail => 100 ] => 'results'
      ),
    }
  
  If imported from Spliner, calling the C<reticulate> routine will be equivalent
  to:
  
    Spliner->new->gather_data->analyze(detail => 100)->results;
  
  If any method returns something on which methods may not be called, the routine
  croaks.
  
  The arguments to C<curry_chain> form an optlist.  The names are methods to be
  called and the arguments, if given, are arrayrefs to be dereferenced and passed
  as arguments to those methods.  C<curry_chain> returns a generator like those
  expected by Sub::Exporter.
  
  B<Achtung!> at present, there is no way to pass arguments from the generated
  routine to the method calls.  This will probably be solved in future revisions
  by allowing the opt list's values to be subroutines that will be called with
  the generated routine's stack.
  
  =head2 merge_col
  
    exports => {
      merge_col(defaults => {
        twiddle => \'_twiddle_gen',
        tweak   => \&_tweak_gen,
      }),
    }
  
  This utility wraps the given generator in one that will merge the named
  collection into its args before calling it.  This means that you can support a
  "default" collector in multiple exports without writing the code each time.
  
  You can specify as many pairs of collection names and generators as you like.
  
  =head2 mixin_installer
  
    use Sub::Exporter -setup => {
      installer => Sub::Exporter::Util::mixin_installer,
      exports   => [ qw(foo bar baz) ],
    };
  
  This utility returns an installer that will install into a superclass and
  adjust the ISA importing class to include the newly generated superclass.
  
  If the target of importing is an object, the hierarchy is reversed: the new
  class will be ISA the object's class, and the object will be reblessed.
  
  B<Prerequisites>: This utility requires that Package::Generator be installed.
  
  =head2 like
  
  It's a collector that adds imports for anything like given regex.
  
  If you provide this configuration:
  
    exports    => [ qw(igrep imap islurp exhausted) ],
    collectors => { -like => Sub::Exporter::Util::like },
  
  A user may import from your module like this:
  
    use Your::Iterator -like => qr/^i/; # imports igre, imap, islurp
  
  or
  
    use Your::Iterator -like => [ qr/^i/ => { -prefix => 'your_' } ];
  
  The group-like prefix and suffix arguments are respected; other arguments are
  passed on to the generators for matching exports.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2007 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_EXPORTER_UTIL

$fatpacked{"Sub/Install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_INSTALL';
  use strict;
  use warnings;
  package Sub::Install;
  # ABSTRACT: install subroutines into packages easily
  $Sub::Install::VERSION = '0.928';
  use Carp;
  use Scalar::Util ();
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   use Sub::Install;
  #pod
  #pod   Sub::Install::install_sub({
  #pod     code => sub { ... },
  #pod     into => $package,
  #pod     as   => $subname
  #pod   });
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This module makes it easy to install subroutines into packages without the
  #pod unsightly mess of C<no strict> or typeglobs lying about where just anyone can
  #pod see them.
  #pod
  #pod =func install_sub
  #pod
  #pod   Sub::Install::install_sub({
  #pod    code => \&subroutine,
  #pod    into => "Finance::Shady",
  #pod    as   => 'launder',
  #pod   });
  #pod
  #pod This routine installs a given code reference into a package as a normal
  #pod subroutine.  The above is equivalent to:
  #pod
  #pod   no strict 'refs';
  #pod   *{"Finance::Shady" . '::' . "launder"} = \&subroutine;
  #pod
  #pod If C<into> is not given, the sub is installed into the calling package.
  #pod
  #pod If C<code> is not a code reference, it is looked for as an existing sub in the
  #pod package named in the C<from> parameter.  If C<from> is not given, it will look
  #pod in the calling package.
  #pod
  #pod If C<as> is not given, and if C<code> is a name, C<as> will default to C<code>.
  #pod If C<as> is not given, but if C<code> is a code ref, Sub::Install will try to
  #pod find the name of the given code ref and use that as C<as>.
  #pod
  #pod That means that this code:
  #pod
  #pod   Sub::Install::install_sub({
  #pod     code => 'twitch',
  #pod     from => 'Person::InPain',
  #pod     into => 'Person::Teenager',
  #pod     as   => 'dance',
  #pod   });
  #pod
  #pod is the same as:
  #pod
  #pod   package Person::Teenager;
  #pod
  #pod   Sub::Install::install_sub({
  #pod     code => Person::InPain->can('twitch'),
  #pod     as   => 'dance',
  #pod   });
  #pod
  #pod =func reinstall_sub
  #pod
  #pod This routine behaves exactly like C<L</install_sub>>, but does not emit a
  #pod warning if warnings are on and the destination is already defined.
  #pod
  #pod =cut
  
  sub _name_of_code {
    my ($code) = @_;
    require B;
    my $name = B::svref_2object($code)->GV->NAME;
    return $name unless $name =~ /\A__ANON__/;
    return;
  }
  
  # See also Params::Util, to which this code was donated.
  sub _CODELIKE {
    (Scalar::Util::reftype($_[0])||'') eq 'CODE'
    || Scalar::Util::blessed($_[0])
    && (overload::Method($_[0],'&{}') ? $_[0] : undef);
  }
  
  # do the heavy lifting
  sub _build_public_installer {
    my ($installer) = @_;
  
    sub {
      my ($arg) = @_;
      my ($calling_pkg) = caller(0);
  
      # I'd rather use ||= but I'm whoring for Devel::Cover.
      for (qw(into from)) { $arg->{$_} = $calling_pkg unless $arg->{$_} }
  
      # This is the only absolutely required argument, in many cases.
      Carp::croak "named argument 'code' is not optional" unless $arg->{code};
  
      if (_CODELIKE($arg->{code})) {
        $arg->{as} ||= _name_of_code($arg->{code});
      } else {
        Carp::croak
          "couldn't find subroutine named $arg->{code} in package $arg->{from}"
          unless my $code = $arg->{from}->can($arg->{code});
  
        $arg->{as}   = $arg->{code} unless $arg->{as};
        $arg->{code} = $code;
      }
  
      Carp::croak "couldn't determine name under which to install subroutine"
        unless $arg->{as};
  
      $installer->(@$arg{qw(into as code) });
    }
  }
  
  # do the ugly work
  
  my $_misc_warn_re;
  my $_redef_warn_re;
  BEGIN {
    $_misc_warn_re = qr/
      Prototype\ mismatch:\ sub\ .+?  |
      Constant subroutine .+? redefined
    /x;
    $_redef_warn_re = qr/Subroutine\ .+?\ redefined/x;
  }
  
  my $eow_re;
  BEGIN { $eow_re = qr/ at .+? line \d+\.\Z/ };
  
  sub _do_with_warn {
    my ($arg) = @_;
    my $code = delete $arg->{code};
    my $wants_code = sub {
      my $code = shift;
      sub {
        my $warn = $SIG{__WARN__} ? $SIG{__WARN__} : sub { warn @_ }; ## no critic
        local $SIG{__WARN__} = sub {
          my ($error) = @_;
          for (@{ $arg->{suppress} }) {
              return if $error =~ $_;
          }
          for (@{ $arg->{croak} }) {
            if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
              Carp::croak $base_error;
            }
          }
          for (@{ $arg->{carp} }) {
            if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
              return $warn->(Carp::shortmess $base_error);
            }
          }
          ($arg->{default} || $warn)->($error);
        };
        $code->(@_);
      };
    };
    return $wants_code->($code) if $code;
    return $wants_code;
  }
  
  sub _installer {
    sub {
      my ($pkg, $name, $code) = @_;
      no strict 'refs'; ## no critic ProhibitNoStrict
      *{"$pkg\::$name"} = $code;
      return $code;
    }
  }
  
  BEGIN {
    *_ignore_warnings = _do_with_warn({
      carp => [ $_misc_warn_re, $_redef_warn_re ]
    });
  
    *install_sub = _build_public_installer(_ignore_warnings(_installer));
  
    *_carp_warnings =  _do_with_warn({
      carp     => [ $_misc_warn_re ],
      suppress => [ $_redef_warn_re ],
    });
  
    *reinstall_sub = _build_public_installer(_carp_warnings(_installer));
  
    *_install_fatal = _do_with_warn({
      code     => _installer,
      croak    => [ $_redef_warn_re ],
    });
  }
  
  #pod =func install_installers
  #pod
  #pod This routine is provided to allow Sub::Install compatibility with
  #pod Sub::Installer.  It installs C<install_sub> and C<reinstall_sub> methods into
  #pod the package named by its argument.
  #pod
  #pod  Sub::Install::install_installers('Code::Builder'); # just for us, please
  #pod  Code::Builder->install_sub({ name => $code_ref });
  #pod
  #pod  Sub::Install::install_installers('UNIVERSAL'); # feeling lucky, punk?
  #pod  Anything::At::All->install_sub({ name => $code_ref });
  #pod
  #pod The installed installers are similar, but not identical, to those provided by
  #pod Sub::Installer.  They accept a single hash as an argument.  The key/value pairs
  #pod are used as the C<as> and C<code> parameters to the C<install_sub> routine
  #pod detailed above.  The package name on which the method is called is used as the
  #pod C<into> parameter.
  #pod
  #pod Unlike Sub::Installer's C<install_sub> will not eval strings into code, but
  #pod will look for named code in the calling package.
  #pod
  #pod =cut
  
  sub install_installers {
    my ($into) = @_;
  
    for my $method (qw(install_sub reinstall_sub)) {
      my $code = sub {
        my ($package, $subs) = @_;
        my ($caller) = caller(0);
        my $return;
        for (my ($name, $sub) = %$subs) {
          $return = Sub::Install->can($method)->({
            code => $sub,
            from => $caller,
            into => $package,
            as   => $name
          });
        }
        return $return;
      };
      install_sub({ code => $code, into => $into, as => $method });
    }
  }
  
  #pod =head1 EXPORTS
  #pod
  #pod Sub::Install exports C<install_sub> and C<reinstall_sub> only if they are
  #pod requested.
  #pod
  #pod =head2 exporter
  #pod
  #pod Sub::Install has a never-exported subroutine called C<exporter>, which is used
  #pod to implement its C<import> routine.  It takes a hashref of named arguments,
  #pod only one of which is currently recognize: C<exports>.  This must be an arrayref
  #pod of subroutines to offer for export.
  #pod
  #pod This routine is mainly for Sub::Install's own consumption.  Instead, consider
  #pod L<Sub::Exporter>.
  #pod
  #pod =cut
  
  sub exporter {
    my ($arg) = @_;
  
    my %is_exported = map { $_ => undef } @{ $arg->{exports} };
  
    sub {
      my $class = shift;
      my $target = caller;
      for (@_) {
        Carp::croak "'$_' is not exported by $class" if !exists $is_exported{$_};
        install_sub({ code => $_, from => $class, into => $target });
      }
    }
  }
  
  BEGIN { *import = exporter({ exports => [ qw(install_sub reinstall_sub) ] }); }
  
  #pod =head1 SEE ALSO
  #pod
  #pod =over
  #pod
  #pod =item L<Sub::Installer>
  #pod
  #pod This module is (obviously) a reaction to Damian Conway's Sub::Installer, which
  #pod does the same thing, but does it by getting its greasy fingers all over
  #pod UNIVERSAL.  I was really happy about the idea of making the installation of
  #pod coderefs less ugly, but I couldn't bring myself to replace the ugliness of
  #pod typeglobs and loosened strictures with the ugliness of UNIVERSAL methods.
  #pod
  #pod =item L<Sub::Exporter>
  #pod
  #pod This is a complete Exporter.pm replacement, built atop Sub::Install.
  #pod
  #pod =back
  #pod
  #pod =head1 EXTRA CREDITS
  #pod
  #pod Several of the tests are adapted from tests that shipped with Damian Conway's
  #pod Sub-Installer distribution.
  #pod
  #pod =cut
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Sub::Install - install subroutines into packages easily
  
  =head1 VERSION
  
  version 0.928
  
  =head1 SYNOPSIS
  
    use Sub::Install;
  
    Sub::Install::install_sub({
      code => sub { ... },
      into => $package,
      as   => $subname
    });
  
  =head1 DESCRIPTION
  
  This module makes it easy to install subroutines into packages without the
  unsightly mess of C<no strict> or typeglobs lying about where just anyone can
  see them.
  
  =head1 FUNCTIONS
  
  =head2 install_sub
  
    Sub::Install::install_sub({
     code => \&subroutine,
     into => "Finance::Shady",
     as   => 'launder',
    });
  
  This routine installs a given code reference into a package as a normal
  subroutine.  The above is equivalent to:
  
    no strict 'refs';
    *{"Finance::Shady" . '::' . "launder"} = \&subroutine;
  
  If C<into> is not given, the sub is installed into the calling package.
  
  If C<code> is not a code reference, it is looked for as an existing sub in the
  package named in the C<from> parameter.  If C<from> is not given, it will look
  in the calling package.
  
  If C<as> is not given, and if C<code> is a name, C<as> will default to C<code>.
  If C<as> is not given, but if C<code> is a code ref, Sub::Install will try to
  find the name of the given code ref and use that as C<as>.
  
  That means that this code:
  
    Sub::Install::install_sub({
      code => 'twitch',
      from => 'Person::InPain',
      into => 'Person::Teenager',
      as   => 'dance',
    });
  
  is the same as:
  
    package Person::Teenager;
  
    Sub::Install::install_sub({
      code => Person::InPain->can('twitch'),
      as   => 'dance',
    });
  
  =head2 reinstall_sub
  
  This routine behaves exactly like C<L</install_sub>>, but does not emit a
  warning if warnings are on and the destination is already defined.
  
  =head2 install_installers
  
  This routine is provided to allow Sub::Install compatibility with
  Sub::Installer.  It installs C<install_sub> and C<reinstall_sub> methods into
  the package named by its argument.
  
   Sub::Install::install_installers('Code::Builder'); # just for us, please
   Code::Builder->install_sub({ name => $code_ref });
  
   Sub::Install::install_installers('UNIVERSAL'); # feeling lucky, punk?
   Anything::At::All->install_sub({ name => $code_ref });
  
  The installed installers are similar, but not identical, to those provided by
  Sub::Installer.  They accept a single hash as an argument.  The key/value pairs
  are used as the C<as> and C<code> parameters to the C<install_sub> routine
  detailed above.  The package name on which the method is called is used as the
  C<into> parameter.
  
  Unlike Sub::Installer's C<install_sub> will not eval strings into code, but
  will look for named code in the calling package.
  
  =head1 EXPORTS
  
  Sub::Install exports C<install_sub> and C<reinstall_sub> only if they are
  requested.
  
  =head2 exporter
  
  Sub::Install has a never-exported subroutine called C<exporter>, which is used
  to implement its C<import> routine.  It takes a hashref of named arguments,
  only one of which is currently recognize: C<exports>.  This must be an arrayref
  of subroutines to offer for export.
  
  This routine is mainly for Sub::Install's own consumption.  Instead, consider
  L<Sub::Exporter>.
  
  =head1 SEE ALSO
  
  =over
  
  =item L<Sub::Installer>
  
  This module is (obviously) a reaction to Damian Conway's Sub::Installer, which
  does the same thing, but does it by getting its greasy fingers all over
  UNIVERSAL.  I was really happy about the idea of making the installation of
  coderefs less ugly, but I couldn't bring myself to replace the ugliness of
  typeglobs and loosened strictures with the ugliness of UNIVERSAL methods.
  
  =item L<Sub::Exporter>
  
  This is a complete Exporter.pm replacement, built atop Sub::Install.
  
  =back
  
  =head1 EXTRA CREDITS
  
  Several of the tests are adapted from tests that shipped with Damian Conway's
  Sub-Installer distribution.
  
  =head1 AUTHOR
  
  Ricardo SIGNES <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2005 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_INSTALL

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny; # git description: v0.29-2-g3b23a06
  use 5.006;
  # ABSTRACT: Minimal try/catch with proper preservation of $@
  
  our $VERSION = '0.30';
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT = our @EXPORT_OK = qw(try catch finally);
  
  use Carp;
  $Carp::Internal{+__PACKAGE__}++;
  
  BEGIN {
    my $su = $INC{'Sub/Util.pm'} && defined &Sub::Util::set_subname;
    my $sn = $INC{'Sub/Name.pm'} && eval { Sub::Name->VERSION(0.08) };
    unless ($su || $sn) {
      $su = eval { require Sub::Util; } && defined &Sub::Util::set_subname;
      unless ($su) {
        $sn = eval { require Sub::Name; Sub::Name->VERSION(0.08) };
      }
    }
  
    *_subname = $su ? \&Sub::Util::set_subname
              : $sn ? \&Sub::Name::subname
              : sub { $_[1] };
    *_HAS_SUBNAME = ($su || $sn) ? sub(){1} : sub(){0};
  }
  
  my %_finally_guards;
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
    my ( $try, @code_refs ) = @_;
  
    # we need to save this here, the eval block will be in scalar context due
    # to $failed
    my $wantarray = wantarray;
  
    # work around perl bug by explicitly initializing these, due to the likelyhood
    # this will be used in global destruction (perl rt#119311)
    my ( $catch, @finally ) = ();
  
    # find labeled blocks in the argument list.
    # catch and finally tag the blocks by blessing a scalar reference to them.
    foreach my $code_ref (@code_refs) {
  
      if ( ref($code_ref) eq 'Try::Tiny::Catch' ) {
        croak 'A try() may not be followed by multiple catch() blocks'
          if $catch;
        $catch = ${$code_ref};
      } elsif ( ref($code_ref) eq 'Try::Tiny::Finally' ) {
        push @finally, ${$code_ref};
      } else {
        croak(
          'try() encountered an unexpected argument ('
        . ( defined $code_ref ? $code_ref : 'undef' )
        . ') - perhaps a missing semi-colon before or'
        );
      }
    }
  
    # FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
    # not perfect, but we could provide a list of additional errors for
    # $catch->();
  
    # name the blocks if we have Sub::Name installed
    _subname(caller().'::try {...} ' => $try)
      if _HAS_SUBNAME;
  
    # set up scope guards to invoke the finally blocks at the end.
    # this should really be a function scope lexical variable instead of
    # file scope + local but that causes issues with perls < 5.20 due to
    # perl rt#119311
    local $_finally_guards{guards} = [
      map { Try::Tiny::ScopeGuard->_new($_) }
      @finally
    ];
  
    # save the value of $@ so we can set $@ back to it in the beginning of the eval
    # and restore $@ after the eval finishes
    my $prev_error = $@;
  
    my ( @ret, $error );
  
    # failed will be true if the eval dies, because 1 will not be returned
    # from the eval body
    my $failed = not eval {
      $@ = $prev_error;
  
      # evaluate the try block in the correct context
      if ( $wantarray ) {
        @ret = $try->();
      } elsif ( defined $wantarray ) {
        $ret[0] = $try->();
      } else {
        $try->();
      };
  
      return 1; # properly set $failed to false
    };
  
    # preserve the current error and reset the original value of $@
    $error = $@;
    $@ = $prev_error;
  
    # at this point $failed contains a true value if the eval died, even if some
    # destructor overwrote $@ as the eval was unwinding.
    if ( $failed ) {
      # pass $error to the finally blocks
      push @$_, $error for @{$_finally_guards{guards}};
  
      # if we got an error, invoke the catch block.
      if ( $catch ) {
        # This works like given($error), but is backwards compatible and
        # sets $_ in the dynamic scope for the body of C<$catch>
        for ($error) {
          return $catch->($error);
        }
  
        # in case when() was used without an explicit return, the C<for>
        # loop will be aborted and there's no useful return value
      }
  
      return;
    } else {
      # no failure, $@ is back to what it was, everything is fine
      return $wantarray ? @ret : $ret[0];
    }
  }
  
  sub catch (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare catch()' unless wantarray;
  
    _subname(caller().'::catch {...} ' => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Catch'),
      @rest,
    );
  }
  
  sub finally (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare finally()' unless wantarray;
  
    _subname(caller().'::finally {...} ' => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Finally'),
      @rest,
    );
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    use constant UNSTABLE_DOLLARAT => ("$]" < '5.013002') ? 1 : 0;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my ($code, @args) = @{ $_[0] };
  
      local $@ if UNSTABLE_DOLLARAT;
      eval {
        $code->(@args);
        1;
      } or do {
        warn
          "Execution of finally() block $code resulted in an exception, which "
        . '*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. '
        . 'Your program will continue as if this event never took place. '
        . "Original exception text follows:\n\n"
        . (defined $@ ? $@ : '$@ left undefined...')
        . "\n"
        ;
      }
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Try::Tiny - Minimal try/catch with proper preservation of $@
  
  =head1 VERSION
  
  version 0.30
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
    # handle errors with a catch handler
    try {
      die "foo";
    } catch {
      warn "caught error: $_"; # not $@
    };
  
  You can also use it like a standalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
    # just silence errors
    try {
      die "foo";
    };
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the C<try> block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L</BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the C<try> block dies, it returns the value of the last statement executed in
  the C<catch> block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following examples all
  assign C<"bar"> to C<$x>:
  
    my $x = try { die "foo" } catch { "bar" };
    my $x = try { die "foo" } || "bar";
    my $x = (try { die "foo" }) // "bar";
  
    my $x = eval { die "foo" } || "bar";
  
  You can add C<finally> blocks, yielding the following:
  
    my $x;
    try { die 'foo' } finally { $x = 'bar' };
    try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  C<finally> blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many C<finally> blocks to a
  given C<try> block as you like.
  
  Note that adding a C<finally> block without a preceding C<catch> block
  suppresses any errors. This behaviour is consistent with using a standalone
  C<eval>, but it is not consistent with C<try>/C<finally> patterns found in
  other programming languages, such as Java, Python, Javascript or C#. If you
  learnt the C<try>/C<finally> pattern from one of these languages, watch out for
  this.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory C<try> subroutine, an optional C<catch> subroutine and C<finally>
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the C<finally> block, if given, will execute.
  
  =item catch (&;@)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
    catch { ... }
  
  Inside the C<catch> block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
    local $@ = $_;
  
  =item finally (&;@)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. C<finally> blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the C<finally> block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the C<finally> block does not
  localize C<$_> with the error, since unlike in a C<catch> block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the C<finally> block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  Furthermore B<exceptions in C<finally> blocks are not trappable and are unable
  to influence the execution of your program>. This is due to limitation of
  C<DESTROY>-based scope guards, which C<finally> is implemented on top of. This
  may change in a future version of Try::Tiny.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an C<eval> block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically,
  L<before Perl version 5.14.0|perl5140delta/"Exception Handling">
  C<$@> was clobbered at the beginning of the C<eval>, which
  also made it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (the one
  available before entering the C<try> block) in the beginning of the C<eval>
  block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an C<eval> block, C<die> behaves sort of like:
  
    sub die {
      $@ = $_[0];
      return_undef_from_eval();
    }
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
    my $error = do {
      local $@;
      eval { ... };
      $@;
    };
  
    ...
    die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
    if ( $@ ) {
      ...
    }
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode (fixed in L<Perl 5.14.0|perl5140delta/"Exception Handling">) is:
  
    sub Object::DESTROY {
      eval { ... }
    }
  
    eval {
      my $obj = Object->new;
  
      die "foo";
    };
  
    if ( $@ ) {
  
    }
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the C<eval> was aborted due to an error:
  
    my $failed = not eval {
      ...
  
      return 1;
    };
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 ALTERNATE SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements"> (but please don't,
  because that syntax has since been deprecated because there was too much
  unexpected magical behaviour).
  
  =for stopwords topicalizer
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
    try {
      require Foo;
    } catch {
      when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
      default { die $_ }
    };
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  argument list. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
    sub foo {
      my ( $self, @args ) = @_;
      try { $self->bar(@args) }
    }
  
  or
  
    sub bar_in_place {
      my $self = shift;
      my $args = \@_;
      try { $_ = $self->bar($_) for @$args }
    }
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
      try {
        die;
      }
      catch {
        return;
      };
  
      say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
      my $success = try {
        die;
        1;
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
    # OR
    sub parent_sub_with_catch {
      my $success = try {
        die;
        1;
      }
      catch {
        # do something with $_
        return undef; #see note
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
  
  Note that if you have a C<catch> block, it must return C<undef> for this to work,
  since if a C<catch> block exists, its return value is returned in place of C<undef>
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =for stopwords unhygienically
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygienically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
    my $obj = try {
      MightFail->new;
    } catch {
      ...
  
      return; # avoid returning a true value;
    };
  
    return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
    given ($foo) {
      when (...) {
        try {
          ...
        } catch {
          warn $_; # will print $foo, not the error
          warn $_[0]; # instead, get the error like this
        }
      }
    }
  
  Note that this behavior was changed once again in
  L<Perl5 version 18|https://metacpan.org/module/perldelta#given-now-aliases-the-global-_>.
  However, since the entirety of lexical C<$_> is now L<considered experimental
  |https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental>, it
  is unclear whether the new version 18 behavior is final.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul>
  
  Or read the source:
  
  L<http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Try-Tiny>
  (or L<bug-Try-Tiny@rt.cpan.org|mailto:bug-Try-Tiny@rt.cpan.org>).
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Karen Etheridge Peter Rabbitson Ricardo Signes Mark Fowler Graham Knop Lukas Mai Aristotle Pagaltzis Dagfinn Ilmari Mannsåker Paul Howarth Rudolf Leermakers anaxagoras awalker chromatic Alex cm-perl Andrew Yates David Lowe Glenn Hans Dieter Pearcey Jens Berthold Jonathan Yu Marc Mims Stosberg Pali
  
  =over 4
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Mark Fowler <mark@twoshortplanks.com>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Lukas Mai <l.mai@web.de>
  
  =item *
  
  Aristotle Pagaltzis <pagaltzis@gmx.de>
  
  =item *
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =item *
  
  Paul Howarth <paul@city-fan.org>
  
  =item *
  
  Rudolf Leermakers <rudolf@hatsuseno.org>
  
  =item *
  
  anaxagoras <walkeraj@gmail.com>
  
  =item *
  
  awalker <awalker@sourcefire.com>
  
  =item *
  
  chromatic <chromatic@wgz.org>
  
  =item *
  
  Alex <alex@koban.(none)>
  
  =item *
  
  cm-perl <cm-perl@users.noreply.github.com>
  
  =item *
  
  Andrew Yates <ayates@haddock.local>
  
  =item *
  
  David Lowe <davidl@lokku.com>
  
  =item *
  
  Glenn Fowler <cebjyre@cpan.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Jens Berthold <jens@jebecs.de>
  
  =item *
  
  Jonathan Yu <JAWNSY@cpan.org>
  
  =item *
  
  Marc Mims <marc@questright.com>
  
  =item *
  
  Mark Stosberg <mark@stosberg.com>
  
  =item *
  
  Pali <pali@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is Copyright (c) 2009 by יובל קוג'מן (Yuval Kogman).
  
  This is free software, licensed under:
  
    The MIT (X11) License
  
  =cut
TRY_TINY

$fatpacked{"darwin-2level/Class/MOP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_MOP';
  package Class::MOP;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use 5.008003;
  
  use MRO::Compat;
  use Class::Load 0.07 ();
  use Scalar::Util  'weaken', 'isweak', 'blessed';
  use Data::OptList;
  
  use Class::MOP::Mixin::AttributeCore;
  use Class::MOP::Mixin::HasAttributes;
  use Class::MOP::Mixin::HasMethods;
  use Class::MOP::Mixin::HasOverloads;
  use Class::MOP::Class;
  use Class::MOP::Attribute;
  use Class::MOP::Method;
  
  BEGIN {
      *IS_RUNNING_ON_5_10 = ("$]" < 5.009_005)
          ? sub () { 0 }
          : sub () { 1 };
  
      # this is either part of core or set up appropriately by MRO::Compat
      *check_package_cache_flag = \&mro::get_pkg_gen;
  }
  
  XSLoader::load(
      'Moose',
      $VERSION,
  );
  
  {
      # Metaclasses are singletons, so we cache them here.
      # there is no need to worry about destruction though
      # because they should die only when the program dies.
      # After all, do package definitions even get reaped?
      # Anonymous classes manage their own destruction.
      my %METAS;
  
      sub get_all_metaclasses         {        %METAS         }
      sub get_all_metaclass_instances { values %METAS         }
      sub get_all_metaclass_names     { keys   %METAS         }
      sub get_metaclass_by_name       { $METAS{$_[0]}         }
      sub store_metaclass_by_name     { $METAS{$_[0]} = $_[1] }
      sub weaken_metaclass            { weaken($METAS{$_[0]}) }
      sub metaclass_is_weak           { isweak($METAS{$_[0]}) }
      sub does_metaclass_exist        { exists $METAS{$_[0]} && defined $METAS{$_[0]} }
      sub remove_metaclass_by_name    { delete $METAS{$_[0]}; return }
  
      # This handles instances as well as class names
      sub class_of {
          return unless defined $_[0];
          my $class = blessed($_[0]) || $_[0];
          return $METAS{$class};
      }
  
      # NOTE:
      # We only cache metaclasses, meaning instances of
      # Class::MOP::Class. We do not cache instance of
      # Class::MOP::Package or Class::MOP::Module. Mostly
      # because I don't yet see a good reason to do so.
  }
  
  sub load_class {
      Class::MOP::Deprecated::deprecated(
          message => 'Class::MOP::load_class is deprecated',
          feature => 'Class::Load wrapper functions',
      );
      require Class::Load;
      goto &Class::Load::load_class;
  }
  
  sub load_first_existing_class {
      Class::MOP::Deprecated::deprecated(
          message => 'Class::MOP::load_first_existing_class is deprecated',
          feature => 'Class::Load wrapper functions',
      );
      require Class::Load;
      goto &Class::Load::load_first_existing_class;
  }
  
  sub is_class_loaded {
      Class::MOP::Deprecated::deprecated(
          message => 'Class::MOP::is_class_loaded is deprecated',
          feature => 'Class::Load wrapper functions',
      );
      require Class::Load;
      goto &Class::Load::is_class_loaded;
  }
  
  sub _definition_context {
      my %context;
      @context{qw(package file line)} = caller(0);
  
      return (
          definition_context => \%context,
      );
  }
  
  ## ----------------------------------------------------------------------------
  ## Setting up our environment ...
  ## ----------------------------------------------------------------------------
  ## Class::MOP needs to have a few things in the global perl environment so
  ## that it can operate effectively. Those things are done here.
  ## ----------------------------------------------------------------------------
  
  # ... nothing yet actually ;)
  
  ## ----------------------------------------------------------------------------
  ## Bootstrapping
  ## ----------------------------------------------------------------------------
  ## The code below here is to bootstrap our MOP with itself. This is also
  ## sometimes called "tying the knot". By doing this, we make it much easier
  ## to extend the MOP through subclassing and such since now you can use the
  ## MOP itself to extend itself.
  ##
  ## Yes, I know, that's weird and insane, but it's a good thing, trust me :)
  ## ----------------------------------------------------------------------------
  
  # We need to add in the meta-attributes here so that
  # any subclass of Class::MOP::* will be able to
  # inherit them using _construct_instance
  
  ## --------------------------------------------------------
  ## Class::MOP::Mixin::HasMethods
  
  Class::MOP::Mixin::HasMethods->meta->add_attribute(
      Class::MOP::Attribute->new('_methods' => (
          reader   => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              '_method_map' => \&Class::MOP::Mixin::HasMethods::_method_map
          },
          default => sub { {} },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::HasMethods->meta->add_attribute(
      Class::MOP::Attribute->new('method_metaclass' => (
          reader   => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'method_metaclass' => \&Class::MOP::Mixin::HasMethods::method_metaclass
          },
          default  => 'Class::MOP::Method',
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::HasMethods->meta->add_attribute(
      Class::MOP::Attribute->new('wrapped_method_metaclass' => (
          reader   => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'wrapped_method_metaclass' => \&Class::MOP::Mixin::HasMethods::wrapped_method_metaclass
          },
          default  => 'Class::MOP::Method::Wrapped',
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Mixin::HasAttributes
  
  Class::MOP::Mixin::HasAttributes->meta->add_attribute(
      Class::MOP::Attribute->new('attributes' => (
          reader   => {
              # NOTE: we need to do this in order
              # for the instance meta-object to
              # not fall into meta-circular death
              #
              # we just alias the original method
              # rather than re-produce it here
              '_attribute_map' => \&Class::MOP::Mixin::HasAttributes::_attribute_map
          },
          default  => sub { {} },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::HasAttributes->meta->add_attribute(
      Class::MOP::Attribute->new('attribute_metaclass' => (
          reader   => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'attribute_metaclass' => \&Class::MOP::Mixin::HasAttributes::attribute_metaclass
          },
          default  => 'Class::MOP::Attribute',
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Mixin::HasOverloads
  
  Class::MOP::Mixin::HasOverloads->meta->add_attribute(
      Class::MOP::Attribute->new('_overload_map' => (
          reader   => {
              '_overload_map' => \&Class::MOP::Mixin::HasOverloads::_overload_map
          },
          clearer => '_clear_overload_map',
          default => sub { {} },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Package
  
  Class::MOP::Package->meta->add_attribute(
      Class::MOP::Attribute->new('package' => (
          reader   => {
              # NOTE: we need to do this in order
              # for the instance meta-object to
              # not fall into meta-circular death
              #
              # we just alias the original method
              # rather than re-produce it here
              'name' => \&Class::MOP::Package::name
          },
          _definition_context(),
      ))
  );
  
  Class::MOP::Package->meta->add_attribute(
      Class::MOP::Attribute->new('namespace' => (
          reader => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'namespace' => \&Class::MOP::Package::namespace
          },
          init_arg => undef,
          default  => sub { \undef },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Module
  
  # NOTE:
  # yeah this is kind of stretching things a bit,
  # but truthfully the version should be an attribute
  # of the Module, the weirdness comes from having to
  # stick to Perl 5 convention and store it in the
  # $VERSION package variable. Basically if you just
  # squint at it, it will look how you want it to look.
  # Either as a package variable, or as a attribute of
  # the metaclass, isn't abstraction great :)
  
  Class::MOP::Module->meta->add_attribute(
      Class::MOP::Attribute->new('version' => (
          reader => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'version' => \&Class::MOP::Module::version
          },
          init_arg => undef,
          default  => sub { \undef },
          _definition_context(),
      ))
  );
  
  # NOTE:
  # By following the same conventions as version here,
  # we are opening up the possibility that people can
  # use the $AUTHORITY in non-Class::MOP modules as
  # well.
  
  Class::MOP::Module->meta->add_attribute(
      Class::MOP::Attribute->new('authority' => (
          reader => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'authority' => \&Class::MOP::Module::authority
          },
          init_arg => undef,
          default  => sub { \undef },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Class
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('superclasses' => (
          accessor => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'superclasses' => \&Class::MOP::Class::superclasses
          },
          init_arg => undef,
          default  => sub { \undef },
          _definition_context(),
      ))
  );
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('instance_metaclass' => (
          reader   => {
              # NOTE: we need to do this in order
              # for the instance meta-object to
              # not fall into meta-circular death
              #
              # we just alias the original method
              # rather than re-produce it here
              'instance_metaclass' => \&Class::MOP::Class::instance_metaclass
          },
          default  => 'Class::MOP::Instance',
          _definition_context(),
      ))
  );
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('immutable_trait' => (
          reader   => {
              'immutable_trait' => \&Class::MOP::Class::immutable_trait
          },
          default => "Class::MOP::Class::Immutable::Trait",
          _definition_context(),
      ))
  );
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('constructor_name' => (
          reader   => {
              'constructor_name' => \&Class::MOP::Class::constructor_name,
          },
          default => "new",
          _definition_context(),
      ))
  );
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('constructor_class' => (
          reader   => {
              'constructor_class' => \&Class::MOP::Class::constructor_class,
          },
          default => "Class::MOP::Method::Constructor",
          _definition_context(),
      ))
  );
  
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('destructor_class' => (
          reader   => {
              'destructor_class' => \&Class::MOP::Class::destructor_class,
          },
          _definition_context(),
      ))
  );
  
  # NOTE:
  # we don't actually need to tie the knot with
  # Class::MOP::Class here, it is actually handled
  # within Class::MOP::Class itself in the
  # _construct_class_instance method.
  
  ## --------------------------------------------------------
  ## Class::MOP::Mixin::AttributeCore
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('name' => (
          reader   => {
              # NOTE: we need to do this in order
              # for the instance meta-object to
              # not fall into meta-circular death
              #
              # we just alias the original method
              # rather than re-produce it here
              'name' => \&Class::MOP::Mixin::AttributeCore::name
          },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('accessor' => (
          reader    => { 'accessor'     => \&Class::MOP::Mixin::AttributeCore::accessor     },
          predicate => { 'has_accessor' => \&Class::MOP::Mixin::AttributeCore::has_accessor },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('reader' => (
          reader    => { 'reader'     => \&Class::MOP::Mixin::AttributeCore::reader     },
          predicate => { 'has_reader' => \&Class::MOP::Mixin::AttributeCore::has_reader },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('initializer' => (
          reader    => { 'initializer'     => \&Class::MOP::Mixin::AttributeCore::initializer     },
          predicate => { 'has_initializer' => \&Class::MOP::Mixin::AttributeCore::has_initializer },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('definition_context' => (
          reader    => { 'definition_context'     => \&Class::MOP::Mixin::AttributeCore::definition_context     },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('writer' => (
          reader    => { 'writer'     => \&Class::MOP::Mixin::AttributeCore::writer     },
          predicate => { 'has_writer' => \&Class::MOP::Mixin::AttributeCore::has_writer },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('predicate' => (
          reader    => { 'predicate'     => \&Class::MOP::Mixin::AttributeCore::predicate     },
          predicate => { 'has_predicate' => \&Class::MOP::Mixin::AttributeCore::has_predicate },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('clearer' => (
          reader    => { 'clearer'     => \&Class::MOP::Mixin::AttributeCore::clearer     },
          predicate => { 'has_clearer' => \&Class::MOP::Mixin::AttributeCore::has_clearer },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('builder' => (
          reader    => { 'builder'     => \&Class::MOP::Mixin::AttributeCore::builder     },
          predicate => { 'has_builder' => \&Class::MOP::Mixin::AttributeCore::has_builder },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('init_arg' => (
          reader    => { 'init_arg'     => \&Class::MOP::Mixin::AttributeCore::init_arg     },
          predicate => { 'has_init_arg' => \&Class::MOP::Mixin::AttributeCore::has_init_arg },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('default' => (
          # default has a custom 'reader' method ...
          predicate => { 'has_default' => \&Class::MOP::Mixin::AttributeCore::has_default },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('insertion_order' => (
          reader      => { 'insertion_order' => \&Class::MOP::Mixin::AttributeCore::insertion_order },
          writer      => { '_set_insertion_order' => \&Class::MOP::Mixin::AttributeCore::_set_insertion_order },
          predicate   => { 'has_insertion_order' => \&Class::MOP::Mixin::AttributeCore::has_insertion_order },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Attribute
  Class::MOP::Attribute->meta->add_attribute(
      Class::MOP::Attribute->new('associated_class' => (
          reader   => {
              # NOTE: we need to do this in order
              # for the instance meta-object to
              # not fall into meta-circular death
              #
              # we just alias the original method
              # rather than re-produce it here
              'associated_class' => \&Class::MOP::Attribute::associated_class
          },
          _definition_context(),
      ))
  );
  
  Class::MOP::Attribute->meta->add_attribute(
      Class::MOP::Attribute->new('associated_methods' => (
          reader   => { 'associated_methods' => \&Class::MOP::Attribute::associated_methods },
          default  => sub { [] },
          _definition_context(),
      ))
  );
  
  Class::MOP::Attribute->meta->add_method('clone' => sub {
      my $self  = shift;
      $self->meta->clone_object($self, @_);
  });
  
  ## --------------------------------------------------------
  ## Class::MOP::Method
  Class::MOP::Method->meta->add_attribute(
      Class::MOP::Attribute->new('body' => (
          reader   => { 'body' => \&Class::MOP::Method::body },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method->meta->add_attribute(
      Class::MOP::Attribute->new('associated_metaclass' => (
          reader   => { 'associated_metaclass' => \&Class::MOP::Method::associated_metaclass },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method->meta->add_attribute(
      Class::MOP::Attribute->new('package_name' => (
          reader   => { 'package_name' => \&Class::MOP::Method::package_name },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method->meta->add_attribute(
      Class::MOP::Attribute->new('name' => (
          reader   => { 'name' => \&Class::MOP::Method::name },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method->meta->add_attribute(
      Class::MOP::Attribute->new('original_method' => (
          reader   => { 'original_method'      => \&Class::MOP::Method::original_method },
          writer   => { '_set_original_method' => \&Class::MOP::Method::_set_original_method },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Method::Wrapped
  
  # NOTE:
  # the way this item is initialized, this
  # really does not follow the standard
  # practices of attributes, but we put
  # it here for completeness
  Class::MOP::Method::Wrapped->meta->add_attribute(
      Class::MOP::Attribute->new('modifier_table' => (
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Method::Generated
  
  Class::MOP::Method::Generated->meta->add_attribute(
      Class::MOP::Attribute->new('is_inline' => (
          reader   => { 'is_inline' => \&Class::MOP::Method::Generated::is_inline },
          default  => 0,
          _definition_context(),
      ))
  );
  
  Class::MOP::Method::Generated->meta->add_attribute(
      Class::MOP::Attribute->new('definition_context' => (
          reader   => { 'definition_context' => \&Class::MOP::Method::Generated::definition_context },
          _definition_context(),
      ))
  );
  
  
  ## --------------------------------------------------------
  ## Class::MOP::Method::Inlined
  
  Class::MOP::Method::Inlined->meta->add_attribute(
      Class::MOP::Attribute->new('_expected_method_class' => (
          reader   => { '_expected_method_class' => \&Class::MOP::Method::Inlined::_expected_method_class },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Method::Accessor
  
  Class::MOP::Method::Accessor->meta->add_attribute(
      Class::MOP::Attribute->new('attribute' => (
          reader   => {
              'associated_attribute' => \&Class::MOP::Method::Accessor::associated_attribute
          },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method::Accessor->meta->add_attribute(
      Class::MOP::Attribute->new('accessor_type' => (
          reader   => { 'accessor_type' => \&Class::MOP::Method::Accessor::accessor_type },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Method::Constructor
  
  Class::MOP::Method::Constructor->meta->add_attribute(
      Class::MOP::Attribute->new('options' => (
          reader   => {
              'options' => \&Class::MOP::Method::Constructor::options
          },
          default  => sub { +{} },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method::Constructor->meta->add_attribute(
      Class::MOP::Attribute->new('associated_metaclass' => (
          init_arg => "metaclass", # FIXME alias and rename
          reader   => {
              'associated_metaclass' => \&Class::MOP::Method::Constructor::associated_metaclass
          },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Overload
  
  Class::MOP::Overload->meta->add_attribute(
      Class::MOP::Attribute->new(
          'operator' => (
              reader   => { 'operator' => \&Class::MOP::Overload::operator },
              required => 1,
              _definition_context(),
          )
      )
  );
  
  for my $attr (qw( method_name coderef coderef_package coderef_name method )) {
      Class::MOP::Overload->meta->add_attribute(
          Class::MOP::Attribute->new(
              $attr => (
                  reader    => { $attr => Class::MOP::Overload->can($attr) },
                  predicate => {
                      'has_'
                          . $attr => Class::MOP::Overload->can( 'has_' . $attr )
                  },
                  _definition_context(),
              )
          )
      );
  }
  
  Class::MOP::Overload->meta->add_attribute(
      Class::MOP::Attribute->new(
          'associated_metaclass' => (
              reader => {
                  'associated_metaclass' =>
                      \&Class::MOP::Overload::associated_metaclass
              },
              _definition_context(),
          )
      )
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Instance
  
  # NOTE:
  # these don't yet do much of anything, but are just
  # included for completeness
  
  Class::MOP::Instance->meta->add_attribute(
      Class::MOP::Attribute->new('associated_metaclass',
          reader   => { associated_metaclass => \&Class::MOP::Instance::associated_metaclass },
          _definition_context(),
      ),
  );
  
  Class::MOP::Instance->meta->add_attribute(
      Class::MOP::Attribute->new('_class_name',
          init_arg => undef,
          reader   => { _class_name => \&Class::MOP::Instance::_class_name },
          #lazy     => 1, # not yet supported by Class::MOP but out our version does it anyway
          #default  => sub { $_[0]->associated_metaclass->name },
          _definition_context(),
      ),
  );
  
  Class::MOP::Instance->meta->add_attribute(
      Class::MOP::Attribute->new('attributes',
          reader   => { attributes => \&Class::MOP::Instance::get_all_attributes },
          _definition_context(),
      ),
  );
  
  Class::MOP::Instance->meta->add_attribute(
      Class::MOP::Attribute->new('slots',
          reader   => { slots => \&Class::MOP::Instance::slots },
          _definition_context(),
      ),
  );
  
  Class::MOP::Instance->meta->add_attribute(
      Class::MOP::Attribute->new('slot_hash',
          reader   => { slot_hash => \&Class::MOP::Instance::slot_hash },
          _definition_context(),
      ),
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Object
  
  # need to replace the meta method there with a real meta method object
  Class::MOP::Object->meta->_add_meta_method('meta');
  
  ## --------------------------------------------------------
  ## Class::MOP::Mixin
  
  # need to replace the meta method there with a real meta method object
  Class::MOP::Mixin->meta->_add_meta_method('meta');
  
  require Class::MOP::Deprecated unless our $no_deprecated;
  
  # we need the meta instance of the meta instance to be created now, in order
  # for the constructor to be able to use it
  Class::MOP::Instance->meta->get_meta_instance;
  
  # pretend the add_method never happened. it hasn't yet affected anything
  undef Class::MOP::Instance->meta->{_package_cache_flag};
  
  ## --------------------------------------------------------
  ## Now close all the Class::MOP::* classes
  
  # NOTE: we don't need to inline the accessors this only lengthens the compile
  # time of the MOP, and gives us no actual benefits.
  
  $_->meta->make_immutable(
      inline_constructor  => 0,
      constructor_name    => "_new",
      inline_accessors => 0,
  ) for qw/
      Class::MOP::Package
      Class::MOP::Module
      Class::MOP::Class
  
      Class::MOP::Attribute
      Class::MOP::Method
      Class::MOP::Instance
  
      Class::MOP::Object
  
      Class::MOP::Method::Generated
      Class::MOP::Method::Inlined
  
      Class::MOP::Method::Accessor
      Class::MOP::Method::Constructor
      Class::MOP::Method::Wrapped
  
      Class::MOP::Method::Meta
  
      Class::MOP::Overload
  /;
  
  $_->meta->make_immutable(
      inline_constructor  => 0,
      constructor_name    => undef,
      inline_accessors => 0,
  ) for qw/
      Class::MOP::Mixin
      Class::MOP::Mixin::AttributeCore
      Class::MOP::Mixin::HasAttributes
      Class::MOP::Mixin::HasMethods
      Class::MOP::Mixin::HasOverloads
  /;
  
  1;
  
  # ABSTRACT: A Meta Object Protocol for Perl 5
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP - A Meta Object Protocol for Perl 5
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This module is a fully functioning meta object protocol for the
  Perl 5 object system. It makes no attempt to change the behavior or
  characteristics of the Perl 5 object system, only to create a
  protocol for its manipulation and introspection.
  
  That said, it does attempt to create the tools for building a rich set
  of extensions to the Perl 5 object system. Every attempt has been made
  to abide by the spirit of the Perl 5 object system that we all know
  and love.
  
  This documentation is sparse on conceptual details. We suggest looking
  at the items listed in the L<SEE ALSO> section for more
  information. In particular the book "The Art of the Meta Object
  Protocol" was very influential in the development of this system.
  
  =head2 What is a Meta Object Protocol?
  
  A meta object protocol is an API to an object system.
  
  To be more specific, it abstracts the components of an object system
  (classes, object, methods, object attributes, etc.). These
  abstractions can then be used to inspect and manipulate the object
  system which they describe.
  
  It can be said that there are two MOPs for any object system; the
  implicit MOP and the explicit MOP. The implicit MOP handles things
  like method dispatch or inheritance, which happen automatically as
  part of how the object system works. The explicit MOP typically
  handles the introspection/reflection features of the object system.
  
  All object systems have implicit MOPs. Without one, they would not
  work. Explicit MOPs are much less common, and depending on the
  language can vary from restrictive (Reflection in Java or C#) to wide
  open (CLOS is a perfect example).
  
  =head2 Yet Another Class Builder! Why?
  
  This is B<not> a class builder so much as a I<class builder
  B<builder>>. The intent is that an end user will not use this module
  directly, but instead this module is used by module authors to build
  extensions and features onto the Perl 5 object system.
  
  This system is used by L<Moose>, which supplies a powerful class
  builder system built entirely on top of C<Class::MOP>.
  
  =head2 Who is this module for?
  
  This module is for anyone who has ever created or wanted to create a
  module for the Class:: namespace. The tools which this module provides
  make doing complex Perl 5 wizardry simpler, by removing such barriers
  as the need to hack symbol tables, or understand the fine details of
  method dispatch.
  
  =head2 What changes do I have to make to use this module?
  
  This module was designed to be as unobtrusive as possible. Many of its
  features are accessible without B<any> change to your existing
  code. It is meant to be a complement to your existing code and not an
  intrusion on your code base. Unlike many other B<Class::> modules,
  this module B<does not> require you subclass it, or even that you
  C<use> it in within your module's package.
  
  The only features which require additions to your code are the
  attribute handling and instance construction features, and these are
  both completely optional features. The only reason for this is because
  Perl 5's object system does not actually have these features built
  in. More information about this feature can be found below.
  
  =head2 About Performance
  
  It is a common misconception that explicit MOPs are a performance hit.
  This is not a universal truth, it is a side-effect of some specific
  implementations. For instance, using Java reflection is slow because
  the JVM cannot take advantage of any compiler optimizations, and the
  JVM has to deal with much more runtime type information as well.
  
  Reflection in C# is marginally better as it was designed into the
  language and runtime (the CLR). In contrast, CLOS (the Common Lisp
  Object System) was built to support an explicit MOP, and so
  performance is tuned for it.
  
  This library in particular does its absolute best to avoid putting
  B<any> drain at all upon your code's performance. In fact, by itself
  it does nothing to affect your existing code. So you only pay for what
  you actually use.
  
  =head2 About Metaclass compatibility
  
  This module makes sure that all metaclasses created are both upwards
  and downwards compatible. The topic of metaclass compatibility is
  highly esoteric and is something only encountered when doing deep and
  involved metaclass hacking. There are two basic kinds of metaclass
  incompatibility; upwards and downwards.
  
  Upwards metaclass compatibility means that the metaclass of a
  given class is either the same as (or a subclass of) all of the
  metaclasses of the class's ancestors.
  
  Downward metaclass compatibility means that the metaclasses of a
  given class's ancestors are all the same as (or a subclass of) that
  class's metaclass.
  
  Here is a diagram showing a set of two classes (C<A> and C<B>) and
  two metaclasses (C<Meta::A> and C<Meta::B>) which have correct
  metaclass compatibility both upwards and downwards.
  
      +---------+     +---------+
      | Meta::A |<----| Meta::B |      <....... (instance of  )
      +---------+     +---------+      <------- (inherits from)
           ^               ^
           :               :
      +---------+     +---------+
      |    A    |<----|    B    |
      +---------+     +---------+
  
  In actuality, I<all> of a class's metaclasses must be compatible,
  not just the class metaclass. That includes the instance, attribute,
  and method metaclasses, as well as the constructor and destructor
  classes.
  
  C<Class::MOP> will attempt to fix some simple types of
  incompatibilities. If all the metaclasses for the parent class are
  I<subclasses> of the child's metaclasses then we can simply replace
  the child's metaclasses with the parent's. In addition, if the child
  is missing a metaclass that the parent has, we can also just make the
  child use the parent's metaclass.
  
  As I said this is a highly esoteric topic and one you will only run
  into if you do a lot of subclassing of L<Class::MOP::Class>. If you
  are interested in why this is an issue see the paper I<Uniform and
  safe metaclass composition> linked to in the L<SEE ALSO> section of
  this document.
  
  =head2 Using custom metaclasses
  
  Always use the L<metaclass> pragma when using a custom metaclass, this
  will ensure the proper initialization order and not accidentally
  create an incorrect type of metaclass for you. This is a very rare
  problem, and one which can only occur if you are doing deep metaclass
  programming. So in other words, don't worry about it.
  
  Note that if you're using L<Moose> we encourage you to I<not> use the
  L<metaclass> pragma, and instead use L<Moose::Util::MetaRole> to apply
  roles to a class's metaclasses. This topic is covered at length in
  various L<Moose::Cookbook> recipes.
  
  =head1 PROTOCOLS
  
  The meta-object protocol is divided into 4 main sub-protocols:
  
  =head2 The Class protocol
  
  This provides a means of manipulating and introspecting a Perl 5
  class. It handles symbol table hacking for you, and provides a rich
  set of methods that go beyond simple package introspection.
  
  See L<Class::MOP::Class> for more details.
  
  =head2 The Attribute protocol
  
  This provides a consistent representation for an attribute of a Perl 5
  class. Since there are so many ways to create and handle attributes in
  Perl 5 OO, the Attribute protocol provide as much of a unified
  approach as possible. Of course, you are always free to extend this
  protocol by subclassing the appropriate classes.
  
  See L<Class::MOP::Attribute> for more details.
  
  =head2 The Method protocol
  
  This provides a means of manipulating and introspecting methods in the
  Perl 5 object system. As with attributes, there are many ways to
  approach this topic, so we try to keep it pretty basic, while still
  making it possible to extend the system in many ways.
  
  See L<Class::MOP::Method> for more details.
  
  =head2 The Instance protocol
  
  This provides a layer of abstraction for creating object instances.
  Since the other layers use this protocol, it is relatively easy to
  change the type of your instances from the default hash reference to
  some other type of reference. Several examples are provided in the
  F<examples/> directory included in this distribution.
  
  See L<Class::MOP::Instance> for more details.
  
  =head1 FUNCTIONS
  
  Note that this module does not export any constants or functions.
  
  =head2 Utility functions
  
  Note that these are all called as B<functions, not methods>.
  
  =head3 Class::MOP::get_code_info($code)
  
  This function returns two values, the name of the package the C<$code>
  is from and the name of the C<$code> itself. This is used by several
  elements of the MOP to determine where a given C<$code> reference is
  from.
  
  =head3 Class::MOP::class_of($instance_or_class_name)
  
  This will return the metaclass of the given instance or class name.  If the
  class lacks a metaclass, no metaclass will be initialized, and C<undef> will be
  returned.
  
  You should almost certainly be using
  L<C<Moose::Util::find_meta>|Moose::Util/find_meta> instead.
  
  =head2 Metaclass cache functions
  
  C<Class::MOP> holds a cache of metaclasses. The following are functions
  (B<not methods>) which can be used to access that cache. It is not
  recommended that you mess with these. Bad things could happen, but if
  you are brave and willing to risk it: go for it!
  
  =head3 Class::MOP::get_all_metaclasses
  
  This will return a hash of all the metaclass instances that have
  been cached by L<Class::MOP::Class>, keyed by the package name.
  
  =head3 Class::MOP::get_all_metaclass_instances
  
  This will return a list of all the metaclass instances that have
  been cached by L<Class::MOP::Class>.
  
  =head3 Class::MOP::get_all_metaclass_names
  
  This will return a list of all the metaclass names that have
  been cached by L<Class::MOP::Class>.
  
  =head3 Class::MOP::get_metaclass_by_name($name)
  
  This will return a cached L<Class::MOP::Class> instance, or nothing
  if no metaclass exists with that C<$name>.
  
  =head3 Class::MOP::store_metaclass_by_name($name, $meta)
  
  This will store a metaclass in the cache at the supplied C<$key>.
  
  =head3 Class::MOP::weaken_metaclass($name)
  
  In rare cases (e.g. anonymous metaclasses) it is desirable to
  store a weakened reference in the metaclass cache. This
  function will weaken the reference to the metaclass stored
  in C<$name>.
  
  =head3 Class::MOP::metaclass_is_weak($name)
  
  Returns true if the metaclass for C<$name> has been weakened
  (via C<weaken_metaclass>).
  
  =head3 Class::MOP::does_metaclass_exist($name)
  
  This will return true of there exists a metaclass stored in the
  C<$name> key, and return false otherwise.
  
  =head3 Class::MOP::remove_metaclass_by_name($name)
  
  This will remove the metaclass stored in the C<$name> key.
  
  Some utility functions (such as C<Class::MOP::load_class>) that were
  previously defined in C<Class::MOP> regarding loading of classes have been
  extracted to L<Class::Load>. Please see L<Class::Load> for documentation.
  
  =head1 SEE ALSO
  
  =head2 Books
  
  There are very few books out on Meta Object Protocols and Metaclasses
  because it is such an esoteric topic. The following books are really
  the only ones I have found. If you know of any more, B<I<please>>
  email me and let me know, I would love to hear about them.
  
  =over 4
  
  =item I<The Art of the Meta Object Protocol>
  
  =item I<Advances in Object-Oriented Metalevel Architecture and Reflection>
  
  =item I<Putting MetaClasses to Work>
  
  =item I<Smalltalk: The Language>
  
  =back
  
  =head2 Papers
  
  =over 4
  
  =item "Uniform and safe metaclass composition"
  
  An excellent paper by the people who brought us the original Traits paper.
  This paper is on how Traits can be used to do safe metaclass composition,
  and offers an excellent introduction section which delves into the topic of
  metaclass compatibility.
  
  L<http://scg.unibe.ch/archive/papers/Duca05ySafeMetaclassTrait.pdf>
  
  =item "Safe Metaclass Programming"
  
  This paper seems to precede the above paper, and propose a mix-in based
  approach as opposed to the Traits based approach. Both papers have similar
  information on the metaclass compatibility problem space.
  
  L<http://citeseer.ist.psu.edu/37617.html>
  
  =back
  
  =head2 Prior Art
  
  =over 4
  
  =item The Perl 6 MetaModel work in the Pugs project
  
  =over 4
  
  =item L<http://github.com/perl6/p5-modules/tree/master/Perl6-ObjectSpace/>
  
  =back
  
  =back
  
  =head2 Articles
  
  =over 4
  
  =item CPAN Module Review of Class::MOP
  
  L<http://www.oreillynet.com/onlamp/blog/2006/06/cpan_module_review_classmop.html>
  
  =back
  
  =head1 SIMILAR MODULES
  
  As I have said above, this module is a class-builder-builder, so it is
  not the same thing as modules like L<Class::Accessor> and
  L<Class::MethodMaker>. That being said there are very few modules on CPAN
  with similar goals to this module. The one I have found which is most
  like this module is L<Class::Meta>, although its philosophy and the MOP it
  creates are very different from this modules.
  
  =head1 BUGS
  
  All complex software has bugs lurking in it, and this module is no
  exception.
  
  Please report any bugs to C<bug-class-mop@rt.cpan.org>, or through the
  web interface at L<http://rt.cpan.org>.
  
  You can also discuss feature requests or possible bugs on the Moose
  mailing list (moose@perl.org) or on IRC at
  L<irc://irc.perl.org/#moose>.
  
  =head1 ACKNOWLEDGEMENTS
  
  =over 4
  
  =item Rob Kinyon
  
  Thanks to Rob for actually getting the development of this module kick-started.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_CLASS_MOP

$fatpacked{"darwin-2level/Class/MOP/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_MOP_ATTRIBUTE';
  package Class::MOP::Attribute;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Class::MOP::Method::Accessor;
  
  use Carp         'confess';
  use Scalar::Util 'blessed', 'weaken';
  use Try::Tiny;
  
  use parent 'Class::MOP::Object', 'Class::MOP::Mixin::AttributeCore';
  
  # NOTE: (meta-circularity)
  # This method will be replaced in the
  # boostrap section of Class::MOP, by
  # a new version which uses the
  # &Class::MOP::Class::construct_instance
  # method to build an attribute meta-object
  # which itself is described with attribute
  # meta-objects.
  #     - Ain't meta-circularity grand? :)
  sub new {
      my ( $class, @args ) = @_;
  
      unshift @args, "name" if @args % 2 == 1;
      my %options = @args;
  
      my $name = $options{name};
  
      (defined $name)
          || $class->_throw_exception( MOPAttributeNewNeedsAttributeName => class  => $class,
                                                                   params => \%options
                            );
  
      $options{init_arg} = $name
          if not exists $options{init_arg};
      if(exists $options{builder}){
          $class->_throw_exception( BuilderMustBeAMethodName => class  => $class,
                                                       params => \%options
                         )
              if ref $options{builder} || !(defined $options{builder});
          $class->_throw_exception( BothBuilderAndDefaultAreNotAllowed => class  => $class,
                                                                 params => \%options
                         )
              if exists $options{default};
      } else {
          ($class->is_default_a_coderef(\%options))
              || $class->_throw_exception( ReferencesAreNotAllowedAsDefault => class          => $class,
                                                                      params         => \%options,
                                                                      attribute_name => $options{name}
                                )
                  if exists $options{default} && ref $options{default};
      }
  
      if( $options{required} and not( defined($options{builder}) || defined($options{init_arg}) || exists $options{default} ) ) {
          $class->_throw_exception( RequiredAttributeLacksInitialization => class  => $class,
                                                                   params => \%options
                         );
      }
  
      $class->_new(\%options);
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $options = @_ == 1 ? $_[0] : {@_};
  
      bless {
          'name'               => $options->{name},
          'accessor'           => $options->{accessor},
          'reader'             => $options->{reader},
          'writer'             => $options->{writer},
          'predicate'          => $options->{predicate},
          'clearer'            => $options->{clearer},
          'builder'            => $options->{builder},
          'init_arg'           => $options->{init_arg},
          exists $options->{default}
              ? ('default'     => $options->{default})
              : (),
          'initializer'        => $options->{initializer},
          'definition_context' => $options->{definition_context},
          # keep a weakened link to the
          # class we are associated with
          'associated_class' => undef,
          # and a list of the methods
          # associated with this attr
          'associated_methods' => [],
          # this let's us keep track of
          # our order inside the associated
          # class
          'insertion_order'    => undef,
      }, $class;
  }
  
  # NOTE:
  # this is a primitive (and kludgy) clone operation
  # for now, it will be replaced in the Class::MOP
  # bootstrap with a proper one, however we know
  # that this one will work fine for now.
  sub clone {
      my $self    = shift;
      my %options = @_;
      (blessed($self))
          || confess "Can only clone an instance";
      # this implementation is overwritten by the bootstrap process,
      # so this exception will never trigger. If it ever does occur,
      # it indicates a gigantic problem with the most internal parts
      # of Moose, so we wouldn't want a Moose-based exception object anyway
  
      return bless { %{$self}, %options } => ref($self);
  }
  
  sub initialize_instance_slot {
      my ($self, $meta_instance, $instance, $params) = @_;
      my $init_arg = $self->{'init_arg'};
  
      # try to fetch the init arg from the %params ...
  
      # if nothing was in the %params, we can use the
      # attribute's default value (if it has one)
      if(defined $init_arg and exists $params->{$init_arg}){
          $self->_set_initial_slot_value(
              $meta_instance,
              $instance,
              $params->{$init_arg},
          );
      }
      elsif (exists $self->{'default'}) {
          $self->_set_initial_slot_value(
              $meta_instance,
              $instance,
              $self->default($instance),
          );
      }
      elsif (defined( my $builder = $self->{'builder'})) {
          if ($builder = $instance->can($builder)) {
              $self->_set_initial_slot_value(
                  $meta_instance,
                  $instance,
                  $instance->$builder,
              );
          }
          else {
              $self->_throw_exception( BuilderMethodNotSupportedForAttribute => attribute => $self,
                                                                        instance  => $instance
                             );
          }
      }
  }
  
  sub _set_initial_slot_value {
      my ($self, $meta_instance, $instance, $value) = @_;
  
      my $slot_name = $self->name;
  
      return $meta_instance->set_slot_value($instance, $slot_name, $value)
          unless $self->has_initializer;
  
      my $callback = $self->_make_initializer_writer_callback(
          $meta_instance, $instance, $slot_name
      );
  
      my $initializer = $self->initializer;
  
      # most things will just want to set a value, so make it first arg
      $instance->$initializer($value, $callback, $self);
  }
  
  sub _make_initializer_writer_callback {
      my $self = shift;
      my ($meta_instance, $instance, $slot_name) = @_;
  
      return sub {
          $meta_instance->set_slot_value($instance, $slot_name, $_[0]);
      };
  }
  
  sub get_read_method  {
      my $self   = shift;
      my $reader = $self->reader || $self->accessor;
      # normal case ...
      return $reader unless ref $reader;
      # the HASH ref case
      my ($name) = %$reader;
      return $name;
  }
  
  sub get_write_method {
      my $self   = shift;
      my $writer = $self->writer || $self->accessor;
      # normal case ...
      return $writer unless ref $writer;
      # the HASH ref case
      my ($name) = %$writer;
      return $name;
  }
  
  sub get_read_method_ref {
      my $self = shift;
      if ((my $reader = $self->get_read_method) && $self->associated_class) {
          return $self->associated_class->get_method($reader);
      }
      else {
          my $code = sub { $self->get_value(@_) };
          if (my $class = $self->associated_class) {
              return $class->method_metaclass->wrap(
                  $code,
                  package_name => $class->name,
                  name         => '__ANON__'
              );
          }
          else {
              return $code;
          }
      }
  }
  
  sub get_write_method_ref {
      my $self = shift;
      if ((my $writer = $self->get_write_method) && $self->associated_class) {
          return $self->associated_class->get_method($writer);
      }
      else {
          my $code = sub { $self->set_value(@_) };
          if (my $class = $self->associated_class) {
              return $class->method_metaclass->wrap(
                  $code,
                  package_name => $class->name,
                  name         => '__ANON__'
              );
          }
          else {
              return $code;
          }
      }
  }
  
  # slots
  
  sub slots { (shift)->name }
  
  # class association
  
  sub attach_to_class {
      my ($self, $class) = @_;
      (blessed($class) && $class->isa('Class::MOP::Class'))
          || $self->_throw_exception( AttachToClassNeedsAClassMOPClassInstanceOrASubclass => attribute => $self,
                                                                                     class     => $class
                            );
      weaken($self->{'associated_class'} = $class);
  }
  
  sub detach_from_class {
      my $self = shift;
      $self->{'associated_class'} = undef;
  }
  
  # method association
  
  sub associate_method {
      my ($self, $method) = @_;
      push @{$self->{'associated_methods'}} => $method;
  }
  
  ## Slot management
  
  sub set_initial_value {
      my ($self, $instance, $value) = @_;
      $self->_set_initial_slot_value(
          Class::MOP::Class->initialize(ref($instance))->get_meta_instance,
          $instance,
          $value
      );
  }
  
  sub set_value { shift->set_raw_value(@_) }
  
  sub set_raw_value {
      my $self = shift;
      my ($instance, $value) = @_;
  
      my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
      return $mi->set_slot_value($instance, $self->name, $value);
  }
  
  sub _inline_set_value {
      my $self = shift;
      return $self->_inline_instance_set(@_) . ';';
  }
  
  sub _inline_instance_set {
      my $self = shift;
      my ($instance, $value) = @_;
  
      my $mi = $self->associated_class->get_meta_instance;
      return $mi->inline_set_slot_value($instance, $self->name, $value);
  }
  
  sub get_value { shift->get_raw_value(@_) }
  
  sub get_raw_value {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
      return $mi->get_slot_value($instance, $self->name);
  }
  
  sub _inline_get_value {
      my $self = shift;
      return $self->_inline_instance_get(@_) . ';';
  }
  
  sub _inline_instance_get {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = $self->associated_class->get_meta_instance;
      return $mi->inline_get_slot_value($instance, $self->name);
  }
  
  sub has_value {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
      return $mi->is_slot_initialized($instance, $self->name);
  }
  
  sub _inline_has_value {
      my $self = shift;
      return $self->_inline_instance_has(@_) . ';';
  }
  
  sub _inline_instance_has {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = $self->associated_class->get_meta_instance;
      return $mi->inline_is_slot_initialized($instance, $self->name);
  }
  
  sub clear_value {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
      return $mi->deinitialize_slot($instance, $self->name);
  }
  
  sub _inline_clear_value {
      my $self = shift;
      return $self->_inline_instance_clear(@_) . ';';
  }
  
  sub _inline_instance_clear {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = $self->associated_class->get_meta_instance;
      return $mi->inline_deinitialize_slot($instance, $self->name);
  }
  
  ## load em up ...
  
  sub accessor_metaclass { 'Class::MOP::Method::Accessor' }
  
  sub _process_accessors {
      my ($self, $type, $accessor, $generate_as_inline_methods) = @_;
  
      my $method_ctx = { %{ $self->definition_context || {} } };
  
      if (ref($accessor)) {
          (ref($accessor) eq 'HASH')
              || $self->_throw_exception( BadOptionFormat => attribute    => $self,
                                                     option_value => $accessor,
                                                     option_name  => $type
                                );
  
          my ($name, $method) = %{$accessor};
  
          $method_ctx->{description} = $self->_accessor_description($name, $type);
  
          $method = $self->accessor_metaclass->wrap(
              $method,
              attribute    => $self,
              package_name => $self->associated_class->name,
              name         => $name,
              associated_metaclass => $self->associated_class,
              definition_context => $method_ctx,
          );
          $self->associate_method($method);
          return ($name, $method);
      }
      else {
          my $inline_me = ($generate_as_inline_methods && $self->associated_class->instance_metaclass->is_inlinable);
          my $method;
          try {
              $method_ctx->{description} = $self->_accessor_description($accessor, $type);
  
              $method = $self->accessor_metaclass->new(
                  attribute     => $self,
                  is_inline     => $inline_me,
                  accessor_type => $type,
                  package_name  => $self->associated_class->name,
                  name          => $accessor,
                  associated_metaclass => $self->associated_class,
                  definition_context => $method_ctx,
              );
          }
          catch {
              $self->_throw_exception( CouldNotCreateMethod => attribute    => $self,
                                                       option_value => $accessor,
                                                       option_name  => $type,
                                                       error        => $_
                             );
          };
          $self->associate_method($method);
          return ($accessor, $method);
      }
  }
  
  sub _accessor_description {
      my $self = shift;
      my ($name, $type) = @_;
  
      my $desc = "$type " . $self->associated_class->name . "::$name";
      if ( $name ne $self->name ) {
          $desc .= " of attribute " . $self->name;
      }
  
      return $desc;
  }
  
  sub install_accessors {
      my $self   = shift;
      my $inline = shift;
      my $class  = $self->associated_class;
  
      $class->add_method(
          $self->_process_accessors('accessor' => $self->accessor(), $inline)
      ) if $self->has_accessor();
  
      $class->add_method(
          $self->_process_accessors('reader' => $self->reader(), $inline)
      ) if $self->has_reader();
  
      $class->add_method(
          $self->_process_accessors('writer' => $self->writer(), $inline)
      ) if $self->has_writer();
  
      $class->add_method(
          $self->_process_accessors('predicate' => $self->predicate(), $inline)
      ) if $self->has_predicate();
  
      $class->add_method(
          $self->_process_accessors('clearer' => $self->clearer(), $inline)
      ) if $self->has_clearer();
  
      return;
  }
  
  {
      my $_remove_accessor = sub {
          my ($accessor, $class) = @_;
          if (ref($accessor) && ref($accessor) eq 'HASH') {
              ($accessor) = keys %{$accessor};
          }
          my $method = $class->get_method($accessor);
          $class->remove_method($accessor)
              if (ref($method) && $method->isa('Class::MOP::Method::Accessor'));
      };
  
      sub remove_accessors {
          my $self = shift;
          # TODO:
          # we really need to make sure to remove from the
          # associates methods here as well. But this is
          # such a slimly used method, I am not worried
          # about it right now.
          $_remove_accessor->($self->accessor(),  $self->associated_class()) if $self->has_accessor();
          $_remove_accessor->($self->reader(),    $self->associated_class()) if $self->has_reader();
          $_remove_accessor->($self->writer(),    $self->associated_class()) if $self->has_writer();
          $_remove_accessor->($self->predicate(), $self->associated_class()) if $self->has_predicate();
          $_remove_accessor->($self->clearer(),   $self->associated_class()) if $self->has_clearer();
          return;
      }
  
  }
  
  1;
  
  # ABSTRACT: Attribute Meta Object
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Attribute - Attribute Meta Object
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 SYNOPSIS
  
    Class::MOP::Attribute->new(
        foo => (
            accessor  => 'foo',           # dual purpose get/set accessor
            predicate => 'has_foo',       # predicate check for defined-ness
            init_arg  => '-foo',          # class->new will look for a -foo key
            default   => 'BAR IS BAZ!'    # if no -foo key is provided, use this
        )
    );
  
    Class::MOP::Attribute->new(
        bar => (
            reader    => 'bar',           # getter
            writer    => 'set_bar',       # setter
            predicate => 'has_bar',       # predicate check for defined-ness
            init_arg  => ':bar',          # class->new will look for a :bar key
                                          # no default value means it is undef
        )
    );
  
  =head1 DESCRIPTION
  
  The Attribute Protocol is almost entirely an invention of
  C<Class::MOP>. Perl 5 does not have a consistent notion of
  attributes. There are so many ways in which this is done, and very few
  (if any) are easily discoverable by this module.
  
  With that said, this module attempts to inject some order into this
  chaos, by introducing a consistent API which can be used to create
  object attributes.
  
  =head1 METHODS
  
  =head2 Creation
  
  =over 4
  
  =item B<< Class::MOP::Attribute->new($name, ?%options) >>
  
  An attribute must (at the very least), have a C<$name>. All other
  C<%options> are added as key-value pairs.
  
  =over 8
  
  =item * init_arg
  
  This is a string value representing the expected key in an
  initialization hash. For instance, if we have an C<init_arg> value of
  C<-foo>, then the following code will Just Work.
  
    MyClass->meta->new_object( -foo => 'Hello There' );
  
  If an init_arg is not assigned, it will automatically use the
  attribute's name. If C<init_arg> is explicitly set to C<undef>, the
  attribute cannot be specified during initialization.
  
  =item * builder
  
  This provides the name of a method that will be called to initialize
  the attribute. This method will be called on the object after it is
  constructed. It is expected to return a valid value for the attribute.
  
  =item * default
  
  This can be used to provide an explicit default for initializing the
  attribute. If the default you provide is a subroutine reference, then
  this reference will be called I<as a method> on the object.
  
  If the value is a simple scalar (string or number), then it can be
  just passed as is. However, if you wish to initialize it with a HASH
  or ARRAY ref, then you need to wrap that inside a subroutine
  reference:
  
    Class::MOP::Attribute->new(
        'foo' => (
            default => sub { [] },
        )
    );
  
    # or ...
  
    Class::MOP::Attribute->new(
        'foo' => (
            default => sub { {} },
        )
    );
  
  If you wish to initialize an attribute with a subroutine reference
  itself, then you need to wrap that in a subroutine as well:
  
    Class::MOP::Attribute->new(
        'foo' => (
            default => sub {
                sub { print "Hello World" }
            },
        )
    );
  
  And lastly, if the value of your attribute is dependent upon some
  other aspect of the instance structure, then you can take advantage of
  the fact that when the C<default> value is called as a method:
  
    Class::MOP::Attribute->new(
        'object_identity' => (
            default => sub { Scalar::Util::refaddr( $_[0] ) },
        )
    );
  
  Note that there is no guarantee that attributes are initialized in any
  particular order, so you cannot rely on the value of some other
  attribute when generating the default.
  
  =item * initializer
  
  This option can be either a method name or a subroutine
  reference. This method will be called when setting the attribute's
  value in the constructor. Unlike C<default> and C<builder>, the
  initializer is only called when a value is provided to the
  constructor. The initializer allows you to munge this value during
  object construction.
  
  The initializer is called as a method with three arguments. The first
  is the value that was passed to the constructor. The second is a
  subroutine reference that can be called to actually set the
  attribute's value, and the last is the associated
  C<Class::MOP::Attribute> object.
  
  This contrived example shows an initializer that sets the attribute to
  twice the given value.
  
    Class::MOP::Attribute->new(
        'doubled' => (
            initializer => sub {
                my ( $self, $value, $set, $attr ) = @_;
                $set->( $value * 2 );
            },
        )
    );
  
  Since an initializer can be a method name, you can easily make
  attribute initialization use the writer:
  
    Class::MOP::Attribute->new(
        'some_attr' => (
            writer      => 'some_attr',
            initializer => 'some_attr',
        )
    );
  
  Your writer (actually, a wrapper around the writer, using
  L<method modifications|Moose::Manual::MethodModifiers>) will need to examine
  C<@_> and determine under which
  context it is being called:
  
    around 'some_attr' => sub {
        my $orig = shift;
        my $self = shift;
        # $value is not defined if being called as a reader
        # $setter and $attr are only defined if being called as an initializer
        my ($value, $setter, $attr) = @_;
  
        # the reader behaves normally
        return $self->$orig if not @_;
  
        # mutate $value as desired
        # $value = <something($value);
  
        # if called as an initializer, set the value and we're done
        return $setter->($row) if $setter;
  
        # otherwise, call the real writer with the new value
        $self->$orig($row);
    };
  
  =back
  
  The C<accessor>, C<reader>, C<writer>, C<predicate> and C<clearer>
  options all accept the same parameters. You can provide the name of
  the method, in which case an appropriate default method will be
  generated for you. Or instead you can also provide hash reference
  containing exactly one key (the method name) and one value. The value
  should be a subroutine reference, which will be installed as the
  method itself.
  
  =over 8
  
  =item * accessor
  
  An C<accessor> is a standard Perl-style read/write accessor. It will
  return the value of the attribute, and if a value is passed as an
  argument, it will assign that value to the attribute.
  
  Note that C<undef> is a legitimate value, so this will work:
  
    $object->set_something(undef);
  
  =item * reader
  
  This is a basic read-only accessor. It returns the value of the
  attribute.
  
  =item * writer
  
  This is a basic write accessor, it accepts a single argument, and
  assigns that value to the attribute.
  
  Note that C<undef> is a legitimate value, so this will work:
  
    $object->set_something(undef);
  
  =item * predicate
  
  The predicate method returns a boolean indicating whether or not the
  attribute has been explicitly set.
  
  Note that the predicate returns true even if the attribute was set to
  a false value (C<0> or C<undef>).
  
  =item * clearer
  
  This method will uninitialize the attribute. After an attribute is
  cleared, its C<predicate> will return false.
  
  =item * definition_context
  
  Mostly, this exists as a hook for the benefit of Moose.
  
  This option should be a hash reference containing several keys which
  will be used when inlining the attribute's accessors. The keys should
  include C<line>, the line number where the attribute was created, and
  either C<file> or C<description>.
  
  This information will ultimately be used when eval'ing inlined
  accessor code so that error messages report a useful line and file
  name.
  
  =back
  
  =item B<< $attr->clone(%options) >>
  
  This clones the attribute. Any options you provide will override the
  settings of the original attribute. You can change the name of the new
  attribute by passing a C<name> key in C<%options>.
  
  =back
  
  =head2 Informational
  
  These are all basic read-only accessors for the values passed into
  the constructor.
  
  =over 4
  
  =item B<< $attr->name >>
  
  Returns the attribute's name.
  
  =item B<< $attr->accessor >>
  
  =item B<< $attr->reader >>
  
  =item B<< $attr->writer >>
  
  =item B<< $attr->predicate >>
  
  =item B<< $attr->clearer >>
  
  The C<accessor>, C<reader>, C<writer>, C<predicate>, and C<clearer>
  methods all return exactly what was passed to the constructor, so it
  can be either a string containing a method name, or a hash reference.
  
  =item B<< $attr->initializer >>
  
  Returns the initializer as passed to the constructor, so this may be
  either a method name or a subroutine reference.
  
  =item B<< $attr->init_arg >>
  
  =item B<< $attr->is_default_a_coderef >>
  
  =item B<< $attr->builder >>
  
  =item B<< $attr->default($instance) >>
  
  The C<$instance> argument is optional. If you don't pass it, the
  return value for this method is exactly what was passed to the
  constructor, either a simple scalar or a subroutine reference.
  
  If you I<do> pass an C<$instance> and the default is a subroutine
  reference, then the reference is called as a method on the
  C<$instance> and the generated value is returned.
  
  =item B<< $attr->slots >>
  
  Return a list of slots required by the attribute. This is usually just
  one, the name of the attribute.
  
  A slot is the name of the hash key used to store the attribute in an
  object instance.
  
  =item B<< $attr->get_read_method >>
  
  =item B<< $attr->get_write_method >>
  
  Returns the name of a method suitable for reading or writing the value
  of the attribute in the associated class.
  
  If an attribute is read- or write-only, then these methods can return
  C<undef> as appropriate.
  
  =item B<< $attr->has_read_method >>
  
  =item B<< $attr->has_write_method >>
  
  This returns a boolean indicating whether the attribute has a I<named>
  read or write method.
  
  =item B<< $attr->get_read_method_ref >>
  
  =item B<< $attr->get_write_method_ref >>
  
  Returns the subroutine reference of a method suitable for reading or
  writing the attribute's value in the associated class. These methods
  always return a subroutine reference, regardless of whether or not the
  attribute is read- or write-only.
  
  =item B<< $attr->insertion_order >>
  
  If this attribute has been inserted into a class, this returns a zero
  based index regarding the order of insertion.
  
  =back
  
  =head2 Informational predicates
  
  These are all basic predicate methods for the values passed into C<new>.
  
  =over 4
  
  =item B<< $attr->has_accessor >>
  
  =item B<< $attr->has_reader >>
  
  =item B<< $attr->has_writer >>
  
  =item B<< $attr->has_predicate >>
  
  =item B<< $attr->has_clearer >>
  
  =item B<< $attr->has_initializer >>
  
  =item B<< $attr->has_init_arg >>
  
  This will be I<false> if the C<init_arg> was set to C<undef>.
  
  =item B<< $attr->has_default >>
  
  This will be I<false> if the C<default> was set to C<undef>, since
  C<undef> is the default C<default> anyway.
  
  =item B<< $attr->has_builder >>
  
  =item B<< $attr->has_insertion_order >>
  
  This will be I<false> if this attribute has not be inserted into a class
  
  =back
  
  =head2 Value management
  
  These methods are basically "back doors" to the instance, and can be
  used to bypass the regular accessors, but still stay within the MOP.
  
  These methods are not for general use, and should only be used if you
  really know what you are doing.
  
  =over 4
  
  =item B<< $attr->initialize_instance_slot($meta_instance, $instance, $params) >>
  
  This method is used internally to initialize the attribute's slot in
  the object C<$instance>.
  
  The C<$params> is a hash reference of the values passed to the object
  constructor.
  
  It's unlikely that you'll need to call this method yourself.
  
  =item B<< $attr->set_value($instance, $value) >>
  
  Sets the value without going through the accessor. Note that this
  works even with read-only attributes.
  
  =item B<< $attr->set_raw_value($instance, $value) >>
  
  Sets the value with no side effects such as a trigger.
  
  This doesn't actually apply to Class::MOP attributes, only to subclasses.
  
  =item B<< $attr->set_initial_value($instance, $value) >>
  
  Sets the value without going through the accessor. This method is only
  called when the instance is first being initialized.
  
  =item B<< $attr->get_value($instance) >>
  
  Returns the value without going through the accessor. Note that this
  works even with write-only accessors.
  
  =item B<< $attr->get_raw_value($instance) >>
  
  Returns the value without any side effects such as lazy attributes.
  
  Doesn't actually apply to Class::MOP attributes, only to subclasses.
  
  =item B<< $attr->has_value($instance) >>
  
  Return a boolean indicating whether the attribute has been set in
  C<$instance>. This how the default C<predicate> method works.
  
  =item B<< $attr->clear_value($instance) >>
  
  This will clear the attribute's value in C<$instance>. This is what
  the default C<clearer> calls.
  
  Note that this works even if the attribute does not have any
  associated read, write or clear methods.
  
  =back
  
  =head2 Class association
  
  These methods allow you to manage the attributes association with
  the class that contains it. These methods should not be used
  lightly, nor are they very magical, they are mostly used internally
  and by metaclass instances.
  
  =over 4
  
  =item B<< $attr->associated_class >>
  
  This returns the L<Class::MOP::Class> with which this attribute is
  associated, if any.
  
  =item B<< $attr->attach_to_class($metaclass) >>
  
  This method stores a weakened reference to the C<$metaclass> object
  internally.
  
  This method does not remove the attribute from its old class,
  nor does it create any accessors in the new class.
  
  It is probably best to use the L<Class::MOP::Class> C<add_attribute>
  method instead.
  
  =item B<< $attr->detach_from_class >>
  
  This method removes the associate metaclass object from the attribute
  it has one.
  
  This method does not remove the attribute itself from the class, or
  remove its accessors.
  
  It is probably best to use the L<Class::MOP::Class>
  C<remove_attribute> method instead.
  
  =back
  
  =head2 Attribute Accessor generation
  
  =over 4
  
  =item B<< $attr->accessor_metaclass >>
  
  Accessor methods are generated using an accessor metaclass. By
  default, this is L<Class::MOP::Method::Accessor>. This method returns
  the name of the accessor metaclass that this attribute uses.
  
  =item B<< $attr->associate_method($method) >>
  
  This associates a L<Class::MOP::Method> object with the
  attribute. Typically, this is called internally when an attribute
  generates its accessors.
  
  =item B<< $attr->associated_methods >>
  
  This returns the list of methods which have been associated with the
  attribute.
  
  =item B<< $attr->install_accessors >>
  
  This method generates and installs code the attributes various
  accessors. It is typically called from the L<Class::MOP::Class>
  C<add_attribute> method.
  
  =item B<< $attr->remove_accessors >>
  
  This method removes all of the accessors associated with the
  attribute.
  
  This does not currently remove methods from the list returned by
  C<associated_methods>.
  
  =item B<< $attr->inline_get >>
  
  =item B<< $attr->inline_set >>
  
  =item B<< $attr->inline_has >>
  
  =item B<< $attr->inline_clear >>
  
  These methods return a code snippet suitable for inlining the relevant
  operation. They expect strings containing variable names to be used in the
  inlining, like C<'$self'> or C<'$_[1]'>.
  
  =back
  
  =head2 Introspection
  
  =over 4
  
  =item B<< Class::MOP::Attribute->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  It should also be noted that L<Class::MOP> will actually bootstrap
  this module by installing a number of attribute meta-objects into its
  metaclass.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_CLASS_MOP_ATTRIBUTE

$fatpacked{"darwin-2level/Class/MOP/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_MOP_CLASS';
  package Class::MOP::Class;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Class::MOP::Instance;
  use Class::MOP::Method::Wrapped;
  use Class::MOP::Method::Accessor;
  use Class::MOP::Method::Constructor;
  use Class::MOP::MiniTrait;
  
  use Carp         'confess';
  use Module::Runtime 'use_package_optimistically';
  use Scalar::Util 'blessed';
  use Sub::Name    'subname';
  use Try::Tiny;
  use List::Util 1.33 'all';
  
  use parent 'Class::MOP::Module',
           'Class::MOP::Mixin::HasAttributes',
           'Class::MOP::Mixin::HasMethods',
           'Class::MOP::Mixin::HasOverloads';
  
  # Creation
  
  sub initialize {
      my $class = shift;
  
      my $package_name;
  
      if ( @_ % 2 ) {
          $package_name = shift;
      } else {
          my %options = @_;
          $package_name = $options{package};
      }
  
      ($package_name && !ref($package_name))
          || ($class||__PACKAGE__)->_throw_exception( InitializeTakesUnBlessedPackageName => package_name => $package_name );
      return Class::MOP::get_metaclass_by_name($package_name)
          || $class->_construct_class_instance(package => $package_name, @_);
  }
  
  sub reinitialize {
      my ( $class, @args ) = @_;
      unshift @args, "package" if @args % 2;
      my %options = @args;
      my $old_metaclass = blessed($options{package})
          ? $options{package}
          : Class::MOP::get_metaclass_by_name($options{package});
      $options{weaken} = Class::MOP::metaclass_is_weak($old_metaclass->name)
          if !exists $options{weaken}
          && blessed($old_metaclass)
          && $old_metaclass->isa('Class::MOP::Class');
      $old_metaclass->_remove_generated_metaobjects
          if $old_metaclass && $old_metaclass->isa('Class::MOP::Class');
      my $new_metaclass = $class->SUPER::reinitialize(%options);
      $new_metaclass->_restore_metaobjects_from($old_metaclass)
          if $old_metaclass && $old_metaclass->isa('Class::MOP::Class');
      return $new_metaclass;
  }
  
  # NOTE: (meta-circularity)
  # this is a special form of _construct_instance
  # (see below), which is used to construct class
  # meta-object instances for any Class::MOP::*
  # class. All other classes will use the more
  # normal &construct_instance.
  sub _construct_class_instance {
      my $class        = shift;
      my $options      = @_ == 1 ? $_[0] : {@_};
      my $package_name = $options->{package};
      (defined $package_name && $package_name)
          || $class->_throw_exception("ConstructClassInstanceTakesPackageName");
      # NOTE:
      # return the metaclass if we have it cached,
      # and it is still defined (it has not been
      # reaped by DESTROY yet, which can happen
      # annoyingly enough during global destruction)
  
      if (defined(my $meta = Class::MOP::get_metaclass_by_name($package_name))) {
          return $meta;
      }
  
      $class
          = ref $class
          ? $class->_real_ref_name
          : $class;
  
      # now create the metaclass
      my $meta;
      if ($class eq 'Class::MOP::Class') {
          $meta = $class->_new($options);
      }
      else {
          # NOTE:
          # it is safe to use meta here because
          # class will always be a subclass of
          # Class::MOP::Class, which defines meta
          $meta = $class->meta->_construct_instance($options)
      }
  
      # and check the metaclass compatibility
      $meta->_check_metaclass_compatibility();
  
      Class::MOP::store_metaclass_by_name($package_name, $meta);
  
      # NOTE:
      # we need to weaken any anon classes
      # so that they can call DESTROY properly
      Class::MOP::weaken_metaclass($package_name) if $options->{weaken};
  
      $meta;
  }
  
  sub _real_ref_name {
      my $self = shift;
  
      # NOTE: we need to deal with the possibility of class immutability here,
      # and then get the name of the class appropriately
      return $self->is_immutable
          ? $self->_get_mutable_metaclass_name()
          : ref $self;
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $options = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          # inherited from Class::MOP::Package
          'package' => $options->{package},
  
          # NOTE:
          # since the following attributes will
          # actually be loaded from the symbol
          # table, and actually bypass the instance
          # entirely, we can just leave these things
          # listed here for reference, because they
          # should not actually have a value associated
          # with the slot.
          'namespace' => \undef,
          'methods'   => {},
  
          # inherited from Class::MOP::Module
          'version'   => \undef,
          'authority' => \undef,
  
          # defined in Class::MOP::Class
          'superclasses' => \undef,
  
          'attributes' => {},
          'attribute_metaclass' =>
              ( $options->{'attribute_metaclass'} || 'Class::MOP::Attribute' ),
          'method_metaclass' =>
              ( $options->{'method_metaclass'} || 'Class::MOP::Method' ),
          'wrapped_method_metaclass' => (
              $options->{'wrapped_method_metaclass'}
                  || 'Class::MOP::Method::Wrapped'
          ),
          'instance_metaclass' =>
              ( $options->{'instance_metaclass'} || 'Class::MOP::Instance' ),
          'immutable_trait' => (
              $options->{'immutable_trait'}
                  || 'Class::MOP::Class::Immutable::Trait'
          ),
          'constructor_name' => ( $options->{constructor_name} || 'new' ),
          'constructor_class' => (
              $options->{constructor_class} || 'Class::MOP::Method::Constructor'
          ),
          'destructor_class' => $options->{destructor_class},
      }, $class;
  }
  
  ## Metaclass compatibility
  {
      my %base_metaclass = (
          attribute_metaclass      => 'Class::MOP::Attribute',
          method_metaclass         => 'Class::MOP::Method',
          wrapped_method_metaclass => 'Class::MOP::Method::Wrapped',
          instance_metaclass       => 'Class::MOP::Instance',
          constructor_class        => 'Class::MOP::Method::Constructor',
          destructor_class         => 'Class::MOP::Method::Destructor',
      );
  
      sub _base_metaclasses { %base_metaclass }
  }
  
  sub _check_metaclass_compatibility {
      my $self = shift;
  
      my @superclasses = $self->superclasses
          or return;
  
      $self->_fix_metaclass_incompatibility(@superclasses);
  
      my %base_metaclass = $self->_base_metaclasses;
  
      # this is always okay ...
      return
          if ref($self) eq 'Class::MOP::Class'
              && all {
                  my $meta = $self->$_;
                  !defined($meta) || $meta eq $base_metaclass{$_};
          }
          keys %base_metaclass;
  
      for my $superclass (@superclasses) {
          $self->_check_class_metaclass_compatibility($superclass);
      }
  
      for my $metaclass_type ( keys %base_metaclass ) {
          next unless defined $self->$metaclass_type;
          for my $superclass (@superclasses) {
              $self->_check_single_metaclass_compatibility( $metaclass_type,
                  $superclass );
          }
      }
  }
  
  sub _check_class_metaclass_compatibility {
      my $self = shift;
      my ( $superclass_name ) = @_;
  
      if (!$self->_class_metaclass_is_compatible($superclass_name)) {
          my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name);
  
          my $super_meta_type = $super_meta->_real_ref_name;
  
          $self->_throw_exception( IncompatibleMetaclassOfSuperclass => class_name           => $self->name,
                                                                class_meta_type      => ref( $self ),
                                                                superclass_name      => $superclass_name,
                                                                superclass_meta_type => $super_meta_type
                         );
      }
  }
  
  sub _class_metaclass_is_compatible {
      my $self = shift;
      my ( $superclass_name ) = @_;
  
      my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name)
          || return 1;
  
      my $super_meta_name = $super_meta->_real_ref_name;
  
      return $self->_is_compatible_with($super_meta_name);
  }
  
  sub _check_single_metaclass_compatibility {
      my $self = shift;
      my ( $metaclass_type, $superclass_name ) = @_;
  
      if (!$self->_single_metaclass_is_compatible($metaclass_type, $superclass_name)) {
          my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name);
  
          $self->_throw_exception( MetaclassTypeIncompatible => class_name      => $self->name,
                                                        superclass_name => $superclass_name,
                                                        metaclass_type  => $metaclass_type
                         );
      }
  }
  
  sub _single_metaclass_is_compatible {
      my $self = shift;
      my ( $metaclass_type, $superclass_name ) = @_;
  
      my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name)
          || return 1;
  
      # for instance, Moose::Meta::Class has a error_class attribute, but
      # Class::MOP::Class doesn't - this shouldn't be an error
      return 1 unless $super_meta->can($metaclass_type);
      # for instance, Moose::Meta::Class has a destructor_class, but
      # Class::MOP::Class doesn't - this shouldn't be an error
      return 1 unless defined $super_meta->$metaclass_type;
      # if metaclass is defined in superclass but not here, it's not compatible
      # this is a really odd case
      return 0 unless defined $self->$metaclass_type;
  
      return $self->$metaclass_type->_is_compatible_with($super_meta->$metaclass_type);
  }
  
  sub _fix_metaclass_incompatibility {
      my $self = shift;
      my @supers = map { Class::MOP::Class->initialize($_) } @_;
  
      my $necessary = 0;
      for my $super (@supers) {
          $necessary = 1
              if $self->_can_fix_metaclass_incompatibility($super);
      }
      return unless $necessary;
  
      for my $super (@supers) {
          if (!$self->_class_metaclass_is_compatible($super->name)) {
              $self->_fix_class_metaclass_incompatibility($super);
          }
      }
  
      my %base_metaclass = $self->_base_metaclasses;
      for my $metaclass_type (keys %base_metaclass) {
          for my $super (@supers) {
              if (!$self->_single_metaclass_is_compatible($metaclass_type, $super->name)) {
                  $self->_fix_single_metaclass_incompatibility(
                      $metaclass_type, $super
                  );
              }
          }
      }
  }
  
  sub _can_fix_metaclass_incompatibility {
      my $self = shift;
      my ($super_meta) = @_;
  
      return 1 if $self->_class_metaclass_can_be_made_compatible($super_meta);
  
      my %base_metaclass = $self->_base_metaclasses;
      for my $metaclass_type (keys %base_metaclass) {
          return 1 if $self->_single_metaclass_can_be_made_compatible($super_meta, $metaclass_type);
      }
  
      return;
  }
  
  sub _class_metaclass_can_be_made_compatible {
      my $self = shift;
      my ($super_meta) = @_;
  
      return $self->_can_be_made_compatible_with($super_meta->_real_ref_name);
  }
  
  sub _single_metaclass_can_be_made_compatible {
      my $self = shift;
      my ($super_meta, $metaclass_type) = @_;
  
      my $specific_meta = $self->$metaclass_type;
  
      return unless $super_meta->can($metaclass_type);
      my $super_specific_meta = $super_meta->$metaclass_type;
  
      # for instance, Moose::Meta::Class has a destructor_class, but
      # Class::MOP::Class doesn't - this shouldn't be an error
      return unless defined $super_specific_meta;
  
      # if metaclass is defined in superclass but not here, it's fixable
      # this is a really odd case
      return 1 unless defined $specific_meta;
  
      return 1 if $specific_meta->_can_be_made_compatible_with($super_specific_meta);
  }
  
  sub _fix_class_metaclass_incompatibility {
      my $self = shift;
      my ( $super_meta ) = @_;
  
      if ($self->_class_metaclass_can_be_made_compatible($super_meta)) {
          ($self->is_pristine)
              || $self->_throw_exception( CannotFixMetaclassCompatibility => class_name => $self->name,
                                                                     superclass => $super_meta
                                );
  
          my $super_meta_name = $super_meta->_real_ref_name;
  
          $self->_make_compatible_with($super_meta_name);
      }
  }
  
  sub _fix_single_metaclass_incompatibility {
      my $self = shift;
      my ( $metaclass_type, $super_meta ) = @_;
  
      if ($self->_single_metaclass_can_be_made_compatible($super_meta, $metaclass_type)) {
          ($self->is_pristine)
              || $self->_throw_exception( CannotFixMetaclassCompatibility => class_name     => $self->name,
                                                                     superclass     => $super_meta,
                                                                     metaclass_type => $metaclass_type
                                );
  
          my $new_metaclass = $self->$metaclass_type
              ? $self->$metaclass_type->_get_compatible_metaclass($super_meta->$metaclass_type)
              : $super_meta->$metaclass_type;
          $self->{$metaclass_type} = $new_metaclass;
      }
  }
  
  sub _restore_metaobjects_from {
      my $self = shift;
      my ($old_meta) = @_;
  
      $self->_restore_metamethods_from($old_meta);
      $self->_restore_metaattributes_from($old_meta);
  }
  
  sub _remove_generated_metaobjects {
      my $self = shift;
  
      for my $attr (map { $self->get_attribute($_) } $self->get_attribute_list) {
          $attr->remove_accessors;
      }
  }
  
  # creating classes with MOP ...
  
  sub create {
      my $class = shift;
      my @args = @_;
  
      unshift @args, 'package' if @args % 2 == 1;
      my %options = @args;
  
      (ref $options{superclasses} eq 'ARRAY')
          || __PACKAGE__->_throw_exception( CreateMOPClassTakesArrayRefOfSuperclasses => class  => $class,
                                                                           params => \%options
                            )
              if exists $options{superclasses};
  
      (ref $options{attributes} eq 'ARRAY')
          || __PACKAGE__->_throw_exception( CreateMOPClassTakesArrayRefOfAttributes => class  => $class,
                                                                         params => \%options
                            )
              if exists $options{attributes};
  
      (ref $options{methods} eq 'HASH')
          || __PACKAGE__->_throw_exception( CreateMOPClassTakesHashRefOfMethods => class  => $class,
                                                                     params => \%options
                            )
              if exists $options{methods};
  
      my $package      = delete $options{package};
      my $superclasses = delete $options{superclasses};
      my $attributes   = delete $options{attributes};
      my $methods      = delete $options{methods};
      my $meta_name    = exists $options{meta_name}
                           ? delete $options{meta_name}
                           : 'meta';
  
      my $meta = $class->SUPER::create($package => %options);
  
      $meta->_add_meta_method($meta_name)
          if defined $meta_name;
  
      $meta->superclasses(@{$superclasses})
          if defined $superclasses;
      # NOTE:
      # process attributes first, so that they can
      # install accessors, but locally defined methods
      # can then overwrite them. It is maybe a little odd, but
      # I think this should be the order of things.
      if (defined $attributes) {
          foreach my $attr (@{$attributes}) {
              $meta->add_attribute($attr);
          }
      }
      if (defined $methods) {
          foreach my $method_name (keys %{$methods}) {
              $meta->add_method($method_name, $methods->{$method_name});
          }
      }
      return $meta;
  }
  
  # XXX: something more intelligent here?
  sub _anon_package_prefix { 'Class::MOP::Class::__ANON__::SERIAL::' }
  
  sub create_anon_class { shift->create_anon(@_) }
  sub is_anon_class     { shift->is_anon(@_)     }
  
  sub _anon_cache_key {
      my $class = shift;
      my %options = @_;
      # Makes something like Super::Class|Super::Class::2
      return join '=' => (
          join( '|', sort @{ $options{superclasses} || [] } ),
      );
  }
  
  # Instance Construction & Cloning
  
  sub new_object {
      my $class = shift;
  
      # NOTE:
      # we need to protect the integrity of the
      # Class::MOP::Class singletons here, so we
      # delegate this to &construct_class_instance
      # which will deal with the singletons
      return $class->_construct_class_instance(@_)
          if $class->name->isa('Class::MOP::Class');
      return $class->_construct_instance(@_);
  }
  
  sub _construct_instance {
      my $class = shift;
      my $params = @_ == 1 ? $_[0] : {@_};
      my $meta_instance = $class->get_meta_instance();
      # FIXME:
      # the code below is almost certainly incorrect
      # but this is foreign inheritance, so we might
      # have to kludge it in the end.
      my $instance;
      if (my $instance_class = blessed($params->{__INSTANCE__})) {
          ($instance_class eq $class->name)
              || $class->_throw_exception( InstanceBlessedIntoWrongClass => class_name => $class->name,
                                                                   params     => $params,
                                                                   instance   => $params->{__INSTANCE__}
                                );
          $instance = $params->{__INSTANCE__};
      }
      elsif (exists $params->{__INSTANCE__}) {
          $class->_throw_exception( InstanceMustBeABlessedReference => class_name => $class->name,
                                                              params     => $params,
                                                              instance   => $params->{__INSTANCE__}
                         );
      }
      else {
          $instance = $meta_instance->create_instance();
      }
      foreach my $attr ($class->get_all_attributes()) {
          $attr->initialize_instance_slot($meta_instance, $instance, $params);
      }
      if (Class::MOP::metaclass_is_weak($class->name)) {
          $meta_instance->_set_mop_slot($instance, $class);
      }
      return $instance;
  }
  
  sub _inline_new_object {
      my $self = shift;
  
      return (
          'my $class = shift;',
          '$class = Scalar::Util::blessed($class) || $class;',
          $self->_inline_fallback_constructor('$class'),
          $self->_inline_params('$params', '$class'),
          $self->_inline_generate_instance('$instance', '$class'),
          $self->_inline_slot_initializers,
          $self->_inline_preserve_weak_metaclasses,
          $self->_inline_extra_init,
          'return $instance',
      );
  }
  
  sub _inline_fallback_constructor {
      my $self = shift;
      my ($class) = @_;
      return (
          'return ' . $self->_generate_fallback_constructor($class),
              'if ' . $class . ' ne \'' . $self->name . '\';',
      );
  }
  
  sub _generate_fallback_constructor {
      my $self = shift;
      my ($class) = @_;
      return 'Class::MOP::Class->initialize(' . $class . ')->new_object(@_)',
  }
  
  sub _inline_params {
      my $self = shift;
      my ($params, $class) = @_;
      return (
          'my ' . $params . ' = @_ == 1 ? $_[0] : {@_};',
      );
  }
  
  sub _inline_generate_instance {
      my $self = shift;
      my ($inst, $class) = @_;
      return (
          'my ' . $inst . ' = ' . $self->_inline_create_instance($class) . ';',
      );
  }
  
  sub _inline_create_instance {
      my $self = shift;
  
      return $self->get_meta_instance->inline_create_instance(@_);
  }
  
  sub _inline_slot_initializers {
      my $self = shift;
  
      my $idx = 0;
  
      return map { $self->_inline_slot_initializer($_, $idx++) }
                 sort { $a->name cmp $b->name } $self->get_all_attributes;
  }
  
  sub _inline_slot_initializer {
      my $self  = shift;
      my ($attr, $idx) = @_;
  
      if (defined(my $init_arg = $attr->init_arg)) {
          my @source = (
              'if (exists $params->{\'' . $init_arg . '\'}) {',
                  $self->_inline_init_attr_from_constructor($attr, $idx),
              '}',
          );
          if (my @default = $self->_inline_init_attr_from_default($attr, $idx)) {
              push @source, (
                  'else {',
                      @default,
                  '}',
              );
          }
          return @source;
      }
      elsif (my @default = $self->_inline_init_attr_from_default($attr, $idx)) {
          return (
              '{',
                  @default,
              '}',
          );
      }
      else {
          return ();
      }
  }
  
  sub _inline_init_attr_from_constructor {
      my $self = shift;
      my ($attr, $idx) = @_;
  
      my @initial_value = $attr->_inline_set_value(
          '$instance', '$params->{\'' . $attr->init_arg . '\'}',
      );
  
      push @initial_value, (
          '$attrs->[' . $idx . ']->set_initial_value(',
              '$instance,',
              $attr->_inline_instance_get('$instance'),
          ');',
      ) if $attr->has_initializer;
  
      return @initial_value;
  }
  
  sub _inline_init_attr_from_default {
      my $self = shift;
      my ($attr, $idx) = @_;
  
      my $default = $self->_inline_default_value($attr, $idx);
      return unless $default;
  
      my @initial_value = $attr->_inline_set_value('$instance', $default);
  
      push @initial_value, (
          '$attrs->[' . $idx . ']->set_initial_value(',
              '$instance,',
              $attr->_inline_instance_get('$instance'),
          ');',
      ) if $attr->has_initializer;
  
      return @initial_value;
  }
  
  sub _inline_default_value {
      my $self = shift;
      my ($attr, $index) = @_;
  
      if ($attr->has_default) {
          # NOTE:
          # default values can either be CODE refs
          # in which case we need to call them. Or
          # they can be scalars (strings/numbers)
          # in which case we can just deal with them
          # in the code we eval.
          if ($attr->is_default_a_coderef) {
              return '$defaults->[' . $index . ']->($instance)';
          }
          else {
              return '$defaults->[' . $index . ']';
          }
      }
      elsif ($attr->has_builder) {
          return '$instance->' . $attr->builder;
      }
      else {
          return;
      }
  }
  
  sub _inline_preserve_weak_metaclasses {
      my $self = shift;
      if (Class::MOP::metaclass_is_weak($self->name)) {
          return (
              $self->_inline_set_mop_slot(
                  '$instance', 'Class::MOP::class_of($class)'
              ) . ';'
          );
      }
      else {
          return ();
      }
  }
  
  sub _inline_extra_init { }
  
  sub _eval_environment {
      my $self = shift;
  
      my @attrs = sort { $a->name cmp $b->name } $self->get_all_attributes;
  
      my $defaults = [map { $_->default } @attrs];
  
      return {
          '$defaults' => \$defaults,
      };
  }
  
  
  sub get_meta_instance {
      my $self = shift;
      $self->{'_meta_instance'} ||= $self->_create_meta_instance();
  }
  
  sub _create_meta_instance {
      my $self = shift;
  
      my $instance = $self->instance_metaclass->new(
          associated_metaclass => $self,
          attributes => [ $self->get_all_attributes() ],
      );
  
      $self->add_meta_instance_dependencies()
          if $instance->is_dependent_on_superclasses();
  
      return $instance;
  }
  
  # TODO: this is actually not being used!
  sub _inline_rebless_instance {
      my $self = shift;
  
      return $self->get_meta_instance->inline_rebless_instance_structure(@_);
  }
  
  sub _inline_get_mop_slot {
      my $self = shift;
  
      return $self->get_meta_instance->_inline_get_mop_slot(@_);
  }
  
  sub _inline_set_mop_slot {
      my $self = shift;
  
      return $self->get_meta_instance->_inline_set_mop_slot(@_);
  }
  
  sub _inline_clear_mop_slot {
      my $self = shift;
  
      return $self->get_meta_instance->_inline_clear_mop_slot(@_);
  }
  
  sub clone_object {
      my $class    = shift;
      my $instance = shift;
      (blessed($instance) && $instance->isa($class->name))
          || $class->_throw_exception( CloneObjectExpectsAnInstanceOfMetaclass => class_name => $class->name,
                                                                         instance   => $instance,
                            );
      # NOTE:
      # we need to protect the integrity of the
      # Class::MOP::Class singletons here, they
      # should not be cloned.
      return $instance if $instance->isa('Class::MOP::Class');
      $class->_clone_instance($instance, @_);
  }
  
  sub _clone_instance {
      my ($class, $instance, %params) = @_;
      (blessed($instance))
          || $class->_throw_exception( OnlyInstancesCanBeCloned => class_name => $class->name,
                                                          instance   => $instance,
                                                          params     => \%params
                            );
      my $meta_instance = $class->get_meta_instance();
      my $clone = $meta_instance->clone_instance($instance);
      foreach my $attr ($class->get_all_attributes()) {
          if ( defined( my $init_arg = $attr->init_arg ) ) {
              if (exists $params{$init_arg}) {
                  $attr->set_value($clone, $params{$init_arg});
              }
          }
      }
      return $clone;
  }
  
  sub _force_rebless_instance {
      my ($self, $instance, %params) = @_;
      my $old_metaclass = Class::MOP::class_of($instance);
  
      $old_metaclass->rebless_instance_away($instance, $self, %params)
          if $old_metaclass;
  
      my $meta_instance = $self->get_meta_instance;
  
      if (Class::MOP::metaclass_is_weak($old_metaclass->name)) {
          $meta_instance->_clear_mop_slot($instance);
      }
  
      # rebless!
      # we use $_[1] here because of t/cmop/rebless_overload.t regressions
      # on 5.8.8
      $meta_instance->rebless_instance_structure($_[1], $self);
  
      $self->_fixup_attributes_after_rebless($instance, $old_metaclass, %params);
  
      if (Class::MOP::metaclass_is_weak($self->name)) {
          $meta_instance->_set_mop_slot($instance, $self);
      }
  }
  
  sub rebless_instance {
      my ($self, $instance, %params) = @_;
      my $old_metaclass = Class::MOP::class_of($instance);
  
      my $old_class = $old_metaclass ? $old_metaclass->name : blessed($instance);
      $self->name->isa($old_class)
          || $self->_throw_exception( CanReblessOnlyIntoASubclass => class_name     => $self->name,
                                                             instance       => $instance,
                                                             instance_class => blessed( $instance ),
                                                             params         => \%params,
                            );
  
      $self->_force_rebless_instance($_[1], %params);
  
      return $instance;
  }
  
  sub rebless_instance_back {
      my ( $self, $instance ) = @_;
      my $old_metaclass = Class::MOP::class_of($instance);
      my $old_class
          = $old_metaclass ? $old_metaclass->name : blessed($instance);
      $old_class->isa( $self->name )
          || $self->_throw_exception( CanReblessOnlyIntoASuperclass => class_name     => $self->name,
                                                               instance       => $instance,
                                                               instance_class => blessed( $instance ),
                            );
  
      $self->_force_rebless_instance($_[1]);
  
      return $instance;
  }
  
  sub rebless_instance_away {
      # this intentionally does nothing, it is just a hook
  }
  
  sub _fixup_attributes_after_rebless {
      my $self = shift;
      my ($instance, $rebless_from, %params) = @_;
      my $meta_instance = $self->get_meta_instance;
  
      for my $attr ( $rebless_from->get_all_attributes ) {
          next if $self->find_attribute_by_name( $attr->name );
          $meta_instance->deinitialize_slot( $instance, $_ ) for $attr->slots;
      }
  
      foreach my $attr ( $self->get_all_attributes ) {
          if ( $attr->has_value($instance) ) {
              if ( defined( my $init_arg = $attr->init_arg ) ) {
                  $params{$init_arg} = $attr->get_value($instance)
                      unless exists $params{$init_arg};
              }
              else {
                  $attr->set_value($instance, $attr->get_value($instance));
              }
          }
      }
  
      foreach my $attr ($self->get_all_attributes) {
          $attr->initialize_instance_slot($meta_instance, $instance, \%params);
      }
  }
  
  sub _attach_attribute {
      my ($self, $attribute) = @_;
      $attribute->attach_to_class($self);
  }
  
  sub _post_add_attribute {
      my ( $self, $attribute ) = @_;
  
      $self->invalidate_meta_instances;
  
      # invalidate package flag here
      try {
          local $SIG{__DIE__};
          $attribute->install_accessors;
      }
      catch {
          $self->remove_attribute( $attribute->name );
          die $_;
      };
  }
  
  sub remove_attribute {
      my $self = shift;
  
      my $removed_attribute = $self->SUPER::remove_attribute(@_)
          or return;
  
      $self->invalidate_meta_instances;
  
      $removed_attribute->remove_accessors;
      $removed_attribute->detach_from_class;
  
      return$removed_attribute;
  }
  
  sub find_attribute_by_name {
      my ( $self, $attr_name ) = @_;
  
      foreach my $class ( $self->linearized_isa ) {
          # fetch the meta-class ...
          my $meta = Class::MOP::Class->initialize($class);
          return $meta->get_attribute($attr_name)
              if $meta->has_attribute($attr_name);
      }
  
      return;
  }
  
  sub get_all_attributes {
      my $self = shift;
      my %attrs = map { %{ Class::MOP::Class->initialize($_)->_attribute_map } }
          reverse $self->linearized_isa;
      return values %attrs;
  }
  
  # Inheritance
  
  sub superclasses {
      my $self     = shift;
  
      my $isa = $self->get_or_add_package_symbol('@ISA');
  
      if (@_) {
          my @supers = @_;
          @{$isa} = @supers;
  
          # NOTE:
          # on 5.8 and below, we need to call
          # a method to get Perl to detect
          # a cycle in the class hierarchy
          my $class = $self->name;
          $class->isa($class);
  
          # NOTE:
          # we need to check the metaclass
          # compatibility here so that we can
          # be sure that the superclass is
          # not potentially creating an issues
          # we don't know about
  
          $self->_check_metaclass_compatibility();
          $self->_superclasses_updated();
      }
  
      return @{$isa};
  }
  
  sub _superclasses_updated {
      my $self = shift;
      $self->update_meta_instance_dependencies();
      # keep strong references to all our parents, so they don't disappear if
      # they are anon classes and don't have any direct instances
      $self->_superclass_metas(
          map { Class::MOP::class_of($_) } $self->superclasses
      );
  }
  
  sub _superclass_metas {
      my $self = shift;
      $self->{_superclass_metas} = [@_];
  }
  
  sub subclasses {
      my $self = shift;
      my $super_class = $self->name;
  
      return @{ $super_class->mro::get_isarev() };
  }
  
  sub direct_subclasses {
      my $self = shift;
      my $super_class = $self->name;
  
      return grep {
          grep {
              $_ eq $super_class
          } Class::MOP::Class->initialize($_)->superclasses
      } $self->subclasses;
  }
  
  sub linearized_isa {
      return @{ mro::get_linear_isa( (shift)->name ) };
  }
  
  sub class_precedence_list {
      my $self = shift;
      my $name = $self->name;
  
      unless (Class::MOP::IS_RUNNING_ON_5_10()) {
          # NOTE:
          # We need to check for circular inheritance here
          # if we are not on 5.10, cause 5.8 detects it late.
          # This will do nothing if all is well, and blow up
          # otherwise. Yes, it's an ugly hack, better
          # suggestions are welcome.
          # - SL
          ($name || return)->isa('This is a test for circular inheritance')
      }
  
      # if our mro is c3, we can
      # just grab the linear_isa
      if (mro::get_mro($name) eq 'c3') {
          return @{ mro::get_linear_isa($name) }
      }
      else {
          # NOTE:
          # we can't grab the linear_isa for dfs
          # since it has all the duplicates
          # already removed.
          return (
              $name,
              map {
                  Class::MOP::Class->initialize($_)->class_precedence_list()
              } $self->superclasses()
          );
      }
  }
  
  sub _method_lookup_order {
      return (shift->linearized_isa, 'UNIVERSAL');
  }
  
  ## Methods
  
  {
      my $fetch_and_prepare_method = sub {
          my ($self, $method_name) = @_;
          my $wrapped_metaclass = $self->wrapped_method_metaclass;
          # fetch it locally
          my $method = $self->get_method($method_name);
          # if we don't have local ...
          unless ($method) {
              # try to find the next method
              $method = $self->find_next_method_by_name($method_name);
              # die if it does not exist
              (defined $method)
                  || $self->_throw_exception( MethodNameNotFoundInInheritanceHierarchy => class_name  => $self->name,
                                                                                  method_name => $method_name
                                    );
              # and now make sure to wrap it
              # even if it is already wrapped
              # because we need a new sub ref
              $method = $wrapped_metaclass->wrap($method,
                  package_name => $self->name,
                  name         => $method_name,
              );
          }
          else {
              # now make sure we wrap it properly
              $method = $wrapped_metaclass->wrap($method,
                  package_name => $self->name,
                  name         => $method_name,
              ) unless $method->isa($wrapped_metaclass);
          }
          $self->add_method($method_name => $method);
          return $method;
      };
  
      sub add_before_method_modifier {
          my ($self, $method_name, $method_modifier) = @_;
          (defined $method_name && length $method_name)
              || $self->_throw_exception( MethodModifierNeedsMethodName => class_name => $self->name );
          my $method = $fetch_and_prepare_method->($self, $method_name);
          $method->add_before_modifier(
              subname(':before' => $method_modifier)
          );
      }
  
      sub add_after_method_modifier {
          my ($self, $method_name, $method_modifier) = @_;
          (defined $method_name && length $method_name)
              || $self->_throw_exception( MethodModifierNeedsMethodName => class_name => $self->name );
          my $method = $fetch_and_prepare_method->($self, $method_name);
          $method->add_after_modifier(
              subname(':after' => $method_modifier)
          );
      }
  
      sub add_around_method_modifier {
          my ($self, $method_name, $method_modifier) = @_;
          (defined $method_name && length $method_name)
              || $self->_throw_exception( MethodModifierNeedsMethodName => class_name => $self->name );
          my $method = $fetch_and_prepare_method->($self, $method_name);
          $method->add_around_modifier(
              subname(':around' => $method_modifier)
          );
      }
  
      # NOTE:
      # the methods above used to be named like this:
      #    ${pkg}::${method}:(before|after|around)
      # but this proved problematic when using one modifier
      # to wrap multiple methods (something which is likely
      # to happen pretty regularly IMO). So instead of naming
      # it like this, I have chosen to just name them purely
      # with their modifier names, like so:
      #    :(before|after|around)
      # The fact is that in a stack trace, it will be fairly
      # evident from the context what method they are attached
      # to, and so don't need the fully qualified name.
  }
  
  sub find_method_by_name {
      my ($self, $method_name) = @_;
      (defined $method_name && length $method_name)
          || $self->_throw_exception( MethodNameNotGiven => class_name => $self->name );
      foreach my $class ($self->_method_lookup_order) {
          my $method = Class::MOP::Class->initialize($class)->get_method($method_name);
          return $method if defined $method;
      }
      return;
  }
  
  sub get_all_methods {
      my $self = shift;
  
      my %methods;
      for my $class ( reverse $self->_method_lookup_order ) {
          my $meta = Class::MOP::Class->initialize($class);
  
          $methods{ $_->name } = $_ for $meta->_get_local_methods;
      }
  
      return values %methods;
  }
  
  sub get_all_method_names {
      my $self = shift;
      map { $_->name } $self->get_all_methods;
  }
  
  sub find_all_methods_by_name {
      my ($self, $method_name) = @_;
      (defined $method_name && length $method_name)
          || $self->_throw_exception( MethodNameNotGiven => class_name => $self->name );
      my @methods;
      foreach my $class ($self->_method_lookup_order) {
          # fetch the meta-class ...
          my $meta = Class::MOP::Class->initialize($class);
          push @methods => {
              name  => $method_name,
              class => $class,
              code  => $meta->get_method($method_name)
          } if $meta->has_method($method_name);
      }
      return @methods;
  }
  
  sub find_next_method_by_name {
      my ($self, $method_name) = @_;
      (defined $method_name && length $method_name)
          || $self->_throw_exception( MethodNameNotGiven => class_name => $self->name );
      my @cpl = ($self->_method_lookup_order);
      shift @cpl; # discard ourselves
      foreach my $class (@cpl) {
          my $method = Class::MOP::Class->initialize($class)->get_method($method_name);
          return $method if defined $method;
      }
      return;
  }
  
  sub update_meta_instance_dependencies {
      my $self = shift;
  
      if ( $self->{meta_instance_dependencies} ) {
          return $self->add_meta_instance_dependencies;
      }
  }
  
  sub add_meta_instance_dependencies {
      my $self = shift;
  
      $self->remove_meta_instance_dependencies;
  
      my @attrs = $self->get_all_attributes();
  
      my %seen;
      my @classes = grep { not $seen{ $_->name }++ }
          map { $_->associated_class } @attrs;
  
      foreach my $class (@classes) {
          $class->add_dependent_meta_instance($self);
      }
  
      $self->{meta_instance_dependencies} = \@classes;
  }
  
  sub remove_meta_instance_dependencies {
      my $self = shift;
  
      if ( my $classes = delete $self->{meta_instance_dependencies} ) {
          foreach my $class (@$classes) {
              $class->remove_dependent_meta_instance($self);
          }
  
          return $classes;
      }
  
      return;
  
  }
  
  sub add_dependent_meta_instance {
      my ( $self, $metaclass ) = @_;
      push @{ $self->{dependent_meta_instances} }, $metaclass;
  }
  
  sub remove_dependent_meta_instance {
      my ( $self, $metaclass ) = @_;
      my $name = $metaclass->name;
      @$_ = grep { $_->name ne $name } @$_
          for $self->{dependent_meta_instances};
  }
  
  sub invalidate_meta_instances {
      my $self = shift;
      $_->invalidate_meta_instance()
          for $self, @{ $self->{dependent_meta_instances} };
  }
  
  sub invalidate_meta_instance {
      my $self = shift;
      undef $self->{_meta_instance};
  }
  
  # check if we can reinitialize
  sub is_pristine {
      my $self = shift;
  
      # if any local attr is defined
      return if $self->get_attribute_list;
  
      # or any non-declared methods
      for my $method ( map { $self->get_method($_) } $self->get_method_list ) {
          return if $method->isa("Class::MOP::Method::Generated");
          # FIXME do we need to enforce this too? return unless $method->isa( $self->method_metaclass );
      }
  
      return 1;
  }
  
  ## Class closing
  
  sub is_mutable   { 1 }
  sub is_immutable { 0 }
  
  sub immutable_options { %{ $_[0]{__immutable}{options} || {} } }
  
  sub _immutable_options {
      my ( $self, @args ) = @_;
  
      return (
          inline_accessors   => 1,
          inline_constructor => 1,
          inline_destructor  => 0,
          debug              => 0,
          immutable_trait    => $self->immutable_trait,
          constructor_name   => $self->constructor_name,
          constructor_class  => $self->constructor_class,
          destructor_class   => $self->destructor_class,
          @args,
      );
  }
  
  sub make_immutable {
      my ( $self, @args ) = @_;
  
      return $self unless $self->is_mutable;
  
      my ($file, $line) = (caller)[1..2];
  
      $self->_initialize_immutable(
          file => $file,
          line => $line,
          $self->_immutable_options(@args),
      );
      $self->_rebless_as_immutable(@args);
  
      return $self;
  }
  
  sub make_mutable {
      my $self = shift;
  
      if ( $self->is_immutable ) {
          my @args = $self->immutable_options;
          $self->_rebless_as_mutable();
          $self->_remove_inlined_code(@args);
          delete $self->{__immutable};
          return $self;
      }
      else {
          return;
      }
  }
  
  sub _rebless_as_immutable {
      my ( $self, @args ) = @_;
  
      $self->{__immutable}{original_class} = ref $self;
  
      bless $self => $self->_immutable_metaclass(@args);
  }
  
  sub _immutable_metaclass {
      my ( $self, %args ) = @_;
  
      if ( my $class = $args{immutable_metaclass} ) {
          return $class;
      }
  
      my $trait = $args{immutable_trait} = $self->immutable_trait
          || $self->_throw_exception( NoImmutableTraitSpecifiedForClass => class_name => $self->name,
                                                                   params     => \%args
                            );
  
      my $meta      = $self->meta;
      my $meta_attr = $meta->find_attribute_by_name("immutable_trait");
  
      my $class_name;
  
      if ( $meta_attr and $trait eq $meta_attr->default ) {
          # if the trait is the same as the default we try and pick a
          # predictable name for the immutable metaclass
          $class_name = 'Class::MOP::Class::Immutable::' . ref($self);
      }
      else {
          $class_name = join '::', 'Class::MOP::Class::Immutable::CustomTrait',
              $trait, 'ForMetaClass', ref($self);
      }
  
      return $class_name
          if Class::MOP::does_metaclass_exist($class_name);
  
      # If the metaclass is a subclass of CMOP::Class which has had
      # metaclass roles applied (via Moose), then we want to make sure
      # that we preserve that anonymous class (see Fey::ORM for an
      # example of where this matters).
      my $meta_name = $meta->_real_ref_name;
  
      my $immutable_meta = $meta_name->create(
          $class_name,
          superclasses => [ ref $self ],
      );
  
      Class::MOP::MiniTrait::apply( $immutable_meta, $trait );
  
      $immutable_meta->make_immutable(
          inline_constructor => 0,
          inline_accessors   => 0,
      );
  
      return $class_name;
  }
  
  sub _remove_inlined_code {
      my $self = shift;
  
      $self->remove_method( $_->name ) for $self->_inlined_methods;
  
      delete $self->{__immutable}{inlined_methods};
  }
  
  sub _inlined_methods { @{ $_[0]{__immutable}{inlined_methods} || [] } }
  
  sub _add_inlined_method {
      my ( $self, $method ) = @_;
  
      push @{ $self->{__immutable}{inlined_methods} ||= [] }, $method;
  }
  
  sub _initialize_immutable {
      my ( $self, %args ) = @_;
  
      $self->{__immutable}{options} = \%args;
      $self->_install_inlined_code(%args);
  }
  
  sub _install_inlined_code {
      my ( $self, %args ) = @_;
  
      # FIXME
      $self->_inline_accessors(%args)   if $args{inline_accessors};
      $self->_inline_constructor(%args) if $args{inline_constructor};
      $self->_inline_destructor(%args)  if $args{inline_destructor};
  }
  
  sub _rebless_as_mutable {
      my $self = shift;
  
      bless $self, $self->_get_mutable_metaclass_name;
  
      return $self;
  }
  
  sub _inline_accessors {
      my $self = shift;
  
      foreach my $attr_name ( $self->get_attribute_list ) {
          $self->get_attribute($attr_name)->install_accessors(1);
      }
  }
  
  sub _inline_constructor {
      my ( $self, %args ) = @_;
  
      my $name = $args{constructor_name};
      # A class may not even have a constructor, and that's okay.
      return unless defined $name;
  
      if ( $self->has_method($name) && !$args{replace_constructor} ) {
          my $class = $self->name;
          warn "Not inlining a constructor for $class since it defines"
              . " its own constructor.\n"
              . "If you are certain you don't need to inline your"
              . " constructor, specify inline_constructor => 0 in your"
              . " call to $class->meta->make_immutable\n";
          return;
      }
  
      my $constructor_class = $args{constructor_class};
  
      {
          local $@;
          use_package_optimistically($constructor_class);
      }
  
      my $constructor = $constructor_class->new(
          options      => \%args,
          metaclass    => $self,
          is_inline    => 1,
          package_name => $self->name,
          name         => $name,
          definition_context => {
              description => "constructor " . $self->name . "::" . $name,
              file        => $args{file},
              line        => $args{line},
          },
      );
  
      if ( $args{replace_constructor} or $constructor->can_be_inlined ) {
          $self->add_method( $name => $constructor );
          $self->_add_inlined_method($constructor);
      }
  }
  
  sub _inline_destructor {
      my ( $self, %args ) = @_;
  
      ( exists $args{destructor_class} && defined $args{destructor_class} )
          || $self->_throw_exception( NoDestructorClassSpecified => class_name => $self->name,
                                                            params     => \%args,
                            );
  
      if ( $self->has_method('DESTROY') && ! $args{replace_destructor} ) {
          my $class = $self->name;
          warn "Not inlining a destructor for $class since it defines"
              . " its own destructor.\n";
          return;
      }
  
      my $destructor_class = $args{destructor_class};
  
      {
          local $@;
          use_package_optimistically($destructor_class);
      }
  
      return unless $destructor_class->is_needed($self);
  
      my $destructor = $destructor_class->new(
          options      => \%args,
          metaclass    => $self,
          package_name => $self->name,
          name         => 'DESTROY',
          definition_context => {
              description => "destructor " . $self->name . "::DESTROY",
              file        => $args{file},
              line        => $args{line},
          },
      );
  
      if ( $args{replace_destructor} or $destructor->can_be_inlined ) {
          $self->add_method( 'DESTROY' => $destructor );
          $self->_add_inlined_method($destructor);
      }
  }
  
  1;
  
  # ABSTRACT: Class Meta Object
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Class - Class Meta Object
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 SYNOPSIS
  
    # assuming that class Foo
    # has been defined, you can
  
    # use this for introspection ...
  
    # add a method to Foo ...
    Foo->meta->add_method( 'bar' => sub {...} )
  
    # get a list of all the classes searched
    # the method dispatcher in the correct order
    Foo->meta->class_precedence_list()
  
    # remove a method from Foo
    Foo->meta->remove_method('bar');
  
    # or use this to actually create classes ...
  
    Class::MOP::Class->create(
        'Bar' => (
            version      => '0.01',
            superclasses => ['Foo'],
            attributes   => [
                Class::MOP::Attribute->new('$bar'),
                Class::MOP::Attribute->new('$baz'),
            ],
            methods => {
                calculate_bar => sub {...},
                construct_baz => sub {...}
            }
        )
    );
  
  =head1 DESCRIPTION
  
  The Class Protocol is the largest and most complex part of the
  Class::MOP meta-object protocol. It controls the introspection and
  manipulation of Perl 5 classes, and it can create them as well. The
  best way to understand what this module can do is to read the
  documentation for each of its methods.
  
  =head1 INHERITANCE
  
  C<Class::MOP::Class> is a subclass of L<Class::MOP::Module>.
  
  =head1 METHODS
  
  =head2 Class construction
  
  These methods all create new C<Class::MOP::Class> objects. These
  objects can represent existing classes or they can be used to create
  new classes from scratch.
  
  The metaclass object for a given class is a singleton. If you attempt
  to create a metaclass for the same class twice, you will just get the
  existing object.
  
  =over 4
  
  =item B<< Class::MOP::Class->create($package_name, %options) >>
  
  This method creates a new C<Class::MOP::Class> object with the given
  package name. It accepts a number of options:
  
  =over 8
  
  =item * version
  
  An optional version number for the newly created package.
  
  =item * authority
  
  An optional authority for the newly created package.
  See L<Class::MOP::Module/authority> for more details.
  
  =item * superclasses
  
  An optional array reference of superclass names.
  
  =item * methods
  
  An optional hash reference of methods for the class. The keys of the
  hash reference are method names and values are subroutine references.
  
  =item * attributes
  
  An optional array reference of L<Class::MOP::Attribute> objects.
  
  =item * meta_name
  
  Specifies the name to install the C<meta> method for this class under.
  If it is not passed, C<meta> is assumed, and if C<undef> is explicitly
  given, no meta method will be installed.
  
  =item * weaken
  
  If true, the metaclass that is stored in the global cache will be a
  weak reference.
  
  Classes created in this way are destroyed once the metaclass they are
  attached to goes out of scope, and will be removed from Perl's internal
  symbol table.
  
  All instances of a class with a weakened metaclass keep a special
  reference to the metaclass object, which prevents the metaclass from
  going out of scope while any instances exist.
  
  This only works if the instance is based on a hash reference, however.
  
  =back
  
  =item B<< Class::MOP::Class->create_anon_class(%options) >>
  
  This method works just like C<< Class::MOP::Class->create >> but it
  creates an "anonymous" class. In fact, the class does have a name, but
  that name is a unique name generated internally by this module.
  
  It accepts the same C<superclasses>, C<methods>, and C<attributes>
  parameters that C<create> accepts.
  
  It also accepts a C<cache> option. If this is C<true>, then the anonymous class
  will be cached based on its superclasses and roles. If an existing anonymous
  class in the cache has the same superclasses and roles, it will be reused.
  
  Anonymous classes default to C<< weaken => 1 >> if cache is C<false>, although
  this can be overridden.
  
  =item B<< Class::MOP::Class->initialize($package_name, %options) >>
  
  This method will initialize a C<Class::MOP::Class> object for the
  named package. Unlike C<create>, this method I<will not> create a new
  class.
  
  The purpose of this method is to retrieve a C<Class::MOP::Class>
  object for introspecting an existing class.
  
  If an existing C<Class::MOP::Class> object exists for the named
  package, it will be returned, and any options provided will be
  ignored!
  
  If the object does not yet exist, it will be created.
  
  The valid options that can be passed to this method are
  C<attribute_metaclass>, C<method_metaclass>,
  C<wrapped_method_metaclass>, and C<instance_metaclass>. These are all
  optional, and default to the appropriate class in the C<Class::MOP>
  distribution.
  
  =back
  
  =head2 Object instance construction and cloning
  
  These methods are all related to creating and/or cloning object
  instances.
  
  =over 4
  
  =item B<< $metaclass->clone_object($instance, %params) >>
  
  This method clones an existing object instance. Any parameters you
  provide are will override existing attribute values in the object.
  
  This is a convenience method for cloning an object instance, then
  blessing it into the appropriate package.
  
  You could implement a clone method in your class, using this method:
  
    sub clone {
        my ($self, %params) = @_;
        $self->meta->clone_object($self, %params);
    }
  
  =item B<< $metaclass->rebless_instance($instance, %params) >>
  
  This method changes the class of C<$instance> to the metaclass's class.
  
  You can only rebless an instance into a subclass of its current
  class. If you pass any additional parameters, these will be treated
  like constructor parameters and used to initialize the object's
  attributes. Any existing attributes that are already set will be
  overwritten.
  
  Before reblessing the instance, this method will call
  C<rebless_instance_away> on the instance's current metaclass. This method
  will be passed the instance, the new metaclass, and any parameters
  specified to C<rebless_instance>. By default, C<rebless_instance_away>
  does nothing; it is merely a hook.
  
  =item B<< $metaclass->rebless_instance_back($instance) >>
  
  Does the same thing as C<rebless_instance>, except that you can only
  rebless an instance into one of its superclasses. Any attributes that
  do not exist in the superclass will be deinitialized.
  
  This is a much more dangerous operation than C<rebless_instance>,
  especially when multiple inheritance is involved, so use this carefully!
  
  =item B<< $metaclass->new_object(%params) >>
  
  This method is used to create a new object of the metaclass's
  class. Any parameters you provide are used to initialize the
  instance's attributes. A special C<__INSTANCE__> key can be passed to
  provide an already generated instance, rather than having Class::MOP
  generate it for you. This is mostly useful for using Class::MOP with
  foreign classes which generate instances using their own constructors.
  
  =item B<< $metaclass->instance_metaclass >>
  
  Returns the class name of the instance metaclass. See
  L<Class::MOP::Instance> for more information on the instance
  metaclass.
  
  =item B<< $metaclass->get_meta_instance >>
  
  Returns an instance of the C<instance_metaclass> to be used in the
  construction of a new instance of the class.
  
  =back
  
  =head2 Informational predicates
  
  These are a few predicate methods for asking information about the
  class itself.
  
  =over 4
  
  =item B<< $metaclass->is_anon_class >>
  
  This returns true if the class was created by calling C<<
  Class::MOP::Class->create_anon_class >>.
  
  =item B<< $metaclass->is_mutable >>
  
  This returns true if the class is still mutable.
  
  =item B<< $metaclass->is_immutable >>
  
  This returns true if the class has been made immutable.
  
  =item B<< $metaclass->is_pristine >>
  
  A class is I<not> pristine if it has non-inherited attributes or if it
  has any generated methods.
  
  =back
  
  =head2 Inheritance Relationships
  
  =over 4
  
  =item B<< $metaclass->superclasses(@superclasses) >>
  
  This is a read-write accessor which represents the superclass
  relationships of the metaclass's class.
  
  This is basically sugar around getting and setting C<@ISA>.
  
  =item B<< $metaclass->class_precedence_list >>
  
  This returns a list of all of the class's ancestor classes. The
  classes are returned in method dispatch order.
  
  =item B<< $metaclass->linearized_isa >>
  
  This returns a list based on C<class_precedence_list> but with all
  duplicates removed.
  
  =item B<< $metaclass->subclasses >>
  
  This returns a list of all subclasses for this class, even indirect
  subclasses.
  
  =item B<< $metaclass->direct_subclasses >>
  
  This returns a list of immediate subclasses for this class, which does not
  include indirect subclasses.
  
  =back
  
  =head2 Method introspection and creation
  
  These methods allow you to introspect a class's methods, as well as
  add, remove, or change methods.
  
  Determining what is truly a method in a Perl 5 class requires some
  heuristics (aka guessing).
  
  Methods defined outside the package with a fully qualified name (C<sub
  Package::name { ... }>) will be included. Similarly, methods named
  with a fully qualified name using L<Sub::Name> are also included.
  
  However, we attempt to ignore imported functions.
  
  Ultimately, we are using heuristics to determine what truly is a
  method in a class, and these heuristics may get the wrong answer in
  some edge cases. However, for most "normal" cases the heuristics work
  correctly.
  
  =over 4
  
  =item B<< $metaclass->get_method($method_name) >>
  
  This will return a L<Class::MOP::Method> for the specified
  C<$method_name>. If the class does not have the specified method, it
  returns C<undef>
  
  =item B<< $metaclass->has_method($method_name) >>
  
  Returns a boolean indicating whether or not the class defines the
  named method. It does not include methods inherited from parent
  classes.
  
  =item B<< $metaclass->get_method_list >>
  
  This will return a list of method I<names> for all methods defined in
  this class.
  
  =item B<< $metaclass->add_method($method_name, $method) >>
  
  This method takes a method name and a subroutine reference, and adds
  the method to the class.
  
  The subroutine reference can be a L<Class::MOP::Method>, and you are
  strongly encouraged to pass a meta method object instead of a code
  reference. If you do so, that object gets stored as part of the
  class's method map directly. If not, the meta information will have to
  be recreated later, and may be incorrect.
  
  If you provide a method object, this method will clone that object if
  the object's package name does not match the class name. This lets us
  track the original source of any methods added from other classes
  (notably Moose roles).
  
  =item B<< $metaclass->remove_method($method_name) >>
  
  Remove the named method from the class. This method returns the
  L<Class::MOP::Method> object for the method.
  
  =item B<< $metaclass->method_metaclass >>
  
  Returns the class name of the method metaclass, see
  L<Class::MOP::Method> for more information on the method metaclass.
  
  =item B<< $metaclass->wrapped_method_metaclass >>
  
  Returns the class name of the wrapped method metaclass, see
  L<Class::MOP::Method::Wrapped> for more information on the wrapped
  method metaclass.
  
  =item B<< $metaclass->get_all_methods >>
  
  This will traverse the inheritance hierarchy and return a list of all
  the L<Class::MOP::Method> objects for this class and its parents.
  
  =item B<< $metaclass->find_method_by_name($method_name) >>
  
  This will return a L<Class::MOP::Method> for the specified
  C<$method_name>. If the class does not have the specified method, it
  returns C<undef>
  
  Unlike C<get_method>, this method I<will> look for the named method in
  superclasses.
  
  =item B<< $metaclass->get_all_method_names >>
  
  This will return a list of method I<names> for all of this class's
  methods, including inherited methods.
  
  =item B<< $metaclass->find_all_methods_by_name($method_name) >>
  
  This method looks for the named method in the class and all of its
  parents. It returns every matching method it finds in the inheritance
  tree, so it returns a list of methods.
  
  Each method is returned as a hash reference with three keys. The keys
  are C<name>, C<class>, and C<code>. The C<code> key has a
  L<Class::MOP::Method> object as its value.
  
  The list of methods is distinct.
  
  =item B<< $metaclass->find_next_method_by_name($method_name) >>
  
  This method returns the first method in any superclass matching the
  given name. It is effectively the method that C<SUPER::$method_name>
  would dispatch to.
  
  =back
  
  =head2 Attribute introspection and creation
  
  Because Perl 5 does not have a core concept of attributes in classes,
  we can only return information about attributes which have been added
  via this class's methods. We cannot discover information about
  attributes which are defined in terms of "regular" Perl 5 methods.
  
  =over 4
  
  =item B<< $metaclass->get_attribute($attribute_name) >>
  
  This will return a L<Class::MOP::Attribute> for the specified
  C<$attribute_name>. If the class does not have the specified
  attribute, it returns C<undef>.
  
  NOTE that get_attribute does not search superclasses, for that you
  need to use C<find_attribute_by_name>.
  
  =item B<< $metaclass->has_attribute($attribute_name) >>
  
  Returns a boolean indicating whether or not the class defines the
  named attribute. It does not include attributes inherited from parent
  classes.
  
  =item B<< $metaclass->get_attribute_list >>
  
  This will return a list of attributes I<names> for all attributes
  defined in this class.  Note that this operates on the current class
  only, it does not traverse the inheritance hierarchy.
  
  =item B<< $metaclass->get_all_attributes >>
  
  This will traverse the inheritance hierarchy and return a list of all
  the L<Class::MOP::Attribute> objects for this class and its parents.
  
  =item B<< $metaclass->find_attribute_by_name($attribute_name) >>
  
  This will return a L<Class::MOP::Attribute> for the specified
  C<$attribute_name>. If the class does not have the specified
  attribute, it returns C<undef>.
  
  Unlike C<get_attribute>, this attribute I<will> look for the named
  attribute in superclasses.
  
  =item B<< $metaclass->add_attribute(...) >>
  
  This method accepts either an existing L<Class::MOP::Attribute>
  object or parameters suitable for passing to that class's C<new>
  method.
  
  The attribute provided will be added to the class.
  
  Any accessor methods defined by the attribute will be added to the
  class when the attribute is added.
  
  If an attribute of the same name already exists, the old attribute
  will be removed first.
  
  =item B<< $metaclass->remove_attribute($attribute_name) >>
  
  This will remove the named attribute from the class, and
  L<Class::MOP::Attribute> object.
  
  Removing an attribute also removes any accessor methods defined by the
  attribute.
  
  However, note that removing an attribute will only affect I<future>
  object instances created for this class, not existing instances.
  
  =item B<< $metaclass->attribute_metaclass >>
  
  Returns the class name of the attribute metaclass for this class. By
  default, this is L<Class::MOP::Attribute>.
  
  =back
  
  =head2 Overload introspection and creation
  
  These methods provide an API to the core L<overload> functionality.
  
  =over 4
  
  =item B<< $metaclass->is_overloaded >>
  
  Returns true if overloading is enabled for this class. Corresponds to
  L<Devel::OverloadInfo/is_overloaded>.
  
  =item B<< $metaclass->get_overloaded_operator($op) >>
  
  Returns the L<Class::MOP::Overload> object corresponding to the operator named
  C<$op>, if one exists for this class.
  
  =item B<< $metaclass->has_overloaded_operator($op) >>
  
  Returns whether or not the operator C<$op> is overloaded for this class.
  
  =item B<< $metaclass->get_overload_list >>
  
  Returns a list of operator names which have been overloaded (see
  L<overload/Overloadable Operations> for the list of valid operator names).
  
  =item B<< $metaclass->get_all_overloaded_operators >>
  
  Returns a list of L<Class::MOP::Overload> objects corresponding to the
  operators that have been overloaded.
  
  =item B<< $metaclass->add_overloaded_operator($op, $impl) >>
  
  Overloads the operator C<$op> for this class. The C<$impl> can be a coderef, a
  method name, or a L<Class::MOP::Overload> object. Corresponds to
  C<< use overload $op => $impl; >>
  
  =item B<< $metaclass->remove_overloaded_operator($op) >>
  
  Remove overloading for operator C<$op>. Corresponds to C<< no overload $op; >>
  
  =item B<< $metaclass->get_overload_fallback_value >>
  
  Returns the overload C<fallback> setting for the package.
  
  =item B<< $metaclass->set_overload_fallback_value($fallback) >>
  
  Sets the overload C<fallback> setting for the package.
  
  =back
  
  =head2 Class Immutability
  
  Making a class immutable "freezes" the class definition. You can no
  longer call methods which alter the class, such as adding or removing
  methods or attributes.
  
  Making a class immutable lets us optimize the class by inlining some
  methods, and also allows us to optimize some methods on the metaclass
  object itself.
  
  After immutabilization, the metaclass object will cache most informational
  methods that returns information about methods or attributes. Methods which
  would alter the class, such as C<add_attribute> and C<add_method>, will
  throw an error on an immutable metaclass object.
  
  The immutabilization system in L<Moose> takes much greater advantage
  of the inlining features than Class::MOP itself does.
  
  =over 4
  
  =item B<< $metaclass->make_immutable(%options) >>
  
  This method will create an immutable transformer and use it to make
  the class and its metaclass object immutable, and returns true
  (you should not rely on the details of this value apart from its truth).
  
  This method accepts the following options:
  
  =over 8
  
  =item * inline_accessors
  
  =item * inline_constructor
  
  =item * inline_destructor
  
  These are all booleans indicating whether the specified method(s)
  should be inlined.
  
  By default, accessors and the constructor are inlined, but not the
  destructor.
  
  =item * immutable_trait
  
  The name of a class which will be used as a parent class for the
  metaclass object being made immutable. This "trait" implements the
  post-immutability functionality of the metaclass (but not the
  transformation itself).
  
  This defaults to L<Class::MOP::Class::Immutable::Trait>.
  
  =item * constructor_name
  
  This is the constructor method name. This defaults to "new".
  
  =item * constructor_class
  
  The name of the method metaclass for constructors. It will be used to
  generate the inlined constructor. This defaults to
  "Class::MOP::Method::Constructor".
  
  =item * replace_constructor
  
  This is a boolean indicating whether an existing constructor should be
  replaced when inlining a constructor. This defaults to false.
  
  =item * destructor_class
  
  The name of the method metaclass for destructors. It will be used to
  generate the inlined destructor. This defaults to
  "Class::MOP::Method::Denstructor".
  
  =item * replace_destructor
  
  This is a boolean indicating whether an existing destructor should be
  replaced when inlining a destructor. This defaults to false.
  
  =back
  
  =item B<< $metaclass->immutable_options >>
  
  Returns a hash of the options used when making the class immutable, including
  both defaults and anything supplied by the user in the call to C<<
  $metaclass->make_immutable >>. This is useful if you need to temporarily make
  a class mutable and then restore immutability as it was before.
  
  =item B<< $metaclass->make_mutable >>
  
  Calling this method reverse the immutabilization transformation.
  
  =back
  
  =head2 Method Modifiers
  
  Method modifiers are hooks which allow a method to be wrapped with
  I<before>, I<after> and I<around> method modifiers. Every time a
  method is called, its modifiers are also called.
  
  A class can modify its own methods, as well as methods defined in
  parent classes.
  
  =head3 How method modifiers work?
  
  Method modifiers work by wrapping the original method and then
  replacing it in the class's symbol table. The wrappers will handle
  calling all the modifiers in the appropriate order and preserving the
  calling context for the original method.
  
  The return values of C<before> and C<after> modifiers are
  ignored. This is because their purpose is B<not> to filter the input
  and output of the primary method (this is done with an I<around>
  modifier).
  
  This may seem like an odd restriction to some, but doing this allows
  for simple code to be added at the beginning or end of a method call
  without altering the function of the wrapped method or placing any
  extra responsibility on the code of the modifier.
  
  Of course if you have more complex needs, you can use the C<around>
  modifier which allows you to change both the parameters passed to the
  wrapped method, as well as its return value.
  
  Before and around modifiers are called in last-defined-first-called
  order, while after modifiers are called in first-defined-first-called
  order. So the call tree might looks something like this:
  
    before 2
     before 1
      around 2
       around 1
        primary
       around 1
      around 2
     after 1
    after 2
  
  =head3 What is the performance impact?
  
  Of course there is a performance cost associated with method
  modifiers, but we have made every effort to make that cost directly
  proportional to the number of modifier features you use.
  
  The wrapping method does its best to B<only> do as much work as it
  absolutely needs to. In order to do this we have moved some of the
  performance costs to set-up time, where they are easier to amortize.
  
  All this said, our benchmarks have indicated the following:
  
    simple wrapper with no modifiers             100% slower
    simple wrapper with simple before modifier   400% slower
    simple wrapper with simple after modifier    450% slower
    simple wrapper with simple around modifier   500-550% slower
    simple wrapper with all 3 modifiers          1100% slower
  
  These numbers may seem daunting, but you must remember, every feature
  comes with some cost. To put things in perspective, just doing a
  simple C<AUTOLOAD> which does nothing but extract the name of the
  method called and return it costs about 400% over a normal method
  call.
  
  =over 4
  
  =item B<< $metaclass->add_before_method_modifier($method_name, $code) >>
  
  This wraps the specified method with the supplied subroutine
  reference. The modifier will be called as a method itself, and will
  receive the same arguments as are passed to the method.
  
  When the modifier exits, the wrapped method will be called.
  
  The return value of the modifier will be ignored.
  
  =item B<< $metaclass->add_after_method_modifier($method_name, $code) >>
  
  This wraps the specified method with the supplied subroutine
  reference. The modifier will be called as a method itself, and will
  receive the same arguments as are passed to the method.
  
  When the wrapped methods exits, the modifier will be called.
  
  The return value of the modifier will be ignored.
  
  =item B<< $metaclass->add_around_method_modifier($method_name, $code) >>
  
  This wraps the specified method with the supplied subroutine
  reference.
  
  The first argument passed to the modifier will be a subroutine
  reference to the wrapped method. The second argument is the object,
  and after that come any arguments passed when the method is called.
  
  The around modifier can choose to call the original method, as well as
  what arguments to pass if it does so.
  
  The return value of the modifier is what will be seen by the caller.
  
  =back
  
  =head2 Introspection
  
  =over 4
  
  =item B<< Class::MOP::Class->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  It should also be noted that L<Class::MOP> will actually bootstrap
  this module by installing a number of attribute meta-objects into its
  metaclass.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_CLASS_MOP_CLASS

$fatpacked{"darwin-2level/Class/MOP/Class/Immutable/Trait.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_MOP_CLASS_IMMUTABLE_TRAIT';
  package Class::MOP::Class::Immutable::Trait;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use MRO::Compat;
  use Module::Runtime 'use_module';
  
  # the original class of the metaclass instance
  sub _get_mutable_metaclass_name { $_[0]{__immutable}{original_class} }
  
  sub is_mutable   { 0 }
  sub is_immutable { 1 }
  
  sub _immutable_metaclass { ref $_[1] }
  
  sub _immutable_read_only {
      my $name = shift;
      __throw_exception( CallingReadOnlyMethodOnAnImmutableInstance => method_name => $name );
  }
  
  sub _immutable_cannot_call {
      my $name = shift;
      __throw_exception( CallingMethodOnAnImmutableInstance => method_name => $name );
  }
  
  for my $name (qw/superclasses/) {
      no strict 'refs';
      *{__PACKAGE__."::$name"} = sub {
          my $orig = shift;
          my $self = shift;
          _immutable_read_only($name) if @_;
          $self->$orig;
      };
  }
  
  for my $name (qw/add_method alias_method remove_method add_attribute remove_attribute remove_package_symbol add_package_symbol/) {
      no strict 'refs';
      *{__PACKAGE__."::$name"} = sub { _immutable_cannot_call($name) };
  }
  
  sub class_precedence_list {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{class_precedence_list}
              ||= [ $self->$orig ] };
  }
  
  sub linearized_isa {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{linearized_isa} ||= [ $self->$orig ] };
  }
  
  sub get_all_methods {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{get_all_methods} ||= [ $self->$orig ] };
  }
  
  sub get_all_method_names {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{get_all_method_names} ||= [ $self->$orig ] };
  }
  
  sub get_all_attributes {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{get_all_attributes} ||= [ $self->$orig ] };
  }
  
  sub get_meta_instance {
      my $orig = shift;
      my $self = shift;
      $self->{__immutable}{get_meta_instance} ||= $self->$orig;
  }
  
  sub _method_map {
      my $orig = shift;
      my $self = shift;
      $self->{__immutable}{_method_map} ||= $self->$orig;
  }
  
  # private method, for this file only -
  # if we declare a method here, it will behave differently depending on what
  # class this trait is applied to, so we won't have a reliable parameter list.
  sub __throw_exception {
      my ($exception_type, @args_to_exception) = @_;
      die use_module( "Moose::Exception::$exception_type" )->new( @args_to_exception );
  }
  
  1;
  
  # ABSTRACT: Implements immutability for metaclass objects
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Class::Immutable::Trait - Implements immutability for metaclass objects
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class provides a pseudo-trait that is applied to immutable metaclass
  objects. In reality, it is simply a parent class.
  
  It implements caching and read-only-ness for various metaclass methods.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_CLASS_MOP_CLASS_IMMUTABLE_TRAIT

$fatpacked{"darwin-2level/Class/MOP/Deprecated.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_MOP_DEPRECATED';
  package Class::MOP::Deprecated;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Package::DeprecationManager -deprecations => {
      'Class::Load wrapper functions' => '2.1100',
  };
  
  1;
  
  # ABSTRACT: Manages deprecation warnings for Class::MOP
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Deprecated - Manages deprecation warnings for Class::MOP
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
      use Class::MOP::Deprecated -api_version => $version;
  
  =head1 FUNCTIONS
  
  This module manages deprecation warnings for features that have been
  deprecated in Class::MOP.
  
  If you specify C<< -api_version => $version >>, you can use deprecated features
  without warnings. Note that this special treatment is limited to the package
  that loads C<Class::MOP::Deprecated>.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_CLASS_MOP_DEPRECATED

$fatpacked{"darwin-2level/Class/MOP/Instance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_MOP_INSTANCE';
  package Class::MOP::Instance;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'isweak', 'weaken', 'blessed';
  
  use parent 'Class::MOP::Object';
  
  # make this not a valid method name, to avoid (most) attribute conflicts
  my $RESERVED_MOP_SLOT = '<<MOP>>';
  
  sub BUILDARGS {
      my ($class, @args) = @_;
  
      if ( @args == 1 ) {
          unshift @args, "associated_metaclass";
      } elsif ( @args >= 2 && blessed($args[0]) && $args[0]->isa("Class::MOP::Class") ) {
          # compat mode
          my ( $meta, @attrs ) = @args;
          @args = ( associated_metaclass => $meta, attributes => \@attrs );
      }
  
      my %options = @args;
      # FIXME lazy_build
      $options{slots} ||= [ map { $_->slots } @{ $options{attributes} || [] } ];
      $options{slot_hash} = { map { $_ => undef } @{ $options{slots} } }; # FIXME lazy_build
  
      return \%options;
  }
  
  sub new {
      my $class = shift;
      my $options = $class->BUILDARGS(@_);
  
      # FIXME replace with a proper constructor
      my $instance = $class->_new(%$options);
  
      # FIXME weak_ref => 1,
      weaken($instance->{'associated_metaclass'});
  
      return $instance;
  }
  
  sub _new {
      my $class = shift;
      return Class::MOP::Class->initialize($class)->new_object(@_)
        if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
      return bless {
          # NOTE:
          # I am not sure that it makes
          # sense to pass in the meta
          # The ideal would be to just
          # pass in the class name, but
          # that is placing too much of
          # an assumption on bless(),
          # which is *probably* a safe
          # assumption,.. but you can
          # never tell <:)
          'associated_metaclass' => $params->{associated_metaclass},
          'attributes'           => $params->{attributes},
          'slots'                => $params->{slots},
          'slot_hash'            => $params->{slot_hash},
      } => $class;
  }
  
  sub _class_name { $_[0]->{_class_name} ||= $_[0]->associated_metaclass->name }
  
  sub create_instance {
      my $self = shift;
      bless {}, $self->_class_name;
  }
  
  sub clone_instance {
      my ($self, $instance) = @_;
  
      my $clone = $self->create_instance;
      for my $attr ($self->get_all_attributes) {
          next unless $attr->has_value($instance);
          for my $slot ($attr->slots) {
              my $val = $self->get_slot_value($instance, $slot);
              $self->set_slot_value($clone, $slot, $val);
              $self->weaken_slot_value($clone, $slot)
                  if $self->slot_value_is_weak($instance, $slot);
          }
      }
  
      $self->_set_mop_slot($clone, $self->_get_mop_slot($instance))
          if $self->_has_mop_slot($instance);
  
      return $clone;
  }
  
  # operations on meta instance
  
  sub get_all_slots {
      my $self = shift;
      return @{$self->{'slots'}};
  }
  
  sub get_all_attributes {
      my $self = shift;
      return @{$self->{attributes}};
  }
  
  sub is_valid_slot {
      my ($self, $slot_name) = @_;
      exists $self->{'slot_hash'}->{$slot_name};
  }
  
  # operations on created instances
  
  sub get_slot_value {
      my ($self, $instance, $slot_name) = @_;
      $instance->{$slot_name};
  }
  
  sub set_slot_value {
      my ($self, $instance, $slot_name, $value) = @_;
      $instance->{$slot_name} = $value;
  }
  
  sub initialize_slot {
      my ($self, $instance, $slot_name) = @_;
      return;
  }
  
  sub deinitialize_slot {
      my ( $self, $instance, $slot_name ) = @_;
      delete $instance->{$slot_name};
  }
  
  sub initialize_all_slots {
      my ($self, $instance) = @_;
      foreach my $slot_name ($self->get_all_slots) {
          $self->initialize_slot($instance, $slot_name);
      }
  }
  
  sub deinitialize_all_slots {
      my ($self, $instance) = @_;
      foreach my $slot_name ($self->get_all_slots) {
          $self->deinitialize_slot($instance, $slot_name);
      }
  }
  
  sub is_slot_initialized {
      my ($self, $instance, $slot_name, $value) = @_;
      exists $instance->{$slot_name};
  }
  
  sub weaken_slot_value {
      my ($self, $instance, $slot_name) = @_;
      weaken $instance->{$slot_name};
  }
  
  sub slot_value_is_weak {
      my ($self, $instance, $slot_name) = @_;
      isweak $instance->{$slot_name};
  }
  
  sub strengthen_slot_value {
      my ($self, $instance, $slot_name) = @_;
      $self->set_slot_value($instance, $slot_name, $self->get_slot_value($instance, $slot_name));
  }
  
  sub rebless_instance_structure {
      my ($self, $instance, $metaclass) = @_;
  
      # we use $_[1] here because of t/cmop/rebless_overload.t regressions
      # on 5.8.8
      bless $_[1], $metaclass->name;
  }
  
  sub is_dependent_on_superclasses {
      return; # for meta instances that require updates on inherited slot changes
  }
  
  sub _get_mop_slot {
      my ($self, $instance) = @_;
      $self->get_slot_value($instance, $RESERVED_MOP_SLOT);
  }
  
  sub _has_mop_slot {
      my ($self, $instance) = @_;
      $self->is_slot_initialized($instance, $RESERVED_MOP_SLOT);
  }
  
  sub _set_mop_slot {
      my ($self, $instance, $value) = @_;
      $self->set_slot_value($instance, $RESERVED_MOP_SLOT, $value);
  }
  
  sub _clear_mop_slot {
      my ($self, $instance) = @_;
      $self->deinitialize_slot($instance, $RESERVED_MOP_SLOT);
  }
  
  # inlinable operation snippets
  
  sub is_inlinable { 1 }
  
  sub inline_create_instance {
      my ($self, $class_variable) = @_;
      'bless {} => ' . $class_variable;
  }
  
  sub inline_slot_access {
      my ($self, $instance, $slot_name) = @_;
      sprintf q[%s->{"%s"}], $instance, quotemeta($slot_name);
  }
  
  sub inline_get_is_lvalue { 1 }
  
  sub inline_get_slot_value {
      my ($self, $instance, $slot_name) = @_;
      $self->inline_slot_access($instance, $slot_name);
  }
  
  sub inline_set_slot_value {
      my ($self, $instance, $slot_name, $value) = @_;
      $self->inline_slot_access($instance, $slot_name) . " = $value",
  }
  
  sub inline_initialize_slot {
      my ($self, $instance, $slot_name) = @_;
      return '';
  }
  
  sub inline_deinitialize_slot {
      my ($self, $instance, $slot_name) = @_;
      "delete " . $self->inline_slot_access($instance, $slot_name);
  }
  sub inline_is_slot_initialized {
      my ($self, $instance, $slot_name) = @_;
      "exists " . $self->inline_slot_access($instance, $slot_name);
  }
  
  sub inline_weaken_slot_value {
      my ($self, $instance, $slot_name) = @_;
      sprintf "Scalar::Util::weaken( %s )", $self->inline_slot_access($instance, $slot_name);
  }
  
  sub inline_strengthen_slot_value {
      my ($self, $instance, $slot_name) = @_;
      $self->inline_set_slot_value($instance, $slot_name, $self->inline_slot_access($instance, $slot_name));
  }
  
  sub inline_rebless_instance_structure {
      my ($self, $instance, $class_variable) = @_;
      "bless $instance => $class_variable";
  }
  
  sub _inline_get_mop_slot {
      my ($self, $instance) = @_;
      $self->inline_get_slot_value($instance, $RESERVED_MOP_SLOT);
  }
  
  sub _inline_set_mop_slot {
      my ($self, $instance, $value) = @_;
      $self->inline_set_slot_value($instance, $RESERVED_MOP_SLOT, $value);
  }
  
  sub _inline_clear_mop_slot {
      my ($self, $instance) = @_;
      $self->inline_deinitialize_slot($instance, $RESERVED_MOP_SLOT);
  }
  
  1;
  
  # ABSTRACT: Instance Meta Object
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Instance - Instance Meta Object
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  The Instance Protocol controls the creation of object instances, and
  the storage of attribute values in those instances.
  
  Using this API directly in your own code violates encapsulation, and
  we recommend that you use the appropriate APIs in L<Class::MOP::Class>
  and L<Class::MOP::Attribute> instead. Those APIs in turn call the
  methods in this class as appropriate.
  
  This class also participates in generating inlined code by providing
  snippets of code to access an object instance.
  
  =head1 METHODS
  
  =head2 Object construction
  
  =over 4
  
  =item B<< Class::MOP::Instance->new(%options) >>
  
  This method creates a new meta-instance object.
  
  It accepts the following keys in C<%options>:
  
  =over 8
  
  =item * associated_metaclass
  
  The L<Class::MOP::Class> object for which instances will be created.
  
  =item * attributes
  
  An array reference of L<Class::MOP::Attribute> objects. These are the
  attributes which can be stored in each instance.
  
  =back
  
  =back
  
  =head2 Creating and altering instances
  
  =over 4
  
  =item B<< $metainstance->create_instance >>
  
  This method returns a reference blessed into the associated
  metaclass's class.
  
  The default is to use a hash reference. Subclasses can override this.
  
  =item B<< $metainstance->clone_instance($instance) >>
  
  Given an instance, this method creates a new object by making
  I<shallow> clone of the original.
  
  =back
  
  =head2 Introspection
  
  =over 4
  
  =item B<< $metainstance->associated_metaclass >>
  
  This returns the L<Class::MOP::Class> object associated with the
  meta-instance object.
  
  =item B<< $metainstance->get_all_slots >>
  
  This returns a list of slot names stored in object instances. In
  almost all cases, slot names correspond directly attribute names.
  
  =item B<< $metainstance->is_valid_slot($slot_name) >>
  
  This will return true if C<$slot_name> is a valid slot name.
  
  =item B<< $metainstance->get_all_attributes >>
  
  This returns a list of attributes corresponding to the attributes
  passed to the constructor.
  
  =back
  
  =head2 Operations on Instance Structures
  
  It's important to understand that the meta-instance object is a
  different entity from the actual instances it creates. For this
  reason, any operations on the C<$instance_structure> always require
  that the object instance be passed to the method.
  
  =over 4
  
  =item B<< $metainstance->get_slot_value($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->set_slot_value($instance_structure, $slot_name, $value) >>
  
  =item B<< $metainstance->initialize_slot($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->deinitialize_slot($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->initialize_all_slots($instance_structure) >>
  
  =item B<< $metainstance->deinitialize_all_slots($instance_structure) >>
  
  =item B<< $metainstance->is_slot_initialized($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->weaken_slot_value($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->slot_value_is_weak($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->strengthen_slot_value($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->rebless_instance_structure($instance_structure, $new_metaclass) >>
  
  The exact details of what each method does should be fairly obvious
  from the method name.
  
  =back
  
  =head2 Inlinable Instance Operations
  
  =over 4
  
  =item B<< $metainstance->is_inlinable >>
  
  This is a boolean that indicates whether or not slot access operations
  can be inlined. By default it is true, but subclasses can override
  this.
  
  =item B<< $metainstance->inline_create_instance($class_variable) >>
  
  This method expects a string that, I<when inlined>, will become a
  class name. This would literally be something like C<'$class'>, not an
  actual class name.
  
  It returns a snippet of code that creates a new object for the
  class. This is something like C< bless {}, $class_name >.
  
  =item B<< $metainstance->inline_get_is_lvalue >>
  
  Returns whether or not C<inline_get_slot_value> is a valid lvalue. This can be
  used to do extra optimizations when generating inlined methods.
  
  =item B<< $metainstance->inline_slot_access($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_get_slot_value($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_set_slot_value($instance_variable, $slot_name, $value) >>
  
  =item B<< $metainstance->inline_initialize_slot($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_deinitialize_slot($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_is_slot_initialized($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_weaken_slot_value($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_strengthen_slot_value($instance_variable, $slot_name) >>
  
  These methods all expect two arguments. The first is the name of a
  variable, than when inlined, will represent the object
  instance. Typically this will be a literal string like C<'$_[0]'>.
  
  The second argument is a slot name.
  
  The method returns a snippet of code that, when inlined, performs some
  operation on the instance.
  
  =item B<< $metainstance->inline_rebless_instance_structure($instance_variable, $class_variable) >>
  
  This takes the name of a variable that will, when inlined, represent the object
  instance, and the name of a variable that will represent the class to rebless
  into, and returns code to rebless an instance into a class.
  
  =back
  
  =head2 Introspection
  
  =over 4
  
  =item B<< Class::MOP::Instance->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  It should also be noted that L<Class::MOP> will actually bootstrap
  this module by installing a number of attribute meta-objects into its
  metaclass.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_CLASS_MOP_INSTANCE

$fatpacked{"darwin-2level/Class/MOP/Method.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_MOP_METHOD';
  package Class::MOP::Method;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'weaken', 'reftype', 'blessed';
  
  use parent 'Class::MOP::Object';
  
  # NOTE:
  # if poked in the right way,
  # they should act like CODE refs.
  use overload
      '&{}' => sub { $_[0]->body },
      'bool' => sub { 1 },
      '""' => sub { overload::StrVal($_[0]) },
      fallback => 1;
  
  # construction
  
  sub wrap {
      my ( $class, @args ) = @_;
  
      unshift @args, 'body' if @args % 2 == 1;
  
      my %params = @args;
      my $code = $params{body};
  
      if (blessed($code) && $code->isa(__PACKAGE__)) {
          my $method = $code->clone;
          delete $params{body};
          Class::MOP::class_of($class)->rebless_instance($method, %params);
          return $method;
      }
      elsif (!ref $code || 'CODE' ne reftype($code)) {
          $class->_throw_exception( WrapTakesACodeRefToBless => params => \%params,
                                                                    class  => $class,
                                                                    code   => $code
                                      );
      }
  
      ($params{package_name} && $params{name})
          || $class->_throw_exception( PackageNameAndNameParamsNotGivenToWrap => params => \%params,
                                                                                     class  => $class,
                                                                                     code   => $code
                                         );
  
      my $self = $class->_new(\%params);
  
      weaken($self->{associated_metaclass}) if $self->{associated_metaclass};
  
      return $self;
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          'body'                 => $params->{body},
          'associated_metaclass' => $params->{associated_metaclass},
          'package_name'         => $params->{package_name},
          'name'                 => $params->{name},
          'original_method'      => $params->{original_method},
      } => $class;
  }
  
  ## accessors
  
  sub associated_metaclass { shift->{'associated_metaclass'} }
  
  sub attach_to_class {
      my ( $self, $class ) = @_;
      $self->{associated_metaclass} = $class;
      weaken($self->{associated_metaclass});
  }
  
  sub detach_from_class {
      my $self = shift;
      delete $self->{associated_metaclass};
  }
  
  sub fully_qualified_name {
      my $self = shift;
      $self->package_name . '::' . $self->name;
  }
  
  sub original_method { (shift)->{'original_method'} }
  
  sub _set_original_method { $_[0]->{'original_method'} = $_[1] }
  
  # It's possible that this could cause a loop if there is a circular
  # reference in here. That shouldn't ever happen in normal
  # circumstances, since original method only gets set when clone is
  # called. We _could_ check for such a loop, but it'd involve some sort
  # of package-lexical variable, and wouldn't be terribly subclassable.
  sub original_package_name {
      my $self = shift;
  
      $self->original_method
          ? $self->original_method->original_package_name
          : $self->package_name;
  }
  
  sub original_name {
      my $self = shift;
  
      $self->original_method
          ? $self->original_method->original_name
          : $self->name;
  }
  
  sub original_fully_qualified_name {
      my $self = shift;
  
      $self->original_method
          ? $self->original_method->original_fully_qualified_name
          : $self->fully_qualified_name;
  }
  
  sub execute {
      my $self = shift;
      $self->body->(@_);
  }
  
  # We used to go through use Class::MOP::Class->clone_instance to do this, but
  # this was awfully slow. This method may be called a number of times when
  # classes are loaded (especially during Moose role application), so it is
  # worth optimizing. - DR
  sub clone {
      my $self = shift;
  
      my $clone = bless { %{$self}, @_ }, blessed($self);
      weaken($clone->{associated_metaclass}) if $clone->{associated_metaclass};
  
      $clone->_set_original_method($self);
  
      return $clone;
  }
  
  sub _inline_throw_exception {
      my ( $self, $exception_type, $throw_args ) = @_;
      return
            'die Module::Runtime::use_module("Moose::Exception::'
          . $exception_type
          . '")->new('
          . ( $throw_args || '' ) . ')';
  }
  
  1;
  
  # ABSTRACT: Method Meta Object
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Method - Method Meta Object
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  The Method Protocol is very small, since methods in Perl 5 are just
  subroutines in a specific package. We provide a very basic
  introspection interface.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Class::MOP::Method->wrap($code, %options) >>
  
  This is the constructor. It accepts a method body in the form of
  either a code reference or a L<Class::MOP::Method> instance, followed
  by a hash of options.
  
  The options are:
  
  =over 8
  
  =item * name
  
  The method name (without a package name). This is required if C<$code>
  is a coderef.
  
  =item * package_name
  
  The package name for the method. This is required if C<$code> is a
  coderef.
  
  =item * associated_metaclass
  
  An optional L<Class::MOP::Class> object. This is the metaclass for the
  method's class.
  
  =back
  
  =item B<< $metamethod->clone(%params) >>
  
  This makes a shallow clone of the method object. In particular,
  subroutine reference itself is shared between all clones of a given
  method.
  
  When a method is cloned, the original method object will be available
  by calling C<original_method> on the clone.
  
  =item B<< $metamethod->body >>
  
  This returns a reference to the method's subroutine.
  
  =item B<< $metamethod->name >>
  
  This returns the method's name.
  
  =item B<< $metamethod->package_name >>
  
  This returns the method's package name.
  
  =item B<< $metamethod->fully_qualified_name >>
  
  This returns the method's fully qualified name (package name and
  method name).
  
  =item B<< $metamethod->associated_metaclass >>
  
  This returns the L<Class::MOP::Class> object for the method, if one
  exists.
  
  =item B<< $metamethod->original_method >>
  
  If this method object was created as a clone of some other method
  object, this returns the object that was cloned.
  
  =item B<< $metamethod->original_name >>
  
  This returns the method's original name, wherever it was first
  defined.
  
  If this method is a clone of a clone (of a clone, etc.), this method
  returns the name from the I<first> method in the chain of clones.
  
  =item B<< $metamethod->original_package_name >>
  
  This returns the method's original package name, wherever it was first
  defined.
  
  If this method is a clone of a clone (of a clone, etc.), this method
  returns the package name from the I<first> method in the chain of
  clones.
  
  =item B<< $metamethod->original_fully_qualified_name >>
  
  This returns the method's original fully qualified name, wherever it
  was first defined.
  
  If this method is a clone of a clone (of a clone, etc.), this method
  returns the fully qualified name from the I<first> method in the chain
  of clones.
  
  =item B<< $metamethod->is_stub >>
  
  Returns true if the method is just a stub:
  
    sub foo;
  
  =item B<< $metamethod->attach_to_class($metaclass) >>
  
  Given a L<Class::MOP::Class> object, this method sets the associated
  metaclass for the method. This will overwrite any existing associated
  metaclass.
  
  =item B<< $metamethod->detach_from_class >>
  
  Removes any associated metaclass object for the method.
  
  =item B<< $metamethod->execute(...) >>
  
  This executes the method. Any arguments provided will be passed on to
  the method itself.
  
  =item B<< Class::MOP::Method->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  It should also be noted that L<Class::MOP> will actually bootstrap
  this module by installing a number of attribute meta-objects into its
  metaclass.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_CLASS_MOP_METHOD

$fatpacked{"darwin-2level/Class/MOP/Method/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_MOP_METHOD_ACCESSOR';
  package Class::MOP::Method::Accessor;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed', 'weaken';
  use Try::Tiny;
  
  use parent 'Class::MOP::Method::Generated';
  
  sub new {
      my $class   = shift;
      my %options = @_;
  
      (exists $options{attribute})
          || $class->_throw_exception( MustSupplyAnAttributeToConstructWith => params => \%options,
                                                                      class  => $class,
                            );
  
      (exists $options{accessor_type})
          || $class->_throw_exception( MustSupplyAnAccessorTypeToConstructWith => params => \%options,
                                                                         class  => $class,
                            );
  
      (blessed($options{attribute}) && $options{attribute}->isa('Class::MOP::Attribute'))
          || $class->_throw_exception( MustSupplyAClassMOPAttributeInstance => params => \%options,
                                                                      class  => $class
                            );
  
      ($options{package_name} && $options{name})
          || $class->_throw_exception( MustSupplyPackageNameAndName => params => \%options,
                                                              class  => $class
                            );
  
      my $self = $class->_new(\%options);
  
      # we don't want this creating
      # a cycle in the code, if not
      # needed
      weaken($self->{'attribute'});
  
      $self->_initialize_body;
  
      return $self;
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          # inherited from Class::MOP::Method
          body                 => $params->{body},
          associated_metaclass => $params->{associated_metaclass},
          package_name         => $params->{package_name},
          name                 => $params->{name},
          original_method      => $params->{original_method},
  
          # inherit from Class::MOP::Generated
          is_inline            => $params->{is_inline} || 0,
          definition_context   => $params->{definition_context},
  
          # defined in this class
          attribute            => $params->{attribute},
          accessor_type        => $params->{accessor_type},
      } => $class;
  }
  
  ## accessors
  
  sub associated_attribute { (shift)->{'attribute'}     }
  sub accessor_type        { (shift)->{'accessor_type'} }
  
  ## factory
  
  sub _initialize_body {
      my $self = shift;
  
      my $method_name = join "_" => (
          '_generate',
          $self->accessor_type,
          'method',
          ($self->is_inline ? 'inline' : ())
      );
  
      $self->{'body'} = $self->$method_name();
  }
  
  ## generators
  
  sub _generate_accessor_method {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return sub {
          if (@_ >= 2) {
              $attr->set_value($_[0], $_[1]);
          }
          $attr->get_value($_[0]);
      };
  }
  
  sub _generate_accessor_method_inline {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return try {
          $self->_compile_code([
              'sub {',
                  'if (@_ > 1) {',
                      $attr->_inline_set_value('$_[0]', '$_[1]'),
                  '}',
                  $attr->_inline_get_value('$_[0]'),
              '}',
          ]);
      }
      catch {
          $self->_throw_exception( CouldNotGenerateInlineAttributeMethod => instance => $self,
                                                                    error    => $_,
                                                                    option   => "accessor"
                         );
      };
  }
  
  sub _generate_reader_method {
      my $self = shift;
      my $attr = $self->associated_attribute;
      my $class = $attr->associated_class;
  
      return sub {
          $self->_throw_exception( CannotAssignValueToReadOnlyAccessor => class_name => $class->name,
                                                                  value      => $_[1],
                                                                  attribute  => $attr
                         )
              if @_ > 1;
          $attr->get_value($_[0]);
      };
  }
  
  sub _generate_reader_method_inline {
      my $self = shift;
      my $attr = $self->associated_attribute;
      my $attr_name = $attr->name;
  
      return try {
          $self->_compile_code([
              'sub {',
                  'if (@_ > 1) {',
                      $self->_inline_throw_exception( CannotAssignValueToReadOnlyAccessor =>
                                                      'class_name                          => ref $_[0],'.
                                                      'value                               => $_[1],'.
                                                      "attribute_name                      => '".$attr_name."'",
                      ) . ';',
                  '}',
                  $attr->_inline_get_value('$_[0]'),
              '}',
          ]);
      }
      catch {
          $self->_throw_exception( CouldNotGenerateInlineAttributeMethod => instance => $self,
                                                                    error    => $_,
                                                                    option   => "reader"
                         );
      };
  }
  
  sub _generate_writer_method {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return sub {
          $attr->set_value($_[0], $_[1]);
      };
  }
  
  sub _generate_writer_method_inline {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return try {
          $self->_compile_code([
              'sub {',
                  $attr->_inline_set_value('$_[0]', '$_[1]'),
              '}',
          ]);
      }
      catch {
          $self->_throw_exception( CouldNotGenerateInlineAttributeMethod => instance => $self,
                                                                    error    => $_,
                                                                    option   => "writer"
                         );
      };
  }
  
  sub _generate_predicate_method {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return sub {
          $attr->has_value($_[0])
      };
  }
  
  sub _generate_predicate_method_inline {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return try {
          $self->_compile_code([
              'sub {',
                  $attr->_inline_has_value('$_[0]'),
              '}',
          ]);
      }
      catch {
          $self->_throw_exception( CouldNotGenerateInlineAttributeMethod => instance => $self,
                                                                    error    => $_,
                                                                    option   => "predicate"
                         );
      };
  }
  
  sub _generate_clearer_method {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return sub {
          $attr->clear_value($_[0])
      };
  }
  
  sub _generate_clearer_method_inline {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return try {
          $self->_compile_code([
              'sub {',
                  $attr->_inline_clear_value('$_[0]'),
              '}',
          ]);
      }
      catch {
          $self->_throw_exception( CouldNotGenerateInlineAttributeMethod => instance => $self,
                                                                    error    => $_,
                                                                    option   => "clearer"
                         );
      };
  }
  
  1;
  
  # ABSTRACT: Method Meta Object for accessors
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Method::Accessor - Method Meta Object for accessors
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 SYNOPSIS
  
      use Class::MOP::Method::Accessor;
  
      my $reader = Class::MOP::Method::Accessor->new(
          attribute     => $attribute,
          is_inline     => 1,
          accessor_type => 'reader',
      );
  
      $reader->body->execute($instance); # call the reader method
  
  =head1 DESCRIPTION
  
  This is a subclass of C<Class::MOP::Method> which is used by
  C<Class::MOP::Attribute> to generate accessor code. It handles
  generation of readers, writers, predicates and clearers. For each type
  of method, it can either create a subroutine reference, or actually
  inline code by generating a string and C<eval>'ing it.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Class::MOP::Method::Accessor->new(%options) >>
  
  This returns a new C<Class::MOP::Method::Accessor> based on the
  C<%options> provided.
  
  =over 4
  
  =item * attribute
  
  This is the C<Class::MOP::Attribute> for which accessors are being
  generated. This option is required.
  
  =item * accessor_type
  
  This is a string which should be one of "reader", "writer",
  "accessor", "predicate", or "clearer". This is the type of method
  being generated. This option is required.
  
  =item * is_inline
  
  This indicates whether or not the accessor should be inlined. This
  defaults to false.
  
  =item * name
  
  The method name (without a package name). This is required.
  
  =item * package_name
  
  The package name for the method. This is required.
  
  =back
  
  =item B<< $metamethod->accessor_type >>
  
  Returns the accessor type which was passed to C<new>.
  
  =item B<< $metamethod->is_inline >>
  
  Returns a boolean indicating whether or not the accessor is inlined.
  
  =item B<< $metamethod->associated_attribute >>
  
  This returns the L<Class::MOP::Attribute> object which was passed to
  C<new>.
  
  =item B<< $metamethod->body >>
  
  The method itself is I<generated> when the accessor object is
  constructed.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_CLASS_MOP_METHOD_ACCESSOR

$fatpacked{"darwin-2level/Class/MOP/Method/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_MOP_METHOD_CONSTRUCTOR';
  package Class::MOP::Method::Constructor;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed', 'weaken';
  use Try::Tiny;
  
  use parent 'Class::MOP::Method::Inlined';
  
  sub new {
      my $class   = shift;
      my %options = @_;
  
      (blessed $options{metaclass} && $options{metaclass}->isa('Class::MOP::Class'))
          || $class->_throw_exception( MustSupplyAMetaclass => params => \%options,
                                                      class  => $class
                            )
              if $options{is_inline};
  
      ($options{package_name} && $options{name})
          || $class->_throw_exception( MustSupplyPackageNameAndName => params => \%options,
                                                              class  => $class
                            );
  
      my $self = $class->_new(\%options);
  
      # we don't want this creating
      # a cycle in the code, if not
      # needed
      weaken($self->{'associated_metaclass'});
  
      $self->_initialize_body;
  
      return $self;
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          # inherited from Class::MOP::Method
          body                 => $params->{body},
          # associated_metaclass => $params->{associated_metaclass}, # overridden
          package_name         => $params->{package_name},
          name                 => $params->{name},
          original_method      => $params->{original_method},
  
          # inherited from Class::MOP::Generated
          is_inline            => $params->{is_inline} || 0,
          definition_context   => $params->{definition_context},
  
          # inherited from Class::MOP::Inlined
          _expected_method_class => $params->{_expected_method_class},
  
          # defined in this subclass
          options              => $params->{options} || {},
          associated_metaclass => $params->{metaclass},
      }, $class;
  }
  
  ## accessors
  
  sub options              { (shift)->{'options'}              }
  sub associated_metaclass { (shift)->{'associated_metaclass'} }
  
  ## method
  
  sub _initialize_body {
      my $self        = shift;
      my $method_name = '_generate_constructor_method';
  
      $method_name .= '_inline' if $self->is_inline;
  
      $self->{'body'} = $self->$method_name;
  }
  
  sub _eval_environment {
      my $self = shift;
      return $self->associated_metaclass->_eval_environment;
  }
  
  sub _generate_constructor_method {
      return sub { Class::MOP::Class->initialize(shift)->new_object(@_) }
  }
  
  sub _generate_constructor_method_inline {
      my $self = shift;
  
      my $meta = $self->associated_metaclass;
  
      my @source = (
          'sub {',
              $meta->_inline_new_object,
          '}',
      );
  
      warn join("\n", @source) if $self->options->{debug};
  
      my $code = try {
          $self->_compile_code(\@source);
      }
      catch {
          my $source = join("\n", @source);
          $self->_throw_exception( CouldNotEvalConstructor => constructor_method => $self,
                                                      source             => $source,
                                                      error              => $_
                         );
      };
  
      return $code;
  }
  
  1;
  
  # ABSTRACT: Method Meta Object for constructors
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Method::Constructor - Method Meta Object for constructors
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 SYNOPSIS
  
    use Class::MOP::Method::Constructor;
  
    my $constructor = Class::MOP::Method::Constructor->new(
        metaclass => $metaclass,
        options   => {
            debug => 1, # this is all for now
        },
    );
  
    # calling the constructor ...
    $constructor->body->execute($metaclass->name, %params);
  
  =head1 DESCRIPTION
  
  This is a subclass of L<Class::MOP::Method> which generates
  constructor methods.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Class::MOP::Method::Constructor->new(%options) >>
  
  This creates a new constructor object. It accepts a hash reference of
  options.
  
  =over 8
  
  =item * metaclass
  
  This should be a L<Class::MOP::Class> object. It is required.
  
  =item * name
  
  The method name (without a package name). This is required.
  
  =item * package_name
  
  The package name for the method. This is required.
  
  =item * is_inline
  
  This indicates whether or not the constructor should be inlined. This
  defaults to false.
  
  =back
  
  =item B<< $metamethod->is_inline >>
  
  Returns a boolean indicating whether or not the constructor is
  inlined.
  
  =item B<< $metamethod->associated_metaclass >>
  
  This returns the L<Class::MOP::Class> object for the method.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_CLASS_MOP_METHOD_CONSTRUCTOR

$fatpacked{"darwin-2level/Class/MOP/Method/Generated.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_MOP_METHOD_GENERATED';
  package Class::MOP::Method::Generated;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Eval::Closure;
  
  use parent 'Class::MOP::Method';
  
  ## accessors
  
  sub new {
      $_[0]->_throw_exception( CannotCallAnAbstractBaseMethod => package_name => __PACKAGE__ );
  }
  
  sub _initialize_body {
      $_[0]->_throw_exception( NoBodyToInitializeInAnAbstractBaseClass => package_name => __PACKAGE__ );
  }
  
  sub _generate_description {
      my ( $self, $context ) = @_;
      $context ||= $self->definition_context;
  
      my $desc = "generated method";
      my $origin = "unknown origin";
  
      if (defined $context) {
          if (defined $context->{description}) {
              $desc = $context->{description};
          }
  
          if (defined $context->{file} || defined $context->{line}) {
              $origin = "defined at "
                      . (defined $context->{file}
                          ? $context->{file} : "<unknown file>")
                      . " line "
                      . (defined $context->{line}
                          ? $context->{line} : "<unknown line>");
          }
      }
  
      return "$desc ($origin)";
  }
  
  sub _compile_code {
      my ( $self, @args ) = @_;
      unshift @args, 'source' if @args % 2;
      my %args = @args;
  
      my $context = delete $args{context};
      my $environment = $self->can('_eval_environment')
          ? $self->_eval_environment
          : {};
  
      return eval_closure(
          environment => $environment,
          description => $self->_generate_description($context),
          %args,
      );
  }
  
  1;
  
  # ABSTRACT: Abstract base class for generated methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Method::Generated - Abstract base class for generated methods
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This is a C<Class::MOP::Method> subclass which is subclassed by
  C<Class::MOP::Method::Accessor> and
  C<Class::MOP::Method::Constructor>.
  
  It is not intended to be used directly.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_CLASS_MOP_METHOD_GENERATED

$fatpacked{"darwin-2level/Class/MOP/Method/Inlined.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_MOP_METHOD_INLINED';
  package Class::MOP::Method::Inlined;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'refaddr';
  
  use parent 'Class::MOP::Method::Generated';
  
  sub _uninlined_body {
      my $self = shift;
  
      my $super_method
          = $self->associated_metaclass->find_next_method_by_name( $self->name )
          or return;
  
      if ( $super_method->isa(__PACKAGE__) ) {
          return $super_method->_uninlined_body;
      }
      else {
          return $super_method->body;
      }
  }
  
  sub can_be_inlined {
      my $self      = shift;
      my $metaclass = $self->associated_metaclass;
      my $class     = $metaclass->name;
  
      # If we don't find an inherited method, this is a rather weird
      # case where we have no method in the inheritance chain even
      # though we're expecting one to be there
      my $inherited_method
          = $metaclass->find_next_method_by_name( $self->name );
  
      if (   $inherited_method
          && $inherited_method->isa('Class::MOP::Method::Wrapped') ) {
          warn "Not inlining '"
              . $self->name
              . "' for $class since it "
              . "has method modifiers which would be lost if it were inlined\n";
  
          return 0;
      }
  
      my $expected_class = $self->_expected_method_class
          or return 1;
  
      # if we are shadowing a method we first verify that it is
      # compatible with the definition we are replacing it with
      my $expected_method = $expected_class->can( $self->name );
  
      if ( ! $expected_method ) {
          warn "Not inlining '"
              . $self->name
              . "' for $class since ${expected_class}::"
              . $self->name
              . " is not defined\n";
  
          return 0;
      }
  
      my $actual_method = $class->can( $self->name )
          or return 1;
  
      # the method is what we wanted (probably Moose::Object::new)
      return 1
          if refaddr($expected_method) == refaddr($actual_method);
  
      # otherwise we have to check that the actual method is an inlined
      # version of what we're expecting
      if ( $inherited_method->isa(__PACKAGE__) ) {
          if ( $inherited_method->_uninlined_body
               && refaddr( $inherited_method->_uninlined_body )
               == refaddr($expected_method) ) {
              return 1;
          }
      }
      elsif ( refaddr( $inherited_method->body )
              == refaddr($expected_method) ) {
          return 1;
      }
  
      my $warning
          = "Not inlining '"
          . $self->name
          . "' for $class since it is not"
          . " inheriting the default ${expected_class}::"
          . $self->name . "\n";
  
      if ( $self->isa("Class::MOP::Method::Constructor") ) {
  
          # FIXME kludge, refactor warning generation to a method
          $warning
              .= "If you are certain you don't need to inline your"
              . " constructor, specify inline_constructor => 0 in your"
              . " call to $class->meta->make_immutable\n";
      }
  
      warn $warning;
  
      return 0;
  }
  
  1;
  
  # ABSTRACT: Method base class for methods which have been inlined
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Method::Inlined - Method base class for methods which have been inlined
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This is a L<Class::MOP::Method::Generated> subclass for methods which
  can be inlined.
  
  =head1 METHODS
  
  =head2 $metamethod->can_be_inlined
  
  This method returns true if the method in question can be inlined in
  the associated metaclass.
  
  If it cannot be inlined, it spits out a warning and returns false.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_CLASS_MOP_METHOD_INLINED

$fatpacked{"darwin-2level/Class/MOP/Method/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_MOP_METHOD_META';
  package Class::MOP::Method::Meta;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Carp         'confess';
  use Scalar::Util 'blessed', 'weaken';
  
  use constant DEBUG_NO_META => $ENV{DEBUG_NO_META} ? 1 : 0;
  
  use parent 'Class::MOP::Method';
  
  sub _is_caller_mop_internal {
      my $self = shift;
      my ($caller) = @_;
      return $caller =~ /^(?:Class::MOP|metaclass)(?:::|$)/;
  }
  
  sub _generate_meta_method {
      my $method_self = shift;
      my $metaclass   = shift;
      weaken($metaclass);
  
      sub {
          # this will be compiled out if the env var wasn't set
          if (DEBUG_NO_META) {
              confess "'meta' method called by MOP internals"
                  # it's okay to call meta methods on metaclasses, since we
                  # explicitly ask for them
                  if !$_[0]->isa('Class::MOP::Object')
                  && !$_[0]->isa('Class::MOP::Mixin')
                  # it's okay if the test itself calls ->meta, we only care about
                  # if the mop internals call ->meta
                  && $method_self->_is_caller_mop_internal(scalar caller);
          }
          # we must re-initialize so that it
          # works as expected in subclasses,
          # since metaclass instances are
          # singletons, this is not really a
          # big deal anyway.
          $metaclass->initialize(blessed($_[0]) || $_[0])
      };
  }
  
  sub wrap {
      my ($class, @args) = @_;
  
      unshift @args, 'body' if @args % 2 == 1;
      my %params = @args;
      $class->_throw_exception( CannotOverrideBodyOfMetaMethods => params => \%params,
                                                                       class  => $class
                                  )
          if $params{body};
  
      my $metaclass_class = $params{associated_metaclass}->meta;
      $params{body} = $class->_generate_meta_method($metaclass_class);
      return $class->SUPER::wrap(%params);
  }
  
  sub _make_compatible_with {
      my $self = shift;
      my ($other) = @_;
  
      # XXX: this is pretty gross. the issue here is that CMOP::Method::Meta
      # objects are subclasses of CMOP::Method, but when we get to moose, they'll
      # need to be compatible with Moose::Meta::Method, which isn't possible. the
      # right solution here is to make ::Meta into a role that gets applied to
      # whatever the method_metaclass happens to be and get rid of
      # _meta_method_metaclass entirely, but that's not going to happen until
      # we ditch cmop and get roles into the bootstrapping, so. i'm not
      # maintaining the previous behavior of turning them into instances of the
      # new method_metaclass because that's equally broken, and at least this way
      # any issues will at least be detectable and potentially fixable. -doy
      return $self unless $other->_is_compatible_with($self->_real_ref_name);
  
      return $self->SUPER::_make_compatible_with(@_);
  }
  
  1;
  
  # ABSTRACT: Method Meta Object for C<meta> methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Method::Meta - Method Meta Object for C<meta> methods
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This is a L<Class::MOP::Method> subclass which represents C<meta>
  methods installed into classes by Class::MOP.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Class::MOP::Method::Wrapped->wrap($metamethod, %options) >>
  
  This is the constructor. It accepts a L<Class::MOP::Method> object and
  a hash of options. The options accepted are identical to the ones
  accepted by L<Class::MOP::Method>, except that C<body> cannot be passed
  (it will be generated automatically).
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_CLASS_MOP_METHOD_META

$fatpacked{"darwin-2level/Class/MOP/Method/Wrapped.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_MOP_METHOD_WRAPPED';
  package Class::MOP::Method::Wrapped;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed';
  use Sub::Name 'subname';
  
  use parent 'Class::MOP::Method';
  
  # NOTE:
  # this ugly beast is the result of trying
  # to micro optimize this as much as possible
  # while not completely loosing maintainability.
  # At this point it's "fast enough", after all
  # you can't get something for nothing :)
  my $_build_wrapped_method = sub {
      my $modifier_table = shift;
      my ($before, $after, $around) = (
          $modifier_table->{before},
          $modifier_table->{after},
          $modifier_table->{around},
      );
      if (@$before && @$after) {
          $modifier_table->{cache} = sub {
              for my $c (@$before) { $c->(@_) };
              my @rval;
              ((defined wantarray) ?
                  ((wantarray) ?
                      (@rval = $around->{cache}->(@_))
                      :
                      ($rval[0] = $around->{cache}->(@_)))
                  :
                  $around->{cache}->(@_));
              for my $c (@$after) { $c->(@_) };
              return unless defined wantarray;
              return wantarray ? @rval : $rval[0];
          }
      }
      elsif (@$before) {
          $modifier_table->{cache} = sub {
              for my $c (@$before) { $c->(@_) };
              return $around->{cache}->(@_);
          }
      }
      elsif (@$after) {
          $modifier_table->{cache} = sub {
              my @rval;
              ((defined wantarray) ?
                  ((wantarray) ?
                      (@rval = $around->{cache}->(@_))
                      :
                      ($rval[0] = $around->{cache}->(@_)))
                  :
                  $around->{cache}->(@_));
              for my $c (@$after) { $c->(@_) };
              return unless defined wantarray;
              return wantarray ? @rval : $rval[0];
          }
      }
      else {
          $modifier_table->{cache} = $around->{cache};
      }
  };
  
  sub wrap {
      my ( $class, $code, %params ) = @_;
  
      (blessed($code) && $code->isa('Class::MOP::Method'))
          || $class->_throw_exception( CanOnlyWrapBlessedCode => params => \%params,
                                                        class  => $class,
                                                        code   => $code
                            );
  
      my $modifier_table = {
          cache  => undef,
          orig   => $code->body,
          before => [],
          after  => [],
          around => {
              cache   => $code->body,
              methods => [],
          },
      };
      $_build_wrapped_method->($modifier_table);
  
      # get these from the original unless explicitly overridden
      my $pkg_name    = $params{package_name} || $code->package_name;
      my $method_name = $params{name}         || $code->name;
  
      return $class->SUPER::wrap(
          sub {
              my $wrapped = subname "${pkg_name}::_wrapped_${method_name}" => $modifier_table->{cache};
              return $wrapped->(@_) ;
          },
          package_name    => $pkg_name,
          name            => $method_name,
          original_method => $code,
          modifier_table  => $modifier_table,
      );
  }
  
  sub _new {
      my $class = shift;
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          # inherited from Class::MOP::Method
          'body'                 => $params->{body},
          'associated_metaclass' => $params->{associated_metaclass},
          'package_name'         => $params->{package_name},
          'name'                 => $params->{name},
          'original_method'      => $params->{original_method},
  
          # defined in this class
          'modifier_table'       => $params->{modifier_table}
      } => $class;
  }
  
  sub get_original_method {
      my $code = shift;
      $code->original_method;
  }
  
  sub add_before_modifier {
      my $code     = shift;
      my $modifier = shift;
      unshift @{$code->{'modifier_table'}->{before}} => $modifier;
      $_build_wrapped_method->($code->{'modifier_table'});
  }
  
  sub before_modifiers {
      my $code = shift;
      return @{$code->{'modifier_table'}->{before}};
  }
  
  sub add_after_modifier {
      my $code     = shift;
      my $modifier = shift;
      push @{$code->{'modifier_table'}->{after}} => $modifier;
      $_build_wrapped_method->($code->{'modifier_table'});
  }
  
  sub after_modifiers {
      my $code = shift;
      return @{$code->{'modifier_table'}->{after}};
  }
  
  {
      # NOTE:
      # this is another possible candidate for
      # optimization as well. There is an overhead
      # associated with the currying that, if
      # eliminated might make around modifiers
      # more manageable.
      my $compile_around_method = sub {{
          my $f1 = pop;
          return $f1 unless @_;
          my $f2 = pop;
          push @_, sub { $f2->( $f1, @_ ) };
          redo;
      }};
  
      sub add_around_modifier {
          my $code     = shift;
          my $modifier = shift;
          unshift @{$code->{'modifier_table'}->{around}->{methods}} => $modifier;
          $code->{'modifier_table'}->{around}->{cache} = $compile_around_method->(
              @{$code->{'modifier_table'}->{around}->{methods}},
              $code->{'modifier_table'}->{orig}
          );
          $_build_wrapped_method->($code->{'modifier_table'});
      }
  }
  
  sub around_modifiers {
      my $code = shift;
      return @{$code->{'modifier_table'}->{around}->{methods}};
  }
  
  sub _make_compatible_with {
      my $self = shift;
      my ($other) = @_;
  
      # XXX: this is pretty gross. the issue here is that CMOP::Method::Wrapped
      # objects are subclasses of CMOP::Method, but when we get to moose, they'll
      # need to be compatible with Moose::Meta::Method, which isn't possible. the
      # right solution here is to make ::Wrapped into a role that gets applied to
      # whatever the method_metaclass happens to be and get rid of
      # wrapped_method_metaclass entirely, but that's not going to happen until
      # we ditch cmop and get roles into the bootstrapping, so. i'm not
      # maintaining the previous behavior of turning them into instances of the
      # new method_metaclass because that's equally broken, and at least this way
      # any issues will at least be detectable and potentially fixable. -doy
      return $self unless $other->_is_compatible_with($self->_real_ref_name);
  
      return $self->SUPER::_make_compatible_with(@_);
  }
  
  1;
  
  # ABSTRACT: Method Meta Object for methods with before/after/around modifiers
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Method::Wrapped - Method Meta Object for methods with before/after/around modifiers
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This is a L<Class::MOP::Method> subclass which implements before,
  after, and around method modifiers.
  
  =head1 METHODS
  
  =head2 Class::MOP::Method::Wrapped->wrap($metamethod, %options)
  
  This is the constructor. It accepts a L<Class::MOP::Method> object and
  a hash of options.
  
  The options are:
  
  =over 4
  
  =item * name
  
  The method name (without a package name). This will be taken from the
  provided L<Class::MOP::Method> object if it is not provided.
  
  =item * package_name
  
  The package name for the method. This will be taken from the provided
  L<Class::MOP::Method> object if it is not provided.
  
  =item * associated_metaclass
  
  An optional L<Class::MOP::Class> object. This is the metaclass for the
  method's class.
  
  =back
  
  =head2 $metamethod->get_original_method
  
  This returns the L<Class::MOP::Method> object that was passed to the
  constructor.
  
  =head2 $metamethod->add_before_modifier($code)
  
  =head2 $metamethod->add_after_modifier($code)
  
  =head2 $metamethod->add_around_modifier($code)
  
  These methods all take a subroutine reference and apply it as a
  modifier to the original method.
  
  =head2 $metamethod->before_modifiers
  
  =head2 $metamethod->after_modifiers
  
  =head2 $metamethod->around_modifiers
  
  These methods all return a list of subroutine references which are
  acting as the specified type of modifier.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_CLASS_MOP_METHOD_WRAPPED

$fatpacked{"darwin-2level/Class/MOP/MiniTrait.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_MOP_MINITRAIT';
  package Class::MOP::MiniTrait;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Module::Runtime 'use_package_optimistically';
  
  sub apply {
      my ( $to_class, $trait ) = @_;
  
      for ( grep { !ref } $to_class, $trait ) {
          use_package_optimistically($_);
          $_ = Class::MOP::Class->initialize($_);
      }
  
      for my $meth ( grep { $_->package_name ne 'UNIVERSAL' } $trait->get_all_methods ) {
          my $meth_name = $meth->name;
          next if index($meth_name, '__') == 0;   # skip private subs
  
          if ( $to_class->find_method_by_name($meth_name) ) {
              $to_class->add_around_method_modifier( $meth_name, $meth->body );
          }
          else {
              $to_class->add_method( $meth_name, $meth->clone );
          }
      }
  }
  
  # We can't load this with use, since it may be loaded and used from Class::MOP
  # (via Class::MOP::Class, etc). However, if for some reason this module is loaded
  # _without_ first loading Class::MOP we need to require Class::MOP so we can
  # use it and Class::MOP::Class.
  require Class::MOP;
  
  1;
  
  # ABSTRACT: Extremely limited trait application
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::MiniTrait - Extremely limited trait application
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This package provides a single function, C<apply>, which does a half-assed job
  of applying a trait to a class. It exists solely for use inside Class::MOP and
  L<Moose> core classes.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_CLASS_MOP_MINITRAIT

$fatpacked{"darwin-2level/Class/MOP/Mixin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_MOP_MIXIN';
  package Class::MOP::Mixin;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed';
  use Module::Runtime 'use_module';
  
  sub meta {
      require Class::MOP::Class;
      Class::MOP::Class->initialize( blessed( $_[0] ) || $_[0] );
  }
  
  sub _throw_exception {
      my ($class, $exception_type, @args_to_exception) = @_;
      die use_module( "Moose::Exception::$exception_type" )->new( @args_to_exception );
  }
  
  1;
  
  # ABSTRACT: Base class for mixin classes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Mixin - Base class for mixin classes
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class provides a few methods which are useful in all metaclasses.
  
  =head1 METHODS
  
  =head2 Class::MOP::Mixin->meta
  
  This returns a L<Class::MOP::Class> object for the mixin class.
  
  =head2 Class::MOP::Mixin->_throw_exception
  
  Throws an exception in the L<Moose::Exception> family. This should ONLY be
  used internally -- any callers outside Class::MOP::* should be using the
  version in L<Moose::Util> instead.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_CLASS_MOP_MIXIN

$fatpacked{"darwin-2level/Class/MOP/Mixin/AttributeCore.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_MOP_MIXIN_ATTRIBUTECORE';
  package Class::MOP::Mixin::AttributeCore;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed';
  
  use parent 'Class::MOP::Mixin';
  
  sub has_accessor        { defined $_[0]->{'accessor'} }
  sub has_reader          { defined $_[0]->{'reader'} }
  sub has_writer          { defined $_[0]->{'writer'} }
  sub has_predicate       { defined $_[0]->{'predicate'} }
  sub has_clearer         { defined $_[0]->{'clearer'} }
  sub has_builder         { defined $_[0]->{'builder'} }
  sub has_init_arg        { defined $_[0]->{'init_arg'} }
  sub has_default         { exists  $_[0]->{'default'} }
  sub has_initializer     { defined $_[0]->{'initializer'} }
  sub has_insertion_order { defined $_[0]->{'insertion_order'} }
  
  sub _set_insertion_order { $_[0]->{'insertion_order'} = $_[1] }
  
  sub has_read_method  { $_[0]->has_reader || $_[0]->has_accessor }
  sub has_write_method { $_[0]->has_writer || $_[0]->has_accessor }
  
  sub is_default_a_coderef {
      # Uber hack because it is called from CMOP::Attribute constructor as
      # $class->is_default_a_coderef(\%options)
      my ($value) = ref $_[0] ? $_[0]->{'default'} : $_[1]->{'default'};
  
      return unless ref($value);
  
      return ref($value) eq 'CODE'
          || ( blessed($value) && $value->isa('Class::MOP::Method') );
  }
  
  sub default {
      my ( $self, $instance ) = @_;
      if ( defined $instance && $self->is_default_a_coderef ) {
          # if the default is a CODE ref, then we pass in the instance and
          # default can return a value based on that instance. Somewhat crude,
          # but works.
          return $self->{'default'}->($instance);
      }
      $self->{'default'};
  }
  
  1;
  
  # ABSTRACT: Core attributes shared by attribute metaclasses
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Mixin::AttributeCore - Core attributes shared by attribute metaclasses
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class implements the core attributes (aka properties) shared by all
  attributes. See the L<Class::MOP::Attribute> documentation for API details.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_CLASS_MOP_MIXIN_ATTRIBUTECORE

$fatpacked{"darwin-2level/Class/MOP/Mixin/HasAttributes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_MOP_MIXIN_HASATTRIBUTES';
  package Class::MOP::Mixin::HasAttributes;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed';
  
  use parent 'Class::MOP::Mixin';
  
  sub add_attribute {
      my $self = shift;
  
      my $attribute
          = blessed( $_[0] ) ? $_[0] : $self->attribute_metaclass->new(@_);
  
      ( $attribute->isa('Class::MOP::Mixin::AttributeCore') )
          || $self->_throw_exception( AttributeMustBeAnClassMOPMixinAttributeCoreOrSubclass => attribute  => $attribute,
                                                                                       class_name => $self->name,
                            );
  
      $self->_attach_attribute($attribute);
  
      my $attr_name = $attribute->name;
  
      $self->remove_attribute($attr_name)
          if $self->has_attribute($attr_name);
  
      my $order = ( scalar keys %{ $self->_attribute_map } );
      $attribute->_set_insertion_order($order);
  
      $self->_attribute_map->{$attr_name} = $attribute;
  
      # This method is called to allow for installing accessors. Ideally, we'd
      # use method overriding, but then the subclass would be responsible for
      # making the attribute, which would end up with lots of code
      # duplication. Even more ideally, we'd use augment/inner, but this is
      # Class::MOP!
      $self->_post_add_attribute($attribute)
          if $self->can('_post_add_attribute');
  
      return $attribute;
  }
  
  sub has_attribute {
      my ( $self, $attribute_name ) = @_;
  
      ( defined $attribute_name )
          || $self->_throw_exception( MustDefineAnAttributeName => class_name => $self->name );
  
      exists $self->_attribute_map->{$attribute_name};
  }
  
  sub get_attribute {
      my ( $self, $attribute_name ) = @_;
  
      ( defined $attribute_name )
          || $self->_throw_exception( MustDefineAnAttributeName => class_name => $self->name );
  
      return $self->_attribute_map->{$attribute_name};
  }
  
  sub remove_attribute {
      my ( $self, $attribute_name ) = @_;
  
      ( defined $attribute_name )
          || $self->_throw_exception( MustDefineAnAttributeName => class_name => $self->name );
  
      my $removed_attribute = $self->_attribute_map->{$attribute_name};
      return unless defined $removed_attribute;
  
      delete $self->_attribute_map->{$attribute_name};
  
      return $removed_attribute;
  }
  
  sub get_attribute_list {
      my $self = shift;
      keys %{ $self->_attribute_map };
  }
  
  sub _restore_metaattributes_from {
      my $self = shift;
      my ($old_meta) = @_;
  
      for my $attr (sort { $a->insertion_order <=> $b->insertion_order }
                         map { $old_meta->get_attribute($_) }
                             $old_meta->get_attribute_list) {
          $attr->_make_compatible_with($self->attribute_metaclass);
          $self->add_attribute($attr);
      }
  }
  
  1;
  
  # ABSTRACT: Methods for metaclasses which have attributes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Mixin::HasAttributes - Methods for metaclasses which have attributes
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class implements methods for metaclasses which have attributes
  (L<Class::MOP::Class> and L<Moose::Meta::Role>). See L<Class::MOP::Class> for
  API details.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_CLASS_MOP_MIXIN_HASATTRIBUTES

$fatpacked{"darwin-2level/Class/MOP/Mixin/HasMethods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_MOP_MIXIN_HASMETHODS';
  package Class::MOP::Mixin::HasMethods;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Class::MOP::Method::Meta;
  
  use Scalar::Util 'blessed', 'reftype';
  use Sub::Name 'subname';
  
  use parent 'Class::MOP::Mixin';
  
  sub _meta_method_class { 'Class::MOP::Method::Meta' }
  
  sub _add_meta_method {
      my $self = shift;
      my ($name) = @_;
      my $existing_method = $self->can('find_method_by_name')
                                ? $self->find_method_by_name($name)
                                : $self->get_method($name);
      return if $existing_method
             && $existing_method->isa($self->_meta_method_class);
      $self->add_method(
          $name => $self->_meta_method_class->wrap(
              name                 => $name,
              package_name         => $self->name,
              associated_metaclass => $self,
          )
      );
  }
  
  sub wrap_method_body {
      my ( $self, %args ) = @_;
  
      ( $args{body} && 'CODE' eq reftype $args{body} )
          || $self->_throw_exception( CodeBlockMustBeACodeRef => instance => $self,
                                                                      params   => \%args
                                         );
      $self->method_metaclass->wrap(
          package_name => $self->name,
          %args,
      );
  }
  
  sub add_method {
      my ( $self, $method_name, $method ) = @_;
      ( defined $method_name && length $method_name )
          || $self->_throw_exception( MustDefineAMethodName => instance => $self );
  
      my $package_name = $self->name;
  
      my $body;
      if ( blessed($method) && $method->isa('Class::MOP::Method') ) {
          $body = $method->body;
          if ( $method->package_name ne $package_name ) {
              $method = $method->clone(
                  package_name => $package_name,
                  name         => $method_name,
              );
          }
  
          $method->attach_to_class($self);
      }
      else {
          # If a raw code reference is supplied, its method object is not created.
          # The method object won't be created until required.
          $body = $method;
      }
  
      $self->_method_map->{$method_name} = $method;
  
      my ($current_package, $current_name) = Class::MOP::get_code_info($body);
  
      subname($package_name . '::' . $method_name, $body)
          unless defined $current_name && $current_name !~ /^__ANON__/;
  
      $self->add_package_symbol("&$method_name", $body);
  
      # we added the method to the method map too, so it's still valid
      $self->update_package_cache_flag;
  }
  
  sub _code_is_mine {
      my ( $self, $code ) = @_;
  
      my ( $code_package, $code_name ) = Class::MOP::get_code_info($code);
  
      return ( $code_package && $code_package eq $self->name )
          || ( $code_package eq 'constant' && $code_name eq '__ANON__' );
  }
  
  sub has_method {
      my ( $self, $method_name ) = @_;
  
      ( defined $method_name && length $method_name )
          || $self->_throw_exception( MustDefineAMethodName => instance => $self );
  
      my $method = $self->_get_maybe_raw_method($method_name);
      return if not $method;
  
      return defined($self->_method_map->{$method_name} = $method);
  }
  
  sub get_method {
      my ( $self, $method_name ) = @_;
  
      ( defined $method_name && length $method_name )
          || $self->_throw_exception( MustDefineAMethodName => instance => $self );
  
      my $method = $self->_get_maybe_raw_method($method_name);
      return if not $method;
  
      return $method if blessed($method) && $method->isa('Class::MOP::Method');
  
      return $self->_method_map->{$method_name} = $self->wrap_method_body(
          body                 => $method,
          name                 => $method_name,
          associated_metaclass => $self,
      );
  }
  
  sub _get_maybe_raw_method {
      my ( $self, $method_name ) = @_;
  
      my $map_entry = $self->_method_map->{$method_name};
      return $map_entry if defined $map_entry;
  
      my $code = $self->get_package_symbol("&$method_name");
  
      return unless $code && $self->_code_is_mine($code);
  
      return $code;
  }
  
  sub remove_method {
      my ( $self, $method_name ) = @_;
  
      ( defined $method_name && length $method_name )
          || $self->_throw_exception( MustDefineAMethodName => instance => $self );
  
      my $removed_method = delete $self->_method_map->{$method_name};
  
      $self->remove_package_symbol("&$method_name");
  
      $removed_method->detach_from_class
          if blessed($removed_method) && $removed_method->isa('Class::MOP::Method');
  
      # still valid, since we just removed the method from the map
      $self->update_package_cache_flag;
  
      return $removed_method;
  }
  
  sub get_method_list {
      my $self = shift;
  
      return keys %{ $self->_full_method_map };
  }
  
  sub _get_local_methods {
      my $self = shift;
  
      return values %{ $self->_full_method_map };
  }
  
  sub _restore_metamethods_from {
      my $self = shift;
      my ($old_meta) = @_;
  
      my $package_name = $self->name;
  
      # Check if Perl debugger is enabled
      my $debugger_enabled = ($^P & 0x10);
      my $debug_method_info;
  
      for my $method ($old_meta->_get_local_methods) {
          my $method_name = $method->name;
  
          # Track DB::sub information for this method if debugger is enabled.
          # This contains original method filename and line numbers.
          $debug_method_info = '';
          if ($debugger_enabled) {
              $debug_method_info = $DB::sub{$package_name . "::" . $method_name}
          }
  
          $method->_make_compatible_with($self->method_metaclass);
          $self->add_method($method_name => $method);
  
          # Restore method debug information, which can be clobbered by add_method.
          # Note that we handle this here instead of in add_method, because we
          # only want to preserve the original debug info in cases where we are
          # restoring a method, not overwriting a method.
          if ($debugger_enabled && $debug_method_info) {
              $DB::sub{$package_name . "::" . $method_name} = $debug_method_info;
          }
      }
  }
  
  sub reset_package_cache_flag  { (shift)->{'_package_cache_flag'} = undef }
  sub update_package_cache_flag {
      my $self = shift;
      # NOTE:
      # we can manually update the cache number
      # since we are actually adding the method
      # to our cache as well. This avoids us
      # having to regenerate the method_map.
      # - SL
      $self->{'_package_cache_flag'} = Class::MOP::check_package_cache_flag($self->name);
  }
  
  sub _full_method_map {
      my $self = shift;
  
      my $pkg_gen = Class::MOP::check_package_cache_flag($self->name);
  
      if (($self->{_package_cache_flag_full} || -1) != $pkg_gen) {
          # forcibly reify all method map entries
          $self->get_method($_)
              for $self->list_all_package_symbols('CODE');
          $self->{_package_cache_flag_full} = $pkg_gen;
      }
  
      return $self->_method_map;
  }
  
  1;
  
  # ABSTRACT: Methods for metaclasses which have methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Mixin::HasMethods - Methods for metaclasses which have methods
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class implements methods for metaclasses which have methods
  (L<Class::MOP::Class> and L<Moose::Meta::Role>). See L<Class::MOP::Class> for
  API details.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_CLASS_MOP_MIXIN_HASMETHODS

$fatpacked{"darwin-2level/Class/MOP/Mixin/HasOverloads.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_MOP_MIXIN_HASOVERLOADS';
  package Class::MOP::Mixin::HasOverloads;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Class::MOP::Overload;
  
  use Devel::OverloadInfo 0.005 'overload_info', 'overload_op_info';
  use Scalar::Util 'blessed';
  use Sub::Identify 'sub_name', 'stash_name';
  
  use overload ();
  
  use parent 'Class::MOP::Mixin';
  
  sub is_overloaded {
      my $self = shift;
      Devel::OverloadInfo::is_overloaded($self->name);
  }
  
  sub get_overload_list {
      my $self = shift;
  
      my $info = $self->_overload_info;
      return grep { $_ ne 'fallback' } keys %{$info}
  }
  
  sub get_all_overloaded_operators {
      my $self = shift;
      return map { $self->_overload_for($_) } $self->get_overload_list;
  }
  
  sub has_overloaded_operator {
      my $self = shift;
      my ($op) = @_;
      return defined $self->_overload_info_for($op);
  }
  
  sub _overload_map {
      $_[0]->{_overload_map} ||= {};
  }
  
  sub get_overloaded_operator {
      my $self = shift;
      my ($op) = @_;
      return $self->_overload_map->{$op} ||= $self->_overload_for($op);
  }
  
  use constant _SET_FALLBACK_EACH_TIME => "$]" < 5.120;
  
  sub add_overloaded_operator {
      my $self = shift;
      my ( $op, $overload ) = @_;
  
      my %p = ( associated_metaclass => $self );
      if ( !ref $overload ) {
          %p = (
              %p,
              operator             => $op,
              method_name          => $overload,
              associated_metaclass => $self,
          );
          $p{method} = $self->get_method($overload)
              if $self->has_method($overload);
          $overload = Class::MOP::Overload->new(%p);
      }
      elsif ( !blessed $overload) {
          $overload = Class::MOP::Overload->new(
              operator        => $op,
              coderef         => $overload,
              coderef_name    => sub_name($overload),
              coderef_package => stash_name($overload),
              %p,
          );
      }
  
      $overload->attach_to_class($self);
      $self->_overload_map->{$op} = $overload;
  
      my %overload = (
            $op => $overload->has_coderef
          ? $overload->coderef
          : $overload->method_name
      );
  
      # Perl 5.10 and earlier appear to have a bug where setting a new
      # overloading operator wipes out the fallback value unless we pass it each
      # time.
      if (_SET_FALLBACK_EACH_TIME) {
          $overload{fallback} = $self->get_overload_fallback_value;
      }
  
      $self->name->overload::OVERLOAD(%overload);
  }
  
  sub remove_overloaded_operator {
      my $self = shift;
      my ($op) = @_;
  
      delete $self->_overload_map->{$op};
  
      # overload.pm provides no api for this - but the problem that makes this
      # necessary has been fixed in 5.18
      $self->get_or_add_package_symbol('%OVERLOAD')->{dummy}++
          if "$]" < 5.017000;
  
      $self->remove_package_symbol('&(' . $op);
  }
  
  sub get_overload_fallback_value {
      my $self = shift;
      return ($self->_overload_info_for('fallback') || {})->{value};
  }
  
  sub set_overload_fallback_value {
      my $self  = shift;
      my $value = shift;
  
      $self->name->overload::OVERLOAD( fallback => $value );
  }
  
  # We could cache this but we'd need some logic to clear it at all the right
  # times, which seems more tedious than it's worth.
  sub _overload_info {
      my $self = shift;
      return overload_info( $self->name ) || {};
  }
  
  sub _overload_info_for {
      my $self = shift;
      my $op   = shift;
      return overload_op_info( $self->name, $op );
  }
  
  sub _overload_for {
      my $self = shift;
      my $op   = shift;
  
      my $map = $self->_overload_map;
      return $map->{$op} if $map->{$op};
  
      my $info = $self->_overload_info_for($op);
      return unless $info;
  
      my %p = (
          operator             => $op,
          associated_metaclass => $self,
      );
  
      if ( $info->{code} && !$info->{method_name} ) {
          $p{coderef} = $info->{code};
          @p{ 'coderef_package', 'coderef_name' }
              = $info->{code_name} =~ /(.+)::([^:]+)/;
      }
      else {
          $p{method_name} = $info->{method_name};
          if ( $self->has_method( $p{method_name} ) ) {
              $p{method} = $self->get_method( $p{method_name} );
          }
      }
  
      return $map->{$op} = Class::MOP::Overload->new(%p);
  }
  
  1;
  
  # ABSTRACT: Methods for metaclasses which have overloads
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Mixin::HasOverloads - Methods for metaclasses which have overloads
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class implements methods for metaclasses which have overloads
  (L<Class::MOP::Clas> and L<Moose::Meta::Role>). See L<Class::MOP::Class> for
  API details.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_CLASS_MOP_MIXIN_HASOVERLOADS

$fatpacked{"darwin-2level/Class/MOP/Module.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_MOP_MODULE';
  package Class::MOP::Module;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use parent 'Class::MOP::Package';
  
  sub _new {
      my $class = shift;
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
      return bless {
          # Need to quote package to avoid a problem with PPI mis-parsing this
          # as a package statement.
  
          # from Class::MOP::Package
          'package' => $params->{package},
          namespace => \undef,
  
          # attributes
          version   => \undef,
          authority => \undef
      } => $class;
  }
  
  sub version {
      my $self = shift;
      ${$self->get_or_add_package_symbol('$VERSION')};
  }
  
  sub authority {
      my $self = shift;
      ${$self->get_or_add_package_symbol('$AUTHORITY')};
  }
  
  sub identifier {
      my $self = shift;
      join '-' => (
          $self->name,
          ($self->version   || ()),
          ($self->authority || ()),
      );
  }
  
  sub create {
      my $class = shift;
      my @args = @_;
  
      unshift @args, 'package' if @args % 2 == 1;
      my %options = @args;
  
      my $package   = delete $options{package};
      my $version   = delete $options{version};
      my $authority = delete $options{authority};
  
      my $meta = $class->SUPER::create($package => %options);
  
      $meta->_instantiate_module($version, $authority);
  
      return $meta;
  }
  
  sub _anon_package_prefix { 'Class::MOP::Module::__ANON__::SERIAL::' }
  
  sub _anon_cache_key {
      my $class = shift;
      my %options = @_;
      $class->_throw_exception( PackagesAndModulesAreNotCachable => class_name => $class,
                                                           params     => \%options,
                                                           is_module  => 1
                     );
  }
  
  sub _instantiate_module {
      my($self, $version, $authority) = @_;
      my $package_name = $self->name;
  
      $self->add_package_symbol('$VERSION' => $version)
          if defined $version;
      $self->add_package_symbol('$AUTHORITY' => $authority)
          if defined $authority;
  
      return;
  }
  
  1;
  
  # ABSTRACT: Module Meta Object
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Module - Module Meta Object
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  A module is essentially a L<Class::MOP::Package> with metadata, in our
  case the version and authority.
  
  =head1 INHERITANCE
  
  B<Class::MOP::Module> is a subclass of L<Class::MOP::Package>.
  
  =head1 METHODS
  
  =head2 Class::MOP::Module->create($package, %options)
  
  Overrides C<create> from L<Class::MOP::Package> to provide these additional
  options:
  
  =over 4
  
  =item C<version>
  
  A version number, to be installed in the C<$VERSION> package global variable.
  
  =item C<authority>
  
  An authority, to be installed in the C<$AUTHORITY> package global variable.
  
  This is a legacy field and its use is not recommended.
  
  =back
  
  =head2 $metamodule->version
  
  This is a read-only attribute which returns the C<$VERSION> of the
  package, if one exists.
  
  =head2 $metamodule->authority
  
  This is a read-only attribute which returns the C<$AUTHORITY> of the
  package, if one exists.
  
  =head2 $metamodule->identifier
  
  This constructs a string which combines the name, version and
  authority.
  
  =head2 Class::MOP::Module->meta
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_CLASS_MOP_MODULE

$fatpacked{"darwin-2level/Class/MOP/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_MOP_OBJECT';
  package Class::MOP::Object;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use parent 'Class::MOP::Mixin';
  use Scalar::Util 'blessed';
  use Module::Runtime;
  
  # introspection
  
  sub throw_error {
      shift->_throw_exception( Legacy => message => join('', @_) );
  }
  
  sub _inline_throw_error {
      my ( $self, $message ) = @_;
      return 'die Module::Runtime::use_module("Moose::Exception::Legacy")->new(message => ' . $message. ')';
  }
  
  sub _new {
      Class::MOP::class_of(shift)->new_object(@_);
  }
  
  # RANT:
  # Cmon, how many times have you written
  # the following code while debugging:
  #
  #  use Data::Dumper;
  #  warn Dumper $obj;
  #
  # It can get seriously annoying, so why
  # not just do this ...
  sub dump {
      my $self = shift;
      require Data::Dumper;
      local $Data::Dumper::Maxdepth = shift || 1;
      Data::Dumper::Dumper $self;
  }
  
  sub _real_ref_name {
      my $self = shift;
      return blessed($self);
  }
  
  sub _is_compatible_with {
      my $self = shift;
      my ($other_name) = @_;
  
      return $self->isa($other_name);
  }
  
  sub _can_be_made_compatible_with {
      my $self = shift;
      return !$self->_is_compatible_with(@_)
          && defined($self->_get_compatible_metaclass(@_));
  }
  
  sub _make_compatible_with {
      my $self = shift;
      my ($other_name) = @_;
  
      my $new_metaclass = $self->_get_compatible_metaclass($other_name);
  
      unless ( defined $new_metaclass ) {
          $self->_throw_exception( CannotMakeMetaclassCompatible => superclass_name => $other_name,
                                                                         class           => $self,
                                      );
      }
  
      # can't use rebless_instance here, because it might not be an actual
      # subclass in the case of, e.g. moose role reconciliation
      $new_metaclass->meta->_force_rebless_instance($self)
          if blessed($self) ne $new_metaclass;
  
      return $self;
  }
  
  sub _get_compatible_metaclass {
      my $self = shift;
      my ($other_name) = @_;
  
      return $self->_get_compatible_metaclass_by_subclassing($other_name);
  }
  
  sub _get_compatible_metaclass_by_subclassing {
      my $self = shift;
      my ($other_name) = @_;
      my $meta_name = blessed($self) ? $self->_real_ref_name : $self;
  
      if ($meta_name->isa($other_name)) {
          return $meta_name;
      }
      elsif ($other_name->isa($meta_name)) {
          return $other_name;
      }
  
      return;
  }
  
  1;
  
  # ABSTRACT: Base class for metaclasses
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Object - Base class for metaclasses
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class is a very minimal base class for metaclasses.
  
  =head1 METHODS
  
  This class provides a few methods which are useful in all metaclasses.
  
  =head2 Class::MOP::???->meta
  
  This returns a L<Class::MOP::Class> object.
  
  =head2 $metaobject->dump($max_depth)
  
  This method uses L<Data::Dumper> to dump the object. You can pass an
  optional maximum depth, which will set C<$Data::Dumper::Maxdepth>. The
  default maximum depth is 1.
  
  =head2 $metaclass->throw_error($message)
  
  This method calls L<Class::MOP::Mixin/_throw_exception> internally, with an object
  of class L<Moose::Exception::Legacy>.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_CLASS_MOP_OBJECT

$fatpacked{"darwin-2level/Class/MOP/Overload.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_MOP_OVERLOAD';
  package Class::MOP::Overload;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use overload ();
  use Scalar::Util qw( blessed weaken );
  use Try::Tiny;
  
  use parent 'Class::MOP::Object';
  
  my %Operators = (
      map { $_ => 1 }
      grep { $_ ne 'fallback' }
      map  { split /\s+/ } values %overload::ops
  );
  
  sub new {
      my ( $class, %params ) = @_;
  
      unless ( defined $params{operator} ) {
          $class->_throw_exception('OverloadRequiresAnOperator');
      }
      unless ( $Operators{ $params{operator} } ) {
          $class->_throw_exception(
              'InvalidOverloadOperator',
              operator => $params{operator},
          );
      }
  
      unless ( defined $params{method_name} || $params{coderef} ) {
          $class->_throw_exception(
              'OverloadRequiresAMethodNameOrCoderef',
              operator => $params{operator},
          );
      }
  
      if ( $params{coderef} ) {
          unless ( defined $params{coderef_package}
              && defined $params{coderef_name} ) {
  
              $class->_throw_exception('OverloadRequiresNamesForCoderef');
          }
      }
  
      if ( $params{method}
          && !try { $params{method}->isa('Class::MOP::Method') } ) {
  
          $class->_throw_exception('OverloadRequiresAMetaMethod');
      }
  
      if ( $params{associated_metaclass}
          && !try { $params{associated_metaclass}->isa('Class::MOP::Module') } )
      {
  
          $class->_throw_exception('OverloadRequiresAMetaClass');
      }
  
      my @optional_attrs
          = qw( method_name coderef coderef_package coderef_name method associated_metaclass );
  
      return bless {
          operator => $params{operator},
          map { defined $params{$_} ? ( $_ => $params{$_} ) : () }
              @optional_attrs
          },
          $class;
  }
  
  sub operator { $_[0]->{operator} }
  
  sub method_name { $_[0]->{method_name} }
  sub has_method_name { exists $_[0]->{method_name} }
  
  sub method { $_[0]->{method} }
  sub has_method { exists $_[0]->{method} }
  
  sub coderef { $_[0]->{coderef} }
  sub has_coderef { exists $_[0]->{coderef} }
  
  sub coderef_package { $_[0]->{coderef_package} }
  sub has_coderef_package { exists $_[0]->{coderef_package} }
  
  sub coderef_name { $_[0]->{coderef_name} }
  sub has_coderef_name { exists $_[0]->{coderef_name} }
  
  sub associated_metaclass { $_[0]->{associated_metaclass} }
  
  sub is_anonymous {
      my $self = shift;
      return $self->has_coderef && $self->coderef_name eq '__ANON__';
  }
  
  sub attach_to_class {
      my ( $self, $class ) = @_;
      $self->{associated_metaclass} = $class;
      weaken $self->{associated_metaclass};
  }
  
  sub clone {
      my $self = shift;
  
      my $clone = bless { %{$self}, @_ }, blessed($self);
      weaken $clone->{associated_metaclass} if $clone->{associated_metaclass};
  
      $clone->_set_original_overload($self);
  
      return $clone;
  }
  
  sub original_overload { $_[0]->{original_overload} }
  sub _set_original_overload { $_[0]->{original_overload} = $_[1] }
  
  sub _is_equal_to {
      my $self  = shift;
      my $other = shift;
  
      if ( $self->has_coderef ) {
          return unless $other->has_coderef;
          return $self->coderef == $other->coderef;
      }
      else {
          return $self->method_name eq $other->method_name;
      }
  }
  
  1;
  
  # ABSTRACT: Overload Meta Object
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Overload - Overload Meta Object
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 SYNOPSIS
  
      my $meta     = Class->meta;
      my $overload = $meta->get_overloaded_operator('+');
  
      if ( $overload->has_method_name ) {
          print 'Method for + is ', $overload->method_name, "\n";
      }
      else {
          print 'Overloading for + is implemented by ',
              $overload->coderef_name, " sub\n";
      }
  
  =head1 DESCRIPTION
  
  This class provides meta information for overloading in classes and roles.
  
  =head1 INHERITANCE
  
  C<Class::MOP::Overload> is a subclass of L<Class::MOP::Object>.
  
  =head1 METHODS
  
  =head2 Class::MOP::Overload->new(%options)
  
  This method creates a new C<Class::MOP::Overload> object. It accepts a number
  of options:
  
  =over 4
  
  =item * operator
  
  This is a string that matches an operator known by the L<overload> module,
  such as C<""> or C<+>. This is required.
  
  =item * method_name
  
  The name of the method which implements the overloading. Note that this does
  not need to actually correspond to a real method, since it's okay to declare a
  not-yet-implemented overloading.
  
  Either this or the C<coderef> option must be passed.
  
  =item * method
  
  A L<Class::MOP::Method> object for the method which implements the
  overloading.
  
  This is optional.
  
  =item * coderef
  
  A coderef which implements the overloading.
  
  Either this or the C<method_name> option must be passed.
  
  =item * coderef_package
  
  The package where the coderef was defined.
  
  This is required if C<coderef> is passed.
  
  =item * coderef_name
  
  The name of the coderef. This can be "__ANON__".
  
  This is required if C<coderef> is passed.
  
  =item * associated_metaclass
  
  A L<Class::MOP::Module> object for the associated class or role.
  
  This is optional.
  
  =back
  
  =head2 $overload->operator
  
  Returns the operator for this overload object.
  
  =head2 $overload->method_name
  
  Returns the method name that implements overloading, if it has one.
  
  =head2 $overload->has_method_name
  
  Returns true if the object has a method name.
  
  =head2 $overload->method
  
  Returns the L<Class::MOP::Method> that implements overloading, if it has one.
  
  =head2 $overload->has_method
  
  Returns true if the object has a method.
  
  =head2 $overload->coderef
  
  Returns the coderef that implements overloading, if it has one.
  
  =head2 $overload->has_coderef
  
  Returns true if the object has a coderef.
  
  =head2 $overload->coderef_package
  
  Returns the package for the coderef that implements overloading, if it has
  one.
  
  =head2 $overload->has_coderef
  
  Returns true if the object has a coderef package.
  
  =head2 $overload->coderef_name
  
  Returns the sub name for the coderef that implements overloading, if it has
  one.
  
  =head2 $overload->has_coderef_name
  
  Returns true if the object has a coderef name.
  
  =head2 $overload->is_anonymous
  
  Returns true if the overloading is implemented by an anonymous coderef.
  
  =head2 $overload->associated_metaclass
  
  Returns the L<Class::MOP::Module> (class or role) that is associated with the
  overload object.
  
  =head2 $overload->clone
  
  Clones the overloading object, setting C<original_overload> in the process.
  
  =head2 $overload->original_overload
  
  For cloned objects, this returns the L<Class::MOP::Overload> object from which
  they were cloned. This can be used to determine the source of an overloading
  in a class that came from a role, for example.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_CLASS_MOP_OVERLOAD

$fatpacked{"darwin-2level/Class/MOP/Package.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLASS_MOP_PACKAGE';
  package Class::MOP::Package;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed', 'weaken';
  use Devel::GlobalDestruction 'in_global_destruction';
  use Module::Runtime 'module_notional_filename';
  use Package::Stash;
  
  use parent 'Class::MOP::Object';
  
  # creation ...
  
  sub initialize {
      my ( $class, @args ) = @_;
  
      unshift @args, "package" if @args % 2;
  
      my %options = @args;
      my $package_name = delete $options{package};
  
      # we hand-construct the class until we can bootstrap it
      if ( my $meta = Class::MOP::get_metaclass_by_name($package_name) ) {
          return $meta;
      } else {
          my $meta = ( ref $class || $class )->_new({
              'package'   => $package_name,
              %options,
          });
          Class::MOP::store_metaclass_by_name($package_name, $meta);
  
          Class::MOP::weaken_metaclass($package_name) if $options{weaken};
  
  
          return $meta;
      }
  }
  
  sub reinitialize {
      my ( $class, @args ) = @_;
  
      unshift @args, "package" if @args % 2;
  
      my %options = @args;
      my $package_name = delete $options{package};
  
      (defined $package_name && $package_name
        && (!blessed $package_name || $package_name->isa('Class::MOP::Package')))
          || $class->_throw_exception( MustPassAPackageNameOrAnExistingClassMOPPackageInstance => params => \%options,
                                                                                         class  => $class
                            );
  
      $package_name = $package_name->name
          if blessed $package_name;
  
      Class::MOP::remove_metaclass_by_name($package_name);
  
      $class->initialize($package_name, %options); # call with first arg form for compat
  }
  
  sub create {
      my $class = shift;
      my @args = @_;
  
      my $meta = $class->initialize(@args);
      my $filename = module_notional_filename($meta->name);
      $INC{$filename} = '(set by Moose)'
          unless exists $INC{$filename};
  
      return $meta;
  }
  
  ## ANON packages
  
  {
      # NOTE:
      # this should be sufficient, if you have a
      # use case where it is not, write a test and
      # I will change it.
      my $ANON_SERIAL = 0;
  
      my %ANON_PACKAGE_CACHE;
  
      # NOTE:
      # we need a sufficiently annoying prefix
      # this should suffice for now, this is
      # used in a couple of places below, so
      # need to put it up here for now.
      sub _anon_package_prefix { 'Class::MOP::Package::__ANON__::SERIAL::' }
  
      sub is_anon {
          my $self = shift;
          no warnings 'uninitialized';
          my $prefix = $self->_anon_package_prefix;
          $self->name =~ /^\Q$prefix/;
      }
  
      sub create_anon {
          my ($class, %options) = @_;
  
          my $cache_ok = delete $options{cache};
          $options{weaken} = !$cache_ok unless exists $options{weaken};
  
          my $cache_key;
          if ($cache_ok) {
              $cache_key = $class->_anon_cache_key(%options);
              undef $cache_ok if !defined($cache_key);
          }
  
          if ($cache_ok) {
              if (defined $ANON_PACKAGE_CACHE{$cache_key}) {
                  return $ANON_PACKAGE_CACHE{$cache_key};
              }
          }
  
          my $package_name = $class->_anon_package_prefix . ++$ANON_SERIAL;
  
          my $meta = $class->create($package_name, %options);
  
          if ($cache_ok) {
              $ANON_PACKAGE_CACHE{$cache_key} = $meta;
              weaken($ANON_PACKAGE_CACHE{$cache_key});
          }
  
          return $meta;
      }
  
      sub _anon_cache_key {
          my $class = shift;
          my %options = @_;
          $class->_throw_exception( PackagesAndModulesAreNotCachable => class_name => $class,
                                                               params     => \%options,
                                                               is_module  => 0
                         );
      }
  
      sub DESTROY {
          my $self = shift;
  
          return if in_global_destruction(); # it'll happen soon anyway and this just makes things more complicated
  
          $self->_free_anon
              if $self->is_anon;
      }
  
      sub _free_anon {
          my $self = shift;
          my $name = $self->name;
  
          # Moose does a weird thing where it replaces the metaclass for
          # class when fixing metaclass incompatibility. In that case,
          # we don't want to clean out the namespace now. We can detect
          # that because Moose will explicitly update the singleton
          # cache in Class::MOP using store_metaclass_by_name, which
          # means that the new metaclass will already exist in the cache
          # by this point.
          # The other options here are that $current_meta can be undef if
          # remove_metaclass_by_name is called explicitly (since the hash
          # entry is removed first, and then this destructor is called),
          # or that $current_meta can be the same as $self, which happens
          # when the metaclass goes out of scope (since the weak reference
          # in the metaclass cache won't be freed until after this
          # destructor runs).
          my $current_meta = Class::MOP::get_metaclass_by_name($name);
          return if defined($current_meta) && $current_meta ne $self;
  
          my ($first_fragments, $last_fragment) = ($name =~ /^(.*)::(.*)$/);
  
          no strict 'refs';
          # clear @ISA first, to avoid a memory leak
          # see https://rt.perl.org/rt3/Public/Bug/Display.html?id=92708
          @{$name . '::ISA'} = ();
          %{$name . '::'}    = ();
          delete ${$first_fragments . '::'}{$last_fragment . '::'};
  
          Class::MOP::remove_metaclass_by_name($name);
  
          delete $INC{module_notional_filename($name)};
      }
  
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          # Need to quote package to avoid a problem with PPI mis-parsing this
          # as a package statement.
          'package' => $params->{package},
  
          # NOTE:
          # because of issues with the Perl API
          # to the typeglob in some versions, we
          # need to just always grab a new
          # reference to the hash in the accessor.
          # Ideally we could just store a ref and
          # it would Just Work, but oh well :\
  
          namespace => \undef,
  
      } => $class;
  }
  
  # Attributes
  
  # NOTE:
  # all these attribute readers will be bootstrapped
  # away in the Class::MOP bootstrap section
  
  sub _package_stash {
      $_[0]->{_package_stash} ||= Package::Stash->new($_[0]->name)
  }
  sub namespace {
      $_[0]->_package_stash->namespace
  }
  
  # Class attributes
  
  # ... these functions have to touch the symbol table itself,.. yuk
  
  sub add_package_symbol {
      my $self = shift;
      $self->_package_stash->add_symbol(@_);
  }
  
  sub remove_package_glob {
      my $self = shift;
      $self->_package_stash->remove_glob(@_);
  }
  
  # ... these functions deal with stuff on the namespace level
  
  sub has_package_symbol {
      my $self = shift;
      $self->_package_stash->has_symbol(@_);
  }
  
  sub get_package_symbol {
      my $self = shift;
      $self->_package_stash->get_symbol(@_);
  }
  
  sub get_or_add_package_symbol {
      my $self = shift;
      $self->_package_stash->get_or_add_symbol(@_);
  }
  
  sub remove_package_symbol {
      my $self = shift;
      $self->_package_stash->remove_symbol(@_);
  }
  
  sub list_all_package_symbols {
      my $self = shift;
      $self->_package_stash->list_all_symbols(@_);
  }
  
  sub get_all_package_symbols {
      my $self = shift;
      $self->_package_stash->get_all_symbols(@_);
  }
  
  1;
  
  # ABSTRACT: Package Meta Object
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Package - Package Meta Object
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  The Package Protocol provides an abstraction of a Perl 5 package. A
  package is basically namespace, and this module provides methods for
  looking at and changing that namespace's symbol table.
  
  =head1 METHODS
  
  =head2 Class::MOP::Package->initialize($package_name, %options)
  
  This method creates a new C<Class::MOP::Package> instance which
  represents specified package. If an existing metaclass object exists
  for the package, that will be returned instead. No options are valid at the
  package level.
  
  =head2 Class::MOP::Package->reinitialize($package, %options)
  
  This method forcibly removes any existing metaclass for the package
  before calling C<initialize>. In contrast to C<initialize>, you may
  also pass an existing C<Class::MOP::Package> instance instead of just
  a package name as C<$package>.
  
  Do not call this unless you know what you are doing.
  
  =head2 Class::MOP::Package->create($package, %options)
  
  Creates a new C<Class::MOP::Package> instance which represents the specified
  package, and also does some initialization of that package. Currently, this
  just does the same thing as C<initialize>, but is overridden in subclasses,
  such as C<Class::MOP::Class>.
  
  =head2 Class::MOP::Package->create_anon(%options)
  
  Creates a new anonymous package. Valid keys for C<%options> are:
  
  =over 4
  
  =item C<cache>
  
  If this will be C<true> (the default is C<false>), the instance will be cached
  in C<Class::MOP>'s metaclass cache.
  
  =item C<weaken>
  
  If this is C<true> (the default C<true> when L<cache> is C<false>), the instance
  stored in C<Class::MOP>'s metaclass cache will be weakened, so that the
  anonymous package will be garbage collected when the returned instance goes out
  of scope.
  
  =back
  
  =head2 $metapackage->is_anon
  
  Returns true if the package is an anonymous package.
  
  =head2 $metapackage->name
  
  This is returns the package's name, as passed to the constructor.
  
  =head2 $metapackage->namespace
  
  This returns a hash reference to the package's symbol table. The keys
  are symbol names and the values are typeglob references.
  
  =head2 $metapackage->add_package_symbol($variable_name, $initial_value)
  
  This method accepts a variable name and an optional initial value. The
  C<$variable_name> must contain a leading sigil.
  
  This method creates the variable in the package's symbol table, and
  sets it to the initial value if one was provided.
  
  =head2 $metapackage->get_package_symbol($variable_name)
  
  Given a variable name, this method returns the variable as a reference
  or undef if it does not exist. The C<$variable_name> must contain a
  leading sigil.
  
  =head2 $metapackage->get_or_add_package_symbol($variable_name)
  
  Given a variable name, this method returns the variable as a reference.
  If it does not exist, a default value will be generated if possible. The
  C<$variable_name> must contain a leading sigil.
  
  =head2 $metapackage->has_package_symbol($variable_name)
  
  Returns true if there is a package variable defined for
  C<$variable_name>. The C<$variable_name> must contain a leading sigil.
  
  =head2 $metapackage->remove_package_symbol($variable_name)
  
  This will remove the package variable specified C<$variable_name>. The
  C<$variable_name> must contain a leading sigil.
  
  =head2 $metapackage->remove_package_glob($glob_name)
  
  Given the name of a glob, this will remove that glob from the
  package's symbol table. Glob names do not include a sigil. Removing
  the glob removes all variables and subroutines with the specified
  name.
  
  =head2 $metapackage->list_all_package_symbols($type_filter)
  
  This will list all the glob names associated with the current
  package. These names do not have leading sigils.
  
  You can provide an optional type filter, which should be one of
  'SCALAR', 'ARRAY', 'HASH', or 'CODE'.
  
  =head2 $metapackage->get_all_package_symbols($type_filter)
  
  This works much like C<list_all_package_symbols>, but it returns a
  hash reference. The keys are glob names and the values are references
  to the value for that name.
  
  =head2 Class::MOP::Package->meta
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_CLASS_MOP_PACKAGE

$fatpacked{"darwin-2level/Moose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE';
  use strict;
  use warnings;
  package Moose; # git description: 2.2010-13-g18a585ef2
  our $VERSION = '2.2011';
  our $AUTHORITY = 'cpan:STEVAN';
  
  use 5.008003;
  
  use Scalar::Util ();
  use Carp         'carp';
  use Module::Runtime 'module_notional_filename';
  use Class::Load  'is_class_loaded';
  
  use Moose::Deprecated;
  use Moose::Exporter;
  
  use Class::MOP;
  
  die "Class::MOP version $Moose::VERSION required--this is version $Class::MOP::VERSION"
      if $Class::MOP::VERSION ne $Moose::VERSION;
  
  use Moose::Meta::Class;
  use Moose::Meta::TypeConstraint;
  use Moose::Meta::TypeCoercion;
  use Moose::Meta::Attribute;
  use Moose::Meta::Instance;
  
  use Moose::Object;
  
  use Moose::Meta::Role;
  use Moose::Meta::Role::Composite;
  use Moose::Meta::Role::Application;
  use Moose::Meta::Role::Application::RoleSummation;
  use Moose::Meta::Role::Application::ToClass;
  use Moose::Meta::Role::Application::ToRole;
  use Moose::Meta::Role::Application::ToInstance;
  
  use Moose::Util::TypeConstraints;
  use Moose::Util 'throw_exception';
  
  use Moose::Meta::Attribute::Native;
  
  sub extends {
      my $meta = shift;
  
      unless ( @_ )
      {
          throw_exception( ExtendsMissingArgs => class_name => $meta->name );
      }
      # this checks the metaclass to make sure
      # it is correct, sometimes it can get out
      # of sync when the classes are being built
      $meta->superclasses(@_);
  }
  
  sub with {
      Moose::Util::apply_all_roles(shift, @_);
  }
  
  sub throw_error {
      shift;
      Class::MOP::Object->throw_error(@_);
  }
  
  sub has {
      my $meta = shift;
      my $name = shift;
  
      my %context = Moose::Util::_caller_info;
      $context{context} = 'has declaration';
      $context{type} = 'class';
      my @options = ( definition_context => \%context, @_ );
      my $attrs = ( ref($name) eq 'ARRAY' ) ? $name : [ ($name) ];
      $meta->add_attribute( $_, @options ) for @$attrs;
  }
  
  sub before {
      Moose::Util::add_method_modifier(shift, 'before', \@_);
  }
  
  sub after {
      Moose::Util::add_method_modifier(shift, 'after', \@_);
  }
  
  sub around {
      Moose::Util::add_method_modifier(shift, 'around', \@_);
  }
  
  our $SUPER_PACKAGE;
  our $SUPER_BODY;
  our @SUPER_ARGS;
  
  sub super {
      if (@_) {
          carp 'Arguments passed to super() are ignored';
      }
  
      # This check avoids a recursion loop - see
      # t/bugs/super_recursion.t
      return if defined $SUPER_PACKAGE && $SUPER_PACKAGE ne caller();
      return unless $SUPER_BODY; $SUPER_BODY->(@SUPER_ARGS);
  }
  
  sub override {
      my $meta = shift;
      my ( $name, $method ) = @_;
      $meta->add_override_method_modifier( $name => $method );
  }
  
  sub inner {
      my $pkg = caller();
      our ( %INNER_BODY, %INNER_ARGS );
  
      if ( my $body = $INNER_BODY{$pkg} ) {
          my @args = @{ $INNER_ARGS{$pkg} };
          local $INNER_ARGS{$pkg};
          local $INNER_BODY{$pkg};
          return $body->(@args);
      } else {
          return;
      }
  }
  
  sub augment {
      my $meta = shift;
      my ( $name, $method ) = @_;
      $meta->add_augment_method_modifier( $name => $method );
  }
  
  Moose::Exporter->setup_import_methods(
      with_meta => [
          qw( extends with has before after around override augment )
      ],
      as_is => [
          qw( super inner ),
          'Carp::confess',
          'Scalar::Util::blessed',
      ],
  );
  
  sub init_meta {
      shift;
      my %args = @_;
  
      my $class = $args{for_class}
          or throw_exception( InitMetaRequiresClass => params => \%args );
  
      my $base_class = $args{base_class} || 'Moose::Object';
      my $metaclass  = $args{metaclass}  || 'Moose::Meta::Class';
      my $meta_name  = exists $args{meta_name} ? $args{meta_name} : 'meta';
  
      throw_exception( MetaclassNotLoaded => class_name => $metaclass )
          unless is_class_loaded($metaclass);
  
      throw_exception( MetaclassMustBeASubclassOfMooseMetaClass => class_name => $metaclass )
          unless $metaclass->isa('Moose::Meta::Class');
  
      # make a subtype for each Moose class
      class_type($class)
          unless find_type_constraint($class);
  
      my $meta;
  
      if ( $meta = Class::MOP::get_metaclass_by_name($class) ) {
          unless ( $meta->isa("Moose::Meta::Class") ) {
              if ( $meta->isa('Moose::Meta::Role') ) {
                  throw_exception( MetaclassIsARoleNotASubclassOfGivenMetaclass => role_name => $class,
                                                                                   metaclass => $metaclass,
                                                                                   role      => $meta
                                 );
              } else {
                  throw_exception( MetaclassIsNotASubclassOfGivenMetaclass => class_name => $class,
                                                                              metaclass  => $metaclass,
                                                                              class      => $meta
                                 );
              }
          }
      } else {
          # no metaclass
  
          # now we check whether our ancestors have metaclass, and if so borrow that
          my ( undef, @isa ) = @{ mro::get_linear_isa($class) };
  
          foreach my $ancestor ( @isa ) {
              my $ancestor_meta = Class::MOP::get_metaclass_by_name($ancestor) || next;
  
              my $ancestor_meta_class = $ancestor_meta->_real_ref_name;
  
              # if we have an ancestor metaclass that inherits $metaclass, we use
              # that. This is like _fix_metaclass_incompatibility, but we can do it now.
  
              # the case of having an ancestry is not very common, but arises in
              # e.g. Reaction
              unless ( $metaclass->isa( $ancestor_meta_class ) ) {
                  if ( $ancestor_meta_class->isa($metaclass) ) {
                      $metaclass = $ancestor_meta_class;
                  }
              }
          }
  
          $meta = $metaclass->initialize($class);
          my $filename = module_notional_filename($meta->name);
          $INC{$filename} = '(set by Moose)'
              unless exists $INC{$filename};
      }
  
      if (defined $meta_name) {
          # also check for inherited non moose 'meta' method?
          my $existing = $meta->get_method($meta_name);
          if ($existing && !$existing->isa('Class::MOP::Method::Meta')) {
              Carp::cluck "Moose is overwriting an existing method named "
                        . "$meta_name in class $class with a method "
                        . "which returns the class's metaclass. If this is "
                        . "actually what you want, you should remove the "
                        . "existing method, otherwise, you should rename or "
                        . "disable this generated method using the "
                        . "'-meta_name' option to 'use Moose'.";
          }
          $meta->_add_meta_method($meta_name);
      }
  
      # make sure they inherit from Moose::Object
      $meta->superclasses($base_class)
        unless $meta->superclasses();
  
      return $meta;
  }
  
  # This may be used in some older MooseX extensions.
  sub _get_caller {
      goto &Moose::Exporter::_get_caller;
  }
  
  ## make 'em all immutable
  
  $_->make_immutable(
      inline_constructor => 1,
      constructor_name   => "_new",
      # these are Class::MOP accessors, so they need inlining
      inline_accessors => 1
      ) for grep { $_->is_mutable }
      map { $_->meta }
      qw(
      Moose::Meta::Attribute
      Moose::Meta::Class
      Moose::Meta::Instance
  
      Moose::Meta::TypeCoercion
      Moose::Meta::TypeCoercion::Union
  
      Moose::Meta::Method
      Moose::Meta::Method::Constructor
      Moose::Meta::Method::Destructor
      Moose::Meta::Method::Overridden
      Moose::Meta::Method::Augmented
  
      Moose::Meta::Role
      Moose::Meta::Role::Attribute
      Moose::Meta::Role::Method
      Moose::Meta::Role::Method::Required
      Moose::Meta::Role::Method::Conflicting
  
      Moose::Meta::Role::Composite
  
      Moose::Meta::Role::Application
      Moose::Meta::Role::Application::RoleSummation
      Moose::Meta::Role::Application::ToClass
      Moose::Meta::Role::Application::ToRole
      Moose::Meta::Role::Application::ToInstance
  );
  
  $_->make_immutable(
      inline_constructor => 0,
      constructor_name   => undef,
      # these are Class::MOP accessors, so they need inlining
      inline_accessors => 1
      ) for grep { $_->is_mutable }
      map { $_->meta }
      qw(
      Moose::Meta::Method::Accessor
      Moose::Meta::Method::Delegation
      Moose::Meta::Mixin::AttributeCore
  );
  
  1;
  
  # ABSTRACT: A postmodern object system for Perl 5
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose - A postmodern object system for Perl 5
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 SYNOPSIS
  
    package Point;
    use Moose; # automatically turns on strict and warnings
  
    has 'x' => (is => 'rw', isa => 'Int');
    has 'y' => (is => 'rw', isa => 'Int');
  
    sub clear {
        my $self = shift;
        $self->x(0);
        $self->y(0);
    }
  
    package Point3D;
    use Moose;
  
    extends 'Point';
  
    has 'z' => (is => 'rw', isa => 'Int');
  
    after 'clear' => sub {
        my $self = shift;
        $self->z(0);
    };
  
  =head1 DESCRIPTION
  
  Moose is an extension of the Perl 5 object system.
  
  The main goal of Moose is to make Perl 5 Object Oriented programming
  easier, more consistent, and less tedious. With Moose you can think
  more about what you want to do and less about the mechanics of OOP.
  
  Additionally, Moose is built on top of L<Class::MOP>, which is a
  metaclass system for Perl 5. This means that Moose not only makes
  building normal Perl 5 objects better, but it provides the power of
  metaclass programming as well.
  
  =head2 New to Moose?
  
  If you're new to Moose, the best place to start is the
  L<Moose::Manual> docs, followed by the L<Moose::Cookbook>. The intro
  will show you what Moose is, and how it makes Perl 5 OO better.
  
  The cookbook recipes on Moose basics will get you up to speed with
  many of Moose's features quickly. Once you have an idea of what Moose
  can do, you can use the API documentation to get more detail on
  features which interest you.
  
  =head2 Moose Extensions
  
  The C<MooseX::> namespace is the official place to find Moose extensions.
  These extensions can be found on the CPAN.  The easiest way to find them
  is to search for them (L<https://metacpan.org/search?q=MooseX::>),
  or to examine L<Task::Moose> which aims to keep an up-to-date, easily
  installable list of Moose extensions.
  
  =head1 TRANSLATIONS
  
  Much of the Moose documentation has been translated into other languages.
  
  =over 4
  
  =item Japanese
  
  Japanese docs can be found at
  L<http://perldoc.perlassociation.org/pod/Moose-Doc-JA/index.html>. The
  source POD files can be found in GitHub:
  L<http://github.com/jpa/Moose-Doc-JA>
  
  =back
  
  =head1 BUILDING CLASSES WITH MOOSE
  
  Moose makes every attempt to provide as much convenience as possible during
  class construction/definition, but still stay out of your way if you want it
  to. Here are a few items to note when building classes with Moose.
  
  When you C<use Moose>, Moose will set the class's parent class to
  L<Moose::Object>, I<unless> the class using Moose already has a parent
  class. In addition, specifying a parent with C<extends> will change the parent
  class.
  
  Moose will also manage all attributes (including inherited ones) that are
  defined with C<has>. And (assuming you call C<new>, which is inherited from
  L<Moose::Object>) this includes properly initializing all instance slots,
  setting defaults where appropriate, and performing any type constraint checking
  or coercion.
  
  =head1 PROVIDED METHODS
  
  Moose provides a number of methods to all your classes, mostly through the
  inheritance of L<Moose::Object>. There is however, one exception. By default,
  Moose will install a method named C<meta> in any class which uses
  C<Moose>. This method returns the current class's metaclass.
  
  If you'd like to rename this method, you can do so by passing the
  C<-meta_name> option when using Moose:
  
      use Moose -meta_name => 'my_meta';
  
  However, the L<Moose::Object> class I<also> provides a method named C<meta>
  which does the same thing. If your class inherits from L<Moose::Object> (which
  is the default), then you will still have a C<meta> method. However, if your
  class inherits from a parent which provides a C<meta> method of its own, your
  class will inherit that instead.
  
  If you'd like for Moose to not install a meta method at all, you can pass
  C<undef> as the C<-meta_name> option:
  
      use Moose -meta_name => undef;
  
  Again, you will still inherit C<meta> from L<Moose::Object> in this case.
  
  =head1 EXPORTED FUNCTIONS
  
  Moose will export a number of functions into the class's namespace which
  may then be used to set up the class. These functions all work directly
  on the current class.
  
  =head2 extends (@superclasses)
  
  This function will set the superclass(es) for the current class. If the parent
  classes are not yet loaded, then C<extends> tries to load them.
  
  This approach is recommended instead of C<use L<base>>/C<use L<parent>>, because
  C<use base> actually C<push>es onto the class's C<@ISA>, whereas C<extends> will
  replace it. This is important to ensure that classes which do not have
  superclasses still properly inherit from L<Moose::Object>.
  
  Each superclass can be followed by a hash reference with options. Currently,
  only L<-version|Class::MOP/Class Loading Options> is recognized:
  
      extends 'My::Parent'      => { -version => 0.01 },
              'My::OtherParent' => { -version => 0.03 };
  
  An exception will be thrown if the version requirements are not
  satisfied.
  
  =head2 with (@roles)
  
  This will apply a given set of C<@roles> to the local class.
  
  Like with C<extends>, each specified role can be followed by a hash
  reference with a L<-version|Class::MOP/Class Loading Options> option:
  
      with 'My::Role'      => { -version => 0.32 },
           'My::Otherrole' => { -version => 0.23 };
  
  The specified version requirements must be satisfied, otherwise an
  exception will be thrown.
  
  If your role takes options or arguments, they can be passed along in the
  hash reference as well.
  
  You should only use one C<with>, even if you are consuming multiple roles. If
  you consume roles using multiple C<with> statements Moose cannot detect method
  conflicts between those roles.
  
  =head2 has $name|@$names =E<gt> %options
  
  This will install an attribute of a given C<$name> into the current class. If
  the first parameter is an array reference, it will create an attribute for
  every C<$name> in the list. The C<%options> will be passed to the constructor
  for L<Moose::Meta::Attribute> (which inherits from L<Class::MOP::Attribute>),
  so the full documentation for the valid options can be found there. These are
  the most commonly used options:
  
  =over 4
  
  =item I<is =E<gt> 'rw'|'ro'>
  
  The I<is> option accepts either I<rw> (for read/write) or I<ro> (for read
  only). These will create either a read/write accessor or a read-only
  accessor respectively, using the same name as the C<$name> of the attribute.
  
  If you need more control over how your accessors are named, you can
  use the L<reader|Class::MOP::Attribute/reader>,
  L<writer|Class::MOP::Attribute/writer> and
  L<accessor|Class::MOP::Attribute/accessor> options inherited from
  L<Class::MOP::Attribute>, however if you use those, you won't need the
  I<is> option.
  
  =item I<isa =E<gt> $type_name>
  
  The I<isa> option uses Moose's type constraint facilities to set up runtime
  type checking for this attribute. Moose will perform the checks during class
  construction, and within any accessors. The C<$type_name> argument must be a
  string. The string may be either a class name or a type defined using
  Moose's type definition features. (Refer to L<Moose::Util::TypeConstraints>
  for information on how to define a new type, and how to retrieve type meta-data).
  
  =item I<coerce =E<gt> (1|0)>
  
  This will attempt to use coercion with the supplied type constraint to change
  the value passed into any accessors or constructors. You B<must> supply a type
  constraint, and that type constraint B<must> define a coercion. See
  L<Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion> for an example.
  
  =item I<does =E<gt> $role_name>
  
  This will accept the name of a role which the value stored in this attribute
  is expected to have consumed.
  
  =item I<required =E<gt> (1|0)>
  
  This marks the attribute as being required. This means a value must be
  supplied during class construction, I<or> the attribute must be lazy
  and have either a default or a builder. Note that C<required> does not
  say anything about the attribute's value, which can be C<undef>.
  
  =item I<weak_ref =E<gt> (1|0)>
  
  This will tell the class to store the value of this attribute as a weakened
  reference. If an attribute is a weakened reference, it B<cannot> also be
  coerced. Note that when a weak ref expires, the attribute's value becomes
  undefined, and is still considered to be set for purposes of predicate,
  default, etc.
  
  =item I<lazy =E<gt> (1|0)>
  
  This will tell the class to not create this slot until absolutely necessary.
  If an attribute is marked as lazy it B<must> have a default or builder
  supplied.
  
  =item I<trigger =E<gt> $code>
  
  The I<trigger> option is a CODE reference which will be called after
  the value of the attribute is set. The CODE ref is passed the
  instance itself, the updated value, and the original value if the
  attribute was already set.
  
  You B<can> have a trigger on a read-only attribute.
  
  B<NOTE:> Triggers will only fire when you B<assign> to the attribute,
  either in the constructor, or using the writer. Default and built values will
  B<not> cause the trigger to be fired.
  
  =item I<handles =E<gt> ARRAY | HASH | REGEXP | ROLE | ROLETYPE | DUCKTYPE | CODE>
  
  The I<handles> option provides Moose classes with automated delegation features.
  This is a pretty complex and powerful option. It accepts many different option
  formats, each with its own benefits and drawbacks.
  
  B<NOTE:> The class being delegated to does not need to be a Moose based class,
  which is why this feature is especially useful when wrapping non-Moose classes.
  
  All I<handles> option formats share the following traits:
  
  You cannot override a locally defined method with a delegated method; an
  exception will be thrown if you try. That is to say, if you define C<foo> in
  your class, you cannot override it with a delegated C<foo>. This is almost never
  something you would want to do, and if it is, you should do it by hand and not
  use Moose.
  
  You cannot override any of the methods found in Moose::Object, or the C<BUILD>
  and C<DEMOLISH> methods. These will not throw an exception, but will silently
  move on to the next method in the list. My reasoning for this is that you would
  almost never want to do this, since it usually breaks your class. As with
  overriding locally defined methods, if you do want to do this, you should do it
  manually, not with Moose.
  
  You do not I<need> to have a reader (or accessor) for the attribute in order
  to delegate to it. Moose will create a means of accessing the value for you,
  however this will be several times B<less> efficient then if you had given
  the attribute a reader (or accessor) to use.
  
  Below is the documentation for each option format:
  
  =over 4
  
  =item C<ARRAY>
  
  This is the most common usage for I<handles>. You basically pass a list of
  method names to be delegated, and Moose will install a delegation method
  for each one.
  
  =item C<HASH>
  
  This is the second most common usage for I<handles>. Instead of a list of
  method names, you pass a HASH ref where each key is the method name you
  want installed locally, and its value is the name of the original method
  in the class being delegated to.
  
  This can be very useful for recursive classes like trees. Here is a
  quick example (soon to be expanded into a Moose::Cookbook recipe):
  
    package Tree;
    use Moose;
  
    has 'node' => (is => 'rw', isa => 'Any');
  
    has 'children' => (
        is      => 'ro',
        isa     => 'ArrayRef',
        default => sub { [] }
    );
  
    has 'parent' => (
        is          => 'rw',
        isa         => 'Tree',
        weak_ref    => 1,
        handles     => {
            parent_node => 'node',
            siblings    => 'children',
        }
    );
  
  In this example, the Tree package gets C<parent_node> and C<siblings> methods,
  which delegate to the C<node> and C<children> methods (respectively) of the Tree
  instance stored in the C<parent> slot.
  
  You may also use an array reference to curry arguments to the original method.
  
    has 'thing' => (
        ...
        handles => { set_foo => [ set => 'foo' ] },
    );
  
    # $self->set_foo(...) calls $self->thing->set('foo', ...)
  
  The first element of the array reference is the original method name, and the
  rest is a list of curried arguments.
  
  =item C<REGEXP>
  
  The regexp option works very similar to the ARRAY option, except that it builds
  the list of methods for you. It starts by collecting all possible methods of the
  class being delegated to, then filters that list using the regexp supplied here.
  
  B<NOTE:> An I<isa> option is required when using the regexp option format. This
  is so that we can determine (at compile time) the method list from the class.
  Without an I<isa> this is just not possible.
  
  =item C<ROLE> or C<ROLETYPE>
  
  With the role option, you specify the name of a role or a
  L<role type|Moose::Meta::TypeConstraint::Role> whose "interface" then becomes
  the list of methods to handle. The "interface" can be defined as; the methods
  of the role and any required methods of the role. It should be noted that this
  does B<not> include any method modifiers or generated attribute methods (which
  is consistent with role composition).
  
  =item C<DUCKTYPE>
  
  With the duck type option, you pass a duck type object whose "interface" then
  becomes the list of methods to handle. The "interface" can be defined as the
  list of methods passed to C<duck_type> to create a duck type object. For more
  information on C<duck_type> please check
  L<Moose::Util::TypeConstraints>.
  
  =item C<CODE>
  
  This is the option to use when you really want to do something funky. You should
  only use it if you really know what you are doing, as it involves manual
  metaclass twiddling.
  
  This takes a code reference, which should expect two arguments. The first is the
  attribute meta-object this I<handles> is attached to. The second is the
  metaclass of the class being delegated to. It expects you to return a hash (not
  a HASH ref) of the methods you want mapped.
  
  =back
  
  =item I<traits =E<gt> [ @role_names ]>
  
  This tells Moose to take the list of C<@role_names> and apply them to the
  attribute meta-object. Custom attribute metaclass traits are useful for
  extending the capabilities of the I<has> keyword: they are the simplest way to
  extend the MOP, but they are still a fairly advanced topic and too much to
  cover here.
  
  See L<Metaclass and Trait Name Resolution> for details on how a trait name is
  resolved to a role name.
  
  Also see L<Moose::Cookbook::Meta::Labeled_AttributeTrait> for a metaclass
  trait example.
  
  =item I<builder> => Str
  
  The value of this key is the name of the method that will be called to obtain
  the value used to initialize the attribute. See the L<builder option docs in
  Class::MOP::Attribute|Class::MOP::Attribute/builder> and/or
  L<Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild> for more
  information.
  
  =item I<default> => SCALAR | CODE
  
  The value of this key is the default value which will initialize the attribute.
  
  NOTE: If the value is a simple scalar (string or number), then it can
  be just passed as is.  However, if you wish to initialize it with a
  HASH or ARRAY ref, then you need to wrap that inside a CODE reference.
  See the L<default option docs in
  Class::MOP::Attribute|Class::MOP::Attribute/default> for more
  information.
  
  =item I<clearer> => Str
  
  Creates a method allowing you to clear the value. See the L<clearer option
  docs in Class::MOP::Attribute|Class::MOP::Attribute/clearer> for more
  information.
  
  =item I<predicate> => Str
  
  Creates a method to perform a basic test to see if a value has been set in the
  attribute. See the L<predicate option docs in
  Class::MOP::Attribute|Class::MOP::Attribute/predicate> for more information.
  
  Note that the predicate will return true even for a C<weak_ref> attribute
  whose value has expired.
  
  =item I<documentation> => $string
  
  An arbitrary string that can be retrieved later by calling C<<
  $attr->documentation >>.
  
  =back
  
  =head2 has +$name =E<gt> %options
  
  This is variation on the normal attribute creator C<has> which allows you to
  clone and extend an attribute from a superclass or from a role. Here is an
  example of the superclass usage:
  
    package Foo;
    use Moose;
  
    has 'message' => (
        is      => 'rw',
        isa     => 'Str',
        default => 'Hello, I am a Foo'
    );
  
    package My::Foo;
    use Moose;
  
    extends 'Foo';
  
    has '+message' => (default => 'Hello I am My::Foo');
  
  What is happening here is that B<My::Foo> is cloning the C<message> attribute
  from its parent class B<Foo>, retaining the C<is =E<gt> 'rw'> and C<isa =E<gt>
  'Str'> characteristics, but changing the value in C<default>.
  
  Here is another example, but within the context of a role:
  
    package Foo::Role;
    use Moose::Role;
  
    has 'message' => (
        is      => 'rw',
        isa     => 'Str',
        default => 'Hello, I am a Foo'
    );
  
    package My::Foo;
    use Moose;
  
    with 'Foo::Role';
  
    has '+message' => (default => 'Hello I am My::Foo');
  
  In this case, we are basically taking the attribute which the role supplied
  and altering it within the bounds of this feature.
  
  Note that you can only extend an attribute from either a superclass or a role,
  you cannot extend an attribute in a role that composes over an attribute from
  another role.
  
  Aside from where the attributes come from (one from superclass, the other
  from a role), this feature works exactly the same. This feature is restricted
  somewhat, so as to try and force at least I<some> sanity into it. Most options work the same, but there are some exceptions:
  
  =over 4
  
  =item I<reader>
  
  =item I<writer>
  
  =item I<accessor>
  
  =item I<clearer>
  
  =item I<predicate>
  
  These options can be added, but cannot override a superclass definition.
  
  =item I<traits>
  
  You are allowed to B<add> additional traits to the C<traits> definition.
  These traits will be composed into the attribute, but preexisting traits
  B<are not> overridden, or removed.
  
  =back
  
  =head2 before $name|@names|\@names|qr/.../ =E<gt> sub { ... }
  
  =head2 after $name|@names|\@names|qr/.../ =E<gt> sub { ... }
  
  =head2 around $name|@names|\@names|qr/.../ =E<gt> sub { ... }
  
  These three items are syntactic sugar for the before, after, and around method
  modifier features that L<Class::MOP> provides. More information on these may be
  found in L<Moose::Manual::MethodModifiers> and the
  L<Class::MOP::Class documentation|Class::MOP::Class/"Method Modifiers">.
  
  =head2 override ($name, &sub)
  
  An C<override> method is a way of explicitly saying "I am overriding this
  method from my superclass". You can call C<super> within this method, and
  it will work as expected. The same thing I<can> be accomplished with a normal
  method call and the C<SUPER::> pseudo-package; it is really your choice.
  
  =head2 super
  
  The keyword C<super> is a no-op when called outside of an C<override> method. In
  the context of an C<override> method, it will call the next most appropriate
  superclass method with the same arguments as the original method.
  
  =head2 augment ($name, &sub)
  
  An C<augment> method, is a way of explicitly saying "I am augmenting this
  method from my superclass". Once again, the details of how C<inner> and
  C<augment> work is best described in the
  L<Moose::Cookbook::Basics::Document_AugmentAndInner>.
  
  =head2 inner
  
  The keyword C<inner>, much like C<super>, is a no-op outside of the context of
  an C<augment> method. You can think of C<inner> as being the inverse of
  C<super>; the details of how C<inner> and C<augment> work is best described in
  the L<Moose::Cookbook::Basics::Document_AugmentAndInner>.
  
  =head2 blessed
  
  This is the C<Scalar::Util::blessed> function. It is highly recommended that
  this is used instead of C<ref> anywhere you need to test for an object's class
  name.
  
  =head2 confess
  
  This is the C<Carp::confess> function, and exported here for historical
  reasons.
  
  =head1 METACLASS
  
  When you use Moose, you can specify traits which will be applied to your
  metaclass:
  
      use Moose -traits => 'My::Trait';
  
  This is very similar to the attribute traits feature. When you do
  this, your class's C<meta> object will have the specified traits
  applied to it. See L<Metaclass and Trait Name Resolution> for more
  details.
  
  =head2 Metaclass and Trait Name Resolution
  
  By default, when given a trait name, Moose simply tries to load a
  class of the same name. If such a class does not exist, it then looks
  for a class matching
  B<Moose::Meta::$type::Custom::Trait::$trait_name>. The C<$type>
  variable here will be one of B<Attribute> or B<Class>, depending on
  what the trait is being applied to.
  
  If a class with this long name exists, Moose checks to see if it has
  the method C<register_implementation>. This method is expected to
  return the I<real> class name of the trait. If there is no
  C<register_implementation> method, it will fall back to using
  B<Moose::Meta::$type::Custom::Trait::$trait> as the trait name.
  
  The lookup method for metaclasses is the same, except that it looks
  for a class matching B<Moose::Meta::$type::Custom::$metaclass_name>.
  
  If all this is confusing, take a look at
  L<Moose::Cookbook::Meta::Labeled_AttributeTrait>, which demonstrates how to
  create an attribute trait.
  
  =head1 UNIMPORTING FUNCTIONS
  
  =head2 B<unimport>
  
  Moose offers a way to remove the keywords it exports, through the C<unimport>
  method. You simply have to say C<no Moose> at the bottom of your code for this
  to work. Here is an example:
  
      package Person;
      use Moose;
  
      has 'first_name' => (is => 'rw', isa => 'Str');
      has 'last_name'  => (is => 'rw', isa => 'Str');
  
      sub full_name {
          my $self = shift;
          $self->first_name . ' ' . $self->last_name
      }
  
      no Moose; # keywords are removed from the Person package
  
  =head1 EXTENDING AND EMBEDDING MOOSE
  
  To learn more about extending Moose, we recommend checking out the
  "Extending" recipes in the L<Moose::Cookbook>, starting with
  L<Moose::Cookbook::Extending::ExtensionOverview>, which provides an overview of
  all the different ways you might extend Moose. L<Moose::Exporter> and
  L<Moose::Util::MetaRole> are the modules which provide the majority of the
  extension functionality, so reading their documentation should also be helpful.
  
  =head2 The MooseX:: namespace
  
  Generally if you're writing an extension I<for> Moose itself you'll want
  to put your extension in the C<MooseX::> namespace. This namespace is
  specifically for extensions that make Moose better or different in some
  fundamental way. It is traditionally B<not> for a package that just happens
  to use Moose. This namespace follows from the examples of the C<LWPx::>
  and C<DBIx::> namespaces that perform the same function for C<LWP> and C<DBI>
  respectively.
  
  =head1 METACLASS COMPATIBILITY AND MOOSE
  
  Metaclass compatibility is a thorny subject. You should start by
  reading the "About Metaclass compatibility" section in the
  L<Class::MOP> docs.
  
  Moose will attempt to resolve a few cases of metaclass incompatibility
  when you set the superclasses for a class, in addition to the cases that
  L<Class::MOP> handles.
  
  Moose tries to determine if the metaclasses only "differ by roles". This
  means that the parent and child's metaclass share a common ancestor in
  their respective hierarchies, and that the subclasses under the common
  ancestor are only different because of role applications. This case is
  actually fairly common when you mix and match various C<MooseX::*>
  modules, many of which apply roles to the metaclass.
  
  If the parent and child do differ by roles, Moose replaces the
  metaclass in the child with a newly created metaclass. This metaclass
  is a subclass of the parent's metaclass which does all of the roles that
  the child's metaclass did before being replaced. Effectively, this
  means the new metaclass does all of the roles done by both the
  parent's and child's original metaclasses.
  
  Ultimately, this is all transparent to you except in the case of an
  unresolvable conflict.
  
  =head1 CAVEATS
  
  It should be noted that C<super> and C<inner> B<cannot> be used in the same
  method. However, they may be combined within the same class hierarchy; see
  F<t/basics/override_augment_inner_super.t> for an example.
  
  The reason for this is that C<super> is only valid within a method
  with the C<override> modifier, and C<inner> will never be valid within an
  C<override> method. In fact, C<augment> will skip over any C<override> methods
  when searching for its appropriate C<inner>.
  
  This might seem like a restriction, but I am of the opinion that keeping these
  two features separate (yet interoperable) actually makes them easy to use, since
  their behavior is then easier to predict. Time will tell whether I am right or
  not (UPDATE: so far so good).
  
  =head1 GETTING HELP
  
  We offer both a mailing list and a very active IRC channel.
  
  The mailing list is L<mailto:moose@perl.org>. You must be subscribed to send
  a message. To subscribe, send an empty message to
  L<mailto:moose-subscribe@perl.org>
  
  You can also visit us at C<#moose> on L<irc://irc.perl.org/#moose>
  This channel is quite active, and questions at all levels (on Moose-related
  topics ;) are welcome.
  
  =head1 WHAT DOES MOOSE STAND FOR?
  
  Moose doesn't stand for one thing in particular, however, if you want, here
  are a few of our favorites. Feel free to contribute more!
  
  =over 4
  
  =item * Make Other Object Systems Envious
  
  =item * Makes Object Orientation So Easy
  
  =item * Makes Object Orientation Spiffy- Er (sorry ingy)
  
  =item * Most Other Object Systems Emasculate
  
  =item * Moose Often Ovulate Sorta Early
  
  =item * Moose Offers Often Super Extensions
  
  =item * Meta Object Obligates Salivary Excitation
  
  =item * Meta Object Orientation Syntax Extensions
  
  =item * Moo, Only Overengineered, Slow, and Execrable (blame rjbs!)
  
  =item * Massive Object-Oriented Stacktrace Emitter
  
  =back
  
  =head1 ACKNOWLEDGEMENTS
  
  =over 4
  
  =item I blame Sam Vilain for introducing me to the insanity that is meta-models.
  
  =item I blame Audrey Tang for then encouraging my meta-model habit in #perl6.
  
  =item Without Yuval "nothingmuch" Kogman this module would not be possible,
  and it certainly wouldn't have this name ;P
  
  =item The basis of the TypeContraints module was Rob Kinyon's idea
  originally, I just ran with it.
  
  =item Thanks to mst & chansen and the whole #moose posse for all the
  early ideas/feature-requests/encouragement/bug-finding.
  
  =item Thanks to David "Theory" Wheeler for meta-discussions and spelling fixes.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<http://moose.perl.org/>
  
  This is the official web home of Moose. It contains links to our public git
  repository, as well as links to a number of talks and articles on Moose and
  Moose related technologies.
  
  =item the L<Moose manual|Moose::Manual>
  
  This is an introduction to Moose which covers most of the basics.
  
  =item Modern Perl, by chromatic
  
  This is an introduction to modern Perl programming, which includes a section on
  Moose. It is available in print and as a free download from
  L<http://onyxneon.com/books/modern_perl/>.
  
  =item The Moose is flying, a tutorial by Randal Schwartz
  
  Part 1 - L<http://www.stonehenge.com/merlyn/LinuxMag/col94.html>
  
  Part 2 - L<http://www.stonehenge.com/merlyn/LinuxMag/col95.html>
  
  =item Several Moose extension modules in the C<MooseX::> namespace.
  
  See L<https://metacpan.org/search?q=MooseX::> for extensions.
  
  =back
  
  =head2 Books
  
  =over 4
  
  =item The Art of the MetaObject Protocol
  
  I mention this in the L<Class::MOP> docs too, as this book was critical in
  the development of both modules and is highly recommended.
  
  =back
  
  =head2 Papers
  
  =over 4
  
  =item L<http://www.cs.utah.edu/plt/publications/oopsla04-gff.pdf>
  
  This paper (suggested by lbr on #moose) was what lead to the implementation
  of the C<super>/C<override> and C<inner>/C<augment> features. If you really
  want to understand them, I suggest you read this.
  
  =back
  
  =head1 BUGS
  
  All complex software has bugs lurking in it, and this module is no
  exception.
  
  Please report any bugs to C<bug-moose@rt.cpan.org>, or through the web
  interface at L<http://rt.cpan.org>. You can also submit a C<TODO> test as a
  pull request at L<https://github.com/moose/Moose>.
  
  You can also discuss feature requests or possible bugs on the Moose mailing
  list (moose@perl.org) or on IRC at L<irc://irc.perl.org/#moose>.
  
  =head1 FEATURE REQUESTS
  
  We are very strict about what features we add to the Moose core, especially
  the user-visible features. Instead we have made sure that the underlying
  meta-system of Moose is as extensible as possible so that you can add your
  own features easily.
  
  That said, occasionally there is a feature needed in the meta-system
  to support your planned extension, in which case you should either
  email the mailing list (moose@perl.org) or join us on IRC at
  L<irc://irc.perl.org/#moose> to discuss. The
  L<Moose::Manual::Contributing> has more detail about how and when you
  can contribute.
  
  =head1 CABAL
  
  There are only a few people with the rights to release a new version
  of Moose. The Moose Cabal are the people to go to with questions regarding
  the wider purview of Moose. They help maintain not just the code
  but the community as well. See the list below under C<AUTHORS>.
  
  =head1 CONTRIBUTORS
  
  Moose is a community project, and as such, involves the work of many, many
  members of the community beyond just the members in the cabal. In particular:
  
  Dave (autarch) Rolsky wrote most of the documentation in L<Moose::Manual>.
  
  John (jgoulah) Goulah wrote L<Moose::Cookbook::Snack::Keywords>.
  
  Jess (castaway) Robinson wrote L<Moose::Cookbook::Snack::Types>.
  
  Aran (bluefeet) Clary Deltac wrote
  L<Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion>.
  
  Anders (Debolaz) Nor Berle contributed L<Test::Moose> and L<Moose::Util>.
  
  Also, the code in L<Moose::Meta::Attribute::Native> is based on code from the
  L<MooseX::AttributeHelpers> distribution, which had contributions from:
  
  Chris (perigrin) Prather
  
  Cory (gphat) Watson
  
  Evan Carroll
  
  Florian (rafl) Ragwitz
  
  Jason May
  
  Jay Hannah
  
  Jesse (doy) Luehrs
  
  Paul (frodwith) Driver
  
  Robert (rlb3) Boone
  
  Robert Buels
  
  Robert (phaylon) Sedlacek
  
  Shawn (Sartak) Moore
  
  Stevan Little
  
  Tom (dec) Lanyon
  
  Yuval Kogman
  
  Finally, these people also contributed various tests, bug fixes,
  documentation, and features to the Moose codebase:
  
  Aankhen
  
  Adam (Alias) Kennedy
  
  Christian (chansen) Hansen
  
  Cory (gphat) Watson
  
  Dylan Hardison (doc fixes)
  
  Eric (ewilhelm) Wilhelm
  
  Evan Carroll
  
  Guillermo (groditi) Roditi
  
  Jason May
  
  Jay Hannah
  
  Jonathan (jrockway) Rockway
  
  Matt (mst) Trout
  
  Nathan (kolibrie) Gray
  
  Paul (frodwith) Driver
  
  Piotr (dexter) Roszatycki
  
  Robert Buels
  
  Robert (phaylon) Sedlacek
  
  Robert (rlb3) Boone
  
  Sam (mugwump) Vilain
  
  Scott (konobi) McWhirter
  
  Shlomi (rindolf) Fish
  
  Tom (dec) Lanyon
  
  Wallace (wreis) Reis
  
  ... and many other #moose folks
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE

$fatpacked{"darwin-2level/Moose/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_CONFLICTS';
  package # hide from PAUSE
      Moose::Conflicts;
  
  use strict;
  use warnings;
  
  # this module was generated with Dist::Zilla::Plugin::Conflicts 0.19
  
  use Dist::CheckConflicts
      -dist      => 'Moose',
      -conflicts => {
          'Catalyst' => '5.90049999',
          'Config::MVP' => '2.200004',
          'Devel::REPL' => '1.003020',
          'Dist::Zilla' => '5.043',
          'Dist::Zilla::Plugin::Git' => '2.016',
          'Fey' => '0.36',
          'Fey::ORM' => '0.42',
          'File::ChangeNotify' => '0.15',
          'HTTP::Throwable' => '0.017',
          'KiokuDB' => '0.51',
          'Markdent' => '0.16',
          'Mason' => '2.18',
          'Moose::Autobox' => '0.15',
          'MooseX::ABC' => '0.05',
          'MooseX::Aliases' => '0.08',
          'MooseX::AlwaysCoerce' => '0.13',
          'MooseX::App' => '1.22',
          'MooseX::Attribute::Deflator' => '2.1.7',
          'MooseX::Attribute::Dependent' => '1.1.3',
          'MooseX::Attribute::Prototype' => '0.10',
          'MooseX::AttributeHelpers' => '0.22',
          'MooseX::AttributeIndexes' => '1.0.0',
          'MooseX::AttributeInflate' => '0.02',
          'MooseX::CascadeClearing' => '0.03',
          'MooseX::ClassAttribute' => '0.26',
          'MooseX::Constructor::AllErrors' => '0.021',
          'MooseX::Declare' => '0.35',
          'MooseX::FollowPBP' => '0.02',
          'MooseX::Getopt' => '0.56',
          'MooseX::InstanceTracking' => '0.04',
          'MooseX::LazyRequire' => '0.06',
          'MooseX::Meta::Attribute::Index' => '0.04',
          'MooseX::Meta::Attribute::Lvalue' => '0.05',
          'MooseX::Method::Signatures' => '0.44',
          'MooseX::MethodAttributes' => '0.22',
          'MooseX::NonMoose' => '0.24',
          'MooseX::Object::Pluggable' => '0.0011',
          'MooseX::POE' => '0.214',
          'MooseX::Params::Validate' => '0.05',
          'MooseX::PrivateSetters' => '0.03',
          'MooseX::Role::Cmd' => '0.06',
          'MooseX::Role::Parameterized' => '1.00',
          'MooseX::Role::WithOverloading' => '0.14',
          'MooseX::Runnable' => '0.03',
          'MooseX::Scaffold' => '0.05',
          'MooseX::SemiAffordanceAccessor' => '0.05',
          'MooseX::SetOnce' => '0.100473',
          'MooseX::Singleton' => '0.25',
          'MooseX::SlurpyConstructor' => '1.1',
          'MooseX::Storage' => '0.42',
          'MooseX::StrictConstructor' => '0.12',
          'MooseX::Traits' => '0.11',
          'MooseX::Types' => '0.19',
          'MooseX::Types::Parameterizable' => '0.05',
          'MooseX::Types::Set::Object' => '0.03',
          'MooseX::Types::Signal' => '1.101930',
          'MooseX::UndefTolerant' => '0.11',
          'Net::Twitter' => '4.01041',
          'PRANG' => '0.14',
          'Pod::Elemental' => '0.093280',
          'Pod::Weaver' => '3.101638',
          'Reaction' => '0.002003',
          'Test::Able' => '0.10',
          'Test::CleanNamespaces' => '0.03',
          'Test::Moose::More' => '0.022',
          'Test::TempDir' => '0.05',
          'Throwable' => '0.102080',
          'namespace::autoclean' => '0.08',
      },
      -also => [ qw(
          Carp
          Class::Load
          Class::Load::XS
          Data::OptList
          Devel::GlobalDestruction
          Devel::OverloadInfo
          Devel::StackTrace
          Dist::CheckConflicts
          Eval::Closure
          List::Util
          MRO::Compat
          Module::Runtime
          Module::Runtime::Conflicts
          Package::DeprecationManager
          Package::Stash
          Package::Stash::XS
          Params::Util
          Scalar::Util
          Sub::Exporter
          Sub::Identify
          Sub::Name
          Try::Tiny
          parent
          strict
          warnings
      ) ],
  
  ;
  
  1;
  
  # ABSTRACT: Provide information on conflicts for Moose
  # Dist::Zilla: -PodWeaver
DARWIN-2LEVEL_MOOSE_CONFLICTS

$fatpacked{"darwin-2level/Moose/Deprecated.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_DEPRECATED';
  package Moose::Deprecated;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Package::DeprecationManager 0.07 -deprecations => {
      'non-arrayref form of enum'         => '2.1100',
      'non-arrayref form of duck_type'    => '2.1100',
      },
      -ignore => [qr/^(?:Class::MOP|Moose)(?:::)?/],
      ;
  
  1;
  
  # ABSTRACT: Manages deprecation warnings for Moose
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Deprecated - Manages deprecation warnings for Moose
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
      use Moose::Deprecated -api_version => $version;
  
  =head1 FUNCTIONS
  
  This module manages deprecation warnings for features that have been
  deprecated in Moose.
  
  If you specify C<< -api_version => $version >>, you can use deprecated features
  without warnings. Note that this special treatment is limited to the package
  that loads C<Moose::Deprecated>.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_DEPRECATED

$fatpacked{"darwin-2level/Moose/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION';
  package Moose::Exception;
  our $VERSION = '2.2011';
  
  use Moose;
  use Devel::StackTrace 2.03;
  
  has 'trace' => (
      is            => 'ro',
      isa           => 'Devel::StackTrace',
      builder       => '_build_trace',
      lazy          => 1,
      documentation => "This attribute is read-only and isa L<Devel::StackTrace>. ".
                       'It is lazy & dependent on $exception->message.'
  );
  
  has 'message' => (
      is            => 'ro',
      isa           => 'Defined',
      builder       => '_build_message',
      lazy          => 1,
      documentation => "This attribute is read-only and isa Defined. ".
                       "It is lazy and has a default value 'Error'."
  );
  
  use overload(
      q{""}    => 'as_string',
      bool     => sub () { 1 },
      fallback => 1,
  );
  
  sub _build_trace {
      my $self = shift;
  
      # skip frames that are method calls on the exception object, which include
      # the object itself in the arguments (but Devel::LeakTrace really ought to
      # be weakening all references in its frames)
      my $skip = 0;
      while (my @c = caller(++$skip)) {
          last if ($c[3] =~ /^(.*)::new$/ || $c[3] =~ /^\S+ (.*)::new \(defined at /)
              && $self->isa($1);
      }
      $skip++;
  
      Devel::StackTrace->new(
          message => $self->message,
          indent  => 1,
          skip_frames => $skip,
          no_refs => 1,
      );
  }
  
  sub _build_message {
      "Error";
  }
  
  sub BUILD {
      my $self = shift;
      $self->trace;
  }
  
  sub as_string {
      my $self = shift;
  
      if ( $ENV{MOOSE_FULL_EXCEPTION} ) {
          return $self->trace->as_string;
      }
  
      my @frames;
      my $last_frame;
      my $in_moose = 1;
      for my $frame ( $self->trace->frames ) {
          if ( $in_moose && $frame->package =~ /^(?:Moose|Class::MOP)(?::|$)/ )
          {
              $last_frame = $frame;
              next;
          }
          elsif ($last_frame) {
              push @frames, $last_frame;
              undef $last_frame;
          }
  
          $in_moose = 0;
          push @frames, $frame;
      }
  
      # This would be a somewhat pathological case, but who knows
      return $self->trace->as_string unless @frames;
  
      my $message = ( shift @frames )->as_string( 1, {} ) . "\n";
      $message .= join q{}, map { $_->as_string( 0, {} ) . "\n" } @frames;
  
      return $message;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
  
  # ABSTRACT: Superclass for Moose internal exceptions
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Exception - Superclass for Moose internal exceptions
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class contains attributes which are common to all Moose internal
  exception classes.
  
  =head1 WARNING WARNING WARNING
  
  If you're writing your own exception classes, you should instead prefer
  the L<Throwable> role or the L<Throwable::Error> superclass - this is
  effectively a cut-down internal fork of the latter, and not designed
  for use in user code.
  
  Of course if you're writing metaclass traits, it would then make sense to
  subclass the relevant Moose exceptions - but only then.
  
  =head1 METHODS
  
  =head2 $exception->message
  
  This attribute contains the exception message.
  
  Every subclass of L<Moose::Exception> is expected to override
  C<_build_message> method in order to construct this value.
  
  =head2 $exception->trace
  
  This attribute contains the stack trace for the given exception. It returns a
  L<Devel::StackTrace> object.
  
  =head2 $exception->as_string
  
  This method returns a stringified form of the exception, including a stack
  trace. By default, this method skips Moose-internal stack frames until it sees
  a caller outside of the Moose core. If the C<MOOSE_FULL_EXCEPTION> environment
  variable is true, these frames are included.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Moose::Manual::Exceptions>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_EXCEPTION

$fatpacked{"darwin-2level/Moose/Exception/AccessorMustReadWrite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ACCESSORMUSTREADWRITE';
  package Moose::Exception::AccessorMustReadWrite;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "Cannot define an accessor name on a read-only attribute, accessors are read/write";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ACCESSORMUSTREADWRITE

$fatpacked{"darwin-2level/Moose/Exception/AddParameterizableTypeTakesParameterizableType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ADDPARAMETERIZABLETYPETAKESPARAMETERIZABLETYPE';
  package Moose::Exception::AddParameterizableTypeTakesParameterizableType;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'type_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Type must be a Moose::Meta::TypeConstraint::Parameterizable not ".$self->type_name;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ADDPARAMETERIZABLETYPETAKESPARAMETERIZABLETYPE

$fatpacked{"darwin-2level/Moose/Exception/AddRoleTakesAMooseMetaRoleInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ADDROLETAKESAMOOSEMETAROLEINSTANCE';
  package Moose::Exception::AddRoleTakesAMooseMetaRoleInstance;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'role_to_be_added' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      "Roles must be instances of Moose::Meta::Role";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ADDROLETAKESAMOOSEMETAROLEINSTANCE

$fatpacked{"darwin-2level/Moose/Exception/AddRoleToARoleTakesAMooseMetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ADDROLETOAROLETAKESAMOOSEMETAROLE';
  package Moose::Exception::AddRoleToARoleTakesAMooseMetaRole;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'role_to_be_added' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      "Roles must be instances of Moose::Meta::Role";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ADDROLETOAROLETAKESAMOOSEMETAROLE

$fatpacked{"darwin-2level/Moose/Exception/ApplyTakesABlessedInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_APPLYTAKESABLESSEDINSTANCE';
  package Moose::Exception::ApplyTakesABlessedInstance;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'param' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      "You must pass in an blessed instance";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_APPLYTAKESABLESSEDINSTANCE

$fatpacked{"darwin-2level/Moose/Exception/AttachToClassNeedsAClassMOPClassInstanceOrASubclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ATTACHTOCLASSNEEDSACLASSMOPCLASSINSTANCEORASUBCLASS';
  package Moose::Exception::AttachToClassNeedsAClassMOPClassInstanceOrASubclass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      "You must pass a Class::MOP::Class instance (or a subclass)";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ATTACHTOCLASSNEEDSACLASSMOPCLASSINSTANCEORASUBCLASS

$fatpacked{"darwin-2level/Moose/Exception/AttributeConflictInRoles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ATTRIBUTECONFLICTINROLES';
  package Moose::Exception::AttributeConflictInRoles;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'second_role_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self             = shift;
      my $role_name        = $self->role_name;
      my $second_role_name = $self->second_role_name;
      my $attribute_name   = $self->attribute_name;
      "Role '$role_name' has encountered an attribute conflict"
      . " while being composed into '$second_role_name'."
      . " This is a fatal error and cannot be disambiguated."
      . " The conflicting attribute is named '$attribute_name'.";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ATTRIBUTECONFLICTINROLES

$fatpacked{"darwin-2level/Moose/Exception/AttributeConflictInSummation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ATTRIBUTECONFLICTINSUMMATION';
  package Moose::Exception::AttributeConflictInSummation;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role', 'Moose::Exception::Role::AttributeName';
  
  has 'second_role_name' => (
      is         => 'ro',
      isa        => 'Str',
      required   => 1,
  );
  
  sub _build_message {
      my $self = shift;
  
      my $role1     = $self->role_name;
      my $role2     = $self->second_role_name;
      my $attr_name = $self->attribute_name;
  
      return "We have encountered an attribute conflict with '$attr_name'"
             . " during role composition. "
             . " This attribute is defined in both $role1 and $role2."
             . " This is a fatal error and cannot be disambiguated.";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ATTRIBUTECONFLICTINSUMMATION

$fatpacked{"darwin-2level/Moose/Exception/AttributeExtensionIsNotSupportedInRoles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ATTRIBUTEEXTENSIONISNOTSUPPORTEDINROLES';
  package Moose::Exception::AttributeExtensionIsNotSupportedInRoles;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      "has '+attr' is not supported in roles";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ATTRIBUTEEXTENSIONISNOTSUPPORTEDINROLES

$fatpacked{"darwin-2level/Moose/Exception/AttributeIsRequired.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ATTRIBUTEISREQUIRED';
  package Moose::Exception::AttributeIsRequired;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'attribute_name' => (
      is            => 'ro',
      isa           => 'Str',
      required      => 1,
      documentation => "This attribute can be used for fetching attribute instance:\n".
                       "    my \$class = Moose::Util::find_meta( \$exception->class_name );\n".
                       "    my \$attribute = \$class->get_attribute( \$exception->attribute_name );\n",
  );
  
  has 'attribute_init_arg' => (
      is  => 'ro',
      isa => 'Str',
  );
  
  has 'params' => (
      is        => 'ro',
      isa       => 'HashRef',
      predicate => 'has_params',
  );
  
  sub _build_message {
      my $self = shift;
  
      my $name = $self->attribute_name;
      my $msg  = "Attribute ($name)";
  
      my $init_arg = $self->attribute_init_arg;
      if ( defined $init_arg && $name ne $init_arg ) {
          $msg .= ", passed as ($init_arg),";
      }
  
      $msg .= ' is required';
  
      return $msg;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ATTRIBUTEISREQUIRED

$fatpacked{"darwin-2level/Moose/Exception/AttributeMustBeAnClassMOPMixinAttributeCoreOrSubclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ATTRIBUTEMUSTBEANCLASSMOPMIXINATTRIBUTECOREORSUBCLASS';
  package Moose::Exception::AttributeMustBeAnClassMOPMixinAttributeCoreOrSubclass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'attribute' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      "Your attribute must be an instance of Class::MOP::Mixin::AttributeCore (or a subclass)";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ATTRIBUTEMUSTBEANCLASSMOPMIXINATTRIBUTECOREORSUBCLASS

$fatpacked{"darwin-2level/Moose/Exception/AttributeNamesDoNotMatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ATTRIBUTENAMESDONOTMATCH';
  package Moose::Exception::AttributeNamesDoNotMatch;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has attribute_name => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  has attribute => (
      is       => 'ro',
      isa      => 'Class::MOP::Attribute',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "attribute_name (".$self-> attribute_name.") does not match attribute->name (".$self->attribute->name.")";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ATTRIBUTENAMESDONOTMATCH

$fatpacked{"darwin-2level/Moose/Exception/AttributeValueIsNotAnObject.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ATTRIBUTEVALUEISNOTANOBJECT';
  package Moose::Exception::AttributeValueIsNotAnObject;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance', 'Moose::Exception::Role::Attribute';
  
  has 'method' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Method::Delegation',
      required => 1,
  );
  
  has 'given_value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Cannot delegate ".$self->method->name." to "
      .$self->method->delegate_to_method." because the value of "
      . $self->attribute->name . " is not an object (got '".$self->given_value."')";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ATTRIBUTEVALUEISNOTANOBJECT

$fatpacked{"darwin-2level/Moose/Exception/AttributeValueIsNotDefined.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ATTRIBUTEVALUEISNOTDEFINED';
  package Moose::Exception::AttributeValueIsNotDefined;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance', 'Moose::Exception::Role::Attribute';
  
  has 'method' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Method::Delegation',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Cannot delegate ".$self->method->name." to "
      .$self->method->delegate_to_method." because the value of "
      . $self->attribute->name . " is not defined";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ATTRIBUTEVALUEISNOTDEFINED

$fatpacked{"darwin-2level/Moose/Exception/AutoDeRefNeedsArrayRefOrHashRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_AUTODEREFNEEDSARRAYREFORHASHREF';
  package Moose::Exception::AutoDeRefNeedsArrayRefOrHashRef;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "You cannot auto-dereference anything other than a ArrayRef or HashRef on attribute (".$self->attribute_name.")";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_AUTODEREFNEEDSARRAYREFORHASHREF

$fatpacked{"darwin-2level/Moose/Exception/BadOptionFormat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_BADOPTIONFORMAT';
  package Moose::Exception::BadOptionFormat;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'option_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'option_value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      "bad accessor/reader/writer/predicate/clearer format, must be a HASH ref";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_BADOPTIONFORMAT

$fatpacked{"darwin-2level/Moose/Exception/BothBuilderAndDefaultAreNotAllowed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_BOTHBUILDERANDDEFAULTARENOTALLOWED';
  package Moose::Exception::BothBuilderAndDefaultAreNotAllowed;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "Setting both default and builder is not allowed.";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_BOTHBUILDERANDDEFAULTARENOTALLOWED

$fatpacked{"darwin-2level/Moose/Exception/BuilderDoesNotExist.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_BUILDERDOESNOTEXIST';
  package Moose::Exception::BuilderDoesNotExist;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute', 'Moose::Exception::Role::Instance';
  
  sub _build_message {
      my $self = shift;
      blessed($self->instance)." does not support builder method '".$self->attribute->builder."' for attribute '".$self->attribute->name."'";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_BUILDERDOESNOTEXIST

$fatpacked{"darwin-2level/Moose/Exception/BuilderMethodNotSupportedForAttribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_BUILDERMETHODNOTSUPPORTEDFORATTRIBUTE';
  package Moose::Exception::BuilderMethodNotSupportedForAttribute;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute', 'Moose::Exception::Role::Instance';
  
  sub _build_message {
      my $self = shift;
      blessed($self->instance)." does not support builder method '". $self->attribute->builder ."' for attribute '" . $self->attribute->name . "'";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_BUILDERMETHODNOTSUPPORTEDFORATTRIBUTE

$fatpacked{"darwin-2level/Moose/Exception/BuilderMethodNotSupportedForInlineAttribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_BUILDERMETHODNOTSUPPORTEDFORINLINEATTRIBUTE';
  package Moose::Exception::BuilderMethodNotSupportedForInlineAttribute;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance', 'Moose::Exception::Role::Class';
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'builder' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      $self->class_name." does not support builder method '". $self->builder ."' for attribute '" . $self->attribute_name . "'";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_BUILDERMETHODNOTSUPPORTEDFORINLINEATTRIBUTE

$fatpacked{"darwin-2level/Moose/Exception/BuilderMustBeAMethodName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_BUILDERMUSTBEAMETHODNAME';
  package Moose::Exception::BuilderMustBeAMethodName;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "builder must be a defined scalar value which is a method name";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_BUILDERMUSTBEAMETHODNAME

$fatpacked{"darwin-2level/Moose/Exception/CallingMethodOnAnImmutableInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CALLINGMETHODONANIMMUTABLEINSTANCE';
  package Moose::Exception::CallingMethodOnAnImmutableInstance;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The '".$self->method_name."' method cannot be called on an immutable instance";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CALLINGMETHODONANIMMUTABLEINSTANCE

$fatpacked{"darwin-2level/Moose/Exception/CallingReadOnlyMethodOnAnImmutableInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CALLINGREADONLYMETHODONANIMMUTABLEINSTANCE';
  package Moose::Exception::CallingReadOnlyMethodOnAnImmutableInstance;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The '".$self->method_name."' method is read-only when called on an immutable instance";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CALLINGREADONLYMETHODONANIMMUTABLEINSTANCE

$fatpacked{"darwin-2level/Moose/Exception/CanExtendOnlyClasses.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANEXTENDONLYCLASSES';
  package Moose::Exception::CanExtendOnlyClasses;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  sub _build_message {
      my $self      = shift;
      my $role_name = $self->role_name;
      return "You cannot inherit from a Moose Role ($role_name)";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANEXTENDONLYCLASSES

$fatpacked{"darwin-2level/Moose/Exception/CanOnlyConsumeRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANONLYCONSUMEROLE';
  package Moose::Exception::CanOnlyConsumeRole;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'role_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "You can only consume roles, ".$self->role_name." is not a Moose role";
  }
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANONLYCONSUMEROLE

$fatpacked{"darwin-2level/Moose/Exception/CanOnlyWrapBlessedCode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANONLYWRAPBLESSEDCODE';
  package Moose::Exception::CanOnlyWrapBlessedCode;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'code' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      "Can only wrap blessed CODE";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANONLYWRAPBLESSEDCODE

$fatpacked{"darwin-2level/Moose/Exception/CanReblessOnlyIntoASubclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANREBLESSONLYINTOASUBCLASS';
  package Moose::Exception::CanReblessOnlyIntoASubclass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Instance', 'Moose::Exception::Role::InstanceClass';
  
  sub _build_message {
      my $self           = shift;
      my $instance_class = $self->instance_class;
      "You may rebless only into a subclass of ($instance_class), of which (". $self->class_name .") isn't."
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANREBLESSONLYINTOASUBCLASS

$fatpacked{"darwin-2level/Moose/Exception/CanReblessOnlyIntoASuperclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANREBLESSONLYINTOASUPERCLASS';
  package Moose::Exception::CanReblessOnlyIntoASuperclass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Instance', 'Moose::Exception::Role::InstanceClass';
  
  sub _build_message {
      my $self = shift;
      "You may rebless only into a superclass of (".blessed( $self->instance )."), of which (". $self->class_name .") isn't."
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANREBLESSONLYINTOASUPERCLASS

$fatpacked{"darwin-2level/Moose/Exception/CannotAddAdditionalTypeCoercionsToUnion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTADDADDITIONALTYPECOERCIONSTOUNION';
  package Moose::Exception::CannotAddAdditionalTypeCoercionsToUnion;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'type_coercion_union_object' => (
      is       => 'ro',
      isa      => 'Moose::Meta::TypeCoercion::Union',
      required => 1
  );
  
  sub _build_message {
      return "Cannot add additional type coercions to Union types";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTADDADDITIONALTYPECOERCIONSTOUNION

$fatpacked{"darwin-2level/Moose/Exception/CannotAddAsAnAttributeToARole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTADDASANATTRIBUTETOAROLE';
  package Moose::Exception::CannotAddAsAnAttributeToARole;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'attribute_class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Cannot add a ".$self->attribute_class." as an attribute to a role";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTADDASANATTRIBUTETOAROLE

$fatpacked{"darwin-2level/Moose/Exception/CannotApplyBaseClassRolesToRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTAPPLYBASECLASSROLESTOROLE';
  package Moose::Exception::CannotApplyBaseClassRolesToRole;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Role';
  
  sub _build_message {
      "You can only apply base class roles to a Moose class, not a role.";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTAPPLYBASECLASSROLESTOROLE

$fatpacked{"darwin-2level/Moose/Exception/CannotAssignValueToReadOnlyAccessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTASSIGNVALUETOREADONLYACCESSOR';
  package Moose::Exception::CannotAssignValueToReadOnlyAccessor;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::EitherAttributeOrAttributeName';
  
  has 'value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Cannot assign a value to a read-only accessor";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTASSIGNVALUETOREADONLYACCESSOR

$fatpacked{"darwin-2level/Moose/Exception/CannotAugmentIfLocalMethodPresent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTAUGMENTIFLOCALMETHODPRESENT';
  package Moose::Exception::CannotAugmentIfLocalMethodPresent;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Method';
  
  sub _build_message {
      "Cannot add an augment method if a local method is already present";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTAUGMENTIFLOCALMETHODPRESENT

$fatpacked{"darwin-2level/Moose/Exception/CannotAugmentNoSuperMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTAUGMENTNOSUPERMETHOD';
  package Moose::Exception::CannotAugmentNoSuperMethod;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "You cannot augment '".$self->method_name."' because it has no super method";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTAUGMENTNOSUPERMETHOD

$fatpacked{"darwin-2level/Moose/Exception/CannotAutoDerefWithoutIsa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTAUTODEREFWITHOUTISA';
  package Moose::Exception::CannotAutoDerefWithoutIsa;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "You cannot auto-dereference without specifying a type constraint on attribute (".$self->attribute_name.")";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTAUTODEREFWITHOUTISA

$fatpacked{"darwin-2level/Moose/Exception/CannotAutoDereferenceTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTAUTODEREFERENCETYPECONSTRAINT';
  package Moose::Exception::CannotAutoDereferenceTypeConstraint;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute', 'Moose::Exception::Role::Instance', 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      "Can not auto de-reference the type constraint '" . $self->type_name . "'";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTAUTODEREFERENCETYPECONSTRAINT

$fatpacked{"darwin-2level/Moose/Exception/CannotCalculateNativeType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTCALCULATENATIVETYPE';
  package Moose::Exception::CannotCalculateNativeType;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance';
  
  sub _build_message {
      my $self = shift;
      "Cannot calculate native type for " . ref $self->instance;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTCALCULATENATIVETYPE

$fatpacked{"darwin-2level/Moose/Exception/CannotCallAnAbstractBaseMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTCALLANABSTRACTBASEMETHOD';
  package Moose::Exception::CannotCallAnAbstractBaseMethod;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'package_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      $self->package_name. " is an abstract base class, you must provide a constructor.";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTCALLANABSTRACTBASEMETHOD

$fatpacked{"darwin-2level/Moose/Exception/CannotCallAnAbstractMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTCALLANABSTRACTMETHOD';
  package Moose::Exception::CannotCallAnAbstractMethod;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "Abstract method";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTCALLANABSTRACTMETHOD

$fatpacked{"darwin-2level/Moose/Exception/CannotCoerceAWeakRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTCOERCEAWEAKREF';
  package Moose::Exception::CannotCoerceAWeakRef;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "You cannot have a weak reference to a coerced value on attribute (".$self->attribute_name.")";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTCOERCEAWEAKREF

$fatpacked{"darwin-2level/Moose/Exception/CannotCoerceAttributeWhichHasNoCoercion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTCOERCEATTRIBUTEWHICHHASNOCOERCION';
  package Moose::Exception::CannotCoerceAttributeWhichHasNoCoercion;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions', 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      my $name = $self->attribute_name;
      my $type = $self->type_name;
  
      return "You cannot coerce an attribute ($name) unless its type ($type) has a coercion";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTCOERCEATTRIBUTEWHICHHASNOCOERCION

$fatpacked{"darwin-2level/Moose/Exception/CannotCreateHigherOrderTypeWithoutATypeParameter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTCREATEHIGHERORDERTYPEWITHOUTATYPEPARAMETER';
  package Moose::Exception::CannotCreateHigherOrderTypeWithoutATypeParameter;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      "You cannot create a Higher Order type without a type parameter";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTCREATEHIGHERORDERTYPEWITHOUTATYPEPARAMETER

$fatpacked{"darwin-2level/Moose/Exception/CannotCreateMethodAliasLocalMethodIsPresent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTCREATEMETHODALIASLOCALMETHODISPRESENT';
  package Moose::Exception::CannotCreateMethodAliasLocalMethodIsPresent;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role', 'Moose::Exception::Role::Method';
  
  has 'role_being_applied_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'aliased_method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "Cannot create a method alias if a local method of the same name exists";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTCREATEMETHODALIASLOCALMETHODISPRESENT

$fatpacked{"darwin-2level/Moose/Exception/CannotCreateMethodAliasLocalMethodIsPresentInClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTCREATEMETHODALIASLOCALMETHODISPRESENTINCLASS';
  package Moose::Exception::CannotCreateMethodAliasLocalMethodIsPresentInClass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role', 'Moose::Exception::Role::Method', 'Moose::Exception::Role::Class';
  
  has 'aliased_method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "Cannot create a method alias if a local method of the same name exists";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTCREATEMETHODALIASLOCALMETHODISPRESENTINCLASS

$fatpacked{"darwin-2level/Moose/Exception/CannotDelegateLocalMethodIsPresent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTDELEGATELOCALMETHODISPRESENT';
  package Moose::Exception::CannotDelegateLocalMethodIsPresent;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute', 'Moose::Exception::Role::Method';
  
  sub _build_message {
      my $self = shift;
      "You cannot overwrite a locally defined method (".$self->method->name.") with a delegation";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTDELEGATELOCALMETHODISPRESENT

$fatpacked{"darwin-2level/Moose/Exception/CannotDelegateWithoutIsa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTDELEGATEWITHOUTISA';
  package Moose::Exception::CannotDelegateWithoutIsa;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  sub _build_message {
      "Cannot delegate methods based on a Regexp without a type constraint (isa)";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTDELEGATEWITHOUTISA

$fatpacked{"darwin-2level/Moose/Exception/CannotFindDelegateMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTFINDDELEGATEMETACLASS';
  package Moose::Exception::CannotFindDelegateMetaclass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  sub _build_message {
      my $self = shift;
      "Cannot find delegate metaclass for attribute ".$self->attribute->name;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTFINDDELEGATEMETACLASS

$fatpacked{"darwin-2level/Moose/Exception/CannotFindType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTFINDTYPE';
  package Moose::Exception::CannotFindType;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'type_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Cannot find type '".$self->type_name."', perhaps you forgot to load it";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTFINDTYPE

$fatpacked{"darwin-2level/Moose/Exception/CannotFindTypeGivenToMatchOnType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTFINDTYPEGIVENTOMATCHONTYPE';
  package Moose::Exception::CannotFindTypeGivenToMatchOnType;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'to_match' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'action' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'type' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $type = $self->type;
  
      return "Cannot find or parse the type '$type'"
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTFINDTYPEGIVENTOMATCHONTYPE

$fatpacked{"darwin-2level/Moose/Exception/CannotFixMetaclassCompatibility.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTFIXMETACLASSCOMPATIBILITY';
  package Moose::Exception::CannotFixMetaclassCompatibility;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'superclass' => (
      is       => 'ro',
      isa      => 'Object',
      required => 1
  );
  
  has 'metaclass_type' => (
      is       => 'ro',
      isa      => 'Str',
  );
  
  sub _build_message {
      my $self = shift;
      my $class_name = $self->class_name;
      "Can't fix metaclass incompatibility for $class_name because it is not pristine.";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTFIXMETACLASSCOMPATIBILITY

$fatpacked{"darwin-2level/Moose/Exception/CannotGenerateInlineConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTGENERATEINLINECONSTRAINT';
  package Moose::Exception::CannotGenerateInlineConstraint;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  has 'parameterizable_type_object_name' => (
      is            => 'ro',
      isa           => 'Str',
      required      => 1,
      documentation => "This attribute can be used for fetching parameterizable type constraint(Moose::Meta::TypeConstraint::Parameterizable):\n".
                       "    my \$type_constraint =  Moose::Util::TypeConstraints::find_type_constraint( \$exception->type_name );\n",
  );
  
  has 'value' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $type = $self->type_name;
  
      return "Can't generate an inline constraint for $type, since none was defined";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTGENERATEINLINECONSTRAINT

$fatpacked{"darwin-2level/Moose/Exception/CannotInitializeMooseMetaRoleComposite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTINITIALIZEMOOSEMETAROLECOMPOSITE';
  package Moose::Exception::CannotInitializeMooseMetaRoleComposite;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'role_composite' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Role::Composite',
      required => 1
  );
  
  has 'old_meta' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'args' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  sub _build_message {
      'Moose::Meta::Role::Composite instances can only be reinitialized from an existing metaclass instance';
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTINITIALIZEMOOSEMETAROLECOMPOSITE

$fatpacked{"darwin-2level/Moose/Exception/CannotInlineTypeConstraintCheck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTINLINETYPECONSTRAINTCHECK';
  package Moose::Exception::CannotInlineTypeConstraintCheck;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      'Cannot inline a type constraint check for ' . $self->type_name;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTINLINETYPECONSTRAINTCHECK

$fatpacked{"darwin-2level/Moose/Exception/CannotLocatePackageInINC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTLOCATEPACKAGEININC';
  package Moose::Exception::CannotLocatePackageInINC;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'INC' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  has 'possible_packages' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'metaclass_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'type' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      my $possible_packages = $self->possible_packages;
      my @inc = @{$self->INC};
  
      return "Can't locate $possible_packages in \@INC (\@INC contains: @INC)."
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTLOCATEPACKAGEININC

$fatpacked{"darwin-2level/Moose/Exception/CannotMakeMetaclassCompatible.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTMAKEMETACLASSCOMPATIBLE';
  package Moose::Exception::CannotMakeMetaclassCompatible;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'superclass_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $class_name = $self->class_name;
      my $superclass = $self->superclass_name;
  
      return "Can't make $class_name compatible with metaclass $superclass";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTMAKEMETACLASSCOMPATIBLE

$fatpacked{"darwin-2level/Moose/Exception/CannotOverrideALocalMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTOVERRIDEALOCALMETHOD';
  package Moose::Exception::CannotOverrideALocalMethod;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Cannot add an override of method '".$self->method_name."' because there is a local version of '".$self->method_name."'";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTOVERRIDEALOCALMETHOD

$fatpacked{"darwin-2level/Moose/Exception/CannotOverrideBodyOfMetaMethods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTOVERRIDEBODYOFMETAMETHODS';
  package Moose::Exception::CannotOverrideBodyOfMetaMethods;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "Overriding the body of meta methods is not allowed";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTOVERRIDEBODYOFMETAMETHODS

$fatpacked{"darwin-2level/Moose/Exception/CannotOverrideLocalMethodIsPresent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTOVERRIDELOCALMETHODISPRESENT';
  package Moose::Exception::CannotOverrideLocalMethodIsPresent;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Method';
  
  sub _build_message {
      "Cannot add an override method if a local method is already present";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTOVERRIDELOCALMETHODISPRESENT

$fatpacked{"darwin-2level/Moose/Exception/CannotOverrideNoSuperMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTOVERRIDENOSUPERMETHOD';
  package Moose::Exception::CannotOverrideNoSuperMethod;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "You cannot override '".$self->method_name."' because it has no super method";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTOVERRIDENOSUPERMETHOD

$fatpacked{"darwin-2level/Moose/Exception/CannotRegisterUnnamedTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTREGISTERUNNAMEDTYPECONSTRAINT';
  package Moose::Exception::CannotRegisterUnnamedTypeConstraint;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "can't register an unnamed type constraint";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTREGISTERUNNAMEDTYPECONSTRAINT

$fatpacked{"darwin-2level/Moose/Exception/CannotUseLazyBuildAndDefaultSimultaneously.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTUSELAZYBUILDANDDEFAULTSIMULTANEOUSLY';
  package Moose::Exception::CannotUseLazyBuildAndDefaultSimultaneously;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "You can not use lazy_build and default for the same attribute (".$self->attribute_name.")";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CANNOTUSELAZYBUILDANDDEFAULTSIMULTANEOUSLY

$fatpacked{"darwin-2level/Moose/Exception/CircularReferenceInAlso.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CIRCULARREFERENCEINALSO';
  package Moose::Exception::CircularReferenceInAlso;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'also_parameter' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'stack' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $also_member = $self->also_parameter;
  
      my @stack = @{$self->stack};
      my $existing_stack = join( ', ', @stack);
  
      return "Circular reference in 'also' parameter to Moose::Exporter between "
             ."$existing_stack and $also_member";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CIRCULARREFERENCEINALSO

$fatpacked{"darwin-2level/Moose/Exception/ClassDoesNotHaveInitMeta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CLASSDOESNOTHAVEINITMETA';
  package Moose::Exception::ClassDoesNotHaveInitMeta;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'traits' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $class = $self->class_name;
  
      return "Cannot provide traits when $class does not have an init_meta() method";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CLASSDOESNOTHAVEINITMETA

$fatpacked{"darwin-2level/Moose/Exception/ClassDoesTheExcludedRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CLASSDOESTHEEXCLUDEDROLE';
  package Moose::Exception::ClassDoesTheExcludedRole;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role', 'Moose::Exception::Role::Class';
  
  has 'excluded_role_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self               = shift;
      my $excluded_role_name = $self->excluded_role_name;
      my $class_name         = $self->class_name;
      return "The class $class_name does the excluded role '$excluded_role_name'";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CLASSDOESTHEEXCLUDEDROLE

$fatpacked{"darwin-2level/Moose/Exception/ClassNamesDoNotMatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CLASSNAMESDONOTMATCH';
  package Moose::Exception::ClassNamesDoNotMatch;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has class_name => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  has class => (
      is       => 'ro',
      isa      => 'Class::MOP::Class',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "class_name (".$self-> class_name.") does not match class->name (".$self->class->name.")";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CLASSNAMESDONOTMATCH

$fatpacked{"darwin-2level/Moose/Exception/CloneObjectExpectsAnInstanceOfMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CLONEOBJECTEXPECTSANINSTANCEOFMETACLASS';
  package Moose::Exception::CloneObjectExpectsAnInstanceOfMetaclass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'instance' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "You must pass an instance of the metaclass (" .$self->class_name. "), not (".$self->instance.")";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CLONEOBJECTEXPECTSANINSTANCEOFMETACLASS

$fatpacked{"darwin-2level/Moose/Exception/CodeBlockMustBeACodeRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CODEBLOCKMUSTBEACODEREF';
  package Moose::Exception::CodeBlockMustBeACodeRef;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Instance';
  
  sub _build_message {
      "Your code block must be a CODE reference";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CODEBLOCKMUSTBEACODEREF

$fatpacked{"darwin-2level/Moose/Exception/CoercingWithoutCoercions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_COERCINGWITHOUTCOERCIONS';
  package Moose::Exception::CoercingWithoutCoercions;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      "Cannot coerce without a type coercion";
  }
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_COERCINGWITHOUTCOERCIONS

$fatpacked{"darwin-2level/Moose/Exception/CoercionAlreadyExists.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_COERCIONALREADYEXISTS';
  package Moose::Exception::CoercionAlreadyExists;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance';
  
  has 'constraint_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "A coercion action already exists for '".$self->constraint_name."'";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_COERCIONALREADYEXISTS

$fatpacked{"darwin-2level/Moose/Exception/CoercionNeedsTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_COERCIONNEEDSTYPECONSTRAINT';
  package Moose::Exception::CoercionNeedsTypeConstraint;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "You cannot have coercion without specifying a type constraint on attribute (".$self->attribute_name.")";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_COERCIONNEEDSTYPECONSTRAINT

$fatpacked{"darwin-2level/Moose/Exception/ConflictDetectedInCheckRoleExclusions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CONFLICTDETECTEDINCHECKROLEEXCLUSIONS';
  package Moose::Exception::ConflictDetectedInCheckRoleExclusions;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'excluded_role_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self               = shift;
      my $role_name          = $self->role_name;
      my $excluded_role_name = $self->excluded_role_name;
      return "Conflict detected: $role_name excludes role '$excluded_role_name'";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CONFLICTDETECTEDINCHECKROLEEXCLUSIONS

$fatpacked{"darwin-2level/Moose/Exception/ConflictDetectedInCheckRoleExclusionsInToClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CONFLICTDETECTEDINCHECKROLEEXCLUSIONSINTOCLASS';
  package Moose::Exception::ConflictDetectedInCheckRoleExclusionsInToClass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Role';
  
  sub _build_message {
      my $self       = shift;
      my $class_name = $self->class_name;
      my $role_name  = $self->role_name;
      return "Conflict detected: $class_name excludes role '$role_name'";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CONFLICTDETECTEDINCHECKROLEEXCLUSIONSINTOCLASS

$fatpacked{"darwin-2level/Moose/Exception/ConstructClassInstanceTakesPackageName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CONSTRUCTCLASSINSTANCETAKESPACKAGENAME';
  package Moose::Exception::ConstructClassInstanceTakesPackageName;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "You must pass a package name";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CONSTRUCTCLASSINSTANCETAKESPACKAGENAME

$fatpacked{"darwin-2level/Moose/Exception/CouldNotCreateMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_COULDNOTCREATEMETHOD';
  package Moose::Exception::CouldNotCreateMethod;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'option_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'option_value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'error' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Could not create the '".$self->option_name."' method for " . $self->attribute->name . " because : ".$self->error;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_COULDNOTCREATEMETHOD

$fatpacked{"darwin-2level/Moose/Exception/CouldNotCreateWriter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_COULDNOTCREATEWRITER';
  package Moose::Exception::CouldNotCreateWriter;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::EitherAttributeOrAttributeName', 'Moose::Exception::Role::Instance';
  
  has 'error' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $error = $self->error;
      my $attribute_name = $self->attribute_name;
  
      return "Could not create writer for '$attribute_name' "
          . "because $error";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_COULDNOTCREATEWRITER

$fatpacked{"darwin-2level/Moose/Exception/CouldNotEvalConstructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_COULDNOTEVALCONSTRUCTOR';
  package Moose::Exception::CouldNotEvalConstructor;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'constructor_method' => (
      is       => 'ro',
      isa      => 'Class::MOP::Method::Constructor',
      required => 1
  );
  
  has 'source' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'error' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $error = $self->error;
      my $source = $self->source;
  
      return "Could not eval the constructor :\n\n$source\n\nbecause :\n\n$error";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_COULDNOTEVALCONSTRUCTOR

$fatpacked{"darwin-2level/Moose/Exception/CouldNotEvalDestructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_COULDNOTEVALDESTRUCTOR';
  package Moose::Exception::CouldNotEvalDestructor;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'method_destructor_object' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Method::Destructor',
      required => 1
  );
  
  has 'source' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'error' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $error = $self->error;
      my $source = $self->source;
  
      return "Could not eval the destructor :\n\n$source\n\nbecause :\n\n$error";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_COULDNOTEVALDESTRUCTOR

$fatpacked{"darwin-2level/Moose/Exception/CouldNotFindTypeConstraintToCoerceFrom.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_COULDNOTFINDTYPECONSTRAINTTOCOERCEFROM';
  package Moose::Exception::CouldNotFindTypeConstraintToCoerceFrom;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance';
  
  has 'constraint_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Could not find the type constraint (".$self->constraint_name.") to coerce from";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_COULDNOTFINDTYPECONSTRAINTTOCOERCEFROM

$fatpacked{"darwin-2level/Moose/Exception/CouldNotGenerateInlineAttributeMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_COULDNOTGENERATEINLINEATTRIBUTEMETHOD';
  package Moose::Exception::CouldNotGenerateInlineAttributeMethod;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance';
  
  has 'option' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'error' => (
      is       => 'ro',
      isa      => 'Str|Moose::Exception',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Could not generate inline ".$self->option." because : ".$self->error;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_COULDNOTGENERATEINLINEATTRIBUTEMETHOD

$fatpacked{"darwin-2level/Moose/Exception/CouldNotLocateTypeConstraintForUnion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_COULDNOTLOCATETYPECONSTRAINTFORUNION';
  package Moose::Exception::CouldNotLocateTypeConstraintForUnion;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      "Could not locate type constraint (".$self->type_name.") for the union";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_COULDNOTLOCATETYPECONSTRAINTFORUNION

$fatpacked{"darwin-2level/Moose/Exception/CouldNotParseType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_COULDNOTPARSETYPE';
  package Moose::Exception::CouldNotParseType;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'type' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'position' => (
      is       => 'ro',
      isa      => 'Int',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $type = $self->type;
      my $length = length($type);
      my $position = $self->position;
  
      return "'$type' didn't parse (parse-pos=$position"
          . " and str-length=$length)";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_COULDNOTPARSETYPE

$fatpacked{"darwin-2level/Moose/Exception/CreateMOPClassTakesArrayRefOfAttributes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESARRAYREFOFATTRIBUTES';
  package Moose::Exception::CreateMOPClassTakesArrayRefOfAttributes;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::RoleForCreateMOPClass';
  
  sub _build_message {
      "You must pass an ARRAY ref of attributes";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESARRAYREFOFATTRIBUTES

$fatpacked{"darwin-2level/Moose/Exception/CreateMOPClassTakesArrayRefOfSuperclasses.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESARRAYREFOFSUPERCLASSES';
  package Moose::Exception::CreateMOPClassTakesArrayRefOfSuperclasses;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::RoleForCreateMOPClass';
  
  sub _build_message {
      "You must pass an ARRAY ref of superclasses";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESARRAYREFOFSUPERCLASSES

$fatpacked{"darwin-2level/Moose/Exception/CreateMOPClassTakesHashRefOfMethods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESHASHREFOFMETHODS';
  package Moose::Exception::CreateMOPClassTakesHashRefOfMethods;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::RoleForCreateMOPClass';
  
  sub _build_message {
      "You must pass an HASH ref of methods";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESHASHREFOFMETHODS

$fatpacked{"darwin-2level/Moose/Exception/CreateTakesArrayRefOfRoles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CREATETAKESARRAYREFOFROLES';
  package Moose::Exception::CreateTakesArrayRefOfRoles;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::RoleForCreate';
  
  sub _build_message {
      "You must pass an ARRAY ref of roles";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CREATETAKESARRAYREFOFROLES

$fatpacked{"darwin-2level/Moose/Exception/CreateTakesHashRefOfAttributes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CREATETAKESHASHREFOFATTRIBUTES';
  package Moose::Exception::CreateTakesHashRefOfAttributes;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::RoleForCreate';
  
  sub _build_message {
      "You must pass a HASH ref of attributes";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CREATETAKESHASHREFOFATTRIBUTES

$fatpacked{"darwin-2level/Moose/Exception/CreateTakesHashRefOfMethods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_CREATETAKESHASHREFOFMETHODS';
  package Moose::Exception::CreateTakesHashRefOfMethods;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::RoleForCreate';
  
  sub _build_message {
      "You must pass a HASH ref of methods";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_CREATETAKESHASHREFOFMETHODS

$fatpacked{"darwin-2level/Moose/Exception/DefaultToMatchOnTypeMustBeCodeRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_DEFAULTTOMATCHONTYPEMUSTBECODEREF';
  package Moose::Exception::DefaultToMatchOnTypeMustBeCodeRef;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'to_match' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'default_action' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'cases_to_be_matched' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $default = $self->default_action;
  
      return "Default case must be a CODE ref, not $default";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_DEFAULTTOMATCHONTYPEMUSTBECODEREF

$fatpacked{"darwin-2level/Moose/Exception/DelegationToAClassWhichIsNotLoaded.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_DELEGATIONTOACLASSWHICHISNOTLOADED';
  package Moose::Exception::DelegationToAClassWhichIsNotLoaded;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'class_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "The ".$self->attribute->name." attribute is trying to delegate to a class which has not been loaded - ".$self->class_name;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_DELEGATIONTOACLASSWHICHISNOTLOADED

$fatpacked{"darwin-2level/Moose/Exception/DelegationToARoleWhichIsNotLoaded.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_DELEGATIONTOAROLEWHICHISNOTLOADED';
  package Moose::Exception::DelegationToARoleWhichIsNotLoaded;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'role_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "The ".$self->attribute->name." attribute is trying to delegate to a role which has not been loaded - ".$self->role_name;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_DELEGATIONTOAROLEWHICHISNOTLOADED

$fatpacked{"darwin-2level/Moose/Exception/DelegationToATypeWhichIsNotAClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_DELEGATIONTOATYPEWHICHISNOTACLASS';
  package Moose::Exception::DelegationToATypeWhichIsNotAClass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  sub _build_message {
      my $self = shift;
      "The ".$self->attribute->name." attribute is trying to delegate to a type (".$self->attribute->type_constraint->name.") that is not backed by a class";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_DELEGATIONTOATYPEWHICHISNOTACLASS

$fatpacked{"darwin-2level/Moose/Exception/DoesRequiresRoleName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_DOESREQUIRESROLENAME';
  package Moose::Exception::DoesRequiresRoleName;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  sub _build_message {
      "You must supply a role name to does()";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_DOESREQUIRESROLENAME

$fatpacked{"darwin-2level/Moose/Exception/EnumCalledWithAnArrayRefAndAdditionalArgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ENUMCALLEDWITHANARRAYREFANDADDITIONALARGS';
  package Moose::Exception::EnumCalledWithAnArrayRefAndAdditionalArgs;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'array' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  has 'args' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  sub _build_message {
      "enum called with an array reference and additional arguments. Did you mean to parenthesize the enum call's parameters?";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ENUMCALLEDWITHANARRAYREFANDADDITIONALARGS

$fatpacked{"darwin-2level/Moose/Exception/EnumValuesMustBeString.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ENUMVALUESMUSTBESTRING';
  package Moose::Exception::EnumValuesMustBeString;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Enum values must be strings, not ".( defined $self->value ? "'".$self->value."'" : "undef" );
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ENUMVALUESMUSTBESTRING

$fatpacked{"darwin-2level/Moose/Exception/ExtendsMissingArgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_EXTENDSMISSINGARGS';
  package Moose::Exception::ExtendsMissingArgs;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  sub _build_message {
      "Must derive at least one class";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_EXTENDSMISSINGARGS

$fatpacked{"darwin-2level/Moose/Exception/HandlesMustBeAHashRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_HANDLESMUSTBEAHASHREF';
  package Moose::Exception::HandlesMustBeAHashRef;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance';
  
  has 'given_handles' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The 'handles' option must be a HASH reference, not ".$self->given_handles;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_HANDLESMUSTBEAHASHREF

$fatpacked{"darwin-2level/Moose/Exception/IllegalInheritedOptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ILLEGALINHERITEDOPTIONS';
  package Moose::Exception::IllegalInheritedOptions;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'illegal_options' => (
      is       => 'ro',
      traits   => ['Array'],
      handles  => {
          _join_options => 'join',
      },
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Illegal inherited options => (".$self->_join_options(', ').")";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ILLEGALINHERITEDOPTIONS

$fatpacked{"darwin-2level/Moose/Exception/IllegalMethodTypeToAddMethodModifier.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ILLEGALMETHODTYPETOADDMETHODMODIFIER';
  package Moose::Exception::IllegalMethodTypeToAddMethodModifier;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'class_or_object' => (
      is       => 'ro',
      isa      => "Any",
      required => 1,
  );
  
  has 'params' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1,
  );
  
  has 'modifier_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Methods passed to ".$self->modifier_name." must be provided as a list, arrayref or regex, not ".$self->params->[0];
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ILLEGALMETHODTYPETOADDMETHODMODIFIER

$fatpacked{"darwin-2level/Moose/Exception/IncompatibleMetaclassOfSuperclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_INCOMPATIBLEMETACLASSOFSUPERCLASS';
  package Moose::Exception::IncompatibleMetaclassOfSuperclass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has [qw/superclass_name superclass_meta_type class_meta_type/] => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self            = shift;
      my $class_name      = $self->class_name;
      my $class_meta_type = $self->class_meta_type;
      my $superclass_name = $self->superclass_name;
      my $supermeta_type  = $self->superclass_meta_type;
  
      return "The metaclass of $class_name ($class_meta_type)" .
             " is not compatible with the metaclass of its superclass, " .
             "$superclass_name ($supermeta_type)";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_INCOMPATIBLEMETACLASSOFSUPERCLASS

$fatpacked{"darwin-2level/Moose/Exception/InitMetaRequiresClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_INITMETAREQUIRESCLASS';
  package Moose::Exception::InitMetaRequiresClass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  sub _build_message {
      "Cannot call init_meta without specifying a for_class";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_INITMETAREQUIRESCLASS

$fatpacked{"darwin-2level/Moose/Exception/InitializeTakesUnBlessedPackageName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_INITIALIZETAKESUNBLESSEDPACKAGENAME';
  package Moose::Exception::InitializeTakesUnBlessedPackageName;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'package_name' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      "You must pass a package name and it cannot be blessed";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_INITIALIZETAKESUNBLESSEDPACKAGENAME

$fatpacked{"darwin-2level/Moose/Exception/InstanceBlessedIntoWrongClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_INSTANCEBLESSEDINTOWRONGCLASS';
  package Moose::Exception::InstanceBlessedIntoWrongClass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Instance';
  
  sub _build_message {
      my $self = shift;
      "Objects passed as the __INSTANCE__ parameter must already be blessed into the correct class, but ".$self->instance." is not a " . $self->class_name;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_INSTANCEBLESSEDINTOWRONGCLASS

$fatpacked{"darwin-2level/Moose/Exception/InstanceMustBeABlessedReference.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_INSTANCEMUSTBEABLESSEDREFERENCE';
  package Moose::Exception::InstanceMustBeABlessedReference;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Class';
  
  has 'instance' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The __INSTANCE__ parameter must be a blessed reference, not ". $self->instance;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_INSTANCEMUSTBEABLESSEDREFERENCE

$fatpacked{"darwin-2level/Moose/Exception/InvalidArgPassedToMooseUtilMetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDARGPASSEDTOMOOSEUTILMETAROLE';
  package Moose::Exception::InvalidArgPassedToMooseUtilMetaRole;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'argument' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $error = 'When using Moose::Util::MetaRole, you must pass a Moose class name,'
          . ' role name, metaclass object, or metarole object.';
  
      my $arg = $self->argument;
      my $found = blessed $arg ? $arg : Class::MOP::class_of($arg);
  
      my $error2;
  
      if ( defined $found && blessed $found ) {
          $error2 = " You passed ".$arg.", and we resolved this to a "
              . ( blessed $found )
              . ' object.';
      }
      elsif ( !defined $found ) {
          $error2 = " You passed ".( defined $arg ? $arg : "undef" ).", and this did not resolve to a metaclass or metarole."
              . ' Maybe you need to call Moose->init_meta to initialize the metaclass first?';
      }
      else {
          $error2 = " You passed an undef."
              . ' Maybe you need to call Moose->init_meta to initialize the metaclass first?';
      }
  
      $error.$error2;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDARGPASSEDTOMOOSEUTILMETAROLE

$fatpacked{"darwin-2level/Moose/Exception/InvalidArgumentToMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDARGUMENTTOMETHOD';
  package Moose::Exception::InvalidArgumentToMethod;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'argument' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has [qw(type type_of_argument method_name)] => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'ordinal' => (
      is        => 'ro',
      isa       => 'Str',
      predicate => 'is_ordinal_set'
  );
  
  has 'argument_noun' => (
      is      => 'ro',
      isa     => 'Str',
      default => 'argument'
  );
  
  sub _build_message {
      my $self = shift;
      my $article = ( $self->type_of_argument =~ /^[aeiou]/ ? 'an ' : 'a ');
      my $arg_noun = $self->argument_noun;
  
      if( $self->is_ordinal_set ) {
          "The ".$self->ordinal." $arg_noun passed to ".$self->method_name." must be ".$article.$self->type_of_argument;
      }
      else {
          "The $arg_noun passed to ".$self->method_name." must be ".$article.$self->type_of_argument;
      }
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDARGUMENTTOMETHOD

$fatpacked{"darwin-2level/Moose/Exception/InvalidArgumentsToTraitAliases.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDARGUMENTSTOTRAITALIASES';
  package Moose::Exception::InvalidArgumentsToTraitAliases;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  use Scalar::Util qw(reftype);
  
  has 'alias' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'package_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $alias = $self->alias;
      my $reftype_alias = reftype($alias);
  
      return "$reftype_alias references are not "
          . "valid arguments to the 'trait_aliases' option";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDARGUMENTSTOTRAITALIASES

$fatpacked{"darwin-2level/Moose/Exception/InvalidBaseTypeGivenToCreateParameterizedTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDBASETYPEGIVENTOCREATEPARAMETERIZEDTYPECONSTRAINT';
  package Moose::Exception::InvalidBaseTypeGivenToCreateParameterizedTypeConstraint;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      "Could not locate the base type (".$self->type_name.")";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDBASETYPEGIVENTOCREATEPARAMETERIZEDTYPECONSTRAINT

$fatpacked{"darwin-2level/Moose/Exception/InvalidHandleValue.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDHANDLEVALUE';
  package Moose::Exception::InvalidHandleValue;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance';
  
  has 'handle_value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "All values passed to handles must be strings or ARRAY references, not ".$self->handle_value;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDHANDLEVALUE

$fatpacked{"darwin-2level/Moose/Exception/InvalidHasProvidedInARole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDHASPROVIDEDINAROLE';
  package Moose::Exception::InvalidHasProvidedInARole;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      "Usage: has 'name' => ( key => value, ... )";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDHASPROVIDEDINAROLE

$fatpacked{"darwin-2level/Moose/Exception/InvalidNameForType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDNAMEFORTYPE';
  package Moose::Exception::InvalidNameForType;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      $self->name." contains invalid characters for a type name. Names can contain alphanumeric character, ':', and '.'";
  }
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDNAMEFORTYPE

$fatpacked{"darwin-2level/Moose/Exception/InvalidOverloadOperator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDOVERLOADOPERATOR';
  package Moose::Exception::InvalidOverloadOperator;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has operator => (
      is       => 'ro',
      isa      => 'Defined',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      'The operator parameter you passed to the Moose::Meta::Overload constructor ('
          . $self->operator()
          . ') was not a valid overloading operator';
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDOVERLOADOPERATOR

$fatpacked{"darwin-2level/Moose/Exception/InvalidRoleApplication.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDROLEAPPLICATION';
  package Moose::Exception::InvalidRoleApplication;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'application' => (
      is       => 'ro',
      isa      => "Any",
      required => 1,
  );
  
  sub _build_message {
      "Role applications must be instances of Moose::Meta::Role::Application::ToClass";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDROLEAPPLICATION

$fatpacked{"darwin-2level/Moose/Exception/InvalidTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDTYPECONSTRAINT';
  package Moose::Exception::InvalidTypeConstraint;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'registry_object' => (
      is       => 'ro',
      isa      => 'Moose::Meta::TypeConstraint::Registry',
      required => 1
  );
  
  has 'type' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      return "No type supplied / type is not a valid type constraint";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDTYPECONSTRAINT

$fatpacked{"darwin-2level/Moose/Exception/InvalidTypeGivenToCreateParameterizedTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDTYPEGIVENTOCREATEPARAMETERIZEDTYPECONSTRAINT';
  package Moose::Exception::InvalidTypeGivenToCreateParameterizedTypeConstraint;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      "Could not parse type name (".$self->type_name.") correctly";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDTYPEGIVENTOCREATEPARAMETERIZEDTYPECONSTRAINT

$fatpacked{"darwin-2level/Moose/Exception/InvalidValueForIs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDVALUEFORIS';
  package Moose::Exception::InvalidValueForIs;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "I do not understand this option (is => ".$self->params->{is}.") on attribute (".$self->attribute_name.")";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_INVALIDVALUEFORIS

$fatpacked{"darwin-2level/Moose/Exception/IsaDoesNotDoTheRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ISADOESNOTDOTHEROLE';
  package Moose::Exception::IsaDoesNotDoTheRole;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "Cannot have an isa option and a does option if the isa does not do the does on attribute (".$self->attribute_name.")";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ISADOESNOTDOTHEROLE

$fatpacked{"darwin-2level/Moose/Exception/IsaLacksDoesMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ISALACKSDOESMETHOD';
  package Moose::Exception::IsaLacksDoesMethod;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "Cannot have an isa option which cannot ->does() on attribute (".$self->attribute_name.")";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ISALACKSDOESMETHOD

$fatpacked{"darwin-2level/Moose/Exception/LazyAttributeNeedsADefault.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_LAZYATTRIBUTENEEDSADEFAULT';
  package Moose::Exception::LazyAttributeNeedsADefault;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::EitherAttributeOrAttributeName';
  
  sub _build_message {
      my $self = shift;
      "You cannot have a lazy attribute (".$self->attribute_name.") without specifying a default value for it";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_LAZYATTRIBUTENEEDSADEFAULT

$fatpacked{"darwin-2level/Moose/Exception/Legacy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_LEGACY';
  package Moose::Exception::Legacy;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_LEGACY

$fatpacked{"darwin-2level/Moose/Exception/MOPAttributeNewNeedsAttributeName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MOPATTRIBUTENEWNEEDSATTRIBUTENAME';
  package Moose::Exception::MOPAttributeNewNeedsAttributeName;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must provide a name for the attribute";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MOPATTRIBUTENEWNEEDSATTRIBUTENAME

$fatpacked{"darwin-2level/Moose/Exception/MatchActionMustBeACodeRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MATCHACTIONMUSTBEACODEREF';
  package Moose::Exception::MatchActionMustBeACodeRef;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  has 'to_match' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  has 'action' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $action = $self->action;
  
      return "Match action must be a CODE ref, not $action";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MATCHACTIONMUSTBEACODEREF

$fatpacked{"darwin-2level/Moose/Exception/MessageParameterMustBeCodeRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MESSAGEPARAMETERMUSTBECODEREF';
  package Moose::Exception::MessageParameterMustBeCodeRef;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "The 'message' parameter must be a coderef";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MESSAGEPARAMETERMUSTBECODEREF

$fatpacked{"darwin-2level/Moose/Exception/MetaclassIsAClassNotASubclassOfGivenMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_METACLASSISACLASSNOTASUBCLASSOFGIVENMETACLASS';
  package Moose::Exception::MetaclassIsAClassNotASubclassOfGivenMetaclass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  use Moose::Util 'find_meta';
  
  has 'metaclass' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $class = find_meta( $self->class_name );
      $self->class_name." already has a metaclass, but it does not inherit ".$self->metaclass.
          " ($class). You cannot make the same thing a role and a class. Remove either Moose or Moose::Role.";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_METACLASSISACLASSNOTASUBCLASSOFGIVENMETACLASS

$fatpacked{"darwin-2level/Moose/Exception/MetaclassIsARoleNotASubclassOfGivenMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_METACLASSISAROLENOTASUBCLASSOFGIVENMETACLASS';
  package Moose::Exception::MetaclassIsARoleNotASubclassOfGivenMetaclass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  use Moose::Util 'find_meta';
  
  has 'metaclass' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $role_name = $self->role_name;
      my $role      = find_meta( $role_name );
      my $metaclass = $self->metaclass;
      return "$role_name already has a metaclass, but it does not inherit $metaclass ($role). "
          ."You cannot make the same thing a role and a class. Remove either Moose or Moose::Role.";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_METACLASSISAROLENOTASUBCLASSOFGIVENMETACLASS

$fatpacked{"darwin-2level/Moose/Exception/MetaclassIsNotASubclassOfGivenMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_METACLASSISNOTASUBCLASSOFGIVENMETACLASS';
  package Moose::Exception::MetaclassIsNotASubclassOfGivenMetaclass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  use Moose::Util 'find_meta';
  
  has 'metaclass' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $class = find_meta( $self->class_name );
      $self->class_name." already has a metaclass, but it does not inherit ".$self->metaclass." ($class).";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_METACLASSISNOTASUBCLASSOFGIVENMETACLASS

$fatpacked{"darwin-2level/Moose/Exception/MetaclassMustBeASubclassOfMooseMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_METACLASSMUSTBEASUBCLASSOFMOOSEMETACLASS';
  package Moose::Exception::MetaclassMustBeASubclassOfMooseMetaClass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  sub _build_message {
      my $self = shift;
      "The Metaclass ".$self->class_name." must be a subclass of Moose::Meta::Class."
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_METACLASSMUSTBEASUBCLASSOFMOOSEMETACLASS

$fatpacked{"darwin-2level/Moose/Exception/MetaclassMustBeASubclassOfMooseMetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_METACLASSMUSTBEASUBCLASSOFMOOSEMETAROLE';
  package Moose::Exception::MetaclassMustBeASubclassOfMooseMetaRole;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  sub _build_message {
      my $self = shift;
      "The Metaclass ".$self->role_name." must be a subclass of Moose::Meta::Role."
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_METACLASSMUSTBEASUBCLASSOFMOOSEMETAROLE

$fatpacked{"darwin-2level/Moose/Exception/MetaclassMustBeDerivedFromClassMOPClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_METACLASSMUSTBEDERIVEDFROMCLASSMOPCLASS';
  package Moose::Exception::MetaclassMustBeDerivedFromClassMOPClass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'class_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The metaclass (".$self->class_name.") must be derived from Class::MOP::Class";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_METACLASSMUSTBEDERIVEDFROMCLASSMOPCLASS

$fatpacked{"darwin-2level/Moose/Exception/MetaclassNotLoaded.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_METACLASSNOTLOADED';
  package Moose::Exception::MetaclassNotLoaded;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  sub _build_message {
      my $self = shift;
      "The Metaclass ".$self->class_name." must be loaded. (Perhaps you forgot to 'use ".$self->class_name."'?)";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_METACLASSNOTLOADED

$fatpacked{"darwin-2level/Moose/Exception/MetaclassTypeIncompatible.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_METACLASSTYPEINCOMPATIBLE';
  package Moose::Exception::MetaclassTypeIncompatible;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  use Moose::Util 'find_meta';
  
  has [qw(superclass_name metaclass_type)] => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $class_name = $self->class_name;
      my $superclass_name = $self->superclass_name;
      my $metaclass_type = $self->metaclass_type;
  
      my $metaclass_type_name = $metaclass_type;
      $metaclass_type_name =~ s/_(?:meta)?class$//;
      $metaclass_type_name =~ s/_/ /g;
  
      my $class = find_meta( $class_name );
  
      my $self_metaclass_type = $class->$metaclass_type;
  
      my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name);
      my $super_metatype = $super_meta->$metaclass_type;
  
     return "The $metaclass_type metaclass for $class_name"
     . " ($self_metaclass_type) is not compatible with the $metaclass_type_name"
     . " metaclass of its superclass, $superclass_name ($super_metatype)";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_METACLASSTYPEINCOMPATIBLE

$fatpacked{"darwin-2level/Moose/Exception/MethodExpectedAMetaclassObject.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_METHODEXPECTEDAMETACLASSOBJECT';
  package Moose::Exception::MethodExpectedAMetaclassObject;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'metaclass' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      "The is_needed method expected a metaclass object as its arugment";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_METHODEXPECTEDAMETACLASSOBJECT

$fatpacked{"darwin-2level/Moose/Exception/MethodExpectsFewerArgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_METHODEXPECTSFEWERARGS';
  package Moose::Exception::MethodExpectsFewerArgs;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  has 'maximum_args' => (
      is       => 'ro',
      isa      => 'Int',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      my $max = $self->maximum_args;
      "Cannot call ".$self->method_name." with ".
          ( $max ? "more than $max" : 'any'). " argument".( $max == 1 ? '' : 's' );
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_METHODEXPECTSFEWERARGS

$fatpacked{"darwin-2level/Moose/Exception/MethodExpectsMoreArgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_METHODEXPECTSMOREARGS';
  package Moose::Exception::MethodExpectsMoreArgs;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'minimum_args' => (
      is       => 'ro',
      isa      => 'Int',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Cannot call ".$self->method_name." without at least ".$self->minimum_args." argument".($self->minimum_args == 1 ? '' : 's');
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_METHODEXPECTSMOREARGS

$fatpacked{"darwin-2level/Moose/Exception/MethodModifierNeedsMethodName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_METHODMODIFIERNEEDSMETHODNAME';
  package Moose::Exception::MethodModifierNeedsMethodName;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  sub _build_message {
      "You must pass in a method name";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_METHODMODIFIERNEEDSMETHODNAME

$fatpacked{"darwin-2level/Moose/Exception/MethodNameConflictInRoles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_METHODNAMECONFLICTINROLES';
  package Moose::Exception::MethodNameConflictInRoles;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'conflict' => (
      traits     => ['Array'],
      is         => 'ro',
      isa        => 'ArrayRef[Moose::Meta::Role::Method::Conflicting]',
      handles    => { conflict_methods_count => 'count',
                      get_method_at          => 'get',
                      get_all_methods        => 'elements',
      },
      required   => 1
  );
  
  sub _get_method_names {
      my $self = shift;
  
      return ( $self->conflict_methods_count == 1 ?
          "'".$self->get_method_at(0)->name."'":
          Moose::Util::english_list( map { q{'} . $_->name . q{'} } $self->get_all_methods ) );
  }
  
  sub _build_message {
      my $self = shift;
      my $count = $self->conflict_methods_count;
      my $roles = $self->get_method_at(0)->roles_as_english_list;
  
      if( $count == 1 )
      {
          "Due to a method name conflict in roles "
          .$roles.", the method ".$self->_get_method_names
          ." must be implemented or excluded by '".$self->class_name."'";
      }
      else
      {
          "Due to method name conflicts in roles "
          .$roles.", the methods ".$self->_get_method_names
          ." must be implemented or excluded by '".$self->class_name."'";
      }
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_METHODNAMECONFLICTINROLES

$fatpacked{"darwin-2level/Moose/Exception/MethodNameNotFoundInInheritanceHierarchy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_METHODNAMENOTFOUNDININHERITANCEHIERARCHY';
  package Moose::Exception::MethodNameNotFoundInInheritanceHierarchy;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The method '".$self->method_name."' was not found in the inheritance hierarchy for ".$self->class_name;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_METHODNAMENOTFOUNDININHERITANCEHIERARCHY

$fatpacked{"darwin-2level/Moose/Exception/MethodNameNotGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_METHODNAMENOTGIVEN';
  package Moose::Exception::MethodNameNotGiven;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  sub _build_message {
      "You must define a method name to find";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_METHODNAMENOTGIVEN

$fatpacked{"darwin-2level/Moose/Exception/MustDefineAMethodName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTDEFINEAMETHODNAME';
  package Moose::Exception::MustDefineAMethodName;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance';
  
  sub _build_message {
      "You must define a method name";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTDEFINEAMETHODNAME

$fatpacked{"darwin-2level/Moose/Exception/MustDefineAnAttributeName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTDEFINEANATTRIBUTENAME';
  package Moose::Exception::MustDefineAnAttributeName;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  sub _build_message {
      "You must define an attribute name";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTDEFINEANATTRIBUTENAME

$fatpacked{"darwin-2level/Moose/Exception/MustDefineAnOverloadOperator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTDEFINEANOVERLOADOPERATOR';
  package Moose::Exception::MustDefineAnOverloadOperator;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance';
  
  sub _build_message {
      "You must define an overload operator";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTDEFINEANOVERLOADOPERATOR

$fatpacked{"darwin-2level/Moose/Exception/MustHaveAtLeastOneValueToEnumerate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTHAVEATLEASTONEVALUETOENUMERATE';
  package Moose::Exception::MustHaveAtLeastOneValueToEnumerate;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must have at least one value to enumerate through";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTHAVEATLEASTONEVALUETOENUMERATE

$fatpacked{"darwin-2level/Moose/Exception/MustPassAHashOfOptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTPASSAHASHOFOPTIONS';
  package Moose::Exception::MustPassAHashOfOptions;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must pass a hash of options";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTPASSAHASHOFOPTIONS

$fatpacked{"darwin-2level/Moose/Exception/MustPassAMooseMetaRoleInstanceOrSubclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTPASSAMOOSEMETAROLEINSTANCEORSUBCLASS';
  package Moose::Exception::MustPassAMooseMetaRoleInstanceOrSubclass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'role' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      "You must pass a Moose::Meta::Role instance (or a subclass)";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTPASSAMOOSEMETAROLEINSTANCEORSUBCLASS

$fatpacked{"darwin-2level/Moose/Exception/MustPassAPackageNameOrAnExistingClassMOPPackageInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTPASSAPACKAGENAMEORANEXISTINGCLASSMOPPACKAGEINSTANCE';
  package Moose::Exception::MustPassAPackageNameOrAnExistingClassMOPPackageInstance;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      "You must pass a package name or an existing Class::MOP::Package instance";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTPASSAPACKAGENAMEORANEXISTINGCLASSMOPPACKAGEINSTANCE

$fatpacked{"darwin-2level/Moose/Exception/MustPassEvenNumberOfArguments.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTPASSEVENNUMBEROFARGUMENTS';
  package Moose::Exception::MustPassEvenNumberOfArguments;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'args' => (
      is         => 'ro',
      isa        => 'ArrayRef',
      required   => 1
  );
  
  has 'method_name' => (
      is         => 'ro',
      isa        => 'Str',
      required   => 1
  );
  
  sub _build_message {
      my $self = shift;
      "You must pass an even number of arguments to ".$self->method_name;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTPASSEVENNUMBEROFARGUMENTS

$fatpacked{"darwin-2level/Moose/Exception/MustPassEvenNumberOfAttributeOptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTPASSEVENNUMBEROFATTRIBUTEOPTIONS';
  package Moose::Exception::MustPassEvenNumberOfAttributeOptions;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'options' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      return 'You must pass an even number of attribute options';
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTPASSEVENNUMBEROFATTRIBUTEOPTIONS

$fatpacked{"darwin-2level/Moose/Exception/MustProvideANameForTheAttribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTPROVIDEANAMEFORTHEATTRIBUTE';
  package Moose::Exception::MustProvideANameForTheAttribute;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must provide a name for the attribute";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTPROVIDEANAMEFORTHEATTRIBUTE

$fatpacked{"darwin-2level/Moose/Exception/MustSpecifyAtleastOneMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEMETHOD';
  package Moose::Exception::MustSpecifyAtleastOneMethod;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  sub _build_message {
      "Must specify at least one method";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEMETHOD

$fatpacked{"darwin-2level/Moose/Exception/MustSpecifyAtleastOneRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEROLE';
  package Moose::Exception::MustSpecifyAtleastOneRole;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  sub _build_message {
      "Must specify at least one role";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEROLE

$fatpacked{"darwin-2level/Moose/Exception/MustSpecifyAtleastOneRoleToApplicant.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEROLETOAPPLICANT';
  package Moose::Exception::MustSpecifyAtleastOneRoleToApplicant;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'applicant' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Must specify at least one role to apply to ".$self->applicant;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEROLETOAPPLICANT

$fatpacked{"darwin-2level/Moose/Exception/MustSupplyAClassMOPAttributeInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTSUPPLYACLASSMOPATTRIBUTEINSTANCE';
  package Moose::Exception::MustSupplyAClassMOPAttributeInstance;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must supply an attribute which is a 'Class::MOP::Attribute' instance";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTSUPPLYACLASSMOPATTRIBUTEINSTANCE

$fatpacked{"darwin-2level/Moose/Exception/MustSupplyADelegateToMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTSUPPLYADELEGATETOMETHOD';
  package Moose::Exception::MustSupplyADelegateToMethod;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must supply a delegate_to_method which is a method name or a CODE reference";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTSUPPLYADELEGATETOMETHOD

$fatpacked{"darwin-2level/Moose/Exception/MustSupplyAMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTSUPPLYAMETACLASS';
  package Moose::Exception::MustSupplyAMetaclass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "You must pass a metaclass instance if you want to inline";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTSUPPLYAMETACLASS

$fatpacked{"darwin-2level/Moose/Exception/MustSupplyAMooseMetaAttributeInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTSUPPLYAMOOSEMETAATTRIBUTEINSTANCE';
  package Moose::Exception::MustSupplyAMooseMetaAttributeInstance;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must supply an attribute which is a 'Moose::Meta::Attribute' instance";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTSUPPLYAMOOSEMETAATTRIBUTEINSTANCE

$fatpacked{"darwin-2level/Moose/Exception/MustSupplyAnAccessorTypeToConstructWith.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTSUPPLYANACCESSORTYPETOCONSTRUCTWITH';
  package Moose::Exception::MustSupplyAnAccessorTypeToConstructWith;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must supply an accessor_type to construct with";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTSUPPLYANACCESSORTYPETOCONSTRUCTWITH

$fatpacked{"darwin-2level/Moose/Exception/MustSupplyAnAttributeToConstructWith.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTSUPPLYANATTRIBUTETOCONSTRUCTWITH';
  package Moose::Exception::MustSupplyAnAttributeToConstructWith;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must supply an attribute to construct with";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTSUPPLYANATTRIBUTETOCONSTRUCTWITH

$fatpacked{"darwin-2level/Moose/Exception/MustSupplyArrayRefAsCurriedArguments.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTSUPPLYARRAYREFASCURRIEDARGUMENTS';
  package Moose::Exception::MustSupplyArrayRefAsCurriedArguments;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Class';
  
  sub _build_message {
      "You must supply a curried_arguments which is an ARRAY reference";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTSUPPLYARRAYREFASCURRIEDARGUMENTS

$fatpacked{"darwin-2level/Moose/Exception/MustSupplyPackageNameAndName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTSUPPLYPACKAGENAMEANDNAME';
  package Moose::Exception::MustSupplyPackageNameAndName;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "You must supply the package_name and name parameters";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_MUSTSUPPLYPACKAGENAMEANDNAME

$fatpacked{"darwin-2level/Moose/Exception/NeedsTypeConstraintUnionForTypeCoercionUnion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_NEEDSTYPECONSTRAINTUNIONFORTYPECOERCIONUNION';
  package Moose::Exception::NeedsTypeConstraintUnionForTypeCoercionUnion;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  # use Moose::Util::TypeConstraints 'find_type_constraint';
  
  has 'type_coercion_union_object' => (
      is       => 'ro',
      isa      => 'Moose::Meta::TypeCoercion::Union',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $type_constraint = $self->type_name;
  
      return "You can only create a Moose::Meta::TypeCoercion::Union for a " .
             "Moose::Meta::TypeConstraint::Union, not a $type_constraint"
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_NEEDSTYPECONSTRAINTUNIONFORTYPECOERCIONUNION

$fatpacked{"darwin-2level/Moose/Exception/NeitherAttributeNorAttributeNameIsGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_NEITHERATTRIBUTENORATTRIBUTENAMEISGIVEN';
  package Moose::Exception::NeitherAttributeNorAttributeNameIsGiven;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "You need to give attribute or attribute_name or both";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_NEITHERATTRIBUTENORATTRIBUTENAMEISGIVEN

$fatpacked{"darwin-2level/Moose/Exception/NeitherClassNorClassNameIsGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_NEITHERCLASSNORCLASSNAMEISGIVEN';
  package Moose::Exception::NeitherClassNorClassNameIsGiven;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "You need to give class or class_name or both";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_NEITHERCLASSNORCLASSNAMEISGIVEN

$fatpacked{"darwin-2level/Moose/Exception/NeitherRoleNorRoleNameIsGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_NEITHERROLENORROLENAMEISGIVEN';
  package Moose::Exception::NeitherRoleNorRoleNameIsGiven;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "You need to give role or role_name or both";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_NEITHERROLENORROLENAMEISGIVEN

$fatpacked{"darwin-2level/Moose/Exception/NeitherTypeNorTypeNameIsGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_NEITHERTYPENORTYPENAMEISGIVEN';
  package Moose::Exception::NeitherTypeNorTypeNameIsGiven;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "You need to give type or type_name or both";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_NEITHERTYPENORTYPENAMEISGIVEN

$fatpacked{"darwin-2level/Moose/Exception/NoAttributeFoundInSuperClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_NOATTRIBUTEFOUNDINSUPERCLASS';
  package Moose::Exception::NoAttributeFoundInSuperClass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "Could not find an attribute by the name of '".$self->attribute_name."' to inherit from in ".$self->class_name;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_NOATTRIBUTEFOUNDINSUPERCLASS

$fatpacked{"darwin-2level/Moose/Exception/NoBodyToInitializeInAnAbstractBaseClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_NOBODYTOINITIALIZEINANABSTRACTBASECLASS';
  package Moose::Exception::NoBodyToInitializeInAnAbstractBaseClass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'package_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "No body to initialize, " .$self->package_name. " is an abstract base class";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_NOBODYTOINITIALIZEINANABSTRACTBASECLASS

$fatpacked{"darwin-2level/Moose/Exception/NoCasesMatched.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_NOCASESMATCHED';
  package Moose::Exception::NoCasesMatched;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'to_match' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'cases_to_be_matched' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $to_match = $self->to_match;
  
      return "No cases matched for $to_match";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_NOCASESMATCHED

$fatpacked{"darwin-2level/Moose/Exception/NoConstraintCheckForTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_NOCONSTRAINTCHECKFORTYPECONSTRAINT';
  package Moose::Exception::NoConstraintCheckForTypeConstraint;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      "Could not compile type constraint '".$self->type_name."' because no constraint check";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_NOCONSTRAINTCHECKFORTYPECONSTRAINT

$fatpacked{"darwin-2level/Moose/Exception/NoDestructorClassSpecified.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_NODESTRUCTORCLASSSPECIFIED';
  package Moose::Exception::NoDestructorClassSpecified;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::ParamsHash';
  
  sub _build_message {
      "The 'inline_destructor' option is present, but no destructor class was specified";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_NODESTRUCTORCLASSSPECIFIED

$fatpacked{"darwin-2level/Moose/Exception/NoImmutableTraitSpecifiedForClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_NOIMMUTABLETRAITSPECIFIEDFORCLASS';
  package Moose::Exception::NoImmutableTraitSpecifiedForClass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::ParamsHash';
  
  use Moose::Util 'find_meta';
  
  sub _build_message {
      my $self  = shift;
      my $class = find_meta( $self->class_name );
      "no immutable trait specified for $class";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_NOIMMUTABLETRAITSPECIFIEDFORCLASS

$fatpacked{"darwin-2level/Moose/Exception/NoParentGivenToSubtype.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_NOPARENTGIVENTOSUBTYPE';
  package Moose::Exception::NoParentGivenToSubtype;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "A subtype cannot consist solely of a name, it must have a parent";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_NOPARENTGIVENTOSUBTYPE

$fatpacked{"darwin-2level/Moose/Exception/OnlyInstancesCanBeCloned.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ONLYINSTANCESCANBECLONED';
  package Moose::Exception::OnlyInstancesCanBeCloned;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::ParamsHash';
  
  has 'instance' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "You can only clone instances, (".$self->instance.") is not a blessed instance";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ONLYINSTANCESCANBECLONED

$fatpacked{"darwin-2level/Moose/Exception/OperatorIsRequired.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_OPERATORISREQUIRED';
  package Moose::Exception::OperatorIsRequired;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "operator is required";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_OPERATORISREQUIRED

$fatpacked{"darwin-2level/Moose/Exception/OverloadConflictInSummation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_OVERLOADCONFLICTINSUMMATION';
  package Moose::Exception::OverloadConflictInSummation;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  use Moose::Util 'find_meta';
  
  has 'role_application' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Role::Application::RoleSummation',
      required => 1
  );
  
  has 'role_names' => (
      traits  => ['Array'],
      is      => 'bare',
      isa     => 'ArrayRef[Str]',
      handles => {
          role_names => 'elements',
      },
      required => 1,
      documentation =>
          "This attribute is an ArrayRef containing role names, if you want metaobjects\n"
          . "associated with these role names, then call method roles on the exception object.\n",
  );
  
  has 'overloaded_op' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub roles {
      my $self = shift;
      my @role_names = $self->role_names;
      my @roles = map { find_meta($_) } @role_names;
      return @roles;
  }
  
  sub _build_message {
      my $self = shift;
  
      my @roles = $self->role_names;
      my $role_names = join "|", @roles;
  
      my $op = $self->overloaded_op;
      if ( $op eq 'fallback' ) {
          return
                'We have encountered an overloading conflict for the fallback '
              . 'during composition. This is a fatal error.';
      }
      else {
          return
                "Role '$role_names' has encountered an overloading conflict "
              . "during composition. The two roles both overload the '$op' operator. "
              . 'This is a fatal error.';
      }
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_OVERLOADCONFLICTINSUMMATION

$fatpacked{"darwin-2level/Moose/Exception/OverloadRequiresAMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_OVERLOADREQUIRESAMETACLASS';
  package Moose::Exception::OverloadRequiresAMetaClass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      my $self = shift;
      'If you provide an associated_metaclass parameter to the Moose::Meta::Overload constructor it must be a Class::MOP::Module object';
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_OVERLOADREQUIRESAMETACLASS

$fatpacked{"darwin-2level/Moose/Exception/OverloadRequiresAMetaMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_OVERLOADREQUIRESAMETAMETHOD';
  package Moose::Exception::OverloadRequiresAMetaMethod;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      my $self = shift;
      'If you provide a method parameter to the Moose::Meta::Overload constructor it must be a Class::MOP::Method object';
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_OVERLOADREQUIRESAMETAMETHOD

$fatpacked{"darwin-2level/Moose/Exception/OverloadRequiresAMetaOverload.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_OVERLOADREQUIRESAMETAOVERLOAD';
  package Moose::Exception::OverloadRequiresAMetaOverload;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      my $self = shift;
      'If you provide an original_overload parameter to the Moose::Meta::Overload constructor it must be a Moose::Meta::Overload object';
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_OVERLOADREQUIRESAMETAOVERLOAD

$fatpacked{"darwin-2level/Moose/Exception/OverloadRequiresAMethodNameOrCoderef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_OVERLOADREQUIRESAMETHODNAMEORCODEREF';
  package Moose::Exception::OverloadRequiresAMethodNameOrCoderef;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      my $self = shift;
      'You must provide a method_name or coderef parameter when constructing a Moose::Meta::Overload object';
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_OVERLOADREQUIRESAMETHODNAMEORCODEREF

$fatpacked{"darwin-2level/Moose/Exception/OverloadRequiresAnOperator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_OVERLOADREQUIRESANOPERATOR';
  package Moose::Exception::OverloadRequiresAnOperator;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      my $self = shift;
      'You must provide an operator parameter when constructing a Moose::Meta::Overload object';
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_OVERLOADREQUIRESANOPERATOR

$fatpacked{"darwin-2level/Moose/Exception/OverloadRequiresNamesForCoderef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_OVERLOADREQUIRESNAMESFORCODEREF';
  package Moose::Exception::OverloadRequiresNamesForCoderef;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      my $self = shift;
      'If you provide a coderef parameter to the Moose::Meta::Overload constructor you must also provide coderef_package and coderef_name parameters';
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_OVERLOADREQUIRESNAMESFORCODEREF

$fatpacked{"darwin-2level/Moose/Exception/OverrideConflictInComposition.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_OVERRIDECONFLICTINCOMPOSITION';
  package Moose::Exception::OverrideConflictInComposition;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'role_being_applied_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'two_overrides_found' => (
      is       => 'ro',
      isa      => 'Bool',
      required => 1,
      default  => 0
  );
  
  sub _build_message {
      my $self = shift;
  
      if( $self->two_overrides_found ) {
          return "Role '" . $self->role_being_applied_name . "' has encountered an 'override' method conflict " .
                 "during composition (Two 'override' methods of the same name encountered). " .
                 "This is a fatal error.";
      }
      else {
          return "Role '".$self->role_being_applied_name."' has encountered an 'override' method conflict ".
                 "during composition (A local method of the same name as been found). ".
                 "This is a fatal error.";
      }
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_OVERRIDECONFLICTINCOMPOSITION

$fatpacked{"darwin-2level/Moose/Exception/OverrideConflictInSummation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_OVERRIDECONFLICTINSUMMATION';
  package Moose::Exception::OverrideConflictInSummation;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  use Moose::Util 'find_meta';
  
  has 'role_application' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Role::Application::RoleSummation',
      required => 1
  );
  
  has 'role_names' => (
      traits   => ['Array'],
      is       => 'bare',
      isa      => 'ArrayRef[Str]',
      handles  => {
          role_names      => 'elements',
      },
      required => 1,
      documentation => "This attribute is an ArrayRef containing role names, if you want metaobjects\n".
                       "associated with these role names, then call method roles on the exception object.\n",
  );
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'two_overrides_found' => (
      is       => 'ro',
      isa      => 'Bool',
      required => 1,
      default  => 0
  );
  
  sub roles {
      my $self = shift;
      my @role_names = $self->role_names;
      my @roles = map { find_meta($_) } @role_names;
      return @roles;
  }
  
  sub _build_message {
      my $self = shift;
  
      my @roles = $self->role_names;
      my $role_names = join "|", @roles;
  
      if( $self->two_overrides_found ) {
          return "We have encountered an 'override' method conflict ".
                 "during composition (Two 'override' methods of the same name encountered). ".
                 "This is a fatal error.";
      }
      else {
          return "Role '$role_names' has encountered an 'override' method conflict " .
                 "during composition (A local method of the same name has been found). This " .
                 "is a fatal error." ;
      }
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_OVERRIDECONFLICTINSUMMATION

$fatpacked{"darwin-2level/Moose/Exception/PackageDoesNotUseMooseExporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_PACKAGEDOESNOTUSEMOOSEEXPORTER';
  package Moose::Exception::PackageDoesNotUseMooseExporter;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'package' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'is_loaded' => (
      is       => 'ro',
      isa      => 'Bool',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $package = $self->package;
      return "Package in also ($package) does not seem to "
             . "use Moose::Exporter"
             . ( $self->is_loaded ? "" : " (is it loaded?)" );
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_PACKAGEDOESNOTUSEMOOSEEXPORTER

$fatpacked{"darwin-2level/Moose/Exception/PackageNameAndNameParamsNotGivenToWrap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_PACKAGENAMEANDNAMEPARAMSNOTGIVENTOWRAP';
  package Moose::Exception::PackageNameAndNameParamsNotGivenToWrap;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'code' => (
      is       => 'ro',
      isa      => 'CodeRef',
      required => 1
  );
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must supply the package_name and name parameters";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_PACKAGENAMEANDNAMEPARAMSNOTGIVENTOWRAP

$fatpacked{"darwin-2level/Moose/Exception/PackagesAndModulesAreNotCachable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_PACKAGESANDMODULESARENOTCACHABLE';
  package Moose::Exception::PackagesAndModulesAreNotCachable;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::ParamsHash';
  
  has 'is_module' => (
      is       => 'ro',
      isa      => 'Bool',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $is_module = $self->is_module;
  
      if( $is_module ) {
          return "Modules are not cacheable";
      } else {
          return "Packages are not cacheable";
      }
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_PACKAGESANDMODULESARENOTCACHABLE

$fatpacked{"darwin-2level/Moose/Exception/ParameterIsNotSubtypeOfParent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_PARAMETERISNOTSUBTYPEOFPARENT';
  package Moose::Exception::ParameterIsNotSubtypeOfParent;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  use Moose::Util::TypeConstraints qw/find_type_constraint/;
  
  has 'type_parameter' => (
      is => 'ro',
      isa => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $type_parameter = $self->type_parameter;
      my $type           = find_type_constraint( $self->type_name );
      my $parent         = $type->parent->type_parameter;
  
      return "$type_parameter is not a subtype of $parent";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_PARAMETERISNOTSUBTYPEOFPARENT

$fatpacked{"darwin-2level/Moose/Exception/ReferencesAreNotAllowedAsDefault.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_REFERENCESARENOTALLOWEDASDEFAULT';
  package Moose::Exception::ReferencesAreNotAllowedAsDefault;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "References are not allowed as default values, you must wrap the default of '".
          $self->attribute_name."' in a CODE reference (ex: sub { [] } and not [])";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_REFERENCESARENOTALLOWEDASDEFAULT

$fatpacked{"darwin-2level/Moose/Exception/RequiredAttributeLacksInitialization.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_REQUIREDATTRIBUTELACKSINITIALIZATION';
  package Moose::Exception::RequiredAttributeLacksInitialization;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "A required attribute must have either 'init_arg', 'builder', or 'default'";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_REQUIREDATTRIBUTELACKSINITIALIZATION

$fatpacked{"darwin-2level/Moose/Exception/RequiredAttributeNeedsADefault.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_REQUIREDATTRIBUTENEEDSADEFAULT';
  package Moose::Exception::RequiredAttributeNeedsADefault;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "You cannot have a required attribute (".$self->attribute_name.") without a default, builder, or an init_arg";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_REQUIREDATTRIBUTENEEDSADEFAULT

$fatpacked{"darwin-2level/Moose/Exception/RequiredMethodsImportedByClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_REQUIREDMETHODSIMPORTEDBYCLASS';
  package Moose::Exception::RequiredMethodsImportedByClass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Role';
  
  has 'missing_methods' => (
      traits   => ['Array'],
      is       => 'ro',
      isa      => 'ArrayRef[Moose::Meta::Role::Method::Required]',
      handles  => { method_count    => 'count',
                    get_method_at   => 'get',
                    get_all_methods => 'elements',
      },
      required => 1
  );
  
  has 'imported_method' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Role::Method::Required',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
  
      my $noun = $self->method_count == 1 ? 'method' : 'methods';
      my $list = Moose::Util::english_list( map { q{'} . $_ . q{'} } $self->get_all_methods );
  
      my ($class, $role, $method) = ($self->class_name,
                                     $self->role_name,
                                     $self->imported_method);
  
      my ($class_quoted, $role_quoted) = ("'".$class."'","'".$role."'");
  
      "$role_quoted requires the $noun $list "
          . "to be implemented by $class_quoted. "
          . "If you imported functions intending to use them as "
          . "methods, you need to explicitly mark them as such, via "
          . "$class->meta->add_method($method"
          . " => \\&$method)";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_REQUIREDMETHODSIMPORTEDBYCLASS

$fatpacked{"darwin-2level/Moose/Exception/RequiredMethodsNotImplementedByClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_REQUIREDMETHODSNOTIMPLEMENTEDBYCLASS';
  package Moose::Exception::RequiredMethodsNotImplementedByClass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Role';
  
  has 'missing_methods' => (
      traits     => ['Array'],
      is         => 'ro',
      isa        => 'ArrayRef[Moose::Meta::Role::Method::Required]',
      handles    => { method_count    => 'count',
                      get_method_at   => 'get',
                      get_all_methods => 'elements',
      },
      required   => 1
  );
  
  sub _build_message {
      my $self = shift;
  
      my $noun = $self->method_count == 1 ? 'method' : 'methods';
      my $list = Moose::Util::english_list( map { q{'} . $_ . q{'} } $self->get_all_methods );
      my ($role_name, $class_name) = ($self->role_name, $self->class_name);
  
      return "'$role_name' requires the $noun $list "
          . "to be implemented by '$class_name'";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_REQUIREDMETHODSNOTIMPLEMENTEDBYCLASS

$fatpacked{"darwin-2level/Moose/Exception/Role/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_ATTRIBUTE';
  package Moose::Exception::Role::Attribute;
  our $VERSION = '2.2011';
  
  use Moose::Role;
  
  has 'attribute' => (
      is        => 'ro',
      isa       => 'Class::MOP::Attribute',
      predicate => 'is_attribute_set'
  );
  
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_ATTRIBUTE

$fatpacked{"darwin-2level/Moose/Exception/Role/AttributeName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_ATTRIBUTENAME';
  package Moose::Exception::Role::AttributeName;
  our $VERSION = '2.2011';
  
  use Moose::Role;
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_ATTRIBUTENAME

$fatpacked{"darwin-2level/Moose/Exception/Role/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_CLASS';
  package Moose::Exception::Role::Class;
  our $VERSION = '2.2011';
  
  use Moose::Role;
  
  has 'class_name' => (
      is            => 'ro',
      isa           => 'Str',
      required      => 1,
      documentation => "This attribute can be used for fetching metaclass instance:\n".
                       "    my \$metaclass_instance = Moose::Util::find_meta( \$exception->class_name );\n",
  );
  
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_CLASS

$fatpacked{"darwin-2level/Moose/Exception/Role/EitherAttributeOrAttributeName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_EITHERATTRIBUTEORATTRIBUTENAME';
  package Moose::Exception::Role::EitherAttributeOrAttributeName;
  our $VERSION = '2.2011';
  
  use Moose::Util 'throw_exception';
  use Moose::Role;
  
  has 'attribute_name' => (
      is         => 'ro',
      isa        => 'Str',
      lazy_build => 1
  );
  
  has 'attribute' => (
      is        => 'ro',
      isa       => 'Class::MOP::Attribute',
      predicate => 'has_attribute'
  );
  
  has 'params' => (
      is        => 'ro',
      isa       => 'HashRef',
      predicate => 'has_params',
  );
  
  sub _build_attribute_name {
      my $self = shift;
  
      if( !$self->has_attribute )
      {
          throw_exception("NeitherAttributeNorAttributeNameIsGiven");
      }
  
      return $self->attribute->name;
  }
  
  after "BUILD" => sub {
      my $self = $_[0];
  
      if( $self->has_attribute_name &&
          $self->has_attribute &&
          ( $self->attribute->name ne $self->attribute_name ) )
      {
          throw_exception( AttributeNamesDoNotMatch => attribute_name => $self->attribute_name,
                                                       attribute      => $self->attribute
                         );
      }
  };
  
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_EITHERATTRIBUTEORATTRIBUTENAME

$fatpacked{"darwin-2level/Moose/Exception/Role/Instance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_INSTANCE';
  package Moose::Exception::Role::Instance;
  our $VERSION = '2.2011';
  
  use Moose::Role;
  
  has 'instance' => (
      is       => 'ro',
      isa      => 'Object',
      required => 1,
  );
  
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_INSTANCE

$fatpacked{"darwin-2level/Moose/Exception/Role/InstanceClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_INSTANCECLASS';
  package Moose::Exception::Role::InstanceClass;
  our $VERSION = '2.2011';
  
  use Moose::Role;
  
  has 'instance_class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_INSTANCECLASS

$fatpacked{"darwin-2level/Moose/Exception/Role/InvalidAttributeOptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_INVALIDATTRIBUTEOPTIONS';
  package Moose::Exception::Role::InvalidAttributeOptions;
  our $VERSION = '2.2011';
  
  use Moose::Role;
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_INVALIDATTRIBUTEOPTIONS

$fatpacked{"darwin-2level/Moose/Exception/Role/Method.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_METHOD';
  package Moose::Exception::Role::Method;
  our $VERSION = '2.2011';
  
  use Moose::Role;
  
  has 'method' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Method',
      required => 1,
  );
  
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_METHOD

$fatpacked{"darwin-2level/Moose/Exception/Role/ParamsHash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_PARAMSHASH';
  package Moose::Exception::Role::ParamsHash;
  our $VERSION = '2.2011';
  
  use Moose::Role;
  
  has 'params' => (
      is       => 'ro',
      isa      => 'HashRef',
      required => 1,
  );
  
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_PARAMSHASH

$fatpacked{"darwin-2level/Moose/Exception/Role/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_ROLE';
  package Moose::Exception::Role::Role;
  our $VERSION = '2.2011';
  
  # use Moose::Util 'throw_exception';
  use Moose::Role;
  
  has 'role_name' => (
      is            => 'ro',
      isa           => 'Str',
      required      => 1,
      documentation => "This attribute can be used for fetching the class's metaclass instance:\n".
                       "    my \$metaclass_instance = Moose::Util::find_meta( \$exception->role_name );\n",
  
  );
  
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_ROLE

$fatpacked{"darwin-2level/Moose/Exception/Role/RoleForCreate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_ROLEFORCREATE';
  package Moose::Exception::Role::RoleForCreate;
  our $VERSION = '2.2011';
  
  use Moose::Role;
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'attribute_class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_ROLEFORCREATE

$fatpacked{"darwin-2level/Moose/Exception/Role/RoleForCreateMOPClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_ROLEFORCREATEMOPCLASS';
  package Moose::Exception::Role::RoleForCreateMOPClass;
  our $VERSION = '2.2011';
  
  use Moose::Role;
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_ROLEFORCREATEMOPCLASS

$fatpacked{"darwin-2level/Moose/Exception/Role/TypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_TYPECONSTRAINT';
  package Moose::Exception::Role::TypeConstraint;
  our $VERSION = '2.2011';
  
  use Moose::Role;
  
  has 'type_name' => (
      is            => 'ro',
      isa           => 'Str',
      required      => 1,
      documentation => "This attribute can be used for fetching type constraint(Moose::Meta::TypeConstraint):\n".
                       "    my \$type_constraint =  Moose::Util::TypeConstraints::find_type_constraint( \$exception->type_name );\n",
  );
  
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLE_TYPECONSTRAINT

$fatpacked{"darwin-2level/Moose/Exception/RoleDoesTheExcludedRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLEDOESTHEEXCLUDEDROLE';
  package Moose::Exception::RoleDoesTheExcludedRole;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'excluded_role_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'second_role_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self               = shift;
      my $role_name          = $self->role_name;
      my $excluded_role_name = $self->excluded_role_name;
      return "The role $role_name does the excluded role '$excluded_role_name'";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLEDOESTHEEXCLUDEDROLE

$fatpacked{"darwin-2level/Moose/Exception/RoleExclusionConflict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLEEXCLUSIONCONFLICT';
  package Moose::Exception::RoleExclusionConflict;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'roles' => (
      is         => 'ro',
      isa        => 'ArrayRef',
      required   => 1,
  );
  
  sub _build_message {
      my $self = shift;
  
      my @roles_array = @{$self->roles};
      my $role_noun = "Role".( @roles_array == 1 ? '' : 's');
      my $all_roles = join(', ', @roles_array);
      my $verb = "exclude".( @roles_array == 1 ? 's' : '' );
      my $role_name = $self->role_name;
  
      return "Conflict detected: $role_noun $all_roles $verb role '$role_name'";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLEEXCLUSIONCONFLICT

$fatpacked{"darwin-2level/Moose/Exception/RoleNameRequired.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLENAMEREQUIRED';
  package Moose::Exception::RoleNameRequired;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  sub _build_message {
      "You must supply a role name to look for";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLENAMEREQUIRED

$fatpacked{"darwin-2level/Moose/Exception/RoleNameRequiredForMooseMetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLENAMEREQUIREDFORMOOSEMETAROLE';
  package Moose::Exception::RoleNameRequiredForMooseMetaRole;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  sub _build_message {
      "You must supply a role name to look for";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLENAMEREQUIREDFORMOOSEMETAROLE

$fatpacked{"darwin-2level/Moose/Exception/RolesDoNotSupportAugment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLESDONOTSUPPORTAUGMENT';
  package Moose::Exception::RolesDoNotSupportAugment;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "Roles cannot support 'augment'";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLESDONOTSUPPORTAUGMENT

$fatpacked{"darwin-2level/Moose/Exception/RolesDoNotSupportExtends.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLESDONOTSUPPORTEXTENDS';
  package Moose::Exception::RolesDoNotSupportExtends;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "Roles do not support 'extends' (you can use 'with' to specialize a role)";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLESDONOTSUPPORTEXTENDS

$fatpacked{"darwin-2level/Moose/Exception/RolesDoNotSupportInner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLESDONOTSUPPORTINNER';
  package Moose::Exception::RolesDoNotSupportInner;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "Roles cannot support 'inner'";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLESDONOTSUPPORTINNER

$fatpacked{"darwin-2level/Moose/Exception/RolesDoNotSupportRegexReferencesForMethodModifiers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLESDONOTSUPPORTREGEXREFERENCESFORMETHODMODIFIERS';
  package Moose::Exception::RolesDoNotSupportRegexReferencesForMethodModifiers;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'modifier_type' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Roles do not currently support regex references for ".$self->modifier_type." method modifiers";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLESDONOTSUPPORTREGEXREFERENCESFORMETHODMODIFIERS

$fatpacked{"darwin-2level/Moose/Exception/RolesInCreateTakesAnArrayRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLESINCREATETAKESANARRAYREF';
  package Moose::Exception::RolesInCreateTakesAnArrayRef;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  sub _build_message {
      my $self = shift;
      "You must pass an ARRAY ref of roles";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLESINCREATETAKESANARRAYREF

$fatpacked{"darwin-2level/Moose/Exception/RolesListMustBeInstancesOfMooseMetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLESLISTMUSTBEINSTANCESOFMOOSEMETAROLE';
  package Moose::Exception::RolesListMustBeInstancesOfMooseMetaRole;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'role' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The list of roles must be instances of Moose::Meta::Role, not ".$self->role;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_ROLESLISTMUSTBEINSTANCESOFMOOSEMETAROLE

$fatpacked{"darwin-2level/Moose/Exception/SingleParamsToNewMustBeHashRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_SINGLEPARAMSTONEWMUSTBEHASHREF';
  package Moose::Exception::SingleParamsToNewMustBeHashRef;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "Single parameters to new() must be a HASH ref";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_SINGLEPARAMSTONEWMUSTBEHASHREF

$fatpacked{"darwin-2level/Moose/Exception/TriggerMustBeACodeRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_TRIGGERMUSTBEACODEREF';
  package Moose::Exception::TriggerMustBeACodeRef;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "Trigger must be a CODE ref on attribute (".$self->attribute_name.")";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_TRIGGERMUSTBEACODEREF

$fatpacked{"darwin-2level/Moose/Exception/TypeConstraintCannotBeUsedForAParameterizableType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_TYPECONSTRAINTCANNOTBEUSEDFORAPARAMETERIZABLETYPE';
  package Moose::Exception::TypeConstraintCannotBeUsedForAParameterizableType;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  has 'parent_type_name' => (
      is            => 'ro',
      isa           => 'Str',
      required      => 1,
      documentation => "This attribute can be used for fetching type constraint(Moose::Meta::TypeConstraint):\n".
                       "    my \$type_constraint =  Moose::Util::TypeConstraints::find_type_constraint( \$exception->parent_type_name );\n",
  );
  
  sub _build_message {
      my $self             = shift;
      my $type_name        = $self->type_name;
      my $parent_type_name = $self->parent_type_name;
      "The $type_name constraint cannot be used, because "
          . "$parent_type_name doesn't subtype or coerce from a parameterizable type.";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_TYPECONSTRAINTCANNOTBEUSEDFORAPARAMETERIZABLETYPE

$fatpacked{"darwin-2level/Moose/Exception/TypeConstraintIsAlreadyCreated.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_TYPECONSTRAINTISALREADYCREATED';
  package Moose::Exception::TypeConstraintIsAlreadyCreated;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  use Moose::Util::TypeConstraints 'find_type_constraint';
  
  has 'package_defined_in' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self                    = shift;
      my $type_name               = $self->type_name;
      my $type                    = find_type_constraint( $type_name );
      my $type_package_defined_in = $type->_package_defined_in;
      my $package_defined_in      = $self->package_defined_in;
      return "The type constraint '$type_name' has already been created in $type_package_defined_in and cannot be created again in $package_defined_in";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_TYPECONSTRAINTISALREADYCREATED

$fatpacked{"darwin-2level/Moose/Exception/TypeParameterMustBeMooseMetaType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_TYPEPARAMETERMUSTBEMOOSEMETATYPE';
  package Moose::Exception::TypeParameterMustBeMooseMetaType;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      "The type parameter must be a Moose meta type";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_TYPEPARAMETERMUSTBEMOOSEMETATYPE

$fatpacked{"darwin-2level/Moose/Exception/UnableToCanonicalizeHandles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_UNABLETOCANONICALIZEHANDLES';
  package Moose::Exception::UnableToCanonicalizeHandles;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'handles' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Unable to canonicalize the 'handles' option with ".$self->handles;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_UNABLETOCANONICALIZEHANDLES

$fatpacked{"darwin-2level/Moose/Exception/UnableToCanonicalizeNonRolePackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_UNABLETOCANONICALIZENONROLEPACKAGE';
  package Moose::Exception::UnableToCanonicalizeNonRolePackage;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'handles' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Unable to canonicalize the 'handles' option with ".$self->handles." because its metaclass is not a Moose::Meta::Role";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_UNABLETOCANONICALIZENONROLEPACKAGE

$fatpacked{"darwin-2level/Moose/Exception/UnableToRecognizeDelegateMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_UNABLETORECOGNIZEDELEGATEMETACLASS';
  package Moose::Exception::UnableToRecognizeDelegateMetaclass;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'delegate_metaclass' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $meta = $self->delegate_metaclass;
  
      return "Unable to recognize the delegate metaclass '$meta'";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_UNABLETORECOGNIZEDELEGATEMETACLASS

$fatpacked{"darwin-2level/Moose/Exception/UndefinedHashKeysPassedToMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_UNDEFINEDHASHKEYSPASSEDTOMETHOD';
  package Moose::Exception::UndefinedHashKeysPassedToMethod;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'hash_keys' => (
      is         => 'ro',
      isa        => 'ArrayRef',
      required   => 1
  );
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Hash keys passed to ".$self->method_name." must be defined";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_UNDEFINEDHASHKEYSPASSEDTOMETHOD

$fatpacked{"darwin-2level/Moose/Exception/UnionCalledWithAnArrayRefAndAdditionalArgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_UNIONCALLEDWITHANARRAYREFANDADDITIONALARGS';
  package Moose::Exception::UnionCalledWithAnArrayRefAndAdditionalArgs;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'array' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  has 'args' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  sub _build_message {
      "union called with an array reference and additional arguments";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_UNIONCALLEDWITHANARRAYREFANDADDITIONALARGS

$fatpacked{"darwin-2level/Moose/Exception/UnionTakesAtleastTwoTypeNames.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_UNIONTAKESATLEASTTWOTYPENAMES';
  package Moose::Exception::UnionTakesAtleastTwoTypeNames;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "You must pass in at least 2 type names to make a union";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_UNIONTAKESATLEASTTWOTYPENAMES

$fatpacked{"darwin-2level/Moose/Exception/ValidationFailedForInlineTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_VALIDATIONFAILEDFORINLINETYPECONSTRAINT';
  package Moose::Exception::ValidationFailedForInlineTypeConstraint;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'type_constraint_message' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'new_member' => (
      is        => 'ro',
      isa       => 'Bool',
      default   => 0,
      predicate => 'is_a_new_member'
  );
  
  sub _build_message {
      my $self = shift;
  
      my $line1;
  
      if( $self->new_member ) {
          $line1 = "A new member value for ".$self->attribute_name." does not pass its type constraint because: "
      }
      else {
          $line1 = "Attribute (".$self->attribute_name.") does not pass the type constraint because: ";
      }
  
      return $line1 . $self->type_constraint_message;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_VALIDATIONFAILEDFORINLINETYPECONSTRAINT

$fatpacked{"darwin-2level/Moose/Exception/ValidationFailedForTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_VALIDATIONFAILEDFORTYPECONSTRAINT';
  package Moose::Exception::ValidationFailedForTypeConstraint;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  has 'type' => (
      is       => 'ro',
      isa      => Moose::Util::TypeConstraints->duck_type(["get_message", "name"]),
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
  
      my $error = $self->type->get_message( $self->value );
  
      return $error unless $self->is_attribute_set;
  
      my $attribute_name = $self->attribute->name;
      return
          "Attribute ($attribute_name) does not pass the type constraint because: $error";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_VALIDATIONFAILEDFORTYPECONSTRAINT

$fatpacked{"darwin-2level/Moose/Exception/WrapTakesACodeRefToBless.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_WRAPTAKESACODEREFTOBLESS';
  package Moose::Exception::WrapTakesACodeRefToBless;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'code' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "You must supply a CODE reference to bless, not (" . ( $self->code ? $self->code : 'undef' ) . ")";
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_WRAPTAKESACODEREFTOBLESS

$fatpacked{"darwin-2level/Moose/Exception/WrongTypeConstraintGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXCEPTION_WRONGTYPECONSTRAINTGIVEN';
  package Moose::Exception::WrongTypeConstraintGiven;
  our $VERSION = '2.2011';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has [qw/required_type given_type attribute_name/] => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The type constraint for ".$self->attribute_name." must be a subtype of "
      .$self->required_type." but it's a ".$self->given_type;
  }
  
  __PACKAGE__->meta->make_immutable;
  1;
DARWIN-2LEVEL_MOOSE_EXCEPTION_WRONGTYPECONSTRAINTGIVEN

$fatpacked{"darwin-2level/Moose/Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_EXPORTER';
  package Moose::Exporter;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Class::Load qw(is_class_loaded);
  use Class::MOP;
  use List::Util 1.45 qw( uniq );
  use Moose::Util::MetaRole;
  use Scalar::Util 1.11 qw(reftype);
  use Sub::Exporter 0.980;
  use Sub::Name qw(subname);
  
  use Moose::Util 'throw_exception';
  
  my %EXPORT_SPEC;
  
  sub setup_import_methods {
      my ( $class, %args ) = @_;
  
      $args{exporting_package} ||= caller();
  
      $class->build_import_methods(
          %args,
          install => [qw(import unimport init_meta)]
      );
  }
  
  # A reminder to intrepid Moose hackers
  # there may be more than one level of exporter
  # don't make doy cry. -- perigrin
  
  sub build_import_methods {
      my ( $class, %args ) = @_;
  
      my $exporting_package = $args{exporting_package} ||= caller();
  
      my $meta_lookup = $args{meta_lookup} || sub { Class::MOP::class_of(shift) };
  
      $EXPORT_SPEC{$exporting_package} = \%args;
  
      my @exports_from = $class->_follow_also($exporting_package);
  
      my $export_recorder = {};
      my $is_reexport     = {};
  
      my $exports = $class->_make_sub_exporter_params(
          [ $exporting_package, @exports_from ],
          $export_recorder,
          $is_reexport,
          $args{meta_lookup}, # so that we don't pass through the default
      );
  
      my $exporter = $class->_make_exporter(
          $exports,
          $is_reexport,
          $meta_lookup,
      );
  
      my %methods;
      $methods{import} = $class->_make_import_sub(
          $exporting_package,
          $exporter,
          \@exports_from,
          $is_reexport,
          $meta_lookup,
      );
  
      $methods{unimport} = $class->_make_unimport_sub(
          $exporting_package,
          $exports,
          $export_recorder,
          $is_reexport,
          $meta_lookup,
      );
  
      $methods{init_meta} = $class->_make_init_meta(
          $exporting_package,
          \%args,
          $meta_lookup,
      );
  
      my $package = Class::MOP::Package->initialize($exporting_package);
      for my $to_install ( @{ $args{install} || [] } ) {
          my $symbol = '&' . $to_install;
  
          next
              unless $methods{$to_install}
                  && !$package->has_package_symbol($symbol);
          $package->add_package_symbol(
              $symbol,
              subname(
                  $exporting_package . '::' . $to_install, $methods{$to_install}
              )
          );
      }
  
      return ( $methods{import}, $methods{unimport}, $methods{init_meta} );
  }
  
  sub _make_exporter {
      my ($class, $exports, $is_reexport, $meta_lookup) = @_;
  
      return Sub::Exporter::build_exporter(
          {
              exports   => $exports,
              groups    => { default => [':all'] },
              installer => sub {
                  my ($arg, $to_export) = @_;
                  my $meta = $meta_lookup->($arg->{into});
  
                  goto &Sub::Exporter::default_installer unless $meta;
  
                  # don't overwrite existing symbols with our magically flagged
                  # version of it if we would install the same sub that's already
                  # in the importer
  
                  my @filtered_to_export;
                  my %installed;
                  for (my $i = 0; $i < @{ $to_export }; $i += 2) {
                      my ($as, $cv) = @{ $to_export }[$i, $i + 1];
  
                      next if !ref($as)
                           && $meta->has_package_symbol('&' . $as)
                           && $meta->get_package_symbol('&' . $as) == $cv;
  
                      push @filtered_to_export, $as, $cv;
                      $installed{$as} = 1 unless ref $as;
                  }
  
                  Sub::Exporter::default_installer($arg, \@filtered_to_export);
  
                  for my $name ( keys %{$is_reexport} ) {
                      no strict 'refs';
                      no warnings 'once';
                      next unless exists $installed{$name};
                      _flag_as_reexport( \*{ join q{::}, $arg->{into}, $name } );
                  }
              },
          }
      );
  }
  
  sub _follow_also {
      my $class             = shift;
      my $exporting_package = shift;
  
      _die_if_cycle_found_in_also_list_for_package($exporting_package);
  
      return uniq( _follow_also_real($exporting_package) );
  }
  
  sub _follow_also_real {
      my $exporting_package = shift;
      my @also              = _also_list_for_package($exporting_package);
  
      return map { $_, _follow_also_real($_) } @also;
  }
  
  sub _also_list_for_package {
      my $package = shift;
  
      if ( !exists $EXPORT_SPEC{$package} ) {
          my $loaded = is_class_loaded($package);
  
          throw_exception( PackageDoesNotUseMooseExporter => package   => $package,
                                                             is_loaded => $loaded
                         );
      }
  
      my $also = $EXPORT_SPEC{$package}{also};
  
      return unless defined $also;
  
      return ref $also ? @$also : $also;
  }
  
  # this is no Tarjan algorithm, but for the list sizes expected,
  # brute force will probably be fine (and more maintainable)
  sub _die_if_cycle_found_in_also_list_for_package {
      my $package = shift;
      _die_if_also_list_cycles_back_to_existing_stack(
          [ _also_list_for_package($package) ],
          [$package],
      );
  }
  
  sub _die_if_also_list_cycles_back_to_existing_stack {
      my ( $also_list, $existing_stack ) = @_;
  
      return unless @$also_list && @$existing_stack;
  
      for my $also_member (@$also_list) {
          for my $stack_member (@$existing_stack) {
              next unless $also_member eq $stack_member;
  
              throw_exception( CircularReferenceInAlso => also_parameter => $also_member,
                                                          stack          => $existing_stack
                             );
          }
  
          _die_if_also_list_cycles_back_to_existing_stack(
              [ _also_list_for_package($also_member) ],
              [ $also_member, @$existing_stack ],
          );
      }
  }
  
  sub _parse_trait_aliases {
      my $class   = shift;
      my ($package, $aliases) = @_;
  
      my @ret;
      for my $alias (@$aliases) {
          my $name;
          if (ref($alias)) {
              reftype($alias) eq 'ARRAY'
                  or throw_exception( InvalidArgumentsToTraitAliases => class_name   => $class,
                                                                        package_name => $package,
                                                                        alias        => $alias
                                    );
              ($alias, $name) = @$alias;
          }
          else {
              ($name = $alias) =~ s/.*:://;
          }
          push @ret, subname "${package}::${name}" => sub () { $alias };
      }
  
      return @ret;
  }
  
  sub _make_sub_exporter_params {
      my $class                = shift;
      my $packages             = shift;
      my $export_recorder      = shift;
      my $is_reexport          = shift;
      my $meta_lookup_override = shift;
  
      my %exports;
      my $current_meta_lookup;
  
      for my $package ( @{$packages} ) {
          my $args = $EXPORT_SPEC{$package}
              or die "The $package package does not use Moose::Exporter\n";
  
          $current_meta_lookup = $meta_lookup_override || $args->{meta_lookup};
          $meta_lookup_override = $current_meta_lookup;
  
          my $meta_lookup = $current_meta_lookup
                         || sub { Class::MOP::class_of(shift) };
  
          for my $name ( @{ $args->{with_meta} } ) {
              my $sub = $class->_sub_from_package( $package, $name )
                  or next;
  
              my $fq_name = $package . '::' . $name;
  
              $exports{$name} = $class->_make_wrapped_sub_with_meta(
                  $fq_name,
                  $sub,
                  $export_recorder,
                  $meta_lookup,
              ) unless exists $exports{$name};
          }
  
          for my $name ( @{ $args->{with_caller} } ) {
              my $sub = $class->_sub_from_package( $package, $name )
                  or next;
  
              my $fq_name = $package . '::' . $name;
  
              $exports{$name} = $class->_make_wrapped_sub(
                  $fq_name,
                  $sub,
                  $export_recorder,
              ) unless exists $exports{$name};
          }
  
          my @extra_exports = $class->_parse_trait_aliases(
              $package, $args->{trait_aliases},
          );
          for my $name ( @{ $args->{as_is} }, @extra_exports ) {
              my ( $sub, $coderef_name );
  
              if ( ref $name ) {
                  $sub = $name;
  
                  my $coderef_pkg;
                  ( $coderef_pkg, $coderef_name )
                      = Class::MOP::get_code_info($name);
  
                  if ( $coderef_pkg ne $package ) {
                      $is_reexport->{$coderef_name} = 1;
                  }
              }
              elsif ( $name =~ /^(.*)::([^:]+)$/ ) {
                  $sub = $class->_sub_from_package( "$1", "$2" )
                      or next;
  
                  $coderef_name = "$2";
  
                  if ( $1 ne $package ) {
                      $is_reexport->{$coderef_name} = 1;
                  }
              }
              else {
                  $sub = $class->_sub_from_package( $package, $name )
                      or next;
  
                  $coderef_name = $name;
              }
  
              $export_recorder->{$sub} = 1;
  
              $exports{$coderef_name} = sub { $sub }
                  unless exists $exports{$coderef_name};
          }
      }
  
      return \%exports;
  }
  
  sub _sub_from_package {
      my $sclass  = shift;
      my $package = shift;
      my $name    = shift;
  
      my $sub = do {
          no strict 'refs';
          \&{ $package . '::' . $name };
      };
  
      return $sub if defined &$sub;
  
      Carp::cluck "Trying to export undefined sub ${package}::${name}";
  
      return;
  }
  
  our $CALLER;
  
  sub _make_wrapped_sub {
      my $self            = shift;
      my $fq_name         = shift;
      my $sub             = shift;
      my $export_recorder = shift;
  
      # We need to set the package at import time, so that when
      # package Foo imports has(), we capture "Foo" as the
      # package. This lets other packages call Foo::has() and get
      # the right package. This is done for backwards compatibility
      # with existing production code, not because this is a good
      # idea ;)
      return sub {
          my $caller = $CALLER;
  
          my $wrapper = $self->_curry_wrapper( $sub, $fq_name, $caller );
  
          my $sub = subname( $fq_name => $wrapper );
  
          $export_recorder->{$sub} = 1;
  
          return $sub;
      };
  }
  
  sub _make_wrapped_sub_with_meta {
      my $self            = shift;
      my $fq_name         = shift;
      my $sub             = shift;
      my $export_recorder = shift;
      my $meta_lookup     = shift;
  
      return sub {
          my $caller = $CALLER;
  
          my $wrapper = $self->_late_curry_wrapper(
              $sub, $fq_name,
              $meta_lookup => $caller
          );
  
          my $sub = subname( $fq_name => $wrapper );
  
          $export_recorder->{$sub} = 1;
  
          return $sub;
      };
  }
  
  sub _curry_wrapper {
      my $class   = shift;
      my $sub     = shift;
      my $fq_name = shift;
      my @extra   = @_;
  
      my $wrapper = sub { $sub->( @extra, @_ ) };
      if ( my $proto = prototype $sub ) {
  
          # XXX - Perl's prototype sucks. Use & to make set_prototype
          # ignore the fact that we're passing "private variables"
          &Scalar::Util::set_prototype( $wrapper, $proto );
      }
      return $wrapper;
  }
  
  sub _late_curry_wrapper {
      my $class   = shift;
      my $sub     = shift;
      my $fq_name = shift;
      my $extra   = shift;
      my @ex_args = @_;
  
      my $wrapper = sub {
  
          # resolve curried arguments at runtime via this closure
          my @curry = ( $extra->(@ex_args) );
          return $sub->( @curry, @_ );
      };
  
      if ( my $proto = prototype $sub ) {
  
          # XXX - Perl's prototype sucks. Use & to make set_prototype
          # ignore the fact that we're passing "private variables"
          &Scalar::Util::set_prototype( $wrapper, $proto );
      }
      return $wrapper;
  }
  
  sub _make_import_sub {
      shift;
      my $exporting_package = shift;
      my $exporter          = shift;
      my $exports_from      = shift;
      my $is_reexport       = shift;
      my $meta_lookup       = shift;
  
      return sub {
  
          # I think we could use Sub::Exporter's collector feature
          # to do this, but that would be rather gross, since that
          # feature isn't really designed to return a value to the
          # caller of the exporter sub.
          #
          # Also, this makes sure we preserve backwards compat for
          # _get_caller, so it always sees the arguments in the
          # expected order.
          my $traits;
          ( $traits, @_ ) = _strip_traits(@_);
  
          my $metaclass;
          ( $metaclass, @_ ) = _strip_metaclass(@_);
          $metaclass
              = Moose::Util::resolve_metaclass_alias( 'Class' => $metaclass )
              if defined $metaclass && length $metaclass;
  
          my $meta_name;
          ( $meta_name, @_ ) = _strip_meta_name(@_);
  
          # Normally we could look at $_[0], but in some weird cases
          # (involving goto &Moose::import), $_[0] ends as something
          # else (like Squirrel).
          my $class = $exporting_package;
  
          $CALLER = _get_caller(@_);
  
          # this works because both pragmas set $^H (see perldoc
          # perlvar) which affects the current compilation -
          # i.e. the file who use'd us - which is why we don't need
          # to do anything special to make it affect that file
          # rather than this one (which is already compiled)
  
          strict->import;
          warnings->import;
  
          my $did_init_meta;
          for my $c ( grep { $_->can('init_meta') } $class, @{$exports_from} ) {
  
              # init_meta can apply a role, which when loaded uses
              # Moose::Exporter, which in turn sets $CALLER, so we need
              # to protect against that.
              local $CALLER = $CALLER;
              $c->init_meta(
                  for_class => $CALLER,
                  metaclass => $metaclass,
                  meta_name => $meta_name,
              );
              $did_init_meta = 1;
          }
  
          {
              # The metaroles will use Moose::Role, which in turn uses
              # Moose::Exporter, which in turn sets $CALLER, so we need
              # to protect against that.
              local $CALLER = $CALLER;
              _apply_metaroles(
                  $CALLER,
                  [$class, @$exports_from],
                  $meta_lookup
              );
          }
  
          if ( $did_init_meta && @{$traits} ) {
  
              # The traits will use Moose::Role, which in turn uses
              # Moose::Exporter, which in turn sets $CALLER, so we need
              # to protect against that.
              local $CALLER = $CALLER;
              _apply_meta_traits( $CALLER, $traits, $meta_lookup );
          }
          elsif ( @{$traits} ) {
              throw_exception( ClassDoesNotHaveInitMeta => class_name => $class,
                                                           traits     => $traits
                             );
          }
  
          my ( undef, @args ) = @_;
          my $extra = shift @args if ref $args[0] eq 'HASH';
  
          $extra ||= {};
          if ( !$extra->{into} ) {
              $extra->{into_level} ||= 0;
              $extra->{into_level}++;
          }
  
          $class->$exporter( $extra, @args );
      };
  }
  
  sub _strip_option {
      my $option_name = shift;
      my $default = shift;
      for my $i ( 0 .. $#_ - 1 ) {
          if (($_[$i] || '') eq $option_name) {
              (undef, my $value) = splice @_, $i, 2;
              return ( $value, @_ );
          }
      }
      return ( $default, @_ );
  }
  
  sub _strip_traits {
      my ($traits, @other) = _strip_option('-traits', [], @_);
      $traits = ref $traits ? $traits : [ $traits ];
      return ( $traits, @other );
  }
  
  sub _strip_metaclass {
      _strip_option('-metaclass', undef, @_);
  }
  
  sub _strip_meta_name {
      _strip_option('-meta_name', 'meta', @_);
  }
  
  sub _apply_metaroles {
      my ($class, $exports_from, $meta_lookup) = @_;
  
      my $metaroles = _collect_metaroles($exports_from);
      my $base_class_roles = delete $metaroles->{base_class_roles};
  
      my $meta = $meta_lookup->($class);
      # for instance, Moose.pm uses Moose::Util::TypeConstraints
      return unless $meta;
  
      Moose::Util::MetaRole::apply_metaroles(
          for => $meta,
          %$metaroles,
      ) if keys %$metaroles;
  
      Moose::Util::MetaRole::apply_base_class_roles(
          for   => $meta,
          roles => $base_class_roles,
      ) if $meta->isa('Class::MOP::Class')
        && $base_class_roles && @$base_class_roles;
  }
  
  sub _collect_metaroles {
      my ($exports_from) = @_;
  
      my @old_style_role_types = map { "${_}_roles" } qw(
          metaclass
          attribute_metaclass
          method_metaclass
          wrapped_method_metaclass
          instance_metaclass
          constructor_class
          destructor_class
          error_class
      );
  
      my %class_metaroles;
      my %role_metaroles;
      my @base_class_roles;
      my %old_style_roles;
  
      for my $exporter (@$exports_from) {
          my $data = $EXPORT_SPEC{$exporter};
  
          if (exists $data->{class_metaroles}) {
              for my $type (keys %{ $data->{class_metaroles} }) {
                  push @{ $class_metaroles{$type} ||= [] },
                       @{ $data->{class_metaroles}{$type} };
              }
          }
  
          if (exists $data->{role_metaroles}) {
              for my $type (keys %{ $data->{role_metaroles} }) {
                  push @{ $role_metaroles{$type} ||= [] },
                       @{ $data->{role_metaroles}{$type} };
              }
          }
  
          if (exists $data->{base_class_roles}) {
              push @base_class_roles, @{ $data->{base_class_roles} };
          }
  
          for my $type (@old_style_role_types) {
              if (exists $data->{$type}) {
                  push @{ $old_style_roles{$type} ||= [] },
                       @{ $data->{$type} };
              }
          }
      }
  
      return {
          (keys(%class_metaroles)
              ? (class_metaroles  => \%class_metaroles)
              : ()),
          (keys(%role_metaroles)
              ? (role_metaroles   => \%role_metaroles)
              : ()),
          (@base_class_roles
              ? (base_class_roles => \@base_class_roles)
              : ()),
          %old_style_roles,
      };
  }
  
  sub _apply_meta_traits {
      my ( $class, $traits, $meta_lookup ) = @_;
  
      return unless @{$traits};
  
      my $meta = $meta_lookup->($class);
  
      my $type = $meta->isa('Moose::Meta::Role') ? 'Role'
               : $meta->isa('Class::MOP::Class') ? 'Class'
               : confess('Cannot determine metaclass type for '
                             . 'trait application. Meta isa '
                             . ref $meta);
  
      my @resolved_traits = map {
          ref $_
              ? $_
              : Moose::Util::resolve_metatrait_alias( $type => $_ )
      } @$traits;
  
      return unless @resolved_traits;
  
      my %args = ( for => $class );
  
      if ( $meta->isa('Moose::Meta::Role') ) {
          $args{role_metaroles} = { role => \@resolved_traits };
      }
      else {
          $args{class_metaroles} = { class => \@resolved_traits };
      }
  
      Moose::Util::MetaRole::apply_metaroles(%args);
  }
  
  sub _get_caller {
  
      # 1 extra level because it's called by import so there's a layer
      # of indirection
      my $offset = 1;
  
      return
            ( ref $_[1] && defined $_[1]->{into} ) ? $_[1]->{into}
          : ( ref $_[1] && defined $_[1]->{into_level} )
          ? caller( $offset + $_[1]->{into_level} )
          : caller($offset);
  }
  
  sub _make_unimport_sub {
      shift;
      my $exporting_package = shift;
      my $exports           = shift;
      my $export_recorder   = shift;
      my $is_reexport       = shift;
      my $meta_lookup       = shift;
  
      return sub {
          my $caller = _get_caller(@_);
          Moose::Exporter->_remove_keywords(
              $caller,
              [ keys %{$exports} ],
              $export_recorder,
              $is_reexport,
          );
      };
  }
  
  sub _remove_keywords {
      shift;
      my $package          = shift;
      my $keywords         = shift;
      my $recorded_exports = shift;
      my $is_reexport      = shift;
  
      no strict 'refs';
  
      foreach my $name ( @{$keywords} ) {
          if ( defined &{ $package . '::' . $name } ) {
              my $sub = \&{ $package . '::' . $name };
  
              # make sure it is from us
              next unless $recorded_exports->{$sub};
  
              if ( $is_reexport->{$name} ) {
                  no strict 'refs';
                  next
                      unless _export_is_flagged(
                              \*{ join q{::} => $package, $name } );
              }
  
              # and if it is from us, then undef the slot
              delete ${ $package . '::' }{$name};
          }
      }
  }
  
  # maintain this for now for backcompat
  # make sure to return a sub to install in the same circumstances as previously
  # but this functionality now happens at the end of ->import
  sub _make_init_meta {
      shift;
      my $class          = shift;
      my $args           = shift;
      my $meta_lookup    = shift;
  
      my %old_style_roles;
      for my $role (
          map {"${_}_roles"}
          qw(
          metaclass
          attribute_metaclass
          method_metaclass
          wrapped_method_metaclass
          instance_metaclass
          constructor_class
          destructor_class
          error_class
          )
          ) {
          $old_style_roles{$role} = $args->{$role}
              if exists $args->{$role};
      }
  
      my %base_class_roles;
      %base_class_roles = ( roles => $args->{base_class_roles} )
          if exists $args->{base_class_roles};
  
      my %new_style_roles = map { $_ => $args->{$_} }
          grep { exists $args->{$_} } qw( class_metaroles role_metaroles );
  
      return unless %new_style_roles || %old_style_roles || %base_class_roles;
  
      return sub {
          shift;
          my %opts = @_;
          $meta_lookup->($opts{for_class});
      };
  }
  
  sub import {
      strict->import;
      warnings->import;
  }
  
  1;
  
  # ABSTRACT: make an import() and unimport() just like Moose.pm
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Exporter - make an import() and unimport() just like Moose.pm
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 SYNOPSIS
  
    package MyApp::Moose;
  
    use Moose ();
    use Moose::Exporter;
    use Some::Random ();
  
    Moose::Exporter->setup_import_methods(
        with_meta => [ 'has_rw', 'sugar2' ],
        as_is     => [ 'sugar3', \&Some::Random::thing, 'Some::Random::other_thing' ],
        also      => 'Moose',
    );
  
    sub has_rw {
        my ( $meta, $name, %options ) = @_;
        $meta->add_attribute(
            $name,
            is => 'rw',
            %options,
        );
    }
  
    # then later ...
    package MyApp::User;
  
    use MyApp::Moose;
  
    has 'name' => ( is => 'ro' );
    has_rw 'size';
    thing;
    other_thing;
  
    no MyApp::Moose;
  
  =head1 DESCRIPTION
  
  This module encapsulates the exporting of sugar functions in a
  C<Moose.pm>-like manner. It does this by building custom C<import> and
  C<unimport> methods for your module, based on a spec you provide.
  
  It also lets you "stack" Moose-alike modules so you can export Moose's sugar
  as well as your own, along with sugar from any random C<MooseX> module, as
  long as they all use C<Moose::Exporter>. This feature exists to let you bundle
  a set of MooseX modules into a policy module that developers can use directly
  instead of using Moose itself.
  
  To simplify writing exporter modules, C<Moose::Exporter> also imports
  C<strict> and C<warnings> into your exporter module, as well as into
  modules that use it.
  
  =head1 METHODS
  
  This module provides two public methods:
  
  =head2 Moose::Exporter->setup_import_methods(...)
  
  When you call this method, C<Moose::Exporter> builds custom C<import> and
  C<unimport> methods for your module. The C<import> method
  will export the functions you specify, and can also re-export functions
  exported by some other module (like C<Moose.pm>). If you pass any parameters
  for L<Moose::Util::MetaRole>, the C<import> method will also call
  L<Moose::Util::MetaRole::apply_metaroles|Moose::Util::MetaRole/apply_metaroles> and
  L<Moose::Util::MetaRole::apply_base_class_roles|Moose::Util::MetaRole/apply_base_class_roles> as needed, after making
  sure the metaclass is initialized.
  
  The C<unimport> method cleans the caller's namespace of all the exported
  functions. This includes any functions you re-export from other
  packages. However, if the consumer of your package also imports those
  functions from the original package, they will I<not> be cleaned.
  
  Note that if any of these methods already exist, they will not be
  overridden, you will have to use C<build_import_methods> to get the
  coderef that would be installed.
  
  This method accepts the following parameters:
  
  =over 4
  
  =item * with_meta => [ ... ]
  
  This list of function I<names only> will be wrapped and then exported. The
  wrapper will pass the metaclass object for the caller as its first argument.
  
  Many sugar functions will need to use this metaclass object to do something to
  the calling package.
  
  =item * as_is => [ ... ]
  
  This list of function names or sub references will be exported as-is. You can
  identify a subroutine by reference, which is handy to re-export some other
  module's functions directly by reference (C<\&Some::Package::function>).
  
  If you do export some other package's function, this function will never be
  removed by the C<unimport> method. The reason for this is we cannot know if
  the caller I<also> explicitly imported the sub themselves, and therefore wants
  to keep it.
  
  =item * trait_aliases => [ ... ]
  
  This is a list of package names which should have shortened aliases exported,
  similar to the functionality of L<aliased>. Each element in the list can be
  either a package name, in which case the export will be named as the last
  namespace component of the package, or an arrayref, whose first element is the
  package to alias to, and second element is the alias to export.
  
  =item * also => $name or \@names
  
  This is a list of modules which contain functions that the caller
  wants to export. These modules must also use C<Moose::Exporter>. The
  most common use case will be to export the functions from C<Moose.pm>.
  Functions specified by C<with_meta> or C<as_is> take precedence over
  functions exported by modules specified by C<also>, so that a module
  can selectively override functions exported by another module.
  
  C<Moose::Exporter> also makes sure all these functions get removed
  when C<unimport> is called.
  
  =item * meta_lookup => sub { ... }
  
  This is a function which will be called to provide the metaclass
  to be operated upon by the exporter. This is an advanced feature
  intended for use by package generator modules in the vein of
  L<MooseX::Role::Parameterized> in order to simplify reusing sugar
  from other modules that use C<Moose::Exporter>. This function is
  used, for example, to select the metaclass to bind to functions
  that are exported using the C<with_meta> option.
  
  This function will receive one parameter: the class name into which
  the sugar is being exported. The default implementation is:
  
      sub { Class::MOP::class_of(shift) }
  
  Accordingly, this function is expected to return a metaclass.
  
  =back
  
  You can also provide parameters for L<Moose::Util::MetaRole::apply_metaroles|Moose::Util::MetaRole/apply_metaroles>
  and L<Moose::Util::MetaRole::apply_base_class_roles|Moose::Util::MetaRole/apply_base_class_roles>. Specifically, valid parameters
  are "class_metaroles", "role_metaroles", and "base_class_roles".
  
  =head2 Moose::Exporter->build_import_methods(...)
  
  Returns three code refs, one for C<import>, one for C<unimport> and one for
  C<init_meta>.
  
  Accepts the additional C<install> option, which accepts an arrayref of method
  names to install into your exporting package. The valid options are C<import>
  and C<unimport>. Calling C<setup_import_methods> is equivalent
  to calling C<build_import_methods> with C<< install => [qw(import unimport)] >>
  except that it doesn't also return the methods.
  
  The C<import> method is built using L<Sub::Exporter>. This means that it can
  take a hashref of the form C<< { into => $package } >> to specify the package
  it operates on.
  
  Used by C<setup_import_methods>.
  
  =head1 IMPORTING AND init_meta
  
  If you want to set an alternative base object class or metaclass class, see
  above for details on how this module can call L<Moose::Util::MetaRole> for
  you.
  
  If you want to do something that is not supported by this module, simply
  define an C<init_meta> method in your class. The C<import> method that
  C<Moose::Exporter> generates for you will call this method (if it exists). It
  will always pass the caller to this method via the C<for_class> parameter.
  
  Most of the time, your C<init_meta> method will probably just call C<<
  Moose->init_meta >> to do the real work:
  
    sub init_meta {
        shift; # our class name
        return Moose->init_meta( @_, metaclass => 'My::Metaclass' );
    }
  
  =head1 METACLASS TRAITS
  
  The C<import> method generated by C<Moose::Exporter> will allow the
  user of your module to specify metaclass traits in a C<-traits>
  parameter passed as part of the import:
  
    use Moose -traits => 'My::Meta::Trait';
  
    use Moose -traits => [ 'My::Meta::Trait', 'My::Other::Trait' ];
  
  These traits will be applied to the caller's metaclass
  instance. Providing traits for an exporting class that does not create
  a metaclass for the caller is an error.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_EXPORTER

$fatpacked{"darwin-2level/Moose/Meta/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_ATTRIBUTE';
  use strict;
  use warnings;
  package Moose::Meta::Attribute;
  our $VERSION = '2.2011';
  
  use B ();
  use Scalar::Util 'blessed';
  use List::Util 1.33 'any';
  use Try::Tiny;
  use overload     ();
  
  use Moose::Deprecated;
  use Moose::Meta::Method::Accessor;
  use Moose::Meta::Method::Delegation;
  use Moose::Util 'throw_exception';
  use Moose::Util::TypeConstraints ();
  use Class::MOP::MiniTrait;
  
  use parent 'Class::MOP::Attribute', 'Moose::Meta::Mixin::AttributeCore';
  
  use Carp 'confess';
  
  Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
  
  __PACKAGE__->meta->add_attribute('traits' => (
      reader    => 'applied_traits',
      predicate => 'has_applied_traits',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('role_attribute' => (
      reader    => 'role_attribute',
      predicate => 'has_role_attribute',
      Class::MOP::_definition_context(),
  ));
  
  # we need to have a ->does method in here to
  # more easily support traits, and the introspection
  # of those traits. We extend the does check to look
  # for metatrait aliases.
  sub does {
      my ($self, $role_name) = @_;
      my $name = try {
          Moose::Util::resolve_metatrait_alias(Attribute => $role_name)
      };
      return 0 if !defined($name); # failed to load class
      return $self->Moose::Object::does($name);
  }
  
  sub _inline_throw_exception {
      my ( $self, $exception_type, $throw_args ) = @_;
      return 'die Module::Runtime::use_module("Moose::Exception::' . $exception_type . '")->new(' . ($throw_args || '') . ')';
  }
  
  sub new {
      my ($class, $name, %options) = @_;
      $class->_process_options($name, \%options) unless $options{__hack_no_process_options}; # used from clone()... YECHKKK FIXME ICKY YUCK GROSS
  
      delete $options{__hack_no_process_options};
  
      my %attrs =
          ( map { $_ => 1 }
            grep { defined }
            map { $_->init_arg() }
            $class->meta()->get_all_attributes()
          );
  
      my @bad = sort grep { ! $attrs{$_} }  keys %options;
  
      if (@bad)
      {
          my $s = @bad > 1 ? 's' : '';
          my $list = join "', '", @bad;
  
          my $package = $options{definition_context}{package};
          my $context = $options{definition_context}{context}
                     || 'attribute constructor';
          my $type = $options{definition_context}{type} || 'class';
  
          my $location = '';
          if (defined($package)) {
              $location = " in ";
              $location .= "$type " if $type;
              $location .= $package;
          }
  
          Carp::cluck "Found unknown argument$s '$list' in the $context for '$name'$location";
      }
  
      return $class->SUPER::new($name, %options);
  }
  
  sub interpolate_class_and_new {
      my $class = shift;
      my $name  = shift;
  
      throw_exception( MustPassEvenNumberOfAttributeOptions => attribute_name => $name,
                                                               options        => \@_
                     )
          if @_ % 2 == 1;
  
      my %args = @_;
  
      my ( $new_class, @traits ) = $class->interpolate_class(\%args);
      $new_class->new($name, %args, ( scalar(@traits) ? ( traits => \@traits ) : () ) );
  }
  
  sub interpolate_class {
      my ($class, $options) = @_;
  
      $class = ref($class) || $class;
  
      if ( my $metaclass_name = delete $options->{metaclass} ) {
          my $new_class = Moose::Util::resolve_metaclass_alias( Attribute => $metaclass_name );
  
          if ( $class ne $new_class ) {
              if ( $new_class->can("interpolate_class") ) {
                  return $new_class->interpolate_class($options);
              } else {
                  $class = $new_class;
              }
          }
      }
  
      my @traits;
  
      if (my $traits = $options->{traits}) {
          my $i = 0;
          my $has_foreign_options = 0;
  
          while ($i < @$traits) {
              my $trait = $traits->[$i++];
              next if ref($trait); # options to a trait we discarded
  
              $trait = Moose::Util::resolve_metatrait_alias(Attribute => $trait)
                    || $trait;
  
              next if $class->does($trait);
  
              push @traits, $trait;
  
              # are there options?
              if ($traits->[$i] && ref($traits->[$i])) {
                  $has_foreign_options = 1
                      if any { $_ ne '-alias' && $_ ne '-excludes' } keys %{ $traits->[$i] };
  
                  push @traits, $traits->[$i++];
              }
          }
  
          if (@traits) {
              my %options = (
                  superclasses => [ $class ],
                  roles        => [ @traits ],
              );
  
              if ($has_foreign_options) {
                  $options{weaken} = 0;
              }
              else {
                  $options{cache} = 1;
              }
  
              my $anon_class = Moose::Meta::Class->create_anon_class(%options);
              $class = $anon_class->name;
          }
      }
  
      return ( wantarray ? ( $class, @traits ) : $class );
  }
  
  # ...
  
  # method-generating options shouldn't be overridden
  sub illegal_options_for_inheritance {
      qw(reader writer accessor clearer predicate)
  }
  
  # NOTE/TODO
  # This method *must* be able to handle
  # Class::MOP::Attribute instances as
  # well. Yes, I know that is wrong, but
  # apparently we didn't realize it was
  # doing that and now we have some code
  # which is dependent on it. The real
  # solution of course is to push this
  # feature back up into Class::MOP::Attribute
  # but I not right now, I am too lazy.
  # However if you are reading this and
  # looking for something to do,.. please
  # be my guest.
  # - stevan
  sub clone_and_inherit_options {
      my ($self, %options) = @_;
  
      # NOTE:
      # we may want to extends a Class::MOP::Attribute
      # in which case we need to be able to use the
      # core set of legal options that have always
      # been here. But we allows Moose::Meta::Attribute
      # instances to changes them.
      # - SL
      my @illegal_options = $self->can('illegal_options_for_inheritance')
          ? $self->illegal_options_for_inheritance
          : ();
  
      my @found_illegal_options = grep { exists $options{$_} && exists $self->{$_} ? $_ : undef } @illegal_options;
      (scalar @found_illegal_options == 0)
          || throw_exception( IllegalInheritedOptions => illegal_options => \@found_illegal_options,
                                                         params          => \%options
                            );
  
      $self->_process_isa_option( $self->name, \%options );
      $self->_process_does_option( $self->name, \%options );
  
      # NOTE:
      # this doesn't apply to Class::MOP::Attributes,
      # so we can ignore it for them.
      # - SL
      if ($self->can('interpolate_class')) {
          ( $options{metaclass}, my @traits ) = $self->interpolate_class(\%options);
  
          my %seen;
          my @all_traits = grep { $seen{$_}++ } @{ $self->applied_traits || [] }, @traits;
          $options{traits} = \@all_traits if @all_traits;
      }
  
      # This method can be called on a CMOP::Attribute object, so we need to
      # make sure we can call this method.
      $self->_process_lazy_build_option( $self->name, \%options )
          if $self->can('_process_lazy_build_option');
  
      $self->clone(%options);
  }
  
  sub clone {
      my ( $self, %params ) = @_;
  
      my $class = delete $params{metaclass} || ref $self;
  
      my ( @init, @non_init );
  
      foreach my $attr ( grep { $_->has_value($self) } Class::MOP::class_of($self)->get_all_attributes ) {
          push @{ $attr->has_init_arg ? \@init : \@non_init }, $attr;
      }
  
      my %new_params = ( ( map { $_->init_arg => $_->get_value($self) } @init ), %params );
  
      my $name = delete $new_params{name};
  
      my $clone = $class->new($name, %new_params, __hack_no_process_options => 1 );
  
      foreach my $attr ( @non_init ) {
          $attr->set_value($clone, $attr->get_value($self));
      }
  
      return $clone;
  }
  
  sub _process_options {
      my ( $class, $name, $options ) = @_;
  
      $class->_process_is_option( $name, $options );
      $class->_process_isa_option( $name, $options );
      $class->_process_does_option( $name, $options );
      $class->_process_coerce_option( $name, $options );
      $class->_process_trigger_option( $name, $options );
      $class->_process_auto_deref_option( $name, $options );
      $class->_process_lazy_build_option( $name, $options );
      $class->_process_lazy_option( $name, $options );
      $class->_process_required_option( $name, $options );
  }
  
  sub _process_is_option {
      my ( $class, $name, $options ) = @_;
  
      return unless $options->{is};
  
      ### -------------------------
      ## is => ro, writer => _foo    # turns into (reader => foo, writer => _foo) as before
      ## is => rw, writer => _foo    # turns into (reader => foo, writer => _foo)
      ## is => rw, accessor => _foo  # turns into (accessor => _foo)
      ## is => ro, accessor => _foo  # error, accesor is rw
      ### -------------------------
  
      if ( $options->{is} eq 'ro' ) {
          throw_exception("AccessorMustReadWrite" => attribute_name => $name,
                                                     params         => $options,
                         )
              if exists $options->{accessor};
          $options->{reader} ||= $name;
      }
      elsif ( $options->{is} eq 'rw' ) {
          if ( ! $options->{accessor} ) {
              if ( $options->{writer}) {
                  $options->{reader} ||= $name;
              }
              else {
                  $options->{accessor} = $name;
              }
          }
      }
      elsif ( $options->{is} eq 'bare' ) {
          return;
          # do nothing, but don't complain (later) about missing methods
      }
      else {
          throw_exception( InvalidValueForIs => attribute_name => $name,
                                                params         => $options,
                         );
      }
  }
  
  sub _process_isa_option {
      my ( $class, $name, $options ) = @_;
  
      return unless exists $options->{isa};
  
      if ( exists $options->{does} ) {
          if ( try { $options->{isa}->can('does') } ) {
              ( $options->{isa}->does( $options->{does} ) )
                  || throw_exception( IsaDoesNotDoTheRole => attribute_name => $name,
                                                             params         => $options,
                                    );
          }
          else {
              throw_exception( IsaLacksDoesMethod => attribute_name => $name,
                                                     params         => $options,
                             );
          }
      }
  
      # allow for anon-subtypes here ...
      #
      # There are a _lot_ of methods that we expect from TC objects, but
      # checking for a specific parent class via ->isa is gross, so we'll check
      # for at least one method.
      if ( blessed( $options->{isa} )
          && $options->{isa}->can('has_coercion') ) {
  
          $options->{type_constraint} = $options->{isa};
      }
      else {
          $options->{type_constraint}
              = Moose::Util::TypeConstraints::find_or_create_isa_type_constraint(
              $options->{isa},
              { package_defined_in => $options->{definition_context}->{package} }
          );
      }
  }
  
  sub _process_does_option {
      my ( $class, $name, $options ) = @_;
  
      return unless exists $options->{does} && ! exists $options->{isa};
  
      # allow for anon-subtypes here ...
      if ( blessed( $options->{does} )
          && $options->{does}->can('has_coercion') ) {
  
          $options->{type_constraint} = $options->{does};
      }
      else {
          $options->{type_constraint}
              = Moose::Util::TypeConstraints::find_or_create_does_type_constraint(
              $options->{does},
              { package_defined_in => $options->{definition_context}->{package} }
          );
      }
  }
  
  sub _process_coerce_option {
      my ( $class, $name, $options ) = @_;
  
      return unless $options->{coerce};
  
      ( exists $options->{type_constraint} )
          || throw_exception( CoercionNeedsTypeConstraint => attribute_name => $name,
                                                             params         => $options,
                            );
  
      throw_exception( CannotCoerceAWeakRef => attribute_name => $name,
                                               params         => $options,
                     )
          if $options->{weak_ref};
  
      unless ( $options->{type_constraint}->has_coercion ) {
          my $type = $options->{type_constraint}->name;
  
          throw_exception( CannotCoerceAttributeWhichHasNoCoercion => attribute_name => $name,
                                                                      type_name      => $type,
                                                                      params         => $options
                         );
      }
  }
  
  sub _process_trigger_option {
      my ( $class, $name, $options ) = @_;
  
      return unless exists $options->{trigger};
  
      ( 'CODE' eq ref $options->{trigger} )
          || throw_exception( TriggerMustBeACodeRef => attribute_name => $name,
                                                       params         => $options,
                            );
  }
  
  sub _process_auto_deref_option {
      my ( $class, $name, $options ) = @_;
  
      return unless $options->{auto_deref};
  
      ( exists $options->{type_constraint} )
          || throw_exception( CannotAutoDerefWithoutIsa => attribute_name => $name,
                                                           params         => $options,
                            );
  
      ( $options->{type_constraint}->is_a_type_of('ArrayRef')
        || $options->{type_constraint}->is_a_type_of('HashRef') )
          || throw_exception( AutoDeRefNeedsArrayRefOrHashRef => attribute_name => $name,
                                                                 params         => $options,
                            );
  }
  
  sub _process_lazy_build_option {
      my ( $class, $name, $options ) = @_;
  
      return unless $options->{lazy_build};
  
      throw_exception( CannotUseLazyBuildAndDefaultSimultaneously => attribute_name => $name,
                                                                     params         => $options,
                     )
          if exists $options->{default};
  
      $options->{lazy} = 1;
      $options->{builder} ||= "_build_${name}";
  
      if ( $name =~ /^_/ ) {
          $options->{clearer}   ||= "_clear${name}";
          $options->{predicate} ||= "_has${name}";
      }
      else {
          $options->{clearer}   ||= "clear_${name}";
          $options->{predicate} ||= "has_${name}";
      }
  }
  
  sub _process_lazy_option {
      my ( $class, $name, $options ) = @_;
  
      return unless $options->{lazy};
  
      ( exists $options->{default} || defined $options->{builder} )
          || throw_exception( LazyAttributeNeedsADefault => params         => $options,
                                                            attribute_name => $name,
                            );
  }
  
  sub _process_required_option {
      my ( $class, $name, $options ) = @_;
  
      if (
          $options->{required}
          && !(
              ( !exists $options->{init_arg} || defined $options->{init_arg} )
              || exists $options->{default}
              || defined $options->{builder}
          )
          ) {
          throw_exception( RequiredAttributeNeedsADefault => params         => $options,
                                                             attribute_name => $name,
                         );
      }
  }
  
  sub initialize_instance_slot {
      my ($self, $meta_instance, $instance, $params) = @_;
      my $init_arg = $self->init_arg();
      # try to fetch the init arg from the %params ...
  
      my $val;
      my $value_is_set;
      if ( defined($init_arg) and exists $params->{$init_arg}) {
          $val = $params->{$init_arg};
          $value_is_set = 1;
      }
      else {
          # skip it if it's lazy
          return if $self->is_lazy;
          # and die if it's required and doesn't have a default value
          my $class_name = blessed( $instance );
          throw_exception(
              'AttributeIsRequired',
              attribute_name => $self->name,
              ( defined $init_arg ? ( attribute_init_arg => $init_arg ) : () ),
              class_name => $class_name,
              params     => $params,
              )
              if $self->is_required
              && !$self->has_default
              && !$self->has_builder;
  
          # if nothing was in the %params, we can use the
          # attribute's default value (if it has one)
          if ($self->has_default) {
              $val = $self->default($instance);
              $value_is_set = 1;
          }
          elsif ($self->has_builder) {
              $val = $self->_call_builder($instance);
              $value_is_set = 1;
          }
      }
  
      return unless $value_is_set;
  
      $val = $self->_coerce_and_verify( $val, $instance );
  
      $self->set_initial_value($instance, $val);
  
      if ( ref $val && $self->is_weak_ref ) {
          $self->_weaken_value($instance);
      }
  }
  
  sub _call_builder {
      my ( $self, $instance ) = @_;
  
      my $builder = $self->builder();
  
      return $instance->$builder()
          if $instance->can( $self->builder );
  
      throw_exception( BuilderDoesNotExist => instance  => $instance,
                                              attribute => $self,
                     );
  }
  
  ## Slot management
  
  sub _make_initializer_writer_callback {
      my $self = shift;
      my ($meta_instance, $instance, $slot_name) = @_;
      my $old_callback = $self->SUPER::_make_initializer_writer_callback(@_);
      return sub {
          $old_callback->($self->_coerce_and_verify($_[0], $instance));
      };
  }
  
  sub set_value {
      my ($self, $instance, @args) = @_;
      my $value = $args[0];
  
      my $class_name = blessed( $instance );
      if ($self->is_required and not @args) {
          throw_exception(
              'AttributeIsRequired',
              attribute_name => $self->name,
              (
                  defined $self->init_arg
                  ? ( attribute_init_arg => $self->init_arg )
                  : ()
              ),
              class_name => $class_name,
          );
      }
  
      $value = $self->_coerce_and_verify( $value, $instance );
  
      my @old;
      if ( $self->has_trigger && $self->has_value($instance) ) {
          @old = $self->get_value($instance, 'for trigger');
      }
  
      $self->SUPER::set_value($instance, $value);
  
      if ( ref $value && $self->is_weak_ref ) {
          $self->_weaken_value($instance);
      }
  
      if ($self->has_trigger) {
          $self->trigger->($instance, $value, @old);
      }
  }
  
  sub _inline_set_value {
      my $self = shift;
      my ($instance, $value, $tc, $coercion, $message, $for_constructor) = @_;
  
      my $old     = '@old';
      my $copy    = '$val';
      $tc       ||= '$type_constraint';
      $coercion ||= '$type_coercion';
      $message  ||= '$type_message';
  
      my @code;
      if ($self->_writer_value_needs_copy) {
          push @code, $self->_inline_copy_value($value, $copy);
          $value = $copy;
      }
  
      # constructors already handle required checks
      push @code, $self->_inline_check_required
          unless $for_constructor;
  
      push @code, $self->_inline_tc_code($value, $tc, $coercion, $message);
  
      # constructors do triggers all at once at the end
      push @code, $self->_inline_get_old_value_for_trigger($instance, $old)
          unless $for_constructor;
  
      push @code, (
          $self->SUPER::_inline_set_value($instance, $value),
          $self->_inline_weaken_value($instance, $value),
      );
  
      # constructors do triggers all at once at the end
      push @code, $self->_inline_trigger($instance, $value, $old)
          unless $for_constructor;
  
      return @code;
  }
  
  sub _writer_value_needs_copy {
      my $self = shift;
      return $self->should_coerce;
  }
  
  sub _inline_copy_value {
      my $self = shift;
      my ($value, $copy) = @_;
  
      return 'my ' . $copy . ' = ' . $value . ';'
  }
  
  sub _inline_check_required {
      my $self = shift;
  
      return unless $self->is_required;
  
      my $throw_params = sprintf( <<'EOF', quotemeta( $self->name ) );
  attribute_name => "%s",
  class_name     => $class_name,
  EOF
      $throw_params .= sprintf(
          'attribute_init_arg => "%s",',
          quotemeta( $self->init_arg )
      ) if defined $self->init_arg;
  
      my $throw = $self->_inline_throw_exception(
          'AttributeIsRequired',
          $throw_params
      );
  
      return sprintf( <<'EOF', $throw );
  if ( @_ < 2 ) {
      %s;
  }
  EOF
  }
  
  sub _inline_tc_code {
      my $self = shift;
      my ($value, $tc, $coercion, $message, $is_lazy) = @_;
      return (
          $self->_inline_check_coercion(
              $value, $tc, $coercion, $is_lazy,
          ),
          $self->_inline_check_constraint(
              $value, $tc, $message, $is_lazy,
          ),
      );
  }
  
  sub _inline_check_coercion {
      my $self = shift;
      my ($value, $tc, $coercion) = @_;
  
      return unless $self->should_coerce && $self->type_constraint->has_coercion;
  
      if ( $self->type_constraint->can_be_inlined ) {
          return (
              'if (! (' . $self->type_constraint->_inline_check($value) . ')) {',
                  $value . ' = ' . $coercion . '->(' . $value . ');',
              '}',
          );
      }
      else {
          return (
              'if (!' . $tc . '->(' . $value . ')) {',
                  $value . ' = ' . $coercion . '->(' . $value . ');',
              '}',
          );
      }
  }
  
  sub _inline_check_constraint {
      my $self = shift;
      my ($value, $tc, $message) = @_;
  
      return unless $self->has_type_constraint;
  
      my $attr_name = quotemeta($self->name);
  
      if ( $self->type_constraint->can_be_inlined ) {
          return (
              'if (! (' . $self->type_constraint->_inline_check($value) . ')) {',
                  'my $msg = do { local $_ = ' . $value . '; '
                  . $message . '->(' . $value . ');'
                  . '};'.
                  $self->_inline_throw_exception( ValidationFailedForInlineTypeConstraint =>
                                                  'type_constraint_message => $msg , '.
                                                  'class_name              => $class_name, '.
                                                  'attribute_name          => "'.$attr_name.'",'.
                                                  'value                   => '.$value
                  ).';',
              '}',
          );
      }
      else {
          return (
              'if (!' . $tc . '->(' . $value . ')) {',
                  'my $msg = do { local $_ = ' . $value . '; '
                  . $message . '->(' . $value . ');'
                  . '};'.
                  $self->_inline_throw_exception( ValidationFailedForInlineTypeConstraint =>
                                                  'type_constraint_message => $msg , '.
                                                  'class_name              => $class_name, '.
                                                  'attribute_name          => "'.$attr_name.'",'.
                                                  'value                   => '.$value
                  ).';',
              '}',
          );
      }
  }
  
  sub _inline_get_old_value_for_trigger {
      my $self = shift;
      my ($instance, $old) = @_;
  
      return unless $self->has_trigger;
  
      return (
          'my ' . $old . ' = ' . $self->_inline_instance_has($instance),
              '? ' . $self->_inline_instance_get($instance),
              ': ();',
      );
  }
  
  sub _inline_weaken_value {
      my $self = shift;
      my ($instance, $value) = @_;
  
      return unless $self->is_weak_ref;
  
      my $mi = $self->associated_class->get_meta_instance;
      return (
          $mi->inline_weaken_slot_value($instance, $self->name),
              'if ref ' . $value . ';',
      );
  }
  
  sub _inline_trigger {
      my $self = shift;
      my ($instance, $value, $old) = @_;
  
      return unless $self->has_trigger;
  
      return '$trigger->(' . $instance . ', ' . $value . ', ' . $old . ');';
  }
  
  sub _eval_environment {
      my $self = shift;
  
      my $env = { };
  
      $env->{'$trigger'} = \($self->trigger)
          if $self->has_trigger;
      $env->{'$attr_default'} = \($self->default)
          if $self->has_default;
  
      if ($self->has_type_constraint) {
          my $tc_obj = $self->type_constraint;
  
          $env->{'$type_constraint'} = \(
              $tc_obj->_compiled_type_constraint
          ) unless $tc_obj->can_be_inlined;
          # these two could probably get inlined versions too
          $env->{'$type_coercion'} = \(
              $tc_obj->coercion->_compiled_type_coercion
          ) if $tc_obj->has_coercion;
          $env->{'$type_message'} = \(
              $tc_obj->has_message ? $tc_obj->message : $tc_obj->_default_message
          );
  
          $env = { %$env, %{ $tc_obj->inline_environment } };
      }
  
      $env->{'$class_name'} = \($self->associated_class->name);
  
      # XXX ugh, fix these
      $env->{'$attr'} = \$self
          if $self->has_initializer && $self->is_lazy;
      # pretty sure this is only going to be closed over if you use a custom
      # error class at this point, but we should still get rid of this
      # at some point
      $env->{'$meta'} = \($self->associated_class);
  
      return $env;
  }
  
  sub _weaken_value {
      my ( $self, $instance ) = @_;
  
      my $meta_instance = Class::MOP::Class->initialize( blessed($instance) )
          ->get_meta_instance;
  
      $meta_instance->weaken_slot_value( $instance, $self->name );
  }
  
  sub get_value {
      my ($self, $instance, $for_trigger) = @_;
  
      if ($self->is_lazy) {
          unless ($self->has_value($instance)) {
              my $value;
              if ($self->has_default) {
                  $value = $self->default($instance);
              } elsif ( $self->has_builder ) {
                  $value = $self->_call_builder($instance);
              }
  
              $value = $self->_coerce_and_verify( $value, $instance );
  
              $self->set_initial_value($instance, $value);
  
              if ( ref $value && $self->is_weak_ref ) {
                  $self->_weaken_value($instance);
              }
          }
      }
  
      if ( $self->should_auto_deref && ! $for_trigger ) {
  
          my $type_constraint = $self->type_constraint;
  
          if ($type_constraint->is_a_type_of('ArrayRef')) {
              my $rv = $self->SUPER::get_value($instance);
              return unless defined $rv;
              return wantarray ? @{ $rv } : $rv;
          }
          elsif ($type_constraint->is_a_type_of('HashRef')) {
              my $rv = $self->SUPER::get_value($instance);
              return unless defined $rv;
              return wantarray ? %{ $rv } : $rv;
          }
          else {
              throw_exception( CannotAutoDereferenceTypeConstraint => type_name => $type_constraint->name,
                                                                      instance  => $instance,
                                                                      attribute => $self
                             );
          }
  
      }
      else {
  
          return $self->SUPER::get_value($instance);
      }
  }
  
  sub _inline_get_value {
      my $self = shift;
      my ($instance, $tc, $coercion, $message) = @_;
  
      my $slot_access = $self->_inline_instance_get($instance);
      $tc           ||= '$type_constraint';
      $coercion     ||= '$type_coercion';
      $message      ||= '$type_message';
  
      return (
          $self->_inline_check_lazy($instance, $tc, $coercion, $message),
          $self->_inline_return_auto_deref($slot_access),
      );
  }
  
  sub _inline_check_lazy {
      my $self = shift;
      my ($instance, $tc, $coercion, $message) = @_;
  
      return unless $self->is_lazy;
  
      my $slot_exists = $self->_inline_instance_has($instance);
  
      return (
          'if (!' . $slot_exists . ') {',
              $self->_inline_init_from_default($instance, '$default', $tc, $coercion, $message, 'lazy'),
          '}',
      );
  }
  
  sub _inline_init_from_default {
      my $self = shift;
      my ($instance, $default, $tc, $coercion, $message, $for_lazy) = @_;
  
      if (!($self->has_default || $self->has_builder)) {
          throw_exception( LazyAttributeNeedsADefault => attribute => $self );
      }
  
      return (
          $self->_inline_generate_default($instance, $default),
          # intentionally not using _inline_tc_code, since that can be overridden
          # to do things like possibly only do member tc checks, which isn't
          # appropriate for checking the result of a default
          $self->has_type_constraint
              ? ($self->_inline_check_coercion($default, $tc, $coercion, $for_lazy),
                 $self->_inline_check_constraint($default, $tc, $message, $for_lazy))
              : (),
          $self->_inline_init_slot($instance, $default),
          $self->_inline_weaken_value($instance, $default),
      );
  }
  
  sub _inline_generate_default {
      my $self = shift;
      my ($instance, $default) = @_;
  
      if ($self->has_default) {
          my $source = 'my ' . $default . ' = $attr_default';
          $source .= '->(' . $instance . ')'
              if $self->is_default_a_coderef;
          return $source . ';';
      }
      elsif ($self->has_builder) {
          my $builder = B::perlstring($self->builder);
          my $builder_str = quotemeta($self->builder);
          my $attr_name_str = quotemeta($self->name);
          return (
              'my ' . $default . ';',
              'if (my $builder = ' . $instance . '->can(' . $builder . ')) {',
                  $default . ' = ' . $instance . '->$builder;',
              '}',
              'else {',
                  'my $class = ref(' . $instance . ') || ' . $instance . ';',
                  $self->_inline_throw_exception(
                      BuilderMethodNotSupportedForInlineAttribute =>
                      'class_name     => $class,'.
                      'attribute_name => "'.$attr_name_str.'",'.
                      'instance       => '.$instance.','.
                      'builder        => "'.$builder_str.'"'
                  ) . ';',
              '}',
          );
      }
      else {
          confess(
              "Can't generate a default for " . $self->name
            . " since no default or builder was specified"
          );
      }
  }
  
  sub _inline_init_slot {
      my $self = shift;
      my ($inv, $value) = @_;
  
      if ($self->has_initializer) {
          return '$attr->set_initial_value(' . $inv . ', ' . $value . ');';
      }
      else {
          return $self->_inline_instance_set($inv, $value) . ';';
      }
  }
  
  sub _inline_return_auto_deref {
      my $self = shift;
  
      return 'return ' . $self->_auto_deref(@_) . ';';
  }
  
  sub _auto_deref {
      my $self = shift;
      my ($ref_value) = @_;
  
      return $ref_value unless $self->should_auto_deref;
  
      my $type_constraint = $self->type_constraint;
  
      my $sigil;
      if ($type_constraint->is_a_type_of('ArrayRef')) {
          $sigil = '@';
      }
      elsif ($type_constraint->is_a_type_of('HashRef')) {
          $sigil = '%';
      }
      else {
          confess(
              'Can not auto de-reference the type constraint \''
            . $type_constraint->name
            . '\''
          );
      }
  
      return 'wantarray '
               . '? ' . $sigil . '{ (' . $ref_value . ') || return } '
               . ': (' . $ref_value . ')';
  }
  
  ## installing accessors
  
  sub accessor_metaclass { 'Moose::Meta::Method::Accessor' }
  
  sub install_accessors {
      my $self = shift;
      $self->SUPER::install_accessors(@_);
      $self->install_delegation if $self->has_handles;
      return;
  }
  
  sub _check_associated_methods {
      my $self = shift;
      unless (
          @{ $self->associated_methods }
          || ($self->_is_metadata || '') eq 'bare'
      ) {
          Carp::cluck(
              'Attribute (' . $self->name . ') of class '
              . $self->associated_class->name
              . ' has no associated methods'
              . ' (did you mean to provide an "is" argument?)'
              . "\n"
          )
      }
  }
  
  sub _process_accessors {
      my $self = shift;
      my ($type, $accessor, $generate_as_inline_methods) = @_;
  
      $accessor = ( keys %$accessor )[0] if ( ref($accessor) || '' ) eq 'HASH';
      my $method = $self->associated_class->get_method($accessor);
  
      if (   $method
          && $method->isa('Class::MOP::Method::Accessor') ) {
  
          # This is a special case that is very unlikely to occur outside of the
          # Moose bootstrapping process. We do not want to warn if the method
          # we're about to replace is for this same attribute, _and_ we're
          # replacing a non-inline method with an inlined version.
          #
          # This would never occur in normal user code because Moose inlines all
          # accessors. However, Moose metaclasses are instances of
          # Class::MOP::Class, which _does not_ inline accessors by
          # default. However, in Class::MOP & Moose.pm, we iterate over all of
          # our internal metaclasses and make them immutable after they're fully
          # defined. This ends up replacing the attribute accessors.
          unless ( $method->associated_attribute->name eq $self->name
              && ( $generate_as_inline_methods && !$method->is_inline ) ) {
  
              my $other_attr = $method->associated_attribute;
  
              my $msg = sprintf(
                  'You are overwriting a %s (%s) for the %s attribute',
                  $method->accessor_type,
                  $accessor,
                  $other_attr->name,
              );
  
              if ( my $method_context = $method->definition_context ) {
                  $msg .= sprintf(
                      ' (defined at %s line %s)',
                      $method_context->{file},
                      $method_context->{line},
                      )
                      if defined $method_context->{file}
                      && $method_context->{line};
              }
  
              $msg .= sprintf(
                  ' with a new %s method for the %s attribute',
                  $type,
                  $self->name,
              );
  
              if ( my $self_context = $self->definition_context ) {
                  $msg .= sprintf(
                      ' (defined at %s line %s)',
                      $self_context->{file},
                      $self_context->{line},
                      )
                      if defined $self_context->{file}
                      && $self_context->{line};
              }
  
              Carp::cluck($msg);
          }
      }
  
      if (
             $method
          && !$method->is_stub
          && !$method->isa('Class::MOP::Method::Accessor')
          && (  !$self->definition_context
              || $method->package_name eq $self->definition_context->{package} )
          ) {
  
          Carp::cluck(
              "You are overwriting a locally defined method ($accessor) with "
                  . "an accessor" );
      }
  
      if (  !$self->associated_class->has_method($accessor)
          && $self->associated_class->has_package_symbol( '&' . $accessor ) ) {
  
          Carp::cluck(
              "You are overwriting a locally defined function ($accessor) with "
                  . "an accessor" );
      }
  
      $self->SUPER::_process_accessors(@_);
  }
  
  sub remove_accessors {
      my $self = shift;
      $self->SUPER::remove_accessors(@_);
      $self->remove_delegation if $self->has_handles;
      return;
  }
  
  sub install_delegation {
      my $self = shift;
  
      # NOTE:
      # Here we canonicalize the 'handles' option
      # this will sort out any details and always
      # return an hash of methods which we want
      # to delegate to, see that method for details
      my %handles = $self->_canonicalize_handles;
  
      # install the delegation ...
      my $associated_class = $self->associated_class;
      my $class_name = $associated_class->name;
  
      foreach my $handle ( sort keys %handles ) {
          my $method_to_call = $handles{$handle};
          my $name           = "${class_name}::${handle}";
  
          if ( my $method = $associated_class->get_method($handle) ) {
              throw_exception(
                  CannotDelegateLocalMethodIsPresent => attribute => $self,
                  method                             => $method,
              ) unless $method->is_stub;
          }
  
          # NOTE:
          # handles is not allowed to delegate
          # any of these methods, as they will
          # override the ones in your class, which
          # is almost certainly not what you want.
  
          # FIXME warn when $handle was explicitly specified, but not if the source is a regex or something
          #cluck("Not delegating method '$handle' because it is a core method") and
          next
              if $class_name->isa("Moose::Object")
              and $handle =~ /^BUILD|DEMOLISH$/ || Moose::Object->can($handle);
  
          my $method = $self->_make_delegation_method($handle, $method_to_call);
  
          $self->associated_class->add_method($method->name, $method);
          $self->associate_method($method);
      }
  }
  
  sub remove_delegation {
      my $self = shift;
      my %handles = $self->_canonicalize_handles;
      my $associated_class = $self->associated_class;
      foreach my $handle (keys %handles) {
          next unless any { $handle eq $_ }
                      map { $_->name }
                      @{ $self->associated_methods };
          $self->associated_class->remove_method($handle);
      }
  }
  
  # private methods to help delegation ...
  
  sub _canonicalize_handles {
      my $self    = shift;
      my $handles = $self->handles;
      if (my $handle_type = ref($handles)) {
          if ($handle_type eq 'HASH') {
              return %{$handles};
          }
          elsif ($handle_type eq 'ARRAY') {
              return map { $_ => $_ } @{$handles};
          }
          elsif ($handle_type eq 'Regexp') {
              ($self->has_type_constraint)
                  || throw_exception( CannotDelegateWithoutIsa => attribute => $self );
              return map  { ($_ => $_) }
                     grep { /$handles/ } $self->_get_delegate_method_list;
          }
          elsif ($handle_type eq 'CODE') {
              return $handles->($self, $self->_find_delegate_metaclass);
          }
          elsif (blessed($handles) && $handles->isa('Moose::Meta::TypeConstraint::DuckType')) {
              return map { $_ => $_ } @{ $handles->methods };
          }
          elsif (blessed($handles) && $handles->isa('Moose::Meta::TypeConstraint::Role')) {
              $handles = $handles->role;
          }
          else {
              throw_exception( UnableToCanonicalizeHandles => attribute => $self,
                                                              handles   => $handles
                             );
          }
      }
  
      Moose::Util::_load_user_class($handles);
      my $role_meta = Class::MOP::class_of($handles);
  
      (blessed $role_meta && $role_meta->isa('Moose::Meta::Role'))
          || throw_exception( UnableToCanonicalizeNonRolePackage => attribute => $self,
                                                                    handles   => $handles
                            );
  
      return map { $_ => $_ }
          map { $_->name }
          grep { !$_->isa('Class::MOP::Method::Meta') } (
          $role_meta->_get_local_methods,
          $role_meta->get_required_method_list,
          );
  }
  
  sub _get_delegate_method_list {
      my $self = shift;
      my $meta = $self->_find_delegate_metaclass;
      if ($meta->isa('Class::MOP::Class')) {
          return map  { $_->name }  # NOTE: !never! delegate &meta
                 grep { $_->package_name ne 'Moose::Object' && !$_->isa('Class::MOP::Method::Meta') }
                      $meta->get_all_methods;
      }
      elsif ($meta->isa('Moose::Meta::Role')) {
          return $meta->get_method_list;
      }
      else {
          throw_exception( UnableToRecognizeDelegateMetaclass => attribute          => $self,
                                                                 delegate_metaclass => $meta
                         );
      }
  }
  
  sub _find_delegate_metaclass {
      my $self = shift;
      my $class = $self->_isa_metadata;
      my $role = $self->_does_metadata;
  
      if ( $class ) {
          # make sure isa is actually a class
          unless ( $self->type_constraint->isa("Moose::Meta::TypeConstraint::Class") ) {
              throw_exception( DelegationToATypeWhichIsNotAClass => attribute => $self );
          }
  
          # make sure the class is loaded
          unless ( Moose::Util::_is_package_loaded($class) ) {
              throw_exception( DelegationToAClassWhichIsNotLoaded => attribute  => $self,
                                                                     class_name => $class
                             );
          }
          # we might be dealing with a non-Moose class,
          # and need to make our own metaclass. if there's
          # already a metaclass, it will be returned
          return Class::MOP::Class->initialize($class);
      }
      elsif ( $role ) {
          unless ( Moose::Util::_is_package_loaded($role) ) {
              throw_exception( DelegationToARoleWhichIsNotLoaded => attribute => $self,
                                                                    role_name => $role
                             );
          }
  
          return Class::MOP::class_of($role);
      }
      else {
          throw_exception( CannotFindDelegateMetaclass => attribute => $self );
      }
  }
  
  sub delegation_metaclass { 'Moose::Meta::Method::Delegation' }
  
  sub _make_delegation_method {
      my ( $self, $handle_name, $method_to_call ) = @_;
  
      my @curried_arguments;
  
      ($method_to_call, @curried_arguments) = @$method_to_call
          if 'ARRAY' eq ref($method_to_call);
  
      return $self->delegation_metaclass->new(
          name               => $handle_name,
          package_name       => $self->associated_class->name,
          attribute          => $self,
          delegate_to_method => $method_to_call,
          curried_arguments  => \@curried_arguments,
      );
  }
  
  sub _coerce_and_verify {
      my $self     = shift;
      my $val      = shift;
      my $instance = shift;
  
      return $val unless $self->has_type_constraint;
  
      $val = $self->type_constraint->coerce($val)
          if $self->should_coerce && $self->type_constraint->has_coercion;
  
      $self->verify_against_type_constraint($val, instance => $instance);
  
      return $val;
  }
  
  sub verify_against_type_constraint {
      my $self = shift;
      my $val  = shift;
  
      return 1 if !$self->has_type_constraint;
  
      my $type_constraint = $self->type_constraint;
  
      $type_constraint->check($val)
          || throw_exception( ValidationFailedForTypeConstraint => type      => $type_constraint,
                                                                   value     => $val,
                                                                   attribute => $self,
                            );
  }
  
  package  # hide from PAUSE
      Moose::Meta::Attribute::Custom::Moose;
  
  sub register_implementation { 'Moose::Meta::Attribute' }
  1;
  
  # ABSTRACT: The Moose attribute metaclass
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute - The Moose attribute metaclass
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Attribute> that provides
  additional Moose-specific functionality.
  
  To really understand this class, you will need to start with the
  L<Class::MOP::Attribute> documentation. This class can be understood
  as a set of additional features on top of the basic feature provided
  by that parent class.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Attribute> is a subclass of L<Class::MOP::Attribute>.
  
  =head1 METHODS
  
  Many of the documented below override methods in
  L<Class::MOP::Attribute> and add Moose specific features.
  
  =head2 Creation
  
  =over 4
  
  =item B<< Moose::Meta::Attribute->new($name, %options) >>
  
  This method overrides the L<Class::MOP::Attribute> constructor.
  
  Many of the options below are described in more detail in the
  L<Moose::Manual::Attributes> document.
  
  It adds the following options to the constructor:
  
  =over 8
  
  =item * is => 'ro', 'rw', 'bare'
  
  This provides a shorthand for specifying the C<reader>, C<writer>, or
  C<accessor> names. If the attribute is read-only ('ro') then it will
  have a C<reader> method with the same attribute as the name.
  
  If it is read-write ('rw') then it will have an C<accessor> method
  with the same name. If you provide an explicit C<writer> for a
  read-write attribute, then you will have a C<reader> with the same
  name as the attribute, and a C<writer> with the name you provided.
  
  Use 'bare' when you are deliberately not installing any methods
  (accessor, reader, etc.) associated with this attribute; otherwise,
  Moose will issue a warning when this attribute is added to a
  metaclass.
  
  =item * isa => $type
  
  This option accepts a type. The type can be a string, which should be
  a type name. If the type name is unknown, it is assumed to be a class
  name.
  
  This option can also accept a L<Moose::Meta::TypeConstraint> object.
  
  If you I<also> provide a C<does> option, then your C<isa> option must
  be a class name, and that class must do the role specified with
  C<does>.
  
  =item * does => $role
  
  This is short-hand for saying that the attribute's type must be an
  object which does the named role.
  
  =item * coerce => $bool
  
  This option is only valid for objects with a type constraint
  (C<isa>) that defined a coercion. If this is true, then coercions will be applied whenever
  this attribute is set.
  
  You cannot make both this and the C<weak_ref> option true.
  
  =item * trigger => $sub
  
  This option accepts a subroutine reference, which will be called after
  the attribute is set.
  
  =item * required => $bool
  
  An attribute which is required must be provided to the constructor. An
  attribute which is required can also have a C<default> or C<builder>,
  which will satisfy its required-ness.
  
  A required attribute must have a C<default>, C<builder> or a
  non-C<undef> C<init_arg>
  
  =item * lazy => $bool
  
  A lazy attribute must have a C<default> or C<builder>. When an
  attribute is lazy, the default value will not be calculated until the
  attribute is read.
  
  =item * weak_ref => $bool
  
  If this is true, the attribute's value will be stored as a weak
  reference.
  
  =item * documentation
  
  An arbitrary string that can be retrieved later by calling C<<
  $attr->documentation >>.
  
  =item * auto_deref => $bool
  
  B<Note that in cases where you want this feature you are often better served
  by using a L<Moose::Meta::Attribute::Native> trait instead>.
  
  If this is true, then the reader will dereference the value when it is
  called. The attribute must have a type constraint which defines the
  attribute as an array or hash reference.
  
  =item * lazy_build => $bool
  
  B<Note that use of this feature is strongly discouraged.> Some documentation
  used to encourage use of this feature as a best practice, but we have changed
  our minds.
  
  Setting this to true makes the attribute lazy and provides a number of
  default methods.
  
    has 'size' => (
        is         => 'ro',
        lazy_build => 1,
    );
  
  is equivalent to this:
  
    has 'size' => (
        is        => 'ro',
        lazy      => 1,
        builder   => '_build_size',
        clearer   => 'clear_size',
        predicate => 'has_size',
    );
  
  If your attribute name starts with an underscore (C<_>), then the clearer
  and predicate will as well:
  
    has '_size' => (
        is         => 'ro',
        lazy_build => 1,
    );
  
  becomes:
  
    has '_size' => (
        is        => 'ro',
        lazy      => 1,
        builder   => '_build__size',
        clearer   => '_clear_size',
        predicate => '_has_size',
    );
  
  Note the doubled underscore in the builder name. Internally, Moose
  simply prepends the attribute name with "_build_" to come up with the
  builder name.
  
  =item * role_attribute => $role_attribute
  
  If provided, this should be a L<Moose::Meta::Role::Attribute> object.
  
  =back
  
  =item B<< $attr->clone(%options) >>
  
  This creates a new attribute based on attribute being cloned. You must
  supply a C<name> option to provide a new name for the attribute.
  
  The C<%options> can only specify options handled by
  L<Class::MOP::Attribute>.
  
  =back
  
  =head2 Value management
  
  =over 4
  
  =item B<< $attr->initialize_instance_slot($meta_instance, $instance, $params) >>
  
  This method is used internally to initialize the attribute's slot in
  the object C<$instance>.
  
  This overrides the L<Class::MOP::Attribute> method to handle lazy
  attributes, weak references, and type constraints.
  
  =item B<get_value>
  
  =item B<set_value>
  
    eval { $point->meta->get_attribute('x')->set_value($point, 'forty-two') };
    if($@) {
      print "Oops: $@\n";
    }
  
  I<Attribute (x) does not pass the type constraint (Int) with 'forty-two'>
  
  Before setting the value, a check is made on the type constraint of
  the attribute, if it has one, to see if the value passes it. If the
  value fails to pass, the set operation dies.
  
  Any coercion to convert values is done before checking the type constraint.
  
  To check a value against a type constraint before setting it, fetch the
  attribute instance using L<Class::MOP::Class/find_attribute_by_name>,
  fetch the type_constraint from the attribute using L<Moose::Meta::Attribute/type_constraint>
  and call L<Moose::Meta::TypeConstraint/check>. See L<Moose::Cookbook::Basics::Company_Subtypes>
  for an example.
  
  =back
  
  =head2 Attribute Accessor generation
  
  =over 4
  
  =item B<< $attr->install_accessors >>
  
  This method overrides the parent to also install delegation methods.
  
  If, after installing all methods, the attribute object has no associated
  methods, it throws an error unless C<< is => 'bare' >> was passed to the
  attribute constructor.  (Trying to add an attribute that has no associated
  methods is almost always an error.)
  
  =item B<< $attr->remove_accessors >>
  
  This method overrides the parent to also remove delegation methods.
  
  =item B<< $attr->inline_set($instance_var, $value_var) >>
  
  This method return a code snippet suitable for inlining the relevant
  operation. It expect strings containing variable names to be used in the
  inlining, like C<'$self'> or C<'$_[1]'>.
  
  =item B<< $attr->install_delegation >>
  
  This method adds its delegation methods to the attribute's associated
  class, if it has any to add.
  
  =item B<< $attr->remove_delegation >>
  
  This method remove its delegation methods from the attribute's
  associated class.
  
  =item B<< $attr->accessor_metaclass >>
  
  Returns the accessor metaclass name, which defaults to
  L<Moose::Meta::Method::Accessor>.
  
  =item B<< $attr->delegation_metaclass >>
  
  Returns the delegation metaclass name, which defaults to
  L<Moose::Meta::Method::Delegation>.
  
  =back
  
  =head2 Additional Moose features
  
  These methods are not found in the superclass. They support features
  provided by Moose.
  
  =over 4
  
  =item B<< $attr->does($role) >>
  
  This indicates whether the I<attribute itself> does the given
  role. The role can be given as a full class name, or as a resolvable
  trait name.
  
  Note that this checks the attribute itself, not its type constraint,
  so it is checking the attribute's metaclass and any traits applied to
  the attribute.
  
  =item B<< Moose::Meta::Class->interpolate_class_and_new($name, %options) >>
  
  This is an alternate constructor that handles the C<metaclass> and
  C<traits> options.
  
  Effectively, this method is a factory that finds or creates the
  appropriate class for the given C<metaclass> and/or C<traits>.
  
  Once it has the appropriate class, it will call C<< $class->new($name,
  %options) >> on that class.
  
  =item B<< $attr->clone_and_inherit_options(%options) >>
  
  This method supports the C<has '+foo'> feature. It does various bits
  of processing on the supplied C<%options> before ultimately calling
  the C<clone> method.
  
  One of its main tasks is to make sure that the C<%options> provided
  does not include the options returned by the
  C<illegal_options_for_inheritance> method.
  
  =item B<< $attr->illegal_options_for_inheritance >>
  
  This returns a blacklist of options that can not be overridden in a
  subclass's attribute definition.
  
  This exists to allow a custom metaclass to change or add to the list
  of options which can not be changed.
  
  =item B<< $attr->type_constraint >>
  
  Returns the L<Moose::Meta::TypeConstraint> object for this attribute,
  if it has one.
  
  =item B<< $attr->has_type_constraint >>
  
  Returns true if this attribute has a type constraint.
  
  =item B<< $attr->verify_against_type_constraint($value) >>
  
  Given a value, this method returns true if the value is valid for the
  attribute's type constraint. If the value is not valid, it throws an
  error.
  
  =item B<< $attr->handles >>
  
  This returns the value of the C<handles> option passed to the
  constructor.
  
  =item B<< $attr->has_handles >>
  
  Returns true if this attribute performs delegation.
  
  =item B<< $attr->is_weak_ref >>
  
  Returns true if this attribute stores its value as a weak reference.
  
  =item B<< $attr->is_required >>
  
  Returns true if this attribute is required to have a value.
  
  =item B<< $attr->is_lazy >>
  
  Returns true if this attribute is lazy.
  
  =item B<< $attr->is_lazy_build >>
  
  Returns true if the C<lazy_build> option was true when passed to the
  constructor.
  
  =item B<< $attr->should_coerce >>
  
  Returns true if the C<coerce> option passed to the constructor was
  true.
  
  =item B<< $attr->should_auto_deref >>
  
  Returns true if the C<auto_deref> option passed to the constructor was
  true.
  
  =item B<< $attr->trigger >>
  
  This is the subroutine reference that was in the C<trigger> option
  passed to the constructor, if any.
  
  =item B<< $attr->has_trigger >>
  
  Returns true if this attribute has a trigger set.
  
  =item B<< $attr->documentation >>
  
  Returns the value that was in the C<documentation> option passed to
  the constructor, if any.
  
  =item B<< $attr->has_documentation >>
  
  Returns true if this attribute has any documentation.
  
  =item B<< $attr->role_attribute >>
  
  Returns the L<Moose::Meta::Role::Attribute> object from which this attribute
  was created, if any. This may return C<undef>.
  
  =item B<< $attr->has_role_attribute >>
  
  Returns true if this attribute has an associated role attribute.
  
  =item B<< $attr->applied_traits >>
  
  This returns an array reference of all the traits which were applied
  to this attribute. If none were applied, this returns C<undef>.
  
  =item B<< $attr->has_applied_traits >>
  
  Returns true if this attribute has any traits applied.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_ATTRIBUTE

$fatpacked{"darwin-2level/Moose/Meta/Attribute/Native.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_ATTRIBUTE_NATIVE';
  use strict;
  use warnings;
  package Moose::Meta::Attribute::Native;
  our $VERSION = '2.2011';
  
  use Module::Runtime 'require_module';
  
  my @trait_names = qw(Bool Counter Number String Array Hash Code);
  
  for my $trait_name (@trait_names) {
      my $trait_class = "Moose::Meta::Attribute::Native::Trait::$trait_name";
      my $meta = Class::MOP::Class->initialize(
          "Moose::Meta::Attribute::Custom::Trait::$trait_name"
      );
  
      if ($meta->find_method_by_name('register_implementation')) {
          my $class = $meta->name->register_implementation;
          die "An implementation for $trait_name already exists " .
              "(found '$class' when trying to register '$trait_class')"
      }
      $meta->add_method(register_implementation => sub {
          # resolve_metatrait_alias will load classes anyway, but throws away
          # their error message; we WANT to die if there's a problem
          require_module($trait_class);
          return $trait_class;
      });
  }
  
  1;
  
  # ABSTRACT: Delegate to native Perl types
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native - Delegate to native Perl types
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 SYNOPSIS
  
    package MyClass;
    use Moose;
  
    has 'mapping' => (
        traits  => ['Hash'],
        is      => 'rw',
        isa     => 'HashRef[Str]',
        default => sub { {} },
        handles => {
            exists_in_mapping => 'exists',
            ids_in_mapping    => 'keys',
            get_mapping       => 'get',
            set_mapping       => 'set',
            set_quantity      => [ set => 'quantity' ],
        },
    );
  
    my $obj = MyClass->new;
    $obj->set_quantity(10);      # quantity => 10
    $obj->set_mapping('foo', 4); # foo => 4
    $obj->set_mapping('bar', 5); # bar => 5
    $obj->set_mapping('baz', 6); # baz => 6
  
    # prints 5
    print $obj->get_mapping('bar') if $obj->exists_in_mapping('bar');
  
    # prints 'quantity, foo, bar, baz'
    print join ', ', $obj->ids_in_mapping;
  
  =head1 DESCRIPTION
  
  Native delegations allow you to delegate to native Perl data
  structures as if they were objects. For example, in the L</SYNOPSIS> you can
  see a hash reference being treated as if it has methods named C<exists()>,
  C<keys()>, C<get()>, and C<set()>.
  
  The delegation methods (mostly) map to Perl builtins and operators. The return
  values of these delegations should be the same as the corresponding Perl
  operation. Any deviations will be explicitly documented.
  
  =head1 API
  
  Native delegations are enabled by passing certain options to C<has> when
  creating an attribute.
  
  =head2 traits
  
  To enable this feature, pass the appropriate name in the C<traits> array
  reference for the attribute. For example, to enable this feature for hash
  reference, we include C<'Hash'> in the list of traits.
  
  =head2 isa
  
  You will need to make sure that the attribute has an appropriate type. For
  example, to use this with a Hash you must specify that your attribute is some
  sort of C<HashRef>.
  
  =head2 handles
  
  This is just like any other delegation, but only a hash reference is allowed
  when defining native delegations. The keys are the methods to be created in
  the class which contains the attribute. The values are the methods provided by
  the associated trait. Currying works the same way as it does with any other
  delegation.
  
  See the docs for each native trait for details on what methods are available.
  
  =head1 TRAITS FOR NATIVE DELEGATIONS
  
  Below are some simple examples of each native trait. More features are
  available than what is shown here; this is just a quick synopsis.
  
  =over
  
  =item Array (L<Moose::Meta::Attribute::Native::Trait::Array>)
  
      has 'queue' => (
          traits  => ['Array'],
          is      => 'ro',
          isa     => 'ArrayRef[Str]',
          default => sub { [] },
          handles => {
              add_item  => 'push',
              next_item => 'shift',
              # ...
          }
      );
  
  =item Bool (L<Moose::Meta::Attribute::Native::Trait::Bool>)
  
      has 'is_lit' => (
          traits  => ['Bool'],
          is      => 'ro',
          isa     => 'Bool',
          default => 0,
          handles => {
              illuminate  => 'set',
              darken      => 'unset',
              flip_switch => 'toggle',
              is_dark     => 'not',
              # ...
          }
      );
  
  =item Code (L<Moose::Meta::Attribute::Native::Trait::Code>)
  
      has 'callback' => (
          traits  => ['Code'],
          is      => 'ro',
          isa     => 'CodeRef',
          default => sub {
              sub {'called'}
          },
          handles => {
              call => 'execute',
              # ...
          }
      );
  
  =item Counter (L<Moose::Meta::Attribute::Native::Trait::Counter>)
  
      has 'counter' => (
          traits  => ['Counter'],
          is      => 'ro',
          isa     => 'Num',
          default => 0,
          handles => {
              inc_counter   => 'inc',
              dec_counter   => 'dec',
              reset_counter => 'reset',
              # ...
          }
      );
  
  =item Hash (L<Moose::Meta::Attribute::Native::Trait::Hash>)
  
      has 'options' => (
          traits  => ['Hash'],
          is      => 'ro',
          isa     => 'HashRef[Str]',
          default => sub { {} },
          handles => {
              set_option => 'set',
              get_option => 'get',
              has_option => 'exists',
              # ...
          }
      );
  
  =item Number (L<Moose::Meta::Attribute::Native::Trait::Number>)
  
      has 'integer' => (
          traits  => ['Number'],
          is      => 'ro',
          isa     => 'Int',
          default => 5,
          handles => {
              set => 'set',
              add => 'add',
              sub => 'sub',
              mul => 'mul',
              div => 'div',
              mod => 'mod',
              abs => 'abs',
              # ...
          }
      );
  
  =item String (L<Moose::Meta::Attribute::Native::Trait::String>)
  
      has 'text' => (
          traits  => ['String'],
          is      => 'ro',
          isa     => 'Str',
          default => q{},
          handles => {
              add_text     => 'append',
              replace_text => 'replace',
              # ...
          }
      );
  
  =back
  
  =head1 COMPATIBILITY WITH MooseX::AttributeHelpers
  
  This feature used to be a separated CPAN distribution called
  L<MooseX::AttributeHelpers>.
  
  When the feature was incorporated into the Moose core, some of the API details
  were changed. The underlying capabilities are the same, but some details of
  the API were changed.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_ATTRIBUTE_NATIVE

$fatpacked{"darwin-2level/Moose/Meta/Attribute/Native/Trait.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT';
  package Moose::Meta::Attribute::Native::Trait;
  our $VERSION = '2.2011';
  
  use Moose::Role;
  use Module::Runtime 'require_module';
  use Moose::Deprecated;
  use Moose::Util 'throw_exception';
  use Moose::Util::TypeConstraints;
  
  requires '_helper_type';
  
  before '_process_options' => sub {
      my ( $self, $name, $options ) = @_;
  
      $self->_check_helper_type( $options, $name );
  };
  
  sub _check_helper_type {
      my ( $self, $options, $name ) = @_;
  
      my $type = $self->_helper_type;
  
      $options->{isa} = $type
          unless exists $options->{isa};
  
      my $isa;
      my $isa_name;
  
      if (   blessed( $options->{isa} )
          && $options->{isa}->can('does')
          && $options->{isa}->does('Specio::Constraint::Role::Interface') ) {
  
          $isa = $options->{isa};
          require Specio::Library::Builtins;
          return if $isa->is_a_type_of( Specio::Library::Builtins::t($type) );
          $isa_name = $isa->name() || $isa->description();
      }
      else {
          $isa = Moose::Util::TypeConstraints::find_or_create_type_constraint(
              $options->{isa} );
          return if $isa->is_a_type_of($type);
          $isa_name = $isa->name();
      }
  
      throw_exception( WrongTypeConstraintGiven => required_type  => $type,
                                                   given_type     => $isa_name,
                                                   attribute_name => $name,
                                                   params         => $options
                     );
  }
  
  before 'install_accessors' => sub { (shift)->_check_handles_values };
  
  sub _check_handles_values {
      my $self = shift;
  
      my %handles = $self->_canonicalize_handles;
  
      for my $original_method ( values %handles ) {
          my $name = $original_method->[0];
  
          my $accessor_class = $self->_native_accessor_class_for($name);
  
          ( $accessor_class && $accessor_class->can('new') )
              || confess
              "$name is an unsupported method type - $accessor_class";
      }
  }
  
  around '_canonicalize_handles' => sub {
      shift;
      my $self    = shift;
      my $handles = $self->handles;
  
      return unless $handles;
  
      unless ( 'HASH' eq ref $handles ) {
         throw_exception( HandlesMustBeAHashRef => instance      => $self,
                                                   given_handles => $handles
                        );
      }
  
      return
          map { $_ => $self->_canonicalize_handles_value( $handles->{$_} ) }
          keys %$handles;
  };
  
  sub _canonicalize_handles_value {
      my $self  = shift;
      my $value = shift;
  
      if ( ref $value && 'ARRAY' ne ref $value ) {
          throw_exception( InvalidHandleValue => instance     => $self,
                                                 handle_value => $value
                         );
      }
  
      return ref $value ? $value : [$value];
  }
  
  around '_make_delegation_method' => sub {
      my $next = shift;
      my ( $self, $handle_name, $method_to_call ) = @_;
  
      my ( $name, @curried_args ) = @$method_to_call;
  
      my $accessor_class = $self->_native_accessor_class_for($name);
  
      die "Cannot find an accessor class for $name"
          unless $accessor_class && $accessor_class->can('new');
  
      return $accessor_class->new(
          name               => $handle_name,
          package_name       => $self->associated_class->name,
          delegate_to_method => $name,
          attribute          => $self,
          is_inline          => 1,
          curried_arguments  => \@curried_args,
          root_types         => [ $self->_root_types ],
      );
  };
  
  sub _root_types {
      return $_[0]->_helper_type;
  }
  
  sub _native_accessor_class_for {
      my ( $self, $suffix ) = @_;
  
      my $role
          = 'Moose::Meta::Method::Accessor::Native::'
          . $self->_native_type . '::'
          . $suffix;
  
      require_module($role);
      return Moose::Meta::Class->create_anon_class(
          superclasses =>
              [ $self->accessor_metaclass, $self->delegation_metaclass ],
          roles => [$role],
          cache => 1,
      )->name;
  }
  
  sub _build_native_type {
      my $self = shift;
  
      for my $role_name ( map { $_->name } $self->meta->calculate_all_roles ) {
          return $1 if $role_name =~ /::Native::Trait::(\w+)$/;
      }
  
      throw_exception( CannotCalculateNativeType => instance => $self );
  }
  
  has '_native_type' => (
      is      => 'ro',
      isa     => 'Str',
      lazy    => 1,
      builder => '_build_native_type',
  );
  
  no Moose::Role;
  no Moose::Util::TypeConstraints;
  
  1;
  
  # ABSTRACT: Shared role for native delegation traits
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait - Shared role for native delegation traits
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 SEE ALSO
  
  Documentation for Moose native traits can be found in
  L<Moose::Meta::Attribute::Native>.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT

$fatpacked{"darwin-2level/Moose/Meta/Attribute/Native/Trait/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_ARRAY';
  package Moose::Meta::Attribute::Native::Trait::Array;
  our $VERSION = '2.2011';
  
  use Moose::Role;
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'ArrayRef' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for ArrayRef attributes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Array - Helper trait for ArrayRef attributes
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 SYNOPSIS
  
      package Stuff;
      use Moose;
  
      has 'options' => (
          traits  => ['Array'],
          is      => 'ro',
          isa     => 'ArrayRef[Str]',
          default => sub { [] },
          handles => {
              all_options    => 'elements',
              add_option     => 'push',
              map_options    => 'map',
              filter_options => 'grep',
              find_option    => 'first',
              get_option     => 'get',
              join_options   => 'join',
              count_options  => 'count',
              has_options    => 'count',
              has_no_options => 'is_empty',
              sorted_options => 'sort',
          },
      );
  
      no Moose;
      1;
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for array references.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<ArrayRef>.
  
  =head1 PROVIDED METHODS
  
  =over 4
  
  =item * B<count>
  
  Returns the number of elements in the array.
  
    $stuff = Stuff->new;
    $stuff->options( [ "foo", "bar", "baz", "boo" ] );
  
    print $stuff->count_options; # prints 4
  
  This method does not accept any arguments.
  
  =item * B<is_empty>
  
  Returns a boolean value that is true when the array has no elements.
  
    $stuff->has_no_options ? die "No options!\n" : print "Good boy.\n";
  
  This method does not accept any arguments.
  
  =item * B<elements>
  
  In list context, returns all of the elements of the array as a list.
  
  In scalar context, returns the number of elements in the array.
  
    my @options = $stuff->all_options;
    print "@options";    # prints "foo bar baz boo"
    print scalar $stuff->all_options; # prints 4
  
  This method does not accept any arguments.
  
  =item * B<get($index)>
  
  Returns an element of the array by its index. You can also use negative index
  numbers, just as with Perl's core array handling.
  
    my $option = $stuff->get_option(1);
    print "$option\n";    # prints "bar"
  
  If the specified element does not exist, this will return C<undef>.
  
  This method accepts just one argument.
  
  =item * B<pop>
  
  Just like Perl's builtin C<pop>.
  
  This method does not accept any arguments.
  
  =item * B<push($value1, $value2, value3 ...)>
  
  Just like Perl's builtin C<push>. Returns the number of elements in the new
  array.
  
  This method accepts any number of arguments.
  
  =item * B<shift>
  
  Just like Perl's builtin C<shift>.
  
  This method does not accept any arguments.
  
  =item * B<unshift($value1, $value2, value3 ...)>
  
  Just like Perl's builtin C<unshift>. Returns the number of elements in the new
  array.
  
  This method accepts any number of arguments.
  
  =item * B<splice($offset, $length, @values)>
  
  Just like Perl's builtin C<splice>. In scalar context, this returns the last
  element removed, or C<undef> if no elements were removed. In list context,
  this returns all the elements removed from the array.
  
  This method requires at least one argument.
  
  =item * B<first( sub { ... } )>
  
  This method returns the first matching item in the array, just like
  L<List::Util>'s C<first> function. The matching is done with a subroutine
  reference you pass to this method. The subroutine will be called against each
  element in the array until one matches or all elements have been checked.
  Each list element will be available to the sub in C<$_>.
  
    my $found = $stuff->find_option( sub {/^b/} );
    print "$found\n";    # prints "bar"
  
  This method requires a single argument.
  
  =item * B<first_index( sub { ... } )>
  
  This method returns the index of the first matching item in the array, just
  like L<List::SomeUtils/first_index>. The matching is done with a
  subroutine reference you pass to this method. The subroutine will be called
  against each element in the array until one matches or all elements have been
  checked. Each list element will be available to the sub in C<$_>.
  If no match is made, -1 is returned.
  
  This method requires a single argument.
  
  =item * B<grep( sub { ... } )>
  
  This method returns every element matching a given criteria, just like Perl's
  core C<grep> function. This method requires a subroutine which implements the
  matching logic; each list element will be available to the sub in C<$_>.
  
    my @found = $stuff->filter_options( sub {/^b/} );
    print "@found\n";    # prints "bar baz boo"
  
  This method requires a single argument.
  
  =item * B<map( sub { ... } )>
  
  This method transforms every element in the array and returns a new array,
  just like Perl's core C<map> function. This method requires a subroutine which
  implements the transformation; each list element will be available to the sub
  in C<$_>.
  
    my @mod_options = $stuff->map_options( sub { $_ . "-tag" } );
    print "@mod_options\n";    # prints "foo-tag bar-tag baz-tag boo-tag"
  
  This method requires a single argument.
  
  =item * B<reduce( sub { ... } )>
  
  This method turns an array into a single value, by passing a function the
  value so far and the next value in the array, just like L<List::Util>'s
  C<reduce> function. The reducing is done with a subroutine reference you pass
  to this method; each list element will be available to the sub in C<$_>.
  
    my $found = $stuff->reduce_options( sub { $_[0] . $_[1] } );
    print "$found\n";    # prints "foobarbazboo"
  
  This method requires a single argument.
  
  =item * B<sort>
  
  =item * B<sort( sub { ... } )>
  
  Returns the elements of the array (not an array reference) in sorted order,
  or, like C<elements>, returns the number of elements in the array in scalar context.
  
  You can provide an optional subroutine reference to sort with (as you can with
  Perl's core C<sort> function). However, instead of using C<$a> and C<$b> in
  this subroutine, you will need to use C<$_[0]> and C<$_[1]>.
  
    # ascending ASCIIbetical
    my @sorted = $stuff->sort_options();
  
    # Descending alphabetical order
    my @sorted_options = $stuff->sort_options( sub { lc $_[1] cmp lc $_[0] } );
    print "@sorted_options\n";    # prints "foo boo baz bar"
  
  This method accepts a single argument.
  
  =item * B<sort_in_place>
  
  =item * B<sort_in_place( sub { ... } )>
  
  Sorts the array I<in place>, modifying the value of the attribute.
  
  You can provide an optional subroutine reference to sort with (as you can with
  Perl's core C<sort> function). However, instead of using C<$a> and C<$b>, you
  will need to use C<$_[0]> and C<$_[1]> instead.
  
  This method does not define a return value.
  
  This method accepts a single argument.
  
  =item * B<shuffle>
  
  Returns the elements of the array in random order, like C<shuffle> from
  L<List::Util>.
  
  This method does not accept any arguments.
  
  =item * B<uniq>
  
  Returns the array with all duplicate elements removed, like L<List::Util/uniq>.
  
  This method does not accept any arguments.
  
  =item * B<join($str)>
  
  Joins every element of the array using the separator given as argument, just
  like Perl's core C<join> function.
  
    my $joined = $stuff->join_options(':');
    print "$joined\n";    # prints "foo:bar:baz:boo"
  
  This method requires a single argument.
  
  =item * B<set($index, $value)>
  
  Given an index and a value, sets the specified array element's value.
  
  This method returns the value at C<$index> after the set.
  
  This method requires two arguments.
  
  =item * B<delete($index)>
  
  Removes the element at the given index from the array.
  
  This method returns the deleted value. Note that if no value exists, it will
  return C<undef>.
  
  This method requires one argument.
  
  =item * B<insert($index, $value)>
  
  Inserts a new element into the array at the given index.
  
  This method returns the new value at C<$index>.
  
  This method requires two arguments.
  
  =item * B<clear>
  
  Empties the entire array, like C<@array = ()>.
  
  This method does not define a return value.
  
  This method does not accept any arguments.
  
  =item * B<accessor($index)>
  
  =item * B<accessor($index, $value)>
  
  This method provides a get/set accessor for the array, based on array indexes.
  If passed one argument, it returns the value at the specified index.  If
  passed two arguments, it sets the value of the specified index.
  
  When called as a setter, this method returns the new value at C<$index>.
  
  This method accepts one or two arguments.
  
  =item * B<natatime($n)>
  
  =item * B<natatime($n, $code)>
  
  This method returns an iterator which, on each call, returns C<$n> more items
  from the array, in order, like L<List::SomeUtils/natatime>.
  
  If you pass a coderef as the second argument, then this code ref will be
  called on each group of C<$n> elements in the array until the array is
  exhausted.
  
  This method accepts one or two arguments.
  
  =item * B<shallow_clone>
  
  This method returns a shallow clone of the array reference.  The return value
  is a reference to a new array with the same elements.  It is I<shallow>
  because any elements that were references in the original will be the I<same>
  references in the clone.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_ARRAY

$fatpacked{"darwin-2level/Moose/Meta/Attribute/Native/Trait/Bool.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_BOOL';
  package Moose::Meta::Attribute::Native::Trait::Bool;
  our $VERSION = '2.2011';
  
  use Moose::Role;
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'Bool' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for Bool attributes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Bool - Helper trait for Bool attributes
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 SYNOPSIS
  
    package Room;
    use Moose;
  
    has 'is_lit' => (
        traits  => ['Bool'],
        is      => 'rw',
        isa     => 'Bool',
        default => 0,
        handles => {
            illuminate  => 'set',
            darken      => 'unset',
            flip_switch => 'toggle',
            is_dark     => 'not',
        },
    );
  
    my $room = Room->new();
    $room->illuminate;        # same as $room->is_lit(1);
    $room->darken;            # same as $room->is_lit(0);
    $room->flip_switch;       # same as $room->is_lit(not $room->is_lit);
    return $room->is_dark;    # same as !$room->is_lit
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for boolean values. A boolean is
  a scalar which can be C<1>, C<0>, C<"">, or C<undef>.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<Bool>.
  
  =head1 PROVIDED METHODS
  
  None of these methods accept arguments.
  
  =over 4
  
  =item * B<set>
  
  Sets the value to C<1> and returns C<1>.
  
  =item * B<unset>
  
  Set the value to C<0> and returns C<0>.
  
  =item * B<toggle>
  
  Toggles the value. If it's true, set to false, and vice versa.
  
  Returns the new value.
  
  =item * B<not>
  
  Equivalent of 'not C<$value>'.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_BOOL

$fatpacked{"darwin-2level/Moose/Meta/Attribute/Native/Trait/Code.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_CODE';
  package Moose::Meta::Attribute::Native::Trait::Code;
  our $VERSION = '2.2011';
  
  use Moose::Role;
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'CodeRef' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for CodeRef attributes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Code - Helper trait for CodeRef attributes
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 SYNOPSIS
  
    package Foo;
    use Moose;
  
    has 'callback' => (
        traits  => ['Code'],
        is      => 'ro',
        isa     => 'CodeRef',
        default => sub {
            sub { print "called" }
        },
        handles => {
            call => 'execute',
        },
    );
  
    my $foo = Foo->new;
    $foo->call;    # prints "called"
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for code references.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<CodeRef>.
  
  =head1 PROVIDED METHODS
  
  =over 4
  
  =item * B<execute(@args)>
  
  Calls the coderef with the given args.
  
  =item * B<execute_method(@args)>
  
  Calls the coderef with the instance as invocant and given args.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_CODE

$fatpacked{"darwin-2level/Moose/Meta/Attribute/Native/Trait/Counter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_COUNTER';
  package Moose::Meta::Attribute::Native::Trait::Counter;
  our $VERSION = '2.2011';
  
  use Moose::Role;
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'Num' }
  sub _root_types { 'Num', 'Int' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for Int attributes which represent counters
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Counter - Helper trait for Int attributes which represent counters
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 SYNOPSIS
  
    package MyHomePage;
    use Moose;
  
    has 'counter' => (
        traits  => ['Counter'],
        is      => 'ro',
        isa     => 'Num',
        default => 0,
        handles => {
            inc_counter   => 'inc',
            dec_counter   => 'dec',
            reset_counter => 'reset',
        },
    );
  
    my $page = MyHomePage->new();
    $page->inc_counter;    # same as $page->counter( $page->counter + 1 );
    $page->dec_counter;    # same as $page->counter( $page->counter - 1 );
  
    my $count_by_twos = 2;
    $page->inc_counter($count_by_twos);
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for counters. A counter can be
  any sort of number (integer or not). The delegation methods allow you to
  increment, decrement, or reset the value.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<Num>.
  
  =head1 PROVIDED METHODS
  
  =over 4
  
  =item * B<set($value)>
  
  Sets the counter to the specified value and returns the new value.
  
  This method requires a single argument.
  
  =item * B<inc>
  
  =item * B<inc($arg)>
  
  Increases the attribute value by the amount of the argument, or by 1 if no
  argument is given. This method returns the new value.
  
  This method accepts a single argument.
  
  =item * B<dec>
  
  =item * B<dec($arg)>
  
  Decreases the attribute value by the amount of the argument, or by 1 if no
  argument is given. This method returns the new value.
  
  This method accepts a single argument.
  
  =item * B<reset>
  
  Resets the value stored in this slot to its default value, and returns the new
  value.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_COUNTER

$fatpacked{"darwin-2level/Moose/Meta/Attribute/Native/Trait/Hash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_HASH';
  package Moose::Meta::Attribute::Native::Trait::Hash;
  our $VERSION = '2.2011';
  
  use Moose::Role;
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'HashRef' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for HashRef attributes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Hash - Helper trait for HashRef attributes
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 SYNOPSIS
  
    package Stuff;
    use Moose;
  
    has 'options' => (
        traits    => ['Hash'],
        is        => 'ro',
        isa       => 'HashRef[Str]',
        default   => sub { {} },
        handles   => {
            set_option     => 'set',
            get_option     => 'get',
            has_no_options => 'is_empty',
            num_options    => 'count',
            delete_option  => 'delete',
            option_pairs   => 'kv',
        },
    );
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for hash references.
  
  =head1 PROVIDED METHODS
  
  =head2 get($key, $key2, $key3...)
  
  Returns values from the hash.
  
  In list context it returns a list of values in the hash for the given keys. In
  scalar context it returns the value for the last key specified.
  
  This method requires at least one argument.
  
  =head2 set($key =E<gt> $value, $key2 =E<gt> $value2...)
  
  Sets the elements in the hash to the given values. It returns the new values
  set for each key, in the same order as the keys passed to the method.
  
  This method requires at least two arguments, and expects an even number of
  arguments.
  
  =head2 delete($key, $key2, $key3...)
  
  Removes the elements with the given keys.
  
  In list context it returns a list of values in the hash for the deleted
  keys. In scalar context it returns the value for the last key specified.
  
  =head2 keys
  
  Returns the list of keys in the hash.
  
  This method does not accept any arguments.
  
  =head2 exists($key)
  
  Returns true if the given key is present in the hash.
  
  This method requires a single argument.
  
  =head2 defined($key)
  
  Returns true if the value of a given key is defined.
  
  This method requires a single argument.
  
  =head2 values
  
  Returns the list of values in the hash.
  
  This method does not accept any arguments.
  
  =head2 kv
  
  Returns the key/value pairs in the hash as an array of array references.
  
    for my $pair ( $object->option_pairs ) {
        print "$pair->[0] = $pair->[1]\n";
    }
  
  This method does not accept any arguments.
  
  =head2 elements
  
  In list context, this returns the key/value pairs in the hash.
  
  In scalar context, this returns the count of keys plus values.  In other words,
  it's the same as L<keys> times two.
  
  This method does not accept any arguments.
  
  =head2 clear
  
  Resets the hash to an empty value, like C<%hash = ()>.
  
  This method does not accept any arguments.
  
  =head2 count
  
  Returns the number of elements in the hash. Also useful to check for a nonempty hash, because C<count> returns a true (nonzero) value if there is something in the hash:
  C<< has_options => 'count' >>.
  
  This method does not accept any arguments.
  
  =head2 is_empty
  
  If the hash is populated, returns false. Otherwise, returns true.
  
  This method does not accept any arguments.
  
  =head2 accessor($key)
  
  =head2 accessor($key, $value)
  
  If passed one argument, returns the value of the specified key. If passed two
  arguments, sets the value of the specified key.
  
  When called as a setter, this method returns the value that was set.
  
  =head2 shallow_clone
  
  This method returns a shallow clone of the hash reference.  The return value
  is a reference to a new hash with the same keys and values.  It is I<shallow>
  because any values that were references in the original will be the I<same>
  references in the clone.
  
  =head2 Why no C<each>?
  
  We have deliberately omitted a method for C<each>, due to its stateful
  interaction with the hash iterator. Using C<keys> or C<kv> is much safer.
  
  =head2 Moose::Meta::Attribute->meta
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  It should also be noted that L<Class::MOP> will actually bootstrap
  this module by installing a number of attribute meta-objects into its
  metaclass.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_HASH

$fatpacked{"darwin-2level/Moose/Meta/Attribute/Native/Trait/Number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_NUMBER';
  package Moose::Meta::Attribute::Native::Trait::Number;
  our $VERSION = '2.2011';
  
  use Moose::Role;
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'Num' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for Num attributes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Number - Helper trait for Num attributes
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 SYNOPSIS
  
    package Real;
    use Moose;
  
    has 'integer' => (
        traits  => ['Number'],
        is      => 'ro',
        isa     => 'Num',
        default => 5,
        handles => {
            set => 'set',
            add => 'add',
            sub => 'sub',
            mul => 'mul',
            div => 'div',
            mod => 'mod',
            abs => 'abs',
        },
    );
  
    my $real = Real->new();
    $real->add(5);    # same as $real->integer($real->integer + 5);
    $real->sub(2);    # same as $real->integer($real->integer - 2);
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for numbers. All of the
  operations correspond to arithmetic operations like addition or
  multiplication.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<Num>.
  
  =head1 PROVIDED METHODS
  
  All of these methods modify the attribute's value in place. All methods return
  the new value.
  
  =over 4
  
  =item * B<add($value)>
  
  Adds the current value of the attribute to C<$value>.
  
  =item * B<sub($value)>
  
  Subtracts C<$value> from the current value of the attribute.
  
  =item * B<mul($value)>
  
  Multiplies the current value of the attribute by C<$value>.
  
  =item * B<div($value)>
  
  Divides the current value of the attribute by C<$value>.
  
  =item * B<mod($value)>
  
  Returns the current value of the attribute modulo C<$value>.
  
  =item * B<abs>
  
  Sets the current value of the attribute to its absolute value.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_NUMBER

$fatpacked{"darwin-2level/Moose/Meta/Attribute/Native/Trait/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_STRING';
  package Moose::Meta::Attribute::Native::Trait::String;
  our $VERSION = '2.2011';
  
  use Moose::Role;
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'Str' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for Str attributes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::String - Helper trait for Str attributes
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 SYNOPSIS
  
    package MyHomePage;
    use Moose;
  
    has 'text' => (
        traits  => ['String'],
        is      => 'rw',
        isa     => 'Str',
        default => q{},
        handles => {
            add_text     => 'append',
            replace_text => 'replace',
        },
    );
  
    my $page = MyHomePage->new();
    $page->add_text("foo");    # same as $page->text($page->text . "foo");
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for strings.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<Str>.
  
  =head1 PROVIDED METHODS
  
  =over 4
  
  =item * B<inc>
  
  Increments the value stored in this slot using the magical string autoincrement
  operator. Note that Perl doesn't provide analogous behavior in C<-->, so
  C<dec> is not available. This method returns the new value.
  
  This method does not accept any arguments.
  
  =item * B<append($string)>
  
  Appends to the string, like C<.=>, and returns the new value.
  
  This method requires a single argument.
  
  =item * B<prepend($string)>
  
  Prepends to the string and returns the new value.
  
  This method requires a single argument.
  
  =item * B<replace($pattern, $replacement)>
  
  Performs a regexp substitution (L<perlop/s>). There is no way to provide the
  C<g> flag, but code references will be accepted for the replacement, causing
  the regex to be modified with a single C<e>. C</smxi> can be applied using the
  C<qr> operator. This method returns the new value.
  
  This method requires two arguments.
  
  =item * B<match($pattern)>
  
  Runs the regex against the string and returns the matching value(s).
  
  This method requires a single argument.
  
  =item * B<chop>
  
  Just like L<perlfunc/chop>. This method returns the chopped character.
  
  This method does not accept any arguments.
  
  =item * B<chomp>
  
  Just like L<perlfunc/chomp>. This method returns the number of characters
  removed.
  
  This method does not accept any arguments.
  
  =item * B<clear>
  
  Sets the string to the empty string (not the value passed to C<default>).
  
  This method does not have a defined return value.
  
  This method does not accept any arguments.
  
  =item * B<length>
  
  Just like L<perlfunc/length>, returns the length of the string.
  
  =item * B<substr>
  
  This acts just like L<perlfunc/substr>. When called as a writer, it returns
  the substring that was replaced, just like the Perl builtin.
  
  This method requires at least one argument, and accepts no more than three.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_STRING

$fatpacked{"darwin-2level/Moose/Meta/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_CLASS';
  package Moose::Meta::Class;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Class::MOP;
  use Data::OptList;
  use List::Util 1.33 qw( any );
  use Scalar::Util 'blessed';
  
  use Moose::Meta::Method::Overridden;
  use Moose::Meta::Method::Augmented;
  use Moose::Meta::Class::Immutable::Trait;
  use Moose::Meta::Method::Constructor;
  use Moose::Meta::Method::Destructor;
  use Moose::Meta::Method::Meta;
  use Moose::Util 'throw_exception';
  use Class::MOP::MiniTrait;
  
  use parent 'Class::MOP::Class';
  
  Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
  
  __PACKAGE__->meta->add_attribute('roles' => (
      reader  => 'roles',
      default => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('role_applications' => (
      reader  => '_get_role_applications',
      default => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute(
      Class::MOP::Attribute->new('immutable_trait' => (
          accessor => "immutable_trait",
          default  => 'Moose::Meta::Class::Immutable::Trait',
          Class::MOP::_definition_context(),
      ))
  );
  
  __PACKAGE__->meta->add_attribute('constructor_class' => (
      accessor => 'constructor_class',
      default  => 'Moose::Meta::Method::Constructor',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('destructor_class' => (
      accessor => 'destructor_class',
      default  => 'Moose::Meta::Method::Destructor',
      Class::MOP::_definition_context(),
  ));
  
  sub initialize {
      my $class = shift;
      my @args = @_;
      unshift @args, 'package' if @args % 2;
      my %opts = @args;
      my $package = delete $opts{package};
      return Class::MOP::get_metaclass_by_name($package)
          || $class->SUPER::initialize($package,
                  'attribute_metaclass' => 'Moose::Meta::Attribute',
                  'method_metaclass'    => 'Moose::Meta::Method',
                  'instance_metaclass'  => 'Moose::Meta::Instance',
                  %opts,
              );
  }
  
  sub create {
      my $class = shift;
      my @args = @_;
  
      unshift @args, 'package' if @args % 2 == 1;
      my %options = @args;
  
      (ref $options{roles} eq 'ARRAY')
          || throw_exception( RolesInCreateTakesAnArrayRef => params => \%options )
              if exists $options{roles};
  
      my $package = delete $options{package};
      my $roles   = delete $options{roles};
  
      my $new_meta = $class->SUPER::create($package, %options);
  
      if ($roles) {
          Moose::Util::apply_all_roles( $new_meta, @$roles );
      }
  
      return $new_meta;
  }
  
  sub _meta_method_class { 'Moose::Meta::Method::Meta' }
  
  sub _anon_package_prefix { 'Moose::Meta::Class::__ANON__::SERIAL::' }
  
  sub _anon_cache_key {
      my $class = shift;
      my %options = @_;
  
      my $superclass_key = join('|',
          map { $_->[0] } @{ Data::OptList::mkopt($options{superclasses} || []) }
      );
  
      my $roles = Data::OptList::mkopt(($options{roles} || []), {
          moniker  => 'role',
          name_test => sub {
              ! ref $_[0] or blessed($_[0]) && $_[0]->isa('Moose::Meta::Role')
          },
      });
  
      my @role_keys;
      for my $role_spec (@$roles) {
          my ($role, $params) = @$role_spec;
          $params = { %$params } if $params;
  
          my $key = blessed($role) ? $role->name : $role;
  
          if ($params && %$params) {
              my $alias    = delete $params->{'-alias'}
                          || delete $params->{'alias'}
                          || {};
              my $excludes = delete $params->{'-excludes'}
                          || delete $params->{'excludes'}
                          || [];
              $excludes = [$excludes] unless ref($excludes) eq 'ARRAY';
  
              if (%$params) {
                  warn "Roles with parameters cannot be cached. Consider "
                     . "applying the parameters before calling "
                     . "create_anon_class, or using 'weaken => 0' instead";
                  return;
              }
  
              my $alias_key = join('%',
                  map { $_ => $alias->{$_} } sort keys %$alias
              );
              my $excludes_key = join('%',
                  sort @$excludes
              );
              $key .= '<' . join('+', 'a', $alias_key, 'e', $excludes_key) . '>';
          }
  
          push @role_keys, $key;
      }
  
      my $role_key = join('|', sort @role_keys);
  
      # Makes something like Super::Class|Super::Class::2=Role|Role::1
      return join('=', $superclass_key, $role_key);
  }
  
  sub reinitialize {
      my $self = shift;
      my $pkg  = shift;
  
      my $meta = blessed $pkg ? $pkg : Class::MOP::class_of($pkg);
  
      my %existing_classes;
      if ($meta) {
          %existing_classes = map { $_ => $meta->$_() } qw(
              attribute_metaclass
              method_metaclass
              wrapped_method_metaclass
              instance_metaclass
              constructor_class
              destructor_class
          );
      }
  
      return $self->SUPER::reinitialize(
          $pkg,
          %existing_classes,
          @_,
      );
  }
  
  sub add_role {
      my ($self, $role) = @_;
      (blessed($role) && $role->isa('Moose::Meta::Role'))
          || throw_exception( AddRoleTakesAMooseMetaRoleInstance => role_to_be_added => $role,
                                                                    class_name       => $self->name,
                            );
      push @{$self->roles} => $role;
  }
  
  sub role_applications {
      my ($self) = @_;
  
      return @{$self->_get_role_applications};
  }
  
  sub add_role_application {
      my ($self, $application) = @_;
  
      (blessed($application) && $application->isa('Moose::Meta::Role::Application::ToClass'))
          || throw_exception( InvalidRoleApplication => class_name  => $self->name,
                                                        application => $application,
                            );
  
      push @{$self->_get_role_applications} => $application;
  }
  
  sub calculate_all_roles {
      my $self = shift;
      my %seen;
      grep { !$seen{$_->name}++ } map { $_->calculate_all_roles } @{ $self->roles };
  }
  
  sub _roles_with_inheritance {
      my $self = shift;
      my %seen;
      grep { !$seen{$_->name}++ }
           map { Class::MOP::class_of($_)->can('roles')
                     ? @{ Class::MOP::class_of($_)->roles }
                     : () }
               $self->linearized_isa;
  }
  
  sub calculate_all_roles_with_inheritance {
      my $self = shift;
      my %seen;
      grep { !$seen{$_->name}++ }
           map { Class::MOP::class_of($_)->can('calculate_all_roles')
                     ? Class::MOP::class_of($_)->calculate_all_roles
                     : () }
               $self->linearized_isa;
  }
  
  sub does_role {
      my ($self, $role_name) = @_;
  
      (defined $role_name)
          || throw_exception( RoleNameRequired => class_name => $self->name );
  
      foreach my $class ($self->class_precedence_list) {
          my $meta = Class::MOP::class_of($class);
          # when a Moose metaclass is itself extended with a role,
          # this check needs to be done since some items in the
          # class_precedence_list might in fact be Class::MOP
          # based still.
          next unless $meta && $meta->can('roles');
          foreach my $role (@{$meta->roles}) {
              return 1 if $role->does_role($role_name);
          }
      }
      return 0;
  }
  
  sub excludes_role {
      my ($self, $role_name) = @_;
  
      (defined $role_name)
          || throw_exception( RoleNameRequired => class_name => $self->name );
  
      foreach my $class ($self->class_precedence_list) {
          my $meta = Class::MOP::class_of($class);
          # when a Moose metaclass is itself extended with a role,
          # this check needs to be done since some items in the
          # class_precedence_list might in fact be Class::MOP
          # based still.
          next unless $meta && $meta->can('roles');
          foreach my $role (@{$meta->roles}) {
              return 1 if $role->excludes_role($role_name);
          }
      }
      return 0;
  }
  
  sub new_object {
      my $self   = shift;
      my $params = @_ == 1 ? $_[0] : {@_};
      my $object = $self->SUPER::new_object($params);
  
      $self->_call_all_triggers($object, $params);
  
      $object->BUILDALL($params) if $object->can('BUILDALL');
  
      return $object;
  }
  
  sub _call_all_triggers {
      my ($self, $object, $params) = @_;
  
      foreach my $attr ( $self->get_all_attributes() ) {
  
          next unless $attr->can('has_trigger') && $attr->has_trigger;
  
          my $init_arg = $attr->init_arg;
          next unless defined $init_arg;
          next unless exists $params->{$init_arg};
  
          $attr->trigger->(
              $object,
              (
                    $attr->should_coerce
                  ? $attr->get_read_method_ref->($object)
                  : $params->{$init_arg}
              ),
          );
      }
  }
  
  sub _generate_fallback_constructor {
      my $self = shift;
      my ($class) = @_;
      return $class . '->Moose::Object::new(@_)'
  }
  
  sub _inline_params {
      my $self = shift;
      my ($params, $class) = @_;
      return (
          'my ' . $params . ' = ',
          $self->_inline_BUILDARGS($class, '@_'),
          ';',
      );
  }
  
  sub _inline_BUILDARGS {
      my $self = shift;
      my ($class, $args) = @_;
  
      my $buildargs = $self->find_method_by_name("BUILDARGS");
  
      if ($args eq '@_'
       && (!$buildargs or $buildargs->body == \&Moose::Object::BUILDARGS)) {
          return (
              'do {',
                  'my $params;',
                  'if (scalar @_ == 1) {',
                      'if (!defined($_[0]) || ref($_[0]) ne \'HASH\') {',
                          $self->_inline_throw_exception(
                              'SingleParamsToNewMustBeHashRef'
                          ) . ';',
                      '}',
                      '$params = { %{ $_[0] } };',
                  '}',
                  'elsif (@_ % 2) {',
                      'Carp::carp(',
                          '"The new() method for ' . $class . ' expects a '
                        . 'hash reference or a key/value list. You passed an '
                        . 'odd number of arguments"',
                      ');',
                      '$params = {@_, undef};',
                  '}',
                  'else {',
                      '$params = {@_};',
                  '}',
                  '$params;',
              '}',
          );
      }
      else {
          return $class . '->BUILDARGS(' . $args . ')';
      }
  }
  
  sub _inline_slot_initializer {
      my $self  = shift;
      my ($attr, $idx) = @_;
  
      return (
          '## ' . $attr->name,
          $self->_inline_check_required_attr($attr),
          $self->SUPER::_inline_slot_initializer(@_),
      );
  }
  
  sub _inline_check_required_attr {
      my $self = shift;
      my ($attr) = @_;
  
      return unless defined $attr->init_arg;
      return unless $attr->can('is_required') && $attr->is_required;
      return if $attr->has_default || $attr->has_builder;
  
      my $throw = $self->_inline_throw_exception(
          'AttributeIsRequired',
          sprintf(
              <<'EOF', quotemeta( $attr->name ), quotemeta( $attr->init_arg ) ), );
  params             => $params,
  class_name         => $class_name,
  attribute_name     => "%s",
  attribute_init_arg => "%s",
  EOF
  
      return sprintf( <<'EOF', quotemeta( $attr->init_arg ), $throw )
  if ( !exists $params->{"%s"} ) {
      %s;
  }
  EOF
  }
  
  # XXX: these two are duplicated from cmop, because we have to pass the tc stuff
  # through to _inline_set_value - this should probably be fixed, but i'm not
  # quite sure how. -doy
  sub _inline_init_attr_from_constructor {
      my $self = shift;
      my ($attr, $idx) = @_;
  
      my @initial_value = $attr->_inline_set_value(
          '$instance',
          '$params->{\'' . $attr->init_arg . '\'}',
          '$type_constraint_bodies[' . $idx . ']',
          '$type_coercions[' . $idx . ']',
          '$type_constraint_messages[' . $idx . ']',
          'for constructor',
      );
  
      push @initial_value, (
          '$attrs->[' . $idx . ']->set_initial_value(',
              '$instance,',
              $attr->_inline_instance_get('$instance'),
          ');',
      ) if $attr->has_initializer;
  
      return @initial_value;
  }
  
  sub _inline_init_attr_from_default {
      my $self = shift;
      my ($attr, $idx) = @_;
  
      return if $attr->can('is_lazy') && $attr->is_lazy;
      my $default = $self->_inline_default_value($attr, $idx);
      return unless $default;
  
      my @initial_value = (
          'my $default = ' . $default . ';',
          $attr->_inline_set_value(
              '$instance',
              '$default',
              '$type_constraint_bodies[' . $idx . ']',
              '$type_coercions[' . $idx . ']',
              '$type_constraint_messages[' . $idx . ']',
              'for constructor',
          ),
      );
  
      push @initial_value, (
          '$attrs->[' . $idx . ']->set_initial_value(',
              '$instance,',
              $attr->_inline_instance_get('$instance'),
          ');',
      ) if $attr->has_initializer;
  
      return @initial_value;
  }
  
  sub _inline_extra_init {
      my $self = shift;
      return (
          $self->_inline_triggers,
          $self->_inline_BUILDALL,
      );
  }
  
  sub _inline_triggers {
      my $self = shift;
      my @trigger_calls;
  
      my @attrs = sort { $a->name cmp $b->name } $self->get_all_attributes;
      for my $i (0 .. $#attrs) {
          my $attr = $attrs[$i];
  
          next unless $attr->can('has_trigger') && $attr->has_trigger;
  
          my $init_arg = $attr->init_arg;
          next unless defined $init_arg;
  
          push @trigger_calls,
              'if (exists $params->{\'' . $init_arg . '\'}) {',
                  '$triggers->[' . $i . ']->(',
                      '$instance,',
                      $attr->_inline_instance_get('$instance') . ',',
                  ');',
              '}';
      }
  
      return @trigger_calls;
  }
  
  sub _inline_BUILDALL {
      my $self = shift;
  
      my @methods = reverse $self->find_all_methods_by_name('BUILD');
      return () unless @methods;
  
      my @BUILD_calls;
  
      foreach my $method (@methods) {
          push @BUILD_calls,
              '$instance->' . $method->{class} . '::BUILD($params);';
      }
  
      return (
          'if (!$params->{__no_BUILD__}) {',
          @BUILD_calls,
          '}',
      );
  }
  
  sub _eval_environment {
      my $self = shift;
  
      my @attrs = sort { $a->name cmp $b->name } $self->get_all_attributes;
  
      my $triggers = [
          map { $_->can('has_trigger') && $_->has_trigger ? $_->trigger : undef }
              @attrs
      ];
  
      # We need to check if the attribute ->can('type_constraint')
      # since we may be trying to immutabilize a Moose meta class,
      # which in turn has attributes which are Class::MOP::Attribute
      # objects, rather than Moose::Meta::Attribute. And
      # Class::MOP::Attribute attributes have no type constraints.
      # However we need to make sure we leave an undef value there
      # because the inlined code is using the index of the attributes
      # to determine where to find the type constraint
  
      my @type_constraints = map {
          $_->can('type_constraint') ? $_->type_constraint : undef
      } @attrs;
  
      my @type_constraint_bodies = map {
          defined $_ ? $_->_compiled_type_constraint : undef;
      } @type_constraints;
  
      my @type_coercions = map {
          defined $_ && $_->has_coercion
              ? $_->coercion->_compiled_type_coercion
              : undef
      } @type_constraints;
  
      my @type_constraint_messages = map {
          defined $_
              ? ($_->has_message ? $_->message : $_->_default_message)
              : undef
      } @type_constraints;
  
      return {
          %{ $self->SUPER::_eval_environment },
          ((any { defined && $_->has_initializer } @attrs)
              ? ('$attrs' => \[@attrs])
              : ()),
          '$triggers' => \$triggers,
          '@type_coercions' => \@type_coercions,
          '@type_constraint_bodies' => \@type_constraint_bodies,
          '@type_constraint_messages' => \@type_constraint_messages,
          ( map { defined($_) ? %{ $_->inline_environment } : () }
                @type_constraints ),
          # pretty sure this is only going to be closed over if you use a custom
          # error class at this point, but we should still get rid of this
          # at some point
          '$meta'  => \$self,
          '$class_name' => \($self->name),
      };
  }
  
  sub superclasses {
      my $self = shift;
      my $supers = Data::OptList::mkopt(\@_);
      foreach my $super (@{ $supers }) {
          my ($name, $opts) = @{ $super };
          Moose::Util::_load_user_class($name, $opts);
          my $meta = Class::MOP::class_of($name);
          throw_exception( CanExtendOnlyClasses => role_name => $meta->name )
              if $meta && $meta->isa('Moose::Meta::Role')
      }
      return $self->SUPER::superclasses(map { $_->[0] } @{ $supers });
  }
  
  ### ---------------------------------------------
  
  sub add_attribute {
      my $self = shift;
      my $attr =
          (blessed $_[0] && $_[0]->isa('Class::MOP::Attribute')
              ? $_[0]
              : $self->_process_attribute(@_));
      $self->SUPER::add_attribute($attr);
      # it may be a Class::MOP::Attribute, theoretically, which doesn't have
      # 'bare' and doesn't implement this method
      if ($attr->can('_check_associated_methods')) {
          $attr->_check_associated_methods;
      }
      return $attr;
  }
  
  sub add_override_method_modifier {
      my ($self, $name, $method, $_super_package) = @_;
  
      my $existing_method = $self->get_method($name);
      (!$existing_method)
          || throw_exception( CannotOverrideLocalMethodIsPresent => class_name => $self->name,
                                                                    method     => $existing_method,
                            );
      $self->add_method($name => Moose::Meta::Method::Overridden->new(
          method  => $method,
          class   => $self,
          package => $_super_package, # need this for roles
          name    => $name,
      ));
  }
  
  sub add_augment_method_modifier {
      my ($self, $name, $method) = @_;
      my $existing_method = $self->get_method($name);
      throw_exception( CannotAugmentIfLocalMethodPresent => class_name => $self->name,
                                                            method     => $existing_method,
                     )
          if( $existing_method );
  
      $self->add_method($name => Moose::Meta::Method::Augmented->new(
          method  => $method,
          class   => $self,
          name    => $name,
      ));
  }
  
  ## Private Utility methods ...
  
  sub _find_next_method_by_name_which_is_not_overridden {
      my ($self, $name) = @_;
      foreach my $method ($self->find_all_methods_by_name($name)) {
          return $method->{code}
              if blessed($method->{code}) && !$method->{code}->isa('Moose::Meta::Method::Overridden');
      }
      return undef;
  }
  
  ## Metaclass compatibility
  
  sub _base_metaclasses {
      my $self = shift;
      my %metaclasses = $self->SUPER::_base_metaclasses;
      for my $class (keys %metaclasses) {
          $metaclasses{$class} =~ s/^Class::MOP/Moose::Meta/;
      }
      return (
          %metaclasses,
      );
  }
  
  sub _fix_class_metaclass_incompatibility {
      my $self = shift;
      my ($super_meta) = @_;
  
      $self->SUPER::_fix_class_metaclass_incompatibility(@_);
  
      if ($self->_class_metaclass_can_be_made_compatible($super_meta)) {
          ($self->is_pristine)
              || throw_exception( CannotFixMetaclassCompatibility => class      => $self,
                                                                     superclass => $super_meta
                                );
          my $super_meta_name = $super_meta->_real_ref_name;
          my $class_meta_subclass_meta_name = Moose::Util::_reconcile_roles_for_metaclass(blessed($self), $super_meta_name);
          my $new_self = $class_meta_subclass_meta_name->reinitialize(
              $self->name,
          );
  
          $self->_replace_self( $new_self, $class_meta_subclass_meta_name );
      }
  }
  
  sub _fix_single_metaclass_incompatibility {
      my $self = shift;
      my ($metaclass_type, $super_meta) = @_;
  
      $self->SUPER::_fix_single_metaclass_incompatibility(@_);
  
      if ($self->_single_metaclass_can_be_made_compatible($super_meta, $metaclass_type)) {
          ($self->is_pristine)
              || throw_exception( CannotFixMetaclassCompatibility => class          => $self,
                                                                     superclass     => $super_meta,
                                                                     metaclass_type => $metaclass_type
                                );
          my $super_meta_name = $super_meta->_real_ref_name;
          my $class_specific_meta_subclass_meta_name = Moose::Util::_reconcile_roles_for_metaclass($self->$metaclass_type, $super_meta->$metaclass_type);
          my $new_self = $super_meta->reinitialize(
              $self->name,
              $metaclass_type => $class_specific_meta_subclass_meta_name,
          );
  
          $self->_replace_self( $new_self, $super_meta_name );
      }
  }
  
  sub _replace_self {
      my $self      = shift;
      my ( $new_self, $new_class)   = @_;
  
      %$self = %$new_self;
      bless $self, $new_class;
  
      # We need to replace the cached metaclass instance or else when it goes
      # out of scope Class::MOP::Class destroy's the namespace for the
      # metaclass's class, causing much havoc.
      my $weaken = Class::MOP::metaclass_is_weak( $self->name );
      Class::MOP::store_metaclass_by_name( $self->name, $self );
      Class::MOP::weaken_metaclass( $self->name ) if $weaken;
  }
  
  sub _process_attribute {
      my ( $self, $name, @args ) = @_;
  
      @args = %{$args[0]} if scalar @args == 1 && ref($args[0]) eq 'HASH';
  
      if (($name || '') =~ /^\+(.*)/) {
          return $self->_process_inherited_attribute($1, @args);
      }
      else {
          return $self->_process_new_attribute($name, @args);
      }
  }
  
  sub _process_new_attribute {
      my ( $self, $name, @args ) = @_;
  
      $self->attribute_metaclass->interpolate_class_and_new($name, @args);
  }
  
  sub _process_inherited_attribute {
      my ($self, $attr_name, %options) = @_;
  
      my $inherited_attr = $self->find_attribute_by_name($attr_name);
      (defined $inherited_attr)
          || throw_exception( NoAttributeFoundInSuperClass => class_name     => $self->name,
                                                              attribute_name => $attr_name,
                                                              params         => \%options
                            );
      if ($inherited_attr->isa('Moose::Meta::Attribute')) {
          return $inherited_attr->clone_and_inherit_options(%options);
      }
      else {
          # NOTE:
          # kind of a kludge to handle Class::MOP::Attributes
          return $inherited_attr->Moose::Meta::Attribute::clone_and_inherit_options(%options);
      }
  }
  
  # reinitialization support
  
  sub _restore_metaobjects_from {
      my $self = shift;
      my ($old_meta) = @_;
  
      $self->SUPER::_restore_metaobjects_from($old_meta);
  
      for my $role ( @{ $old_meta->roles } ) {
          $self->add_role($role);
      }
  
      for my $application ( @{ $old_meta->_get_role_applications } ) {
          $application->class($self);
          $self->add_role_application ($application);
      }
  }
  
  ## Immutability
  
  sub _immutable_options {
      my ( $self, @args ) = @_;
  
      $self->SUPER::_immutable_options(
          inline_destructor => 1,
  
          # Moose always does this when an attribute is created
          inline_accessors => 0,
  
          @args,
      );
  }
  
  sub _fixup_attributes_after_rebless {
      my $self = shift;
      my ($instance, $rebless_from, %params) = @_;
  
      $self->SUPER::_fixup_attributes_after_rebless(
          $instance,
          $rebless_from,
          %params
      );
  
      $self->_call_all_triggers( $instance, \%params );
  }
  
  ## -------------------------------------------------
  
  our $error_level;
  
  sub _inline_throw_exception {
      my ( $self, $exception_type, $throw_args ) = @_;
      return 'die Module::Runtime::use_module("Moose::Exception::' . $exception_type . '")->new(' . ($throw_args || '') . ')';
  }
  
  1;
  
  # ABSTRACT: The Moose metaclass
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Class - The Moose metaclass
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Class> that provides
  additional Moose-specific functionality.
  
  To really understand this class, you will need to start with the
  L<Class::MOP::Class> documentation. This class can be understood as a
  set of additional features on top of the basic feature provided by
  that parent class.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Class> is a subclass of L<Class::MOP::Class>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::Class->initialize($package_name, %options) >>
  
  This overrides the parent's method in order to provide its own
  defaults for the C<attribute_metaclass>, C<instance_metaclass>, and
  C<method_metaclass> options.
  
  These all default to the appropriate Moose class.
  
  =item B<< Moose::Meta::Class->create($package_name, %options) >>
  
  This overrides the parent's method in order to accept a C<roles>
  option. This should be an array reference containing roles
  that the class does, each optionally followed by a hashref of options
  (C<-excludes> and C<-alias>).
  
    my $metaclass = Moose::Meta::Class->create( 'New::Class', roles => [...] );
  
  =item B<< Moose::Meta::Class->create_anon_class >>
  
  This overrides the parent's method to accept a C<roles> option, just
  as C<create> does.
  
  It also accepts a C<cache> option. If this is C<true>, then the anonymous
  class will be cached based on its superclasses and roles. If an
  existing anonymous class in the cache has the same superclasses and
  roles, it will be reused.
  
    my $metaclass = Moose::Meta::Class->create_anon_class(
        superclasses => ['Foo'],
        roles        => [qw/Some Roles Go Here/],
        cache        => 1,
    );
  
  Each entry in both the C<superclasses> and the C<roles> option can be
  followed by a hash reference with arguments. The C<superclasses>
  option can be supplied with a L<-version|Class::MOP/Class Loading
  Options> option that ensures the loaded superclass satisfies the
  required version. The C<role> option also takes the C<-version> as an
  argument, but the option hash reference can also contain any other
  role relevant values like exclusions or parameterized role arguments.
  
  =item B<< $metaclass->new_object(%params) >>
  
  This overrides the parent's method in order to add support for
  attribute triggers.
  
  =item B<< $metaclass->superclasses(@superclasses) >>
  
  This is the accessor allowing you to read or change the parents of
  the class.
  
  Each superclass can be followed by a hash reference containing a
  L<-version|Class::MOP/Class Loading Options> value. If the version
  requirement is not satisfied an error will be thrown.
  
  When you pass classes to this method, we will attempt to load them if they are
  not already loaded.
  
  =item B<< $metaclass->add_override_method_modifier($name, $sub) >>
  
  This adds an C<override> method modifier to the package.
  
  =item B<< $metaclass->add_augment_method_modifier($name, $sub) >>
  
  This adds an C<augment> method modifier to the package.
  
  =item B<< $metaclass->calculate_all_roles >>
  
  This will return a unique array of L<Moose::Meta::Role> instances
  which are attached to this class.
  
  =item B<< $metaclass->calculate_all_roles_with_inheritance >>
  
  This will return a unique array of L<Moose::Meta::Role> instances
  which are attached to this class, and each of this class's ancestors.
  
  =item B<< $metaclass->add_role($role) >>
  
  This takes a L<Moose::Meta::Role> object, and adds it to the class's
  list of roles. This I<does not> actually apply the role to the class.
  
  =item B<< $metaclass->role_applications >>
  
  Returns a list of L<Moose::Meta::Role::Application::ToClass>
  objects, which contain the arguments to role application.
  
  =item B<< $metaclass->add_role_application($application) >>
  
  This takes a L<Moose::Meta::Role::Application::ToClass> object, and
  adds it to the class's list of role applications. This I<does not>
  actually apply any role to the class; it is only for tracking role
  applications.
  
  =item B<< $metaclass->does_role($role) >>
  
  This returns a boolean indicating whether or not the class does the specified
  role. The role provided can be either a role name or a L<Moose::Meta::Role>
  object. This tests both the class and its parents.
  
  =item B<< $metaclass->excludes_role($role_name) >>
  
  A class excludes a role if it has already composed a role which
  excludes the named role. This tests both the class and its parents.
  
  =item B<< $metaclass->add_attribute($attr_name, %params|$params) >>
  
  This overrides the parent's method in order to allow the parameters to
  be provided as a hash reference.
  
  =item B<< $metaclass->constructor_class($class_name) >>
  
  =item B<< $metaclass->destructor_class($class_name) >>
  
  These are the names of classes used when making a class immutable. These
  default to L<Moose::Meta::Method::Constructor> and
  L<Moose::Meta::Method::Destructor> respectively. These accessors are
  read-write, so you can use them to change the class name.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_CLASS

$fatpacked{"darwin-2level/Moose/Meta/Class/Immutable/Trait.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_CLASS_IMMUTABLE_TRAIT';
  package Moose::Meta::Class::Immutable::Trait;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Class::MOP;
  use Scalar::Util qw( blessed );
  
  use parent 'Class::MOP::Class::Immutable::Trait';
  
  use Moose::Util 'throw_exception';
  
  sub add_role { $_[1]->_immutable_cannot_call }
  
  sub calculate_all_roles {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{calculate_all_roles} ||= [ $self->$orig ] };
  }
  
  sub calculate_all_roles_with_inheritance {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{calculate_all_roles_with_inheritance} ||= [ $self->$orig ] };
  }
  
  sub does_role {
      shift;
      my $self = shift;
      my $role = shift;
  
      (defined $role)
          || throw_exception( RoleNameRequired => class_name => $self->name );
  
      $self->{__immutable}{does_role} ||= { map { $_->name => 1 } $self->calculate_all_roles_with_inheritance };
  
      my $name = blessed $role ? $role->name : $role;
  
      return $self->{__immutable}{does_role}{$name};
  }
  
  1;
  
  # ABSTRACT: Implements immutability for metaclass objects
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Class::Immutable::Trait - Implements immutability for metaclass objects
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class makes some Moose-specific metaclass methods immutable. This
  is deep guts.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_CLASS_IMMUTABLE_TRAIT

$fatpacked{"darwin-2level/Moose/Meta/Instance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_INSTANCE';
  package Moose::Meta::Instance;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Class::MOP::MiniTrait;
  
  use parent 'Class::MOP::Instance';
  
  Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
  
  1;
  
  # ABSTRACT: The Moose Instance metaclass
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Instance - The Moose Instance metaclass
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 SYNOPSIS
  
      # nothing to see here
  
  =head1 DESCRIPTION
  
  This class provides the low level data storage abstractions for
  attributes.
  
  Using this API directly in your own code violates encapsulation, and
  we recommend that you use the appropriate APIs in
  L<Moose::Meta::Class> and L<Moose::Meta::Attribute> instead. Those
  APIs in turn call the methods in this class as appropriate.
  
  At present, this is an empty subclass of L<Class::MOP::Instance>, so
  you should see that class for all API details.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Instance> is a subclass of L<Class::MOP::Instance>.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_INSTANCE

$fatpacked{"darwin-2level/Moose/Meta/Method.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD';
  package Moose::Meta::Method;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Class::MOP::MiniTrait;
  
  use parent 'Class::MOP::Method';
  
  Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
  
  1;
  
  # ABSTRACT: A Moose Method metaclass
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method - A Moose Method metaclass
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Method> that provides
  additional Moose-specific functionality, all of which is private.
  
  To understand this class, you should read the L<Class::MOP::Method>
  documentation.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Method> is a subclass of L<Class::MOP::Method>.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_METHOD

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR';
  package Moose::Meta::Method::Accessor;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Try::Tiny;
  
  use parent 'Moose::Meta::Method',
           'Class::MOP::Method::Accessor';
  
  use Moose::Util 'throw_exception';
  
  # multiple inheritance is terrible
  sub new {
      goto &Class::MOP::Method::Accessor::new;
  }
  
  sub _new {
      goto &Class::MOP::Method::Accessor::_new;
  }
  
  sub _error_thrower {
      my $self = shift;
      return $self->associated_attribute
          if ref($self) && defined($self->associated_attribute);
      return $self->SUPER::_error_thrower;
  }
  
  sub _compile_code {
      my $self = shift;
      my @args = @_;
      try {
          $self->SUPER::_compile_code(@args);
      }
      catch {
          throw_exception( CouldNotCreateWriter => attribute      => $self->associated_attribute,
                                                   error          => $_,
                                                   instance       => $self
                         );
      };
  }
  
  sub _eval_environment {
      my $self = shift;
      return $self->associated_attribute->_eval_environment;
  }
  
  sub _instance_is_inlinable {
      my $self = shift;
      return $self->associated_attribute->associated_class->instance_metaclass->is_inlinable;
  }
  
  sub _generate_reader_method {
      my $self = shift;
      $self->_instance_is_inlinable ? $self->_generate_reader_method_inline(@_)
                                    : $self->SUPER::_generate_reader_method(@_);
  }
  
  sub _generate_writer_method {
      my $self = shift;
      $self->_instance_is_inlinable ? $self->_generate_writer_method_inline(@_)
                                    : $self->SUPER::_generate_writer_method(@_);
  }
  
  sub _generate_accessor_method {
      my $self = shift;
      $self->_instance_is_inlinable ? $self->_generate_accessor_method_inline(@_)
                                    : $self->SUPER::_generate_accessor_method(@_);
  }
  
  sub _generate_predicate_method {
      my $self = shift;
      $self->_instance_is_inlinable ? $self->_generate_predicate_method_inline(@_)
                                    : $self->SUPER::_generate_predicate_method(@_);
  }
  
  sub _generate_clearer_method {
      my $self = shift;
      $self->_instance_is_inlinable ? $self->_generate_clearer_method_inline(@_)
                                    : $self->SUPER::_generate_clearer_method(@_);
  }
  
  sub _writer_value_needs_copy {
      shift->associated_attribute->_writer_value_needs_copy(@_);
  }
  
  sub _inline_tc_code {
      shift->associated_attribute->_inline_tc_code(@_);
  }
  
  sub _inline_check_coercion {
      shift->associated_attribute->_inline_check_coercion(@_);
  }
  
  sub _inline_check_constraint {
      shift->associated_attribute->_inline_check_constraint(@_);
  }
  
  sub _inline_check_lazy {
      shift->associated_attribute->_inline_check_lazy(@_);
  }
  
  sub _inline_store_value {
      shift->associated_attribute->_inline_instance_set(@_) . ';';
  }
  
  sub _inline_get_old_value_for_trigger {
      shift->associated_attribute->_inline_get_old_value_for_trigger(@_);
  }
  
  sub _inline_trigger {
      shift->associated_attribute->_inline_trigger(@_);
  }
  
  sub _get_value {
      shift->associated_attribute->_inline_instance_get(@_);
  }
  
  sub _has_value {
      shift->associated_attribute->_inline_instance_has(@_);
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for accessors
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method::Accessor - A Moose Method metaclass for accessors
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Method::Accessor> that
  provides additional Moose-specific functionality, all of which is
  private.
  
  To understand this class, you should read the
  L<Class::MOP::Method::Accessor> documentation.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE';
  package Moose::Meta::Method::Accessor::Native;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Carp qw( confess );
  use Scalar::Util qw( blessed );
  
  use Moose::Role;
  
  use Moose::Util 'throw_exception';
  
  around new => sub {
      my $orig = shift;
      my $class   = shift;
      my %options = @_;
  
      $options{curried_arguments} = []
          unless exists $options{curried_arguments};
  
      throw_exception( MustSupplyArrayRefAsCurriedArguments => params     => \%options,
                                                               class_name => $class
                     )
          unless $options{curried_arguments}
              && ref($options{curried_arguments}) eq 'ARRAY';
  
      my $attr_context = $options{attribute}->definition_context;
      my $desc = 'native delegation method ';
      $desc   .= $options{attribute}->associated_class->name;
      $desc   .= '::' . $options{name};
      $desc   .= " ($options{delegate_to_method})";
      $desc   .= " of attribute " . $options{attribute}->name;
      $options{definition_context} = {
          %{ $attr_context || {} },
          description => $desc,
      };
  
      $options{accessor_type} = 'native';
  
      return $class->$orig(%options);
  };
  
  sub _new {
      my $class = shift;
      my $options = @_ == 1 ? $_[0] : {@_};
  
      return bless $options, $class;
  }
  
  sub root_types { (shift)->{'root_types'} }
  
  sub _initialize_body {
      my $self = shift;
  
      $self->{'body'} = $self->_compile_code( [$self->_generate_method] );
  
      return;
  }
  
  sub _inline_curried_arguments {
      my $self = shift;
  
      return unless @{ $self->curried_arguments };
  
      return 'unshift @_, @curried;';
  }
  
  sub _inline_check_argument_count {
      my $self = shift;
  
      my @code;
  
      if (my $min = $self->_minimum_arguments) {
          push @code, (
              'if (@_ < ' . $min . ') {',
                  $self->_inline_throw_exception( MethodExpectsMoreArgs =>
                                                  'method_name           => "'.$self->delegate_to_method.'",'.
                                                  "minimum_args          => ".$min,
                  ) . ';',
              '}',
          );
      }
  
      if (defined(my $max = $self->_maximum_arguments)) {
          push @code, (
              'if (@_ > ' . $max . ') {',
                  $self->_inline_throw_exception( MethodExpectsFewerArgs =>
                                                  'method_name            => "'.$self->delegate_to_method.'",'.
                                                  'maximum_args           => '.$max,
                  ) . ';',
              '}',
          );
      }
  
      return @code;
  }
  
  sub _inline_return_value {
      my $self = shift;
      my ($slot_access, $for_writer) = @_;
  
      return 'return ' . $self->_return_value($slot_access, $for_writer) . ';';
  }
  
  sub _minimum_arguments { 0 }
  sub _maximum_arguments { undef }
  
  override _get_value => sub {
      my $self = shift;
      my ($instance) = @_;
  
      return $self->_slot_access_can_be_inlined
          ? super()
          : $instance . '->$reader';
  };
  
  override _inline_store_value => sub {
      my $self = shift;
      my ($instance, $value) = @_;
  
      return $self->_slot_access_can_be_inlined
          ? super()
          : $instance . '->$writer(' . $value . ');';
  };
  
  override _eval_environment => sub {
      my $self = shift;
  
      my $env = super();
  
      $env->{'@curried'} = $self->curried_arguments;
  
      return $env if $self->_slot_access_can_be_inlined;
  
      my $reader = $self->associated_attribute->get_read_method_ref;
      $reader = $reader->body if blessed $reader;
  
      $env->{'$reader'} = \$reader;
  
      my $writer = $self->associated_attribute->get_write_method_ref;
      $writer = $writer->body if blessed $writer;
  
      $env->{'$writer'} = \$writer;
  
      return $env;
  };
  
  sub _slot_access_can_be_inlined {
      my $self = shift;
  
      return $self->is_inline && $self->_instance_is_inlinable;
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY';
  package Moose::Meta::Method::Accessor::Native::Array;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  sub _inline_check_var_is_valid_index {
      my $self = shift;
      my ($var) = @_;
  
      return (
          'if (!defined(' . $var . ') || ' . $var . ' !~ /^-?\d+$/) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => '.$var.','.
                                              'method_name             => "'.$self->delegate_to_method.'",'.
                                              'type_of_argument        => "integer",'.
                                              'type                    => "Int",'.
                                              'argument_noun           => "index"',
              ) . ';',
          '}',
      );
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_WRITER';
  package Moose::Meta::Method::Accessor::Native::Array::Writer;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer',
       'Moose::Meta::Method::Accessor::Native::Array',
       'Moose::Meta::Method::Accessor::Native::Collection';
  
  sub _inline_coerce_new_values {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Collection::_inline_coerce_new_values(@_);
  }
  
  sub _new_members { '@_' }
  
  sub _copy_old_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @{(' . $slot_access . ')} ]';
  }
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_WRITER

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_ACCESSOR';
  package Moose::Meta::Method::Accessor::Native::Array::accessor;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::set',
       'Moose::Meta::Method::Accessor::Native::Array::get';
  
  sub _inline_process_arguments {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Array::get::_inline_process_arguments(@_);
  }
  
  sub _inline_check_arguments {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Array::get::_inline_check_arguments(@_);
  }
  
  sub _return_value {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Array::get::_return_value(@_);
  }
  
  sub _generate_method {
      my $self = shift;
  
      my $inv         = '$self';
      my $slot_access = $self->_get_value($inv);
  
      return (
          'sub {',
              'my ' . $inv . ' = shift;',
              $self->_inline_curried_arguments,
              $self->_inline_check_lazy($inv, '$type_constraint', '$type_coercion', '$type_message'),
              # get
              'if (@_ == 1) {',
                  $self->_inline_check_var_is_valid_index('$_[0]'),
                  $self->Moose::Meta::Method::Accessor::Native::Array::get::_inline_return_value($slot_access),
              '}',
              # set
              'else {',
                  $self->_inline_writer_core($inv, $slot_access),
              '}',
          '}',
      );
  }
  
  sub _minimum_arguments { 1 }
  sub _maximum_arguments { 2 }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_ACCESSOR

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/clear.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_CLEAR';
  package Moose::Meta::Method::Accessor::Native::Array::clear;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _adds_members { 0 }
  
  sub _potential_value { '[]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = [];';
  }
  
  sub _return_value { '' }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_CLEAR

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/count.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_COUNT';
  package Moose::Meta::Method::Accessor::Native::Array::count;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'scalar @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_COUNT

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/delete.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_DELETE';
  package Moose::Meta::Method::Accessor::Native::Array::delete;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return $self->_inline_check_var_is_valid_index('$_[0]');
  }
  
  sub _adds_members { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my @potential = @{ (' . $slot_access . ') }; '
               . '@return = splice @potential, $_[0], 1; '
               . '\@potential; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@return = splice @{ (' . $slot_access . ') }, $_[0], 1;';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$return[0]';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_DELETE

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/elements.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_ELEMENTS';
  package Moose::Meta::Method::Accessor::Native::Array::elements;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '@{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_ELEMENTS

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/first.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_FIRST';
  package Moose::Meta::Method::Accessor::Native::Array::first;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use List::Util ();
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[0],'.
                                              'method_name             => "first",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '&List::Util::first($_[0], @{ (' . $slot_access . ') })';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_FIRST

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/first_index.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_FIRST_INDEX';
  package Moose::Meta::Method::Accessor::Native::Array::first_index;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[0],'.
                                              'method_name             => "first_index",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",',
              ) . ';',
          '}',
      );
  }
  
  sub _inline_return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return join '',
          'my @values = @{ (' . $slot_access . ') };',
          'my $f = $_[0];',
          'foreach my $i ( 0 .. $#values ) {',
              'local *_ = \\$values[$i];',
              'return $i if $f->();',
          '}',
          'return -1;';
  }
  
  # Not called, but needed to satisfy the Reader role
  sub _return_value { }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_FIRST_INDEX

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/get.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_GET';
  package Moose::Meta::Method::Accessor::Native::Array::get;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Class::MOP::MiniTrait;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader',
       'Moose::Meta::Method::Accessor::Native::Array';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return $self->_inline_check_var_is_valid_index('$_[0]');
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . '->[ $_[0] ]';
  }
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_GET

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/grep.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_GREP';
  package Moose::Meta::Method::Accessor::Native::Array::grep;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[0],'.
                                              'method_name             => "grep",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'grep { $_[0]->() } @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_GREP

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/insert.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_INSERT';
  package Moose::Meta::Method::Accessor::Native::Array::insert;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _minimum_arguments { 2 }
  
  sub _maximum_arguments { 2 }
  
  sub _adds_members { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my @potential = @{ (' . $slot_access . ') }; '
               . 'splice @potential, $_[0], 0, $_[1]; '
               . '\@potential; '
           . '})';
  }
  
  # We need to override this because while @_ can be written to, we cannot write
  # directly to $_[1].
  sub _inline_coerce_new_values {
      my $self = shift;
  
      return unless $self->associated_attribute->should_coerce;
  
      return unless $self->_tc_member_type_can_coerce;
  
      return '@_ = ($_[0], $member_coercion->($_[1]));';
  };
  
  sub _new_members { '$_[1]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return 'splice @{ (' . $slot_access . ') }, $_[0], 0, $_[1];';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . '->[ $_[0] ]';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_INSERT

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/is_empty.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_IS_EMPTY';
  package Moose::Meta::Method::Accessor::Native::Array::is_empty;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '@{ (' . $slot_access . ') } ? 0 : 1';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_IS_EMPTY

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/join.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_JOIN';
  package Moose::Meta::Method::Accessor::Native::Array::join;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Moose::Util::_STRINGLIKE0($_[0])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[0],'.
                                              'method_name             => "join",'.
                                              'type_of_argument        => "string",'.
                                              'type                    => "Str",',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'join $_[0], @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_JOIN

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/map.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_MAP';
  package Moose::Meta::Method::Accessor::Native::Array::map;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[0],'.
                                              'method_name             => "map",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'map { $_[0]->() } @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_MAP

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/natatime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_NATATIME';
  package Moose::Meta::Method::Accessor::Native::Array::natatime;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 2 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!defined($_[0]) || $_[0] !~ /^\d+$/) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[0],'.
                                              'method_name             => "natatime",'.
                                              'type_of_argument        => "integer",'.
                                              'type                    => "Int",'.
                                              'argument_noun           => "n value"',
              ) . ';',
          '}',
          'if (@_ == 2 && !Params::Util::_CODELIKE($_[1])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[1],'.
                                              'method_name             => "natatime",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",'.
                                              'ordinal                 => "second"',
              ) . ';',
          '}',
      );
  }
  
  sub _inline_return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return (
          'my $step = $_[0];',
          'my @values = @{ (' . $slot_access . ') };',
          'my $iter = sub { splice @values, 0, $step };',
          'if ($_[1]) {',
              'while (my @vals = $iter->()) {',
                  '$_[1]->(@vals);',
              '}',
          '}',
          'else {',
              'return $iter;',
          '}',
      );
  }
  
  # Not called, but needed to satisfy the Reader role
  sub _return_value { }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_NATATIME

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/pop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_POP';
  package Moose::Meta::Method::Accessor::Native::Array::pop;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _adds_members { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @{ (' . $slot_access . ') } > 1 '
               . '? @{ (' . $slot_access . ') }[0..$#{ (' . $slot_access . ') } - 1] '
               . ': () ]';
  }
  
  sub _inline_capture_return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'my $old = ' . $slot_access . '->[-1];';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return 'pop @{ (' . $slot_access . ') };';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$old';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_POP

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/push.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_PUSH';
  package Moose::Meta::Method::Accessor::Native::Array::push;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _adds_members { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @{ (' . $slot_access . ') }, @_ ]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return 'push @{ (' . $slot_access . ') }, @_;';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'scalar @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_PUSH

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/reduce.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_REDUCE';
  package Moose::Meta::Method::Accessor::Native::Array::reduce;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use List::Util ();
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[0],'.
                                              'method_name             => "reduce",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'List::Util::reduce { $_[0]->($a, $b) } @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_REDUCE

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SET';
  package Moose::Meta::Method::Accessor::Native::Array::set;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _minimum_arguments { 2 }
  
  sub _maximum_arguments { 2 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return $self->_inline_check_var_is_valid_index('$_[0]');
  }
  
  sub _adds_members { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my @potential = @{ (' . $slot_access . ') }; '
               . '$potential[$_[0]] = $_[1]; '
               . '\@potential; '
           . '})';
  }
  
  # We need to override this because while @_ can be written to, we cannot write
  # directly to $_[1].
  sub _inline_coerce_new_values {
      my $self = shift;
  
      return unless $self->associated_attribute->should_coerce;
  
      return unless $self->_tc_member_type_can_coerce;
  
      return '@_ = ($_[0], $member_coercion->($_[1]));';
  };
  
  sub _new_members { '$_[1]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . '->[$_[0]] = $_[1];';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . '->[$_[0]]';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SET

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/shallow_clone.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHALLOW_CLONE';
  package Moose::Meta::Method::Accessor::Native::Array::shallow_clone;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 0 }
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @{ (' . $slot_access . ') } ]';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHALLOW_CLONE

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/shift.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHIFT';
  package Moose::Meta::Method::Accessor::Native::Array::shift;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _adds_members { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @{ (' . $slot_access . ') } > 1 '
               . '? @{ (' . $slot_access . ') }[1..$#{ (' . $slot_access . ') }] '
               . ': () ]';
  }
  
  sub _inline_capture_return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'my $old = ' . $slot_access . '->[0];';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return 'shift @{ (' . $slot_access . ') };';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$old';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHIFT

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/shuffle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHUFFLE';
  package Moose::Meta::Method::Accessor::Native::Array::shuffle;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use List::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'List::Util::shuffle @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHUFFLE

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/sort.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SORT';
  package Moose::Meta::Method::Accessor::Native::Array::sort;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (@_ && !Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[0],'.
                                              'method_name             => "sort",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return
          'wantarray ? ( ' .
              '$_[0] '
                  . '? sort { $_[0]->($a, $b) } @{ (' . $slot_access . ') } '
                  . ': sort @{ (' . $slot_access . ') }'
              . ' ) : @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SORT

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/sort_in_place.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SORT_IN_PLACE';
  package Moose::Meta::Method::Accessor::Native::Array::sort_in_place;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (@_ && !Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[0],'.
                                              'method_name             => "sort_in_place",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",',
              ) . ';',
          '}',
      );
  }
  
  sub _adds_members { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ $_[0] '
               . '? sort { $_[0]->($a, $b) } @{ (' . $slot_access . ') } '
               . ': sort @{ (' . $slot_access . ') } ]';
  }
  
  sub _return_value { '' }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SORT_IN_PLACE

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/splice.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SPLICE';
  package Moose::Meta::Method::Accessor::Native::Array::splice;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _adds_members { 1 }
  
  sub _inline_process_arguments {
      return (
          'my $idx = shift;',
          'my $len = @_ ? shift : undef;',
      );
  }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          $self->_inline_check_var_is_valid_index('$idx'),
          'if (defined($len) && $len !~ /^-?\d+$/) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $len,'.
                                              'method_name             => "splice",'.
                                              'type_of_argument        => "integer",'.
                                              'type                    => "Int",'.
                                              'argument_noun           => "length argument"',
              ) . ';',
          '}',
      );
  }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my @potential = @{ (' . $slot_access . ') }; '
               . '@return = defined $len '
                   . '? (splice @potential, $idx, $len, @_) '
                   . ': (splice @potential, $idx); '
                   . '\@potential;'
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return (
          '@return = defined $len',
              '? (splice @{ (' . $slot_access . ') }, $idx, $len, @_)',
              ': (splice @{ (' . $slot_access . ') }, $idx);',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'wantarray ? @return : $return[-1]';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SPLICE

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/uniq.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_UNIQ';
  package Moose::Meta::Method::Accessor::Native::Array::uniq;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use List::Util 1.45 ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'List::Util::uniq @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_UNIQ

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Array/unshift.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_UNSHIFT';
  package Moose::Meta::Method::Accessor::Native::Array::unshift;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _adds_members { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @_, @{ (' . $slot_access . ') } ]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return 'unshift @{ (' . $slot_access . ') }, @_;';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'scalar @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_UNSHIFT

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Bool/not.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_NOT';
  package Moose::Meta::Method::Accessor::Native::Bool::not;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '!' . $slot_access;
  }
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_NOT

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Bool/set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_SET';
  package Moose::Meta::Method::Accessor::Native::Bool::set;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value { 1 }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = 1;';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_SET

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Bool/toggle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_TOGGLE';
  package Moose::Meta::Method::Accessor::Native::Bool::toggle;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' ? 0 : 1';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = ' . $slot_access . ' ? 0 : 1;';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_TOGGLE

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Bool/unset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_UNSET';
  package Moose::Meta::Method::Accessor::Native::Bool::unset;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value { 0 }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = 0;';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_UNSET

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Code/execute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_CODE_EXECUTE';
  package Moose::Meta::Method::Accessor::Native::Code::execute;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . '->(@_)';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_CODE_EXECUTE

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Code/execute_method.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_CODE_EXECUTE_METHOD';
  package Moose::Meta::Method::Accessor::Native::Code::execute_method;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . '->($self, @_)';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_CODE_EXECUTE_METHOD

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Collection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_COLLECTION';
  package Moose::Meta::Method::Accessor::Native::Collection;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  requires qw( _adds_members _new_members );
  
  sub _inline_coerce_new_values {
      my $self = shift;
  
      return unless $self->associated_attribute->should_coerce;
  
      return unless $self->_tc_member_type_can_coerce;
  
      return (
          '(' . $self->_new_members . ') = map { $member_coercion->($_) }',
                                               $self->_new_members . ';',
      );
  }
  
  sub _tc_member_type_can_coerce {
      my $self = shift;
  
      my $member_tc = $self->_tc_member_type;
  
      return $member_tc && $member_tc->has_coercion;
  }
  
  sub _tc_member_type {
      my $self = shift;
  
      my $tc = $self->associated_attribute->type_constraint;
      while ($tc) {
          return $tc->type_parameter
              if $tc->can('type_parameter');
          $tc = $tc->parent;
      }
  
      return;
  }
  
  sub _writer_value_needs_copy {
      my $self = shift;
  
      return $self->_constraint_must_be_checked
          && !$self->_check_new_members_only;
  }
  
  sub _inline_tc_code {
      my $self = shift;
      my ($value, $tc, $coercion, $message, $is_lazy) = @_;
  
      return unless $self->_constraint_must_be_checked;
  
      if ($self->_check_new_members_only) {
          return unless $self->_adds_members;
  
          return $self->_inline_check_member_constraint($self->_new_members);
      }
      else {
          return (
              $self->_inline_check_coercion($value, $tc, $coercion, $is_lazy),
              $self->_inline_check_constraint($value, $tc, $message, $is_lazy),
          );
      }
  }
  
  sub _check_new_members_only {
      my $self = shift;
  
      my $attr = $self->associated_attribute;
  
      my $tc = $attr->type_constraint;
  
      # If we have a coercion, we could come up with an entirely new value after
      # coercing, so we need to check everything,
      return 0 if $attr->should_coerce && $tc->has_coercion;
  
      # If the parent is our root type (ArrayRef, HashRef, etc), that means we
      # can just check the new members of the collection, because we know that
      # we will always be generating an appropriate collection type.
      #
      # However, if this type has its own constraint (it's Parameteriz_able_,
      # not Paramet_erized_), we don't know what is being checked by the
      # constraint, so we need to check the whole value, not just the members.
      return 1
          if $self->_is_root_type( $tc->parent )
              && ( $tc->isa('Moose::Meta::TypeConstraint::Parameterized')
                   || !$tc->can('parameterize') );
  
      return 0;
  }
  
  sub _inline_check_member_constraint {
      my $self = shift;
      my ($new_value) = @_;
  
      my $attr_name = $self->associated_attribute->name;
  
      my $check
          = $self->_tc_member_type->can_be_inlined
          ? '! (' . $self->_tc_member_type->_inline_check('$new_val') . ')'
          : ' !$member_tc->($new_val) ';
  
      return (
          'for my $new_val (' . $new_value . ') {',
              "if ($check) {",
                  'my $msg = do { local $_ = $new_val; $member_message->($new_val) };'.
                  $self->_inline_throw_exception( ValidationFailedForInlineTypeConstraint =>
                                                  "attribute_name          => '".$attr_name."',".
                                                  'type_constraint_message => $msg,'.
                                                  'class_name              => $class_name,'.
                                                  'value                   => $new_val,'.
                                                  'new_member              => 1',
                  ) . ';',
              '}',
          '}',
      );
  }
  
  sub _inline_get_old_value_for_trigger {
      my $self = shift;
      my ($instance, $old) = @_;
  
      my $attr = $self->associated_attribute;
      return unless $attr->has_trigger;
  
      return (
          'my ' . $old . ' = ' . $self->_has_value($instance),
              '? ' . $self->_copy_old_value($self->_get_value($instance)),
              ': ();',
      );
  }
  
  around _eval_environment => sub {
      my $orig = shift;
      my $self = shift;
  
      my $env = $self->$orig(@_);
  
      my $member_tc = $self->_tc_member_type;
  
      return $env unless $member_tc;
  
      $env->{'$member_tc'} = \( $member_tc->_compiled_type_constraint );
      $env->{'$member_coercion'} = \(
          $member_tc->coercion->_compiled_type_coercion
      ) if $member_tc->has_coercion;
      $env->{'$member_message'} = \(
          $member_tc->has_message
              ? $member_tc->message
              : $member_tc->_default_message
      );
  
      my $tc_env = $member_tc->inline_environment();
  
      $env = { %{$env}, %{$tc_env} };
  
      return $env;
  };
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_COLLECTION

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Counter/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_WRITER';
  package Moose::Meta::Method::Accessor::Native::Counter::Writer;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _constraint_must_be_checked {
      my $self = shift;
  
      my $attr = $self->associated_attribute;
  
      return $attr->has_type_constraint
          && ($attr->type_constraint->name =~ /^(?:Num|Int)$/
           || ($attr->should_coerce && $attr->type_constraint->has_coercion)
             );
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_WRITER

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Counter/dec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_DEC';
  package Moose::Meta::Method::Accessor::Native::Counter::dec;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 0 }
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' - (defined $_[0] ? $_[0] : 1)';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' -= defined $_[0] ? $_[0] : 1;';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_DEC

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Counter/inc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_INC';
  package Moose::Meta::Method::Accessor::Native::Counter::inc;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 0 }
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' + (defined $_[0] ? $_[0] : 1)';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' += defined $_[0] ? $_[0] : 1;';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_INC

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Counter/reset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_RESET';
  package Moose::Meta::Method::Accessor::Native::Counter::reset;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      my $attr = $self->associated_attribute;
  
      return '(do { '
               . join(' ', $attr->_inline_generate_default(
                     '$self', '$default_for_reset'
                 )) . ' '
               . '$default_for_reset; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = ' . $self->_potential_value . ';';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_RESET

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Counter/set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_SET';
  package Moose::Meta::Method::Accessor::Native::Counter::set;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  sub _maximum_arguments { 1 }
  
  sub _potential_value { '$_[0]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = $_[0];';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_SET

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Hash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH';
  package Moose::Meta::Method::Accessor::Native::Hash;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  sub _inline_check_var_is_valid_key {
      my $self = shift;
      my ($var) = @_;
  
      return (
          'if (!defined(' . $var . ')) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => '.$var.','.
                                              'method_name             => "'.$self->delegate_to_method.'",'.
                                              'type_of_argument        => "defined value",'.
                                              'type                    => "Defined",'.
                                              'argument_noun           => "key"',
              ) . ';',
          '}',
      );
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Hash/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_WRITER';
  package Moose::Meta::Method::Accessor::Native::Hash::Writer;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Class::MOP::MiniTrait;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer',
       'Moose::Meta::Method::Accessor::Native::Hash',
       'Moose::Meta::Method::Accessor::Native::Collection';
  
  sub _inline_coerce_new_values {
      my $self = shift;
  
      return unless $self->associated_attribute->should_coerce;
  
      return unless $self->_tc_member_type_can_coerce;
  
      return <<'EOF';
  if (@_) {
      my %h = @_;
      @h{ sort keys %h } = map { $member_coercion->($_) } @h{ sort keys %h };
  }
  EOF
  }
  
  sub _new_members { 'values %{ { @_ } }' }
  
  sub _copy_old_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '{ %{ (' . $slot_access . ') } }';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_WRITER

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Hash/accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_ACCESSOR';
  package Moose::Meta::Method::Accessor::Native::Hash::accessor;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Hash::set',
       'Moose::Meta::Method::Accessor::Native::Hash::get';
  
  sub _inline_process_arguments {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Hash::set::_inline_process_arguments(@_);
  }
  
  sub _inline_check_argument_count {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Hash::set::_inline_check_argument_count(@_);
  }
  
  sub _inline_check_arguments {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Hash::set::_inline_check_arguments(@_);
  }
  
  sub _return_value {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Hash::set::_return_value(@_);
  }
  
  sub _generate_method {
      my $self = shift;
  
      my $inv         = '$self';
      my $slot_access = $self->_get_value($inv);
  
      return (
          'sub {',
              'my ' . $inv . ' = shift;',
              $self->_inline_curried_arguments,
              $self->_inline_check_lazy($inv, '$type_constraint', '$type_coercion', '$type_message'),
              # get
              'if (@_ == 1) {',
                  $self->_inline_check_var_is_valid_key('$_[0]'),
                  $slot_access . '->{$_[0]}',
              '}',
              # set
              'else {',
                  $self->_inline_writer_core($inv, $slot_access),
              '}',
          '}',
      );
  }
  
  sub _minimum_arguments { 1 }
  sub _maximum_arguments { 2 }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_ACCESSOR

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Hash/clear.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_CLEAR';
  package Moose::Meta::Method::Accessor::Native::Hash::clear;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Hash::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _adds_members { 0 }
  
  # The inner () in this expression is for the benefit of inlining code that
  # might end up looking like "values %{ {} }". This is a syntax error in perl
  # but 'values %{ { () } }' is not.
  sub _potential_value { '{ ( ) }' }
  
  # There are no new members so we don't need to coerce new values (none exist)
  # and we always want to check the new (empty) hash as a whole.
  sub _inline_coerce_new_values { '' }
  
  sub _check_new_members_only { 0 }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = {};';
  }
  
  sub _return_value { '' }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_CLEAR

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Hash/count.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_COUNT';
  package Moose::Meta::Method::Accessor::Native::Hash::count;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'scalar keys %{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_COUNT

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Hash/defined.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_DEFINED';
  package Moose::Meta::Method::Accessor::Native::Hash::defined;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader',
       'Moose::Meta::Method::Accessor::Native::Hash';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return $self->_inline_check_var_is_valid_key('$_[0]');
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'defined ' . $slot_access . '->{ $_[0] }';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_DEFINED

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Hash/delete.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_DELETE';
  package Moose::Meta::Method::Accessor::Native::Hash::delete;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Hash::Writer';
  
  sub _adds_members { 0 }
  
  # There are no new members so we don't need to coerce new values (none exist)
  # and we always want to check the new (empty) hash as a whole.
  sub _inline_coerce_new_values { '' }
  
  sub _check_new_members_only { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my %potential = %{ (' . $slot_access . ') }; '
               . '@return = delete @potential{@_}; '
               . '\%potential; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@return = delete @{ (' . $slot_access . ') }{@_};';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'wantarray ? @return : $return[-1]';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_DELETE

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Hash/elements.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_ELEMENTS';
  package Moose::Meta::Method::Accessor::Native::Hash::elements;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'map { $_, ' . $slot_access . '->{$_} } '
               . 'keys %{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_ELEMENTS

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Hash/exists.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_EXISTS';
  package Moose::Meta::Method::Accessor::Native::Hash::exists;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader',
       'Moose::Meta::Method::Accessor::Native::Hash';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return $self->_inline_check_var_is_valid_key('$_[0]');
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = shift;
  
      return 'exists ' . $slot_access . '->{ $_[0] }';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_EXISTS

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Hash/get.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_GET';
  package Moose::Meta::Method::Accessor::Native::Hash::get;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader',
       'Moose::Meta::Method::Accessor::Native::Hash';
  
  sub _minimum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'for (@_) {',
              $self->_inline_check_var_is_valid_key('$_'),
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '@_ > 1 '
               . '? @{ (' . $slot_access . ') }{@_} '
               . ': ' . $slot_access . '->{$_[0]}';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_GET

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Hash/is_empty.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_IS_EMPTY';
  package Moose::Meta::Method::Accessor::Native::Hash::is_empty;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'scalar keys %{ (' . $slot_access . ') } ? 0 : 1';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_IS_EMPTY

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Hash/keys.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_KEYS';
  package Moose::Meta::Method::Accessor::Native::Hash::keys;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'keys %{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_KEYS

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Hash/kv.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_KV';
  package Moose::Meta::Method::Accessor::Native::Hash::kv;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'map { [ $_, ' . $slot_access . '->{$_} ] } '
               . 'keys %{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_KV

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Hash/set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_SET';
  package Moose::Meta::Method::Accessor::Native::Hash::set;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use List::Util 1.32;
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Hash::Writer';
  
  sub _minimum_arguments { 2 }
  
  sub _maximum_arguments { undef }
  
  around _inline_check_argument_count => sub {
      my $orig = shift;
      my $self = shift;
  
      return (
          $self->$orig(@_),
          'if (@_ % 2) {',
              $self->_inline_throw_exception( MustPassEvenNumberOfArguments =>
                                              "method_name => '".$self->delegate_to_method."',".
                                              'args        => \@_',
              ) . ';',
          '}',
      );
  };
  
  sub _inline_process_arguments {
      my $self = shift;
  
      return (
          'my @keys_idx = grep { ! ($_ % 2) } 0..$#_;',
          'my @values_idx = grep { $_ % 2 } 0..$#_;',
      );
  }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'for (@keys_idx) {',
              'if (!defined($_[$_])) {',
                  $self->_inline_throw_exception( UndefinedHashKeysPassedToMethod =>
                                                  'hash_keys                       => \@keys_idx,'.
                                                  "method_name                     => '".$self->delegate_to_method."'",
                  ) . ';',
              '}',
          '}',
      );
  }
  
  sub _adds_members { 1 }
  
  # We need to override this because while @_ can be written to, we cannot write
  # directly to $_[1].
  sub _inline_coerce_new_values {
      my $self = shift;
  
      return unless $self->associated_attribute->should_coerce;
  
      return unless $self->_tc_member_type_can_coerce;
  
      # Is there a simpler way to do this?
      return (
          '@_ = List::Util::pairmap { $a => $member_coercion->($b) } @_;',
      );
  };
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '{ %{ (' . $slot_access . ') }, @_ }';
  }
  
  sub _new_members { '@_[ @values_idx ]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@{ (' . $slot_access . ') }{ @_[@keys_idx] } = @_[@values_idx];';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'wantarray '
               . '? @{ (' . $slot_access . ') }{ @_[@keys_idx] } '
               . ': ' . $slot_access . '->{ $_[$keys_idx[0]] }';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_SET

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Hash/shallow_clone.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_SHALLOW_CLONE';
  package Moose::Meta::Method::Accessor::Native::Hash::shallow_clone;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 0 }
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '{ %{ (' . $slot_access . ') } }';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_SHALLOW_CLONE

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Hash/values.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_VALUES';
  package Moose::Meta::Method::Accessor::Native::Hash::values;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'values %{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_VALUES

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Number/abs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_ABS';
  package Moose::Meta::Method::Accessor::Native::Number::abs;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'abs(' . $slot_access . ')';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = abs(' . $slot_access . ');';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_ABS

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Number/add.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_ADD';
  package Moose::Meta::Method::Accessor::Native::Number::add;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' + $_[0]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' += $_[0];';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_ADD

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Number/div.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_DIV';
  package Moose::Meta::Method::Accessor::Native::Number::div;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' / $_[0]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' /= $_[0];';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_DIV

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Number/mod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_MOD';
  package Moose::Meta::Method::Accessor::Native::Number::mod;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' % $_[0]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' %= $_[0];';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_MOD

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Number/mul.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_MUL';
  package Moose::Meta::Method::Accessor::Native::Number::mul;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' * $_[0]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' *= $_[0];';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_MUL

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Number/set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_SET';
  package Moose::Meta::Method::Accessor::Native::Number::set;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  sub _maximum_arguments { 1 }
  
  sub _potential_value { '$_[0]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = $_[0];';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_SET

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Number/sub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_SUB';
  package Moose::Meta::Method::Accessor::Native::Number::sub;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' - $_[0]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' -= $_[0];';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_SUB

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Reader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_READER';
  package Moose::Meta::Method::Accessor::Native::Reader;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native';
  
  requires '_return_value';
  
  sub _generate_method {
      my $self = shift;
  
      my $inv         = '$self';
      my $slot_access = $self->_get_value($inv);
  
      return (
          'sub {',
              'my ' . $inv . ' = shift;',
              $self->_inline_curried_arguments,
              $self->_inline_reader_core($inv, $slot_access, @_),
          '}',
      );
  }
  
  sub _inline_reader_core {
      my $self = shift;
      my ($inv, $slot_access, @extra) = @_;
  
      return (
          $self->_inline_check_argument_count,
          $self->_inline_process_arguments($inv, $slot_access),
          $self->_inline_check_arguments,
          $self->_inline_check_lazy($inv, '$type_constraint', '$type_coercion', '$type_message'),
          $self->_inline_return_value($slot_access),
      );
  }
  
  sub _inline_process_arguments { return }
  
  sub _inline_check_arguments { return }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_READER

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/String/append.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_APPEND';
  package Moose::Meta::Method::Accessor::Native::String::append;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '( ' . $slot_access . ' . $_[0] )';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' .= $_[0];';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_APPEND

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/String/chomp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CHOMP';
  package Moose::Meta::Method::Accessor::Native::String::chomp;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my $val = ' . $slot_access . '; '
               . '@return = chomp $val; '
               . '$val '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@return = chomp ' . $slot_access . ';';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$return[0]';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CHOMP

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/String/chop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CHOP';
  package Moose::Meta::Method::Accessor::Native::String::chop;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my $val = ' . $slot_access . '; '
               . '@return = chop $val; '
               . '$val; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@return = chop ' . $slot_access . ';';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$return[0]';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CHOP

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/String/clear.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CLEAR';
  package Moose::Meta::Method::Accessor::Native::String::clear;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value { '""' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = "";';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CLEAR

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/String/inc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_INC';
  package Moose::Meta::Method::Accessor::Native::String::inc;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my $val = ' . $slot_access . '; '
               . '$val++; '
               . '$val; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . '++;';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_INC

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/String/length.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_LENGTH';
  package Moose::Meta::Method::Accessor::Native::String::length;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'length ' . $slot_access;
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_LENGTH

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/String/match.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_MATCH';
  package Moose::Meta::Method::Accessor::Native::String::match;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Util ();
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Moose::Util::_STRINGLIKE0($_[0]) && !Params::Util::_REGEX($_[0])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[0],'.
                                              'type                    => "Str|RegexpRef",'.
                                              'type_of_argument        => "string or regexp reference",'.
                                              'method_name             => "match"',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' =~ $_[0]';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_MATCH

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/String/prepend.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_PREPEND';
  package Moose::Meta::Method::Accessor::Native::String::prepend;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$_[0] . ' . $slot_access;
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = $_[0] . ' . $slot_access . ';';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_PREPEND

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/String/replace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_REPLACE';
  package Moose::Meta::Method::Accessor::Native::String::replace;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Util ();
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 2 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Moose::Util::_STRINGLIKE0($_[0]) && !Params::Util::_REGEX($_[0])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[0],'.
                                              'method_name             => "replace",'.
                                              'ordinal                 => "first",'.
                                              'type_of_argument        => "string or regexp reference",'.
                                              'type                    => "Str|RegexpRef"',
              ) . ';',
          '}',
          'if (!Moose::Util::_STRINGLIKE0($_[1]) && !Params::Util::_CODELIKE($_[1])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[1],'.
                                              'method_name             => "replace",'.
                                              'ordinal                 => "second",'.
                                              'type_of_argument        => "string or code reference",'.
                                              'type                    => "Str|CodeRef"',
              ) . ';',
          '}',
      );
  }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my $val = ' . $slot_access . '; '
               . 'ref $_[1] '
                   . '? $val =~ s/$_[0]/$_[1]->()/e '
                   . ': $val =~ s/$_[0]/$_[1]/; '
               . '$val; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return (
          'ref $_[1]',
              '? ' . $slot_access . ' =~ s/$_[0]/$_[1]->()/e',
              ': ' . $slot_access . ' =~ s/$_[0]/$_[1]/;',
       );
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_REPLACE

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/String/substr.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_SUBSTR';
  package Moose::Meta::Method::Accessor::Native::String::substr;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader',
       'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _generate_method {
      my $self = shift;
  
      my $inv         = '$self';
      my $slot_access = $self->_get_value($inv);
  
      return (
          'sub {',
              'my ' . $inv . ' = shift;',
              $self->_inline_curried_arguments,
              'if (@_ == 1 || @_ == 2) {',
                  $self->_inline_reader_core($inv, $slot_access),
              '}',
              'elsif (@_ == 3) {',
                  $self->_inline_writer_core($inv, $slot_access),
              '}',
              'else {',
                  $self->_inline_check_argument_count,
              '}',
          '}',
      );
  }
  
  sub _minimum_arguments { 1 }
  sub _maximum_arguments { 3 }
  
  sub _inline_process_arguments {
      my $self = shift;
      my ($inv, $slot_access) = @_;
  
      return (
          'my $offset = shift;',
          'my $length = @_ ? shift : length ' . $slot_access . ';',
          'my $replacement = shift;',
      );
  }
  
  sub _inline_check_arguments {
      my $self = shift;
      my ($for_writer) = @_;
  
      my @code = (
          'if ($offset !~ /^-?\d+$/) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $offset,'.
                                              'ordinal                 => "first",'.
                                              'type_of_argument        => "integer",'.
                                              'method_name             => "substr",'.
                                              'type                    => "Int"',
              ) . ';',
          '}',
          'if ($length !~ /^-?\d+$/) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $length,'.
                                              'ordinal                 => "second",'.
                                              'type_of_argument        => "integer",'.
                                              'method_name             => "substr",'.
                                              'type                    => "Int"',
              ) . ';',
          '}',
      );
  
      if ($for_writer) {
          push @code, (
              'if (!Moose::Util::_STRINGLIKE0($replacement)) {',
                  $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                                  'argument                => $replacement,'.
                                                  'ordinal                 => "third",'.
                                                  'type_of_argument        => "string",'.
                                                  'method_name             => "substr",'.
                                                  'type                    => "Str"',
                  ) . ';',
              '}',
          );
      }
  
      return @code;
  }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my $potential = ' . $slot_access . '; '
               . '@return = substr $potential, $offset, $length, $replacement; '
               . '$potential; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@return = substr ' . $slot_access . ', '
                             . '$offset, $length, $replacement;';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access, $for_writer) = @_;
  
      return '$return[0]' if $for_writer;
  
      return 'substr ' . $slot_access . ', $offset, $length';
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_SUBSTR

$fatpacked{"darwin-2level/Moose/Meta/Method/Accessor/Native/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_WRITER';
  package Moose::Meta::Method::Accessor::Native::Writer;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use List::Util 1.33 qw( any );
  use Moose::Util;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native';
  
  requires '_potential_value';
  
  sub _generate_method {
      my $self = shift;
  
      my $inv         = '$self';
      my $slot_access = $self->_get_value($inv);
  
      return (
          'sub {',
              'my ' . $inv . ' = shift;',
              $self->_inline_curried_arguments,
              $self->_inline_writer_core($inv, $slot_access),
          '}',
      );
  }
  
  sub _inline_writer_core {
      my $self = shift;
      my ($inv, $slot_access) = @_;
  
      my $potential = $self->_potential_value($slot_access);
      my $old       = '@old';
  
      my @code;
      push @code, (
          $self->_inline_check_argument_count,
          $self->_inline_process_arguments($inv, $slot_access),
          $self->_inline_check_arguments('for writer'),
          $self->_inline_check_lazy($inv, '$type_constraint', '$type_coercion', '$type_message'),
      );
  
      if ($self->_return_value($slot_access)) {
          # some writers will save the return value in this variable when they
          # generate the potential value.
          push @code, 'my @return;'
      }
  
      push @code, (
          $self->_inline_coerce_new_values,
          $self->_inline_copy_native_value(\$potential),
          $self->_inline_tc_code($potential, '$type_constraint', '$type_coercion', '$type_message'),
          $self->_inline_get_old_value_for_trigger($inv, $old),
          $self->_inline_capture_return_value($slot_access),
          $self->_inline_set_new_value($inv, $potential, $slot_access),
          $self->_inline_trigger($inv, $slot_access, $old),
          $self->_inline_return_value($slot_access, 'for writer'),
      );
  
      return @code;
  }
  
  sub _inline_process_arguments { return }
  
  sub _inline_check_arguments { return }
  
  sub _inline_coerce_new_values { return }
  
  sub _writer_value_needs_copy {
      my $self = shift;
  
      return $self->_constraint_must_be_checked;
  }
  
  sub _constraint_must_be_checked {
      my $self = shift;
  
      my $attr = $self->associated_attribute;
  
      return $attr->has_type_constraint
          && ( !$self->_is_root_type( $attr->type_constraint )
          || ( $attr->should_coerce && $attr->type_constraint->has_coercion ) );
  }
  
  sub _is_root_type {
      my $self = shift;
      my $type = shift;
  
      if (   blessed($type)
          && $type->can('does')
          && $type->does('Specio::Constraint::Role::Interface') )
      {
          require Specio::Library::Builtins;
          return
              any { $type->is_same_type_as( Specio::Library::Builtins::t($_) ) }
          @{ $self->root_types };
      }
      else {
          my $name = $type->name;
          return any { $name eq $_ } @{ $self->root_types };
      }
  }
  
  sub _inline_copy_native_value {
      my $self = shift;
      my ($potential_ref) = @_;
  
      return unless $self->_writer_value_needs_copy;
  
      my $code = 'my $potential = ' . ${$potential_ref} . ';';
  
      ${$potential_ref} = '$potential';
  
      return $code;
  }
  
  around _inline_tc_code => sub {
      my $orig = shift;
      my $self = shift;
      my ($value, $tc, $coercion, $message, $for_lazy) = @_;
  
      return unless $for_lazy || $self->_constraint_must_be_checked;
  
      return $self->$orig(@_);
  };
  
  around _inline_check_constraint => sub {
      my $orig = shift;
      my $self = shift;
      my ($value, $tc, $message, $for_lazy) = @_;
  
      return unless $for_lazy || $self->_constraint_must_be_checked;
  
      return $self->$orig(@_);
  };
  
  sub _inline_capture_return_value { return }
  
  sub _inline_set_new_value {
      my $self = shift;
  
      return $self->_inline_store_value(@_)
          if $self->_writer_value_needs_copy
          || !$self->_slot_access_can_be_inlined
          || !$self->_get_is_lvalue;
  
      return $self->_inline_optimized_set_new_value(@_);
  }
  
  sub _get_is_lvalue {
      my $self = shift;
  
      return $self->associated_attribute->associated_class->instance_metaclass->inline_get_is_lvalue;
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
  
      return $self->_inline_store_value(@_);
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access;
  }
  
  no Moose::Role;
  
  1;
DARWIN-2LEVEL_MOOSE_META_METHOD_ACCESSOR_NATIVE_WRITER

$fatpacked{"darwin-2level/Moose/Meta/Method/Augmented.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_AUGMENTED';
  package Moose::Meta::Method::Augmented;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use parent 'Moose::Meta::Method';
  
  use Moose::Util 'throw_exception';
  
  sub new {
      my ( $class, %args ) = @_;
  
      # the package can be overridden by roles
      # it is really more like body's compilation stash
      # this is where we need to override the definition of super() so that the
      # body of the code can call the right overridden version
      my $name = $args{name};
      my $meta = $args{class};
  
      my $super = $meta->find_next_method_by_name($name);
  
      (defined $super)
          || throw_exception( CannotAugmentNoSuperMethod => params      => \%args,
                                                            class       => $class,
                                                            method_name => $name
                            );
  
      my $_super_package = $super->package_name;
      # BUT!,... if this is an overridden method ....
      if ($super->isa('Moose::Meta::Method::Overridden')) {
          # we need to be sure that we actually
          # find the next method, which is not
          # an 'override' method, the reason is
          # that an 'override' method will not
          # be the one calling inner()
          my $real_super = $meta->_find_next_method_by_name_which_is_not_overridden($name);
          $_super_package = $real_super->package_name;
      }
  
      my $super_body = $super->body;
  
      my $method = $args{method};
  
      my $body = sub {
          local $Moose::INNER_ARGS{$_super_package} = [ @_ ];
          local $Moose::INNER_BODY{$_super_package} = $method;
          $super_body->(@_);
      };
  
      # FIXME store additional attrs
      $class->wrap(
          $body,
          package_name => $meta->name,
          name         => $name
      );
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for augmented methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method::Augmented - A Moose Method metaclass for augmented methods
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class implements method augmentation logic for the L<Moose>
  C<augment> keyword.
  
  The augmentation subroutine reference will be invoked explicitly using
  the C<inner> keyword from the parent class's method definition.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Method::Augmented> is a subclass of L<Moose::Meta::Method>.
  
  =head1 METHODS
  
  =head2 Moose::Meta::Method::Augmented->new(%options)
  
  This constructs a new object. It accepts the following options:
  
  =over 4
  
  =item * class
  
  The metaclass object for the class in which the augmentation is being
  declared. This option is required.
  
  =item * name
  
  The name of the method which we are augmenting. This method must exist
  in one of the class's superclasses. This option is required.
  
  =item * method
  
  The subroutine reference which implements the augmentation. This
  option is required.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_METHOD_AUGMENTED

$fatpacked{"darwin-2level/Moose/Meta/Method/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_CONSTRUCTOR';
  package Moose::Meta::Method::Constructor;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'weaken';
  
  use parent 'Moose::Meta::Method',
           'Class::MOP::Method::Constructor';
  
  use Moose::Util 'throw_exception';
  
  sub new {
      my $class   = shift;
      my %options = @_;
  
      my $meta = $options{metaclass};
  
      (ref $options{options} eq 'HASH')
          || throw_exception( MustPassAHashOfOptions => params => \%options,
                                                        class  => $class
                            );
  
      ($options{package_name} && $options{name})
          || throw_exception( MustSupplyPackageNameAndName => params => \%options,
                                                              class  => $class
                            );
  
      my $self = bless {
          'body'          => undef,
          'package_name'  => $options{package_name},
          'name'          => $options{name},
          'options'       => $options{options},
          'associated_metaclass' => $meta,
          'definition_context' => $options{definition_context},
          '_expected_method_class' => $options{_expected_method_class} || 'Moose::Object',
      } => $class;
  
      # we don't want this creating
      # a cycle in the code, if not
      # needed
      weaken($self->{'associated_metaclass'});
  
      $self->_initialize_body;
  
      return $self;
  }
  
  ## method
  
  sub _initialize_body {
      my $self = shift;
      $self->{'body'} = $self->_generate_constructor_method_inline;
  }
  
  1;
  
  # ABSTRACT: Method Meta Object for constructors
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method::Constructor - Method Meta Object for constructors
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Method::Constructor> that
  provides additional Moose-specific functionality
  
  To understand this class, you should read the
  L<Class::MOP::Method::Constructor> documentation as well.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Method::Constructor> is a subclass of
  L<Moose::Meta::Method> I<and> L<Class::MOP::Method::Constructor>.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_METHOD_CONSTRUCTOR

$fatpacked{"darwin-2level/Moose/Meta/Method/Delegation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_DELEGATION';
  package Moose::Meta::Method::Delegation;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed', 'weaken';
  use Try::Tiny;
  
  use parent 'Moose::Meta::Method',
           'Class::MOP::Method::Generated';
  
  use Moose::Util 'throw_exception';
  
  sub new {
      my $class   = shift;
      my %options = @_;
  
      ( exists $options{attribute} )
          || throw_exception( MustSupplyAnAttributeToConstructWith => params => \%options,
                                                                      class  => $class
                            );
  
      ( blessed( $options{attribute} )
              && $options{attribute}->isa('Moose::Meta::Attribute') )
          || throw_exception( MustSupplyAMooseMetaAttributeInstance => params => \%options,
                                                                       class  => $class
                            );
  
      ( $options{package_name} && $options{name} )
          || throw_exception( MustSupplyPackageNameAndName => params => \%options,
                                                              class  => $class
                            );
  
      ( $options{delegate_to_method} && ( !ref $options{delegate_to_method} )
              || ( 'CODE' eq ref $options{delegate_to_method} ) )
          || throw_exception( MustSupplyADelegateToMethod => params => \%options,
                                                             class  => $class
                            );
  
      exists $options{curried_arguments}
          || ( $options{curried_arguments} = [] );
  
      ( $options{curried_arguments} &&
          ( 'ARRAY' eq ref $options{curried_arguments} ) )
          || throw_exception( MustSupplyArrayRefAsCurriedArguments => params     => \%options,
                                                                      class_name => $class
                            );
  
      my $self = $class->_new( \%options );
  
      weaken( $self->{'attribute'} );
  
      $self->_initialize_body;
  
      return $self;
  }
  
  sub _new {
      my $class = shift;
      my $options = @_ == 1 ? $_[0] : {@_};
  
      return bless $options, $class;
  }
  
  sub curried_arguments { (shift)->{'curried_arguments'} }
  
  sub associated_attribute { (shift)->{'attribute'} }
  
  sub delegate_to_method { (shift)->{'delegate_to_method'} }
  
  sub _initialize_body {
      my $self = shift;
  
      my $method_to_call = $self->delegate_to_method;
      return $self->{body} = $method_to_call
          if ref $method_to_call;
  
      # We don't inline because it's faster, we do it because when the method is
      # inlined, any errors thrown because of the delegated method have a _much_
      # nicer stack trace, as the trace doesn't include any Moose internals.
      $self->{body} = $self->_generate_inline_method;
  
      return;
  }
  
  sub _generate_inline_method {
      my $self = shift;
  
      my $attr = $self->associated_attribute;
      my $delegate = $self->delegate_to_method;
  
      my $method_name = B::perlstring( $self->name );
      my $attr_name   = B::perlstring( $self->associated_attribute->name );
  
      my $undefined_attr_throw = $self->_inline_throw_exception(
          'AttributeValueIsNotDefined',
          sprintf( <<'EOF', $method_name, $attr_name ) );
  method    => $self->meta->find_method_by_name(%s),
  instance  => $self,
  attribute => $self->meta->find_attribute_by_name(%s),
  EOF
  
      my $not_an_object_throw = $self->_inline_throw_exception(
          'AttributeValueIsNotAnObject',
          sprintf( <<'EOF', $method_name, $attr_name ) );
  method      => $self->meta->find_method_by_name(%s),
  instance    => $self,
  attribute   => $self->meta->find_attribute_by_name(%s),
  given_value => $proxy,
  EOF
  
      my $get_proxy
          = $attr->has_read_method ? $attr->get_read_method : '$reader';
  
      my $args = @{ $self->curried_arguments } ? '@curried, @_' : '@_';
      my $source = sprintf(
          <<'EOF', $get_proxy, $undefined_attr_throw, $not_an_object_throw, $delegate, $args );
  sub {
      my $self = shift;
  
      my $proxy = $self->%s;
      if ( !defined $proxy ) {
          %s;
      }
      elsif ( ref $proxy && !Scalar::Util::blessed($proxy) ) {
          %s;
      }
      return $proxy->%s( %s );
  }
  EOF
  
      my $description
          = 'inline delegation in '
          . $self->package_name . ' for '
          . $attr->name . '->'
          . $delegate;
  
      my $definition = $attr->definition_context;
      # While all attributes created in the usual way (via Moose's has()) will
      # define this, there's no guarantee that this must be defined. For
      # example, when Moo inflates a class to Moose it does not define these (as
      # of Moo 2.003).
      $description .= " (attribute declared in $definition->{file} at line $definition->{line})"
          if defined $definition->{file} && defined $definition->{line};
  
      return try {
          $self->_compile_code(
              source      => $source,
              description => $description,
          );
      }
      catch {
          $self->_throw_exception(
              'CouldNotGenerateInlineAttributeMethod',
              instance => $self,
              error    => $_,
              option   => 'handles for ' . $attr->name . '->' . $delegate,
          );
      };
  }
  
  sub _eval_environment {
      my $self = shift;
  
      my %env;
      if ( @{ $self->curried_arguments } ) {
          $env{'@curried'} = $self->curried_arguments;
      }
  
      unless ( $self->associated_attribute->has_read_method ) {
          $env{'$reader'} = \( $self->_get_delegate_accessor );
      }
  
      return \%env;
  }
  
  sub _get_delegate_accessor {
      my $self = shift;
  
      my $accessor = $self->associated_attribute->get_read_method_ref;
  
      # If it's blessed it's a Moose::Meta::Method
      return blessed $accessor
          ? ( $accessor->body )
          : $accessor;
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for delegation methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method::Delegation - A Moose Method metaclass for delegation methods
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This is a subclass of L<Moose::Meta::Method> for delegation
  methods.
  
  =head1 METHODS
  
  =head2 Moose::Meta::Method::Delegation->new(%options)
  
  This creates the delegation methods based on the provided C<%options>.
  
  =over 4
  
  =item I<attribute>
  
  This must be an instance of C<Moose::Meta::Attribute> which this
  accessor is being generated for. This options is B<required>.
  
  =item I<delegate_to_method>
  
  The method in the associated attribute's value to which we
  delegate. This can be either a method name or a code reference.
  
  =item I<curried_arguments>
  
  An array reference of arguments that will be prepended to the argument list for
  any call to the delegating method.
  
  =back
  
  =head2 $metamethod->associated_attribute
  
  Returns the attribute associated with this method.
  
  =head2 $metamethod->curried_arguments
  
  Return any curried arguments that will be passed to the delegated method.
  
  =head2 $metamethod->delegate_to_method
  
  Returns the method to which this method delegates, as passed to the
  constructor.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_METHOD_DELEGATION

$fatpacked{"darwin-2level/Moose/Meta/Method/Destructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_DESTRUCTOR';
  package Moose::Meta::Method::Destructor;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Devel::GlobalDestruction ();
  use Scalar::Util 'blessed', 'weaken';
  use Try::Tiny;
  
  use parent 'Moose::Meta::Method',
           'Class::MOP::Method::Inlined';
  
  use Moose::Util 'throw_exception';
  
  sub new {
      my $class   = shift;
      my %options = @_;
  
      (ref $options{options} eq 'HASH')
          || throw_exception( MustPassAHashOfOptions => params => \%options,
                                                        class  => $class
                            );
  
      ($options{package_name} && $options{name})
          || throw_exception( MustSupplyPackageNameAndName => params => \%options,
                                                              class  => $class
                            );
  
      my $self = bless {
          # from our superclass
          'body'                 => undef,
          'package_name'         => $options{package_name},
          'name'                 => $options{name},
          # ...
          'options'              => $options{options},
          'definition_context'   => $options{definition_context},
          'associated_metaclass' => $options{metaclass},
      } => $class;
  
      # we don't want this creating
      # a cycle in the code, if not
      # needed
      weaken($self->{'associated_metaclass'});
  
      $self->_initialize_body;
  
      return $self;
  }
  
  ## accessors
  
  sub options              { (shift)->{'options'}              }
  
  ## method
  
  sub is_needed {
      my $self      = shift;
      my $metaclass = shift;
  
      ( blessed $metaclass && $metaclass->isa('Class::MOP::Class') )
          || throw_exception( MethodExpectedAMetaclassObject => metaclass => $metaclass,
                                                                class     => $self
                            );
  
      return $metaclass->find_method_by_name("DEMOLISHALL");
  }
  
  sub _initialize_body {
      my $self = shift;
      # TODO:
      # the %options should also include a both
      # a call 'initializer' and call 'SUPER::'
      # options, which should cover approx 90%
      # of the possible use cases (even if it
      # requires some adaption on the part of
      # the author, after all, nothing is free)
  
      my $class = $self->associated_metaclass->name;
      my @source = (
          'sub {',
              'my $self = shift;',
              'return ' . $self->_generate_fallback_destructor('$self'),
                  'if Scalar::Util::blessed($self) ne \'' . $class . '\';',
              $self->_generate_DEMOLISHALL('$self'),
              'return;',
          '}',
      );
      warn join("\n", @source) if $self->options->{debug};
  
      my $code = try {
          $self->_compile_code(source => \@source);
      }
      catch {
          my $source = join("\n", @source);
          throw_exception( CouldNotEvalDestructor => method_destructor_object => $self,
                                                     source                   => $source,
                                                     error                    => $_
                         );
      };
  
      $self->{'body'} = $code;
  }
  
  sub _generate_fallback_destructor {
      my $self = shift;
      my ($inv) = @_;
  
      return $inv . '->Moose::Object::DESTROY(@_)';
  }
  
  sub _generate_DEMOLISHALL {
      my $self = shift;
      my ($inv) = @_;
  
      my @methods = $self->associated_metaclass->find_all_methods_by_name('DEMOLISH');
      return unless @methods;
  
      return (
          'local $?;',
          'my $igd = Devel::GlobalDestruction::in_global_destruction;',
          'Try::Tiny::try {',
              (map { $inv . '->' . $_->{class} . '::DEMOLISH($igd);' } @methods),
          '}',
          'Try::Tiny::catch {',
              'die $_;',
          '};',
      );
  }
  
  
  1;
  
  # ABSTRACT: Method Meta Object for destructors
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method::Destructor - Method Meta Object for destructors
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Method::Inlined> that
  provides Moose-specific functionality for inlining destructors.
  
  To understand this class, you should read the
  L<Class::MOP::Method::Inlined> documentation as well.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Method::Destructor> is a subclass of
  L<Moose::Meta::Method> I<and> L<Class::MOP::Method::Inlined>.
  
  =head1 METHODS
  
  =head2 Moose::Meta::Method::Destructor->new(%options)
  
  This constructs a new object. It accepts the following options:
  
  =over 4
  
  =item * package_name
  
  The package for the class in which the destructor is being
  inlined. This option is required.
  
  =item * name
  
  The name of the destructor method. This option is required.
  
  =item * metaclass
  
  The metaclass for the class this destructor belongs to. This is
  optional, as it can be set later by calling C<<
  $metamethod->attach_to_class >>.
  
  =back
  
  =head2 Moose::Meta;:Method::Destructor->is_needed($metaclass)
  
  Given a L<Moose::Meta::Class> object, this method returns a boolean
  indicating whether the class needs a destructor. If the class or any
  of its parents defines a C<DEMOLISH> method, it needs a destructor.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_METHOD_DESTRUCTOR

$fatpacked{"darwin-2level/Moose/Meta/Method/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_META';
  package Moose::Meta::Method::Meta;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use parent 'Moose::Meta::Method',
           'Class::MOP::Method::Meta';
  
  sub _is_caller_mop_internal {
      my $self = shift;
      my ($caller) = @_;
      return 1 if $caller =~ /^Moose(?:::|$)/;
      return $self->SUPER::_is_caller_mop_internal($caller);
  }
  
  # XXX: ugh multiple inheritance
  sub wrap {
      my $class = shift;
      return $class->Class::MOP::Method::Meta::wrap(@_);
  }
  
  sub _make_compatible_with {
      my $self = shift;
      return $self->Class::MOP::Method::Meta::_make_compatible_with(@_);
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for C<meta> methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method::Meta - A Moose Method metaclass for C<meta> methods
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Method::Meta> that
  provides additional Moose-specific functionality, all of which is
  private.
  
  To understand this class, you should read the
  L<Class::MOP::Method::Meta> documentation.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_METHOD_META

$fatpacked{"darwin-2level/Moose/Meta/Method/Overridden.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_METHOD_OVERRIDDEN';
  package Moose::Meta::Method::Overridden;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use parent 'Moose::Meta::Method';
  
  use Moose::Util 'throw_exception';
  
  sub new {
      my ( $class, %args ) = @_;
  
      # the package can be overridden by roles
      # it is really more like body's compilation stash
      # this is where we need to override the definition of super() so that the
      # body of the code can call the right overridden version
      my $super_package = $args{package} || $args{class}->name;
  
      my $name = $args{name};
  
      my $super = $args{class}->find_next_method_by_name($name);
  
      (defined $super)
          || throw_exception( CannotOverrideNoSuperMethod => class       => $class,
                                                             params      => \%args,
                                                             method_name => $name
                            );
  
      my $super_body = $super->body;
  
      my $method = $args{method};
  
      my $body = sub {
          local $Moose::SUPER_PACKAGE = $super_package;
          local @Moose::SUPER_ARGS = @_;
          local $Moose::SUPER_BODY = $super_body;
          return $method->(@_);
      };
  
      # FIXME do we need this make sure this works for next::method?
      # subname "${super_package}::${name}", $method;
  
      # FIXME store additional attrs
      $class->wrap(
          $body,
          package_name => $args{class}->name,
          name         => $name
      );
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for overridden methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method::Overridden - A Moose Method metaclass for overridden methods
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class implements method overriding logic for the L<Moose>
  C<override> keyword.
  
  The overriding subroutine's parent will be invoked explicitly using
  the C<super> keyword from the parent class's method definition.
  
  =head1 METHODS
  
  =head2 Moose::Meta::Method::Overridden->new(%options)
  
  This constructs a new object. It accepts the following options:
  
  =over 4
  
  =item * class
  
  The metaclass object for the class in which the override is being
  declared. This option is required.
  
  =item * name
  
  The name of the method which we are overriding. This method must exist
  in one of the class's superclasses. This option is required.
  
  =item * method
  
  The subroutine reference which implements the overriding. This option
  is required.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_METHOD_OVERRIDDEN

$fatpacked{"darwin-2level/Moose/Meta/Mixin/AttributeCore.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_MIXIN_ATTRIBUTECORE';
  package Moose::Meta::Mixin::AttributeCore;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use parent 'Class::MOP::Mixin::AttributeCore';
  
  __PACKAGE__->meta->add_attribute(
      'isa' => (
          reader => '_isa_metadata',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'does' => (
          reader => '_does_metadata',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'is' => (
          reader => '_is_metadata',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'required' => (
          reader => 'is_required',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'lazy' => (
          reader => 'is_lazy',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'lazy_build' => (
          reader => 'is_lazy_build',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'coerce' => (
          reader => 'should_coerce',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'weak_ref' => (
          reader => 'is_weak_ref',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'auto_deref' => (
          reader => 'should_auto_deref',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'type_constraint' => (
          reader    => 'type_constraint',
          predicate => 'has_type_constraint',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'trigger' => (
          reader    => 'trigger',
          predicate => 'has_trigger',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'handles' => (
          reader    => 'handles',
          writer    => '_set_handles',
          predicate => 'has_handles',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'documentation' => (
          reader    => 'documentation',
          predicate => 'has_documentation',
          Class::MOP::_definition_context(),
      )
  );
  
  1;
  
  # ABSTRACT: Core attributes shared by attribute metaclasses
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Mixin::AttributeCore - Core attributes shared by attribute metaclasses
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class implements the core attributes (aka properties) shared by all Moose
  attributes. See the L<Moose::Meta::Attribute> documentation for API details.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_MIXIN_ATTRIBUTECORE

$fatpacked{"darwin-2level/Moose/Meta/Object/Trait.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_OBJECT_TRAIT';
  package Moose::Meta::Object::Trait;
  our $VERSION = '2.2011';
  
  use Scalar::Util qw(blessed);
  
  sub _get_compatible_metaclass {
      my $orig = shift;
      my $self = shift;
      return $self->$orig(@_)
          || $self->_get_compatible_metaclass_by_role_reconciliation(@_);
  }
  
  sub _get_compatible_metaclass_by_role_reconciliation {
      my $self = shift;
      my ($other_name) = @_;
      my $meta_name = blessed($self) ? $self->_real_ref_name : $self;
  
      return unless Moose::Util::_classes_differ_by_roles_only(
          $meta_name, $other_name
      );
  
      return Moose::Util::_reconcile_roles_for_metaclass(
          $meta_name, $other_name
      );
  }
  
  1;
  
  # ABSTRACT: Some overrides for L<Class::MOP::Object> functionality
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Object::Trait - Some overrides for L<Class::MOP::Object> functionality
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This module is entirely private, you shouldn't ever need to interact with
  it directly.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_OBJECT_TRAIT

$fatpacked{"darwin-2level/Moose/Meta/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_ROLE';
  package Moose::Meta::Role;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  
  use Moose::Meta::Class;
  use Moose::Meta::Role::Attribute;
  use Moose::Meta::Role::Method;
  use Moose::Meta::Role::Method::Required;
  use Moose::Meta::Role::Method::Conflicting;
  use Moose::Meta::Method::Meta;
  use Moose::Util qw/throw_exception/;
  use Class::MOP::MiniTrait;
  
  use parent 'Class::MOP::Module',
           'Class::MOP::Mixin::HasAttributes',
           'Class::MOP::Mixin::HasMethods',
           'Class::MOP::Mixin::HasOverloads';
  
  Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
  
  ## ------------------------------------------------------------------
  ## NOTE:
  ## I normally don't do this, but I am doing
  ## a whole bunch of meta-programmin' in this
  ## module, so it just makes sense. For a clearer
  ## picture of what is going on in the next
  ## several lines of code, look at the really
  ## big comment at the end of this file (right
  ## before the POD).
  ## - SL
  ## ------------------------------------------------------------------
  
  my $META = __PACKAGE__->meta;
  
  ## ------------------------------------------------------------------
  ## attributes ...
  
  # NOTE:
  # since roles are lazy, we hold all the attributes
  # of the individual role in 'stasis' until which
  # time when it is applied to a class. This means
  # keeping a lot of things in hash maps, so we are
  # using a little of that meta-programmin' magic
  # here and saving lots of extra typin'. And since
  # many of these attributes above require similar
  # functionality to support them, so we again use
  # the wonders of meta-programmin' to deliver a
  # very compact solution to this normally verbose
  # problem.
  # - SL
  
  foreach my $action (
      {
          name        => 'excluded_roles_map',
          attr_reader => 'get_excluded_roles_map' ,
          methods     => {
              add       => 'add_excluded_roles',
              get_keys  => 'get_excluded_roles_list',
              existence => 'excludes_role',
          }
      },
      {
          name        => 'required_methods',
          attr_reader => 'get_required_methods_map',
          methods     => {
              remove     => 'remove_required_methods',
              get_values => 'get_required_method_list',
              existence  => 'requires_method',
          }
      },
  ) {
  
      my $attr_reader = $action->{attr_reader};
      my $methods     = $action->{methods};
  
      # create the attribute
      $META->add_attribute($action->{name} => (
          reader  => $attr_reader,
          default => sub { {} },
          Class::MOP::_definition_context(),
      ));
  
      # create some helper methods
      $META->add_method($methods->{add} => sub {
          my ($self, @values) = @_;
          $self->$attr_reader->{$_} = undef foreach @values;
      }) if exists $methods->{add};
  
      $META->add_method($methods->{get_keys} => sub {
          my ($self) = @_;
          keys %{$self->$attr_reader};
      }) if exists $methods->{get_keys};
  
      $META->add_method($methods->{get_values} => sub {
          my ($self) = @_;
          values %{$self->$attr_reader};
      }) if exists $methods->{get_values};
  
      $META->add_method($methods->{get} => sub {
          my ($self, $name) = @_;
          $self->$attr_reader->{$name}
      }) if exists $methods->{get};
  
      $META->add_method($methods->{existence} => sub {
          my ($self, $name) = @_;
          exists $self->$attr_reader->{$name} ? 1 : 0;
      }) if exists $methods->{existence};
  
      $META->add_method($methods->{remove} => sub {
          my ($self, @values) = @_;
          delete $self->$attr_reader->{$_} foreach @values;
      }) if exists $methods->{remove};
  }
  
  $META->add_attribute(
      'method_metaclass',
      reader  => 'method_metaclass',
      default => 'Moose::Meta::Role::Method',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'required_method_metaclass',
      reader  => 'required_method_metaclass',
      default => 'Moose::Meta::Role::Method::Required',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'conflicting_method_metaclass',
      reader  => 'conflicting_method_metaclass',
      default => 'Moose::Meta::Role::Method::Conflicting',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'application_to_class_class',
      reader  => 'application_to_class_class',
      default => 'Moose::Meta::Role::Application::ToClass',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'application_to_role_class',
      reader  => 'application_to_role_class',
      default => 'Moose::Meta::Role::Application::ToRole',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'application_to_instance_class',
      reader  => 'application_to_instance_class',
      default => 'Moose::Meta::Role::Application::ToInstance',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'applied_attribute_metaclass',
      reader  => 'applied_attribute_metaclass',
      default => 'Moose::Meta::Attribute',
      Class::MOP::_definition_context(),
  );
  
  # More or less copied from Moose::Meta::Class
  sub initialize {
      my $class = shift;
      my @args = @_;
      unshift @args, 'package' if @args % 2;
      my %opts = @args;
      my $package = delete $opts{package};
      return Class::MOP::get_metaclass_by_name($package)
          || $class->SUPER::initialize($package,
                  'attribute_metaclass' => 'Moose::Meta::Role::Attribute',
                  %opts,
              );
  }
  
  sub reinitialize {
      my $self = shift;
      my $pkg  = shift;
  
      my $meta = blessed $pkg ? $pkg : Class::MOP::class_of($pkg);
  
      my %existing_classes;
      if ($meta) {
          %existing_classes = map { $_ => $meta->$_() } qw(
              attribute_metaclass
              method_metaclass
              wrapped_method_metaclass
              required_method_metaclass
              conflicting_method_metaclass
              application_to_class_class
              application_to_role_class
              application_to_instance_class
              applied_attribute_metaclass
          );
      }
  
      my %options = @_;
      $options{weaken} = Class::MOP::metaclass_is_weak($meta->name)
          if !exists $options{weaken}
          && blessed($meta)
          && $meta->isa('Moose::Meta::Role');
  
      # don't need to remove generated metaobjects here yet, since we don't
      # yet generate anything in roles. this may change in the future though...
      # keep an eye on that
      my $new_meta = $self->SUPER::reinitialize(
          $pkg,
          %existing_classes,
          %options,
      );
      $new_meta->_restore_metaobjects_from($meta)
          if $meta && $meta->isa('Moose::Meta::Role');
      return $new_meta;
  }
  
  sub _restore_metaobjects_from {
      my $self = shift;
      my ($old_meta) = @_;
  
      $self->_restore_metamethods_from($old_meta);
      $self->_restore_metaattributes_from($old_meta);
  
      for my $role ( @{ $old_meta->get_roles } ) {
          $self->add_role($role);
      }
  }
  
  sub add_attribute {
      my $self = shift;
  
      if (blessed $_[0] && ! $_[0]->isa('Moose::Meta::Role::Attribute') ) {
          my $class = ref $_[0];
          throw_exception( CannotAddAsAnAttributeToARole => role_name       => $self->name,
                                                            attribute_class => $class,
                         );
      }
      elsif (!blessed($_[0]) && defined($_[0]) && $_[0] =~ /^\+(.*)/) {
          throw_exception( AttributeExtensionIsNotSupportedInRoles => attribute_name => $_[0],
                                                                      role_name      => $self->name,
                         );
      }
  
      return $self->SUPER::add_attribute(@_);
  }
  
  sub _attach_attribute {
      my ( $self, $attribute ) = @_;
  
      $attribute->attach_to_role($self);
  }
  
  sub add_required_methods {
      my $self = shift;
  
      for (@_) {
          my $method = $_;
          if (!blessed($method)) {
              $method = $self->required_method_metaclass->new(
                  name => $method,
              );
          }
          $self->get_required_methods_map->{$method->name} = $method;
      }
  }
  
  sub add_conflicting_method {
      my $self = shift;
  
      my $method;
      if (@_ == 1 && blessed($_[0])) {
          $method = shift;
      }
      else {
          $method = $self->conflicting_method_metaclass->new(@_);
      }
  
      $self->add_required_methods($method);
  }
  
  ## ------------------------------------------------------------------
  ## method modifiers
  
  # NOTE:
  # the before/around/after method modifiers are
  # stored by name, but there can be many methods
  # then associated with that name. So again we have
  # lots of similar functionality, so we can do some
  # meta-programmin' and save some time.
  # - SL
  
  foreach my $modifier_type (qw[ before around after ]) {
  
      my $attr_reader = "get_${modifier_type}_method_modifiers_map";
  
      # create the attribute ...
      $META->add_attribute("${modifier_type}_method_modifiers" => (
          reader  => $attr_reader,
          default => sub { {} },
          Class::MOP::_definition_context(),
      ));
  
      # and some helper methods ...
      $META->add_method("get_${modifier_type}_method_modifiers" => sub {
          my ($self, $method_name) = @_;
          #return () unless exists $self->$attr_reader->{$method_name};
          my $mm = $self->$attr_reader->{$method_name};
          $mm ? @$mm : ();
      });
  
      $META->add_method("has_${modifier_type}_method_modifiers" => sub {
          my ($self, $method_name) = @_;
          # NOTE:
          # for now we assume that if it exists,..
          # it has at least one modifier in it
          (exists $self->$attr_reader->{$method_name}) ? 1 : 0;
      });
  
      $META->add_method("add_${modifier_type}_method_modifier" => sub {
          my ($self, $method_name, $method) = @_;
  
          $self->$attr_reader->{$method_name} = []
              unless exists $self->$attr_reader->{$method_name};
  
          my $modifiers = $self->$attr_reader->{$method_name};
  
          # NOTE:
          # check to see that we aren't adding the
          # same code twice. We err in favor of the
          # first on here, this may not be as expected
          foreach my $modifier (@{$modifiers}) {
              return if $modifier == $method;
          }
  
          push @{$modifiers} => $method;
      });
  
  }
  
  ## ------------------------------------------------------------------
  ## override method modifiers
  
  $META->add_attribute('override_method_modifiers' => (
      reader  => 'get_override_method_modifiers_map',
      default => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  # NOTE:
  # these are a little different because there
  # can only be one per name, whereas the other
  # method modifiers can have multiples.
  # - SL
  
  sub add_override_method_modifier {
      my ($self, $method_name, $method) = @_;
      (!$self->has_method($method_name))
          || throw_exception( CannotOverrideALocalMethod => method_name => $method_name,
                                                            role_name   => $self->name,
                            );
      $self->get_override_method_modifiers_map->{$method_name} = $method;
  }
  
  sub has_override_method_modifier {
      my ($self, $method_name) = @_;
      # NOTE:
      # for now we assume that if it exists,..
      # it has at least one modifier in it
      (exists $self->get_override_method_modifiers_map->{$method_name}) ? 1 : 0;
  }
  
  sub get_override_method_modifier {
      my ($self, $method_name) = @_;
      $self->get_override_method_modifiers_map->{$method_name};
  }
  
  ## general list accessor ...
  
  sub get_method_modifier_list {
      my ($self, $modifier_type) = @_;
      my $accessor = "get_${modifier_type}_method_modifiers_map";
      keys %{$self->$accessor};
  }
  
  sub _meta_method_class { 'Moose::Meta::Method::Meta' }
  
  ## ------------------------------------------------------------------
  ## subroles
  
  $META->add_attribute('roles' => (
      reader  => 'get_roles',
      default => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  sub add_role {
      my ($self, $role) = @_;
      (blessed($role) && $role->isa('Moose::Meta::Role'))
          || throw_exception( AddRoleToARoleTakesAMooseMetaRole => role_to_be_added => $role,
                                                                   role_name        => $self->name,
                            );
      push @{$self->get_roles} => $role;
      $self->reset_package_cache_flag;
  }
  
  sub calculate_all_roles {
      my $self = shift;
      my %seen;
      grep {
          !$seen{$_->name}++
      } ($self, map {
                    $_->calculate_all_roles
                } @{ $self->get_roles });
  }
  
  sub does_role {
      my ($self, $role) = @_;
      (defined $role)
          || throw_exception( RoleNameRequiredForMooseMetaRole => role_name => $self->name );
      my $role_name = blessed $role ? $role->name : $role;
      # if we are it,.. then return true
      return 1 if $role_name eq $self->name;
      # otherwise.. check our children
      foreach my $role (@{$self->get_roles}) {
          return 1 if $role->does_role($role_name);
      }
      return 0;
  }
  
  sub find_method_by_name { (shift)->get_method(@_) }
  
  ## ------------------------------------------------------------------
  ## role construction
  ## ------------------------------------------------------------------
  
  sub apply {
      my ($self, $other, %args) = @_;
  
      (blessed($other))
          || throw_exception( ApplyTakesABlessedInstance => param     => $other,
                                                            role_name => $self->name,
                            );
  
      my $application_class;
      if ($other->isa('Moose::Meta::Role')) {
          $application_class = $self->application_to_role_class;
      }
      elsif ($other->isa('Moose::Meta::Class')) {
          $application_class = $self->application_to_class_class;
      }
      else {
          $application_class = $self->application_to_instance_class;
      }
  
      Moose::Util::_load_user_class($application_class);
  
      if ( exists $args{'-excludes'} ) {
          # I wish we had coercion here :)
          $args{'-excludes'} = (
              ref $args{'-excludes'} eq 'ARRAY'
              ? $args{'-excludes'}
              : [ $args{'-excludes'} ]
          );
      }
  
      return $application_class->new(%args)->apply($self, $other, \%args);
  }
  
  sub composition_class_roles { }
  
  sub combine {
      my ($class, @role_specs) = @_;
  
      require Moose::Meta::Role::Composite;
  
      my (@roles, %role_params);
      while (@role_specs) {
          my ($role, $params) = @{ splice @role_specs, 0, 1 };
          my $requested_role
              = blessed $role
              ? $role
              : Class::MOP::class_of($role);
  
          my $actual_role = $requested_role->_role_for_combination($params);
          push @roles => $actual_role;
  
          next unless defined $params;
          $role_params{$actual_role->name} = $params;
      }
  
      my $c = Moose::Meta::Role::Composite->new(roles => \@roles);
      return $c->apply_params(\%role_params);
  }
  
  sub _role_for_combination {
      my ($self, $params) = @_;
      return $self;
  }
  
  sub create {
      my $class = shift;
      my @args = @_;
  
      unshift @args, 'package' if @args % 2 == 1;
      my %options = @args;
  
      (ref $options{attributes} eq 'HASH')
          || throw_exception( CreateTakesHashRefOfAttributes => params           => \%options,
                                                                attribute_class  => $class
                            )
              if exists $options{attributes};
  
      (ref $options{methods} eq 'HASH')
          || throw_exception( CreateTakesHashRefOfMethods => params           => \%options,
                                                             attribute_class  => $class
                            )
              if exists $options{methods};
  
      (ref $options{roles} eq 'ARRAY')
          || throw_exception( CreateTakesArrayRefOfRoles => params           => \%options,
                                                            attribute_class  => $class
                            )
              if exists $options{roles};
  
      my $package      = delete $options{package};
      my $roles        = delete $options{roles};
      my $attributes   = delete $options{attributes};
      my $methods      = delete $options{methods};
      my $meta_name    = exists $options{meta_name}
                           ? delete $options{meta_name}
                           : 'meta';
  
      my $meta = $class->SUPER::create($package => %options);
  
      $meta->_add_meta_method($meta_name)
          if defined $meta_name;
  
      if (defined $attributes) {
          foreach my $attribute_name (keys %{$attributes}) {
              my $attr = $attributes->{$attribute_name};
              $meta->add_attribute(
                  $attribute_name => blessed $attr ? $attr : %{$attr} );
          }
      }
  
      if (defined $methods) {
          foreach my $method_name (keys %{$methods}) {
              $meta->add_method($method_name, $methods->{$method_name});
          }
      }
  
      if ($roles) {
          Moose::Util::apply_all_roles($meta, @$roles);
      }
  
      return $meta;
  }
  
  sub consumers {
      my $self = shift;
      my @consumers;
      for my $meta (Class::MOP::get_all_metaclass_instances) {
          next if $meta->name eq $self->name;
          next unless $meta->isa('Moose::Meta::Class')
                   || $meta->isa('Moose::Meta::Role');
          push @consumers, $meta->name
              if $meta->does_role($self->name);
      }
      return @consumers;
  }
  
  # XXX: something more intelligent here?
  sub _anon_package_prefix { 'Moose::Meta::Role::__ANON__::SERIAL::' }
  
  sub create_anon_role { shift->create_anon(@_) }
  sub is_anon_role     { shift->is_anon(@_)     }
  
  sub _anon_cache_key {
      my $class = shift;
      my %options = @_;
  
      # XXX fix this duplication (see MMC::_anon_cache_key
      my $roles = Data::OptList::mkopt(($options{roles} || []), {
          moniker  => 'role',
          val_test => sub { ref($_[0]) eq 'HASH' },
      });
  
      my @role_keys;
      for my $role_spec (@$roles) {
          my ($role, $params) = @$role_spec;
          $params = { %$params };
  
          my $key = blessed($role) ? $role->name : $role;
  
          if ($params && %$params) {
              my $alias    = delete $params->{'-alias'}
                          || delete $params->{'alias'}
                          || {};
              my $excludes = delete $params->{'-excludes'}
                          || delete $params->{'excludes'}
                          || [];
              $excludes = [$excludes] unless ref($excludes) eq 'ARRAY';
  
              if (%$params) {
                  warn "Roles with parameters cannot be cached. Consider "
                     . "applying the parameters before calling "
                     . "create_anon_class, or using 'weaken => 0' instead";
                  return;
              }
  
              my $alias_key = join('%',
                  map { $_ => $alias->{$_} } sort keys %$alias
              );
              my $excludes_key = join('%',
                  sort @$excludes
              );
              $key .= '<' . join('+', 'a', $alias_key, 'e', $excludes_key) . '>';
          }
  
          push @role_keys, $key;
      }
  
      # Makes something like Role|Role::1
      return join('|', sort @role_keys);
  }
  
  #####################################################################
  ## NOTE:
  ## This is Moose::Meta::Role as defined by Moose (plus the use of
  ## MooseX::AttributeHelpers module). It is here as a reference to
  ## make it easier to see what is happening above with all the meta
  ## programming. - SL
  #####################################################################
  #
  # has 'roles' => (
  #     metaclass => 'Array',
  #     reader    => 'get_roles',
  #     isa       => 'ArrayRef[Moose::Meta::Role]',
  #     default   => sub { [] },
  #     provides  => {
  #         'push' => 'add_role',
  #     }
  # );
  #
  # has 'excluded_roles_map' => (
  #     metaclass => 'Hash',
  #     reader    => 'get_excluded_roles_map',
  #     isa       => 'HashRef[Str]',
  #     provides  => {
  #         # Not exactly set, cause it sets multiple
  #         'set'    => 'add_excluded_roles',
  #         'keys'   => 'get_excluded_roles_list',
  #         'exists' => 'excludes_role',
  #     }
  # );
  #
  # has 'required_methods' => (
  #     metaclass => 'Hash',
  #     reader    => 'get_required_methods_map',
  #     isa       => 'HashRef[Moose::Meta::Role::Method::Required]',
  #     provides  => {
  #         # not exactly set, or delete since it works for multiple
  #         'set'    => 'add_required_methods',
  #         'delete' => 'remove_required_methods',
  #         'keys'   => 'get_required_method_list',
  #         'exists' => 'requires_method',
  #     }
  # );
  #
  # # the before, around and after modifiers are
  # # HASH keyed by method-name, with ARRAY of
  # # CODE refs to apply in that order
  #
  # has 'before_method_modifiers' => (
  #     metaclass => 'Hash',
  #     reader    => 'get_before_method_modifiers_map',
  #     isa       => 'HashRef[ArrayRef[CodeRef]]',
  #     provides  => {
  #         'keys'   => 'get_before_method_modifiers',
  #         'exists' => 'has_before_method_modifiers',
  #         # This actually makes sure there is an
  #         # ARRAY at the given key, and pushed onto
  #         # it. It also checks for duplicates as well
  #         # 'add'  => 'add_before_method_modifier'
  #     }
  # );
  #
  # has 'after_method_modifiers' => (
  #     metaclass => 'Hash',
  #     reader    =>'get_after_method_modifiers_map',
  #     isa       => 'HashRef[ArrayRef[CodeRef]]',
  #     provides  => {
  #         'keys'   => 'get_after_method_modifiers',
  #         'exists' => 'has_after_method_modifiers',
  #         # This actually makes sure there is an
  #         # ARRAY at the given key, and pushed onto
  #         # it. It also checks for duplicates as well
  #         # 'add'  => 'add_after_method_modifier'
  #     }
  # );
  #
  # has 'around_method_modifiers' => (
  #     metaclass => 'Hash',
  #     reader    =>'get_around_method_modifiers_map',
  #     isa       => 'HashRef[ArrayRef[CodeRef]]',
  #     provides  => {
  #         'keys'   => 'get_around_method_modifiers',
  #         'exists' => 'has_around_method_modifiers',
  #         # This actually makes sure there is an
  #         # ARRAY at the given key, and pushed onto
  #         # it. It also checks for duplicates as well
  #         # 'add'  => 'add_around_method_modifier'
  #     }
  # );
  #
  # # override is similar to the other modifiers
  # # except that it is not an ARRAY of code refs
  # # but instead just a single name->code mapping
  #
  # has 'override_method_modifiers' => (
  #     metaclass => 'Hash',
  #     reader    =>'get_override_method_modifiers_map',
  #     isa       => 'HashRef[CodeRef]',
  #     provides  => {
  #         'keys'   => 'get_override_method_modifier',
  #         'exists' => 'has_override_method_modifier',
  #         'add'    => 'add_override_method_modifier', # checks for local method ..
  #     }
  # );
  #
  #####################################################################
  
  
  1;
  
  # ABSTRACT: The Moose Role metaclass
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role - The Moose Role metaclass
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Module> that provides
  additional Moose-specific functionality.
  
  Its API looks a lot like L<Moose::Meta::Class>, but internally it
  implements many things differently. This may change in the future.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Role> is a subclass of L<Class::MOP::Module>.
  
  =head1 METHODS
  
  =head2 Construction
  
  =head3 Moose::Meta::Role->initialize($role_name)
  
  This method creates a new role object with the provided name.
  
  =head3 Moose::Meta::Role->combine( [ $role => { ... } ], [ $role ], ... )
  
  This method accepts a list of array references. Each array reference
  should contain a role name or L<Moose::Meta::Role> object as its first element. The second element is
  an optional hash reference. The hash reference can contain C<-excludes>
  and C<-alias> keys to control how methods are composed from the role.
  
  The return value is a new L<Moose::Meta::Role::Composite> that
  represents the combined roles.
  
  =head3 $metarole->composition_class_roles
  
  When combining multiple roles using C<combine>, this method is used to obtain a
  list of role names to be applied to the L<Moose::Meta::Role::Composite>
  instance returned by C<combine>. The default implementation returns an empty
  list. Extensions that need to hook into role combination may wrap this method
  to return additional role names.
  
  =head3 Moose::Meta::Role->create($name, %options)
  
  This method is identical to the L<Moose::Meta::Class> C<create>
  method.
  
  =head3 Moose::Meta::Role->create_anon_role
  
  This method is identical to the L<Moose::Meta::Class>
  C<create_anon_class> method.
  
  =head3 $metarole->is_anon_role
  
  Returns true if the role is an anonymous role.
  
  =head3 $metarole->consumers
  
  Returns a list of names of classes and roles which consume this role.
  
  =head2 Role application
  
  =head3 $metarole->apply( $thing, @options )
  
  This method applies a role to the given C<$thing>. That can be another
  L<Moose::Meta::Role>, object, a L<Moose::Meta::Class> object, or a
  (non-meta) object instance.
  
  The options are passed directly to the constructor for the appropriate
  L<Moose::Meta::Role::Application> subclass.
  
  Note that this will apply the role even if the C<$thing> in question already
  C<does> this role.  L<Moose::Util/does_role> is a convenient wrapper for
  finding out if role application is necessary.
  
  =head2 Roles and other roles
  
  =head3 $metarole->get_roles
  
  This returns an array reference of roles which this role does. This
  list may include duplicates.
  
  =head3 $metarole->calculate_all_roles
  
  This returns a I<unique> list of all roles that this role does, and
  all the roles that its roles do.
  
  =head3 $metarole->does_role($role)
  
  Given a role I<name> or L<Moose::Meta::Role> object, returns true if this role
  does the given role.
  
  =head3 $metarole->add_role($role)
  
  Given a L<Moose::Meta::Role> object, this adds the role to the list of
  roles that the role does.
  
  =head3 $metarole->get_excluded_roles_list
  
  Returns a list of role names which this role excludes.
  
  =head3 $metarole->excludes_role($role_name)
  
  Given a role I<name>, returns true if this role excludes the named
  role.
  
  =head3 $metarole->add_excluded_roles(@role_names)
  
  Given one or more role names, adds those roles to the list of excluded
  roles.
  
  =head2 Methods
  
  The methods for dealing with a role's methods are all identical in API
  and behavior to the same methods in L<Class::MOP::Class>.
  
  =head3 $metarole->method_metaclass
  
  Returns the method metaclass name for the role. This defaults to
  L<Moose::Meta::Role::Method>.
  
  =head3 $metarole->get_method($name)
  
  =head3 $metarole->has_method($name)
  
  =head3 $metarole->add_method( $name, $body )
  
  =head3 $metarole->get_method_list
  
  =head3 $metarole->find_method_by_name($name)
  
  These methods are all identical to the methods of the same name in
  L<Class::MOP::Package>
  
  =head2 Attributes
  
  As with methods, the methods for dealing with a role's attribute are
  all identical in API and behavior to the same methods in
  L<Class::MOP::Class>.
  
  However, attributes stored in this class are I<not> stored as
  objects. Rather, the attribute definition is stored as a hash
  reference. When a role is composed into a class, this hash reference
  is passed directly to the metaclass's C<add_attribute> method.
  
  This is quite likely to change in the future.
  
  =head3 $metarole->get_attribute($attribute_name)
  
  =head3 $metarole->has_attribute($attribute_name)
  
  =head3 $metarole->get_attribute_list
  
  =head3 $metarole->add_attribute($name, %options)
  
  =head3 $metarole->remove_attribute($attribute_name)
  
  =head2 Overload introspection and creation
  
  The methods for dealing with a role's overloads are all identical in API and
  behavior to the same methods in L<Class::MOP::Class>.
  
  =head3 $metarole->is_overloaded
  
  =head3 $metarole->get_overloaded_operator($op)
  
  =head3 $metarole->has_overloaded_operator($op)
  
  =head3 $metarole->get_overload_list
  
  =head3 $metarole->get_all_overloaded_operators
  
  =head3 $metarole->add_overloaded_operator($op, $impl)
  
  =head3 $metarole->remove_overloaded_operator($op)
  
  =head2 Required methods
  
  =head3 $metarole->get_required_method_list
  
  Returns the list of methods required by the role.
  
  =head3 $metarole->requires_method($name)
  
  Returns true if the role requires the named method.
  
  =head3 $metarole->add_required_methods(@names)
  
  Adds the named methods to the role's list of required methods.
  
  =head3 $metarole->remove_required_methods(@names)
  
  Removes the named methods from the role's list of required methods.
  
  =head3 $metarole->add_conflicting_method(%params)
  
  Instantiate the parameters as a L<Moose::Meta::Role::Method::Conflicting>
  object, then add it to the required method list.
  
  =head2 Method modifiers
  
  These methods act like their counterparts in L<Class::MOP::Class> and
  L<Moose::Meta::Class>.
  
  However, method modifiers are simply stored internally, and are not applied
  until the role itself is applied to a class or object.
  
  =head3 $metarole->add_after_method_modifier($method_name, $method)
  
  =head3 $metarole->add_around_method_modifier($method_name, $method)
  
  =head3 $metarole->add_before_method_modifier($method_name, $method)
  
  =head3 $metarole->add_override_method_modifier($method_name, $method)
  
  These methods all add an appropriate modifier to the internal list of
  modifiers.
  
  =head3 $metarole->has_after_method_modifiers
  
  =head3 $metarole->has_around_method_modifiers
  
  =head3 $metarole->has_before_method_modifiers
  
  =head3 $metarole->has_override_method_modifier
  
  Return true if the role has any modifiers of the given type.
  
  =head3 $metarole->get_after_method_modifiers($method_name)
  
  =head3 $metarole->get_around_method_modifiers($method_name)
  
  =head3 $metarole->get_before_method_modifiers($method_name)
  
  Given a method name, returns a list of the appropriate modifiers for
  that method.
  
  =head3 $metarole->get_override_method_modifier($method_name)
  
  Given a method name, returns the override method modifier for that
  method, if it has one.
  
  =head2 Introspection
  
  =head3 Moose::Meta::Role->meta
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_ROLE

$fatpacked{"darwin-2level/Moose/Meta/Role/Application.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_ROLE_APPLICATION';
  package Moose::Meta::Role::Application;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  use metaclass;
  use overload ();
  
  use List::Util 1.33 qw( all );
  
  use Moose::Util 'throw_exception';
  
  __PACKAGE__->meta->add_attribute('method_exclusions' => (
      init_arg => '-excludes',
      reader   => 'get_method_exclusions',
      default  => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('method_aliases' => (
      init_arg => '-alias',
      reader   => 'get_method_aliases',
      default  => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  sub new {
      my ($class, %params) = @_;
      $class->_new(\%params);
  }
  
  sub is_method_excluded {
      my ($self, $method_name) = @_;
      foreach (@{$self->get_method_exclusions}) {
          return 1 if $_ eq $method_name;
      }
      return 0;
  }
  
  sub is_method_aliased {
      my ($self, $method_name) = @_;
      exists $self->get_method_aliases->{$method_name} ? 1 : 0
  }
  
  sub is_aliased_method {
      my ($self, $method_name) = @_;
      my %aliased_names = reverse %{$self->get_method_aliases};
      exists $aliased_names{$method_name} ? 1 : 0;
  }
  
  sub apply {
      my $self = shift;
  
      $self->check_role_exclusions(@_);
      $self->check_required_methods(@_);
      $self->check_required_attributes(@_);
  
      $self->apply_overloading(@_);
      $self->apply_attributes(@_);
      $self->apply_methods(@_);
  
      $self->apply_override_method_modifiers(@_);
  
      $self->apply_before_method_modifiers(@_);
      $self->apply_around_method_modifiers(@_);
      $self->apply_after_method_modifiers(@_);
  }
  
  sub check_role_exclusions           { throw_exception( "CannotCallAnAbstractMethod" ); }
  sub check_required_methods          { throw_exception( "CannotCallAnAbstractMethod" ); }
  sub check_required_attributes       { throw_exception( "CannotCallAnAbstractMethod" ); }
  
  sub apply_attributes                { throw_exception( "CannotCallAnAbstractMethod" ); }
  sub apply_methods                   { throw_exception( "CannotCallAnAbstractMethod" ); }
  sub apply_override_method_modifiers { throw_exception( "CannotCallAnAbstractMethod" ); }
  sub apply_method_modifiers          { throw_exception( "CannotCallAnAbstractMethod" ); }
  
  sub apply_before_method_modifiers   { (shift)->apply_method_modifiers('before' => @_) }
  sub apply_around_method_modifiers   { (shift)->apply_method_modifiers('around' => @_) }
  sub apply_after_method_modifiers    { (shift)->apply_method_modifiers('after'  => @_) }
  
  sub apply_overloading {
      my ( $self, $role, $other ) = @_;
  
      return unless $role->is_overloaded;
  
      unless ( $other->is_overloaded ) {
          $other->set_overload_fallback_value(
              $role->get_overload_fallback_value );
      }
  
      for my $overload ( $role->get_all_overloaded_operators ) {
          next if $other->has_overloaded_operator( $overload->operator );
          $other->add_overloaded_operator(
              $overload->operator => $overload->clone );
      }
  }
  
  1;
  
  # ABSTRACT: A base class for role application
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Application - A base class for role application
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This is the abstract base class for role applications.
  
  The API for this class and its subclasses still needs some
  consideration, and is intentionally not yet documented.
  
  =head2 METHODS
  
  =over 4
  
  =item B<new>
  
  =item B<meta>
  
  =item B<get_method_exclusions>
  
  =item B<is_method_excluded>
  
  =item B<get_method_aliases>
  
  =item B<is_aliased_method>
  
  =item B<is_method_aliased>
  
  =item B<apply>
  
  =item B<check_role_exclusions>
  
  =item B<check_required_methods>
  
  =item B<check_required_attributes>
  
  =item B<apply_attributes>
  
  =item B<apply_methods>
  
  =item B<apply_overloading>
  
  =item B<apply_method_modifiers>
  
  =item B<apply_before_method_modifiers>
  
  =item B<apply_after_method_modifiers>
  
  =item B<apply_around_method_modifiers>
  
  =item B<apply_override_method_modifiers>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_ROLE_APPLICATION

$fatpacked{"darwin-2level/Moose/Meta/Role/Application/RoleSummation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_ROLE_APPLICATION_ROLESUMMATION';
  package Moose::Meta::Role::Application::RoleSummation;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  use metaclass;
  
  use List::Util 1.33 qw( all );
  use Scalar::Util 'blessed';
  
  use Moose::Meta::Role::Composite;
  
  use parent 'Moose::Meta::Role::Application';
  
  use Moose::Util 'throw_exception';
  
  __PACKAGE__->meta->add_attribute('role_params' => (
      reader  => 'role_params',
      default => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  sub get_exclusions_for_role {
      my ($self, $role) = @_;
      $role = $role->name if blessed $role;
      my $excludes_key = exists $self->role_params->{$role}->{'-excludes'} ?
                             '-excludes' : 'excludes';
      if ($self->role_params->{$role} && defined $self->role_params->{$role}->{$excludes_key}) {
          if (ref $self->role_params->{$role}->{$excludes_key} eq 'ARRAY') {
              return $self->role_params->{$role}->{$excludes_key};
          }
          return [ $self->role_params->{$role}->{$excludes_key} ];
      }
      return [];
  }
  
  sub get_method_aliases_for_role {
      my ($self, $role) = @_;
      $role = $role->name if blessed $role;
      my $alias_key = exists $self->role_params->{$role}->{'-alias'} ?
                          '-alias' : 'alias';
      if ($self->role_params->{$role} && defined $self->role_params->{$role}->{$alias_key}) {
          return $self->role_params->{$role}->{$alias_key};
      }
      return {};
  }
  
  sub is_method_excluded {
      my ($self, $role, $method_name) = @_;
      foreach ($self->get_exclusions_for_role($role->name)) {
          return 1 if $_ eq $method_name;
      }
      return 0;
  }
  
  sub is_method_aliased {
      my ($self, $role, $method_name) = @_;
      exists $self->get_method_aliases_for_role($role->name)->{$method_name} ? 1 : 0
  }
  
  sub is_aliased_method {
      my ($self, $role, $method_name) = @_;
      my %aliased_names = reverse %{$self->get_method_aliases_for_role($role->name)};
      exists $aliased_names{$method_name} ? 1 : 0;
  }
  
  sub check_role_exclusions {
      my ($self, $c) = @_;
  
      my %excluded_roles;
      for my $role (@{ $c->get_roles }) {
          my $name = $role->name;
  
          for my $excluded ($role->get_excluded_roles_list) {
              push @{ $excluded_roles{$excluded} }, $name;
          }
      }
  
      foreach my $role (@{$c->get_roles}) {
          foreach my $excluded (keys %excluded_roles) {
              next unless $role->does_role($excluded);
  
              my @excluding = @{ $excluded_roles{$excluded} };
  
              throw_exception( RoleExclusionConflict => roles     => \@excluding,
                                                        role_name => $excluded
                             );
          }
      }
  
      $c->add_excluded_roles(keys %excluded_roles);
  }
  
  sub check_required_methods {
      my ($self, $c) = @_;
  
      my %all_required_methods =
          map { $_->name => $_ }
          map { $_->get_required_method_list }
          @{$c->get_roles};
  
      foreach my $role (@{$c->get_roles}) {
          foreach my $required (keys %all_required_methods) {
  
              delete $all_required_methods{$required}
                  if $role->has_method($required)
                  || $self->is_aliased_method($role, $required);
          }
      }
  
      $c->add_required_methods(values %all_required_methods);
  }
  
  sub check_required_attributes {
  
  }
  
  sub apply_attributes {
      my ($self, $c) = @_;
  
      my @all_attributes;
  
      for my $role ( @{ $c->get_roles } ) {
          push @all_attributes,
              map { $role->get_attribute($_) } $role->get_attribute_list;
      }
  
      my %seen;
      foreach my $attr (@all_attributes) {
          my $name = $attr->name;
  
          if ( exists $seen{$name} ) {
              next if $seen{$name}->is_same_as($attr);
  
              my $role1 = $seen{$name}->associated_role->name;
              my $role2 = $attr->associated_role->name;
  
              throw_exception( AttributeConflictInSummation => attribute_name   => $name,
                                                               role_name        => $role1,
                                                               second_role_name => $role2,
                             );
          }
  
          $seen{$name} = $attr;
      }
  
      foreach my $attr (@all_attributes) {
          $c->add_attribute( $attr->clone );
      }
  }
  
  sub apply_methods {
      my ($self, $c) = @_;
  
      my @all_methods = map {
          my $role     = $_;
          my $aliases  = $self->get_method_aliases_for_role($role);
          my %excludes = map { $_ => undef } @{ $self->get_exclusions_for_role($role) };
          (
              (map {
                  exists $excludes{$_} ? () :
                  +{
                      role   => $role,
                      name   => $_,
                      method => $role->get_method($_),
                  }
              } map { $_->name }
                grep { !$_->isa('Class::MOP::Method::Meta') }
                     $role->_get_local_methods),
              (map {
                  +{
                      role   => $role,
                      name   => $aliases->{$_},
                      method => $role->get_method($_),
                  }
              } keys %$aliases)
          );
      } @{$c->get_roles};
  
      my (%seen, %conflicts, %method_map);
      foreach my $method (@all_methods) {
          next if $conflicts{$method->{name}};
          my $seen = $seen{$method->{name}};
  
          if ($seen) {
              if ($seen->{method}->body != $method->{method}->body) {
                  $c->add_conflicting_method(
                      name  => $method->{name},
                      roles => [$method->{role}->name, $seen->{role}->name],
                  );
  
                  delete $method_map{$method->{name}};
                  $conflicts{$method->{name}} = 1;
                  next;
              }
          }
  
          $seen{$method->{name}}       = $method;
          $method_map{$method->{name}} = $method->{method};
      }
  
      $c->add_method($_ => $method_map{$_}) for keys %method_map;
  }
  
  sub apply_override_method_modifiers {
      my ($self, $c) = @_;
  
      my @all_overrides = map {
          my $role = $_;
          map {
              +{
                  name   => $_,
                  method => $role->get_override_method_modifier($_),
              }
          } $role->get_method_modifier_list('override');
      } @{$c->get_roles};
  
      my %seen;
      foreach my $override (@all_overrides) {
          my @role_names = map { $_->name } @{$c->get_roles};
          if ( $c->has_method($override->{name}) ){
              throw_exception( OverrideConflictInSummation => role_names       => \@role_names,
                                                              role_application => $self,
                                                              method_name      => $override->{name}
                             );
          }
          if (exists $seen{$override->{name}}) {
              if ( $seen{$override->{name}} != $override->{method} ) {
                  throw_exception( OverrideConflictInSummation => role_names          => \@role_names,
                                                                  role_application    => $self,
                                                                  method_name         => $override->{name},
                                                                  two_overrides_found => 1
                                 );
              }
          }
          $seen{$override->{name}} = $override->{method};
      }
  
      $c->add_override_method_modifier(
          $_->{name}, $_->{method}
      ) for @all_overrides;
  
  }
  
  sub apply_method_modifiers {
      my ($self, $modifier_type, $c) = @_;
      my $add = "add_${modifier_type}_method_modifier";
      my $get = "get_${modifier_type}_method_modifiers";
      foreach my $role (@{$c->get_roles}) {
          foreach my $method_name ($role->get_method_modifier_list($modifier_type)) {
              $c->$add(
                  $method_name,
                  $_
              ) foreach $role->$get($method_name);
          }
      }
  }
  
  sub apply_overloading {
      my ( $self, $c ) = @_;
  
      my @overloaded_roles = grep { $_->is_overloaded } @{ $c->get_roles };
      return unless @overloaded_roles;
  
      my %fallback;
      for my $role (@overloaded_roles) {
          $fallback{ $role->name } = $role->get_overload_fallback_value;
      }
  
      for my $role_name ( keys %fallback ) {
          for my $other_role_name ( grep { $_ ne $role_name } keys %fallback ) {
              my @fb_values = @fallback{ $role_name, $other_role_name };
              if ( all {defined} @fb_values ) {
                  next if $fallback{$role_name} eq $fallback{$other_role_name};
                  throw_exception(
                      'OverloadConflictInSummation',
                      role_names       => [ $role_name, $other_role_name ],
                      role_application => $self,
                      overloaded_op    => 'fallback',
                  );
              }
  
              next if all { !defined } @fb_values;
              throw_exception(
                  'OverloadConflictInSummation',
                  role_names       => [ $role_name, $other_role_name ],
                  role_application => $self,
                  overloaded_op    => 'fallback',
              );
          }
      }
  
      if ( keys %fallback ) {
          $c->set_overload_fallback_value( ( values %fallback )[0] );
      }
  
      my %overload_map;
      for my $role (@overloaded_roles) {
          for my $overload ( $role->get_all_overloaded_operators ) {
              $overload_map{ $overload->operator }{ $role->name } = $overload;
          }
      }
  
      for my $op_name ( keys %overload_map ) {
          my @roles = keys %{ $overload_map{$op_name} };
          my $overload = $overload_map{$op_name}{ $roles[0] };
  
          if ( @roles > 1 && !all { $overload->_is_equal_to($_) }
              values %{ $overload_map{$op_name} } ) {
  
              throw_exception(
                  'OverloadConflictInSummation',
                  role_names       => [ @roles[ 0, 1 ] ],
                  role_application => $self,
                  overloaded_op    => $op_name,
              );
          }
  
          $c->add_overloaded_operator(
              $op_name => $overload_map{$op_name}{ $roles[0] } );
      }
  }
  
  1;
  
  # ABSTRACT: Combine two or more roles
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Application::RoleSummation - Combine two or more roles
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  Summation composes two traits, forming the union of non-conflicting
  bindings and 'disabling' the conflicting bindings
  
  =head2 METHODS
  
  =over 4
  
  =item B<new>
  
  =item B<meta>
  
  =item B<role_params>
  
  =item B<get_exclusions_for_role>
  
  =item B<get_method_aliases_for_role>
  
  =item B<is_aliased_method>
  
  =item B<is_method_aliased>
  
  =item B<is_method_excluded>
  
  =item B<apply>
  
  =item B<check_role_exclusions>
  
  =item B<check_required_methods>
  
  =item B<check_required_attributes>
  
  =item B<apply_attributes>
  
  =item B<apply_methods>
  
  =item B<apply_overloading>
  
  =item B<apply_method_modifiers>
  
  =item B<apply_override_method_modifiers>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_ROLE_APPLICATION_ROLESUMMATION

$fatpacked{"darwin-2level/Moose/Meta/Role/Application/ToClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_ROLE_APPLICATION_TOCLASS';
  package Moose::Meta::Role::Application::ToClass;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  use metaclass;
  
  use List::Util 'first';
  use Moose::Util 'throw_exception';
  use Scalar::Util 'weaken';
  
  use parent 'Moose::Meta::Role::Application';
  
  __PACKAGE__->meta->add_attribute('role' => (
      reader => 'role',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('class' => (
      accessor => 'class',
      Class::MOP::_definition_context(),
  ));
  
  sub apply {
      my ($self, $role, $class) = @_;
  
      # We need weak_ref in CMOP :(
      weaken($self->{role}  = $role);
      weaken($self->{class} = $class);
  
      $self->SUPER::apply($role, $class);
  
      $class->add_role($role);
      $class->add_role_application($self);
  }
  
  sub check_role_exclusions {
      my ($self, $role, $class) = @_;
      if ($class->excludes_role($role->name)) {
          throw_exception( ConflictDetectedInCheckRoleExclusionsInToClass => class_name => $class->name,
                                                                             role_name  => $role->name,
                         );
      }
      foreach my $excluded_role_name ($role->get_excluded_roles_list) {
          if ($class->does_role($excluded_role_name)) {
              throw_exception( ClassDoesTheExcludedRole => role_name          => $role->name,
                                                           excluded_role_name => $excluded_role_name,
                                                           class_name         => $class->name,
                             );
          }
      }
  }
  
  sub check_required_methods {
      my ($self, $role, $class) = @_;
  
      my @missing;
      my @is_attr;
  
      # NOTE:
      # we might need to move this down below the
      # the attributes so that we can require any
      # attribute accessors. However I am thinking
      # that maybe those are somehow exempt from
      # the require methods stuff.
      foreach my $required_method ($role->get_required_method_list) {
          my $required_method_name = $required_method->name;
  
          if (!$class->find_method_by_name($required_method_name)) {
  
              next if $self->is_aliased_method($required_method_name);
  
              push @missing, $required_method;
          }
      }
  
      return unless @missing;
  
      my $error = '';
  
      @missing = sort { $a->name cmp $b->name } @missing;
      my @conflicts = grep { $_->isa('Moose::Meta::Role::Method::Conflicting') } @missing;
  
      if (@conflicts) {
          my $conflict = $conflicts[0];
          my $roles = $conflict->roles_as_english_list;
  
          my @same_role_conflicts = grep { $_->roles_as_english_list eq $roles } @conflicts;
  
          throw_exception( MethodNameConflictInRoles => conflict   => \@same_role_conflicts,
                                                        class_name => $class->name
                         );
      }
      elsif (@missing) {
          if (my $meth = first { $class->name->can($_) } @missing) {
              throw_exception( RequiredMethodsImportedByClass => class_name      => $class->name,
                                                                 role_name       => $role->name,
                                                                 missing_methods => \@missing,
                                                                 imported_method => $meth
                             );
          }
          else {
              throw_exception( RequiredMethodsNotImplementedByClass => class_name      => $class->name,
                                                                       role_name       => $role->name,
                                                                       missing_methods => \@missing,
                             );
          }
      }
  }
  
  sub check_required_attributes {
  
  }
  
  sub apply_attributes {
      my ($self, $role, $class) = @_;
  
      foreach my $attribute_name ($role->get_attribute_list) {
          # it if it has one already
          if ($class->has_attribute($attribute_name) &&
              # make sure we haven't seen this one already too
              $class->get_attribute($attribute_name) != $role->get_attribute($attribute_name)) {
              next;
          }
          else {
              $class->add_attribute(
                  $role->get_attribute($attribute_name)->attribute_for_class
              );
          }
      }
  }
  
  sub apply_methods {
      my ( $self, $role, $class ) = @_;
  
      foreach my $method ( $role->_get_local_methods ) {
          my $method_name = $method->name;
  
          next if $method->isa('Class::MOP::Method::Meta');
  
          unless ( $self->is_method_excluded($method_name) ) {
  
              my $class_method = $class->get_method($method_name);
  
              next if $class_method && $class_method->body != $method->body;
  
              $class->add_method(
                  $method_name,
                  $method,
              );
          }
  
          next unless $self->is_method_aliased($method_name);
  
          my $aliased_method_name = $self->get_method_aliases->{$method_name};
  
          my $class_method = $class->get_method($aliased_method_name);
  
          if ( $class_method && $class_method->body != $method->body ) {
              throw_exception( CannotCreateMethodAliasLocalMethodIsPresentInClass => aliased_method_name => $aliased_method_name,
                                                                                     method              => $method,
                                                                                     role_name           => $role->name,
                                                                                     class_name          => $class->name,
                             );
          }
  
          $class->add_method(
              $aliased_method_name,
              $method,
          );
      }
  
      # we must reset the cache here since
      # we are just aliasing methods, otherwise
      # the modifiers go wonky.
      $class->reset_package_cache_flag;
  }
  
  sub apply_override_method_modifiers {
      my ($self, $role, $class) = @_;
      foreach my $method_name ($role->get_method_modifier_list('override')) {
          # it if it has one already then ...
          if ($class->has_method($method_name)) {
              next;
          }
          else {
              # if this is not a role, then we need to
              # find the original package of the method
              # so that we can tell the class were to
              # find the right super() method
              my $method = $role->get_override_method_modifier($method_name);
              my ($package) = Class::MOP::get_code_info($method);
              # if it is a class, we just add it
              $class->add_override_method_modifier($method_name, $method, $package);
          }
      }
  }
  
  sub apply_method_modifiers {
      my ($self, $modifier_type, $role, $class) = @_;
      my $add = "add_${modifier_type}_method_modifier";
      my $get = "get_${modifier_type}_method_modifiers";
      foreach my $method_name ($role->get_method_modifier_list($modifier_type)) {
          $class->$add(
              $method_name,
              $_
          ) foreach $role->$get($method_name);
      }
  }
  
  1;
  
  # ABSTRACT: Compose a role into a class
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Application::ToClass - Compose a role into a class
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  =head2 METHODS
  
  =over 4
  
  =item B<new>
  
  =item B<meta>
  
  =item B<apply>
  
  =item B<check_role_exclusions>
  
  =item B<check_required_methods>
  
  =item B<check_required_attributes>
  
  =item B<apply_attributes>
  
  =item B<apply_methods>
  
  =item B<apply_method_modifiers>
  
  =item B<apply_override_method_modifiers>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_ROLE_APPLICATION_TOCLASS

$fatpacked{"darwin-2level/Moose/Meta/Role/Application/ToInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_ROLE_APPLICATION_TOINSTANCE';
  package Moose::Meta::Role::Application::ToInstance;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  use List::Util 1.33 'all';
  use Devel::OverloadInfo 0.004 'is_overloaded';
  
  use parent 'Moose::Meta::Role::Application';
  
  __PACKAGE__->meta->add_attribute('rebless_params' => (
      reader  => 'rebless_params',
      default => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  use constant _NEED_OVERLOAD_HACK_FOR_OBJECTS => "$]" < 5.008009;
  
  sub apply {
      my ( $self, $role, $object, $args ) = @_;
  
      my $obj_meta = Class::MOP::class_of($object) || 'Moose::Meta::Class';
  
      # This is a special case to handle the case where the object's metaclass
      # is a Class::MOP::Class, but _not_ a Moose::Meta::Class (for example,
      # when applying a role to a Moose::Meta::Attribute object).
      $obj_meta = 'Moose::Meta::Class'
          unless $obj_meta->isa('Moose::Meta::Class');
  
      my $class = $obj_meta->create_anon_class(
          superclasses => [ blessed($object) ],
          roles => [ $role, keys(%$args) ? ($args) : () ],
          cache => (all { $_ eq '-alias' || $_ eq '-excludes' } keys %$args),
      );
  
      $class->rebless_instance( $object, %{ $self->rebless_params } );
  
      if ( _NEED_OVERLOAD_HACK_FOR_OBJECTS
          && is_overloaded( ref $object ) ) {
  
          # need to use $_[2] here to apply to the object in the caller
          _reset_amagic($_[2]);
      }
  
      return $object;
  }
  
  1;
  
  # ABSTRACT: Compose a role into an instance
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Application::ToInstance - Compose a role into an instance
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  =head2 METHODS
  
  =over 4
  
  =item B<new>
  
  =item B<meta>
  
  =item B<apply>
  
  =item B<rebless_params>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_ROLE_APPLICATION_TOINSTANCE

$fatpacked{"darwin-2level/Moose/Meta/Role/Application/ToRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_ROLE_APPLICATION_TOROLE';
  package Moose::Meta::Role::Application::ToRole;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  use metaclass;
  
  use parent 'Moose::Meta::Role::Application';
  
  use Moose::Util 'throw_exception';
  
  sub apply {
      my ($self, $role1, $role2) = @_;
      $self->SUPER::apply($role1, $role2);
      $role2->add_role($role1);
  }
  
  sub check_role_exclusions {
      my ($self, $role1, $role2) = @_;
      if ( $role2->excludes_role($role1->name) ) {
          throw_exception( ConflictDetectedInCheckRoleExclusions => role_name          => $role2->name,
                                                                    excluded_role_name => $role1->name,
                         );
      }
      foreach my $excluded_role_name ($role1->get_excluded_roles_list) {
          if ( $role2->does_role($excluded_role_name) ) {
              throw_exception( RoleDoesTheExcludedRole => role_name          => $role2->name,
                                                          excluded_role_name => $excluded_role_name,
                                                          second_role_name   => $role1->name,
                             );
          }
          $role2->add_excluded_roles($excluded_role_name);
      }
  }
  
  sub check_required_methods {
      my ($self, $role1, $role2) = @_;
      foreach my $required_method ($role1->get_required_method_list) {
          my $required_method_name = $required_method->name;
  
          next if $self->is_aliased_method($required_method_name);
  
          $role2->add_required_methods($required_method)
              unless $role2->find_method_by_name($required_method_name);
      }
  }
  
  sub check_required_attributes {
  
  }
  
  sub apply_attributes {
      my ($self, $role1, $role2) = @_;
      foreach my $attribute_name ($role1->get_attribute_list) {
          # it if it has one already
          if ($role2->has_attribute($attribute_name) &&
              # make sure we haven't seen this one already too
              $role2->get_attribute($attribute_name) != $role1->get_attribute($attribute_name)) {
  
              my $role2_name = $role2->name;
  
              throw_exception( AttributeConflictInRoles => role_name        => $role1->name,
                                                           second_role_name => $role2->name,
                                                           attribute_name   => $attribute_name
                             );
          }
          else {
              $role2->add_attribute(
                  $role1->get_attribute($attribute_name)->clone
              );
          }
      }
  }
  
  sub apply_methods {
      my ( $self, $role1, $role2 ) = @_;
      foreach my $method ( $role1->_get_local_methods ) {
  
          my $method_name = $method->name;
  
          next if $method->isa('Class::MOP::Method::Meta');
  
          unless ( $self->is_method_excluded($method_name) ) {
  
              my $role2_method = $role2->get_method($method_name);
              if (   $role2_method
                  && $role2_method->body != $method->body ) {
  
                  # method conflicts between roles used to result in the method
                  # becoming a requirement but now are permitted just like
                  # for classes, hence no code in this branch anymore.
              }
              else {
                  $role2->add_method(
                      $method_name,
                      $method,
                  );
              }
          }
  
          next unless $self->is_method_aliased($method_name);
  
          my $aliased_method_name = $self->get_method_aliases->{$method_name};
  
          my $role2_method = $role2->get_method($aliased_method_name);
  
          if (   $role2_method
              && $role2_method->body != $method->body ) {
  
              throw_exception( CannotCreateMethodAliasLocalMethodIsPresent => aliased_method_name     => $aliased_method_name,
                                                                              method                  => $method,
                                                                              role_name               => $role2->name,
                                                                              role_being_applied_name => $role1->name,
                             );
          }
  
          $role2->add_method(
              $aliased_method_name,
              $role1->get_method($method_name)
          );
  
          if ( !$role2->has_method($method_name) ) {
              $role2->add_required_methods($method_name)
                  unless $self->is_method_excluded($method_name);
          }
      }
  }
  
  sub apply_override_method_modifiers {
      my ($self, $role1, $role2) = @_;
      foreach my $method_name ($role1->get_method_modifier_list('override')) {
          # it if it has one already then ...
          if ($role2->has_method($method_name)) {
              # if it is being composed into another role
              # we have a conflict here, because you cannot
              # combine an overridden method with a locally
              # defined one
              throw_exception( OverrideConflictInComposition => role_name               => $role2->name,
                                                                role_being_applied_name => $role1->name,
                                                                method_name             => $method_name
                             );
          }
          else {
              # if we are a role, we need to make sure
              # we don't have a conflict with the role
              # we are composing into
              if ($role2->has_override_method_modifier($method_name) &&
                  $role1->get_override_method_modifier($method_name) != $role2->get_override_method_modifier($method_name)) {
  
                  throw_exception( OverrideConflictInComposition => role_name               => $role2->name,
                                                                    role_being_applied_name => $role1->name,
                                                                    method_name             => $method_name,
                                                                    two_overrides_found     => 1
                                 );
              }
              else {
                  # if there is no conflict,
                  # just add it to the role
                  $role2->add_override_method_modifier(
                      $method_name,
                      $role1->get_override_method_modifier($method_name)
                  );
              }
          }
      }
  }
  
  sub apply_method_modifiers {
      my ($self, $modifier_type, $role1, $role2) = @_;
      my $add = "add_${modifier_type}_method_modifier";
      my $get = "get_${modifier_type}_method_modifiers";
      foreach my $method_name ($role1->get_method_modifier_list($modifier_type)) {
          $role2->$add(
              $method_name,
              $_
          ) foreach $role1->$get($method_name);
      }
  }
  
  1;
  
  # ABSTRACT: Compose a role into another role
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Application::ToRole - Compose a role into another role
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  =head2 METHODS
  
  =over 4
  
  =item B<new>
  
  =item B<meta>
  
  =item B<apply>
  
  =item B<check_role_exclusions>
  
  =item B<check_required_methods>
  
  =item B<check_required_attributes>
  
  =item B<apply_attributes>
  
  =item B<apply_methods>
  
  =item B<apply_method_modifiers>
  
  =item B<apply_override_method_modifiers>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_ROLE_APPLICATION_TOROLE

$fatpacked{"darwin-2level/Moose/Meta/Role/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_ROLE_ATTRIBUTE';
  package Moose::Meta::Role::Attribute;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use List::Util 1.33 'all';
  use Scalar::Util 'blessed', 'weaken';
  
  use parent 'Moose::Meta::Mixin::AttributeCore', 'Class::MOP::Object';
  
  use Moose::Util 'throw_exception';
  
  __PACKAGE__->meta->add_attribute(
      'metaclass' => (
          reader => 'metaclass',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'associated_role' => (
          reader => 'associated_role',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      '_original_role' => (
          reader => '_original_role',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'is' => (
          reader => 'is',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'original_options' => (
          reader => 'original_options',
          Class::MOP::_definition_context(),
      )
  );
  
  sub new {
      my ( $class, $name, %options ) = @_;
  
      (defined $name)
          || throw_exception( MustProvideANameForTheAttribute => params => \%options,
                                                                 class  => $class
                            );
  
      my $role = delete $options{_original_role};
  
      return bless {
          name             => $name,
          original_options => \%options,
          _original_role   => $role,
          %options,
      }, $class;
  }
  
  sub attach_to_role {
      my ( $self, $role ) = @_;
  
      ( blessed($role) && $role->isa('Moose::Meta::Role') )
          || throw_exception( MustPassAMooseMetaRoleInstanceOrSubclass => class  => $self,
                                                                          role   => $role
                            );
  
      weaken( $self->{'associated_role'} = $role );
  }
  
  sub original_role {
      my $self = shift;
  
      return $self->_original_role || $self->associated_role;
  }
  
  sub attribute_for_class {
      my $self = shift;
  
      my $metaclass = $self->original_role->applied_attribute_metaclass;
  
      return $metaclass->interpolate_class_and_new(
          $self->name    => %{ $self->original_options },
          role_attribute => $self,
      );
  }
  
  sub clone {
      my $self = shift;
  
      my $role = $self->original_role;
  
      return ( ref $self )->new(
          $self->name,
          %{ $self->original_options },
          _original_role => $role,
      );
  }
  
  sub is_same_as {
      my $self = shift;
      my $attr = shift;
  
      my $self_options = $self->original_options;
      my $other_options = $attr->original_options;
  
      return 0
          unless ( join q{|}, sort keys %{$self_options} ) eq ( join q{|}, sort keys %{$other_options} );
  
      for my $key ( keys %{$self_options} ) {
          return 0 if defined $self_options->{$key} && ! defined $other_options->{$key};
          return 0 if ! defined $self_options->{$key} && defined $other_options->{$key};
  
          next if all { ! defined } $self_options->{$key}, $other_options->{$key};
  
          return 0 unless $self_options->{$key} eq $other_options->{$key};
      }
  
      return 1;
  }
  
  1;
  
  # ABSTRACT: The Moose attribute metaclass for Roles
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Attribute - The Moose attribute metaclass for Roles
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class implements the API for attributes in roles. Attributes in roles are
  more like attribute prototypes than full blown attributes. While they are
  introspectable, they have very little behavior.
  
  =head1 METHODS
  
  =head2 Moose::Meta::Role::Attribute->new(...)
  
  This method accepts all the options that would be passed to the constructor
  for L<Moose::Meta::Attribute>.
  
  =head2 $attr->metaclass
  
  =head2 $attr->is
  
  Returns the option as passed to the constructor.
  
  =head2 $attr->associated_role
  
  Returns the L<Moose::Meta::Role> to which this attribute belongs, if any.
  
  =head2 $attr->original_role
  
  Returns the L<Moose::Meta::Role> in which this attribute was first
  defined. This may not be the same as the value of C<associated_role()> for
  attributes in a composite role, or when one role consumes other roles.
  
  =head2 $attr->original_options
  
  Returns a hash reference of options passed to the constructor. This is used
  when creating a L<Moose::Meta::Attribute> object from this object.
  
  =head2 $attr->attach_to_role($role)
  
  Attaches the attribute to the given L<Moose::Meta::Role>.
  
  =head2 $attr->attribute_for_class($metaclass)
  
  Given an attribute metaclass name, this method calls C<<
  $metaclass->interpolate_class_and_new >> to construct an attribute object
  which can be added to a L<Moose::Meta::Class>.
  
  =head2 $attr->clone
  
  Creates a new object identical to the object on which the method is called.
  
  =head2 $attr->is_same_as($other_attr)
  
  Compares two role attributes and returns true if they are identical.
  
  In addition, this class implements all informational predicates implements by
  L<Moose::Meta::Attribute> (and L<Class::MOP::Attribute>).
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_ROLE_ATTRIBUTE

$fatpacked{"darwin-2level/Moose/Meta/Role/Composite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_ROLE_COMPOSITE';
  package Moose::Meta::Role::Composite;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  use Moose::Util 'throw_exception';
  use parent 'Moose::Meta::Role';
  
  # NOTE:
  # we need to override the ->name
  # method from Class::MOP::Package
  # since we don't have an actual
  # package for this.
  # - SL
  __PACKAGE__->meta->add_attribute('name' => (
      reader => 'name',
      Class::MOP::_definition_context(),
  ));
  
  # NOTE:
  # Again, since we don't have a real
  # package to store our methods in,
  # we use a HASH ref instead.
  # - SL
  __PACKAGE__->meta->add_attribute('_methods' => (
      reader  => '_method_map',
      default => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('_overloads' => (
      reader  => '_overload_map',
      default => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('_overload_fallback' => (
      accessor  => '_overload_fallback',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute(
      'application_role_summation_class',
      reader  => 'application_role_summation_class',
      default => 'Moose::Meta::Role::Application::RoleSummation',
      Class::MOP::_definition_context(),
  );
  
  sub new {
      my ($class, %params) = @_;
  
      # the roles param is required ...
      foreach ( @{$params{roles}} ) {
          unless ( $_->isa('Moose::Meta::Role') ) {
              throw_exception( RolesListMustBeInstancesOfMooseMetaRole => params => \%params,
                                                                          role   => $_,
                                                                          class  => $class
                             );
          }
      }
  
      my @composition_roles = map {
          $_->composition_class_roles
      } @{ $params{roles} };
  
      if (@composition_roles) {
          my $meta = Moose::Meta::Class->create_anon_class(
              superclasses => [ $class ],
              roles        => [ @composition_roles ],
              cache        => 1,
          );
          $class = $meta->name;
      }
  
      # and the name is created from the
      # roles if one has not been provided
      $params{name} ||= (join "|" => map { $_->name } @{$params{roles}});
      $class->_new(\%params);
  }
  
  # There's no such thing as an anonymous composite role since composites are an
  # artifact of Moose's internals. However, a composite role that contains an
  # anon role may _look_ like an anon role since $self->name =~ /$anon_key/ can
  # return true if the first role in the composite is anonymous itself.
  sub is_anon { 0 }
  
  # This is largely a copy of what's in Moose::Meta::Role (itself
  # largely a copy of Class::MOP::Class). However, we can't actually
  # call add_package_symbol, because there's no package into which to
  # add the symbol.
  sub add_method {
      my ($self, $method_name, $method) = @_;
  
      unless ( defined $method_name && $method_name ) {
          throw_exception( MustDefineAMethodName => instance => $self );
      }
  
      my $body;
      if (blessed($method)) {
          $body = $method->body;
          if ($method->package_name ne $self->name) {
              $method = $method->clone(
                  package_name => $self->name,
                  name         => $method_name
              ) if $method->can('clone');
          }
      }
      else {
          $body = $method;
          $method = $self->wrap_method_body( body => $body, name => $method_name );
      }
  
      $self->_method_map->{$method_name} = $method;
  }
  
  sub get_method_list {
      my $self = shift;
      return keys %{ $self->_method_map };
  }
  
  sub _get_local_methods {
      my $self = shift;
      return values %{ $self->_method_map };
  }
  
  sub has_method {
      my ($self, $method_name) = @_;
  
      return exists $self->_method_map->{$method_name};
  }
  
  sub get_method {
      my ($self, $method_name) = @_;
  
      return $self->_method_map->{$method_name};
  }
  
  sub is_overloaded {
      my ($self) = @_;
      return keys %{ $self->_overload_map };
  }
  
  sub add_overloaded_operator {
      my ( $self, $op_name, $overload ) = @_;
  
      unless ( defined $op_name && $op_name ) {
          throw_exception(
              'MustDefineAnOverloadOperator',
              instance => $self,
          );
      }
  
      $self->_overload_map->{$op_name} = $overload;
  }
  
  sub get_overload_fallback_value {
      my ($self) = @_;
      return $self->_overload_fallback;
  }
  
  sub set_overload_fallback_value {
      my $self = shift;
      $self->_overload_fallback(shift);
  }
  
  sub get_all_overloaded_operators {
      my ( $self, $method_name ) = @_;
      return values %{ $self->_overload_map };
  }
  
  sub apply_params {
      my ($self, $role_params) = @_;
      Moose::Util::_load_user_class($self->application_role_summation_class);
  
      $self->application_role_summation_class->new(
          role_params => $role_params,
      )->apply($self);
  
      return $self;
  }
  
  sub reinitialize {
      my ( $class, $old_meta, @args ) = @_;
  
      throw_exception( CannotInitializeMooseMetaRoleComposite => old_meta       => $old_meta,
                                                                 args           => \@args,
                                                                 role_composite => $class
                     )
          if !blessed $old_meta
              || !$old_meta->isa('Moose::Meta::Role::Composite');
  
      my %existing_classes = map { $_ => $old_meta->$_() } qw(
          application_role_summation_class
      );
  
      return $old_meta->meta->clone_object( $old_meta, %existing_classes, @args );
  }
  
  1;
  
  # ABSTRACT: An object to represent the set of roles
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Composite - An object to represent the set of roles
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  A composite is a role that consists of a set of two or more roles.
  
  The API of a composite role is almost identical to that of a regular
  role.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Role::Composite> is a subclass of L<Moose::Meta::Role>.
  
  =head1 METHODS
  
  =head2 Moose::Meta::Role::Composite->new(%options)
  
  This returns a new composite role object. It accepts the same
  options as its parent class, with a few changes:
  
  =over 4
  
  =item * roles
  
  This option is an array reference containing a list of
  L<Moose::Meta::Role> object. This is a required option.
  
  =item * name
  
  If a name is not given, one is generated from the roles provided.
  
  =item * apply_params(\%role_params)
  
  Creates a new RoleSummation role application with C<%role_params> and applies
  the composite role to it. The RoleSummation role application class used is
  determined by the composite role's C<application_role_summation_class>
  attribute.
  
  =item * reinitialize($metaclass)
  
  Like C<< Class::MOP::Package->reinitialize >>, but doesn't allow passing a
  string with the package name, as there is no real package for composite roles.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_ROLE_COMPOSITE

$fatpacked{"darwin-2level/Moose/Meta/Role/Method.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_ROLE_METHOD';
  package Moose::Meta::Role::Method;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use parent 'Moose::Meta::Method';
  
  sub _make_compatible_with {
      my $self = shift;
      my ($other) = @_;
  
      # XXX: this is pretty gross. the issue here is blah blah blah
      # see the comments in CMOP::Method::Meta and CMOP::Method::Wrapped
      return $self unless $other->_is_compatible_with($self->_real_ref_name);
  
      return $self->SUPER::_make_compatible_with(@_);
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for Roles
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Method - A Moose Method metaclass for Roles
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This is primarily used to mark methods coming from a role
  as being different. Right now it is nothing but a subclass
  of L<Moose::Meta::Method>.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_ROLE_METHOD

$fatpacked{"darwin-2level/Moose/Meta/Role/Method/Conflicting.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_ROLE_METHOD_CONFLICTING';
  package Moose::Meta::Role::Method::Conflicting;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Util;
  
  use parent 'Moose::Meta::Role::Method::Required';
  
  __PACKAGE__->meta->add_attribute('roles' => (
      reader   => 'roles',
      required => 1,
      Class::MOP::_definition_context(),
  ));
  
  sub roles_as_english_list {
      my $self = shift;
      Moose::Util::english_list( map { q{'} . $_ . q{'} } @{ $self->roles } );
  }
  
  1;
  
  # ABSTRACT: A Moose metaclass for conflicting methods in Roles
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Method::Conflicting - A Moose metaclass for conflicting methods in Roles
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Role::Method::Conflicting> is a subclass of
  L<Moose::Meta::Role::Method::Required>.
  
  =head1 METHODS
  
  =head2 Moose::Meta::Role::Method::Conflicting->new(%options)
  
  This creates a new type constraint based on the provided C<%options>:
  
  =over 4
  
  =item * name
  
  The method name. This is required.
  
  =item * roles
  
  The list of role names that generated the conflict. This is required.
  
  =back
  
  =head2 $method->name
  
  Returns the conflicting method's name, as provided to the constructor.
  
  =head2 $method->roles
  
  Returns the roles that generated this conflicting method, as provided to the
  constructor.
  
  =head2 $method->roles_as_english_list
  
  Returns the roles that generated this conflicting method as an English list.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_ROLE_METHOD_CONFLICTING

$fatpacked{"darwin-2level/Moose/Meta/Role/Method/Required.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_ROLE_METHOD_REQUIRED';
  package Moose::Meta::Role::Method::Required;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  use metaclass;
  
  use overload
      '""' => sub { shift->name },   # stringify to method name
      'bool' => sub { 1 },
      fallback => 1;
  
  use parent 'Class::MOP::Object';
  
  # This is not a Moose::Meta::Role::Method because it has no implementation, it
  # is just a name
  
  __PACKAGE__->meta->add_attribute('name' => (
      reader   => 'name',
      required => 1,
      Class::MOP::_definition_context(),
  ));
  
  sub new { shift->_new(@_) }
  
  1;
  
  # ABSTRACT: A Moose metaclass for required methods in Roles
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Method::Required - A Moose metaclass for required methods in Roles
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Role::Method::Required> is a subclass of L<Class::MOP::Object>.
  It is B<not> a subclass of C<Moose::Meta::Role::Method> since it does not
  provide an implementation of the method.
  
  =head1 METHODS
  
  =head2 Moose::Meta::Role::Method::Required->new(%options)
  
  This creates a new type constraint based on the provided C<%options>:
  
  =over 4
  
  =item * name
  
  The method name. This is required.
  
  =back
  
  =head2 $method->name
  
  Returns the required method's name, as provided to the constructor.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_ROLE_METHOD_REQUIRED

$fatpacked{"darwin-2level/Moose/Meta/TypeCoercion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_TYPECOERCION';
  package Moose::Meta::TypeCoercion;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  use metaclass;
  
  use Moose::Meta::Attribute;
  use Moose::Util::TypeConstraints ();
  
  use Moose::Util 'throw_exception';
  
  __PACKAGE__->meta->add_attribute('type_coercion_map' => (
      reader  => 'type_coercion_map',
      default => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute(
      Moose::Meta::Attribute->new('type_constraint' => (
          reader   => 'type_constraint',
          weak_ref => 1,
          Class::MOP::_definition_context(),
      ))
  );
  
  # private accessor
  __PACKAGE__->meta->add_attribute('compiled_type_coercion' => (
      accessor => '_compiled_type_coercion',
      Class::MOP::_definition_context(),
  ));
  
  sub new {
      my $class = shift;
      my $self  = Class::MOP::class_of($class)->new_object(@_);
      $self->compile_type_coercion;
      return $self;
  }
  
  sub compile_type_coercion {
      my $self = shift;
      my @coercion_map = @{$self->type_coercion_map};
      my @coercions;
      while (@coercion_map) {
          my ($constraint_name, $action) = splice(@coercion_map, 0, 2);
          my $type_constraint = ref $constraint_name ? $constraint_name : Moose::Util::TypeConstraints::find_or_parse_type_constraint($constraint_name);
  
          unless ( defined $type_constraint ) {
              throw_exception( CouldNotFindTypeConstraintToCoerceFrom => constraint_name => $constraint_name,
                                                                         instance        => $self
                             );
          }
  
          push @coercions => [
              $type_constraint->_compiled_type_constraint,
              $action
          ];
      }
      $self->_compiled_type_coercion(sub {
          my $thing = shift;
          foreach my $coercion (@coercions) {
              my ($constraint, $converter) = @$coercion;
              if ($constraint->($thing)) {
                  local $_ = $thing;
                  return $converter->($thing);
              }
          }
          return $thing;
      });
  }
  
  sub has_coercion_for_type {
      my ($self, $type_name) = @_;
      my %coercion_map = @{$self->type_coercion_map};
      exists $coercion_map{$type_name} ? 1 : 0;
  }
  
  sub add_type_coercions {
      my ($self, @new_coercion_map) = @_;
  
      my $coercion_map = $self->type_coercion_map;
      my %has_coercion = @$coercion_map;
  
      while (@new_coercion_map) {
          my ($constraint_name, $action) = splice(@new_coercion_map, 0, 2);
  
          if ( exists $has_coercion{$constraint_name} ) {
              throw_exception( CoercionAlreadyExists => constraint_name => $constraint_name,
                                                        instance        => $self
                             );
          }
  
          push @{$coercion_map} => ($constraint_name, $action);
      }
  
      # and re-compile ...
      $self->compile_type_coercion;
  }
  
  sub coerce { $_[0]->_compiled_type_coercion->($_[1]) }
  
  
  1;
  
  # ABSTRACT: The Moose Type Coercion metaclass
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeCoercion - The Moose Type Coercion metaclass
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  A type coercion object is basically a mapping of one or more type
  constraints and the associated coercions subroutines.
  
  It's unlikely that you will need to instantiate an object of this
  class directly, as it's part of the deep internals of Moose.
  
  =head1 METHODS
  
  =head2 Moose::Meta::TypeCoercion->new(%options)
  
  Creates a new type coercion object, based on the options provided.
  
  =over 4
  
  =item * type_constraint
  
  This is the L<Moose::Meta::TypeConstraint> object for the type that is
  being coerced I<to>.
  
  =back
  
  =head2 $coercion->type_coercion_map
  
  This returns the map of type constraints to coercions as an array
  reference. The values of the array alternate between type names and
  subroutine references which implement the coercion.
  
  The value is an array reference because coercions are tried in the
  order they are added.
  
  =head2 $coercion->type_constraint
  
  This returns the L<Moose::Meta::TypeConstraint> that was passed to the
  constructor.
  
  =head2 $coercion->has_coercion_for_type($type_name)
  
  Returns true if the coercion can coerce the named type.
  
  =head2 $coercion->add_type_coercions( $type_name => $sub, ... )
  
  This method takes a list of type names and subroutine references. If
  the coercion already has a mapping for a given type, it throws an
  exception.
  
  Coercions are actually
  
  =head2 $coercion->coerce($value)
  
  This method takes a value and applies the first valid coercion it
  finds.
  
  This means that if the value could belong to more than type in the
  coercion object, the first coercion added is used.
  
  =head2 Moose::Meta::TypeCoercion->meta
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_TYPECOERCION

$fatpacked{"darwin-2level/Moose/Meta/TypeCoercion/Union.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_TYPECOERCION_UNION';
  package Moose::Meta::TypeCoercion::Union;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  
  use parent 'Moose::Meta::TypeCoercion';
  
  use Moose::Util 'throw_exception';
  
  sub compile_type_coercion {
      my $self            = shift;
      my $type_constraint = $self->type_constraint;
  
      (blessed $type_constraint && $type_constraint->isa('Moose::Meta::TypeConstraint::Union'))
       || throw_exception( NeedsTypeConstraintUnionForTypeCoercionUnion => type_coercion_union_object => $self,
                                                                           type_name                  => $type_constraint->name
                         );
  
      $self->_compiled_type_coercion(
          sub {
              my $value = shift;
  
              foreach my $type ( grep { $_->has_coercion }
                  @{ $type_constraint->type_constraints } ) {
                  my $temp = $type->coerce($value);
                  return $temp if $type_constraint->check($temp);
              }
  
              return $value;
          }
      );
  }
  
  sub has_coercion_for_type { 0 }
  
  sub add_type_coercions {
      my $self = shift;
      throw_exception( CannotAddAdditionalTypeCoercionsToUnion => type_coercion_union_object => $self );
  }
  
  1;
  
  # ABSTRACT: The Moose Type Coercion metaclass for Unions
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeCoercion::Union - The Moose Type Coercion metaclass for Unions
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This is a subclass of L<Moose::Meta::TypeCoercion> that is used for
  L<Moose::Meta::TypeConstraint::Union> objects.
  
  =head1 METHODS
  
  =head2 $coercion->has_coercion_for_type
  
  This method always returns false.
  
  =head2 $coercion->add_type_coercions
  
  This method always throws an error. You cannot add coercions to a
  union type coercion.
  
  =head2 $coercion->coerce($value)
  
  This method will coerce by trying the coercions for each type in the
  union.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_TYPECOERCION_UNION

$fatpacked{"darwin-2level/Moose/Meta/TypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_TYPECONSTRAINT';
  package Moose::Meta::TypeConstraint;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  use metaclass;
  
  use overload '0+'     => sub { refaddr(shift) }, # id an object
               '""'     => sub { shift->name },   # stringify to tc name
               bool     => sub { 1 },
               fallback => 1;
  
  use Eval::Closure;
  use Scalar::Util qw(refaddr);
  use Sub::Name qw(subname);
  use Try::Tiny;
  
  use parent 'Class::MOP::Object';
  
  use Moose::Util 'throw_exception';
  
  __PACKAGE__->meta->add_attribute('name'       => (
      reader => 'name',
      Class::MOP::_definition_context(),
  ));
  __PACKAGE__->meta->add_attribute('parent'     => (
      reader    => 'parent',
      predicate => 'has_parent',
      Class::MOP::_definition_context(),
  ));
  
  my $null_constraint = sub { 1 };
  __PACKAGE__->meta->add_attribute('constraint' => (
      reader  => 'constraint',
      writer  => '_set_constraint',
      default => sub { $null_constraint },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('message'   => (
      accessor  => 'message',
      predicate => 'has_message',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('_default_message' => (
      accessor  => '_default_message',
      Class::MOP::_definition_context(),
  ));
  
  # can't make this a default because it has to close over the type name, and
  # cmop attributes don't have lazy
  my $_default_message_generator = sub {
      my $name = shift;
      sub {
          my $value = shift;
          # have to load it late like this, since it uses Moose itself
          my $can_partialdump = try {
              # versions prior to 0.14 had a potential infinite loop bug
              require Devel::PartialDump;
              Devel::PartialDump->VERSION(0.14);
              1;
          };
          if ($can_partialdump) {
              $value = Devel::PartialDump->new->dump($value);
          }
          else {
              $value = (defined $value ? overload::StrVal($value) : 'undef');
          }
          return "Validation failed for '" . $name . "' with value $value";
      }
  };
  __PACKAGE__->meta->add_attribute('coercion'   => (
      accessor  => 'coercion',
      predicate => 'has_coercion',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('inlined' => (
      init_arg  => 'inlined',
      accessor  => 'inlined',
      predicate => '_has_inlined_type_constraint',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('inline_environment' => (
      init_arg => 'inline_environment',
      accessor => '_inline_environment',
      default  => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  sub parents {
      my $self = shift;
      $self->parent;
  }
  
  # private accessors
  
  __PACKAGE__->meta->add_attribute('compiled_type_constraint' => (
      accessor  => '_compiled_type_constraint',
      predicate => '_has_compiled_type_constraint',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('package_defined_in' => (
      accessor => '_package_defined_in',
      Class::MOP::_definition_context(),
  ));
  
  sub new {
      my $class = shift;
      my ($first, @rest) = @_;
      my %args = ref $first ? %$first : $first ? ($first, @rest) : ();
      $args{name} = $args{name} ? "$args{name}" : "__ANON__";
  
      if ( exists $args{message}
        && (!ref($args{message}) || ref($args{message}) ne 'CODE') ) {
          throw_exception( MessageParameterMustBeCodeRef => params => \%args,
                                                            class  => $class
                         );
      }
  
      my $self  = $class->_new(%args);
      $self->compile_type_constraint()
          unless $self->_has_compiled_type_constraint;
      $self->_default_message($_default_message_generator->($self->name))
          unless $self->has_message;
      return $self;
  }
  
  
  
  sub coerce {
      my $self = shift;
  
      my $coercion = $self->coercion;
  
      unless ($coercion) {
          throw_exception( CoercingWithoutCoercions => type_name => $self->name );
      }
  
      return $_[0] if $self->check($_[0]);
  
      return $coercion->coerce(@_);
  }
  
  sub assert_coerce {
      my $self = shift;
  
      my $result = $self->coerce(@_);
  
      $self->assert_valid($result);
  
      return $result;
  }
  
  sub check {
      my ($self, @args) = @_;
      my $constraint_subref = $self->_compiled_type_constraint;
      return $constraint_subref->(@args) ? 1 : undef;
  }
  
  sub validate {
      my ($self, $value) = @_;
      if ($self->_compiled_type_constraint->($value)) {
          return undef;
      }
      else {
          $self->get_message($value);
      }
  }
  
  sub can_be_inlined {
      my $self = shift;
  
      if ( $self->has_parent && $self->constraint == $null_constraint ) {
          return $self->parent->can_be_inlined;
      }
  
      return $self->_has_inlined_type_constraint;
  }
  
  sub _inline_check {
      my $self = shift;
  
      unless ( $self->can_be_inlined ) {
          throw_exception( CannotInlineTypeConstraintCheck => type_name => $self->name );
      }
  
      if ( $self->has_parent && $self->constraint == $null_constraint ) {
          return $self->parent->_inline_check(@_);
      }
  
      return '( do { ' . $self->inlined->( $self, @_ ) . ' } )';
  }
  
  sub inline_environment {
      my $self = shift;
  
      if ( $self->has_parent && $self->constraint == $null_constraint ) {
          return $self->parent->inline_environment;
      }
  
      return $self->_inline_environment;
  }
  
  sub assert_valid {
      my ( $self, $value ) = @_;
  
      return 1 if $self->check($value);
  
      throw_exception(
          'ValidationFailedForTypeConstraint',
          type  => $self,
          value => $value
      );
  }
  
  sub get_message {
      my ($self, $value) = @_;
      my $msg = $self->has_message
          ? $self->message
          : $self->_default_message;
      local $_ = $value;
      return $msg->($value);
  }
  
  ## type predicates ...
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
      return if not $other;
  
      return 1 if $self == $other;
  
      return unless $self->constraint == $other->constraint;
  
      if ( $self->has_parent ) {
          return unless $other->has_parent;
          return unless $self->parent->equals( $other->parent );
      } else {
          return if $other->has_parent;
      }
  
      return;
  }
  
  sub is_a_type_of {
      my ($self, $type_or_name) = @_;
  
      my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
      return if not $type;
  
      ($self->equals($type) || $self->is_subtype_of($type));
  }
  
  sub is_subtype_of {
      my ($self, $type_or_name) = @_;
  
      my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
      return if not $type;
  
      my $current = $self;
  
      while (my $parent = $current->parent) {
          return 1 if $parent->equals($type);
          $current = $parent;
      }
  
      return 0;
  }
  
  ## compiling the type constraint
  
  sub compile_type_constraint {
      my $self = shift;
      $self->_compiled_type_constraint($self->_actually_compile_type_constraint);
  }
  
  ## type compilers ...
  
  sub _actually_compile_type_constraint {
      my $self = shift;
  
      if ( $self->can_be_inlined ) {
          return eval_closure(
              source      => 'sub { ' . $self->_inline_check('$_[0]') . ' }',
              environment => $self->inline_environment,
          );
      }
  
      my $check = $self->constraint;
      unless ( defined $check ) {
          throw_exception( NoConstraintCheckForTypeConstraint => type_name => $self->name );
      }
  
      return $self->_compile_subtype($check)
          if $self->has_parent;
  
      return $self->_compile_type($check);
  }
  
  sub _compile_subtype {
      my ($self, $check) = @_;
  
      # gather all the parent constraints in order
      my @parents;
      foreach my $parent ($self->_collect_all_parents) {
          push @parents => $parent->constraint;
      }
  
      @parents = grep { $_ != $null_constraint } reverse @parents;
  
      unless ( @parents ) {
          return $self->_compile_type($check);
      } else {
          # general case, check all the constraints, from the first parent to ourselves
          my @checks = @parents;
          push @checks, $check if $check != $null_constraint;
          return subname($self->name => sub {
              my (@args) = @_;
              local $_ = $args[0];
              foreach my $check (@checks) {
                  return undef unless $check->(@args);
              }
              return 1;
          });
      }
  }
  
  sub _compile_type {
      my ($self, $check) = @_;
  
      return $check if $check == $null_constraint; # Item, Any
  
      return subname($self->name => sub {
          my (@args) = @_;
          local $_ = $args[0];
          $check->(@args);
      });
  }
  
  ## other utils ...
  
  sub _collect_all_parents {
      my $self = shift;
      my @parents;
      my $current = $self->parent;
      while (defined $current) {
          push @parents => $current;
          $current = $current->parent;
      }
      return @parents;
  }
  
  sub create_child_type {
      my ($self, %opts) = @_;
      my $class = ref $self;
      return $class->new(%opts, parent => $self);
  }
  
  1;
  
  # ABSTRACT: The Moose Type Constraint metaclass
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint - The Moose Type Constraint metaclass
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class represents a single type constraint. Moose's built-in type
  constraints, as well as constraints you define, are all stored in a
  L<Moose::Meta::TypeConstraint::Registry> object as objects of this
  class.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint> is a subclass of L<Class::MOP::Object>.
  
  =head1 METHODS
  
  =head2 Moose::Meta::TypeConstraint->new(%options)
  
  This creates a new type constraint based on the provided C<%options>:
  
  =over 4
  
  =item * name
  
  The constraint name. If a name is not provided, it will be set to
  "__ANON__".
  
  =item * parent
  
  A C<Moose::Meta::TypeConstraint> object which is the parent type for
  the type being created. This is optional.
  
  =item * constraint
  
  This is the subroutine reference that implements the actual constraint
  check. This defaults to a subroutine which always returns true.
  
  =item * message
  
  A subroutine reference which is used to generate an error message when
  the constraint fails. This is optional.
  
  =item * coercion
  
  A L<Moose::Meta::TypeCoercion> object representing the coercions to
  the type. This is optional.
  
  =item * inlined
  
  A subroutine which returns a string suitable for inlining this type
  constraint. It will be called as a method on the type constraint object, and
  will receive a single additional parameter, a variable name to be tested
  (usually C<"$_"> or C<"$_[0]">.
  
  This is optional.
  
  =item * inline_environment
  
  A hash reference of variables to close over. The keys are variables names, and
  the values are I<references> to the variables.
  
  =back
  
  =head2 $constraint->equals($type_name_or_object)
  
  Returns true if the supplied name or type object is the same as the
  current type.
  
  =head2 $constraint->is_subtype_of($type_name_or_object)
  
  Returns true if the supplied name or type object is a parent of the
  current type.
  
  =head2 $constraint->is_a_type_of($type_name_or_object)
  
  Returns true if the given type is the same as the current type, or is
  a parent of the current type. This is a shortcut for checking
  C<equals> and C<is_subtype_of>.
  
  =head2 $constraint->coerce($value)
  
  This will attempt to coerce the value to the type. If the type does not
  have any defined coercions this will throw an error.
  
  If no coercion can produce a value matching C<$constraint>, the original
  value is returned.
  
  =head2 $constraint->assert_coerce($value)
  
  This method behaves just like C<coerce>, but if the result is not valid
  according to C<$constraint>, an error is thrown.
  
  =head2 $constraint->check($value)
  
  Returns true if the given value passes the constraint for the type.
  
  =head2 $constraint->validate($value)
  
  This is similar to C<check>. However, if the type I<is valid> then the
  method returns an explicit C<undef>. If the type is not valid, we call
  C<< $self->get_message($value) >> internally to generate an error
  message.
  
  =head2 $constraint->assert_valid($value)
  
  Like C<check> and C<validate>, this method checks whether C<$value> is
  valid under the constraint.  If it is, it will return true.  If it is not,
  an exception will be thrown with the results of
  C<< $self->get_message($value) >>.
  
  =head2 $constraint->name
  
  Returns the type's name, as provided to the constructor.
  
  =head2 $constraint->parent
  
  Returns the type's parent, as provided to the constructor, if any.
  
  =head2 $constraint->has_parent
  
  Returns true if the type has a parent type.
  
  =head2 $constraint->parents
  
  Returns all of the types parents as an list of type constraint objects.
  
  =head2 $constraint->constraint
  
  Returns the type's constraint, as provided to the constructor.
  
  =head2 $constraint->get_message($value)
  
  This generates a method for the given value. If the type does not have
  an explicit message, we generate a default message.
  
  =head2 $constraint->has_message
  
  Returns true if the type has a message.
  
  =head2 $constraint->message
  
  Returns the type's message as a subroutine reference.
  
  =head2 $constraint->coercion
  
  Returns the type's L<Moose::Meta::TypeCoercion> object, if one
  exists.
  
  =head2 $constraint->has_coercion
  
  Returns true if the type has a coercion.
  
  =head2 $constraint->can_be_inlined
  
  Returns true if this type constraint can be inlined. A type constraint which
  subtypes an inlinable constraint and does not add an additional constraint
  "inherits" its parent type's inlining.
  
  =head2 $constraint->create_child_type(%options)
  
  This returns a new type constraint of the same class using the
  provided C<%options>. The C<parent> option will be the current type.
  
  This method exists so that subclasses of this class can override this
  behavior and change how child types are created.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_TYPECONSTRAINT

$fatpacked{"darwin-2level/Moose/Meta/TypeConstraint/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_TYPECONSTRAINT_CLASS';
  package Moose::Meta::TypeConstraint::Class;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  use metaclass;
  
  use B;
  use Scalar::Util ();
  use Moose::Util::TypeConstraints ();
  
  use parent 'Moose::Meta::TypeConstraint';
  
  __PACKAGE__->meta->add_attribute('class' => (
      reader => 'class',
      Class::MOP::_definition_context(),
  ));
  
  my $inliner = sub {
      my $self = shift;
      my $val  = shift;
  
      return 'Scalar::Util::blessed(' . $val . ')'
               . ' && ' . $val . '->isa(' . B::perlstring($self->class) . ')';
  };
  
  sub new {
      my ( $class, %args ) = @_;
  
      $args{parent}
          = Moose::Util::TypeConstraints::find_type_constraint('Object');
  
      my $class_name = $args{class};
      $args{constraint} = sub { $_[0]->isa($class_name) };
  
      $args{inlined} = $inliner;
  
      my $self = $class->SUPER::new( \%args );
  
      $self->compile_type_constraint();
  
      return $self;
  }
  
  sub parents {
      my $self = shift;
      return (
          $self->parent,
          map {
              # FIXME find_type_constraint might find a TC named after the class but that isn't really it
              # I did this anyway since it's a convention that preceded TypeConstraint::Class, and it should DWIM
              # if anybody thinks this problematic please discuss on IRC.
              # a possible fix is to add by attr indexing to the type registry to find types of a certain property
              # regardless of their name
              Moose::Util::TypeConstraints::find_type_constraint($_)
                  ||
              __PACKAGE__->new( class => $_, name => "__ANON__" )
          } Class::MOP::class_of($self->class)->superclasses,
      );
  }
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      if (!defined($other)) {
          if (!ref($type_or_name)) {
              return $self->class eq $type_or_name;
          }
          return;
      }
  
      return unless $other->isa(__PACKAGE__);
  
      return $self->class eq $other->class;
  }
  
  sub is_a_type_of {
      my ($self, $type_or_name) = @_;
  
      ($self->equals($type_or_name) || $self->is_subtype_of($type_or_name));
  }
  
  sub is_subtype_of {
      my ($self, $type_or_name_or_class ) = @_;
  
      my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name_or_class);
  
      if ( not defined $type ) {
          if ( not ref $type_or_name_or_class ) {
              # it might be a class
              my $class = $self->class;
              return 1 if $class ne $type_or_name_or_class
                       && $class->isa( $type_or_name_or_class );
          }
          return;
      }
  
      if ( $type->isa(__PACKAGE__) && $type->class ne $self->class) {
          # if $type_or_name_or_class isn't a class, it might be the TC name of another ::Class type
          # or it could also just be a type object in this branch
          return $self->class->isa( $type->class );
      } else {
          # the only other thing we are a subtype of is Object
          $self->SUPER::is_subtype_of($type);
      }
  }
  
  # This is a bit counter-intuitive, but a child type of a Class type
  # constraint is not itself a Class type constraint (it has no class
  # attribute). This whole create_child_type thing needs some changing
  # though, probably making MMC->new a factory or something.
  sub create_child_type {
      my ($self, @args) = @_;
      return Moose::Meta::TypeConstraint->new(@args, parent => $self);
  }
  
  sub get_message {
      my $self = shift;
      my ($value) = @_;
  
      if ($self->has_message) {
          return $self->SUPER::get_message(@_);
      }
  
      $value = (defined $value ? overload::StrVal($value) : 'undef');
      return "Validation failed for '" . $self->name . "' with value $value (not isa " . $self->class . ")";
  }
  
  1;
  
  # ABSTRACT: Class/TypeConstraint parallel hierarchy
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Class - Class/TypeConstraint parallel hierarchy
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class represents type constraints for a class.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Class> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 METHODS
  
  =head2 Moose::Meta::TypeConstraint::Class->new(%options)
  
  This creates a new class type constraint based on the given
  C<%options>.
  
  It takes the same options as its parent, with two exceptions. First,
  it requires an additional option, C<class>, which is name of the
  constraint's class.  Second, it automatically sets the parent to the
  C<Object> type.
  
  The constructor also overrides the hand optimized type constraint with
  one it creates internally.
  
  =head2 $constraint->class
  
  Returns the class name associated with the constraint.
  
  =head2 $constraint->parents
  
  Returns all the type's parent types, corresponding to its parent
  classes.
  
  =head2 $constraint->is_subtype_of($type_name_or_object)
  
  If the given type is also a class type, then this checks that the
  type's class is a subclass of the other type's class.
  
  Otherwise it falls back to the implementation in
  L<Moose::Meta::TypeConstraint>.
  
  =head2 $constraint->create_child_type(%options)
  
  This returns a new L<Moose::Meta::TypeConstraint> object with the type
  as its parent.
  
  Note that it does I<not> return a
  C<Moose::Meta::TypeConstraint::Class> object!
  
  =head2 $constraint->get_message($value)
  
  This is the same as L<Moose::Meta::TypeConstraint/get_message> except
  that it explicitly says C<isa> was checked. This is to help users deal
  with accidentally autovivified type constraints.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_TYPECONSTRAINT_CLASS

$fatpacked{"darwin-2level/Moose/Meta/TypeConstraint/DuckType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_TYPECONSTRAINT_DUCKTYPE';
  package Moose::Meta::TypeConstraint::DuckType;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  use metaclass;
  
  use B;
  use Scalar::Util 'blessed';
  use List::Util 1.33 qw(all);
  use Moose::Util 'english_list';
  
  use Moose::Util::TypeConstraints ();
  
  use parent 'Moose::Meta::TypeConstraint';
  
  __PACKAGE__->meta->add_attribute('methods' => (
      accessor => 'methods',
      Class::MOP::_definition_context(),
  ));
  
  my $inliner = sub {
      my $self = shift;
      my $val  = shift;
  
      return $self->parent->_inline_check($val)
           . ' && do {' . "\n"
               . 'my $val = ' . $val . ';' . "\n"
               . '&List::Util::all(' . "\n"
                   . 'sub { $val->can($_) },' . "\n"
                   . join(', ', map { B::perlstring($_) } @{ $self->methods })
               . ');' . "\n"
           . '}';
  };
  
  sub new {
      my ( $class, %args ) = @_;
  
      $args{parent}
          = Moose::Util::TypeConstraints::find_type_constraint('Object');
  
      my @methods = @{ $args{methods} };
      $args{constraint} = sub {
          my $val = $_[0];
          return all { $val->can($_) } @methods;
      };
  
      $args{inlined} = $inliner;
  
      my $self = $class->SUPER::new(\%args);
  
      $self->compile_type_constraint()
          unless $self->_has_compiled_type_constraint;
  
      return $self;
  }
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      return unless $other->isa(__PACKAGE__);
  
      my @self_methods  = sort @{ $self->methods };
      my @other_methods = sort @{ $other->methods };
  
      return unless @self_methods == @other_methods;
  
      while ( @self_methods ) {
          my $method = shift @self_methods;
          my $other_method = shift @other_methods;
  
          return unless $method eq $other_method;
      }
  
      return 1;
  }
  
  sub create_child_type {
      my ($self, @args) = @_;
      return Moose::Meta::TypeConstraint->new(@args, parent => $self);
  }
  
  sub get_message {
      my $self = shift;
      my ($value) = @_;
  
      if ($self->has_message) {
          return $self->SUPER::get_message(@_);
      }
  
      return $self->SUPER::get_message($value) unless blessed($value);
  
      my @methods = grep { !$value->can($_) } @{ $self->methods };
      my $class = blessed $value;
      $class ||= $value;
  
      return $class
           . " is missing methods "
           . english_list(map { "'$_'" } @methods);
  }
  
  1;
  
  # ABSTRACT: Type constraint for duck typing
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::DuckType - Type constraint for duck typing
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class represents type constraints based on an enumerated list of
  required methods.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::DuckType> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 METHODS
  
  =head2 Moose::Meta::TypeConstraint::DuckType->new(%options)
  
  This creates a new duck type constraint based on the given
  C<%options>.
  
  It takes the same options as its parent, with several
  exceptions. First, it requires an additional option, C<methods>. This
  should be an array reference containing a list of required method
  names. Second, it automatically sets the parent to the C<Object> type.
  
  Finally, it ignores any provided C<constraint> option. The constraint
  is generated automatically based on the provided C<methods>.
  
  =head2 $constraint->methods
  
  Returns the array reference of required methods provided to the
  constructor.
  
  =head2 $constraint->create_child_type
  
  This returns a new L<Moose::Meta::TypeConstraint> object with the type
  as its parent.
  
  Note that it does I<not> return a C<Moose::Meta::TypeConstraint::DuckType>
  object!
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_TYPECONSTRAINT_DUCKTYPE

$fatpacked{"darwin-2level/Moose/Meta/TypeConstraint/Enum.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_TYPECONSTRAINT_ENUM';
  package Moose::Meta::TypeConstraint::Enum;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  use metaclass;
  
  use B;
  use Moose::Util::TypeConstraints ();
  
  use parent 'Moose::Meta::TypeConstraint';
  
  use Moose::Util 'throw_exception';
  
  __PACKAGE__->meta->add_attribute('values' => (
      accessor => 'values',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('_inline_var_name' => (
      accessor => '_inline_var_name',
      Class::MOP::_definition_context(),
  ));
  
  my $inliner = sub {
      my $self = shift;
      my $val  = shift;
  
      return 'defined(' . $val . ') '
               . '&& !ref(' . $val . ') '
               . '&& $' . $self->_inline_var_name . '{' . $val . '}';
  };
  
  my $var_suffix = 0;
  
  sub new {
      my ( $class, %args ) = @_;
  
      $args{parent} = Moose::Util::TypeConstraints::find_type_constraint('Str');
      $args{inlined} = $inliner;
  
      if ( scalar @{ $args{values} } < 1 ) {
          throw_exception( MustHaveAtLeastOneValueToEnumerate => params => \%args,
                                                                 class  => $class
                         );
      }
  
      for (@{ $args{values} }) {
          if (!defined($_)) {
              throw_exception( EnumValuesMustBeString => params => \%args,
                                                         class  => $class,
                                                         value  => $_
                             );
          }
          elsif (ref($_)) {
              throw_exception( EnumValuesMustBeString => params => \%args,
                                                         class  => $class,
                                                         value  => $_
                             );
          }
      }
  
      my %values = map { $_ => 1 } @{ $args{values} };
      $args{constraint} = sub { $values{ $_[0] } };
  
      my $var_name = 'enums' . $var_suffix++;;
      $args{_inline_var_name} = $var_name;
      $args{inline_environment} = { '%' . $var_name => \%values };
  
      my $self = $class->SUPER::new(\%args);
  
      $self->compile_type_constraint()
          unless $self->_has_compiled_type_constraint;
  
      return $self;
  }
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      return unless $other->isa(__PACKAGE__);
  
      my @self_values  = sort @{ $self->values };
      my @other_values = sort @{ $other->values };
  
      return unless @self_values == @other_values;
  
      while ( @self_values ) {
          my $value = shift @self_values;
          my $other_value = shift @other_values;
  
          return unless $value eq $other_value;
      }
  
      return 1;
  }
  
  sub constraint {
      my $self = shift;
  
      my %values = map { $_ => undef } @{ $self->values };
  
      return sub { exists $values{$_[0]} };
  }
  
  sub create_child_type {
      my ($self, @args) = @_;
      return Moose::Meta::TypeConstraint->new(@args, parent => $self);
  }
  
  1;
  
  # ABSTRACT: Type constraint for enumerated values.
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Enum - Type constraint for enumerated values.
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class represents type constraints based on an enumerated list of
  acceptable values.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Enum> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 METHODS
  
  =head2 Moose::Meta::TypeConstraint::Enum->new(%options)
  
  This creates a new enum type constraint based on the given
  C<%options>.
  
  It takes the same options as its parent, with several
  exceptions. First, it requires an additional option, C<values>. This
  should be an array reference containing a list of valid string
  values. Second, it automatically sets the parent to the C<Str> type.
  
  Finally, it ignores any provided C<constraint> option. The constraint
  is generated automatically based on the provided C<values>.
  
  =head2 $constraint->values
  
  Returns the array reference of acceptable values provided to the
  constructor.
  
  =head2 $constraint->create_child_type
  
  This returns a new L<Moose::Meta::TypeConstraint> object with the type
  as its parent.
  
  Note that it does I<not> return a C<Moose::Meta::TypeConstraint::Enum>
  object!
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_TYPECONSTRAINT_ENUM

$fatpacked{"darwin-2level/Moose/Meta/TypeConstraint/Parameterizable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_TYPECONSTRAINT_PARAMETERIZABLE';
  package Moose::Meta::TypeConstraint::Parameterizable;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  use metaclass;
  
  use parent 'Moose::Meta::TypeConstraint';
  use Moose::Meta::TypeConstraint::Parameterized;
  use Moose::Util::TypeConstraints ();
  
  use Moose::Util 'throw_exception';
  
  use Carp 'confess';
  
  __PACKAGE__->meta->add_attribute('constraint_generator' => (
      accessor  => 'constraint_generator',
      predicate => 'has_constraint_generator',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('inline_generator' => (
      accessor  => 'inline_generator',
      predicate => 'has_inline_generator',
      Class::MOP::_definition_context(),
  ));
  
  sub generate_constraint_for {
      my ($self, $type) = @_;
  
      return unless $self->has_constraint_generator;
  
      return $self->constraint_generator->($type->type_parameter)
          if $type->is_subtype_of($self->name);
  
      return $self->_can_coerce_constraint_from($type)
          if $self->has_coercion
          && $self->coercion->has_coercion_for_type($type->parent->name);
  
      return;
  }
  
  sub _can_coerce_constraint_from {
      my ($self, $type) = @_;
      my $coercion   = $self->coercion;
      my $constraint = $self->constraint_generator->($type->type_parameter);
      return sub {
          local $_ = $coercion->coerce($_);
          $constraint->(@_);
      };
  }
  
  sub generate_inline_for {
      my ($self, $type, $val) = @_;
  
      throw_exception( CannotGenerateInlineConstraint => parameterizable_type_object_name => $self->name,
                                                         type_name                        => $type->name,
                                                         value                            => $val,
                     )
          unless $self->has_inline_generator;
  
      return '( do { ' . $self->inline_generator->( $self, $type, $val ) . ' } )';
  }
  
  sub _parse_type_parameter {
      my ($self, $type_parameter) = @_;
      return Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($type_parameter);
  }
  
  sub parameterize {
      my ($self, $type_parameter) = @_;
  
      my $contained_tc = $self->_parse_type_parameter($type_parameter);
  
      ## The type parameter should be a subtype of the parent's type parameter
      ## if there is one.
  
      if(my $parent = $self->parent) {
          if($parent->can('type_parameter')) {
              unless ( $contained_tc->is_a_type_of($parent->type_parameter) ) {
                  throw_exception( ParameterIsNotSubtypeOfParent => type_parameter => $type_parameter,
                                                                    type_name      => $self->name,
                                 );
              }
          }
      }
  
      if ( $contained_tc->isa('Moose::Meta::TypeConstraint') ) {
          my $tc_name = $self->name . '[' . $contained_tc->name . ']';
          return Moose::Meta::TypeConstraint::Parameterized->new(
              name               => $tc_name,
              parent             => $self,
              type_parameter     => $contained_tc,
              parameterized_from => $self,
          );
      }
      else {
          confess("The type parameter must be a Moose meta type");
      }
  }
  
  
  1;
  
  # ABSTRACT: Type constraints which can take a parameter (ArrayRef)
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Parameterizable - Type constraints which can take a parameter (ArrayRef)
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class represents a parameterizable type constraint. This is a
  type constraint like C<ArrayRef> or C<HashRef>, that can be
  parameterized and made more specific by specifying a contained
  type. For example, instead of just an C<ArrayRef> of anything, you can
  specify that is an C<ArrayRef[Int]>.
  
  A parameterizable constraint should not be used as an attribute type
  constraint. Instead, when parameterized it creates a
  L<Moose::Meta::TypeConstraint::Parameterized> which should be used.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Parameterizable> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 METHODS
  
  This class is intentionally not documented because the API is
  confusing and needs some work.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_TYPECONSTRAINT_PARAMETERIZABLE

$fatpacked{"darwin-2level/Moose/Meta/TypeConstraint/Parameterized.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_TYPECONSTRAINT_PARAMETERIZED';
  package Moose::Meta::TypeConstraint::Parameterized;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  use Moose::Util::TypeConstraints;
  use Moose::Meta::TypeConstraint::Parameterizable;
  use Moose::Util 'throw_exception';
  
  use parent 'Moose::Meta::TypeConstraint';
  
  __PACKAGE__->meta->add_attribute('type_parameter' => (
      accessor  => 'type_parameter',
      predicate => 'has_type_parameter',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('parameterized_from' => (
      accessor   => 'parameterized_from',
      predicate  => 'has_parameterized_from',
      Class::MOP::_definition_context(),
  ));
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      return unless $other->isa(__PACKAGE__);
  
      return (
          $self->type_parameter->equals( $other->type_parameter )
              and
          $self->parent->equals( $other->parent )
      );
  }
  
  sub compile_type_constraint {
      my $self = shift;
  
      unless ( $self->has_type_parameter ) {
          throw_exception( CannotCreateHigherOrderTypeWithoutATypeParameter => type_name => $self->name );
      }
  
      my $type_parameter = $self->type_parameter;
  
      unless ( blessed $type_parameter && $type_parameter->isa('Moose::Meta::TypeConstraint') ) {
          throw_exception( TypeParameterMustBeMooseMetaType => type_name => $self->name );
      }
  
      foreach my $type (Moose::Util::TypeConstraints::get_all_parameterizable_types()) {
          if (my $constraint = $type->generate_constraint_for($self)) {
              $self->_set_constraint($constraint);
              return $self->SUPER::compile_type_constraint;
          }
      }
  
      # if we get here, then we couldn't
      # find a way to parameterize this type
      throw_exception( TypeConstraintCannotBeUsedForAParameterizableType => type_name        => $self->name,
                                                                            parent_type_name => $self->parent->name,
                     );
  }
  
  sub can_be_inlined {
      my $self = shift;
  
      return
             $self->has_parameterized_from
          && $self->parameterized_from->has_inline_generator
          && $self->type_parameter->can_be_inlined;
  }
  
  sub inline_environment {
      my $self = shift;
  
      return {
          ($self->has_parameterized_from
              ? (%{ $self->parameterized_from->inline_environment })
              : ()),
          ($self->has_type_parameter
              ? (%{ $self->type_parameter->inline_environment })
              : ()),
      };
  }
  
  sub _inline_check {
      my $self = shift;
  
      return unless $self->can_be_inlined;
  
      return $self->parameterized_from->generate_inline_for( $self->type_parameter, @_ );
  }
  
  sub create_child_type {
      my ($self, %opts) = @_;
      return Moose::Meta::TypeConstraint::Parameterizable->new(%opts, parent=>$self);
  }
  
  1;
  
  # ABSTRACT: Type constraints with a bound parameter (ArrayRef[Int])
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Parameterized - Type constraints with a bound parameter (ArrayRef[Int])
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 METHODS
  
  This class is intentionally not documented because the API is
  confusing and needs some work.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Parameterized> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_TYPECONSTRAINT_PARAMETERIZED

$fatpacked{"darwin-2level/Moose/Meta/TypeConstraint/Registry.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_TYPECONSTRAINT_REGISTRY';
  package Moose::Meta::TypeConstraint::Registry;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  
  use parent 'Class::MOP::Object';
  
  use Moose::Util 'throw_exception';
  
  __PACKAGE__->meta->add_attribute('parent_registry' => (
      reader    => 'get_parent_registry',
      writer    => 'set_parent_registry',
      predicate => 'has_parent_registry',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('type_constraints' => (
      reader  => 'type_constraints',
      default => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  sub new {
      my $class = shift;
      my $self  = $class->_new(@_);
      return $self;
  }
  
  sub has_type_constraint {
      my ($self, $type_name) = @_;
      ($type_name and exists $self->type_constraints->{$type_name}) ? 1 : 0
  }
  
  sub get_type_constraint {
      my ($self, $type_name) = @_;
      return unless defined $type_name;
      $self->type_constraints->{$type_name}
  }
  
  sub add_type_constraint {
      my ($self, $type) = @_;
  
      unless ( $type && blessed $type && $type->isa('Moose::Meta::TypeConstraint') ) {
          throw_exception( InvalidTypeConstraint => registry_object => $self,
                                                    type            => $type
                         );
      }
  
      $self->type_constraints->{$type->name} = $type;
  }
  
  sub find_type_constraint {
      my ($self, $type_name) = @_;
      return $self->get_type_constraint($type_name)
          if $self->has_type_constraint($type_name);
      return $self->get_parent_registry->find_type_constraint($type_name)
          if $self->has_parent_registry;
      return;
  }
  
  1;
  
  # ABSTRACT: registry for type constraints
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Registry - registry for type constraints
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class is a registry that maps type constraint names to
  L<Moose::Meta::TypeConstraint> objects.
  
  Currently, it is only used internally by
  L<Moose::Util::TypeConstraints>, which creates a single global
  registry.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Registry> is a subclass of
  L<Class::MOP::Object>.
  
  =head1 METHODS
  
  =head2 Moose::Meta::TypeConstraint::Registry->new(%options)
  
  This creates a new registry object based on the provided C<%options>:
  
  =over 4
  
  =item * parent_registry
  
  This is an optional L<Moose::Meta::TypeConstraint::Registry>
  object.
  
  =item * type_constraints
  
  This is hash reference of type names to type objects. This is
  optional. Constraints can be added to the registry after it is
  created.
  
  =back
  
  =head2 $registry->get_parent_registry
  
  Returns the registry's parent registry, if it has one.
  
  =head2 $registry->has_parent_registry
  
  Returns true if the registry has a parent.
  
  =head2 $registry->set_parent_registry($registry)
  
  Sets the parent registry.
  
  =head2 $registry->get_type_constraint($type_name)
  
  This returns the L<Moose::Meta::TypeConstraint> object from the
  registry for the given name, if one exists.
  
  =head2 $registry->has_type_constraint($type_name)
  
  Returns true if the registry has a type of the given name.
  
  =head2 $registry->add_type_constraint($type)
  
  Adds a new L<Moose::Meta::TypeConstraint> object to the registry.
  
  =head2 $registry->find_type_constraint($type_name)
  
  This method looks in the current registry for the named type. If the
  type is not found, then this method will look in the registry's
  parent, if it has one.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_TYPECONSTRAINT_REGISTRY

$fatpacked{"darwin-2level/Moose/Meta/TypeConstraint/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_TYPECONSTRAINT_ROLE';
  package Moose::Meta::TypeConstraint::Role;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  use metaclass;
  
  use B;
  use Moose::Util::TypeConstraints ();
  use Moose::Util ();
  
  use parent 'Moose::Meta::TypeConstraint';
  
  __PACKAGE__->meta->add_attribute('role' => (
      reader => 'role',
      Class::MOP::_definition_context(),
  ));
  
  my $inliner = sub {
      my $self = shift;
      my $val  = shift;
  
      return 'Moose::Util::does_role('
               . $val . ', '
               . B::perlstring($self->role)
           . ')';
  };
  
  sub new {
      my ( $class, %args ) = @_;
  
      $args{parent} = Moose::Util::TypeConstraints::find_type_constraint('Object');
  
      my $role_name = $args{role};
      $args{constraint} = sub { Moose::Util::does_role( $_[0], $role_name ) };
  
      $args{inlined} = $inliner;
  
      my $self = $class->SUPER::new( \%args );
  
      $self->compile_type_constraint();
  
      return $self;
  }
  
  sub parents {
      my $self = shift;
      return (
          $self->parent,
          map {
              # FIXME find_type_constraint might find a TC named after the role but that isn't really it
              # I did this anyway since it's a convention that preceded TypeConstraint::Role, and it should DWIM
              # if anybody thinks this problematic please discuss on IRC.
              # a possible fix is to add by attr indexing to the type registry to find types of a certain property
              # regardless of their name
              Moose::Util::TypeConstraints::find_type_constraint($_)
                  ||
              __PACKAGE__->new( role => $_, name => "__ANON__" )
          } @{ Class::MOP::class_of($self->role)->get_roles },
      );
  }
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      return unless defined $other;
      return unless $other->isa(__PACKAGE__);
  
      return $self->role eq $other->role;
  }
  
  sub is_a_type_of {
      my ($self, $type_or_name) = @_;
  
      my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      ($self->equals($type) || $self->is_subtype_of($type_or_name));
  }
  
  sub is_subtype_of {
      my ($self, $type_or_name_or_role ) = @_;
  
      if ( not ref $type_or_name_or_role ) {
          # it might be a role
          my $class = Class::MOP::class_of($self->role);
          return 1 if defined($class) && $class->does_role( $type_or_name_or_role );
      }
  
      my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name_or_role);
  
      return unless defined $type;
  
      if ( $type->isa(__PACKAGE__) ) {
          # if $type_or_name_or_role isn't a role, it might be the TC name of another ::Role type
          # or it could also just be a type object in this branch
          my $class = Class::MOP::class_of($self->role);
          return defined($class) && $class->does_role( $type->role );
      } else {
          # the only other thing we are a subtype of is Object
          $self->SUPER::is_subtype_of($type);
      }
  }
  
  sub create_child_type {
      my ($self, @args) = @_;
      return Moose::Meta::TypeConstraint->new(@args, parent => $self);
  }
  
  1;
  
  # ABSTRACT: Role/TypeConstraint parallel hierarchy
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Role - Role/TypeConstraint parallel hierarchy
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class represents type constraints for a role.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Role> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 METHODS
  
  =head2 Moose::Meta::TypeConstraint::Role->new(%options)
  
  This creates a new role type constraint based on the given
  C<%options>.
  
  It takes the same options as its parent, with two exceptions. First,
  it requires an additional option, C<role>, which is name of the
  constraint's role.  Second, it automatically sets the parent to the
  C<Object> type.
  
  The constructor also overrides the hand optimized type constraint with
  one it creates internally.
  
  =head2 $constraint->role
  
  Returns the role name associated with the constraint.
  
  =head2 $constraint->parents
  
  Returns all the type's parent types, corresponding to the roles that
  its role does.
  
  =head2 $constraint->is_subtype_of($type_name_or_object)
  
  If the given type is also a role type, then this checks that the
  type's role does the other type's role.
  
  Otherwise it falls back to the implementation in
  L<Moose::Meta::TypeConstraint>.
  
  =head2 $constraint->create_child_type(%options)
  
  This returns a new L<Moose::Meta::TypeConstraint> object with the type
  as its parent.
  
  Note that it does I<not> return a C<Moose::Meta::TypeConstraint::Role>
  object!
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_TYPECONSTRAINT_ROLE

$fatpacked{"darwin-2level/Moose/Meta/TypeConstraint/Union.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_META_TYPECONSTRAINT_UNION';
  package Moose::Meta::TypeConstraint::Union;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  use metaclass;
  
  use Moose::Meta::TypeCoercion::Union;
  
  use List::Util 1.33 qw(first all);
  
  use parent 'Moose::Meta::TypeConstraint';
  
  __PACKAGE__->meta->add_attribute('type_constraints' => (
      accessor  => 'type_constraints',
      default   => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  sub new {
      my ($class, %options) = @_;
  
      my $name = join '|' => sort { $a cmp $b }
          map { $_->name } @{ $options{type_constraints} };
  
      my $self = $class->SUPER::new(
          name => $name,
          %options,
      );
  
      $self->_set_constraint( $self->_compiled_type_constraint );
  
      return $self;
  }
  
  # XXX - this is a rather gross implementation of laziness for the benefit of
  # MX::Types. If we try to call ->has_coercion on the objects during object
  # construction, this does not work when defining a recursive constraint with
  # MX::Types.
  sub coercion {
      my $self = shift;
  
      return $self->{coercion} if exists $self->{coercion};
  
      # Using any instead of grep here causes a weird error with some corner
      # cases when MX::Types is in use. See RT #61001.
      if ( grep { $_->has_coercion } @{ $self->type_constraints } ) {
          return $self->{coercion} = Moose::Meta::TypeCoercion::Union->new(
              type_constraint => $self );
      }
      else {
          return $self->{coercion} = undef;
      }
  }
  
  sub has_coercion {
      return defined $_[0]->coercion;
  }
  
  sub _actually_compile_type_constraint {
      my $self = shift;
  
      my @constraints = @{ $self->type_constraints };
  
      return sub {
          my $value = shift;
          foreach my $type (@constraints) {
              return 1 if $type->check($value);
          }
          return undef;
      };
  }
  
  sub can_be_inlined {
      my $self = shift;
  
      # This was originally done with all() from List::MoreUtils, but that
      # caused some sort of bizarro parsing failure under 5.10.
      for my $tc ( @{ $self->type_constraints } ) {
          return 0 unless $tc->can_be_inlined;
      }
  
      return 1;
  }
  
  sub _inline_check {
      my $self = shift;
      my $val  = shift;
  
      return '('
                 . (
                    join ' || ', map { '(' . $_->_inline_check($val) . ')' }
                    @{ $self->type_constraints }
                   )
             . ')';
  }
  
  sub inline_environment {
      my $self = shift;
  
      return { map { %{ $_->inline_environment } }
              @{ $self->type_constraints } };
  }
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      return unless $other->isa(__PACKAGE__);
  
      my @self_constraints  = @{ $self->type_constraints };
      my @other_constraints = @{ $other->type_constraints };
  
      return unless @self_constraints == @other_constraints;
  
      # FIXME presort type constraints for efficiency?
      constraint: foreach my $constraint ( @self_constraints ) {
          for ( my $i = 0; $i < @other_constraints; $i++ ) {
              if ( $constraint->equals($other_constraints[$i]) ) {
                  splice @other_constraints, $i, 1;
                  next constraint;
              }
          }
      }
  
      return @other_constraints == 0;
  }
  
  sub parent {
      my $self = shift;
  
      my ($first, @rest) = @{ $self->type_constraints };
  
      for my $parent ( $first->_collect_all_parents ) {
          return $parent if all { $_->is_a_type_of($parent) } @rest;
      }
  
      return;
  }
  
  sub validate {
      my ($self, $value) = @_;
      my $message;
      foreach my $type (@{$self->type_constraints}) {
          my $err = $type->validate($value);
          return unless defined $err;
          $message .= ($message ? ' and ' : '') . $err
              if defined $err;
      }
      return ($message . ' in (' . $self->name . ')') ;
  }
  
  sub find_type_for {
      my ($self, $value) = @_;
  
      return first { $_->check($value) } @{ $self->type_constraints };
  }
  
  sub is_a_type_of {
      my ($self, $type_name) = @_;
  
      return all { $_->is_a_type_of($type_name) } @{ $self->type_constraints };
  }
  
  sub is_subtype_of {
      my ($self, $type_name) = @_;
  
      return all { $_->is_subtype_of($type_name) } @{ $self->type_constraints };
  }
  
  sub create_child_type {
      my ( $self, %opts ) = @_;
  
      my $constraint
          = Moose::Meta::TypeConstraint->new( %opts, parent => $self );
  
      # if we have a type constraint union, and no
      # type check, this means we are just aliasing
      # the union constraint, which means we need to
      # handle this differently.
      # - SL
      if ( not( defined $opts{constraint} )
          && $self->has_coercion ) {
          $constraint->coercion(
              Moose::Meta::TypeCoercion::Union->new(
                  type_constraint => $self,
              )
          );
      }
  
      return $constraint;
  }
  
  1;
  
  # ABSTRACT: A union of Moose type constraints
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Union - A union of Moose type constraints
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This metaclass represents a union of type constraints. A union takes
  multiple type constraints, and is true if any one of its member
  constraints is true.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Union> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 METHODS
  
  =head2 Moose::Meta::TypeConstraint::Union->new(%options)
  
  This creates a new class type constraint based on the given
  C<%options>.
  
  It takes the same options as its parent. It also requires an
  additional option, C<type_constraints>. This is an array reference
  containing the L<Moose::Meta::TypeConstraint> objects that are the
  members of the union type. The C<name> option defaults to the names
  all of these member types sorted and then joined by a pipe (|).
  
  The constructor sets the implementation of the constraint so that is
  simply calls C<check> on the newly created object.
  
  Finally, the constructor also makes sure that the object's C<coercion>
  attribute is a L<Moose::Meta::TypeCoercion::Union> object.
  
  =head2 $constraint->type_constraints
  
  This returns the array reference of C<type_constraints> provided to
  the constructor.
  
  =head2 $constraint->parent
  
  This returns the nearest common ancestor of all the components of the union.
  
  =head2 $constraint->check($value)
  
  =head2 $constraint->validate($value)
  
  These two methods simply call the relevant method on each of the
  member type constraints in the union. If any type accepts the value,
  the value is valid.
  
  With C<validate> the error message returned includes all of the error
  messages returned by the member type constraints.
  
  =head2 $constraint->equals($type_name_or_object)
  
  A type is considered equal if it is also a union type, and the two
  unions have the same member types.
  
  =head2 $constraint->find_type_for($value)
  
  This returns the first member type constraint for which C<check($value)> is
  true, allowing you to determine which of the Union's member type constraints
  a given value matches.
  
  =head2 $constraint->is_a_type_of($type_name_or_object)
  
  This returns true if all of the member type constraints return true
  for the C<is_a_type_of> method.
  
  =head2 $constraint->is_subtype_of
  
  This returns true if all of the member type constraints return true
  for the C<is_subtype_of> method.
  
  =head2 $constraint->create_child_type(%options)
  
  This returns a new L<Moose::Meta::TypeConstraint> object with the type
  as its parent.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_META_TYPECONSTRAINT_UNION

$fatpacked{"darwin-2level/Moose/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_OBJECT';
  package Moose::Object;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Carp ();
  use Devel::GlobalDestruction ();
  use MRO::Compat ();
  use Scalar::Util ();
  use Try::Tiny ();
  
  use Moose::Util ();
  
  use if ( not our $__mx_is_compiled ), 'Moose::Meta::Class';
  use if ( not our $__mx_is_compiled ), metaclass => 'Moose::Meta::Class';
  
  sub new {
      my $class = shift;
      my $real_class = Scalar::Util::blessed($class) || $class;
  
      my $params = $real_class->BUILDARGS(@_);
  
      return Class::MOP::Class->initialize($real_class)->new_object($params);
  }
  
  sub BUILDARGS {
      my $class = shift;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              Moose::Util::throw_exception( "SingleParamsToNewMustBeHashRef" );
          }
          return { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          Carp::carp(
              "The new() method for $class expects a hash reference or a key/value list."
                  . " You passed an odd number of arguments" );
          return { @_, undef };
      }
      else {
          return { @_ };
      }
  }
  
  sub BUILDALL {
      # NOTE: we ask Perl if we even
      # need to do this first, to avoid
      # extra meta level calls
      return unless $_[0]->can('BUILD');
      my ($self, $params) = @_;
      return if $params->{__no_BUILD__};
      foreach my $method (reverse Class::MOP::class_of($self)->find_all_methods_by_name('BUILD')) {
          $method->{code}->execute($self, $params);
      }
  }
  
  sub DEMOLISHALL {
      my $self = shift;
      my ($in_global_destruction) = @_;
  
      # NOTE: we ask Perl if we even
      # need to do this first, to avoid
      # extra meta level calls
      return unless $self->can('DEMOLISH');
  
      my @isa;
      if ( my $meta = Class::MOP::class_of($self ) ) {
          @isa = $meta->linearized_isa;
      } else {
          # We cannot count on being able to retrieve a previously made
          # metaclass, _or_ being able to make a new one during global
          # destruction. However, we should still be able to use mro at
          # that time (at least tests suggest so ;)
          my $class_name = ref $self;
          @isa = @{ mro::get_linear_isa($class_name) }
      }
  
      foreach my $class (@isa) {
          no strict 'refs';
          my $demolish = *{"${class}::DEMOLISH"}{CODE};
          $self->$demolish($in_global_destruction)
              if defined $demolish;
      }
  }
  
  sub DESTROY {
      my $self = shift;
  
      local $?;
  
      # < doy> if the destructor is being called because an exception is thrown, then $@ will be set
      # < doy> but if DEMOLISH does an eval which succeeds, that will clear $@
      # < doy> which is broken
      # < doy> try::tiny implicitly localizes $@ in the try block, which fixes that
      Try::Tiny::try {
          $self->DEMOLISHALL(Devel::GlobalDestruction::in_global_destruction);
      }
      Try::Tiny::catch {
          die $_;
      };
  
      return;
  }
  
  # support for UNIVERSAL::DOES ...
  BEGIN {
      my $does = UNIVERSAL->can("DOES") ? "SUPER::DOES" : "isa";
      eval 'sub DOES {
          my ( $self, $class_or_role_name ) = @_;
          return $self->'.$does.'($class_or_role_name)
              || $self->does($class_or_role_name);
      }';
  }
  
  # new does() methods will be created
  # as appropriate see Moose::Meta::Role
  sub does {
      my ($self, $role_name) = @_;
      my $class = Scalar::Util::blessed($self) || $self;
      my $meta = Class::MOP::Class->initialize($class);
      (defined $role_name)
          || Moose::Util::throw_exception( DoesRequiresRoleName => class_name => $meta->name );
      return 1 if $meta->can('does_role') && $meta->does_role($role_name);
      return 0;
  }
  
  sub dump {
      my $self = shift;
      require Data::Dumper;
      local $Data::Dumper::Maxdepth = shift if @_;
      Data::Dumper::Dumper $self;
  }
  
  1;
  
  # ABSTRACT: The base object for Moose
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Object - The base object for Moose
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 DESCRIPTION
  
  This class is the default base class for all Moose-using classes. When
  you C<use Moose> in this class, your class will inherit from this
  class.
  
  It provides a default constructor and destructor, which run all of the
  C<BUILD> and C<DEMOLISH> methods in the inheritance hierarchy,
  respectively.
  
  You don't actually I<need> to inherit from this in order to use Moose,
  but it makes it easier to take advantage of all of Moose's features.
  
  =head1 METHODS
  
  =head2 Moose::Object->new(%params|$params)
  
  This method calls C<< $class->BUILDARGS(@_) >>, and then creates a new
  instance of the appropriate class. Once the instance is created, it
  calls C<< $instance->BUILD($params) >> for each C<BUILD> method in the
  inheritance hierarchy.
  
  =head2 Moose::Object->BUILDARGS(%params|$params)
  
  The default implementation of this method accepts a hash or hash
  reference of named parameters. If it receives a single argument that
  I<isn't> a hash reference it throws an error.
  
  You can override this method in your class to handle other types of
  options passed to the constructor.
  
  This method should always return a hash reference of named options.
  
  =head2 $object->does($role_name)
  
  This returns true if the object does the given role.
  
  =head2 $object->DOES($class_or_role_name)
  
  This is a Moose role-aware implementation of L<UNIVERSAL/DOES>.
  
  This is effectively the same as writing:
  
    $object->does($name) || $object->isa($name)
  
  This method will work with Perl 5.8, which did not implement
  C<UNIVERSAL::DOES>.
  
  =head2 $object->dump($maxdepth)
  
  =for stopwords ing
  
  This is a handy utility for L<Data::Dumper>ing an object. By default,
  there is no maximum depth.
  
  =head2 $object->DESTROY
  
  A default destructor is provided, which calls
  C<< $instance->DEMOLISH($in_global_destruction) >> for each C<DEMOLISH>
  method in the inheritance hierarchy.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_OBJECT

$fatpacked{"darwin-2level/Moose/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_ROLE';
  use strict;
  use warnings;
  package Moose::Role;
  our $VERSION = '2.2011';
  
  use Scalar::Util ();
  use Carp ();
  use Class::Load  'is_class_loaded';
  use Module::Runtime 'module_notional_filename';
  
  use Sub::Exporter;
  
  use Moose       ();
  use Moose::Util 'throw_exception';
  
  use Moose::Exporter;
  use Moose::Meta::Role;
  use Moose::Util::TypeConstraints;
  
  sub extends {
      throw_exception("RolesDoNotSupportExtends");
  }
  
  sub with {
      Moose::Util::apply_all_roles( shift, @_ );
  }
  
  sub requires {
      my $meta = shift;
      throw_exception( MustSpecifyAtleastOneMethod => role_name => $meta->name ) unless @_;
      $meta->add_required_methods(@_);
  }
  
  sub excludes {
      my $meta = shift;
      throw_exception( MustSpecifyAtleastOneRole => role_name => $meta->name ) unless @_;
      $meta->add_excluded_roles(@_);
  }
  
  sub has {
      my $meta = shift;
      my $name = shift;
      throw_exception( InvalidHasProvidedInARole => role_name       => $meta->name,
                                                    attribute_name  => $name,
                     )
          if @_ == 1;
      my %context = Moose::Util::_caller_info;
      $context{context} = 'has declaration';
      $context{type} = 'role';
      my %options = ( definition_context => \%context, @_ );
      my $attrs = ( ref($name) eq 'ARRAY' ) ? $name : [ ($name) ];
      $meta->add_attribute( $_, %options ) for @$attrs;
  }
  
  sub _add_method_modifier {
      my $type = shift;
      my $meta = shift;
  
      if ( ref($_[0]) eq 'Regexp' ) {
          throw_exception( RolesDoNotSupportRegexReferencesForMethodModifiers => modifier_type => $type,
                                                                                 role_name     => $meta->name,
                         );
      }
  
      Moose::Util::add_method_modifier($meta, $type, \@_);
  }
  
  sub before { _add_method_modifier('before', @_) }
  
  sub after  { _add_method_modifier('after',  @_) }
  
  sub around { _add_method_modifier('around', @_) }
  
  # see Moose.pm for discussion
  sub super {
      return unless $Moose::SUPER_BODY;
      $Moose::SUPER_BODY->(@Moose::SUPER_ARGS);
  }
  
  sub override {
      my $meta = shift;
      my ( $name, $code ) = @_;
      $meta->add_override_method_modifier( $name, $code );
  }
  
  sub inner {
      throw_exception("RolesDoNotSupportInner");
  }
  
  sub augment {
      throw_exception("RolesDoNotSupportAugment");
  }
  
  Moose::Exporter->setup_import_methods(
      with_meta => [
          qw( with requires excludes has before after around override )
      ],
      as_is => [
          qw( extends super inner augment ),
          'Carp::confess',
          'Scalar::Util::blessed',
      ],
  );
  
  sub init_meta {
      shift;
      my %args = @_;
  
      my $role = $args{for_class};
  
      unless ($role) {
          require Moose;
          throw_exception( InitMetaRequiresClass => params => \%args );
      }
  
      my $metaclass = $args{metaclass} || "Moose::Meta::Role";
      my $meta_name = exists $args{meta_name} ? $args{meta_name} : 'meta';
  
      throw_exception( MetaclassNotLoaded => class_name => $metaclass )
          unless is_class_loaded($metaclass);
  
      throw_exception( MetaclassMustBeASubclassOfMooseMetaRole => role_name => $metaclass )
          unless $metaclass->isa('Moose::Meta::Role');
  
      # make a subtype for each Moose role
      role_type $role unless find_type_constraint($role);
  
      my $meta;
      if ( $meta = Class::MOP::get_metaclass_by_name($role) ) {
          unless ( $meta->isa("Moose::Meta::Role") ) {
              if ( $meta->isa('Moose::Meta::Class') ) {
                  throw_exception( MetaclassIsAClassNotASubclassOfGivenMetaclass => class_name => $role,
                                                                                    metaclass  => $metaclass,
                                 );
              } else {
                  throw_exception( MetaclassIsNotASubclassOfGivenMetaclass => class_name => $role,
                                                                              metaclass  => $metaclass,
                                 );
              }
          }
      }
      else {
          $meta = $metaclass->initialize($role);
          my $filename = module_notional_filename($meta->name);
          $INC{$filename} = '(set by Moose)'
              unless exists $INC{$filename};
      }
  
      if (defined $meta_name) {
          # also check for inherited non moose 'meta' method?
          my $existing = $meta->get_method($meta_name);
          if ($existing && !$existing->isa('Class::MOP::Method::Meta')) {
              Carp::cluck "Moose::Role is overwriting an existing method named "
                        . "$meta_name in role $role with a method "
                        . "which returns the class's metaclass. If this is "
                        . "actually what you want, you should remove the "
                        . "existing method, otherwise, you should rename or "
                        . "disable this generated method using the "
                        . "'-meta_name' option to 'use Moose::Role'.";
          }
          $meta->_add_meta_method($meta_name);
      }
  
      return $meta;
  }
  
  1;
  
  # ABSTRACT: The Moose Role
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Role - The Moose Role
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 SYNOPSIS
  
    package Eq;
    use Moose::Role; # automatically turns on strict and warnings
  
    requires 'equal';
  
    sub no_equal {
        my ($self, $other) = @_;
        !$self->equal($other);
    }
  
    # ... then in your classes
  
    package Currency;
    use Moose; # automatically turns on strict and warnings
  
    with 'Eq';
  
    sub equal {
        my ($self, $other) = @_;
        $self->as_float == $other->as_float;
    }
  
    # ... and also
  
    package Comparator;
    use Moose;
  
    has compare_to => (
        is      => 'ro',
        does    => 'Eq',
        handles => 'Eq',
    );
  
    # ... which allows
  
    my $currency1 = Currency->new(...);
    my $currency2 = Currency->new(...);
    Comparator->new(compare_to => $currency1)->equal($currency2);
  
  =head1 DESCRIPTION
  
  The concept of roles is documented in L<Moose::Manual::Roles>. This document
  serves as API documentation.
  
  =head1 EXPORTED FUNCTIONS
  
  Moose::Role currently supports all of the functions that L<Moose> exports, but
  differs slightly in how some items are handled (see L</CAVEATS> below for
  details).
  
  Moose::Role also offers two role-specific keyword exports:
  
  =head2 requires (@method_names)
  
  Roles can require that certain methods are implemented by any class which
  C<does> the role.
  
  Note that attribute accessors also count as methods for the purposes
  of satisfying the requirements of a role.
  
  =head2 excludes (@role_names)
  
  Roles can C<exclude> other roles, in effect saying "I can never be combined
  with these C<@role_names>". This is a feature which should not be used
  lightly.
  
  =head2 no Moose::Role
  
  Moose::Role offers a way to remove the keywords it exports, through the
  C<unimport> method. You simply have to say C<no Moose::Role> at the bottom of
  your code for this to work.
  
  =head1 METACLASS
  
  When you use Moose::Role, you can specify traits which will be applied to your
  role metaclass:
  
      use Moose::Role -traits => 'My::Trait';
  
  This is very similar to the attribute traits feature. When you do
  this, your class's C<meta> object will have the specified traits
  applied to it. See L<Moose/Metaclass and Trait Name Resolution> for more
  details.
  
  All role metaclasses (note, not the role itself) extend L<Moose::Meta::Role>.
  You can test if a package is a role or not using L<Moose::Util/is_role>.
  
  =head1 APPLYING ROLES
  
  In addition to being applied to a class using the 'with' syntax (see
  L<Moose::Manual::Roles>) and using the L<Moose::Util> 'apply_all_roles'
  method, roles may also be applied to an instance of a class using
  L<Moose::Util> 'apply_all_roles' or the role's metaclass:
  
     MyApp::Test::SomeRole->meta->apply( $instance );
  
  Doing this creates a new, mutable, anonymous subclass, applies the role to that,
  and reblesses. In a debugger, for example, you will see class names of the
  form C< Moose::Meta::Class::__ANON__::SERIAL::6 >, which means that doing a
  'ref' on your instance may not return what you expect. See L<Moose::Object> for
  'DOES'.
  
  Additional params may be added to the new instance by providing
  'rebless_params'. See L<Moose::Meta::Role::Application::ToInstance>.
  
  =head1 CAVEATS
  
  Role support has only a few caveats:
  
  =over 4
  
  =item *
  
  Roles cannot use the C<extends> keyword; it will throw an exception for now.
  The same is true of the C<augment> and C<inner> keywords (not sure those
  really make sense for roles). All other Moose keywords will be I<deferred>
  so that they can be applied to the consuming class.
  
  =item *
  
  Role composition does its best to B<not> be order-sensitive when it comes to
  conflict resolution and requirements detection. However, it is order-sensitive
  when it comes to method modifiers. All before/around/after modifiers are
  included whenever a role is composed into a class, and then applied in the order
  in which the roles are used. This also means that there is no conflict for
  before/around/after modifiers.
  
  In most cases, this will be a non-issue; however, it is something to keep in
  mind when using method modifiers in a role. You should never assume any
  ordering.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_ROLE

$fatpacked{"darwin-2level/Moose/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_UTIL';
  package Moose::Util;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Module::Runtime 0.014 'use_package_optimistically', 'module_notional_filename';
  use Data::OptList;
  use Sub::Exporter;
  use Scalar::Util 'blessed';
  use List::Util 1.33 qw(first any all);
  use overload ();
  use Try::Tiny;
  
  
  my @exports = qw[
      find_meta
      is_role
      does_role
      search_class_by_role
      ensure_all_roles
      apply_all_roles
      with_traits
      get_all_init_args
      get_all_attribute_values
      resolve_metatrait_alias
      resolve_metaclass_alias
      add_method_modifier
      english_list
      meta_attribute_alias
      meta_class_alias
      throw_exception
  ];
  
  Sub::Exporter::setup_exporter({
      exports => \@exports,
      groups  => { all => \@exports }
  });
  
  # Things that need to ->import from Moose::Util
  # should be loaded after Moose::Util defines ->import
  require Class::MOP;
  
  sub throw_exception {
      my ($class_name, @args_to_exception) = @_;
      my $class = "Moose::Exception::$class_name";
      _load_user_class( $class );
      die $class->new( @args_to_exception );
  }
  
  ## some utils for the utils ...
  
  sub find_meta { Class::MOP::class_of(@_) }
  
  ## the functions ...
  
  sub is_role {
      my $package_or_obj = shift;
  
      my $meta = find_meta($package_or_obj);
      return if not $meta;
      return $meta->isa('Moose::Meta::Role');
  }
  
  sub does_role {
      my ($class_or_obj, $role) = @_;
  
      if (try { $class_or_obj->isa('Moose::Object') }) {
          return $class_or_obj->does($role);
      }
  
      my $meta = find_meta($class_or_obj);
  
      return unless defined $meta;
      return unless $meta->can('does_role');
      return 1 if $meta->does_role($role);
      return;
  }
  
  sub search_class_by_role {
      my ($class_or_obj, $role) = @_;
  
      my $meta = find_meta($class_or_obj);
  
      return unless defined $meta;
  
      my $role_name = blessed $role ? $role->name : $role;
  
      foreach my $class ($meta->class_precedence_list) {
  
          my $_meta = find_meta($class);
  
          next unless defined $_meta;
  
          foreach my $role (@{ $_meta->roles || [] }) {
              return $class if $role->name eq $role_name;
          }
      }
  
      return;
  }
  
  # this can possibly behave in unexpected ways because the roles being composed
  # before being applied could differ from call to call; I'm not sure if or how
  # to document this possible quirk.
  sub ensure_all_roles {
      my $applicant = shift;
      _apply_all_roles($applicant, sub { !does_role($applicant, $_) }, @_);
  }
  
  sub apply_all_roles {
      my $applicant = shift;
      _apply_all_roles($applicant, undef, @_);
  }
  
  sub _apply_all_roles {
      my $applicant = shift;
      my $role_filter = shift;
  
      unless (@_) {
          require Moose;
          throw_exception( MustSpecifyAtleastOneRoleToApplicant => applicant => $applicant );
      }
  
      # If @_ contains role meta objects, mkopt will think that they're values,
      # because they're references.  In other words (roleobj1, roleobj2,
      # roleobj3) will become [ [ roleobj1, roleobj2 ], [ roleobj3, undef ] ]
      # -- this is no good.  We'll preprocess @_ first to eliminate the potential
      # bug.
      # -- rjbs, 2011-04-08
      my $roles = Data::OptList::mkopt( [@_], {
        moniker   => 'role',
        name_test => sub {
          ! ref $_[0] or blessed($_[0]) && $_[0]->isa('Moose::Meta::Role')
        }
      });
  
      my @role_metas;
      foreach my $role (@$roles) {
          my $meta;
  
          if ( blessed $role->[0] ) {
              $meta = $role->[0];
          }
          else {
              _load_user_class( $role->[0] , $role->[1] );
              $meta = find_meta( $role->[0] );
          }
  
          unless ($meta && $meta->isa('Moose::Meta::Role') ) {
              throw_exception( CanOnlyConsumeRole => role_name => $role->[0] );
          }
  
          push @role_metas, [ $meta, $role->[1] ];
      }
  
      if ( defined $role_filter ) {
          @role_metas = grep { local $_ = $_->[0]; $role_filter->() } @role_metas;
      }
  
      return unless @role_metas;
  
      _load_user_class($applicant)
          unless blessed($applicant)
              || Class::MOP::class_of($applicant);
  
      my $meta = ( blessed $applicant ? $applicant : Moose::Meta::Class->initialize($applicant) );
  
      if ( scalar @role_metas == 1 ) {
          my ( $role, $params ) = @{ $role_metas[0] };
          $role->apply( $meta, ( defined $params ? %$params : () ) );
      }
      else {
          Moose::Meta::Role->combine(@role_metas)->apply($meta);
      }
  }
  
  sub with_traits {
      my ($class, @roles) = @_;
      return $class unless @roles;
      return Moose::Meta::Class->create_anon_class(
          superclasses => [$class],
          roles        => \@roles,
          cache        => 1,
      )->name;
  }
  
  # instance deconstruction ...
  
  sub get_all_attribute_values {
      my ($class, $instance) = @_;
      return +{
          map { $_->name => $_->get_value($instance) }
              grep { $_->has_value($instance) }
                  $class->get_all_attributes
      };
  }
  
  sub get_all_init_args {
      my ($class, $instance) = @_;
      return +{
          map { $_->init_arg => $_->get_value($instance) }
              grep { $_->has_value($instance) }
                  grep { defined($_->init_arg) }
                      $class->get_all_attributes
      };
  }
  
  sub resolve_metatrait_alias {
      return resolve_metaclass_alias( @_, trait => 1 );
  }
  
  sub _build_alias_package_name {
      my ($type, $name, $trait) = @_;
      return 'Moose::Meta::'
           . $type
           . '::Custom::'
           . ( $trait ? 'Trait::' : '' )
           . $name;
  }
  
  {
      my %cache;
  
      sub resolve_metaclass_alias {
          my ( $type, $metaclass_name, %options ) = @_;
  
          my $cache_key = $type . q{ } . ( $options{trait} ? '-Trait' : '' );
          return $cache{$cache_key}{$metaclass_name}
              if $cache{$cache_key}{$metaclass_name};
  
          my $possible_full_name = _build_alias_package_name(
              $type, $metaclass_name, $options{trait}
          );
  
          my @possible = ($possible_full_name, $metaclass_name);
          for my $package (@possible) {
              use_package_optimistically($package);
              if ($package->can('register_implementation')) {
                  return $cache{$cache_key}{$metaclass_name} =
                      $package->register_implementation;
              }
              elsif (find_meta($package)) {
                  return $cache{$cache_key}{$metaclass_name} = $package;
              }
          }
  
          throw_exception( CannotLocatePackageInINC => possible_packages => _english_list_or(@possible),
                                                       INC               => \@INC,
                                                       type              => $type,
                                                       metaclass_name    => $metaclass_name,
                                                       params            => \%options
                         );
      }
  }
  
  sub add_method_modifier {
      my ( $class_or_obj, $modifier_name, $args ) = @_;
      my $meta
          = $class_or_obj->can('add_before_method_modifier')
          ? $class_or_obj
          : find_meta($class_or_obj);
      my $code                = pop @{$args};
      my $add_modifier_method = 'add_' . $modifier_name . '_method_modifier';
      if ( my $method_modifier_type = ref( $args->[0] ) ) {
          if ( $method_modifier_type eq 'Regexp' ) {
              my @all_methods = $meta->get_all_methods;
              my @matched_methods
                  = grep { $_->name =~ $args->[0] } @all_methods;
              $meta->$add_modifier_method( $_->name, $code )
                  for @matched_methods;
          }
          elsif ($method_modifier_type eq 'ARRAY') {
              $meta->$add_modifier_method( $_, $code ) for @{$args->[0]};
          }
          else {
              throw_exception( IllegalMethodTypeToAddMethodModifier => class_or_object => $class_or_obj,
                                                                       modifier_name   => $modifier_name,
                                                                       params          => $args
                             );
          }
      }
      else {
          $meta->$add_modifier_method( $_, $code ) for @{$args};
      }
  }
  
  sub english_list {
      _english_list_and(@_);
  }
  
  sub _english_list_and {
      _english_list('and', \@_);
  }
  
  sub _english_list_or {
      _english_list('or', \@_);
  }
  
  sub _english_list {
      my ($conjunction, $items) = @_;
  
      my @items = sort @$items;
  
      return $items[0] if @items == 1;
      return "$items[0] $conjunction $items[1]" if @items == 2;
  
      my $tail = pop @items;
      my $list = join ', ', @items;
      $list .= ", $conjunction " . $tail;
  
      return $list;
  }
  
  sub _caller_info {
      my $level = @_ ? ($_[0] + 1) : 2;
      my %info;
      @info{qw(package file line)} = caller($level);
      return %info;
  }
  
  sub _create_alias {
      my ($type, $name, $trait, $for) = @_;
      my $package = _build_alias_package_name($type, $name, $trait);
      Class::MOP::Class->initialize($package)->add_method(
          register_implementation => sub { $for }
      );
  }
  
  sub meta_attribute_alias {
      my ($to, $from) = @_;
      $from ||= caller;
      my $meta = Class::MOP::class_of($from);
      my $trait = $meta->isa('Moose::Meta::Role');
      _create_alias('Attribute', $to, $trait, $from);
  }
  
  sub meta_class_alias {
      my ($to, $from) = @_;
      $from ||= caller;
      my $meta = Class::MOP::class_of($from);
      my $trait = $meta->isa('Moose::Meta::Role');
      _create_alias('Class', $to, $trait, $from);
  }
  
  sub _load_user_class {
      my ($class, $opts) = @_;
      &use_package_optimistically(
          $class,
          $opts && $opts->{-version} ? $opts->{-version} : ()
      );
  }
  
  # XXX - this should be added to Params::Util
  sub _STRINGLIKE0 ($) {
      return 0 if !defined $_[0];
      return 1 if !ref $_[0];
      return 1 if overload::OverloadedStringify($_[0]);
      return 0;
  }
  
  sub _reconcile_roles_for_metaclass {
      my ($class_meta_name, $super_meta_name) = @_;
  
      my @role_differences = _role_differences(
          $class_meta_name, $super_meta_name,
      );
  
      # handle the case where we need to fix compatibility between a class and
      # its parent, but all roles in the class are already also done by the
      # parent
      # see t/metaclasses/metaclass_compat_no_fixing_bug.t
      return $super_meta_name
          unless @role_differences;
  
      return Moose::Meta::Class->create_anon_class(
          superclasses => [$super_meta_name],
          roles        => [map { $_->name } @role_differences],
          cache        => 1,
      )->name;
  }
  
  sub _role_differences {
      my ($class_meta_name, $super_meta_name) = @_;
      my @super_role_metas = map {
          $_->isa('Moose::Meta::Role::Composite')
              ? (@{ $_->get_roles })
              : ($_)
      } $super_meta_name->meta->can('_roles_with_inheritance')
          ? $super_meta_name->meta->_roles_with_inheritance
      : $super_meta_name->meta->can('roles')
          ? @{ $super_meta_name->meta->roles }
      :     ();
      my @role_metas = map {
          $_->isa('Moose::Meta::Role::Composite')
              ? (@{ $_->get_roles })
              : ($_)
      } $class_meta_name->meta->can('_roles_with_inheritance')
          ? $class_meta_name->meta->_roles_with_inheritance
      : $class_meta_name->meta->can('roles')
          ? @{ $class_meta_name->meta->roles }
      :     ();
      my @differences;
      for my $role_meta (@role_metas) {
          push @differences, $role_meta
              unless any { $_->name eq $role_meta->name } @super_role_metas;
      }
      return @differences;
  }
  
  sub _classes_differ_by_roles_only {
      my ( $self_meta_name, $super_meta_name ) = @_;
  
      my $common_base_name
          = _find_common_base( $self_meta_name, $super_meta_name );
  
      return unless defined $common_base_name;
  
      my @super_meta_name_ancestor_names
          = _get_ancestors_until( $super_meta_name, $common_base_name );
      my @class_meta_name_ancestor_names
          = _get_ancestors_until( $self_meta_name, $common_base_name );
  
      return
          unless all { _is_role_only_subclass($_) }
          @super_meta_name_ancestor_names,
          @class_meta_name_ancestor_names;
  
      return 1;
  }
  
  sub _find_common_base {
      my ($meta1, $meta2) = map { Class::MOP::class_of($_) } @_;
      return unless defined $meta1 && defined $meta2;
  
      # FIXME? This doesn't account for multiple inheritance (not sure
      # if it needs to though). For example, if somewhere in $meta1's
      # history it inherits from both ClassA and ClassB, and $meta2
      # inherits from ClassB & ClassA, does it matter? And what crazy
      # fool would do that anyway?
  
      my %meta1_parents = map { $_ => 1 } $meta1->linearized_isa;
  
      return first { $meta1_parents{$_} } $meta2->linearized_isa;
  }
  
  sub _get_ancestors_until {
      my ($start_name, $until_name) = @_;
  
      my @ancestor_names;
      for my $ancestor_name (Class::MOP::class_of($start_name)->linearized_isa) {
          last if $ancestor_name eq $until_name;
          push @ancestor_names, $ancestor_name;
      }
      return @ancestor_names;
  }
  
  sub _is_role_only_subclass {
      my ($meta_name) = @_;
      my $meta = Class::MOP::Class->initialize($meta_name);
      my @parent_names = $meta->superclasses;
  
      # XXX: don't feel like messing with multiple inheritance here... what would
      # that even do?
      return unless @parent_names == 1;
      my ($parent_name) = @parent_names;
      my $parent_meta = Class::MOP::Class->initialize($parent_name);
  
      # only get the roles attached to this particular class, don't look at
      # superclasses
      my @roles = $meta->can('calculate_all_roles')
                      ? $meta->calculate_all_roles
                      : ();
  
      # it's obviously not a role-only subclass if it doesn't do any roles
      return unless @roles;
  
      # loop over all methods that are a part of the current class
      # (not inherited)
      for my $method ( $meta->_get_local_methods ) {
          # always ignore meta
          next if $method->isa('Class::MOP::Method::Meta');
          # we'll deal with attributes below
          next if $method->can('associated_attribute');
          # if the method comes from a role we consumed, ignore it
          next if $meta->can('does_role')
               && $meta->does_role($method->original_package_name);
          # FIXME - this really isn't right. Just because a modifier is
          # defined in a role doesn't mean it isn't _also_ defined in the
          # subclass.
          next if $method->isa('Class::MOP::Method::Wrapped')
               && (
                   (!scalar($method->around_modifiers)
                 || any { $_->has_around_method_modifiers($method->name) } @roles)
                && (!scalar($method->before_modifiers)
                 || any { $_->has_before_method_modifiers($method->name) } @roles)
                && (!scalar($method->after_modifiers)
                 || any { $_->has_after_method_modifiers($method->name) } @roles)
                  );
  
          return 0;
      }
  
      # loop over all attributes that are a part of the current class
      # (not inherited)
      # FIXME - this really isn't right. Just because an attribute is
      # defined in a role doesn't mean it isn't _also_ defined in the
      # subclass.
      for my $attr (map { $meta->get_attribute($_) } $meta->get_attribute_list) {
          next if any { $_->has_attribute($attr->name) } @roles;
  
          return 0;
      }
  
      return 1;
  }
  
  sub _is_package_loaded {
      my ($package) = @_;
      defined $INC{module_notional_filename($package)};
  }
  
  1;
  
  # ABSTRACT: Utilities for working with Moose classes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Util - Utilities for working with Moose classes
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 SYNOPSIS
  
    use Moose::Util qw/find_meta does_role search_class_by_role/;
  
    my $meta = find_meta($object) || die "No metaclass found";
  
    if (does_role($object, $role)) {
      print "The object can do $role!\n";
    }
  
    my $class = search_class_by_role($object, 'FooRole');
    print "Nearest class with 'FooRole' is $class\n";
  
  =head1 DESCRIPTION
  
  This module provides a set of utility functions. Many of these
  functions are intended for use in Moose itself or MooseX modules, but
  some of them may be useful for use in your own code.
  
  =head1 EXPORTED FUNCTIONS
  
  =head2 find_meta($class_or_obj)
  
  This method takes a class name or object and attempts to find a
  metaclass for the class, if one exists. It will B<not> create one if it
  does not yet exist.
  
  =head2 is_role($package_or_obj)
  
  Returns true if the provided package name or object is a L<Moose::Role>.
  
  =head2 does_role($class_or_obj, $role_or_obj)
  
  Returns true if C<$class_or_obj> does the given C<$role_or_obj>. The role can
  be provided as a name or a L<Moose::Meta::Role> object.
  
  The class must already have a metaclass for this to work. If it doesn't, this
  function simply returns false.
  
  =head2 search_class_by_role($class_or_obj, $role_or_obj)
  
  Returns the first class in the class's precedence list that does
  C<$role_or_obj>, if any. The role can be either a name or a
  L<Moose::Meta::Role> object.
  
  The class must already have a metaclass for this to work.
  
  =head2 apply_all_roles($applicant, @roles)
  
  This function applies one or more roles to the given C<$applicant>. The
  applicant can be a role name, class name, or object.
  
  The C<$applicant> must already have a metaclass object.
  
  The list of C<@roles> should a list of names or L<Moose::Meta::Role> objects,
  each of which can be followed by an optional hash reference of options
  (C<-excludes> and C<-alias>).
  
  =head2 ensure_all_roles($applicant, @roles)
  
  This function is similar to C<apply_all_roles>, but only applies roles that
  C<$applicant> does not already consume.
  
  =head2 with_traits($class_name, @role_names)
  
  This function creates a new class from C<$class_name> with each of
  C<@role_names> applied. It returns the name of the new class.
  
  =head2 get_all_attribute_values($meta, $instance)
  
  Returns a hash reference containing all of the C<$instance>'s
  attributes. The keys are attribute names.
  
  =head2 get_all_init_args($meta, $instance)
  
  Returns a hash reference containing all of the C<init_arg> values for
  the instance's attributes. The values are the associated attribute
  values. If an attribute does not have a defined C<init_arg>, it is
  skipped.
  
  This could be useful in cloning an object.
  
  =head2 resolve_metaclass_alias($category, $name, %options)
  
  =head2 resolve_metatrait_alias($category, $name, %options)
  
  Resolves a short name to a full class name. Short names are often used
  when specifying the C<metaclass> or C<traits> option for an attribute:
  
      has foo => (
          metaclass => "Bar",
      );
  
  The name resolution mechanism is covered in
  L<Moose/Metaclass and Trait Name Resolution>.
  
  =head2 meta_class_alias($to[, $from])
  
  =head2 meta_attribute_alias($to[, $from])
  
  Create an alias from the class C<$from> (or the current package, if
  C<$from> is unspecified), so that
  L<Moose/Metaclass and Trait Name Resolution> works properly.
  
  =head2 english_list(@items)
  
  Given a list of scalars, turns them into a proper list in English
  ("one and two", "one, two, three, and four"). This is used to help us
  make nicer error messages.
  
  =head2 throw_exception( $class_name, %arguments_to_exception)
  
  Calls die with an object of Moose::Exception::$class_name, with
  %arguments_to_exception passed as arguments.
  
  =head1 TODO
  
  Here is a list of possible functions to write
  
  =over 4
  
  =item discovering original method from modified method
  
  =item search for origin class of a method or attribute
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_UTIL

$fatpacked{"darwin-2level/Moose/Util/MetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_UTIL_METAROLE';
  package Moose::Util::MetaRole;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  use Scalar::Util 'blessed';
  
  use List::Util 1.33 qw( first all );
  use Moose::Deprecated;
  use Moose::Util 'throw_exception';
  
  sub apply_metaroles {
      my %args = @_;
  
      my $for = _metathing_for( $args{for} );
  
      if ( $for->isa('Moose::Meta::Role') ) {
          return _make_new_metaclass( $for, $args{role_metaroles}, 'role' );
      }
      else {
          return _make_new_metaclass( $for, $args{class_metaroles}, 'class' );
      }
  }
  
  sub _metathing_for {
      my $passed = shift;
  
      my $found
          = blessed $passed
          ? $passed
          : Class::MOP::class_of($passed);
  
      return $found
          if defined $found
              && blessed $found
              && (   $found->isa('Moose::Meta::Role')
                  || $found->isa('Moose::Meta::Class') );
  
      local $Carp::CarpLevel = $Carp::CarpLevel + 1;
  
      throw_exception( InvalidArgPassedToMooseUtilMetaRole => argument => $passed );
  }
  
  sub _make_new_metaclass {
      my $for     = shift;
      my $roles   = shift;
      my $primary = shift;
  
      return $for unless keys %{$roles};
  
      my $new_metaclass
          = exists $roles->{$primary}
          ? _make_new_class( ref $for, $roles->{$primary} )
          : blessed $for;
  
      my %classes;
  
      for my $key ( grep { $_ ne $primary } keys %{$roles} ) {
          my $attr = first {$_}
              map { $for->meta->find_attribute_by_name($_) } (
              $key . '_metaclass',
              $key . '_class'
          );
  
          my $reader = $attr->get_read_method;
  
          $classes{ $attr->init_arg }
              = _make_new_class( $for->$reader(), $roles->{$key} );
      }
  
      my $new_meta = $new_metaclass->reinitialize( $for, %classes );
  
      return $new_meta;
  }
  
  sub apply_base_class_roles {
      my %args = @_;
  
      my $meta = _metathing_for( $args{for} || $args{for_class} );
      throw_exception( CannotApplyBaseClassRolesToRole => params    => \%args,
                                                          role_name => $meta->name,
                     )
          if $meta->isa('Moose::Meta::Role');
  
      my $new_base = _make_new_class(
          $meta->name,
          $args{roles},
          [ $meta->superclasses() ],
      );
  
      $meta->superclasses($new_base)
          if $new_base ne $meta->name();
  }
  
  sub _make_new_class {
      my $existing_class = shift;
      my $roles          = shift;
      my $superclasses   = shift || [$existing_class];
  
      return $existing_class unless $roles;
  
      my $meta = Class::MOP::Class->initialize($existing_class);
  
      return $existing_class
          if $meta->can('does_role') && all  { $meta->does_role($_) }
                                        grep { !ref $_ } @{$roles};
  
      return Moose::Meta::Class->create_anon_class(
          superclasses => $superclasses,
          roles        => $roles,
          cache        => 1,
      )->name();
  }
  
  1;
  
  # ABSTRACT: Apply roles to any metaclass, as well as the object base class
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Util::MetaRole - Apply roles to any metaclass, as well as the object base class
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 SYNOPSIS
  
    package MyApp::Moose;
  
    use Moose ();
    use Moose::Exporter;
    use Moose::Util::MetaRole;
  
    use MyApp::Role::Meta::Class;
    use MyApp::Role::Meta::Method::Constructor;
    use MyApp::Role::Object;
  
    Moose::Exporter->setup_import_methods( also => 'Moose' );
  
    sub init_meta {
        shift;
        my %args = @_;
  
        Moose->init_meta(%args);
  
        Moose::Util::MetaRole::apply_metaroles(
            for             => $args{for_class},
            class_metaroles => {
                class       => ['MyApp::Role::Meta::Class'],
                constructor => ['MyApp::Role::Meta::Method::Constructor'],
            },
        );
  
        Moose::Util::MetaRole::apply_base_class_roles(
            for   => $args{for_class},
            roles => ['MyApp::Role::Object'],
        );
  
        return $args{for_class}->meta();
    }
  
  =head1 DESCRIPTION
  
  This utility module is designed to help authors of Moose extensions
  write extensions that are able to cooperate with other Moose
  extensions. To do this, you must write your extensions as roles, which
  can then be dynamically applied to the caller's metaclasses.
  
  This module makes sure to preserve any existing superclasses and roles
  already set for the meta objects, which means that any number of
  extensions can apply roles in any order.
  
  =head1 USAGE
  
  The easiest way to use this module is through L<Moose::Exporter>, which can
  generate the appropriate C<init_meta> method for you, and make sure it is
  called when imported.
  
  =head1 FUNCTIONS
  
  This module provides two functions.
  
  =head2 apply_metaroles( ... )
  
  This function will apply roles to one or more metaclasses for the specified
  class. It will return a new metaclass object for the class or role passed in
  the "for" parameter.
  
  It accepts the following parameters:
  
  =over 4
  
  =item * for => $name
  
  This specifies the class or for which to alter the meta classes. This can be a
  package name, or an appropriate meta-object (a L<Moose::Meta::Class> or
  L<Moose::Meta::Role>).
  
  =item * class_metaroles => \%roles
  
  This is a hash reference specifying which metaroles will be applied to the
  class metaclass and its contained metaclasses and helper classes.
  
  Each key should in turn point to an array reference of role names.
  
  It accepts the following keys:
  
  =over 8
  
  =item class
  
  =item attribute
  
  =item method
  
  =item wrapped_method
  
  =item instance
  
  =item constructor
  
  =item destructor
  
  =item error
  
  =back
  
  =item * role_metaroles => \%roles
  
  This is a hash reference specifying which metaroles will be applied to the
  role metaclass and its contained metaclasses and helper classes.
  
  It accepts the following keys:
  
  =over 8
  
  =item role
  
  =item attribute
  
  =item method
  
  =item required_method
  
  =item conflicting_method
  
  =item application_to_class
  
  =item application_to_role
  
  =item application_to_instance
  
  =item application_role_summation
  
  =item applied_attribute
  
  =back
  
  =back
  
  =head2 apply_base_class_roles( for => $class, roles => \@roles )
  
  This function will apply the specified roles to the object's base class.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_UTIL_METAROLE

$fatpacked{"darwin-2level/Moose/Util/TypeConstraints.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_UTIL_TYPECONSTRAINTS';
  package Moose::Util::TypeConstraints;
  our $VERSION = '2.2011';
  
  use Carp ();
  use Scalar::Util qw( blessed );
  use Moose::Exporter;
  use Moose::Deprecated;
  
  ## --------------------------------------------------------
  # Prototyped subs must be predeclared because we have a
  # circular dependency with Moose::Meta::Attribute et. al.
  # so in case of us being use'd first the predeclaration
  # ensures the prototypes are in scope when consumers are
  # compiled.
  
  # dah sugah!
  sub where (&);
  sub via (&);
  sub message (&);
  sub inline_as (&);
  
  ## --------------------------------------------------------
  
  use Moose::Meta::TypeConstraint;
  use Moose::Meta::TypeConstraint::Union;
  use Moose::Meta::TypeConstraint::Parameterized;
  use Moose::Meta::TypeConstraint::Parameterizable;
  use Moose::Meta::TypeConstraint::Class;
  use Moose::Meta::TypeConstraint::Role;
  use Moose::Meta::TypeConstraint::Enum;
  use Moose::Meta::TypeConstraint::DuckType;
  use Moose::Meta::TypeCoercion;
  use Moose::Meta::TypeCoercion::Union;
  use Moose::Meta::TypeConstraint::Registry;
  
  use Moose::Util 'throw_exception';
  
  Moose::Exporter->setup_import_methods(
      as_is => [
          qw(
              type subtype class_type role_type maybe_type duck_type
              as where message inline_as
              coerce from via
              enum union
              find_type_constraint
              register_type_constraint
              match_on_type )
      ],
  );
  
  ## --------------------------------------------------------
  ## type registry and some useful functions for it
  ## --------------------------------------------------------
  
  my $REGISTRY = Moose::Meta::TypeConstraint::Registry->new;
  
  sub get_type_constraint_registry {$REGISTRY}
  sub list_all_type_constraints    { keys %{ $REGISTRY->type_constraints } }
  
  sub export_type_constraints_as_functions {
      my $pkg = caller();
      no strict 'refs';
      foreach my $constraint ( keys %{ $REGISTRY->type_constraints } ) {
          my $tc = $REGISTRY->get_type_constraint($constraint)
              ->_compiled_type_constraint;
          *{"${pkg}::${constraint}"}
              = sub { $tc->( $_[0] ) ? 1 : undef };    # the undef is for compat
      }
  }
  
  sub create_type_constraint_union {
      _create_type_constraint_union(\@_);
  }
  
  sub create_named_type_constraint_union {
      my $name = shift;
      _create_type_constraint_union($name, \@_);
  }
  
  sub _create_type_constraint_union {
      my $name;
      $name = shift if @_ > 1;
      my @tcs = @{ shift() };
  
      my @type_constraint_names;
  
      if ( scalar @tcs == 1 && _detect_type_constraint_union( $tcs[0] ) ) {
          @type_constraint_names = _parse_type_constraint_union( $tcs[0] );
      }
      else {
          @type_constraint_names = @tcs;
      }
  
      ( scalar @type_constraint_names >= 2 )
          || throw_exception("UnionTakesAtleastTwoTypeNames");
  
      my @type_constraints = map {
          find_or_parse_type_constraint($_)
              || throw_exception( CouldNotLocateTypeConstraintForUnion => type_name => $_ );
      } @type_constraint_names;
  
      my %options = (
        type_constraints => \@type_constraints
      );
      $options{name} = $name if defined $name;
  
      return Moose::Meta::TypeConstraint::Union->new(%options);
  }
  
  
  sub create_parameterized_type_constraint {
      my $type_constraint_name = shift;
      my ( $base_type, $type_parameter )
          = _parse_parameterized_type_constraint($type_constraint_name);
  
      ( defined $base_type && defined $type_parameter )
          || throw_exception( InvalidTypeGivenToCreateParameterizedTypeConstraint => type_name => $type_constraint_name );
  
      if ( $REGISTRY->has_type_constraint($base_type) ) {
          my $base_type_tc = $REGISTRY->get_type_constraint($base_type);
          return _create_parameterized_type_constraint(
              $base_type_tc,
              $type_parameter
          );
      }
      else {
          throw_exception( InvalidBaseTypeGivenToCreateParameterizedTypeConstraint => type_name => $base_type );
      }
  }
  
  sub _create_parameterized_type_constraint {
      my ( $base_type_tc, $type_parameter ) = @_;
      if ( $base_type_tc->can('parameterize') ) {
          return $base_type_tc->parameterize($type_parameter);
      }
      else {
          return Moose::Meta::TypeConstraint::Parameterized->new(
              name   => $base_type_tc->name . '[' . $type_parameter . ']',
              parent => $base_type_tc,
              type_parameter =>
                  find_or_create_isa_type_constraint($type_parameter),
          );
      }
  }
  
  #should we also support optimized checks?
  sub create_class_type_constraint {
      my ( $class, $options ) = @_;
  
  # too early for this check
  #find_type_constraint("ClassName")->check($class)
  #    || __PACKAGE__->_throw_error("Can't create a class type constraint because '$class' is not a class name");
  
      my $pkg_defined_in = $options->{package_defined_in} || scalar( caller(1) );
  
      if (my $type = $REGISTRY->get_type_constraint($class)) {
          if (!($type->isa('Moose::Meta::TypeConstraint::Class') && $type->class eq $class)) {
              throw_exception( TypeConstraintIsAlreadyCreated => package_defined_in => $pkg_defined_in,
                                                                 type_name          => $type->name,
                             );
          }
          else {
              return $type;
          }
      }
  
      my %options = (
          class              => $class,
          name               => $class,
          package_defined_in => $pkg_defined_in,
          %{ $options || {} },    # overrides options from above
      );
  
      $options{name} ||= "__ANON__";
  
      my $tc = Moose::Meta::TypeConstraint::Class->new(%options);
      $REGISTRY->add_type_constraint($tc);
      return $tc;
  }
  
  sub create_role_type_constraint {
      my ( $role, $options ) = @_;
  
  # too early for this check
  #find_type_constraint("ClassName")->check($class)
  #    || __PACKAGE__->_throw_error("Can't create a class type constraint because '$class' is not a class name");
  
      my $pkg_defined_in = $options->{package_defined_in} || scalar( caller(1) );
  
      if (my $type = $REGISTRY->get_type_constraint($role)) {
          if (!($type->isa('Moose::Meta::TypeConstraint::Role') && $type->role eq $role)) {
              throw_exception( TypeConstraintIsAlreadyCreated => type_name          => $type->name,
                                                                 package_defined_in => $pkg_defined_in
                             );
          }
          else {
              return $type;
          }
      }
  
      my %options = (
          role               => $role,
          name               => $role,
          package_defined_in => $pkg_defined_in,
          %{ $options || {} },
      );
  
      $options{name} ||= "__ANON__";
  
      my $tc = Moose::Meta::TypeConstraint::Role->new(%options);
      $REGISTRY->add_type_constraint($tc);
      return $tc;
  }
  
  sub find_or_create_type_constraint {
      my ( $type_constraint_name, $options_for_anon_type ) = @_;
  
      if ( my $constraint
          = find_or_parse_type_constraint($type_constraint_name) ) {
          return $constraint;
      }
      elsif ( defined $options_for_anon_type ) {
  
          # NOTE:
          # if there is no $options_for_anon_type
          # specified, then we assume they don't
          # want to create one, and return nothing.
  
          # otherwise assume that we should create
          # an ANON type with the $options_for_anon_type
          # options which can be passed in. It should
          # be noted that these don't get registered
          # so we need to return it.
          # - SL
          return Moose::Meta::TypeConstraint->new(
              name => '__ANON__',
              %{$options_for_anon_type}
          );
      }
  
      return;
  }
  
  sub find_or_create_isa_type_constraint {
      my ($type_constraint_name, $options) = @_;
      find_or_parse_type_constraint($type_constraint_name)
          || create_class_type_constraint($type_constraint_name, $options);
  }
  
  sub find_or_create_does_type_constraint {
      my ($type_constraint_name, $options) = @_;
      find_or_parse_type_constraint($type_constraint_name)
          || create_role_type_constraint($type_constraint_name, $options);
  }
  
  sub find_or_parse_type_constraint {
      my $type_constraint_name = normalize_type_constraint_name(shift);
      my $constraint;
  
      if ( $constraint = find_type_constraint($type_constraint_name) ) {
          return $constraint;
      }
      elsif ( _detect_type_constraint_union($type_constraint_name) ) {
          $constraint = create_type_constraint_union($type_constraint_name);
      }
      elsif ( _detect_parameterized_type_constraint($type_constraint_name) ) {
          $constraint
              = create_parameterized_type_constraint($type_constraint_name);
      }
      else {
          return;
      }
  
      $REGISTRY->add_type_constraint($constraint);
      return $constraint;
  }
  
  sub normalize_type_constraint_name {
      my $type_constraint_name = shift;
      $type_constraint_name =~ s/\s//g;
      return $type_constraint_name;
  }
  
  sub _confess {
      my $error = shift;
  
      local $Carp::CarpLevel = $Carp::CarpLevel + 1;
      Carp::confess($error);
  }
  
  ## --------------------------------------------------------
  ## exported functions ...
  ## --------------------------------------------------------
  
  sub find_type_constraint {
      my $type = shift;
  
      if ( blessed $type and $type->isa("Moose::Meta::TypeConstraint") ) {
          return $type;
      }
      else {
          return unless $REGISTRY->has_type_constraint($type);
          return $REGISTRY->get_type_constraint($type);
      }
  }
  
  sub register_type_constraint {
      my $constraint = shift;
      throw_exception( CannotRegisterUnnamedTypeConstraint => type => $constraint )
          unless defined $constraint->name;
      $REGISTRY->add_type_constraint($constraint);
      return $constraint;
  }
  
  # type constructors
  
  sub type {
      my $name = shift;
  
      my %p = map { %{$_} } @_;
  
      return _create_type_constraint(
          $name, undef, $p{where}, $p{message},
          $p{inline_as},
      );
  }
  
  sub subtype {
      if ( @_ == 1 && !ref $_[0] ) {
          throw_exception( NoParentGivenToSubtype => name => $_[0] );
      }
  
      # The blessed check is mostly to accommodate MooseX::Types, which
      # uses an object which overloads stringification as a type name.
      my $name = ref $_[0] && !blessed $_[0] ? undef : shift;
  
      my %p = map { %{$_} } @_;
  
      # subtype Str => where { ... };
      if ( !exists $p{as} ) {
          $p{as} = $name;
          $name = undef;
      }
  
      return _create_type_constraint(
          $name, $p{as}, $p{where}, $p{message},
          $p{inline_as},
      );
  }
  
  sub class_type {
      create_class_type_constraint(@_);
  }
  
  sub role_type ($;$) {
      create_role_type_constraint(@_);
  }
  
  sub maybe_type {
      my ($type_parameter) = @_;
  
      register_type_constraint(
          $REGISTRY->get_type_constraint('Maybe')->parameterize($type_parameter)
      );
  }
  
  sub duck_type {
      my ( $type_name, @methods ) = @_;
      if ( ref $type_name eq 'ARRAY' && !@methods ) {
          @methods   = ($type_name);
          $type_name = undef;
      }
      if ( @methods == 1 && ref $methods[0] eq 'ARRAY' ) {
          @methods = @{ $methods[0] };
      }
      else {
          Moose::Deprecated::deprecated(
              feature => 'non-arrayref form of duck_type',
              message => "Passing a list of values to duck_type is deprecated. "
                       . "The method names should be wrapped in an arrayref.",
          );
      }
  
      register_type_constraint(
          create_duck_type_constraint(
              $type_name,
              \@methods,
          )
      );
  }
  
  sub coerce {
      my ( $type_name, @coercion_map ) = @_;
      _install_type_coercions( $type_name, \@coercion_map );
  }
  
  # The trick of returning @_ lets us avoid having to specify a
  # prototype. Perl will parse this:
  #
  # subtype 'Foo'
  #     => as 'Str'
  #     => where { ... }
  #
  # as this:
  #
  # subtype( 'Foo', as( 'Str', where { ... } ) );
  #
  # If as() returns all its extra arguments, this just works, and
  # preserves backwards compatibility.
  sub as { +{ as => shift }, @_ }
  sub where (&)       { +{ where       => $_[0] } }
  sub message (&)     { +{ message     => $_[0] } }
  sub inline_as (&)   { +{ inline_as   => $_[0] } }
  
  sub from    { @_ }
  sub via (&) { $_[0] }
  
  sub enum {
      my ( $type_name, @values ) = @_;
  
      # NOTE:
      # if only an array-ref is passed then
      # you get an anon-enum
      # - SL
      if ( ref $type_name eq 'ARRAY' ) {
          @values == 0
              || throw_exception( EnumCalledWithAnArrayRefAndAdditionalArgs => array => $type_name,
                                                                               args  => \@values
                                );
          @values    = ($type_name);
          $type_name = undef;
      }
      if ( @values == 1 && ref $values[0] eq 'ARRAY' ) {
          @values = @{ $values[0] };
      }
      else {
          Moose::Deprecated::deprecated(
              feature => 'non-arrayref form of enum',
              message => "Passing a list of values to enum is deprecated. "
                       . "Enum values should be wrapped in an arrayref.",
          );
      }
  
      register_type_constraint(
          create_enum_type_constraint(
              $type_name,
              \@values,
          )
      );
  }
  
  sub union {
    my ( $type_name, @constraints ) = @_;
    if ( ref $type_name eq 'ARRAY' ) {
      @constraints == 0
        || throw_exception( UnionCalledWithAnArrayRefAndAdditionalArgs => array => $type_name,
                                                                          args  => \@constraints
                          );
      @constraints = @$type_name;
      $type_name   = undef;
    }
    if ( @constraints == 1 && ref $constraints[0] eq 'ARRAY' ) {
      @constraints = @{ $constraints[0] };
    }
    if ( defined $type_name ) {
      return register_type_constraint(
        create_named_type_constraint_union( $type_name, @constraints )
      );
    }
    return create_type_constraint_union( @constraints );
  }
  
  sub create_enum_type_constraint {
      my ( $type_name, $values ) = @_;
  
      Moose::Meta::TypeConstraint::Enum->new(
          name => $type_name || '__ANON__',
          values => $values,
      );
  }
  
  sub create_duck_type_constraint {
      my ( $type_name, $methods ) = @_;
  
      Moose::Meta::TypeConstraint::DuckType->new(
          name => $type_name || '__ANON__',
          methods => $methods,
      );
  }
  
  sub match_on_type {
      my ($to_match, @cases) = @_;
      my $default;
      if (@cases % 2 != 0) {
          $default = pop @cases;
          (ref $default eq 'CODE')
              || throw_exception( DefaultToMatchOnTypeMustBeCodeRef => to_match            => $to_match,
                                                                       default_action      => $default,
                                                                       cases_to_be_matched => \@cases
                                );
      }
      while (@cases) {
          my ($type, $action) = splice @cases, 0, 2;
  
          unless (blessed $type && $type->isa('Moose::Meta::TypeConstraint')) {
              $type = find_or_parse_type_constraint($type)
                   || throw_exception( CannotFindTypeGivenToMatchOnType => type     => $type,
                                                                           to_match => $to_match,
                                                                           action   => $action
                                     );
          }
  
          (ref $action eq 'CODE')
              || throw_exception( MatchActionMustBeACodeRef => type_name => $type->name,
                                                               action    => $action,
                                                               to_match  => $to_match
                                );
  
          if ($type->check($to_match)) {
              local $_ = $to_match;
              return $action->($to_match);
          }
      }
      (defined $default)
          || throw_exception( NoCasesMatched => to_match            => $to_match,
                                                cases_to_be_matched => \@cases
                            );
      {
          local $_ = $to_match;
          return $default->($to_match);
      }
  }
  
  
  ## --------------------------------------------------------
  ## desugaring functions ...
  ## --------------------------------------------------------
  
  sub _create_type_constraint ($$$;$) {
      my $name      = shift;
      my $parent    = shift;
      my $check     = shift;
      my $message   = shift;
      my $inlined   = shift;
  
      my $pkg_defined_in = scalar( caller(1) );
  
      if ( defined $name ) {
          my $type = $REGISTRY->get_type_constraint($name);
  
          ( $type->_package_defined_in eq $pkg_defined_in )
              || throw_exception( TypeConstraintIsAlreadyCreated => package_defined_in => $pkg_defined_in,
                                                                    type_name          => $type->name,
                                )
              if defined $type;
  
          if( $name !~ /^[\w:\.]+$/ ) {
              throw_exception( InvalidNameForType => name => $name );
          }
      }
  
      my %opts = (
          name               => $name,
          package_defined_in => $pkg_defined_in,
  
          ( $check     ? ( constraint => $check )     : () ),
          ( $message   ? ( message    => $message )   : () ),
          ( $inlined   ? ( inlined    => $inlined )   : () ),
      );
  
      my $constraint;
      if (
          defined $parent
          and $parent
          = blessed $parent
          ? $parent
          : find_or_create_isa_type_constraint($parent)
          ) {
          $constraint = $parent->create_child_type(%opts);
      }
      else {
          $constraint = Moose::Meta::TypeConstraint->new(%opts);
      }
  
      $REGISTRY->add_type_constraint($constraint)
          if defined $name;
  
      return $constraint;
  }
  
  sub _install_type_coercions ($$) {
      my ( $type_name, $coercion_map ) = @_;
      my $type = find_type_constraint($type_name);
      ( defined $type )
          || throw_exception( CannotFindType => type_name => $type_name );
  
      if ( $type->has_coercion ) {
          $type->coercion->add_type_coercions(@$coercion_map);
      }
      else {
          my $type_coercion = Moose::Meta::TypeCoercion->new(
              type_coercion_map => $coercion_map,
              type_constraint   => $type
          );
          $type->coercion($type_coercion);
      }
  }
  
  ## --------------------------------------------------------
  ## type notation parsing ...
  ## --------------------------------------------------------
  
  {
  
      # All I have to say is mugwump++ cause I know
      # do not even have enough regexp-fu to be able
      # to have written this (I can only barely
      # understand it as it is)
      # - SL
  
      use re "eval";
  
      my $valid_chars = qr{[\w:\.]};
      my $type_atom   = qr{ (?>$valid_chars+) }x;
      my $ws          = qr{ (?>\s*) }x;
      my $op_union    = qr{ $ws \| $ws }x;
  
      my ($type, $type_capture_parts, $type_with_parameter, $union, $any);
      if (Class::MOP::IS_RUNNING_ON_5_10) {
          my $type_pattern
              = q{  (?&type_atom)  (?: \[ (?&ws)  (?&any)  (?&ws) \] )? };
          my $type_capture_parts_pattern
              = q{ ((?&type_atom)) (?: \[ (?&ws) ((?&any)) (?&ws) \] )? };
          my $type_with_parameter_pattern
              = q{  (?&type_atom)      \[ (?&ws)  (?&any)  (?&ws) \]    };
          my $union_pattern
              = q{ (?&type) (?> (?: (?&op_union) (?&type) )+ ) };
          my $any_pattern
              = q{ (?&type) | (?&union) };
  
          my $defines = qr{(?(DEFINE)
              (?<valid_chars>         $valid_chars)
              (?<type_atom>           $type_atom)
              (?<ws>                  $ws)
              (?<op_union>            $op_union)
              (?<type>                $type_pattern)
              (?<type_capture_parts>  $type_capture_parts_pattern)
              (?<type_with_parameter> $type_with_parameter_pattern)
              (?<union>               $union_pattern)
              (?<any>                 $any_pattern)
          )}x;
  
          $type                = qr{ $type_pattern                $defines }x;
          $type_capture_parts  = qr{ $type_capture_parts_pattern  $defines }x;
          $type_with_parameter = qr{ $type_with_parameter_pattern $defines }x;
          $union               = qr{ $union_pattern               $defines }x;
          $any                 = qr{ $any_pattern                 $defines }x;
      }
      else {
          $type
              = qr{  $type_atom  (?: \[ $ws  (??{$any})  $ws \] )? }x;
          $type_capture_parts
              = qr{ ($type_atom) (?: \[ $ws ((??{$any})) $ws \] )? }x;
          $type_with_parameter
              = qr{  $type_atom      \[ $ws  (??{$any})  $ws \]    }x;
          $union
              = qr{ $type (?> (?: $op_union $type )+ ) }x;
          $any
              = qr{ $type | $union }x;
      }
  
  
      sub _parse_parameterized_type_constraint {
          { no warnings 'void'; $any; }  # force capture of interpolated lexical
          $_[0] =~ m{ $type_capture_parts }x;
          return ( $1, $2 );
      }
  
      sub _detect_parameterized_type_constraint {
          { no warnings 'void'; $any; }  # force capture of interpolated lexical
          $_[0] =~ m{ ^ $type_with_parameter $ }x;
      }
  
      sub _parse_type_constraint_union {
          { no warnings 'void'; $any; }  # force capture of interpolated lexical
          my $given = shift;
          my @rv;
          while ( $given =~ m{ \G (?: $op_union )? ($type) }gcx ) {
              push @rv => $1;
          }
          ( pos($given) eq length($given) )
              || throw_exception( CouldNotParseType => type     => $given,
                                                       position => pos($given)
                                );
          @rv;
      }
  
      sub _detect_type_constraint_union {
          { no warnings 'void'; $any; }  # force capture of interpolated lexical
          $_[0] =~ m{^ $type $op_union $type ( $op_union .* )? $}x;
      }
  }
  
  ## --------------------------------------------------------
  # define some basic built-in types
  ## --------------------------------------------------------
  
  # By making these classes immutable before creating all the types in
  # Moose::Util::TypeConstraints::Builtin , we avoid repeatedly calling the slow
  # MOP-based accessors.
  $_->make_immutable(
      inline_constructor => 1,
      constructor_name   => "_new",
  
      # these are Class::MOP accessors, so they need inlining
      inline_accessors => 1
      ) for grep { $_->is_mutable }
      map { Class::MOP::class_of($_) }
      qw(
      Moose::Meta::TypeConstraint
      Moose::Meta::TypeConstraint::Union
      Moose::Meta::TypeConstraint::Parameterized
      Moose::Meta::TypeConstraint::Parameterizable
      Moose::Meta::TypeConstraint::Class
      Moose::Meta::TypeConstraint::Role
      Moose::Meta::TypeConstraint::Enum
      Moose::Meta::TypeConstraint::DuckType
      Moose::Meta::TypeConstraint::Registry
  );
  
  require Moose::Util::TypeConstraints::Builtins;
  Moose::Util::TypeConstraints::Builtins::define_builtins($REGISTRY);
  
  my @PARAMETERIZABLE_TYPES
      = map { $REGISTRY->get_type_constraint($_) } qw[ScalarRef ArrayRef HashRef Maybe];
  
  sub get_all_parameterizable_types {@PARAMETERIZABLE_TYPES}
  
  sub add_parameterizable_type {
      my $type = shift;
      ( blessed $type
              && $type->isa('Moose::Meta::TypeConstraint::Parameterizable') )
          || throw_exception( AddParameterizableTypeTakesParameterizableType => type_name => $type );
  
      push @PARAMETERIZABLE_TYPES => $type;
  }
  
  ## --------------------------------------------------------
  # end of built-in types ...
  ## --------------------------------------------------------
  
  {
      my @BUILTINS = list_all_type_constraints();
      sub list_all_builtin_type_constraints {@BUILTINS}
  }
  
  1;
  
  # ABSTRACT: Type constraint system for Moose
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Util::TypeConstraints - Type constraint system for Moose
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 SYNOPSIS
  
    use Moose::Util::TypeConstraints;
  
    subtype 'Natural',
        as 'Int',
        where { $_ > 0 };
  
    subtype 'NaturalLessThanTen',
        as 'Natural',
        where { $_ < 10 },
        message { "This number ($_) is not less than ten!" };
  
    coerce 'Num',
        from 'Str',
        via { 0+$_ };
  
    class_type 'DateTimeClass', { class => 'DateTime' };
  
    role_type 'Barks', { role => 'Some::Library::Role::Barks' };
  
    enum 'RGBColors', [qw(red green blue)];
  
    union 'StringOrArray', [qw( String ArrayRef )];
  
    no Moose::Util::TypeConstraints;
  
  =head1 DESCRIPTION
  
  This module provides Moose with the ability to create custom type
  constraints to be used in attribute definition.
  
  =head2 Important Caveat
  
  This is B<NOT> a type system for Perl 5. These are type constraints,
  and they are not used by Moose unless you tell it to. No type
  inference is performed, expressions are not typed, etc. etc. etc.
  
  A type constraint is at heart a small "check if a value is valid"
  function. A constraint can be associated with an attribute. This
  simplifies parameter validation, and makes your code clearer to read,
  because you can refer to constraints by name.
  
  =head2 Slightly Less Important Caveat
  
  It is B<always> a good idea to quote your type names.
  
  This prevents Perl from trying to execute the call as an indirect
  object call. This can be an issue when you have a subtype with the
  same name as a valid class.
  
  For instance:
  
    subtype DateTime => as Object => where { $_->isa('DateTime') };
  
  will I<just work>, while this:
  
    use DateTime;
    subtype DateTime => as Object => where { $_->isa('DateTime') };
  
  will fail silently and cause many headaches. The simple way to solve
  this, as well as future proof your subtypes from classes which have
  yet to have been created, is to quote the type name:
  
    use DateTime;
    subtype 'DateTime', as 'Object', where { $_->isa('DateTime') };
  
  =head2 Default Type Constraints
  
  This module also provides a simple hierarchy for Perl 5 types, here is
  that hierarchy represented visually.
  
    Any
        Item
            Bool
            Maybe[`a]
            Undef
            Defined
                Value
                    Str
                        Num
                            Int
                        ClassName
                        RoleName
                Ref
                    ScalarRef[`a]
                    ArrayRef[`a]
                    HashRef[`a]
                    CodeRef
                    RegexpRef
                    GlobRef
                    FileHandle
                    Object
  
  B<NOTE:> Any type followed by a type parameter C<[`a]> can be
  parameterized, this means you can say:
  
    ArrayRef[Int]    # an array of integers
    HashRef[CodeRef] # a hash of str to CODE ref mappings
    ScalarRef[Int]   # a reference to an integer
    Maybe[Str]       # value may be a string, may be undefined
  
  If Moose finds a name in brackets that it does not recognize as an
  existing type, it assumes that this is a class name, for example
  C<ArrayRef[DateTime]>.
  
  B<NOTE:> Unless you parameterize a type, then it is invalid to include
  the square brackets. I.e. C<ArrayRef[]> will be treated as a new type
  name, I<not> as a parameterization of C<ArrayRef>.
  
  B<NOTE:> The C<Undef> type constraint for the most part works
  correctly now, but edge cases may still exist, please use it
  sparingly.
  
  B<NOTE:> The C<ClassName> type constraint does a complex package
  existence check. This means that your class B<must> be loaded for this
  type constraint to pass.
  
  B<NOTE:> The C<RoleName> constraint checks a string is a I<package
  name> which is a role, like C<'MyApp::Role::Comparable'>.
  
  =head2 Type Constraint Naming
  
  Type names declared via this module can only contain alphanumeric
  characters, colons (:), and periods (.).
  
  Since the types created by this module are global, it is suggested
  that you namespace your types just as you would namespace your
  modules. So instead of creating a I<Color> type for your
  B<My::Graphics> module, you would call the type
  I<My::Graphics::Types::Color> instead.
  
  =head2 Use with Other Constraint Modules
  
  This module can play nicely with other constraint modules with some
  slight tweaking. The C<where> clause in types is expected to be a
  C<CODE> reference which checks its first argument and returns a
  boolean. Since most constraint modules work in a similar way, it
  should be simple to adapt them to work with Moose.
  
  For instance, this is how you could use it with
  L<Declare::Constraints::Simple> to declare a completely new type.
  
    type 'HashOfArrayOfObjects',
        where {
            IsHashRef(
                -keys   => HasLength,
                -values => IsArrayRef(IsObject)
            )->(@_);
        };
  
  For more examples see the F<t/examples/example_w_DCS.t> test
  file.
  
  Here is an example of using L<Test::Deep> and its non-test
  related C<eq_deeply> function.
  
    type 'ArrayOfHashOfBarsAndRandomNumbers',
        where {
            eq_deeply($_,
                array_each(subhashof({
                    bar           => isa('Bar'),
                    random_number => ignore()
                })))
          };
  
  For a complete example see the
  F<t/examples/example_w_TestDeep.t> test file.
  
  =head2 Error messages
  
  Type constraints can also specify custom error messages, for when they fail to
  validate. This is provided as just another coderef, which receives the invalid
  value in C<$_>, as in:
  
    subtype 'PositiveInt',
         as 'Int',
         where { $_ > 0 },
         message { "$_ is not a positive integer!" };
  
  If no message is specified, a default message will be used, which indicates
  which type constraint was being used and what value failed. If
  L<Devel::PartialDump> (version 0.14 or higher) is installed, it will be used to
  display the invalid value, otherwise it will just be printed as is.
  
  =head1 FUNCTIONS
  
  =head2 Type Constraint Constructors
  
  The following functions are used to create type constraints.  They
  will also register the type constraints your create in a global
  registry that is used to look types up by name.
  
  See the L</SYNOPSIS> for an example of how to use these.
  
  =head3 subtype 'Name', as 'Parent', where { } ...
  
  This creates a named subtype.
  
  If you provide a parent that Moose does not recognize, it will
  automatically create a new class type constraint for this name.
  
  When creating a named type, the C<subtype> function should either be
  called with the sugar helpers (C<where>, C<message>, etc), or with a
  name and a hashref of parameters:
  
   subtype( 'Foo', { where => ..., message => ... } );
  
  The valid hashref keys are C<as> (the parent), C<where>, C<message>,
  and C<inline_as>.
  
  =head3 subtype as 'Parent', where { } ...
  
  This creates an unnamed subtype and will return the type
  constraint meta-object, which will be an instance of
  L<Moose::Meta::TypeConstraint>.
  
  When creating an anonymous type, the C<subtype> function should either
  be called with the sugar helpers (C<where>, C<message>, etc), or with
  just a hashref of parameters:
  
   subtype( { where => ..., message => ... } );
  
  =head3 class_type ($class, ?$options)
  
  Creates a new subtype of C<Object> with the name C<$class> and the
  metaclass L<Moose::Meta::TypeConstraint::Class>.
  
    # Create a type called 'Box' which tests for objects which ->isa('Box')
    class_type 'Box';
  
  By default, the name of the type and the name of the class are the same, but
  you can specify both separately.
  
    # Create a type called 'Box' which tests for objects which ->isa('ObjectLibrary::Box');
    class_type 'Box', { class => 'ObjectLibrary::Box' };
  
  =head3 role_type ($role, ?$options)
  
  Creates a C<Role> type constraint with the name C<$role> and the
  metaclass L<Moose::Meta::TypeConstraint::Role>.
  
    # Create a type called 'Walks' which tests for objects which ->does('Walks')
    role_type 'Walks';
  
  By default, the name of the type and the name of the role are the same, but
  you can specify both separately.
  
    # Create a type called 'Walks' which tests for objects which ->does('MooseX::Role::Walks');
    role_type 'Walks', { role => 'MooseX::Role::Walks' };
  
  =head3 maybe_type ($type)
  
  Creates a type constraint for either C<undef> or something of the
  given type.
  
  =head3 duck_type ($name, \@methods)
  
  This will create a subtype of Object and test to make sure the value
  C<can()> do the methods in C<\@methods>.
  
  This is intended as an easy way to accept non-Moose objects that
  provide a certain interface. If you're using Moose classes, we
  recommend that you use a C<requires>-only Role instead.
  
  =head3 duck_type (\@methods)
  
  If passed an ARRAY reference as the only parameter instead of the
  C<$name>, C<\@methods> pair, this will create an unnamed duck type.
  This can be used in an attribute definition like so:
  
    has 'cache' => (
        is  => 'ro',
        isa => duck_type( [qw( get_set )] ),
    );
  
  =head3 enum ($name, \@values)
  
  This will create a basic subtype for a given set of strings.
  The resulting constraint will be a subtype of C<Str> and
  will match any of the items in C<\@values>. It is case sensitive.
  See the L</SYNOPSIS> for a simple example.
  
  B<NOTE:> This is not a true proper enum type, it is simply
  a convenient constraint builder.
  
  =head3 enum (\@values)
  
  If passed an ARRAY reference as the only parameter instead of the
  C<$name>, C<\@values> pair, this will create an unnamed enum. This
  can then be used in an attribute definition like so:
  
    has 'sort_order' => (
        is  => 'ro',
        isa => enum([qw[ ascending descending ]]),
    );
  
  =head3 union ($name, \@constraints)
  
  This will create a basic subtype where any of the provided constraints
  may match in order to satisfy this constraint.
  
  =head3 union (\@constraints)
  
  If passed an ARRAY reference as the only parameter instead of the
  C<$name>, C<\@constraints> pair, this will create an unnamed union.
  This can then be used in an attribute definition like so:
  
    has 'items' => (
        is => 'ro',
        isa => union([qw[ Str ArrayRef ]]),
    );
  
  This is similar to the existing string union:
  
    isa => 'Str|ArrayRef'
  
  except that it supports anonymous elements as child constraints:
  
    has 'color' => (
      isa => 'ro',
      isa => union([ 'Int',  enum([qw[ red green blue ]]) ]),
    );
  
  =head3 as 'Parent'
  
  This is just sugar for the type constraint construction syntax.
  
  It takes a single argument, which is the name of a parent type.
  
  =head3 where { ... }
  
  This is just sugar for the type constraint construction syntax.
  
  It takes a subroutine reference as an argument. When the type
  constraint is tested, the reference is run with the value to be tested
  in C<$_>. This reference should return true or false to indicate
  whether or not the constraint check passed.
  
  =head3 message { ... }
  
  This is just sugar for the type constraint construction syntax.
  
  It takes a subroutine reference as an argument. When the type
  constraint fails, then the code block is run with the value provided
  in C<$_>. This reference should return a string, which will be used in
  the text of the exception thrown.
  
  =head3 inline_as { ... }
  
  This can be used to define a "hand optimized" inlinable version of your type
  constraint.
  
  You provide a subroutine which will be called I<as a method> on a
  L<Moose::Meta::TypeConstraint> object. It will receive a single parameter, the
  name of the variable to check, typically something like C<"$_"> or C<"$_[0]">.
  
  The subroutine should return a code string suitable for inlining. You can
  assume that the check will be wrapped in parentheses when it is inlined.
  
  The inlined code should include any checks that your type's parent types
  do. If your parent type constraint defines its own inlining, you can simply use
  that to avoid repeating code. For example, here is the inlining code for the
  C<Value> type, which is a subtype of C<Defined>:
  
      sub {
          $_[0]->parent()->_inline_check($_[1])
          . ' && !ref(' . $_[1] . ')'
      }
  
  =head3 type 'Name', where { } ...
  
  This creates a base type, which has no parent.
  
  The C<type> function should either be called with the sugar helpers
  (C<where>, C<message>, etc), or with a name and a hashref of
  parameters:
  
    type( 'Foo', { where => ..., message => ... } );
  
  The valid hashref keys are C<where>, C<message>, and C<inlined_as>.
  
  =head2 Type Constraint Utilities
  
  =head3 match_on_type $value => ( $type => \&action, ... ?\&default )
  
  This is a utility function for doing simple type based dispatching similar to
  match/case in OCaml and case/of in Haskell. It is not as featureful as those
  languages, nor does not it support any kind of automatic destructuring
  bind. Here is a simple Perl pretty printer dispatching over the core Moose
  types.
  
    sub ppprint {
        my $x = shift;
        match_on_type $x => (
            HashRef => sub {
                my $hash = shift;
                '{ '
                    . (
                    join ", " => map { $_ . ' => ' . ppprint( $hash->{$_} ) }
                        sort keys %$hash
                    ) . ' }';
            },
            ArrayRef => sub {
                my $array = shift;
                '[ ' . ( join ", " => map { ppprint($_) } @$array ) . ' ]';
            },
            CodeRef   => sub {'sub { ... }'},
            RegexpRef => sub { 'qr/' . $_ . '/' },
            GlobRef   => sub { '*' . B::svref_2object($_)->NAME },
            Object    => sub { $_->can('to_string') ? $_->to_string : $_ },
            ScalarRef => sub { '\\' . ppprint( ${$_} ) },
            Num       => sub {$_},
            Str       => sub { '"' . $_ . '"' },
            Undef     => sub {'undef'},
            => sub { die "I don't know what $_ is" }
        );
    }
  
  Or a simple JSON serializer:
  
    sub to_json {
        my $x = shift;
        match_on_type $x => (
            HashRef => sub {
                my $hash = shift;
                '{ '
                    . (
                    join ", " =>
                        map { '"' . $_ . '" : ' . to_json( $hash->{$_} ) }
                        sort keys %$hash
                    ) . ' }';
            },
            ArrayRef => sub {
                my $array = shift;
                '[ ' . ( join ", " => map { to_json($_) } @$array ) . ' ]';
            },
            Num   => sub {$_},
            Str   => sub { '"' . $_ . '"' },
            Undef => sub {'null'},
            => sub { die "$_ is not acceptable json type" }
        );
    }
  
  The matcher is done by mapping a C<$type> to an C<\&action>. The C<$type> can
  be either a string type or a L<Moose::Meta::TypeConstraint> object, and
  C<\&action> is a subroutine reference. This function will dispatch on the
  first match for C<$value>. It is possible to have a catch-all by providing an
  additional subroutine reference as the final argument to C<match_on_type>.
  
  =head2 Type Coercion Constructors
  
  You can define coercions for type constraints, which allow you to
  automatically transform values to something valid for the type
  constraint. If you ask your accessor to coerce by adding the option C<< coerce => 1 >>, then Moose will run
  the type-coercion code first, followed by the type constraint
  check. This feature should be used carefully as it is very powerful
  and could easily take off a limb if you are not careful.
  
  See the L</SYNOPSIS> for an example of how to use these.
  
  =head3 coerce 'Name', from 'OtherName', via { ... }
  
  This defines a coercion from one type to another. The C<Name> argument
  is the type you are coercing I<to>.
  
  To define multiple coercions, supply more sets of from/via pairs:
  
    coerce 'Name',
      from 'OtherName', via { ... },
      from 'ThirdName', via { ... };
  
  =head3 from 'OtherName'
  
  This is just sugar for the type coercion construction syntax.
  
  It takes a single type name (or type object), which is the type being
  coerced I<from>.
  
  =head3 via { ... }
  
  This is just sugar for the type coercion construction syntax.
  
  It takes a subroutine reference. This reference will be called with
  the value to be coerced in C<$_>. It is expected to return a new value
  of the proper type for the coercion.
  
  =head2 Creating and Finding Type Constraints
  
  These are additional functions for creating and finding type
  constraints. Most of these functions are not available for
  importing. The ones that are importable as specified.
  
  =head3 find_type_constraint($type_name)
  
  This function can be used to locate the L<Moose::Meta::TypeConstraint>
  object for a named type.
  
  This function is importable.
  
  =head3 register_type_constraint($type_object)
  
  This function will register a L<Moose::Meta::TypeConstraint> with the
  global type registry.
  
  This function is importable.
  
  =head3 normalize_type_constraint_name($type_constraint_name)
  
  This method takes a type constraint name and returns the normalized
  form. This removes any whitespace in the string.
  
  =head3 create_type_constraint_union($pipe_separated_types | @type_constraint_names)
  
  =head3 create_named_type_constraint_union($name, $pipe_separated_types | @type_constraint_names)
  
  This can take a union type specification like C<'Int|ArrayRef[Int]'>,
  or a list of names. It returns a new
  L<Moose::Meta::TypeConstraint::Union> object.
  
  =head3 create_parameterized_type_constraint($type_name)
  
  Given a C<$type_name> in the form of C<'BaseType[ContainerType]'>,
  this will create a new L<Moose::Meta::TypeConstraint::Parameterized>
  object. The C<BaseType> must already exist as a parameterizable
  type.
  
  =head3 create_class_type_constraint($class, $options)
  
  Given a class name this function will create a new
  L<Moose::Meta::TypeConstraint::Class> object for that class name.
  
  The C<$options> is a hash reference that will be passed to the
  L<Moose::Meta::TypeConstraint::Class> constructor (as a hash).
  
  =head3 create_role_type_constraint($role, $options)
  
  Given a role name this function will create a new
  L<Moose::Meta::TypeConstraint::Role> object for that role name.
  
  The C<$options> is a hash reference that will be passed to the
  L<Moose::Meta::TypeConstraint::Role> constructor (as a hash).
  
  =head3 create_enum_type_constraint($name, $values)
  
  Given a enum name this function will create a new
  L<Moose::Meta::TypeConstraint::Enum> object for that enum name.
  
  =head3 create_duck_type_constraint($name, $methods)
  
  Given a duck type name this function will create a new
  L<Moose::Meta::TypeConstraint::DuckType> object for that enum name.
  
  =head3 find_or_parse_type_constraint($type_name)
  
  Given a type name, this first attempts to find a matching constraint
  in the global registry.
  
  If the type name is a union or parameterized type, it will create a
  new object of the appropriate, but if given a "regular" type that does
  not yet exist, it simply returns false.
  
  When given a union or parameterized type, the member or base type must
  already exist.
  
  If it creates a new union or parameterized type, it will add it to the
  global registry.
  
  =head3 find_or_create_isa_type_constraint($type_name)
  
  =head3 find_or_create_does_type_constraint($type_name)
  
  These functions will first call C<find_or_parse_type_constraint>. If
  that function does not return a type, a new type object will
  be created.
  
  The C<isa> variant will use C<create_class_type_constraint> and the
  C<does> variant will use C<create_role_type_constraint>.
  
  =head3 get_type_constraint_registry
  
  Returns the L<Moose::Meta::TypeConstraint::Registry> object which
  keeps track of all type constraints.
  
  =head3 list_all_type_constraints
  
  This will return a list of type constraint names in the global
  registry. You can then fetch the actual type object using
  C<find_type_constraint($type_name)>.
  
  =head3 list_all_builtin_type_constraints
  
  This will return a list of builtin type constraints, meaning those
  which are defined in this module. See the L<Default Type Constraints>
  section for a complete list.
  
  =head3 export_type_constraints_as_functions
  
  This will export all the current type constraints as functions into
  the caller's namespace (C<Int()>, C<Str()>, etc). Right now, this is
  mostly used for testing, but it might prove useful to others.
  
  =head3 get_all_parameterizable_types
  
  This returns all the parameterizable types that have been registered,
  as a list of type objects.
  
  =head3 add_parameterizable_type($type)
  
  Adds C<$type> to the list of parameterizable types
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_MOOSE_UTIL_TYPECONSTRAINTS

$fatpacked{"darwin-2level/Moose/Util/TypeConstraints/Builtins.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_MOOSE_UTIL_TYPECONSTRAINTS_BUILTINS';
  package Moose::Util::TypeConstraints::Builtins;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Class::Load qw( is_class_loaded );
  use List::Util 1.33 ();
  use Scalar::Util qw( blessed );
  
  sub type { goto &Moose::Util::TypeConstraints::type }
  sub subtype { goto &Moose::Util::TypeConstraints::subtype }
  sub as { goto &Moose::Util::TypeConstraints::as }
  sub where (&) { goto &Moose::Util::TypeConstraints::where }
  sub inline_as (&) { goto &Moose::Util::TypeConstraints::inline_as }
  
  sub define_builtins {
      my $registry = shift;
  
      type 'Any'    # meta-type including all
          => where {1}
          => inline_as { '1' };
  
      subtype 'Item'  # base type
          => as 'Any'
          => inline_as { '1' };
  
      subtype 'Undef'
          => as 'Item'
          => where { !defined($_) }
          => inline_as {
              '!defined(' . $_[1] . ')'
          };
  
      subtype 'Defined'
          => as 'Item'
          => where { defined($_) }
          => inline_as {
              'defined(' . $_[1] . ')'
          };
  
      subtype 'Bool'
          => as 'Item'
          => where { !defined($_) || $_ eq "" || "$_" eq '1' || "$_" eq '0' }
          => inline_as {
              '('
                  . '!defined(' . $_[1] . ') '
                  . '|| ' . $_[1] . ' eq "" '
                  . '|| (' . $_[1] . '."") eq "1" '
                  . '|| (' . $_[1] . '."") eq "0"'
              . ')'
          };
  
      subtype 'Value'
          => as 'Defined'
          => where { !ref($_) }
          => inline_as {
              $_[0]->parent()->_inline_check($_[1])
              . ' && !ref(' . $_[1] . ')'
          };
  
      subtype 'Ref'
          => as 'Defined'
          => where { ref($_) }
              # no need to call parent - ref also checks for definedness
          => inline_as { 'ref(' . $_[1] . ')' };
  
      subtype 'Str'
          => as 'Value'
          => where { ref(\$_) eq 'SCALAR' || ref(\(my $val = $_)) eq 'SCALAR' }
          => inline_as {
              $_[0]->parent()->_inline_check($_[1])
              . ' && ('
                  . 'ref(\\' . $_[1] . ') eq "SCALAR"'
                  . ' || ref(\\(my $val = ' . $_[1] . ')) eq "SCALAR"'
              . ')'
          };
  
      my $value_type = Moose::Util::TypeConstraints::find_type_constraint('Value');
      subtype 'Num'
          => as 'Str'
          => where {
          my $val = $_;
          ($val =~ /\A[+-]?[0-9]+\z/) ||
          ( $val =~ /\A(?:[+-]?)              # matches optional +- in the beginning
          (?=[0-9]|\.[0-9])                   # matches previous +- only if there is something like 3 or .3
          [0-9]*                              # matches 0-9 zero or more times
          (?:\.[0-9]+)?                       # matches optional .89 or nothing
          (?:[Ee](?:[+-]?[0-9]+))?            # matches E1 or e1 or e-1 or e+1 etc
          \z/x );
             }
          => inline_as {
              # the long Str tests are redundant here
          #storing $_[1] in a temporary value,
          #so that $_[1] won't get converted to a string for regex match
          #see t/attributes/numeric_defaults.t for more details
          'my $val = '.$_[1].';'.
          $value_type->_inline_check('$val')
          .' && ( $val =~ /\A[+-]?[0-9]+\z/ || '
          . '$val =~ /\A(?:[+-]?)             # matches optional +- in the beginning
                  (?=[0-9]|\.[0-9])           # matches previous +- only if there is something like 3 or .3
                  [0-9]*                      # matches 0-9 zero or more times
                  (?:\.[0-9]+)?               # matches optional .89 or nothing
                  (?:[Ee](?:[+-]?[0-9]+))?    # matches E1 or e1 or e-1 or e+1 etc
                  \z/x ); '
          };
  
      subtype 'Int'
          => as 'Num'
          => where { (my $val = $_) =~ /\A-?[0-9]+\z/ }
          => inline_as {
              $value_type->_inline_check($_[1])
              . ' && (my $val = ' . $_[1] . ') =~ /\A-?[0-9]+\z/'
          };
  
      subtype 'CodeRef'
          => as 'Ref'
          => where { ref($_) eq 'CODE' }
          => inline_as { 'ref(' . $_[1] . ') eq "CODE"' };
  
      subtype 'RegexpRef'
          => as 'Ref'
          => where( \&_RegexpRef )
          => inline_as {
              'Moose::Util::TypeConstraints::Builtins::_RegexpRef(' . $_[1] . ')'
          };
  
      subtype 'GlobRef'
          => as 'Ref'
          => where { ref($_) eq 'GLOB' }
          => inline_as { 'ref(' . $_[1] . ') eq "GLOB"' };
  
      # NOTE: scalar filehandles are GLOB refs, but a GLOB ref is not always a
      # filehandle
      subtype 'FileHandle'
          => as 'Ref'
          => where {
              (ref($_) eq "GLOB" && Scalar::Util::openhandle($_))
           || (blessed($_) && $_->isa("IO::Handle"));
          }
          => inline_as {
              '(ref(' . $_[1] . ') eq "GLOB" '
              . '&& Scalar::Util::openhandle(' . $_[1] . ')) '
              . '|| (Scalar::Util::blessed(' . $_[1] . ') '
              . '&& ' . $_[1] . '->isa("IO::Handle"))'
          };
  
      subtype 'Object'
          => as 'Ref'
          => where { blessed($_) }
          => inline_as { 'Scalar::Util::blessed(' . $_[1] . ')' };
  
      subtype 'ClassName'
          => as 'Str'
          => where { is_class_loaded($_) }
              # the long Str tests are redundant here
          => inline_as { 'Class::Load::is_class_loaded(' . $_[1] . ')' };
  
      subtype 'RoleName'
          => as 'ClassName'
          => where {
              (Class::MOP::class_of($_) || return)->isa('Moose::Meta::Role');
          }
          => inline_as {
              $_[0]->parent()->_inline_check($_[1])
              . ' && do {'
                  . 'my $meta = Class::MOP::class_of(' . $_[1] . ');'
                  . '$meta && $meta->isa("Moose::Meta::Role");'
              . '}'
          };
  
      $registry->add_type_constraint(
          Moose::Meta::TypeConstraint::Parameterizable->new(
              name               => 'ScalarRef',
              package_defined_in => __PACKAGE__,
              parent =>
                  Moose::Util::TypeConstraints::find_type_constraint('Ref'),
              constraint => sub { ref($_) eq 'SCALAR' || ref($_) eq 'REF' },
              constraint_generator => sub {
                  my $type_parameter = shift;
                  my $check = $type_parameter->_compiled_type_constraint;
                  return sub {
                      return $check->( ${$_} );
                  };
              },
              inlined => sub {
                  'ref(' . $_[1] . ') eq "SCALAR" '
                    . '|| ref(' . $_[1] . ') eq "REF"'
              },
              inline_generator => sub {
                  my $self           = shift;
                  my $type_parameter = shift;
                  my $val            = shift;
                  '(ref(' . $val . ') eq "SCALAR" || ref(' . $val . ') eq "REF") '
                    . '&& ' . $type_parameter->_inline_check('${(' . $val . ')}')
              },
          )
      );
  
      $registry->add_type_constraint(
          Moose::Meta::TypeConstraint::Parameterizable->new(
              name               => 'ArrayRef',
              package_defined_in => __PACKAGE__,
              parent =>
                  Moose::Util::TypeConstraints::find_type_constraint('Ref'),
              constraint => sub { ref($_) eq 'ARRAY' },
              constraint_generator => sub {
                  my $type_parameter = shift;
                  my $check = $type_parameter->_compiled_type_constraint;
                  return sub {
                      foreach my $x (@$_) {
                          ( $check->($x) ) || return;
                      }
                      1;
                      }
              },
              inlined          => sub { 'ref(' . $_[1] . ') eq "ARRAY"' },
              inline_generator => sub {
                  my $self           = shift;
                  my $type_parameter = shift;
                  my $val            = shift;
  
                  'do {'
                      . 'my $check = ' . $val . ';'
                      . 'ref($check) eq "ARRAY" '
                          . '&& &List::Util::all('
                              . 'sub { ' . $type_parameter->_inline_check('$_') . ' }, '
                              . '@{$check}'
                          . ')'
                  . '}';
              },
          )
      );
  
      $registry->add_type_constraint(
          Moose::Meta::TypeConstraint::Parameterizable->new(
              name               => 'HashRef',
              package_defined_in => __PACKAGE__,
              parent =>
                  Moose::Util::TypeConstraints::find_type_constraint('Ref'),
              constraint => sub { ref($_) eq 'HASH' },
              constraint_generator => sub {
                  my $type_parameter = shift;
                  my $check = $type_parameter->_compiled_type_constraint;
                  return sub {
                      foreach my $x ( values %$_ ) {
                          ( $check->($x) ) || return;
                      }
                      1;
                      }
              },
              inlined          => sub { 'ref(' . $_[1] . ') eq "HASH"' },
              inline_generator => sub {
                  my $self           = shift;
                  my $type_parameter = shift;
                  my $val            = shift;
  
                  'do {'
                      . 'my $check = ' . $val . ';'
                      . 'ref($check) eq "HASH" '
                          . '&& &List::Util::all('
                              . 'sub { ' . $type_parameter->_inline_check('$_') . ' }, '
                              . 'values %{$check}'
                          . ')'
                  . '}';
              },
          )
      );
  
      $registry->add_type_constraint(
          Moose::Meta::TypeConstraint::Parameterizable->new(
              name               => 'Maybe',
              package_defined_in => __PACKAGE__,
              parent =>
                  Moose::Util::TypeConstraints::find_type_constraint('Item'),
              constraint           => sub {1},
              constraint_generator => sub {
                  my $type_parameter = shift;
                  my $check = $type_parameter->_compiled_type_constraint;
                  return sub {
                      return 1 if not( defined($_) ) || $check->($_);
                      return;
                      }
              },
              inlined          => sub {'1'},
              inline_generator => sub {
                  my $self           = shift;
                  my $type_parameter = shift;
                  my $val            = shift;
                  '!defined(' . $val . ') '
                    . '|| (' . $type_parameter->_inline_check($val) . ')'
              },
          )
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =for pod_coverage_needs_some_pod
  
  =cut
DARWIN-2LEVEL_MOOSE_UTIL_TYPECONSTRAINTS_BUILTINS

$fatpacked{"darwin-2level/Params/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_PARAMS_UTIL';
  package Params::Util;
  
  =pod
  
  =head1 NAME
  
  Params::Util - Simple, compact and correct param-checking functions
  
  =head1 SYNOPSIS
  
    # Import some functions
    use Params::Util qw{_SCALAR _HASH _INSTANCE};
    
    # If you are lazy, or need a lot of them...
    use Params::Util ':ALL';
    
    sub foo {
        my $object  = _INSTANCE(shift, 'Foo') or return undef;
        my $image   = _SCALAR(shift)          or return undef;
        my $options = _HASH(shift)            or return undef;
        # etc...
    }
  
  =head1 DESCRIPTION
  
  C<Params::Util> provides a basic set of importable functions that makes
  checking parameters a hell of a lot easier
  
  While they can be (and are) used in other contexts, the main point
  behind this module is that the functions B<both> Do What You Mean,
  and Do The Right Thing, so they are most useful when you are getting
  params passed into your code from someone and/or somewhere else
  and you can't really trust the quality.
  
  Thus, C<Params::Util> is of most use at the edges of your API, where
  params and data are coming in from outside your code.
  
  The functions provided by C<Params::Util> check in the most strictly
  correct manner known, are documented as thoroughly as possible so their
  exact behaviour is clear, and heavily tested so make sure they are not
  fooled by weird data and Really Bad Things.
  
  To use, simply load the module providing the functions you want to use
  as arguments (as shown in the SYNOPSIS).
  
  To aid in maintainability, C<Params::Util> will B<never> export by
  default.
  
  You must explicitly name the functions you want to export, or use the
  C<:ALL> param to just have it export everything (although this is not
  recommended if you have any _FOO functions yourself with which future
  additions to C<Params::Util> may clash)
  
  =head1 FUNCTIONS
  
  =cut
  
  use 5.00503;
  use strict;
  require overload;
  require Exporter;
  require Scalar::Util;
  require DynaLoader;
  
  use vars qw{$VERSION @ISA @EXPORT_OK %EXPORT_TAGS};
  
  $VERSION   = '1.07';
  @ISA       = qw{
  	Exporter
  	DynaLoader
  };
  @EXPORT_OK = qw{
  	_STRING     _IDENTIFIER
  	_CLASS      _CLASSISA   _SUBCLASS  _DRIVER  _CLASSDOES
  	_NUMBER     _POSINT     _NONNEGINT
  	_SCALAR     _SCALAR0
  	_ARRAY      _ARRAY0     _ARRAYLIKE
  	_HASH       _HASH0      _HASHLIKE
  	_CODE       _CODELIKE
  	_INVOCANT   _REGEX      _INSTANCE  _INSTANCEDOES
  	_SET        _SET0
  	_HANDLE
  };
  %EXPORT_TAGS = ( ALL => \@EXPORT_OK );
  
  eval {
  	local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
  	bootstrap Params::Util $VERSION;
  	1;
  } unless $ENV{PERL_PARAMS_UTIL_PP};
  
  # Use a private pure-perl copy of looks_like_number if the version of
  # Scalar::Util is old (for whatever reason).
  my $SU = eval "$Scalar::Util::VERSION" || 0;
  if ( $SU >= 1.18 ) { 
  	Scalar::Util->import('looks_like_number');
  } else {
  	eval <<'END_PERL';
  sub looks_like_number {
  	local $_ = shift;
  
  	# checks from perlfaq4
  	return 0 if !defined($_);
  	if (ref($_)) {
  		return overload::Overloaded($_) ? defined(0 + $_) : 0;
  	}
  	return 1 if (/^[+-]?[0-9]+$/); # is a +/- integer
  	return 1 if (/^([+-]?)(?=[0-9]|\.[0-9])[0-9]*(\.[0-9]*)?([Ee]([+-]?[0-9]+))?$/); # a C float
  	return 1 if ($] >= 5.008 and /^(Inf(inity)?|NaN)$/i) or ($] >= 5.006001 and /^Inf$/i);
  
  	0;
  }
  END_PERL
  }
  
  
  
  
  
  #####################################################################
  # Param Checking Functions
  
  =pod
  
  =head2 _STRING $string
  
  The C<_STRING> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a normal non-false string of non-zero length.
  
  Note that this will NOT do anything magic to deal with the special
  C<'0'> false negative case, but will return it.
  
    # '0' not considered valid data
    my $name = _STRING(shift) or die "Bad name";
    
    # '0' is considered valid data
    my $string = _STRING($_[0]) ? shift : die "Bad string";
  
  Please also note that this function expects a normal string. It does
  not support overloading or other magic techniques to get a string.
  
  Returns the string as a conveince if it is a valid string, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_STRING;
  sub _STRING ($) {
  	(defined $_[0] and ! ref $_[0] and length($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _IDENTIFIER $string
  
  The C<_IDENTIFIER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl identifier.
  
  Returns the string as a convenience if it is a valid identifier, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_IDENTIFIER;
  sub _IDENTIFIER ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASS $string
  
  The C<_CLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl class.
  
  This function only checks that the format is valid, not that the
  class is actually loaded. It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASS;
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASSISA $string, $class
  
  The C<_CLASSISA> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a particularly class, or a subclass of it.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSISA;
  sub _CLASSISA ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =head2 _CLASSDOES $string, $role
  
  This routine behaves exactly like C<L</_CLASSISA>>, but checks with C<< ->DOES
  >> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
  5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
  implemented.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSDOES;
  sub _CLASSDOES ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SUBCLASS $string, $class
  
  The C<_SUBCLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a subclass of a specified class.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SUBCLASS;
  sub _SUBCLASS ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0] ne $_[1] and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NUMBER $scalar
  
  The C<_NUMBER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a number. That is, it is defined and perl thinks it's a number.
  
  This function is basically a Params::Util-style wrapper around the
  L<Scalar::Util> C<looks_like_number> function.
  
  Returns the value as a convience, or C<undef> if the value is not a
  number.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NUMBER;
  sub _NUMBER ($) {
  	( defined $_[0] and ! ref $_[0] and looks_like_number($_[0]) )
  	? $_[0]
  	: undef;
  }
  END_PERL
  
  =pod
  
  =head2 _POSINT $integer
  
  The C<_POSINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a positive integer (of any length).
  
  Returns the value as a convience, or C<undef> if the value is not a
  positive integer.
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_POSINT;
  sub _POSINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[1-9]\d*$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NONNEGINT $integer
  
  The C<_NONNEGINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a non-negative integer (of any length). That is, a positive integer,
  or zero.
  
  Returns the value as a convience, or C<undef> if the value is not a
  non-negative integer.
  
  As with other tests that may return false values, care should be taken
  to test via "defined" in boolean validy contexts.
  
    unless ( defined _NONNEGINT($value) ) {
       die "Invalid value";
    }
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NONNEGINT;
  sub _NONNEGINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^(?:0|[1-9]\d*)$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR \$scalar
  
  The C<_SCALAR> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR> reference, with content of non-zero length.
  
  For a version that allows zero length C<SCALAR> references, see
  the C<_SCALAR0> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR;
  sub _SCALAR ($) {
  	(ref $_[0] eq 'SCALAR' and defined ${$_[0]} and ${$_[0]} ne '') ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR0 \$scalar
  
  The C<_SCALAR0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR0> reference, allowing content of zero-length.
  
  For a simpler "give me some content" version that requires non-zero
  length, C<_SCALAR> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR0;
  sub _SCALAR0 ($) {
  	ref $_[0] eq 'SCALAR' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY $value
  
  The C<_ARRAY> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference containing B<at least> one element of any kind.
  
  For a more basic form that allows zero length ARRAY references, see
  the C<_ARRAY0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY;
  sub _ARRAY ($) {
  	(ref $_[0] eq 'ARRAY' and @{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY0 $value
  
  The C<_ARRAY0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference, allowing C<ARRAY> references that contain no
  elements.
  
  For a more basic "An array of something" form that also requires at
  least one element, see the C<_ARRAY> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY0;
  sub _ARRAY0 ($) {
  	ref $_[0] eq 'ARRAY' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAYLIKE $value
  
  The C<_ARRAYLIKE> function tests whether a given scalar value can respond to
  array dereferencing.  If it can, the value is returned.  If it cannot,
  C<_ARRAYLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAYLIKE;
  sub _ARRAYLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'ARRAY')
  		or
  		overload::Method($_[0], '@{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH $value
  
  The C<_HASH> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference with at least one entry.
  
  For a version of this function that allows the C<HASH> to be empty,
  see the C<_HASH0> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH;
  sub _HASH ($) {
  	(ref $_[0] eq 'HASH' and scalar %{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH0 $value
  
  The C<_HASH0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference, regardless of the C<HASH> content.
  
  For a simpler "A hash of something" version that requires at least one
  element, see the C<_HASH> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH0;
  sub _HASH0 ($) {
  	ref $_[0] eq 'HASH' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASHLIKE $value
  
  The C<_HASHLIKE> function tests whether a given scalar value can respond to
  hash dereferencing.  If it can, the value is returned.  If it cannot,
  C<_HASHLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASHLIKE;
  sub _HASHLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'HASH')
  		or
  		overload::Method($_[0], '%{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODE $value
  
  The C<_CODE> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<CODE> reference.
  
  Returns the C<CODE> reference itself as a convenience, or C<undef>
  if the value provided is not an C<CODE> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODE;
  sub _CODE ($) {
  	ref $_[0] eq 'CODE' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODELIKE $value
  
  The C<_CODELIKE> is the more generic version of C<_CODE>. Unlike C<_CODE>,
  which checks for an explicit C<CODE> reference, the C<_CODELIKE> function
  also includes things that act like them, such as blessed objects that
  overload C<'&{}'>.
  
  Please note that in the case of objects overloaded with '&{}', you will
  almost always end up also testing it in 'bool' context at some stage.
  
  For example:
  
    sub foo {
        my $code1 = _CODELIKE(shift) or die "No code param provided";
        my $code2 = _CODELIKE(shift);
        if ( $code2 ) {
             print "Got optional second code param";
        }
    }
  
  As such, you will most likely always want to make sure your class has
  at least the following to allow it to evaluate to true in boolean
  context.
  
    # Always evaluate to true in boolean context
    use overload 'bool' => sub () { 1 };
  
  Returns the callable value as a convenience, or C<undef> if the
  value provided is not callable.
  
  Note - This function was formerly known as _CALLABLE but has been renamed
  for greater symmetry with the other _XXXXLIKE functions.
  
  The use of _CALLABLE has been deprecated. It will continue to work, but
  with a warning, until end-2006, then will be removed.
  
  I apologise for any inconvenience caused.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODELIKE;
  sub _CODELIKE($) {
  	(
  		(Scalar::Util::reftype($_[0])||'') eq 'CODE'
  		or
  		Scalar::Util::blessed($_[0]) and overload::Method($_[0],'&{}')
  	)
  	? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INVOCANT $value
  
  This routine tests whether the given value is a valid method invocant.
  This can be either an instance of an object, or a class name.
  
  If so, the value itself is returned.  Otherwise, C<_INVOCANT>
  returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INVOCANT;
  sub _INVOCANT($) {
  	(defined $_[0] and
  		(defined Scalar::Util::blessed($_[0])
  		or      
  		# We used to check for stash definedness, but any class-like name is a
  		# valid invocant for UNIVERSAL methods, so we stopped. -- rjbs, 2006-07-02
  		Params::Util::_CLASS($_[0]))
  	) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INSTANCE $object, $class
  
  The C<_INSTANCE> function is intended to be imported into your package,
  and provides a convenient way to test for an object of a particular class
  in a strictly correct manner.
  
  Returns the object itself as a convenience, or C<undef> if the value
  provided is not an object of that type.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCE;
  sub _INSTANCE ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =head2 _INSTANCEDOES $object, $role
  
  This routine behaves exactly like C<L</_INSTANCE>>, but checks with C<< ->DOES
  >> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
  5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
  implemented.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCEDOES;
  sub _INSTANCEDOES ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _REGEX $value
  
  The C<_REGEX> function is intended to be imported into your package,
  and provides a convenient way to test for a regular expression.
  
  Returns the value itself as a convenience, or C<undef> if the value
  provided is not a regular expression.
  
  =cut
  
  eval <<'END_PERL' unless defined &_REGEX;
  sub _REGEX ($) {
  	(defined $_[0] and 'Regexp' eq ref($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SET \@array, $class
  
  The C<_SET> function is intended to be imported into your package,
  and provides a convenient way to test for set of at least one object of
  a particular class in a strictly correct manner.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that allows zero-length sets, see the
  C<_SET0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET;
  sub _SET ($$) {
  	my $set = shift;
  	_ARRAY($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _SET0 \@array, $class
  
  The C<_SET0> function is intended to be imported into your package,
  and provides a convenient way to test for a set of objects of a
  particular class in a strictly correct manner, allowing for zero objects.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that requires at least one object, see the
  C<_SET> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET0;
  sub _SET0 ($$) {
  	my $set = shift;
  	_ARRAY0($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _HANDLE
  
  The C<_HANDLE> function is intended to be imported into your package,
  and provides a convenient way to test whether or not a single scalar
  value is a file handle.
  
  Unfortunately, in Perl the definition of a file handle can be a little
  bit fuzzy, so this function is likely to be somewhat imperfect (at first
  anyway).
  
  That said, it is implement as well or better than the other file handle
  detectors in existance (and we stole from the best of them).
  
  =cut
  
  # We're doing this longhand for now. Once everything is perfect,
  # we'll compress this into something that compiles more efficiently.
  # Further, testing file handles is not something that is generally
  # done millions of times, so doing it slowly is not a big speed hit.
  eval <<'END_PERL' unless defined &_HANDLE;
  sub _HANDLE {
  	my $it = shift;
  
  	# It has to be defined, of course
  	unless ( defined $it ) {
  		return undef;
  	}
  
  	# Normal globs are considered to be file handles
  	if ( ref $it eq 'GLOB' ) {
  		return $it;
  	}
  
  	# Check for a normal tied filehandle
  	# Side Note: 5.5.4's tied() and can() doesn't like getting undef
  	if ( tied($it) and tied($it)->can('TIEHANDLE') ) {
  		return $it;
  	}
  
  	# There are no other non-object handles that we support
  	unless ( Scalar::Util::blessed($it) ) {
  		return undef;
  	}
  
  	# Check for a common base classes for conventional IO::Handle object
  	if ( $it->isa('IO::Handle') ) {
  		return $it;
  	}
  
  
  	# Check for tied file handles using Tie::Handle
  	if ( $it->isa('Tie::Handle') ) {
  		return $it;
  	}
  
  	# IO::Scalar is not a proper seekable, but it is valid is a
  	# regular file handle
  	if ( $it->isa('IO::Scalar') ) {
  		return $it;
  	}
  
  	# Yet another special case for IO::String, which refuses (for now
  	# anyway) to become a subclass of IO::Handle.
  	if ( $it->isa('IO::String') ) {
  		return $it;
  	}
  
  	# This is not any sort of object we know about
  	return undef;
  }
  END_PERL
  
  =pod
  
  =head2 _DRIVER $string
  
    sub foo {
      my $class = _DRIVER(shift, 'My::Driver::Base') or die "Bad driver";
      ...
    }
  
  The C<_DRIVER> function is intended to be imported into your
  package, and provides a convenient way to load and validate
  a driver class.
  
  The most common pattern when taking a driver class as a parameter
  is to check that the name is a class (i.e. check against _CLASS)
  and then to load the class (if it exists) and then ensure that
  the class returns true for the isa method on some base driver name.
  
  Return the value as a convenience, or C<undef> if the value is not
  a class name, the module does not exist, the module does not load,
  or the class fails the isa test.
  
  =cut
  
  eval <<'END_PERL' unless defined &_DRIVER;
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  END_PERL
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Add _CAN to help resolve the UNIVERSAL::can debacle
  
  - Would be even nicer if someone would demonstrate how the hell to
  build a Module::Install dist of the ::Util dual Perl/XS type. :/
  
  - Implement an assertion-like version of this module, that dies on
  error.
  
  - Implement a Test:: version of this module, for use in testing
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params-Util>
  
  For other issues, contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Params::Validate>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2012 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
DARWIN-2LEVEL_PARAMS_UTIL

$fatpacked{"darwin-2level/Sub/Identify.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_SUB_IDENTIFY';
  package Sub::Identify;
  
  use strict;
  use Exporter;
  
  BEGIN {
      our $VERSION = '0.14';
      our @ISA = ('Exporter');
      our %EXPORT_TAGS = (
          all => [
              our @EXPORT_OK = qw(
                  sub_name
                  stash_name
                  sub_fullname
                  get_code_info
                  get_code_location
                  is_sub_constant
              )
          ]
      );
  
      our $IsPurePerl = 1;
      unless ($ENV{PERL_SUB_IDENTIFY_PP}) {
          if (
              eval {
                  require XSLoader;
                  XSLoader::load(__PACKAGE__, $VERSION);
                  1;
              }
          ) {
              $IsPurePerl = 0;
          }
          else {
              die $@ if $@ && $@ !~ /object version|loadable object/;
          }
      }
  
      if ($IsPurePerl) {
          require B;
          *get_code_info = sub ($) {
              my ($coderef) = @_;
              ref $coderef or return;
              my $cv = B::svref_2object($coderef);
              $cv->isa('B::CV') or return;
              # bail out if GV is undefined
              $cv->GV->isa('B::SPECIAL') and return;
  
              return ($cv->GV->STASH->NAME, $cv->GV->NAME);
          };
          *get_code_location = sub ($) {
              my ($coderef) = @_;
              ref $coderef or return;
              my $cv = B::svref_2object($coderef);
              $cv->isa('B::CV') && $cv->START->isa('B::COP')
                  or return;
  
              return ($cv->START->file, $cv->START->line);
          };
      }
      if ($IsPurePerl || $] < 5.016) {
          require B;
          *is_sub_constant = sub ($) {
              my ($coderef) = @_;
              ref $coderef or return 0;
              my $cv = B::svref_2object($coderef);
              $cv->isa('B::CV') or return 0;
              my $p = prototype $coderef;
              defined $p && $p eq "" or return 0;
              return ($cv->CvFLAGS & B::CVf_CONST()) == B::CVf_CONST();
          };
      }
  }
  
  sub stash_name   ($) { (get_code_info($_[0]))[0] }
  sub sub_name     ($) { (get_code_info($_[0]))[1] }
  sub sub_fullname ($) { join '::', get_code_info($_[0]) }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Sub::Identify - Retrieve names of code references
  
  =head1 SYNOPSIS
  
      use Sub::Identify ':all';
      my $subname = sub_name( $some_coderef );
      my $packagename = stash_name( $some_coderef );
      # or, to get all at once...
      my $fully_qualified_name = sub_fullname( $some_coderef );
      defined $subname
          and say "this coderef points to sub $subname in package $packagename";
      my ($file, $line) = get_code_location( $some_coderef );
      $file
          and say "this coderef is defined at line $line in file $file";
      is_sub_constant( $some_coderef )
          and say "this coderef points to a constant subroutine";
  
  =head1 DESCRIPTION
  
  C<Sub::Identify> allows you to retrieve the real name of code references.
  
  It provides six functions, all of them taking a code reference.
  
  C<sub_name> returns the name of the code reference passed as an
  argument (or C<__ANON__> if it's an anonymous code reference),
  C<stash_name> returns its package, and C<sub_fullname> returns the
  concatenation of the two.
  
  C<get_code_info> returns a list of two elements, the package and the
  subroutine name (in case of you want both and are worried by the speed.)
  
  In case of subroutine aliasing, those functions always return the
  original name.
  
  C<get_code_location> returns a two-element list containing the file
  name and the line number where the subroutine has been defined.
  
  C<is_sub_constant> returns a boolean value indicating whether the
  subroutine is a constant or not.
  
  =head2 Pure-Perl version
  
  By default C<Sub::Identify> tries to load an XS implementation of the
  C<get_code_info>, C<get_code_location> and (on perl versions 5.16.0 and later)
  C<is_sub_constant> functions, for speed; if that fails, or if the environment
  variable C<PERL_SUB_IDENTIFY_PP> is defined to a true value, it will fall
  back to a pure perl implementation, that uses perl's introspection mechanism,
  provided by the C<B> module.
  
  =head1 SEE ALSO
  
  L<Sub::Util>, part of the module distribution L<Scalar::List::Utils>
  since version 1.40. Since this will be a core module starting with perl
  5.22.0, it is encouraged to migrate to Sub::Util when possible.
  
  L<Sub::Name>
  
  =head1 SOURCE
  
  A git repository for the sources is at L<https://github.com/rgs/Sub-Identify>.
  
  =head1 LICENSE
  
  (c) Rafael Garcia-Suarez (rgs at consttype dot org) 2005, 2008, 2012, 2014, 2015
  
  This program is free software; you may redistribute it and/or modify it under
  the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_SUB_IDENTIFY

$fatpacked{"darwin-2level/Sub/Name.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_SUB_NAME';
  package Sub::Name; # git description: v0.20-2-gc0a0e62
  # ABSTRACT: (Re)name a sub
  # KEYWORDS: subroutine function utility name rename symbol
  
  #pod =pod
  #pod
  #pod =head1 SYNOPSIS
  #pod
  #pod     use Sub::Name;
  #pod
  #pod     subname $name, $subref;
  #pod
  #pod     $subref = subname foo => sub { ... };
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This module has only one function, which is also exported by default:
  #pod
  #pod =for stopwords subname
  #pod
  #pod =head2 subname NAME, CODEREF
  #pod
  #pod Assigns a new name to referenced sub.  If package specification is omitted in
  #pod the name, then the current package is used.  The return value is the sub.
  #pod
  #pod The name is only used for informative routines (caller, Carp, etc).  You won't
  #pod be able to actually invoke the sub by the given name.  To allow that, you need
  #pod to do glob-assignment yourself.
  #pod
  #pod Note that for anonymous closures (subs that reference lexicals declared outside
  #pod the sub itself) you can name each instance of the closure differently, which
  #pod can be very useful for debugging.
  #pod
  #pod =head1 SEE ALSO
  #pod
  #pod =for :list
  #pod * L<Sub::Identify> - for getting information about subs
  #pod * L<Sub::Util> - set_subname is another implementation of C<subname>
  #pod
  #pod =for stopwords cPanel
  #pod
  #pod =head1 COPYRIGHT AND LICENSE
  #pod
  #pod This software is copyright (c) 2004, 2008 by Matthijs van Duin, all rights reserved;
  #pod copyright (c) 2014 cPanel Inc., all rights reserved.
  #pod
  #pod This program is free software; you can redistribute it and/or modify
  #pod it under the same terms as Perl itself.
  #pod
  #pod =cut
  
  use 5.006;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.21';
  
  use Exporter 5.57 'import';
  
  our @EXPORT = qw(subname);
  our @EXPORT_OK = @EXPORT;
  
  use XSLoader;
  XSLoader::load(
      __PACKAGE__,
      $VERSION,
  );
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Sub::Name - (Re)name a sub
  
  =head1 VERSION
  
  version 0.21
  
  =head1 SYNOPSIS
  
      use Sub::Name;
  
      subname $name, $subref;
  
      $subref = subname foo => sub { ... };
  
  =head1 DESCRIPTION
  
  This module has only one function, which is also exported by default:
  
  =for stopwords subname
  
  =head2 subname NAME, CODEREF
  
  Assigns a new name to referenced sub.  If package specification is omitted in
  the name, then the current package is used.  The return value is the sub.
  
  The name is only used for informative routines (caller, Carp, etc).  You won't
  be able to actually invoke the sub by the given name.  To allow that, you need
  to do glob-assignment yourself.
  
  Note that for anonymous closures (subs that reference lexicals declared outside
  the sub itself) you can name each instance of the closure differently, which
  can be very useful for debugging.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<Sub::Identify> - for getting information about subs
  
  =item *
  
  L<Sub::Util> - set_subname is another implementation of C<subname>
  
  =back
  
  =for stopwords cPanel
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Sub-Name>
  (or L<bug-Sub-Name@rt.cpan.org|mailto:bug-Sub-Name@rt.cpan.org>).
  
  There is also an irc channel available for users of this distribution, at
  L<C<#toolchain> on C<irc.perl.org>|irc://irc.perl.org/#toolchain>.
  
  =head1 AUTHOR
  
  Matthijs van Duin <xmath@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Karen Etheridge Leon Timmermans Florian Ragwitz Reini Urban Matthijs van Duin gfx Dagfinn Ilmari Mannsåker Aristotle Pagaltzis J.R. Mash Alexander Bluhm
  
  =over 4
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Leon Timmermans <fawaka@gmail.com>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Reini Urban <rurban@cpanel.net>
  
  =item *
  
  Matthijs van Duin <xmath-no-spam@nospam.cpan.org>
  
  =item *
  
  gfx <gfuji@cpan.org>
  
  =item *
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =item *
  
  Aristotle Pagaltzis <pagaltzis@gmx.de>
  
  =item *
  
  J.R. Mash <jmash.code@gmail.com>
  
  =item *
  
  Alexander Bluhm <alexander.bluhm@gmx.net>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2004, 2008 by Matthijs van Duin, all rights reserved;
  copyright (c) 2014 cPanel Inc., all rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_SUB_NAME

$fatpacked{"darwin-2level/Test/Moose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_TEST_MOOSE';
  package Test::Moose;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Sub::Exporter;
  use Test::Builder;
  
  use List::Util 1.33 'all';
  use Moose::Util 'does_role', 'find_meta';
  
  my @exports = qw[
      meta_ok
      does_ok
      has_attribute_ok
      with_immutable
  ];
  
  Sub::Exporter::setup_exporter({
      exports => \@exports,
      groups  => { default => \@exports }
  });
  
  ## the test builder instance ...
  
  my $Test = Test::Builder->new;
  
  ## exported functions
  
  sub meta_ok ($;$) {
      my ($class_or_obj, $message) = @_;
  
      $message ||= "The object has a meta";
  
      if (find_meta($class_or_obj)) {
          return $Test->ok(1, $message)
      }
      else {
          return $Test->ok(0, $message);
      }
  }
  
  sub does_ok ($$;$) {
      my ($class_or_obj, $does, $message) = @_;
  
      $message ||= "The object does $does";
  
      if (does_role($class_or_obj, $does)) {
          return $Test->ok(1, $message)
      }
      else {
          return $Test->ok(0, $message);
      }
  }
  
  sub has_attribute_ok ($$;$) {
      my ($class_or_obj, $attr_name, $message) = @_;
  
      $message ||= "The object does has an attribute named $attr_name";
  
      my $meta = find_meta($class_or_obj);
  
      if ($meta->find_attribute_by_name($attr_name)) {
          return $Test->ok(1, $message)
      }
      else {
          return $Test->ok(0, $message);
      }
  }
  
  sub with_immutable (&@) {
      my $block = shift;
      my $before = $Test->current_test;
  
      $block->(0);
      Class::MOP::class_of($_)->make_immutable for @_;
      $block->(1);
  
      my $num_tests = $Test->current_test - $before;
      my $all_passed = all { $_ } ($Test->summary)[-$num_tests..-1];
      return $all_passed;
  }
  
  1;
  
  # ABSTRACT: Test functions for Moose specific features
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test::Moose - Test functions for Moose specific features
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 SYNOPSIS
  
    use Test::More plan => 1;
    use Test::Moose;
  
    meta_ok($class_or_obj, "... Foo has a ->meta");
    does_ok($class_or_obj, $role, "... Foo does the Baz role");
    has_attribute_ok($class_or_obj, $attr_name, "... Foo has the 'bar' attribute");
  
  =head1 DESCRIPTION
  
  This module provides some useful test functions for Moose based classes. It
  is an experimental first release, so comments and suggestions are very welcome.
  
  =head1 EXPORTED FUNCTIONS
  
  =head2 meta_ok ($class_or_object)
  
  Tests if a class or object has a metaclass.
  
  =head2 does_ok ($class_or_object, $role, ?$message)
  
  Tests if a class or object does a certain role, similar to what C<isa_ok>
  does for the C<isa> method.
  
  =head2 has_attribute_ok($class_or_object, $attr_name, ?$message)
  
  Tests if a class or object has a certain attribute, similar to what C<can_ok>
  does for the methods.
  
  =head2 with_immutable { CODE } @class_names
  
  Runs B<CODE> (which should contain normal tests) twice, and make each
  class in C<@class_names> immutable in between the two runs.
  
  The B<CODE> block is called with a single boolean argument indicating whether
  or not the classes have been made immutable yet.
  
  =head1 TODO
  
  =over 4
  
  =item Convert the Moose test suite to use this module.
  
  =item Here is a list of possible functions to write
  
  =over 4
  
  =item immutability predicates
  
  =item anon-class predicates
  
  =item discovering original method from modified method
  
  =item attribute metaclass predicates (attribute_isa?)
  
  =back
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<Test::More>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_TEST_MOOSE

$fatpacked{"darwin-2level/metaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_METACLASS';
  package metaclass;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Module::Runtime 'use_package_optimistically', 'use_module';
  use Class::MOP;
  
  sub import {
      my ( $class, @args ) = @_;
  
      unshift @args, "metaclass" if @args % 2 == 1;
      my %options = @args;
  
      my $meta_name = exists $options{meta_name} ? $options{meta_name} : 'meta';
      my $metaclass = delete $options{metaclass};
  
      unless ( defined $metaclass ) {
          $metaclass = "Class::MOP::Class";
      } else {
          use_package_optimistically($metaclass);
      }
  
      ($metaclass->isa('Class::MOP::Class'))
          || die use_module('Moose::Exception::MetaclassMustBeDerivedFromClassMOPClass')->new( class_name => $metaclass );
  
      # make sure the custom metaclasses get loaded
      foreach my $key (grep { /_(?:meta)?class$/ } keys %options) {
          unless ( ref( my $class = $options{$key} ) ) {
              use_package_optimistically($class)
          }
      }
  
      my $package = caller();
  
      # create a meta object so we can install &meta
      my $meta = $metaclass->initialize($package => %options);
      $meta->_add_meta_method($meta_name)
          if defined $meta_name;
  }
  
  1;
  
  # ABSTRACT: a pragma for installing and using Class::MOP metaclasses
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  metaclass - a pragma for installing and using Class::MOP metaclasses
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 SYNOPSIS
  
    package MyClass;
  
    # use Class::MOP::Class
    use metaclass;
  
    # ... or use a custom metaclass
    use metaclass 'MyMetaClass';
  
    # ... or use a custom metaclass
    # and custom attribute and method
    # metaclasses
    use metaclass 'MyMetaClass' => (
        'attribute_metaclass' => 'MyAttributeMetaClass',
        'method_metaclass'    => 'MyMethodMetaClass',
    );
  
    # ... or just specify custom attribute
    # and method classes, and Class::MOP::Class
    # is the assumed metaclass
    use metaclass (
        'attribute_metaclass' => 'MyAttributeMetaClass',
        'method_metaclass'    => 'MyMethodMetaClass',
    );
  
    # if we'd rather not install a 'meta' method, we can do this
    use metaclass meta_name => undef;
    # or if we'd like it to have a different name,
    use metaclass meta_name => 'my_meta';
  
  =head1 DESCRIPTION
  
  This is a pragma to make it easier to use a specific metaclass
  and a set of custom attribute and method metaclasses. It also
  installs a C<meta> method to your class as well, unless C<undef>
  is passed to the C<meta_name> option.
  
  Note that if you are using Moose, you most likely do B<not> want
  to be using this - look into L<Moose::Util::MetaRole> instead.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_METACLASS

$fatpacked{"darwin-2level/oose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_OOSE';
  package oose;
  our $VERSION = '2.2011';
  
  use strict;
  use warnings;
  
  use Moose::Util ();
  
  BEGIN {
      my $package;
      sub import {
          $package = $_[1] || 'Class';
          if ($package =~ /^\+/) {
              $package =~ s/^\+//;
              Moose::Util::_load_user_class($package);
          }
      }
      use Filter::Simple sub { s/^/package $package;\nuse Moose;use Moose::Util::TypeConstraints;\n/; }
  }
  
  1;
  
  # ABSTRACT: syntactic sugar to make Moose one-liners easier
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  oose - syntactic sugar to make Moose one-liners easier
  
  =head1 VERSION
  
  version 2.2011
  
  =head1 SYNOPSIS
  
    # create a Moose class on the fly ...
    perl -Moose=Foo -e 'has bar => ( is=>q[ro], default => q[baz] ); print Foo->new->bar' # prints baz
  
    # loads an existing class (Moose or non-Moose)
    # and re-"opens" the package definition to make
    # debugging/introspection easier
    perl -Moose=+My::Class -e 'print join ", " => __PACKAGE__->meta->get_method_list'
  
    # also loads Moose::Util::TypeConstraints to allow subtypes etc
    perl -Moose=Person -e'subtype q[ValidAge] => as q[Int] => where { $_ > 0 && $_ < 78 }; has => age ( isa => q[ValidAge], is => q[ro]); Person->new(age => 90)'
  
  =head1 DESCRIPTION
  
  oose.pm is a simple source filter that adds
  C<package $name; use Moose; use Moose::Util::TypeConstraints;>
  to the beginning of your script and was entirely created because typing
  C<perl -e'package Foo; use Moose; ...'> was annoying me.
  
  =head1 INTERFACE
  
  oose provides exactly one method and it's automatically called by perl:
  
  =over 4
  
  =item B<import($package)>
  
  Pass a package name to import to be used by the source filter. The
  package defaults to C<Class> if none is given.
  
  =back
  
  =head1 DEPENDENCIES
  
  You will need L<Filter::Simple> and eventually L<Moose>
  
  =head1 INCOMPATIBILITIES
  
  None reported. But it is a source filter and might have issues there.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DARWIN-2LEVEL_OOSE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/Users/st21277/perl5/perlbrew/perls/perl-5.18.4/bin/perl

use strict;
use warnings;
# PODNAME: moose-outdated

# this script was generated with Dist::Zilla::Plugin::Conflicts 0.19

use Getopt::Long;
use Moose::Conflicts;

my $verbose;
GetOptions( 'verbose|v' => \$verbose );

if ($verbose) {
    Moose::Conflicts->check_conflicts;
}
else {
    my @conflicts = Moose::Conflicts->calculate_conflicts;
    print "$_\n" for map { $_->{package} } @conflicts;
    exit @conflicts;
}
