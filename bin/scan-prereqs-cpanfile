#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Module/CPANfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE';
  package Module::CPANfile;
  use strict;
  use warnings;
  use Cwd;
  use Carp ();
  use Module::CPANfile::Environment;
  use Module::CPANfile::Requirement;
  
  our $VERSION = '1.1001';
  
  sub new {
      my($class, $file) = @_;
      bless {}, $class;
  }
  
  sub load {
      my($proto, $file) = @_;
  
      my $self = ref $proto ? $proto : $proto->new;
      $self->parse($file || Cwd::abs_path('cpanfile'));
      $self;
  }
  
  sub save {
      my($self, $path) = @_;
  
      open my $out, ">", $path or die "$path: $!";
      print {$out} $self->to_string;
  }
  
  sub parse {
      my($self, $file) = @_;
  
      my $code = do {
          open my $fh, "<", $file or die "$file: $!";
          join '', <$fh>;
      };
  
      my $env = Module::CPANfile::Environment->new($file);
      $env->parse($code) or die $@;
  
      $self->{_mirrors} = $env->mirrors;
      $self->{_prereqs} = $env->prereqs;
  }
  
  sub from_prereqs {
      my($proto, $prereqs) = @_;
  
      my $self = $proto->new;
      $self->{_prereqs} = Module::CPANfile::Prereqs->from_cpan_meta($prereqs);
  
      $self;
  }
  
  sub mirrors {
      my $self = shift;
      $self->{_mirrors} || [];
  }
  
  sub features {
      my $self = shift;
      map $self->feature($_), $self->{_prereqs}->identifiers;
  }
  
  sub feature {
      my($self, $identifier) = @_;
      $self->{_prereqs}->feature($identifier);
  }
  
  sub prereq { shift->prereqs }
  
  sub prereqs {
      my $self = shift;
      $self->{_prereqs}->as_cpan_meta;
  }
  
  sub merged_requirements {
      my $self = shift;
      $self->{_prereqs}->merged_requirements;
  }
  
  sub effective_prereqs {
      my($self, $features) = @_;
      $self->prereqs_with(@{$features || []});
  }
  
  sub prereqs_with {
      my($self, @feature_identifiers) = @_;
  
      my $prereqs = $self->prereqs;
      my @others = map { $self->feature($_)->prereqs } @feature_identifiers;
  
      $prereqs->with_merged_prereqs(\@others);
  }
  
  sub prereq_specs {
      my $self = shift;
      $self->prereqs->as_string_hash;
  }
  
  sub prereq_for_module {
      my($self, $module) = @_;
      $self->{_prereqs}->find($module);
  }
  
  sub options_for_module {
      my($self, $module) = @_;
      my $prereq = $self->prereq_for_module($module) or return;
      $prereq->requirement->options;
  }
  
  sub merge_meta {
      my($self, $file, $version) = @_;
  
      require CPAN::Meta;
  
      $version ||= $file =~ /\.yml$/ ? '1.4' : '2';
  
      my $prereq = $self->prereqs;
  
      my $meta = CPAN::Meta->load_file($file);
      my $prereqs_hash = $prereq->with_merged_prereqs($meta->effective_prereqs)->as_string_hash;
      my $struct = { %{$meta->as_struct}, prereqs => $prereqs_hash };
  
      CPAN::Meta->new($struct)->save($file, { version => $version });
  }
  
  sub _dump {
      my $str = shift;
      require Data::Dumper;
      chomp(my $value = Data::Dumper->new([$str])->Terse(1)->Dump);
      $value;
  }
  
  sub to_string {
      my($self, $include_empty) = @_;
  
      my $mirrors = $self->mirrors;
      my $prereqs = $self->prereq_specs;
  
      my $code = '';
      $code .= $self->_dump_mirrors($mirrors);
      $code .= $self->_dump_prereqs($prereqs, $include_empty);
  
      for my $feature ($self->features) {
          $code .= sprintf "feature %s, %s => sub {\n", _dump($feature->{identifier}), _dump($feature->{description});
          $code .= $self->_dump_prereqs($feature->{spec}, $include_empty, 4);
          $code .= "}\n\n";
      }
  
      $code =~ s/\n+$/\n/s;
      $code;
  }
  
  sub _dump_mirrors {
      my($self, $mirrors) = @_;
  
      my $code = "";
  
      for my $url (@$mirrors) {
          $code .= "mirror '$url';\n";
      }
  
      $code =~ s/\n+$/\n/s;
      $code;
  }
  
  sub _dump_prereqs {
      my($self, $prereqs, $include_empty, $base_indent) = @_;
  
      my $code = '';
      for my $phase (qw(runtime configure build test develop)) {
          my $indent = $phase eq 'runtime' ? '' : '    ';
          $indent = (' ' x ($base_indent || 0)) . $indent;
  
          my($phase_code, $requirements);
          $phase_code .= "on $phase => sub {\n" unless $phase eq 'runtime';
  
          for my $type (qw(requires recommends suggests conflicts)) {
              for my $mod (sort keys %{$prereqs->{$phase}{$type}}) {
                  my $ver = $prereqs->{$phase}{$type}{$mod};
                  $phase_code .= $ver eq '0'
                               ? "${indent}$type '$mod';\n"
                               : "${indent}$type '$mod', '$ver';\n";
                  $requirements++;
              }
          }
  
          $phase_code .= "\n" unless $requirements;
          $phase_code .= "};\n" unless $phase eq 'runtime';
  
          $code .= $phase_code . "\n" if $requirements or $include_empty;
      }
  
      $code =~ s/\n+$/\n/s;
      $code;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Module::CPANfile - Parse cpanfile
  
  =head1 SYNOPSIS
  
    use Module::CPANfile;
  
    my $file = Module::CPANfile->load("cpanfile");
    my $prereqs = $file->prereqs; # CPAN::Meta::Prereqs object
  
    my @features = $file->features; # CPAN::Meta::Feature objects
    my $merged_prereqs = $file->prereqs_with(@identifiers); # CPAN::Meta::Prereqs
  
    $file->merge_meta('MYMETA.json');
  
  =head1 DESCRIPTION
  
  Module::CPANfile is a tool to handle L<cpanfile> format to load application
  specific dependencies, not just for CPAN distributions.
  
  =head1 METHODS
  
  =over 4
  
  =item load
  
    $file = Module::CPANfile->load;
    $file = Module::CPANfile->load('cpanfile');
  
  Load and parse a cpanfile. By default it tries to load C<cpanfile> in
  the current directory, unless you pass the path to its argument.
  
  =item from_prereqs
  
    $file = Module::CPANfile->from_prereqs({
      runtime => { requires => { DBI => '1.000' } },
    });
  
  Creates a new Module::CPANfile object from prereqs hash you can get
  via L<CPAN::Meta>'s C<prereqs>, or L<CPAN::Meta::Prereqs>'
  C<as_string_hash>.
  
    # read MYMETA, then feed the prereqs to create Module::CPANfile
    my $meta = CPAN::Meta->load_file('MYMETA.json');
    my $file = Module::CPANfile->from_prereqs($meta->prereqs);
  
    # load cpanfile, then recreate it with round-trip
    my $file = Module::CPANfile->load('cpanfile');
    $file = Module::CPANfile->from_prereqs($file->prereq_specs);
                                      # or $file->prereqs->as_string_hash
  
  =item prereqs
  
  Returns L<CPAN::Meta::Prereqs> object out of the parsed cpanfile.
  
  =item prereq_specs
  
  Returns a hash reference that should be passed to C<< CPAN::Meta::Prereqs->new >>.
  
  =item features
  
  Returns a list of features available in the cpanfile as L<CPAN::Meta::Feature>.
  
  =item prereqs_with(@identifiers), effective_prereqs(\@identifiers)
  
  Returns L<CPAN::Meta::Prereqs> object, with merged prereqs for
  features identified with the C<@identifiers>.
  
  =item to_string($include_empty)
  
    $file->to_string;
    $file->to_string(1);
  
  Returns a canonical string (code) representation for cpanfile. Useful
  if you want to convert L<CPAN::Meta::Prereqs> to a new cpanfile.
  
    # read MYMETA's prereqs and print cpanfile representation of it
    my $meta = CPAN::Meta->load_file('MYMETA.json');
    my $file = Module::CPANfile->from_prereqs($meta->prereqs);
    print $file->to_string;
  
  By default, it omits the phase where there're no modules
  registered. If you pass the argument of a true value, it will print
  them as well.
  
  =item save
  
    $file->save('cpanfile');
  
  Saves the currently loaded prereqs as a new C<cpanfile> by calling
  C<to_string>. Beware B<this method will overwrite the existing
  cpanfile without any warning or backup>. Taking a backup or giving
  warnings to users is a caller's responsibility.
  
    # Read MYMETA.json and creates a new cpanfile
    my $meta = CPAN::Meta->load_file('MYMETA.json');
    my $file = Module::CPANfile->from_prereqs($meta->prereqs);
    $file->save('cpanfile');
  
  =item merge_meta
  
    $file->merge_meta('META.yml');
    $file->merge_meta('MYMETA.json', '2.0');
  
  Merge the effective prereqs with Meta specification loaded from the
  given META file, using CPAN::Meta. You can specify the META spec
  version in the second argument, which defaults to 1.4 in case the
  given file is YAML, and 2 if it is JSON.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<cpanfile>, L<CPAN::Meta>, L<CPAN::Meta::Spec>
  
  =cut
MODULE_CPANFILE

$fatpacked{"Module/CPANfile/Environment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_ENVIRONMENT';
  package Module::CPANfile::Environment;
  use strict;
  use warnings;
  use Module::CPANfile::Prereqs;
  use Carp ();
  
  my @bindings = qw(
      on requires recommends suggests conflicts
      feature
      osname
      mirror
      configure_requires build_requires test_requires author_requires
  );
  
  my $file_id = 1;
  
  sub new {
      my($class, $file) = @_;
      bless {
          file     => $file,
          phase    => 'runtime', # default phase
          feature  => undef,
          features => {},
          prereqs  => Module::CPANfile::Prereqs->new,
          mirrors  => [],
      }, $class;
  }
  
  sub bind {
      my $self = shift;
      my $pkg = caller;
  
      for my $binding (@bindings) {
          no strict 'refs';
          *{"$pkg\::$binding"} = sub { $self->$binding(@_) };
      }
  }
  
  sub parse {
      my($self, $code) = @_;
  
      my $err;
      {
          local $@;
          $file_id++;
          $self->_evaluate(<<EVAL);
  package Module::CPANfile::Sandbox$file_id;
  no warnings;
  BEGIN { \$_environment->bind }
  
  # line 1 "$self->{file}"
  $code;
  EVAL
          $err = $@;
      }
  
      if ($err) { die "Parsing $self->{file} failed: $err" };
  
      return 1;
  }
  
  sub _evaluate {
      my $_environment = $_[0];
      eval $_[1];
  }
  
  sub prereqs { $_[0]->{prereqs} }
  
  sub mirrors { $_[0]->{mirrors} }
  
  # DSL goes from here
  
  sub on {
      my($self, $phase, $code) = @_;
      local $self->{phase} = $phase;
      $code->();
  }
  
  sub feature {
      my($self, $identifier, $description, $code) = @_;
  
      # shortcut: feature identifier => sub { ... }
      if (@_ == 3 && ref($description) eq 'CODE') {
          $code = $description;
          $description = $identifier;
      }
  
      unless (ref $description eq '' && ref $code eq 'CODE') {
          Carp::croak("Usage: feature 'identifier', 'Description' => sub { ... }");
      }
  
      local $self->{feature} = $identifier;
      $self->prereqs->add_feature($identifier, $description);
  
      $code->();
  }
  
  sub osname { die "TODO" }
  
  sub mirror {
      my($self, $url) = @_;
      push @{$self->{mirrors}}, $url;
  }
  
  sub requirement_for {
      my($self, $module, @args) = @_;
  
      my $requirement = 0;
      $requirement = shift @args if @args % 2;
  
      return Module::CPANfile::Requirement->new(
          name    => $module,
          version => $requirement,
          @args,
      );
  }
  
  sub requires {
      my $self = shift;
      $self->add_prereq(requires => @_);
  }
  
  sub recommends {
      my $self = shift;
      $self->add_prereq(recommends => @_);
  }
  
  sub suggests {
      my $self = shift;
      $self->add_prereq(suggests => @_);
  }
  
  sub conflicts {
      my $self = shift;
      $self->add_prereq(conflicts => @_);
  }
  
  sub add_prereq {
      my($self, $type, $module, @args) = @_;
  
      $self->prereqs->add_prereq(
          feature => $self->{feature},
          phase   => $self->{phase},
          type    => $type,
          module  => $module,
          requirement => $self->requirement_for($module, @args),
      );
  }
  
  # Module::Install compatible shortcuts
  
  sub configure_requires {
      my($self, @args) = @_;
      $self->on(configure => sub { $self->requires(@args) });
  }
  
  sub build_requires {
      my($self, @args) = @_;
      $self->on(build => sub { $self->requires(@args) });
  }
  
  sub test_requires {
      my($self, @args) = @_;
      $self->on(test => sub { $self->requires(@args) });
  }
  
  sub author_requires {
      my($self, @args) = @_;
      $self->on(develop => sub { $self->requires(@args) });
  }
  
  1;
  
MODULE_CPANFILE_ENVIRONMENT

$fatpacked{"Module/CPANfile/Prereq.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_PREREQ';
  package Module::CPANfile::Prereq;
  use strict;
  
  sub new {
      my($class, %options) = @_;
      bless \%options, $class;
  }
  
  sub feature { $_[0]->{feature} }
  sub phase   { $_[0]->{phase} }
  sub type    { $_[0]->{type} }
  sub module  { $_[0]->{module} }
  sub requirement { $_[0]->{requirement} }
  
  sub match_feature {
      my($self, $identifier) = @_;
      no warnings 'uninitialized';
      $self->feature eq $identifier;
  }
  
  1;
MODULE_CPANFILE_PREREQ

$fatpacked{"Module/CPANfile/Prereqs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_PREREQS';
  package Module::CPANfile::Prereqs;
  use strict;
  use Carp ();
  use CPAN::Meta::Feature;
  use Module::CPANfile::Prereq;
  
  sub from_cpan_meta {
      my($class, $prereqs) = @_;
  
      my $self = $class->new;
  
      for my $phase (keys %$prereqs) {
          for my $type (keys %{ $prereqs->{$phase} }) {
              while (my($module, $requirement) = each %{ $prereqs->{$phase}{$type} }) {
                  $self->add_prereq(
                      phase => $phase,
                      type  => $type,
                      module => $module,
                      requirement => Module::CPANfile::Requirement->new(name => $module, version => $requirement),
                  );
              }
          }
      }
  
      $self;
  }
  
  sub new {
      my $class = shift;
      bless {
          prereqs => [],
          features => {},
      }, $class;
  }
  
  sub add_feature {
      my($self, $identifier, $description) = @_;
      $self->{features}{$identifier} = { description => $description };
  }
  
  sub add_prereq {
      my($self, %args) = @_;
      $self->add( Module::CPANfile::Prereq->new(%args) );
  }
  
  sub add {
      my($self, $prereq) = @_;
      push @{$self->{prereqs}}, $prereq;
  }
  
  sub as_cpan_meta {
      my $self = shift;
      $self->{cpanmeta} ||= $self->build_cpan_meta;
  }
  
  sub build_cpan_meta {
      my($self, $identifier) = @_;
  
      my $prereq_spec = {};
      $self->prereq_each($identifier, sub {
          my $prereq = shift;
          $prereq_spec->{$prereq->phase}{$prereq->type}{$prereq->module} = $prereq->requirement->version;
      });
  
      CPAN::Meta::Prereqs->new($prereq_spec);
  }
  
  sub prereq_each {
      my($self, $identifier, $code) = @_;
  
      for my $prereq (@{$self->{prereqs}}) {
          next unless $prereq->match_feature($identifier);
          $code->($prereq);
      }
  }
  
  sub merged_requirements {
      my $self = shift;
  
      my $reqs = CPAN::Meta::Requirements->new;
      for my $prereq (@{$self->{prereqs}}) {
          $reqs->add_string_requirement($prereq->module, $prereq->requirement->version);
      }
  
      $reqs;
  }
  
  sub find {
      my($self, $module) = @_;
  
      for my $prereq (@{$self->{prereqs}}) {
          return $prereq if $prereq->module eq $module;
      }
  
      return;
  }
  
  sub identifiers {
      my $self = shift;
      keys %{$self->{features}};
  }
  
  sub feature {
      my($self, $identifier) = @_;
  
      my $data = $self->{features}{$identifier}
        or Carp::croak("Unknown feature '$identifier'");
  
      my $prereqs = $self->build_cpan_meta($identifier);
  
      CPAN::Meta::Feature->new($identifier, {
          description => $data->{description},
          prereqs => $prereqs->as_string_hash,
      });
  }
  
  1;
MODULE_CPANFILE_PREREQS

$fatpacked{"Module/CPANfile/Requirement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_REQUIREMENT';
  package Module::CPANfile::Requirement;
  use strict;
  
  sub new {
      my ($class, %args) = @_;
  
      $args{version} ||= 0;
  
      bless +{
          name    => delete $args{name},
          version => delete $args{version},
          options => \%args,
      }, $class;
  }
  
  sub name    { $_[0]->{name} }
  sub version { $_[0]->{version} }
  
  sub options { $_[0]->{options} }
  
  sub has_options {
      keys %{$_[0]->{options}} > 0;
  }
  
  1;
MODULE_CPANFILE_REQUIREMENT

$fatpacked{"Module/Metadata.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_METADATA';
  # -*- mode: cperl; tab-width: 8; indent-tabs-mode: nil; basic-offset: 2 -*-
  # vim:ts=8:sw=2:et:sta:sts=2
  package Module::Metadata; # git description: v1.000026-12-g9b12bf1
  
  # Adapted from Perl-licensed code originally distributed with
  # Module-Build by Ken Williams
  
  # This module provides routines to gather information about
  # perl modules (assuming this may be expanded in the distant
  # parrot future to look at other types of modules).
  
  sub __clean_eval { eval $_[0] }
  use strict;
  use warnings;
  
  our $VERSION = '1.000027';
  
  use Carp qw/croak/;
  use File::Spec;
  BEGIN {
         # Try really hard to not depend ony any DynaLoaded module, such as IO::File or Fcntl
         eval {
                 require Fcntl; Fcntl->import('SEEK_SET'); 1;
         } or *SEEK_SET = sub { 0 }
  }
  use version 0.87;
  BEGIN {
    if ($INC{'Log/Contextual.pm'}) {
      require "Log/Contextual/WarnLogger.pm"; # Hide from AutoPrereqs
      Log::Contextual->import('log_info',
        '-default_logger' => Log::Contextual::WarnLogger->new({ env_prefix => 'MODULE_METADATA', }),
      );
    } else {
      *log_info = sub (&) { warn $_[0]->() };
    }
  }
  use File::Find qw(find);
  
  my $V_NUM_REGEXP = qr{v?[0-9._]+};  # crudely, a v-string or decimal
  
  my $PKG_FIRST_WORD_REGEXP = qr{ # the FIRST word in a package name
    [a-zA-Z_]                     # the first word CANNOT start with a digit
      (?:
        [\w']?                    # can contain letters, digits, _, or ticks
        \w                        # But, NO multi-ticks or trailing ticks
      )*
  }x;
  
  my $PKG_ADDL_WORD_REGEXP = qr{ # the 2nd+ word in a package name
    \w                           # the 2nd+ word CAN start with digits
      (?:
        [\w']?                   # and can contain letters or ticks
        \w                       # But, NO multi-ticks or trailing ticks
      )*
  }x;
  
  my $PKG_NAME_REGEXP = qr{ # match a package name
    (?: :: )?               # a pkg name can start with arisdottle
    $PKG_FIRST_WORD_REGEXP  # a package word
    (?:
      (?: :: )+             ### arisdottle (allow one or many times)
      $PKG_ADDL_WORD_REGEXP ### a package word
    )*                      # ^ zero, one or many times
    (?:
      ::                    # allow trailing arisdottle
    )?
  }x;
  
  my $PKG_REGEXP  = qr{   # match a package declaration
    ^[\s\{;]*             # intro chars on a line
    package               # the word 'package'
    \s+                   # whitespace
    ($PKG_NAME_REGEXP)    # a package name
    \s*                   # optional whitespace
    ($V_NUM_REGEXP)?        # optional version number
    \s*                   # optional whitesapce
    [;\{]                 # semicolon line terminator or block start (since 5.16)
  }x;
  
  my $VARNAME_REGEXP = qr{ # match fully-qualified VERSION name
    ([\$*])         # sigil - $ or *
    (
      (             # optional leading package name
        (?:::|\')?  # possibly starting like just :: (a la $::VERSION)
        (?:\w+(?:::|\'))*  # Foo::Bar:: ...
      )?
      VERSION
    )\b
  }x;
  
  my $VERS_REGEXP = qr{ # match a VERSION definition
    (?:
      \(\s*$VARNAME_REGEXP\s*\) # with parens
    |
      $VARNAME_REGEXP           # without parens
    )
    \s*
    =[^=~>]  # = but not ==, nor =~, nor =>
  }x;
  
  sub new_from_file {
    my $class    = shift;
    my $filename = File::Spec->rel2abs( shift );
  
    return undef unless defined( $filename ) && -f $filename;
    return $class->_init(undef, $filename, @_);
  }
  
  sub new_from_handle {
    my $class    = shift;
    my $handle   = shift;
    my $filename = shift;
    return undef unless defined($handle) && defined($filename);
    $filename = File::Spec->rel2abs( $filename );
  
    return $class->_init(undef, $filename, @_, handle => $handle);
  
  }
  
  
  sub new_from_module {
    my $class   = shift;
    my $module  = shift;
    my %props   = @_;
  
    $props{inc} ||= \@INC;
    my $filename = $class->find_module_by_name( $module, $props{inc} );
    return undef unless defined( $filename ) && -f $filename;
    return $class->_init($module, $filename, %props);
  }
  
  {
  
    my $compare_versions = sub {
      my ($v1, $op, $v2) = @_;
      $v1 = version->new($v1)
        unless UNIVERSAL::isa($v1,'version');
  
      my $eval_str = "\$v1 $op \$v2";
      my $result   = eval $eval_str;
      log_info { "error comparing versions: '$eval_str' $@" } if $@;
  
      return $result;
    };
  
    my $normalize_version = sub {
      my ($version) = @_;
      if ( $version =~ /[=<>!,]/ ) { # logic, not just version
        # take as is without modification
      }
      elsif ( ref $version eq 'version' ) { # version objects
        $version = $version->is_qv ? $version->normal : $version->stringify;
      }
      elsif ( $version =~ /^[^v][^.]*\.[^.]+\./ ) { # no leading v, multiple dots
        # normalize string tuples without "v": "1.2.3" -> "v1.2.3"
        $version = "v$version";
      }
      else {
        # leave alone
      }
      return $version;
    };
  
    # separate out some of the conflict resolution logic
  
    my $resolve_module_versions = sub {
      my $packages = shift;
  
      my( $file, $version );
      my $err = '';
        foreach my $p ( @$packages ) {
          if ( defined( $p->{version} ) ) {
            if ( defined( $version ) ) {
              if ( $compare_versions->( $version, '!=', $p->{version} ) ) {
                $err .= "  $p->{file} ($p->{version})\n";
              } else {
                # same version declared multiple times, ignore
              }
            } else {
              $file    = $p->{file};
              $version = $p->{version};
            }
          }
        $file ||= $p->{file} if defined( $p->{file} );
      }
  
      if ( $err ) {
        $err = "  $file ($version)\n" . $err;
      }
  
      my %result = (
        file    => $file,
        version => $version,
        err     => $err
      );
  
      return \%result;
    };
  
    sub provides {
      my $class = shift;
  
      croak "provides() requires key/value pairs \n" if @_ % 2;
      my %args = @_;
  
      croak "provides() takes only one of 'dir' or 'files'\n"
        if $args{dir} && $args{files};
  
      croak "provides() requires a 'version' argument"
        unless defined $args{version};
  
      croak "provides() does not support version '$args{version}' metadata"
          unless grep { $args{version} eq $_ } qw/1.4 2/;
  
      $args{prefix} = 'lib' unless defined $args{prefix};
  
      my $p;
      if ( $args{dir} ) {
        $p = $class->package_versions_from_directory($args{dir});
      }
      else {
        croak "provides() requires 'files' to be an array reference\n"
          unless ref $args{files} eq 'ARRAY';
        $p = $class->package_versions_from_directory($args{files});
      }
  
      # Now, fix up files with prefix
      if ( length $args{prefix} ) { # check in case disabled with q{}
        $args{prefix} =~ s{/$}{};
        for my $v ( values %$p ) {
          $v->{file} = "$args{prefix}/$v->{file}";
        }
      }
  
      return $p
    }
  
    sub package_versions_from_directory {
      my ( $class, $dir, $files ) = @_;
  
      my @files;
  
      if ( $files ) {
        @files = @$files;
      } else {
        find( {
          wanted => sub {
            push @files, $_ if -f $_ && /\.pm$/;
          },
          no_chdir => 1,
        }, $dir );
      }
  
      # First, we enumerate all packages & versions,
      # separating into primary & alternative candidates
      my( %prime, %alt );
      foreach my $file (@files) {
        my $mapped_filename = File::Spec::Unix->abs2rel( $file, $dir );
        my @path = split( /\//, $mapped_filename );
        (my $prime_package = join( '::', @path )) =~ s/\.pm$//;
  
        my $pm_info = $class->new_from_file( $file );
  
        foreach my $package ( $pm_info->packages_inside ) {
          next if $package eq 'main';  # main can appear numerous times, ignore
          next if $package eq 'DB';    # special debugging package, ignore
          next if grep /^_/, split( /::/, $package ); # private package, ignore
  
          my $version = $pm_info->version( $package );
  
          $prime_package = $package if lc($prime_package) eq lc($package);
          if ( $package eq $prime_package ) {
            if ( exists( $prime{$package} ) ) {
              croak "Unexpected conflict in '$package'; multiple versions found.\n";
            } else {
              $mapped_filename = "$package.pm" if lc("$package.pm") eq lc($mapped_filename);
              $prime{$package}{file} = $mapped_filename;
              $prime{$package}{version} = $version if defined( $version );
            }
          } else {
            push( @{$alt{$package}}, {
                                      file    => $mapped_filename,
                                      version => $version,
                                     } );
          }
        }
      }
  
      # Then we iterate over all the packages found above, identifying conflicts
      # and selecting the "best" candidate for recording the file & version
      # for each package.
      foreach my $package ( keys( %alt ) ) {
        my $result = $resolve_module_versions->( $alt{$package} );
  
        if ( exists( $prime{$package} ) ) { # primary package selected
  
          if ( $result->{err} ) {
          # Use the selected primary package, but there are conflicting
          # errors among multiple alternative packages that need to be
          # reported
            log_info {
              "Found conflicting versions for package '$package'\n" .
              "  $prime{$package}{file} ($prime{$package}{version})\n" .
              $result->{err}
            };
  
          } elsif ( defined( $result->{version} ) ) {
          # There is a primary package selected, and exactly one
          # alternative package
  
          if ( exists( $prime{$package}{version} ) &&
               defined( $prime{$package}{version} ) ) {
            # Unless the version of the primary package agrees with the
            # version of the alternative package, report a conflict
          if ( $compare_versions->(
                   $prime{$package}{version}, '!=', $result->{version}
                 )
               ) {
  
              log_info {
                "Found conflicting versions for package '$package'\n" .
                "  $prime{$package}{file} ($prime{$package}{version})\n" .
                "  $result->{file} ($result->{version})\n"
              };
            }
  
          } else {
            # The prime package selected has no version so, we choose to
            # use any alternative package that does have a version
            $prime{$package}{file}    = $result->{file};
            $prime{$package}{version} = $result->{version};
          }
  
          } else {
          # no alt package found with a version, but we have a prime
          # package so we use it whether it has a version or not
          }
  
        } else { # No primary package was selected, use the best alternative
  
          if ( $result->{err} ) {
            log_info {
              "Found conflicting versions for package '$package'\n" .
              $result->{err}
            };
          }
  
          # Despite possible conflicting versions, we choose to record
          # something rather than nothing
          $prime{$package}{file}    = $result->{file};
          $prime{$package}{version} = $result->{version}
            if defined( $result->{version} );
        }
      }
  
      # Normalize versions.  Can't use exists() here because of bug in YAML::Node.
      # XXX "bug in YAML::Node" comment seems irrelevant -- dagolden, 2009-05-18
      for (grep defined $_->{version}, values %prime) {
        $_->{version} = $normalize_version->( $_->{version} );
      }
  
      return \%prime;
    }
  }
  
  
  sub _init {
    my $class    = shift;
    my $module   = shift;
    my $filename = shift;
    my %props = @_;
  
    my $handle = delete $props{handle};
    my( %valid_props, @valid_props );
    @valid_props = qw( collect_pod inc );
    @valid_props{@valid_props} = delete( @props{@valid_props} );
    warn "Unknown properties: @{[keys %props]}\n" if scalar( %props );
  
    my %data = (
      module       => $module,
      filename     => $filename,
      version      => undef,
      packages     => [],
      versions     => {},
      pod          => {},
      pod_headings => [],
      collect_pod  => 0,
  
      %valid_props,
    );
  
    my $self = bless(\%data, $class);
  
    if ( not $handle ) {
      my $filename = $self->{filename};
      open $handle, '<', $filename
        or croak( "Can't open '$filename': $!" );
  
      $self->_handle_bom($handle, $filename);
    }
    $self->_parse_fh($handle);
  
    unless($self->{module} and length($self->{module})) {
      my ($v, $d, $f) = File::Spec->splitpath($self->{filename});
      if($f =~ /\.pm$/) {
        $f =~ s/\..+$//;
        my @candidates = grep /$f$/, @{$self->{packages}};
        $self->{module} = shift(@candidates); # punt
      }
      else {
        if(grep /main/, @{$self->{packages}}) {
          $self->{module} = 'main';
        }
        else {
          $self->{module} = $self->{packages}[0] || '';
        }
      }
    }
  
    $self->{version} = $self->{versions}{$self->{module}}
        if defined( $self->{module} );
  
    return $self;
  }
  
  # class method
  sub _do_find_module {
    my $class   = shift;
    my $module  = shift || croak 'find_module_by_name() requires a package name';
    my $dirs    = shift || \@INC;
  
    my $file = File::Spec->catfile(split( /::/, $module));
    foreach my $dir ( @$dirs ) {
      my $testfile = File::Spec->catfile($dir, $file);
      return [ File::Spec->rel2abs( $testfile ), $dir ]
        if -e $testfile and !-d _;  # For stuff like ExtUtils::xsubpp
      $testfile .= '.pm';
      return [ File::Spec->rel2abs( $testfile ), $dir ]
        if -e $testfile;
    }
    return;
  }
  
  # class method
  sub find_module_by_name {
    my $found = shift()->_do_find_module(@_) or return;
    return $found->[0];
  }
  
  # class method
  sub find_module_dir_by_name {
    my $found = shift()->_do_find_module(@_) or return;
    return $found->[1];
  }
  
  
  # given a line of perl code, attempt to parse it if it looks like a
  # $VERSION assignment, returning sigil, full name, & package name
  sub _parse_version_expression {
    my $self = shift;
    my $line = shift;
  
    my( $sigil, $variable_name, $package);
    if ( $line =~ /$VERS_REGEXP/o ) {
      ( $sigil, $variable_name, $package) = $2 ? ( $1, $2, $3 ) : ( $4, $5, $6 );
      if ( $package ) {
        $package = ($package eq '::') ? 'main' : $package;
        $package =~ s/::$//;
      }
    }
  
    return ( $sigil, $variable_name, $package );
  }
  
  # Look for a UTF-8/UTF-16BE/UTF-16LE BOM at the beginning of the stream.
  # If there's one, then skip it and set the :encoding layer appropriately.
  sub _handle_bom {
    my ($self, $fh, $filename) = @_;
  
    my $pos = tell $fh;
    return unless defined $pos;
  
    my $buf = ' ' x 2;
    my $count = read $fh, $buf, length $buf;
    return unless defined $count and $count >= 2;
  
    my $encoding;
    if ( $buf eq "\x{FE}\x{FF}" ) {
      $encoding = 'UTF-16BE';
    } elsif ( $buf eq "\x{FF}\x{FE}" ) {
      $encoding = 'UTF-16LE';
    } elsif ( $buf eq "\x{EF}\x{BB}" ) {
      $buf = ' ';
      $count = read $fh, $buf, length $buf;
      if ( defined $count and $count >= 1 and $buf eq "\x{BF}" ) {
        $encoding = 'UTF-8';
      }
    }
  
    if ( defined $encoding ) {
      if ( "$]" >= 5.008 ) {
        binmode( $fh, ":encoding($encoding)" );
      }
    } else {
      seek $fh, $pos, SEEK_SET
        or croak( sprintf "Can't reset position to the top of '$filename'" );
    }
  
    return $encoding;
  }
  
  sub _parse_fh {
    my ($self, $fh) = @_;
  
    my( $in_pod, $seen_end, $need_vers ) = ( 0, 0, 0 );
    my( @packages, %vers, %pod, @pod );
    my $package = 'main';
    my $pod_sect = '';
    my $pod_data = '';
    my $in_end = 0;
  
    while (defined( my $line = <$fh> )) {
      my $line_num = $.;
  
      chomp( $line );
  
      # From toke.c : any line that begins by "=X", where X is an alphabetic
      # character, introduces a POD segment.
      my $is_cut;
      if ( $line =~ /^=([a-zA-Z].*)/ ) {
        my $cmd = $1;
        # Then it goes back to Perl code for "=cutX" where X is a non-alphabetic
        # character (which includes the newline, but here we chomped it away).
        $is_cut = $cmd =~ /^cut(?:[^a-zA-Z]|$)/;
        $in_pod = !$is_cut;
      }
  
      if ( $in_pod ) {
  
        if ( $line =~ /^=head[1-4]\s+(.+)\s*$/ ) {
          push( @pod, $1 );
          if ( $self->{collect_pod} && length( $pod_data ) ) {
            $pod{$pod_sect} = $pod_data;
            $pod_data = '';
          }
          $pod_sect = $1;
  
        } elsif ( $self->{collect_pod} ) {
          $pod_data .= "$line\n";
  
        }
  
      } elsif ( $is_cut ) {
  
        if ( $self->{collect_pod} && length( $pod_data ) ) {
          $pod{$pod_sect} = $pod_data;
          $pod_data = '';
        }
        $pod_sect = '';
  
      } else {
  
        # Skip after __END__
        next if $in_end;
  
        # Skip comments in code
        next if $line =~ /^\s*#/;
  
        # Would be nice if we could also check $in_string or something too
        if ($line eq '__END__') {
          $in_end++;
          next;
        }
        last if $line eq '__DATA__';
  
        # parse $line to see if it's a $VERSION declaration
        my( $version_sigil, $version_fullname, $version_package ) =
            index($line, 'VERSION') >= 1
                ? $self->_parse_version_expression( $line )
                : ();
  
        if ( $line =~ /$PKG_REGEXP/o ) {
          $package = $1;
          my $version = $2;
          push( @packages, $package ) unless grep( $package eq $_, @packages );
          $need_vers = defined $version ? 0 : 1;
  
          if ( not exists $vers{$package} and defined $version ){
            # Upgrade to a version object.
            my $dwim_version = eval { _dwim_version($version) };
            croak "Version '$version' from $self->{filename} does not appear to be valid:\n$line\n\nThe fatal error was: $@\n"
                unless defined $dwim_version;  # "0" is OK!
            $vers{$package} = $dwim_version;
          }
  
        # VERSION defined with full package spec, i.e. $Module::VERSION
        } elsif ( $version_fullname && $version_package ) {
          push( @packages, $version_package ) unless grep( $version_package eq $_, @packages );
          $need_vers = 0 if $version_package eq $package;
  
          unless ( defined $vers{$version_package} && length $vers{$version_package} ) {
          $vers{$version_package} = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
        }
  
        # first non-comment line in undeclared package main is VERSION
        } elsif ( $package eq 'main' && $version_fullname && !exists($vers{main}) ) {
          $need_vers = 0;
          my $v = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
          $vers{$package} = $v;
          push( @packages, 'main' );
  
        # first non-comment line in undeclared package defines package main
        } elsif ( $package eq 'main' && !exists($vers{main}) && $line =~ /\w/ ) {
          $need_vers = 1;
          $vers{main} = '';
          push( @packages, 'main' );
  
        # only keep if this is the first $VERSION seen
        } elsif ( $version_fullname && $need_vers ) {
          $need_vers = 0;
          my $v = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
  
          unless ( defined $vers{$package} && length $vers{$package} ) {
            $vers{$package} = $v;
          }
        }
      }
    }
  
    if ( $self->{collect_pod} && length($pod_data) ) {
      $pod{$pod_sect} = $pod_data;
    }
  
    $self->{versions} = \%vers;
    $self->{packages} = \@packages;
    $self->{pod} = \%pod;
    $self->{pod_headings} = \@pod;
  }
  
  {
  my $pn = 0;
  sub _evaluate_version_line {
    my $self = shift;
    my( $sigil, $variable_name, $line ) = @_;
  
    # We compile into a local sub because 'use version' would cause
    # compiletime/runtime issues with local()
    $pn++; # everybody gets their own package
    my $eval = qq{ my \$dummy = q#  Hide from _packages_inside()
      #; package Module::Metadata::_version::p${pn};
      use version;
      sub {
        local $sigil$variable_name;
        $line;
        \$$variable_name
      };
    };
  
    $eval = $1 if $eval =~ m{^(.+)}s;
  
    local $^W;
    # Try to get the $VERSION
    my $vsub = __clean_eval($eval);
    # some modules say $VERSION <equal sign> $Foo::Bar::VERSION, but Foo::Bar isn't
    # installed, so we need to hunt in ./lib for it
    if ( $@ =~ /Can't locate/ && -d 'lib' ) {
      local @INC = ('lib',@INC);
      $vsub = __clean_eval($eval);
    }
    warn "Error evaling version line '$eval' in $self->{filename}: $@\n"
      if $@;
  
    (ref($vsub) eq 'CODE') or
      croak "failed to build version sub for $self->{filename}";
  
    my $result = eval { $vsub->() };
    # FIXME: $eval is not the right thing to print here
    croak "Could not get version from $self->{filename} by executing:\n$eval\n\nThe fatal error was: $@\n"
      if $@;
  
    # Upgrade it into a version object
    my $version = eval { _dwim_version($result) };
  
    # FIXME: $eval is not the right thing to print here
    croak "Version '$result' from $self->{filename} does not appear to be valid:\n$eval\n\nThe fatal error was: $@\n"
      unless defined $version; # "0" is OK!
  
    return $version;
  }
  }
  
  # Try to DWIM when things fail the lax version test in obvious ways
  {
    my @version_prep = (
      # Best case, it just works
      sub { return shift },
  
      # If we still don't have a version, try stripping any
      # trailing junk that is prohibited by lax rules
      sub {
        my $v = shift;
        $v =~ s{([0-9])[a-z-].*$}{$1}i; # 1.23-alpha or 1.23b
        return $v;
      },
  
      # Activestate apparently creates custom versions like '1.23_45_01', which
      # cause version.pm to think it's an invalid alpha.  So check for that
      # and strip them
      sub {
        my $v = shift;
        my $num_dots = () = $v =~ m{(\.)}g;
        my $num_unders = () = $v =~ m{(_)}g;
        my $leading_v = substr($v,0,1) eq 'v';
        if ( ! $leading_v && $num_dots < 2 && $num_unders > 1 ) {
          $v =~ s{_}{}g;
          $num_unders = () = $v =~ m{(_)}g;
        }
        return $v;
      },
  
      # Worst case, try numifying it like we would have before version objects
      sub {
        my $v = shift;
        no warnings 'numeric';
        return 0 + $v;
      },
  
    );
  
    sub _dwim_version {
      my ($result) = shift;
  
      return $result if ref($result) eq 'version';
  
      my ($version, $error);
      for my $f (@version_prep) {
        $result = $f->($result);
        $version = eval { version->new($result) };
        $error ||= $@ if $@; # capture first failure
        last if defined $version;
      }
  
      croak $error unless defined $version;
  
      return $version;
    }
  }
  
  ############################################################
  
  # accessors
  sub name            { $_[0]->{module}            }
  
  sub filename        { $_[0]->{filename}          }
  sub packages_inside { @{$_[0]->{packages}}       }
  sub pod_inside      { @{$_[0]->{pod_headings}}   }
  sub contains_pod    { 0+@{$_[0]->{pod_headings}} }
  
  sub version {
      my $self = shift;
      my $mod  = shift || $self->{module};
      my $vers;
      if ( defined( $mod ) && length( $mod ) &&
           exists( $self->{versions}{$mod} ) ) {
          return $self->{versions}{$mod};
      } else {
          return undef;
      }
  }
  
  sub pod {
      my $self = shift;
      my $sect = shift;
      if ( defined( $sect ) && length( $sect ) &&
           exists( $self->{pod}{$sect} ) ) {
          return $self->{pod}{$sect};
      } else {
          return undef;
      }
  }
  
  sub is_indexable {
    my ($self, $package) = @_;
  
    my @indexable_packages = grep { $_ ne 'main' } $self->packages_inside;
  
    # check for specific package, if provided
    return !! grep { $_ eq $package } @indexable_packages if $package;
  
    # otherwise, check for any indexable packages at all
    return !! @indexable_packages;
  }
  
  1;
  
  =head1 NAME
  
  Module::Metadata - Gather package and POD information from perl module files
  
  =head1 SYNOPSIS
  
    use Module::Metadata;
  
    # information about a .pm file
    my $info = Module::Metadata->new_from_file( $file );
    my $version = $info->version;
  
    # CPAN META 'provides' field for .pm files in a directory
    my $provides = Module::Metadata->provides(
      dir => 'lib', version => 2
    );
  
  =head1 DESCRIPTION
  
  This module provides a standard way to gather metadata about a .pm file through
  (mostly) static analysis and (some) code execution.  When determining the
  version of a module, the C<$VERSION> assignment is C<eval>ed, as is traditional
  in the CPAN toolchain.
  
  =head1 CLASS METHODS
  
  =head2 C<< new_from_file($filename, collect_pod => 1) >>
  
  Constructs a C<Module::Metadata> object given the path to a file.  Returns
  undef if the filename does not exist.
  
  C<collect_pod> is a optional boolean argument that determines whether POD
  data is collected and stored for reference.  POD data is not collected by
  default.  POD headings are always collected.
  
  If the file begins by an UTF-8, UTF-16BE or UTF-16LE byte-order mark, then
  it is skipped before processing, and the content of the file is also decoded
  appropriately starting from perl 5.8.
  
  =head2 C<< new_from_handle($handle, $filename, collect_pod => 1) >>
  
  This works just like C<new_from_file>, except that a handle can be provided
  as the first argument.
  
  Note that there is no validation to confirm that the handle is a handle or
  something that can act like one.  Passing something that isn't a handle will
  cause a exception when trying to read from it.  The C<filename> argument is
  mandatory or undef will be returned.
  
  You are responsible for setting the decoding layers on C<$handle> if
  required.
  
  =head2 C<< new_from_module($module, collect_pod => 1, inc => \@dirs) >>
  
  Constructs a C<Module::Metadata> object given a module or package name.
  Returns undef if the module cannot be found.
  
  In addition to accepting the C<collect_pod> argument as described above,
  this method accepts a C<inc> argument which is a reference to an array of
  directories to search for the module.  If none are given, the default is
  @INC.
  
  If the file that contains the module begins by an UTF-8, UTF-16BE or
  UTF-16LE byte-order mark, then it is skipped before processing, and the
  content of the file is also decoded appropriately starting from perl 5.8.
  
  =head2 C<< find_module_by_name($module, \@dirs) >>
  
  Returns the path to a module given the module or package name. A list
  of directories can be passed in as an optional parameter, otherwise
  @INC is searched.
  
  Can be called as either an object or a class method.
  
  =head2 C<< find_module_dir_by_name($module, \@dirs) >>
  
  Returns the entry in C<@dirs> (or C<@INC> by default) that contains
  the module C<$module>. A list of directories can be passed in as an
  optional parameter, otherwise @INC is searched.
  
  Can be called as either an object or a class method.
  
  =head2 C<< provides( %options ) >>
  
  This is a convenience wrapper around C<package_versions_from_directory>
  to generate a CPAN META C<provides> data structure.  It takes key/value
  pairs.  Valid option keys include:
  
  =over
  
  =item version B<(required)>
  
  Specifies which version of the L<CPAN::Meta::Spec> should be used as
  the format of the C<provides> output.  Currently only '1.4' and '2'
  are supported (and their format is identical).  This may change in
  the future as the definition of C<provides> changes.
  
  The C<version> option is required.  If it is omitted or if
  an unsupported version is given, then C<provides> will throw an error.
  
  =item dir
  
  Directory to search recursively for F<.pm> files.  May not be specified with
  C<files>.
  
  =item files
  
  Array reference of files to examine.  May not be specified with C<dir>.
  
  =item prefix
  
  String to prepend to the C<file> field of the resulting output. This defaults
  to F<lib>, which is the common case for most CPAN distributions with their
  F<.pm> files in F<lib>.  This option ensures the META information has the
  correct relative path even when the C<dir> or C<files> arguments are
  absolute or have relative paths from a location other than the distribution
  root.
  
  =back
  
  For example, given C<dir> of 'lib' and C<prefix> of 'lib', the return value
  is a hashref of the form:
  
    {
      'Package::Name' => {
        version => '0.123',
        file => 'lib/Package/Name.pm'
      },
      'OtherPackage::Name' => ...
    }
  
  =head2 C<< package_versions_from_directory($dir, \@files?) >>
  
  Scans C<$dir> for .pm files (unless C<@files> is given, in which case looks
  for those files in C<$dir> - and reads each file for packages and versions,
  returning a hashref of the form:
  
    {
      'Package::Name' => {
        version => '0.123',
        file => 'Package/Name.pm'
      },
      'OtherPackage::Name' => ...
    }
  
  The C<DB> and C<main> packages are always omitted, as are any "private"
  packages that have leading underscores in the namespace (e.g.
  C<Foo::_private>)
  
  Note that the file path is relative to C<$dir> if that is specified.
  This B<must not> be used directly for CPAN META C<provides>.  See
  the C<provides> method instead.
  
  =head2 C<< log_info (internal) >>
  
  Used internally to perform logging; imported from Log::Contextual if
  Log::Contextual has already been loaded, otherwise simply calls warn.
  
  =head1 OBJECT METHODS
  
  =head2 C<< name() >>
  
  Returns the name of the package represented by this module. If there
  is more than one package, it makes a best guess based on the
  filename. If it's a script (i.e. not a *.pm) the package name is
  'main'.
  
  =head2 C<< version($package) >>
  
  Returns the version as defined by the $VERSION variable for the
  package as returned by the C<name> method if no arguments are
  given. If given the name of a package it will attempt to return the
  version of that package if it is specified in the file.
  
  =head2 C<< filename() >>
  
  Returns the absolute path to the file.
  Note that this file may not actually exist on disk yet, e.g. if the module was read from an in-memory filehandle.
  
  =head2 C<< packages_inside() >>
  
  Returns a list of packages. Note: this is a raw list of packages
  discovered (or assumed, in the case of C<main>).  It is not
  filtered for C<DB>, C<main> or private packages the way the
  C<provides> method does.  Invalid package names are not returned,
  for example "Foo:Bar".  Strange but valid package names are
  returned, for example "Foo::Bar::", and are left up to the caller
  on how to handle.
  
  =head2 C<< pod_inside() >>
  
  Returns a list of POD sections.
  
  =head2 C<< contains_pod() >>
  
  Returns true if there is any POD in the file.
  
  =head2 C<< pod($section) >>
  
  Returns the POD data in the given section.
  
  =head2 C<< is_indexable($package) >> or C<< is_indexable() >>
  
  Returns a boolean indicating whether the package (if provided) or any package
  (otherwise) is eligible for indexing by PAUSE, the Perl Authors Upload Server.
  Note This only checks for valid C<package> declarations, and does not take any
  ownership information into account.
  
  =head1 AUTHOR
  
  Original code from Module::Build::ModuleInfo by Ken Williams
  <kwilliams@cpan.org>, Randy W. Sims <RandyS@ThePierianSpring.org>
  
  Released as Module::Metadata by Matt S Trout (mst) <mst@shadowcat.co.uk> with
  assistance from David Golden (xdg) <dagolden@cpan.org>.
  
  =head1 COPYRIGHT & LICENSE
  
  Original code Copyright (c) 2001-2011 Ken Williams.
  Additional code Copyright (c) 2010-2011 Matt Trout and David Golden.
  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
MODULE_METADATA

$fatpacked{"Perl/PrereqScanner/Lite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_PREREQSCANNER_LITE';
  package Perl::PrereqScanner::Lite;
  use 5.008005;
  use strict;
  use warnings;
  use Carp ();
  use Compiler::Lexer;
  use CPAN::Meta::Requirements;
  use Perl::PrereqScanner::Lite::Constants;
  
  our $VERSION = "0.26";
  
  sub new {
      my ($class, $opt) = @_;
  
      my $lexer;
      if ($opt->{no_prereq}) {
          $lexer = Compiler::Lexer->new({verbose => 1}),
      }
      else {
          $lexer = Compiler::Lexer->new(),
      }
  
      my $extra_scanners = [];
      if (my $scanner_names = $opt->{extra_scanners}) {
          if (ref $scanner_names eq 'ARRAY') {
              for my $scanner_name (@$scanner_names) {
                  my $extra_scanner;
                  if (substr($scanner_name, 0, 1) eq '+') {
                      $extra_scanner = substr $scanner_name, 1;
                  }
                  else {
                      $extra_scanner = "Perl::PrereqScanner::Lite::Scanner::$scanner_name";
                  }
  
                  eval "require $extra_scanner"; ## no critic
                  push @$extra_scanners, $extra_scanner;
              }
          } else {
              Carp::croak "'extra_scanners' option must be array reference";
          }
      }
  
      bless {
          lexer          => $lexer,
          extra_scanners => $extra_scanners,
          module_reqs    => CPAN::Meta::Requirements->new,
      }, $class;
  }
  
  sub add_extra_scanner {
      my ($self, $scanner_name) = @_;
  
      my $extra_scanner;
      if (substr($scanner_name, 0, 1) eq '+') {
          $extra_scanner = substr $scanner_name, 1;
      }
      else {
          $extra_scanner = "Perl::PrereqScanner::Lite::Scanner::$scanner_name";
      }
  
      eval "require $extra_scanner"; ## no critic
      push @{$self->{extra_scanners}}, $extra_scanner;
  }
  
  sub scan_string {
      my ($self, $string) = @_;
  
      my $tokens = $self->{lexer}->tokenize($string);
      $self->_scan($tokens);
  }
  
  sub scan_file {
      my ($self, $file) = @_;
  
      open my $fh, '<', $file or die "Cannot open file: $file";
      my $script = do { local $/; <$fh>; };
  
      $self->scan_string($script);
  }
  
  sub scan_tokens {
      my ($self, $tokens) = @_;
      $self->_scan($tokens);
  }
  
  sub scan_module {
      my ($self, $module) = @_;
  
      require Module::Path;
  
      if (defined(my $path = Module::Path::module_path($module))) {
          return $self->scan_file($path);
      }
  }
  
  sub _scan {
      my ($self, $tokens) = @_;
  
      my $module_name    = '';
      my $module_version = 0;
  
      my $not_decl_module_name = '';
  
      my $is_in_reglist   = 0;
      my $is_in_usedecl   = 0;
      my $is_in_reqdecl   = 0;
      my $is_inherited    = 0;
      my $is_in_list      = 0;
      my $is_version_decl = 0;
      my $is_aliased      = 0;
      my $is_prev_version = 0;
      my $is_prev_module_name = 0;
  
      my $does_garbage_exist = 0;
      my $does_use_lib_or_constant = 0;
  
      my $latest_prereq = '';
  
      TOP:
      for (my $i = 0; my $token = $tokens->[$i]; $i++) {
          my $token_type = $token->{type};
  
          # For require statement
          if ($token_type == REQUIRE_DECL || ($token_type == BUILTIN_FUNC && $token->{data} eq 'no')) {
              $is_in_reqdecl = 1;
              next;
          }
          if ($is_in_reqdecl) {
              # e.g.
              #   require Foo;
              if ($token_type == REQUIRED_NAME || $token_type == KEY) {
                  $latest_prereq = $self->add_minimum($token->{data} => 0);
  
                  $is_in_reqdecl = 0;
                  next;
              }
  
              # e.g.
              #   require Foo::Bar;
              if ($token_type == NAMESPACE || $token_type == NAMESPACE_RESOLVER) {
                  $module_name .= $token->{data};
                  next;
              }
  
              # End of declare of require statement
              if ($token_type == SEMI_COLON) {
                  if ($module_name) {
                      $latest_prereq = $self->add_minimum($module_name => 0);
                  }
  
                  $module_name   = '';
                  $is_in_reqdecl = 0;
                  next;
              }
  
              next;
          }
  
          # For use statement
          if ($token_type == USE_DECL) {
              $is_in_usedecl = 1;
              next;
          }
          if ($is_in_usedecl) {
              # e.g.
              #   use Foo;
              #   use parent qw/Foo/;
              #
              if ($token_type == USED_NAME || $token_type == IF_STMT) {
                  # XXX                       ~~~~~~~~~~~~~~~~~~~~~~
                  # Workaround for `use if` statement
                  # It is a matter of Compiler::Lexer (maybe).
                  #
                  #   use if $] < 5.009_005, 'MRO::Compat';
  
                  $module_name = $token->{data};
  
                  if ($module_name eq 'lib' || $module_name eq 'constant') {
                      $latest_prereq = $self->add_minimum($module_name, 0);
                      $does_use_lib_or_constant = 1;
                  }
                  elsif ($module_name =~ /(?:base|parent)/) {
                      $is_inherited = 1;
                  }
                  elsif ($module_name =~ 'aliased') {
                      $is_aliased = 1;
                  }
  
                  $is_prev_module_name = 1;
                  next;
              }
  
              # End of declare of use statement
              if ($token_type == SEMI_COLON || $token_type == LEFT_BRACE || $token_type == LEFT_BRACKET) {
                  if ($module_name && !$does_use_lib_or_constant) {
                      $latest_prereq = $self->add_minimum($module_name => $module_version);
                  }
  
                  $module_name    = '';
                  $module_version = 0;
                  $is_in_reglist  = 0;
                  $is_inherited   = 0;
                  $is_in_list     = 0;
                  $is_in_usedecl  = 0;
                  $is_aliased     = 0;
                  $does_garbage_exist  = 0;
                  $is_prev_module_name = 0;
                  $does_use_lib_or_constant = 0;
  
                  next;
              }
  
              # e.g.
              #   use Foo::Bar;
              if ($token_type == NAMESPACE || $token_type == NAMESPACE_RESOLVER) {
                  $module_name .= $token->{data};
                  $is_prev_module_name = 1;
                  next;
              }
  
              # Section for parent/base
              if ($is_inherited) {
                  # For qw() notation
                  # e.g.
                  #   use parent qw/Foo Bar/;
                  if ($token_type == REG_LIST) {
                      $is_in_reglist = 1;
                  }
                  elsif ($is_in_reglist) {
                      if ($token_type == REG_EXP) {
                          for my $_module_name (split /\s+/, $token->{data}) {
                              $latest_prereq = $self->add_minimum($_module_name => 0);
                          }
                          $is_in_reglist = 0;
                      }
                  }
  
                  # For simply list
                  # e.g.
                  #   use parent ('Foo' 'Bar');
                  elsif ($token_type == LEFT_PAREN) {
                      $is_in_list = 1;
                  }
                  elsif ($token_type == RIGHT_PAREN) {
                      $is_in_list = 0;
                  }
                  elsif ($is_in_list) {
                      if ($token_type == STRING || $token_type == RAW_STRING) {
                          $latest_prereq = $self->add_minimum($token->{data} => 0);
                      }
                  }
  
                  # For string
                  # e.g.
                  #   use parent "Foo"
                  elsif ($token_type == STRING || $token_type == RAW_STRING) {
                      $latest_prereq = $self->add_minimum($token->{data} => 0);
                  }
  
                  $is_prev_module_name = 0;
                  next;
              }
  
              if ($token_type == DOUBLE || $token_type == INT || $token_type == VERSION_STRING) {
                  if (!$module_name) {
                      if (!$does_garbage_exist) {
                          # For perl version
                          # e.g.
                          #   use 5.012;
                          my $perl_version = $token->{data};
                          $latest_prereq = $self->add_minimum('perl' => $perl_version);
                          $is_in_usedecl = 0;
                      }
                  }
                  elsif($is_prev_module_name) {
                      # For module version
                      # e.g.
                      #   use Foo::Bar 0.0.1;'
                      #   use Foo::Bar v0.0.1;
                      #   use Foo::Bar 0.0_1;
                      $module_version = $token->{data};
                  }
  
                  $is_prev_module_name = 0;
                  $is_prev_version = 1;
                  next;
              }
  
              if ($is_aliased) {
                  if ($token_type == STRING || $token_type == RAW_STRING) {
                      $latest_prereq = $self->add_minimum($token->{data} => 0);
                      $is_aliased = 0;
                  }
                  next;
              }
  
              if (($is_prev_module_name || $is_prev_version) && $token_type == LEFT_PAREN) {
                  my $left_paren_num = 1;
                  for ($i++; $token = $tokens->[$i]; $i++) { # skip content that is surrounded by parens
                      $token_type = $token->{type};
  
                      if ($token_type == LEFT_PAREN) {
                          $left_paren_num++;
                      }
                      elsif ($token_type == RIGHT_PAREN) {
                          last if --$left_paren_num <= 0;
                      }
                  }
                  next;
              }
  
              if ($token_type != WHITESPACE) {
                  $does_garbage_exist  = 1;
                  $is_prev_module_name = 0;
                  $is_prev_version = 0;
              }
              next;
          }
  
          for my $extra_scanner (@{$self->{extra_scanners}}) {
              if ($extra_scanner->scan($self, $token, $token_type)) {
                  next TOP;
              }
          }
  
          if ($token_type == COMMENT && $token->{data} =~ /\A##\s*no prereq\Z/) {
              $self->{module_reqs}->clear_requirement($latest_prereq);
              next;
          }
      }
  
      return $self->{module_reqs};
  }
  
  sub add_minimum {
      my ($self, $module_name, $module_version) = @_;
  
      if ($module_name) {
          $self->{module_reqs}->add_minimum($module_name => $module_version);
      }
  
      return $module_name;
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =for stopwords prepend reimplement
  
  =head1 NAME
  
  Perl::PrereqScanner::Lite - Lightweight Prereqs Scanner for Perl
  
  =head1 SYNOPSIS
  
      use Perl::PrereqScanner::Lite;
  
      my $scanner = Perl::PrereqScanner::Lite->new;
      $scanner->add_extra_scanner('Moose'); # add extra scanner for moose style
      my $modules = $scanner->scan_file('path/to/file');
  
  =head1 DESCRIPTION
  
  Perl::PrereqScanner::Lite is the lightweight prereqs scanner for perl.
  This scanner uses L<Compiler::Lexer> as tokenizer, therefore processing speed is really fast.
  
  =head1 METHODS
  
  =head2 new($opt)
  
  Create a scanner instance.
  
  C<$opt> must be hash reference. It accepts following keys of hash:
  
  =over 4
  
  =item * extra_scanners
  
  It specifies extra scanners. This item must be array reference.
  
  e.g.
  
      my $scanner = Perl::PrereqScanner::Lite->new(
          extra_scanners => [qw/Moose Version/]
      );
  
  See also L</add_extra_scanner($scanner_name)>.
  
  =item * no_prereq
  
  It specifies to use C<## no prereq> or not. Please see also L</ADDITIONAL NOTATION>.
  
  =back
  
  =head2 scan_file($file_path)
  
  Scan and figure out prereqs which is instance of C<CPAN::Meta::Requirements> by file path.
  
  =head2 scan_string($string)
  
  Scan and figure out prereqs which is instance of C<CPAN::Meta::Requirements> by source code string written in perl.
  
  e.g.
  
      open my $fh, '<', __FILE__;
      my $string = do { local $/; <$fh> };
      my $modules = $scanner->scan_string($string);
  
  =head2 scan_module($module_name)
  
  Scan and figure out prereqs which is instance of C<CPAN::Meta::Requirements> by module name.
  
  e.g.
  
      my $modules = $scanner->scan_module('Perl::PrereqScanner::Lite');
  
  =head2 scan_tokens($tokens)
  
  Scan and figure out prereqs which is instance of C<CPAN::Meta::Requirements> by tokens of L<Compiler::Lexer>.
  
  e.g.
  
      open my $fh, '<', __FILE__;
      my $string = do { local $/; <$fh> };
      my $tokens = Compiler::Lexer->new->tokenize($string);
      my $modules = $scanner->scan_tokens($tokens);
  
  =head2 add_extra_scanner($scanner_name)
  
  Add extra scanner to scan and figure out prereqs. This module loads extra scanner such as C<Perl::PrereqScanner::Lite::Scanner::$scanner_name> if specifying scanner name through this method.
  
  If you want to specify an extra scanner from external package without C<Perl::PrereqScanner::Lite::> prefix, you can prepend C<+> to C<$scanner_name>. Like so C<+Your::Awesome::Scanner>.
  
  Extra scanners that are default supported are followings;
  
  =over 8
  
  =item * L<Perl::PrereqScanner::Lite::Scanner::Moose>
  
  =item * L<Perl::PrereqScanner::Lite::Scanner::Version>
  
  =back
  
  =head1 ADDITIONAL NOTATION
  
  If C<no_prereq> is enabled by C<new()> (like so: C<Perl::PrereqScanner::Lite-E<gt>new({no_prereq =E<gt> 1})>),
  this module recognize C<## no prereq> optional comment. The requiring declaration with this comment on the same line will be ignored as prereq.
  
  For example
  
      use Foo;
      use Bar; ## no prereq
  
  In this case C<Foo> is the prereq, however C<Bar> is ignored.
  
  =head1 SPEED COMPARISON
  
  =head2 Plain
  
                                  Rate   Perl::PrereqScanner Perl::PrereqScanner::Lite
      Perl::PrereqScanner       8.57/s                    --                      -97%
      Perl::PrereqScanner::Lite  246/s                 2770%                        --
  
  =head2 With Moose scanner
  
                                  Rate   Perl::PrereqScanner Perl::PrereqScanner::Lite
      Perl::PrereqScanner       9.00/s                    --                      -94%
      Perl::PrereqScanner::Lite  152/s                 1587%                        --
  
  =head1 NOTES
  
  This is a quotation from L<https://github.com/moznion/Perl-PrereqScanner-Lite/issues/13>.
  
  =begin text
  
  The interface of an this module object suggests every scan_* call is not affected by any other, yet the code is storing the requirements in that object. This is quite surprising.
  
  I'd suggest that either it must change to be more functional-style, or this behavior should be clearly documented.
  
  =end text
  
  Yes, it's true. This design is so ugly and not smart.
  So I have to redesign and reimplement this module, and I have some plans.
  
  If you have a mind to expand this module by implementing external scanner,
  please be careful.
  Every C<scan_*> calls must not affect to any others through the
  singleton of this module (called it C<$c> in L<https://github.com/moznion/Perl-PrereqScanner-Lite/blob/c03638b2e2a39d92f4d7df360af5a6be65dc417a/lib/Perl/PrereqScanner/Lite/Scanner/Moose.pm#L8>).
  
  =head1 SEE ALSO
  
  L<Perl::PrereqScanner>, L<Compiler::Lexer>
  
  =head1 LICENSE
  
  Copyright (C) moznion.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  moznion E<lt>moznion@gmail.comE<gt>
  
  =cut
  
PERL_PREREQSCANNER_LITE

$fatpacked{"Perl/PrereqScanner/Lite/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_PREREQSCANNER_LITE_CONSTANTS';
  package Perl::PrereqScanner::Lite::Constants;
  use strict;
  use warnings;
  use utf8;
  use Compiler::Lexer::Constants;
  
  use parent qw(Exporter);
  
  our @EXPORT = qw(
      REQUIRE_DECL REQUIRED_NAME NAMESPACE_RESOLVER NAMESPACE
      SEMI_COLON USE_DECL USED_NAME REG_LIST REG_EXP LEFT_PAREN
      RIGHT_PAREN STRING RAW_STRING VERSION_STRING INT DOUBLE KEY
      METHOD WHITESPACE COMMENT LEFT_BRACE RIGHT_BRACE
      LEFT_BRACKET RIGHT_BRACKET BUILTIN_FUNC
      IF_STMT COMMA
  );
  
  use constant {
      REQUIRE_DECL       => Compiler::Lexer::TokenType::T_RequireDecl,
      REQUIRED_NAME      => Compiler::Lexer::TokenType::T_RequiredName,
      NAMESPACE_RESOLVER => Compiler::Lexer::TokenType::T_NamespaceResolver,
      NAMESPACE          => Compiler::Lexer::TokenType::T_Namespace,
      SEMI_COLON         => Compiler::Lexer::TokenType::T_SemiColon,
      USE_DECL           => Compiler::Lexer::TokenType::T_UseDecl,
      USED_NAME          => Compiler::Lexer::TokenType::T_UsedName,
      REG_LIST           => Compiler::Lexer::TokenType::T_RegList,
      REG_EXP            => Compiler::Lexer::TokenType::T_RegExp,
      STRING             => Compiler::Lexer::TokenType::T_String,
      RAW_STRING         => Compiler::Lexer::TokenType::T_RawString,
      VERSION_STRING     => Compiler::Lexer::TokenType::T_VersionString,
      INT                => Compiler::Lexer::TokenType::T_Int,
      DOUBLE             => Compiler::Lexer::TokenType::T_Double,
      KEY                => Compiler::Lexer::TokenType::T_Key,
      METHOD             => Compiler::Lexer::TokenType::T_Method,
      WHITESPACE         => Compiler::Lexer::TokenType::T_WhiteSpace,
      COMMENT            => Compiler::Lexer::TokenType::T_Comment,
      IF_STMT            => Compiler::Lexer::TokenType::T_IfStmt,
      COMMA              => Compiler::Lexer::TokenType::T_Comma,
  
      LEFT_PAREN   => Compiler::Lexer::TokenType::T_LeftParenthesis,
      RIGHT_PAREN  => Compiler::Lexer::TokenType::T_RightParenthesis,
      LEFT_BRACE   => Compiler::Lexer::TokenType::T_LeftBrace,
      RIGHT_BRACE   => Compiler::Lexer::TokenType::T_RightBrace,
      LEFT_BRACKET => Compiler::Lexer::TokenType::T_LeftBracket,
      RIGHT_BRACKET => Compiler::Lexer::TokenType::T_RightBracket,
  
      BUILTIN_FUNC => Compiler::Lexer::TokenType::T_BuiltinFunc,
  };
  
  1;
  
PERL_PREREQSCANNER_LITE_CONSTANTS

$fatpacked{"Perl/PrereqScanner/Lite/Scanner/Moose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_PREREQSCANNER_LITE_SCANNER_MOOSE';
  package Perl::PrereqScanner::Lite::Scanner::Moose;
  use strict;
  use warnings;
  use utf8;
  use Perl::PrereqScanner::Lite::Constants;
  
  sub scan {
      my ($class, $c, $token, $token_type) = @_;
  
      my $token_data = $token->data;
      if ($token_type == KEY && ($token_data eq 'extends' || $token_data eq 'with')) {
          $c->{is_in_moose_inherited} = 1;
          return 1;
      }
  
      if ($c->{is_in_moose_inherited}) {
          # to skip content which is is curly bracket -> { ... }
          {
              if ($token_type == LEFT_BRACE) {
                  $c->{is_in_moose_role_def} = 1;
                  return 1;
              }
  
              if ($token_type == RIGHT_BRACE) {
                  $c->{is_in_moose_role_def} = 0;
                  return 1;
              }
  
              if ($c->{is_in_moose_role_def}) {
                  return 1;
              }
          }
  
          # For qw() notation
          # e.g.
          #   extends qw/Foo Bar/;
          #   with qw/Foo Bar/;
          if ($token_type == REG_LIST) {
              $c->{is_in_moose_inherited_reglist} = 1;
              return 1;
          }
          if ($c->{is_in_moose_inherited_reglist} && !$c->{does_exist_moose_garbage}) {
              if ($token_type == REG_EXP) {
                  for my $_module_name (split /\s+/, $token_data) {
                      $c->add_minimum($_module_name => 0);
                  }
                  $c->{is_in_moose_inherited_reglist} = 0;
              }
              return 1;
          }
  
          # For simply list
          # e.g.
          #   extends ('Foo', 'Bar');
          #   with ('Foo', 'Bar');
          if ($token_type == LEFT_PAREN) {
              $c->{is_in_moose_inherited_list} = 1;
              return 1;
          }
          if ($token_type == RIGHT_PAREN) {
              $c->{is_in_moose_inherited_list} = 0;
              return 1;
          }
          if ($c->{is_in_moose_inherited_list}) {
              if (($token_type == STRING || $token_type == RAW_STRING) && !$c->{does_exist_moose_garbage}) {
                  $c->add_minimum($token_data => 0);
              }
              return 1;
          }
  
          # For string
          # e.g.
          #   extends "Foo"
          #   with "Foo"
          if ((($token_type == STRING || $token_type == RAW_STRING)) && !$c->{does_exist_moose_garbage}) {
              $c->add_minimum($token_data => 0);
              return 1;
          }
  
          # End of extends or with
          if ($token_type == SEMI_COLON) {
              $c->{is_in_moose_inherited}         = 0;
              $c->{is_in_moose_inherited_reglist} = 0;
              $c->{is_in_moose_inherited_list}    = 0;
              $c->{does_exist_moose_garbage}      = 0;
              return 1;
          }
  
          # For
          #   extends 'Class1', 'Class2';
          if ($token_type != COMMA) {
              $c->{does_exist_moose_garbage} = 1;
          }
  
          return 1;
      }
  
      return;
  }
  
  1;
  
  =encoding utf-8
  
  =head1 NAME
  
  Perl::PrereqScanner::Lite::Scanner::Moose - Extra Perl::PrereqScanner::Lite Scanner for Moose Family
  
  =head1 SYNOPSIS
  
      use Perl::PrereqScanner::Lite;
  
      my $scanner = Perl::PrereqScanner::Lite->new;
      $scanner->add_extra_scanner('Moose');
  
  =head1 DESCRIPTION
  
  Perl::PrereqScanner::Lite::Scanner::Moose is the extra scanner for Perl::PrereqScanner::Lite. This scanner supports C<extends> and C<with> notation for Moose family.
  
  =head1 LICENSE
  
  Copyright (C) moznion.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  moznion E<lt>moznion@gmail.comE<gt>
  
  =cut
  
PERL_PREREQSCANNER_LITE_SCANNER_MOOSE

$fatpacked{"Perl/PrereqScanner/Lite/Scanner/Version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_PREREQSCANNER_LITE_SCANNER_VERSION';
  package Perl::PrereqScanner::Lite::Scanner::Version;
  use strict;
  use warnings;
  use utf8;
  use Perl::PrereqScanner::Lite::Constants;
  
  sub scan {
      my ($class, $c, $token, $token_type) = @_;
  
      if ($token_type == KEY || $token_type == NAMESPACE || $token_type == NAMESPACE_RESOLVER) {
          $c->{not_decl_module_name} .= $token->{data};
          return 1;
      }
  
      if ($token_type == METHOD && $token->{data} eq 'VERSION') {
          $c->{is_version_decl} = 1;
          return 1;
      }
  
      if ($c->{is_version_decl} && $token_type == INT || $token_type == DOUBLE || $token_type == VERSION_STRING) {
          if ($c->{module_reqs}->{requirements}->{$c->{not_decl_module_name}}) {
              $c->add_minimum($c->{not_decl_module_name} => $token->{data});
          }
          $c->{is_version_decl} = 0;
          $c->{not_decl_module_name} = '';
          return 1;
      }
  
      if ($token_type == SEMI_COLON) {
          $c->{is_version_decl} = 0;
          $c->{not_decl_module_name} = '';
          return 1;
      }
  }
  
  1;
  
  =encoding utf-8
  
  =head1 NAME
  
  Perl::PrereqScanner::Lite::Scanner::Version - Extra Perl::PrereqScanner::Lite Scanner for VERSION method
  
  =head1 SYNOPSIS
  
      use Perl::PrereqScanner::Lite;
  
      my $scanner = Perl::PrereqScanner::Lite->new;
      $scanner->add_extra_scanner('Version');
  
  =head1 DESCRIPTION
  
  Perl::PrereqScanner::Lite::Scanner::Version is the extra scanner for Perl::PrereqScanner::Lite.
  This scanner supports C<VERSION> method. It retrieves version from the argument of C<VERSION>.
  
  For example,
  
      require Foo::Bar;
      Foo::Bar->VERSION(1.00);
  
  =head1 LICENSE
  
  Copyright (C) moznion.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  moznion E<lt>moznion@gmail.comE<gt>
  
  =cut
  
PERL_PREREQSCANNER_LITE_SCANNER_VERSION

$fatpacked{"darwin-2level/Compiler/Lexer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_COMPILER_LEXER';
  package Compiler::Lexer;
  use strict;
  use warnings;
  use 5.008_001;
  use File::Find;
  use Compiler::Lexer::Token;
  use Compiler::Lexer::Constants;
  
  require Exporter;
  our @ISA = qw(Exporter);
  our %EXPORT_TAGS = ( 'all' => [ qw() ] );
  our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );
  our @EXPORT = qw();
  our $VERSION = '0.22';
  require XSLoader;
  XSLoader::load(__PACKAGE__, $VERSION);
  
  my $inc;
  
  sub new {
      my ($class, $args) = @_;
      my $options = +{};
      if (ref $args eq 'HASH') {
          $options = $args;
      } elsif (ref $args eq 'SCALAR') {
          $options->{filename} = $args;
      }
      $options->{filename} ||= '-';
      $options->{verbose}  ||= 0;
      return $class->_new($options);
  }
  
  sub set_library_path {
      my ($self, $_inc) = @_;
      $inc = $_inc;
  }
  
  sub load_module {
      my ($self, $name) = @_;
      $name =~ s|::|/|g;
      my @include_path = ($inc) ? @$inc : @INC;
      my $module_path = '';
      foreach my $path (@include_path) {
          next unless -e $path;
          find(sub {
              return if ($module_path);
              my $absolute_path = $File::Find::name;
              if ($absolute_path =~ "$name.pm") {
                  $module_path = $absolute_path;
              }
          }, $path);
          last if ($module_path);
      }
      return undef unless $module_path;
      open my $fh, '<', $module_path;
      return do { local $/; <$fh> };
  }
  
  sub recursive_tokenize {
      my ($self, $script) = @_;
      my %results;
      $self->__recursive_tokenize(\%results, $script);
      $results{main} = $self->tokenize($script);
      return \%results;
  }
  
  sub __recursive_tokenize {
      my ($self, $results, $script) = @_;
      my $modules = $self->get_used_modules($script);
      foreach my $module (@$modules) {
          my $name = $module->{name};
          next if (defined $results->{$name});
          $results->{$name} ||= [];
          my $code = $self->load_module($name);
          next unless ($code);
          $results->{$name} = $self->tokenize($code);
          $self->__recursive_tokenize($results, $code);
      }
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Compiler::Lexer - Lexical Analyzer for Perl5
  
  =head1 SYNOPSIS
  
    use Compiler::Lexer;
    use Data::Dumper;
  
    my $filename = $ARGV[0];
    open my $fh, '<', $filename or die "Cannot open $filename: $!";
    my $script = do { local $/; <$fh> };
  
    my $lexer = Compiler::Lexer->new($filename);
    my $tokens = $lexer->tokenize($script);
    print Dumper $tokens;
  
    my $modules = $lexer->get_used_modules($script);
    print Dumper $modules;
  
  =head1 METHODS
  
  =over 4
  
  =item my $lexer = Compiler::Lexer->new($options);
  
  create new instance.
  You can create object from $options in hash reference.
  
  B<options list>
  
  =over 4
  
  =item filename
  
  =item verbose : includes token of Pod, Comment and WhiteSpace
  
  =back
  
  =item $lexer->tokenize($script);
  
  get token objects includes parameter of 'name' or 'type' or 'line' and so on.
  This method requires perl source code in string.
  
  =item $lexer->set_library_path(['path1', 'path2' ...])
  
  set libraries path for reading recursively. Default paths are @INC.
  
  =item $lexer->recursive_tokenize($script)
  
  get hash reference like { 'module_nameA' => [], 'module_nameB' => [] ... }.
  This method requires per source code in string.
  
  =item $lexer->get_used_modules($script);
  
  get names of used module.
  This method requires perl source code in string.
  
  =back
  
  =head1 AUTHOR
  
  Masaaki Goshima (goccy) E<lt>goccy(at)cpan.orgE<gt>
  
  =head1 CONTRIBUTORS
  
  tokuhirom: Tokuhiro Matsuno
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright (c) 2013, Masaaki Goshima (goccy). All rights reserved.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_COMPILER_LEXER

$fatpacked{"darwin-2level/Compiler/Lexer/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_COMPILER_LEXER_CONSTANTS';
  use strict;
  use warnings;
  
  package Compiler::Lexer::TokenType;
  use constant {
      T_Return => 0,
      T_Add => 1,
      T_Sub => 2,
      T_Mul => 3,
      T_Div => 4,
      T_Mod => 5,
      T_ThreeTermOperator => 6,
      T_Greater => 7,
      T_Less => 8,
      T_StringAdd => 9,
      T_Ref => 10,
      T_Glob => 11,
      T_BitNot => 12,
      T_BitOr => 13,
      T_AlphabetOr => 14,
      T_BitAnd => 15,
      T_AlphabetAnd => 16,
      T_BitXOr => 17,
      T_AlphabetXOr => 18,
      T_StringMul => 19,
      T_AddEqual => 20,
      T_SubEqual => 21,
      T_MulEqual => 22,
      T_DivEqual => 23,
      T_ModEqual => 24,
      T_StringAddEqual => 25,
      T_LeftShiftEqual => 26,
      T_RightShiftEqual => 27,
      T_StringMulEqual => 28,
      T_GreaterEqual => 29,
      T_LessEqual => 30,
      T_EqualEqual => 31,
      T_Diamond => 32,
      T_Compare => 33,
      T_PolymorphicCompare => 34,
      T_RegOK => 35,
      T_RegNot => 36,
      T_NotEqual => 37,
      T_StringLess => 38,
      T_StringLessEqual => 39,
      T_StringGreater => 40,
      T_StringGreaterEqual => 41,
      T_StringEqual => 42,
      T_StringNotEqual => 43,
      T_StringCompare => 44,
      T_Inc => 45,
      T_Dec => 46,
      T_Exp => 47,
      T_PowerEqual => 48,
      T_DefaultEqual => 49,
      T_LeftShift => 50,
      T_RightShift => 51,
      T_And => 52,
      T_Or => 53,
      T_AndBitEqual => 54,
      T_OrBitEqual => 55,
      T_NotBitEqual => 56,
      T_OrEqual => 57,
      T_AndEqual => 58,
      T_Slice => 59,
      T_DefaultOperator => 60,
      T_ToDo => 61,
      T_VarDecl => 62,
      T_FunctionDecl => 63,
      T_Method => 64,
      T_Assign => 65,
      T_ArraySize => 66,
      T_Is => 67,
      T_Not => 68,
      T_AlphabetNot => 69,
      T_BuiltinFunc => 70,
      T_RequireDecl => 71,
      T_Import => 72,
      T_SpecificKeyword => 73,
      T_DataWord => 74,
      T_ModWord => 75,
      T_AUTOLOAD => 76,
      T_CORE => 77,
      T_DESTROY => 78,
      T_STDIN => 79,
      T_STDOUT => 80,
      T_STDERR => 81,
      T_Redo => 82,
      T_Next => 83,
      T_Last => 84,
      T_Goto => 85,
      T_Continue => 86,
      T_Do => 87,
      T_Break => 88,
      T_Handle => 89,
      T_LocalDecl => 90,
      T_OurDecl => 91,
      T_StateDecl => 92,
      T_UseDecl => 93,
      T_UsedName => 94,
      T_RequiredName => 95,
      T_IfStmt => 96,
      T_ElseStmt => 97,
      T_ElsifStmt => 98,
      T_UnlessStmt => 99,
      T_UntilStmt => 100,
      T_WhenStmt => 101,
      T_GivenStmt => 102,
      T_DefaultStmt => 103,
      T_Comma => 104,
      T_Colon => 105,
      T_SemiColon => 106,
      T_LeftParenthesis => 107,
      T_RightParenthesis => 108,
      T_LeftBrace => 109,
      T_RightBrace => 110,
      T_LeftBracket => 111,
      T_RightBracket => 112,
      T_ArrayDereference => 113,
      T_HashDereference => 114,
      T_ScalarDereference => 115,
      T_CodeDereference => 116,
      T_ShortScalarDereference => 117,
      T_ShortArrayDereference => 118,
      T_ShortHashDereference => 119,
      T_ShortCodeDereference => 120,
      T_ArraySizeDereference => 121,
      T_Key => 122,
      T_BareWord => 123,
      T_Arrow => 124,
      T_Pointer => 125,
      T_NamespaceResolver => 126,
      T_Namespace => 127,
      T_Package => 128,
      T_Class => 129,
      T_CallDecl => 130,
      T_CodeRef => 131,
      T_WhileStmt => 132,
      T_ForStmt => 133,
      T_ForeachStmt => 134,
      T_Annotation => 135,
      T_ArgumentArray => 136,
      T_SpecificValue => 137,
      T_ConstValue => 138,
      T_ProgramArgument => 139,
      T_LibraryDirectories => 140,
      T_Environment => 141,
      T_Include => 142,
      T_Signal => 143,
      T_RegOpt => 144,
      T_RegQuote => 145,
      T_RegDoubleQuote => 146,
      T_RegList => 147,
      T_RegExec => 148,
      T_RegDecl => 149,
      T_RegMatch => 150,
      T_RegDelim => 151,
      T_HandleDelim => 152,
      T_RegMiddleDelim => 153,
      T_RegAllReplace => 154,
      T_RegReplace => 155,
      T_RegReplaceFrom => 156,
      T_RegReplaceTo => 157,
      T_FieldDecl => 158,
      T_TypeRef => 159,
      T_LabelRef => 160,
      T_LocalVarDecl => 161,
      T_GlobalVarDecl => 162,
      T_MultiLocalVarDecl => 163,
      T_MultiGlobalVarDecl => 164,
      T_Prototype => 165,
      T_Var => 166,
      T_CodeVar => 167,
      T_ArrayVar => 168,
      T_HashVar => 169,
      T_Int => 170,
      T_Double => 171,
      T_String => 172,
      T_RawString => 173,
      T_ExecString => 174,
      T_VersionString => 175,
      T_HereDocumentTag => 176,
      T_HereDocumentRawTag => 177,
      T_HereDocumentExecTag => 178,
      T_HereDocumentBareTag => 179,
      T_RawHereDocument => 180,
      T_HereDocument => 181,
      T_HereDocumentEnd => 182,
      T_FormatDecl => 183,
      T_Format => 184,
      T_FormatEnd => 185,
      T_Object => 186,
      T_RegExp => 187,
      T_Array => 188,
      T_Hash => 189,
      T_Operator => 190,
      T_LocalVar => 191,
      T_LocalArrayVar => 192,
      T_LocalHashVar => 193,
      T_GlobalVar => 194,
      T_GlobalArrayVar => 195,
      T_GlobalHashVar => 196,
      T_ArrayRef => 197,
      T_HashRef => 198,
      T_ArrayAt => 199,
      T_HashAt => 200,
      T_ArraySet => 201,
      T_HashSet => 202,
      T_Function => 203,
      T_Call => 204,
      T_Argument => 205,
      T_List => 206,
      T_Default => 207,
      T_Pod => 208,
      T_Comment => 209,
      T_WhiteSpace => 210,
      T_Undefined => 211,
      T_PostDeref => 212,
      T_PostDerefStar => 213,
      T_PostDerefArraySliceOpenBracket => 214,
      T_PostDerefArraySliceCloseBracket => 215,
      T_PostDerefHashSliceOpenBrace => 216,
      T_PostDerefHashSliceCloseBrace => 217,
      T_PostDerefCodeOpenParen => 218,
      T_PostDerefCodeCloseParen => 219
  };
  
  package Compiler::Lexer::SyntaxType;
  use constant {
      T_Value => 0,
      T_Term => 1,
      T_Expr => 2,
      T_Stmt => 3,
      T_BlockStmt => 4
  };
  
  package Compiler::Lexer::Kind;
  use constant {
      T_Return => 0,
      T_Operator => 1,
      T_Assign => 2,
      T_Decl => 3,
      T_Function => 4,
      T_SingleTerm => 5,
      T_Import => 6,
      T_SpecificKeyword => 7,
      T_DataWord => 8,
      T_ModWord => 9,
      T_AUTOLOAD => 10,
      T_CORE => 11,
      T_DESTROY => 12,
      T_Handle => 13,
      T_Control => 14,
      T_Do => 15,
      T_Module => 16,
      T_Stmt => 17,
      T_DefaultStmt => 18,
      T_Comma => 19,
      T_Colon => 20,
      T_StmtEnd => 21,
      T_Symbol => 22,
      T_Modifier => 23,
      T_Term => 24,
      T_Namespace => 25,
      T_Package => 26,
      T_Class => 27,
      T_Annotation => 28,
      T_RegOpt => 29,
      T_RegPrefix => 30,
      T_RegReplacePrefix => 31,
      T_Ref => 32,
      T_Get => 33,
      T_Set => 34,
      T_Verbose => 35,
      T_Undefined => 36
  };
  
  1;
DARWIN-2LEVEL_COMPILER_LEXER_CONSTANTS

$fatpacked{"darwin-2level/Compiler/Lexer/Token.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_COMPILER_LEXER_TOKEN';
  package Compiler::Lexer::Token;
  use strict;
  use warnings;
  
  my $FIELDS = [qw/
      stype
      type
      kind
      line
      name
      data
      has_warnings
  /];
  
  {
      no strict 'refs';
      foreach my $field (@$FIELDS) {
          *{__PACKAGE__ . '::' . $field} = sub {
              my ($self, $value) = @_;
              return $self->{$field} unless defined $value;
              $self->{$field} = $value;
          };
      }
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =for stopwords stype
  
  =head1 NAME
  
  Compiler::Lexer::Token
  
  =head1 SYNOPSIS
  
  Compiler::Lexer::Token includes the following members.
  
  =over
  
  =item stype
  
  constant of Compiler::Lexer::SyntaxType
  
  =item type
  
  constant of Compiler::Lexer::TokenType
  
  =item kind
  
  constant of Compiler::Lexer::Kind
  
  =item name
  
  name of Compiler::Lexer::TokenType
  
  =item data
  
  raw data
  
  =item has_warnings
  
  flag of whether unknown keyword or not
  
  =back
  
  =head1 METHODS
  
  support simple get/set accessors like Class::Accessor::Fast
  
  example:
  
    my $type = $token->type;                            # get accessor
    $token->type(Compiler::Lexer::TokenType::T_RegExp); # set accessor
  
  =head1 AUTHOR
  
  Masaaki Goshima (goccy) E<lt>goccy(at)cpan.orgE<gt>
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright (c) 2013, Masaaki Goshima (goccy). All rights reserved.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_COMPILER_LEXER_TOKEN

$fatpacked{"darwin-2level/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle uniq uniqnum uniqstr
    pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.45";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first
  
        max maxstr min minstr product sum sum0
  
        pairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniqnum uniqstr
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of the all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
DARWIN-2LEVEL_LIST_UTIL

$fatpacked{"darwin-2level/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.45";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_LIST_UTIL_XS

$fatpacked{"darwin-2level/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.45";
  $VERSION   = eval $VERSION;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be a dual-valued variable, it is
  actually implemented as a magical variable inside the interpreter:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use L</isweak> or L</weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_SCALAR_UTIL

$fatpacked{"darwin-2level/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.45";
  $VERSION   = eval $VERSION;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If a name has been set using L</set_subname>, this name will
  be returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.+?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
DARWIN-2LEVEL_SUB_UTIL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/Users/gugod/perl5/perlbrew/perls/perl-5.22.0/bin/perl
use strict;
use warnings;
use utf8;
use 5.008001;

use version;
use CPAN::Meta;
use Getopt::Long;
use CPAN::Meta::Requirements ();
use File::Find qw(find);
use Module::CoreList;
use Module::CPANfile;
use File::Spec;
use File::Basename ();
use Module::Metadata;
use Perl::PrereqScanner::Lite;

our $VERSION = '1.03';

sub debugf {
    if ($ENV{SCAN_PREREQS_CPANFILE_DEBUG}) {
        require Data::Dumper;
        my $format = shift;
        no warnings 'once';
        local $Data::Dumper::Terse  = 1;
        local $Data::Dumper::Indent = 0;
        my $txt = sprintf($format, map { defined($_) ? Data::Dumper::Dumper($_) : '-' } @_);
        print $txt, "\n";
    }
}

my $version;
my $diff;
my $include_empty;
my $scan_test_requires;
my @ignore = qw(eg examples share fatlib _build .git blib local .build);
my $add_ignore;
my $p = Getopt::Long::Parser->new(
    config => [qw(posix_default no_ignore_case auto_help)]
);
$p->getoptions(
    'version!'       => \$version,
    'diff=s'         => \$diff,
    'ignore=s'       => \$add_ignore,
    'include-empty!' => \$include_empty,
    'scan-test-requires' => \$scan_test_requires,
);
push @ignore, split /,/,$add_ignore if $add_ignore;
if ($version) {
    printf "%s %s\n", File::Basename::basename($0), $VERSION;
    exit 0;
}

&main; exit;

sub main {
    my ($runtime_files, $test_files, $configure_files, $develop_files) = find_perl_files();
    debugf($develop_files);

    my @inner_packages = scan_inner_packages(@$test_files, @$runtime_files, @$configure_files, @$develop_files);
    my $meta_prereqs = $diff ? load_diff_src($diff) : +{};

    # runtime
    my $runtime_prereqs = scan($runtime_files, \@inner_packages, $meta_prereqs, [qw(runtime)], 'runtime', +{});

    # test
    my $test_prereqs = scan($test_files, \@inner_packages, $meta_prereqs, [qw(test runtime)], 'test', $runtime_prereqs);

    # configure
    my $configure_prereqs = scan($configure_files, \@inner_packages, $meta_prereqs, [qw(configure runtime)], 'configure', $runtime_prereqs);

    # develop
    my $develop_prereqs = scan($develop_files, \@inner_packages, $meta_prereqs, [qw(develop test runtime)], 'develop', +{ %{$runtime_prereqs||{}}, %{$test_prereqs||{}}});

    if ($scan_test_requires) {
        $develop_prereqs = scan_test_requires($develop_prereqs);
    }

    print Module::CPANfile->from_prereqs(
        {
            runtime => {
                requires => $runtime_prereqs,
            },
            configure => {
                requires => $configure_prereqs,
            },
            test => {
                requires => $test_prereqs,
            },
            develop => {
                requires => $develop_prereqs,
            },
        }
    )->to_string($include_empty);
}

sub scan {
    my ($files, $inner_packages, $meta_prereqs, $prereq_types, $type, $optional_prereqs) = @_;

    my $prereqs = scan_files(@$files);

    # Remove internal packages.
    remove_prereqs($prereqs, +{ map { $_ => 1 } @$inner_packages });

    # Remove from meta
    for my $type (@$prereq_types) {
        remove_prereqs($prereqs, $meta_prereqs->{$type}->{requires});
        remove_prereqs($prereqs, $meta_prereqs->{$type}->{recommends});
    }

    # Runtime prereqs.
    if ($optional_prereqs) {
        remove_prereqs($prereqs, $optional_prereqs);
    }

    # Remove core modules.
    my $perl_version = $meta_prereqs->{perl} || '5.008001';
    remove_prereqs($prereqs, blead_corelist($perl_version));

    return $prereqs;
}

sub scan_inner_packages {
    my @files = @_;
    my %uniq;
    my @list;
    for my $file (@files) {
        push @list, grep { !$uniq{$_}++ } Module::Metadata->new_from_file($file)->packages_inside();
    }
    return @list;
}

sub scan_files {
    my @files = @_;

    my $combined = CPAN::Meta::Requirements->new;
    for my $file (@files) {
        debugf("Reading %s", $file);

        my $scanner = Perl::PrereqScanner::Lite->new;
        $scanner->add_extra_scanner('Moose');
        my $prereqs = $scanner->scan_file($file);
        $combined->add_requirements($prereqs);
    }
    my $prereqs = $combined->as_string_hash;
}

sub blead_corelist {
    my $perl_version = shift;
    my %corelist = %{$Module::CoreList::version{$perl_version}};
    for my $module (keys %corelist) {
        my $upstream = $Module::CoreList::upstream{$module};
        if ($upstream && $upstream eq 'cpan') {
            delete $corelist{$module};
        }
    }
    return \%corelist;
}

sub remove_prereqs {
    my ($prereqs, $allowed) = @_;
    return unless $allowed;

    for my $module (keys %$allowed) {
        if (exists $allowed->{$module}) {
            if (parse_version($allowed->{$module}) >= parse_version($prereqs->{$module})) {
                debugf("Core: %s %s >= %s", $module, $allowed->{$module}, $prereqs->{$module});
                delete $prereqs->{$module}
            }
        }
    }
}

sub parse_version {
    my $v = shift;
    return version->parse(0) unless defined $v;
    return version->parse(''.$v);
}

sub load_diff_src {
    my $src = shift;
    if (File::Basename::basename($src) eq 'cpanfile') {
        return Module::CPANfile->load($src)->prereq_specs;
    } elsif ($src =~ /\.(yml|json)$/) {
        my $meta = CPAN::Meta->load_file($src);
        my $meta_prereqs = CPAN::Meta::Prereqs->new($meta->prereqs)->as_string_hash;
        return $meta_prereqs;
    } else {
        die "No META.json and cpanfile\n";
    }
}

sub read_from_file {
    my ($fname, $length) = @_;
    return q{} if !-f $fname;
    open my $fh, '<', $fname
        or Carp::croak("Can't open '$fname' for reading: '$!'");
    my $buf;
    read $fh, $buf, $length;
    return $buf;
}

sub find_perl_files {
    my (@runtime_files, @test_files, @configure_files, @develop_files);
    find(
        {
            no_chdir => 1,
            wanted   => sub {
                return if $_ eq '.';
                return if -S $_; # Ignore UNIX socket

                # Ignore files.
                my (undef, $topdir, ) = File::Spec->splitdir($_);
                my $basename = File::Basename::basename($_);
                return if $basename eq 'Build';

                # Ignore build dir like Dist-Name-0.01/.
                return if -f "$topdir/META.json";

                for my $ignored (@ignore) {
                    return if $topdir eq $ignored;
                }

                if ($basename eq 'Build.PL' || $basename eq 'Makefile.PL') {
                    push @configure_files, $_
                } elsif ($topdir eq 't') {
                    if (/\.(pl|pm|psgi|t)$/) {
                        if ($basename =~ /^(?:author|release)-/) {
                            # dzil creates author test files to t/author-XXX.t
                            push @develop_files, $_
                        } else {
                            push @test_files, $_
                        }
                    }
                } elsif ($topdir eq 'xt' || $topdir eq 'author' || $topdir eq 'benchmark') {
                    if (/\.(pl|pm|psgi|t)$/) {
                        push @develop_files, $_
                    }
                } else {
                    if (/\.(pl|pm|psgi)$/) {
                        push @runtime_files, $_
                    } else {
                        my $header = read_from_file($_, 1024);
                        if ($header && $header =~ /^#!.*perl/) {
                            # Skip fatpacked file.
                            if ($header =~ /This chunk of stuff was generated by App::FatPacker./) {
                                debugf("fatpacked %s", $_);
                                return;
                            }

                            push @runtime_files, $_
                        }
                    }
                }
            }
        },
        '.'
    );
    return (\@runtime_files, \@test_files, \@configure_files, \@develop_files);
}

sub scan_test_requires {
    my $develop_prereqs = shift;

    require Test::Requires::Scanner;

    my @test_files;
    find(
        {
            no_chdir => 1,
            wanted   => sub {
                return if $_ eq '.';
                return if -S $_; # Ignore UNIX socket

                my (undef, $topdir, ) = File::Spec->splitdir($_);
                if (($topdir eq 'xt' || $topdir eq 't') && /\.t$/ ) {
                    push @test_files, $_
                }
            },
        },
        '.'
    );
    my $test_requires_prereqs = Test::Requires::Scanner->scan_files(@test_files);

    for my $module (keys %$test_requires_prereqs) {
        my $version = $test_requires_prereqs->{$module};

        if (! exists $develop_prereqs->{$module} ||
            parse_version($version) > parse_version($develop_prereqs->{$module})
        ) {
            $develop_prereqs->{$module} = $version || 0;
        }
    }

    return $develop_prereqs;
}

__END__

=head1 NAME

scan-prereqs-cpanfile - Scan prerequisite modules and generate CPANfile

=head1 SYNOPSIS

    % scan-prereqs-cpanfile

        --diff=META.json      # Generate diff from META.json
        --diff=cpanfile       # Generate diff from cpanfile
        --ignore=extlib/

=head1 DESCRIPTION

This script scans prerequisite modules from your code, and generate CPANfile.
You can also list missing prerequisite modules.

=head1 SCANNING RULES

=over 4

=item Used modules in `Build.PL` or `Makefile.PL` as 'test' requires

=item Used modules in `t/` as 'test' requires

=item Used modules in `xt/`, `benchmark/` and `author/` as 'develop' requires

=item Used modules in other directories as 'runtime' requires

=back

=head1 OPTIONS

=over 4

=item --diff

        --diff=META.json      # Generate diff from META.json
        --diff=cpanfile       # Generate diff from cpanfile

Compare the scanning result with META.json, META.yml or cpanfile.
With this option, scan-prereqs-cpanfile displays missing prerequisite modules only.

=item --ignore

    --ignore=tools/

Ignore some directories.

=item --include-empty

By default, phases without any prereqs are not dumped, By giving this option, cpanfile will have an empty block such as:

    on test => sub {

    };

Defaults to false.

=item --scan-test-requires (EXPERIMENTAL)

Scan test files and include the modules specified by L<Test::Requires> as 'develop' requires.

=back

=head1 AUTHOR

Tokuhiro Matsuno

=head1 SEE ALSO

L<Module::CPANfile>, L<Perl::PrereqScanner::Lite>

