#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Module/CPANfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE';
  package Module::CPANfile;
  use strict;
  use warnings;
  use Cwd;
  use Carp ();
  use Module::CPANfile::Environment;
  use Module::CPANfile::Requirement;
  
  our $VERSION = '1.1001';
  
  sub new {
      my($class, $file) = @_;
      bless {}, $class;
  }
  
  sub load {
      my($proto, $file) = @_;
  
      my $self = ref $proto ? $proto : $proto->new;
      $self->parse($file || Cwd::abs_path('cpanfile'));
      $self;
  }
  
  sub save {
      my($self, $path) = @_;
  
      open my $out, ">", $path or die "$path: $!";
      print {$out} $self->to_string;
  }
  
  sub parse {
      my($self, $file) = @_;
  
      my $code = do {
          open my $fh, "<", $file or die "$file: $!";
          join '', <$fh>;
      };
  
      my $env = Module::CPANfile::Environment->new($file);
      $env->parse($code) or die $@;
  
      $self->{_mirrors} = $env->mirrors;
      $self->{_prereqs} = $env->prereqs;
  }
  
  sub from_prereqs {
      my($proto, $prereqs) = @_;
  
      my $self = $proto->new;
      $self->{_prereqs} = Module::CPANfile::Prereqs->from_cpan_meta($prereqs);
  
      $self;
  }
  
  sub mirrors {
      my $self = shift;
      $self->{_mirrors} || [];
  }
  
  sub features {
      my $self = shift;
      map $self->feature($_), $self->{_prereqs}->identifiers;
  }
  
  sub feature {
      my($self, $identifier) = @_;
      $self->{_prereqs}->feature($identifier);
  }
  
  sub prereq { shift->prereqs }
  
  sub prereqs {
      my $self = shift;
      $self->{_prereqs}->as_cpan_meta;
  }
  
  sub merged_requirements {
      my $self = shift;
      $self->{_prereqs}->merged_requirements;
  }
  
  sub effective_prereqs {
      my($self, $features) = @_;
      $self->prereqs_with(@{$features || []});
  }
  
  sub prereqs_with {
      my($self, @feature_identifiers) = @_;
  
      my $prereqs = $self->prereqs;
      my @others = map { $self->feature($_)->prereqs } @feature_identifiers;
  
      $prereqs->with_merged_prereqs(\@others);
  }
  
  sub prereq_specs {
      my $self = shift;
      $self->prereqs->as_string_hash;
  }
  
  sub prereq_for_module {
      my($self, $module) = @_;
      $self->{_prereqs}->find($module);
  }
  
  sub options_for_module {
      my($self, $module) = @_;
      my $prereq = $self->prereq_for_module($module) or return;
      $prereq->requirement->options;
  }
  
  sub merge_meta {
      my($self, $file, $version) = @_;
  
      require CPAN::Meta;
  
      $version ||= $file =~ /\.yml$/ ? '1.4' : '2';
  
      my $prereq = $self->prereqs;
  
      my $meta = CPAN::Meta->load_file($file);
      my $prereqs_hash = $prereq->with_merged_prereqs($meta->effective_prereqs)->as_string_hash;
      my $struct = { %{$meta->as_struct}, prereqs => $prereqs_hash };
  
      CPAN::Meta->new($struct)->save($file, { version => $version });
  }
  
  sub _dump {
      my $str = shift;
      require Data::Dumper;
      chomp(my $value = Data::Dumper->new([$str])->Terse(1)->Dump);
      $value;
  }
  
  sub to_string {
      my($self, $include_empty) = @_;
  
      my $mirrors = $self->mirrors;
      my $prereqs = $self->prereq_specs;
  
      my $code = '';
      $code .= $self->_dump_mirrors($mirrors);
      $code .= $self->_dump_prereqs($prereqs, $include_empty);
  
      for my $feature ($self->features) {
          $code .= sprintf "feature %s, %s => sub {\n", _dump($feature->{identifier}), _dump($feature->{description});
          $code .= $self->_dump_prereqs($feature->{spec}, $include_empty, 4);
          $code .= "}\n\n";
      }
  
      $code =~ s/\n+$/\n/s;
      $code;
  }
  
  sub _dump_mirrors {
      my($self, $mirrors) = @_;
  
      my $code = "";
  
      for my $url (@$mirrors) {
          $code .= "mirror '$url';\n";
      }
  
      $code =~ s/\n+$/\n/s;
      $code;
  }
  
  sub _dump_prereqs {
      my($self, $prereqs, $include_empty, $base_indent) = @_;
  
      my $code = '';
      for my $phase (qw(runtime configure build test develop)) {
          my $indent = $phase eq 'runtime' ? '' : '    ';
          $indent = (' ' x ($base_indent || 0)) . $indent;
  
          my($phase_code, $requirements);
          $phase_code .= "on $phase => sub {\n" unless $phase eq 'runtime';
  
          for my $type (qw(requires recommends suggests conflicts)) {
              for my $mod (sort keys %{$prereqs->{$phase}{$type}}) {
                  my $ver = $prereqs->{$phase}{$type}{$mod};
                  $phase_code .= $ver eq '0'
                               ? "${indent}$type '$mod';\n"
                               : "${indent}$type '$mod', '$ver';\n";
                  $requirements++;
              }
          }
  
          $phase_code .= "\n" unless $requirements;
          $phase_code .= "};\n" unless $phase eq 'runtime';
  
          $code .= $phase_code . "\n" if $requirements or $include_empty;
      }
  
      $code =~ s/\n+$/\n/s;
      $code;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Module::CPANfile - Parse cpanfile
  
  =head1 SYNOPSIS
  
    use Module::CPANfile;
  
    my $file = Module::CPANfile->load("cpanfile");
    my $prereqs = $file->prereqs; # CPAN::Meta::Prereqs object
  
    my @features = $file->features; # CPAN::Meta::Feature objects
    my $merged_prereqs = $file->prereqs_with(@identifiers); # CPAN::Meta::Prereqs
  
    $file->merge_meta('MYMETA.json');
  
  =head1 DESCRIPTION
  
  Module::CPANfile is a tool to handle L<cpanfile> format to load application
  specific dependencies, not just for CPAN distributions.
  
  =head1 METHODS
  
  =over 4
  
  =item load
  
    $file = Module::CPANfile->load;
    $file = Module::CPANfile->load('cpanfile');
  
  Load and parse a cpanfile. By default it tries to load C<cpanfile> in
  the current directory, unless you pass the path to its argument.
  
  =item from_prereqs
  
    $file = Module::CPANfile->from_prereqs({
      runtime => { requires => { DBI => '1.000' } },
    });
  
  Creates a new Module::CPANfile object from prereqs hash you can get
  via L<CPAN::Meta>'s C<prereqs>, or L<CPAN::Meta::Prereqs>'
  C<as_string_hash>.
  
    # read MYMETA, then feed the prereqs to create Module::CPANfile
    my $meta = CPAN::Meta->load_file('MYMETA.json');
    my $file = Module::CPANfile->from_prereqs($meta->prereqs);
  
    # load cpanfile, then recreate it with round-trip
    my $file = Module::CPANfile->load('cpanfile');
    $file = Module::CPANfile->from_prereqs($file->prereq_specs);
                                      # or $file->prereqs->as_string_hash
  
  =item prereqs
  
  Returns L<CPAN::Meta::Prereqs> object out of the parsed cpanfile.
  
  =item prereq_specs
  
  Returns a hash reference that should be passed to C<< CPAN::Meta::Prereqs->new >>.
  
  =item features
  
  Returns a list of features available in the cpanfile as L<CPAN::Meta::Feature>.
  
  =item prereqs_with(@identifiers), effective_prereqs(\@identifiers)
  
  Returns L<CPAN::Meta::Prereqs> object, with merged prereqs for
  features identified with the C<@identifiers>.
  
  =item to_string($include_empty)
  
    $file->to_string;
    $file->to_string(1);
  
  Returns a canonical string (code) representation for cpanfile. Useful
  if you want to convert L<CPAN::Meta::Prereqs> to a new cpanfile.
  
    # read MYMETA's prereqs and print cpanfile representation of it
    my $meta = CPAN::Meta->load_file('MYMETA.json');
    my $file = Module::CPANfile->from_prereqs($meta->prereqs);
    print $file->to_string;
  
  By default, it omits the phase where there're no modules
  registered. If you pass the argument of a true value, it will print
  them as well.
  
  =item save
  
    $file->save('cpanfile');
  
  Saves the currently loaded prereqs as a new C<cpanfile> by calling
  C<to_string>. Beware B<this method will overwrite the existing
  cpanfile without any warning or backup>. Taking a backup or giving
  warnings to users is a caller's responsibility.
  
    # Read MYMETA.json and creates a new cpanfile
    my $meta = CPAN::Meta->load_file('MYMETA.json');
    my $file = Module::CPANfile->from_prereqs($meta->prereqs);
    $file->save('cpanfile');
  
  =item merge_meta
  
    $file->merge_meta('META.yml');
    $file->merge_meta('MYMETA.json', '2.0');
  
  Merge the effective prereqs with Meta specification loaded from the
  given META file, using CPAN::Meta. You can specify the META spec
  version in the second argument, which defaults to 1.4 in case the
  given file is YAML, and 2 if it is JSON.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<cpanfile>, L<CPAN::Meta>, L<CPAN::Meta::Spec>
  
  =cut
MODULE_CPANFILE

$fatpacked{"Module/CPANfile/Environment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_ENVIRONMENT';
  package Module::CPANfile::Environment;
  use strict;
  use warnings;
  use Module::CPANfile::Prereqs;
  use Carp ();
  
  my @bindings = qw(
      on requires recommends suggests conflicts
      feature
      osname
      mirror
      configure_requires build_requires test_requires author_requires
  );
  
  my $file_id = 1;
  
  sub new {
      my($class, $file) = @_;
      bless {
          file     => $file,
          phase    => 'runtime', # default phase
          feature  => undef,
          features => {},
          prereqs  => Module::CPANfile::Prereqs->new,
          mirrors  => [],
      }, $class;
  }
  
  sub bind {
      my $self = shift;
      my $pkg = caller;
  
      for my $binding (@bindings) {
          no strict 'refs';
          *{"$pkg\::$binding"} = sub { $self->$binding(@_) };
      }
  }
  
  sub parse {
      my($self, $code) = @_;
  
      my $err;
      {
          local $@;
          $file_id++;
          $self->_evaluate(<<EVAL);
  package Module::CPANfile::Sandbox$file_id;
  no warnings;
  BEGIN { \$_environment->bind }
  
  # line 1 "$self->{file}"
  $code;
  EVAL
          $err = $@;
      }
  
      if ($err) { die "Parsing $self->{file} failed: $err" };
  
      return 1;
  }
  
  sub _evaluate {
      my $_environment = $_[0];
      eval $_[1];
  }
  
  sub prereqs { $_[0]->{prereqs} }
  
  sub mirrors { $_[0]->{mirrors} }
  
  # DSL goes from here
  
  sub on {
      my($self, $phase, $code) = @_;
      local $self->{phase} = $phase;
      $code->();
  }
  
  sub feature {
      my($self, $identifier, $description, $code) = @_;
  
      # shortcut: feature identifier => sub { ... }
      if (@_ == 3 && ref($description) eq 'CODE') {
          $code = $description;
          $description = $identifier;
      }
  
      unless (ref $description eq '' && ref $code eq 'CODE') {
          Carp::croak("Usage: feature 'identifier', 'Description' => sub { ... }");
      }
  
      local $self->{feature} = $identifier;
      $self->prereqs->add_feature($identifier, $description);
  
      $code->();
  }
  
  sub osname { die "TODO" }
  
  sub mirror {
      my($self, $url) = @_;
      push @{$self->{mirrors}}, $url;
  }
  
  sub requirement_for {
      my($self, $module, @args) = @_;
  
      my $requirement = 0;
      $requirement = shift @args if @args % 2;
  
      return Module::CPANfile::Requirement->new(
          name    => $module,
          version => $requirement,
          @args,
      );
  }
  
  sub requires {
      my $self = shift;
      $self->add_prereq(requires => @_);
  }
  
  sub recommends {
      my $self = shift;
      $self->add_prereq(recommends => @_);
  }
  
  sub suggests {
      my $self = shift;
      $self->add_prereq(suggests => @_);
  }
  
  sub conflicts {
      my $self = shift;
      $self->add_prereq(conflicts => @_);
  }
  
  sub add_prereq {
      my($self, $type, $module, @args) = @_;
  
      $self->prereqs->add_prereq(
          feature => $self->{feature},
          phase   => $self->{phase},
          type    => $type,
          module  => $module,
          requirement => $self->requirement_for($module, @args),
      );
  }
  
  # Module::Install compatible shortcuts
  
  sub configure_requires {
      my($self, @args) = @_;
      $self->on(configure => sub { $self->requires(@args) });
  }
  
  sub build_requires {
      my($self, @args) = @_;
      $self->on(build => sub { $self->requires(@args) });
  }
  
  sub test_requires {
      my($self, @args) = @_;
      $self->on(test => sub { $self->requires(@args) });
  }
  
  sub author_requires {
      my($self, @args) = @_;
      $self->on(develop => sub { $self->requires(@args) });
  }
  
  1;
  
MODULE_CPANFILE_ENVIRONMENT

$fatpacked{"Module/CPANfile/Prereq.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_PREREQ';
  package Module::CPANfile::Prereq;
  use strict;
  
  sub new {
      my($class, %options) = @_;
      bless \%options, $class;
  }
  
  sub feature { $_[0]->{feature} }
  sub phase   { $_[0]->{phase} }
  sub type    { $_[0]->{type} }
  sub module  { $_[0]->{module} }
  sub requirement { $_[0]->{requirement} }
  
  sub match_feature {
      my($self, $identifier) = @_;
      no warnings 'uninitialized';
      $self->feature eq $identifier;
  }
  
  1;
MODULE_CPANFILE_PREREQ

$fatpacked{"Module/CPANfile/Prereqs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_PREREQS';
  package Module::CPANfile::Prereqs;
  use strict;
  use Carp ();
  use CPAN::Meta::Feature;
  use Module::CPANfile::Prereq;
  
  sub from_cpan_meta {
      my($class, $prereqs) = @_;
  
      my $self = $class->new;
  
      for my $phase (keys %$prereqs) {
          for my $type (keys %{ $prereqs->{$phase} }) {
              while (my($module, $requirement) = each %{ $prereqs->{$phase}{$type} }) {
                  $self->add_prereq(
                      phase => $phase,
                      type  => $type,
                      module => $module,
                      requirement => Module::CPANfile::Requirement->new(name => $module, version => $requirement),
                  );
              }
          }
      }
  
      $self;
  }
  
  sub new {
      my $class = shift;
      bless {
          prereqs => [],
          features => {},
      }, $class;
  }
  
  sub add_feature {
      my($self, $identifier, $description) = @_;
      $self->{features}{$identifier} = { description => $description };
  }
  
  sub add_prereq {
      my($self, %args) = @_;
      $self->add( Module::CPANfile::Prereq->new(%args) );
  }
  
  sub add {
      my($self, $prereq) = @_;
      push @{$self->{prereqs}}, $prereq;
  }
  
  sub as_cpan_meta {
      my $self = shift;
      $self->{cpanmeta} ||= $self->build_cpan_meta;
  }
  
  sub build_cpan_meta {
      my($self, $identifier) = @_;
  
      my $prereq_spec = {};
      $self->prereq_each($identifier, sub {
          my $prereq = shift;
          $prereq_spec->{$prereq->phase}{$prereq->type}{$prereq->module} = $prereq->requirement->version;
      });
  
      CPAN::Meta::Prereqs->new($prereq_spec);
  }
  
  sub prereq_each {
      my($self, $identifier, $code) = @_;
  
      for my $prereq (@{$self->{prereqs}}) {
          next unless $prereq->match_feature($identifier);
          $code->($prereq);
      }
  }
  
  sub merged_requirements {
      my $self = shift;
  
      my $reqs = CPAN::Meta::Requirements->new;
      for my $prereq (@{$self->{prereqs}}) {
          $reqs->add_string_requirement($prereq->module, $prereq->requirement->version);
      }
  
      $reqs;
  }
  
  sub find {
      my($self, $module) = @_;
  
      for my $prereq (@{$self->{prereqs}}) {
          return $prereq if $prereq->module eq $module;
      }
  
      return;
  }
  
  sub identifiers {
      my $self = shift;
      keys %{$self->{features}};
  }
  
  sub feature {
      my($self, $identifier) = @_;
  
      my $data = $self->{features}{$identifier}
        or Carp::croak("Unknown feature '$identifier'");
  
      my $prereqs = $self->build_cpan_meta($identifier);
  
      CPAN::Meta::Feature->new($identifier, {
          description => $data->{description},
          prereqs => $prereqs->as_string_hash,
      });
  }
  
  1;
MODULE_CPANFILE_PREREQS

$fatpacked{"Module/CPANfile/Requirement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_REQUIREMENT';
  package Module::CPANfile::Requirement;
  use strict;
  
  sub new {
      my ($class, %args) = @_;
  
      $args{version} ||= 0;
  
      bless +{
          name    => delete $args{name},
          version => delete $args{version},
          options => \%args,
      }, $class;
  }
  
  sub name    { $_[0]->{name} }
  sub version { $_[0]->{version} }
  
  sub options { $_[0]->{options} }
  
  sub has_options {
      keys %{$_[0]->{options}} > 0;
  }
  
  1;
MODULE_CPANFILE_REQUIREMENT

$fatpacked{"Module/Metadata.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_METADATA';
  # -*- mode: cperl; tab-width: 8; indent-tabs-mode: nil; basic-offset: 2 -*-
  # vim:ts=8:sw=2:et:sta:sts=2
  package Module::Metadata; # git description: v1.000026-12-g9b12bf1
  
  # Adapted from Perl-licensed code originally distributed with
  # Module-Build by Ken Williams
  
  # This module provides routines to gather information about
  # perl modules (assuming this may be expanded in the distant
  # parrot future to look at other types of modules).
  
  sub __clean_eval { eval $_[0] }
  use strict;
  use warnings;
  
  our $VERSION = '1.000027';
  
  use Carp qw/croak/;
  use File::Spec;
  BEGIN {
         # Try really hard to not depend ony any DynaLoaded module, such as IO::File or Fcntl
         eval {
                 require Fcntl; Fcntl->import('SEEK_SET'); 1;
         } or *SEEK_SET = sub { 0 }
  }
  use version 0.87;
  BEGIN {
    if ($INC{'Log/Contextual.pm'}) {
      require "Log/Contextual/WarnLogger.pm"; # Hide from AutoPrereqs
      Log::Contextual->import('log_info',
        '-default_logger' => Log::Contextual::WarnLogger->new({ env_prefix => 'MODULE_METADATA', }),
      );
    } else {
      *log_info = sub (&) { warn $_[0]->() };
    }
  }
  use File::Find qw(find);
  
  my $V_NUM_REGEXP = qr{v?[0-9._]+};  # crudely, a v-string or decimal
  
  my $PKG_FIRST_WORD_REGEXP = qr{ # the FIRST word in a package name
    [a-zA-Z_]                     # the first word CANNOT start with a digit
      (?:
        [\w']?                    # can contain letters, digits, _, or ticks
        \w                        # But, NO multi-ticks or trailing ticks
      )*
  }x;
  
  my $PKG_ADDL_WORD_REGEXP = qr{ # the 2nd+ word in a package name
    \w                           # the 2nd+ word CAN start with digits
      (?:
        [\w']?                   # and can contain letters or ticks
        \w                       # But, NO multi-ticks or trailing ticks
      )*
  }x;
  
  my $PKG_NAME_REGEXP = qr{ # match a package name
    (?: :: )?               # a pkg name can start with arisdottle
    $PKG_FIRST_WORD_REGEXP  # a package word
    (?:
      (?: :: )+             ### arisdottle (allow one or many times)
      $PKG_ADDL_WORD_REGEXP ### a package word
    )*                      # ^ zero, one or many times
    (?:
      ::                    # allow trailing arisdottle
    )?
  }x;
  
  my $PKG_REGEXP  = qr{   # match a package declaration
    ^[\s\{;]*             # intro chars on a line
    package               # the word 'package'
    \s+                   # whitespace
    ($PKG_NAME_REGEXP)    # a package name
    \s*                   # optional whitespace
    ($V_NUM_REGEXP)?        # optional version number
    \s*                   # optional whitesapce
    [;\{]                 # semicolon line terminator or block start (since 5.16)
  }x;
  
  my $VARNAME_REGEXP = qr{ # match fully-qualified VERSION name
    ([\$*])         # sigil - $ or *
    (
      (             # optional leading package name
        (?:::|\')?  # possibly starting like just :: (a la $::VERSION)
        (?:\w+(?:::|\'))*  # Foo::Bar:: ...
      )?
      VERSION
    )\b
  }x;
  
  my $VERS_REGEXP = qr{ # match a VERSION definition
    (?:
      \(\s*$VARNAME_REGEXP\s*\) # with parens
    |
      $VARNAME_REGEXP           # without parens
    )
    \s*
    =[^=~>]  # = but not ==, nor =~, nor =>
  }x;
  
  sub new_from_file {
    my $class    = shift;
    my $filename = File::Spec->rel2abs( shift );
  
    return undef unless defined( $filename ) && -f $filename;
    return $class->_init(undef, $filename, @_);
  }
  
  sub new_from_handle {
    my $class    = shift;
    my $handle   = shift;
    my $filename = shift;
    return undef unless defined($handle) && defined($filename);
    $filename = File::Spec->rel2abs( $filename );
  
    return $class->_init(undef, $filename, @_, handle => $handle);
  
  }
  
  
  sub new_from_module {
    my $class   = shift;
    my $module  = shift;
    my %props   = @_;
  
    $props{inc} ||= \@INC;
    my $filename = $class->find_module_by_name( $module, $props{inc} );
    return undef unless defined( $filename ) && -f $filename;
    return $class->_init($module, $filename, %props);
  }
  
  {
  
    my $compare_versions = sub {
      my ($v1, $op, $v2) = @_;
      $v1 = version->new($v1)
        unless UNIVERSAL::isa($v1,'version');
  
      my $eval_str = "\$v1 $op \$v2";
      my $result   = eval $eval_str;
      log_info { "error comparing versions: '$eval_str' $@" } if $@;
  
      return $result;
    };
  
    my $normalize_version = sub {
      my ($version) = @_;
      if ( $version =~ /[=<>!,]/ ) { # logic, not just version
        # take as is without modification
      }
      elsif ( ref $version eq 'version' ) { # version objects
        $version = $version->is_qv ? $version->normal : $version->stringify;
      }
      elsif ( $version =~ /^[^v][^.]*\.[^.]+\./ ) { # no leading v, multiple dots
        # normalize string tuples without "v": "1.2.3" -> "v1.2.3"
        $version = "v$version";
      }
      else {
        # leave alone
      }
      return $version;
    };
  
    # separate out some of the conflict resolution logic
  
    my $resolve_module_versions = sub {
      my $packages = shift;
  
      my( $file, $version );
      my $err = '';
        foreach my $p ( @$packages ) {
          if ( defined( $p->{version} ) ) {
            if ( defined( $version ) ) {
              if ( $compare_versions->( $version, '!=', $p->{version} ) ) {
                $err .= "  $p->{file} ($p->{version})\n";
              } else {
                # same version declared multiple times, ignore
              }
            } else {
              $file    = $p->{file};
              $version = $p->{version};
            }
          }
        $file ||= $p->{file} if defined( $p->{file} );
      }
  
      if ( $err ) {
        $err = "  $file ($version)\n" . $err;
      }
  
      my %result = (
        file    => $file,
        version => $version,
        err     => $err
      );
  
      return \%result;
    };
  
    sub provides {
      my $class = shift;
  
      croak "provides() requires key/value pairs \n" if @_ % 2;
      my %args = @_;
  
      croak "provides() takes only one of 'dir' or 'files'\n"
        if $args{dir} && $args{files};
  
      croak "provides() requires a 'version' argument"
        unless defined $args{version};
  
      croak "provides() does not support version '$args{version}' metadata"
          unless grep { $args{version} eq $_ } qw/1.4 2/;
  
      $args{prefix} = 'lib' unless defined $args{prefix};
  
      my $p;
      if ( $args{dir} ) {
        $p = $class->package_versions_from_directory($args{dir});
      }
      else {
        croak "provides() requires 'files' to be an array reference\n"
          unless ref $args{files} eq 'ARRAY';
        $p = $class->package_versions_from_directory($args{files});
      }
  
      # Now, fix up files with prefix
      if ( length $args{prefix} ) { # check in case disabled with q{}
        $args{prefix} =~ s{/$}{};
        for my $v ( values %$p ) {
          $v->{file} = "$args{prefix}/$v->{file}";
        }
      }
  
      return $p
    }
  
    sub package_versions_from_directory {
      my ( $class, $dir, $files ) = @_;
  
      my @files;
  
      if ( $files ) {
        @files = @$files;
      } else {
        find( {
          wanted => sub {
            push @files, $_ if -f $_ && /\.pm$/;
          },
          no_chdir => 1,
        }, $dir );
      }
  
      # First, we enumerate all packages & versions,
      # separating into primary & alternative candidates
      my( %prime, %alt );
      foreach my $file (@files) {
        my $mapped_filename = File::Spec::Unix->abs2rel( $file, $dir );
        my @path = split( /\//, $mapped_filename );
        (my $prime_package = join( '::', @path )) =~ s/\.pm$//;
  
        my $pm_info = $class->new_from_file( $file );
  
        foreach my $package ( $pm_info->packages_inside ) {
          next if $package eq 'main';  # main can appear numerous times, ignore
          next if $package eq 'DB';    # special debugging package, ignore
          next if grep /^_/, split( /::/, $package ); # private package, ignore
  
          my $version = $pm_info->version( $package );
  
          $prime_package = $package if lc($prime_package) eq lc($package);
          if ( $package eq $prime_package ) {
            if ( exists( $prime{$package} ) ) {
              croak "Unexpected conflict in '$package'; multiple versions found.\n";
            } else {
              $mapped_filename = "$package.pm" if lc("$package.pm") eq lc($mapped_filename);
              $prime{$package}{file} = $mapped_filename;
              $prime{$package}{version} = $version if defined( $version );
            }
          } else {
            push( @{$alt{$package}}, {
                                      file    => $mapped_filename,
                                      version => $version,
                                     } );
          }
        }
      }
  
      # Then we iterate over all the packages found above, identifying conflicts
      # and selecting the "best" candidate for recording the file & version
      # for each package.
      foreach my $package ( keys( %alt ) ) {
        my $result = $resolve_module_versions->( $alt{$package} );
  
        if ( exists( $prime{$package} ) ) { # primary package selected
  
          if ( $result->{err} ) {
          # Use the selected primary package, but there are conflicting
          # errors among multiple alternative packages that need to be
          # reported
            log_info {
              "Found conflicting versions for package '$package'\n" .
              "  $prime{$package}{file} ($prime{$package}{version})\n" .
              $result->{err}
            };
  
          } elsif ( defined( $result->{version} ) ) {
          # There is a primary package selected, and exactly one
          # alternative package
  
          if ( exists( $prime{$package}{version} ) &&
               defined( $prime{$package}{version} ) ) {
            # Unless the version of the primary package agrees with the
            # version of the alternative package, report a conflict
          if ( $compare_versions->(
                   $prime{$package}{version}, '!=', $result->{version}
                 )
               ) {
  
              log_info {
                "Found conflicting versions for package '$package'\n" .
                "  $prime{$package}{file} ($prime{$package}{version})\n" .
                "  $result->{file} ($result->{version})\n"
              };
            }
  
          } else {
            # The prime package selected has no version so, we choose to
            # use any alternative package that does have a version
            $prime{$package}{file}    = $result->{file};
            $prime{$package}{version} = $result->{version};
          }
  
          } else {
          # no alt package found with a version, but we have a prime
          # package so we use it whether it has a version or not
          }
  
        } else { # No primary package was selected, use the best alternative
  
          if ( $result->{err} ) {
            log_info {
              "Found conflicting versions for package '$package'\n" .
              $result->{err}
            };
          }
  
          # Despite possible conflicting versions, we choose to record
          # something rather than nothing
          $prime{$package}{file}    = $result->{file};
          $prime{$package}{version} = $result->{version}
            if defined( $result->{version} );
        }
      }
  
      # Normalize versions.  Can't use exists() here because of bug in YAML::Node.
      # XXX "bug in YAML::Node" comment seems irrelevant -- dagolden, 2009-05-18
      for (grep defined $_->{version}, values %prime) {
        $_->{version} = $normalize_version->( $_->{version} );
      }
  
      return \%prime;
    }
  }
  
  
  sub _init {
    my $class    = shift;
    my $module   = shift;
    my $filename = shift;
    my %props = @_;
  
    my $handle = delete $props{handle};
    my( %valid_props, @valid_props );
    @valid_props = qw( collect_pod inc );
    @valid_props{@valid_props} = delete( @props{@valid_props} );
    warn "Unknown properties: @{[keys %props]}\n" if scalar( %props );
  
    my %data = (
      module       => $module,
      filename     => $filename,
      version      => undef,
      packages     => [],
      versions     => {},
      pod          => {},
      pod_headings => [],
      collect_pod  => 0,
  
      %valid_props,
    );
  
    my $self = bless(\%data, $class);
  
    if ( not $handle ) {
      my $filename = $self->{filename};
      open $handle, '<', $filename
        or croak( "Can't open '$filename': $!" );
  
      $self->_handle_bom($handle, $filename);
    }
    $self->_parse_fh($handle);
  
    unless($self->{module} and length($self->{module})) {
      my ($v, $d, $f) = File::Spec->splitpath($self->{filename});
      if($f =~ /\.pm$/) {
        $f =~ s/\..+$//;
        my @candidates = grep /$f$/, @{$self->{packages}};
        $self->{module} = shift(@candidates); # punt
      }
      else {
        if(grep /main/, @{$self->{packages}}) {
          $self->{module} = 'main';
        }
        else {
          $self->{module} = $self->{packages}[0] || '';
        }
      }
    }
  
    $self->{version} = $self->{versions}{$self->{module}}
        if defined( $self->{module} );
  
    return $self;
  }
  
  # class method
  sub _do_find_module {
    my $class   = shift;
    my $module  = shift || croak 'find_module_by_name() requires a package name';
    my $dirs    = shift || \@INC;
  
    my $file = File::Spec->catfile(split( /::/, $module));
    foreach my $dir ( @$dirs ) {
      my $testfile = File::Spec->catfile($dir, $file);
      return [ File::Spec->rel2abs( $testfile ), $dir ]
        if -e $testfile and !-d _;  # For stuff like ExtUtils::xsubpp
      $testfile .= '.pm';
      return [ File::Spec->rel2abs( $testfile ), $dir ]
        if -e $testfile;
    }
    return;
  }
  
  # class method
  sub find_module_by_name {
    my $found = shift()->_do_find_module(@_) or return;
    return $found->[0];
  }
  
  # class method
  sub find_module_dir_by_name {
    my $found = shift()->_do_find_module(@_) or return;
    return $found->[1];
  }
  
  
  # given a line of perl code, attempt to parse it if it looks like a
  # $VERSION assignment, returning sigil, full name, & package name
  sub _parse_version_expression {
    my $self = shift;
    my $line = shift;
  
    my( $sigil, $variable_name, $package);
    if ( $line =~ /$VERS_REGEXP/o ) {
      ( $sigil, $variable_name, $package) = $2 ? ( $1, $2, $3 ) : ( $4, $5, $6 );
      if ( $package ) {
        $package = ($package eq '::') ? 'main' : $package;
        $package =~ s/::$//;
      }
    }
  
    return ( $sigil, $variable_name, $package );
  }
  
  # Look for a UTF-8/UTF-16BE/UTF-16LE BOM at the beginning of the stream.
  # If there's one, then skip it and set the :encoding layer appropriately.
  sub _handle_bom {
    my ($self, $fh, $filename) = @_;
  
    my $pos = tell $fh;
    return unless defined $pos;
  
    my $buf = ' ' x 2;
    my $count = read $fh, $buf, length $buf;
    return unless defined $count and $count >= 2;
  
    my $encoding;
    if ( $buf eq "\x{FE}\x{FF}" ) {
      $encoding = 'UTF-16BE';
    } elsif ( $buf eq "\x{FF}\x{FE}" ) {
      $encoding = 'UTF-16LE';
    } elsif ( $buf eq "\x{EF}\x{BB}" ) {
      $buf = ' ';
      $count = read $fh, $buf, length $buf;
      if ( defined $count and $count >= 1 and $buf eq "\x{BF}" ) {
        $encoding = 'UTF-8';
      }
    }
  
    if ( defined $encoding ) {
      if ( "$]" >= 5.008 ) {
        binmode( $fh, ":encoding($encoding)" );
      }
    } else {
      seek $fh, $pos, SEEK_SET
        or croak( sprintf "Can't reset position to the top of '$filename'" );
    }
  
    return $encoding;
  }
  
  sub _parse_fh {
    my ($self, $fh) = @_;
  
    my( $in_pod, $seen_end, $need_vers ) = ( 0, 0, 0 );
    my( @packages, %vers, %pod, @pod );
    my $package = 'main';
    my $pod_sect = '';
    my $pod_data = '';
    my $in_end = 0;
  
    while (defined( my $line = <$fh> )) {
      my $line_num = $.;
  
      chomp( $line );
  
      # From toke.c : any line that begins by "=X", where X is an alphabetic
      # character, introduces a POD segment.
      my $is_cut;
      if ( $line =~ /^=([a-zA-Z].*)/ ) {
        my $cmd = $1;
        # Then it goes back to Perl code for "=cutX" where X is a non-alphabetic
        # character (which includes the newline, but here we chomped it away).
        $is_cut = $cmd =~ /^cut(?:[^a-zA-Z]|$)/;
        $in_pod = !$is_cut;
      }
  
      if ( $in_pod ) {
  
        if ( $line =~ /^=head[1-4]\s+(.+)\s*$/ ) {
          push( @pod, $1 );
          if ( $self->{collect_pod} && length( $pod_data ) ) {
            $pod{$pod_sect} = $pod_data;
            $pod_data = '';
          }
          $pod_sect = $1;
  
        } elsif ( $self->{collect_pod} ) {
          $pod_data .= "$line\n";
  
        }
  
      } elsif ( $is_cut ) {
  
        if ( $self->{collect_pod} && length( $pod_data ) ) {
          $pod{$pod_sect} = $pod_data;
          $pod_data = '';
        }
        $pod_sect = '';
  
      } else {
  
        # Skip after __END__
        next if $in_end;
  
        # Skip comments in code
        next if $line =~ /^\s*#/;
  
        # Would be nice if we could also check $in_string or something too
        if ($line eq '__END__') {
          $in_end++;
          next;
        }
        last if $line eq '__DATA__';
  
        # parse $line to see if it's a $VERSION declaration
        my( $version_sigil, $version_fullname, $version_package ) =
            index($line, 'VERSION') >= 1
                ? $self->_parse_version_expression( $line )
                : ();
  
        if ( $line =~ /$PKG_REGEXP/o ) {
          $package = $1;
          my $version = $2;
          push( @packages, $package ) unless grep( $package eq $_, @packages );
          $need_vers = defined $version ? 0 : 1;
  
          if ( not exists $vers{$package} and defined $version ){
            # Upgrade to a version object.
            my $dwim_version = eval { _dwim_version($version) };
            croak "Version '$version' from $self->{filename} does not appear to be valid:\n$line\n\nThe fatal error was: $@\n"
                unless defined $dwim_version;  # "0" is OK!
            $vers{$package} = $dwim_version;
          }
  
        # VERSION defined with full package spec, i.e. $Module::VERSION
        } elsif ( $version_fullname && $version_package ) {
          push( @packages, $version_package ) unless grep( $version_package eq $_, @packages );
          $need_vers = 0 if $version_package eq $package;
  
          unless ( defined $vers{$version_package} && length $vers{$version_package} ) {
          $vers{$version_package} = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
        }
  
        # first non-comment line in undeclared package main is VERSION
        } elsif ( $package eq 'main' && $version_fullname && !exists($vers{main}) ) {
          $need_vers = 0;
          my $v = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
          $vers{$package} = $v;
          push( @packages, 'main' );
  
        # first non-comment line in undeclared package defines package main
        } elsif ( $package eq 'main' && !exists($vers{main}) && $line =~ /\w/ ) {
          $need_vers = 1;
          $vers{main} = '';
          push( @packages, 'main' );
  
        # only keep if this is the first $VERSION seen
        } elsif ( $version_fullname && $need_vers ) {
          $need_vers = 0;
          my $v = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
  
          unless ( defined $vers{$package} && length $vers{$package} ) {
            $vers{$package} = $v;
          }
        }
      }
    }
  
    if ( $self->{collect_pod} && length($pod_data) ) {
      $pod{$pod_sect} = $pod_data;
    }
  
    $self->{versions} = \%vers;
    $self->{packages} = \@packages;
    $self->{pod} = \%pod;
    $self->{pod_headings} = \@pod;
  }
  
  {
  my $pn = 0;
  sub _evaluate_version_line {
    my $self = shift;
    my( $sigil, $variable_name, $line ) = @_;
  
    # We compile into a local sub because 'use version' would cause
    # compiletime/runtime issues with local()
    $pn++; # everybody gets their own package
    my $eval = qq{ my \$dummy = q#  Hide from _packages_inside()
      #; package Module::Metadata::_version::p${pn};
      use version;
      sub {
        local $sigil$variable_name;
        $line;
        \$$variable_name
      };
    };
  
    $eval = $1 if $eval =~ m{^(.+)}s;
  
    local $^W;
    # Try to get the $VERSION
    my $vsub = __clean_eval($eval);
    # some modules say $VERSION <equal sign> $Foo::Bar::VERSION, but Foo::Bar isn't
    # installed, so we need to hunt in ./lib for it
    if ( $@ =~ /Can't locate/ && -d 'lib' ) {
      local @INC = ('lib',@INC);
      $vsub = __clean_eval($eval);
    }
    warn "Error evaling version line '$eval' in $self->{filename}: $@\n"
      if $@;
  
    (ref($vsub) eq 'CODE') or
      croak "failed to build version sub for $self->{filename}";
  
    my $result = eval { $vsub->() };
    # FIXME: $eval is not the right thing to print here
    croak "Could not get version from $self->{filename} by executing:\n$eval\n\nThe fatal error was: $@\n"
      if $@;
  
    # Upgrade it into a version object
    my $version = eval { _dwim_version($result) };
  
    # FIXME: $eval is not the right thing to print here
    croak "Version '$result' from $self->{filename} does not appear to be valid:\n$eval\n\nThe fatal error was: $@\n"
      unless defined $version; # "0" is OK!
  
    return $version;
  }
  }
  
  # Try to DWIM when things fail the lax version test in obvious ways
  {
    my @version_prep = (
      # Best case, it just works
      sub { return shift },
  
      # If we still don't have a version, try stripping any
      # trailing junk that is prohibited by lax rules
      sub {
        my $v = shift;
        $v =~ s{([0-9])[a-z-].*$}{$1}i; # 1.23-alpha or 1.23b
        return $v;
      },
  
      # Activestate apparently creates custom versions like '1.23_45_01', which
      # cause version.pm to think it's an invalid alpha.  So check for that
      # and strip them
      sub {
        my $v = shift;
        my $num_dots = () = $v =~ m{(\.)}g;
        my $num_unders = () = $v =~ m{(_)}g;
        my $leading_v = substr($v,0,1) eq 'v';
        if ( ! $leading_v && $num_dots < 2 && $num_unders > 1 ) {
          $v =~ s{_}{}g;
          $num_unders = () = $v =~ m{(_)}g;
        }
        return $v;
      },
  
      # Worst case, try numifying it like we would have before version objects
      sub {
        my $v = shift;
        no warnings 'numeric';
        return 0 + $v;
      },
  
    );
  
    sub _dwim_version {
      my ($result) = shift;
  
      return $result if ref($result) eq 'version';
  
      my ($version, $error);
      for my $f (@version_prep) {
        $result = $f->($result);
        $version = eval { version->new($result) };
        $error ||= $@ if $@; # capture first failure
        last if defined $version;
      }
  
      croak $error unless defined $version;
  
      return $version;
    }
  }
  
  ############################################################
  
  # accessors
  sub name            { $_[0]->{module}            }
  
  sub filename        { $_[0]->{filename}          }
  sub packages_inside { @{$_[0]->{packages}}       }
  sub pod_inside      { @{$_[0]->{pod_headings}}   }
  sub contains_pod    { 0+@{$_[0]->{pod_headings}} }
  
  sub version {
      my $self = shift;
      my $mod  = shift || $self->{module};
      my $vers;
      if ( defined( $mod ) && length( $mod ) &&
           exists( $self->{versions}{$mod} ) ) {
          return $self->{versions}{$mod};
      } else {
          return undef;
      }
  }
  
  sub pod {
      my $self = shift;
      my $sect = shift;
      if ( defined( $sect ) && length( $sect ) &&
           exists( $self->{pod}{$sect} ) ) {
          return $self->{pod}{$sect};
      } else {
          return undef;
      }
  }
  
  sub is_indexable {
    my ($self, $package) = @_;
  
    my @indexable_packages = grep { $_ ne 'main' } $self->packages_inside;
  
    # check for specific package, if provided
    return !! grep { $_ eq $package } @indexable_packages if $package;
  
    # otherwise, check for any indexable packages at all
    return !! @indexable_packages;
  }
  
  1;
  
  =head1 NAME
  
  Module::Metadata - Gather package and POD information from perl module files
  
  =head1 SYNOPSIS
  
    use Module::Metadata;
  
    # information about a .pm file
    my $info = Module::Metadata->new_from_file( $file );
    my $version = $info->version;
  
    # CPAN META 'provides' field for .pm files in a directory
    my $provides = Module::Metadata->provides(
      dir => 'lib', version => 2
    );
  
  =head1 DESCRIPTION
  
  This module provides a standard way to gather metadata about a .pm file through
  (mostly) static analysis and (some) code execution.  When determining the
  version of a module, the C<$VERSION> assignment is C<eval>ed, as is traditional
  in the CPAN toolchain.
  
  =head1 CLASS METHODS
  
  =head2 C<< new_from_file($filename, collect_pod => 1) >>
  
  Constructs a C<Module::Metadata> object given the path to a file.  Returns
  undef if the filename does not exist.
  
  C<collect_pod> is a optional boolean argument that determines whether POD
  data is collected and stored for reference.  POD data is not collected by
  default.  POD headings are always collected.
  
  If the file begins by an UTF-8, UTF-16BE or UTF-16LE byte-order mark, then
  it is skipped before processing, and the content of the file is also decoded
  appropriately starting from perl 5.8.
  
  =head2 C<< new_from_handle($handle, $filename, collect_pod => 1) >>
  
  This works just like C<new_from_file>, except that a handle can be provided
  as the first argument.
  
  Note that there is no validation to confirm that the handle is a handle or
  something that can act like one.  Passing something that isn't a handle will
  cause a exception when trying to read from it.  The C<filename> argument is
  mandatory or undef will be returned.
  
  You are responsible for setting the decoding layers on C<$handle> if
  required.
  
  =head2 C<< new_from_module($module, collect_pod => 1, inc => \@dirs) >>
  
  Constructs a C<Module::Metadata> object given a module or package name.
  Returns undef if the module cannot be found.
  
  In addition to accepting the C<collect_pod> argument as described above,
  this method accepts a C<inc> argument which is a reference to an array of
  directories to search for the module.  If none are given, the default is
  @INC.
  
  If the file that contains the module begins by an UTF-8, UTF-16BE or
  UTF-16LE byte-order mark, then it is skipped before processing, and the
  content of the file is also decoded appropriately starting from perl 5.8.
  
  =head2 C<< find_module_by_name($module, \@dirs) >>
  
  Returns the path to a module given the module or package name. A list
  of directories can be passed in as an optional parameter, otherwise
  @INC is searched.
  
  Can be called as either an object or a class method.
  
  =head2 C<< find_module_dir_by_name($module, \@dirs) >>
  
  Returns the entry in C<@dirs> (or C<@INC> by default) that contains
  the module C<$module>. A list of directories can be passed in as an
  optional parameter, otherwise @INC is searched.
  
  Can be called as either an object or a class method.
  
  =head2 C<< provides( %options ) >>
  
  This is a convenience wrapper around C<package_versions_from_directory>
  to generate a CPAN META C<provides> data structure.  It takes key/value
  pairs.  Valid option keys include:
  
  =over
  
  =item version B<(required)>
  
  Specifies which version of the L<CPAN::Meta::Spec> should be used as
  the format of the C<provides> output.  Currently only '1.4' and '2'
  are supported (and their format is identical).  This may change in
  the future as the definition of C<provides> changes.
  
  The C<version> option is required.  If it is omitted or if
  an unsupported version is given, then C<provides> will throw an error.
  
  =item dir
  
  Directory to search recursively for F<.pm> files.  May not be specified with
  C<files>.
  
  =item files
  
  Array reference of files to examine.  May not be specified with C<dir>.
  
  =item prefix
  
  String to prepend to the C<file> field of the resulting output. This defaults
  to F<lib>, which is the common case for most CPAN distributions with their
  F<.pm> files in F<lib>.  This option ensures the META information has the
  correct relative path even when the C<dir> or C<files> arguments are
  absolute or have relative paths from a location other than the distribution
  root.
  
  =back
  
  For example, given C<dir> of 'lib' and C<prefix> of 'lib', the return value
  is a hashref of the form:
  
    {
      'Package::Name' => {
        version => '0.123',
        file => 'lib/Package/Name.pm'
      },
      'OtherPackage::Name' => ...
    }
  
  =head2 C<< package_versions_from_directory($dir, \@files?) >>
  
  Scans C<$dir> for .pm files (unless C<@files> is given, in which case looks
  for those files in C<$dir> - and reads each file for packages and versions,
  returning a hashref of the form:
  
    {
      'Package::Name' => {
        version => '0.123',
        file => 'Package/Name.pm'
      },
      'OtherPackage::Name' => ...
    }
  
  The C<DB> and C<main> packages are always omitted, as are any "private"
  packages that have leading underscores in the namespace (e.g.
  C<Foo::_private>)
  
  Note that the file path is relative to C<$dir> if that is specified.
  This B<must not> be used directly for CPAN META C<provides>.  See
  the C<provides> method instead.
  
  =head2 C<< log_info (internal) >>
  
  Used internally to perform logging; imported from Log::Contextual if
  Log::Contextual has already been loaded, otherwise simply calls warn.
  
  =head1 OBJECT METHODS
  
  =head2 C<< name() >>
  
  Returns the name of the package represented by this module. If there
  is more than one package, it makes a best guess based on the
  filename. If it's a script (i.e. not a *.pm) the package name is
  'main'.
  
  =head2 C<< version($package) >>
  
  Returns the version as defined by the $VERSION variable for the
  package as returned by the C<name> method if no arguments are
  given. If given the name of a package it will attempt to return the
  version of that package if it is specified in the file.
  
  =head2 C<< filename() >>
  
  Returns the absolute path to the file.
  Note that this file may not actually exist on disk yet, e.g. if the module was read from an in-memory filehandle.
  
  =head2 C<< packages_inside() >>
  
  Returns a list of packages. Note: this is a raw list of packages
  discovered (or assumed, in the case of C<main>).  It is not
  filtered for C<DB>, C<main> or private packages the way the
  C<provides> method does.  Invalid package names are not returned,
  for example "Foo:Bar".  Strange but valid package names are
  returned, for example "Foo::Bar::", and are left up to the caller
  on how to handle.
  
  =head2 C<< pod_inside() >>
  
  Returns a list of POD sections.
  
  =head2 C<< contains_pod() >>
  
  Returns true if there is any POD in the file.
  
  =head2 C<< pod($section) >>
  
  Returns the POD data in the given section.
  
  =head2 C<< is_indexable($package) >> or C<< is_indexable() >>
  
  Returns a boolean indicating whether the package (if provided) or any package
  (otherwise) is eligible for indexing by PAUSE, the Perl Authors Upload Server.
  Note This only checks for valid C<package> declarations, and does not take any
  ownership information into account.
  
  =head1 AUTHOR
  
  Original code from Module::Build::ModuleInfo by Ken Williams
  <kwilliams@cpan.org>, Randy W. Sims <RandyS@ThePierianSpring.org>
  
  Released as Module::Metadata by Matt S Trout (mst) <mst@shadowcat.co.uk> with
  assistance from David Golden (xdg) <dagolden@cpan.org>.
  
  =head1 COPYRIGHT & LICENSE
  
  Original code Copyright (c) 2001-2011 Ken Williams.
  Additional code Copyright (c) 2010-2011 Matt Trout and David Golden.
  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
MODULE_METADATA

$fatpacked{"Perl/PrereqScanner/Lite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_PREREQSCANNER_LITE';
  package Perl::PrereqScanner::Lite;
  use 5.008005;
  use strict;
  use warnings;
  use Carp ();
  use Compiler::Lexer;
  use CPAN::Meta::Requirements;
  use Perl::PrereqScanner::Lite::Constants;
  
  our $VERSION = "0.26";
  
  sub new {
      my ($class, $opt) = @_;
  
      my $lexer;
      if ($opt->{no_prereq}) {
          $lexer = Compiler::Lexer->new({verbose => 1}),
      }
      else {
          $lexer = Compiler::Lexer->new(),
      }
  
      my $extra_scanners = [];
      if (my $scanner_names = $opt->{extra_scanners}) {
          if (ref $scanner_names eq 'ARRAY') {
              for my $scanner_name (@$scanner_names) {
                  my $extra_scanner;
                  if (substr($scanner_name, 0, 1) eq '+') {
                      $extra_scanner = substr $scanner_name, 1;
                  }
                  else {
                      $extra_scanner = "Perl::PrereqScanner::Lite::Scanner::$scanner_name";
                  }
  
                  eval "require $extra_scanner"; ## no critic
                  push @$extra_scanners, $extra_scanner;
              }
          } else {
              Carp::croak "'extra_scanners' option must be array reference";
          }
      }
  
      bless {
          lexer          => $lexer,
          extra_scanners => $extra_scanners,
          module_reqs    => CPAN::Meta::Requirements->new,
      }, $class;
  }
  
  sub add_extra_scanner {
      my ($self, $scanner_name) = @_;
  
      my $extra_scanner;
      if (substr($scanner_name, 0, 1) eq '+') {
          $extra_scanner = substr $scanner_name, 1;
      }
      else {
          $extra_scanner = "Perl::PrereqScanner::Lite::Scanner::$scanner_name";
      }
  
      eval "require $extra_scanner"; ## no critic
      push @{$self->{extra_scanners}}, $extra_scanner;
  }
  
  sub scan_string {
      my ($self, $string) = @_;
  
      my $tokens = $self->{lexer}->tokenize($string);
      $self->_scan($tokens);
  }
  
  sub scan_file {
      my ($self, $file) = @_;
  
      open my $fh, '<', $file or die "Cannot open file: $file";
      my $script = do { local $/; <$fh>; };
  
      $self->scan_string($script);
  }
  
  sub scan_tokens {
      my ($self, $tokens) = @_;
      $self->_scan($tokens);
  }
  
  sub scan_module {
      my ($self, $module) = @_;
  
      require Module::Path;
  
      if (defined(my $path = Module::Path::module_path($module))) {
          return $self->scan_file($path);
      }
  }
  
  sub _scan {
      my ($self, $tokens) = @_;
  
      my $module_name    = '';
      my $module_version = 0;
  
      my $not_decl_module_name = '';
  
      my $is_in_reglist   = 0;
      my $is_in_usedecl   = 0;
      my $is_in_reqdecl   = 0;
      my $is_inherited    = 0;
      my $is_in_list      = 0;
      my $is_version_decl = 0;
      my $is_aliased      = 0;
      my $is_prev_version = 0;
      my $is_prev_module_name = 0;
  
      my $does_garbage_exist = 0;
      my $does_use_lib_or_constant = 0;
  
      my $latest_prereq = '';
  
      TOP:
      for (my $i = 0; my $token = $tokens->[$i]; $i++) {
          my $token_type = $token->{type};
  
          # For require statement
          if ($token_type == REQUIRE_DECL || ($token_type == BUILTIN_FUNC && $token->{data} eq 'no')) {
              $is_in_reqdecl = 1;
              next;
          }
          if ($is_in_reqdecl) {
              # e.g.
              #   require Foo;
              if ($token_type == REQUIRED_NAME || $token_type == KEY) {
                  $latest_prereq = $self->add_minimum($token->{data} => 0);
  
                  $is_in_reqdecl = 0;
                  next;
              }
  
              # e.g.
              #   require Foo::Bar;
              if ($token_type == NAMESPACE || $token_type == NAMESPACE_RESOLVER) {
                  $module_name .= $token->{data};
                  next;
              }
  
              # End of declare of require statement
              if ($token_type == SEMI_COLON) {
                  if ($module_name) {
                      $latest_prereq = $self->add_minimum($module_name => 0);
                  }
  
                  $module_name   = '';
                  $is_in_reqdecl = 0;
                  next;
              }
  
              next;
          }
  
          # For use statement
          if ($token_type == USE_DECL) {
              $is_in_usedecl = 1;
              next;
          }
          if ($is_in_usedecl) {
              # e.g.
              #   use Foo;
              #   use parent qw/Foo/;
              #
              if ($token_type == USED_NAME || $token_type == IF_STMT) {
                  # XXX                       ~~~~~~~~~~~~~~~~~~~~~~
                  # Workaround for `use if` statement
                  # It is a matter of Compiler::Lexer (maybe).
                  #
                  #   use if $] < 5.009_005, 'MRO::Compat';
  
                  $module_name = $token->{data};
  
                  if ($module_name eq 'lib' || $module_name eq 'constant') {
                      $latest_prereq = $self->add_minimum($module_name, 0);
                      $does_use_lib_or_constant = 1;
                  }
                  elsif ($module_name =~ /(?:base|parent)/) {
                      $is_inherited = 1;
                  }
                  elsif ($module_name =~ 'aliased') {
                      $is_aliased = 1;
                  }
  
                  $is_prev_module_name = 1;
                  next;
              }
  
              # End of declare of use statement
              if ($token_type == SEMI_COLON || $token_type == LEFT_BRACE || $token_type == LEFT_BRACKET) {
                  if ($module_name && !$does_use_lib_or_constant) {
                      $latest_prereq = $self->add_minimum($module_name => $module_version);
                  }
  
                  $module_name    = '';
                  $module_version = 0;
                  $is_in_reglist  = 0;
                  $is_inherited   = 0;
                  $is_in_list     = 0;
                  $is_in_usedecl  = 0;
                  $is_aliased     = 0;
                  $does_garbage_exist  = 0;
                  $is_prev_module_name = 0;
                  $does_use_lib_or_constant = 0;
  
                  next;
              }
  
              # e.g.
              #   use Foo::Bar;
              if ($token_type == NAMESPACE || $token_type == NAMESPACE_RESOLVER) {
                  $module_name .= $token->{data};
                  $is_prev_module_name = 1;
                  next;
              }
  
              # Section for parent/base
              if ($is_inherited) {
                  # For qw() notation
                  # e.g.
                  #   use parent qw/Foo Bar/;
                  if ($token_type == REG_LIST) {
                      $is_in_reglist = 1;
                  }
                  elsif ($is_in_reglist) {
                      if ($token_type == REG_EXP) {
                          for my $_module_name (split /\s+/, $token->{data}) {
                              $latest_prereq = $self->add_minimum($_module_name => 0);
                          }
                          $is_in_reglist = 0;
                      }
                  }
  
                  # For simply list
                  # e.g.
                  #   use parent ('Foo' 'Bar');
                  elsif ($token_type == LEFT_PAREN) {
                      $is_in_list = 1;
                  }
                  elsif ($token_type == RIGHT_PAREN) {
                      $is_in_list = 0;
                  }
                  elsif ($is_in_list) {
                      if ($token_type == STRING || $token_type == RAW_STRING) {
                          $latest_prereq = $self->add_minimum($token->{data} => 0);
                      }
                  }
  
                  # For string
                  # e.g.
                  #   use parent "Foo"
                  elsif ($token_type == STRING || $token_type == RAW_STRING) {
                      $latest_prereq = $self->add_minimum($token->{data} => 0);
                  }
  
                  $is_prev_module_name = 0;
                  next;
              }
  
              if ($token_type == DOUBLE || $token_type == INT || $token_type == VERSION_STRING) {
                  if (!$module_name) {
                      if (!$does_garbage_exist) {
                          # For perl version
                          # e.g.
                          #   use 5.012;
                          my $perl_version = $token->{data};
                          $latest_prereq = $self->add_minimum('perl' => $perl_version);
                          $is_in_usedecl = 0;
                      }
                  }
                  elsif($is_prev_module_name) {
                      # For module version
                      # e.g.
                      #   use Foo::Bar 0.0.1;'
                      #   use Foo::Bar v0.0.1;
                      #   use Foo::Bar 0.0_1;
                      $module_version = $token->{data};
                  }
  
                  $is_prev_module_name = 0;
                  $is_prev_version = 1;
                  next;
              }
  
              if ($is_aliased) {
                  if ($token_type == STRING || $token_type == RAW_STRING) {
                      $latest_prereq = $self->add_minimum($token->{data} => 0);
                      $is_aliased = 0;
                  }
                  next;
              }
  
              if (($is_prev_module_name || $is_prev_version) && $token_type == LEFT_PAREN) {
                  my $left_paren_num = 1;
                  for ($i++; $token = $tokens->[$i]; $i++) { # skip content that is surrounded by parens
                      $token_type = $token->{type};
  
                      if ($token_type == LEFT_PAREN) {
                          $left_paren_num++;
                      }
                      elsif ($token_type == RIGHT_PAREN) {
                          last if --$left_paren_num <= 0;
                      }
                  }
                  next;
              }
  
              if ($token_type != WHITESPACE) {
                  $does_garbage_exist  = 1;
                  $is_prev_module_name = 0;
                  $is_prev_version = 0;
              }
              next;
          }
  
          for my $extra_scanner (@{$self->{extra_scanners}}) {
              if ($extra_scanner->scan($self, $token, $token_type)) {
                  next TOP;
              }
          }
  
          if ($token_type == COMMENT && $token->{data} =~ /\A##\s*no prereq\Z/) {
              $self->{module_reqs}->clear_requirement($latest_prereq);
              next;
          }
      }
  
      return $self->{module_reqs};
  }
  
  sub add_minimum {
      my ($self, $module_name, $module_version) = @_;
  
      if ($module_name) {
          $self->{module_reqs}->add_minimum($module_name => $module_version);
      }
  
      return $module_name;
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =for stopwords prepend reimplement
  
  =head1 NAME
  
  Perl::PrereqScanner::Lite - Lightweight Prereqs Scanner for Perl
  
  =head1 SYNOPSIS
  
      use Perl::PrereqScanner::Lite;
  
      my $scanner = Perl::PrereqScanner::Lite->new;
      $scanner->add_extra_scanner('Moose'); # add extra scanner for moose style
      my $modules = $scanner->scan_file('path/to/file');
  
  =head1 DESCRIPTION
  
  Perl::PrereqScanner::Lite is the lightweight prereqs scanner for perl.
  This scanner uses L<Compiler::Lexer> as tokenizer, therefore processing speed is really fast.
  
  =head1 METHODS
  
  =head2 new($opt)
  
  Create a scanner instance.
  
  C<$opt> must be hash reference. It accepts following keys of hash:
  
  =over 4
  
  =item * extra_scanners
  
  It specifies extra scanners. This item must be array reference.
  
  e.g.
  
      my $scanner = Perl::PrereqScanner::Lite->new(
          extra_scanners => [qw/Moose Version/]
      );
  
  See also L</add_extra_scanner($scanner_name)>.
  
  =item * no_prereq
  
  It specifies to use C<## no prereq> or not. Please see also L</ADDITIONAL NOTATION>.
  
  =back
  
  =head2 scan_file($file_path)
  
  Scan and figure out prereqs which is instance of C<CPAN::Meta::Requirements> by file path.
  
  =head2 scan_string($string)
  
  Scan and figure out prereqs which is instance of C<CPAN::Meta::Requirements> by source code string written in perl.
  
  e.g.
  
      open my $fh, '<', __FILE__;
      my $string = do { local $/; <$fh> };
      my $modules = $scanner->scan_string($string);
  
  =head2 scan_module($module_name)
  
  Scan and figure out prereqs which is instance of C<CPAN::Meta::Requirements> by module name.
  
  e.g.
  
      my $modules = $scanner->scan_module('Perl::PrereqScanner::Lite');
  
  =head2 scan_tokens($tokens)
  
  Scan and figure out prereqs which is instance of C<CPAN::Meta::Requirements> by tokens of L<Compiler::Lexer>.
  
  e.g.
  
      open my $fh, '<', __FILE__;
      my $string = do { local $/; <$fh> };
      my $tokens = Compiler::Lexer->new->tokenize($string);
      my $modules = $scanner->scan_tokens($tokens);
  
  =head2 add_extra_scanner($scanner_name)
  
  Add extra scanner to scan and figure out prereqs. This module loads extra scanner such as C<Perl::PrereqScanner::Lite::Scanner::$scanner_name> if specifying scanner name through this method.
  
  If you want to specify an extra scanner from external package without C<Perl::PrereqScanner::Lite::> prefix, you can prepend C<+> to C<$scanner_name>. Like so C<+Your::Awesome::Scanner>.
  
  Extra scanners that are default supported are followings;
  
  =over 8
  
  =item * L<Perl::PrereqScanner::Lite::Scanner::Moose>
  
  =item * L<Perl::PrereqScanner::Lite::Scanner::Version>
  
  =back
  
  =head1 ADDITIONAL NOTATION
  
  If C<no_prereq> is enabled by C<new()> (like so: C<Perl::PrereqScanner::Lite-E<gt>new({no_prereq =E<gt> 1})>),
  this module recognize C<## no prereq> optional comment. The requiring declaration with this comment on the same line will be ignored as prereq.
  
  For example
  
      use Foo;
      use Bar; ## no prereq
  
  In this case C<Foo> is the prereq, however C<Bar> is ignored.
  
  =head1 SPEED COMPARISON
  
  =head2 Plain
  
                                  Rate   Perl::PrereqScanner Perl::PrereqScanner::Lite
      Perl::PrereqScanner       8.57/s                    --                      -97%
      Perl::PrereqScanner::Lite  246/s                 2770%                        --
  
  =head2 With Moose scanner
  
                                  Rate   Perl::PrereqScanner Perl::PrereqScanner::Lite
      Perl::PrereqScanner       9.00/s                    --                      -94%
      Perl::PrereqScanner::Lite  152/s                 1587%                        --
  
  =head1 NOTES
  
  This is a quotation from L<https://github.com/moznion/Perl-PrereqScanner-Lite/issues/13>.
  
  =begin text
  
  The interface of an this module object suggests every scan_* call is not affected by any other, yet the code is storing the requirements in that object. This is quite surprising.
  
  I'd suggest that either it must change to be more functional-style, or this behavior should be clearly documented.
  
  =end text
  
  Yes, it's true. This design is so ugly and not smart.
  So I have to redesign and reimplement this module, and I have some plans.
  
  If you have a mind to expand this module by implementing external scanner,
  please be careful.
  Every C<scan_*> calls must not affect to any others through the
  singleton of this module (called it C<$c> in L<https://github.com/moznion/Perl-PrereqScanner-Lite/blob/c03638b2e2a39d92f4d7df360af5a6be65dc417a/lib/Perl/PrereqScanner/Lite/Scanner/Moose.pm#L8>).
  
  =head1 SEE ALSO
  
  L<Perl::PrereqScanner>, L<Compiler::Lexer>
  
  =head1 LICENSE
  
  Copyright (C) moznion.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  moznion E<lt>moznion@gmail.comE<gt>
  
  =cut
  
PERL_PREREQSCANNER_LITE

$fatpacked{"Perl/PrereqScanner/Lite/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_PREREQSCANNER_LITE_CONSTANTS';
  package Perl::PrereqScanner::Lite::Constants;
  use strict;
  use warnings;
  use utf8;
  use Compiler::Lexer::Constants;
  
  use parent qw(Exporter);
  
  our @EXPORT = qw(
      REQUIRE_DECL REQUIRED_NAME NAMESPACE_RESOLVER NAMESPACE
      SEMI_COLON USE_DECL USED_NAME REG_LIST REG_EXP LEFT_PAREN
      RIGHT_PAREN STRING RAW_STRING VERSION_STRING INT DOUBLE KEY
      METHOD WHITESPACE COMMENT LEFT_BRACE RIGHT_BRACE
      LEFT_BRACKET RIGHT_BRACKET BUILTIN_FUNC
      IF_STMT COMMA
  );
  
  use constant {
      REQUIRE_DECL       => Compiler::Lexer::TokenType::T_RequireDecl,
      REQUIRED_NAME      => Compiler::Lexer::TokenType::T_RequiredName,
      NAMESPACE_RESOLVER => Compiler::Lexer::TokenType::T_NamespaceResolver,
      NAMESPACE          => Compiler::Lexer::TokenType::T_Namespace,
      SEMI_COLON         => Compiler::Lexer::TokenType::T_SemiColon,
      USE_DECL           => Compiler::Lexer::TokenType::T_UseDecl,
      USED_NAME          => Compiler::Lexer::TokenType::T_UsedName,
      REG_LIST           => Compiler::Lexer::TokenType::T_RegList,
      REG_EXP            => Compiler::Lexer::TokenType::T_RegExp,
      STRING             => Compiler::Lexer::TokenType::T_String,
      RAW_STRING         => Compiler::Lexer::TokenType::T_RawString,
      VERSION_STRING     => Compiler::Lexer::TokenType::T_VersionString,
      INT                => Compiler::Lexer::TokenType::T_Int,
      DOUBLE             => Compiler::Lexer::TokenType::T_Double,
      KEY                => Compiler::Lexer::TokenType::T_Key,
      METHOD             => Compiler::Lexer::TokenType::T_Method,
      WHITESPACE         => Compiler::Lexer::TokenType::T_WhiteSpace,
      COMMENT            => Compiler::Lexer::TokenType::T_Comment,
      IF_STMT            => Compiler::Lexer::TokenType::T_IfStmt,
      COMMA              => Compiler::Lexer::TokenType::T_Comma,
  
      LEFT_PAREN   => Compiler::Lexer::TokenType::T_LeftParenthesis,
      RIGHT_PAREN  => Compiler::Lexer::TokenType::T_RightParenthesis,
      LEFT_BRACE   => Compiler::Lexer::TokenType::T_LeftBrace,
      RIGHT_BRACE   => Compiler::Lexer::TokenType::T_RightBrace,
      LEFT_BRACKET => Compiler::Lexer::TokenType::T_LeftBracket,
      RIGHT_BRACKET => Compiler::Lexer::TokenType::T_RightBracket,
  
      BUILTIN_FUNC => Compiler::Lexer::TokenType::T_BuiltinFunc,
  };
  
  1;
  
PERL_PREREQSCANNER_LITE_CONSTANTS

$fatpacked{"Perl/PrereqScanner/Lite/Scanner/Moose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_PREREQSCANNER_LITE_SCANNER_MOOSE';
  package Perl::PrereqScanner::Lite::Scanner::Moose;
  use strict;
  use warnings;
  use utf8;
  use Perl::PrereqScanner::Lite::Constants;
  
  sub scan {
      my ($class, $c, $token, $token_type) = @_;
  
      my $token_data = $token->data;
      if ($token_type == KEY && ($token_data eq 'extends' || $token_data eq 'with')) {
          $c->{is_in_moose_inherited} = 1;
          return 1;
      }
  
      if ($c->{is_in_moose_inherited}) {
          # to skip content which is is curly bracket -> { ... }
          {
              if ($token_type == LEFT_BRACE) {
                  $c->{is_in_moose_role_def} = 1;
                  return 1;
              }
  
              if ($token_type == RIGHT_BRACE) {
                  $c->{is_in_moose_role_def} = 0;
                  return 1;
              }
  
              if ($c->{is_in_moose_role_def}) {
                  return 1;
              }
          }
  
          # For qw() notation
          # e.g.
          #   extends qw/Foo Bar/;
          #   with qw/Foo Bar/;
          if ($token_type == REG_LIST) {
              $c->{is_in_moose_inherited_reglist} = 1;
              return 1;
          }
          if ($c->{is_in_moose_inherited_reglist} && !$c->{does_exist_moose_garbage}) {
              if ($token_type == REG_EXP) {
                  for my $_module_name (split /\s+/, $token_data) {
                      $c->add_minimum($_module_name => 0);
                  }
                  $c->{is_in_moose_inherited_reglist} = 0;
              }
              return 1;
          }
  
          # For simply list
          # e.g.
          #   extends ('Foo', 'Bar');
          #   with ('Foo', 'Bar');
          if ($token_type == LEFT_PAREN) {
              $c->{is_in_moose_inherited_list} = 1;
              return 1;
          }
          if ($token_type == RIGHT_PAREN) {
              $c->{is_in_moose_inherited_list} = 0;
              return 1;
          }
          if ($c->{is_in_moose_inherited_list}) {
              if (($token_type == STRING || $token_type == RAW_STRING) && !$c->{does_exist_moose_garbage}) {
                  $c->add_minimum($token_data => 0);
              }
              return 1;
          }
  
          # For string
          # e.g.
          #   extends "Foo"
          #   with "Foo"
          if ((($token_type == STRING || $token_type == RAW_STRING)) && !$c->{does_exist_moose_garbage}) {
              $c->add_minimum($token_data => 0);
              return 1;
          }
  
          # End of extends or with
          if ($token_type == SEMI_COLON) {
              $c->{is_in_moose_inherited}         = 0;
              $c->{is_in_moose_inherited_reglist} = 0;
              $c->{is_in_moose_inherited_list}    = 0;
              $c->{does_exist_moose_garbage}      = 0;
              return 1;
          }
  
          # For
          #   extends 'Class1', 'Class2';
          if ($token_type != COMMA) {
              $c->{does_exist_moose_garbage} = 1;
          }
  
          return 1;
      }
  
      return;
  }
  
  1;
  
  =encoding utf-8
  
  =head1 NAME
  
  Perl::PrereqScanner::Lite::Scanner::Moose - Extra Perl::PrereqScanner::Lite Scanner for Moose Family
  
  =head1 SYNOPSIS
  
      use Perl::PrereqScanner::Lite;
  
      my $scanner = Perl::PrereqScanner::Lite->new;
      $scanner->add_extra_scanner('Moose');
  
  =head1 DESCRIPTION
  
  Perl::PrereqScanner::Lite::Scanner::Moose is the extra scanner for Perl::PrereqScanner::Lite. This scanner supports C<extends> and C<with> notation for Moose family.
  
  =head1 LICENSE
  
  Copyright (C) moznion.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  moznion E<lt>moznion@gmail.comE<gt>
  
  =cut
  
PERL_PREREQSCANNER_LITE_SCANNER_MOOSE

$fatpacked{"Perl/PrereqScanner/Lite/Scanner/Version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_PREREQSCANNER_LITE_SCANNER_VERSION';
  package Perl::PrereqScanner::Lite::Scanner::Version;
  use strict;
  use warnings;
  use utf8;
  use Perl::PrereqScanner::Lite::Constants;
  
  sub scan {
      my ($class, $c, $token, $token_type) = @_;
  
      if ($token_type == KEY || $token_type == NAMESPACE || $token_type == NAMESPACE_RESOLVER) {
          $c->{not_decl_module_name} .= $token->{data};
          return 1;
      }
  
      if ($token_type == METHOD && $token->{data} eq 'VERSION') {
          $c->{is_version_decl} = 1;
          return 1;
      }
  
      if ($c->{is_version_decl} && $token_type == INT || $token_type == DOUBLE || $token_type == VERSION_STRING) {
          if ($c->{module_reqs}->{requirements}->{$c->{not_decl_module_name}}) {
              $c->add_minimum($c->{not_decl_module_name} => $token->{data});
          }
          $c->{is_version_decl} = 0;
          $c->{not_decl_module_name} = '';
          return 1;
      }
  
      if ($token_type == SEMI_COLON) {
          $c->{is_version_decl} = 0;
          $c->{not_decl_module_name} = '';
          return 1;
      }
  }
  
  1;
  
  =encoding utf-8
  
  =head1 NAME
  
  Perl::PrereqScanner::Lite::Scanner::Version - Extra Perl::PrereqScanner::Lite Scanner for VERSION method
  
  =head1 SYNOPSIS
  
      use Perl::PrereqScanner::Lite;
  
      my $scanner = Perl::PrereqScanner::Lite->new;
      $scanner->add_extra_scanner('Version');
  
  =head1 DESCRIPTION
  
  Perl::PrereqScanner::Lite::Scanner::Version is the extra scanner for Perl::PrereqScanner::Lite.
  This scanner supports C<VERSION> method. It retrieves version from the argument of C<VERSION>.
  
  For example,
  
      require Foo::Bar;
      Foo::Bar->VERSION(1.00);
  
  =head1 LICENSE
  
  Copyright (C) moznion.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  moznion E<lt>moznion@gmail.comE<gt>
  
  =cut
  
PERL_PREREQSCANNER_LITE_SCANNER_VERSION

$fatpacked{"darwin-2level/Compiler/Lexer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_COMPILER_LEXER';
  package Compiler::Lexer;
  use strict;
  use warnings;
  use 5.008_001;
  use File::Find;
  use Compiler::Lexer::Token;
  use Compiler::Lexer::Constants;
  
  require Exporter;
  our @ISA = qw(Exporter);
  our %EXPORT_TAGS = ( 'all' => [ qw() ] );
  our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );
  our @EXPORT = qw();
  our $VERSION = '0.22';
  require XSLoader;
  XSLoader::load(__PACKAGE__, $VERSION);
  
  my $inc;
  
  sub new {
      my ($class, $args) = @_;
      my $options = +{};
      if (ref $args eq 'HASH') {
          $options = $args;
      } elsif (ref $args eq 'SCALAR') {
          $options->{filename} = $args;
      }
      $options->{filename} ||= '-';
      $options->{verbose}  ||= 0;
      return $class->_new($options);
  }
  
  sub set_library_path {
      my ($self, $_inc) = @_;
      $inc = $_inc;
  }
  
  sub load_module {
      my ($self, $name) = @_;
      $name =~ s|::|/|g;
      my @include_path = ($inc) ? @$inc : @INC;
      my $module_path = '';
      foreach my $path (@include_path) {
          next unless -e $path;
          find(sub {
              return if ($module_path);
              my $absolute_path = $File::Find::name;
              if ($absolute_path =~ "$name.pm") {
                  $module_path = $absolute_path;
              }
          }, $path);
          last if ($module_path);
      }
      return undef unless $module_path;
      open my $fh, '<', $module_path;
      return do { local $/; <$fh> };
  }
  
  sub recursive_tokenize {
      my ($self, $script) = @_;
      my %results;
      $self->__recursive_tokenize(\%results, $script);
      $results{main} = $self->tokenize($script);
      return \%results;
  }
  
  sub __recursive_tokenize {
      my ($self, $results, $script) = @_;
      my $modules = $self->get_used_modules($script);
      foreach my $module (@$modules) {
          my $name = $module->{name};
          next if (defined $results->{$name});
          $results->{$name} ||= [];
          my $code = $self->load_module($name);
          next unless ($code);
          $results->{$name} = $self->tokenize($code);
          $self->__recursive_tokenize($results, $code);
      }
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Compiler::Lexer - Lexical Analyzer for Perl5
  
  =head1 SYNOPSIS
  
    use Compiler::Lexer;
    use Data::Dumper;
  
    my $filename = $ARGV[0];
    open my $fh, '<', $filename or die "Cannot open $filename: $!";
    my $script = do { local $/; <$fh> };
  
    my $lexer = Compiler::Lexer->new($filename);
    my $tokens = $lexer->tokenize($script);
    print Dumper $tokens;
  
    my $modules = $lexer->get_used_modules($script);
    print Dumper $modules;
  
  =head1 METHODS
  
  =over 4
  
  =item my $lexer = Compiler::Lexer->new($options);
  
  create new instance.
  You can create object from $options in hash reference.
  
  B<options list>
  
  =over 4
  
  =item filename
  
  =item verbose : includes token of Pod, Comment and WhiteSpace
  
  =back
  
  =item $lexer->tokenize($script);
  
  get token objects includes parameter of 'name' or 'type' or 'line' and so on.
  This method requires perl source code in string.
  
  =item $lexer->set_library_path(['path1', 'path2' ...])
  
  set libraries path for reading recursively. Default paths are @INC.
  
  =item $lexer->recursive_tokenize($script)
  
  get hash reference like { 'module_nameA' => [], 'module_nameB' => [] ... }.
  This method requires per source code in string.
  
  =item $lexer->get_used_modules($script);
  
  get names of used module.
  This method requires perl source code in string.
  
  =back
  
  =head1 AUTHOR
  
  Masaaki Goshima (goccy) E<lt>goccy(at)cpan.orgE<gt>
  
  =head1 CONTRIBUTORS
  
  tokuhirom: Tokuhiro Matsuno
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright (c) 2013, Masaaki Goshima (goccy). All rights reserved.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_COMPILER_LEXER

$fatpacked{"darwin-2level/Compiler/Lexer/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_COMPILER_LEXER_CONSTANTS';
  use strict;
  use warnings;
  
  package Compiler::Lexer::TokenType;
  use constant {
      T_Return => 0,
      T_Add => 1,
      T_Sub => 2,
      T_Mul => 3,
      T_Div => 4,
      T_Mod => 5,
      T_ThreeTermOperator => 6,
      T_Greater => 7,
      T_Less => 8,
      T_StringAdd => 9,
      T_Ref => 10,
      T_Glob => 11,
      T_BitNot => 12,
      T_BitOr => 13,
      T_AlphabetOr => 14,
      T_BitAnd => 15,
      T_AlphabetAnd => 16,
      T_BitXOr => 17,
      T_AlphabetXOr => 18,
      T_StringMul => 19,
      T_AddEqual => 20,
      T_SubEqual => 21,
      T_MulEqual => 22,
      T_DivEqual => 23,
      T_ModEqual => 24,
      T_StringAddEqual => 25,
      T_LeftShiftEqual => 26,
      T_RightShiftEqual => 27,
      T_StringMulEqual => 28,
      T_GreaterEqual => 29,
      T_LessEqual => 30,
      T_EqualEqual => 31,
      T_Diamond => 32,
      T_Compare => 33,
      T_PolymorphicCompare => 34,
      T_RegOK => 35,
      T_RegNot => 36,
      T_NotEqual => 37,
      T_StringLess => 38,
      T_StringLessEqual => 39,
      T_StringGreater => 40,
      T_StringGreaterEqual => 41,
      T_StringEqual => 42,
      T_StringNotEqual => 43,
      T_StringCompare => 44,
      T_Inc => 45,
      T_Dec => 46,
      T_Exp => 47,
      T_PowerEqual => 48,
      T_DefaultEqual => 49,
      T_LeftShift => 50,
      T_RightShift => 51,
      T_And => 52,
      T_Or => 53,
      T_AndBitEqual => 54,
      T_OrBitEqual => 55,
      T_NotBitEqual => 56,
      T_OrEqual => 57,
      T_AndEqual => 58,
      T_Slice => 59,
      T_DefaultOperator => 60,
      T_ToDo => 61,
      T_VarDecl => 62,
      T_FunctionDecl => 63,
      T_Method => 64,
      T_Assign => 65,
      T_ArraySize => 66,
      T_Is => 67,
      T_Not => 68,
      T_AlphabetNot => 69,
      T_BuiltinFunc => 70,
      T_RequireDecl => 71,
      T_Import => 72,
      T_SpecificKeyword => 73,
      T_DataWord => 74,
      T_ModWord => 75,
      T_AUTOLOAD => 76,
      T_CORE => 77,
      T_DESTROY => 78,
      T_STDIN => 79,
      T_STDOUT => 80,
      T_STDERR => 81,
      T_Redo => 82,
      T_Next => 83,
      T_Last => 84,
      T_Goto => 85,
      T_Continue => 86,
      T_Do => 87,
      T_Break => 88,
      T_Handle => 89,
      T_LocalDecl => 90,
      T_OurDecl => 91,
      T_StateDecl => 92,
      T_UseDecl => 93,
      T_UsedName => 94,
      T_RequiredName => 95,
      T_IfStmt => 96,
      T_ElseStmt => 97,
      T_ElsifStmt => 98,
      T_UnlessStmt => 99,
      T_UntilStmt => 100,
      T_WhenStmt => 101,
      T_GivenStmt => 102,
      T_DefaultStmt => 103,
      T_Comma => 104,
      T_Colon => 105,
      T_SemiColon => 106,
      T_LeftParenthesis => 107,
      T_RightParenthesis => 108,
      T_LeftBrace => 109,
      T_RightBrace => 110,
      T_LeftBracket => 111,
      T_RightBracket => 112,
      T_ArrayDereference => 113,
      T_HashDereference => 114,
      T_ScalarDereference => 115,
      T_CodeDereference => 116,
      T_ShortScalarDereference => 117,
      T_ShortArrayDereference => 118,
      T_ShortHashDereference => 119,
      T_ShortCodeDereference => 120,
      T_ArraySizeDereference => 121,
      T_Key => 122,
      T_BareWord => 123,
      T_Arrow => 124,
      T_Pointer => 125,
      T_NamespaceResolver => 126,
      T_Namespace => 127,
      T_Package => 128,
      T_Class => 129,
      T_CallDecl => 130,
      T_CodeRef => 131,
      T_WhileStmt => 132,
      T_ForStmt => 133,
      T_ForeachStmt => 134,
      T_Annotation => 135,
      T_ArgumentArray => 136,
      T_SpecificValue => 137,
      T_ConstValue => 138,
      T_ProgramArgument => 139,
      T_LibraryDirectories => 140,
      T_Environment => 141,
      T_Include => 142,
      T_Signal => 143,
      T_RegOpt => 144,
      T_RegQuote => 145,
      T_RegDoubleQuote => 146,
      T_RegList => 147,
      T_RegExec => 148,
      T_RegDecl => 149,
      T_RegMatch => 150,
      T_RegDelim => 151,
      T_HandleDelim => 152,
      T_RegMiddleDelim => 153,
      T_RegAllReplace => 154,
      T_RegReplace => 155,
      T_RegReplaceFrom => 156,
      T_RegReplaceTo => 157,
      T_FieldDecl => 158,
      T_TypeRef => 159,
      T_LabelRef => 160,
      T_LocalVarDecl => 161,
      T_GlobalVarDecl => 162,
      T_MultiLocalVarDecl => 163,
      T_MultiGlobalVarDecl => 164,
      T_Prototype => 165,
      T_Var => 166,
      T_CodeVar => 167,
      T_ArrayVar => 168,
      T_HashVar => 169,
      T_Int => 170,
      T_Double => 171,
      T_String => 172,
      T_RawString => 173,
      T_ExecString => 174,
      T_VersionString => 175,
      T_HereDocumentTag => 176,
      T_HereDocumentRawTag => 177,
      T_HereDocumentExecTag => 178,
      T_HereDocumentBareTag => 179,
      T_RawHereDocument => 180,
      T_HereDocument => 181,
      T_HereDocumentEnd => 182,
      T_FormatDecl => 183,
      T_Format => 184,
      T_FormatEnd => 185,
      T_Object => 186,
      T_RegExp => 187,
      T_Array => 188,
      T_Hash => 189,
      T_Operator => 190,
      T_LocalVar => 191,
      T_LocalArrayVar => 192,
      T_LocalHashVar => 193,
      T_GlobalVar => 194,
      T_GlobalArrayVar => 195,
      T_GlobalHashVar => 196,
      T_ArrayRef => 197,
      T_HashRef => 198,
      T_ArrayAt => 199,
      T_HashAt => 200,
      T_ArraySet => 201,
      T_HashSet => 202,
      T_Function => 203,
      T_Call => 204,
      T_Argument => 205,
      T_List => 206,
      T_Default => 207,
      T_Pod => 208,
      T_Comment => 209,
      T_WhiteSpace => 210,
      T_Undefined => 211,
      T_PostDeref => 212,
      T_PostDerefStar => 213,
      T_PostDerefArraySliceOpenBracket => 214,
      T_PostDerefArraySliceCloseBracket => 215,
      T_PostDerefHashSliceOpenBrace => 216,
      T_PostDerefHashSliceCloseBrace => 217,
      T_PostDerefCodeOpenParen => 218,
      T_PostDerefCodeCloseParen => 219
  };
  
  package Compiler::Lexer::SyntaxType;
  use constant {
      T_Value => 0,
      T_Term => 1,
      T_Expr => 2,
      T_Stmt => 3,
      T_BlockStmt => 4
  };
  
  package Compiler::Lexer::Kind;
  use constant {
      T_Return => 0,
      T_Operator => 1,
      T_Assign => 2,
      T_Decl => 3,
      T_Function => 4,
      T_SingleTerm => 5,
      T_Import => 6,
      T_SpecificKeyword => 7,
      T_DataWord => 8,
      T_ModWord => 9,
      T_AUTOLOAD => 10,
      T_CORE => 11,
      T_DESTROY => 12,
      T_Handle => 13,
      T_Control => 14,
      T_Do => 15,
      T_Module => 16,
      T_Stmt => 17,
      T_DefaultStmt => 18,
      T_Comma => 19,
      T_Colon => 20,
      T_StmtEnd => 21,
      T_Symbol => 22,
      T_Modifier => 23,
      T_Term => 24,
      T_Namespace => 25,
      T_Package => 26,
      T_Class => 27,
      T_Annotation => 28,
      T_RegOpt => 29,
      T_RegPrefix => 30,
      T_RegReplacePrefix => 31,
      T_Ref => 32,
      T_Get => 33,
      T_Set => 34,
      T_Verbose => 35,
      T_Undefined => 36
  };
  
  1;
DARWIN-2LEVEL_COMPILER_LEXER_CONSTANTS

$fatpacked{"darwin-2level/Compiler/Lexer/Token.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_COMPILER_LEXER_TOKEN';
  package Compiler::Lexer::Token;
  use strict;
  use warnings;
  
  my $FIELDS = [qw/
      stype
      type
      kind
      line
      name
      data
      has_warnings
  /];
  
  {
      no strict 'refs';
      foreach my $field (@$FIELDS) {
          *{__PACKAGE__ . '::' . $field} = sub {
              my ($self, $value) = @_;
              return $self->{$field} unless defined $value;
              $self->{$field} = $value;
          };
      }
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =for stopwords stype
  
  =head1 NAME
  
  Compiler::Lexer::Token
  
  =head1 SYNOPSIS
  
  Compiler::Lexer::Token includes the following members.
  
  =over
  
  =item stype
  
  constant of Compiler::Lexer::SyntaxType
  
  =item type
  
  constant of Compiler::Lexer::TokenType
  
  =item kind
  
  constant of Compiler::Lexer::Kind
  
  =item name
  
  name of Compiler::Lexer::TokenType
  
  =item data
  
  raw data
  
  =item has_warnings
  
  flag of whether unknown keyword or not
  
  =back
  
  =head1 METHODS
  
  support simple get/set accessors like Class::Accessor::Fast
  
  example:
  
    my $type = $token->type;                            # get accessor
    $token->type(Compiler::Lexer::TokenType::T_RegExp); # set accessor
  
  =head1 AUTHOR
  
  Masaaki Goshima (goccy) E<lt>goccy(at)cpan.orgE<gt>
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright (c) 2013, Masaaki Goshima (goccy). All rights reserved.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_COMPILER_LEXER_TOKEN

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/Users/gugod/perl5/perlbrew/perls/perl-5.22.0/bin/perl
use strict;
use warnings;
use utf8;
use 5.008001;

use version;
use CPAN::Meta;
use Getopt::Long;
use CPAN::Meta::Requirements ();
use File::Find qw(find);
use Module::CoreList;
use Module::CPANfile;
use File::Spec;
use File::Basename ();
use Module::Metadata;
use Perl::PrereqScanner::Lite;

our $VERSION = '1.03';

sub debugf {
    if ($ENV{SCAN_PREREQS_CPANFILE_DEBUG}) {
        require Data::Dumper;
        my $format = shift;
        no warnings 'once';
        local $Data::Dumper::Terse  = 1;
        local $Data::Dumper::Indent = 0;
        my $txt = sprintf($format, map { defined($_) ? Data::Dumper::Dumper($_) : '-' } @_);
        print $txt, "\n";
    }
}

my $version;
my $diff;
my $include_empty;
my $scan_test_requires;
my @ignore = qw(eg examples share fatlib _build .git blib local .build);
my $add_ignore;
my $p = Getopt::Long::Parser->new(
    config => [qw(posix_default no_ignore_case auto_help)]
);
$p->getoptions(
    'version!'       => \$version,
    'diff=s'         => \$diff,
    'ignore=s'       => \$add_ignore,
    'include-empty!' => \$include_empty,
    'scan-test-requires' => \$scan_test_requires,
);
push @ignore, split /,/,$add_ignore if $add_ignore;
if ($version) {
    printf "%s %s\n", File::Basename::basename($0), $VERSION;
    exit 0;
}

&main; exit;

sub main {
    my ($runtime_files, $test_files, $configure_files, $develop_files) = find_perl_files();
    debugf($develop_files);

    my @inner_packages = scan_inner_packages(@$test_files, @$runtime_files, @$configure_files, @$develop_files);
    my $meta_prereqs = $diff ? load_diff_src($diff) : +{};

    # runtime
    my $runtime_prereqs = scan($runtime_files, \@inner_packages, $meta_prereqs, [qw(runtime)], 'runtime', +{});

    # test
    my $test_prereqs = scan($test_files, \@inner_packages, $meta_prereqs, [qw(test runtime)], 'test', $runtime_prereqs);

    # configure
    my $configure_prereqs = scan($configure_files, \@inner_packages, $meta_prereqs, [qw(configure runtime)], 'configure', $runtime_prereqs);

    # develop
    my $develop_prereqs = scan($develop_files, \@inner_packages, $meta_prereqs, [qw(develop test runtime)], 'develop', +{ %{$runtime_prereqs||{}}, %{$test_prereqs||{}}});

    if ($scan_test_requires) {
        $develop_prereqs = scan_test_requires($develop_prereqs);
    }

    print Module::CPANfile->from_prereqs(
        {
            runtime => {
                requires => $runtime_prereqs,
            },
            configure => {
                requires => $configure_prereqs,
            },
            test => {
                requires => $test_prereqs,
            },
            develop => {
                requires => $develop_prereqs,
            },
        }
    )->to_string($include_empty);
}

sub scan {
    my ($files, $inner_packages, $meta_prereqs, $prereq_types, $type, $optional_prereqs) = @_;

    my $prereqs = scan_files(@$files);

    # Remove internal packages.
    remove_prereqs($prereqs, +{ map { $_ => 1 } @$inner_packages });

    # Remove from meta
    for my $type (@$prereq_types) {
        remove_prereqs($prereqs, $meta_prereqs->{$type}->{requires});
        remove_prereqs($prereqs, $meta_prereqs->{$type}->{recommends});
    }

    # Runtime prereqs.
    if ($optional_prereqs) {
        remove_prereqs($prereqs, $optional_prereqs);
    }

    # Remove core modules.
    my $perl_version = $meta_prereqs->{perl} || '5.008001';
    remove_prereqs($prereqs, blead_corelist($perl_version));

    return $prereqs;
}

sub scan_inner_packages {
    my @files = @_;
    my %uniq;
    my @list;
    for my $file (@files) {
        push @list, grep { !$uniq{$_}++ } Module::Metadata->new_from_file($file)->packages_inside();
    }
    return @list;
}

sub scan_files {
    my @files = @_;

    my $combined = CPAN::Meta::Requirements->new;
    for my $file (@files) {
        debugf("Reading %s", $file);

        my $scanner = Perl::PrereqScanner::Lite->new;
        $scanner->add_extra_scanner('Moose');
        my $prereqs = $scanner->scan_file($file);
        $combined->add_requirements($prereqs);
    }
    my $prereqs = $combined->as_string_hash;
}

sub blead_corelist {
    my $perl_version = shift;
    my %corelist = %{$Module::CoreList::version{$perl_version}};
    for my $module (keys %corelist) {
        my $upstream = $Module::CoreList::upstream{$module};
        if ($upstream && $upstream eq 'cpan') {
            delete $corelist{$module};
        }
    }
    return \%corelist;
}

sub remove_prereqs {
    my ($prereqs, $allowed) = @_;
    return unless $allowed;

    for my $module (keys %$allowed) {
        if (exists $allowed->{$module}) {
            if (parse_version($allowed->{$module}) >= parse_version($prereqs->{$module})) {
                debugf("Core: %s %s >= %s", $module, $allowed->{$module}, $prereqs->{$module});
                delete $prereqs->{$module}
            }
        }
    }
}

sub parse_version {
    my $v = shift;
    return version->parse(0) unless defined $v;
    return version->parse(''.$v);
}

sub load_diff_src {
    my $src = shift;
    if (File::Basename::basename($src) eq 'cpanfile') {
        return Module::CPANfile->load($src)->prereq_specs;
    } elsif ($src =~ /\.(yml|json)$/) {
        my $meta = CPAN::Meta->load_file($src);
        my $meta_prereqs = CPAN::Meta::Prereqs->new($meta->prereqs)->as_string_hash;
        return $meta_prereqs;
    } else {
        die "No META.json and cpanfile\n";
    }
}

sub read_from_file {
    my ($fname, $length) = @_;
    return q{} if !-f $fname;
    open my $fh, '<', $fname
        or Carp::croak("Can't open '$fname' for reading: '$!'");
    my $buf;
    read $fh, $buf, $length;
    return $buf;
}

sub find_perl_files {
    my (@runtime_files, @test_files, @configure_files, @develop_files);
    find(
        {
            no_chdir => 1,
            wanted   => sub {
                return if $_ eq '.';
                return if -S $_; # Ignore UNIX socket

                # Ignore files.
                my (undef, $topdir, ) = File::Spec->splitdir($_);
                my $basename = File::Basename::basename($_);
                return if $basename eq 'Build';

                # Ignore build dir like Dist-Name-0.01/.
                return if -f "$topdir/META.json";

                for my $ignored (@ignore) {
                    return if $topdir eq $ignored;
                }

                if ($basename eq 'Build.PL' || $basename eq 'Makefile.PL') {
                    push @configure_files, $_
                } elsif ($topdir eq 't') {
                    if (/\.(pl|pm|psgi|t)$/) {
                        if ($basename =~ /^(?:author|release)-/) {
                            # dzil creates author test files to t/author-XXX.t
                            push @develop_files, $_
                        } else {
                            push @test_files, $_
                        }
                    }
                } elsif ($topdir eq 'xt' || $topdir eq 'author' || $topdir eq 'benchmark') {
                    if (/\.(pl|pm|psgi|t)$/) {
                        push @develop_files, $_
                    }
                } else {
                    if (/\.(pl|pm|psgi)$/) {
                        push @runtime_files, $_
                    } else {
                        my $header = read_from_file($_, 1024);
                        if ($header && $header =~ /^#!.*perl/) {
                            # Skip fatpacked file.
                            if ($header =~ /This chunk of stuff was generated by App::FatPacker./) {
                                debugf("fatpacked %s", $_);
                                return;
                            }

                            push @runtime_files, $_
                        }
                    }
                }
            }
        },
        '.'
    );
    return (\@runtime_files, \@test_files, \@configure_files, \@develop_files);
}

sub scan_test_requires {
    my $develop_prereqs = shift;

    require Test::Requires::Scanner;

    my @test_files;
    find(
        {
            no_chdir => 1,
            wanted   => sub {
                return if $_ eq '.';
                return if -S $_; # Ignore UNIX socket

                my (undef, $topdir, ) = File::Spec->splitdir($_);
                if (($topdir eq 'xt' || $topdir eq 't') && /\.t$/ ) {
                    push @test_files, $_
                }
            },
        },
        '.'
    );
    my $test_requires_prereqs = Test::Requires::Scanner->scan_files(@test_files);

    for my $module (keys %$test_requires_prereqs) {
        my $version = $test_requires_prereqs->{$module};

        if (! exists $develop_prereqs->{$module} ||
            parse_version($version) > parse_version($develop_prereqs->{$module})
        ) {
            $develop_prereqs->{$module} = $version || 0;
        }
    }

    return $develop_prereqs;
}

__END__

=head1 NAME

scan-prereqs-cpanfile - Scan prerequisite modules and generate CPANfile

=head1 SYNOPSIS

    % scan-prereqs-cpanfile

        --diff=META.json      # Generate diff from META.json
        --diff=cpanfile       # Generate diff from cpanfile
        --ignore=extlib/

=head1 DESCRIPTION

This script scans prerequisite modules from your code, and generate CPANfile.
You can also list missing prerequisite modules.

=head1 SCANNING RULES

=over 4

=item Used modules in `Build.PL` or `Makefile.PL` as 'test' requires

=item Used modules in `t/` as 'test' requires

=item Used modules in `xt/`, `benchmark/` and `author/` as 'develop' requires

=item Used modules in other directories as 'runtime' requires

=back

=head1 OPTIONS

=over 4

=item --diff

        --diff=META.json      # Generate diff from META.json
        --diff=cpanfile       # Generate diff from cpanfile

Compare the scanning result with META.json, META.yml or cpanfile.
With this option, scan-prereqs-cpanfile displays missing prerequisite modules only.

=item --ignore

    --ignore=tools/

Ignore some directories.

=item --include-empty

By default, phases without any prereqs are not dumped, By giving this option, cpanfile will have an empty block such as:

    on test => sub {

    };

Defaults to false.

=item --scan-test-requires (EXPERIMENTAL)

Scan test files and include the modules specified by L<Test::Requires> as 'develop' requires.

=back

=head1 AUTHOR

Tokuhiro Matsuno

=head1 SEE ALSO

L<Module::CPANfile>, L<Perl::PrereqScanner::Lite>

