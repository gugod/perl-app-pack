#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/YG.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_YG';
  package App::YG;
  use strict;
  use warnings;
  use Carp qw/croak/;
  use Getopt::Long qw/GetOptionsFromArray/;
  use Pod::Usage;
  use IO::Interactive qw/is_interactive/;
  use Term::ANSIColor qw/colored/;
  
  our $VERSION = '0.063';
  
  our $CONFIG_FILE    = '.ygconfig';
  our $DEFAULT_PARSER = 'apache-combined';
  our $DIGEST_LENGTH = 6;
  our $DEFAULT_COLOR = +{
      label  => 'blue',
      colon  => 'cyan',
      value  => 'green',
      hr     => 'yellow',
      count  => 'red',
      digest => 'magenta',
  };
  
  use Class::Accessor::Lite (
      new => 1,
      rw  => [qw/
          config
          parse_class
          parse_func
          labels
          label_format
          count
          hr
      /],
  );
  
  sub run {
      my $self = shift;
      $self->pre(\@_)->loop;
  }
  
  sub loop {
      my $self = shift;
  
      $self->count(1);
      if ( !is_interactive() ) {
          while ( my $line = <STDIN> ) {
              $self->_out_put(\$line);
          }
      }
      elsif ( scalar @{ $self->config->{file} } ) {
          for my $file (@{$self->config->{file}}) {
              open my $fh, '<', $file or croak $!;
              while ( my $line = <$fh> ) {
                  $self->_out_put(\$line);
              }
              close $fh;
          }
      }
  
      return 1;
  }
  
  sub _out_put {
      my ($self, $line_ref) = @_;
  
      chomp ${$line_ref};
  
      if ( ( !$self->config->{match} && !$self->config->{regexp} )
              || ( $self->config->{match} && $self->_match($line_ref) )
                  || ( $self->config->{regexp} && $self->_regexp($line_ref) )
      ) {
          $self->__out($line_ref);
      }
      else {
          return;
      }
  }
  
  sub __out {
      my ($self, $line_ref) = @_;
  
      if ($self->config->{through}) {
          print "${$line_ref}\n";
          return;
      }
  
      if (!$self->config->{nohr}) {
          my $digest = '';
          if ($self->config->{digest}) {
              $digest = substr(Digest::SHA1::sha1_hex(${$line_ref}), 0, $DIGEST_LENGTH);
          }
          $self->_output_head($self->count, $digest);
      }
  
      $self->_output_raw($line_ref) if $self->config->{raw};
  
      if ($self->config->{ltsv}) {
          $self->_output_ltsv_line($line_ref);
      }
      elsif ( $self->config->{tab} || $self->config->{space} ) {
          $self->_output_splited_line($line_ref);
      }
      else {
          $self->_output_parsed_line($line_ref);
      }
  
      $self->count( $self->count() + 1 );
      return;
  }
  
  sub _match {
      my ($self, $line_ref) = @_;
  
      return 1 if index(${$line_ref}, $self->{config}->{match}) > -1;
  }
  
  sub _regexp {
      my ($self, $line_ref) = @_;
  
      if ($self->config->{ignore_case}) {
          return 1 if ${$line_ref} =~ m!$self->{config}->{regexp}!i;
      }
      else {
          return 1 if ${$line_ref} =~ m!$self->{config}->{regexp}!;
      }
  }
  
  sub _output_head {
      my ($self, $count, $digest) = @_;
  
      my $colon = $digest ? ': ' : '';
  
      if ($self->config->{color}) {
          print colored($self->hr.' ', $self->config->{_color}{hr});
          print colored($count, $self->config->{_color}{count});
          print colored($colon, $self->config->{_color}{colon});
          print colored($digest, $self->config->{_color}{digest});
          print colored(' '.$self->hr, $self->config->{_color}{hr});
          print "\n";
      }
      else {
          print $self->hr. " $count$colon$digest ". $self->hr. "\n";
      }
  }
  
  sub _output_raw {
      print "${$_[1]}\n";
  }
  
  sub _output_ltsv_line {
      my ($self, $line_ref) = @_;
  
      my $delimiter = "\t";
  
      my @cols = split $delimiter, ${$line_ref};
      my @labels;
      for my $col (@cols) {
          my ($label, $value) = split ':', $col;
          push @labels, $label;
      }
      my $lablel_width = _max_label_len(\@labels);
  
      for my $col (@cols) {
          my ($label, $value) = split ':', $col;
          $self->__output_line( sprintf("%${lablel_width}s", $label), $value );
      }
      print "\n";
  }
  
  sub _output_parsed_line {
      my ($self, $line_ref) = @_;
  
      my $logs;
      {
          no strict 'refs'; ## no critic
          $logs = &{ $self->parse_func }(${$line_ref});
      }
      if (@{$logs}) {
          my $i = 0;
          for my $label (@{$self->labels}) {
              $self->__output_line( sprintf($self->label_format, $label), $logs->[$i] );
              $i++;
          }
      }
      else {
          print ${$line_ref};
      }
      print "\n";
  }
  
  sub _output_splited_line {
      my ($self, $line_ref) = @_;
  
      my $delimiter = $self->config->{space} ? ' ' : "\t";
      my $i = 1;
      my @cols = split $delimiter, ${$line_ref};
  
      if ($self->config->{number}) {
          my $j = length(scalar @cols);
          for my $col (@cols) {
              $self->__output_line( sprintf("%${j}d", $i), $col );
              $i++;
          }
      }
      else {
          for my $col (@cols) {
              $self->__output_line( '', $col );
              $i++;
          }
      }
      print "\n";
  }
  
  sub __output_line {
      my ($self, $label, $value) = @_;
  
      if ($self->config->{color}) {
          print colored($label, $self->config->{_color}{label});
          print colored(': ', $self->config->{_color}{colon}) if $label;
          print colored("$value\n", $self->config->{_color}{value});
      }
      else {
          print "$label: " if $label;
          print "$value\n";
      }
  }
  
  sub pre {
      my ($self, $argv) = @_;
  
      my $config = $self->_set_config;
      $self->_merge_opt($config, $argv);
      $self->config($config);
      $self->parse_class(
          $self->_load_parser($config->{parser} || $DEFAULT_PARSER)
      );
      $self->parse_func( $self->parse_class. '::parse');
      {
          no strict 'refs'; ## no critic
          $self->labels( &{ $self->parse_class. '::labels' }() );
      }
      $self->label_format(
          '%'. _max_label_len($self->labels). 's'
      );
  
      if ($self->config->{digest}) {
          eval { require Digest::SHA1; };
          croak $@ if $@;
      }
  
      if ($self->config->{color}) {
          for my $k (keys %{$DEFAULT_COLOR}) {
              $self->config->{_color}{$k}
                  = $self->config->{"color-$k"} || $DEFAULT_COLOR->{$k};
          }
      }
  
      $self->hr($self->_hr);
  
      $self;
  }
  
  sub _hr {
      my $self = shift;
  
      my $hr     = $self->config->{hr}         || '*';
      my $hr_num = $self->config->{'hr-count'} || 20;
      return scalar($hr x $hr_num);
  }
  
  sub _set_config {
      my $self = shift;
  
      my %config;
      for my $dir ($ENV{YG_DIR}, $ENV{HOME}) {
          next unless $dir;
          next unless -e "$dir/$CONFIG_FILE";
          $self->__read_config("$dir/$CONFIG_FILE" => \%config);
      }
  
      return \%config;
  }
  
  sub __read_config {
      my ($self, $file, $config) = @_;
  
      open my $fh, '<', $file or croak $!;
      while (<$fh>) {
          chomp;
          next if /\A\s*\Z/sm;
          if (/\A(\w+):\s*(.+)\Z/sm) {
              my ($key, $value) = ($1, $2);
              if ($key eq 'file') {
                  push @{$config->{$key}}, $value;
              }
              else {
                  $config->{$key} = $value;
              }
          }
      }
      close $fh;
  }
  
  sub _merge_opt {
      my ($self, $config, $argv) = @_;
  
      Getopt::Long::Configure('bundling');
      GetOptionsFromArray(
          $argv,
          'f|file=s@'      => \$config->{file},
          'p|parser=s'     => \$config->{parser},
          'tab'            => \$config->{tab},
          'space'          => \$config->{space},
          'n|number!'      => \$config->{number},
          'm|match=s'      => \$config->{match},
          're|regexp=s'    => \$config->{regexp},
          'i|ignore-case!' => \$config->{ignore_case},
          'r|raw'          => \$config->{raw},
          't|through'      => \$config->{through},
          'digest!'        => \$config->{digest},
          'ltsv'           => \$config->{ltsv},
          'c|color!'       => \$config->{color},
          'color-label=s'  => \$config->{color_label},
          'color-colon=s'  => \$config->{color_colon},
          'color-value=s'  => \$config->{color_value},
          'color-hr=s'     => \$config->{color_hr},
          'color-count=s'  => \$config->{color_count},
          'color-digest=s' => \$config->{color_digest},
          'hr=s'           => \$config->{hr},
          'hr-count=i'     => \$config->{'hr-count'},
          'nohr'           => \$config->{'nohr'},
          'h|help'         => sub {
              pod2usage(1);
          },
          'v|version'     => sub {
              print "yg v$App::YG::VERSION\n";
              exit 1;
          },
      ) or pod2usage(2);
  
      push @{$config->{file}}, @{$argv};
  }
  
  sub _load_parser {
      my ($self, $parser) = @_;
  
      my $class = __PACKAGE__. join('', map { '::'.ucfirst($_) } split('-', $parser));
      my $file = $class;
      $file =~ s!::!/!g;
      eval {
          require "$file.pm"; ## no critic
      };
      if ($@) {
          croak "wrong parser: $parser, $@";
      }
      return $class;
  }
  
  sub _max_label_len {
      my $labels = shift;
  
      my $max = 0;
      for my $label (@{$labels}) {
          my $len = length($label);
          $max = $len if $max < $len;
      }
      return $max;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  App::YG - log line filter, like \G of MySQL
  
  
  =head1 SYNOPSIS
  
      use App::YG;
  
      my $yg = App::YG->new;
      $yg->run(@ARGV);
  
  See command L<yg>.
  
  
  =head1 METHOD
  
  =over
  
  =item new
  
  constructor
  
  =item run(I<@ARGV>)
  
  execute command
  
  =item pre
  
  prepare for showing logs
  
  =item loop
  
  loop for showing logs
  
  =back
  
  
  =head1 SEE ALSO
  
  L<yg>
  
  
  =head1 AUTHOR
  
  Dai Okabayashi E<lt>bayashi@cpan.orgE<gt>
  
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself. See L<perlartistic>.
  
  =cut
APP_YG

$fatpacked{"App/YG/Apache/Combined.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_YG_APACHE_COMBINED';
  package App::YG::Apache::Combined;
  use strict;
  use warnings;
  
  # 127.0.0.1 - - [30/Sep/2012:12:34:56 +0900] "GET /foo HTTP/1.0" 200 123 "http://example.com/" "Mozilla/5.0"
  our $regexp = qr/^
    ([^\ ]+)\ +([^\ ]+)\ +([^\ ]+)\ +
    \[([^\]]+)\]\ +
    "(.*)"\ +(\d+)\ +([^\ ]+)\ +
    "(.*)"\ +"(.*)"
  $/x;
  
  sub parse {
      my $line = shift;
  
      $line =~ m!$regexp! or warn "failed to parse line: '$line'\n";
  
      return [
          $1 || '', $2 || '', $3 || '',
          $4 || '',
          $5 || '', $6 || '', $7 || '',
          $8 || '', $9 || '',
      ];
  }
  
  sub labels {
      return [qw/
          Host
          Ident
          Authuser
          Date
          Request
          Status
          Bytes
          Referer
          UserAgent
      /];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  App::YG::Apache::Combined - Apache combined log parser
  
  
  =head1 SYNOPSIS
  
      use App::YG::Apache::Combined;
      App::YG::Apache::Combined::parse($log);
  
  
  =head1 METHOD
  
  =over
  
  =item parse($log_line)
  
  g
  
  =item labels
  
  g
  
  =back
  
  
  =head1 AUTHOR
  
  Dai Okabayashi E<lt>bayashi@cpan.orgE<gt>
  
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself. See L<perlartistic>.
  
  =cut
APP_YG_APACHE_COMBINED

$fatpacked{"App/YG/Apache/Common.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_YG_APACHE_COMMON';
  package App::YG::Apache::Common;
  use strict;
  use warnings;
  
  # 127.0.0.1 - - [30/Sep/2012:12:34:56 +0900] "GET /foo HTTP/1.0" 200 123
  our $regexp = qr/^
    ([^\ ]+)\ +([^\ ]+)\ +([^\ ]+)\ +
    \[([^\]]+)\]\ +
    "(.*)"\ +(\d+)\ +([^\ ]+)
  $/x;
  
  sub parse {
      my $line = shift;
  
      $line =~ m!$regexp! or warn "failed to parse line: '$line'\n";
  
      return [
          $1 || '', $2 || '', $3 || '',
          $4 || '',
          $5 || '', $6 || '', $7 || '',
      ];
  }
  
  sub labels {
      return [qw/
          Host
          Ident
          Authuser
          Date
          Request
          Status
          Bytes
      /];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  App::YG::Apache::Common - Apache common log parser
  
  
  =head1 SYNOPSIS
  
      use App::YG::Apache::Common;
      App::YG::Apache::Common::parse($log);
  
  
  =head1 METHOD
  
  =over
  
  =item parse($log_line)
  
  =item labels
  
  =back
  
  
  =head1 AUTHOR
  
  Dai Okabayashi E<lt>bayashi@cpan.orgE<gt>
  
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself. See L<perlartistic>.
  
  =cut
APP_YG_APACHE_COMMON

$fatpacked{"App/YG/Apache/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_YG_APACHE_ERROR';
  package App::YG::Apache::Error;
  use strict;
  use warnings;
  
  # [Sat Oct 06 17:34:17 2012] [notice] suEXEC mechanism enabled (wrapper: /usr/sbin/suexec)
  # [Sat Oct 06 17:36:10 2012] [error] [client 123.220.65.13] File does not exist: /var/www/html/favicon.ico
  our $regexp = qr/^
    \[([^\]]+)\]\ +\[([^\]]+)\]\ +
    (?:\[client\ ([^\]]+)\]\ +)?
    (.+)
  $/x;
  
  sub parse {
      my $line = shift;
  
      $line =~ m!$regexp! or warn "failed to parse line: '$line'\n";
  
      return [
          $1 || '', $2 ||'',
          $3 || '',
          $4 || '',
      ];
  }
  
  sub labels {
      return [qw/
          Date
          Log_Level
          Client
          Message
      /];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  App::YG::Apache::Error - Apache error log parser
  
  
  =head1 SYNOPSIS
  
      use App::YG::Apache::Error;
      App::YG::Apache::Error::parse($log);
  
  
  =head1 METHOD
  
  =over
  
  =item parse($log_line)
  
  =item labels
  
  =back
  
  
  =head1 AUTHOR
  
  Dai Okabayashi E<lt>bayashi@cpan.orgE<gt>
  
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself. See L<perlartistic>.
  
  =cut
APP_YG_APACHE_ERROR

$fatpacked{"App/YG/Nginx/Main.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_YG_NGINX_MAIN';
  package App::YG::Nginx::Main;
  use strict;
  use warnings;
  
  # $remote_addr - $remote_user [$time_local] "$request" $status $body_bytes_sent "$http_referer" "$http_user_agent" "$http_x_forwarded_for"
  our $regexp = qr/^
    ([^\ ]+)\ +([^\ ]+)\ +([^\ ]+)\ +
    \[([^\]]+)\]\ +
    "(.*)"\ +(\d+)\ +([^\ ]+)\ +
    "(.*)"\ +"(.*)"\ +"(.*)"
  $/x;
  
  sub parse {
      my $line = shift;
  
      $line =~ m!$regexp! or warn "failed to parse line: '$line'\n";
  
      return [
          $1 || '', $2 || '', $3 || '',
          $4 || '',
          $5 || '', $6 || '', $7 || '',
          $8 || '', $9 || '', $10 || '',
      ];
  }
  
  sub labels {
      return [qw/
          Remote_Addr
          -
          Remote_User
          Time_Local
          Request
          Status
          Body_Bytes_Sent
          HTTP_Referer
          User_Agent
          HTTP_x_Forwarded_For
      /];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  App::YG::Nginx::Main - Nginx main log parser
  
  
  =head1 SYNOPSIS
  
      use App::YG::Nginx::Main;
      App::YG::Nginx::Main::parse($log);
  
  
  =head1 METHOD
  
  =over
  
  =item parse($log_line)
  
  =item labels
  
  =back
  
  
  =head1 AUTHOR
  
  Dai Okabayashi E<lt>bayashi@cpan.orgE<gt>
  
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself. See L<perlartistic>.
  
  =cut
APP_YG_NGINX_MAIN

$fatpacked{"App/YG/Vmstat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_YG_VMSTAT';
  package App::YG::Vmstat;
  use strict;
  use warnings;
  
  our $regexp = qr/
    [^\d]+?(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)
  /x;
  
  sub parse {
      my $line = shift;
  
      if ($line =~ m!(proc|swpd)!) {
          return [];
      }
  
      my @matched = ($line =~ m!$regexp!);
      unless (scalar @matched) {
          warn "failed to parse line: '$line'\n";
      }
  
      return \@matched;
  }
  
  sub labels {
      return [qw/
          r
          b
          swpd
          free
          buff
          cache
          si
          so
          bi
          bo
          in
          cs
          us
          sy
          id
          wa
          st
      /];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  App::YG::Vmstat - vmstat log parser
  
  
  =head1 SYNOPSIS
  
      use App::YG::Vmstat;
      App::YG::Vmstat::parse($log);
  
  
  =head1 METHOD
  
  =over
  
  =item parse($log_line)
  
  =item labels
  
  =back
  
  
  =head1 AUTHOR
  
  Dai Okabayashi E<lt>bayashi@cpan.orgE<gt>
  
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself. See L<perlartistic>.
  
  =cut
APP_YG_VMSTAT

$fatpacked{"Class/Accessor/Lite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_ACCESSOR_LITE';
  package Class::Accessor::Lite;
  
  use strict;
  
  our $VERSION = '0.08';
  
  sub croak {require Carp; Carp::croak(@_)}
  
  sub import {
      shift;
      my %args = @_;
      my $pkg = caller(0);
      my %key_ctor = (
          rw => \&_mk_accessors,
          ro => \&_mk_ro_accessors,
          wo => \&_mk_wo_accessors,
      );
      for my $key (sort keys %key_ctor) {
          if (defined $args{$key}) {
              croak("value of the '$key' parameter should be an arrayref")
                  unless ref($args{$key}) eq 'ARRAY';
              $key_ctor{$key}->($pkg, @{$args{$key}});
          }
      }
      _mk_new($pkg)
          if $args{new};
      1;
  }
  
  sub mk_new_and_accessors {
      (undef, my @properties) = @_;
      my $pkg = caller(0);
      _mk_new($pkg);
      _mk_accessors($pkg, @properties);
  }
  
  sub mk_new {
      my $pkg = caller(0);
      _mk_new($pkg);
  }
  
  sub mk_accessors {
      (undef, my @properties) = @_;
      my $pkg = caller(0);
      _mk_accessors($pkg, @properties);
  }
  
  sub mk_ro_accessors {
      (undef, my @properties) = @_;
      my $pkg = caller(0);
      _mk_ro_accessors($pkg, @properties);
  }
  
  sub mk_wo_accessors {
      (undef, my @properties) = @_;
      my $pkg = caller(0);
      _mk_wo_accessors($pkg, @properties);
  }
  
  sub _mk_new {
      my $pkg = shift;
      no strict 'refs';
      *{$pkg . '::new'} = __m_new($pkg);
  }
  
  sub _mk_accessors {
      my $pkg = shift;
      no strict 'refs';
      for my $n (@_) {
          *{$pkg . '::' . $n} = __m($n);
      }
  }
  
  sub _mk_ro_accessors {
      my $pkg = shift;
      no strict 'refs';
      for my $n (@_) {
          *{$pkg . '::' . $n} = __m_ro($pkg, $n);
      }
  }
  
  sub _mk_wo_accessors {
      my $pkg = shift;
      no strict 'refs';
      for my $n (@_) {
          *{$pkg . '::' . $n} = __m_wo($pkg, $n);
      }
  }
  
  sub __m_new {
      my $pkg = shift;
      no strict 'refs';
      return sub {
          my $klass = shift;
          bless {
              (@_ == 1 && ref($_[0]) eq 'HASH' ? %{$_[0]} : @_),
          }, $klass;
      };
  }
  
  sub __m {
      my $n = shift;
      sub {
          return $_[0]->{$n} if @_ == 1;
          return $_[0]->{$n} = $_[1] if @_ == 2;
          shift->{$n} = \@_;
      };
  }
  
  sub __m_ro {
      my ($pkg, $n) = @_;
      sub {
          if (@_ == 1) {
              return $_[0]->{$n} if @_ == 1;
          } else {
              my $caller = caller(0);
              croak("'$caller' cannot access the value of '$n' on objects of class '$pkg'");
          }
      };
  }
  
  sub __m_wo {
      my ($pkg, $n) = @_;
      sub {
          if (@_ == 1) {
              my $caller = caller(0);
              croak("'$caller' cannot alter the value of '$n' on objects of class '$pkg'")
          } else {
              return $_[0]->{$n} = $_[1] if @_ == 2;
              shift->{$n} = \@_;
          }
      };
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::Accessor::Lite - a minimalistic variant of Class::Accessor
  
  =head1 SYNOPSIS
  
      package MyPackage;
  
      use Class::Accessor::Lite (
          new => 1,
          rw  => [ qw(foo bar) ],
          ro  => [ qw(baz) ],
          wo  => [ qw(hoge) ],
      );
  
  =head1 DESCRIPTION
  
  The module is a variant of C<Class::Accessor>.  It is fast and requires less typing, has no dependencies to other modules, and does not mess up the @ISA.
  
  =head1 THE USE STATEMENT
  
  The use statement (i.e. the C<import> function) of the module takes a single hash as an argument that specifies the types and the names of the properties.  Recognises the following keys.
  
  =over 4
  
  =item new => $true_or_false
  
  the default constructor is created if the value evaluates to true, otherwise nothing is done (the default behaviour)
  
  =item rw => \@name_of_the_properties
  
  creates a read / write accessor for the name of the properties passed through as an arrayref
  
  =item ro => \@name_of_the_properties
  
  creates a read-only accessor for the name of the properties passed through as an arrayref
  
  =item wo => \@name_of_the_properties
  
  creates a write-only accessor for the name of the properties passed through as an arrayref
  
  =back
  
  For more detailed explanation read the following section describing the behaviour of each function that actually creates the accessors.
  
  =head1 FUNCTIONS
  
  As of version 0.04 the properties can be specified as the arguments to the C<use> statement (as can be seen in the SYNOPSIS) which is now the recommended way of using the module, but for compatibility the following functions are provided as well.
  
  =head2 Class::Accessor::Lite->mk_accessors(@name_of_the_properties)
  
  Creates an accessor in current package under the name specified by the arguments that access the properties (of a hashref) with the same name.
  
  =head2 Class::Accessor::Lite->mk_ro_accessors(@name_of_the_properties)
  
  Same as mk_accessors() except it will generate read-only accessors (i.e. true accessors).  If you attempt to set a value with these accessors it will throw an exception.
  
  =head2 Class::Accessor::Lite->mk_wo_accessors(@name_of_the_properties)
  
  Same as mk_accessors() except it will generate write-only accessors (i.e. mutators).  If you attempt to read a value with these accessors it will throw an exception.
  
  =head2 Class::Accessor::Lite->mk_new()
  
  Creates the C<new> function that accepts a hash or a hashref as the initial properties of the object.
  
  =head2 Class::Accessor::Lite->mk_new_and_accessors(@name_of_the_properties)
  
  DEPRECATED.  Use the new "use Class::Accessor::Lite (...)" style.
  
  =head1 FAQ
  
  =head2 Can I use C<Class::Accessor::Lite> in an inherited module?
  
  Yes in most cases, when the class object in the super class is implemented using a hashref.  However you _should_ _not_ create the constructor for the inherited class by calling C<<Class::Accessor::Lite->new()>> or by C<<use Class::Accessor::Lite (new => 1)>>.  The only other thing that C<Class::Accessor::Lite> does is to set up the accessor functions for given property names through a blessed hashref.
  
  =head2 What happens when passing more than one arguments to the accessor?
  
  When the accessor built by Class::Accessor::Lite is given more than one arguments, a reference to the arguments will be saved as an arrayref.  This behaviour might not be necessary but is implemented as is to maintain compatibility with L<Class::Accessor::Fast>.
  
      my @data = (1, 2, 3);
      $obj->someproperty(@data);
  
      $obj->someproperty->[2]++; # $data[3] is incremented
  
  In general, you should pass an arrayref to set an arrayref to a property.
  
      my @data = (1, 2, 3);
      $obj->someproperty([ @data ]); # save a copy using arrayref
  
      $obj->someproper->[2]++; # @data is not modified
  
  =head1 SEE ALSO
  
  L<Class::Accessor>
  
  L<Class::Accessor::Lite>
  
  =head1 AUTHORS
  
  Copyright (C) 2008 - 2010 Kazuho Oku
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself, either Perl version 5.8.6 or, at your option, any later version of Perl 5 you may have available.
  
  =cut
  
CLASS_ACCESSOR_LITE

$fatpacked{"IO/Interactive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_INTERACTIVE';
  package IO::Interactive;
  
  use version; $VERSION = qv('0.0.6');
  
  use warnings;
  use strict;
  use Carp;
  use Scalar::Util qw( openhandle );
  
  sub is_interactive {
      my ($out_handle) = (@_, select);    # Default to default output handle
  
      # Not interactive if output is not to terminal...
      return 0 if not -t $out_handle;
  
      # If *ARGV is opened, we're interactive if...
      if (openhandle *ARGV) {
          # ...it's currently opened to the magic '-' file
          return -t *STDIN if defined $ARGV && $ARGV eq '-';
  
          # ...it's at end-of-file and the next file is the magic '-' file
          return @ARGV>0 && $ARGV[0] eq '-' && -t *STDIN if eof *ARGV;
  
          # ...it's directly attached to the terminal 
          return -t *ARGV;
      }
  
      # If *ARGV isn't opened, it will be interactive if *STDIN is attached 
      # to a terminal.
      else {
          return -t *STDIN;
      }
  }
  
  local (*DEV_NULL, *DEV_NULL2);
  my $dev_null;
  BEGIN {
      pipe *DEV_NULL, *DEV_NULL2
          or die "Internal error: can't create null filehandle";
      $dev_null = \*DEV_NULL;
  }
  
  sub interactive {
      my ($out_handle) = (@_, \*STDOUT);      # Default to STDOUT
      return &is_interactive ? $out_handle : $dev_null;
  }
  
  sub _input_pending_on {
      my ($fh) = @_;
      my $read_bits = "";
      my $bit = fileno($fh);
      return if $bit < 0;
      vec($read_bits, fileno($fh), 1) = 1;
      select $read_bits, undef, undef, 0.1;
      return $read_bits;
  }
  
  sub busy (&) {
      my ($block_ref) = @_;
  
      # Non-interactive busy-ness is easy...just do it
      if (!is_interactive()) {
          $block_ref->();
          open my $fh, '<', \"";
          return $fh;
      }
  
      # Otherwise fork off an interceptor process...
      my ($read, $write);
      pipe $read, $write;
      my $child = fork;
  
      # Within that interceptor process...
      if (!$child) {
          # Prepare to send back any intercepted input...
          use IO::Handle;
          close $read;
          $write->autoflush(1);
  
          # Intercept that input...
          while (1) {
              if (_input_pending_on(\*ARGV)) {
                  # Read it...
                  my $res = <ARGV>;
  
                  # Send it back to the parent...
                  print {$write} $res;
  
                  # Admonish them for not waiting...
                  print {*STDERR} "That input was ignored. ",
                                  "Please don't press any keys yet.\n";
              }
          }
          exit;
      }
  
      # Meanwhile, back in the parent...
      close $write;
  
      # Temporarily close the input...
      local *ARGV;
      open *ARGV, '<', \"";
  
      # Do the job...
      $block_ref->();
  
      # Take down the interceptor...
      kill 9, $child;
      wait;
  
      # Return whatever the interceptor caught...
      return $read;
  }
  
  use Carp;
  
  sub import {
      my ($package) = shift;
      my $caller = caller;
  
      # Export each sub if it's requested...
      for my $request ( @_ ) {
          no strict 'refs';
          my $impl = *{$package.'::'.$request}{CODE};
          croak "Unknown subroutine ($request()) requested"
              if !$impl || $request =~ m/\A _/xms;
          *{$caller.'::'.$request} = $impl;
      }
  }
  
  
  1; # Magic true value required at end of module
  __END__
  
  =head1 NAME
  
  IO::Interactive - Utilities for interactive I/O
  
  =head1 VERSION
  
  This document describes IO::Interactive version 0.0.6
  
  
  =head1 SYNOPSIS
  
      use IO::Interactive qw(is_interactive interactive busy);
  
      if ( is_interactive() ) {
          print "Running interactively\n";
      }
  
      # or...
  
      print {interactive} "Running interactively\n";
  
  
      $fh = busy {
          do_noninteractive_stuff();
      }
  
  
  =head1 DESCRIPTION
  
  This module provides three utility subroutines that make it easier to
  develop interactive applications...
  
  =over
  
  =item C<is_interactive()>
  
  This subroutine returns true if C<*ARGV> and the currently selected
  filehandle (usually C<*STDOUT>) are connected to the terminal. The 
  test is considerably more sophisticated than:
  
      -t *ARGV && -t *STDOUT
  
  as it takes into account the magic behaviour of C<*ARGV>.
  
  You can also pass C<is_interactive> a writable filehandle, in which case it
  requires that filehandle be connected to a terminal (instead of the
  currently selected).  The usual suspect here is C<*STDERR>:
  
      if ( is_interactive(*STDERR) ) {
          carp $warning;
      }
  
  
  =item C<interactive()>
  
  This subroutine returns C<*STDOUT> if C<is_interactive> is true. If
  C<is_interactive()> is false, C<interactive> returns a filehandle that
  does not print.
  
  This makes it easy to create applications that print out only when the
  application is interactive:
  
      print {interactive} "Please enter a value: ";
      my $value = <>;
  
  You can also pass C<interactive> a writable filehandle, in which case it
  writes to that filehandle if it is connected to a terminal (instead of 
  writinbg to C<*STDOUT>). Once again, the usual suspect is C<*STDERR>:
  
      print {interactive(*STDERR)} $warning;
  
  
  =item C<busy {...}>
  
  This subroutine takes a block as its single argument and executes that block.
  Whilst the block is executed, C<*ARGV> is temporarily replaced by a closed
  filehandle. That is, no input from C<*ARGV> is possible in a C<busy> block.
  Furthermore, any attempts to send input into the C<busy> block through
  C<*ARGV> is intercepted and a warning message is printed to C<*STDERR>.
  The C<busy> call returns a filehandle that contains the intercepted input.
  
  A C<busy> block is therefore useful to prevent attempts at input when the
  program is busy at some non-interactive task.
  
  =back
  
  =head1 DIAGNOSTICS
  
  =over
  
  =item Unknown subroutine (%s) requested
  
  This module only exports the three subroutines described above.
  You asked for something else. Maybe you misspelled the subroutine you wanted.
  
  =back
  
  =head1 CONFIGURATION AND ENVIRONMENT
  
  IO::Interactive requires no configuration files or environment variables.
  
  
  =head1 DEPENDENCIES
  
  This module requires the C<openhandle()> subroutine from the
  Scalar::Util module.
  
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  =head1 BUGS AND LIMITATIONS
  
  No bugs have been reported.
  
  Please report any bugs or feature requests to
  C<bug-io-interactive@rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org>.
  
  
  =head1 AUTHOR
  
  Damian Conway  C<< <DCONWAY@cpan.org> >>
  
  Currently maintained by brian d foy C<< <bdfoy@cpan.org> >>
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2005, Damian Conway C<< <DCONWAY@cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
  
  =cut
IO_INTERACTIVE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/home/gugod/perl5/perlbrew/perls/perl-5.22.0/bin/perl 

eval 'exec /home/gugod/perl5/perlbrew/perls/perl-5.22.0/bin/perl  -S $0 ${1+"$@"}'
    if 0; # not running under some shell
use strict;
use warnings;
use App::YG;

my $yg = App::YG->new;
$yg->run(@ARGV);

__END__

=encoding UTF-8

=head1 NAME

yg - log line filter, like \G of MySQL


=head1 SYNOPSIS

    $ yg [options] FILE ...

    or

    $ cat apache_log | yg [option]

    options:
        -p,  --parser         parser(default: apache-combined)
             --tab            show tab delimited log
             --space          show space delimited log
                              NOTE: if you set options --tab or --space, then --parser option is ignored
             --ltsv           parsed and show LTSV log
        -n,  --number         if you specify delimiter and -n, then show number points
        -m,  --match          show log lines only if a keyword matches
        -re, --regexp         show log lines only if regular expression matches
        -i,  --ignore-case    regexp option: ignore case distinctions
        -r,  --raw            also show raw log lines
        -t,  --through        ignore yg command, output only raw log lines
             --digest         show digest of raw log string

        -c, --color           show colorized log

        -h,  --help           show this help message
        -V,  --version        show version


=head1 EXAMPLES

parse Apache Combined logs, show logs vertically with labels of element

    $ yg apache_commbined_log

parse Apache Error logs, show logs vertically with labels of element

    $ yg -p apache-error apache_error_log

parse TAB-delimited logs, show logs vertically

    $ yg --tab tab_delimited_log

parse TAB-delimited logs, show logs vertically with number labels

    $ yg --tab -n tab_delimited_log

parse SPACE-delimited logs, show logs vertically

    $ yg --space space_delimited_log

parse LTSV logs, show logs vertically

    $ yg --ltsv ltsv_log

tailed log

    $ tail -f apache_commbined_log | yg


=head1 DESCRIPTION

C<yg> is a log viewer(filter) to show log lines vertically.

When you check apache logs, I guess you do like this

    $ cat apache_log
    127.0.0.1 - - [30/Sep/2012:12:34:56 +0900] "GET /foo HTTP/1.0" 200 123 "http://example.com/foo" "Mozilla/5.0"
    127.0.0.1 - - [30/Sep/2012:12:34:57 +0900] "GET /bar HTTP/1.0" 301 124 "http://example.com/bar" "Mozilla/5.1"

If you use C<yg>, log lines are showed like below:

    $ yg apache_log
    ******************** 1 ********************
         Host: 127.0.0.1
        Ident: -
     Authuser: -
         Date: 30/Sep/2012:12:34:56 +0900
      Request: GET /foo HTTP/1.0
       Status: 200
        Bytes: 123
      Referer: http://example.com/foo
    UserAgent: Mozilla/5.0

    ******************** 2 ********************
         Host: 127.0.0.1
        Ident: -
     Authuser: -
         Date: 30/Sep/2012:12:34:57 +0900
      Request: GET /bar HTTP/1.0
       Status: 200
        Bytes: 124
      Referer: http://example.com/bar
    UserAgent: Mozilla/5.1

easier for understanding.

Of course, C<yg> can work for like below.

    $ cat apache_log | yg

C<yg> command supports few formats of log. And you can write custom parser of L<App::YG>.

=head2 PARSERS

Above sample uses L<App::YG::Apache::Combined>. It is default parser. If you want to view other format logs, you should specify C<--parser> option.

    $ cat apache-error-log | yg --parser apache-error

Then C<yg> uses L<App::YG::Apache::Error> to parse log lines.

    $ cat apache-error-log | yg --parser apache-error
    ******************** 1 ********************
         Date: Sat Oct 06 17:34:17 2012
    Log_Level: error
       Client: 127.0.0.1
      Message: File does not exist: /var/www/html/favicon.ico

App::YG has below parsers.

=over 2

=item App::YG::Apache::Combined

for apache combined log

=item App::YG::Apache::Common

for apache common log

=item App::YG::Apache::Error

for apache error log

=item App::YG::Nginx::Main

for nginx main log

=back

=head3 HOW TO WRITE YOUR OWN PARSER

L<App::YG> is designed to be easily extensible. You might want to write a custom log parser. Each parser is easy to write one.

For example:

    package App::YG::MyApp::Log;
    use strict;
    use warnings;

    sub parse {
        my $line = shift;

        $line =~ m!^DATE:([^\t]+)\t([^\t]+)\tMSG:(.+)$! or warn "failed to parse line: '$line'\n";

        return [
            $1 || '',
            $2 || '',
            $3 || '',
        ];
    }

    sub labels {
        return [qw/
            Date
            Level
            Message
        /];
    }

Parser class must have 2 methods C<parser> and C<labels>. Both methods must return array reference. Let's look at the anatomy of App::YG::* modules. And check test codes in F<t/parser/*/*.t>.


=head1 AUTHOR

Dai Okabayashi E<lt>bayashi@cpan.orgE<gt>


=head1 SEE ALSO

L<App::YG>


=head1 LICENSE

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See L<perlartistic>.


=cut
