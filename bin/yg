#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/YG.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_YG';
  package App::YG;
  use strict;
  use warnings;
  use Carp qw/croak/;
  use Getopt::Long qw/GetOptionsFromArray/;
  use Pod::Usage;
  use IO::Interactive qw/is_interactive/;
  use Term::ANSIColor qw/colored/;
  
  our $VERSION = '0.063';
  
  our $CONFIG_FILE    = '.ygconfig';
  our $DEFAULT_PARSER = 'apache-combined';
  our $DIGEST_LENGTH = 6;
  our $DEFAULT_COLOR = +{
      label  => 'blue',
      colon  => 'cyan',
      value  => 'green',
      hr     => 'yellow',
      count  => 'red',
      digest => 'magenta',
  };
  
  use Class::Accessor::Lite (
      new => 1,
      rw  => [qw/
          config
          parse_class
          parse_func
          labels
          label_format
          count
          hr
      /],
  );
  
  sub run {
      my $self = shift;
      $self->pre(\@_)->loop;
  }
  
  sub loop {
      my $self = shift;
  
      $self->count(1);
      if ( !is_interactive() ) {
          while ( my $line = <STDIN> ) {
              $self->_out_put(\$line);
          }
      }
      elsif ( scalar @{ $self->config->{file} } ) {
          for my $file (@{$self->config->{file}}) {
              open my $fh, '<', $file or croak $!;
              while ( my $line = <$fh> ) {
                  $self->_out_put(\$line);
              }
              close $fh;
          }
      }
  
      return 1;
  }
  
  sub _out_put {
      my ($self, $line_ref) = @_;
  
      chomp ${$line_ref};
  
      if ( ( !$self->config->{match} && !$self->config->{regexp} )
              || ( $self->config->{match} && $self->_match($line_ref) )
                  || ( $self->config->{regexp} && $self->_regexp($line_ref) )
      ) {
          $self->__out($line_ref);
      }
      else {
          return;
      }
  }
  
  sub __out {
      my ($self, $line_ref) = @_;
  
      if ($self->config->{through}) {
          print "${$line_ref}\n";
          return;
      }
  
      if (!$self->config->{nohr}) {
          my $digest = '';
          if ($self->config->{digest}) {
              $digest = substr(Digest::SHA1::sha1_hex(${$line_ref}), 0, $DIGEST_LENGTH);
          }
          $self->_output_head($self->count, $digest);
      }
  
      $self->_output_raw($line_ref) if $self->config->{raw};
  
      if ($self->config->{ltsv}) {
          $self->_output_ltsv_line($line_ref);
      }
      elsif ( $self->config->{tab} || $self->config->{space} ) {
          $self->_output_splited_line($line_ref);
      }
      else {
          $self->_output_parsed_line($line_ref);
      }
  
      $self->count( $self->count() + 1 );
      return;
  }
  
  sub _match {
      my ($self, $line_ref) = @_;
  
      return 1 if index(${$line_ref}, $self->{config}->{match}) > -1;
  }
  
  sub _regexp {
      my ($self, $line_ref) = @_;
  
      if ($self->config->{ignore_case}) {
          return 1 if ${$line_ref} =~ m!$self->{config}->{regexp}!i;
      }
      else {
          return 1 if ${$line_ref} =~ m!$self->{config}->{regexp}!;
      }
  }
  
  sub _output_head {
      my ($self, $count, $digest) = @_;
  
      my $colon = $digest ? ': ' : '';
  
      if ($self->config->{color}) {
          print colored($self->hr.' ', $self->config->{_color}{hr});
          print colored($count, $self->config->{_color}{count});
          print colored($colon, $self->config->{_color}{colon});
          print colored($digest, $self->config->{_color}{digest});
          print colored(' '.$self->hr, $self->config->{_color}{hr});
          print "\n";
      }
      else {
          print $self->hr. " $count$colon$digest ". $self->hr. "\n";
      }
  }
  
  sub _output_raw {
      print "${$_[1]}\n";
  }
  
  sub _output_ltsv_line {
      my ($self, $line_ref) = @_;
  
      my $delimiter = "\t";
  
      my @cols = split $delimiter, ${$line_ref};
      my @labels;
      for my $col (@cols) {
          my ($label, $value) = split ':', $col;
          push @labels, $label;
      }
      my $lablel_width = _max_label_len(\@labels);
  
      for my $col (@cols) {
          my ($label, $value) = split ':', $col;
          $self->__output_line( sprintf("%${lablel_width}s", $label), $value );
      }
      print "\n";
  }
  
  sub _output_parsed_line {
      my ($self, $line_ref) = @_;
  
      my $logs;
      {
          no strict 'refs'; ## no critic
          $logs = &{ $self->parse_func }(${$line_ref});
      }
      if (@{$logs}) {
          my $i = 0;
          for my $label (@{$self->labels}) {
              $self->__output_line( sprintf($self->label_format, $label), $logs->[$i] );
              $i++;
          }
      }
      else {
          print ${$line_ref};
      }
      print "\n";
  }
  
  sub _output_splited_line {
      my ($self, $line_ref) = @_;
  
      my $delimiter = $self->config->{space} ? ' ' : "\t";
      my $i = 1;
      my @cols = split $delimiter, ${$line_ref};
  
      if ($self->config->{number}) {
          my $j = length(scalar @cols);
          for my $col (@cols) {
              $self->__output_line( sprintf("%${j}d", $i), $col );
              $i++;
          }
      }
      else {
          for my $col (@cols) {
              $self->__output_line( '', $col );
              $i++;
          }
      }
      print "\n";
  }
  
  sub __output_line {
      my ($self, $label, $value) = @_;
  
      if ($self->config->{color}) {
          print colored($label, $self->config->{_color}{label});
          print colored(': ', $self->config->{_color}{colon}) if $label;
          print colored("$value\n", $self->config->{_color}{value});
      }
      else {
          print "$label: " if $label;
          print "$value\n";
      }
  }
  
  sub pre {
      my ($self, $argv) = @_;
  
      my $config = $self->_set_config;
      $self->_merge_opt($config, $argv);
      $self->config($config);
      $self->parse_class(
          $self->_load_parser($config->{parser} || $DEFAULT_PARSER)
      );
      $self->parse_func( $self->parse_class. '::parse');
      {
          no strict 'refs'; ## no critic
          $self->labels( &{ $self->parse_class. '::labels' }() );
      }
      $self->label_format(
          '%'. _max_label_len($self->labels). 's'
      );
  
      if ($self->config->{digest}) {
          eval { require Digest::SHA1; };
          croak $@ if $@;
      }
  
      if ($self->config->{color}) {
          for my $k (keys %{$DEFAULT_COLOR}) {
              $self->config->{_color}{$k}
                  = $self->config->{"color-$k"} || $DEFAULT_COLOR->{$k};
          }
      }
  
      $self->hr($self->_hr);
  
      $self;
  }
  
  sub _hr {
      my $self = shift;
  
      my $hr     = $self->config->{hr}         || '*';
      my $hr_num = $self->config->{'hr-count'} || 20;
      return scalar($hr x $hr_num);
  }
  
  sub _set_config {
      my $self = shift;
  
      my %config;
      for my $dir ($ENV{YG_DIR}, $ENV{HOME}) {
          next unless $dir;
          next unless -e "$dir/$CONFIG_FILE";
          $self->__read_config("$dir/$CONFIG_FILE" => \%config);
      }
  
      return \%config;
  }
  
  sub __read_config {
      my ($self, $file, $config) = @_;
  
      open my $fh, '<', $file or croak $!;
      while (<$fh>) {
          chomp;
          next if /\A\s*\Z/sm;
          if (/\A(\w+):\s*(.+)\Z/sm) {
              my ($key, $value) = ($1, $2);
              if ($key eq 'file') {
                  push @{$config->{$key}}, $value;
              }
              else {
                  $config->{$key} = $value;
              }
          }
      }
      close $fh;
  }
  
  sub _merge_opt {
      my ($self, $config, $argv) = @_;
  
      Getopt::Long::Configure('bundling');
      GetOptionsFromArray(
          $argv,
          'f|file=s@'      => \$config->{file},
          'p|parser=s'     => \$config->{parser},
          'tab'            => \$config->{tab},
          'space'          => \$config->{space},
          'n|number!'      => \$config->{number},
          'm|match=s'      => \$config->{match},
          're|regexp=s'    => \$config->{regexp},
          'i|ignore-case!' => \$config->{ignore_case},
          'r|raw'          => \$config->{raw},
          't|through'      => \$config->{through},
          'digest!'        => \$config->{digest},
          'ltsv'           => \$config->{ltsv},
          'c|color!'       => \$config->{color},
          'color-label=s'  => \$config->{color_label},
          'color-colon=s'  => \$config->{color_colon},
          'color-value=s'  => \$config->{color_value},
          'color-hr=s'     => \$config->{color_hr},
          'color-count=s'  => \$config->{color_count},
          'color-digest=s' => \$config->{color_digest},
          'hr=s'           => \$config->{hr},
          'hr-count=i'     => \$config->{'hr-count'},
          'nohr'           => \$config->{'nohr'},
          'h|help'         => sub {
              pod2usage(1);
          },
          'v|version'     => sub {
              print "yg v$App::YG::VERSION\n";
              exit 1;
          },
      ) or pod2usage(2);
  
      push @{$config->{file}}, @{$argv};
  }
  
  sub _load_parser {
      my ($self, $parser) = @_;
  
      my $class = __PACKAGE__. join('', map { '::'.ucfirst($_) } split('-', $parser));
      my $file = $class;
      $file =~ s!::!/!g;
      eval {
          require "$file.pm"; ## no critic
      };
      if ($@) {
          croak "wrong parser: $parser, $@";
      }
      return $class;
  }
  
  sub _max_label_len {
      my $labels = shift;
  
      my $max = 0;
      for my $label (@{$labels}) {
          my $len = length($label);
          $max = $len if $max < $len;
      }
      return $max;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  App::YG - log line filter, like \G of MySQL
  
  
  =head1 SYNOPSIS
  
      use App::YG;
  
      my $yg = App::YG->new;
      $yg->run(@ARGV);
  
  See command L<yg>.
  
  
  =head1 METHOD
  
  =over
  
  =item new
  
  constructor
  
  =item run(I<@ARGV>)
  
  execute command
  
  =item pre
  
  prepare for showing logs
  
  =item loop
  
  loop for showing logs
  
  =back
  
  
  =head1 SEE ALSO
  
  L<yg>
  
  
  =head1 AUTHOR
  
  Dai Okabayashi E<lt>bayashi@cpan.orgE<gt>
  
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself. See L<perlartistic>.
  
  =cut
APP_YG

$fatpacked{"App/YG/Apache/Combined.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_YG_APACHE_COMBINED';
  package App::YG::Apache::Combined;
  use strict;
  use warnings;
  
  # 127.0.0.1 - - [30/Sep/2012:12:34:56 +0900] "GET /foo HTTP/1.0" 200 123 "http://example.com/" "Mozilla/5.0"
  our $regexp = qr/^
    ([^\ ]+)\ +([^\ ]+)\ +([^\ ]+)\ +
    \[([^\]]+)\]\ +
    "(.*)"\ +(\d+)\ +([^\ ]+)\ +
    "(.*)"\ +"(.*)"
  $/x;
  
  sub parse {
      my $line = shift;
  
      $line =~ m!$regexp! or warn "failed to parse line: '$line'\n";
  
      return [
          $1 || '', $2 || '', $3 || '',
          $4 || '',
          $5 || '', $6 || '', $7 || '',
          $8 || '', $9 || '',
      ];
  }
  
  sub labels {
      return [qw/
          Host
          Ident
          Authuser
          Date
          Request
          Status
          Bytes
          Referer
          UserAgent
      /];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  App::YG::Apache::Combined - Apache combined log parser
  
  
  =head1 SYNOPSIS
  
      use App::YG::Apache::Combined;
      App::YG::Apache::Combined::parse($log);
  
  
  =head1 METHOD
  
  =over
  
  =item parse($log_line)
  
  g
  
  =item labels
  
  g
  
  =back
  
  
  =head1 AUTHOR
  
  Dai Okabayashi E<lt>bayashi@cpan.orgE<gt>
  
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself. See L<perlartistic>.
  
  =cut
APP_YG_APACHE_COMBINED

$fatpacked{"App/YG/Apache/Common.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_YG_APACHE_COMMON';
  package App::YG::Apache::Common;
  use strict;
  use warnings;
  
  # 127.0.0.1 - - [30/Sep/2012:12:34:56 +0900] "GET /foo HTTP/1.0" 200 123
  our $regexp = qr/^
    ([^\ ]+)\ +([^\ ]+)\ +([^\ ]+)\ +
    \[([^\]]+)\]\ +
    "(.*)"\ +(\d+)\ +([^\ ]+)
  $/x;
  
  sub parse {
      my $line = shift;
  
      $line =~ m!$regexp! or warn "failed to parse line: '$line'\n";
  
      return [
          $1 || '', $2 || '', $3 || '',
          $4 || '',
          $5 || '', $6 || '', $7 || '',
      ];
  }
  
  sub labels {
      return [qw/
          Host
          Ident
          Authuser
          Date
          Request
          Status
          Bytes
      /];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  App::YG::Apache::Common - Apache common log parser
  
  
  =head1 SYNOPSIS
  
      use App::YG::Apache::Common;
      App::YG::Apache::Common::parse($log);
  
  
  =head1 METHOD
  
  =over
  
  =item parse($log_line)
  
  =item labels
  
  =back
  
  
  =head1 AUTHOR
  
  Dai Okabayashi E<lt>bayashi@cpan.orgE<gt>
  
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself. See L<perlartistic>.
  
  =cut
APP_YG_APACHE_COMMON

$fatpacked{"App/YG/Apache/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_YG_APACHE_ERROR';
  package App::YG::Apache::Error;
  use strict;
  use warnings;
  
  # [Sat Oct 06 17:34:17 2012] [notice] suEXEC mechanism enabled (wrapper: /usr/sbin/suexec)
  # [Sat Oct 06 17:36:10 2012] [error] [client 123.220.65.13] File does not exist: /var/www/html/favicon.ico
  our $regexp = qr/^
    \[([^\]]+)\]\ +\[([^\]]+)\]\ +
    (?:\[client\ ([^\]]+)\]\ +)?
    (.+)
  $/x;
  
  sub parse {
      my $line = shift;
  
      $line =~ m!$regexp! or warn "failed to parse line: '$line'\n";
  
      return [
          $1 || '', $2 ||'',
          $3 || '',
          $4 || '',
      ];
  }
  
  sub labels {
      return [qw/
          Date
          Log_Level
          Client
          Message
      /];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  App::YG::Apache::Error - Apache error log parser
  
  
  =head1 SYNOPSIS
  
      use App::YG::Apache::Error;
      App::YG::Apache::Error::parse($log);
  
  
  =head1 METHOD
  
  =over
  
  =item parse($log_line)
  
  =item labels
  
  =back
  
  
  =head1 AUTHOR
  
  Dai Okabayashi E<lt>bayashi@cpan.orgE<gt>
  
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself. See L<perlartistic>.
  
  =cut
APP_YG_APACHE_ERROR

$fatpacked{"App/YG/Nginx/Main.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_YG_NGINX_MAIN';
  package App::YG::Nginx::Main;
  use strict;
  use warnings;
  
  # $remote_addr - $remote_user [$time_local] "$request" $status $body_bytes_sent "$http_referer" "$http_user_agent" "$http_x_forwarded_for"
  our $regexp = qr/^
    ([^\ ]+)\ +([^\ ]+)\ +([^\ ]+)\ +
    \[([^\]]+)\]\ +
    "(.*)"\ +(\d+)\ +([^\ ]+)\ +
    "(.*)"\ +"(.*)"\ +"(.*)"
  $/x;
  
  sub parse {
      my $line = shift;
  
      $line =~ m!$regexp! or warn "failed to parse line: '$line'\n";
  
      return [
          $1 || '', $2 || '', $3 || '',
          $4 || '',
          $5 || '', $6 || '', $7 || '',
          $8 || '', $9 || '', $10 || '',
      ];
  }
  
  sub labels {
      return [qw/
          Remote_Addr
          -
          Remote_User
          Time_Local
          Request
          Status
          Body_Bytes_Sent
          HTTP_Referer
          User_Agent
          HTTP_x_Forwarded_For
      /];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  App::YG::Nginx::Main - Nginx main log parser
  
  
  =head1 SYNOPSIS
  
      use App::YG::Nginx::Main;
      App::YG::Nginx::Main::parse($log);
  
  
  =head1 METHOD
  
  =over
  
  =item parse($log_line)
  
  =item labels
  
  =back
  
  
  =head1 AUTHOR
  
  Dai Okabayashi E<lt>bayashi@cpan.orgE<gt>
  
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself. See L<perlartistic>.
  
  =cut
APP_YG_NGINX_MAIN

$fatpacked{"App/YG/Vmstat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_YG_VMSTAT';
  package App::YG::Vmstat;
  use strict;
  use warnings;
  
  our $regexp = qr/
    [^\d]+?(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\d]+(\d+)
  /x;
  
  sub parse {
      my $line = shift;
  
      if ($line =~ m!(proc|swpd)!) {
          return [];
      }
  
      my @matched = ($line =~ m!$regexp!);
      unless (scalar @matched) {
          warn "failed to parse line: '$line'\n";
      }
  
      return \@matched;
  }
  
  sub labels {
      return [qw/
          r
          b
          swpd
          free
          buff
          cache
          si
          so
          bi
          bo
          in
          cs
          us
          sy
          id
          wa
          st
      /];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  App::YG::Vmstat - vmstat log parser
  
  
  =head1 SYNOPSIS
  
      use App::YG::Vmstat;
      App::YG::Vmstat::parse($log);
  
  
  =head1 METHOD
  
  =over
  
  =item parse($log_line)
  
  =item labels
  
  =back
  
  
  =head1 AUTHOR
  
  Dai Okabayashi E<lt>bayashi@cpan.orgE<gt>
  
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself. See L<perlartistic>.
  
  =cut
APP_YG_VMSTAT

$fatpacked{"Class/Accessor/Lite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_ACCESSOR_LITE';
  package Class::Accessor::Lite;
  
  use strict;
  
  our $VERSION = '0.08';
  
  sub croak {require Carp; Carp::croak(@_)}
  
  sub import {
      shift;
      my %args = @_;
      my $pkg = caller(0);
      my %key_ctor = (
          rw => \&_mk_accessors,
          ro => \&_mk_ro_accessors,
          wo => \&_mk_wo_accessors,
      );
      for my $key (sort keys %key_ctor) {
          if (defined $args{$key}) {
              croak("value of the '$key' parameter should be an arrayref")
                  unless ref($args{$key}) eq 'ARRAY';
              $key_ctor{$key}->($pkg, @{$args{$key}});
          }
      }
      _mk_new($pkg)
          if $args{new};
      1;
  }
  
  sub mk_new_and_accessors {
      (undef, my @properties) = @_;
      my $pkg = caller(0);
      _mk_new($pkg);
      _mk_accessors($pkg, @properties);
  }
  
  sub mk_new {
      my $pkg = caller(0);
      _mk_new($pkg);
  }
  
  sub mk_accessors {
      (undef, my @properties) = @_;
      my $pkg = caller(0);
      _mk_accessors($pkg, @properties);
  }
  
  sub mk_ro_accessors {
      (undef, my @properties) = @_;
      my $pkg = caller(0);
      _mk_ro_accessors($pkg, @properties);
  }
  
  sub mk_wo_accessors {
      (undef, my @properties) = @_;
      my $pkg = caller(0);
      _mk_wo_accessors($pkg, @properties);
  }
  
  sub _mk_new {
      my $pkg = shift;
      no strict 'refs';
      *{$pkg . '::new'} = __m_new($pkg);
  }
  
  sub _mk_accessors {
      my $pkg = shift;
      no strict 'refs';
      for my $n (@_) {
          *{$pkg . '::' . $n} = __m($n);
      }
  }
  
  sub _mk_ro_accessors {
      my $pkg = shift;
      no strict 'refs';
      for my $n (@_) {
          *{$pkg . '::' . $n} = __m_ro($pkg, $n);
      }
  }
  
  sub _mk_wo_accessors {
      my $pkg = shift;
      no strict 'refs';
      for my $n (@_) {
          *{$pkg . '::' . $n} = __m_wo($pkg, $n);
      }
  }
  
  sub __m_new {
      my $pkg = shift;
      no strict 'refs';
      return sub {
          my $klass = shift;
          bless {
              (@_ == 1 && ref($_[0]) eq 'HASH' ? %{$_[0]} : @_),
          }, $klass;
      };
  }
  
  sub __m {
      my $n = shift;
      sub {
          return $_[0]->{$n} if @_ == 1;
          return $_[0]->{$n} = $_[1] if @_ == 2;
          shift->{$n} = \@_;
      };
  }
  
  sub __m_ro {
      my ($pkg, $n) = @_;
      sub {
          if (@_ == 1) {
              return $_[0]->{$n} if @_ == 1;
          } else {
              my $caller = caller(0);
              croak("'$caller' cannot access the value of '$n' on objects of class '$pkg'");
          }
      };
  }
  
  sub __m_wo {
      my ($pkg, $n) = @_;
      sub {
          if (@_ == 1) {
              my $caller = caller(0);
              croak("'$caller' cannot alter the value of '$n' on objects of class '$pkg'")
          } else {
              return $_[0]->{$n} = $_[1] if @_ == 2;
              shift->{$n} = \@_;
          }
      };
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::Accessor::Lite - a minimalistic variant of Class::Accessor
  
  =head1 SYNOPSIS
  
      package MyPackage;
  
      use Class::Accessor::Lite (
          new => 1,
          rw  => [ qw(foo bar) ],
          ro  => [ qw(baz) ],
          wo  => [ qw(hoge) ],
      );
  
  =head1 DESCRIPTION
  
  The module is a variant of C<Class::Accessor>.  It is fast and requires less typing, has no dependencies to other modules, and does not mess up the @ISA.
  
  =head1 THE USE STATEMENT
  
  The use statement (i.e. the C<import> function) of the module takes a single hash as an argument that specifies the types and the names of the properties.  Recognises the following keys.
  
  =over 4
  
  =item new => $true_or_false
  
  the default constructor is created if the value evaluates to true, otherwise nothing is done (the default behaviour)
  
  =item rw => \@name_of_the_properties
  
  creates a read / write accessor for the name of the properties passed through as an arrayref
  
  =item ro => \@name_of_the_properties
  
  creates a read-only accessor for the name of the properties passed through as an arrayref
  
  =item wo => \@name_of_the_properties
  
  creates a write-only accessor for the name of the properties passed through as an arrayref
  
  =back
  
  For more detailed explanation read the following section describing the behaviour of each function that actually creates the accessors.
  
  =head1 FUNCTIONS
  
  As of version 0.04 the properties can be specified as the arguments to the C<use> statement (as can be seen in the SYNOPSIS) which is now the recommended way of using the module, but for compatibility the following functions are provided as well.
  
  =head2 Class::Accessor::Lite->mk_accessors(@name_of_the_properties)
  
  Creates an accessor in current package under the name specified by the arguments that access the properties (of a hashref) with the same name.
  
  =head2 Class::Accessor::Lite->mk_ro_accessors(@name_of_the_properties)
  
  Same as mk_accessors() except it will generate read-only accessors (i.e. true accessors).  If you attempt to set a value with these accessors it will throw an exception.
  
  =head2 Class::Accessor::Lite->mk_wo_accessors(@name_of_the_properties)
  
  Same as mk_accessors() except it will generate write-only accessors (i.e. mutators).  If you attempt to read a value with these accessors it will throw an exception.
  
  =head2 Class::Accessor::Lite->mk_new()
  
  Creates the C<new> function that accepts a hash or a hashref as the initial properties of the object.
  
  =head2 Class::Accessor::Lite->mk_new_and_accessors(@name_of_the_properties)
  
  DEPRECATED.  Use the new "use Class::Accessor::Lite (...)" style.
  
  =head1 FAQ
  
  =head2 Can I use C<Class::Accessor::Lite> in an inherited module?
  
  Yes in most cases, when the class object in the super class is implemented using a hashref.  However you _should_ _not_ create the constructor for the inherited class by calling C<<Class::Accessor::Lite->new()>> or by C<<use Class::Accessor::Lite (new => 1)>>.  The only other thing that C<Class::Accessor::Lite> does is to set up the accessor functions for given property names through a blessed hashref.
  
  =head2 What happens when passing more than one arguments to the accessor?
  
  When the accessor built by Class::Accessor::Lite is given more than one arguments, a reference to the arguments will be saved as an arrayref.  This behaviour might not be necessary but is implemented as is to maintain compatibility with L<Class::Accessor::Fast>.
  
      my @data = (1, 2, 3);
      $obj->someproperty(@data);
  
      $obj->someproperty->[2]++; # $data[3] is incremented
  
  In general, you should pass an arrayref to set an arrayref to a property.
  
      my @data = (1, 2, 3);
      $obj->someproperty([ @data ]); # save a copy using arrayref
  
      $obj->someproper->[2]++; # @data is not modified
  
  =head1 SEE ALSO
  
  L<Class::Accessor>
  
  L<Class::Accessor::Lite>
  
  =head1 AUTHORS
  
  Copyright (C) 2008 - 2010 Kazuho Oku
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself, either Perl version 5.8.6 or, at your option, any later version of Perl 5 you may have available.
  
  =cut
  
CLASS_ACCESSOR_LITE

$fatpacked{"IO/Interactive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_INTERACTIVE';
  package IO::Interactive;
  
  use version; $VERSION = qv('0.0.6');
  
  use warnings;
  use strict;
  use Carp;
  use Scalar::Util qw( openhandle );
  
  sub is_interactive {
      my ($out_handle) = (@_, select);    # Default to default output handle
  
      # Not interactive if output is not to terminal...
      return 0 if not -t $out_handle;
  
      # If *ARGV is opened, we're interactive if...
      if (openhandle *ARGV) {
          # ...it's currently opened to the magic '-' file
          return -t *STDIN if defined $ARGV && $ARGV eq '-';
  
          # ...it's at end-of-file and the next file is the magic '-' file
          return @ARGV>0 && $ARGV[0] eq '-' && -t *STDIN if eof *ARGV;
  
          # ...it's directly attached to the terminal 
          return -t *ARGV;
      }
  
      # If *ARGV isn't opened, it will be interactive if *STDIN is attached 
      # to a terminal.
      else {
          return -t *STDIN;
      }
  }
  
  local (*DEV_NULL, *DEV_NULL2);
  my $dev_null;
  BEGIN {
      pipe *DEV_NULL, *DEV_NULL2
          or die "Internal error: can't create null filehandle";
      $dev_null = \*DEV_NULL;
  }
  
  sub interactive {
      my ($out_handle) = (@_, \*STDOUT);      # Default to STDOUT
      return &is_interactive ? $out_handle : $dev_null;
  }
  
  sub _input_pending_on {
      my ($fh) = @_;
      my $read_bits = "";
      my $bit = fileno($fh);
      return if $bit < 0;
      vec($read_bits, fileno($fh), 1) = 1;
      select $read_bits, undef, undef, 0.1;
      return $read_bits;
  }
  
  sub busy (&) {
      my ($block_ref) = @_;
  
      # Non-interactive busy-ness is easy...just do it
      if (!is_interactive()) {
          $block_ref->();
          open my $fh, '<', \"";
          return $fh;
      }
  
      # Otherwise fork off an interceptor process...
      my ($read, $write);
      pipe $read, $write;
      my $child = fork;
  
      # Within that interceptor process...
      if (!$child) {
          # Prepare to send back any intercepted input...
          use IO::Handle;
          close $read;
          $write->autoflush(1);
  
          # Intercept that input...
          while (1) {
              if (_input_pending_on(\*ARGV)) {
                  # Read it...
                  my $res = <ARGV>;
  
                  # Send it back to the parent...
                  print {$write} $res;
  
                  # Admonish them for not waiting...
                  print {*STDERR} "That input was ignored. ",
                                  "Please don't press any keys yet.\n";
              }
          }
          exit;
      }
  
      # Meanwhile, back in the parent...
      close $write;
  
      # Temporarily close the input...
      local *ARGV;
      open *ARGV, '<', \"";
  
      # Do the job...
      $block_ref->();
  
      # Take down the interceptor...
      kill 9, $child;
      wait;
  
      # Return whatever the interceptor caught...
      return $read;
  }
  
  use Carp;
  
  sub import {
      my ($package) = shift;
      my $caller = caller;
  
      # Export each sub if it's requested...
      for my $request ( @_ ) {
          no strict 'refs';
          my $impl = *{$package.'::'.$request}{CODE};
          croak "Unknown subroutine ($request()) requested"
              if !$impl || $request =~ m/\A _/xms;
          *{$caller.'::'.$request} = $impl;
      }
  }
  
  
  1; # Magic true value required at end of module
  __END__
  
  =head1 NAME
  
  IO::Interactive - Utilities for interactive I/O
  
  =head1 VERSION
  
  This document describes IO::Interactive version 0.0.6
  
  
  =head1 SYNOPSIS
  
      use IO::Interactive qw(is_interactive interactive busy);
  
      if ( is_interactive() ) {
          print "Running interactively\n";
      }
  
      # or...
  
      print {interactive} "Running interactively\n";
  
  
      $fh = busy {
          do_noninteractive_stuff();
      }
  
  
  =head1 DESCRIPTION
  
  This module provides three utility subroutines that make it easier to
  develop interactive applications...
  
  =over
  
  =item C<is_interactive()>
  
  This subroutine returns true if C<*ARGV> and the currently selected
  filehandle (usually C<*STDOUT>) are connected to the terminal. The 
  test is considerably more sophisticated than:
  
      -t *ARGV && -t *STDOUT
  
  as it takes into account the magic behaviour of C<*ARGV>.
  
  You can also pass C<is_interactive> a writable filehandle, in which case it
  requires that filehandle be connected to a terminal (instead of the
  currently selected).  The usual suspect here is C<*STDERR>:
  
      if ( is_interactive(*STDERR) ) {
          carp $warning;
      }
  
  
  =item C<interactive()>
  
  This subroutine returns C<*STDOUT> if C<is_interactive> is true. If
  C<is_interactive()> is false, C<interactive> returns a filehandle that
  does not print.
  
  This makes it easy to create applications that print out only when the
  application is interactive:
  
      print {interactive} "Please enter a value: ";
      my $value = <>;
  
  You can also pass C<interactive> a writable filehandle, in which case it
  writes to that filehandle if it is connected to a terminal (instead of 
  writinbg to C<*STDOUT>). Once again, the usual suspect is C<*STDERR>:
  
      print {interactive(*STDERR)} $warning;
  
  
  =item C<busy {...}>
  
  This subroutine takes a block as its single argument and executes that block.
  Whilst the block is executed, C<*ARGV> is temporarily replaced by a closed
  filehandle. That is, no input from C<*ARGV> is possible in a C<busy> block.
  Furthermore, any attempts to send input into the C<busy> block through
  C<*ARGV> is intercepted and a warning message is printed to C<*STDERR>.
  The C<busy> call returns a filehandle that contains the intercepted input.
  
  A C<busy> block is therefore useful to prevent attempts at input when the
  program is busy at some non-interactive task.
  
  =back
  
  =head1 DIAGNOSTICS
  
  =over
  
  =item Unknown subroutine (%s) requested
  
  This module only exports the three subroutines described above.
  You asked for something else. Maybe you misspelled the subroutine you wanted.
  
  =back
  
  =head1 CONFIGURATION AND ENVIRONMENT
  
  IO::Interactive requires no configuration files or environment variables.
  
  
  =head1 DEPENDENCIES
  
  This module requires the C<openhandle()> subroutine from the
  Scalar::Util module.
  
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  =head1 BUGS AND LIMITATIONS
  
  No bugs have been reported.
  
  Please report any bugs or feature requests to
  C<bug-io-interactive@rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org>.
  
  
  =head1 AUTHOR
  
  Damian Conway  C<< <DCONWAY@cpan.org> >>
  
  Currently maintained by brian d foy C<< <bdfoy@cpan.org> >>
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2005, Damian Conway C<< <DCONWAY@cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
  
  =cut
IO_INTERACTIVE

$fatpacked{"darwin-2level/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle uniq uniqnum uniqstr
    pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.45";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first
  
        max maxstr min minstr product sum sum0
  
        pairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniqnum uniqstr
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of the all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
DARWIN-2LEVEL_LIST_UTIL

$fatpacked{"darwin-2level/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.45";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_LIST_UTIL_XS

$fatpacked{"darwin-2level/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.45";
  $VERSION   = eval $VERSION;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be a dual-valued variable, it is
  actually implemented as a magical variable inside the interpreter:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use L</isweak> or L</weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_SCALAR_UTIL

$fatpacked{"darwin-2level/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.45";
  $VERSION   = eval $VERSION;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If a name has been set using L</set_subname>, this name will
  be returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.+?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
DARWIN-2LEVEL_SUB_UTIL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/Users/gugod/perl5/perlbrew/perls/perl-5.22.0/bin/perl 

eval 'exec /Users/gugod/perl5/perlbrew/perls/perl-5.22.0/bin/perl  -S $0 ${1+"$@"}'
    if 0; # not running under some shell
use strict;
use warnings;
use App::YG;

my $yg = App::YG->new;
$yg->run(@ARGV);

__END__

=encoding UTF-8

=head1 NAME

yg - log line filter, like \G of MySQL


=head1 SYNOPSIS

    $ yg [options] FILE ...

    or

    $ cat apache_log | yg [option]

    options:
        -p,  --parser         parser(default: apache-combined)
             --tab            show tab delimited log
             --space          show space delimited log
                              NOTE: if you set options --tab or --space, then --parser option is ignored
             --ltsv           parsed and show LTSV log
        -n,  --number         if you specify delimiter and -n, then show number points
        -m,  --match          show log lines only if a keyword matches
        -re, --regexp         show log lines only if regular expression matches
        -i,  --ignore-case    regexp option: ignore case distinctions
        -r,  --raw            also show raw log lines
        -t,  --through        ignore yg command, output only raw log lines
             --digest         show digest of raw log string

        -c, --color           show colorized log

        -h,  --help           show this help message
        -V,  --version        show version


=head1 EXAMPLES

parse Apache Combined logs, show logs vertically with labels of element

    $ yg apache_commbined_log

parse Apache Error logs, show logs vertically with labels of element

    $ yg -p apache-error apache_error_log

parse TAB-delimited logs, show logs vertically

    $ yg --tab tab_delimited_log

parse TAB-delimited logs, show logs vertically with number labels

    $ yg --tab -n tab_delimited_log

parse SPACE-delimited logs, show logs vertically

    $ yg --space space_delimited_log

parse LTSV logs, show logs vertically

    $ yg --ltsv ltsv_log

tailed log

    $ tail -f apache_commbined_log | yg


=head1 DESCRIPTION

C<yg> is a log viewer(filter) to show log lines vertically.

When you check apache logs, I guess you do like this

    $ cat apache_log
    127.0.0.1 - - [30/Sep/2012:12:34:56 +0900] "GET /foo HTTP/1.0" 200 123 "http://example.com/foo" "Mozilla/5.0"
    127.0.0.1 - - [30/Sep/2012:12:34:57 +0900] "GET /bar HTTP/1.0" 301 124 "http://example.com/bar" "Mozilla/5.1"

If you use C<yg>, log lines are showed like below:

    $ yg apache_log
    ******************** 1 ********************
         Host: 127.0.0.1
        Ident: -
     Authuser: -
         Date: 30/Sep/2012:12:34:56 +0900
      Request: GET /foo HTTP/1.0
       Status: 200
        Bytes: 123
      Referer: http://example.com/foo
    UserAgent: Mozilla/5.0

    ******************** 2 ********************
         Host: 127.0.0.1
        Ident: -
     Authuser: -
         Date: 30/Sep/2012:12:34:57 +0900
      Request: GET /bar HTTP/1.0
       Status: 200
        Bytes: 124
      Referer: http://example.com/bar
    UserAgent: Mozilla/5.1

easier for understanding.

Of course, C<yg> can work for like below.

    $ cat apache_log | yg

C<yg> command supports few formats of log. And you can write custom parser of L<App::YG>.

=head2 PARSERS

Above sample uses L<App::YG::Apache::Combined>. It is default parser. If you want to view other format logs, you should specify C<--parser> option.

    $ cat apache-error-log | yg --parser apache-error

Then C<yg> uses L<App::YG::Apache::Error> to parse log lines.

    $ cat apache-error-log | yg --parser apache-error
    ******************** 1 ********************
         Date: Sat Oct 06 17:34:17 2012
    Log_Level: error
       Client: 127.0.0.1
      Message: File does not exist: /var/www/html/favicon.ico

App::YG has below parsers.

=over 2

=item App::YG::Apache::Combined

for apache combined log

=item App::YG::Apache::Common

for apache common log

=item App::YG::Apache::Error

for apache error log

=item App::YG::Nginx::Main

for nginx main log

=back

=head3 HOW TO WRITE YOUR OWN PARSER

L<App::YG> is designed to be easily extensible. You might want to write a custom log parser. Each parser is easy to write one.

For example:

    package App::YG::MyApp::Log;
    use strict;
    use warnings;

    sub parse {
        my $line = shift;

        $line =~ m!^DATE:([^\t]+)\t([^\t]+)\tMSG:(.+)$! or warn "failed to parse line: '$line'\n";

        return [
            $1 || '',
            $2 || '',
            $3 || '',
        ];
    }

    sub labels {
        return [qw/
            Date
            Level
            Message
        /];
    }

Parser class must have 2 methods C<parser> and C<labels>. Both methods must return array reference. Let's look at the anatomy of App::YG::* modules. And check test codes in F<t/parser/*/*.t>.


=head1 AUTHOR

Dai Okabayashi E<lt>bayashi@cpan.orgE<gt>


=head1 SEE ALSO

L<App::YG>


=head1 LICENSE

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See L<perlartistic>.


=cut
