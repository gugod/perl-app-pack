#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Getopt/Long.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG';
  #! perl
  
  # Getopt::Long.pm -- Universal options parsing
  # Author          : Johan Vromans
  # Created On      : Tue Sep 11 15:00:12 1990
  # Last Modified By: Johan Vromans
  # Last Modified On: Sat May 27 12:11:39 2017
  # Update Count    : 1715
  # Status          : Released
  
  ################ Module Preamble ################
  
  use 5.004;
  
  use strict;
  use warnings;
  
  package Getopt::Long;
  
  use vars qw($VERSION);
  $VERSION        =  2.50;
  # For testing versions only.
  use vars qw($VERSION_STRING);
  $VERSION_STRING = "2.50";
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  # Exported subroutines.
  sub GetOptions(@);		# always
  sub GetOptionsFromArray(@);	# on demand
  sub GetOptionsFromString(@);	# on demand
  sub Configure(@);		# on demand
  sub HelpMessage(@);		# on demand
  sub VersionMessage(@);		# in demand
  
  BEGIN {
      # Init immediately so their contents can be used in the 'use vars' below.
      @EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
      @EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
  		    &GetOptionsFromArray &GetOptionsFromString);
  }
  
  # User visible variables.
  use vars @EXPORT, @EXPORT_OK;
  use vars qw($error $debug $major_version $minor_version);
  # Deprecated visible variables.
  use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
  	    $passthrough);
  # Official invisible variables.
  use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
  
  # Really invisible variables.
  my $bundling_values;
  
  # Public subroutines.
  sub config(@);			# deprecated name
  
  # Private subroutines.
  sub ConfigDefaults();
  sub ParseOptionSpec($$);
  sub OptCtl($);
  sub FindOption($$$$$);
  sub ValidValue ($$$$$);
  
  ################ Local Variables ################
  
  # $requested_version holds the version that was mentioned in the 'use'
  # or 'require', if any. It can be used to enable or disable specific
  # features.
  my $requested_version = 0;
  
  ################ Resident subroutines ################
  
  sub ConfigDefaults() {
      # Handle POSIX compliancy.
      if ( defined $ENV{"POSIXLY_CORRECT"} ) {
  	$genprefix = "(--|-)";
  	$autoabbrev = 0;		# no automatic abbrev of options
  	$bundling = 0;			# no bundling of single letter switches
  	$getopt_compat = 0;		# disallow '+' to start options
  	$order = $REQUIRE_ORDER;
      }
      else {
  	$genprefix = "(--|-|\\+)";
  	$autoabbrev = 1;		# automatic abbrev of options
  	$bundling = 0;			# bundling off by default
  	$getopt_compat = 1;		# allow '+' to start options
  	$order = $PERMUTE;
      }
      # Other configurable settings.
      $debug = 0;			# for debugging
      $error = 0;			# error tally
      $ignorecase = 1;		# ignore case when matching options
      $passthrough = 0;		# leave unrecognized options alone
      $gnu_compat = 0;		# require --opt=val if value is optional
      $longprefix = "(--)";       # what does a long prefix look like
      $bundling_values = 0;	# no bundling of values
  }
  
  # Override import.
  sub import {
      my $pkg = shift;		# package
      my @syms = ();		# symbols to import
      my @config = ();		# configuration
      my $dest = \@syms;		# symbols first
      for ( @_ ) {
  	if ( $_ eq ':config' ) {
  	    $dest = \@config;	# config next
  	    next;
  	}
  	push(@$dest, $_);	# push
      }
      # Hide one level and call super.
      local $Exporter::ExportLevel = 1;
      push(@syms, qw(&GetOptions)) if @syms; # always export GetOptions
      $requested_version = 0;
      $pkg->SUPER::import(@syms);
      # And configure.
      Configure(@config) if @config;
  }
  
  ################ Initialization ################
  
  # Values for $order. See GNU getopt.c for details.
  ($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
  # Version major/minor numbers.
  ($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;
  
  ConfigDefaults();
  
  ################ OO Interface ################
  
  package Getopt::Long::Parser;
  
  # Store a copy of the default configuration. Since ConfigDefaults has
  # just been called, what we get from Configure is the default.
  my $default_config = do {
      Getopt::Long::Configure ()
  };
  
  sub new {
      my $that = shift;
      my $class = ref($that) || $that;
      my %atts = @_;
  
      # Register the callers package.
      my $self = { caller_pkg => (caller)[0] };
  
      bless ($self, $class);
  
      # Process config attributes.
      if ( defined $atts{config} ) {
  	my $save = Getopt::Long::Configure ($default_config, @{$atts{config}});
  	$self->{settings} = Getopt::Long::Configure ($save);
  	delete ($atts{config});
      }
      # Else use default config.
      else {
  	$self->{settings} = $default_config;
      }
  
      if ( %atts ) {		# Oops
  	die(__PACKAGE__.": unhandled attributes: ".
  	    join(" ", sort(keys(%atts)))."\n");
      }
  
      $self;
  }
  
  sub configure {
      my ($self) = shift;
  
      # Restore settings, merge new settings in.
      my $save = Getopt::Long::Configure ($self->{settings}, @_);
  
      # Restore orig config and save the new config.
      $self->{settings} = Getopt::Long::Configure ($save);
  }
  
  sub getoptions {
      my ($self) = shift;
  
      return $self->getoptionsfromarray(\@ARGV, @_);
  }
  
  sub getoptionsfromarray {
      my ($self) = shift;
  
      # Restore config settings.
      my $save = Getopt::Long::Configure ($self->{settings});
  
      # Call main routine.
      my $ret = 0;
      $Getopt::Long::caller = $self->{caller_pkg};
  
      eval {
  	# Locally set exception handler to default, otherwise it will
  	# be called implicitly here, and again explicitly when we try
  	# to deliver the messages.
  	local ($SIG{__DIE__}) = 'DEFAULT';
  	$ret = Getopt::Long::GetOptionsFromArray (@_);
      };
  
      # Restore saved settings.
      Getopt::Long::Configure ($save);
  
      # Handle errors and return value.
      die ($@) if $@;
      return $ret;
  }
  
  package Getopt::Long;
  
  ################ Back to Normal ################
  
  # Indices in option control info.
  # Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
  use constant CTL_TYPE    => 0;
  #use constant   CTL_TYPE_FLAG   => '';
  #use constant   CTL_TYPE_NEG    => '!';
  #use constant   CTL_TYPE_INCR   => '+';
  #use constant   CTL_TYPE_INT    => 'i';
  #use constant   CTL_TYPE_INTINC => 'I';
  #use constant   CTL_TYPE_XINT   => 'o';
  #use constant   CTL_TYPE_FLOAT  => 'f';
  #use constant   CTL_TYPE_STRING => 's';
  
  use constant CTL_CNAME   => 1;
  
  use constant CTL_DEFAULT => 2;
  
  use constant CTL_DEST    => 3;
   use constant   CTL_DEST_SCALAR => 0;
   use constant   CTL_DEST_ARRAY  => 1;
   use constant   CTL_DEST_HASH   => 2;
   use constant   CTL_DEST_CODE   => 3;
  
  use constant CTL_AMIN    => 4;
  use constant CTL_AMAX    => 5;
  
  # FFU.
  #use constant CTL_RANGE   => ;
  #use constant CTL_REPEAT  => ;
  
  # Rather liberal patterns to match numbers.
  use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
  use constant PAT_XINT  =>
    "(?:".
  	  "[-+]?_*[1-9][0-9_]*".
    "|".
  	  "0x_*[0-9a-f][0-9a-f_]*".
    "|".
  	  "0b_*[01][01_]*".
    "|".
  	  "0[0-7_]*".
    ")";
  use constant PAT_FLOAT =>
    "[-+]?".			# optional sign
    "(?=[0-9.])".			# must start with digit or dec.point
    "[0-9_]*".			# digits before the dec.point
    "(\.[0-9_]+)?".		# optional fraction
    "([eE][-+]?[0-9_]+)?";	# optional exponent
  
  sub GetOptions(@) {
      # Shift in default array.
      unshift(@_, \@ARGV);
      # Try to keep caller() and Carp consistent.
      goto &GetOptionsFromArray;
  }
  
  sub GetOptionsFromString(@) {
      my ($string) = shift;
      require Text::ParseWords;
      my $args = [ Text::ParseWords::shellwords($string) ];
      $caller ||= (caller)[0];	# current context
      my $ret = GetOptionsFromArray($args, @_);
      return ( $ret, $args ) if wantarray;
      if ( @$args ) {
  	$ret = 0;
  	warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n");
      }
      $ret;
  }
  
  sub GetOptionsFromArray(@) {
  
      my ($argv, @optionlist) = @_;	# local copy of the option descriptions
      my $argend = '--';		# option list terminator
      my %opctl = ();		# table of option specs
      my $pkg = $caller || (caller)[0];	# current context
  				# Needed if linkage is omitted.
      my @ret = ();		# accum for non-options
      my %linkage;		# linkage
      my $userlinkage;		# user supplied HASH
      my $opt;			# current option
      my $prefix = $genprefix;	# current prefix
  
      $error = '';
  
      if ( $debug ) {
  	# Avoid some warnings if debugging.
  	local ($^W) = 0;
  	print STDERR
  	  ("Getopt::Long $Getopt::Long::VERSION ",
  	   "called from package \"$pkg\".",
  	   "\n  ",
  	   "argv: ",
  	   defined($argv)
  	   ? UNIVERSAL::isa( $argv, 'ARRAY' ) ? "(@$argv)" : $argv
  	   : "<undef>",
  	   "\n  ",
  	   "autoabbrev=$autoabbrev,".
  	   "bundling=$bundling,",
  	   "bundling_values=$bundling_values,",
  	   "getopt_compat=$getopt_compat,",
  	   "gnu_compat=$gnu_compat,",
  	   "order=$order,",
  	   "\n  ",
  	   "ignorecase=$ignorecase,",
  	   "requested_version=$requested_version,",
  	   "passthrough=$passthrough,",
  	   "genprefix=\"$genprefix\",",
  	   "longprefix=\"$longprefix\".",
  	   "\n");
      }
  
      # Check for ref HASH as first argument.
      # First argument may be an object. It's OK to use this as long
      # as it is really a hash underneath.
      $userlinkage = undef;
      if ( @optionlist && ref($optionlist[0]) and
  	 UNIVERSAL::isa($optionlist[0],'HASH') ) {
  	$userlinkage = shift (@optionlist);
  	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
      }
  
      # See if the first element of the optionlist contains option
      # starter characters.
      # Be careful not to interpret '<>' as option starters.
      if ( @optionlist && $optionlist[0] =~ /^\W+$/
  	 && !($optionlist[0] eq '<>'
  	      && @optionlist > 0
  	      && ref($optionlist[1])) ) {
  	$prefix = shift (@optionlist);
  	# Turn into regexp. Needs to be parenthesized!
  	$prefix =~ s/(\W)/\\$1/g;
  	$prefix = "([" . $prefix . "])";
  	print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
      }
  
      # Verify correctness of optionlist.
      %opctl = ();
      while ( @optionlist ) {
  	my $opt = shift (@optionlist);
  
  	unless ( defined($opt) ) {
  	    $error .= "Undefined argument in option spec\n";
  	    next;
  	}
  
  	# Strip leading prefix so people can specify "--foo=i" if they like.
  	$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  
  	if ( $opt eq '<>' ) {
  	    if ( (defined $userlinkage)
  		&& !(@optionlist > 0 && ref($optionlist[0]))
  		&& (exists $userlinkage->{$opt})
  		&& ref($userlinkage->{$opt}) ) {
  		unshift (@optionlist, $userlinkage->{$opt});
  	    }
  	    unless ( @optionlist > 0
  		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
  		$error .= "Option spec <> requires a reference to a subroutine\n";
  		# Kill the linkage (to avoid another error).
  		shift (@optionlist)
  		  if @optionlist && ref($optionlist[0]);
  		next;
  	    }
  	    $linkage{'<>'} = shift (@optionlist);
  	    next;
  	}
  
  	# Parse option spec.
  	my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  	unless ( defined $name ) {
  	    # Failed. $orig contains the error message. Sorry for the abuse.
  	    $error .= $orig;
  	    # Kill the linkage (to avoid another error).
  	    shift (@optionlist)
  	      if @optionlist && ref($optionlist[0]);
  	    next;
  	}
  
  	# If no linkage is supplied in the @optionlist, copy it from
  	# the userlinkage if available.
  	if ( defined $userlinkage ) {
  	    unless ( @optionlist > 0 && ref($optionlist[0]) ) {
  		if ( exists $userlinkage->{$orig} &&
  		     ref($userlinkage->{$orig}) ) {
  		    print STDERR ("=> found userlinkage for \"$orig\": ",
  				  "$userlinkage->{$orig}\n")
  			if $debug;
  		    unshift (@optionlist, $userlinkage->{$orig});
  		}
  		else {
  		    # Do nothing. Being undefined will be handled later.
  		    next;
  		}
  	    }
  	}
  
  	# Copy the linkage. If omitted, link to global variable.
  	if ( @optionlist > 0 && ref($optionlist[0]) ) {
  	    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  		if $debug;
  	    my $rl = ref($linkage{$orig} = shift (@optionlist));
  
  	    if ( $rl eq "ARRAY" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  	    }
  	    elsif ( $rl eq "HASH" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
  	    }
  	    elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
  #		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  #		    my $t = $linkage{$orig};
  #		    $$t = $linkage{$orig} = [];
  #		}
  #		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  #		}
  #		else {
  		    # Ok.
  #		}
  	    }
  	    elsif ( $rl eq "CODE" ) {
  		# Ok.
  	    }
  	    else {
  		$error .= "Invalid option linkage for \"$opt\"\n";
  	    }
  	}
  	else {
  	    # Link to global $opt_XXX variable.
  	    # Make sure a valid perl identifier results.
  	    my $ov = $orig;
  	    $ov =~ s/\W/_/g;
  	    if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  		print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;");
  	    }
  	    elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  		print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
  	    }
  	    else {
  		print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
  	    }
  	}
  
  	if ( $opctl{$name}[CTL_TYPE] eq 'I'
  	     && ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY
  		  || $opctl{$name}[CTL_DEST] == CTL_DEST_HASH )
  	   ) {
  	    $error .= "Invalid option linkage for \"$opt\"\n";
  	}
  
      }
  
      $error .= "GetOptionsFromArray: 1st parameter is not an array reference\n"
        unless $argv && UNIVERSAL::isa( $argv, 'ARRAY' );
  
      # Bail out if errors found.
      die ($error) if $error;
      $error = 0;
  
      # Supply --version and --help support, if needed and allowed.
      if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{version}) ) {
  	    $opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
  	    $linkage{version} = \&VersionMessage;
  	}
  	$auto_version = 1;
      }
      if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
  	    $opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
  	    $linkage{help} = \&HelpMessage;
  	}
  	$auto_help = 1;
      }
  
      # Show the options tables if debugging.
      if ( $debug ) {
  	my ($arrow, $k, $v);
  	$arrow = "=> ";
  	while ( ($k,$v) = each(%opctl) ) {
  	    print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
  	    $arrow = "   ";
  	}
      }
  
      # Process argument list
      my $goon = 1;
      while ( $goon && @$argv > 0 ) {
  
  	# Get next argument.
  	$opt = shift (@$argv);
  	print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  
  	# Double dash is option list terminator.
  	if ( defined($opt) && $opt eq $argend ) {
  	  push (@ret, $argend) if $passthrough;
  	  last;
  	}
  
  	# Look it up.
  	my $tryopt = $opt;
  	my $found;		# success status
  	my $key;		# key (if hash type)
  	my $arg;		# option argument
  	my $ctl;		# the opctl entry
  
  	($found, $opt, $ctl, $arg, $key) =
  	  FindOption ($argv, $prefix, $argend, $opt, \%opctl);
  
  	if ( $found ) {
  
  	    # FindOption undefines $opt in case of errors.
  	    next unless defined $opt;
  
  	    my $argcnt = 0;
  	    while ( defined $arg ) {
  
  		# Get the canonical name.
  		print STDERR ("=> cname for \"$opt\" is ") if $debug;
  		$opt = $ctl->[CTL_CNAME];
  		print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  
  		if ( defined $linkage{$opt} ) {
  		    print STDERR ("=> ref(\$L{$opt}) -> ",
  				  ref($linkage{$opt}), "\n") if $debug;
  
  		    if ( ref($linkage{$opt}) eq 'SCALAR'
  			 || ref($linkage{$opt}) eq 'REF' ) {
  			if ( $ctl->[CTL_TYPE] eq '+' ) {
  			    print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
  			      if $debug;
  			    if ( defined ${$linkage{$opt}} ) {
  			        ${$linkage{$opt}} += $arg;
  			    }
  		            else {
  			        ${$linkage{$opt}} = $arg;
  			    }
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to ARRAY\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = [];
  			    print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			      if $debug;
  			    push (@{$linkage{$opt}}, $arg);
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to HASH\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = {};
  			    print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			      if $debug;
  			    $linkage{$opt}->{$key} = $arg;
  			}
  			else {
  			    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  			      if $debug;
  			    ${$linkage{$opt}} = $arg;
  		        }
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
  			print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			    if $debug;
  			push (@{$linkage{$opt}}, $arg);
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
  			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$linkage{$opt}->{$key} = $arg;
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
  			print STDERR ("=> &L{$opt}(\"$opt\"",
  				      $ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
  				      ", \"$arg\")\n")
  			    if $debug;
  			my $eval_error = do {
  			    local $@;
  			    local $SIG{__DIE__}  = 'DEFAULT';
  			    eval {
  				&{$linkage{$opt}}
  				  (Getopt::Long::CallBack->new
  				   (name    => $opt,
  				    ctl     => $ctl,
  				    opctl   => \%opctl,
  				    linkage => \%linkage,
  				    prefix  => $prefix,
  				   ),
  				   $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
  				   $arg);
  			    };
  			    $@;
  			};
  			print STDERR ("=> die($eval_error)\n")
  			  if $debug && $eval_error ne '';
  			if ( $eval_error =~ /^!/ ) {
  			    if ( $eval_error =~ /^!FINISH\b/ ) {
  				$goon = 0;
  			    }
  			}
  			elsif ( $eval_error ne '' ) {
  			    warn ($eval_error);
  			    $error++;
  			}
  		    }
  		    else {
  			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
  				      "\" in linkage\n");
  			die("Getopt::Long -- internal error!\n");
  		    }
  		}
  		# No entry in linkage means entry in userlinkage.
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")
  			    if $debug;
  			push (@{$userlinkage->{$opt}}, $arg);
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
  			    if $debug;
  			$userlinkage->{$opt} = [$arg];
  		    }
  		}
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$userlinkage->{$opt}->{$key} = $arg;
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
  			    if $debug;
  			$userlinkage->{$opt} = {$key => $arg};
  		    }
  		}
  		else {
  		    if ( $ctl->[CTL_TYPE] eq '+' ) {
  			print STDERR ("=> \$L{$opt} += \"$arg\"\n")
  			  if $debug;
  			if ( defined $userlinkage->{$opt} ) {
  			    $userlinkage->{$opt} += $arg;
  			}
  			else {
  			    $userlinkage->{$opt} = $arg;
  			}
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
  			$userlinkage->{$opt} = $arg;
  		    }
  		}
  
  		$argcnt++;
  		last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  		undef($arg);
  
  		# Need more args?
  		if ( $argcnt < $ctl->[CTL_AMIN] ) {
  		    if ( @$argv ) {
  			if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
  			    $arg = shift(@$argv);
  			    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  				$arg =~ tr/_//d;
  				$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  				  ? oct($arg)
  				  : 0+$arg
  			    }
  			    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  			      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  			    next;
  			}
  			warn("Value \"$$argv[0]\" invalid for option $opt\n");
  			$error++;
  		    }
  		    else {
  			warn("Insufficient arguments for option $opt\n");
  			$error++;
  		    }
  		}
  
  		# Any more args?
  		if ( @$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
  		    $arg = shift(@$argv);
  		    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  			$arg =~ tr/_//d;
  			$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  			  ? oct($arg)
  			  : 0+$arg
  		    }
  		    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  		      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  		    next;
  		}
  	    }
  	}
  
  	# Not an option. Save it if we $PERMUTE and don't have a <>.
  	elsif ( $order == $PERMUTE ) {
  	    # Try non-options call-back.
  	    my $cb;
  	    if ( defined ($cb = $linkage{'<>'}) ) {
  		print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
  		  if $debug;
  		my $eval_error = do {
  		    local $@;
  		    local $SIG{__DIE__}  = 'DEFAULT';
  		    eval {
  			# The arg to <> cannot be the CallBack object
  			# since it may be passed to other modules that
  			# get confused (e.g., Archive::Tar). Well,
  			# it's not relevant for this callback anyway.
  			&$cb($tryopt);
  		    };
  		    $@;
  		};
  		print STDERR ("=> die($eval_error)\n")
  		  if $debug && $eval_error ne '';
  		if ( $eval_error =~ /^!/ ) {
  		    if ( $eval_error =~ /^!FINISH\b/ ) {
  			$goon = 0;
  		    }
  		}
  		elsif ( $eval_error ne '' ) {
  		    warn ($eval_error);
  		    $error++;
  		}
  	    }
  	    else {
  		print STDERR ("=> saving \"$tryopt\" ",
  			      "(not an option, may permute)\n") if $debug;
  		push (@ret, $tryopt);
  	    }
  	    next;
  	}
  
  	# ...otherwise, terminate.
  	else {
  	    # Push this one back and exit.
  	    unshift (@$argv, $tryopt);
  	    return ($error == 0);
  	}
  
      }
  
      # Finish.
      if ( @ret && $order == $PERMUTE ) {
  	#  Push back accumulated arguments
  	print STDERR ("=> restoring \"", join('" "', @ret), "\"\n")
  	    if $debug;
  	unshift (@$argv, @ret);
      }
  
      return ($error == 0);
  }
  
  # A readable representation of what's in an optbl.
  sub OptCtl ($) {
      my ($v) = @_;
      my @v = map { defined($_) ? ($_) : ("<undef>") } @$v;
      "[".
        join(",",
  	   "\"$v[CTL_TYPE]\"",
  	   "\"$v[CTL_CNAME]\"",
  	   "\"$v[CTL_DEFAULT]\"",
  	   ("\$","\@","\%","\&")[$v[CTL_DEST] || 0],
  	   $v[CTL_AMIN] || '',
  	   $v[CTL_AMAX] || '',
  #	   $v[CTL_RANGE] || '',
  #	   $v[CTL_REPEAT] || '',
  	  ). "]";
  }
  
  # Parse an option specification and fill the tables.
  sub ParseOptionSpec ($$) {
      my ($opt, $opctl) = @_;
  
      # Match option spec.
      if ( $opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Alias names, or "?"
  		     (?: \| (?: \? | \w[-\w]* ) )*
  		     # Aliases
  		     (?: \| (?: [^-|!+=:][^|!+=:]* )? )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x ) {
  	return (undef, "Error in option spec: \"$opt\"\n");
      }
  
      my ($names, $spec) = ($1, $2);
      $spec = '' unless defined $spec;
  
      # $orig keeps track of the primary name the user specified.
      # This name will be used for the internal or external linkage.
      # In other words, if the user specifies "FoO|BaR", it will
      # match any case combinations of 'foo' and 'bar', but if a global
      # variable needs to be set, it will be $opt_FoO in the exact case
      # as specified.
      my $orig;
  
      my @names;
      if ( defined $names ) {
  	@names =  split (/\|/, $names);
  	$orig = $names[0];
      }
      else {
  	@names = ('');
  	$orig = '';
      }
  
      # Construct the opctl entries.
      my $entry;
      if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
  	# Fields are hard-wired here.
  	$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
      }
      elsif ( $spec =~ /^:(-?\d+|\+)([@%])?$/ ) {
  	my $def = $1;
  	my $dest = $2;
  	my $type = $def eq '+' ? 'I' : 'i';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,$def eq '+' ? undef : $def,
  		  $dest,0,1];
      }
      else {
  	my ($mand, $type, $dest) =
  	  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
  	return (undef, "Cannot repeat while bundling: \"$opt\"\n")
  	  if $bundling && defined($4);
  	my ($mi, $cm, $ma) = ($5, $6, $7);
  	return (undef, "{0} is useless in option spec: \"$opt\"\n")
  	  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
  
  	$type = 'i' if $type eq 'n';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Default minargs to 1/0 depending on mand status.
  	$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
  	# Adjust mand status according to minargs.
  	$mand = $mi ? '=' : ':';
  	# Adjust maxargs.
  	$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
  	return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
  	  if defined($ma) && !$ma;
  	return (undef, "Max less than min in option spec: \"$opt\"\n")
  	  if defined($ma) && $ma < $mi;
  
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
      }
  
      # Process all names. First is canonical, the rest are aliases.
      my $dups = '';
      foreach ( @names ) {
  
  	$_ = lc ($_)
  	  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
  
  	if ( exists $opctl->{$_} ) {
  	    $dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
  	}
  
  	if ( $spec eq '!' ) {
  	    $opctl->{"no$_"} = $entry;
  	    $opctl->{"no-$_"} = $entry;
  	    $opctl->{$_} = [@$entry];
  	    $opctl->{$_}->[CTL_TYPE] = '';
  	}
  	else {
  	    $opctl->{$_} = $entry;
  	}
      }
  
      if ( $dups && $^W ) {
  	foreach ( split(/\n+/, $dups) ) {
  	    warn($_."\n");
  	}
      }
      ($names[0], $orig);
  }
  
  # Option lookup.
  sub FindOption ($$$$$) {
  
      # returns (1, $opt, $ctl, $arg, $key) if okay,
      # returns (1, undef) if option in error,
      # returns (0) otherwise.
  
      my ($argv, $prefix, $argend, $opt, $opctl) = @_;
  
      print STDERR ("=> find \"$opt\"\n") if $debug;
  
      return (0) unless defined($opt);
      return (0) unless $opt =~ /^($prefix)(.*)$/s;
      return (0) if $opt eq "-" && !defined $opctl->{''};
  
      $opt = substr( $opt, length($1) ); # retain taintedness
      my $starter = $1;
  
      print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
  
      my $optarg;			# value supplied with --opt=value
      my $rest;			# remainder from unbundling
  
      # If it is a long option, it may include the value.
      # With getopt_compat, only if not bundling.
      if ( ($starter=~/^$longprefix$/
  	  || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
  	 && (my $oppos = index($opt, '=', 1)) > 0) {
  	my $optorg = $opt;
  	$opt = substr($optorg, 0, $oppos);
  	$optarg = substr($optorg, $oppos + 1); # retain tainedness
  	print STDERR ("=> option \"", $opt,
  		      "\", optarg = \"$optarg\"\n") if $debug;
      }
  
      #### Look it up ###
  
      my $tryopt = $opt;		# option to try
  
      if ( ( $bundling || $bundling_values ) && $starter eq '-' ) {
  
  	# To try overrides, obey case ignore.
  	$tryopt = $ignorecase ? lc($opt) : $opt;
  
  	# If bundling == 2, long options can override bundles.
  	if ( $bundling == 2 && length($tryopt) > 1
  	     && defined ($opctl->{$tryopt}) ) {
  	    print STDERR ("=> $starter$tryopt overrides unbundling\n")
  	      if $debug;
  	}
  
  	# If bundling_values, option may be followed by the value.
  	elsif ( $bundling_values ) {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    # Whatever remains may not be considered an option.
  	    $optarg = $rest eq '' ? undef : $rest;
  	    $rest = undef;
  	}
  
  	# Split off a single letter and leave the rest for
  	# further processing.
  	else {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    $rest = undef unless $rest ne '';
  	}
      }
  
      # Try auto-abbreviation.
      elsif ( $autoabbrev && $opt ne "" ) {
  	# Sort the possible long option names.
  	my @names = sort(keys (%$opctl));
  	# Downcase if allowed.
  	$opt = lc ($opt) if $ignorecase;
  	$tryopt = $opt;
  	# Turn option name into pattern.
  	my $pat = quotemeta ($opt);
  	# Look up in option names.
  	my @hits = grep (/^$pat/, @names);
  	print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
  		      "out of ", scalar(@names), "\n") if $debug;
  
  	# Check for ambiguous results.
  	unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
  	    # See if all matches are for the same option.
  	    my %hit;
  	    foreach ( @hits ) {
  		my $hit = $opctl->{$_}->[CTL_CNAME]
  		  if defined $opctl->{$_}->[CTL_CNAME];
  		$hit = "no" . $hit if $opctl->{$_}->[CTL_TYPE] eq '!';
  		$hit{$hit} = 1;
  	    }
  	    # Remove auto-supplied options (version, help).
  	    if ( keys(%hit) == 2 ) {
  		if ( $auto_version && exists($hit{version}) ) {
  		    delete $hit{version};
  		}
  		elsif ( $auto_help && exists($hit{help}) ) {
  		    delete $hit{help};
  		}
  	    }
  	    # Now see if it really is ambiguous.
  	    unless ( keys(%hit) == 1 ) {
  		return (0) if $passthrough;
  		warn ("Option ", $opt, " is ambiguous (",
  		      join(", ", @hits), ")\n");
  		$error++;
  		return (1, undef);
  	    }
  	    @hits = keys(%hit);
  	}
  
  	# Complete the option name, if appropriate.
  	if ( @hits == 1 && $hits[0] ne $opt ) {
  	    $tryopt = $hits[0];
  	    $tryopt = lc ($tryopt)
  	      if $ignorecase > (($bundling && length($tryopt) == 1) ? 1 : 0);
  	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
  		if $debug;
  	}
      }
  
      # Map to all lowercase if ignoring case.
      elsif ( $ignorecase ) {
  	$tryopt = lc ($opt);
      }
  
      # Check validity by fetching the info.
      my $ctl = $opctl->{$tryopt};
      unless  ( defined $ctl ) {
  	return (0) if $passthrough;
  	# Pretend one char when bundling.
  	if ( $bundling == 1 && length($starter) == 1 ) {
  	    $opt = substr($opt,0,1);
              unshift (@$argv, $starter.$rest) if defined $rest;
  	}
  	if ( $opt eq "" ) {
  	    warn ("Missing option after ", $starter, "\n");
  	}
  	else {
  	    warn ("Unknown option: ", $opt, "\n");
  	}
  	$error++;
  	return (1, undef);
      }
      # Apparently valid.
      $opt = $tryopt;
      print STDERR ("=> found ", OptCtl($ctl),
  		  " for \"", $opt, "\"\n") if $debug;
  
      #### Determine argument status ####
  
      # If it is an option w/o argument, we're almost finished with it.
      my $type = $ctl->[CTL_TYPE];
      my $arg;
  
      if ( $type eq '' || $type eq '!' || $type eq '+' ) {
  	if ( defined $optarg ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " does not take an argument\n");
  	    $error++;
  	    undef $opt;
  	    undef $optarg if $bundling_values;
  	}
  	elsif ( $type eq '' || $type eq '+' ) {
  	    # Supply explicit value.
  	    $arg = 1;
  	}
  	else {
  	    $opt =~ s/^no-?//i;	# strip NO prefix
  	    $arg = 0;		# supply explicit value
  	}
  	unshift (@$argv, $starter.$rest) if defined $rest;
  	return (1, $opt, $ctl, $arg);
      }
  
      # Get mandatory status and type info.
      my $mand = $ctl->[CTL_AMIN];
  
      # Check if there is an option argument available.
      if ( $gnu_compat ) {
  	my $optargtype = 0; # none, 1 = empty, 2 = nonempty, 3 = aux
  	if ( defined($optarg) ) {
  	    $optargtype = (length($optarg) == 0) ? 1 : 2;
  	}
  	elsif ( defined $rest || @$argv > 0 ) {
  	    # GNU getopt_long() does not accept the (optional)
  	    # argument to be passed to the option without = sign.
  	    # We do, since not doing so breaks existing scripts.
  	    $optargtype = 3;
  	}
  	if(($optargtype == 0) && !$mand) {
  	    my $val
  	      = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT]
  	      : $type eq 's'                 ? ''
  	      :                                0;
  	    return (1, $opt, $ctl, $val);
  	}
  	return (1, $opt, $ctl, $type eq 's' ? '' : 0)
  	  if $optargtype == 1;  # --foo=  -> return nothing
      }
  
      # Check if there is an option argument available.
      if ( defined $optarg
  	 ? ($optarg eq '')
  	 : !(defined $rest || @$argv > 0) ) {
  	# Complain if this option needs an argument.
  #	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
  	if ( $mand ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " requires an argument\n");
  	    $error++;
  	    return (1, undef);
  	}
  	if ( $type eq 'I' ) {
  	    # Fake incremental type.
  	    my @c = @$ctl;
  	    $c[CTL_TYPE] = '+';
  	    return (1, $opt, \@c, 1);
  	}
  	return (1, $opt, $ctl,
  		defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  		$type eq 's' ? '' : 0);
      }
  
      # Get (possibly optional) argument.
      $arg = (defined $rest ? $rest
  	    : (defined $optarg ? $optarg : shift (@$argv)));
  
      # Get key if this is a "name=value" pair for a hash option.
      my $key;
      if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
  	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
  	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  	     ($mand ? undef : ($type eq 's' ? "" : 1)));
  	if (! defined $arg) {
  	    warn ("Option $opt, key \"$key\", requires a value\n");
  	    $error++;
  	    # Push back.
  	    unshift (@$argv, $starter.$rest) if defined $rest;
  	    return (1, undef);
  	}
      }
  
      #### Check if the argument is valid for this option ####
  
      my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1, $opt, $ctl, $arg, $key) if $mand;
  
  	# Same for optional string as a hash value
  	return (1, $opt, $ctl, $arg, $key)
  	  if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  
  	# An optional string takes almost anything.
  	return (1, $opt, $ctl, $arg, $key)
  	  if defined $optarg || defined $rest;
  	return (1, $opt, $ctl, $arg, $key) if $arg eq "-"; # ??
  
  	# Check for option or option list terminator.
  	if ($arg eq $argend ||
  	    $arg =~ /^$prefix.+/) {
  	    # Push back.
  	    unshift (@$argv, $arg);
  	    # Supply empty value.
  	    $arg = '';
  	}
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  
  	if ( $bundling && defined $rest
  	     && $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/si ) {
  	    $arg =~ tr/_//d;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (",
  		      $type eq 'o' ? "extended " : '',
  		      "number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		if ( $type eq 'I' ) {
  		    # Fake incremental type.
  		    my @c = @$ctl;
  		    $c[CTL_TYPE] = '+';
  		    return (1, $opt, \@c, 1);
  		}
  		# Supply default value.
  		$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
  	    }
  	}
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	if ( $bundling && defined $rest &&
  	     $rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
  	    $arg =~ tr/_//d;
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/ ) {
  	    $arg =~ tr/_//d;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (real number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		# Supply default value.
  		$arg = 0.0;
  	    }
  	}
      }
      else {
  	die("Getopt::Long internal error (Can't happen)\n");
      }
      return (1, $opt, $ctl, $arg, $key);
  }
  
  sub ValidValue ($$$$$) {
      my ($ctl, $arg, $mand, $argend, $prefix) = @_;
  
      if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  	return 0 unless $arg =~ /[^=]+=(.*)/;
  	$arg = $1;
      }
  
      my $type = $ctl->[CTL_TYPE];
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1) if $mand;
  
  	return (1) if $arg eq "-";
  
  	# Check for option or option list terminator.
  	return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
  	return 1;
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  	return $arg =~ /^$o_valid$/si;
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	return $arg =~ /^$o_valid$/;
      }
      die("ValidValue: Cannot happen\n");
  }
  
  # Getopt::Long Configuration.
  sub Configure (@) {
      my (@options) = @_;
  
      my $prevconfig =
        [ $error, $debug, $major_version, $minor_version, $caller,
  	$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	$longprefix, $bundling_values ];
  
      if ( ref($options[0]) eq 'ARRAY' ) {
  	( $error, $debug, $major_version, $minor_version, $caller,
  	  $autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	  $longprefix, $bundling_values ) = @{shift(@options)};
      }
  
      my $opt;
      foreach $opt ( @options ) {
  	my $try = lc ($opt);
  	my $action = 1;
  	if ( $try =~ /^no_?(.*)$/s ) {
  	    $action = 0;
  	    $try = $+;
  	}
  	if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
  	    ConfigDefaults ();
  	}
  	elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
  	    local $ENV{POSIXLY_CORRECT};
  	    $ENV{POSIXLY_CORRECT} = 1 if $action;
  	    ConfigDefaults ();
  	}
  	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
  	    $autoabbrev = $action;
  	}
  	elsif ( $try eq 'getopt_compat' ) {
  	    $getopt_compat = $action;
              $genprefix = $action ? "(--|-|\\+)" : "(--|-)";
  	}
  	elsif ( $try eq 'gnu_getopt' ) {
  	    if ( $action ) {
  		$gnu_compat = 1;
  		$bundling = 1;
  		$getopt_compat = 0;
                  $genprefix = "(--|-)";
  		$order = $PERMUTE;
  		$bundling_values = 0;
  	    }
  	}
  	elsif ( $try eq 'gnu_compat' ) {
  	    $gnu_compat = $action;
  	    $bundling = 0;
  	    $bundling_values = 1;
  	}
  	elsif ( $try =~ /^(auto_?)?version$/ ) {
  	    $auto_version = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?help$/ ) {
  	    $auto_help = $action;
  	}
  	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
  	    $ignorecase = $action;
  	}
  	elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
  	    $ignorecase = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'bundling' ) {
  	    $bundling = $action;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_override' ) {
  	    $bundling = $action ? 2 : 0;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_values' ) {
  	    $bundling_values = $action;
  	    $bundling = 0 if $action;
  	}
  	elsif ( $try eq 'require_order' ) {
  	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
  	}
  	elsif ( $try eq 'permute' ) {
  	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
  	}
  	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
  	    $passthrough = $action;
  	}
  	elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Turn into regexp. Needs to be parenthesized!
  	    $genprefix = "(" . quotemeta($genprefix) . ")";
  	    eval { '' =~ /$genprefix/; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Parenthesize if needed.
  	    $genprefix = "(" . $genprefix . ")"
  	      unless $genprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$genprefix"; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
  	    $longprefix = $1;
  	    # Parenthesize if needed.
  	    $longprefix = "(" . $longprefix . ")"
  	      unless $longprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$longprefix"; };
  	    die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n") if $@;
  	}
  	elsif ( $try eq 'debug' ) {
  	    $debug = $action;
  	}
  	else {
  	    die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")
  	}
      }
      $prevconfig;
  }
  
  # Deprecated name.
  sub config (@) {
      Configure (@_);
  }
  
  # Issue a standard message for --version.
  #
  # The arguments are mostly the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub VersionMessage(@) {
      # Massage args.
      my $pa = setup_pa_args("version", @_);
  
      my $v = $main::VERSION;
      my $fh = $pa->{-output} ||
        ( ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR );
  
      print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
  	       $0, defined $v ? " version $v" : (),
  	       "\n",
  	       "(", __PACKAGE__, "::", "GetOptions",
  	       " version ",
  	       defined($Getopt::Long::VERSION_STRING)
  	         ? $Getopt::Long::VERSION_STRING : $VERSION, ";",
  	       " Perl version ",
  	       $] >= 5.006 ? sprintf("%vd", $^V) : $],
  	       ")\n");
      exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
  }
  
  # Issue a standard message for --help.
  #
  # The arguments are the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub HelpMessage(@) {
      eval {
  	require Pod::Usage;
  	import Pod::Usage;
  	1;
      } || die("Cannot provide help: cannot load Pod::Usage\n");
  
      # Note that pod2usage will issue a warning if -exitval => NOEXIT.
      pod2usage(setup_pa_args("help", @_));
  
  }
  
  # Helper routine to set up a normalized hash ref to be used as
  # argument to pod2usage.
  sub setup_pa_args($@) {
      my $tag = shift;		# who's calling
  
      # If called by direct binding to an option, it will get the option
      # name and value as arguments. Remove these, if so.
      @_ = () if @_ == 2 && $_[0] eq $tag;
  
      my $pa;
      if ( @_ > 1 ) {
  	$pa = { @_ };
      }
      else {
  	$pa = shift || {};
      }
  
      # At this point, $pa can be a number (exit value), string
      # (message) or hash with options.
  
      if ( UNIVERSAL::isa($pa, 'HASH') ) {
  	# Get rid of -msg vs. -message ambiguity.
  	$pa->{-message} = $pa->{-msg};
  	delete($pa->{-msg});
      }
      elsif ( $pa =~ /^-?\d+$/ ) {
  	$pa = { -exitval => $pa };
      }
      else {
  	$pa = { -message => $pa };
      }
  
      # These are _our_ defaults.
      $pa->{-verbose} = 0 unless exists($pa->{-verbose});
      $pa->{-exitval} = 0 unless exists($pa->{-exitval});
      $pa;
  }
  
  # Sneak way to know what version the user requested.
  sub VERSION {
      $requested_version = $_[1];
      shift->SUPER::VERSION(@_);
  }
  
  package Getopt::Long::CallBack;
  
  sub new {
      my ($pkg, %atts) = @_;
      bless { %atts }, $pkg;
  }
  
  sub name {
      my $self = shift;
      ''.$self->{name};
  }
  
  use overload
    # Treat this object as an ordinary string for legacy API.
    '""'	   => \&name,
    fallback => 1;
  
  1;
  
  ################ Documentation ################
  
  =head1 NAME
  
  Getopt::Long - Extended processing of command line options
  
  =head1 SYNOPSIS
  
    use Getopt::Long;
    my $data   = "file.dat";
    my $length = 24;
    my $verbose;
    GetOptions ("length=i" => \$length,    # numeric
                "file=s"   => \$data,      # string
                "verbose"  => \$verbose)   # flag
    or die("Error in command line arguments\n");
  
  =head1 DESCRIPTION
  
  The Getopt::Long module implements an extended getopt function called
  GetOptions(). It parses the command line from C<@ARGV>, recognizing
  and removing specified options and their possible values.
  
  This function adheres to the POSIX syntax for command
  line options, with GNU extensions. In general, this means that options
  have long names instead of single letters, and are introduced with a
  double dash "--". Support for bundling of command line options, as was
  the case with the more traditional single-letter approach, is provided
  but not enabled by default.
  
  =head1 Command Line Options, an Introduction
  
  Command line operated programs traditionally take their arguments from
  the command line, for example filenames or other information that the
  program needs to know. Besides arguments, these programs often take
  command line I<options> as well. Options are not necessary for the
  program to work, hence the name 'option', but are used to modify its
  default behaviour. For example, a program could do its job quietly,
  but with a suitable option it could provide verbose information about
  what it did.
  
  Command line options come in several flavours. Historically, they are
  preceded by a single dash C<->, and consist of a single letter.
  
      -l -a -c
  
  Usually, these single-character options can be bundled:
  
      -lac
  
  Options can have values, the value is placed after the option
  character. Sometimes with whitespace in between, sometimes not:
  
      -s 24 -s24
  
  Due to the very cryptic nature of these options, another style was
  developed that used long names. So instead of a cryptic C<-l> one
  could use the more descriptive C<--long>. To distinguish between a
  bundle of single-character options and a long one, two dashes are used
  to precede the option name. Early implementations of long options used
  a plus C<+> instead. Also, option values could be specified either
  like
  
      --size=24
  
  or
  
      --size 24
  
  The C<+> form is now obsolete and strongly deprecated.
  
  =head1 Getting Started with Getopt::Long
  
  Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was the
  first Perl module that provided support for handling the new style of
  command line options, in particular long option names, hence the Perl5
  name Getopt::Long. This module also supports single-character options
  and bundling.
  
  To use Getopt::Long from a Perl program, you must include the
  following line in your Perl program:
  
      use Getopt::Long;
  
  This will load the core of the Getopt::Long module and prepare your
  program for using it. Most of the actual Getopt::Long code is not
  loaded until you really call one of its functions.
  
  In the default configuration, options names may be abbreviated to
  uniqueness, case does not matter, and a single dash is sufficient,
  even for long option names. Also, options may be placed between
  non-option arguments. See L<Configuring Getopt::Long> for more
  details on how to configure Getopt::Long.
  
  =head2 Simple options
  
  The most simple options are the ones that take no values. Their mere
  presence on the command line enables the option. Popular examples are:
  
      --all --verbose --quiet --debug
  
  Handling simple options is straightforward:
  
      my $verbose = '';	# option variable with default value (false)
      my $all = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose, 'all' => \$all);
  
  The call to GetOptions() parses the command line arguments that are
  present in C<@ARGV> and sets the option variable to the value C<1> if
  the option did occur on the command line. Otherwise, the option
  variable is not touched. Setting the option value to true is often
  called I<enabling> the option.
  
  The option name as specified to the GetOptions() function is called
  the option I<specification>. Later we'll see that this specification
  can contain more than just the option name. The reference to the
  variable is called the option I<destination>.
  
  GetOptions() will return a true value if the command line could be
  processed successfully. Otherwise, it will write error messages using
  die() and warn(), and return a false result.
  
  =head2 A little bit less simple options
  
  Getopt::Long supports two useful variants of simple options:
  I<negatable> options and I<incremental> options.
  
  A negatable option is specified with an exclamation mark C<!> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose!' => \$verbose);
  
  Now, using C<--verbose> on the command line will enable C<$verbose>,
  as expected. But it is also allowed to use C<--noverbose>, which will
  disable C<$verbose> by setting its value to C<0>. Using a suitable
  default value, the program can find out whether C<$verbose> is false
  by default, or disabled by using C<--noverbose>.
  
  An incremental option is specified with a plus C<+> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose+' => \$verbose);
  
  Using C<--verbose> on the command line will increment the value of
  C<$verbose>. This way the program can keep track of how many times the
  option occurred on the command line. For example, each occurrence of
  C<--verbose> could increase the verbosity level of the program.
  
  =head2 Mixing command line option with other arguments
  
  Usually programs take command line options as well as other arguments,
  for example, file names. It is good practice to always specify the
  options first, and the other arguments last. Getopt::Long will,
  however, allow the options and arguments to be mixed and 'filter out'
  all the options before passing the rest of the arguments to the
  program. To stop Getopt::Long from processing further arguments,
  insert a double dash C<--> on the command line:
  
      --size 24 -- --all
  
  In this example, C<--all> will I<not> be treated as an option, but
  passed to the program unharmed, in C<@ARGV>.
  
  =head2 Options with values
  
  For options that take values it must be specified whether the option
  value is required or not, and what kind of value the option expects.
  
  Three kinds of values are supported: integer numbers, floating point
  numbers, and strings.
  
  If the option value is required, Getopt::Long will take the
  command line argument that follows the option and assign this to the
  option variable. If, however, the option value is specified as
  optional, this will only be done if that value does not look like a
  valid command line option itself.
  
      my $tag = '';	# option variable with default value
      GetOptions ('tag=s' => \$tag);
  
  In the option specification, the option name is followed by an equals
  sign C<=> and the letter C<s>. The equals sign indicates that this
  option requires a value. The letter C<s> indicates that this value is
  an arbitrary string. Other possible value types are C<i> for integer
  values, and C<f> for floating point values. Using a colon C<:> instead
  of the equals sign indicates that the option value is optional. In
  this case, if no suitable value is supplied, string valued options get
  an empty string C<''> assigned, while numeric options are set to C<0>.
  
  =head2 Options with multiple values
  
  Options sometimes take several values. For example, a program could
  use multiple directories to search for library files:
  
      --library lib/stdlib --library lib/extlib
  
  To accomplish this behaviour, simply specify an array reference as the
  destination for the option:
  
      GetOptions ("library=s" => \@libfiles);
  
  Alternatively, you can specify that the option can have multiple
  values by adding a "@", and pass a reference to a scalar as the
  destination:
  
      GetOptions ("library=s@" => \$libfiles);
  
  Used with the example above, C<@libfiles> c.q. C<@$libfiles> would
  contain two strings upon completion: C<"lib/stdlib"> and
  C<"lib/extlib">, in that order. It is also possible to specify that
  only integer or floating point numbers are acceptable values.
  
  Often it is useful to allow comma-separated lists of values as well as
  multiple occurrences of the options. This is easy using Perl's split()
  and join() operators:
  
      GetOptions ("library=s" => \@libfiles);
      @libfiles = split(/,/,join(',',@libfiles));
  
  Of course, it is important to choose the right separator string for
  each purpose.
  
  Warning: What follows is an experimental feature.
  
  Options can take multiple values at once, for example
  
      --coordinates 52.2 16.4 --rgbcolor 255 255 149
  
  This can be accomplished by adding a repeat specifier to the option
  specification. Repeat specifiers are very similar to the C<{...}>
  repeat specifiers that can be used with regular expression patterns.
  For example, the above command line would be handled as follows:
  
      GetOptions('coordinates=f{2}' => \@coor, 'rgbcolor=i{3}' => \@color);
  
  The destination for the option must be an array or array reference.
  
  It is also possible to specify the minimal and maximal number of
  arguments an option takes. C<foo=s{2,4}> indicates an option that
  takes at least two and at most 4 arguments. C<foo=s{1,}> indicates one
  or more values; C<foo:s{,}> indicates zero or more option values.
  
  =head2 Options with hash values
  
  If the option destination is a reference to a hash, the option will
  take, as value, strings of the form I<key>C<=>I<value>. The value will
  be stored with the specified key in the hash.
  
      GetOptions ("define=s" => \%defines);
  
  Alternatively you can use:
  
      GetOptions ("define=s%" => \$defines);
  
  When used with command line options:
  
      --define os=linux --define vendor=redhat
  
  the hash C<%defines> (or C<%$defines>) will contain two keys, C<"os">
  with value C<"linux"> and C<"vendor"> with value C<"redhat">. It is
  also possible to specify that only integer or floating point numbers
  are acceptable values. The keys are always taken to be strings.
  
  =head2 User-defined subroutines to handle options
  
  Ultimate control over what should be done when (actually: each time)
  an option is encountered on the command line can be achieved by
  designating a reference to a subroutine (or an anonymous subroutine)
  as the option destination. When GetOptions() encounters the option, it
  will call the subroutine with two or three arguments. The first
  argument is the name of the option. (Actually, it is an object that
  stringifies to the name of the option.) For a scalar or array destination,
  the second argument is the value to be stored. For a hash destination,
  the second argument is the key to the hash, and the third argument
  the value to be stored. It is up to the subroutine to store the value,
  or do whatever it thinks is appropriate.
  
  A trivial application of this mechanism is to implement options that
  are related to each other. For example:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose,
  	        'quiet'   => sub { $verbose = 0 });
  
  Here C<--verbose> and C<--quiet> control the same variable
  C<$verbose>, but with opposite values.
  
  If the subroutine needs to signal an error, it should call die() with
  the desired error message as its argument. GetOptions() will catch the
  die(), issue the error message, and record that an error result must
  be returned upon completion.
  
  If the text of the error message starts with an exclamation mark C<!>
  it is interpreted specially by GetOptions(). There is currently one
  special command implemented: C<die("!FINISH")> will cause GetOptions()
  to stop processing options, as if it encountered a double dash C<-->.
  
  In version 2.37 the first argument to the callback function was
  changed from string to object. This was done to make room for
  extensions and more detailed control. The object stringifies to the
  option name so this change should not introduce compatibility
  problems.
  
  Here is an example of how to access the option name and value from within
  a subroutine:
  
      GetOptions ('opt=i' => \&handler);
      sub handler {
          my ($opt_name, $opt_value) = @_;
          print("Option name is $opt_name and value is $opt_value\n");
      }
  
  =head2 Options with multiple names
  
  Often it is user friendly to supply alternate mnemonic names for
  options. For example C<--height> could be an alternate name for
  C<--length>. Alternate names can be included in the option
  specification, separated by vertical bar C<|> characters. To implement
  the above example:
  
      GetOptions ('length|height=f' => \$length);
  
  The first name is called the I<primary> name, the other names are
  called I<aliases>. When using a hash to store options, the key will
  always be the primary name.
  
  Multiple alternate names are possible.
  
  =head2 Case and abbreviations
  
  Without additional configuration, GetOptions() will ignore the case of
  option names, and allow the options to be abbreviated to uniqueness.
  
      GetOptions ('length|height=f' => \$length, "head" => \$head);
  
  This call will allow C<--l> and C<--L> for the length option, but
  requires a least C<--hea> and C<--hei> for the head and height options.
  
  =head2 Summary of Option Specifications
  
  Each option specifier consists of two parts: the name specification
  and the argument specification.
  
  The name specification contains the name of the option, optionally
  followed by a list of alternative names separated by vertical bar
  characters.
  
      length	      option name is "length"
      length|size|l     name is "length", aliases are "size" and "l"
  
  The argument specification is optional. If omitted, the option is
  considered boolean, a value of 1 will be assigned when the option is
  used on the command line.
  
  The argument specification can be
  
  =over 4
  
  =item !
  
  The option does not take an argument and may be negated by prefixing
  it with "no" or "no-". E.g. C<"foo!"> will allow C<--foo> (a value of
  1 will be assigned) as well as C<--nofoo> and C<--no-foo> (a value of
  0 will be assigned). If the option has aliases, this applies to the
  aliases as well.
  
  Using negation on a single letter option when bundling is in effect is
  pointless and will result in a warning.
  
  =item +
  
  The option does not take an argument and will be incremented by 1
  every time it appears on the command line. E.g. C<"more+">, when used
  with C<--more --more --more>, will increment the value three times,
  resulting in a value of 3 (provided it was 0 or undefined at first).
  
  The C<+> specifier is ignored if the option destination is not a scalar.
  
  =item = I<type> [ I<desttype> ] [ I<repeat> ]
  
  The option requires an argument of the given type. Supported types
  are:
  
  =over 4
  
  =item s
  
  String. An arbitrary sequence of characters. It is valid for the
  argument to start with C<-> or C<-->.
  
  =item i
  
  Integer. An optional leading plus or minus sign, followed by a
  sequence of digits.
  
  =item o
  
  Extended integer, Perl style. This can be either an optional leading
  plus or minus sign, followed by a sequence of digits, or an octal
  string (a zero, optionally followed by '0', '1', .. '7'), or a
  hexadecimal string (C<0x> followed by '0' .. '9', 'a' .. 'f', case
  insensitive), or a binary string (C<0b> followed by a series of '0'
  and '1').
  
  =item f
  
  Real number. For example C<3.14>, C<-6.23E24> and so on.
  
  =back
  
  The I<desttype> can be C<@> or C<%> to specify that the option is
  list or a hash valued. This is only needed when the destination for
  the option value is not otherwise specified. It should be omitted when
  not needed.
  
  The I<repeat> specifies the number of values this option takes per
  occurrence on the command line. It has the format C<{> [ I<min> ] [ C<,> [ I<max> ] ] C<}>.
  
  I<min> denotes the minimal number of arguments. It defaults to 1 for
  options with C<=> and to 0 for options with C<:>, see below. Note that
  I<min> overrules the C<=> / C<:> semantics.
  
  I<max> denotes the maximum number of arguments. It must be at least
  I<min>. If I<max> is omitted, I<but the comma is not>, there is no
  upper bound to the number of argument values taken.
  
  =item : I<type> [ I<desttype> ]
  
  Like C<=>, but designates the argument as optional.
  If omitted, an empty string will be assigned to string values options,
  and the value zero to numeric options.
  
  Note that if a string argument starts with C<-> or C<-->, it will be
  considered an option on itself.
  
  =item : I<number> [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the I<number> will be assigned.
  
  =item : + [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the current value for the
  option will be incremented.
  
  =back
  
  =head1 Advanced Possibilities
  
  =head2 Object oriented interface
  
  Getopt::Long can be used in an object oriented way as well:
  
      use Getopt::Long;
      $p = Getopt::Long::Parser->new;
      $p->configure(...configuration options...);
      if ($p->getoptions(...options descriptions...)) ...
      if ($p->getoptionsfromarray( \@array, ...options descriptions...)) ...
  
  Configuration options can be passed to the constructor:
  
      $p = new Getopt::Long::Parser
               config => [...configuration options...];
  
  =head2 Thread Safety
  
  Getopt::Long is thread safe when using ithreads as of Perl 5.8.  It is
  I<not> thread safe when using the older (experimental and now
  obsolete) threads implementation that was added to Perl 5.005.
  
  =head2 Documentation and help texts
  
  Getopt::Long encourages the use of Pod::Usage to produce help
  messages. For example:
  
      use Getopt::Long;
      use Pod::Usage;
  
      my $man = 0;
      my $help = 0;
  
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-exitval => 0, -verbose => 2) if $man;
  
      __END__
  
      =head1 NAME
  
      sample - Using Getopt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 8
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  See L<Pod::Usage> for details.
  
  =head2 Parsing options from an arbitrary array
  
  By default, GetOptions parses the options that are present in the
  global array C<@ARGV>. A special entry C<GetOptionsFromArray> can be
  used to parse options from an arbitrary array.
  
      use Getopt::Long qw(GetOptionsFromArray);
      $ret = GetOptionsFromArray(\@myopts, ...);
  
  When used like this, options and their possible values are removed
  from C<@myopts>, the global C<@ARGV> is not touched at all.
  
  The following two calls behave identically:
  
      $ret = GetOptions( ... );
      $ret = GetOptionsFromArray(\@ARGV, ... );
  
  This also means that a first argument hash reference now becomes the
  second argument:
  
      $ret = GetOptions(\%opts, ... );
      $ret = GetOptionsFromArray(\@ARGV, \%opts, ... );
  
  =head2 Parsing options from an arbitrary string
  
  A special entry C<GetOptionsFromString> can be used to parse options
  from an arbitrary string.
  
      use Getopt::Long qw(GetOptionsFromString);
      $ret = GetOptionsFromString($string, ...);
  
  The contents of the string are split into arguments using a call to
  C<Text::ParseWords::shellwords>. As with C<GetOptionsFromArray>, the
  global C<@ARGV> is not touched.
  
  It is possible that, upon completion, not all arguments in the string
  have been processed. C<GetOptionsFromString> will, when called in list
  context, return both the return status and an array reference to any
  remaining arguments:
  
      ($ret, $args) = GetOptionsFromString($string, ... );
  
  If any arguments remain, and C<GetOptionsFromString> was not called in
  list context, a message will be given and C<GetOptionsFromString> will
  return failure.
  
  As with GetOptionsFromArray, a first argument hash reference now
  becomes the second argument.
  
  =head2 Storing options values in a hash
  
  Sometimes, for example when there are a lot of options, having a
  separate variable for each of them can be cumbersome. GetOptions()
  supports, as an alternative mechanism, storing options values in a
  hash.
  
  To obtain this, a reference to a hash must be passed I<as the first
  argument> to GetOptions(). For each option that is specified on the
  command line, the option value will be stored in the hash with the
  option name as key. Options that are not actually used on the command
  line will not be put in the hash, on other words,
  C<exists($h{option})> (or defined()) can be used to test if an option
  was used. The drawback is that warnings will be issued if the program
  runs under C<use strict> and uses C<$h{option}> without testing with
  exists() or defined() first.
  
      my %h = ();
      GetOptions (\%h, 'length=i');	# will store in $h{length}
  
  For options that take list or hash values, it is necessary to indicate
  this by appending an C<@> or C<%> sign after the type:
  
      GetOptions (\%h, 'colours=s@');	# will push to @{$h{colours}}
  
  To make things more complicated, the hash may contain references to
  the actual destinations, for example:
  
      my $len = 0;
      my %h = ('length' => \$len);
      GetOptions (\%h, 'length=i');	# will store in $len
  
  This example is fully equivalent with:
  
      my $len = 0;
      GetOptions ('length=i' => \$len);	# will store in $len
  
  Any mixture is possible. For example, the most frequently used options
  could be stored in variables while all other options get stored in the
  hash:
  
      my $verbose = 0;			# frequently referred
      my $debug = 0;			# frequently referred
      my %h = ('verbose' => \$verbose, 'debug' => \$debug);
      GetOptions (\%h, 'verbose', 'debug', 'filter', 'size=i');
      if ( $verbose ) { ... }
      if ( exists $h{filter} ) { ... option 'filter' was specified ... }
  
  =head2 Bundling
  
  With bundling it is possible to set several single-character options
  at once. For example if C<a>, C<v> and C<x> are all valid options,
  
      -vax
  
  will set all three.
  
  Getopt::Long supports three styles of bundling. To enable bundling, a
  call to Getopt::Long::Configure is required.
  
  The simplest style of bundling can be enabled with:
  
      Getopt::Long::Configure ("bundling");
  
  Configured this way, single-character options can be bundled but long
  options B<must> always start with a double dash C<--> to avoid
  ambiguity. For example, when C<vax>, C<a>, C<v> and C<x> are all valid
  options,
  
      -vax
  
  will set C<a>, C<v> and C<x>, but
  
      --vax
  
  will set C<vax>.
  
  The second style of bundling lifts this restriction. It can be enabled
  with:
  
      Getopt::Long::Configure ("bundling_override");
  
  Now, C<-vax> will set the option C<vax>.
  
  In all of the above cases, option values may be inserted in the
  bundle. For example:
  
      -h24w80
  
  is equivalent to
  
      -h 24 -w 80
  
  A third style of bundling allows only values to be bundled with
  options. It can be enabled with:
  
      Getopt::Long::Configure ("bundling_values");
  
  Now, C<-h24> will set the option C<h> to C<24>, but option bundles
  like C<-vxa> and C<-h24w80> are flagged as errors.
  
  Enabling C<bundling_values> will disable the other two styles of
  bundling.
  
  When configured for bundling, single-character options are matched
  case sensitive while long options are matched case insensitive. To
  have the single-character options matched case insensitive as well,
  use:
  
      Getopt::Long::Configure ("bundling", "ignorecase_always");
  
  It goes without saying that bundling can be quite confusing.
  
  =head2 The lonesome dash
  
  Normally, a lone dash C<-> on the command line will not be considered
  an option. Option processing will terminate (unless "permute" is
  configured) and the dash will be left in C<@ARGV>.
  
  It is possible to get special treatment for a lone dash. This can be
  achieved by adding an option specification with an empty name, for
  example:
  
      GetOptions ('' => \$stdio);
  
  A lone dash on the command line will now be a legal option, and using
  it will set variable C<$stdio>.
  
  =head2 Argument callback
  
  A special option 'name' C<< <> >> can be used to designate a subroutine
  to handle non-option arguments. When GetOptions() encounters an
  argument that does not look like an option, it will immediately call this
  subroutine and passes it one parameter: the argument name. Well, actually
  it is an object that stringifies to the argument name.
  
  For example:
  
      my $width = 80;
      sub process { ... }
      GetOptions ('width=i' => \$width, '<>' => \&process);
  
  When applied to the following command line:
  
      arg1 --width=72 arg2 --width=60 arg3
  
  This will call
  C<process("arg1")> while C<$width> is C<80>,
  C<process("arg2")> while C<$width> is C<72>, and
  C<process("arg3")> while C<$width> is C<60>.
  
  This feature requires configuration option B<permute>, see section
  L<Configuring Getopt::Long>.
  
  =head1 Configuring Getopt::Long
  
  Getopt::Long can be configured by calling subroutine
  Getopt::Long::Configure(). This subroutine takes a list of quoted
  strings, each specifying a configuration option to be enabled, e.g.
  C<ignore_case>, or disabled, e.g. C<no_ignore_case>. Case does not
  matter. Multiple calls to Configure() are possible.
  
  Alternatively, as of version 2.24, the configuration options may be
  passed together with the C<use> statement:
  
      use Getopt::Long qw(:config no_ignore_case bundling);
  
  The following options are available:
  
  =over 12
  
  =item default
  
  This option causes all configuration options to be reset to their
  default values.
  
  =item posix_default
  
  This option causes all configuration options to be reset to their
  default values as if the environment variable POSIXLY_CORRECT had
  been set.
  
  =item auto_abbrev
  
  Allow option names to be abbreviated to uniqueness.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is disabled.
  
  =item getopt_compat
  
  Allow C<+> to start options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<getopt_compat> is disabled.
  
  =item gnu_compat
  
  C<gnu_compat> controls whether C<--opt=> is allowed, and what it should
  do. Without C<gnu_compat>, C<--opt=> gives an error. With C<gnu_compat>,
  C<--opt=> will give option C<opt> and empty value.
  This is the way GNU getopt_long() does it.
  
  Note that C<--opt value> is still accepted, even though GNU
  getopt_long() doesn't.
  
  =item gnu_getopt
  
  This is a short way of setting C<gnu_compat> C<bundling> C<permute>
  C<no_getopt_compat>. With C<gnu_getopt>, command line handling should be
  reasonably compatible with GNU getopt_long().
  
  =item require_order
  
  Whether command line arguments are allowed to be mixed with options.
  Default is disabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<require_order> is enabled.
  
  See also C<permute>, which is the opposite of C<require_order>.
  
  =item permute
  
  Whether command line arguments are allowed to be mixed with options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<permute> is disabled.
  Note that C<permute> is the opposite of C<require_order>.
  
  If C<permute> is enabled, this means that
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo --bar arg1 arg2 arg3
  
  If an argument callback routine is specified, C<@ARGV> will always be
  empty upon successful return of GetOptions() since all options have been
  processed. The only exception is when C<--> is used:
  
      --foo arg1 --bar arg2 -- arg3
  
  This will call the callback routine for arg1 and arg2, and then
  terminate GetOptions() leaving C<"arg3"> in C<@ARGV>.
  
  If C<require_order> is enabled, options processing
  terminates when the first non-option is encountered.
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo -- arg1 --bar arg2 arg3
  
  If C<pass_through> is also enabled, options processing will terminate
  at the first unrecognized option, or non-option, whichever comes
  first.
  
  =item bundling (default: disabled)
  
  Enabling this option will allow single-character options to be
  bundled. To distinguish bundles from long option names, long options
  I<must> be introduced with C<--> and bundles with C<->.
  
  Note that, if you have options C<a>, C<l> and C<all>, and
  auto_abbrev enabled, possible arguments and option settings are:
  
      using argument               sets option(s)
      ------------------------------------------
      -a, --a                      a
      -l, --l                      l
      -al, -la, -ala, -all,...     a, l
      --al, --all                  all
  
  The surprising part is that C<--a> sets option C<a> (due to auto
  completion), not C<all>.
  
  Note: disabling C<bundling> also disables C<bundling_override>.
  
  =item bundling_override (default: disabled)
  
  If C<bundling_override> is enabled, bundling is enabled as with
  C<bundling> but now long option names override option bundles.
  
  Note: disabling C<bundling_override> also disables C<bundling>.
  
  B<Note:> Using option bundling can easily lead to unexpected results,
  especially when mixing long options and bundles. Caveat emptor.
  
  =item ignore_case  (default: enabled)
  
  If enabled, case is ignored when matching option names. If, however,
  bundling is enabled as well, single character options will be treated
  case-sensitive.
  
  With C<ignore_case>, option specifications for options that only
  differ in case, e.g., C<"foo"> and C<"Foo">, will be flagged as
  duplicates.
  
  Note: disabling C<ignore_case> also disables C<ignore_case_always>.
  
  =item ignore_case_always (default: disabled)
  
  When bundling is in effect, case is ignored on single-character
  options also.
  
  Note: disabling C<ignore_case_always> also disables C<ignore_case>.
  
  =item auto_version (default:disabled)
  
  Automatically provide support for the B<--version> option if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a standard version message that includes the
  program name, its version (if $main::VERSION is defined), and the
  versions of Getopt::Long and Perl. The message will be written to
  standard output and processing will terminate.
  
  C<auto_version> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item auto_help (default:disabled)
  
  Automatically provide support for the B<--help> and B<-?> options if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a help message using module L<Pod::Usage>. The
  message, derived from the SYNOPSIS POD section, will be written to
  standard output and processing will terminate.
  
  C<auto_help> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item pass_through (default: disabled)
  
  With C<pass_through> anything that is unknown, ambiguous or supplied with
  an invalid option will not be flagged as an error. Instead the unknown
  option(s) will be passed to the catchall C<< <> >> if present, otherwise
  through to C<@ARGV>. This makes it possible to write wrapper scripts that
  process only part of the user supplied command line arguments, and pass the
  remaining options to some other program.
  
  If C<require_order> is enabled, options processing will terminate at the
  first unrecognized option, or non-option, whichever comes first and all
  remaining arguments are passed to C<@ARGV> instead of the catchall
  C<< <> >> if present.  However, if C<permute> is enabled instead, results
  can become confusing.
  
  Note that the options terminator (default C<-->), if present, will
  also be passed through in C<@ARGV>.
  
  =item prefix
  
  The string that starts options. If a constant string is not
  sufficient, see C<prefix_pattern>.
  
  =item prefix_pattern
  
  A Perl pattern that identifies the strings that introduce options.
  Default is C<--|-|\+> unless environment variable
  POSIXLY_CORRECT has been set, in which case it is C<--|->.
  
  =item long_prefix_pattern
  
  A Perl pattern that allows the disambiguation of long and short
  prefixes. Default is C<-->.
  
  Typically you only need to set this if you are using nonstandard
  prefixes and want some or all of them to have the same semantics as
  '--' does under normal circumstances.
  
  For example, setting prefix_pattern to C<--|-|\+|\/> and
  long_prefix_pattern to C<--|\/> would add Win32 style argument
  handling.
  
  =item debug (default: disabled)
  
  Enable debugging output.
  
  =back
  
  =head1 Exportable Methods
  
  =over
  
  =item VersionMessage
  
  This subroutine provides a standard version message. Its argument can be:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the standard message.
  
  =item *
  
  A numeric value corresponding to the desired exit status.
  
  =item *
  
  A reference to a hash.
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message>
  
  =item C<-msg>
  
  The text of a message to print immediately prior to printing the
  program's usage message.
  
  =item C<-exitval>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string "NOEXIT" to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-output>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =back
  
  You cannot tie this routine directly to an option, e.g.:
  
      GetOptions("version" => \&VersionMessage);
  
  Use this instead:
  
      GetOptions("version" => sub { VersionMessage() });
  
  =item HelpMessage
  
  This subroutine produces a standard help message, derived from the
  program's POD section SYNOPSIS using L<Pod::Usage>. It takes the same
  arguments as VersionMessage(). In particular, you cannot tie it
  directly to an option, e.g.:
  
      GetOptions("help" => \&HelpMessage);
  
  Use this instead:
  
      GetOptions("help" => sub { HelpMessage() });
  
  =back
  
  =head1 Return values and Errors
  
  Configuration errors and errors in the option definitions are
  signalled using die() and will terminate the calling program unless
  the call to Getopt::Long::GetOptions() was embedded in C<eval { ...
  }>, or die() was trapped using C<$SIG{__DIE__}>.
  
  GetOptions returns true to indicate success.
  It returns false when the function detected one or more errors during
  option parsing. These errors are signalled using warn() and can be
  trapped with C<$SIG{__WARN__}>.
  
  =head1 Legacy
  
  The earliest development of C<newgetopt.pl> started in 1990, with Perl
  version 4. As a result, its development, and the development of
  Getopt::Long, has gone through several stages. Since backward
  compatibility has always been extremely important, the current version
  of Getopt::Long still supports a lot of constructs that nowadays are
  no longer necessary or otherwise unwanted. This section describes
  briefly some of these 'features'.
  
  =head2 Default destinations
  
  When no destination is specified for an option, GetOptions will store
  the resultant value in a global variable named C<opt_>I<XXX>, where
  I<XXX> is the primary name of this option. When a program executes
  under C<use strict> (recommended), these variables must be
  pre-declared with our() or C<use vars>.
  
      our $opt_length = 0;
      GetOptions ('length=i');	# will store in $opt_length
  
  To yield a usable Perl variable, characters that are not part of the
  syntax for variables are translated to underscores. For example,
  C<--fpp-struct-return> will set the variable
  C<$opt_fpp_struct_return>. Note that this variable resides in the
  namespace of the calling program, not necessarily C<main>. For
  example:
  
      GetOptions ("size=i", "sizes=i@");
  
  with command line "-size 10 -sizes 24 -sizes 48" will perform the
  equivalent of the assignments
  
      $opt_size = 10;
      @opt_sizes = (24, 48);
  
  =head2 Alternative option starters
  
  A string of alternative option starter characters may be passed as the
  first argument (or the first argument after a leading hash reference
  argument).
  
      my $len = 0;
      GetOptions ('/', 'length=i' => $len);
  
  Now the command line may look like:
  
      /length 24 -- arg
  
  Note that to terminate options processing still requires a double dash
  C<-->.
  
  GetOptions() will not interpret a leading C<< "<>" >> as option starters
  if the next argument is a reference. To force C<< "<" >> and C<< ">" >> as
  option starters, use C<< "><" >>. Confusing? Well, B<using a starter
  argument is strongly deprecated> anyway.
  
  =head2 Configuration variables
  
  Previous versions of Getopt::Long used variables for the purpose of
  configuring. Although manipulating these variables still work, it is
  strongly encouraged to use the C<Configure> routine that was introduced
  in version 2.17. Besides, it is much easier.
  
  =head1 Tips and Techniques
  
  =head2 Pushing multiple values in a hash option
  
  Sometimes you want to combine the best of hashes and arrays. For
  example, the command line:
  
    --list add=first --list add=second --list add=third
  
  where each successive 'list add' option will push the value of add
  into array ref $list->{'add'}. The result would be like
  
    $list->{add} = [qw(first second third)];
  
  This can be accomplished with a destination routine:
  
    GetOptions('list=s%' =>
                 sub { push(@{$list{$_[1]}}, $_[2]) });
  
  =head1 Troubleshooting
  
  =head2 GetOptions does not return a false result when an option is not supplied
  
  That's why they're called 'options'.
  
  =head2 GetOptions does not split the command line correctly
  
  The command line is not split by GetOptions, but by the command line
  interpreter (CLI). On Unix, this is the shell. On Windows, it is
  COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.
  
  It is important to know that these CLIs may behave different when the
  command line contains special characters, in particular quotes or
  backslashes. For example, with Unix shells you can use single quotes
  (C<'>) and double quotes (C<">) to group words together. The following
  alternatives are equivalent on Unix:
  
      "two words"
      'two words'
      two\ words
  
  In case of doubt, insert the following statement in front of your Perl
  program:
  
      print STDERR (join("|",@ARGV),"\n");
  
  to verify how your CLI passes the arguments to the program.
  
  =head2 Undefined subroutine &main::GetOptions called
  
  Are you running Windows, and did you write
  
      use GetOpt::Long;
  
  (note the capital 'O')?
  
  =head2 How do I put a "-?" option into a Getopt::Long?
  
  You can only obtain this using an alias, and Getopt::Long of at least
  version 2.13.
  
      use Getopt::Long;
      GetOptions ("help|?");    # -help and -? will both set $opt_help
  
  Other characters that can't appear in Perl identifiers are also supported
  as aliases with Getopt::Long of at least version 2.39.
  
  As of version 2.32 Getopt::Long provides auto-help, a quick and easy way
  to add the options --help and -? to your program, and handle them.
  
  See C<auto_help> in section L<Configuring Getopt::Long>.
  
  =head1 AUTHOR
  
  Johan Vromans <jvromans@squirrel.nl>
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  This program is Copyright 1990,2015 by Johan Vromans.
  This program is free software; you can redistribute it and/or
  modify it under the terms of the Perl Artistic License or the
  GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any
  later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  If you do not have a copy of the GNU General Public License write to
  the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
  MA 02139, USA.
  
  =cut
  
GETOPT_LONG

$fatpacked{"IO/Socket/IP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_SOCKET_IP';
  #  You may distribute under the terms of either the GNU General Public License
  #  or the Artistic License (the same terms as Perl itself)
  #
  #  (C) Paul Evans, 2010-2015 -- leonerd@leonerd.org.uk
  
  package IO::Socket::IP;
  # $VERSION needs to be set before  use base 'IO::Socket'
  #  - https://rt.cpan.org/Ticket/Display.html?id=92107
  BEGIN {
     $VERSION = '0.39';
  }
  
  use strict;
  use warnings;
  use base qw( IO::Socket );
  
  use Carp;
  
  use Socket 1.97 qw(
     getaddrinfo getnameinfo
     sockaddr_family
     AF_INET
     AI_PASSIVE
     IPPROTO_TCP IPPROTO_UDP
     IPPROTO_IPV6 IPV6_V6ONLY
     NI_DGRAM NI_NUMERICHOST NI_NUMERICSERV NIx_NOHOST NIx_NOSERV
     SO_REUSEADDR SO_REUSEPORT SO_BROADCAST SO_ERROR
     SOCK_DGRAM SOCK_STREAM
     SOL_SOCKET
  );
  my $AF_INET6 = eval { Socket::AF_INET6() }; # may not be defined
  my $AI_ADDRCONFIG = eval { Socket::AI_ADDRCONFIG() } || 0;
  use POSIX qw( dup2 );
  use Errno qw( EINVAL EINPROGRESS EISCONN ENOTCONN ETIMEDOUT EWOULDBLOCK EOPNOTSUPP );
  
  use constant HAVE_MSWIN32 => ( $^O eq "MSWin32" );
  
  # At least one OS (Android) is known not to have getprotobyname()
  use constant HAVE_GETPROTOBYNAME => defined eval { getprotobyname( "tcp" ) };
  
  my $IPv6_re = do {
     # translation of RFC 3986 3.2.2 ABNF to re
     my $IPv4address = do {
        my $dec_octet = q<(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])>;
        qq<$dec_octet(?: \\. $dec_octet){3}>;
     };
     my $IPv6address = do {
        my $h16  = qq<[0-9A-Fa-f]{1,4}>;
        my $ls32 = qq<(?: $h16 : $h16 | $IPv4address)>;
        qq<(?:
                                              (?: $h16 : ){6} $ls32
           |                               :: (?: $h16 : ){5} $ls32
           | (?:                   $h16 )? :: (?: $h16 : ){4} $ls32
           | (?: (?: $h16 : ){0,1} $h16 )? :: (?: $h16 : ){3} $ls32
           | (?: (?: $h16 : ){0,2} $h16 )? :: (?: $h16 : ){2} $ls32
           | (?: (?: $h16 : ){0,3} $h16 )? ::     $h16 :      $ls32
           | (?: (?: $h16 : ){0,4} $h16 )? ::                 $ls32
           | (?: (?: $h16 : ){0,5} $h16 )? ::                 $h16
           | (?: (?: $h16 : ){0,6} $h16 )? ::
        )>
     };
     qr<$IPv6address>xo;
  };
  
  =head1 NAME
  
  C<IO::Socket::IP> - Family-neutral IP socket supporting both IPv4 and IPv6
  
  =head1 SYNOPSIS
  
   use IO::Socket::IP;
  
   my $sock = IO::Socket::IP->new(
      PeerHost => "www.google.com",
      PeerPort => "http",
      Type     => SOCK_STREAM,
   ) or die "Cannot construct socket - $@";
  
   my $familyname = ( $sock->sockdomain == PF_INET6 ) ? "IPv6" :
                    ( $sock->sockdomain == PF_INET  ) ? "IPv4" :
                                                        "unknown";
  
   printf "Connected to google via %s\n", $familyname;
  
  =head1 DESCRIPTION
  
  This module provides a protocol-independent way to use IPv4 and IPv6 sockets,
  intended as a replacement for L<IO::Socket::INET>. Most constructor arguments
  and methods are provided in a backward-compatible way. For a list of known
  differences, see the C<IO::Socket::INET> INCOMPATIBILITES section below.
  
  It uses the C<getaddrinfo(3)> function to convert hostnames and service names
  or port numbers into sets of possible addresses to connect to or listen on.
  This allows it to work for IPv6 where the system supports it, while still
  falling back to IPv4-only on systems which don't.
  
  =head1 REPLACING C<IO::Socket> DEFAULT BEHAVIOUR
  
  By placing C<-register> in the import list, L<IO::Socket> uses
  C<IO::Socket::IP> rather than C<IO::Socket::INET> as the class that handles
  C<PF_INET>.  C<IO::Socket> will also use C<IO::Socket::IP> rather than
  C<IO::Socket::INET6> to handle C<PF_INET6>, provided that the C<AF_INET6>
  constant is available.
  
  Changing C<IO::Socket>'s default behaviour means that calling the
  C<IO::Socket> constructor with either C<PF_INET> or C<PF_INET6> as the
  C<Domain> parameter will yield an C<IO::Socket::IP> object.
  
   use IO::Socket::IP -register;
  
   my $sock = IO::Socket->new(
      Domain    => PF_INET6,
      LocalHost => "::1",
      Listen    => 1,
   ) or die "Cannot create socket - $@\n";
  
   print "Created a socket of type " . ref($sock) . "\n";
  
  Note that C<-register> is a global setting that applies to the entire program;
  it cannot be applied only for certain callers, removed, or limited by lexical
  scope.
  
  =cut
  
  sub import
  {
     my $pkg = shift;
     my @symbols;
  
     foreach ( @_ ) {
        if( $_ eq "-register" ) {
           IO::Socket::IP::_ForINET->register_domain( AF_INET );
           IO::Socket::IP::_ForINET6->register_domain( $AF_INET6 ) if defined $AF_INET6;
        }
        else {
           push @symbols, $_;
        }
     }
  
     @_ = ( $pkg, @symbols );
     goto &IO::Socket::import;
  }
  
  # Convenient capability test function
  {
     my $can_disable_v6only;
     sub CAN_DISABLE_V6ONLY
     {
        return $can_disable_v6only if defined $can_disable_v6only;
  
        socket my $testsock, Socket::PF_INET6(), SOCK_STREAM, 0 or
           die "Cannot socket(PF_INET6) - $!";
  
        if( setsockopt $testsock, IPPROTO_IPV6, IPV6_V6ONLY, 0 ) {
           return $can_disable_v6only = 1;
        }
        elsif( $! == EINVAL || $! == EOPNOTSUPP ) {
           return $can_disable_v6only = 0;
        }
        else {
           die "Cannot setsockopt() - $!";
        }
     }
  }
  
  =head1 CONSTRUCTORS
  
  =cut
  
  =head2 $sock = IO::Socket::IP->new( %args )
  
  Creates a new C<IO::Socket::IP> object, containing a newly created socket
  handle according to the named arguments passed. The recognised arguments are:
  
  =over 8
  
  =item PeerHost => STRING
  
  =item PeerService => STRING
  
  Hostname and service name for the peer to C<connect()> to. The service name
  may be given as a port number, as a decimal string.
  
  =item PeerAddr => STRING
  
  =item PeerPort => STRING
  
  For symmetry with the accessor methods and compatibility with
  C<IO::Socket::INET>, these are accepted as synonyms for C<PeerHost> and
  C<PeerService> respectively.
  
  =item PeerAddrInfo => ARRAY
  
  Alternate form of specifying the peer to C<connect()> to. This should be an
  array of the form returned by C<Socket::getaddrinfo>.
  
  This parameter takes precedence over the C<Peer*>, C<Family>, C<Type> and
  C<Proto> arguments.
  
  =item LocalHost => STRING
  
  =item LocalService => STRING
  
  Hostname and service name for the local address to C<bind()> to.
  
  =item LocalAddr => STRING
  
  =item LocalPort => STRING
  
  For symmetry with the accessor methods and compatibility with
  C<IO::Socket::INET>, these are accepted as synonyms for C<LocalHost> and
  C<LocalService> respectively.
  
  =item LocalAddrInfo => ARRAY
  
  Alternate form of specifying the local address to C<bind()> to. This should be
  an array of the form returned by C<Socket::getaddrinfo>.
  
  This parameter takes precedence over the C<Local*>, C<Family>, C<Type> and
  C<Proto> arguments.
  
  =item Family => INT
  
  The address family to pass to C<getaddrinfo> (e.g. C<AF_INET>, C<AF_INET6>).
  Normally this will be left undefined, and C<getaddrinfo> will search using any
  address family supported by the system.
  
  =item Type => INT
  
  The socket type to pass to C<getaddrinfo> (e.g. C<SOCK_STREAM>,
  C<SOCK_DGRAM>). Normally defined by the caller; if left undefined
  C<getaddrinfo> may attempt to infer the type from the service name.
  
  =item Proto => STRING or INT
  
  The IP protocol to use for the socket (e.g. C<'tcp'>, C<IPPROTO_TCP>,
  C<'udp'>,C<IPPROTO_UDP>). Normally this will be left undefined, and either
  C<getaddrinfo> or the kernel will choose an appropriate value. May be given
  either in string name or numeric form.
  
  =item GetAddrInfoFlags => INT
  
  More flags to pass to the C<getaddrinfo()> function. If not supplied, a
  default of C<AI_ADDRCONFIG> will be used.
  
  These flags will be combined with C<AI_PASSIVE> if the C<Listen> argument is
  given. For more information see the documentation about C<getaddrinfo()> in
  the L<Socket> module.
  
  =item Listen => INT
  
  If defined, puts the socket into listening mode where new connections can be
  accepted using the C<accept> method. The value given is used as the
  C<listen(2)> queue size.
  
  =item ReuseAddr => BOOL
  
  If true, set the C<SO_REUSEADDR> sockopt
  
  =item ReusePort => BOOL
  
  If true, set the C<SO_REUSEPORT> sockopt (not all OSes implement this sockopt)
  
  =item Broadcast => BOOL
  
  If true, set the C<SO_BROADCAST> sockopt
  
  =item Sockopts => ARRAY
  
  An optional array of other socket options to apply after the three listed
  above. The value is an ARRAY containing 2- or 3-element ARRAYrefs. Each inner
  array relates to a single option, giving the level and option name, and an
  optional value. If the value element is missing, it will be given the value of
  a platform-sized integer 1 constant (i.e. suitable to enable most of the
  common boolean options).
  
  For example, both options given below are equivalent to setting C<ReuseAddr>.
  
   Sockopts => [
      [ SOL_SOCKET, SO_REUSEADDR ],
      [ SOL_SOCKET, SO_REUSEADDR, pack( "i", 1 ) ],
   ]
  
  =item V6Only => BOOL
  
  If defined, set the C<IPV6_V6ONLY> sockopt when creating C<PF_INET6> sockets
  to the given value. If true, a listening-mode socket will only listen on the
  C<AF_INET6> addresses; if false it will also accept connections from
  C<AF_INET> addresses.
  
  If not defined, the socket option will not be changed, and default value set
  by the operating system will apply. For repeatable behaviour across platforms
  it is recommended this value always be defined for listening-mode sockets.
  
  Note that not all platforms support disabling this option. Some, at least
  OpenBSD and MirBSD, will fail with C<EINVAL> if you attempt to disable it.
  To determine whether it is possible to disable, you may use the class method
  
   if( IO::Socket::IP->CAN_DISABLE_V6ONLY ) {
      ...
   }
   else {
      ...
   }
  
  If your platform does not support disabling this option but you still want to
  listen for both C<AF_INET> and C<AF_INET6> connections you will have to create
  two listening sockets, one bound to each protocol.
  
  =item MultiHomed
  
  This C<IO::Socket::INET>-style argument is ignored, except if it is defined
  but false. See the C<IO::Socket::INET> INCOMPATIBILITES section below.
  
  However, the behaviour it enables is always performed by C<IO::Socket::IP>.
  
  =item Blocking => BOOL
  
  If defined but false, the socket will be set to non-blocking mode. Otherwise
  it will default to blocking mode. See the NON-BLOCKING section below for more
  detail.
  
  =item Timeout => NUM
  
  If defined, gives a maximum time in seconds to block per C<connect()> call
  when in blocking mode. If missing, no timeout is applied other than that
  provided by the underlying operating system. When in non-blocking mode this
  parameter is ignored.
  
  Note that if the hostname resolves to multiple address candidates, the same
  timeout will apply to each connection attempt individually, rather than to the
  operation as a whole. Further note that the timeout does not apply to the
  initial hostname resolve operation, if connecting by hostname.
  
  This behviour is copied inspired by C<IO::Socket::INET>; for more fine grained
  control over connection timeouts, consider performing a nonblocking connect
  directly.
  
  =back
  
  If neither C<Type> nor C<Proto> hints are provided, a default of
  C<SOCK_STREAM> and C<IPPROTO_TCP> respectively will be set, to maintain
  compatibility with C<IO::Socket::INET>. Other named arguments that are not
  recognised are ignored.
  
  If neither C<Family> nor any hosts or addresses are passed, nor any
  C<*AddrInfo>, then the constructor has no information on which to decide a
  socket family to create. In this case, it performs a C<getaddinfo> call with
  the C<AI_ADDRCONFIG> flag, no host name, and a service name of C<"0">, and
  uses the family of the first returned result.
  
  If the constructor fails, it will set C<$@> to an appropriate error message;
  this may be from C<$!> or it may be some other string; not every failure
  necessarily has an associated C<errno> value.
  
  =head2 $sock = IO::Socket::IP->new( $peeraddr )
  
  As a special case, if the constructor is passed a single argument (as
  opposed to an even-sized list of key/value pairs), it is taken to be the value
  of the C<PeerAddr> parameter. This is parsed in the same way, according to the
  behaviour given in the C<PeerHost> AND C<LocalHost> PARSING section below.
  
  =cut
  
  sub new
  {
     my $class = shift;
     my %arg = (@_ == 1) ? (PeerHost => $_[0]) : @_;
     return $class->SUPER::new(%arg);
  }
  
  # IO::Socket may call this one; neaten up the arguments from IO::Socket::INET
  # before calling our real _configure method
  sub configure
  {
     my $self = shift;
     my ( $arg ) = @_;
  
     $arg->{PeerHost} = delete $arg->{PeerAddr}
        if exists $arg->{PeerAddr} && !exists $arg->{PeerHost};
  
     $arg->{PeerService} = delete $arg->{PeerPort}
        if exists $arg->{PeerPort} && !exists $arg->{PeerService};
  
     $arg->{LocalHost} = delete $arg->{LocalAddr}
        if exists $arg->{LocalAddr} && !exists $arg->{LocalHost};
  
     $arg->{LocalService} = delete $arg->{LocalPort}
        if exists $arg->{LocalPort} && !exists $arg->{LocalService};
  
     for my $type (qw(Peer Local)) {
        my $host    = $type . 'Host';
        my $service = $type . 'Service';
  
        if( defined $arg->{$host} ) {
           ( $arg->{$host}, my $s ) = $self->split_addr( $arg->{$host} );
           # IO::Socket::INET compat - *Host parsed port always takes precedence
           $arg->{$service} = $s if defined $s;
        }
     }
  
     $self->_io_socket_ip__configure( $arg );
  }
  
  # Avoid simply calling it _configure, as some subclasses of IO::Socket::INET on CPAN already take that
  sub _io_socket_ip__configure
  {
     my $self = shift;
     my ( $arg ) = @_;
  
     my %hints;
     my @localinfos;
     my @peerinfos;
  
     my $listenqueue = $arg->{Listen};
     if( defined $listenqueue and
         ( defined $arg->{PeerHost} || defined $arg->{PeerService} || defined $arg->{PeerAddrInfo} ) ) {
        croak "Cannot Listen with a peer address";
     }
  
     if( defined $arg->{GetAddrInfoFlags} ) {
        $hints{flags} = $arg->{GetAddrInfoFlags};
     }
     else {
        $hints{flags} = $AI_ADDRCONFIG;
     }
  
     if( defined( my $family = $arg->{Family} ) ) {
        $hints{family} = $family;
     }
  
     if( defined( my $type = $arg->{Type} ) ) {
        $hints{socktype} = $type;
     }
  
     if( defined( my $proto = $arg->{Proto} ) ) {
        unless( $proto =~ m/^\d+$/ ) {
           my $protonum = HAVE_GETPROTOBYNAME
              ? getprotobyname( $proto )
              : eval { Socket->${\"IPPROTO_\U$proto"}() };
           defined $protonum or croak "Unrecognised protocol $proto";
           $proto = $protonum;
        }
  
        $hints{protocol} = $proto;
     }
  
     # To maintain compatibility with IO::Socket::INET, imply a default of
     # SOCK_STREAM + IPPROTO_TCP if neither hint is given
     if( !defined $hints{socktype} and !defined $hints{protocol} ) {
        $hints{socktype} = SOCK_STREAM;
        $hints{protocol} = IPPROTO_TCP;
     }
  
     # Some OSes (NetBSD) don't seem to like just a protocol hint without a
     # socktype hint as well. We'll set a couple of common ones
     if( !defined $hints{socktype} and defined $hints{protocol} ) {
        $hints{socktype} = SOCK_STREAM if $hints{protocol} == IPPROTO_TCP;
        $hints{socktype} = SOCK_DGRAM  if $hints{protocol} == IPPROTO_UDP;
     }
  
     if( my $info = $arg->{LocalAddrInfo} ) {
        ref $info eq "ARRAY" or croak "Expected 'LocalAddrInfo' to be an ARRAY ref";
        @localinfos = @$info;
     }
     elsif( defined $arg->{LocalHost} or
            defined $arg->{LocalService} or
            HAVE_MSWIN32 and $arg->{Listen} ) {
        # Either may be undef
        my $host = $arg->{LocalHost};
        my $service = $arg->{LocalService};
  
        unless ( defined $host or defined $service ) {
           $service = 0;
        }
  
        local $1; # Placate a taint-related bug; [perl #67962]
        defined $service and $service =~ s/\((\d+)\)$// and
           my $fallback_port = $1;
  
        my %localhints = %hints;
        $localhints{flags} |= AI_PASSIVE;
        ( my $err, @localinfos ) = getaddrinfo( $host, $service, \%localhints );
  
        if( $err and defined $fallback_port ) {
           ( $err, @localinfos ) = getaddrinfo( $host, $fallback_port, \%localhints );
        }
  
        if( $err ) {
           $@ = "$err";
           $! = EINVAL;
           return;
        }
     }
  
     if( my $info = $arg->{PeerAddrInfo} ) {
        ref $info eq "ARRAY" or croak "Expected 'PeerAddrInfo' to be an ARRAY ref";
        @peerinfos = @$info;
     }
     elsif( defined $arg->{PeerHost} or defined $arg->{PeerService} ) {
        defined( my $host = $arg->{PeerHost} ) or
           croak "Expected 'PeerHost'";
        defined( my $service = $arg->{PeerService} ) or
           croak "Expected 'PeerService'";
  
        local $1; # Placate a taint-related bug; [perl #67962]
        defined $service and $service =~ s/\((\d+)\)$// and
           my $fallback_port = $1;
  
        ( my $err, @peerinfos ) = getaddrinfo( $host, $service, \%hints );
  
        if( $err and defined $fallback_port ) {
           ( $err, @peerinfos ) = getaddrinfo( $host, $fallback_port, \%hints );
        }
  
        if( $err ) {
           $@ = "$err";
           $! = EINVAL;
           return;
        }
     }
  
     my $INT_1 = pack "i", 1;
  
     my @sockopts_enabled;
     push @sockopts_enabled, [ SOL_SOCKET, SO_REUSEADDR, $INT_1 ] if $arg->{ReuseAddr};
     push @sockopts_enabled, [ SOL_SOCKET, SO_REUSEPORT, $INT_1 ] if $arg->{ReusePort};
     push @sockopts_enabled, [ SOL_SOCKET, SO_BROADCAST, $INT_1 ] if $arg->{Broadcast};
  
     if( my $sockopts = $arg->{Sockopts} ) {
        ref $sockopts eq "ARRAY" or croak "Expected 'Sockopts' to be an ARRAY ref";
        foreach ( @$sockopts ) {
           ref $_ eq "ARRAY" or croak "Bad Sockopts item - expected ARRAYref";
           @$_ >= 2 and @$_ <= 3 or
              croak "Bad Sockopts item - expected 2 or 3 elements";
  
           my ( $level, $optname, $value ) = @$_;
           # TODO: consider more sanity checking on argument values
  
           defined $value or $value = $INT_1;
           push @sockopts_enabled, [ $level, $optname, $value ];
        }
     }
  
     my $blocking = $arg->{Blocking};
     defined $blocking or $blocking = 1;
  
     my $v6only = $arg->{V6Only};
  
     # IO::Socket::INET defines this key. IO::Socket::IP always implements the
     # behaviour it requests, so we can ignore it, unless the caller is for some
     # reason asking to disable it.
     if( defined $arg->{MultiHomed} and !$arg->{MultiHomed} ) {
        croak "Cannot disable the MultiHomed parameter";
     }
  
     my @infos;
     foreach my $local ( @localinfos ? @localinfos : {} ) {
        foreach my $peer ( @peerinfos ? @peerinfos : {} ) {
           next if defined $local->{family}   and defined $peer->{family}   and
              $local->{family} != $peer->{family};
           next if defined $local->{socktype} and defined $peer->{socktype} and
              $local->{socktype} != $peer->{socktype};
           next if defined $local->{protocol} and defined $peer->{protocol} and
              $local->{protocol} != $peer->{protocol};
  
           my $family   = $local->{family}   || $peer->{family}   or next;
           my $socktype = $local->{socktype} || $peer->{socktype} or next;
           my $protocol = $local->{protocol} || $peer->{protocol} || 0;
  
           push @infos, {
              family    => $family,
              socktype  => $socktype,
              protocol  => $protocol,
              localaddr => $local->{addr},
              peeraddr  => $peer->{addr},
           };
        }
     }
  
     if( !@infos ) {
        # If there was a Family hint then create a plain unbound, unconnected socket
        if( defined $hints{family} ) {
           @infos = ( {
              family   => $hints{family},
              socktype => $hints{socktype},
              protocol => $hints{protocol},
           } );
        }
        # If there wasn't, use getaddrinfo()'s AI_ADDRCONFIG side-effect to guess a
        # suitable family first.
        else {
           ( my $err, @infos ) = getaddrinfo( "", "0", \%hints );
           if( $err ) {
              $@ = "$err";
              $! = EINVAL;
              return;
           }
  
           # We'll take all the @infos anyway, because some OSes (HPUX) are known to
           # ignore the AI_ADDRCONFIG hint and return AF_INET6 even if they don't
           # support them
        }
     }
  
     # In the nonblocking case, caller will be calling ->setup multiple times.
     # Store configuration in the object for the ->setup method
     # Yes, these are messy. Sorry, I can't help that...
  
     ${*$self}{io_socket_ip_infos} = \@infos;
  
     ${*$self}{io_socket_ip_idx} = -1;
  
     ${*$self}{io_socket_ip_sockopts} = \@sockopts_enabled;
     ${*$self}{io_socket_ip_v6only} = $v6only;
     ${*$self}{io_socket_ip_listenqueue} = $listenqueue;
     ${*$self}{io_socket_ip_blocking} = $blocking;
  
     ${*$self}{io_socket_ip_errors} = [ undef, undef, undef ];
  
     # ->setup is allowed to return false in nonblocking mode
     $self->setup or !$blocking or return undef;
  
     return $self;
  }
  
  sub setup
  {
     my $self = shift;
  
     while(1) {
        ${*$self}{io_socket_ip_idx}++;
        last if ${*$self}{io_socket_ip_idx} >= @{ ${*$self}{io_socket_ip_infos} };
  
        my $info = ${*$self}{io_socket_ip_infos}->[${*$self}{io_socket_ip_idx}];
  
        $self->socket( @{$info}{qw( family socktype protocol )} ) or
           ( ${*$self}{io_socket_ip_errors}[2] = $!, next );
  
        $self->blocking( 0 ) unless ${*$self}{io_socket_ip_blocking};
  
        foreach my $sockopt ( @{ ${*$self}{io_socket_ip_sockopts} } ) {
           my ( $level, $optname, $value ) = @$sockopt;
           $self->setsockopt( $level, $optname, $value ) or ( $@ = "$!", return undef );
        }
  
        if( defined ${*$self}{io_socket_ip_v6only} and defined $AF_INET6 and $info->{family} == $AF_INET6 ) {
           my $v6only = ${*$self}{io_socket_ip_v6only};
           $self->setsockopt( IPPROTO_IPV6, IPV6_V6ONLY, pack "i", $v6only ) or ( $@ = "$!", return undef );
        }
  
        if( defined( my $addr = $info->{localaddr} ) ) {
           $self->bind( $addr ) or
              ( ${*$self}{io_socket_ip_errors}[1] = $!, next );
        }
  
        if( defined( my $listenqueue = ${*$self}{io_socket_ip_listenqueue} ) ) {
           $self->listen( $listenqueue ) or ( $@ = "$!", return undef );
        }
  
        if( defined( my $addr = $info->{peeraddr} ) ) {
           if( $self->connect( $addr ) ) {
              $! = 0;
              return 1;
           }
  
           if( $! == EINPROGRESS or $! == EWOULDBLOCK ) {
              ${*$self}{io_socket_ip_connect_in_progress} = 1;
              return 0;
           }
  
           # If connect failed but we have no system error there must be an error
           # at the application layer, like a bad certificate with
           # IO::Socket::SSL.
           # In this case don't continue IP based multi-homing because the problem
           # cannot be solved at the IP layer.
           return 0 if ! $!;
  
           ${*$self}{io_socket_ip_errors}[0] = $!;
           next;
        }
  
        return 1;
     }
  
     # Pick the most appropriate error, stringified
     $! = ( grep defined, @{ ${*$self}{io_socket_ip_errors}} )[0];
     $@ = "$!";
     return undef;
  }
  
  sub connect :method
  {
     my $self = shift;
  
     # It seems that IO::Socket hides EINPROGRESS errors, making them look like
     # a success. This is annoying here.
     # Instead of putting up with its frankly-irritating intentional breakage of
     # useful APIs I'm just going to end-run around it and call core's connect()
     # directly
  
     if( @_ ) {
        my ( $addr ) = @_;
  
        # Annoyingly IO::Socket's connect() is where the timeout logic is
        # implemented, so we'll have to reinvent it here
        my $timeout = ${*$self}{'io_socket_timeout'};
  
        return connect( $self, $addr ) unless defined $timeout;
  
        my $was_blocking = $self->blocking( 0 );
  
        my $err = defined connect( $self, $addr ) ? 0 : $!+0;
  
        if( !$err ) {
           # All happy
           $self->blocking( $was_blocking );
           return 1;
        }
        elsif( not( $err == EINPROGRESS or $err == EWOULDBLOCK ) ) {
           # Failed for some other reason
           $self->blocking( $was_blocking );
           return undef;
        }
        elsif( !$was_blocking ) {
           # We shouldn't block anyway
           return undef;
        }
  
        my $vec = ''; vec( $vec, $self->fileno, 1 ) = 1;
        if( !select( undef, $vec, $vec, $timeout ) ) {
           $self->blocking( $was_blocking );
           $! = ETIMEDOUT;
           return undef;
        }
  
        # Hoist the error by connect()ing a second time
        $err = $self->getsockopt( SOL_SOCKET, SO_ERROR );
        $err = 0 if $err == EISCONN; # Some OSes give EISCONN
  
        $self->blocking( $was_blocking );
  
        $! = $err, return undef if $err;
        return 1;
     }
  
     return 1 if !${*$self}{io_socket_ip_connect_in_progress};
  
     # See if a connect attempt has just failed with an error
     if( my $errno = $self->getsockopt( SOL_SOCKET, SO_ERROR ) ) {
        delete ${*$self}{io_socket_ip_connect_in_progress};
        ${*$self}{io_socket_ip_errors}[0] = $! = $errno;
        return $self->setup;
     }
  
     # No error, so either connect is still in progress, or has completed
     # successfully. We can tell by trying to connect() again; either it will
     # succeed or we'll get EISCONN (connected successfully), or EALREADY
     # (still in progress). This even works on MSWin32.
     my $addr = ${*$self}{io_socket_ip_infos}[${*$self}{io_socket_ip_idx}]{peeraddr};
  
     if( connect( $self, $addr ) or $! == EISCONN ) {
        delete ${*$self}{io_socket_ip_connect_in_progress};
        $! = 0;
        return 1;
     }
     else {
        $! = EINPROGRESS;
        return 0;
     }
  }
  
  sub connected
  {
     my $self = shift;
     return defined $self->fileno &&
            !${*$self}{io_socket_ip_connect_in_progress} &&
            defined getpeername( $self ); # ->peername caches, we need to detect disconnection
  }
  
  =head1 METHODS
  
  As well as the following methods, this class inherits all the methods in
  L<IO::Socket> and L<IO::Handle>.
  
  =cut
  
  sub _get_host_service
  {
     my $self = shift;
     my ( $addr, $flags, $xflags ) = @_;
  
     defined $addr or
        $! = ENOTCONN, return;
  
     $flags |= NI_DGRAM if $self->socktype == SOCK_DGRAM;
  
     my ( $err, $host, $service ) = getnameinfo( $addr, $flags, $xflags || 0 );
     croak "getnameinfo - $err" if $err;
  
     return ( $host, $service );
  }
  
  sub _unpack_sockaddr
  {
     my ( $addr ) = @_;
     my $family = sockaddr_family $addr;
  
     if( $family == AF_INET ) {
        return ( Socket::unpack_sockaddr_in( $addr ) )[1];
     }
     elsif( defined $AF_INET6 and $family == $AF_INET6 ) {
        return ( Socket::unpack_sockaddr_in6( $addr ) )[1];
     }
     else {
        croak "Unrecognised address family $family";
     }
  }
  
  =head2 ( $host, $service ) = $sock->sockhost_service( $numeric )
  
  Returns the hostname and service name of the local address (that is, the
  socket address given by the C<sockname> method).
  
  If C<$numeric> is true, these will be given in numeric form rather than being
  resolved into names.
  
  The following four convenience wrappers may be used to obtain one of the two
  values returned here. If both host and service names are required, this method
  is preferable to the following wrappers, because it will call
  C<getnameinfo(3)> only once.
  
  =cut
  
  sub sockhost_service
  {
     my $self = shift;
     my ( $numeric ) = @_;
  
     $self->_get_host_service( $self->sockname, $numeric ? NI_NUMERICHOST|NI_NUMERICSERV : 0 );
  }
  
  =head2 $addr = $sock->sockhost
  
  Return the numeric form of the local address as a textual representation
  
  =head2 $port = $sock->sockport
  
  Return the numeric form of the local port number
  
  =head2 $host = $sock->sockhostname
  
  Return the resolved name of the local address
  
  =head2 $service = $sock->sockservice
  
  Return the resolved name of the local port number
  
  =cut
  
  sub sockhost { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, NI_NUMERICHOST, NIx_NOSERV ) )[0] }
  sub sockport { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, NI_NUMERICSERV, NIx_NOHOST ) )[1] }
  
  sub sockhostname { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, 0, NIx_NOSERV ) )[0] }
  sub sockservice  { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, 0, NIx_NOHOST ) )[1] }
  
  =head2 $addr = $sock->sockaddr
  
  Return the local address as a binary octet string
  
  =cut
  
  sub sockaddr { my $self = shift; _unpack_sockaddr $self->sockname }
  
  =head2 ( $host, $service ) = $sock->peerhost_service( $numeric )
  
  Returns the hostname and service name of the peer address (that is, the
  socket address given by the C<peername> method), similar to the
  C<sockhost_service> method.
  
  The following four convenience wrappers may be used to obtain one of the two
  values returned here. If both host and service names are required, this method
  is preferable to the following wrappers, because it will call
  C<getnameinfo(3)> only once.
  
  =cut
  
  sub peerhost_service
  {
     my $self = shift;
     my ( $numeric ) = @_;
  
     $self->_get_host_service( $self->peername, $numeric ? NI_NUMERICHOST|NI_NUMERICSERV : 0 );
  }
  
  =head2 $addr = $sock->peerhost
  
  Return the numeric form of the peer address as a textual representation
  
  =head2 $port = $sock->peerport
  
  Return the numeric form of the peer port number
  
  =head2 $host = $sock->peerhostname
  
  Return the resolved name of the peer address
  
  =head2 $service = $sock->peerservice
  
  Return the resolved name of the peer port number
  
  =cut
  
  sub peerhost { my $self = shift; scalar +( $self->_get_host_service( $self->peername, NI_NUMERICHOST, NIx_NOSERV ) )[0] }
  sub peerport { my $self = shift; scalar +( $self->_get_host_service( $self->peername, NI_NUMERICSERV, NIx_NOHOST ) )[1] }
  
  sub peerhostname { my $self = shift; scalar +( $self->_get_host_service( $self->peername, 0, NIx_NOSERV ) )[0] }
  sub peerservice  { my $self = shift; scalar +( $self->_get_host_service( $self->peername, 0, NIx_NOHOST ) )[1] }
  
  =head2 $addr = $peer->peeraddr
  
  Return the peer address as a binary octet string
  
  =cut
  
  sub peeraddr { my $self = shift; _unpack_sockaddr $self->peername }
  
  # This unbelievably dodgy hack works around the bug that IO::Socket doesn't do
  # it
  #    https://rt.cpan.org/Ticket/Display.html?id=61577
  sub accept
  {
     my $self = shift;
     my ( $new, $peer ) = $self->SUPER::accept( @_ ) or return;
  
     ${*$new}{$_} = ${*$self}{$_} for qw( io_socket_domain io_socket_type io_socket_proto );
  
     return wantarray ? ( $new, $peer )
                      : $new;
  }
  
  # This second unbelievably dodgy hack guarantees that $self->fileno doesn't
  # change, which is useful during nonblocking connect
  sub socket :method
  {
     my $self = shift;
     return $self->SUPER::socket(@_) if not defined $self->fileno;
  
     # I hate core prototypes sometimes...
     socket( my $tmph, $_[0], $_[1], $_[2] ) or return undef;
  
     dup2( $tmph->fileno, $self->fileno ) or die "Unable to dup2 $tmph onto $self - $!";
  }
  
  # Versions of IO::Socket before 1.35 may leave socktype undef if from, say, an
  #   ->fdopen call. In this case we'll apply a fix
  BEGIN {
     if( eval($IO::Socket::VERSION) < 1.35 ) {
        *socktype = sub {
           my $self = shift;
           my $type = $self->SUPER::socktype;
           if( !defined $type ) {
              $type = $self->sockopt( Socket::SO_TYPE() );
           }
           return $type;
        };
     }
  }
  
  =head2 $inet = $sock->as_inet
  
  Returns a new L<IO::Socket::INET> instance wrapping the same filehandle. This
  may be useful in cases where it is required, for backward-compatibility, to
  have a real object of C<IO::Socket::INET> type instead of C<IO::Socket::IP>.
  The new object will wrap the same underlying socket filehandle as the
  original, so care should be taken not to continue to use both objects
  concurrently. Ideally the original C<$sock> should be discarded after this
  method is called.
  
  This method checks that the socket domain is C<PF_INET> and will throw an
  exception if it isn't.
  
  =cut
  
  sub as_inet
  {
     my $self = shift;
     croak "Cannot downgrade a non-PF_INET socket to IO::Socket::INET" unless $self->sockdomain == AF_INET;
     return IO::Socket::INET->new_from_fd( $self->fileno, "r+" );
  }
  
  =head1 NON-BLOCKING
  
  If the constructor is passed a defined but false value for the C<Blocking>
  argument then the socket is put into non-blocking mode. When in non-blocking
  mode, the socket will not be set up by the time the constructor returns,
  because the underlying C<connect(2)> syscall would otherwise have to block.
  
  The non-blocking behaviour is an extension of the C<IO::Socket::INET> API,
  unique to C<IO::Socket::IP>, because the former does not support multi-homed
  non-blocking connect.
  
  When using non-blocking mode, the caller must repeatedly check for
  writeability on the filehandle (for instance using C<select> or C<IO::Poll>).
  Each time the filehandle is ready to write, the C<connect> method must be
  called, with no arguments. Note that some operating systems, most notably
  C<MSWin32> do not report a C<connect()> failure using write-ready; so you must
  also C<select()> for exceptional status.
  
  While C<connect> returns false, the value of C<$!> indicates whether it should
  be tried again (by being set to the value C<EINPROGRESS>, or C<EWOULDBLOCK> on
  MSWin32), or whether a permanent error has occurred (e.g. C<ECONNREFUSED>).
  
  Once the socket has been connected to the peer, C<connect> will return true
  and the socket will now be ready to use.
  
  Note that calls to the platform's underlying C<getaddrinfo(3)> function may
  block. If C<IO::Socket::IP> has to perform this lookup, the constructor will
  block even when in non-blocking mode.
  
  To avoid this blocking behaviour, the caller should pass in the result of such
  a lookup using the C<PeerAddrInfo> or C<LocalAddrInfo> arguments. This can be
  achieved by using L<Net::LibAsyncNS>, or the C<getaddrinfo(3)> function can be
  called in a child process.
  
   use IO::Socket::IP;
   use Errno qw( EINPROGRESS EWOULDBLOCK );
  
   my @peeraddrinfo = ... # Caller must obtain the getaddinfo result here
  
   my $socket = IO::Socket::IP->new(
      PeerAddrInfo => \@peeraddrinfo,
      Blocking     => 0,
   ) or die "Cannot construct socket - $@";
  
   while( !$socket->connect and ( $! == EINPROGRESS || $! == EWOULDBLOCK ) ) {
      my $wvec = '';
      vec( $wvec, fileno $socket, 1 ) = 1;
      my $evec = '';
      vec( $evec, fileno $socket, 1 ) = 1;
  
      select( undef, $wvec, $evec, undef ) or die "Cannot select - $!";
   }
  
   die "Cannot connect - $!" if $!;
  
   ...
  
  The example above uses C<select()>, but any similar mechanism should work
  analogously. C<IO::Socket::IP> takes care when creating new socket filehandles
  to preserve the actual file descriptor number, so such techniques as C<poll>
  or C<epoll> should be transparent to its reallocation of a different socket
  underneath, perhaps in order to switch protocol family between C<PF_INET> and
  C<PF_INET6>.
  
  For another example using C<IO::Poll> and C<Net::LibAsyncNS>, see the
  F<examples/nonblocking_libasyncns.pl> file in the module distribution.
  
  =cut
  
  =head1 C<PeerHost> AND C<LocalHost> PARSING
  
  To support the C<IO::Socket::INET> API, the host and port information may be
  passed in a single string rather than as two separate arguments.
  
  If either C<LocalHost> or C<PeerHost> (or their C<...Addr> synonyms) have any
  of the following special forms then special parsing is applied.
  
  The value of the C<...Host> argument will be split to give both the hostname
  and port (or service name):
  
   hostname.example.org:http    # Host name
   192.0.2.1:80                 # IPv4 address
   [2001:db8::1]:80             # IPv6 address
  
  In each case, the port or service name (e.g. C<80>) is passed as the
  C<LocalService> or C<PeerService> argument.
  
  Either of C<LocalService> or C<PeerService> (or their C<...Port> synonyms) can
  be either a service name, a decimal number, or a string containing both a
  service name and number, in a form such as
  
   http(80)
  
  In this case, the name (C<http>) will be tried first, but if the resolver does
  not understand it then the port number (C<80>) will be used instead.
  
  If the C<...Host> argument is in this special form and the corresponding
  C<...Service> or C<...Port> argument is also defined, the one parsed from
  the C<...Host> argument will take precedence and the other will be ignored.
  
  =head2 ( $host, $port ) = IO::Socket::IP->split_addr( $addr )
  
  Utility method that provides the parsing functionality described above.
  Returns a 2-element list, containing either the split hostname and port
  description if it could be parsed, or the given address and C<undef> if it was
  not recognised.
  
   IO::Socket::IP->split_addr( "hostname:http" )
                                # ( "hostname",  "http" )
  
   IO::Socket::IP->split_addr( "192.0.2.1:80" )
                                # ( "192.0.2.1", "80"   )
  
   IO::Socket::IP->split_addr( "[2001:db8::1]:80" )
                                # ( "2001:db8::1", "80" )
  
   IO::Socket::IP->split_addr( "something.else" )
                                # ( "something.else", undef )
  
  =cut
  
  sub split_addr
  {
     shift;
     my ( $addr ) = @_;
  
     local ( $1, $2 ); # Placate a taint-related bug; [perl #67962]
     if( $addr =~ m/\A\[($IPv6_re)\](?::([^\s:]*))?\z/ or
         $addr =~ m/\A([^\s:]*):([^\s:]*)\z/ ) {
        return ( $1, $2 ) if defined $2 and length $2;
        return ( $1, undef );
     }
  
     return ( $addr, undef );
  }
  
  =head2 $addr = IO::Socket::IP->join_addr( $host, $port )
  
  Utility method that performs the reverse of C<split_addr>, returning a string
  formed by joining the specified host address and port number. The host address
  will be wrapped in C<[]> brackets if required (because it is a raw IPv6
  numeric address).
  
  This can be especially useful when combined with the C<sockhost_service> or
  C<peerhost_service> methods.
  
   say "Connected to ", IO::Socket::IP->join_addr( $sock->peerhost_service );
  
  =cut
  
  sub join_addr
  {
     shift;
     my ( $host, $port ) = @_;
  
     $host = "[$host]" if $host =~ m/:/;
  
     return join ":", $host, $port if defined $port;
     return $host;
  }
  
  # Since IO::Socket->new( Domain => ... ) will delete the Domain parameter
  # before calling ->configure, we need to keep track of which it was
  
  package # hide from indexer
     IO::Socket::IP::_ForINET;
  use base qw( IO::Socket::IP );
  
  sub configure
  {
     # This is evil
     my $self = shift;
     my ( $arg ) = @_;
  
     bless $self, "IO::Socket::IP";
     $self->configure( { %$arg, Family => Socket::AF_INET() } );
  }
  
  package # hide from indexer
     IO::Socket::IP::_ForINET6;
  use base qw( IO::Socket::IP );
  
  sub configure
  {
     # This is evil
     my $self = shift;
     my ( $arg ) = @_;
  
     bless $self, "IO::Socket::IP";
     $self->configure( { %$arg, Family => Socket::AF_INET6() } );
  }
  
  =head1 C<IO::Socket::INET> INCOMPATIBILITES
  
  =over 4
  
  =item *
  
  The behaviour enabled by C<MultiHomed> is in fact implemented by
  C<IO::Socket::IP> as it is required to correctly support searching for a
  useable address from the results of the C<getaddrinfo(3)> call. The
  constructor will ignore the value of this argument, except if it is defined
  but false. An exception is thrown in this case, because that would request it
  disable the C<getaddrinfo(3)> search behaviour in the first place.
  
  =item *
  
  C<IO::Socket::IP> implements both the C<Blocking> and C<Timeout> parameters,
  but it implements the interaction of both in a different way.
  
  In C<::INET>, supplying a timeout overrides the non-blocking behaviour,
  meaning that the C<connect()> operation will still block despite that the
  caller asked for a non-blocking socket. This is not explicitly specified in
  its documentation, nor does this author believe that is a useful behaviour -
  it appears to come from a quirk of implementation.
  
  In C<::IP> therefore, the C<Blocking> parameter takes precedence - if a
  non-blocking socket is requested, no operation will block. The C<Timeout>
  parameter here simply defines the maximum time that a blocking C<connect()>
  call will wait, if it blocks at all.
  
  In order to specifically obtain the "blocking connect then non-blocking send
  and receive" behaviour of specifying this combination of options to C<::INET>
  when using C<::IP>, perform first a blocking connect, then afterwards turn the
  socket into nonblocking mode.
  
   my $sock = IO::Socket::IP->new(
      PeerHost => $peer,
      Timeout => 20,
   ) or die "Cannot connect - $@";
  
   $sock->blocking( 0 );
  
  This code will behave identically under both C<IO::Socket::INET> and
  C<IO::Socket::IP>.
  
  =back
  
  =cut
  
  =head1 TODO
  
  =over 4
  
  =item *
  
  Investigate whether C<POSIX::dup2> upsets BSD's C<kqueue> watchers, and if so,
  consider what possible workarounds might be applied.
  
  =back
  
  =head1 AUTHOR
  
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  0x55AA;
IO_SOCKET_IP

$fatpacked{"IO/Socket/SSL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_SOCKET_SSL';
  #vim: set sts=4 sw=4 ts=8 ai:
  #
  # IO::Socket::SSL:
  # provide an interface to SSL connections similar to IO::Socket modules
  #
  # Current Code Shepherd: Steffen Ullrich <sullr at cpan.org>
  # Code Shepherd before: Peter Behroozi, <behrooz at fas.harvard.edu>
  #
  # The original version of this module was written by
  # Marko Asplund, <marko.asplund at kronodoc.fi>, who drew from
  # Crypt::SSLeay (Net::SSL) by Gisle Aas.
  #
  
  package IO::Socket::SSL;
  
  our $VERSION = '2.056';
  
  use IO::Socket;
  use Net::SSLeay 1.46;
  use IO::Socket::SSL::PublicSuffix;
  use Exporter ();
  use Errno qw( EWOULDBLOCK EAGAIN ETIMEDOUT EINTR EPIPE );
  use Carp;
  use strict;
  
  my $use_threads;
  BEGIN {
      die "no support for weaken - please install Scalar::Util" if ! do {
  	local $SIG{__DIE__};
  	eval { require Scalar::Util; Scalar::Util->import("weaken"); 1 }
  	    || eval { require WeakRef; WeakRef->import("weaken"); 1 }
      };
      require Config;
      $use_threads = $Config::Config{usethreads};
  }
  
  
  # results from commonly used constant functions from Net::SSLeay for fast access
  my $Net_SSLeay_ERROR_WANT_READ   = Net::SSLeay::ERROR_WANT_READ();
  my $Net_SSLeay_ERROR_WANT_WRITE  = Net::SSLeay::ERROR_WANT_WRITE();
  my $Net_SSLeay_ERROR_SYSCALL     = Net::SSLeay::ERROR_SYSCALL();
  my $Net_SSLeay_VERIFY_NONE       = Net::SSLeay::VERIFY_NONE();
  my $Net_SSLeay_VERIFY_PEER       = Net::SSLeay::VERIFY_PEER();
  
  
  use constant SSL_VERIFY_NONE => &Net::SSLeay::VERIFY_NONE;
  use constant SSL_VERIFY_PEER => &Net::SSLeay::VERIFY_PEER;
  use constant SSL_VERIFY_FAIL_IF_NO_PEER_CERT => Net::SSLeay::VERIFY_FAIL_IF_NO_PEER_CERT();
  use constant SSL_VERIFY_CLIENT_ONCE => Net::SSLeay::VERIFY_CLIENT_ONCE();
  
  # from openssl/ssl.h; should be better in Net::SSLeay
  use constant SSL_SENT_SHUTDOWN => 1;
  use constant SSL_RECEIVED_SHUTDOWN => 2;
  
  use constant SSL_OCSP_NO_STAPLE   => 0b00001;
  use constant SSL_OCSP_MUST_STAPLE => 0b00010;
  use constant SSL_OCSP_FAIL_HARD   => 0b00100;
  use constant SSL_OCSP_FULL_CHAIN  => 0b01000;
  use constant SSL_OCSP_TRY_STAPLE  => 0b10000;
  
  # capabilities of underlying Net::SSLeay/openssl
  my $can_client_sni;  # do we support SNI on the client side
  my $can_server_sni;  # do we support SNI on the server side
  my $can_npn;         # do we support NPN (obsolete)
  my $can_alpn;        # do we support ALPN
  my $can_ecdh;        # do we support ECDH key exchange
  my $can_ocsp;        # do we support OCSP
  my $can_ocsp_staple; # do we support OCSP stapling
  my $can_tckt_keycb;  # TLS ticket key callback
  BEGIN {
      $can_client_sni = Net::SSLeay::OPENSSL_VERSION_NUMBER() >= 0x01000000;
      $can_server_sni = defined &Net::SSLeay::get_servername;
      if ($can_npn = defined &Net::SSLeay::P_next_proto_negotiated and
  	Net::SSLeay::SSLeay_version(0) =~m{^LibreSSL\s+(\d+)\.(\d+)\.(\d+)}) {
  	# LibreSSL 2.6.1 disabled NPN by keeping the relevant functions
  	# available but remove the actual functionality from these functions. It
  	# does not set OPENSSL_NO_NEXTPROTONEG as OpenSSL does in case NPN is
  	# not supported, which means one need to rely on checking the LibreSSL
  	# version instead.
  	$can_npn =
  	    $1 < 2 ? $can_npn :       # version 1.x.y
  	    $1 > 2 ? 0 :              # version 3.x.y
  	    $2 < 6 ? $can_npn :       # version 2.5.y and lower
  	    $2 > 6 ? 0 :              # version 2.7.y and higher
  	    $3 == 0 ? $can_npn :      # version 2.6.0
  	    0;                        # version 2.6.1 and higher
      }
      $can_alpn       = defined &Net::SSLeay::CTX_set_alpn_protos;
      $can_ecdh       = defined &Net::SSLeay::CTX_set_tmp_ecdh &&
  	# There is a regression with elliptic curves on 1.0.1d with 64bit
  	# http://rt.openssl.org/Ticket/Display.html?id=2975
  	( Net::SSLeay::OPENSSL_VERSION_NUMBER() != 0x1000104f
  	|| length(pack("P",0)) == 4 );
      $can_ocsp        = defined &Net::SSLeay::OCSP_cert2ids
  	# OCSP got broken in 1.75..1.77
  	&& ($Net::SSLeay::VERSION < 1.75 || $Net::SSLeay::VERSION > 1.77);
      $can_ocsp_staple = $can_ocsp
  	&& defined &Net::SSLeay::set_tlsext_status_type;
      $can_tckt_keycb  = defined &Net::SSLeay::CTX_set_tlsext_ticket_getkey_cb
  	&& $Net::SSLeay::VERSION >= 1.80;  
  }
  
  my $algo2digest = do {
      my %digest;
      sub {
  	my $digest_name = shift;
  	return $digest{$digest_name} ||= do {
  	    Net::SSLeay::SSLeay_add_ssl_algorithms();
  	    Net::SSLeay::EVP_get_digestbyname($digest_name)
  		or die "Digest algorithm $digest_name is not available";
  	};
      }
  };
  
  
  # global defaults
  my %DEFAULT_SSL_ARGS = (
      SSL_check_crl => 0,
      SSL_version => 'SSLv23:!SSLv3:!SSLv2', # consider both SSL3.0 and SSL2.0 as broken
      SSL_verify_callback => undef,
      SSL_verifycn_scheme => undef,  # fallback cn verification
      SSL_verifycn_publicsuffix => undef,  # fallback default list verification
      #SSL_verifycn_name => undef,   # use from PeerAddr/PeerHost - do not override in set_args_filter_hack 'use_defaults'
      SSL_npn_protocols => undef,    # meaning depends whether on server or client side
      SSL_alpn_protocols => undef,   # list of protocols we'll accept/send, for example ['http/1.1','spdy/3.1']
  
      # https://wiki.mozilla.org/Security/Server_Side_TLS, 2016/04/20
      # "Old backward compatibility" for best compatibility
      # .. "Most ciphers that are not clearly broken and dangerous to use are supported"
      SSL_cipher_list => 'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:ECDHE-RSA-DES-CBC3-SHA:ECDHE-ECDSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:DES-CBC3-SHA:HIGH:SEED:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!RSAPSK:!aDH:!aECDH:!EDH-DSS-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA:!SRP',
  );
  
  my %DEFAULT_SSL_CLIENT_ARGS = (
      %DEFAULT_SSL_ARGS,
      SSL_verify_mode => SSL_VERIFY_PEER,
  
      SSL_ca_file => undef,
      SSL_ca_path => undef,
  
      # older versions of F5 BIG-IP hang when getting SSL client hello >255 bytes
      # http://support.f5.com/kb/en-us/solutions/public/13000/000/sol13037.html
      # http://guest:guest@rt.openssl.org/Ticket/Display.html?id=2771
      # Ubuntu worked around this by disabling TLSv1_2 on the client side for
      # a while. Later a padding extension was added to OpenSSL to work around
      # broken F5 but then IronPort croaked because it did not understand this
      # extension so it was disabled again :(
      # Firefox, Chrome and IE11 use TLSv1_2 but use only a few ciphers, so
      # that packet stays small enough. We try the same here.
  
      SSL_cipher_list => join(" ",
  
  	# SSLabs report for Chrome 48/OSX. 
  	# This also includes the fewer ciphers Firefox uses.
  	'ECDHE-ECDSA-AES128-GCM-SHA256',
  	'ECDHE-RSA-AES128-GCM-SHA256',
  	'DHE-RSA-AES128-GCM-SHA256',
  	'ECDHE-ECDSA-CHACHA20-POLY1305',
  	'ECDHE-RSA-CHACHA20-POLY1305',
  	'ECDHE-ECDSA-AES256-SHA',
  	'ECDHE-RSA-AES256-SHA',
  	'DHE-RSA-AES256-SHA',
  	'ECDHE-ECDSA-AES128-SHA',
  	'ECDHE-RSA-AES128-SHA',
  	'DHE-RSA-AES128-SHA',
  	'AES128-GCM-SHA256',
  	'AES256-SHA',
  	'AES128-SHA',
  	'DES-CBC3-SHA',
  
  	# IE11/Edge has some more ciphers, notably SHA384 and DSS
  	# we don't offer the *-AES128-SHA256 and *-AES256-SHA384 non-GCM
  	# ciphers IE/Edge offers because they look like a large mismatch
  	# between a very strong HMAC and a comparably weak (but sufficient)
  	# encryption. Similar all browsers which do SHA384 can do ECDHE
  	# so skip the DHE*SHA384 ciphers.
  	'ECDHE-RSA-AES256-GCM-SHA384',
  	'ECDHE-ECDSA-AES256-GCM-SHA384',
  	# 'ECDHE-RSA-AES256-SHA384',
  	# 'ECDHE-ECDSA-AES256-SHA384',
  	# 'ECDHE-RSA-AES128-SHA256',
  	# 'ECDHE-ECDSA-AES128-SHA256',
  	# 'DHE-RSA-AES256-GCM-SHA384',
  	# 'AES256-GCM-SHA384',
  	'AES256-SHA256',
  	# 'AES128-SHA256',
  	'DHE-DSS-AES256-SHA256',
  	# 'DHE-DSS-AES128-SHA256',
  	'DHE-DSS-AES256-SHA',
  	'DHE-DSS-AES128-SHA',
  	'EDH-DSS-DES-CBC3-SHA',
  
  	# Just to make sure, that we don't accidentally add bad ciphers above.
  	# This includes dropping RC4 which is no longer supported by modern
  	# browsers and also excluded in the SSL libraries of Python and Ruby.
  	"!EXP !MEDIUM !LOW !eNULL !aNULL !RC4 !DES !MD5 !PSK !SRP"
      )
  );
  
  # set values inside _init to work with perlcc, RT#95452
  my %DEFAULT_SSL_SERVER_ARGS;
  
  # Initialization of OpenSSL internals
  # This will be called once during compilation - perlcc users might need to
  # call it again by hand, see RT#95452
  {
      sub init {
  	# library_init returns false if the library was already initialized.
  	# This way we can find out if the library needs to be re-initialized
  	# inside code compiled with perlcc
  	Net::SSLeay::library_init() or return; 
  
  	Net::SSLeay::load_error_strings();
  	Net::SSLeay::OpenSSL_add_all_digests();
  	Net::SSLeay::randomize();
  
  	%DEFAULT_SSL_SERVER_ARGS = (
  	    %DEFAULT_SSL_ARGS,
  	    SSL_verify_mode => SSL_VERIFY_NONE,
  	    SSL_honor_cipher_order => 1,  # trust server to know the best cipher
  	    SSL_dh => do {
  		my $bio = Net::SSLeay::BIO_new(Net::SSLeay::BIO_s_mem());
  		# generated with: openssl dhparam 2048
  		Net::SSLeay::BIO_write($bio,<<'DH');
  -----BEGIN DH PARAMETERS-----
  MIIBCAKCAQEAr8wskArj5+1VCVsnWt/RUR7tXkHJ7mGW7XxrLSPOaFyKyWf8lZht
  iSY2Lc4oa4Zw8wibGQ3faeQu/s8fvPq/aqTxYmyHPKCMoze77QJHtrYtJAosB9SY
  CN7s5Hexxb5/vQ4qlQuOkVrZDiZO9GC4KaH9mJYnCoAsXDhDft6JT0oRVSgtZQnU
  gWFKShIm+JVjN94kGs0TcBEesPTK2g8XVHK9H8AtSUb9BwW2qD/T5RmgNABysApO
  Ps2vlkxjAHjJcqc3O+OiImKik/X2rtBTZjpKmzN3WWTB0RJZCOWaLlDO81D01o1E
  aZecz3Np9KIYey900f+X7zC2bJxEHp95ywIBAg==
  -----END DH PARAMETERS-----
  DH
  		my $dh = Net::SSLeay::PEM_read_bio_DHparams($bio);
  		Net::SSLeay::BIO_free($bio);
  		$dh or die "no DH";
  		$dh;
  	    },
  	    $can_ecdh ? ( SSL_ecdh_curve => 'prime256v1' ):(),
  	);
      }
      # Call it once at compile time and try it at INIT.
      # This should catch all cases of including the module, e.g. 'use' (INIT) or
      # 'require' (compile time) and works also with perlcc
      {
  	no warnings;
  	INIT { init() }
  	init();
      }
  }
  
  # global defaults which can be changed using set_defaults
  # either key/value can be set or it can just be set to an external hash
  my $GLOBAL_SSL_ARGS = {};
  my $GLOBAL_SSL_CLIENT_ARGS = {};
  my $GLOBAL_SSL_SERVER_ARGS = {};
  
  # hack which is used to filter bad settings from used modules
  my $FILTER_SSL_ARGS = undef;
  
  # non-XS Versions of Scalar::Util will fail
  BEGIN{
      die "You need the XS Version of Scalar::Util for dualvar() support" if !do {
  	local $SIG{__DIE__}; local $SIG{__WARN__}; # be silent
  	eval { use Scalar::Util 'dualvar'; dualvar(0,''); 1 };
      };
  }
  
  # get constants for SSL_OP_NO_* now, instead calling the related functions
  # every time we setup a connection
  my %SSL_OP_NO;
  for(qw( SSLv2 SSLv3 TLSv1 TLSv1_1 TLSv11:TLSv1_1 TLSv1_2 TLSv12:TLSv1_2 )) {
      my ($k,$op) = m{:} ? split(m{:},$_,2) : ($_,$_);
      my $sub = "Net::SSLeay::OP_NO_$op";
      local $SIG{__DIE__};
      $SSL_OP_NO{$k} = eval { no strict 'refs'; &$sub } || 0;
  }
  
  # Make SSL_CTX_clear_options accessible through SSL_CTX_ctrl unless it is
  # already implemented in Net::SSLeay
  if (!defined &Net::SSLeay::CTX_clear_options) {
      *Net::SSLeay::CTX_clear_options = sub {
  	my ($ctx,$opt) = @_;
  	# 77 = SSL_CTRL_CLEAR_OPTIONS
  	Net::SSLeay::CTX_ctrl($ctx,77,$opt,0);
      };
  }
  
  # Try to work around problems with alternative trust path by default, RT#104759
  my $DEFAULT_X509_STORE_flags = 0;
  {
      local $SIG{__DIE__};
      eval { $DEFAULT_X509_STORE_flags |= Net::SSLeay::X509_V_FLAG_TRUSTED_FIRST() };
  }
  
  our $DEBUG;
  use vars qw(@ISA $SSL_ERROR @EXPORT);
  
  {
      # These constants will be used in $! at return from SSL_connect,
      # SSL_accept, _generic_(read|write), thus notifying the caller
      # the usual way of problems. Like with EWOULDBLOCK, EINPROGRESS..
      # these are especially important for non-blocking sockets
  
      my $x = $Net_SSLeay_ERROR_WANT_READ;
      use constant SSL_WANT_READ  => dualvar( \$x, 'SSL wants a read first' );
      my $y = $Net_SSLeay_ERROR_WANT_WRITE;
      use constant SSL_WANT_WRITE => dualvar( \$y, 'SSL wants a write first' );
  
      @EXPORT = qw(
  	SSL_WANT_READ SSL_WANT_WRITE SSL_VERIFY_NONE SSL_VERIFY_PEER
  	SSL_VERIFY_FAIL_IF_NO_PEER_CERT SSL_VERIFY_CLIENT_ONCE
  	SSL_OCSP_NO_STAPLE SSL_OCSP_TRY_STAPLE SSL_OCSP_MUST_STAPLE
  	SSL_OCSP_FAIL_HARD SSL_OCSP_FULL_CHAIN
  	$SSL_ERROR GEN_DNS GEN_IPADD
      );
  }
  
  my @caller_force_inet4; # in case inet4 gets forced we store here who forced it
  
  my $IOCLASS;
  my $family_key; # 'Domain'||'Family'
  BEGIN {
      # declare @ISA depending of the installed socket class
  
      # try to load inet_pton from Socket or Socket6 and make sure it is usable
      local $SIG{__DIE__}; local $SIG{__WARN__}; # be silent
      my $ip6 = eval {
  	require Socket;
  	Socket->VERSION(1.95);
  	Socket::inet_pton( AF_INET6(),'::1') && AF_INET6() or die;
  	Socket->import( qw/inet_pton NI_NUMERICHOST NI_NUMERICSERV/ );
  	# behavior different to Socket6::getnameinfo - wrap
  	*_getnameinfo = sub { 
  	    my ($err,$host,$port) = Socket::getnameinfo(@_) or return; 
  	    return if $err;
  	    return ($host,$port);
  	};
  	1;
      } || eval {
  	require Socket6;
  	Socket6::inet_pton( AF_INET6(),'::1') && AF_INET6() or die;
  	Socket6->import( qw/inet_pton NI_NUMERICHOST NI_NUMERICSERV/ );
  	# behavior different to Socket::getnameinfo - wrap
  	*_getnameinfo = sub { return Socket6::getnameinfo(@_); };
  	1;
      };
  
      # try IO::Socket::IP or IO::Socket::INET6 for IPv6 support
      $family_key = 'Domain'; # traditional
      if ( $ip6 ) {
  	# if we have IO::Socket::IP >= 0.31 we will use this in preference
  	# because it can handle both IPv4 and IPv6
  	if ( eval { 
  	    require IO::Socket::IP; 
  	    IO::Socket::IP->VERSION(0.31)
  	}) {
  	    @ISA = qw(IO::Socket::IP);
  	    constant->import( CAN_IPV6 => "IO::Socket::IP" );
  	    $family_key = 'Family';
  	    $IOCLASS = "IO::Socket::IP";
  
  	# if we have IO::Socket::INET6 we will use this not IO::Socket::INET
  	# because it can handle both IPv4 and IPv6
  	# require at least 2.62 because of several problems before that version
  	} elsif( eval { require IO::Socket::INET6; IO::Socket::INET6->VERSION(2.62) } ) {
  	    @ISA = qw(IO::Socket::INET6);
  	    constant->import( CAN_IPV6 => "IO::Socket::INET6" );
  	    $IOCLASS = "IO::Socket::INET6";
  	} else {
  	    $ip6 = 0;
  	}
      }
  
      # fall back to IO::Socket::INET for IPv4 only
      if ( ! $ip6 ) {
  	@ISA = qw(IO::Socket::INET);
  	$IOCLASS = "IO::Socket::INET";
  	constant->import(CAN_IPV6 => '');
  	constant->import(NI_NUMERICHOST => 1);
  	constant->import(NI_NUMERICSERV => 2);
      }
  
      #Make $DEBUG another name for $Net::SSLeay::trace
      *DEBUG = \$Net::SSLeay::trace;
  
      #Compatibility
      *ERROR = \$SSL_ERROR;
  }
  
  
  sub DEBUG {
      $DEBUG or return;
      my (undef,$file,$line,$sub) = caller(1);
      if ($sub =~m{^IO::Socket::SSL::(?:error|(_internal_error))$}) {
  	(undef,$file,$line) = caller(2) if $1;
      } else {
  	(undef,$file,$line) = caller;
      }
      my $msg = shift;
      $file = '...'.substr( $file,-17 ) if length($file)>20;
      $msg = sprintf $msg,@_ if @_;
      print STDERR "DEBUG: $file:$line: $msg\n";
  }
  
  BEGIN {
      # import some constants from Net::SSLeay or use hard-coded defaults
      # if Net::SSLeay isn't recent enough to provide the constants
      my %const = (
  	NID_CommonName => 13,
  	GEN_DNS => 2,
  	GEN_IPADD => 7,
      );
      while ( my ($name,$value) = each %const ) {
  	no strict 'refs';
  	*{$name} = UNIVERSAL::can( 'Net::SSLeay', $name ) || sub { $value };
      }
  
      *idn_to_ascii = \&IO::Socket::SSL::PublicSuffix::idn_to_ascii;
      *idn_to_unicode = \&IO::Socket::SSL::PublicSuffix::idn_to_unicode;
  }
  
  my $OPENSSL_LIST_SEPARATOR = $^O =~m{^(?:(dos|os2|mswin32|netware)|vms)$}i
      ? $1 ? ';' : ',' : ':';
  my $CHECK_SSL_PATH = sub {
      my %args = (@_ == 1) ? ('',@_) : @_;
      for my $type (keys %args) {
  	my $path = $args{$type};
  	if (!$type) {
  	    delete $args{$type};
  	    $type = (ref($path) || -d $path) ? 'SSL_ca_path' : 'SSL_ca_file';
  	    $args{$type} = $path;
  	}
  
  	next if ref($path) eq 'SCALAR' && ! $$path;
  	if ($type eq 'SSL_ca_file') {
  	    die "SSL_ca_file $path can't be used: $!"
  		if ! open(my $fh,'<',$path);
  	} elsif ($type eq 'SSL_ca_path') {
  	    $path = [ split($OPENSSL_LIST_SEPARATOR,$path) ] if !ref($path);
  	    my @err;
  	    for my $d (ref($path) ? @$path : $path) {
  		if (! -d $d) {
  		    push @err, "SSL_ca_path $d does not exist";
  		} elsif (! opendir(my $dh,$d)) {
  		    push @err, "SSL_ca_path $d is not accessible: $!"
  		} else {
  		    @err = ();
  		    last
  		}
  	    }
  	    die "@err" if @err;
  	}
      }
      return %args;
  };
  
  
  {
      my %default_ca;
      my $ca_detected; # 0: never detect, undef: need to (re)detect
      my $openssldir;
  
      sub default_ca {
  	if (@_) {
  	    # user defined default CA or reset
  	    if ( @_ > 1 ) {
  		%default_ca = @_;
  		$ca_detected  = 0;
  	    } elsif ( my $path = shift ) {
  		%default_ca = $CHECK_SSL_PATH->($path);
  		$ca_detected  = 0;
  	    } else {
  		$ca_detected = undef;
  	    }
  	}
  	return %default_ca if defined $ca_detected;
  
  	# SSLEAY_DIR was 5 up to OpenSSL 1.1, then switched to 4 and got
  	# renamed to OPENSSL_DIR. Unfortunately it is not exported as constant
  	# by Net::SSLeay so we use the fixed number.
  	$openssldir ||=
  	    Net::SSLeay::SSLeay_version(5) =~m{^OPENSSLDIR: "(.+)"$} ? $1 :
  	    Net::SSLeay::SSLeay_version(4) =~m{^OPENSSLDIR: "(.+)"$} ? $1 :
  	    'cannot-determine-openssldir-from-ssleay-version';
  
  	# (re)detect according to openssl crypto/cryptlib.h
  	my $dir = $ENV{SSL_CERT_DIR}
  	    || ( $^O =~m{vms}i ? "SSLCERTS:":"$openssldir/certs" );
  	if ( opendir(my $dh,$dir)) {
  	    FILES: for my $f (  grep { m{^[a-f\d]{8}(\.\d+)?$} } readdir($dh) ) {
  		open( my $fh,'<',"$dir/$f") or next;
  		while (my $line = <$fh>) {
  		    $line =~m{^-+BEGIN (X509 |TRUSTED |)CERTIFICATE-} or next;
  		    $default_ca{SSL_ca_path} = $dir;
  		    last FILES;
  		}
  	    }
  	}
  	my $file = $ENV{SSL_CERT_FILE}
  	    || ( $^O =~m{vms}i ? "SSLCERTS:cert.pem":"$openssldir/cert.pem" );
  	if ( open(my $fh,'<',$file)) {
  	    while (my $line = <$fh>) {
  		$line =~m{^-+BEGIN (X509 |TRUSTED |)CERTIFICATE-} or next;
  		$default_ca{SSL_ca_file} = $file;
  		last;
  	    }
  	}
  
  	$default_ca{SSL_ca_file} = Mozilla::CA::SSL_ca_file() if ! %default_ca && do {
  		local $SIG{__DIE__};
  		eval { require Mozilla::CA; 1 };
  	    };
  
  	$ca_detected = 1;
  	return %default_ca;
      }
  }
  
  
  # Export some stuff
  # inet4|inet6|debug will be handled by myself, everything
  # else will be handled the Exporter way
  sub import {
      my $class = shift;
  
      my @export;
      foreach (@_) {
  	if ( /^inet4$/i ) {
  	    # explicitly fall back to inet4
  	    @ISA = 'IO::Socket::INET';
  	    @caller_force_inet4 = caller(); # save for warnings for 'inet6' case
  	} elsif ( /^inet6$/i ) {
  	    # check if we have already ipv6 as base
  	    if ( ! UNIVERSAL::isa( $class, 'IO::Socket::INET6')
  		and ! UNIVERSAL::isa( $class, 'IO::Socket::IP' )) {
  		# either we don't support it or we disabled it by explicitly
  		# loading it with 'inet4'. In this case re-enable but warn
  		# because this is probably an error
  		if ( CAN_IPV6 ) {
  		    @ISA = ( CAN_IPV6 );
  		    warn "IPv6 support re-enabled in __PACKAGE__, got disabled in file $caller_force_inet4[1] line $caller_force_inet4[2]";
  		} else {
  		    die "INET6 is not supported, install IO::Socket::IP";
  		}
  	    }
  	} elsif ( /^:?debug(\d+)/ ) {
  	    $DEBUG=$1;
  	} else {
  	    push @export,$_
  	}
      }
  
      @_ = ( $class,@export );
      goto &Exporter::import;
  }
  
  my %SSL_OBJECT;
  my %CREATED_IN_THIS_THREAD;
  sub CLONE { %CREATED_IN_THIS_THREAD = (); }
  
  # all keys used internally, these should be cleaned up at end
  my @all_my_keys = qw(
      _SSL_arguments
      _SSL_certificate
      _SSL_ctx
      _SSL_fileno
      _SSL_in_DESTROY
      _SSL_ioclass_downgrade
      _SSL_ioclass_upgraded
      _SSL_last_err
      _SSL_object
      _SSL_ocsp_verify
      _SSL_opened
      _SSL_opening
      _SSL_servername
  );
  
  
  # we have callbacks associated with contexts, but have no way to access the
  # current SSL object from these callbacks. To work around this
  # CURRENT_SSL_OBJECT will be set before calling Net::SSLeay::{connect,accept}
  # and reset afterwards, so we have access to it inside _internal_error.
  my $CURRENT_SSL_OBJECT;
  
  # You might be expecting to find a new() subroutine here, but that is
  # not how IO::Socket::INET works.  All configuration gets performed in
  # the calls to configure() and either connect() or accept().
  
  #Call to configure occurs when a new socket is made using
  #IO::Socket::INET.  Returns false (empty list) on failure.
  sub configure {
      my ($self, $arg_hash) = @_;
      return _invalid_object() unless($self);
  
      # force initial blocking
      # otherwise IO::Socket::SSL->new might return undef if the
      # socket is nonblocking and it fails to connect immediately
      # for real nonblocking behavior one should create a nonblocking
      # socket and later call connect explicitly
      my $blocking = delete $arg_hash->{Blocking};
  
      # because Net::HTTPS simple redefines blocking() to {} (e.g.
      # return undef) and IO::Socket::INET does not like this we
      # set Blocking only explicitly if it was set
      $arg_hash->{Blocking} = 1 if defined ($blocking);
  
      $self->configure_SSL($arg_hash) || return;
  
      if ($arg_hash->{$family_key} ||= $arg_hash->{Domain} || $arg_hash->{Family}) {
  	# Hack to work around the problem that IO::Socket::IP defaults to
  	# AI_ADDRCONFIG which creates problems if we have only the loopback
  	# interface. If we already know the family this flag is more harmful
  	# then useful.
  	$arg_hash->{GetAddrInfoFlags} = 0 if $IOCLASS eq 'IO::Socket::IP'
  		&& ! defined $arg_hash->{GetAddrInfoFlags};
      }
      return $self->_internal_error("@ISA configuration failed",0)
  	if ! $self->SUPER::configure($arg_hash);
  
      $self->blocking(0) if defined $blocking && !$blocking;
      return $self;
  }
  
  sub configure_SSL {
      my ($self, $arg_hash) = @_;
  
      $arg_hash->{Proto} ||= 'tcp';
      my $is_server = $arg_hash->{SSL_server};
      if ( ! defined $is_server ) {
  	$is_server = $arg_hash->{SSL_server} = $arg_hash->{Listen} || 0;
      }
  
      # add user defined defaults, maybe after filtering
      $FILTER_SSL_ARGS->($is_server,$arg_hash) if $FILTER_SSL_ARGS;
  
      delete @{*$self}{@all_my_keys};
      ${*$self}{_SSL_opened} = $is_server;
      ${*$self}{_SSL_arguments} = $arg_hash;
  
      # this adds defaults to $arg_hash as a side effect!
      ${*$self}{'_SSL_ctx'} = IO::Socket::SSL::SSL_Context->new($arg_hash)
  	or return;
  
      return $self;
  }
  
  
  sub _skip_rw_error {
      my ($self,$ssl,$rv) = @_;
      my $err = Net::SSLeay::get_error($ssl,$rv);
      if ( $err == $Net_SSLeay_ERROR_WANT_READ) {
  	$SSL_ERROR = SSL_WANT_READ;
      } elsif ( $err == $Net_SSLeay_ERROR_WANT_WRITE) {
  	$SSL_ERROR = SSL_WANT_WRITE;
      } else {
  	return $err;
      }
      $! ||= EWOULDBLOCK;
      ${*$self}{_SSL_last_err} = [$SSL_ERROR,4] if ref($self);
      Net::SSLeay::ERR_clear_error();
      return 0;
  }
  
  
  # Call to connect occurs when a new client socket is made using IO::Socket::*
  sub connect {
      my $self = shift || return _invalid_object();
      return $self if ${*$self}{'_SSL_opened'};  # already connected
  
      if ( ! ${*$self}{'_SSL_opening'} ) {
  	# call SUPER::connect if the underlying socket is not connected
  	# if this fails this might not be an error (e.g. if $! = EINPROGRESS
  	# and socket is nonblocking this is normal), so keep any error
  	# handling to the client
  	$DEBUG>=2 && DEBUG('socket not yet connected' );
  	$self->SUPER::connect(@_) || return;
  	$DEBUG>=2 && DEBUG('socket connected' );
  
  	# IO::Socket works around systems, which return EISCONN or similar
  	# on non-blocking re-connect by returning true, even if $! is set
  	# but it does not clear $!, so do it here
  	$! = undef;
  
  	# don't continue with connect_SSL if SSL_startHandshake is set to 0
  	my $sh = ${*$self}{_SSL_arguments}{SSL_startHandshake};
  	return $self if defined $sh && ! $sh;
      }
      return $self->connect_SSL;
  }
  
  
  sub connect_SSL {
      my $self = shift;
      my $args = @_>1 ? {@_}: $_[0]||{};
      return $self if ${*$self}{'_SSL_opened'};  # already connected
  
      my ($ssl,$ctx);
      if ( ! ${*$self}{'_SSL_opening'} ) {
  	# start ssl connection
  	$DEBUG>=2 && DEBUG('ssl handshake not started' );
  	${*$self}{'_SSL_opening'} = 1;
  	my $arg_hash = ${*$self}{'_SSL_arguments'};
  
  	my $fileno = ${*$self}{'_SSL_fileno'} = fileno($self);
  	return $self->_internal_error("Socket has no fileno",9)
  	    if ! defined $fileno;
  
  	$ctx = ${*$self}{'_SSL_ctx'};  # Reference to real context
  	$ssl = ${*$self}{'_SSL_object'} = Net::SSLeay::new($ctx->{context})
  	    || return $self->error("SSL structure creation failed");
  	$CREATED_IN_THIS_THREAD{$ssl} = 1 if $use_threads;
  	$SSL_OBJECT{$ssl} = [$self,0];
  	weaken($SSL_OBJECT{$ssl}[0]);
  
  	Net::SSLeay::set_fd($ssl, $fileno)
  	    || return $self->error("SSL filehandle association failed");
  
  	if ( $can_client_sni ) {
  	    my $host;
  	    if ( exists $arg_hash->{SSL_hostname} ) {
  		# explicitly given
  		# can be set to undef/'' to not use extension
  		$host = $arg_hash->{SSL_hostname}
  	    } elsif ( $host = $arg_hash->{PeerAddr} || $arg_hash->{PeerHost} ) {
  		# implicitly given
  		$host =~s{:[a-zA-Z0-9_\-]+$}{};
  		# should be hostname, not IPv4/6
  		$host = undef if $host !~m{[a-z_]}i or $host =~m{:};
  	    }
  	    # define SSL_CTRL_SET_TLSEXT_HOSTNAME 55
  	    # define TLSEXT_NAMETYPE_host_name 0
  	    if ($host) {
  		$DEBUG>=2 && DEBUG("using SNI with hostname $host");
  		Net::SSLeay::ctrl($ssl,55,0,$host);
  	    } else {
  		$DEBUG>=2 && DEBUG("not using SNI because hostname is unknown");
  	    }
  	} elsif ( $arg_hash->{SSL_hostname} ) {
  	    return $self->_internal_error(
  		"Client side SNI not supported for this openssl",9);
  	} else {
  	    $DEBUG>=2 && DEBUG("not using SNI because openssl is too old");
  	}
  
  	$arg_hash->{PeerAddr} || $arg_hash->{PeerHost} || $self->_update_peer;
  	if ( $ctx->{verify_name_ref} ) {
  	    # need target name for update
  	    my $host = $arg_hash->{SSL_verifycn_name}
  		|| $arg_hash->{SSL_hostname};
  	    if ( ! defined $host ) {
  		if ( $host = $arg_hash->{PeerAddr} || $arg_hash->{PeerHost} ) {
  		    $host =~s{:[a-zA-Z0-9_\-]+$}{};
  		}
  	    }
  	    ${$ctx->{verify_name_ref}} = $host;
  	}
  
  	my $ocsp = $ctx->{ocsp_mode};
  	if ( $ocsp & SSL_OCSP_NO_STAPLE ) {
  	    # don't try stapling
  	} elsif ( ! $can_ocsp_staple ) {
  	    croak("OCSP stapling not support") if $ocsp & SSL_OCSP_MUST_STAPLE;
  	} elsif ( $ocsp & (SSL_OCSP_TRY_STAPLE|SSL_OCSP_MUST_STAPLE)) {
  	    # staple by default if verification enabled
  	    ${*$self}{_SSL_ocsp_verify} = undef;
  	    Net::SSLeay::set_tlsext_status_type($ssl,
  		Net::SSLeay::TLSEXT_STATUSTYPE_ocsp());
  	    $DEBUG>=2 && DEBUG("request OCSP stapling");
  	}
  
  	if ($ctx->{session_cache}
  	    and my $session = $ctx->{session_cache}->get_session(
  		$arg_hash->{SSL_session_key} || do {
  		    my $host = $arg_hash->{PeerAddr} || $arg_hash->{PeerHost};
  		    my $port = $arg_hash->{PeerPort} || $arg_hash->{PeerService};
  		    $port ? "$host:$port" : $host;
  		}
  	    )) {
  	    Net::SSLeay::set_session($ssl, $session);
  	}
      }
  
      $ssl ||= ${*$self}{'_SSL_object'};
  
      $SSL_ERROR = $! = undef;
      my $timeout = exists $args->{Timeout}
  	? $args->{Timeout}
  	: ${*$self}{io_socket_timeout}; # from IO::Socket
      if ( defined($timeout) && $timeout>0 && $self->blocking(0) ) {
  	$DEBUG>=2 && DEBUG( "set socket to non-blocking to enforce timeout=$timeout" );
  	# timeout was given and socket was blocking
  	# enforce timeout with now non-blocking socket
      } else {
  	# timeout does not apply because invalid or socket non-blocking
  	$timeout = undef;
      }
  
      my $start = defined($timeout) && time();
      {
  	$SSL_ERROR = undef;
  	$CURRENT_SSL_OBJECT = $self;
  	$DEBUG>=3 && DEBUG("call Net::SSLeay::connect" );
  	my $rv = Net::SSLeay::connect($ssl);
  	$CURRENT_SSL_OBJECT = undef;
  	$DEBUG>=3 && DEBUG("done Net::SSLeay::connect -> $rv" );
  	if ( $rv < 0 ) {
  	    if ( my $err = $self->_skip_rw_error( $ssl,$rv )) {
  		$self->error("SSL connect attempt failed");
  		delete ${*$self}{'_SSL_opening'};
  		${*$self}{'_SSL_opened'} = -1;
  		$DEBUG>=1 && DEBUG( "fatal SSL error: $SSL_ERROR" );
  		return $self->fatal_ssl_error();
  	    }
  
  	    $DEBUG>=2 && DEBUG('ssl handshake in progress' );
  	    # connect failed because handshake needs to be completed
  	    # if socket was non-blocking or no timeout was given return with this error
  	    return if ! defined($timeout);
  
  	    # wait until socket is readable or writable
  	    my $rv;
  	    if ( $timeout>0 ) {
  		my $vec = '';
  		vec($vec,$self->fileno,1) = 1;
  		$DEBUG>=2 && DEBUG( "waiting for fd to become ready: $SSL_ERROR" );
  		$rv =
  		    $SSL_ERROR == SSL_WANT_READ ? select( $vec,undef,undef,$timeout) :
  		    $SSL_ERROR == SSL_WANT_WRITE ? select( undef,$vec,undef,$timeout) :
  		    undef;
  	    } else {
  		$DEBUG>=2 && DEBUG("handshake failed because no more time" );
  		$! = ETIMEDOUT
  	    }
  	    if ( ! $rv ) {
  		$DEBUG>=2 && DEBUG("handshake failed because socket did not became ready" );
  		# failed because of timeout, return
  		$! ||= ETIMEDOUT;
  		delete ${*$self}{'_SSL_opening'};
  		${*$self}{'_SSL_opened'} = -1;
  		$self->blocking(1); # was blocking before
  		return
  	    }
  
  	    # socket is ready, try non-blocking connect again after recomputing timeout
  	    $DEBUG>=2 && DEBUG("socket ready, retrying connect" );
  	    my $now = time();
  	    $timeout -= $now - $start;
  	    $start = $now;
  	    redo;
  
  	} elsif ( $rv == 0 ) {
  	    delete ${*$self}{'_SSL_opening'};
  	    $DEBUG>=2 && DEBUG("connection failed - connect returned 0" );
  	    $self->error("SSL connect attempt failed because of handshake problems" );
  	    ${*$self}{'_SSL_opened'} = -1;
  	    return $self->fatal_ssl_error();
  	}
      }
  
      $DEBUG>=2 && DEBUG('ssl handshake done' );
      # ssl connect successful
      delete ${*$self}{'_SSL_opening'};
      ${*$self}{'_SSL_opened'}=1;
      if (defined($timeout)) {
  	$self->blocking(1); # reset back to blocking
  	$! = undef; # reset errors from non-blocking
      }
  
      $ctx ||= ${*$self}{'_SSL_ctx'};
  
      if ( my $ocsp_result = ${*$self}{_SSL_ocsp_verify} ) {
  	# got result from OCSP stapling
  	if ( $ocsp_result->[0] > 0 ) {
  	    $DEBUG>=3 && DEBUG("got OCSP success with stapling");
  	    # successful validated
  	} elsif ( $ocsp_result->[0] < 0 ) {
  	    # Permanent problem with validation because certificate
  	    # is either self-signed or the issuer cannot be found.
  	    # Ignore here, because this will cause other errors too.
  	    $DEBUG>=3 && DEBUG("got OCSP failure with stapling: %s",
  		$ocsp_result->[1]);
  	} else {
  	    # definitely revoked
  	    $DEBUG>=3 && DEBUG("got OCSP revocation with stapling: %s",
  		$ocsp_result->[1]);
  	    $self->_internal_error($ocsp_result->[1],5);
  	    return $self->fatal_ssl_error();
  	}
      } elsif ( $ctx->{ocsp_mode} & SSL_OCSP_MUST_STAPLE ) {
  	$self->_internal_error("did not receive the required stapled OCSP response",5);
  	return $self->fatal_ssl_error();
      }
  
      if ( $ctx->{session_cache}
  	and my $session = Net::SSLeay::get1_session($ssl)) {
  	my $arg_hash = ${*$self}{'_SSL_arguments'};
  	$ctx->{session_cache}->add_session(
  	    $arg_hash->{SSL_session_key} || do {
  		my $host = $arg_hash->{PeerAddr} || $arg_hash->{PeerHost}
  		    || $self->_update_peer;
  		my $port = $arg_hash->{PeerPort} || $arg_hash->{PeerService};
  		$port ? "$host:$port" : $host;
  	    },
  	    $session
  	);
      }
  
      tie *{$self}, "IO::Socket::SSL::SSL_HANDLE", $self;
  
      return $self;
  }
  
  # called if PeerAddr is not set in ${*$self}{'_SSL_arguments'}
  # this can be the case if start_SSL is called with a normal IO::Socket::INET
  # so that PeerAddr|PeerPort are not set from args
  # returns PeerAddr
  sub _update_peer {
      my $self = shift;
      my $arg_hash = ${*$self}{'_SSL_arguments'};
      eval {
  	my $sockaddr = getpeername( $self );
  	my $af = sockaddr_family($sockaddr);
  	if( CAN_IPV6 && $af == AF_INET6 ) {
  	    my (undef, $host, $port) = _getnameinfo($sockaddr,
  		NI_NUMERICHOST | NI_NUMERICSERV);
  	    $arg_hash->{PeerPort} = $port;
  	    $arg_hash->{PeerAddr} = $host;
  	} else {
  	    my ($port,$addr) = sockaddr_in( $sockaddr);
  	    $arg_hash->{PeerPort} = $port;
  	    $arg_hash->{PeerAddr} = inet_ntoa( $addr );
  	}
      }
  }
  
  #Call to accept occurs when a new client connects to a server using
  #IO::Socket::SSL
  sub accept {
      my $self = shift || return _invalid_object();
      my $class = shift || 'IO::Socket::SSL';
  
      my $socket = ${*$self}{'_SSL_opening'};
      if ( ! $socket ) {
  	# underlying socket not done
  	$DEBUG>=2 && DEBUG('no socket yet' );
  	$socket = $self->SUPER::accept($class) || return;
  	$DEBUG>=2 && DEBUG('accept created normal socket '.$socket );
  
  	# don't continue with accept_SSL if SSL_startHandshake is set to 0
  	my $sh = ${*$self}{_SSL_arguments}{SSL_startHandshake};
  	if (defined $sh && ! $sh) {
  	    ${*$socket}{_SSL_ctx} = ${*$self}{_SSL_ctx};
  	    ${*$socket}{_SSL_arguments} = {
  		%{${*$self}{_SSL_arguments}},
  		SSL_server => 0,
  	    };
  	    $DEBUG>=2 && DEBUG('will not start SSL handshake yet');
  	    return wantarray ? ($socket, getpeername($socket) ) : $socket
  	}
      }
  
      $self->accept_SSL($socket) || return;
      $DEBUG>=2 && DEBUG('accept_SSL ok' );
  
      return wantarray ? ($socket, getpeername($socket) ) : $socket;
  }
  
  sub accept_SSL {
      my $self = shift;
      my $socket = ( @_ && UNIVERSAL::isa( $_[0], 'IO::Handle' )) ? shift : $self;
      my $args = @_>1 ? {@_}: $_[0]||{};
  
      my $ssl;
      if ( ! ${*$self}{'_SSL_opening'} ) {
  	$DEBUG>=2 && DEBUG('starting sslifying' );
  	${*$self}{'_SSL_opening'} = $socket;
  	if ($socket != $self) {
  	    ${*$socket}{_SSL_ctx} = ${*$self}{_SSL_ctx};
  	    ${*$socket}{_SSL_arguments} = {
  		%{${*$self}{_SSL_arguments}},
  		SSL_server => 0
  	    };
  	}
  
  	my $fileno = ${*$socket}{'_SSL_fileno'} = fileno($socket);
  	return $socket->_internal_error("Socket has no fileno",9)
  	    if ! defined $fileno;
  
  	$ssl = ${*$socket}{_SSL_object} =
  	    Net::SSLeay::new(${*$socket}{_SSL_ctx}{context})
  	    || return $socket->error("SSL structure creation failed");
  	$CREATED_IN_THIS_THREAD{$ssl} = 1 if $use_threads;
  	$SSL_OBJECT{$ssl} = [$socket,1];
  	weaken($SSL_OBJECT{$ssl}[0]);
  
  	Net::SSLeay::set_fd($ssl, $fileno)
  	    || return $socket->error("SSL filehandle association failed");
      }
  
      $ssl ||= ${*$socket}{'_SSL_object'};
  
      $SSL_ERROR = $! = undef;
      #$DEBUG>=2 && DEBUG('calling ssleay::accept' );
  
      my $timeout = exists $args->{Timeout}
  	? $args->{Timeout}
  	: ${*$self}{io_socket_timeout}; # from IO::Socket
      if ( defined($timeout) && $timeout>0 && $socket->blocking(0) ) {
  	# timeout was given and socket was blocking
  	# enforce timeout with now non-blocking socket
      } else {
  	# timeout does not apply because invalid or socket non-blocking
  	$timeout = undef;
      }
  
      my $start = defined($timeout) && time();
      {
  	$SSL_ERROR = undef;
  	$CURRENT_SSL_OBJECT = $self;
  	my $rv = Net::SSLeay::accept($ssl);
  	$CURRENT_SSL_OBJECT = undef;
  	$DEBUG>=3 && DEBUG( "Net::SSLeay::accept -> $rv" );
  	if ( $rv < 0 ) {
  	    if ( my $err = $socket->_skip_rw_error( $ssl,$rv )) {
  		$socket->error("SSL accept attempt failed");
  		delete ${*$self}{'_SSL_opening'};
  		${*$socket}{'_SSL_opened'} = -1;
  		return $socket->fatal_ssl_error();
  	    }
  
  	    # accept failed because handshake needs to be completed
  	    # if socket was non-blocking or no timeout was given return with this error
  	    return if ! defined($timeout);
  
  	    # wait until socket is readable or writable
  	    my $rv;
  	    if ( $timeout>0 ) {
  		my $vec = '';
  		vec($vec,$socket->fileno,1) = 1;
  		$rv =
  		    $SSL_ERROR == SSL_WANT_READ  ? select( $vec,undef,undef,$timeout) :
  		    $SSL_ERROR == SSL_WANT_WRITE ? select( undef,$vec,undef,$timeout) :
  		    undef;
  	    } else {
  		$! = ETIMEDOUT
  	    }
  	    if ( ! $rv ) {
  		# failed because of timeout, return
  		$! ||= ETIMEDOUT;
  		delete ${*$self}{'_SSL_opening'};
  		${*$socket}{'_SSL_opened'} = -1;
  		$socket->blocking(1); # was blocking before
  		return
  	    }
  
  	    # socket is ready, try non-blocking accept again after recomputing timeout
  	    my $now = time();
  	    $timeout -= $now - $start;
  	    $start = $now;
  	    redo;
  
  	} elsif ( $rv == 0 ) {
  	    $socket->error("SSL accept attempt failed because of handshake problems" );
  	    delete ${*$self}{'_SSL_opening'};
  	    ${*$socket}{'_SSL_opened'} = -1;
  	    return $socket->fatal_ssl_error();
  	}
      }
  
      $DEBUG>=2 && DEBUG('handshake done, socket ready' );
      # socket opened
      delete ${*$self}{'_SSL_opening'};
      ${*$socket}{'_SSL_opened'} = 1;
      if (defined($timeout)) {
  	$socket->blocking(1); # reset back to blocking
  	$! = undef; # reset errors from non-blocking
      }
  
      tie *{$socket}, "IO::Socket::SSL::SSL_HANDLE", $socket;
  
      return $socket;
  }
  
  
  ####### I/O subroutines ########################
  
  sub _generic_read {
      my ($self, $read_func, undef, $length, $offset) = @_;
      my $ssl =  ${*$self}{_SSL_object} || return;
      my $buffer=\$_[2];
  
      $SSL_ERROR = $! = undef;
      my ($data,$rwerr) = $read_func->($ssl, $length);
      while ( ! defined($data)) {
  	if ( my $err = $self->_skip_rw_error( $ssl, defined($rwerr) ? $rwerr:-1 )) {
  	    if ($err == $Net_SSLeay_ERROR_SYSCALL) {
  		# OpenSSL 1.1.0c+ : EOF can now result in SSL_read returning -1
  		if (not $!) {
  		    # SSL_ERROR_SYSCALL but not errno -> treat as EOF
  		    $data = '';
  		    last;
  		}
  	    }
  	    $self->error("SSL read error");
  	}
  	return;
      }
  
      $length = length($data);
      $$buffer = '' if !defined $$buffer;
      $offset ||= 0;
      if ($offset>length($$buffer)) {
  	$$buffer.="\0" x ($offset-length($$buffer));  #mimic behavior of read
      }
  
      substr($$buffer, $offset, length($$buffer), $data);
      return $length;
  }
  
  sub read {
      my $self = shift;
      ${*$self}{_SSL_object} && return _generic_read($self,
  	$self->blocking ? \&Net::SSLeay::ssl_read_all : \&Net::SSLeay::read,
  	@_
      );
  
      # fall back to plain read if we are not required to use SSL yet
      return $self->SUPER::read(@_);
  }
  
  # contrary to the behavior of read sysread can read partial data
  sub sysread {
      my $self = shift;
      ${*$self}{_SSL_object} && return _generic_read( $self,
  	\&Net::SSLeay::read, @_ );
  
      # fall back to plain sysread if we are not required to use SSL yet
      my $rv = $self->SUPER::sysread(@_);
      return $rv;
  }
  
  sub peek {
      my $self = shift;
      ${*$self}{_SSL_object} && return _generic_read( $self,
  	\&Net::SSLeay::peek, @_ );
  
      # fall back to plain peek if we are not required to use SSL yet
      # emulate peek with recv(...,MS_PEEK) - peek(buf,len,offset)
      return if ! defined recv($self,my $buf,$_[1],MSG_PEEK);
      $_[0] = $_[2] ? substr($_[0],0,$_[2]).$buf : $buf;
      return length($buf);
  }
  
  
  sub _generic_write {
      my ($self, $write_all, undef, $length, $offset) = @_;
  
      my $ssl =  ${*$self}{_SSL_object} || return;
      my $buffer = \$_[2];
  
      my $buf_len = length($$buffer);
      $length ||= $buf_len;
      $offset ||= 0;
      return $self->_internal_error("Invalid offset for SSL write",9)
  	if $offset>$buf_len;
      return 0 if ($offset == $buf_len);
  
      $SSL_ERROR = $! = undef;
      my $written;
      if ( $write_all ) {
  	my $data = $length < $buf_len-$offset ? substr($$buffer, $offset, $length) : $$buffer;
  	($written, my $errs) = Net::SSLeay::ssl_write_all($ssl, $data);
  	# ssl_write_all returns number of bytes written
  	$written = undef if ! $written && $errs;
      } else {
  	$written = Net::SSLeay::write_partial( $ssl,$offset,$length,$$buffer );
  	# write_partial does SSL_write which returns -1 on error
  	$written = undef if $written < 0;
      }
      if ( !defined($written) ) {
  	if ( my $err = $self->_skip_rw_error( $ssl,-1 )) {
  	    # if $! is not set with ERROR_SYSCALL then report as EPIPE
  	    $! ||= EPIPE if $err == $Net_SSLeay_ERROR_SYSCALL;
  	    $self->error("SSL write error ($err)");
  	}
  	return;
      }
  
      return $written;
  }
  
  # if socket is blocking write() should return only on error or
  # if all data are written
  sub write {
      my $self = shift;
      ${*$self}{_SSL_object} && return _generic_write( $self,
  	scalar($self->blocking),@_ );
  
      # fall back to plain write if we are not required to use SSL yet
      return $self->SUPER::write(@_);
  }
  
  # contrary to write syswrite() returns already if only
  # a part of the data is written
  sub syswrite {
      my $self = shift;
      ${*$self}{_SSL_object} && return _generic_write($self,0,@_);
  
      # fall back to plain syswrite if we are not required to use SSL yet
      return $self->SUPER::syswrite(@_);
  }
  
  sub print {
      my $self = shift;
      my $string = join(($, or ''), @_, ($\ or ''));
      return $self->write( $string );
  }
  
  sub printf {
      my ($self,$format) = (shift,shift);
      return $self->write(sprintf($format, @_));
  }
  
  sub getc {
      my ($self, $buffer) = (shift, undef);
      return $buffer if $self->read($buffer, 1, 0);
  }
  
  sub readline {
      my $self = shift;
      ${*$self}{_SSL_object} or return $self->SUPER::getline;
  
      if ( not defined $/ or wantarray) {
  	# read all and split
  
  	my $buf = '';
  	while (1) {
  	    my $rv = $self->sysread($buf,2**16,length($buf));
  	    if ( ! defined $rv ) {
  		next if $! == EINTR;       # retry
  		last if $! == EWOULDBLOCK || $! == EAGAIN; # use everything so far
  		return;                    # return error
  	    } elsif ( ! $rv ) {
  		last
  	    }
  	}
  
  	if ( ! defined $/ ) {
  	    return $buf
  	} elsif ( ref($/)) {
  	    my $size = ${$/};
  	    die "bad value in ref \$/: $size" unless $size>0;
  	    return $buf=~m{\G(.{1,$size})}g;
  	} elsif ( $/ eq '' ) {
  	    return $buf =~m{\G(.*\n\n+|.+)}g;
  	} else {
  	    return $buf =~m{\G(.*$/|.+)}g;
  	}
      }
  
      # read only one line
      if ( ref($/) ) {
  	my $size = ${$/};
  	# read record of $size bytes
  	die "bad value in ref \$/: $size" unless $size>0;
  	my $buf = '';
  	while ( $size>length($buf)) {
  	    my $rv = $self->sysread($buf,$size-length($buf),length($buf));
  	    if ( ! defined $rv ) {
  		next if $! == EINTR;       # retry
  		last if $! == EWOULDBLOCK || $! == EAGAIN; # use everything so far
  		return;                    # return error
  	    } elsif ( ! $rv ) {
  		last
  	    }
  	}
  	return $buf;
      }
  
      my ($delim0,$delim1) = $/ eq '' ? ("\n\n","\n"):($/,'');
  
      # find first occurrence of $delim0 followed by as much as possible $delim1
      my $buf = '';
      my $eod = 0;  # pointer into $buf after $delim0 $delim1*
      my $ssl = $self->_get_ssl_object or return;
      while (1) {
  
  	# wait until we have more data or eof
  	my $poke = Net::SSLeay::peek($ssl,1);
  	if ( ! defined $poke or $poke eq '' ) {
  	    next if $! == EINTR;
  	}
  
  	my $skip = 0;
  
  	# peek into available data w/o reading
  	my $pending = Net::SSLeay::pending($ssl);
  	if ( $pending and
  	    ( my $pb = Net::SSLeay::peek( $ssl,$pending )) ne '' ) {
  	    $buf .= $pb
  	} else {
  	    return $buf eq '' ? ():$buf;
  	}
  	if ( !$eod ) {
  	    my $pos = index( $buf,$delim0 );
  	    if ( $pos<0 ) {
  		$skip = $pending
  	    } else {
  		$eod = $pos + length($delim0); # pos after delim0
  	    }
  	}
  
  	if ( $eod ) {
  	    if ( $delim1 ne '' ) {
  		# delim0 found, check for as much delim1 as possible
  		while ( index( $buf,$delim1,$eod ) == $eod ) {
  		    $eod+= length($delim1);
  		}
  	    }
  	    $skip = $pending - ( length($buf) - $eod );
  	}
  
  	# remove data from $self which I already have in buf
  	while ( $skip>0 ) {
  	    if ($self->sysread(my $p,$skip,0)) {
  		$skip -= length($p);
  		next;
  	    }
  	    $! == EINTR or last;
  	}
  
  	if ( $eod and ( $delim1 eq '' or $eod < length($buf))) {
  	    # delim0 found and there can be no more delim1 pending
  	    last
  	}
      }
      return substr($buf,0,$eod);
  }
  
  sub close {
      my $self = shift || return _invalid_object();
      my $close_args = (ref($_[0]) eq 'HASH') ? $_[0] : {@_};
  
      return if ! $self->stop_SSL(
  	SSL_fast_shutdown => 1,
  	%$close_args,
  	_SSL_ioclass_downgrade => 0,
      );
  
      if ( ! $close_args->{_SSL_in_DESTROY} ) {
  	untie( *$self );
  	undef ${*$self}{_SSL_fileno};
  	return $self->SUPER::close;
      }
      return 1;
  }
  
  sub is_SSL {
      my $self = pop;
      return ${*$self}{_SSL_object} && 1
  }
  
  sub stop_SSL {
      my $self = shift || return _invalid_object();
      my $stop_args = (ref($_[0]) eq 'HASH') ? $_[0] : {@_};
      $stop_args->{SSL_no_shutdown} = 1 if ! ${*$self}{_SSL_opened};
  
      if (my $ssl = ${*$self}{'_SSL_object'}) {
  	if ( ! $stop_args->{SSL_no_shutdown} ) {
  	    my $status = Net::SSLeay::get_shutdown($ssl);
  
  	    my $timeout =
  		not($self->blocking) ? undef :
  		exists $stop_args->{Timeout} ? $stop_args->{Timeout} :
  		${*$self}{io_socket_timeout}; # from IO::Socket
  	    if ($timeout) {
  		$self->blocking(0);
  		$timeout += time();
  	    }
  
  	    while (1) {
  		if ( $status & SSL_SENT_SHUTDOWN and
  		    # don't care for received if fast shutdown
  		    $status & SSL_RECEIVED_SHUTDOWN
  			|| $stop_args->{SSL_fast_shutdown}) {
  		    # shutdown complete
  		    last;
  		}
  		if ((${*$self}{'_SSL_opened'}||0) <= 0) {
  		    # not really open, thus don't expect shutdown to return
  		    # something meaningful
  		    last;
  		}
  
  		# initiate or complete shutdown
  		local $SIG{PIPE} = 'IGNORE';
  		my $rv = Net::SSLeay::shutdown($ssl);
  		if ( $rv < 0 ) {
  		    # non-blocking socket?
  		    if ( ! $timeout ) {
  			$self->_skip_rw_error( $ssl,$rv );
  			# need to try again
  			return;
  		    }
  
  		    # don't use _skip_rw_error so that existing error does
  		    # not get cleared
  		    my $wait = $timeout - time();
  		    last if $wait<=0;
  		    vec(my $vec = '',fileno($self),1) = 1;
  		    my $err = Net::SSLeay::get_error($ssl,$rv);
  		    if ( $err == $Net_SSLeay_ERROR_WANT_READ) {
  			select($vec,undef,undef,$wait)
  		    } elsif ( $err == $Net_SSLeay_ERROR_WANT_READ) {
  			select(undef,$vec,undef,$wait)
  		    } else {
  			last;
  		    }
  		}
  
  		$status |= SSL_SENT_SHUTDOWN;
  		$status |= SSL_RECEIVED_SHUTDOWN if $rv>0;
  	    }
  	    $self->blocking(1) if $timeout;
  	}
  
  	# destroy allocated objects for SSL and untie
  	# do not destroy CTX unless explicitly specified
  	Net::SSLeay::free($ssl);
  	delete ${*$self}{_SSL_object};
  	if (my $cert = delete ${*$self}{'_SSL_certificate'}) {
  	    Net::SSLeay::X509_free($cert);
  	}
  	${*$self}{'_SSL_opened'} = 0;
  	untie(*$self);
      }
  
      if ($stop_args->{'SSL_ctx_free'}) {
  	my $ctx = delete ${*$self}{'_SSL_ctx'};
  	$ctx && $ctx->DESTROY();
      }
  
  
      if ( ! $stop_args->{_SSL_in_DESTROY} ) {
  
  	my $downgrade = $stop_args->{_SSL_ioclass_downgrade};
  	if ( $downgrade || ! defined $downgrade ) {
  	    # rebless to original class from start_SSL
  	    if ( my $orig_class = delete ${*$self}{'_SSL_ioclass_upgraded'} ) {
  		bless $self,$orig_class;
  		# FIXME: if original class was tied too we need to restore the tie
  		# remove all _SSL related from *$self
  		my @sslkeys = grep { m{^_?SSL_} } keys %{*$self};
  		delete @{*$self}{@sslkeys} if @sslkeys;
  	    }
  	}
      }
      return 1;
  }
  
  
  sub fileno {
      my $self = shift;
      my $fn = ${*$self}{'_SSL_fileno'};
  	return defined($fn) ? $fn : $self->SUPER::fileno();
  }
  
  
  ####### IO::Socket::SSL specific functions #######
  # _get_ssl_object is for internal use ONLY!
  sub _get_ssl_object {
      my $self = shift;
      return ${*$self}{'_SSL_object'} ||
  	IO::Socket::SSL->_internal_error("Undefined SSL object",9);
  }
  
  # _get_ctx_object is for internal use ONLY!
  sub _get_ctx_object {
      my $self = shift;
      my $ctx_object = ${*$self}{_SSL_ctx};
      return $ctx_object && $ctx_object->{context};
  }
  
  # default error for undefined arguments
  sub _invalid_object {
      return IO::Socket::SSL->_internal_error("Undefined IO::Socket::SSL object",9);
  }
  
  
  sub pending {
      my $ssl = shift()->_get_ssl_object || return;
      return Net::SSLeay::pending($ssl);
  }
  
  sub start_SSL {
      my ($class,$socket) = (shift,shift);
      return $class->_internal_error("Not a socket",9) if ! ref($socket);
      my $arg_hash = @_ == 1 ? $_[0] : {@_};
      my %to = exists $arg_hash->{Timeout} ? ( Timeout => delete $arg_hash->{Timeout} ) :();
      my $original_class = ref($socket);
      if ( ! $original_class ) {
  	$socket = ($original_class = $ISA[0])->new_from_fd($socket,'<+')
  	    or return $class->_internal_error(
  	    "creating $original_class from file handle failed",9);
      }
      my $original_fileno = (UNIVERSAL::can($socket, "fileno"))
  	? $socket->fileno : CORE::fileno($socket);
      return $class->_internal_error("Socket has no fileno",9)
  	if ! defined $original_fileno;
  
      bless $socket, $class;
      $socket->configure_SSL($arg_hash) or bless($socket, $original_class) && return;
  
      ${*$socket}{'_SSL_fileno'} = $original_fileno;
      ${*$socket}{'_SSL_ioclass_upgraded'} = $original_class
  	if $class ne $original_class;
  
      my $start_handshake = $arg_hash->{SSL_startHandshake};
      if ( ! defined($start_handshake) || $start_handshake ) {
  	# if we have no callback force blocking mode
  	$DEBUG>=2 && DEBUG( "start handshake" );
  	my $was_blocking = $socket->blocking(1);
  	my $result = ${*$socket}{'_SSL_arguments'}{SSL_server}
  	    ? $socket->accept_SSL(%to)
  	    : $socket->connect_SSL(%to);
  	if ( $result ) {
  	    $socket->blocking(0) if ! $was_blocking;
  	    return $socket;
  	} else {
  	    # upgrade to SSL failed, downgrade socket to original class
  	    if ( $original_class ) {
  		bless($socket,$original_class);
  		$socket->blocking(0) if ! $was_blocking
  		    && $socket->can('blocking');
  	    }
  	    return;
  	}
      } else {
  	$DEBUG>=2 && DEBUG( "don't start handshake: $socket" );
  	return $socket; # just return upgraded socket
      }
  
  }
  
  sub new_from_fd {
      my ($class, $fd) = (shift,shift);
      # Check for accidental inclusion of MODE in the argument list
      if (length($_[0]) < 4) {
  	(my $mode = $_[0]) =~ tr/+<>//d;
  	shift unless length($mode);
      }
      my $handle = $ISA[0]->new_from_fd($fd, '+<')
  	|| return($class->error("Could not create socket from file descriptor."));
  
      # Annoying workaround for Perl 5.6.1 and below:
      $handle = $ISA[0]->new_from_fd($handle, '+<');
  
      return $class->start_SSL($handle, @_);
  }
  
  
  sub dump_peer_certificate {
      my $ssl = shift()->_get_ssl_object || return;
      return Net::SSLeay::dump_peer_certificate($ssl);
  }
  
  if ( defined &Net::SSLeay::get_peer_cert_chain
      && $Net::SSLeay::VERSION >= 1.58 ) {
      *peer_certificates = sub {
  	my $self = shift;
  	my $ssl = $self->_get_ssl_object || return;
  	my @chain = Net::SSLeay::get_peer_cert_chain($ssl);
  	@chain = () if @chain && !$self->peer_certificate; # work around #96013
  	if ( ${*$self}{_SSL_arguments}{SSL_server} ) {
  	    # in the client case the chain contains the peer certificate,
  	    # in the server case not
  	    # this one has an increased reference counter, the other not
  	    if ( my $peer = Net::SSLeay::get_peer_certificate($ssl)) {
  		Net::SSLeay::X509_free($peer);
  		unshift @chain, $peer;
  	    }
  	}
  	return @chain;
  
      }
  } else {
      *peer_certificates = sub {
  	die "peer_certificates needs Net::SSLeay>=1.58";
      }
  }
  
  {
      my %dispatcher = (
  	issuer =>  sub { Net::SSLeay::X509_NAME_oneline( Net::SSLeay::X509_get_issuer_name( shift )) },
  	subject => sub { Net::SSLeay::X509_NAME_oneline( Net::SSLeay::X509_get_subject_name( shift )) },
  	commonName => sub {
  	    my $cn = Net::SSLeay::X509_NAME_get_text_by_NID(
  		Net::SSLeay::X509_get_subject_name( shift ), NID_CommonName);
  	    $cn;
  	},
  	subjectAltNames => sub { Net::SSLeay::X509_get_subjectAltNames( shift ) },
      );
  
      # alternative names
      $dispatcher{authority} = $dispatcher{issuer};
      $dispatcher{owner}     = $dispatcher{subject};
      $dispatcher{cn}        = $dispatcher{commonName};
  
      sub peer_certificate {
  	my ($self,$field,$reload) = @_;
  	my $ssl = $self->_get_ssl_object or return;
  
  	Net::SSLeay::X509_free(delete ${*$self}{_SSL_certificate})
  	    if $reload && ${*$self}{_SSL_certificate};
  	my $cert = ${*$self}{_SSL_certificate}
  	    ||= Net::SSLeay::get_peer_certificate($ssl)
  	    or return $self->error("Could not retrieve peer certificate");
  
  	if ($field) {
  	    my $sub = $dispatcher{$field} or croak
  		"invalid argument for peer_certificate, valid are: ".join( " ",keys %dispatcher ).
  		"\nMaybe you need to upgrade your Net::SSLeay";
  	    return $sub->($cert);
  	} else {
  	    return $cert
  	}
      }
  
      sub sock_certificate {
  	my ($self,$field) = @_;
  	my $ssl = $self->_get_ssl_object || return;
  	my $cert = Net::SSLeay::get_certificate( $ssl ) || return;
  	if ($field) {
  	    my $sub = $dispatcher{$field} or croak
  		"invalid argument for sock_certificate, valid are: ".join( " ",keys %dispatcher ).
  		"\nMaybe you need to upgrade your Net::SSLeay";
  	    return $sub->($cert);
  	} else {
  	    return $cert
  	}
      }
  
  
      # known schemes, possible attributes are:
      #  - wildcards_in_alt (0, 'full_label', 'anywhere')
      #  - wildcards_in_cn (0, 'full_label', 'anywhere')
      #  - check_cn (0, 'always', 'when_only')
      # unfortunately there are a lot of different schemes used, see RFC 6125 for a
      # summary, which references all of the following except RFC4217/ftp
  
      my %scheme = (
  	none => {}, # do not check
  	# default set is a superset of all the others and thus worse than a more
  	# specific set, but much better than not verifying name at all
  	default => {
  	    wildcards_in_cn  => 'anywhere',
  	    wildcards_in_alt => 'anywhere',
  	    check_cn         => 'always',
  	    ip_in_cn         => 1,
  	},
      );
  
      for(qw(
  	rfc2818
  	rfc3920 xmpp
  	rfc4217 ftp
      )) {
  	$scheme{$_} = {
  	    wildcards_in_cn  => 'anywhere',
  	    wildcards_in_alt => 'anywhere',
  	    check_cn         => 'when_only',
  	}
      }
  
      for(qw(www http)) {
  	$scheme{$_} = {
  	    wildcards_in_cn  => 'anywhere',
  	    wildcards_in_alt => 'anywhere',
  	    check_cn         => 'when_only',
  	    ip_in_cn         => 4,
  	}
      }
  
      for(qw(
  	rfc4513 ldap
      )) {
  	$scheme{$_} = {
  	    wildcards_in_cn  => 0,
  	    wildcards_in_alt => 'full_label',
  	    check_cn         => 'always',
  	};
      }
  
      for(qw(
  	rfc2595 smtp
  	rfc4642 imap pop3 acap
  	rfc5539 nntp
  	rfc5538 netconf
  	rfc5425 syslog
  	rfc5953 snmp
      )) {
  	$scheme{$_} = {
  	    wildcards_in_cn  => 'full_label',
  	    wildcards_in_alt => 'full_label',
  	    check_cn         => 'always'
  	};
      }
      for(qw(
  	rfc5971 gist
      )) {
  	$scheme{$_} = {
  	    wildcards_in_cn  => 'full_label',
  	    wildcards_in_alt => 'full_label',
  	    check_cn         => 'when_only',
  	};
      }
  
      for(qw(
  	rfc5922 sip
      )) {
  	$scheme{$_} = {
  	    wildcards_in_cn  => 0,
  	    wildcards_in_alt => 0,
  	    check_cn         => 'always',
  	};
      }
  
  
      # function to verify the hostname
      #
      # as every application protocol has its own rules to do this
      # we provide some default rules as well as a user-defined
      # callback
  
      sub verify_hostname_of_cert {
  	my $identity = shift;
  	my $cert = shift;
  	my $scheme = shift || 'default';
  	my $publicsuffix = shift;
  	if ( ! ref($scheme) ) {
  	    $DEBUG>=3 && DEBUG( "scheme=$scheme cert=$cert" );
  	    $scheme = $scheme{$scheme} || croak("scheme $scheme not defined");
  	}
  
  	return 1 if ! %$scheme; # 'none'
  	$identity =~s{\.+$}{}; # ignore absolutism
  
  	# get data from certificate
  	my $commonName = $dispatcher{cn}->($cert);
  	my @altNames = $dispatcher{subjectAltNames}->($cert);
  	$DEBUG>=3 && DEBUG("identity=$identity cn=$commonName alt=@altNames" );
  
  	if ( my $sub = $scheme->{callback} ) {
  	    # use custom callback
  	    return $sub->($identity,$commonName,@altNames);
  	}
  
  	# is the given hostname an IP address? Then we have to convert to network byte order [RFC791][RFC2460]
  
  	my $ipn;
  	if ( CAN_IPV6 and $identity =~m{:} ) {
  	    # no IPv4 or hostname have ':'  in it, try IPv6.
  	    $identity =~m{[^\da-fA-F:\.]} and return; # invalid characters in name
  	    $ipn = inet_pton(AF_INET6,$identity) or return; # invalid name
  	} elsif ( my @ip = $identity =~m{^(\d+)(?:\.(\d+)\.(\d+)\.(\d+)|[\d\.]*)$} ) {
  	    # check for invalid IP/hostname
  	    return if 4 != @ip or 4 != grep { defined($_) && $_<256 } @ip; 
  	    $ipn = pack("CCCC",@ip);
  	} else {
  	    # assume hostname, check for umlauts etc
  	    if ( $identity =~m{[^a-zA-Z0-9_.\-]} ) {
  		$identity =~m{\0} and return; # $identity has \\0 byte
  		$identity = idn_to_ascii($identity)
  		    or return; # conversation to IDNA failed
  		$identity =~m{[^a-zA-Z0-9_.\-]}
  		    and return; # still junk inside
  	    }
  	}
  
  	# do the actual verification
  	my $check_name = sub {
  	    my ($name,$identity,$wtyp,$publicsuffix) = @_;
  	    $name =~s{\.+$}{}; # ignore absolutism
  	    $name eq '' and return;
  	    $wtyp ||= '';
  	    my $pattern;
  	    ### IMPORTANT!
  	    # We accept only a single wildcard and only for a single part of the FQDN
  	    # e.g. *.example.org does match www.example.org but not bla.www.example.org
  	    # The RFCs are in this regard unspecific but we don't want to have to
  	    # deal with certificates like *.com, *.co.uk or even *
  	    # see also http://nils.toedtmann.net/pub/subjectAltName.txt .
  	    # Also, we fall back to full_label matches if the identity is an IDNA
  	    # name, see RFC6125 and the discussion at
  	    # http://bugs.python.org/issue17997#msg194950
  	    if ( $wtyp eq 'anywhere' and $name =~m{^([a-zA-Z0-9_\-]*)\*(.+)} ) {
  		return if $1 ne '' and substr($identity,0,4) eq 'xn--'; # IDNA
  		$pattern = qr{^\Q$1\E[a-zA-Z0-9_\-]+\Q$2\E$}i;
  	    } elsif ( $wtyp =~ m{^(?:full_label|leftmost)$}
  		and $name =~m{^\*(\..+)$} ) {
  		$pattern = qr{^[a-zA-Z0-9_\-]+\Q$1\E$}i;
  	    } else {
  		return lc($identity) eq lc($name);
  	    }
  	    if ( $identity =~ $pattern ) {
  		$publicsuffix = IO::Socket::SSL::PublicSuffix->default
  		    if ! defined $publicsuffix;
  		return 1 if $publicsuffix eq '';
  		my @labels = split( m{\.+}, $identity );
  		my $tld = $publicsuffix->public_suffix(\@labels,+1);
  		return 1 if @labels > ( $tld ? 0+@$tld : 1 );
  	    }
  	    return;
  	};
  
  
  	my $alt_dnsNames = 0;
  	while (@altNames) {
  	    my ($type, $name) = splice (@altNames, 0, 2);
  	    if ( $ipn and $type == GEN_IPADD ) {
  		# exact match needed for IP
  		# $name is already packed format (inet_xton)
  		return 1 if $ipn eq $name;
  
  	    } elsif ( ! $ipn and $type == GEN_DNS ) {
  		$name =~s/\s+$//; $name =~s/^\s+//;
  		$alt_dnsNames++;
  		$check_name->($name,$identity,$scheme->{wildcards_in_alt},$publicsuffix)
  		    and return 1;
  	    }
  	}
  
  	if ( $scheme->{check_cn} eq 'always' or
  	    $scheme->{check_cn} eq 'when_only' and !$alt_dnsNames ) {
  	    if ( ! $ipn ) {
  		$check_name->($commonName,$identity,$scheme->{wildcards_in_cn},$publicsuffix)
  		    and return 1;
  	    } elsif ( $scheme->{ip_in_cn} ) {
  		if ( $identity eq $commonName ) {
  		    return 1 if
  			$scheme->{ip_in_cn} == 4 ? length($ipn) == 4 :
  			$scheme->{ip_in_cn} == 6 ? length($ipn) == 8 :
  			1;
  		}
  	    }
  	}
  
  	return 0; # no match
      }
  }
  
  sub verify_hostname {
      my $self = shift;
      my $host = shift;
      my $cert = $self->peer_certificate;
      return verify_hostname_of_cert( $host,$cert,@_ );
  }
  
  
  sub get_servername {
      my $self = shift;
      return ${*$self}{_SSL_servername} ||= do {
  	my $ssl = $self->_get_ssl_object or return;
  	Net::SSLeay::get_servername($ssl);
      };
  }
  
  sub get_fingerprint_bin {
      my ($self,$algo,$cert,$key_only) = @_;
      $cert ||= $self->peer_certificate;
      return $key_only 
  	? Net::SSLeay::X509_pubkey_digest($cert, $algo2digest->($algo || 'sha256'))
  	: Net::SSLeay::X509_digest($cert, $algo2digest->($algo || 'sha256'));
  }
  
  sub get_fingerprint {
      my ($self,$algo,$cert,$key_only) = @_;
      $algo ||= 'sha256';
      my $fp = get_fingerprint_bin($self,$algo,$cert,$key_only) or return;
      return $algo.'$'.($key_only ? 'pub$':'').unpack('H*',$fp);
  }
  
  sub get_cipher {
      my $ssl = shift()->_get_ssl_object || return;
      return Net::SSLeay::get_cipher($ssl);
  }
  
  sub get_sslversion {
      my $ssl = shift()->_get_ssl_object || return;
      my $version = Net::SSLeay::version($ssl) or return;
      return
  	$version == 0x0303 ? 'TLSv1_2' :
  	$version == 0x0302 ? 'TLSv1_1' :
  	$version == 0x0301 ? 'TLSv1'   :
  	$version == 0x0300 ? 'SSLv3'   :
  	$version == 0x0002 ? 'SSLv2'   :
  	$version == 0xfeff ? 'DTLS1'   :
  	undef;
  }
  
  sub get_sslversion_int {
      my $ssl = shift()->_get_ssl_object || return;
      return Net::SSLeay::version($ssl);
  }
  
  if ($can_ocsp) {
      no warnings 'once';
      *ocsp_resolver = sub {
  	my $self = shift;
  	my $ssl = $self->_get_ssl_object || return;
  	my $ctx = ${*$self}{_SSL_ctx};
  	return IO::Socket::SSL::OCSP_Resolver->new(
  	    $ssl,
  	    $ctx->{ocsp_cache} ||= IO::Socket::SSL::OCSP_Cache->new,
  	    $ctx->{ocsp_mode} & SSL_OCSP_FAIL_HARD,
  	    @_ ? \@_ :
  		$ctx->{ocsp_mode} & SSL_OCSP_FULL_CHAIN ? [ $self->peer_certificates ]:
  		[ $self->peer_certificate ]
  	);
      };
  }
  
  sub errstr {
      my $self = shift;
      my $oe = ref($self) && ${*$self}{_SSL_last_err};
      return $oe ? $oe->[0] : $SSL_ERROR || '';
  }
  
  sub fatal_ssl_error {
      my $self = shift;
      my $error_trap = ${*$self}{'_SSL_arguments'}->{'SSL_error_trap'};
      $@ = $self->errstr;
      if (defined $error_trap and ref($error_trap) eq 'CODE') {
  	$error_trap->($self, $self->errstr()."\n".$self->get_ssleay_error());
      } elsif ( ${*$self}{'_SSL_ioclass_upgraded'}
  	|| ${*$self}{_SSL_arguments}{SSL_keepSocketOnError}) {
  	# downgrade only
  	$DEBUG>=3 && DEBUG('downgrading SSL only, not closing socket' );
  	$self->stop_SSL;
      } else {
  	# kill socket
  	$self->close
      }
      return;
  }
  
  sub get_ssleay_error {
      #Net::SSLeay will print out the errors itself unless we explicitly
      #undefine $Net::SSLeay::trace while running print_errs()
      local $Net::SSLeay::trace;
      return Net::SSLeay::print_errs('SSL error: ') || '';
  }
  
  # internal errors, e.g. unsupported features, hostname check failed etc
  # _SSL_last_err contains severity so that on error chains we can decide if one
  # error should replace the previous one or if this is just a less specific
  # follow-up error, e.g. configuration failed because certificate failed because
  # hostname check went wrong:
  # 0 - fallback errors
  # 4 - errors bubbled up from OpenSSL (sub error, r/w error)
  # 5 - hostname or OCSP verification failed
  # 9 - fatal problems, e.g. missing feature, no fileno...
  # _SSL_last_err and SSL_ERROR are only replaced if the error has a higher
  # severity than the previous one
  
  sub _internal_error {
      my ($self, $error, $severity) = @_;
      $error = dualvar( -1, $error );
      $self = $CURRENT_SSL_OBJECT if !ref($self) && $CURRENT_SSL_OBJECT;
      if (ref($self)) {
  	my $oe = ${*$self}{_SSL_last_err};
  	if (!$oe || $oe->[1] <= $severity) {
  	    ${*$self}{_SSL_last_err} = [$error,$severity];
  	    $SSL_ERROR = $error;
  	    $DEBUG && DEBUG("local error: $error");
  	} else {
  	    $DEBUG && DEBUG("ignoring less severe local error '$error', keep '$oe->[0]'");
  	}
      } else {
  	$SSL_ERROR = $error;
  	$DEBUG && DEBUG("global error: $error");
      }
      return;
  }
  
  # OpenSSL errors
  sub error {
      my ($self, $error) = @_;
      my @err;
      while ( my $err = Net::SSLeay::ERR_get_error()) {
  	push @err, Net::SSLeay::ERR_error_string($err);
  	$DEBUG>=2 && DEBUG( $error."\n".$self->get_ssleay_error());
      }
      $error .= ' '.join(' ',@err) if @err;
      return $self->_internal_error($error,4) if $error;
      return;
  }
  
  sub can_client_sni { return $can_client_sni }
  sub can_server_sni { return $can_server_sni }
  sub can_npn        { return $can_npn }
  sub can_alpn       { return $can_alpn }
  sub can_ecdh       { return $can_ecdh }
  sub can_ipv6       { return CAN_IPV6 }
  sub can_ocsp       { return $can_ocsp }
  sub can_ticket_keycb { return $can_tckt_keycb }
  
  sub DESTROY {
      my $self = shift or return;
      my $ssl = ${*$self}{_SSL_object} or return;
      delete $SSL_OBJECT{$ssl};
      if (!$use_threads or delete $CREATED_IN_THIS_THREAD{$ssl}) {
  	$self->close(_SSL_in_DESTROY => 1, SSL_no_shutdown => 1)
  	    if ${*$self}{'_SSL_opened'};
      }
      delete @{*$self}{@all_my_keys};
  }
  
  
  #######Extra Backwards Compatibility Functionality#######
  sub socket_to_SSL { IO::Socket::SSL->start_SSL(@_); }
  sub socketToSSL { IO::Socket::SSL->start_SSL(@_); }
  sub kill_socket { shift->close }
  
  sub issuer_name { return(shift()->peer_certificate("issuer")) }
  sub subject_name { return(shift()->peer_certificate("subject")) }
  sub get_peer_certificate { return shift() }
  
  sub context_init {
      return($GLOBAL_SSL_ARGS = (ref($_[0]) eq 'HASH') ? $_[0] : {@_});
  }
  
  sub set_default_context {
      $GLOBAL_SSL_ARGS->{'SSL_reuse_ctx'} = shift;
  }
  
  sub set_default_session_cache {
      $GLOBAL_SSL_ARGS->{SSL_session_cache} = shift;
  }
  
  
  {
      my $set_defaults = sub {
  	my $args = shift;
  	for(my $i=0;$i<@$args;$i+=2 ) {
  	    my ($k,$v) = @{$args}[$i,$i+1];
  	    if ( $k =~m{^SSL_} ) {
  		$_->{$k} = $v for(@_);
  	    } elsif ( $k =~m{^(name|scheme)$} ) {
  		$_->{"SSL_verifycn_$k"} = $v for (@_);
  	    } elsif ( $k =~m{^(callback|mode)$} ) {
  		$_->{"SSL_verify_$k"} = $v for(@_);
  	    } else {
  		$_->{"SSL_$k"} = $v for(@_);
  	    }
  	}
      };
      sub set_defaults {
  	my %args = @_;
  	$set_defaults->(\@_,
  	    $GLOBAL_SSL_ARGS,
  	    $GLOBAL_SSL_CLIENT_ARGS,
  	    $GLOBAL_SSL_SERVER_ARGS
  	);
      }
      { # deprecated API
  	no warnings;
  	*set_ctx_defaults = \&set_defaults;
      }
      sub set_client_defaults {
  	my %args = @_;
  	$set_defaults->(\@_, $GLOBAL_SSL_CLIENT_ARGS );
      }
      sub set_server_defaults {
  	my %args = @_;
  	$set_defaults->(\@_, $GLOBAL_SSL_SERVER_ARGS );
      }
  }
  
  sub set_args_filter_hack {
      my $sub = shift;
      if ( ref $sub ) {
  	$FILTER_SSL_ARGS = $sub;
      } elsif ( $sub eq 'use_defaults' ) {
  	# override args with defaults
  	$FILTER_SSL_ARGS = sub {
  	    my ($is_server,$args) = @_;
  	    %$args = ( %$args, $is_server
  		? ( %DEFAULT_SSL_SERVER_ARGS, %$GLOBAL_SSL_SERVER_ARGS )
  		: ( %DEFAULT_SSL_CLIENT_ARGS, %$GLOBAL_SSL_CLIENT_ARGS )
  	    );
  	}
      }
  }
  
  sub next_proto_negotiated {
      my $self = shift;
      return $self->_internal_error("NPN not supported in Net::SSLeay",9) if ! $can_npn;
      my $ssl = $self->_get_ssl_object || return;
      return Net::SSLeay::P_next_proto_negotiated($ssl);
  }
  
  sub alpn_selected {
      my $self = shift;
      return $self->_internal_error("ALPN not supported in Net::SSLeay",9) if ! $can_alpn;
      my $ssl = $self->_get_ssl_object || return;
      return Net::SSLeay::P_alpn_selected($ssl);
  }
  
  sub opened {
      my $self = shift;
      return IO::Handle::opened($self) && ${*$self}{'_SSL_opened'};
  }
  
  sub opening {
      my $self = shift;
      return ${*$self}{'_SSL_opening'};
  }
  
  sub want_read  { shift->errstr == SSL_WANT_READ }
  sub want_write { shift->errstr == SSL_WANT_WRITE }
  
  
  #Redundant IO::Handle functionality
  sub getline { return(scalar shift->readline()) }
  sub getlines {
      return(shift->readline()) if wantarray();
      croak("Use of getlines() not allowed in scalar context");
  }
  
  #Useless IO::Handle functionality
  sub truncate { croak("Use of truncate() not allowed with SSL") }
  sub stat     { croak("Use of stat() not allowed with SSL" ) }
  sub setbuf   { croak("Use of setbuf() not allowed with SSL" ) }
  sub setvbuf  { croak("Use of setvbuf() not allowed with SSL" ) }
  sub fdopen   { croak("Use of fdopen() not allowed with SSL" ) }
  
  #Unsupported socket functionality
  sub ungetc { croak("Use of ungetc() not implemented in IO::Socket::SSL") }
  sub send   { croak("Use of send() not implemented in IO::Socket::SSL; use print/printf/syswrite instead") }
  sub recv   { croak("Use of recv() not implemented in IO::Socket::SSL; use read/sysread instead") }
  
  package IO::Socket::SSL::SSL_HANDLE;
  use strict;
  use Errno 'EBADF';
  *weaken = *IO::Socket::SSL::weaken;
  
  sub TIEHANDLE {
      my ($class, $handle) = @_;
      weaken($handle);
      bless \$handle, $class;
  }
  
  sub READ     { ${shift()}->sysread(@_) }
  sub READLINE { ${shift()}->readline(@_) }
  sub GETC     { ${shift()}->getc(@_) }
  
  sub PRINT    { ${shift()}->print(@_) }
  sub PRINTF   { ${shift()}->printf(@_) }
  sub WRITE    { ${shift()}->syswrite(@_) }
  
  sub FILENO   { ${shift()}->fileno(@_) }
  
  sub TELL     { $! = EBADF; return -1 }
  sub BINMODE  { return 0 }  # not perfect, but better than not implementing the method
  
  sub CLOSE {                          #<---- Do not change this function!
      my $ssl = ${$_[0]};
      local @_;
      $ssl->close();
  }
  
  
  package IO::Socket::SSL::SSL_Context;
  use Carp;
  use strict;
  
  my %CTX_CREATED_IN_THIS_THREAD;
  *DEBUG = *IO::Socket::SSL::DEBUG;
  
  use constant SSL_MODE_ENABLE_PARTIAL_WRITE => 1;
  use constant SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER => 2;
  
  use constant FILETYPE_PEM => Net::SSLeay::FILETYPE_PEM();
  use constant FILETYPE_ASN1 => Net::SSLeay::FILETYPE_ASN1();
  
  my $DEFAULT_SSL_OP = &Net::SSLeay::OP_ALL
      | &Net::SSLeay::OP_SINGLE_DH_USE
      | ($can_ecdh && &Net::SSLeay::OP_SINGLE_ECDH_USE);
  
  # Note that the final object will actually be a reference to the scalar
  # (C-style pointer) returned by Net::SSLeay::CTX_*_new() so that
  # it can be blessed.
  sub new {
      my $class = shift;
      #DEBUG( "$class @_" );
      my $arg_hash = (ref($_[0]) eq 'HASH') ? $_[0] : {@_};
  
      my $is_server = $arg_hash->{SSL_server};
      my %defaults = $is_server
  	? (%DEFAULT_SSL_SERVER_ARGS, %$GLOBAL_SSL_ARGS, %$GLOBAL_SSL_SERVER_ARGS) 
  	: (%DEFAULT_SSL_CLIENT_ARGS, %$GLOBAL_SSL_ARGS, %$GLOBAL_SSL_CLIENT_ARGS);
      if ( $defaults{SSL_reuse_ctx} ) {
  	# ignore default context if there are args to override it
  	delete $defaults{SSL_reuse_ctx}
  	    if grep { m{^SSL_(?!verifycn_name|hostname)$} } keys %$arg_hash;
      }
      %$arg_hash = ( %defaults, %$arg_hash ) if %defaults;
  
      if (my $ctx = $arg_hash->{'SSL_reuse_ctx'}) {
  	if ($ctx->isa('IO::Socket::SSL::SSL_Context') and
  	    $ctx->{context}) {
  	    # valid context
  	} elsif ( $ctx = ${*$ctx}{_SSL_ctx} ) {
  	    # reuse context from existing SSL object
  	}
  	return $ctx
      }
  
      # common problem forgetting to set SSL_use_cert
      # if client cert is given by user but SSL_use_cert is undef, assume that it
      # should be set
      if ( ! $is_server && ! defined $arg_hash->{SSL_use_cert}
  	&& ( grep { $arg_hash->{$_} } qw(SSL_cert SSL_cert_file))
  	&& ( grep { $arg_hash->{$_} } qw(SSL_key SSL_key_file)) ) {
  	$arg_hash->{SSL_use_cert} = 1
      }
  
      # if any of SSL_ca* is set don't set the other SSL_ca*
      # from defaults
      if ( $arg_hash->{SSL_ca} ) {
  	$arg_hash->{SSL_ca_file} ||= undef
  	$arg_hash->{SSL_ca_path} ||= undef
      } elsif ( $arg_hash->{SSL_ca_path} ) {
  	$arg_hash->{SSL_ca_file} ||= undef
      } elsif ( $arg_hash->{SSL_ca_file} ) {
  	$arg_hash->{SSL_ca_path} ||= undef;
      }
  
      # add library defaults
      $arg_hash->{SSL_use_cert} = $is_server if ! defined $arg_hash->{SSL_use_cert};
  
  
      # Avoid passing undef arguments to Net::SSLeay
      defined($arg_hash->{$_}) or delete($arg_hash->{$_}) for(keys %$arg_hash);
  
      # check SSL CA, cert etc arguments
      # some apps set keys '' to signal that it is not set, replace with undef
      for (qw( SSL_cert SSL_cert_file SSL_key SSL_key_file
  	SSL_ca SSL_ca_file SSL_ca_path
  	SSL_fingerprint )) {
  	$arg_hash->{$_} = undef if defined $arg_hash->{$_}
  	    and $arg_hash->{$_} eq '';
      }
      for(qw(SSL_cert_file SSL_key_file)) {
  	 defined( my $file = $arg_hash->{$_} ) or next;
  	for my $f (ref($file) eq 'HASH' ? values(%$file):$file ) {
  	    die "$_ $f can't be used: $!" if ! open(my $fh,'<',$f)
  	}
      }
  
      my $verify_mode = $arg_hash->{SSL_verify_mode} || 0;
      if ( $verify_mode != $Net_SSLeay_VERIFY_NONE) {
  	for (qw(SSL_ca_file SSL_ca_path)) {
  	    $CHECK_SSL_PATH->($_ => $arg_hash->{$_} || next);
  	}
      } elsif ( $verify_mode ne '0' ) {
  	# some users use the string 'SSL_VERIFY_PEER' instead of the constant
  	die "SSL_verify_mode must be a number and not a string";
      }
  
      my $self = bless {},$class;
  
      my $vcn_scheme = delete $arg_hash->{SSL_verifycn_scheme};
      my $vcn_publicsuffix = delete $arg_hash->{SSL_verifycn_publicsuffix};
      if ( ! $is_server and $verify_mode & 0x01 and
  	! $vcn_scheme || $vcn_scheme ne 'none' ) {
  
  	# gets updated during configure_SSL
  	my $verify_name;
  	$self->{verify_name_ref} = \$verify_name;
  
  	my $vcb = $arg_hash->{SSL_verify_callback};
  	$arg_hash->{SSL_verify_callback} = sub {
  	    my ($ok,$ctx_store,$certname,$error,$cert,$depth) = @_;
  	    $ok = $vcb->($ok,$ctx_store,$certname,$error,$cert,$depth) if $vcb;
  	    $ok or return 0;
  
  	    return $ok if $depth != 0;
  
  	    my $host = $verify_name || ref($vcn_scheme) && $vcn_scheme->{callback} && 'unknown';
  	    if ( ! $host ) {
  		if ( $vcn_scheme ) {
  		    IO::Socket::SSL->_internal_error(
  			"Cannot determine peer hostname for verification",8);
  		    return 0;
  		}
  		warn "Cannot determine hostname of peer for verification. ".
  		    "Disabling default hostname verification for now. ".
  		    "Please specify hostname with SSL_verifycn_name and better set SSL_verifycn_scheme too.\n";
  		return $ok;
  	    } elsif ( ! $vcn_scheme && $host =~m{^[\d.]+$|:} ) {
  		# don't try to verify IP by default
  		return $ok;
  	    }
  
  
  	    # verify name
  	    my $rv = IO::Socket::SSL::verify_hostname_of_cert(
  		$host,$cert,$vcn_scheme,$vcn_publicsuffix );
  	    if ( ! $rv ) {
  		IO::Socket::SSL->_internal_error(
  		    "hostname verification failed",5);
  	    }
  	    return $rv;
  	};
      }
  
      if ($is_server) {
  	if ($arg_hash->{SSL_ticket_keycb} && !$can_tckt_keycb) {
  	    warn "Ticket Key Callback is not supported - ignoring option SSL_ticket_keycb\n";
  	    delete $arg_hash->{SSL_ticket_keycb};
  	}
      }
  
  
      my $ssl_op = $DEFAULT_SSL_OP;
  
      my $ver;
      for (split(/\s*:\s*/,$arg_hash->{SSL_version})) {
  	m{^(!?)(?:(SSL(?:v2|v3|v23|v2/3))|(TLSv1(?:_?[12])?))$}i
  	or croak("invalid SSL_version specified");
  	my $not = $1;
  	( my $v = lc($2||$3) ) =~s{^(...)}{\U$1};
  	if ( $not ) {
  	    $ssl_op |= $SSL_OP_NO{$v};
  	} else {
  	    croak("cannot set multiple SSL protocols in SSL_version")
  		if $ver && $v ne $ver;
  	    $ver = $v;
  	    $ver =~s{/}{}; # interpret SSLv2/3 as SSLv23
  	    $ver =~s{(TLSv1)(\d)}{$1\_$2}; # TLSv1_1
  	}
      }
  
      my $ctx_new_sub =  UNIVERSAL::can( 'Net::SSLeay',
  	$ver eq 'SSLv2'   ? 'CTX_v2_new' :
  	$ver eq 'SSLv3'   ? 'CTX_v3_new' :
  	$ver eq 'TLSv1'   ? 'CTX_tlsv1_new' :
  	$ver eq 'TLSv1_1' ? 'CTX_tlsv1_1_new' :
  	$ver eq 'TLSv1_2' ? 'CTX_tlsv1_2_new' :
  	'CTX_new'
      ) or return IO::Socket::SSL->_internal_error("SSL Version $ver not supported",9);
  
      # For SNI in server mode we need a separate context for each certificate.
      my %ctx;
      if ($is_server) {
  	my %sni;
  	for my $opt (qw(SSL_key SSL_key_file SSL_cert SSL_cert_file)) {
  	    my $val  = $arg_hash->{$opt} or next;
  	    if ( ref($val) eq 'HASH' ) {
  		while ( my ($host,$v) = each %$val ) {
  		    $sni{lc($host)}{$opt} = $v;
  		}
  	    }
  	}
  	while (my ($host,$v) = each %sni) {
  	    $ctx{$host} = { %$arg_hash, %$v };
  	}
      }
      $ctx{''} = $arg_hash if ! %ctx;
  
      while (my ($host,$arg_hash) = each %ctx) {
  	# replace value in %ctx with real context
  	my $ctx = $ctx_new_sub->() or return
  	    IO::Socket::SSL->error("SSL Context init failed");
  	$CTX_CREATED_IN_THIS_THREAD{$ctx} = 1 if $use_threads;
  
  	# SSL_OP_CIPHER_SERVER_PREFERENCE
  	$ssl_op |= 0x00400000 if $arg_hash->{SSL_honor_cipher_order};
  
  	if ($ver eq 'SSLv23' && !($ssl_op & $SSL_OP_NO{SSLv3})) {
  	    # At least LibreSSL disables SSLv3 by default in SSL_CTX_new.
  	    # If we really want SSL3.0 we need to explicitly allow it with
  	    # SSL_CTX_clear_options.
  	    Net::SSLeay::CTX_clear_options($ctx,$SSL_OP_NO{SSLv3});
  	}
  
  	Net::SSLeay::CTX_set_options($ctx,$ssl_op);
  
  	# if we don't set session_id_context if client certificate is expected
  	# client session caching will fail
  	# if user does not provide explicit id just use the stringification
  	# of the context
  	if($arg_hash->{SSL_server} and my $id = 
  	    $arg_hash->{SSL_session_id_context} || 
  	    ( $arg_hash->{SSL_verify_mode} & 0x01 ) && "$ctx" ) {
  	    Net::SSLeay::CTX_set_session_id_context($ctx,$id,length($id));
  	}
  
  	# SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER makes syswrite return if at least one
  	# buffer was written and not block for the rest
  	# SSL_MODE_ENABLE_PARTIAL_WRITE can be necessary for non-blocking because we
  	# cannot guarantee, that the location of the buffer stays constant
  	Net::SSLeay::CTX_set_mode( $ctx,
  	    SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER|SSL_MODE_ENABLE_PARTIAL_WRITE);
  
  	if ( my $proto_list = $arg_hash->{SSL_npn_protocols} ) {
  	    return IO::Socket::SSL->_internal_error("NPN not supported in Net::SSLeay",9)
  		if ! $can_npn;
  	    if($arg_hash->{SSL_server}) {
  		# on server side SSL_npn_protocols means a list of advertised protocols
  		Net::SSLeay::CTX_set_next_protos_advertised_cb($ctx, $proto_list);
  	    } else {
  		# on client side SSL_npn_protocols means a list of preferred protocols
  		# negotiation algorithm used is "as-openssl-implements-it"
  		Net::SSLeay::CTX_set_next_proto_select_cb($ctx, $proto_list);
  	    }
  	}
  
  	if ( my $proto_list = $arg_hash->{SSL_alpn_protocols} ) {
  	    return IO::Socket::SSL->_internal_error("ALPN not supported in Net::SSLeay",9)
  		if ! $can_alpn;
  	    if($arg_hash->{SSL_server}) {
  		Net::SSLeay::CTX_set_alpn_select_cb($ctx, $proto_list);
  	    } else {
  		Net::SSLeay::CTX_set_alpn_protos($ctx, $proto_list);
  	    }
  	}
  
  	if ($arg_hash->{SSL_ticket_keycb}) {
  	    my $cb = $arg_hash->{SSL_ticket_keycb};
  	    ($cb,my $arg) = ref($cb) eq 'CODE' ? ($cb):@$cb;
  	    Net::SSLeay::CTX_set_tlsext_ticket_getkey_cb($ctx,$cb,$arg);
  	}
  
  	# Try to apply SSL_ca even if SSL_verify_mode is 0, so that they can be
  	# used to verify OCSP responses.
  	# If applying fails complain only if verify_mode != VERIFY_NONE.
  	if ( $arg_hash->{SSL_ca}
  	    || defined $arg_hash->{SSL_ca_file}
  	    || defined $arg_hash->{SSL_ca_path} ) {
  	    my $file = $arg_hash->{SSL_ca_file};
  	    $file = undef if ref($file) eq 'SCALAR' && ! $$file;
  	    my $dir = $arg_hash->{SSL_ca_path};
  	    $dir = undef if ref($dir) eq 'SCALAR' && ! $$dir;
  	    if ( $arg_hash->{SSL_ca} ) {
  		my $store = Net::SSLeay::CTX_get_cert_store($ctx);
  		for (@{$arg_hash->{SSL_ca}}) {
  		    Net::SSLeay::X509_STORE_add_cert($store,$_) or
  			return IO::Socket::SSL->error(
  			    "Failed to add certificate to CA store");
  		}
  	    }
  	    $dir = join($OPENSSL_LIST_SEPARATOR,@$dir) if ref($dir);
  	    if ( $file || $dir and ! Net::SSLeay::CTX_load_verify_locations(
  		$ctx, $file || '', $dir || '')) {
  		return IO::Socket::SSL->error(
  		    "Invalid certificate authority locations")
  		    if $verify_mode != $Net_SSLeay_VERIFY_NONE;
  	    }
  	} elsif ( my %ca = IO::Socket::SSL::default_ca()) {
  	    # no CA path given, continue with system defaults
  	    my $dir = $ca{SSL_ca_path};
  	    $dir = join($OPENSSL_LIST_SEPARATOR,@$dir) if ref($dir);
  	    if (! Net::SSLeay::CTX_load_verify_locations( $ctx,
  		$ca{SSL_ca_file} || '',$dir || '')
  		&& $verify_mode != $Net_SSLeay_VERIFY_NONE) {
  		return IO::Socket::SSL->error(
  		    "Invalid default certificate authority locations")
  	    }
  	}
  
  	if ($is_server && ($verify_mode & $Net_SSLeay_VERIFY_PEER)) {
  	    if ($arg_hash->{SSL_client_ca}) {
  		for (@{$arg_hash->{SSL_client_ca}}) {
  		    return IO::Socket::SSL->error(
  			"Failed to add certificate to client CA list") if
  			! Net::SSLeay::CTX_add_client_CA($ctx,$_);
  		}
  	    }
  	    if ($arg_hash->{SSL_client_ca_file}) {
  		my $list = Net::SSLeay::load_client_CA_file(
  		    $arg_hash->{SSL_client_ca_file}) or
  		    return IO::Socket::SSL->error(
  		    "Failed to load certificate to client CA list");
  		Net::SSLeay::CTX_set_client_CA_list($ctx,$list);
  	    }
  	}
  
  	my $X509_STORE_flags = $DEFAULT_X509_STORE_flags;
  	if ($arg_hash->{'SSL_check_crl'}) {
  	    $X509_STORE_flags |= Net::SSLeay::X509_V_FLAG_CRL_CHECK();
  	    if ($arg_hash->{'SSL_crl_file'}) {
  		my $bio = Net::SSLeay::BIO_new_file($arg_hash->{'SSL_crl_file'}, 'r');
  		my $crl = Net::SSLeay::PEM_read_bio_X509_CRL($bio);
  		Net::SSLeay::BIO_free($bio);
  		if ( $crl ) {
  		    Net::SSLeay::X509_STORE_add_crl(Net::SSLeay::CTX_get_cert_store($ctx), $crl);
  		} else {
  		    return IO::Socket::SSL->error("Invalid certificate revocation list");
  		}
  	    }
  	}
  
  	Net::SSLeay::X509_STORE_set_flags(
  	    Net::SSLeay::CTX_get_cert_store($ctx),
  	    $X509_STORE_flags
  	) if $X509_STORE_flags;
  
  	Net::SSLeay::CTX_set_default_passwd_cb($ctx,$arg_hash->{SSL_passwd_cb})
  	    if $arg_hash->{SSL_passwd_cb};
  
  	my ($havekey,$havecert);
  	if ( my $x509 = $arg_hash->{SSL_cert} ) {
  	    # binary, e.g. X509*
  	    # we have either a single certificate or a list with
  	    # a chain of certificates
  	    my @x509 = ref($x509) eq 'ARRAY' ? @$x509: ($x509);
  	    my $cert = shift @x509;
  	    Net::SSLeay::CTX_use_certificate( $ctx,$cert )
  		|| return IO::Socket::SSL->error("Failed to use Certificate");
  	    foreach my $ca (@x509) {
  		Net::SSLeay::CTX_add_extra_chain_cert( $ctx,$ca )
  		    || return IO::Socket::SSL->error("Failed to use Certificate");
  	    }
  	    $havecert = 'OBJ';
  	} elsif ( my $f = $arg_hash->{SSL_cert_file} ) {
  	    # try to load chain from PEM or certificate from ASN1
  	    if (Net::SSLeay::CTX_use_certificate_chain_file($ctx,$f)) {
  		$havecert = 'PEM';
  	    } elsif (Net::SSLeay::CTX_use_certificate_file($ctx,$f,FILETYPE_ASN1)) {
  		$havecert = 'DER';
  	    } else {
  		# try to load certificate, key and chain from PKCS12 file
  		my ($key,$cert,@chain) = Net::SSLeay::P_PKCS12_load_file($f,1);
  		if (!$cert and $arg_hash->{SSL_passwd_cb}
  		    and defined( my $pw = $arg_hash->{SSL_passwd_cb}->(0))) {
  		    ($key,$cert,@chain) = Net::SSLeay::P_PKCS12_load_file($f,1,$pw);
  		}
  		PKCS12: while ($cert) {
  		    Net::SSLeay::CTX_use_certificate($ctx,$cert) or last;
  		    # Net::SSLeay::P_PKCS12_load_file is implemented using
  		    # OpenSSL PKCS12_parse which according to the source code
  		    # returns the chain with the last CA certificate first (i.e.
  		    # reverse order as in the PKCS12 file). This is not
  		    # documented but given the age of this function we'll assume
  		    # that this will stay this way in the future.
  		    while (my $ca = pop @chain) {
  			Net::SSLeay::CTX_add_extra_chain_cert($ctx,$ca)
  			    or last PKCS12;
  		    }
  		    last if $key && ! Net::SSLeay::CTX_use_PrivateKey($ctx,$key);
  		    $havecert = 'PKCS12';
  		    last;
  		}
  		$havekey = 'PKCS12' if $key;
  		Net::SSLeay::X509_free($cert) if $cert;
  		Net::SSLeay::EVP_PKEY_free($key) if $key;
  		# don't free @chain, because CTX_add_extra_chain_cert
  		# did not duplicate the certificates
  	    }
  	    $havecert or return IO::Socket::SSL->error(
  		"Failed to load certificate from file (no PEM, DER or PKCS12)");
  	}
  
  	if (!$havecert || $havekey) {
  	    # skip SSL_key_*
  	} elsif ( my $pkey = $arg_hash->{SSL_key} ) {
  	    # binary, e.g. EVP_PKEY*
  	    Net::SSLeay::CTX_use_PrivateKey($ctx, $pkey)
  		|| return IO::Socket::SSL->error("Failed to use Private Key");
  	    $havekey = 'MEM';
  	} elsif ( my $f = $arg_hash->{SSL_key_file}
  	    || (($havecert eq 'PEM') ? $arg_hash->{SSL_cert_file}:undef) ) {
  	    for my $ft ( FILETYPE_PEM, FILETYPE_ASN1 ) {
  		if (Net::SSLeay::CTX_use_PrivateKey_file($ctx,$f,$ft)) {
  		    $havekey = ($ft == FILETYPE_PEM) ? 'PEM':'DER';
  		    last;
  		}
  	    }
  	    $havekey or return IO::Socket::SSL->error(
  		"Failed to load key from file (no PEM or DER)");
  	}
  
  	# replace arg_hash with created context
  	$ctx{$host} = $ctx;
      }
  
      if ($arg_hash->{'SSL_server'} || $arg_hash->{'SSL_use_cert'}) {
  
  	if ( my $f = $arg_hash->{SSL_dh_file} ) {
  	    my $bio = Net::SSLeay::BIO_new_file( $f,'r' )
  		|| return IO::Socket::SSL->error( "Failed to open DH file $f" );
  	    my $dh = Net::SSLeay::PEM_read_bio_DHparams($bio);
  	    Net::SSLeay::BIO_free($bio);
  	    $dh || return IO::Socket::SSL->error( "Failed to read PEM for DH from $f - wrong format?" );
  	    my $rv;
  	    for (values (%ctx)) {
  		$rv = Net::SSLeay::CTX_set_tmp_dh( $_,$dh ) or last;
  	    }
  	    Net::SSLeay::DH_free( $dh );
  	    $rv || return IO::Socket::SSL->error( "Failed to set DH from $f" );
  	} elsif ( my $dh = $arg_hash->{SSL_dh} ) {
  	    # binary, e.g. DH*
  
  	    for( values %ctx ) {
  		Net::SSLeay::CTX_set_tmp_dh( $_,$dh ) || return 
  		    IO::Socket::SSL->error( "Failed to set DH from SSL_dh" );
  	    }
  	}
  
  	if ( my $curve = $arg_hash->{SSL_ecdh_curve} ) {
  	    return IO::Socket::SSL->_internal_error(
  		"ECDH curve needs Net::SSLeay>=1.56 and OpenSSL>=1.0",9)
  		if ! $can_ecdh;
  	    if ( $curve !~ /^\d+$/ ) {
  		# name of curve, find NID
  		$curve = Net::SSLeay::OBJ_txt2nid($curve)
  		    || return IO::Socket::SSL->error(
  		    "cannot find NID for curve name '$curve'");
  	    }
  	    my $ecdh = Net::SSLeay::EC_KEY_new_by_curve_name($curve) or
  		return IO::Socket::SSL->error(
  		"cannot create curve for NID $curve");
  	    for( values %ctx ) {
  		Net::SSLeay::CTX_set_tmp_ecdh($_,$ecdh) or
  		    return IO::Socket::SSL->error(
  		    "failed to set ECDH curve context");
  	    }
  	    Net::SSLeay::EC_KEY_free($ecdh);
  	}
      }
  
      my $verify_cb = $arg_hash->{SSL_verify_callback};
      my @accept_fp;
      if ( my $fp = $arg_hash->{SSL_fingerprint} ) {
  	for( ref($fp) ? @$fp : $fp) {
  	    my ($algo,$pubkey,$digest) = m{^([\w-]+)\$(pub\$)?([a-f\d:]+)$}i;
  	    return IO::Socket::SSL->_internal_error("invalid fingerprint '$_'",9)
  		if ! $algo;
  	    $algo = lc($algo);
  	    ( $digest = lc($digest) ) =~s{:}{}g;
  	    push @accept_fp,[ $algo, $pubkey || '', pack('H*',$digest) ]
  	}
      }
      my $verify_fingerprint = @accept_fp && do {
  	my $fail;
  	sub {
  	    my ($ok,$cert,$depth) = @_;
  	    $fail = 1 if ! $ok;
  	    return 1 if $depth>0; # to let us continue with verification
  	    # Check fingerprint only from top certificate.
  	    my %fp;
  	    for(@accept_fp) {
  		my $fp = $fp{$_->[0],$_->[1]} ||= $_->[1]
  		    ? Net::SSLeay::X509_pubkey_digest($cert,$algo2digest->($_->[0]))
  		    : Net::SSLeay::X509_digest($cert,$algo2digest->($_->[0]));
  		next if $fp ne $_->[2];
  		return 1;
  	    }
  	    return ! $fail;
  	}
      };
      my $verify_callback = ( $verify_cb || @accept_fp ) && sub {
  	my ($ok, $ctx_store) = @_;
  	my ($certname,$cert,$error,$depth);
  	if ($ctx_store) {
  	    $cert  = Net::SSLeay::X509_STORE_CTX_get_current_cert($ctx_store);
  	    $error = Net::SSLeay::X509_STORE_CTX_get_error($ctx_store);
  	    $depth = Net::SSLeay::X509_STORE_CTX_get_error_depth($ctx_store);
  	    $certname =
  		Net::SSLeay::X509_NAME_oneline(Net::SSLeay::X509_get_issuer_name($cert)).
  		Net::SSLeay::X509_NAME_oneline(Net::SSLeay::X509_get_subject_name($cert));
  	    $error &&= Net::SSLeay::ERR_error_string($error);
  	}
  	$DEBUG>=3 && DEBUG( "ok=$ok [$depth] $certname" );
  	$ok = $verify_cb->($ok,$ctx_store,$certname,$error,$cert,$depth) if $verify_cb;
  	$ok = $verify_fingerprint->($ok,$cert,$depth) if $verify_fingerprint && $cert;
  	return $ok;
      };
  
      if ( $^O eq 'darwin' ) {
  	# explicitly set error code to disable use of apples TEA patch
  	# https://hynek.me/articles/apple-openssl-verification-surprises/
  	my $vcb = $verify_callback;
  	$verify_callback = sub {
  	    my $rv = $vcb ? &$vcb : $_[0];
  	    if ( $rv != 1 ) {
  		# 50 - X509_V_ERR_APPLICATION_VERIFICATION: application verification failure
  		Net::SSLeay::X509_STORE_CTX_set_error($_[1], 50);
  	    }
  	    return $rv;
  	};
      }
      Net::SSLeay::CTX_set_verify($_, $verify_mode, $verify_callback)
  	for (values %ctx);
  
      my $staple_callback = $arg_hash->{SSL_ocsp_staple_callback};
      if ( !$is_server && $can_ocsp_staple && ! $verify_fingerprint) {
  	$self->{ocsp_cache} = $arg_hash->{SSL_ocsp_cache};
  	my $status_cb = sub {
  	    my ($ssl,$resp) = @_;
  	    my $iossl = $SSL_OBJECT{$ssl} or
  		die "no IO::Socket::SSL object found for SSL $ssl";
  	    $iossl->[1] and do {
  		# we must return with 1 or it will be called again
  		# and because we have no SSL object we must make the error global
  		Carp::cluck($IO::Socket::SSL::SSL_ERROR
  		    = "OCSP callback on server side");
  		return 1;
  	    };
  	    $iossl = $iossl->[0];
  
  	    # if we have a callback use this
  	    # callback must not free or copy $resp !!
  	    if ( $staple_callback ) {
  		$staple_callback->($iossl,$resp);
  		return 1;
  	    }
  
  	    # default callback does verification
  	    if ( ! $resp ) {
  		$DEBUG>=3 && DEBUG("did not get stapled OCSP response");
  		return 1;
  	    }
  	    $DEBUG>=3 && DEBUG("got stapled OCSP response");
  	    my $status = Net::SSLeay::OCSP_response_status($resp);
  	    if ($status != Net::SSLeay::OCSP_RESPONSE_STATUS_SUCCESSFUL()) {
  		$DEBUG>=3 && DEBUG("bad status of stapled OCSP response: ".
  		    Net::SSLeay::OCSP_response_status_str($status));
  		return 1;
  	    }
  	    if (!eval { Net::SSLeay::OCSP_response_verify($ssl,$resp) }) {
  		$DEBUG>=3 && DEBUG("verify of stapled OCSP response failed");
  		return 1;
  	    }
  	    my (@results,$hard_error);
  	    my @chain = $iossl->peer_certificates;
  	    for my $cert (@chain) {
  		my $certid = eval { Net::SSLeay::OCSP_cert2ids($ssl,$cert) };
  		if (!$certid) {
  		    $DEBUG>=3 && DEBUG("cannot create OCSP_CERTID: $@");
  		    push @results,[-1,$@];
  		    last;
  		}
  		($status) = Net::SSLeay::OCSP_response_results($resp,$certid);
  		if ($status && $status->[2]) {
  		    my $cache = ${*$iossl}{_SSL_ctx}{ocsp_cache};
  		    if (!$status->[1]) {
  			push @results,[1,$status->[2]{nextUpdate}];
  			$cache && $cache->put($certid,$status->[2]);
  		    } elsif ( $status->[2]{statusType} ==
  			Net::SSLeay::V_OCSP_CERTSTATUS_GOOD()) {
  			push @results,[1,$status->[2]{nextUpdate}];
  			$cache && $cache->put($certid,{
  			    %{$status->[2]},
  			    expire => time()+120,
  			    soft_error => $status->[1],
  			});
  		    } else {
  			push @results,($hard_error = [0,$status->[1]]);
  			$cache && $cache->put($certid,{
  			    %{$status->[2]},
  			    hard_error => $status->[1],
  			});
  		    }
  		}
  	    }
  	    # return result of lead certificate, this should be in chain[0] and
  	    # thus result[0], but we better check. But if we had any hard_error
  	    # return this instead
  	    if ($hard_error) {
  		${*$iossl}{_SSL_ocsp_verify} = $hard_error;
  	    } elsif (@results and $chain[0] == $iossl->peer_certificate) {
  		${*$iossl}{_SSL_ocsp_verify} = $results[0];
  	    }
  	    return 1;
  	};
  	Net::SSLeay::CTX_set_tlsext_status_cb($_,$status_cb) for (values %ctx);
      }
  
      if ( my $cl = $arg_hash->{SSL_cipher_list} ) {
  	for (keys %ctx) {
  	    Net::SSLeay::CTX_set_cipher_list($ctx{$_}, ref($cl) 
  		? $cl->{$_} || $cl->{''} || $DEFAULT_SSL_ARGS{SSL_cipher_list} || next 
  		: $cl
  	    ) || return IO::Socket::SSL->error("Failed to set SSL cipher list");
  	}
      }
  
      # Main context is default context or any other if no default context.
      my $ctx = $ctx{''} || (values %ctx)[0];
      if (keys(%ctx) > 1 || ! exists $ctx{''}) {
  	$can_server_sni or return IO::Socket::SSL->_internal_error(
  	    "Server side SNI not supported for this openssl/Net::SSLeay",9);
  
  	Net::SSLeay::CTX_set_tlsext_servername_callback($ctx, sub {
  	    my $ssl = shift;
  	    my $host = Net::SSLeay::get_servername($ssl);
  	    $host = '' if ! defined $host;
  	    my $snictx = $ctx{lc($host)} || $ctx{''} or do {
  		$DEBUG>1 and DEBUG(
  		    "cannot get context from servername '$host'");
  		return 0;
  	    };
  	    $DEBUG>1 and DEBUG("set context from servername $host");
  	    Net::SSLeay::set_SSL_CTX($ssl,$snictx) if $snictx != $ctx;
  	    return 1;
  	});
      }
  
      if ( my $cb = $arg_hash->{SSL_create_ctx_callback} ) {
  	$cb->($_) for values (%ctx);
      }
  
      $self->{context} = $ctx;
      $self->{verify_mode} = $arg_hash->{SSL_verify_mode};
      $self->{ocsp_mode} =
  	defined($arg_hash->{SSL_ocsp_mode}) ? $arg_hash->{SSL_ocsp_mode} :
  	$self->{verify_mode} ? IO::Socket::SSL::SSL_OCSP_TRY_STAPLE() :
  	0;
      $DEBUG>=3 && DEBUG( "new ctx $ctx" );
  
      if ( my $cache = $arg_hash->{SSL_session_cache} ) {
  	# use predefined cache
  	$self->{session_cache} = $cache
      } elsif ( my $size = $arg_hash->{SSL_session_cache_size}) {
  	$self->{session_cache} = IO::Socket::SSL::Session_Cache->new( $size );
      }
  
      return $self;
  }
  
  
  sub has_session_cache {
      return defined shift->{session_cache};
  }
  
  
  sub CLONE { %CTX_CREATED_IN_THIS_THREAD = (); }
  sub DESTROY {
      my $self = shift;
      if ( my $ctx = $self->{context} ) {
  	$DEBUG>=3 && DEBUG("free ctx $ctx open=".join( " ",keys %CTX_CREATED_IN_THIS_THREAD ));
  	if (!$use_threads or delete $CTX_CREATED_IN_THIS_THREAD{$ctx} ) {
  	    # remove any verify callback for this context
  	    if ( $self->{verify_mode}) {
  		$DEBUG>=3 && DEBUG("free ctx $ctx callback" );
  		Net::SSLeay::CTX_set_verify($ctx, 0,undef);
  	    }
  	    if ( $self->{ocsp_error_ref}) {
  		$DEBUG>=3 && DEBUG("free ctx $ctx tlsext_status_cb" );
  		Net::SSLeay::CTX_set_tlsext_status_cb($ctx,undef);
  	    }
  	    $DEBUG>=3 && DEBUG("OK free ctx $ctx" );
  	    Net::SSLeay::CTX_free($ctx);
  	}
      }
      delete(@{$self}{'context','session_cache'});
  }
  
  package IO::Socket::SSL::Session_Cache;
  use strict;
  
  sub new {
      my ($class, $size) = @_;
      $size>0 or return;
      return bless { _maxsize => $size }, $class;
  }
  
  
  sub del_session {
      my ($self, $key) = @_;
      my $val = delete $self->{$key} or return;
      Net::SSLeay::SESSION_free($val->{session});
      $val->{prev}{next} = $val->{next};
      $val->{next}{prev} = $val->{prev};
      if ($val != $self->{_head}) {
  	# keep head
      } elsif ($val == $val->{next}) {
  	# single element in cache, drop it
  	$self->{_head} = undef
      } else {
  	# point to next element in cache
  	$self->{_head} = $val->{next}
      }
  }
  
  sub get_session {
      my ($self, $key) = @_;
      my $session = $self->{$key} || return;
      return $session->{session} if ($self->{'_head'} eq $session);
      $session->{prev}->{next} = $session->{next};
      $session->{next}->{prev} = $session->{prev};
      $session->{next} = $self->{'_head'};
      $session->{prev} = $self->{'_head'}->{prev};
      $self->{'_head'}->{prev} = $self->{'_head'}->{prev}->{next} = $session;
      $self->{'_head'} = $session;
      return $session->{session};
  }
  
  sub add_session {
      my ($self, $key, $val) = @_;
      return if ($key eq '_maxsize' or $key eq '_head');
  
      if ( my $have = $self->{$key} ) {
  	Net::SSLeay::SESSION_free( $have->{session} );
  	$have->{session} = $val;
  	return get_session($self,$key); # will put key on front
      }
  
      my $session = $self->{$key} = { session => $val, key => $key };
  
      if ( keys(%$self) > $self->{_maxsize}+2) {
  	my $last = $self->{'_head'}->{prev};
  	Net::SSLeay::SESSION_free($last->{session});
  	delete($self->{$last->{key}});
  	$self->{'_head'}->{prev} = $self->{'_head'}->{prev}->{prev};
  	delete($self->{'_head'}) if ($self->{'_maxsize'} == 1);
      }
  
      if ($self->{'_head'}) {
  	$session->{next} = $self->{'_head'};
  	$session->{prev} = $self->{'_head'}->{prev};
  	$self->{'_head'}->{prev}->{next} = $session;
  	$self->{'_head'}->{prev} = $session;
      } else {
  	$session->{next} = $session->{prev} = $session;
      }
      $self->{'_head'} = $session;
      return $session;
  }
  
  sub DESTROY {
      my $self = shift;
      delete(@{$self}{'_head','_maxsize'});
      for (values %$self) {
  	Net::SSLeay::SESSION_free($_->{session} || next);
      }
  }
  
  
  
  package IO::Socket::SSL::OCSP_Cache;
  
  sub new {
      my ($class,$size) = @_;
      return bless {
  	'' => { _lru => 0, size => $size || 100 }
      },$class;
  }
  sub get {
      my ($self,$id) = @_;
      my $e = $self->{$id} or return;
      $e->{_lru} = $self->{''}{_lru}++;
      if ( $e->{expire} && time()<$e->{expire}) {
  	delete $self->{$id};
  	return;
      }
      if ( $e->{nextUpdate} && time()<$e->{nextUpdate} ) {
  	delete $self->{$id};
  	return;
      }
      return $e;
  }
  
  sub put {
      my ($self,$id,$e) = @_;
      $self->{$id} = $e;
      $e->{_lru} = $self->{''}{_lru}++;
      my $del = keys(%$self) - $self->{''}{size};
      if ($del>0) {
  	my @k = sort { $self->{$a}{_lru} <=> $self->{$b}{_lru} } keys %$self;
  	delete @{$self}{ splice(@k,0,$del) };
      }
      return $e;
  }
  
  package IO::Socket::SSL::OCSP_Resolver;
  *DEBUG = *IO::Socket::SSL::DEBUG;
  
  # create a new resolver
  # $ssl - the ssl object
  # $cache - OCSP_Cache object (put,get)
  # $failhard - flag if we should fail hard on OCSP problems
  # $certs - list of certs to verify
  sub new {
      my ($class,$ssl,$cache,$failhard,$certs) = @_;
      my (%todo,$done,$hard_error,@soft_error);
      for my $cert (@$certs) {
  	# skip entries which have no OCSP uri or where we cannot get a certid
  	# (e.g. self-signed or where we don't have the issuer)
  	my $subj = Net::SSLeay::X509_NAME_oneline(Net::SSLeay::X509_get_subject_name($cert));
  	my $uri = Net::SSLeay::P_X509_get_ocsp_uri($cert) or do {
  	    $DEBUG>2 && DEBUG("no URI for certificate $subj");
  	    push @soft_error,"no ocsp_uri for $subj";
  	    next;
  	};
  	my $certid = eval { Net::SSLeay::OCSP_cert2ids($ssl,$cert) } or do {
  	    $DEBUG>2 && DEBUG("no OCSP_CERTID for certificate $subj: $@");
  	    push @soft_error,"no certid for $subj: $@";
  	    next;
  	};
  	if (!($done = $cache->get($certid))) {
  	    push @{ $todo{$uri}{ids} }, $certid;
  	    push @{ $todo{$uri}{subj} }, $subj;
  	} elsif ( $done->{hard_error} ) {
  	    # one error is enough to fail validation
  	    $hard_error = $done->{hard_error};
  	    %todo = ();
  	    last;
  	} elsif ( $done->{soft_error} ) {
  	    push @soft_error,$done->{soft_error};
  	}
      }
      while ( my($uri,$v) = each %todo) {
  	my $ids = $v->{ids};
  	$v->{req} = Net::SSLeay::i2d_OCSP_REQUEST(
  	    Net::SSLeay::OCSP_ids2req(@$ids));
      }
      $hard_error ||= '' if ! %todo;
      return bless {
  	ssl => $ssl,
  	cache => $cache,
  	failhard => $failhard,
  	hard_error => $hard_error,
  	soft_error => @soft_error ? join("; ",@soft_error) : undef,
  	todo => \%todo,
      },$class;
  }
  
  # return current result, e.g. '' for no error, else error
  # if undef we have no final result yet
  sub hard_error { return shift->{hard_error} }
  sub soft_error { return shift->{soft_error} }
  
  # return hash with uri => ocsp_request_data for open requests
  sub requests {
      my $todo = shift()->{todo};
      return map { ($_,$todo->{$_}{req}) } keys %$todo;
  }
  
  # add new response
  sub add_response {
      my ($self,$uri,$resp) = @_;
      my $todo = delete $self->{todo}{$uri};
      return $self->{error} if ! $todo || $self->{error};
  
      my ($req,@soft_error,@hard_error);
  
      # do we have a response
      if (!$resp) {
  	@soft_error = "http request for OCSP failed; subject: ".
  	    join("; ",@{$todo->{subj}});
  
      # is it a valid OCSP_RESPONSE
      } elsif ( ! eval { $resp = Net::SSLeay::d2i_OCSP_RESPONSE($resp) }) {
  	@soft_error = "invalid response (no OCSP_RESPONSE); subject: ".
  	    join("; ",@{$todo->{subj}});
  	# hopefully short-time error
  	$self->{cache}->put($_,{
  	    soft_error => "@soft_error",
  	    expire => time()+10,
  	}) for (@{$todo->{ids}});
      # is the OCSP response status success
      } elsif (
  	( my $status = Net::SSLeay::OCSP_response_status($resp))
  	    != Net::SSLeay::OCSP_RESPONSE_STATUS_SUCCESSFUL()
      ){
  	@soft_error = "OCSP response failed: ".
  	    Net::SSLeay::OCSP_response_status_str($status).
  	    "; subject: ".join("; ",@{$todo->{subj}});
  	# hopefully short-time error
  	$self->{cache}->put($_,{
  	    soft_error => "@soft_error",
  	    expire => time()+10,
  	}) for (@{$todo->{ids}});
  
      # does nonce match the request and can the signature be verified
      } elsif ( ! eval {
  	$req = Net::SSLeay::d2i_OCSP_REQUEST($todo->{req});
  	Net::SSLeay::OCSP_response_verify($self->{ssl},$resp,$req);
      }) {
  	if ($@) {
  	    @soft_error = $@
  	} else {
  	    my @err;
  	    while ( my $err = Net::SSLeay::ERR_get_error()) {
  		push @soft_error, Net::SSLeay::ERR_error_string($err);
  	    }
  	    @soft_error = 'failed to verify OCSP response; subject: '.
  		join("; ",@{$todo->{subj}}) if ! @soft_error;
  	}
  	# configuration problem or we don't know the signer
  	$self->{cache}->put($_,{
  	    soft_error => "@soft_error",
  	    expire => time()+120,
  	}) for (@{$todo->{ids}});
  
      # extract results from response
      } elsif ( my @result =
  	Net::SSLeay::OCSP_response_results($resp,@{$todo->{ids}})) {
  	my (@found,@miss);
  	for my $rv (@result) {
  	    if ($rv->[2]) {
  		push @found,$rv->[0];
  		if (!$rv->[1]) {
  		    # no error
  		    $self->{cache}->put($rv->[0],$rv->[2]);
  		} elsif ( $rv->[2]{statusType} ==
  		    Net::SSLeay::V_OCSP_CERTSTATUS_GOOD()) {
  		    # soft error, like response after nextUpdate
  		    push @soft_error,$rv->[1]."; subject: ".
  			join("; ",@{$todo->{subj}});
  		    $self->{cache}->put($rv->[0],{
  			%{$rv->[2]},
  			soft_error => "@soft_error",
  			expire => time()+120,
  		    });
  		} else {
  		    # hard error
  		    $self->{cache}->put($rv->[0],$rv->[2]);
  		    push @hard_error, $rv->[1]."; subject: ".
  			join("; ",@{$todo->{subj}});
  		}
  	    } else {
  		push @miss,$rv->[0];
  	    }
  	}
  	if (@miss && @found) {
  	    # we sent multiple responses, but server answered only to one
  	    # try again
  	    $self->{todo}{$uri} = $todo;
  	    $todo->{ids} = \@miss;
  	    $todo->{req} = Net::SSLeay::i2d_OCSP_REQUEST(
  		Net::SSLeay::OCSP_ids2req(@miss));
  	    $DEBUG>=2 && DEBUG("$uri just answered ".@found." of ".(@found+@miss)." requests");
  	}
      } else {
  	@soft_error = "no data in response; subject: ".
  	    join("; ",@{$todo->{subj}});
  	# probably configuration problem
  	$self->{cache}->put($_,{
  	    soft_error => "@soft_error",
  	    expire => time()+120,
  	}) for (@{$todo->{ids}});
      }
  
      Net::SSLeay::OCSP_REQUEST_free($req) if $req;
      if ($self->{failhard}) {
  	push @hard_error,@soft_error;
  	@soft_error = ();
      }
      if (@soft_error) {
  	$self->{soft_error} .= "; " if $self->{soft_error};
  	$self->{soft_error} .= "$uri: ".join('; ',@soft_error);
      }
      if (@hard_error) {
  	$self->{hard_error} = "$uri: ".join('; ',@hard_error);
  	%{$self->{todo}} = ();
      } elsif ( ! %{$self->{todo}} ) {
  	$self->{hard_error} = ''
      }
      return $self->{hard_error};
  }
  
  # make all necessary requests to get OCSP responses blocking
  sub resolve_blocking {
      my ($self,%args) = @_;
      while ( my %todo = $self->requests ) {
  	eval { require HTTP::Tiny } or die "need HTTP::Tiny installed";
  	# OCSP responses have their own signature, so we don't need SSL verification
  	my $ua = HTTP::Tiny->new(verify_SSL => 0,%args);
  	while (my ($uri,$reqdata) = each %todo) {
  	    $DEBUG && DEBUG("sending OCSP request to $uri");
  	    my $resp = $ua->request('POST',$uri, {
  		headers => { 'Content-type' => 'application/ocsp-request' },
  		content => $reqdata
  	    });
  	    $DEBUG && DEBUG("got  OCSP response from $uri code=$resp->{status}");
  	    defined ($self->add_response($uri,
  		$resp->{success} && $resp->{content}))
  		&& last;
  	}
      }
      $DEBUG>=2 && DEBUG("no more open OCSP requests");
      return $self->{hard_error};
  }
  
  1;
  
  __END__
IO_SOCKET_SSL

$fatpacked{"IO/Socket/SSL/Intercept.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_SOCKET_SSL_INTERCEPT';
  
  package IO::Socket::SSL::Intercept;
  use strict;
  use warnings;
  use Carp 'croak';
  use IO::Socket::SSL::Utils;
  use Net::SSLeay;
  
  our $VERSION = '2.056';
  
  
  sub new {
      my ($class,%args) = @_;
  
      my $cacert = delete $args{proxy_cert};
      if ( ! $cacert ) {
  	if ( my $f = delete $args{proxy_cert_file} ) {
  	    $cacert = PEM_file2cert($f);
  	} else {
  	    croak "no proxy_cert or proxy_cert_file given";
  	}
      }
  
      my $cakey  = delete $args{proxy_key};
      if ( ! $cakey ) {
  	if ( my $f = delete $args{proxy_key_file} ) {
  	    $cakey = PEM_file2key($f);
  	} else {
  	    croak "no proxy_cert or proxy_cert_file given";
  	}
      }
  
      my $certkey = delete $args{cert_key};
      if ( ! $certkey ) {
  	if ( my $f = delete $args{cert_key_file} ) {
  	    $certkey = PEM_file2key($f);
  	}
      }
  
      my $cache = delete $args{cache} || {};
      if (ref($cache) eq 'CODE') {
  	# check cache type
  	my $type = $cache->('type');
  	if (!$type) {
  	    # old cache interface - change into new interface
  	    # get: $cache->(fp)
  	    # set: $cache->(fp,cert,key)
  	    my $oc = $cache;
  	    $cache = sub {
  		my ($fp,$create_cb) = @_;
  		my @ck = $oc->($fp);
  		$oc->($fp, @ck = &$create_cb) if !@ck;
  		return @ck;
  	    };
  	} elsif ($type == 1) {
  	    # current interface:
  	    # get/set: $cache->(fp,cb_create)
  	} else {
  	    die "invalid type of cache: $type";
  	}
      }
  
      my $self = bless {
  	cacert => $cacert,
  	cakey => $cakey,
  	certkey => $certkey,
  	cache => $cache,
  	serial => delete $args{serial},
      };
      return $self;
  }
  
  sub DESTROY {
      # call various ssl _free routines
      my $self = shift or return;
      for ( \$self->{cacert}, 
  	map { \$_->{cert} } ref($self->{cache}) ne 'CODE' ? values %{$self->{cache}} :()) {
  	$$_ or next;
  	CERT_free($$_);
  	$$_ = undef;
      }
      for ( \$self->{cakey}, \$self->{pubkey} ) {
  	$$_ or next;
  	KEY_free($$_);
  	$$_ = undef;
      }
  }
  
  sub clone_cert {
      my ($self,$old_cert,$clone_key) = @_;
  
      my $hash = CERT_asHash($old_cert);
      my $create_cb = sub {
  	# if not in cache create new certificate based on original
  	# copy most but not all extensions
  	if (my $ext = $hash->{ext}) {
  	    @$ext = grep {
  		defined($_->{sn}) && $_->{sn} !~m{^(?:
  		    authorityInfoAccess    |
  		    subjectKeyIdentifier   |
  		    authorityKeyIdentifier |
  		    certificatePolicies    |
  		    crlDistributionPoints
  		)$}x
  	    } @$ext;
  	}
  	my ($clone,$key) = CERT_create(
  	    %$hash,
  	    issuer_cert => $self->{cacert},
  	    issuer_key => $self->{cakey},
  	    key => $self->{certkey},
  	    serial => defined($self->{serial}) ? ++$self->{serial} : 
  		(unpack('L',$hash->{x509_digest_sha256}))[0],
  	);
  	return ($clone,$key);
      };
  
      $clone_key ||= substr(unpack("H*", $hash->{x509_digest_sha256}),0,32);
      my $c = $self->{cache};
      return $c->($clone_key,$create_cb) if ref($c) eq 'CODE';
  
      my $e = $c->{$clone_key} ||= do {
  	my ($cert,$key) = &$create_cb;
  	{ cert => $cert, key => $key };
      };
      $e->{atime} = time();
      return ($e->{cert},$e->{key});
  }
  
  
  sub STORABLE_freeze { my $self = shift; $self->serialize() }
  sub STORABLE_thaw   { my ($class,undef,$data) = @_; $class->unserialize($data) }
  
  sub serialize {
      my $self = shift;
      my $data = pack("N",2); # version
      $data .= pack("N/a", PEM_cert2string($self->{cacert}));
      $data .= pack("N/a", PEM_key2string($self->{cakey}));
      if ( $self->{certkey} ) {
  	$data .= pack("N/a", PEM_key2string($self->{certkey}));
      } else {
  	$data .= pack("N/a", '');
      }
      $data .= pack("N",$self->{serial});
      if ( ref($self->{cache}) eq 'HASH' ) {
  	while ( my($k,$v) = each %{ $self->{cache}} ) {
  	    $data .= pack("N/aN/aN/aN", $k,
  		PEM_cert2string($k->{cert}),
  		$k->{key} ? PEM_key2string($k->{key}) : '',
  		$k->{atime});
  	}
      }
      return $data;
  }
  
  sub unserialize {
      my ($class,$data) = @_;
      unpack("N",substr($data,0,4,'')) == 2 or 
  	croak("serialized with wrong version");
      ( my $cacert,my $cakey,my $certkey,my $serial,$data) 
  	= unpack("N/aN/aN/aNa*",$data);
      my $self = bless {
  	serial => $serial,
  	cacert => PEM_string2cert($cacert),
  	cakey => PEM_string2key($cakey),
  	$certkey ? ( certkey => PEM_string2key($certkey)):(),
      }, ref($class)||$class;
  
      $self->{cache} = {} if $data ne '';
      while ( $data ne '' ) {
  	(my $key,my $cert,my $certkey, my $atime,$data) = unpack("N/aN/aNa*",$data);
  	$self->{cache}{$key} = { 
  	    cert => PEM_string2cert($cert), 
  	    $key ? ( key => PEM_string2key($certkey)):(),
  	    atime => $atime 
  	};
      }
      return $self;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Socket::SSL::Intercept -- SSL interception (man in the middle)
  
  =head1 SYNOPSIS
  
      use IO::Socket::SSL::Intercept;
      # create interceptor with proxy certificates
      my $mitm = IO::Socket::SSL::Intercept->new(
  	proxy_cert_file => 'proxy_cert.pem',
  	proxy_key_file  => 'proxy_key.pem',
  	...
      );
      my $listen = IO::Socket::INET->new( LocalAddr => .., Listen => .. );
      while (1) {
  	# TCP accept new client
  	my $client = $listen->accept or next;
  	# SSL connect to server
  	my $server = IO::Socket::SSL->new(
  	    PeerAddr => ..,
  	    SSL_verify_mode => ...,
  	    ...
  	) or die "ssl connect failed: $!,$SSL_ERROR";
  	# clone server certificate
  	my ($cert,$key) = $mitm->clone_cert( $server->peer_certificate );
  	# and upgrade client side to SSL with cloned certificate
  	IO::Socket::SSL->start_SSL($client,
  	    SSL_server => 1,
  	    SSL_cert => $cert,
  	    SSL_key => $key
  	) or die "upgrade failed: $SSL_ERROR";
  	# now transfer data between $client and $server and analyze
  	# the unencrypted data
  	...
      }
  
  
  =head1 DESCRIPTION
  
  This module provides functionality to clone certificates and sign them with a
  proxy certificate, thus making it easy to intercept SSL connections (man in the
  middle). It also manages a cache of the generated certificates.
  
  =head1 How Intercepting SSL Works
  
  Intercepting SSL connections is useful for analyzing encrypted traffic for
  security reasons or for testing. It does not break the end-to-end security of
  SSL, e.g. a properly written client will notice the interception unless you
  explicitly configure the client to trust your interceptor.
  Intercepting SSL works the following way:
  
  =over 4
  
  =item *
  
  Create a new CA certificate, which will be used to sign the cloned certificates.
  This proxy CA certificate should be trusted by the client, or (a properly
  written client) will throw error messages or deny the connections because it
  detected a man in the middle attack.
  Due to the way the interception works there no support for client side
  certificates is possible.
  
  Using openssl such a proxy CA certificate and private key can be created with:
  
    openssl genrsa -out proxy_key.pem 1024
    openssl req -new -x509 -extensions v3_ca -key proxy_key.pem -out proxy_cert.pem
    # export as PKCS12 for import into browser
    openssl pkcs12 -export -in proxy_cert.pem -inkey proxy_key.pem -out proxy_cert.p12
  
  =item * 
  
  Configure client to connect to use intercepting proxy or somehow redirect
  connections from client to the proxy (e.g. packet filter redirects, ARP or DNS
  spoofing etc).
  
  =item *
  
  Accept the TCP connection from the client, e.g. don't do any SSL handshakes with
  the client yet.
  
  =item *
  
  Establish the SSL connection to the server and verify the servers certificate as
  usually. Then create a new certificate based on the original servers
  certificate, but signed by your proxy CA.
  This is the step where IO::Socket::SSL::Intercept helps.
  
  =item *
  
  Upgrade the TCP connection to the client to SSL using the cloned certificate
  from the server. If the client trusts your proxy CA it will accept the upgrade
  to SSL.
  
  =item *
  
  Transfer data between client and server. While the connections to client and
  server are both encrypted with SSL you will read/write the unencrypted data in
  your proxy application.
  
  =back
  
  =head1 METHODS 
  
  IO::Socket::SSL::Intercept helps creating the cloned certificate with the
  following methods:
  
  =over 4
  
  =item B<< $mitm = IO::Socket::SSL::Intercept->new(%args) >>
  
  This creates a new interceptor object. C<%args> should be
  
  =over 8
  
  =item proxy_cert X509 | proxy_cert_file filename
  
  This is the proxy certificate.
  It can be either given by an X509 object from L<Net::SSLeay>s internal
  representation, or using a file in PEM format.
  
  =item proxy_key EVP_PKEY | proxy_key_file filename
  
  This is the key for the proxy certificate.
  It can be either given by an EVP_PKEY object from L<Net::SSLeay>s internal
  representation, or using a file in PEM format.
  The key should not have a passphrase.
  
  =item pubkey EVP_PKEY | pubkey_file filename
  
  This optional argument specifies the public key used for the cloned certificate.
  It can be either given by an EVP_PKEY object from L<Net::SSLeay>s internal
  representation, or using a file in PEM format.
  If not given it will create a new public key on each call of C<new>.
  
  =item serial INTEGER
  
  This optional argument gives the starting point for the serial numbers of the
  newly created certificates. If not set the serial number will be created based
  on the digest of the original certificate.
  
  =item cache HASH | SUBROUTINE
  
  This optional argument gives a way to cache created certificates, so that they
  don't get recreated on future accesses to the same host.
  If the argument ist not given an internal HASH ist used.
  
  If the argument is a hash it will store for each generated certificate a hash
  reference with C<cert> and C<atime> in the hash, where C<atime> is the time of
  last access (to expire unused entries) and C<cert> is the certificate. Please
  note, that the certificate is in L<Net::SSLeay>s internal X509 format and can
  thus not be simply dumped and restored.
  The key for the hash is an C<ident> either given to C<clone_cert> or generated
  from the original certificate.
  
  If the argument is a subroutine it will be called as C<< $cache->(ident,sub) >>.
  This call should return either an existing (cached) C<< (cert,key) >> or
  call C<sub> without arguments to create a new C<< (cert,key) >>, store it
  and return it.
  If called with C<< $cache->('type') >> the function should just return 1 to
  signal that it supports the current type of cache. If it reutrns nothing
  instead the older cache interface is assumed for compatibility reasons.
  
  =back
  
  =item B<< ($clone_cert,$key) = $mitm->clone_cert($original_cert,[ $ident ]) >>
  
  This clones the given certificate.
  An ident as the key into the cache can be given (like C<host:port>), if not it
  will be created from the properties of the original certificate.
  It returns the cloned certificate and its key (which is the same for alle
  created certificates).
  
  =item B<< $string = $mitm->serialize >>
  
  This creates a serialized version of the object (e.g. a string) which can then
  be used to persistantly store created certificates over restarts of the
  application. The cache will only be serialized if it is a HASH.
  To work together with L<Storable> the C<STORABLE_freeze> function is defined to
  call C<serialize>.
  
  =item B<< $mitm = IO::Socket::SSL::Intercept->unserialize($string) >>
  
  This restores an Intercept object from a serialized string.
  To work together with L<Storable> the C<STORABLE_thaw> function is defined to
  call C<unserialize>.
  
  =back
  
  =head1 AUTHOR
  
  Steffen Ullrich
IO_SOCKET_SSL_INTERCEPT

$fatpacked{"IO/Socket/SSL/PublicSuffix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_SOCKET_SSL_PUBLICSUFFIX';
  
  use strict;
  use warnings;
  package IO::Socket::SSL::PublicSuffix;
  use Carp;
  
  # for updates
  use constant URL => 'http://publicsuffix.org/list/effective_tld_names.dat';
  
  =head1 NAME
  
  IO::Socket::SSL::PublicSuffix - provide access to Mozilla's list of effective TLD names
  
  =head1 SYNOPSIS
  
      # use builtin default
      use IO::Socket::SSL::PublicSuffix;
      $ps = IO::Socket::SSL::PublicSuffix->default;
  
      # load from string
      $ps = IO::Socket::SSL::PublicSuffix->from_string("*.uk\n*");
  
      # load from file or file handle
      $ps = IO::Socket::SSL::PublicSuffix->from_file($filename);
      $ps = IO::Socket::SSL::PublicSuffix->from_file(\*STDIN);
  
  
      # --- string in -> string out
      # $rest -> whatever.host
      # $tld  -> co.uk
      my ($rest,$tld) = $ps->public_suffix('whatever.host.co.uk');
      my $tld = $ps->public_suffix('whatever.host.co.uk');
  
      # $root_domain -> host.co.uk
      my $root_domain = $ps->public_suffix('whatever.host.co.uk', 1);
  
      # --- array in -> array out
      # $rest -> [qw(whatever host)]
      # $tld  -> [qw(co uk)]
      my ($rest,$tld) = $ps->public_suffix([qw(whatever host co uk)]);
  
   ----
  
      # To update this file with the current list:
      perl -MIO::Socket::SSL::PublicSuffix -e 'IO::Socket::SSL::PublicSuffix::update_self_from_url()'
  
  
  
  =head1 DESCRIPTION
  
  This module uses the list of effective top level domain names from the mozilla
  project to determine the public top level domain for a given hostname.
  
  =head2 Method
  
  =over 4
  
  =item class->default(%args)
  
  Returns object with builtin default.
  C<min_suffix> can be given in C<%args> to specify the minimal suffix, default
  is 1.
  
  =item class->from_string(string,%args)
  
  Returns object with configuration from string.
  See method C<default> for C<%args>.
  
  =item class->from_file( file name| file handle, %args )
  
  Returns object with configuration from file or file handle.
  See method C<default> for C<%args>.
  
  =item $self->public_suffix( $host|\@host, [ $add ] )
  
  In array context the function returns the non-tld part and the tld part of the
  given hostname, in scalar context only the tld part.
  It adds C<$add> parts of the non-tld part to the tld, e.g. with C<$add=1> it
  will return the root domain.
  
  If there were no explicit matches against the public suffix configuration it
  will fall back to a suffix of length 1.
  
  The function accepts a string or an array-ref (e.g. host split by C<.>). In the
  first case it will return string(s), in the latter case array-ref(s).
  
  International hostnames or labels can be in ASCII (IDNA form starting with
  C<xn-->) or unicode. In the latter case an IDNA handling library like
  L<Net::IDN:::Encode>, L<Net::LibIDN> or recent versions of L<URI> need to be
  installed.
  
  =item ($self|class)->can_idn
  
  Returns true if IDN support is available.
  
  =back
  
  =head1 FILES
  
  http://publicsuffix.org/list/effective_tld_names.dat
  
  =head1 SEE ALSO
  
  Domain::PublicSuffix, Mozilla::PublicSuffix
  
  =head1 BUGS
  
   Q: Why yet another module, we already have L<Domain::PublicSuffix> and
      L<Mozilla::PublicSuffix>.
   A: Because the public suffix data change more often than these modules do,
      IO::Socket::SSL needs this list and it is more easy this way to keep it
      up-to-date.
  
  
  =head1 AUTHOR
  
  Steffen Ullrich
  
  =cut
  
  
  BEGIN {
      if ( eval {
  	require URI::_idna;
  	defined &URI::_idna::encode && defined &URI::_idna::decode
      }) {
  	*idn_to_ascii   = \&URI::_idna::encode;
  	*idn_to_unicode = \&URI::_idna::decode;
  	*can_idn = sub { 1 };
      } elsif ( eval { require Net::IDN::Encode } ) {
  	*idn_to_ascii   = \&Net::IDN::Encode::domain_to_ascii;
  	*idn_to_unicode = \&Net::IDN::Encode::domain_to_unicode;
  	*can_idn = sub { 1 };
      } elsif ( eval { require Net::LibIDN; require Encode } ) {
  	# Net::LibIDN does not use utf-8 flag and expects raw data
  	*idn_to_ascii   = sub { 
  	    Net::LibIDN::idn_to_ascii(Encode::encode('utf-8',$_[0]),'utf-8');
  	},
  	*idn_to_unicode = sub { 
  	    Encode::decode('utf-8',Net::LibIDN::idn_to_unicode($_[0],'utf-8'));
  	},
  	*can_idn = sub { 1 };
      } else {
  	*idn_to_ascii   = sub { croak "idn_to_ascii(@_) - no IDNA library installed" };
  	*idn_to_unicode = sub { croak "idn_to_unicode(@_) - no IDNA library installed" };
  	*can_idn = sub { 0 };
      }
  }
  
  {
      my %default;
      sub default {
  	my (undef,%args) = @_;
  	my $min_suffix = delete $args{min_suffix};
  	$min_suffix = 1 if ! defined $min_suffix;
  	%args and die "unknown args: ".join(" ",sort keys %args);
  	return $default{$min_suffix} ||= shift->from_string(_default_data(),
  	    min_suffix => $min_suffix);
      }
  }
  
  sub from_string {
      my $class = shift;
      my $data  = shift;
      open( my $fh,'<', \$data );
      return $class->from_file($fh,@_);
  }
  
  sub from_file {
      my ($class,$file,%args) = @_;
      my $min_suffix = delete $args{min_suffix};
      $min_suffix = 1 if ! defined $min_suffix;
      %args and die "unknown args: ".join(" ",sort keys %args);
  
      my $fh;
      if ( ref($file)) {
  	$fh = $file
      } elsif ( ! open($fh,'<',$file)) {
  	die "failed to open $file: $!";
      }
      my %tree;
      local $/ = "\n";
      while ( my $line = <$fh>) {
  	$line =~s{//.*}{};
  	$line =~s{\s+$}{};
  	$line eq '' and next;
  	my $p = \%tree;
  	$line = idn_to_ascii($line) if $line !~m{\A[\x00-\x7f]*\Z};
  	my $not = $line =~s{^!}{};
  	my @path = split(m{\.},$line);
  	for(reverse @path) {
  	    $p = $p->{$_} ||= {}
  	}
  	$p->{'\0'} = $not ? -1:1;
      }
      return bless { 
  	tree => \%tree, 
  	min_suffix => $min_suffix 
      },$class;
  }
  
  
  sub public_suffix {
      my ($self,$name,$add) = @_;
      my $want; # [a]rray, [s]tring, [u]nicode-string
      if ( ref($name)) {
  	$want = 'a';
  	$name = [ @$name ]; # don't change input
      } else {
  	return if ! defined $name;
  	if ( $name !~m{\A[\x00-\x7f]*\Z} ) {
  	    $name = idn_to_ascii($name);
  	    $want = 'u';
  	} else {
  	    $want = 's';
  	}
  	$name = lc($name);
  	$name =~s{\.$}{};
  	$name = [ $name =~m{([^.]+)}g ];
      }
      @$name or return;
      $_ = lc($_) for(@$name);
  
      my (%wild,%host,%xcept,@stack,$choices);
      my $p = $self->{tree};
      for( my $i=0; $i<@$name; $i++ ) {
  	$choices = [];
  	if ( my $px = $p->{ $name->[$#$name-$i] } ) {
  	    # name match, continue with next path element
  	    push @$choices,$px;
  	    if ( my $end = $px->{'\0'} ) {
  		( $end>0 ? \%host : \%xcept )->{$i+1} = $end;
  	    }
  	}
  	if ( my $px = $p->{'*'} ) {
  	    # wildcard match, continue with next path element
  	    push @$choices,$px;
  	    if ( my $end = $px->{'\0'} ) {
  		( $end>0 ? \%wild : \%xcept )->{$i+1} = $end;
  	    }
  	}
  
  
  	next_choice:
  	if ( @$choices ) {
  	    $p = shift(@$choices);
  	    push @stack, [ $choices, $i ] if @$choices;
  	    next; # go deeper
  	}
  
  	# backtrack
  	@stack or last;
  	($choices,$i) = @{ pop(@stack) };
  	goto next_choice;
      }
  
      #warn Dumper([\%wild,\%host,\%xcept]); use Data::Dumper;
  
  
      # remove all exceptions from wildcards
      delete @wild{ keys %xcept } if %xcept;
      # get longest match
      my ($len) = sort { $b <=> $a } (
  	keys(%wild), keys(%host), map { $_-1 } keys(%xcept));
      # if we have no matches use a minimum of min_suffix
      $len = $self->{min_suffix} if ! defined $len;
      $len += $add if $add;
      my $suffix;
      if ( $len < @$name ) {
  	$suffix = [ splice( @$name, -$len, $len ) ];
      } elsif ( $len > 0 ) {
  	$suffix = $name;
  	$name = []
      } else {
  	$suffix = []
      }
  
      if ( $want ne 'a' ) {
  	$suffix = join('.',@$suffix);
  	$name = join('.',@$name);
  	if ( $want eq 'u' ) {
  	    $suffix = idn_to_unicode($suffix);
  	    $name   = idn_to_unicode($name);
  	}
      }
  
      return wantarray ? ($name,$suffix):$suffix;
  }
  
  
  {
      my $data;
      sub _default_data {
  	if ( ! defined $data ) {
  	    $data = _builtin_data();
  	    $data =~s{^// ===END ICANN DOMAINS.*}{}ms
  		or die "cannot find END ICANN DOMAINS";
  	}
  	return $data;
      }
  }
  
  sub update_self_from_url {
      my $url = shift || URL();
      my $dst = __FILE__;
      -w $dst or die "cannot write $dst";
      open( my $fh,'<',$dst ) or die "open $dst: $!";
      my $code = '';
      local $/ = "\n";
      while (<$fh>) {
  	$code .= $_;
  	m{<<\'END_BUILTIN_DATA\'} and last;
      }
      my $tail;
      while (<$fh>) {
  	m{\AEND_BUILTIN_DATA\r?\n} or next;
  	$tail = $_;
  	last;
      }
      $tail .= do { local $/; <$fh> };
      close($fh);
  
      require LWP::UserAgent;
      my $resp = LWP::UserAgent->new->get($url)
  	or die "no response from $url";
      die "no success url=$url code=".$resp->code." ".$resp->message 
  	if ! $resp->is_success;
      my $content = $resp->decoded_content;
      while ( $content =~m{(.*\n)}g ) {
  	my $line = $1;
  	if ( $line =~m{\S} && $line !~m{\A\s*//} ) {
  	    $line =~s{//.*}{};
  	    $line =~s{\s+$}{};
  	    $line eq '' and next;
  	    if ( $line !~m{\A[\x00-\x7f]+\Z} ) {
  		$line = idn_to_ascii($line);
  	    }
  	    $code .= "$line\n";
  	} else {
  	    $code .= "$line";
  	}
      }
  
      open( $fh,'>:utf8',$dst ) or die "open $dst: $!";
      print $fh $code.$tail;
  }
  
  sub _builtin_data { return <<'END_BUILTIN_DATA' }
  // This Source Code Form is subject to the terms of the Mozilla Public
  // License, v. 2.0. If a copy of the MPL was not distributed with this
  // file, You can obtain one at https://mozilla.org/MPL/2.0/.
  
  // Please pull this list from, and only from https://publicsuffix.org/list/public_suffix_list.dat,
  // rather than any other VCS sites. Pulling from any other URL is not guaranteed to be supported.
  
  // Instructions on pulling and using this list can be found at https://publicsuffix.org/list/.
  
  // ===BEGIN ICANN DOMAINS===
  
  // ac : https://en.wikipedia.org/wiki/.ac
  ac
  com.ac
  edu.ac
  gov.ac
  net.ac
  mil.ac
  org.ac
  
  // ad : https://en.wikipedia.org/wiki/.ad
  ad
  nom.ad
  
  // ae : https://en.wikipedia.org/wiki/.ae
  // see also: "Domain Name Eligibility Policy" at http://www.aeda.ae/eng/aepolicy.php
  ae
  co.ae
  net.ae
  org.ae
  sch.ae
  ac.ae
  gov.ae
  mil.ae
  
  // aero : see https://www.information.aero/index.php?id=66
  aero
  accident-investigation.aero
  accident-prevention.aero
  aerobatic.aero
  aeroclub.aero
  aerodrome.aero
  agents.aero
  aircraft.aero
  airline.aero
  airport.aero
  air-surveillance.aero
  airtraffic.aero
  air-traffic-control.aero
  ambulance.aero
  amusement.aero
  association.aero
  author.aero
  ballooning.aero
  broker.aero
  caa.aero
  cargo.aero
  catering.aero
  certification.aero
  championship.aero
  charter.aero
  civilaviation.aero
  club.aero
  conference.aero
  consultant.aero
  consulting.aero
  control.aero
  council.aero
  crew.aero
  design.aero
  dgca.aero
  educator.aero
  emergency.aero
  engine.aero
  engineer.aero
  entertainment.aero
  equipment.aero
  exchange.aero
  express.aero
  federation.aero
  flight.aero
  freight.aero
  fuel.aero
  gliding.aero
  government.aero
  groundhandling.aero
  group.aero
  hanggliding.aero
  homebuilt.aero
  insurance.aero
  journal.aero
  journalist.aero
  leasing.aero
  logistics.aero
  magazine.aero
  maintenance.aero
  media.aero
  microlight.aero
  modelling.aero
  navigation.aero
  parachuting.aero
  paragliding.aero
  passenger-association.aero
  pilot.aero
  press.aero
  production.aero
  recreation.aero
  repbody.aero
  res.aero
  research.aero
  rotorcraft.aero
  safety.aero
  scientist.aero
  services.aero
  show.aero
  skydiving.aero
  software.aero
  student.aero
  trader.aero
  trading.aero
  trainer.aero
  union.aero
  workinggroup.aero
  works.aero
  
  // af : http://www.nic.af/help.jsp
  af
  gov.af
  com.af
  org.af
  net.af
  edu.af
  
  // ag : http://www.nic.ag/prices.htm
  ag
  com.ag
  org.ag
  net.ag
  co.ag
  nom.ag
  
  // ai : http://nic.com.ai/
  ai
  off.ai
  com.ai
  net.ai
  org.ai
  
  // al : http://www.ert.gov.al/ert_alb/faq_det.html?Id=31
  al
  com.al
  edu.al
  gov.al
  mil.al
  net.al
  org.al
  
  // am : https://en.wikipedia.org/wiki/.am
  am
  
  // ao : https://en.wikipedia.org/wiki/.ao
  // http://www.dns.ao/REGISTR.DOC
  ao
  ed.ao
  gv.ao
  og.ao
  co.ao
  pb.ao
  it.ao
  
  // aq : https://en.wikipedia.org/wiki/.aq
  aq
  
  // ar : https://nic.ar/nic-argentina/normativa-vigente
  ar
  com.ar
  edu.ar
  gob.ar
  gov.ar
  int.ar
  mil.ar
  musica.ar
  net.ar
  org.ar
  tur.ar
  
  // arpa : https://en.wikipedia.org/wiki/.arpa
  // Confirmed by registry <iana-questions@icann.org> 2008-06-18
  arpa
  e164.arpa
  in-addr.arpa
  ip6.arpa
  iris.arpa
  uri.arpa
  urn.arpa
  
  // as : https://en.wikipedia.org/wiki/.as
  as
  gov.as
  
  // asia : https://en.wikipedia.org/wiki/.asia
  asia
  
  // at : https://en.wikipedia.org/wiki/.at
  // Confirmed by registry <it@nic.at> 2008-06-17
  at
  ac.at
  co.at
  gv.at
  or.at
  
  // au : https://en.wikipedia.org/wiki/.au
  // http://www.auda.org.au/
  au
  // 2LDs
  com.au
  net.au
  org.au
  edu.au
  gov.au
  asn.au
  id.au
  // Historic 2LDs (closed to new registration, but sites still exist)
  info.au
  conf.au
  oz.au
  // CGDNs - http://www.cgdn.org.au/
  act.au
  nsw.au
  nt.au
  qld.au
  sa.au
  tas.au
  vic.au
  wa.au
  // 3LDs
  act.edu.au
  nsw.edu.au
  nt.edu.au
  qld.edu.au
  sa.edu.au
  tas.edu.au
  vic.edu.au
  wa.edu.au
  // act.gov.au  Bug 984824 - Removed at request of Greg Tankard
  // nsw.gov.au  Bug 547985 - Removed at request of <Shae.Donelan@services.nsw.gov.au>
  // nt.gov.au  Bug 940478 - Removed at request of Greg Connors <Greg.Connors@nt.gov.au>
  qld.gov.au
  sa.gov.au
  tas.gov.au
  vic.gov.au
  wa.gov.au
  
  // aw : https://en.wikipedia.org/wiki/.aw
  aw
  com.aw
  
  // ax : https://en.wikipedia.org/wiki/.ax
  ax
  
  // az : https://en.wikipedia.org/wiki/.az
  az
  com.az
  net.az
  int.az
  gov.az
  org.az
  edu.az
  info.az
  pp.az
  mil.az
  name.az
  pro.az
  biz.az
  
  // ba : http://nic.ba/users_data/files/pravilnik_o_registraciji.pdf
  ba
  com.ba
  edu.ba
  gov.ba
  mil.ba
  net.ba
  org.ba
  
  // bb : https://en.wikipedia.org/wiki/.bb
  bb
  biz.bb
  co.bb
  com.bb
  edu.bb
  gov.bb
  info.bb
  net.bb
  org.bb
  store.bb
  tv.bb
  
  // bd : https://en.wikipedia.org/wiki/.bd
  *.bd
  
  // be : https://en.wikipedia.org/wiki/.be
  // Confirmed by registry <tech@dns.be> 2008-06-08
  be
  ac.be
  
  // bf : https://en.wikipedia.org/wiki/.bf
  bf
  gov.bf
  
  // bg : https://en.wikipedia.org/wiki/.bg
  // https://www.register.bg/user/static/rules/en/index.html
  bg
  a.bg
  b.bg
  c.bg
  d.bg
  e.bg
  f.bg
  g.bg
  h.bg
  i.bg
  j.bg
  k.bg
  l.bg
  m.bg
  n.bg
  o.bg
  p.bg
  q.bg
  r.bg
  s.bg
  t.bg
  u.bg
  v.bg
  w.bg
  x.bg
  y.bg
  z.bg
  0.bg
  1.bg
  2.bg
  3.bg
  4.bg
  5.bg
  6.bg
  7.bg
  8.bg
  9.bg
  
  // bh : https://en.wikipedia.org/wiki/.bh
  bh
  com.bh
  edu.bh
  net.bh
  org.bh
  gov.bh
  
  // bi : https://en.wikipedia.org/wiki/.bi
  // http://whois.nic.bi/
  bi
  co.bi
  com.bi
  edu.bi
  or.bi
  org.bi
  
  // biz : https://en.wikipedia.org/wiki/.biz
  biz
  
  // bj : https://en.wikipedia.org/wiki/.bj
  bj
  asso.bj
  barreau.bj
  gouv.bj
  
  // bm : http://www.bermudanic.bm/dnr-text.txt
  bm
  com.bm
  edu.bm
  gov.bm
  net.bm
  org.bm
  
  // bn : https://en.wikipedia.org/wiki/.bn
  *.bn
  
  // bo : https://nic.bo/delegacion2015.php#h-1.10
  bo
  com.bo
  edu.bo
  gob.bo
  int.bo
  org.bo
  net.bo
  mil.bo
  tv.bo
  web.bo
  // Social Domains 
  academia.bo
  agro.bo
  arte.bo
  blog.bo
  bolivia.bo
  ciencia.bo
  cooperativa.bo
  democracia.bo
  deporte.bo
  ecologia.bo
  economia.bo
  empresa.bo
  indigena.bo
  industria.bo
  info.bo
  medicina.bo
  movimiento.bo
  musica.bo
  natural.bo
  nombre.bo
  noticias.bo
  patria.bo
  politica.bo
  profesional.bo
  plurinacional.bo
  pueblo.bo
  revista.bo
  salud.bo
  tecnologia.bo
  tksat.bo
  transporte.bo
  wiki.bo
  
  // br : http://registro.br/dominio/categoria.html
  // Submitted by registry <fneves@registro.br>
  br
  9guacu.br
  abc.br
  adm.br
  adv.br
  agr.br
  aju.br
  am.br
  anani.br
  aparecida.br
  arq.br
  art.br
  ato.br
  b.br
  belem.br
  bhz.br
  bio.br
  blog.br
  bmd.br
  boavista.br
  bsb.br
  campinagrande.br
  campinas.br
  caxias.br
  cim.br
  cng.br
  cnt.br
  com.br
  contagem.br
  coop.br
  cri.br
  cuiaba.br
  curitiba.br
  def.br
  ecn.br
  eco.br
  edu.br
  emp.br
  eng.br
  esp.br
  etc.br
  eti.br
  far.br
  feira.br
  flog.br
  floripa.br
  fm.br
  fnd.br
  fortal.br
  fot.br
  foz.br
  fst.br
  g12.br
  ggf.br
  goiania.br
  gov.br
  // gov.br 26 states + df https://en.wikipedia.org/wiki/States_of_Brazil
  ac.gov.br
  al.gov.br
  am.gov.br
  ap.gov.br
  ba.gov.br
  ce.gov.br
  df.gov.br
  es.gov.br
  go.gov.br
  ma.gov.br
  mg.gov.br
  ms.gov.br
  mt.gov.br
  pa.gov.br
  pb.gov.br
  pe.gov.br
  pi.gov.br
  pr.gov.br
  rj.gov.br
  rn.gov.br
  ro.gov.br
  rr.gov.br
  rs.gov.br
  sc.gov.br
  se.gov.br
  sp.gov.br
  to.gov.br
  gru.br
  imb.br
  ind.br
  inf.br
  jab.br
  jampa.br
  jdf.br
  joinville.br
  jor.br
  jus.br
  leg.br
  lel.br
  londrina.br
  macapa.br
  maceio.br
  manaus.br
  maringa.br
  mat.br
  med.br
  mil.br
  morena.br
  mp.br
  mus.br
  natal.br
  net.br
  niteroi.br
  *.nom.br
  not.br
  ntr.br
  odo.br
  org.br
  osasco.br
  palmas.br
  poa.br
  ppg.br
  pro.br
  psc.br
  psi.br
  pvh.br
  qsl.br
  radio.br
  rec.br
  recife.br
  ribeirao.br
  rio.br
  riobranco.br
  riopreto.br
  salvador.br
  sampa.br
  santamaria.br
  santoandre.br
  saobernardo.br
  saogonca.br
  sjc.br
  slg.br
  slz.br
  sorocaba.br
  srv.br
  taxi.br
  teo.br
  the.br
  tmp.br
  trd.br
  tur.br
  tv.br
  udi.br
  vet.br
  vix.br
  vlog.br
  wiki.br
  zlg.br
  
  // bs : http://www.nic.bs/rules.html
  bs
  com.bs
  net.bs
  org.bs
  edu.bs
  gov.bs
  
  // bt : https://en.wikipedia.org/wiki/.bt
  bt
  com.bt
  edu.bt
  gov.bt
  net.bt
  org.bt
  
  // bv : No registrations at this time.
  // Submitted by registry <jarle@uninett.no>
  bv
  
  // bw : https://en.wikipedia.org/wiki/.bw
  // http://www.gobin.info/domainname/bw.doc
  // list of other 2nd level tlds ?
  bw
  co.bw
  org.bw
  
  // by : https://en.wikipedia.org/wiki/.by
  // http://tld.by/rules_2006_en.html
  // list of other 2nd level tlds ?
  by
  gov.by
  mil.by
  // Official information does not indicate that com.by is a reserved
  // second-level domain, but it's being used as one (see www.google.com.by and
  // www.yahoo.com.by, for example), so we list it here for safety's sake.
  com.by
  
  // http://hoster.by/
  of.by
  
  // bz : https://en.wikipedia.org/wiki/.bz
  // http://www.belizenic.bz/
  bz
  com.bz
  net.bz
  org.bz
  edu.bz
  gov.bz
  
  // ca : https://en.wikipedia.org/wiki/.ca
  ca
  // ca geographical names
  ab.ca
  bc.ca
  mb.ca
  nb.ca
  nf.ca
  nl.ca
  ns.ca
  nt.ca
  nu.ca
  on.ca
  pe.ca
  qc.ca
  sk.ca
  yk.ca
  // gc.ca: https://en.wikipedia.org/wiki/.gc.ca
  // see also: http://registry.gc.ca/en/SubdomainFAQ
  gc.ca
  
  // cat : https://en.wikipedia.org/wiki/.cat
  cat
  
  // cc : https://en.wikipedia.org/wiki/.cc
  cc
  
  // cd : https://en.wikipedia.org/wiki/.cd
  // see also: https://www.nic.cd/domain/insertDomain_2.jsp?act=1
  cd
  gov.cd
  
  // cf : https://en.wikipedia.org/wiki/.cf
  cf
  
  // cg : https://en.wikipedia.org/wiki/.cg
  cg
  
  // ch : https://en.wikipedia.org/wiki/.ch
  ch
  
  // ci : https://en.wikipedia.org/wiki/.ci
  // http://www.nic.ci/index.php?page=charte
  ci
  org.ci
  or.ci
  com.ci
  co.ci
  edu.ci
  ed.ci
  ac.ci
  net.ci
  go.ci
  asso.ci
  xn--aroport-bya.ci
  int.ci
  presse.ci
  md.ci
  gouv.ci
  
  // ck : https://en.wikipedia.org/wiki/.ck
  *.ck
  !www.ck
  
  // cl : https://en.wikipedia.org/wiki/.cl
  cl
  gov.cl
  gob.cl
  co.cl
  mil.cl
  
  // cm : https://en.wikipedia.org/wiki/.cm plus bug 981927
  cm
  co.cm
  com.cm
  gov.cm
  net.cm
  
  // cn : https://en.wikipedia.org/wiki/.cn
  // Submitted by registry <tanyaling@cnnic.cn>
  cn
  ac.cn
  com.cn
  edu.cn
  gov.cn
  net.cn
  org.cn
  mil.cn
  xn--55qx5d.cn
  xn--io0a7i.cn
  xn--od0alg.cn
  // cn geographic names
  ah.cn
  bj.cn
  cq.cn
  fj.cn
  gd.cn
  gs.cn
  gz.cn
  gx.cn
  ha.cn
  hb.cn
  he.cn
  hi.cn
  hl.cn
  hn.cn
  jl.cn
  js.cn
  jx.cn
  ln.cn
  nm.cn
  nx.cn
  qh.cn
  sc.cn
  sd.cn
  sh.cn
  sn.cn
  sx.cn
  tj.cn
  xj.cn
  xz.cn
  yn.cn
  zj.cn
  hk.cn
  mo.cn
  tw.cn
  
  // co : https://en.wikipedia.org/wiki/.co
  // Submitted by registry <tecnico@uniandes.edu.co>
  co
  arts.co
  com.co
  edu.co
  firm.co
  gov.co
  info.co
  int.co
  mil.co
  net.co
  nom.co
  org.co
  rec.co
  web.co
  
  // com : https://en.wikipedia.org/wiki/.com
  com
  
  // coop : https://en.wikipedia.org/wiki/.coop
  coop
  
  // cr : http://www.nic.cr/niccr_publico/showRegistroDominiosScreen.do
  cr
  ac.cr
  co.cr
  ed.cr
  fi.cr
  go.cr
  or.cr
  sa.cr
  
  // cu : https://en.wikipedia.org/wiki/.cu
  cu
  com.cu
  edu.cu
  org.cu
  net.cu
  gov.cu
  inf.cu
  
  // cv : https://en.wikipedia.org/wiki/.cv
  cv
  
  // cw : http://www.una.cw/cw_registry/
  // Confirmed by registry <registry@una.net> 2013-03-26
  cw
  com.cw
  edu.cw
  net.cw
  org.cw
  
  // cx : https://en.wikipedia.org/wiki/.cx
  // list of other 2nd level tlds ?
  cx
  gov.cx
  
  // cy : http://www.nic.cy/
  // Submitted by registry Panayiotou Fotia <cydns@ucy.ac.cy>
  cy
  ac.cy
  biz.cy
  com.cy
  ekloges.cy
  gov.cy
  ltd.cy
  name.cy
  net.cy
  org.cy
  parliament.cy
  press.cy
  pro.cy
  tm.cy
  
  // cz : https://en.wikipedia.org/wiki/.cz
  cz
  
  // de : https://en.wikipedia.org/wiki/.de
  // Confirmed by registry <ops@denic.de> (with technical
  // reservations) 2008-07-01
  de
  
  // dj : https://en.wikipedia.org/wiki/.dj
  dj
  
  // dk : https://en.wikipedia.org/wiki/.dk
  // Confirmed by registry <robert@dk-hostmaster.dk> 2008-06-17
  dk
  
  // dm : https://en.wikipedia.org/wiki/.dm
  dm
  com.dm
  net.dm
  org.dm
  edu.dm
  gov.dm
  
  // do : https://en.wikipedia.org/wiki/.do
  do
  art.do
  com.do
  edu.do
  gob.do
  gov.do
  mil.do
  net.do
  org.do
  sld.do
  web.do
  
  // dz : https://en.wikipedia.org/wiki/.dz
  dz
  com.dz
  org.dz
  net.dz
  gov.dz
  edu.dz
  asso.dz
  pol.dz
  art.dz
  
  // ec : http://www.nic.ec/reg/paso1.asp
  // Submitted by registry <vabboud@nic.ec>
  ec
  com.ec
  info.ec
  net.ec
  fin.ec
  k12.ec
  med.ec
  pro.ec
  org.ec
  edu.ec
  gov.ec
  gob.ec
  mil.ec
  
  // edu : https://en.wikipedia.org/wiki/.edu
  edu
  
  // ee : http://www.eenet.ee/EENet/dom_reeglid.html#lisa_B
  ee
  edu.ee
  gov.ee
  riik.ee
  lib.ee
  med.ee
  com.ee
  pri.ee
  aip.ee
  org.ee
  fie.ee
  
  // eg : https://en.wikipedia.org/wiki/.eg
  eg
  com.eg
  edu.eg
  eun.eg
  gov.eg
  mil.eg
  name.eg
  net.eg
  org.eg
  sci.eg
  
  // er : https://en.wikipedia.org/wiki/.er
  *.er
  
  // es : https://www.nic.es/site_ingles/ingles/dominios/index.html
  es
  com.es
  nom.es
  org.es
  gob.es
  edu.es
  
  // et : https://en.wikipedia.org/wiki/.et
  et
  com.et
  gov.et
  org.et
  edu.et
  biz.et
  name.et
  info.et
  net.et
  
  // eu : https://en.wikipedia.org/wiki/.eu
  eu
  
  // fi : https://en.wikipedia.org/wiki/.fi
  fi
  // aland.fi : https://en.wikipedia.org/wiki/.ax
  // This domain is being phased out in favor of .ax. As there are still many
  // domains under aland.fi, we still keep it on the list until aland.fi is
  // completely removed.
  // TODO: Check for updates (expected to be phased out around Q1/2009)
  aland.fi
  
  // fj : https://en.wikipedia.org/wiki/.fj
  *.fj
  
  // fk : https://en.wikipedia.org/wiki/.fk
  *.fk
  
  // fm : https://en.wikipedia.org/wiki/.fm
  fm
  
  // fo : https://en.wikipedia.org/wiki/.fo
  fo
  
  // fr : http://www.afnic.fr/
  // domaines descriptifs : http://www.afnic.fr/obtenir/chartes/nommage-fr/annexe-descriptifs
  fr
  com.fr
  asso.fr
  nom.fr
  prd.fr
  presse.fr
  tm.fr
  // domaines sectoriels : http://www.afnic.fr/obtenir/chartes/nommage-fr/annexe-sectoriels
  aeroport.fr
  assedic.fr
  avocat.fr
  avoues.fr
  cci.fr
  chambagri.fr
  chirurgiens-dentistes.fr
  experts-comptables.fr
  geometre-expert.fr
  gouv.fr
  greta.fr
  huissier-justice.fr
  medecin.fr
  notaires.fr
  pharmacien.fr
  port.fr
  veterinaire.fr
  
  // ga : https://en.wikipedia.org/wiki/.ga
  ga
  
  // gb : This registry is effectively dormant
  // Submitted by registry <Damien.Shaw@ja.net>
  gb
  
  // gd : https://en.wikipedia.org/wiki/.gd
  gd
  
  // ge : http://www.nic.net.ge/policy_en.pdf
  ge
  com.ge
  edu.ge
  gov.ge
  org.ge
  mil.ge
  net.ge
  pvt.ge
  
  // gf : https://en.wikipedia.org/wiki/.gf
  gf
  
  // gg : http://www.channelisles.net/register-domains/
  // Confirmed by registry <nigel@channelisles.net> 2013-11-28
  gg
  co.gg
  net.gg
  org.gg
  
  // gh : https://en.wikipedia.org/wiki/.gh
  // see also: http://www.nic.gh/reg_now.php
  // Although domains directly at second level are not possible at the moment,
  // they have been possible for some time and may come back.
  gh
  com.gh
  edu.gh
  gov.gh
  org.gh
  mil.gh
  
  // gi : http://www.nic.gi/rules.html
  gi
  com.gi
  ltd.gi
  gov.gi
  mod.gi
  edu.gi
  org.gi
  
  // gl : https://en.wikipedia.org/wiki/.gl
  // http://nic.gl
  gl
  co.gl
  com.gl
  edu.gl
  net.gl
  org.gl
  
  // gm : http://www.nic.gm/htmlpages%5Cgm-policy.htm
  gm
  
  // gn : http://psg.com/dns/gn/gn.txt
  // Submitted by registry <randy@psg.com>
  gn
  ac.gn
  com.gn
  edu.gn
  gov.gn
  org.gn
  net.gn
  
  // gov : https://en.wikipedia.org/wiki/.gov
  gov
  
  // gp : http://www.nic.gp/index.php?lang=en
  gp
  com.gp
  net.gp
  mobi.gp
  edu.gp
  org.gp
  asso.gp
  
  // gq : https://en.wikipedia.org/wiki/.gq
  gq
  
  // gr : https://grweb.ics.forth.gr/english/1617-B-2005.html
  // Submitted by registry <segred@ics.forth.gr>
  gr
  com.gr
  edu.gr
  net.gr
  org.gr
  gov.gr
  
  // gs : https://en.wikipedia.org/wiki/.gs
  gs
  
  // gt : http://www.gt/politicas_de_registro.html
  gt
  com.gt
  edu.gt
  gob.gt
  ind.gt
  mil.gt
  net.gt
  org.gt
  
  // gu : http://gadao.gov.gu/registration.txt
  *.gu
  
  // gw : https://en.wikipedia.org/wiki/.gw
  gw
  
  // gy : https://en.wikipedia.org/wiki/.gy
  // http://registry.gy/
  gy
  co.gy
  com.gy
  edu.gy
  gov.gy
  net.gy
  org.gy
  
  // hk : https://www.hkdnr.hk
  // Submitted by registry <hk.tech@hkirc.hk>
  hk
  com.hk
  edu.hk
  gov.hk
  idv.hk
  net.hk
  org.hk
  xn--55qx5d.hk
  xn--wcvs22d.hk
  xn--lcvr32d.hk
  xn--mxtq1m.hk
  xn--gmqw5a.hk
  xn--ciqpn.hk
  xn--gmq050i.hk
  xn--zf0avx.hk
  xn--io0a7i.hk
  xn--mk0axi.hk
  xn--od0alg.hk
  xn--od0aq3b.hk
  xn--tn0ag.hk
  xn--uc0atv.hk
  xn--uc0ay4a.hk
  
  // hm : https://en.wikipedia.org/wiki/.hm
  hm
  
  // hn : http://www.nic.hn/politicas/ps02,,05.html
  hn
  com.hn
  edu.hn
  org.hn
  net.hn
  mil.hn
  gob.hn
  
  // hr : http://www.dns.hr/documents/pdf/HRTLD-regulations.pdf
  hr
  iz.hr
  from.hr
  name.hr
  com.hr
  
  // ht : http://www.nic.ht/info/charte.cfm
  ht
  com.ht
  shop.ht
  firm.ht
  info.ht
  adult.ht
  net.ht
  pro.ht
  org.ht
  med.ht
  art.ht
  coop.ht
  pol.ht
  asso.ht
  edu.ht
  rel.ht
  gouv.ht
  perso.ht
  
  // hu : http://www.domain.hu/domain/English/sld.html
  // Confirmed by registry <pasztor@iszt.hu> 2008-06-12
  hu
  co.hu
  info.hu
  org.hu
  priv.hu
  sport.hu
  tm.hu
  2000.hu
  agrar.hu
  bolt.hu
  casino.hu
  city.hu
  erotica.hu
  erotika.hu
  film.hu
  forum.hu
  games.hu
  hotel.hu
  ingatlan.hu
  jogasz.hu
  konyvelo.hu
  lakas.hu
  media.hu
  news.hu
  reklam.hu
  sex.hu
  shop.hu
  suli.hu
  szex.hu
  tozsde.hu
  utazas.hu
  video.hu
  
  // id : https://register.pandi.or.id/
  id
  ac.id
  biz.id
  co.id
  desa.id
  go.id
  mil.id
  my.id
  net.id
  or.id
  sch.id
  web.id
  
  // ie : https://en.wikipedia.org/wiki/.ie
  ie
  gov.ie
  
  // il : http://www.isoc.org.il/domains/
  il
  ac.il
  co.il
  gov.il
  idf.il
  k12.il
  muni.il
  net.il
  org.il
  
  // im : https://www.nic.im/
  // Submitted by registry <info@nic.im>
  im
  ac.im
  co.im
  com.im
  ltd.co.im
  net.im
  org.im
  plc.co.im
  tt.im
  tv.im
  
  // in : https://en.wikipedia.org/wiki/.in
  // see also: https://registry.in/Policies
  // Please note, that nic.in is not an official eTLD, but used by most
  // government institutions.
  in
  co.in
  firm.in
  net.in
  org.in
  gen.in
  ind.in
  nic.in
  ac.in
  edu.in
  res.in
  gov.in
  mil.in
  
  // info : https://en.wikipedia.org/wiki/.info
  info
  
  // int : https://en.wikipedia.org/wiki/.int
  // Confirmed by registry <iana-questions@icann.org> 2008-06-18
  int
  eu.int
  
  // io : http://www.nic.io/rules.html
  // list of other 2nd level tlds ?
  io
  com.io
  
  // iq : http://www.cmc.iq/english/iq/iqregister1.htm
  iq
  gov.iq
  edu.iq
  mil.iq
  com.iq
  org.iq
  net.iq
  
  // ir : http://www.nic.ir/Terms_and_Conditions_ir,_Appendix_1_Domain_Rules
  // Also see http://www.nic.ir/Internationalized_Domain_Names
  // Two <iran>.ir entries added at request of <tech-team@nic.ir>, 2010-04-16
  ir
  ac.ir
  co.ir
  gov.ir
  id.ir
  net.ir
  org.ir
  sch.ir
  // xn--mgba3a4f16a.ir (<iran>.ir, Persian YEH)
  xn--mgba3a4f16a.ir
  // xn--mgba3a4fra.ir (<iran>.ir, Arabic YEH)
  xn--mgba3a4fra.ir
  
  // is : http://www.isnic.is/domain/rules.php
  // Confirmed by registry <marius@isgate.is> 2008-12-06
  is
  net.is
  com.is
  edu.is
  gov.is
  org.is
  int.is
  
  // it : https://en.wikipedia.org/wiki/.it
  it
  gov.it
  edu.it
  // Reserved geo-names:
  // http://www.nic.it/documenti/regolamenti-e-linee-guida/regolamento-assegnazione-versione-6.0.pdf
  // There is also a list of reserved geo-names corresponding to Italian municipalities
  // http://www.nic.it/documenti/appendice-c.pdf, but it is not included here.
  // Regions
  abr.it
  abruzzo.it
  aosta-valley.it
  aostavalley.it
  bas.it
  basilicata.it
  cal.it
  calabria.it
  cam.it
  campania.it
  emilia-romagna.it
  emiliaromagna.it
  emr.it
  friuli-v-giulia.it
  friuli-ve-giulia.it
  friuli-vegiulia.it
  friuli-venezia-giulia.it
  friuli-veneziagiulia.it
  friuli-vgiulia.it
  friuliv-giulia.it
  friulive-giulia.it
  friulivegiulia.it
  friulivenezia-giulia.it
  friuliveneziagiulia.it
  friulivgiulia.it
  fvg.it
  laz.it
  lazio.it
  lig.it
  liguria.it
  lom.it
  lombardia.it
  lombardy.it
  lucania.it
  mar.it
  marche.it
  mol.it
  molise.it
  piedmont.it
  piemonte.it
  pmn.it
  pug.it
  puglia.it
  sar.it
  sardegna.it
  sardinia.it
  sic.it
  sicilia.it
  sicily.it
  taa.it
  tos.it
  toscana.it
  trentino-a-adige.it
  trentino-aadige.it
  trentino-alto-adige.it
  trentino-altoadige.it
  trentino-s-tirol.it
  trentino-stirol.it
  trentino-sud-tirol.it
  trentino-sudtirol.it
  trentino-sued-tirol.it
  trentino-suedtirol.it
  trentinoa-adige.it
  trentinoaadige.it
  trentinoalto-adige.it
  trentinoaltoadige.it
  trentinos-tirol.it
  trentinostirol.it
  trentinosud-tirol.it
  trentinosudtirol.it
  trentinosued-tirol.it
  trentinosuedtirol.it
  tuscany.it
  umb.it
  umbria.it
  val-d-aosta.it
  val-daosta.it
  vald-aosta.it
  valdaosta.it
  valle-aosta.it
  valle-d-aosta.it
  valle-daosta.it
  valleaosta.it
  valled-aosta.it
  valledaosta.it
  vallee-aoste.it
  valleeaoste.it
  vao.it
  vda.it
  ven.it
  veneto.it
  // Provinces
  ag.it
  agrigento.it
  al.it
  alessandria.it
  alto-adige.it
  altoadige.it
  an.it
  ancona.it
  andria-barletta-trani.it
  andria-trani-barletta.it
  andriabarlettatrani.it
  andriatranibarletta.it
  ao.it
  aosta.it
  aoste.it
  ap.it
  aq.it
  aquila.it
  ar.it
  arezzo.it
  ascoli-piceno.it
  ascolipiceno.it
  asti.it
  at.it
  av.it
  avellino.it
  ba.it
  balsan.it
  bari.it
  barletta-trani-andria.it
  barlettatraniandria.it
  belluno.it
  benevento.it
  bergamo.it
  bg.it
  bi.it
  biella.it
  bl.it
  bn.it
  bo.it
  bologna.it
  bolzano.it
  bozen.it
  br.it
  brescia.it
  brindisi.it
  bs.it
  bt.it
  bz.it
  ca.it
  cagliari.it
  caltanissetta.it
  campidano-medio.it
  campidanomedio.it
  campobasso.it
  carbonia-iglesias.it
  carboniaiglesias.it
  carrara-massa.it
  carraramassa.it
  caserta.it
  catania.it
  catanzaro.it
  cb.it
  ce.it
  cesena-forli.it
  cesenaforli.it
  ch.it
  chieti.it
  ci.it
  cl.it
  cn.it
  co.it
  como.it
  cosenza.it
  cr.it
  cremona.it
  crotone.it
  cs.it
  ct.it
  cuneo.it
  cz.it
  dell-ogliastra.it
  dellogliastra.it
  en.it
  enna.it
  fc.it
  fe.it
  fermo.it
  ferrara.it
  fg.it
  fi.it
  firenze.it
  florence.it
  fm.it
  foggia.it
  forli-cesena.it
  forlicesena.it
  fr.it
  frosinone.it
  ge.it
  genoa.it
  genova.it
  go.it
  gorizia.it
  gr.it
  grosseto.it
  iglesias-carbonia.it
  iglesiascarbonia.it
  im.it
  imperia.it
  is.it
  isernia.it
  kr.it
  la-spezia.it
  laquila.it
  laspezia.it
  latina.it
  lc.it
  le.it
  lecce.it
  lecco.it
  li.it
  livorno.it
  lo.it
  lodi.it
  lt.it
  lu.it
  lucca.it
  macerata.it
  mantova.it
  massa-carrara.it
  massacarrara.it
  matera.it
  mb.it
  mc.it
  me.it
  medio-campidano.it
  mediocampidano.it
  messina.it
  mi.it
  milan.it
  milano.it
  mn.it
  mo.it
  modena.it
  monza-brianza.it
  monza-e-della-brianza.it
  monza.it
  monzabrianza.it
  monzaebrianza.it
  monzaedellabrianza.it
  ms.it
  mt.it
  na.it
  naples.it
  napoli.it
  no.it
  novara.it
  nu.it
  nuoro.it
  og.it
  ogliastra.it
  olbia-tempio.it
  olbiatempio.it
  or.it
  oristano.it
  ot.it
  pa.it
  padova.it
  padua.it
  palermo.it
  parma.it
  pavia.it
  pc.it
  pd.it
  pe.it
  perugia.it
  pesaro-urbino.it
  pesarourbino.it
  pescara.it
  pg.it
  pi.it
  piacenza.it
  pisa.it
  pistoia.it
  pn.it
  po.it
  pordenone.it
  potenza.it
  pr.it
  prato.it
  pt.it
  pu.it
  pv.it
  pz.it
  ra.it
  ragusa.it
  ravenna.it
  rc.it
  re.it
  reggio-calabria.it
  reggio-emilia.it
  reggiocalabria.it
  reggioemilia.it
  rg.it
  ri.it
  rieti.it
  rimini.it
  rm.it
  rn.it
  ro.it
  roma.it
  rome.it
  rovigo.it
  sa.it
  salerno.it
  sassari.it
  savona.it
  si.it
  siena.it
  siracusa.it
  so.it
  sondrio.it
  sp.it
  sr.it
  ss.it
  suedtirol.it
  sv.it
  ta.it
  taranto.it
  te.it
  tempio-olbia.it
  tempioolbia.it
  teramo.it
  terni.it
  tn.it
  to.it
  torino.it
  tp.it
  tr.it
  trani-andria-barletta.it
  trani-barletta-andria.it
  traniandriabarletta.it
  tranibarlettaandria.it
  trapani.it
  trentino.it
  trento.it
  treviso.it
  trieste.it
  ts.it
  turin.it
  tv.it
  ud.it
  udine.it
  urbino-pesaro.it
  urbinopesaro.it
  va.it
  varese.it
  vb.it
  vc.it
  ve.it
  venezia.it
  venice.it
  verbania.it
  vercelli.it
  verona.it
  vi.it
  vibo-valentia.it
  vibovalentia.it
  vicenza.it
  viterbo.it
  vr.it
  vs.it
  vt.it
  vv.it
  
  // je : http://www.channelisles.net/register-domains/
  // Confirmed by registry <nigel@channelisles.net> 2013-11-28
  je
  co.je
  net.je
  org.je
  
  // jm : http://www.com.jm/register.html
  *.jm
  
  // jo : http://www.dns.jo/Registration_policy.aspx
  jo
  com.jo
  org.jo
  net.jo
  edu.jo
  sch.jo
  gov.jo
  mil.jo
  name.jo
  
  // jobs : https://en.wikipedia.org/wiki/.jobs
  jobs
  
  // jp : https://en.wikipedia.org/wiki/.jp
  // http://jprs.co.jp/en/jpdomain.html
  // Submitted by registry <info@jprs.jp>
  jp
  // jp organizational type names
  ac.jp
  ad.jp
  co.jp
  ed.jp
  go.jp
  gr.jp
  lg.jp
  ne.jp
  or.jp
  // jp prefecture type names
  aichi.jp
  akita.jp
  aomori.jp
  chiba.jp
  ehime.jp
  fukui.jp
  fukuoka.jp
  fukushima.jp
  gifu.jp
  gunma.jp
  hiroshima.jp
  hokkaido.jp
  hyogo.jp
  ibaraki.jp
  ishikawa.jp
  iwate.jp
  kagawa.jp
  kagoshima.jp
  kanagawa.jp
  kochi.jp
  kumamoto.jp
  kyoto.jp
  mie.jp
  miyagi.jp
  miyazaki.jp
  nagano.jp
  nagasaki.jp
  nara.jp
  niigata.jp
  oita.jp
  okayama.jp
  okinawa.jp
  osaka.jp
  saga.jp
  saitama.jp
  shiga.jp
  shimane.jp
  shizuoka.jp
  tochigi.jp
  tokushima.jp
  tokyo.jp
  tottori.jp
  toyama.jp
  wakayama.jp
  yamagata.jp
  yamaguchi.jp
  yamanashi.jp
  xn--4pvxs.jp
  xn--vgu402c.jp
  xn--c3s14m.jp
  xn--f6qx53a.jp
  xn--8pvr4u.jp
  xn--uist22h.jp
  xn--djrs72d6uy.jp
  xn--mkru45i.jp
  xn--0trq7p7nn.jp
  xn--8ltr62k.jp
  xn--2m4a15e.jp
  xn--efvn9s.jp
  xn--32vp30h.jp
  xn--4it797k.jp
  xn--1lqs71d.jp
  xn--5rtp49c.jp
  xn--5js045d.jp
  xn--ehqz56n.jp
  xn--1lqs03n.jp
  xn--qqqt11m.jp
  xn--kbrq7o.jp
  xn--pssu33l.jp
  xn--ntsq17g.jp
  xn--uisz3g.jp
  xn--6btw5a.jp
  xn--1ctwo.jp
  xn--6orx2r.jp
  xn--rht61e.jp
  xn--rht27z.jp
  xn--djty4k.jp
  xn--nit225k.jp
  xn--rht3d.jp
  xn--klty5x.jp
  xn--kltx9a.jp
  xn--kltp7d.jp
  xn--uuwu58a.jp
  xn--zbx025d.jp
  xn--ntso0iqx3a.jp
  xn--elqq16h.jp
  xn--4it168d.jp
  xn--klt787d.jp
  xn--rny31h.jp
  xn--7t0a264c.jp
  xn--5rtq34k.jp
  xn--k7yn95e.jp
  xn--tor131o.jp
  xn--d5qv7z876c.jp
  // jp geographic type names
  // http://jprs.jp/doc/rule/saisoku-1.html
  *.kawasaki.jp
  *.kitakyushu.jp
  *.kobe.jp
  *.nagoya.jp
  *.sapporo.jp
  *.sendai.jp
  *.yokohama.jp
  !city.kawasaki.jp
  !city.kitakyushu.jp
  !city.kobe.jp
  !city.nagoya.jp
  !city.sapporo.jp
  !city.sendai.jp
  !city.yokohama.jp
  // 4th level registration
  aisai.aichi.jp
  ama.aichi.jp
  anjo.aichi.jp
  asuke.aichi.jp
  chiryu.aichi.jp
  chita.aichi.jp
  fuso.aichi.jp
  gamagori.aichi.jp
  handa.aichi.jp
  hazu.aichi.jp
  hekinan.aichi.jp
  higashiura.aichi.jp
  ichinomiya.aichi.jp
  inazawa.aichi.jp
  inuyama.aichi.jp
  isshiki.aichi.jp
  iwakura.aichi.jp
  kanie.aichi.jp
  kariya.aichi.jp
  kasugai.aichi.jp
  kira.aichi.jp
  kiyosu.aichi.jp
  komaki.aichi.jp
  konan.aichi.jp
  kota.aichi.jp
  mihama.aichi.jp
  miyoshi.aichi.jp
  nishio.aichi.jp
  nisshin.aichi.jp
  obu.aichi.jp
  oguchi.aichi.jp
  oharu.aichi.jp
  okazaki.aichi.jp
  owariasahi.aichi.jp
  seto.aichi.jp
  shikatsu.aichi.jp
  shinshiro.aichi.jp
  shitara.aichi.jp
  tahara.aichi.jp
  takahama.aichi.jp
  tobishima.aichi.jp
  toei.aichi.jp
  togo.aichi.jp
  tokai.aichi.jp
  tokoname.aichi.jp
  toyoake.aichi.jp
  toyohashi.aichi.jp
  toyokawa.aichi.jp
  toyone.aichi.jp
  toyota.aichi.jp
  tsushima.aichi.jp
  yatomi.aichi.jp
  akita.akita.jp
  daisen.akita.jp
  fujisato.akita.jp
  gojome.akita.jp
  hachirogata.akita.jp
  happou.akita.jp
  higashinaruse.akita.jp
  honjo.akita.jp
  honjyo.akita.jp
  ikawa.akita.jp
  kamikoani.akita.jp
  kamioka.akita.jp
  katagami.akita.jp
  kazuno.akita.jp
  kitaakita.akita.jp
  kosaka.akita.jp
  kyowa.akita.jp
  misato.akita.jp
  mitane.akita.jp
  moriyoshi.akita.jp
  nikaho.akita.jp
  noshiro.akita.jp
  odate.akita.jp
  oga.akita.jp
  ogata.akita.jp
  semboku.akita.jp
  yokote.akita.jp
  yurihonjo.akita.jp
  aomori.aomori.jp
  gonohe.aomori.jp
  hachinohe.aomori.jp
  hashikami.aomori.jp
  hiranai.aomori.jp
  hirosaki.aomori.jp
  itayanagi.aomori.jp
  kuroishi.aomori.jp
  misawa.aomori.jp
  mutsu.aomori.jp
  nakadomari.aomori.jp
  noheji.aomori.jp
  oirase.aomori.jp
  owani.aomori.jp
  rokunohe.aomori.jp
  sannohe.aomori.jp
  shichinohe.aomori.jp
  shingo.aomori.jp
  takko.aomori.jp
  towada.aomori.jp
  tsugaru.aomori.jp
  tsuruta.aomori.jp
  abiko.chiba.jp
  asahi.chiba.jp
  chonan.chiba.jp
  chosei.chiba.jp
  choshi.chiba.jp
  chuo.chiba.jp
  funabashi.chiba.jp
  futtsu.chiba.jp
  hanamigawa.chiba.jp
  ichihara.chiba.jp
  ichikawa.chiba.jp
  ichinomiya.chiba.jp
  inzai.chiba.jp
  isumi.chiba.jp
  kamagaya.chiba.jp
  kamogawa.chiba.jp
  kashiwa.chiba.jp
  katori.chiba.jp
  katsuura.chiba.jp
  kimitsu.chiba.jp
  kisarazu.chiba.jp
  kozaki.chiba.jp
  kujukuri.chiba.jp
  kyonan.chiba.jp
  matsudo.chiba.jp
  midori.chiba.jp
  mihama.chiba.jp
  minamiboso.chiba.jp
  mobara.chiba.jp
  mutsuzawa.chiba.jp
  nagara.chiba.jp
  nagareyama.chiba.jp
  narashino.chiba.jp
  narita.chiba.jp
  noda.chiba.jp
  oamishirasato.chiba.jp
  omigawa.chiba.jp
  onjuku.chiba.jp
  otaki.chiba.jp
  sakae.chiba.jp
  sakura.chiba.jp
  shimofusa.chiba.jp
  shirako.chiba.jp
  shiroi.chiba.jp
  shisui.chiba.jp
  sodegaura.chiba.jp
  sosa.chiba.jp
  tako.chiba.jp
  tateyama.chiba.jp
  togane.chiba.jp
  tohnosho.chiba.jp
  tomisato.chiba.jp
  urayasu.chiba.jp
  yachimata.chiba.jp
  yachiyo.chiba.jp
  yokaichiba.chiba.jp
  yokoshibahikari.chiba.jp
  yotsukaido.chiba.jp
  ainan.ehime.jp
  honai.ehime.jp
  ikata.ehime.jp
  imabari.ehime.jp
  iyo.ehime.jp
  kamijima.ehime.jp
  kihoku.ehime.jp
  kumakogen.ehime.jp
  masaki.ehime.jp
  matsuno.ehime.jp
  matsuyama.ehime.jp
  namikata.ehime.jp
  niihama.ehime.jp
  ozu.ehime.jp
  saijo.ehime.jp
  seiyo.ehime.jp
  shikokuchuo.ehime.jp
  tobe.ehime.jp
  toon.ehime.jp
  uchiko.ehime.jp
  uwajima.ehime.jp
  yawatahama.ehime.jp
  echizen.fukui.jp
  eiheiji.fukui.jp
  fukui.fukui.jp
  ikeda.fukui.jp
  katsuyama.fukui.jp
  mihama.fukui.jp
  minamiechizen.fukui.jp
  obama.fukui.jp
  ohi.fukui.jp
  ono.fukui.jp
  sabae.fukui.jp
  sakai.fukui.jp
  takahama.fukui.jp
  tsuruga.fukui.jp
  wakasa.fukui.jp
  ashiya.fukuoka.jp
  buzen.fukuoka.jp
  chikugo.fukuoka.jp
  chikuho.fukuoka.jp
  chikujo.fukuoka.jp
  chikushino.fukuoka.jp
  chikuzen.fukuoka.jp
  chuo.fukuoka.jp
  dazaifu.fukuoka.jp
  fukuchi.fukuoka.jp
  hakata.fukuoka.jp
  higashi.fukuoka.jp
  hirokawa.fukuoka.jp
  hisayama.fukuoka.jp
  iizuka.fukuoka.jp
  inatsuki.fukuoka.jp
  kaho.fukuoka.jp
  kasuga.fukuoka.jp
  kasuya.fukuoka.jp
  kawara.fukuoka.jp
  keisen.fukuoka.jp
  koga.fukuoka.jp
  kurate.fukuoka.jp
  kurogi.fukuoka.jp
  kurume.fukuoka.jp
  minami.fukuoka.jp
  miyako.fukuoka.jp
  miyama.fukuoka.jp
  miyawaka.fukuoka.jp
  mizumaki.fukuoka.jp
  munakata.fukuoka.jp
  nakagawa.fukuoka.jp
  nakama.fukuoka.jp
  nishi.fukuoka.jp
  nogata.fukuoka.jp
  ogori.fukuoka.jp
  okagaki.fukuoka.jp
  okawa.fukuoka.jp
  oki.fukuoka.jp
  omuta.fukuoka.jp
  onga.fukuoka.jp
  onojo.fukuoka.jp
  oto.fukuoka.jp
  saigawa.fukuoka.jp
  sasaguri.fukuoka.jp
  shingu.fukuoka.jp
  shinyoshitomi.fukuoka.jp
  shonai.fukuoka.jp
  soeda.fukuoka.jp
  sue.fukuoka.jp
  tachiarai.fukuoka.jp
  tagawa.fukuoka.jp
  takata.fukuoka.jp
  toho.fukuoka.jp
  toyotsu.fukuoka.jp
  tsuiki.fukuoka.jp
  ukiha.fukuoka.jp
  umi.fukuoka.jp
  usui.fukuoka.jp
  yamada.fukuoka.jp
  yame.fukuoka.jp
  yanagawa.fukuoka.jp
  yukuhashi.fukuoka.jp
  aizubange.fukushima.jp
  aizumisato.fukushima.jp
  aizuwakamatsu.fukushima.jp
  asakawa.fukushima.jp
  bandai.fukushima.jp
  date.fukushima.jp
  fukushima.fukushima.jp
  furudono.fukushima.jp
  futaba.fukushima.jp
  hanawa.fukushima.jp
  higashi.fukushima.jp
  hirata.fukushima.jp
  hirono.fukushima.jp
  iitate.fukushima.jp
  inawashiro.fukushima.jp
  ishikawa.fukushima.jp
  iwaki.fukushima.jp
  izumizaki.fukushima.jp
  kagamiishi.fukushima.jp
  kaneyama.fukushima.jp
  kawamata.fukushima.jp
  kitakata.fukushima.jp
  kitashiobara.fukushima.jp
  koori.fukushima.jp
  koriyama.fukushima.jp
  kunimi.fukushima.jp
  miharu.fukushima.jp
  mishima.fukushima.jp
  namie.fukushima.jp
  nango.fukushima.jp
  nishiaizu.fukushima.jp
  nishigo.fukushima.jp
  okuma.fukushima.jp
  omotego.fukushima.jp
  ono.fukushima.jp
  otama.fukushima.jp
  samegawa.fukushima.jp
  shimogo.fukushima.jp
  shirakawa.fukushima.jp
  showa.fukushima.jp
  soma.fukushima.jp
  sukagawa.fukushima.jp
  taishin.fukushima.jp
  tamakawa.fukushima.jp
  tanagura.fukushima.jp
  tenei.fukushima.jp
  yabuki.fukushima.jp
  yamato.fukushima.jp
  yamatsuri.fukushima.jp
  yanaizu.fukushima.jp
  yugawa.fukushima.jp
  anpachi.gifu.jp
  ena.gifu.jp
  gifu.gifu.jp
  ginan.gifu.jp
  godo.gifu.jp
  gujo.gifu.jp
  hashima.gifu.jp
  hichiso.gifu.jp
  hida.gifu.jp
  higashishirakawa.gifu.jp
  ibigawa.gifu.jp
  ikeda.gifu.jp
  kakamigahara.gifu.jp
  kani.gifu.jp
  kasahara.gifu.jp
  kasamatsu.gifu.jp
  kawaue.gifu.jp
  kitagata.gifu.jp
  mino.gifu.jp
  minokamo.gifu.jp
  mitake.gifu.jp
  mizunami.gifu.jp
  motosu.gifu.jp
  nakatsugawa.gifu.jp
  ogaki.gifu.jp
  sakahogi.gifu.jp
  seki.gifu.jp
  sekigahara.gifu.jp
  shirakawa.gifu.jp
  tajimi.gifu.jp
  takayama.gifu.jp
  tarui.gifu.jp
  toki.gifu.jp
  tomika.gifu.jp
  wanouchi.gifu.jp
  yamagata.gifu.jp
  yaotsu.gifu.jp
  yoro.gifu.jp
  annaka.gunma.jp
  chiyoda.gunma.jp
  fujioka.gunma.jp
  higashiagatsuma.gunma.jp
  isesaki.gunma.jp
  itakura.gunma.jp
  kanna.gunma.jp
  kanra.gunma.jp
  katashina.gunma.jp
  kawaba.gunma.jp
  kiryu.gunma.jp
  kusatsu.gunma.jp
  maebashi.gunma.jp
  meiwa.gunma.jp
  midori.gunma.jp
  minakami.gunma.jp
  naganohara.gunma.jp
  nakanojo.gunma.jp
  nanmoku.gunma.jp
  numata.gunma.jp
  oizumi.gunma.jp
  ora.gunma.jp
  ota.gunma.jp
  shibukawa.gunma.jp
  shimonita.gunma.jp
  shinto.gunma.jp
  showa.gunma.jp
  takasaki.gunma.jp
  takayama.gunma.jp
  tamamura.gunma.jp
  tatebayashi.gunma.jp
  tomioka.gunma.jp
  tsukiyono.gunma.jp
  tsumagoi.gunma.jp
  ueno.gunma.jp
  yoshioka.gunma.jp
  asaminami.hiroshima.jp
  daiwa.hiroshima.jp
  etajima.hiroshima.jp
  fuchu.hiroshima.jp
  fukuyama.hiroshima.jp
  hatsukaichi.hiroshima.jp
  higashihiroshima.hiroshima.jp
  hongo.hiroshima.jp
  jinsekikogen.hiroshima.jp
  kaita.hiroshima.jp
  kui.hiroshima.jp
  kumano.hiroshima.jp
  kure.hiroshima.jp
  mihara.hiroshima.jp
  miyoshi.hiroshima.jp
  naka.hiroshima.jp
  onomichi.hiroshima.jp
  osakikamijima.hiroshima.jp
  otake.hiroshima.jp
  saka.hiroshima.jp
  sera.hiroshima.jp
  seranishi.hiroshima.jp
  shinichi.hiroshima.jp
  shobara.hiroshima.jp
  takehara.hiroshima.jp
  abashiri.hokkaido.jp
  abira.hokkaido.jp
  aibetsu.hokkaido.jp
  akabira.hokkaido.jp
  akkeshi.hokkaido.jp
  asahikawa.hokkaido.jp
  ashibetsu.hokkaido.jp
  ashoro.hokkaido.jp
  assabu.hokkaido.jp
  atsuma.hokkaido.jp
  bibai.hokkaido.jp
  biei.hokkaido.jp
  bifuka.hokkaido.jp
  bihoro.hokkaido.jp
  biratori.hokkaido.jp
  chippubetsu.hokkaido.jp
  chitose.hokkaido.jp
  date.hokkaido.jp
  ebetsu.hokkaido.jp
  embetsu.hokkaido.jp
  eniwa.hokkaido.jp
  erimo.hokkaido.jp
  esan.hokkaido.jp
  esashi.hokkaido.jp
  fukagawa.hokkaido.jp
  fukushima.hokkaido.jp
  furano.hokkaido.jp
  furubira.hokkaido.jp
  haboro.hokkaido.jp
  hakodate.hokkaido.jp
  hamatonbetsu.hokkaido.jp
  hidaka.hokkaido.jp
  higashikagura.hokkaido.jp
  higashikawa.hokkaido.jp
  hiroo.hokkaido.jp
  hokuryu.hokkaido.jp
  hokuto.hokkaido.jp
  honbetsu.hokkaido.jp
  horokanai.hokkaido.jp
  horonobe.hokkaido.jp
  ikeda.hokkaido.jp
  imakane.hokkaido.jp
  ishikari.hokkaido.jp
  iwamizawa.hokkaido.jp
  iwanai.hokkaido.jp
  kamifurano.hokkaido.jp
  kamikawa.hokkaido.jp
  kamishihoro.hokkaido.jp
  kamisunagawa.hokkaido.jp
  kamoenai.hokkaido.jp
  kayabe.hokkaido.jp
  kembuchi.hokkaido.jp
  kikonai.hokkaido.jp
  kimobetsu.hokkaido.jp
  kitahiroshima.hokkaido.jp
  kitami.hokkaido.jp
  kiyosato.hokkaido.jp
  koshimizu.hokkaido.jp
  kunneppu.hokkaido.jp
  kuriyama.hokkaido.jp
  kuromatsunai.hokkaido.jp
  kushiro.hokkaido.jp
  kutchan.hokkaido.jp
  kyowa.hokkaido.jp
  mashike.hokkaido.jp
  matsumae.hokkaido.jp
  mikasa.hokkaido.jp
  minamifurano.hokkaido.jp
  mombetsu.hokkaido.jp
  moseushi.hokkaido.jp
  mukawa.hokkaido.jp
  muroran.hokkaido.jp
  naie.hokkaido.jp
  nakagawa.hokkaido.jp
  nakasatsunai.hokkaido.jp
  nakatombetsu.hokkaido.jp
  nanae.hokkaido.jp
  nanporo.hokkaido.jp
  nayoro.hokkaido.jp
  nemuro.hokkaido.jp
  niikappu.hokkaido.jp
  niki.hokkaido.jp
  nishiokoppe.hokkaido.jp
  noboribetsu.hokkaido.jp
  numata.hokkaido.jp
  obihiro.hokkaido.jp
  obira.hokkaido.jp
  oketo.hokkaido.jp
  okoppe.hokkaido.jp
  otaru.hokkaido.jp
  otobe.hokkaido.jp
  otofuke.hokkaido.jp
  otoineppu.hokkaido.jp
  oumu.hokkaido.jp
  ozora.hokkaido.jp
  pippu.hokkaido.jp
  rankoshi.hokkaido.jp
  rebun.hokkaido.jp
  rikubetsu.hokkaido.jp
  rishiri.hokkaido.jp
  rishirifuji.hokkaido.jp
  saroma.hokkaido.jp
  sarufutsu.hokkaido.jp
  shakotan.hokkaido.jp
  shari.hokkaido.jp
  shibecha.hokkaido.jp
  shibetsu.hokkaido.jp
  shikabe.hokkaido.jp
  shikaoi.hokkaido.jp
  shimamaki.hokkaido.jp
  shimizu.hokkaido.jp
  shimokawa.hokkaido.jp
  shinshinotsu.hokkaido.jp
  shintoku.hokkaido.jp
  shiranuka.hokkaido.jp
  shiraoi.hokkaido.jp
  shiriuchi.hokkaido.jp
  sobetsu.hokkaido.jp
  sunagawa.hokkaido.jp
  taiki.hokkaido.jp
  takasu.hokkaido.jp
  takikawa.hokkaido.jp
  takinoue.hokkaido.jp
  teshikaga.hokkaido.jp
  tobetsu.hokkaido.jp
  tohma.hokkaido.jp
  tomakomai.hokkaido.jp
  tomari.hokkaido.jp
  toya.hokkaido.jp
  toyako.hokkaido.jp
  toyotomi.hokkaido.jp
  toyoura.hokkaido.jp
  tsubetsu.hokkaido.jp
  tsukigata.hokkaido.jp
  urakawa.hokkaido.jp
  urausu.hokkaido.jp
  uryu.hokkaido.jp
  utashinai.hokkaido.jp
  wakkanai.hokkaido.jp
  wassamu.hokkaido.jp
  yakumo.hokkaido.jp
  yoichi.hokkaido.jp
  aioi.hyogo.jp
  akashi.hyogo.jp
  ako.hyogo.jp
  amagasaki.hyogo.jp
  aogaki.hyogo.jp
  asago.hyogo.jp
  ashiya.hyogo.jp
  awaji.hyogo.jp
  fukusaki.hyogo.jp
  goshiki.hyogo.jp
  harima.hyogo.jp
  himeji.hyogo.jp
  ichikawa.hyogo.jp
  inagawa.hyogo.jp
  itami.hyogo.jp
  kakogawa.hyogo.jp
  kamigori.hyogo.jp
  kamikawa.hyogo.jp
  kasai.hyogo.jp
  kasuga.hyogo.jp
  kawanishi.hyogo.jp
  miki.hyogo.jp
  minamiawaji.hyogo.jp
  nishinomiya.hyogo.jp
  nishiwaki.hyogo.jp
  ono.hyogo.jp
  sanda.hyogo.jp
  sannan.hyogo.jp
  sasayama.hyogo.jp
  sayo.hyogo.jp
  shingu.hyogo.jp
  shinonsen.hyogo.jp
  shiso.hyogo.jp
  sumoto.hyogo.jp
  taishi.hyogo.jp
  taka.hyogo.jp
  takarazuka.hyogo.jp
  takasago.hyogo.jp
  takino.hyogo.jp
  tamba.hyogo.jp
  tatsuno.hyogo.jp
  toyooka.hyogo.jp
  yabu.hyogo.jp
  yashiro.hyogo.jp
  yoka.hyogo.jp
  yokawa.hyogo.jp
  ami.ibaraki.jp
  asahi.ibaraki.jp
  bando.ibaraki.jp
  chikusei.ibaraki.jp
  daigo.ibaraki.jp
  fujishiro.ibaraki.jp
  hitachi.ibaraki.jp
  hitachinaka.ibaraki.jp
  hitachiomiya.ibaraki.jp
  hitachiota.ibaraki.jp
  ibaraki.ibaraki.jp
  ina.ibaraki.jp
  inashiki.ibaraki.jp
  itako.ibaraki.jp
  iwama.ibaraki.jp
  joso.ibaraki.jp
  kamisu.ibaraki.jp
  kasama.ibaraki.jp
  kashima.ibaraki.jp
  kasumigaura.ibaraki.jp
  koga.ibaraki.jp
  miho.ibaraki.jp
  mito.ibaraki.jp
  moriya.ibaraki.jp
  naka.ibaraki.jp
  namegata.ibaraki.jp
  oarai.ibaraki.jp
  ogawa.ibaraki.jp
  omitama.ibaraki.jp
  ryugasaki.ibaraki.jp
  sakai.ibaraki.jp
  sakuragawa.ibaraki.jp
  shimodate.ibaraki.jp
  shimotsuma.ibaraki.jp
  shirosato.ibaraki.jp
  sowa.ibaraki.jp
  suifu.ibaraki.jp
  takahagi.ibaraki.jp
  tamatsukuri.ibaraki.jp
  tokai.ibaraki.jp
  tomobe.ibaraki.jp
  tone.ibaraki.jp
  toride.ibaraki.jp
  tsuchiura.ibaraki.jp
  tsukuba.ibaraki.jp
  uchihara.ibaraki.jp
  ushiku.ibaraki.jp
  yachiyo.ibaraki.jp
  yamagata.ibaraki.jp
  yawara.ibaraki.jp
  yuki.ibaraki.jp
  anamizu.ishikawa.jp
  hakui.ishikawa.jp
  hakusan.ishikawa.jp
  kaga.ishikawa.jp
  kahoku.ishikawa.jp
  kanazawa.ishikawa.jp
  kawakita.ishikawa.jp
  komatsu.ishikawa.jp
  nakanoto.ishikawa.jp
  nanao.ishikawa.jp
  nomi.ishikawa.jp
  nonoichi.ishikawa.jp
  noto.ishikawa.jp
  shika.ishikawa.jp
  suzu.ishikawa.jp
  tsubata.ishikawa.jp
  tsurugi.ishikawa.jp
  uchinada.ishikawa.jp
  wajima.ishikawa.jp
  fudai.iwate.jp
  fujisawa.iwate.jp
  hanamaki.iwate.jp
  hiraizumi.iwate.jp
  hirono.iwate.jp
  ichinohe.iwate.jp
  ichinoseki.iwate.jp
  iwaizumi.iwate.jp
  iwate.iwate.jp
  joboji.iwate.jp
  kamaishi.iwate.jp
  kanegasaki.iwate.jp
  karumai.iwate.jp
  kawai.iwate.jp
  kitakami.iwate.jp
  kuji.iwate.jp
  kunohe.iwate.jp
  kuzumaki.iwate.jp
  miyako.iwate.jp
  mizusawa.iwate.jp
  morioka.iwate.jp
  ninohe.iwate.jp
  noda.iwate.jp
  ofunato.iwate.jp
  oshu.iwate.jp
  otsuchi.iwate.jp
  rikuzentakata.iwate.jp
  shiwa.iwate.jp
  shizukuishi.iwate.jp
  sumita.iwate.jp
  tanohata.iwate.jp
  tono.iwate.jp
  yahaba.iwate.jp
  yamada.iwate.jp
  ayagawa.kagawa.jp
  higashikagawa.kagawa.jp
  kanonji.kagawa.jp
  kotohira.kagawa.jp
  manno.kagawa.jp
  marugame.kagawa.jp
  mitoyo.kagawa.jp
  naoshima.kagawa.jp
  sanuki.kagawa.jp
  tadotsu.kagawa.jp
  takamatsu.kagawa.jp
  tonosho.kagawa.jp
  uchinomi.kagawa.jp
  utazu.kagawa.jp
  zentsuji.kagawa.jp
  akune.kagoshima.jp
  amami.kagoshima.jp
  hioki.kagoshima.jp
  isa.kagoshima.jp
  isen.kagoshima.jp
  izumi.kagoshima.jp
  kagoshima.kagoshima.jp
  kanoya.kagoshima.jp
  kawanabe.kagoshima.jp
  kinko.kagoshima.jp
  kouyama.kagoshima.jp
  makurazaki.kagoshima.jp
  matsumoto.kagoshima.jp
  minamitane.kagoshima.jp
  nakatane.kagoshima.jp
  nishinoomote.kagoshima.jp
  satsumasendai.kagoshima.jp
  soo.kagoshima.jp
  tarumizu.kagoshima.jp
  yusui.kagoshima.jp
  aikawa.kanagawa.jp
  atsugi.kanagawa.jp
  ayase.kanagawa.jp
  chigasaki.kanagawa.jp
  ebina.kanagawa.jp
  fujisawa.kanagawa.jp
  hadano.kanagawa.jp
  hakone.kanagawa.jp
  hiratsuka.kanagawa.jp
  isehara.kanagawa.jp
  kaisei.kanagawa.jp
  kamakura.kanagawa.jp
  kiyokawa.kanagawa.jp
  matsuda.kanagawa.jp
  minamiashigara.kanagawa.jp
  miura.kanagawa.jp
  nakai.kanagawa.jp
  ninomiya.kanagawa.jp
  odawara.kanagawa.jp
  oi.kanagawa.jp
  oiso.kanagawa.jp
  sagamihara.kanagawa.jp
  samukawa.kanagawa.jp
  tsukui.kanagawa.jp
  yamakita.kanagawa.jp
  yamato.kanagawa.jp
  yokosuka.kanagawa.jp
  yugawara.kanagawa.jp
  zama.kanagawa.jp
  zushi.kanagawa.jp
  aki.kochi.jp
  geisei.kochi.jp
  hidaka.kochi.jp
  higashitsuno.kochi.jp
  ino.kochi.jp
  kagami.kochi.jp
  kami.kochi.jp
  kitagawa.kochi.jp
  kochi.kochi.jp
  mihara.kochi.jp
  motoyama.kochi.jp
  muroto.kochi.jp
  nahari.kochi.jp
  nakamura.kochi.jp
  nankoku.kochi.jp
  nishitosa.kochi.jp
  niyodogawa.kochi.jp
  ochi.kochi.jp
  okawa.kochi.jp
  otoyo.kochi.jp
  otsuki.kochi.jp
  sakawa.kochi.jp
  sukumo.kochi.jp
  susaki.kochi.jp
  tosa.kochi.jp
  tosashimizu.kochi.jp
  toyo.kochi.jp
  tsuno.kochi.jp
  umaji.kochi.jp
  yasuda.kochi.jp
  yusuhara.kochi.jp
  amakusa.kumamoto.jp
  arao.kumamoto.jp
  aso.kumamoto.jp
  choyo.kumamoto.jp
  gyokuto.kumamoto.jp
  kamiamakusa.kumamoto.jp
  kikuchi.kumamoto.jp
  kumamoto.kumamoto.jp
  mashiki.kumamoto.jp
  mifune.kumamoto.jp
  minamata.kumamoto.jp
  minamioguni.kumamoto.jp
  nagasu.kumamoto.jp
  nishihara.kumamoto.jp
  oguni.kumamoto.jp
  ozu.kumamoto.jp
  sumoto.kumamoto.jp
  takamori.kumamoto.jp
  uki.kumamoto.jp
  uto.kumamoto.jp
  yamaga.kumamoto.jp
  yamato.kumamoto.jp
  yatsushiro.kumamoto.jp
  ayabe.kyoto.jp
  fukuchiyama.kyoto.jp
  higashiyama.kyoto.jp
  ide.kyoto.jp
  ine.kyoto.jp
  joyo.kyoto.jp
  kameoka.kyoto.jp
  kamo.kyoto.jp
  kita.kyoto.jp
  kizu.kyoto.jp
  kumiyama.kyoto.jp
  kyotamba.kyoto.jp
  kyotanabe.kyoto.jp
  kyotango.kyoto.jp
  maizuru.kyoto.jp
  minami.kyoto.jp
  minamiyamashiro.kyoto.jp
  miyazu.kyoto.jp
  muko.kyoto.jp
  nagaokakyo.kyoto.jp
  nakagyo.kyoto.jp
  nantan.kyoto.jp
  oyamazaki.kyoto.jp
  sakyo.kyoto.jp
  seika.kyoto.jp
  tanabe.kyoto.jp
  uji.kyoto.jp
  ujitawara.kyoto.jp
  wazuka.kyoto.jp
  yamashina.kyoto.jp
  yawata.kyoto.jp
  asahi.mie.jp
  inabe.mie.jp
  ise.mie.jp
  kameyama.mie.jp
  kawagoe.mie.jp
  kiho.mie.jp
  kisosaki.mie.jp
  kiwa.mie.jp
  komono.mie.jp
  kumano.mie.jp
  kuwana.mie.jp
  matsusaka.mie.jp
  meiwa.mie.jp
  mihama.mie.jp
  minamiise.mie.jp
  misugi.mie.jp
  miyama.mie.jp
  nabari.mie.jp
  shima.mie.jp
  suzuka.mie.jp
  tado.mie.jp
  taiki.mie.jp
  taki.mie.jp
  tamaki.mie.jp
  toba.mie.jp
  tsu.mie.jp
  udono.mie.jp
  ureshino.mie.jp
  watarai.mie.jp
  yokkaichi.mie.jp
  furukawa.miyagi.jp
  higashimatsushima.miyagi.jp
  ishinomaki.miyagi.jp
  iwanuma.miyagi.jp
  kakuda.miyagi.jp
  kami.miyagi.jp
  kawasaki.miyagi.jp
  marumori.miyagi.jp
  matsushima.miyagi.jp
  minamisanriku.miyagi.jp
  misato.miyagi.jp
  murata.miyagi.jp
  natori.miyagi.jp
  ogawara.miyagi.jp
  ohira.miyagi.jp
  onagawa.miyagi.jp
  osaki.miyagi.jp
  rifu.miyagi.jp
  semine.miyagi.jp
  shibata.miyagi.jp
  shichikashuku.miyagi.jp
  shikama.miyagi.jp
  shiogama.miyagi.jp
  shiroishi.miyagi.jp
  tagajo.miyagi.jp
  taiwa.miyagi.jp
  tome.miyagi.jp
  tomiya.miyagi.jp
  wakuya.miyagi.jp
  watari.miyagi.jp
  yamamoto.miyagi.jp
  zao.miyagi.jp
  aya.miyazaki.jp
  ebino.miyazaki.jp
  gokase.miyazaki.jp
  hyuga.miyazaki.jp
  kadogawa.miyazaki.jp
  kawaminami.miyazaki.jp
  kijo.miyazaki.jp
  kitagawa.miyazaki.jp
  kitakata.miyazaki.jp
  kitaura.miyazaki.jp
  kobayashi.miyazaki.jp
  kunitomi.miyazaki.jp
  kushima.miyazaki.jp
  mimata.miyazaki.jp
  miyakonojo.miyazaki.jp
  miyazaki.miyazaki.jp
  morotsuka.miyazaki.jp
  nichinan.miyazaki.jp
  nishimera.miyazaki.jp
  nobeoka.miyazaki.jp
  saito.miyazaki.jp
  shiiba.miyazaki.jp
  shintomi.miyazaki.jp
  takaharu.miyazaki.jp
  takanabe.miyazaki.jp
  takazaki.miyazaki.jp
  tsuno.miyazaki.jp
  achi.nagano.jp
  agematsu.nagano.jp
  anan.nagano.jp
  aoki.nagano.jp
  asahi.nagano.jp
  azumino.nagano.jp
  chikuhoku.nagano.jp
  chikuma.nagano.jp
  chino.nagano.jp
  fujimi.nagano.jp
  hakuba.nagano.jp
  hara.nagano.jp
  hiraya.nagano.jp
  iida.nagano.jp
  iijima.nagano.jp
  iiyama.nagano.jp
  iizuna.nagano.jp
  ikeda.nagano.jp
  ikusaka.nagano.jp
  ina.nagano.jp
  karuizawa.nagano.jp
  kawakami.nagano.jp
  kiso.nagano.jp
  kisofukushima.nagano.jp
  kitaaiki.nagano.jp
  komagane.nagano.jp
  komoro.nagano.jp
  matsukawa.nagano.jp
  matsumoto.nagano.jp
  miasa.nagano.jp
  minamiaiki.nagano.jp
  minamimaki.nagano.jp
  minamiminowa.nagano.jp
  minowa.nagano.jp
  miyada.nagano.jp
  miyota.nagano.jp
  mochizuki.nagano.jp
  nagano.nagano.jp
  nagawa.nagano.jp
  nagiso.nagano.jp
  nakagawa.nagano.jp
  nakano.nagano.jp
  nozawaonsen.nagano.jp
  obuse.nagano.jp
  ogawa.nagano.jp
  okaya.nagano.jp
  omachi.nagano.jp
  omi.nagano.jp
  ookuwa.nagano.jp
  ooshika.nagano.jp
  otaki.nagano.jp
  otari.nagano.jp
  sakae.nagano.jp
  sakaki.nagano.jp
  saku.nagano.jp
  sakuho.nagano.jp
  shimosuwa.nagano.jp
  shinanomachi.nagano.jp
  shiojiri.nagano.jp
  suwa.nagano.jp
  suzaka.nagano.jp
  takagi.nagano.jp
  takamori.nagano.jp
  takayama.nagano.jp
  tateshina.nagano.jp
  tatsuno.nagano.jp
  togakushi.nagano.jp
  togura.nagano.jp
  tomi.nagano.jp
  ueda.nagano.jp
  wada.nagano.jp
  yamagata.nagano.jp
  yamanouchi.nagano.jp
  yasaka.nagano.jp
  yasuoka.nagano.jp
  chijiwa.nagasaki.jp
  futsu.nagasaki.jp
  goto.nagasaki.jp
  hasami.nagasaki.jp
  hirado.nagasaki.jp
  iki.nagasaki.jp
  isahaya.nagasaki.jp
  kawatana.nagasaki.jp
  kuchinotsu.nagasaki.jp
  matsuura.nagasaki.jp
  nagasaki.nagasaki.jp
  obama.nagasaki.jp
  omura.nagasaki.jp
  oseto.nagasaki.jp
  saikai.nagasaki.jp
  sasebo.nagasaki.jp
  seihi.nagasaki.jp
  shimabara.nagasaki.jp
  shinkamigoto.nagasaki.jp
  togitsu.nagasaki.jp
  tsushima.nagasaki.jp
  unzen.nagasaki.jp
  ando.nara.jp
  gose.nara.jp
  heguri.nara.jp
  higashiyoshino.nara.jp
  ikaruga.nara.jp
  ikoma.nara.jp
  kamikitayama.nara.jp
  kanmaki.nara.jp
  kashiba.nara.jp
  kashihara.nara.jp
  katsuragi.nara.jp
  kawai.nara.jp
  kawakami.nara.jp
  kawanishi.nara.jp
  koryo.nara.jp
  kurotaki.nara.jp
  mitsue.nara.jp
  miyake.nara.jp
  nara.nara.jp
  nosegawa.nara.jp
  oji.nara.jp
  ouda.nara.jp
  oyodo.nara.jp
  sakurai.nara.jp
  sango.nara.jp
  shimoichi.nara.jp
  shimokitayama.nara.jp
  shinjo.nara.jp
  soni.nara.jp
  takatori.nara.jp
  tawaramoto.nara.jp
  tenkawa.nara.jp
  tenri.nara.jp
  uda.nara.jp
  yamatokoriyama.nara.jp
  yamatotakada.nara.jp
  yamazoe.nara.jp
  yoshino.nara.jp
  aga.niigata.jp
  agano.niigata.jp
  gosen.niigata.jp
  itoigawa.niigata.jp
  izumozaki.niigata.jp
  joetsu.niigata.jp
  kamo.niigata.jp
  kariwa.niigata.jp
  kashiwazaki.niigata.jp
  minamiuonuma.niigata.jp
  mitsuke.niigata.jp
  muika.niigata.jp
  murakami.niigata.jp
  myoko.niigata.jp
  nagaoka.niigata.jp
  niigata.niigata.jp
  ojiya.niigata.jp
  omi.niigata.jp
  sado.niigata.jp
  sanjo.niigata.jp
  seiro.niigata.jp
  seirou.niigata.jp
  sekikawa.niigata.jp
  shibata.niigata.jp
  tagami.niigata.jp
  tainai.niigata.jp
  tochio.niigata.jp
  tokamachi.niigata.jp
  tsubame.niigata.jp
  tsunan.niigata.jp
  uonuma.niigata.jp
  yahiko.niigata.jp
  yoita.niigata.jp
  yuzawa.niigata.jp
  beppu.oita.jp
  bungoono.oita.jp
  bungotakada.oita.jp
  hasama.oita.jp
  hiji.oita.jp
  himeshima.oita.jp
  hita.oita.jp
  kamitsue.oita.jp
  kokonoe.oita.jp
  kuju.oita.jp
  kunisaki.oita.jp
  kusu.oita.jp
  oita.oita.jp
  saiki.oita.jp
  taketa.oita.jp
  tsukumi.oita.jp
  usa.oita.jp
  usuki.oita.jp
  yufu.oita.jp
  akaiwa.okayama.jp
  asakuchi.okayama.jp
  bizen.okayama.jp
  hayashima.okayama.jp
  ibara.okayama.jp
  kagamino.okayama.jp
  kasaoka.okayama.jp
  kibichuo.okayama.jp
  kumenan.okayama.jp
  kurashiki.okayama.jp
  maniwa.okayama.jp
  misaki.okayama.jp
  nagi.okayama.jp
  niimi.okayama.jp
  nishiawakura.okayama.jp
  okayama.okayama.jp
  satosho.okayama.jp
  setouchi.okayama.jp
  shinjo.okayama.jp
  shoo.okayama.jp
  soja.okayama.jp
  takahashi.okayama.jp
  tamano.okayama.jp
  tsuyama.okayama.jp
  wake.okayama.jp
  yakage.okayama.jp
  aguni.okinawa.jp
  ginowan.okinawa.jp
  ginoza.okinawa.jp
  gushikami.okinawa.jp
  haebaru.okinawa.jp
  higashi.okinawa.jp
  hirara.okinawa.jp
  iheya.okinawa.jp
  ishigaki.okinawa.jp
  ishikawa.okinawa.jp
  itoman.okinawa.jp
  izena.okinawa.jp
  kadena.okinawa.jp
  kin.okinawa.jp
  kitadaito.okinawa.jp
  kitanakagusuku.okinawa.jp
  kumejima.okinawa.jp
  kunigami.okinawa.jp
  minamidaito.okinawa.jp
  motobu.okinawa.jp
  nago.okinawa.jp
  naha.okinawa.jp
  nakagusuku.okinawa.jp
  nakijin.okinawa.jp
  nanjo.okinawa.jp
  nishihara.okinawa.jp
  ogimi.okinawa.jp
  okinawa.okinawa.jp
  onna.okinawa.jp
  shimoji.okinawa.jp
  taketomi.okinawa.jp
  tarama.okinawa.jp
  tokashiki.okinawa.jp
  tomigusuku.okinawa.jp
  tonaki.okinawa.jp
  urasoe.okinawa.jp
  uruma.okinawa.jp
  yaese.okinawa.jp
  yomitan.okinawa.jp
  yonabaru.okinawa.jp
  yonaguni.okinawa.jp
  zamami.okinawa.jp
  abeno.osaka.jp
  chihayaakasaka.osaka.jp
  chuo.osaka.jp
  daito.osaka.jp
  fujiidera.osaka.jp
  habikino.osaka.jp
  hannan.osaka.jp
  higashiosaka.osaka.jp
  higashisumiyoshi.osaka.jp
  higashiyodogawa.osaka.jp
  hirakata.osaka.jp
  ibaraki.osaka.jp
  ikeda.osaka.jp
  izumi.osaka.jp
  izumiotsu.osaka.jp
  izumisano.osaka.jp
  kadoma.osaka.jp
  kaizuka.osaka.jp
  kanan.osaka.jp
  kashiwara.osaka.jp
  katano.osaka.jp
  kawachinagano.osaka.jp
  kishiwada.osaka.jp
  kita.osaka.jp
  kumatori.osaka.jp
  matsubara.osaka.jp
  minato.osaka.jp
  minoh.osaka.jp
  misaki.osaka.jp
  moriguchi.osaka.jp
  neyagawa.osaka.jp
  nishi.osaka.jp
  nose.osaka.jp
  osakasayama.osaka.jp
  sakai.osaka.jp
  sayama.osaka.jp
  sennan.osaka.jp
  settsu.osaka.jp
  shijonawate.osaka.jp
  shimamoto.osaka.jp
  suita.osaka.jp
  tadaoka.osaka.jp
  taishi.osaka.jp
  tajiri.osaka.jp
  takaishi.osaka.jp
  takatsuki.osaka.jp
  tondabayashi.osaka.jp
  toyonaka.osaka.jp
  toyono.osaka.jp
  yao.osaka.jp
  ariake.saga.jp
  arita.saga.jp
  fukudomi.saga.jp
  genkai.saga.jp
  hamatama.saga.jp
  hizen.saga.jp
  imari.saga.jp
  kamimine.saga.jp
  kanzaki.saga.jp
  karatsu.saga.jp
  kashima.saga.jp
  kitagata.saga.jp
  kitahata.saga.jp
  kiyama.saga.jp
  kouhoku.saga.jp
  kyuragi.saga.jp
  nishiarita.saga.jp
  ogi.saga.jp
  omachi.saga.jp
  ouchi.saga.jp
  saga.saga.jp
  shiroishi.saga.jp
  taku.saga.jp
  tara.saga.jp
  tosu.saga.jp
  yoshinogari.saga.jp
  arakawa.saitama.jp
  asaka.saitama.jp
  chichibu.saitama.jp
  fujimi.saitama.jp
  fujimino.saitama.jp
  fukaya.saitama.jp
  hanno.saitama.jp
  hanyu.saitama.jp
  hasuda.saitama.jp
  hatogaya.saitama.jp
  hatoyama.saitama.jp
  hidaka.saitama.jp
  higashichichibu.saitama.jp
  higashimatsuyama.saitama.jp
  honjo.saitama.jp
  ina.saitama.jp
  iruma.saitama.jp
  iwatsuki.saitama.jp
  kamiizumi.saitama.jp
  kamikawa.saitama.jp
  kamisato.saitama.jp
  kasukabe.saitama.jp
  kawagoe.saitama.jp
  kawaguchi.saitama.jp
  kawajima.saitama.jp
  kazo.saitama.jp
  kitamoto.saitama.jp
  koshigaya.saitama.jp
  kounosu.saitama.jp
  kuki.saitama.jp
  kumagaya.saitama.jp
  matsubushi.saitama.jp
  minano.saitama.jp
  misato.saitama.jp
  miyashiro.saitama.jp
  miyoshi.saitama.jp
  moroyama.saitama.jp
  nagatoro.saitama.jp
  namegawa.saitama.jp
  niiza.saitama.jp
  ogano.saitama.jp
  ogawa.saitama.jp
  ogose.saitama.jp
  okegawa.saitama.jp
  omiya.saitama.jp
  otaki.saitama.jp
  ranzan.saitama.jp
  ryokami.saitama.jp
  saitama.saitama.jp
  sakado.saitama.jp
  satte.saitama.jp
  sayama.saitama.jp
  shiki.saitama.jp
  shiraoka.saitama.jp
  soka.saitama.jp
  sugito.saitama.jp
  toda.saitama.jp
  tokigawa.saitama.jp
  tokorozawa.saitama.jp
  tsurugashima.saitama.jp
  urawa.saitama.jp
  warabi.saitama.jp
  yashio.saitama.jp
  yokoze.saitama.jp
  yono.saitama.jp
  yorii.saitama.jp
  yoshida.saitama.jp
  yoshikawa.saitama.jp
  yoshimi.saitama.jp
  aisho.shiga.jp
  gamo.shiga.jp
  higashiomi.shiga.jp
  hikone.shiga.jp
  koka.shiga.jp
  konan.shiga.jp
  kosei.shiga.jp
  koto.shiga.jp
  kusatsu.shiga.jp
  maibara.shiga.jp
  moriyama.shiga.jp
  nagahama.shiga.jp
  nishiazai.shiga.jp
  notogawa.shiga.jp
  omihachiman.shiga.jp
  otsu.shiga.jp
  ritto.shiga.jp
  ryuoh.shiga.jp
  takashima.shiga.jp
  takatsuki.shiga.jp
  torahime.shiga.jp
  toyosato.shiga.jp
  yasu.shiga.jp
  akagi.shimane.jp
  ama.shimane.jp
  gotsu.shimane.jp
  hamada.shimane.jp
  higashiizumo.shimane.jp
  hikawa.shimane.jp
  hikimi.shimane.jp
  izumo.shimane.jp
  kakinoki.shimane.jp
  masuda.shimane.jp
  matsue.shimane.jp
  misato.shimane.jp
  nishinoshima.shimane.jp
  ohda.shimane.jp
  okinoshima.shimane.jp
  okuizumo.shimane.jp
  shimane.shimane.jp
  tamayu.shimane.jp
  tsuwano.shimane.jp
  unnan.shimane.jp
  yakumo.shimane.jp
  yasugi.shimane.jp
  yatsuka.shimane.jp
  arai.shizuoka.jp
  atami.shizuoka.jp
  fuji.shizuoka.jp
  fujieda.shizuoka.jp
  fujikawa.shizuoka.jp
  fujinomiya.shizuoka.jp
  fukuroi.shizuoka.jp
  gotemba.shizuoka.jp
  haibara.shizuoka.jp
  hamamatsu.shizuoka.jp
  higashiizu.shizuoka.jp
  ito.shizuoka.jp
  iwata.shizuoka.jp
  izu.shizuoka.jp
  izunokuni.shizuoka.jp
  kakegawa.shizuoka.jp
  kannami.shizuoka.jp
  kawanehon.shizuoka.jp
  kawazu.shizuoka.jp
  kikugawa.shizuoka.jp
  kosai.shizuoka.jp
  makinohara.shizuoka.jp
  matsuzaki.shizuoka.jp
  minamiizu.shizuoka.jp
  mishima.shizuoka.jp
  morimachi.shizuoka.jp
  nishiizu.shizuoka.jp
  numazu.shizuoka.jp
  omaezaki.shizuoka.jp
  shimada.shizuoka.jp
  shimizu.shizuoka.jp
  shimoda.shizuoka.jp
  shizuoka.shizuoka.jp
  susono.shizuoka.jp
  yaizu.shizuoka.jp
  yoshida.shizuoka.jp
  ashikaga.tochigi.jp
  bato.tochigi.jp
  haga.tochigi.jp
  ichikai.tochigi.jp
  iwafune.tochigi.jp
  kaminokawa.tochigi.jp
  kanuma.tochigi.jp
  karasuyama.tochigi.jp
  kuroiso.tochigi.jp
  mashiko.tochigi.jp
  mibu.tochigi.jp
  moka.tochigi.jp
  motegi.tochigi.jp
  nasu.tochigi.jp
  nasushiobara.tochigi.jp
  nikko.tochigi.jp
  nishikata.tochigi.jp
  nogi.tochigi.jp
  ohira.tochigi.jp
  ohtawara.tochigi.jp
  oyama.tochigi.jp
  sakura.tochigi.jp
  sano.tochigi.jp
  shimotsuke.tochigi.jp
  shioya.tochigi.jp
  takanezawa.tochigi.jp
  tochigi.tochigi.jp
  tsuga.tochigi.jp
  ujiie.tochigi.jp
  utsunomiya.tochigi.jp
  yaita.tochigi.jp
  aizumi.tokushima.jp
  anan.tokushima.jp
  ichiba.tokushima.jp
  itano.tokushima.jp
  kainan.tokushima.jp
  komatsushima.tokushima.jp
  matsushige.tokushima.jp
  mima.tokushima.jp
  minami.tokushima.jp
  miyoshi.tokushima.jp
  mugi.tokushima.jp
  nakagawa.tokushima.jp
  naruto.tokushima.jp
  sanagochi.tokushima.jp
  shishikui.tokushima.jp
  tokushima.tokushima.jp
  wajiki.tokushima.jp
  adachi.tokyo.jp
  akiruno.tokyo.jp
  akishima.tokyo.jp
  aogashima.tokyo.jp
  arakawa.tokyo.jp
  bunkyo.tokyo.jp
  chiyoda.tokyo.jp
  chofu.tokyo.jp
  chuo.tokyo.jp
  edogawa.tokyo.jp
  fuchu.tokyo.jp
  fussa.tokyo.jp
  hachijo.tokyo.jp
  hachioji.tokyo.jp
  hamura.tokyo.jp
  higashikurume.tokyo.jp
  higashimurayama.tokyo.jp
  higashiyamato.tokyo.jp
  hino.tokyo.jp
  hinode.tokyo.jp
  hinohara.tokyo.jp
  inagi.tokyo.jp
  itabashi.tokyo.jp
  katsushika.tokyo.jp
  kita.tokyo.jp
  kiyose.tokyo.jp
  kodaira.tokyo.jp
  koganei.tokyo.jp
  kokubunji.tokyo.jp
  komae.tokyo.jp
  koto.tokyo.jp
  kouzushima.tokyo.jp
  kunitachi.tokyo.jp
  machida.tokyo.jp
  meguro.tokyo.jp
  minato.tokyo.jp
  mitaka.tokyo.jp
  mizuho.tokyo.jp
  musashimurayama.tokyo.jp
  musashino.tokyo.jp
  nakano.tokyo.jp
  nerima.tokyo.jp
  ogasawara.tokyo.jp
  okutama.tokyo.jp
  ome.tokyo.jp
  oshima.tokyo.jp
  ota.tokyo.jp
  setagaya.tokyo.jp
  shibuya.tokyo.jp
  shinagawa.tokyo.jp
  shinjuku.tokyo.jp
  suginami.tokyo.jp
  sumida.tokyo.jp
  tachikawa.tokyo.jp
  taito.tokyo.jp
  tama.tokyo.jp
  toshima.tokyo.jp
  chizu.tottori.jp
  hino.tottori.jp
  kawahara.tottori.jp
  koge.tottori.jp
  kotoura.tottori.jp
  misasa.tottori.jp
  nanbu.tottori.jp
  nichinan.tottori.jp
  sakaiminato.tottori.jp
  tottori.tottori.jp
  wakasa.tottori.jp
  yazu.tottori.jp
  yonago.tottori.jp
  asahi.toyama.jp
  fuchu.toyama.jp
  fukumitsu.toyama.jp
  funahashi.toyama.jp
  himi.toyama.jp
  imizu.toyama.jp
  inami.toyama.jp
  johana.toyama.jp
  kamiichi.toyama.jp
  kurobe.toyama.jp
  nakaniikawa.toyama.jp
  namerikawa.toyama.jp
  nanto.toyama.jp
  nyuzen.toyama.jp
  oyabe.toyama.jp
  taira.toyama.jp
  takaoka.toyama.jp
  tateyama.toyama.jp
  toga.toyama.jp
  tonami.toyama.jp
  toyama.toyama.jp
  unazuki.toyama.jp
  uozu.toyama.jp
  yamada.toyama.jp
  arida.wakayama.jp
  aridagawa.wakayama.jp
  gobo.wakayama.jp
  hashimoto.wakayama.jp
  hidaka.wakayama.jp
  hirogawa.wakayama.jp
  inami.wakayama.jp
  iwade.wakayama.jp
  kainan.wakayama.jp
  kamitonda.wakayama.jp
  katsuragi.wakayama.jp
  kimino.wakayama.jp
  kinokawa.wakayama.jp
  kitayama.wakayama.jp
  koya.wakayama.jp
  koza.wakayama.jp
  kozagawa.wakayama.jp
  kudoyama.wakayama.jp
  kushimoto.wakayama.jp
  mihama.wakayama.jp
  misato.wakayama.jp
  nachikatsuura.wakayama.jp
  shingu.wakayama.jp
  shirahama.wakayama.jp
  taiji.wakayama.jp
  tanabe.wakayama.jp
  wakayama.wakayama.jp
  yuasa.wakayama.jp
  yura.wakayama.jp
  asahi.yamagata.jp
  funagata.yamagata.jp
  higashine.yamagata.jp
  iide.yamagata.jp
  kahoku.yamagata.jp
  kaminoyama.yamagata.jp
  kaneyama.yamagata.jp
  kawanishi.yamagata.jp
  mamurogawa.yamagata.jp
  mikawa.yamagata.jp
  murayama.yamagata.jp
  nagai.yamagata.jp
  nakayama.yamagata.jp
  nanyo.yamagata.jp
  nishikawa.yamagata.jp
  obanazawa.yamagata.jp
  oe.yamagata.jp
  oguni.yamagata.jp
  ohkura.yamagata.jp
  oishida.yamagata.jp
  sagae.yamagata.jp
  sakata.yamagata.jp
  sakegawa.yamagata.jp
  shinjo.yamagata.jp
  shirataka.yamagata.jp
  shonai.yamagata.jp
  takahata.yamagata.jp
  tendo.yamagata.jp
  tozawa.yamagata.jp
  tsuruoka.yamagata.jp
  yamagata.yamagata.jp
  yamanobe.yamagata.jp
  yonezawa.yamagata.jp
  yuza.yamagata.jp
  abu.yamaguchi.jp
  hagi.yamaguchi.jp
  hikari.yamaguchi.jp
  hofu.yamaguchi.jp
  iwakuni.yamaguchi.jp
  kudamatsu.yamaguchi.jp
  mitou.yamaguchi.jp
  nagato.yamaguchi.jp
  oshima.yamaguchi.jp
  shimonoseki.yamaguchi.jp
  shunan.yamaguchi.jp
  tabuse.yamaguchi.jp
  tokuyama.yamaguchi.jp
  toyota.yamaguchi.jp
  ube.yamaguchi.jp
  yuu.yamaguchi.jp
  chuo.yamanashi.jp
  doshi.yamanashi.jp
  fuefuki.yamanashi.jp
  fujikawa.yamanashi.jp
  fujikawaguchiko.yamanashi.jp
  fujiyoshida.yamanashi.jp
  hayakawa.yamanashi.jp
  hokuto.yamanashi.jp
  ichikawamisato.yamanashi.jp
  kai.yamanashi.jp
  kofu.yamanashi.jp
  koshu.yamanashi.jp
  kosuge.yamanashi.jp
  minami-alps.yamanashi.jp
  minobu.yamanashi.jp
  nakamichi.yamanashi.jp
  nanbu.yamanashi.jp
  narusawa.yamanashi.jp
  nirasaki.yamanashi.jp
  nishikatsura.yamanashi.jp
  oshino.yamanashi.jp
  otsuki.yamanashi.jp
  showa.yamanashi.jp
  tabayama.yamanashi.jp
  tsuru.yamanashi.jp
  uenohara.yamanashi.jp
  yamanakako.yamanashi.jp
  yamanashi.yamanashi.jp
  
  // ke : http://www.kenic.or.ke/index.php/en/ke-domains/ke-domains
  ke
  ac.ke
  co.ke
  go.ke
  info.ke
  me.ke
  mobi.ke
  ne.ke
  or.ke
  sc.ke
  
  // kg : http://www.domain.kg/dmn_n.html
  kg
  org.kg
  net.kg
  com.kg
  edu.kg
  gov.kg
  mil.kg
  
  // kh : http://www.mptc.gov.kh/dns_registration.htm
  *.kh
  
  // ki : http://www.ki/dns/index.html
  ki
  edu.ki
  biz.ki
  net.ki
  org.ki
  gov.ki
  info.ki
  com.ki
  
  // km : https://en.wikipedia.org/wiki/.km
  // http://www.domaine.km/documents/charte.doc
  km
  org.km
  nom.km
  gov.km
  prd.km
  tm.km
  edu.km
  mil.km
  ass.km
  com.km
  // These are only mentioned as proposed suggestions at domaine.km, but
  // https://en.wikipedia.org/wiki/.km says they're available for registration:
  coop.km
  asso.km
  presse.km
  medecin.km
  notaires.km
  pharmaciens.km
  veterinaire.km
  gouv.km
  
  // kn : https://en.wikipedia.org/wiki/.kn
  // http://www.dot.kn/domainRules.html
  kn
  net.kn
  org.kn
  edu.kn
  gov.kn
  
  // kp : http://www.kcce.kp/en_index.php
  kp
  com.kp
  edu.kp
  gov.kp
  org.kp
  rep.kp
  tra.kp
  
  // kr : https://en.wikipedia.org/wiki/.kr
  // see also: http://domain.nida.or.kr/eng/registration.jsp
  kr
  ac.kr
  co.kr
  es.kr
  go.kr
  hs.kr
  kg.kr
  mil.kr
  ms.kr
  ne.kr
  or.kr
  pe.kr
  re.kr
  sc.kr
  // kr geographical names
  busan.kr
  chungbuk.kr
  chungnam.kr
  daegu.kr
  daejeon.kr
  gangwon.kr
  gwangju.kr
  gyeongbuk.kr
  gyeonggi.kr
  gyeongnam.kr
  incheon.kr
  jeju.kr
  jeonbuk.kr
  jeonnam.kr
  seoul.kr
  ulsan.kr
  
  // kw : https://en.wikipedia.org/wiki/.kw
  *.kw
  
  // ky : http://www.icta.ky/da_ky_reg_dom.php
  // Confirmed by registry <kysupport@perimeterusa.com> 2008-06-17
  ky
  edu.ky
  gov.ky
  com.ky
  org.ky
  net.ky
  
  // kz : https://en.wikipedia.org/wiki/.kz
  // see also: http://www.nic.kz/rules/index.jsp
  kz
  org.kz
  edu.kz
  net.kz
  gov.kz
  mil.kz
  com.kz
  
  // la : https://en.wikipedia.org/wiki/.la
  // Submitted by registry <gavin.brown@nic.la>
  la
  int.la
  net.la
  info.la
  edu.la
  gov.la
  per.la
  com.la
  org.la
  
  // lb : https://en.wikipedia.org/wiki/.lb
  // Submitted by registry <randy@psg.com>
  lb
  com.lb
  edu.lb
  gov.lb
  net.lb
  org.lb
  
  // lc : https://en.wikipedia.org/wiki/.lc
  // see also: http://www.nic.lc/rules.htm
  lc
  com.lc
  net.lc
  co.lc
  org.lc
  edu.lc
  gov.lc
  
  // li : https://en.wikipedia.org/wiki/.li
  li
  
  // lk : http://www.nic.lk/seclevpr.html
  lk
  gov.lk
  sch.lk
  net.lk
  int.lk
  com.lk
  org.lk
  edu.lk
  ngo.lk
  soc.lk
  web.lk
  ltd.lk
  assn.lk
  grp.lk
  hotel.lk
  ac.lk
  
  // lr : http://psg.com/dns/lr/lr.txt
  // Submitted by registry <randy@psg.com>
  lr
  com.lr
  edu.lr
  gov.lr
  org.lr
  net.lr
  
  // ls : https://en.wikipedia.org/wiki/.ls
  ls
  co.ls
  org.ls
  
  // lt : https://en.wikipedia.org/wiki/.lt
  lt
  // gov.lt : http://www.gov.lt/index_en.php
  gov.lt
  
  // lu : http://www.dns.lu/en/
  lu
  
  // lv : http://www.nic.lv/DNS/En/generic.php
  lv
  com.lv
  edu.lv
  gov.lv
  org.lv
  mil.lv
  id.lv
  net.lv
  asn.lv
  conf.lv
  
  // ly : http://www.nic.ly/regulations.php
  ly
  com.ly
  net.ly
  gov.ly
  plc.ly
  edu.ly
  sch.ly
  med.ly
  org.ly
  id.ly
  
  // ma : https://en.wikipedia.org/wiki/.ma
  // http://www.anrt.ma/fr/admin/download/upload/file_fr782.pdf
  ma
  co.ma
  net.ma
  gov.ma
  org.ma
  ac.ma
  press.ma
  
  // mc : http://www.nic.mc/
  mc
  tm.mc
  asso.mc
  
  // md : https://en.wikipedia.org/wiki/.md
  md
  
  // me : https://en.wikipedia.org/wiki/.me
  me
  co.me
  net.me
  org.me
  edu.me
  ac.me
  gov.me
  its.me
  priv.me
  
  // mg : http://nic.mg/nicmg/?page_id=39
  mg
  org.mg
  nom.mg
  gov.mg
  prd.mg
  tm.mg
  edu.mg
  mil.mg
  com.mg
  co.mg
  
  // mh : https://en.wikipedia.org/wiki/.mh
  mh
  
  // mil : https://en.wikipedia.org/wiki/.mil
  mil
  
  // mk : https://en.wikipedia.org/wiki/.mk
  // see also: http://dns.marnet.net.mk/postapka.php
  mk
  com.mk
  org.mk
  net.mk
  edu.mk
  gov.mk
  inf.mk
  name.mk
  
  // ml : http://www.gobin.info/domainname/ml-template.doc
  // see also: https://en.wikipedia.org/wiki/.ml
  ml
  com.ml
  edu.ml
  gouv.ml
  gov.ml
  net.ml
  org.ml
  presse.ml
  
  // mm : https://en.wikipedia.org/wiki/.mm
  *.mm
  
  // mn : https://en.wikipedia.org/wiki/.mn
  mn
  gov.mn
  edu.mn
  org.mn
  
  // mo : http://www.monic.net.mo/
  mo
  com.mo
  net.mo
  org.mo
  edu.mo
  gov.mo
  
  // mobi : https://en.wikipedia.org/wiki/.mobi
  mobi
  
  // mp : http://www.dot.mp/
  // Confirmed by registry <dcamacho@saipan.com> 2008-06-17
  mp
  
  // mq : https://en.wikipedia.org/wiki/.mq
  mq
  
  // mr : https://en.wikipedia.org/wiki/.mr
  mr
  gov.mr
  
  // ms : http://www.nic.ms/pdf/MS_Domain_Name_Rules.pdf
  ms
  com.ms
  edu.ms
  gov.ms
  net.ms
  org.ms
  
  // mt : https://www.nic.org.mt/go/policy
  // Submitted by registry <help@nic.org.mt>
  mt
  com.mt
  edu.mt
  net.mt
  org.mt
  
  // mu : https://en.wikipedia.org/wiki/.mu
  mu
  com.mu
  net.mu
  org.mu
  gov.mu
  ac.mu
  co.mu
  or.mu
  
  // museum : http://about.museum/naming/
  // http://index.museum/
  museum
  academy.museum
  agriculture.museum
  air.museum
  airguard.museum
  alabama.museum
  alaska.museum
  amber.museum
  ambulance.museum
  american.museum
  americana.museum
  americanantiques.museum
  americanart.museum
  amsterdam.museum
  and.museum
  annefrank.museum
  anthro.museum
  anthropology.museum
  antiques.museum
  aquarium.museum
  arboretum.museum
  archaeological.museum
  archaeology.museum
  architecture.museum
  art.museum
  artanddesign.museum
  artcenter.museum
  artdeco.museum
  arteducation.museum
  artgallery.museum
  arts.museum
  artsandcrafts.museum
  asmatart.museum
  assassination.museum
  assisi.museum
  association.museum
  astronomy.museum
  atlanta.museum
  austin.museum
  australia.museum
  automotive.museum
  aviation.museum
  axis.museum
  badajoz.museum
  baghdad.museum
  bahn.museum
  bale.museum
  baltimore.museum
  barcelona.museum
  baseball.museum
  basel.museum
  baths.museum
  bauern.museum
  beauxarts.museum
  beeldengeluid.museum
  bellevue.museum
  bergbau.museum
  berkeley.museum
  berlin.museum
  bern.museum
  bible.museum
  bilbao.museum
  bill.museum
  birdart.museum
  birthplace.museum
  bonn.museum
  boston.museum
  botanical.museum
  botanicalgarden.museum
  botanicgarden.museum
  botany.museum
  brandywinevalley.museum
  brasil.museum
  bristol.museum
  british.museum
  britishcolumbia.museum
  broadcast.museum
  brunel.museum
  brussel.museum
  brussels.museum
  bruxelles.museum
  building.museum
  burghof.museum
  bus.museum
  bushey.museum
  cadaques.museum
  california.museum
  cambridge.museum
  can.museum
  canada.museum
  capebreton.museum
  carrier.museum
  cartoonart.museum
  casadelamoneda.museum
  castle.museum
  castres.museum
  celtic.museum
  center.museum
  chattanooga.museum
  cheltenham.museum
  chesapeakebay.museum
  chicago.museum
  children.museum
  childrens.museum
  childrensgarden.museum
  chiropractic.museum
  chocolate.museum
  christiansburg.museum
  cincinnati.museum
  cinema.museum
  circus.museum
  civilisation.museum
  civilization.museum
  civilwar.museum
  clinton.museum
  clock.museum
  coal.museum
  coastaldefence.museum
  cody.museum
  coldwar.museum
  collection.museum
  colonialwilliamsburg.museum
  coloradoplateau.museum
  columbia.museum
  columbus.museum
  communication.museum
  communications.museum
  community.museum
  computer.museum
  computerhistory.museum
  xn--comunicaes-v6a2o.museum
  contemporary.museum
  contemporaryart.museum
  convent.museum
  copenhagen.museum
  corporation.museum
  xn--correios-e-telecomunicaes-ghc29a.museum
  corvette.museum
  costume.museum
  countryestate.museum
  county.museum
  crafts.museum
  cranbrook.museum
  creation.museum
  cultural.museum
  culturalcenter.museum
  culture.museum
  cyber.museum
  cymru.museum
  dali.museum
  dallas.museum
  database.museum
  ddr.museum
  decorativearts.museum
  delaware.museum
  delmenhorst.museum
  denmark.museum
  depot.museum
  design.museum
  detroit.museum
  dinosaur.museum
  discovery.museum
  dolls.museum
  donostia.museum
  durham.museum
  eastafrica.museum
  eastcoast.museum
  education.museum
  educational.museum
  egyptian.museum
  eisenbahn.museum
  elburg.museum
  elvendrell.museum
  embroidery.museum
  encyclopedic.museum
  england.museum
  entomology.museum
  environment.museum
  environmentalconservation.museum
  epilepsy.museum
  essex.museum
  estate.museum
  ethnology.museum
  exeter.museum
  exhibition.museum
  family.museum
  farm.museum
  farmequipment.museum
  farmers.museum
  farmstead.museum
  field.museum
  figueres.museum
  filatelia.museum
  film.museum
  fineart.museum
  finearts.museum
  finland.museum
  flanders.museum
  florida.museum
  force.museum
  fortmissoula.museum
  fortworth.museum
  foundation.museum
  francaise.museum
  frankfurt.museum
  franziskaner.museum
  freemasonry.museum
  freiburg.museum
  fribourg.museum
  frog.museum
  fundacio.museum
  furniture.museum
  gallery.museum
  garden.museum
  gateway.museum
  geelvinck.museum
  gemological.museum
  geology.museum
  georgia.museum
  giessen.museum
  glas.museum
  glass.museum
  gorge.museum
  grandrapids.museum
  graz.museum
  guernsey.museum
  halloffame.museum
  hamburg.museum
  handson.museum
  harvestcelebration.museum
  hawaii.museum
  health.museum
  heimatunduhren.museum
  hellas.museum
  helsinki.museum
  hembygdsforbund.museum
  heritage.museum
  histoire.museum
  historical.museum
  historicalsociety.museum
  historichouses.museum
  historisch.museum
  historisches.museum
  history.museum
  historyofscience.museum
  horology.museum
  house.museum
  humanities.museum
  illustration.museum
  imageandsound.museum
  indian.museum
  indiana.museum
  indianapolis.museum
  indianmarket.museum
  intelligence.museum
  interactive.museum
  iraq.museum
  iron.museum
  isleofman.museum
  jamison.museum
  jefferson.museum
  jerusalem.museum
  jewelry.museum
  jewish.museum
  jewishart.museum
  jfk.museum
  journalism.museum
  judaica.museum
  judygarland.museum
  juedisches.museum
  juif.museum
  karate.museum
  karikatur.museum
  kids.museum
  koebenhavn.museum
  koeln.museum
  kunst.museum
  kunstsammlung.museum
  kunstunddesign.museum
  labor.museum
  labour.museum
  lajolla.museum
  lancashire.museum
  landes.museum
  lans.museum
  xn--lns-qla.museum
  larsson.museum
  lewismiller.museum
  lincoln.museum
  linz.museum
  living.museum
  livinghistory.museum
  localhistory.museum
  london.museum
  losangeles.museum
  louvre.museum
  loyalist.museum
  lucerne.museum
  luxembourg.museum
  luzern.museum
  mad.museum
  madrid.museum
  mallorca.museum
  manchester.museum
  mansion.museum
  mansions.museum
  manx.museum
  marburg.museum
  maritime.museum
  maritimo.museum
  maryland.museum
  marylhurst.museum
  media.museum
  medical.museum
  medizinhistorisches.museum
  meeres.museum
  memorial.museum
  mesaverde.museum
  michigan.museum
  midatlantic.museum
  military.museum
  mill.museum
  miners.museum
  mining.museum
  minnesota.museum
  missile.museum
  missoula.museum
  modern.museum
  moma.museum
  money.museum
  monmouth.museum
  monticello.museum
  montreal.museum
  moscow.museum
  motorcycle.museum
  muenchen.museum
  muenster.museum
  mulhouse.museum
  muncie.museum
  museet.museum
  museumcenter.museum
  museumvereniging.museum
  music.museum
  national.museum
  nationalfirearms.museum
  nationalheritage.museum
  nativeamerican.museum
  naturalhistory.museum
  naturalhistorymuseum.museum
  naturalsciences.museum
  nature.museum
  naturhistorisches.museum
  natuurwetenschappen.museum
  naumburg.museum
  naval.museum
  nebraska.museum
  neues.museum
  newhampshire.museum
  newjersey.museum
  newmexico.museum
  newport.museum
  newspaper.museum
  newyork.museum
  niepce.museum
  norfolk.museum
  north.museum
  nrw.museum
  nuernberg.museum
  nuremberg.museum
  nyc.museum
  nyny.museum
  oceanographic.museum
  oceanographique.museum
  omaha.museum
  online.museum
  ontario.museum
  openair.museum
  oregon.museum
  oregontrail.museum
  otago.museum
  oxford.museum
  pacific.museum
  paderborn.museum
  palace.museum
  paleo.museum
  palmsprings.museum
  panama.museum
  paris.museum
  pasadena.museum
  pharmacy.museum
  philadelphia.museum
  philadelphiaarea.museum
  philately.museum
  phoenix.museum
  photography.museum
  pilots.museum
  pittsburgh.museum
  planetarium.museum
  plantation.museum
  plants.museum
  plaza.museum
  portal.museum
  portland.museum
  portlligat.museum
  posts-and-telecommunications.museum
  preservation.museum
  presidio.museum
  press.museum
  project.museum
  public.museum
  pubol.museum
  quebec.museum
  railroad.museum
  railway.museum
  research.museum
  resistance.museum
  riodejaneiro.museum
  rochester.museum
  rockart.museum
  roma.museum
  russia.museum
  saintlouis.museum
  salem.museum
  salvadordali.museum
  salzburg.museum
  sandiego.museum
  sanfrancisco.museum
  santabarbara.museum
  santacruz.museum
  santafe.museum
  saskatchewan.museum
  satx.museum
  savannahga.museum
  schlesisches.museum
  schoenbrunn.museum
  schokoladen.museum
  school.museum
  schweiz.museum
  science.museum
  scienceandhistory.museum
  scienceandindustry.museum
  sciencecenter.museum
  sciencecenters.museum
  science-fiction.museum
  sciencehistory.museum
  sciences.museum
  sciencesnaturelles.museum
  scotland.museum
  seaport.museum
  settlement.museum
  settlers.museum
  shell.museum
  sherbrooke.museum
  sibenik.museum
  silk.museum
  ski.museum
  skole.museum
  society.museum
  sologne.museum
  soundandvision.museum
  southcarolina.museum
  southwest.museum
  space.museum
  spy.museum
  square.museum
  stadt.museum
  stalbans.museum
  starnberg.museum
  state.museum
  stateofdelaware.museum
  station.museum
  steam.museum
  steiermark.museum
  stjohn.museum
  stockholm.museum
  stpetersburg.museum
  stuttgart.museum
  suisse.museum
  surgeonshall.museum
  surrey.museum
  svizzera.museum
  sweden.museum
  sydney.museum
  tank.museum
  tcm.museum
  technology.museum
  telekommunikation.museum
  television.museum
  texas.museum
  textile.museum
  theater.museum
  time.museum
  timekeeping.museum
  topology.museum
  torino.museum
  touch.museum
  town.museum
  transport.museum
  tree.museum
  trolley.museum
  trust.museum
  trustee.museum
  uhren.museum
  ulm.museum
  undersea.museum
  university.museum
  usa.museum
  usantiques.museum
  usarts.museum
  uscountryestate.museum
  usculture.museum
  usdecorativearts.museum
  usgarden.museum
  ushistory.museum
  ushuaia.museum
  uslivinghistory.museum
  utah.museum
  uvic.museum
  valley.museum
  vantaa.museum
  versailles.museum
  viking.museum
  village.museum
  virginia.museum
  virtual.museum
  virtuel.museum
  vlaanderen.museum
  volkenkunde.museum
  wales.museum
  wallonie.museum
  war.museum
  washingtondc.museum
  watchandclock.museum
  watch-and-clock.museum
  western.museum
  westfalen.museum
  whaling.museum
  wildlife.museum
  williamsburg.museum
  windmill.museum
  workshop.museum
  york.museum
  yorkshire.museum
  yosemite.museum
  youth.museum
  zoological.museum
  zoology.museum
  xn--9dbhblg6di.museum
  xn--h1aegh.museum
  
  // mv : https://en.wikipedia.org/wiki/.mv
  // "mv" included because, contra Wikipedia, google.mv exists.
  mv
  aero.mv
  biz.mv
  com.mv
  coop.mv
  edu.mv
  gov.mv
  info.mv
  int.mv
  mil.mv
  museum.mv
  name.mv
  net.mv
  org.mv
  pro.mv
  
  // mw : http://www.registrar.mw/
  mw
  ac.mw
  biz.mw
  co.mw
  com.mw
  coop.mw
  edu.mw
  gov.mw
  int.mw
  museum.mw
  net.mw
  org.mw
  
  // mx : http://www.nic.mx/
  // Submitted by registry <farias@nic.mx>
  mx
  com.mx
  org.mx
  gob.mx
  edu.mx
  net.mx
  
  // my : http://www.mynic.net.my/
  my
  com.my
  net.my
  org.my
  gov.my
  edu.my
  mil.my
  name.my
  
  // mz : http://www.uem.mz/
  // Submitted by registry <antonio@uem.mz>
  mz
  ac.mz
  adv.mz
  co.mz
  edu.mz
  gov.mz
  mil.mz
  net.mz
  org.mz
  
  // na : http://www.na-nic.com.na/
  // http://www.info.na/domain/
  na
  info.na
  pro.na
  name.na
  school.na
  or.na
  dr.na
  us.na
  mx.na
  ca.na
  in.na
  cc.na
  tv.na
  ws.na
  mobi.na
  co.na
  com.na
  org.na
  
  // name : has 2nd-level tlds, but there's no list of them
  name
  
  // nc : http://www.cctld.nc/
  nc
  asso.nc
  nom.nc
  
  // ne : https://en.wikipedia.org/wiki/.ne
  ne
  
  // net : https://en.wikipedia.org/wiki/.net
  net
  
  // nf : https://en.wikipedia.org/wiki/.nf
  nf
  com.nf
  net.nf
  per.nf
  rec.nf
  web.nf
  arts.nf
  firm.nf
  info.nf
  other.nf
  store.nf
  
  // ng : http://www.nira.org.ng/index.php/join-us/register-ng-domain/189-nira-slds
  ng
  com.ng
  edu.ng
  gov.ng
  i.ng
  mil.ng
  mobi.ng
  name.ng
  net.ng
  org.ng
  sch.ng
  
  // ni : http://www.nic.ni/
  ni
  ac.ni
  biz.ni
  co.ni
  com.ni
  edu.ni
  gob.ni
  in.ni
  info.ni
  int.ni
  mil.ni
  net.ni
  nom.ni
  org.ni
  web.ni
  
  // nl : https://en.wikipedia.org/wiki/.nl
  //      https://www.sidn.nl/
  //      ccTLD for the Netherlands
  nl
  
  // BV.nl will be a registry for dutch BV's (besloten vennootschap)
  bv.nl
  
  // no : http://www.norid.no/regelverk/index.en.html
  // The Norwegian registry has declined to notify us of updates. The web pages
  // referenced below are the official source of the data. There is also an
  // announce mailing list:
  // https://postlister.uninett.no/sympa/info/norid-diskusjon
  no
  // Norid generic domains : http://www.norid.no/regelverk/vedlegg-c.en.html
  fhs.no
  vgs.no
  fylkesbibl.no
  folkebibl.no
  museum.no
  idrett.no
  priv.no
  // Non-Norid generic domains : http://www.norid.no/regelverk/vedlegg-d.en.html
  mil.no
  stat.no
  dep.no
  kommune.no
  herad.no
  // no geographical names : http://www.norid.no/regelverk/vedlegg-b.en.html
  // counties
  aa.no
  ah.no
  bu.no
  fm.no
  hl.no
  hm.no
  jan-mayen.no
  mr.no
  nl.no
  nt.no
  of.no
  ol.no
  oslo.no
  rl.no
  sf.no
  st.no
  svalbard.no
  tm.no
  tr.no
  va.no
  vf.no
  // primary and lower secondary schools per county
  gs.aa.no
  gs.ah.no
  gs.bu.no
  gs.fm.no
  gs.hl.no
  gs.hm.no
  gs.jan-mayen.no
  gs.mr.no
  gs.nl.no
  gs.nt.no
  gs.of.no
  gs.ol.no
  gs.oslo.no
  gs.rl.no
  gs.sf.no
  gs.st.no
  gs.svalbard.no
  gs.tm.no
  gs.tr.no
  gs.va.no
  gs.vf.no
  // cities
  akrehamn.no
  xn--krehamn-dxa.no
  algard.no
  xn--lgrd-poac.no
  arna.no
  brumunddal.no
  bryne.no
  bronnoysund.no
  xn--brnnysund-m8ac.no
  drobak.no
  xn--drbak-wua.no
  egersund.no
  fetsund.no
  floro.no
  xn--flor-jra.no
  fredrikstad.no
  hokksund.no
  honefoss.no
  xn--hnefoss-q1a.no
  jessheim.no
  jorpeland.no
  xn--jrpeland-54a.no
  kirkenes.no
  kopervik.no
  krokstadelva.no
  langevag.no
  xn--langevg-jxa.no
  leirvik.no
  mjondalen.no
  xn--mjndalen-64a.no
  mo-i-rana.no
  mosjoen.no
  xn--mosjen-eya.no
  nesoddtangen.no
  orkanger.no
  osoyro.no
  xn--osyro-wua.no
  raholt.no
  xn--rholt-mra.no
  sandnessjoen.no
  xn--sandnessjen-ogb.no
  skedsmokorset.no
  slattum.no
  spjelkavik.no
  stathelle.no
  stavern.no
  stjordalshalsen.no
  xn--stjrdalshalsen-sqb.no
  tananger.no
  tranby.no
  vossevangen.no
  // communities
  afjord.no
  xn--fjord-lra.no
  agdenes.no
  al.no
  xn--l-1fa.no
  alesund.no
  xn--lesund-hua.no
  alstahaug.no
  alta.no
  xn--lt-liac.no
  alaheadju.no
  xn--laheadju-7ya.no
  alvdal.no
  amli.no
  xn--mli-tla.no
  amot.no
  xn--mot-tla.no
  andebu.no
  andoy.no
  xn--andy-ira.no
  andasuolo.no
  ardal.no
  xn--rdal-poa.no
  aremark.no
  arendal.no
  xn--s-1fa.no
  aseral.no
  xn--seral-lra.no
  asker.no
  askim.no
  askvoll.no
  askoy.no
  xn--asky-ira.no
  asnes.no
  xn--snes-poa.no
  audnedaln.no
  aukra.no
  aure.no
  aurland.no
  aurskog-holand.no
  xn--aurskog-hland-jnb.no
  austevoll.no
  austrheim.no
  averoy.no
  xn--avery-yua.no
  balestrand.no
  ballangen.no
  balat.no
  xn--blt-elab.no
  balsfjord.no
  bahccavuotna.no
  xn--bhccavuotna-k7a.no
  bamble.no
  bardu.no
  beardu.no
  beiarn.no
  bajddar.no
  xn--bjddar-pta.no
  baidar.no
  xn--bidr-5nac.no
  berg.no
  bergen.no
  berlevag.no
  xn--berlevg-jxa.no
  bearalvahki.no
  xn--bearalvhki-y4a.no
  bindal.no
  birkenes.no
  bjarkoy.no
  xn--bjarky-fya.no
  bjerkreim.no
  bjugn.no
  bodo.no
  xn--bod-2na.no
  badaddja.no
  xn--bdddj-mrabd.no
  budejju.no
  bokn.no
  bremanger.no
  bronnoy.no
  xn--brnny-wuac.no
  bygland.no
  bykle.no
  barum.no
  xn--brum-voa.no
  bo.telemark.no
  xn--b-5ga.telemark.no
  bo.nordland.no
  xn--b-5ga.nordland.no
  bievat.no
  xn--bievt-0qa.no
  bomlo.no
  xn--bmlo-gra.no
  batsfjord.no
  xn--btsfjord-9za.no
  bahcavuotna.no
  xn--bhcavuotna-s4a.no
  dovre.no
  drammen.no
  drangedal.no
  dyroy.no
  xn--dyry-ira.no
  donna.no
  xn--dnna-gra.no
  eid.no
  eidfjord.no
  eidsberg.no
  eidskog.no
  eidsvoll.no
  eigersund.no
  elverum.no
  enebakk.no
  engerdal.no
  etne.no
  etnedal.no
  evenes.no
  evenassi.no
  xn--eveni-0qa01ga.no
  evje-og-hornnes.no
  farsund.no
  fauske.no
  fuossko.no
  fuoisku.no
  fedje.no
  fet.no
  finnoy.no
  xn--finny-yua.no
  fitjar.no
  fjaler.no
  fjell.no
  flakstad.no
  flatanger.no
  flekkefjord.no
  flesberg.no
  flora.no
  fla.no
  xn--fl-zia.no
  folldal.no
  forsand.no
  fosnes.no
  frei.no
  frogn.no
  froland.no
  frosta.no
  frana.no
  xn--frna-woa.no
  froya.no
  xn--frya-hra.no
  fusa.no
  fyresdal.no
  forde.no
  xn--frde-gra.no
  gamvik.no
  gangaviika.no
  xn--ggaviika-8ya47h.no
  gaular.no
  gausdal.no
  gildeskal.no
  xn--gildeskl-g0a.no
  giske.no
  gjemnes.no
  gjerdrum.no
  gjerstad.no
  gjesdal.no
  gjovik.no
  xn--gjvik-wua.no
  gloppen.no
  gol.no
  gran.no
  grane.no
  granvin.no
  gratangen.no
  grimstad.no
  grong.no
  kraanghke.no
  xn--kranghke-b0a.no
  grue.no
  gulen.no
  hadsel.no
  halden.no
  halsa.no
  hamar.no
  hamaroy.no
  habmer.no
  xn--hbmer-xqa.no
  hapmir.no
  xn--hpmir-xqa.no
  hammerfest.no
  hammarfeasta.no
  xn--hmmrfeasta-s4ac.no
  haram.no
  hareid.no
  harstad.no
  hasvik.no
  aknoluokta.no
  xn--koluokta-7ya57h.no
  hattfjelldal.no
  aarborte.no
  haugesund.no
  hemne.no
  hemnes.no
  hemsedal.no
  heroy.more-og-romsdal.no
  xn--hery-ira.xn--mre-og-romsdal-qqb.no
  heroy.nordland.no
  xn--hery-ira.nordland.no
  hitra.no
  hjartdal.no
  hjelmeland.no
  hobol.no
  xn--hobl-ira.no
  hof.no
  hol.no
  hole.no
  holmestrand.no
  holtalen.no
  xn--holtlen-hxa.no
  hornindal.no
  horten.no
  hurdal.no
  hurum.no
  hvaler.no
  hyllestad.no
  hagebostad.no
  xn--hgebostad-g3a.no
  hoyanger.no
  xn--hyanger-q1a.no
  hoylandet.no
  xn--hylandet-54a.no
  ha.no
  xn--h-2fa.no
  ibestad.no
  inderoy.no
  xn--indery-fya.no
  iveland.no
  jevnaker.no
  jondal.no
  jolster.no
  xn--jlster-bya.no
  karasjok.no
  karasjohka.no
  xn--krjohka-hwab49j.no
  karlsoy.no
  galsa.no
  xn--gls-elac.no
  karmoy.no
  xn--karmy-yua.no
  kautokeino.no
  guovdageaidnu.no
  klepp.no
  klabu.no
  xn--klbu-woa.no
  kongsberg.no
  kongsvinger.no
  kragero.no
  xn--krager-gya.no
  kristiansand.no
  kristiansund.no
  krodsherad.no
  xn--krdsherad-m8a.no
  kvalsund.no
  rahkkeravju.no
  xn--rhkkervju-01af.no
  kvam.no
  kvinesdal.no
  kvinnherad.no
  kviteseid.no
  kvitsoy.no
  xn--kvitsy-fya.no
  kvafjord.no
  xn--kvfjord-nxa.no
  giehtavuoatna.no
  kvanangen.no
  xn--kvnangen-k0a.no
  navuotna.no
  xn--nvuotna-hwa.no
  kafjord.no
  xn--kfjord-iua.no
  gaivuotna.no
  xn--givuotna-8ya.no
  larvik.no
  lavangen.no
  lavagis.no
  loabat.no
  xn--loabt-0qa.no
  lebesby.no
  davvesiida.no
  leikanger.no
  leirfjord.no
  leka.no
  leksvik.no
  lenvik.no
  leangaviika.no
  xn--leagaviika-52b.no
  lesja.no
  levanger.no
  lier.no
  lierne.no
  lillehammer.no
  lillesand.no
  lindesnes.no
  lindas.no
  xn--linds-pra.no
  lom.no
  loppa.no
  lahppi.no
  xn--lhppi-xqa.no
  lund.no
  lunner.no
  luroy.no
  xn--lury-ira.no
  luster.no
  lyngdal.no
  lyngen.no
  ivgu.no
  lardal.no
  lerdal.no
  xn--lrdal-sra.no
  lodingen.no
  xn--ldingen-q1a.no
  lorenskog.no
  xn--lrenskog-54a.no
  loten.no
  xn--lten-gra.no
  malvik.no
  masoy.no
  xn--msy-ula0h.no
  muosat.no
  xn--muost-0qa.no
  mandal.no
  marker.no
  marnardal.no
  masfjorden.no
  meland.no
  meldal.no
  melhus.no
  meloy.no
  xn--mely-ira.no
  meraker.no
  xn--merker-kua.no
  moareke.no
  xn--moreke-jua.no
  midsund.no
  midtre-gauldal.no
  modalen.no
  modum.no
  molde.no
  moskenes.no
  moss.no
  mosvik.no
  malselv.no
  xn--mlselv-iua.no
  malatvuopmi.no
  xn--mlatvuopmi-s4a.no
  namdalseid.no
  aejrie.no
  namsos.no
  namsskogan.no
  naamesjevuemie.no
  xn--nmesjevuemie-tcba.no
  laakesvuemie.no
  nannestad.no
  narvik.no
  narviika.no
  naustdal.no
  nedre-eiker.no
  nes.akershus.no
  nes.buskerud.no
  nesna.no
  nesodden.no
  nesseby.no
  unjarga.no
  xn--unjrga-rta.no
  nesset.no
  nissedal.no
  nittedal.no
  nord-aurdal.no
  nord-fron.no
  nord-odal.no
  norddal.no
  nordkapp.no
  davvenjarga.no
  xn--davvenjrga-y4a.no
  nordre-land.no
  nordreisa.no
  raisa.no
  xn--risa-5na.no
  nore-og-uvdal.no
  notodden.no
  naroy.no
  xn--nry-yla5g.no
  notteroy.no
  xn--nttery-byae.no
  odda.no
  oksnes.no
  xn--ksnes-uua.no
  oppdal.no
  oppegard.no
  xn--oppegrd-ixa.no
  orkdal.no
  orland.no
  xn--rland-uua.no
  orskog.no
  xn--rskog-uua.no
  orsta.no
  xn--rsta-fra.no
  os.hedmark.no
  os.hordaland.no
  osen.no
  osteroy.no
  xn--ostery-fya.no
  ostre-toten.no
  xn--stre-toten-zcb.no
  overhalla.no
  ovre-eiker.no
  xn--vre-eiker-k8a.no
  oyer.no
  xn--yer-zna.no
  oygarden.no
  xn--ygarden-p1a.no
  oystre-slidre.no
  xn--ystre-slidre-ujb.no
  porsanger.no
  porsangu.no
  xn--porsgu-sta26f.no
  porsgrunn.no
  radoy.no
  xn--rady-ira.no
  rakkestad.no
  rana.no
  ruovat.no
  randaberg.no
  rauma.no
  rendalen.no
  rennebu.no
  rennesoy.no
  xn--rennesy-v1a.no
  rindal.no
  ringebu.no
  ringerike.no
  ringsaker.no
  rissa.no
  risor.no
  xn--risr-ira.no
  roan.no
  rollag.no
  rygge.no
  ralingen.no
  xn--rlingen-mxa.no
  rodoy.no
  xn--rdy-0nab.no
  romskog.no
  xn--rmskog-bya.no
  roros.no
  xn--rros-gra.no
  rost.no
  xn--rst-0na.no
  royken.no
  xn--ryken-vua.no
  royrvik.no
  xn--ryrvik-bya.no
  rade.no
  xn--rde-ula.no
  salangen.no
  siellak.no
  saltdal.no
  salat.no
  xn--slt-elab.no
  xn--slat-5na.no
  samnanger.no
  sande.more-og-romsdal.no
  sande.xn--mre-og-romsdal-qqb.no
  sande.vestfold.no
  sandefjord.no
  sandnes.no
  sandoy.no
  xn--sandy-yua.no
  sarpsborg.no
  sauda.no
  sauherad.no
  sel.no
  selbu.no
  selje.no
  seljord.no
  sigdal.no
  siljan.no
  sirdal.no
  skaun.no
  skedsmo.no
  ski.no
  skien.no
  skiptvet.no
  skjervoy.no
  xn--skjervy-v1a.no
  skierva.no
  xn--skierv-uta.no
  skjak.no
  xn--skjk-soa.no
  skodje.no
  skanland.no
  xn--sknland-fxa.no
  skanit.no
  xn--sknit-yqa.no
  smola.no
  xn--smla-hra.no
  snillfjord.no
  snasa.no
  xn--snsa-roa.no
  snoasa.no
  snaase.no
  xn--snase-nra.no
  sogndal.no
  sokndal.no
  sola.no
  solund.no
  songdalen.no
  sortland.no
  spydeberg.no
  stange.no
  stavanger.no
  steigen.no
  steinkjer.no
  stjordal.no
  xn--stjrdal-s1a.no
  stokke.no
  stor-elvdal.no
  stord.no
  stordal.no
  storfjord.no
  omasvuotna.no
  strand.no
  stranda.no
  stryn.no
  sula.no
  suldal.no
  sund.no
  sunndal.no
  surnadal.no
  sveio.no
  svelvik.no
  sykkylven.no
  sogne.no
  xn--sgne-gra.no
  somna.no
  xn--smna-gra.no
  sondre-land.no
  xn--sndre-land-0cb.no
  sor-aurdal.no
  xn--sr-aurdal-l8a.no
  sor-fron.no
  xn--sr-fron-q1a.no
  sor-odal.no
  xn--sr-odal-q1a.no
  sor-varanger.no
  xn--sr-varanger-ggb.no
  matta-varjjat.no
  xn--mtta-vrjjat-k7af.no
  sorfold.no
  xn--srfold-bya.no
  sorreisa.no
  xn--srreisa-q1a.no
  sorum.no
  xn--srum-gra.no
  tana.no
  deatnu.no
  time.no
  tingvoll.no
  tinn.no
  tjeldsund.no
  dielddanuorri.no
  tjome.no
  xn--tjme-hra.no
  tokke.no
  tolga.no
  torsken.no
  tranoy.no
  xn--trany-yua.no
  tromso.no
  xn--troms-zua.no
  tromsa.no
  romsa.no
  trondheim.no
  troandin.no
  trysil.no
  trana.no
  xn--trna-woa.no
  trogstad.no
  xn--trgstad-r1a.no
  tvedestrand.no
  tydal.no
  tynset.no
  tysfjord.no
  divtasvuodna.no
  divttasvuotna.no
  tysnes.no
  tysvar.no
  xn--tysvr-vra.no
  tonsberg.no
  xn--tnsberg-q1a.no
  ullensaker.no
  ullensvang.no
  ulvik.no
  utsira.no
  vadso.no
  xn--vads-jra.no
  cahcesuolo.no
  xn--hcesuolo-7ya35b.no
  vaksdal.no
  valle.no
  vang.no
  vanylven.no
  vardo.no
  xn--vard-jra.no
  varggat.no
  xn--vrggt-xqad.no
  vefsn.no
  vaapste.no
  vega.no
  vegarshei.no
  xn--vegrshei-c0a.no
  vennesla.no
  verdal.no
  verran.no
  vestby.no
  vestnes.no
  vestre-slidre.no
  vestre-toten.no
  vestvagoy.no
  xn--vestvgy-ixa6o.no
  vevelstad.no
  vik.no
  vikna.no
  vindafjord.no
  volda.no
  voss.no
  varoy.no
  xn--vry-yla5g.no
  vagan.no
  xn--vgan-qoa.no
  voagat.no
  vagsoy.no
  xn--vgsy-qoa0j.no
  vaga.no
  xn--vg-yiab.no
  valer.ostfold.no
  xn--vler-qoa.xn--stfold-9xa.no
  valer.hedmark.no
  xn--vler-qoa.hedmark.no
  
  // np : http://www.mos.com.np/register.html
  *.np
  
  // nr : http://cenpac.net.nr/dns/index.html
  // Submitted by registry <technician@cenpac.net.nr>
  nr
  biz.nr
  info.nr
  gov.nr
  edu.nr
  org.nr
  net.nr
  com.nr
  
  // nu : https://en.wikipedia.org/wiki/.nu
  nu
  
  // nz : https://en.wikipedia.org/wiki/.nz
  // Submitted by registry <jay@nzrs.net.nz>
  nz
  ac.nz
  co.nz
  cri.nz
  geek.nz
  gen.nz
  govt.nz
  health.nz
  iwi.nz
  kiwi.nz
  maori.nz
  mil.nz
  xn--mori-qsa.nz
  net.nz
  org.nz
  parliament.nz
  school.nz
  
  // om : https://en.wikipedia.org/wiki/.om
  om
  co.om
  com.om
  edu.om
  gov.om
  med.om
  museum.om
  net.om
  org.om
  pro.om
  
  // onion : https://tools.ietf.org/html/rfc7686
  onion
  
  // org : https://en.wikipedia.org/wiki/.org
  org
  
  // pa : http://www.nic.pa/
  // Some additional second level "domains" resolve directly as hostnames, such as
  // pannet.pa, so we add a rule for "pa".
  pa
  ac.pa
  gob.pa
  com.pa
  org.pa
  sld.pa
  edu.pa
  net.pa
  ing.pa
  abo.pa
  med.pa
  nom.pa
  
  // pe : https://www.nic.pe/InformeFinalComision.pdf
  pe
  edu.pe
  gob.pe
  nom.pe
  mil.pe
  org.pe
  com.pe
  net.pe
  
  // pf : http://www.gobin.info/domainname/formulaire-pf.pdf
  pf
  com.pf
  org.pf
  edu.pf
  
  // pg : https://en.wikipedia.org/wiki/.pg
  *.pg
  
  // ph : http://www.domains.ph/FAQ2.asp
  // Submitted by registry <jed@email.com.ph>
  ph
  com.ph
  net.ph
  org.ph
  gov.ph
  edu.ph
  ngo.ph
  mil.ph
  i.ph
  
  // pk : http://pk5.pknic.net.pk/pk5/msgNamepk.PK
  pk
  com.pk
  net.pk
  edu.pk
  org.pk
  fam.pk
  biz.pk
  web.pk
  gov.pk
  gob.pk
  gok.pk
  gon.pk
  gop.pk
  gos.pk
  info.pk
  
  // pl http://www.dns.pl/english/index.html
  // Submitted by registry
  pl
  com.pl
  net.pl
  org.pl
  // pl functional domains (http://www.dns.pl/english/index.html)
  aid.pl
  agro.pl
  atm.pl
  auto.pl
  biz.pl
  edu.pl
  gmina.pl
  gsm.pl
  info.pl
  mail.pl
  miasta.pl
  media.pl
  mil.pl
  nieruchomosci.pl
  nom.pl
  pc.pl
  powiat.pl
  priv.pl
  realestate.pl
  rel.pl
  sex.pl
  shop.pl
  sklep.pl
  sos.pl
  szkola.pl
  targi.pl
  tm.pl
  tourism.pl
  travel.pl
  turystyka.pl
  // Government domains
  gov.pl
  ap.gov.pl
  ic.gov.pl
  is.gov.pl
  us.gov.pl
  kmpsp.gov.pl
  kppsp.gov.pl
  kwpsp.gov.pl
  psp.gov.pl
  wskr.gov.pl
  kwp.gov.pl
  mw.gov.pl
  ug.gov.pl
  um.gov.pl
  umig.gov.pl
  ugim.gov.pl
  upow.gov.pl
  uw.gov.pl
  starostwo.gov.pl
  pa.gov.pl
  po.gov.pl
  psse.gov.pl
  pup.gov.pl
  rzgw.gov.pl
  sa.gov.pl
  so.gov.pl
  sr.gov.pl
  wsa.gov.pl
  sko.gov.pl
  uzs.gov.pl
  wiih.gov.pl
  winb.gov.pl
  pinb.gov.pl
  wios.gov.pl
  witd.gov.pl
  wzmiuw.gov.pl
  piw.gov.pl
  wiw.gov.pl
  griw.gov.pl
  wif.gov.pl
  oum.gov.pl
  sdn.gov.pl
  zp.gov.pl
  uppo.gov.pl
  mup.gov.pl
  wuoz.gov.pl
  konsulat.gov.pl
  oirm.gov.pl
  // pl regional domains (http://www.dns.pl/english/index.html)
  augustow.pl
  babia-gora.pl
  bedzin.pl
  beskidy.pl
  bialowieza.pl
  bialystok.pl
  bielawa.pl
  bieszczady.pl
  boleslawiec.pl
  bydgoszcz.pl
  bytom.pl
  cieszyn.pl
  czeladz.pl
  czest.pl
  dlugoleka.pl
  elblag.pl
  elk.pl
  glogow.pl
  gniezno.pl
  gorlice.pl
  grajewo.pl
  ilawa.pl
  jaworzno.pl
  jelenia-gora.pl
  jgora.pl
  kalisz.pl
  kazimierz-dolny.pl
  karpacz.pl
  kartuzy.pl
  kaszuby.pl
  katowice.pl
  kepno.pl
  ketrzyn.pl
  klodzko.pl
  kobierzyce.pl
  kolobrzeg.pl
  konin.pl
  konskowola.pl
  kutno.pl
  lapy.pl
  lebork.pl
  legnica.pl
  lezajsk.pl
  limanowa.pl
  lomza.pl
  lowicz.pl
  lubin.pl
  lukow.pl
  malbork.pl
  malopolska.pl
  mazowsze.pl
  mazury.pl
  mielec.pl
  mielno.pl
  mragowo.pl
  naklo.pl
  nowaruda.pl
  nysa.pl
  olawa.pl
  olecko.pl
  olkusz.pl
  olsztyn.pl
  opoczno.pl
  opole.pl
  ostroda.pl
  ostroleka.pl
  ostrowiec.pl
  ostrowwlkp.pl
  pila.pl
  pisz.pl
  podhale.pl
  podlasie.pl
  polkowice.pl
  pomorze.pl
  pomorskie.pl
  prochowice.pl
  pruszkow.pl
  przeworsk.pl
  pulawy.pl
  radom.pl
  rawa-maz.pl
  rybnik.pl
  rzeszow.pl
  sanok.pl
  sejny.pl
  slask.pl
  slupsk.pl
  sosnowiec.pl
  stalowa-wola.pl
  skoczow.pl
  starachowice.pl
  stargard.pl
  suwalki.pl
  swidnica.pl
  swiebodzin.pl
  swinoujscie.pl
  szczecin.pl
  szczytno.pl
  tarnobrzeg.pl
  tgory.pl
  turek.pl
  tychy.pl
  ustka.pl
  walbrzych.pl
  warmia.pl
  warszawa.pl
  waw.pl
  wegrow.pl
  wielun.pl
  wlocl.pl
  wloclawek.pl
  wodzislaw.pl
  wolomin.pl
  wroclaw.pl
  zachpomor.pl
  zagan.pl
  zarow.pl
  zgora.pl
  zgorzelec.pl
  
  // pm : http://www.afnic.fr/medias/documents/AFNIC-naming-policy2012.pdf
  pm
  
  // pn : http://www.government.pn/PnRegistry/policies.htm
  pn
  gov.pn
  co.pn
  org.pn
  edu.pn
  net.pn
  
  // post : https://en.wikipedia.org/wiki/.post
  post
  
  // pr : http://www.nic.pr/index.asp?f=1
  pr
  com.pr
  net.pr
  org.pr
  gov.pr
  edu.pr
  isla.pr
  pro.pr
  biz.pr
  info.pr
  name.pr
  // these aren't mentioned on nic.pr, but on https://en.wikipedia.org/wiki/.pr
  est.pr
  prof.pr
  ac.pr
  
  // pro : http://registry.pro/get-pro
  pro
  aaa.pro
  aca.pro
  acct.pro
  avocat.pro
  bar.pro
  cpa.pro
  eng.pro
  jur.pro
  law.pro
  med.pro
  recht.pro
  
  // ps : https://en.wikipedia.org/wiki/.ps
  // http://www.nic.ps/registration/policy.html#reg
  ps
  edu.ps
  gov.ps
  sec.ps
  plo.ps
  com.ps
  org.ps
  net.ps
  
  // pt : http://online.dns.pt/dns/start_dns
  pt
  net.pt
  gov.pt
  org.pt
  edu.pt
  int.pt
  publ.pt
  com.pt
  nome.pt
  
  // pw : https://en.wikipedia.org/wiki/.pw
  pw
  co.pw
  ne.pw
  or.pw
  ed.pw
  go.pw
  belau.pw
  
  // py : http://www.nic.py/pautas.html#seccion_9
  // Submitted by registry
  py
  com.py
  coop.py
  edu.py
  gov.py
  mil.py
  net.py
  org.py
  
  // qa : http://domains.qa/en/
  qa
  com.qa
  edu.qa
  gov.qa
  mil.qa
  name.qa
  net.qa
  org.qa
  sch.qa
  
  // re : http://www.afnic.re/obtenir/chartes/nommage-re/annexe-descriptifs
  re
  asso.re
  com.re
  nom.re
  
  // ro : http://www.rotld.ro/
  ro
  arts.ro
  com.ro
  firm.ro
  info.ro
  nom.ro
  nt.ro
  org.ro
  rec.ro
  store.ro
  tm.ro
  www.ro
  
  // rs : https://www.rnids.rs/en/domains/national-domains
  rs
  ac.rs
  co.rs
  edu.rs
  gov.rs
  in.rs
  org.rs
  
  // ru : https://cctld.ru/en/domains/domens_ru/reserved/
  ru
  ac.ru
  edu.ru
  gov.ru
  int.ru
  mil.ru
  test.ru
  
  // rw : http://www.nic.rw/cgi-bin/policy.pl
  rw
  gov.rw
  net.rw
  edu.rw
  ac.rw
  com.rw
  co.rw
  int.rw
  mil.rw
  gouv.rw
  
  // sa : http://www.nic.net.sa/
  sa
  com.sa
  net.sa
  org.sa
  gov.sa
  med.sa
  pub.sa
  edu.sa
  sch.sa
  
  // sb : http://www.sbnic.net.sb/
  // Submitted by registry <lee.humphries@telekom.com.sb>
  sb
  com.sb
  edu.sb
  gov.sb
  net.sb
  org.sb
  
  // sc : http://www.nic.sc/
  sc
  com.sc
  gov.sc
  net.sc
  org.sc
  edu.sc
  
  // sd : http://www.isoc.sd/sudanic.isoc.sd/billing_pricing.htm
  // Submitted by registry <admin@isoc.sd>
  sd
  com.sd
  net.sd
  org.sd
  edu.sd
  med.sd
  tv.sd
  gov.sd
  info.sd
  
  // se : https://en.wikipedia.org/wiki/.se
  // Submitted by registry <patrik.wallstrom@iis.se>
  se
  a.se
  ac.se
  b.se
  bd.se
  brand.se
  c.se
  d.se
  e.se
  f.se
  fh.se
  fhsk.se
  fhv.se
  g.se
  h.se
  i.se
  k.se
  komforb.se
  kommunalforbund.se
  komvux.se
  l.se
  lanbib.se
  m.se
  n.se
  naturbruksgymn.se
  o.se
  org.se
  p.se
  parti.se
  pp.se
  press.se
  r.se
  s.se
  t.se
  tm.se
  u.se
  w.se
  x.se
  y.se
  z.se
  
  // sg : http://www.nic.net.sg/page/registration-policies-procedures-and-guidelines
  sg
  com.sg
  net.sg
  org.sg
  gov.sg
  edu.sg
  per.sg
  
  // sh : http://www.nic.sh/registrar.html
  sh
  com.sh
  net.sh
  gov.sh
  org.sh
  mil.sh
  
  // si : https://en.wikipedia.org/wiki/.si
  si
  
  // sj : No registrations at this time.
  // Submitted by registry <jarle@uninett.no>
  sj
  
  // sk : https://en.wikipedia.org/wiki/.sk
  // list of 2nd level domains ?
  sk
  
  // sl : http://www.nic.sl
  // Submitted by registry <adam@neoip.com>
  sl
  com.sl
  net.sl
  edu.sl
  gov.sl
  org.sl
  
  // sm : https://en.wikipedia.org/wiki/.sm
  sm
  
  // sn : https://en.wikipedia.org/wiki/.sn
  sn
  art.sn
  com.sn
  edu.sn
  gouv.sn
  org.sn
  perso.sn
  univ.sn
  
  // so : http://www.soregistry.com/
  so
  com.so
  net.so
  org.so
  
  // sr : https://en.wikipedia.org/wiki/.sr
  sr
  
  // st : http://www.nic.st/html/policyrules/
  st
  co.st
  com.st
  consulado.st
  edu.st
  embaixada.st
  gov.st
  mil.st
  net.st
  org.st
  principe.st
  saotome.st
  store.st
  
  // su : https://en.wikipedia.org/wiki/.su
  su
  
  // sv : http://www.svnet.org.sv/niveldos.pdf
  sv
  com.sv
  edu.sv
  gob.sv
  org.sv
  red.sv
  
  // sx : https://en.wikipedia.org/wiki/.sx
  // Submitted by registry <jcvignes@openregistry.com>
  sx
  gov.sx
  
  // sy : https://en.wikipedia.org/wiki/.sy
  // see also: http://www.gobin.info/domainname/sy.doc
  sy
  edu.sy
  gov.sy
  net.sy
  mil.sy
  com.sy
  org.sy
  
  // sz : https://en.wikipedia.org/wiki/.sz
  // http://www.sispa.org.sz/
  sz
  co.sz
  ac.sz
  org.sz
  
  // tc : https://en.wikipedia.org/wiki/.tc
  tc
  
  // td : https://en.wikipedia.org/wiki/.td
  td
  
  // tel: https://en.wikipedia.org/wiki/.tel
  // http://www.telnic.org/
  tel
  
  // tf : https://en.wikipedia.org/wiki/.tf
  tf
  
  // tg : https://en.wikipedia.org/wiki/.tg
  // http://www.nic.tg/
  tg
  
  // th : https://en.wikipedia.org/wiki/.th
  // Submitted by registry <krit@thains.co.th>
  th
  ac.th
  co.th
  go.th
  in.th
  mi.th
  net.th
  or.th
  
  // tj : http://www.nic.tj/policy.html
  tj
  ac.tj
  biz.tj
  co.tj
  com.tj
  edu.tj
  go.tj
  gov.tj
  int.tj
  mil.tj
  name.tj
  net.tj
  nic.tj
  org.tj
  test.tj
  web.tj
  
  // tk : https://en.wikipedia.org/wiki/.tk
  tk
  
  // tl : https://en.wikipedia.org/wiki/.tl
  tl
  gov.tl
  
  // tm : http://www.nic.tm/local.html
  tm
  com.tm
  co.tm
  org.tm
  net.tm
  nom.tm
  gov.tm
  mil.tm
  edu.tm
  
  // tn : https://en.wikipedia.org/wiki/.tn
  // http://whois.ati.tn/
  tn
  com.tn
  ens.tn
  fin.tn
  gov.tn
  ind.tn
  intl.tn
  nat.tn
  net.tn
  org.tn
  info.tn
  perso.tn
  tourism.tn
  edunet.tn
  rnrt.tn
  rns.tn
  rnu.tn
  mincom.tn
  agrinet.tn
  defense.tn
  turen.tn
  
  // to : https://en.wikipedia.org/wiki/.to
  // Submitted by registry <egullich@colo.to>
  to
  com.to
  gov.to
  net.to
  org.to
  edu.to
  mil.to
  
  // subTLDs: https://www.nic.tr/forms/eng/policies.pdf
  //     and: https://www.nic.tr/forms/politikalar.pdf
  // Submitted by <mehmetgurevin@gmail.com>
  tr
  com.tr
  info.tr
  biz.tr
  net.tr
  org.tr
  web.tr
  gen.tr
  tv.tr
  av.tr
  dr.tr
  bbs.tr
  name.tr
  tel.tr
  gov.tr
  bel.tr
  pol.tr
  mil.tr
  k12.tr
  edu.tr
  kep.tr
  
  // Used by Northern Cyprus
  nc.tr
  
  // Used by government agencies of Northern Cyprus
  gov.nc.tr
  
  // travel : https://en.wikipedia.org/wiki/.travel
  travel
  
  // tt : http://www.nic.tt/
  tt
  co.tt
  com.tt
  org.tt
  net.tt
  biz.tt
  info.tt
  pro.tt
  int.tt
  coop.tt
  jobs.tt
  mobi.tt
  travel.tt
  museum.tt
  aero.tt
  name.tt
  gov.tt
  edu.tt
  
  // tv : https://en.wikipedia.org/wiki/.tv
  // Not listing any 2LDs as reserved since none seem to exist in practice,
  // Wikipedia notwithstanding.
  tv
  
  // tw : https://en.wikipedia.org/wiki/.tw
  tw
  edu.tw
  gov.tw
  mil.tw
  com.tw
  net.tw
  org.tw
  idv.tw
  game.tw
  ebiz.tw
  club.tw
  xn--zf0ao64a.tw
  xn--uc0atv.tw
  xn--czrw28b.tw
  
  // tz : http://www.tznic.or.tz/index.php/domains
  // Submitted by registry <manager@tznic.or.tz>
  tz
  ac.tz
  co.tz
  go.tz
  hotel.tz
  info.tz
  me.tz
  mil.tz
  mobi.tz
  ne.tz
  or.tz
  sc.tz
  tv.tz
  
  // ua : https://hostmaster.ua/policy/?ua
  // Submitted by registry <dk@cctld.ua>
  ua
  // ua 2LD
  com.ua
  edu.ua
  gov.ua
  in.ua
  net.ua
  org.ua
  // ua geographic names
  // https://hostmaster.ua/2ld/
  cherkassy.ua
  cherkasy.ua
  chernigov.ua
  chernihiv.ua
  chernivtsi.ua
  chernovtsy.ua
  ck.ua
  cn.ua
  cr.ua
  crimea.ua
  cv.ua
  dn.ua
  dnepropetrovsk.ua
  dnipropetrovsk.ua
  dominic.ua
  donetsk.ua
  dp.ua
  if.ua
  ivano-frankivsk.ua
  kh.ua
  kharkiv.ua
  kharkov.ua
  kherson.ua
  khmelnitskiy.ua
  khmelnytskyi.ua
  kiev.ua
  kirovograd.ua
  km.ua
  kr.ua
  krym.ua
  ks.ua
  kv.ua
  kyiv.ua
  lg.ua
  lt.ua
  lugansk.ua
  lutsk.ua
  lv.ua
  lviv.ua
  mk.ua
  mykolaiv.ua
  nikolaev.ua
  od.ua
  odesa.ua
  odessa.ua
  pl.ua
  poltava.ua
  rivne.ua
  rovno.ua
  rv.ua
  sb.ua
  sebastopol.ua
  sevastopol.ua
  sm.ua
  sumy.ua
  te.ua
  ternopil.ua
  uz.ua
  uzhgorod.ua
  vinnica.ua
  vinnytsia.ua
  vn.ua
  volyn.ua
  yalta.ua
  zaporizhzhe.ua
  zaporizhzhia.ua
  zhitomir.ua
  zhytomyr.ua
  zp.ua
  zt.ua
  
  // ug : https://www.registry.co.ug/
  ug
  co.ug
  or.ug
  ac.ug
  sc.ug
  go.ug
  ne.ug
  com.ug
  org.ug
  
  // uk : https://en.wikipedia.org/wiki/.uk
  // Submitted by registry <Michael.Daly@nominet.org.uk>
  uk
  ac.uk
  co.uk
  gov.uk
  ltd.uk
  me.uk
  net.uk
  nhs.uk
  org.uk
  plc.uk
  police.uk
  *.sch.uk
  
  // us : https://en.wikipedia.org/wiki/.us
  us
  dni.us
  fed.us
  isa.us
  kids.us
  nsn.us
  // us geographic names
  ak.us
  al.us
  ar.us
  as.us
  az.us
  ca.us
  co.us
  ct.us
  dc.us
  de.us
  fl.us
  ga.us
  gu.us
  hi.us
  ia.us
  id.us
  il.us
  in.us
  ks.us
  ky.us
  la.us
  ma.us
  md.us
  me.us
  mi.us
  mn.us
  mo.us
  ms.us
  mt.us
  nc.us
  nd.us
  ne.us
  nh.us
  nj.us
  nm.us
  nv.us
  ny.us
  oh.us
  ok.us
  or.us
  pa.us
  pr.us
  ri.us
  sc.us
  sd.us
  tn.us
  tx.us
  ut.us
  vi.us
  vt.us
  va.us
  wa.us
  wi.us
  wv.us
  wy.us
  // The registrar notes several more specific domains available in each state,
  // such as state.*.us, dst.*.us, etc., but resolution of these is somewhat
  // haphazard; in some states these domains resolve as addresses, while in others
  // only subdomains are available, or even nothing at all. We include the
  // most common ones where it's clear that different sites are different
  // entities.
  k12.ak.us
  k12.al.us
  k12.ar.us
  k12.as.us
  k12.az.us
  k12.ca.us
  k12.co.us
  k12.ct.us
  k12.dc.us
  k12.de.us
  k12.fl.us
  k12.ga.us
  k12.gu.us
  // k12.hi.us  Bug 614565 - Hawaii has a state-wide DOE login
  k12.ia.us
  k12.id.us
  k12.il.us
  k12.in.us
  k12.ks.us
  k12.ky.us
  k12.la.us
  k12.ma.us
  k12.md.us
  k12.me.us
  k12.mi.us
  k12.mn.us
  k12.mo.us
  k12.ms.us
  k12.mt.us
  k12.nc.us
  // k12.nd.us  Bug 1028347 - Removed at request of Travis Rosso <trossow@nd.gov>
  k12.ne.us
  k12.nh.us
  k12.nj.us
  k12.nm.us
  k12.nv.us
  k12.ny.us
  k12.oh.us
  k12.ok.us
  k12.or.us
  k12.pa.us
  k12.pr.us
  k12.ri.us
  k12.sc.us
  // k12.sd.us  Bug 934131 - Removed at request of James Booze <James.Booze@k12.sd.us>
  k12.tn.us
  k12.tx.us
  k12.ut.us
  k12.vi.us
  k12.vt.us
  k12.va.us
  k12.wa.us
  k12.wi.us
  // k12.wv.us  Bug 947705 - Removed at request of Verne Britton <verne@wvnet.edu>
  k12.wy.us
  cc.ak.us
  cc.al.us
  cc.ar.us
  cc.as.us
  cc.az.us
  cc.ca.us
  cc.co.us
  cc.ct.us
  cc.dc.us
  cc.de.us
  cc.fl.us
  cc.ga.us
  cc.gu.us
  cc.hi.us
  cc.ia.us
  cc.id.us
  cc.il.us
  cc.in.us
  cc.ks.us
  cc.ky.us
  cc.la.us
  cc.ma.us
  cc.md.us
  cc.me.us
  cc.mi.us
  cc.mn.us
  cc.mo.us
  cc.ms.us
  cc.mt.us
  cc.nc.us
  cc.nd.us
  cc.ne.us
  cc.nh.us
  cc.nj.us
  cc.nm.us
  cc.nv.us
  cc.ny.us
  cc.oh.us
  cc.ok.us
  cc.or.us
  cc.pa.us
  cc.pr.us
  cc.ri.us
  cc.sc.us
  cc.sd.us
  cc.tn.us
  cc.tx.us
  cc.ut.us
  cc.vi.us
  cc.vt.us
  cc.va.us
  cc.wa.us
  cc.wi.us
  cc.wv.us
  cc.wy.us
  lib.ak.us
  lib.al.us
  lib.ar.us
  lib.as.us
  lib.az.us
  lib.ca.us
  lib.co.us
  lib.ct.us
  lib.dc.us
  // lib.de.us  Issue #243 - Moved to Private section at request of Ed Moore <Ed.Moore@lib.de.us>
  lib.fl.us
  lib.ga.us
  lib.gu.us
  lib.hi.us
  lib.ia.us
  lib.id.us
  lib.il.us
  lib.in.us
  lib.ks.us
  lib.ky.us
  lib.la.us
  lib.ma.us
  lib.md.us
  lib.me.us
  lib.mi.us
  lib.mn.us
  lib.mo.us
  lib.ms.us
  lib.mt.us
  lib.nc.us
  lib.nd.us
  lib.ne.us
  lib.nh.us
  lib.nj.us
  lib.nm.us
  lib.nv.us
  lib.ny.us
  lib.oh.us
  lib.ok.us
  lib.or.us
  lib.pa.us
  lib.pr.us
  lib.ri.us
  lib.sc.us
  lib.sd.us
  lib.tn.us
  lib.tx.us
  lib.ut.us
  lib.vi.us
  lib.vt.us
  lib.va.us
  lib.wa.us
  lib.wi.us
  // lib.wv.us  Bug 941670 - Removed at request of Larry W Arnold <arnold@wvlc.lib.wv.us>
  lib.wy.us
  // k12.ma.us contains school districts in Massachusetts. The 4LDs are
  //  managed independently except for private (PVT), charter (CHTR) and
  //  parochial (PAROCH) schools.  Those are delegated directly to the
  //  5LD operators.   <k12-ma-hostmaster _ at _ rsuc.gweep.net>
  pvt.k12.ma.us
  chtr.k12.ma.us
  paroch.k12.ma.us
  // Merit Network, Inc. maintains the registry for =~ /(k12|cc|lib).mi.us/ and the following
  //    see also: http://domreg.merit.edu
  //    see also: whois -h whois.domreg.merit.edu help
  ann-arbor.mi.us
  cog.mi.us
  dst.mi.us
  eaton.mi.us
  gen.mi.us
  mus.mi.us
  tec.mi.us
  washtenaw.mi.us
  
  // uy : http://www.nic.org.uy/
  uy
  com.uy
  edu.uy
  gub.uy
  mil.uy
  net.uy
  org.uy
  
  // uz : http://www.reg.uz/
  uz
  co.uz
  com.uz
  net.uz
  org.uz
  
  // va : https://en.wikipedia.org/wiki/.va
  va
  
  // vc : https://en.wikipedia.org/wiki/.vc
  // Submitted by registry <kshah@ca.afilias.info>
  vc
  com.vc
  net.vc
  org.vc
  gov.vc
  mil.vc
  edu.vc
  
  // ve : https://registro.nic.ve/
  // Submitted by registry
  ve
  arts.ve
  co.ve
  com.ve
  e12.ve
  edu.ve
  firm.ve
  gob.ve
  gov.ve
  info.ve
  int.ve
  mil.ve
  net.ve
  org.ve
  rec.ve
  store.ve
  tec.ve
  web.ve
  
  // vg : https://en.wikipedia.org/wiki/.vg
  vg
  
  // vi : http://www.nic.vi/newdomainform.htm
  // http://www.nic.vi/Domain_Rules/body_domain_rules.html indicates some other
  // TLDs are "reserved", such as edu.vi and gov.vi, but doesn't actually say they
  // are available for registration (which they do not seem to be).
  vi
  co.vi
  com.vi
  k12.vi
  net.vi
  org.vi
  
  // vn : https://www.dot.vn/vnnic/vnnic/domainregistration.jsp
  vn
  com.vn
  net.vn
  org.vn
  edu.vn
  gov.vn
  int.vn
  ac.vn
  biz.vn
  info.vn
  name.vn
  pro.vn
  health.vn
  
  // vu : https://en.wikipedia.org/wiki/.vu
  // http://www.vunic.vu/
  vu
  com.vu
  edu.vu
  net.vu
  org.vu
  
  // wf : http://www.afnic.fr/medias/documents/AFNIC-naming-policy2012.pdf
  wf
  
  // ws : https://en.wikipedia.org/wiki/.ws
  // http://samoanic.ws/index.dhtml
  ws
  com.ws
  net.ws
  org.ws
  gov.ws
  edu.ws
  
  // yt : http://www.afnic.fr/medias/documents/AFNIC-naming-policy2012.pdf
  yt
  
  // IDN ccTLDs
  // When submitting patches, please maintain a sort by ISO 3166 ccTLD, then
  // U-label, and follow this format:
  // // A-Label ("<Latin renderings>", <language name>[, variant info]) : <ISO 3166 ccTLD>
  // // [sponsoring org]
  // U-Label
  
  // xn--mgbaam7a8h ("Emerat", Arabic) : AE
  // http://nic.ae/english/arabicdomain/rules.jsp
  xn--mgbaam7a8h
  
  // xn--y9a3aq ("hye", Armenian) : AM
  // ISOC AM (operated by .am Registry)
  xn--y9a3aq
  
  // xn--54b7fta0cc ("Bangla", Bangla) : BD
  xn--54b7fta0cc
  
  // xn--90ae ("bg", Bulgarian) : BG
  xn--90ae
  
  // xn--90ais ("bel", Belarusian/Russian Cyrillic) : BY
  // Operated by .by registry
  xn--90ais
  
  // xn--fiqs8s ("Zhongguo/China", Chinese, Simplified) : CN
  // CNNIC
  // http://cnnic.cn/html/Dir/2005/10/11/3218.htm
  xn--fiqs8s
  
  // xn--fiqz9s ("Zhongguo/China", Chinese, Traditional) : CN
  // CNNIC
  // http://cnnic.cn/html/Dir/2005/10/11/3218.htm
  xn--fiqz9s
  
  // xn--lgbbat1ad8j ("Algeria/Al Jazair", Arabic) : DZ
  xn--lgbbat1ad8j
  
  // xn--wgbh1c ("Egypt/Masr", Arabic) : EG
  // http://www.dotmasr.eg/
  xn--wgbh1c
  
  // xn--e1a4c ("eu", Cyrillic) : EU
  xn--e1a4c
  
  // xn--node ("ge", Georgian Mkhedruli) : GE
  xn--node
  
  // xn--qxam ("el", Greek) : GR
  // Hellenic Ministry of Infrastructure, Transport, and Networks
  xn--qxam
  
  // xn--j6w193g ("Hong Kong", Chinese) : HK
  // https://www2.hkirc.hk/register/rules.jsp
  xn--j6w193g
  
  // xn--2scrj9c ("Bharat", Kannada) : IN
  // India
  xn--2scrj9c
  
  // xn--3hcrj9c ("Bharat", Oriya) : IN
  // India
  xn--3hcrj9c
  
  // xn--45br5cyl ("Bharatam", Assamese) : IN
  // India
  xn--45br5cyl
  
  // xn--h2breg3eve ("Bharatam", Sanskrit) : IN
  // India
  xn--h2breg3eve
  
  // xn--h2brj9c8c ("Bharot", Santali) : IN
  // India
  xn--h2brj9c8c
  
  // xn--mgbgu82a ("Bharat", Sindhi) : IN
  // India
  xn--mgbgu82a
  
  // xn--rvc1e0am3e ("Bharatam", Malayalam) : IN
  // India
  xn--rvc1e0am3e
  
  // xn--h2brj9c ("Bharat", Devanagari) : IN
  // India
  xn--h2brj9c
  
  // xn--mgbbh1a71e ("Bharat", Arabic) : IN
  // India
  xn--mgbbh1a71e
  
  // xn--fpcrj9c3d ("Bharat", Telugu) : IN
  // India
  xn--fpcrj9c3d
  
  // xn--gecrj9c ("Bharat", Gujarati) : IN
  // India
  xn--gecrj9c
  
  // xn--s9brj9c ("Bharat", Gurmukhi) : IN
  // India
  xn--s9brj9c
  
  // xn--45brj9c ("Bharat", Bengali) : IN
  // India
  xn--45brj9c
  
  // xn--xkc2dl3a5ee0h ("India", Tamil) : IN
  // India
  xn--xkc2dl3a5ee0h
  
  // xn--mgba3a4f16a ("Iran", Persian) : IR
  xn--mgba3a4f16a
  
  // xn--mgba3a4fra ("Iran", Arabic) : IR
  xn--mgba3a4fra
  
  // xn--mgbtx2b ("Iraq", Arabic) : IQ
  // Communications and Media Commission
  xn--mgbtx2b
  
  // xn--mgbayh7gpa ("al-Ordon", Arabic) : JO
  // National Information Technology Center (NITC)
  // Royal Scientific Society, Al-Jubeiha
  xn--mgbayh7gpa
  
  // xn--3e0b707e ("Republic of Korea", Hangul) : KR
  xn--3e0b707e
  
  // xn--80ao21a ("Kaz", Kazakh) : KZ
  xn--80ao21a
  
  // xn--fzc2c9e2c ("Lanka", Sinhalese-Sinhala) : LK
  // http://nic.lk
  xn--fzc2c9e2c
  
  // xn--xkc2al3hye2a ("Ilangai", Tamil) : LK
  // http://nic.lk
  xn--xkc2al3hye2a
  
  // xn--mgbc0a9azcg ("Morocco/al-Maghrib", Arabic) : MA
  xn--mgbc0a9azcg
  
  // xn--d1alf ("mkd", Macedonian) : MK
  // MARnet
  xn--d1alf
  
  // xn--l1acc ("mon", Mongolian) : MN
  xn--l1acc
  
  // xn--mix891f ("Macao", Chinese, Traditional) : MO
  // MONIC / HNET Asia (Registry Operator for .mo)
  xn--mix891f
  
  // xn--mix082f ("Macao", Chinese, Simplified) : MO
  xn--mix082f
  
  // xn--mgbx4cd0ab ("Malaysia", Malay) : MY
  xn--mgbx4cd0ab
  
  // xn--mgb9awbf ("Oman", Arabic) : OM
  xn--mgb9awbf
  
  // xn--mgbai9azgqp6j ("Pakistan", Urdu/Arabic) : PK
  xn--mgbai9azgqp6j
  
  // xn--mgbai9a5eva00b ("Pakistan", Urdu/Arabic, variant) : PK
  xn--mgbai9a5eva00b
  
  // xn--ygbi2ammx ("Falasteen", Arabic) : PS
  // The Palestinian National Internet Naming Authority (PNINA)
  // http://www.pnina.ps
  xn--ygbi2ammx
  
  // xn--90a3ac ("srb", Cyrillic) : RS
  // https://www.rnids.rs/en/domains/national-domains
  xn--90a3ac
  xn--o1ac.xn--90a3ac
  xn--c1avg.xn--90a3ac
  xn--90azh.xn--90a3ac
  xn--d1at.xn--90a3ac
  xn--o1ach.xn--90a3ac
  xn--80au.xn--90a3ac
  
  // xn--p1ai ("rf", Russian-Cyrillic) : RU
  // http://www.cctld.ru/en/docs/rulesrf.php
  xn--p1ai
  
  // xn--wgbl6a ("Qatar", Arabic) : QA
  // http://www.ict.gov.qa/
  xn--wgbl6a
  
  // xn--mgberp4a5d4ar ("AlSaudiah", Arabic) : SA
  // http://www.nic.net.sa/
  xn--mgberp4a5d4ar
  
  // xn--mgberp4a5d4a87g ("AlSaudiah", Arabic, variant)  : SA
  xn--mgberp4a5d4a87g
  
  // xn--mgbqly7c0a67fbc ("AlSaudiah", Arabic, variant) : SA
  xn--mgbqly7c0a67fbc
  
  // xn--mgbqly7cvafr ("AlSaudiah", Arabic, variant) : SA
  xn--mgbqly7cvafr
  
  // xn--mgbpl2fh ("sudan", Arabic) : SD
  // Operated by .sd registry
  xn--mgbpl2fh
  
  // xn--yfro4i67o Singapore ("Singapore", Chinese) : SG
  xn--yfro4i67o
  
  // xn--clchc0ea0b2g2a9gcd ("Singapore", Tamil) : SG
  xn--clchc0ea0b2g2a9gcd
  
  // xn--ogbpf8fl ("Syria", Arabic) : SY
  xn--ogbpf8fl
  
  // xn--mgbtf8fl ("Syria", Arabic, variant) : SY
  xn--mgbtf8fl
  
  // xn--o3cw4h ("Thai", Thai) : TH
  // http://www.thnic.co.th
  xn--o3cw4h
  xn--12c1fe0br.xn--o3cw4h
  xn--12co0c3b4eva.xn--o3cw4h
  xn--h3cuzk1di.xn--o3cw4h
  xn--o3cyx2a.xn--o3cw4h
  xn--m3ch0j3a.xn--o3cw4h
  xn--12cfi8ixb8l.xn--o3cw4h
  
  // xn--pgbs0dh ("Tunisia", Arabic) : TN
  // http://nic.tn
  xn--pgbs0dh
  
  // xn--kpry57d ("Taiwan", Chinese, Traditional) : TW
  // http://www.twnic.net/english/dn/dn_07a.htm
  xn--kpry57d
  
  // xn--kprw13d ("Taiwan", Chinese, Simplified) : TW
  // http://www.twnic.net/english/dn/dn_07a.htm
  xn--kprw13d
  
  // xn--nnx388a ("Taiwan", Chinese, variant) : TW
  xn--nnx388a
  
  // xn--j1amh ("ukr", Cyrillic) : UA
  xn--j1amh
  
  // xn--mgb2ddes ("AlYemen", Arabic) : YE
  xn--mgb2ddes
  
  // xxx : http://icmregistry.com
  xxx
  
  // ye : http://www.y.net.ye/services/domain_name.htm
  *.ye
  
  // za : http://www.zadna.org.za/content/page/domain-information
  ac.za
  agric.za
  alt.za
  co.za
  edu.za
  gov.za
  grondar.za
  law.za
  mil.za
  net.za
  ngo.za
  nis.za
  nom.za
  org.za
  school.za
  tm.za
  web.za
  
  // zm : https://zicta.zm/
  // Submitted by registry <info@zicta.zm>
  zm
  ac.zm
  biz.zm
  co.zm
  com.zm
  edu.zm
  gov.zm
  info.zm
  mil.zm
  net.zm
  org.zm
  sch.zm
  
  // zw : https://www.potraz.gov.zw/
  // Confirmed by registry <bmtengwa@potraz.gov.zw> 2017-01-25
  zw
  ac.zw
  co.zw
  gov.zw
  mil.zw
  org.zw
  
  // List of new gTLDs imported from https://newgtlds.icann.org/newgtlds.csv on 2017-02-23T00:46:09Z
  
  // aaa : 2015-02-26 American Automobile Association, Inc.
  aaa
  
  // aarp : 2015-05-21 AARP
  aarp
  
  // abarth : 2015-07-30 Fiat Chrysler Automobiles N.V.
  abarth
  
  // abb : 2014-10-24 ABB Ltd
  abb
  
  // abbott : 2014-07-24 Abbott Laboratories, Inc.
  abbott
  
  // abbvie : 2015-07-30 AbbVie Inc.
  abbvie
  
  // abc : 2015-07-30 Disney Enterprises, Inc.
  abc
  
  // able : 2015-06-25 Able Inc.
  able
  
  // abogado : 2014-04-24 Top Level Domain Holdings Limited
  abogado
  
  // abudhabi : 2015-07-30 Abu Dhabi Systems and Information Centre
  abudhabi
  
  // academy : 2013-11-07 Half Oaks, LLC
  academy
  
  // accenture : 2014-08-15 Accenture plc
  accenture
  
  // accountant : 2014-11-20 dot Accountant Limited
  accountant
  
  // accountants : 2014-03-20 Knob Town, LLC
  accountants
  
  // aco : 2015-01-08 ACO Severin Ahlmann GmbH & Co. KG
  aco
  
  // active : 2014-05-01 The Active Network, Inc
  active
  
  // actor : 2013-12-12 United TLD Holdco Ltd.
  actor
  
  // adac : 2015-07-16 Allgemeiner Deutscher Automobil-Club e.V. (ADAC)
  adac
  
  // ads : 2014-12-04 Charleston Road Registry Inc.
  ads
  
  // adult : 2014-10-16 ICM Registry AD LLC
  adult
  
  // aeg : 2015-03-19 Aktiebolaget Electrolux
  aeg
  
  // aetna : 2015-05-21 Aetna Life Insurance Company
  aetna
  
  // afamilycompany : 2015-07-23 Johnson Shareholdings, Inc.
  afamilycompany
  
  // afl : 2014-10-02 Australian Football League
  afl
  
  // africa : 2014-03-24 ZA Central Registry NPC trading as Registry.Africa
  africa
  
  // agakhan : 2015-04-23 Fondation Aga Khan (Aga Khan Foundation)
  agakhan
  
  // agency : 2013-11-14 Steel Falls, LLC
  agency
  
  // aig : 2014-12-18 American International Group, Inc.
  aig
  
  // aigo : 2015-08-06 aigo Digital Technology Co,Ltd.
  aigo
  
  // airbus : 2015-07-30 Airbus S.A.S.
  airbus
  
  // airforce : 2014-03-06 United TLD Holdco Ltd.
  airforce
  
  // airtel : 2014-10-24 Bharti Airtel Limited
  airtel
  
  // akdn : 2015-04-23 Fondation Aga Khan (Aga Khan Foundation)
  akdn
  
  // alfaromeo : 2015-07-31 Fiat Chrysler Automobiles N.V.
  alfaromeo
  
  // alibaba : 2015-01-15 Alibaba Group Holding Limited
  alibaba
  
  // alipay : 2015-01-15 Alibaba Group Holding Limited
  alipay
  
  // allfinanz : 2014-07-03 Allfinanz Deutsche Vermgensberatung Aktiengesellschaft
  allfinanz
  
  // allstate : 2015-07-31 Allstate Fire and Casualty Insurance Company
  allstate
  
  // ally : 2015-06-18 Ally Financial Inc.
  ally
  
  // alsace : 2014-07-02 REGION D ALSACE
  alsace
  
  // alstom : 2015-07-30 ALSTOM
  alstom
  
  // americanexpress : 2015-07-31 American Express Travel Related Services Company, Inc.
  americanexpress
  
  // americanfamily : 2015-07-23 AmFam, Inc.
  americanfamily
  
  // amex : 2015-07-31 American Express Travel Related Services Company, Inc.
  amex
  
  // amfam : 2015-07-23 AmFam, Inc.
  amfam
  
  // amica : 2015-05-28 Amica Mutual Insurance Company
  amica
  
  // amsterdam : 2014-07-24 Gemeente Amsterdam
  amsterdam
  
  // analytics : 2014-12-18 Campus IP LLC
  analytics
  
  // android : 2014-08-07 Charleston Road Registry Inc.
  android
  
  // anquan : 2015-01-08 QIHOO 360 TECHNOLOGY CO. LTD.
  anquan
  
  // anz : 2015-07-31 Australia and New Zealand Banking Group Limited
  anz
  
  // aol : 2015-09-17 AOL Inc.
  aol
  
  // apartments : 2014-12-11 June Maple, LLC
  apartments
  
  // app : 2015-05-14 Charleston Road Registry Inc.
  app
  
  // apple : 2015-05-14 Apple Inc.
  apple
  
  // aquarelle : 2014-07-24 Aquarelle.com
  aquarelle
  
  // arab : 2015-11-12 League of Arab States
  arab
  
  // aramco : 2014-11-20 Aramco Services Company
  aramco
  
  // archi : 2014-02-06 STARTING DOT LIMITED
  archi
  
  // army : 2014-03-06 United TLD Holdco Ltd.
  army
  
  // art : 2016-03-24 UK Creative Ideas Limited
  art
  
  // arte : 2014-12-11 Association Relative  la Tlvision Europenne G.E.I.E.
  arte
  
  // asda : 2015-07-31 Wal-Mart Stores, Inc.
  asda
  
  // associates : 2014-03-06 Baxter Hill, LLC
  associates
  
  // athleta : 2015-07-30 The Gap, Inc.
  athleta
  
  // attorney : 2014-03-20
  attorney
  
  // auction : 2014-03-20
  auction
  
  // audi : 2015-05-21 AUDI Aktiengesellschaft
  audi
  
  // audible : 2015-06-25 Amazon EU S. r.l.
  audible
  
  // audio : 2014-03-20 Uniregistry, Corp.
  audio
  
  // auspost : 2015-08-13 Australian Postal Corporation
  auspost
  
  // author : 2014-12-18 Amazon EU S. r.l.
  author
  
  // auto : 2014-11-13
  auto
  
  // autos : 2014-01-09 DERAutos, LLC
  autos
  
  // avianca : 2015-01-08 Aerovias del Continente Americano S.A. Avianca
  avianca
  
  // aws : 2015-06-25 Amazon EU S. r.l.
  aws
  
  // axa : 2013-12-19 AXA SA
  axa
  
  // azure : 2014-12-18 Microsoft Corporation
  azure
  
  // baby : 2015-04-09 Johnson & Johnson Services, Inc.
  baby
  
  // baidu : 2015-01-08 Baidu, Inc.
  baidu
  
  // banamex : 2015-07-30 Citigroup Inc.
  banamex
  
  // bananarepublic : 2015-07-31 The Gap, Inc.
  bananarepublic
  
  // band : 2014-06-12
  band
  
  // bank : 2014-09-25 fTLD Registry Services LLC
  bank
  
  // bar : 2013-12-12 Punto 2012 Sociedad Anonima Promotora de Inversion de Capital Variable
  bar
  
  // barcelona : 2014-07-24 Municipi de Barcelona
  barcelona
  
  // barclaycard : 2014-11-20 Barclays Bank PLC
  barclaycard
  
  // barclays : 2014-11-20 Barclays Bank PLC
  barclays
  
  // barefoot : 2015-06-11 Gallo Vineyards, Inc.
  barefoot
  
  // bargains : 2013-11-14 Half Hallow, LLC
  bargains
  
  // baseball : 2015-10-29 MLB Advanced Media DH, LLC
  baseball
  
  // basketball : 2015-08-20 Fdration Internationale de Basketball (FIBA)
  basketball
  
  // bauhaus : 2014-04-17 Werkhaus GmbH
  bauhaus
  
  // bayern : 2014-01-23 Bayern Connect GmbH
  bayern
  
  // bbc : 2014-12-18 British Broadcasting Corporation
  bbc
  
  // bbt : 2015-07-23 BB&T Corporation
  bbt
  
  // bbva : 2014-10-02 BANCO BILBAO VIZCAYA ARGENTARIA, S.A.
  bbva
  
  // bcg : 2015-04-02 The Boston Consulting Group, Inc.
  bcg
  
  // bcn : 2014-07-24 Municipi de Barcelona
  bcn
  
  // beats : 2015-05-14 Beats Electronics, LLC
  beats
  
  // beauty : 2015-12-03 L'Oral
  beauty
  
  // beer : 2014-01-09 Top Level Domain Holdings Limited
  beer
  
  // bentley : 2014-12-18 Bentley Motors Limited
  bentley
  
  // berlin : 2013-10-31 dotBERLIN GmbH & Co. KG
  berlin
  
  // best : 2013-12-19 BestTLD Pty Ltd
  best
  
  // bestbuy : 2015-07-31 BBY Solutions, Inc.
  bestbuy
  
  // bet : 2015-05-07 Afilias plc
  bet
  
  // bharti : 2014-01-09 Bharti Enterprises (Holding) Private Limited
  bharti
  
  // bible : 2014-06-19 American Bible Society
  bible
  
  // bid : 2013-12-19 dot Bid Limited
  bid
  
  // bike : 2013-08-27 Grand Hollow, LLC
  bike
  
  // bing : 2014-12-18 Microsoft Corporation
  bing
  
  // bingo : 2014-12-04 Sand Cedar, LLC
  bingo
  
  // bio : 2014-03-06 STARTING DOT LIMITED
  bio
  
  // black : 2014-01-16 Afilias Limited
  black
  
  // blackfriday : 2014-01-16 Uniregistry, Corp.
  blackfriday
  
  // blanco : 2015-07-16 BLANCO GmbH + Co KG
  blanco
  
  // blockbuster : 2015-07-30 Dish DBS Corporation
  blockbuster
  
  // blog : 2015-05-14
  blog
  
  // bloomberg : 2014-07-17 Bloomberg IP Holdings LLC
  bloomberg
  
  // blue : 2013-11-07 Afilias Limited
  blue
  
  // bms : 2014-10-30 Bristol-Myers Squibb Company
  bms
  
  // bmw : 2014-01-09 Bayerische Motoren Werke Aktiengesellschaft
  bmw
  
  // bnl : 2014-07-24 Banca Nazionale del Lavoro
  bnl
  
  // bnpparibas : 2014-05-29 BNP Paribas
  bnpparibas
  
  // boats : 2014-12-04 DERBoats, LLC
  boats
  
  // boehringer : 2015-07-09 Boehringer Ingelheim International GmbH
  boehringer
  
  // bofa : 2015-07-31 NMS Services, Inc.
  bofa
  
  // bom : 2014-10-16 Ncleo de Informao e Coordenao do Ponto BR - NIC.br
  bom
  
  // bond : 2014-06-05 Bond University Limited
  bond
  
  // boo : 2014-01-30 Charleston Road Registry Inc.
  boo
  
  // book : 2015-08-27 Amazon EU S. r.l.
  book
  
  // booking : 2015-07-16 Booking.com B.V.
  booking
  
  // boots : 2015-01-08 THE BOOTS COMPANY PLC
  boots
  
  // bosch : 2015-06-18 Robert Bosch GMBH
  bosch
  
  // bostik : 2015-05-28 Bostik SA
  bostik
  
  // boston : 2015-12-10
  boston
  
  // bot : 2014-12-18 Amazon EU S. r.l.
  bot
  
  // boutique : 2013-11-14 Over Galley, LLC
  boutique
  
  // box : 2015-11-12 NS1 Limited
  box
  
  // bradesco : 2014-12-18 Banco Bradesco S.A.
  bradesco
  
  // bridgestone : 2014-12-18 Bridgestone Corporation
  bridgestone
  
  // broadway : 2014-12-22 Celebrate Broadway, Inc.
  broadway
  
  // broker : 2014-12-11 IG Group Holdings PLC
  broker
  
  // brother : 2015-01-29 Brother Industries, Ltd.
  brother
  
  // brussels : 2014-02-06 DNS.be vzw
  brussels
  
  // budapest : 2013-11-21 Top Level Domain Holdings Limited
  budapest
  
  // bugatti : 2015-07-23 Bugatti International SA
  bugatti
  
  // build : 2013-11-07 Plan Bee LLC
  build
  
  // builders : 2013-11-07 Atomic Madison, LLC
  builders
  
  // business : 2013-11-07 Spring Cross, LLC
  business
  
  // buy : 2014-12-18 Amazon EU S. r.l.
  buy
  
  // buzz : 2013-10-02 DOTSTRATEGY CO.
  buzz
  
  // bzh : 2014-02-27 Association www.bzh
  bzh
  
  // cab : 2013-10-24 Half Sunset, LLC
  cab
  
  // cafe : 2015-02-11 Pioneer Canyon, LLC
  cafe
  
  // cal : 2014-07-24 Charleston Road Registry Inc.
  cal
  
  // call : 2014-12-18 Amazon EU S. r.l.
  call
  
  // calvinklein : 2015-07-30 PVH gTLD Holdings LLC
  calvinklein
  
  // cam : 2016-04-21 AC Webconnecting Holding B.V.
  cam
  
  // camera : 2013-08-27 Atomic Maple, LLC
  camera
  
  // camp : 2013-11-07 Delta Dynamite, LLC
  camp
  
  // cancerresearch : 2014-05-15 Australian Cancer Research Foundation
  cancerresearch
  
  // canon : 2014-09-12 Canon Inc.
  canon
  
  // capetown : 2014-03-24 ZA Central Registry NPC trading as ZA Central Registry
  capetown
  
  // capital : 2014-03-06 Delta Mill, LLC
  capital
  
  // capitalone : 2015-08-06 Capital One Financial Corporation
  capitalone
  
  // car : 2015-01-22
  car
  
  // caravan : 2013-12-12 Caravan International, Inc.
  caravan
  
  // cards : 2013-12-05 Foggy Hollow, LLC
  cards
  
  // care : 2014-03-06 Goose Cross
  care
  
  // career : 2013-10-09 dotCareer LLC
  career
  
  // careers : 2013-10-02 Wild Corner, LLC
  careers
  
  // cars : 2014-11-13
  cars
  
  // cartier : 2014-06-23 Richemont DNS Inc.
  cartier
  
  // casa : 2013-11-21 Top Level Domain Holdings Limited
  casa
  
  // case : 2015-09-03 CNH Industrial N.V.
  case
  
  // caseih : 2015-09-03 CNH Industrial N.V.
  caseih
  
  // cash : 2014-03-06 Delta Lake, LLC
  cash
  
  // casino : 2014-12-18 Binky Sky, LLC
  casino
  
  // catering : 2013-12-05 New Falls. LLC
  catering
  
  // catholic : 2015-10-21 Pontificium Consilium de Comunicationibus Socialibus (PCCS) (Pontifical Council for Social Communication)
  catholic
  
  // cba : 2014-06-26 COMMONWEALTH BANK OF AUSTRALIA
  cba
  
  // cbn : 2014-08-22 The Christian Broadcasting Network, Inc.
  cbn
  
  // cbre : 2015-07-02 CBRE, Inc.
  cbre
  
  // cbs : 2015-08-06 CBS Domains Inc.
  cbs
  
  // ceb : 2015-04-09 The Corporate Executive Board Company
  ceb
  
  // center : 2013-11-07 Tin Mill, LLC
  center
  
  // ceo : 2013-11-07 CEOTLD Pty Ltd
  ceo
  
  // cern : 2014-06-05 European Organization for Nuclear Research ("CERN")
  cern
  
  // cfa : 2014-08-28 CFA Institute
  cfa
  
  // cfd : 2014-12-11 IG Group Holdings PLC
  cfd
  
  // chanel : 2015-04-09 Chanel International B.V.
  chanel
  
  // channel : 2014-05-08 Charleston Road Registry Inc.
  channel
  
  // chase : 2015-04-30 JPMorgan Chase & Co.
  chase
  
  // chat : 2014-12-04 Sand Fields, LLC
  chat
  
  // cheap : 2013-11-14 Sand Cover, LLC
  cheap
  
  // chintai : 2015-06-11 CHINTAI Corporation
  chintai
  
  // christmas : 2013-11-21 Uniregistry, Corp.
  christmas
  
  // chrome : 2014-07-24 Charleston Road Registry Inc.
  chrome
  
  // chrysler : 2015-07-30 FCA US LLC.
  chrysler
  
  // church : 2014-02-06 Holly Fields, LLC
  church
  
  // cipriani : 2015-02-19 Hotel Cipriani Srl
  cipriani
  
  // circle : 2014-12-18 Amazon EU S. r.l.
  circle
  
  // cisco : 2014-12-22 Cisco Technology, Inc.
  cisco
  
  // citadel : 2015-07-23 Citadel Domain LLC
  citadel
  
  // citi : 2015-07-30 Citigroup Inc.
  citi
  
  // citic : 2014-01-09 CITIC Group Corporation
  citic
  
  // city : 2014-05-29 Snow Sky, LLC
  city
  
  // cityeats : 2014-12-11 Lifestyle Domain Holdings, Inc.
  cityeats
  
  // claims : 2014-03-20 Black Corner, LLC
  claims
  
  // cleaning : 2013-12-05 Fox Shadow, LLC
  cleaning
  
  // click : 2014-06-05 Uniregistry, Corp.
  click
  
  // clinic : 2014-03-20 Goose Park, LLC
  clinic
  
  // clinique : 2015-10-01 The Este Lauder Companies Inc.
  clinique
  
  // clothing : 2013-08-27 Steel Lake, LLC
  clothing
  
  // cloud : 2015-04-16 ARUBA S.p.A.
  cloud
  
  // club : 2013-11-08 .CLUB DOMAINS, LLC
  club
  
  // clubmed : 2015-06-25 Club Mditerrane S.A.
  clubmed
  
  // coach : 2014-10-09 Koko Island, LLC
  coach
  
  // codes : 2013-10-31 Puff Willow, LLC
  codes
  
  // coffee : 2013-10-17 Trixy Cover, LLC
  coffee
  
  // college : 2014-01-16 XYZ.COM LLC
  college
  
  // cologne : 2014-02-05 NetCologne Gesellschaft fr Telekommunikation mbH
  cologne
  
  // comcast : 2015-07-23 Comcast IP Holdings I, LLC
  comcast
  
  // commbank : 2014-06-26 COMMONWEALTH BANK OF AUSTRALIA
  commbank
  
  // community : 2013-12-05 Fox Orchard, LLC
  community
  
  // company : 2013-11-07 Silver Avenue, LLC
  company
  
  // compare : 2015-10-08 iSelect Ltd
  compare
  
  // computer : 2013-10-24 Pine Mill, LLC
  computer
  
  // comsec : 2015-01-08 VeriSign, Inc.
  comsec
  
  // condos : 2013-12-05 Pine House, LLC
  condos
  
  // construction : 2013-09-16 Fox Dynamite, LLC
  construction
  
  // consulting : 2013-12-05
  consulting
  
  // contact : 2015-01-08 Top Level Spectrum, Inc.
  contact
  
  // contractors : 2013-09-10 Magic Woods, LLC
  contractors
  
  // cooking : 2013-11-21 Top Level Domain Holdings Limited
  cooking
  
  // cookingchannel : 2015-07-02 Lifestyle Domain Holdings, Inc.
  cookingchannel
  
  // cool : 2013-11-14 Koko Lake, LLC
  cool
  
  // corsica : 2014-09-25 Collectivit Territoriale de Corse
  corsica
  
  // country : 2013-12-19 Top Level Domain Holdings Limited
  country
  
  // coupon : 2015-02-26 Amazon EU S. r.l.
  coupon
  
  // coupons : 2015-03-26 Black Island, LLC
  coupons
  
  // courses : 2014-12-04 OPEN UNIVERSITIES AUSTRALIA PTY LTD
  courses
  
  // credit : 2014-03-20 Snow Shadow, LLC
  credit
  
  // creditcard : 2014-03-20 Binky Frostbite, LLC
  creditcard
  
  // creditunion : 2015-01-22 CUNA Performance Resources, LLC
  creditunion
  
  // cricket : 2014-10-09 dot Cricket Limited
  cricket
  
  // crown : 2014-10-24 Crown Equipment Corporation
  crown
  
  // crs : 2014-04-03 Federated Co-operatives Limited
  crs
  
  // cruise : 2015-12-10 Viking River Cruises (Bermuda) Ltd.
  cruise
  
  // cruises : 2013-12-05 Spring Way, LLC
  cruises
  
  // csc : 2014-09-25 Alliance-One Services, Inc.
  csc
  
  // cuisinella : 2014-04-03 SALM S.A.S.
  cuisinella
  
  // cymru : 2014-05-08 Nominet UK
  cymru
  
  // cyou : 2015-01-22 Beijing Gamease Age Digital Technology Co., Ltd.
  cyou
  
  // dabur : 2014-02-06 Dabur India Limited
  dabur
  
  // dad : 2014-01-23 Charleston Road Registry Inc.
  dad
  
  // dance : 2013-10-24 United TLD Holdco Ltd.
  dance
  
  // data : 2016-06-02 Dish DBS Corporation
  data
  
  // date : 2014-11-20 dot Date Limited
  date
  
  // dating : 2013-12-05 Pine Fest, LLC
  dating
  
  // datsun : 2014-03-27 NISSAN MOTOR CO., LTD.
  datsun
  
  // day : 2014-01-30 Charleston Road Registry Inc.
  day
  
  // dclk : 2014-11-20 Charleston Road Registry Inc.
  dclk
  
  // dds : 2015-05-07 Top Level Domain Holdings Limited
  dds
  
  // deal : 2015-06-25 Amazon EU S. r.l.
  deal
  
  // dealer : 2014-12-22 Dealer Dot Com, Inc.
  dealer
  
  // deals : 2014-05-22 Sand Sunset, LLC
  deals
  
  // degree : 2014-03-06
  degree
  
  // delivery : 2014-09-11 Steel Station, LLC
  delivery
  
  // dell : 2014-10-24 Dell Inc.
  dell
  
  // deloitte : 2015-07-31 Deloitte Touche Tohmatsu
  deloitte
  
  // delta : 2015-02-19 Delta Air Lines, Inc.
  delta
  
  // democrat : 2013-10-24 United TLD Holdco Ltd.
  democrat
  
  // dental : 2014-03-20 Tin Birch, LLC
  dental
  
  // dentist : 2014-03-20
  dentist
  
  // desi : 2013-11-14 Desi Networks LLC
  desi
  
  // design : 2014-11-07 Top Level Design, LLC
  design
  
  // dev : 2014-10-16 Charleston Road Registry Inc.
  dev
  
  // dhl : 2015-07-23 Deutsche Post AG
  dhl
  
  // diamonds : 2013-09-22 John Edge, LLC
  diamonds
  
  // diet : 2014-06-26 Uniregistry, Corp.
  diet
  
  // digital : 2014-03-06 Dash Park, LLC
  digital
  
  // direct : 2014-04-10 Half Trail, LLC
  direct
  
  // directory : 2013-09-20 Extra Madison, LLC
  directory
  
  // discount : 2014-03-06 Holly Hill, LLC
  discount
  
  // discover : 2015-07-23 Discover Financial Services
  discover
  
  // dish : 2015-07-30 Dish DBS Corporation
  dish
  
  // diy : 2015-11-05 Lifestyle Domain Holdings, Inc.
  diy
  
  // dnp : 2013-12-13 Dai Nippon Printing Co., Ltd.
  dnp
  
  // docs : 2014-10-16 Charleston Road Registry Inc.
  docs
  
  // doctor : 2016-06-02 Brice Trail, LLC
  doctor
  
  // dodge : 2015-07-30 FCA US LLC.
  dodge
  
  // dog : 2014-12-04 Koko Mill, LLC
  dog
  
  // doha : 2014-09-18 Communications Regulatory Authority (CRA)
  doha
  
  // domains : 2013-10-17 Sugar Cross, LLC
  domains
  
  // dot : 2015-05-21 Dish DBS Corporation
  dot
  
  // download : 2014-11-20 dot Support Limited
  download
  
  // drive : 2015-03-05 Charleston Road Registry Inc.
  drive
  
  // dtv : 2015-06-04 Dish DBS Corporation
  dtv
  
  // dubai : 2015-01-01 Dubai Smart Government Department
  dubai
  
  // duck : 2015-07-23 Johnson Shareholdings, Inc.
  duck
  
  // dunlop : 2015-07-02 The Goodyear Tire & Rubber Company
  dunlop
  
  // duns : 2015-08-06 The Dun & Bradstreet Corporation
  duns
  
  // dupont : 2015-06-25 E. I. du Pont de Nemours and Company
  dupont
  
  // durban : 2014-03-24 ZA Central Registry NPC trading as ZA Central Registry
  durban
  
  // dvag : 2014-06-23 Deutsche Vermgensberatung Aktiengesellschaft DVAG
  dvag
  
  // dvr : 2016-05-26 Hughes Satellite Systems Corporation
  dvr
  
  // earth : 2014-12-04 Interlink Co., Ltd.
  earth
  
  // eat : 2014-01-23 Charleston Road Registry Inc.
  eat
  
  // eco : 2016-07-08 Big Room Inc.
  eco
  
  // edeka : 2014-12-18 EDEKA Verband kaufmnnischer Genossenschaften e.V.
  edeka
  
  // education : 2013-11-07 Brice Way, LLC
  education
  
  // email : 2013-10-31 Spring Madison, LLC
  email
  
  // emerck : 2014-04-03 Merck KGaA
  emerck
  
  // energy : 2014-09-11 Binky Birch, LLC
  energy
  
  // engineer : 2014-03-06 United TLD Holdco Ltd.
  engineer
  
  // engineering : 2014-03-06 Romeo Canyon
  engineering
  
  // enterprises : 2013-09-20 Snow Oaks, LLC
  enterprises
  
  // epost : 2015-07-23 Deutsche Post AG
  epost
  
  // epson : 2014-12-04 Seiko Epson Corporation
  epson
  
  // equipment : 2013-08-27 Corn Station, LLC
  equipment
  
  // ericsson : 2015-07-09 Telefonaktiebolaget L M Ericsson
  ericsson
  
  // erni : 2014-04-03 ERNI Group Holding AG
  erni
  
  // esq : 2014-05-08 Charleston Road Registry Inc.
  esq
  
  // estate : 2013-08-27 Trixy Park, LLC
  estate
  
  // esurance : 2015-07-23 Esurance Insurance Company
  esurance
  
  // etisalat : 2015-09-03 Emirates Telecommunications Corporation (trading as Etisalat)
  etisalat
  
  // eurovision : 2014-04-24 European Broadcasting Union (EBU)
  eurovision
  
  // eus : 2013-12-12 Puntueus Fundazioa
  eus
  
  // events : 2013-12-05 Pioneer Maple, LLC
  events
  
  // everbank : 2014-05-15 EverBank
  everbank
  
  // exchange : 2014-03-06 Spring Falls, LLC
  exchange
  
  // expert : 2013-11-21 Magic Pass, LLC
  expert
  
  // exposed : 2013-12-05 Victor Beach, LLC
  exposed
  
  // express : 2015-02-11 Sea Sunset, LLC
  express
  
  // extraspace : 2015-05-14 Extra Space Storage LLC
  extraspace
  
  // fage : 2014-12-18 Fage International S.A.
  fage
  
  // fail : 2014-03-06 Atomic Pipe, LLC
  fail
  
  // fairwinds : 2014-11-13 FairWinds Partners, LLC
  fairwinds
  
  // faith : 2014-11-20 dot Faith Limited
  faith
  
  // family : 2015-04-02
  family
  
  // fan : 2014-03-06
  fan
  
  // fans : 2014-11-07 Asiamix Digital Limited
  fans
  
  // farm : 2013-11-07 Just Maple, LLC
  farm
  
  // farmers : 2015-07-09 Farmers Insurance Exchange
  farmers
  
  // fashion : 2014-07-03 Top Level Domain Holdings Limited
  fashion
  
  // fast : 2014-12-18 Amazon EU S. r.l.
  fast
  
  // fedex : 2015-08-06 Federal Express Corporation
  fedex
  
  // feedback : 2013-12-19 Top Level Spectrum, Inc.
  feedback
  
  // ferrari : 2015-07-31 Fiat Chrysler Automobiles N.V.
  ferrari
  
  // ferrero : 2014-12-18 Ferrero Trading Lux S.A.
  ferrero
  
  // fiat : 2015-07-31 Fiat Chrysler Automobiles N.V.
  fiat
  
  // fidelity : 2015-07-30 Fidelity Brokerage Services LLC
  fidelity
  
  // fido : 2015-08-06 Rogers Communications Partnership
  fido
  
  // film : 2015-01-08 Motion Picture Domain Registry Pty Ltd
  film
  
  // final : 2014-10-16 Ncleo de Informao e Coordenao do Ponto BR - NIC.br
  final
  
  // finance : 2014-03-20 Cotton Cypress, LLC
  finance
  
  // financial : 2014-03-06 Just Cover, LLC
  financial
  
  // fire : 2015-06-25 Amazon EU S. r.l.
  fire
  
  // firestone : 2014-12-18 Bridgestone Corporation
  firestone
  
  // firmdale : 2014-03-27 Firmdale Holdings Limited
  firmdale
  
  // fish : 2013-12-12 Fox Woods, LLC
  fish
  
  // fishing : 2013-11-21 Top Level Domain Holdings Limited
  fishing
  
  // fit : 2014-11-07 Top Level Domain Holdings Limited
  fit
  
  // fitness : 2014-03-06 Brice Orchard, LLC
  fitness
  
  // flickr : 2015-04-02 Yahoo! Domain Services Inc.
  flickr
  
  // flights : 2013-12-05 Fox Station, LLC
  flights
  
  // flir : 2015-07-23 FLIR Systems, Inc.
  flir
  
  // florist : 2013-11-07 Half Cypress, LLC
  florist
  
  // flowers : 2014-10-09 Uniregistry, Corp.
  flowers
  
  // fly : 2014-05-08 Charleston Road Registry Inc.
  fly
  
  // foo : 2014-01-23 Charleston Road Registry Inc.
  foo
  
  // food : 2016-04-21 Lifestyle Domain Holdings, Inc.
  food
  
  // foodnetwork : 2015-07-02 Lifestyle Domain Holdings, Inc.
  foodnetwork
  
  // football : 2014-12-18 Foggy Farms, LLC
  football
  
  // ford : 2014-11-13 Ford Motor Company
  ford
  
  // forex : 2014-12-11 IG Group Holdings PLC
  forex
  
  // forsale : 2014-05-22
  forsale
  
  // forum : 2015-04-02 Fegistry, LLC
  forum
  
  // foundation : 2013-12-05 John Dale, LLC
  foundation
  
  // fox : 2015-09-11 FOX Registry, LLC
  fox
  
  // free : 2015-12-10 Amazon EU S. r.l.
  free
  
  // fresenius : 2015-07-30 Fresenius Immobilien-Verwaltungs-GmbH
  fresenius
  
  // frl : 2014-05-15 FRLregistry B.V.
  frl
  
  // frogans : 2013-12-19 OP3FT
  frogans
  
  // frontdoor : 2015-07-02 Lifestyle Domain Holdings, Inc.
  frontdoor
  
  // frontier : 2015-02-05 Frontier Communications Corporation
  frontier
  
  // ftr : 2015-07-16 Frontier Communications Corporation
  ftr
  
  // fujitsu : 2015-07-30 Fujitsu Limited
  fujitsu
  
  // fujixerox : 2015-07-23 Xerox DNHC LLC
  fujixerox
  
  // fun : 2016-01-14
  fun
  
  // fund : 2014-03-20 John Castle, LLC
  fund
  
  // furniture : 2014-03-20 Lone Fields, LLC
  furniture
  
  // futbol : 2013-09-20
  futbol
  
  // fyi : 2015-04-02 Silver Tigers, LLC
  fyi
  
  // gal : 2013-11-07 Asociacin puntoGAL
  gal
  
  // gallery : 2013-09-13 Sugar House, LLC
  gallery
  
  // gallo : 2015-06-11 Gallo Vineyards, Inc.
  gallo
  
  // gallup : 2015-02-19 Gallup, Inc.
  gallup
  
  // game : 2015-05-28 Uniregistry, Corp.
  game
  
  // games : 2015-05-28
  games
  
  // gap : 2015-07-31 The Gap, Inc.
  gap
  
  // garden : 2014-06-26 Top Level Domain Holdings Limited
  garden
  
  // gbiz : 2014-07-17 Charleston Road Registry Inc.
  gbiz
  
  // gdn : 2014-07-31 Joint Stock Company "Navigation-information systems"
  gdn
  
  // gea : 2014-12-04 GEA Group Aktiengesellschaft
  gea
  
  // gent : 2014-01-23 COMBELL GROUP NV/SA
  gent
  
  // genting : 2015-03-12 Resorts World Inc Pte. Ltd.
  genting
  
  // george : 2015-07-31 Wal-Mart Stores, Inc.
  george
  
  // ggee : 2014-01-09 GMO Internet, Inc.
  ggee
  
  // gift : 2013-10-17 Uniregistry, Corp.
  gift
  
  // gifts : 2014-07-03 Goose Sky, LLC
  gifts
  
  // gives : 2014-03-06 United TLD Holdco Ltd.
  gives
  
  // giving : 2014-11-13 Giving Limited
  giving
  
  // glade : 2015-07-23 Johnson Shareholdings, Inc.
  glade
  
  // glass : 2013-11-07 Black Cover, LLC
  glass
  
  // gle : 2014-07-24 Charleston Road Registry Inc.
  gle
  
  // global : 2014-04-17 Dot GLOBAL AS
  global
  
  // globo : 2013-12-19 Globo Comunicao e Participaes S.A
  globo
  
  // gmail : 2014-05-01 Charleston Road Registry Inc.
  gmail
  
  // gmbh : 2016-01-29 Extra Dynamite, LLC
  gmbh
  
  // gmo : 2014-01-09 GMO Internet, Inc.
  gmo
  
  // gmx : 2014-04-24 1&1 Mail & Media GmbH
  gmx
  
  // godaddy : 2015-07-23 Go Daddy East, LLC
  godaddy
  
  // gold : 2015-01-22 June Edge, LLC
  gold
  
  // goldpoint : 2014-11-20 YODOBASHI CAMERA CO.,LTD.
  goldpoint
  
  // golf : 2014-12-18 Lone falls, LLC
  golf
  
  // goo : 2014-12-18 NTT Resonant Inc.
  goo
  
  // goodhands : 2015-07-31 Allstate Fire and Casualty Insurance Company
  goodhands
  
  // goodyear : 2015-07-02 The Goodyear Tire & Rubber Company
  goodyear
  
  // goog : 2014-11-20 Charleston Road Registry Inc.
  goog
  
  // google : 2014-07-24 Charleston Road Registry Inc.
  google
  
  // gop : 2014-01-16 Republican State Leadership Committee, Inc.
  gop
  
  // got : 2014-12-18 Amazon EU S. r.l.
  got
  
  // grainger : 2015-05-07 Grainger Registry Services, LLC
  grainger
  
  // graphics : 2013-09-13 Over Madison, LLC
  graphics
  
  // gratis : 2014-03-20 Pioneer Tigers, LLC
  gratis
  
  // green : 2014-05-08 Afilias Limited
  green
  
  // gripe : 2014-03-06 Corn Sunset, LLC
  gripe
  
  // grocery : 2016-06-16 Wal-Mart Stores, Inc.
  grocery
  
  // group : 2014-08-15 Romeo Town, LLC
  group
  
  // guardian : 2015-07-30 The Guardian Life Insurance Company of America
  guardian
  
  // gucci : 2014-11-13 Guccio Gucci S.p.a.
  gucci
  
  // guge : 2014-08-28 Charleston Road Registry Inc.
  guge
  
  // guide : 2013-09-13 Snow Moon, LLC
  guide
  
  // guitars : 2013-11-14 Uniregistry, Corp.
  guitars
  
  // guru : 2013-08-27 Pioneer Cypress, LLC
  guru
  
  // hair : 2015-12-03 L'Oral
  hair
  
  // hamburg : 2014-02-20 Hamburg Top-Level-Domain GmbH
  hamburg
  
  // hangout : 2014-11-13 Charleston Road Registry Inc.
  hangout
  
  // haus : 2013-12-05
  haus
  
  // hbo : 2015-07-30 HBO Registry Services, Inc.
  hbo
  
  // hdfc : 2015-07-30 HOUSING DEVELOPMENT FINANCE CORPORATION LIMITED
  hdfc
  
  // hdfcbank : 2015-02-12 HDFC Bank Limited
  hdfcbank
  
  // health : 2015-02-11 DotHealth, LLC
  health
  
  // healthcare : 2014-06-12 Silver Glen, LLC
  healthcare
  
  // help : 2014-06-26 Uniregistry, Corp.
  help
  
  // helsinki : 2015-02-05 City of Helsinki
  helsinki
  
  // here : 2014-02-06 Charleston Road Registry Inc.
  here
  
  // hermes : 2014-07-10 HERMES INTERNATIONAL
  hermes
  
  // hgtv : 2015-07-02 Lifestyle Domain Holdings, Inc.
  hgtv
  
  // hiphop : 2014-03-06 Uniregistry, Corp.
  hiphop
  
  // hisamitsu : 2015-07-16 Hisamitsu Pharmaceutical Co.,Inc.
  hisamitsu
  
  // hitachi : 2014-10-31 Hitachi, Ltd.
  hitachi
  
  // hiv : 2014-03-13
  hiv
  
  // hkt : 2015-05-14 PCCW-HKT DataCom Services Limited
  hkt
  
  // hockey : 2015-03-19 Half Willow, LLC
  hockey
  
  // holdings : 2013-08-27 John Madison, LLC
  holdings
  
  // holiday : 2013-11-07 Goose Woods, LLC
  holiday
  
  // homedepot : 2015-04-02 Homer TLC, Inc.
  homedepot
  
  // homegoods : 2015-07-16 The TJX Companies, Inc.
  homegoods
  
  // homes : 2014-01-09 DERHomes, LLC
  homes
  
  // homesense : 2015-07-16 The TJX Companies, Inc.
  homesense
  
  // honda : 2014-12-18 Honda Motor Co., Ltd.
  honda
  
  // honeywell : 2015-07-23 Honeywell GTLD LLC
  honeywell
  
  // horse : 2013-11-21 Top Level Domain Holdings Limited
  horse
  
  // hospital : 2016-10-20 Ruby Pike, LLC
  hospital
  
  // host : 2014-04-17 DotHost Inc.
  host
  
  // hosting : 2014-05-29 Uniregistry, Corp.
  hosting
  
  // hot : 2015-08-27 Amazon EU S. r.l.
  hot
  
  // hoteles : 2015-03-05 Travel Reservations SRL
  hoteles
  
  // hotels : 2016-04-07 Booking.com B.V.
  hotels
  
  // hotmail : 2014-12-18 Microsoft Corporation
  hotmail
  
  // house : 2013-11-07 Sugar Park, LLC
  house
  
  // how : 2014-01-23 Charleston Road Registry Inc.
  how
  
  // hsbc : 2014-10-24 HSBC Holdings PLC
  hsbc
  
  // hughes : 2015-07-30 Hughes Satellite Systems Corporation
  hughes
  
  // hyatt : 2015-07-30 Hyatt GTLD, L.L.C.
  hyatt
  
  // hyundai : 2015-07-09 Hyundai Motor Company
  hyundai
  
  // ibm : 2014-07-31 International Business Machines Corporation
  ibm
  
  // icbc : 2015-02-19 Industrial and Commercial Bank of China Limited
  icbc
  
  // ice : 2014-10-30 IntercontinentalExchange, Inc.
  ice
  
  // icu : 2015-01-08 One.com A/S
  icu
  
  // ieee : 2015-07-23 IEEE Global LLC
  ieee
  
  // ifm : 2014-01-30 ifm electronic gmbh
  ifm
  
  // ikano : 2015-07-09 Ikano S.A.
  ikano
  
  // imamat : 2015-08-06 Fondation Aga Khan (Aga Khan Foundation)
  imamat
  
  // imdb : 2015-06-25 Amazon EU S. r.l.
  imdb
  
  // immo : 2014-07-10 Auburn Bloom, LLC
  immo
  
  // immobilien : 2013-11-07 United TLD Holdco Ltd.
  immobilien
  
  // industries : 2013-12-05 Outer House, LLC
  industries
  
  // infiniti : 2014-03-27 NISSAN MOTOR CO., LTD.
  infiniti
  
  // ing : 2014-01-23 Charleston Road Registry Inc.
  ing
  
  // ink : 2013-12-05 Top Level Design, LLC
  ink
  
  // institute : 2013-11-07 Outer Maple, LLC
  institute
  
  // insurance : 2015-02-19 fTLD Registry Services LLC
  insurance
  
  // insure : 2014-03-20 Pioneer Willow, LLC
  insure
  
  // intel : 2015-08-06 Intel Corporation
  intel
  
  // international : 2013-11-07 Wild Way, LLC
  international
  
  // intuit : 2015-07-30 Intuit Administrative Services, Inc.
  intuit
  
  // investments : 2014-03-20 Holly Glen, LLC
  investments
  
  // ipiranga : 2014-08-28 Ipiranga Produtos de Petroleo S.A.
  ipiranga
  
  // irish : 2014-08-07 Dot-Irish LLC
  irish
  
  // iselect : 2015-02-11 iSelect Ltd
  iselect
  
  // ismaili : 2015-08-06 Fondation Aga Khan (Aga Khan Foundation)
  ismaili
  
  // ist : 2014-08-28 Istanbul Metropolitan Municipality
  ist
  
  // istanbul : 2014-08-28 Istanbul Metropolitan Municipality
  istanbul
  
  // itau : 2014-10-02 Itau Unibanco Holding S.A.
  itau
  
  // itv : 2015-07-09 ITV Services Limited
  itv
  
  // iveco : 2015-09-03 CNH Industrial N.V.
  iveco
  
  // iwc : 2014-06-23 Richemont DNS Inc.
  iwc
  
  // jaguar : 2014-11-13 Jaguar Land Rover Ltd
  jaguar
  
  // java : 2014-06-19 Oracle Corporation
  java
  
  // jcb : 2014-11-20 JCB Co., Ltd.
  jcb
  
  // jcp : 2015-04-23 JCP Media, Inc.
  jcp
  
  // jeep : 2015-07-30 FCA US LLC.
  jeep
  
  // jetzt : 2014-01-09
  jetzt
  
  // jewelry : 2015-03-05 Wild Bloom, LLC
  jewelry
  
  // jio : 2015-04-02 Affinity Names, Inc.
  jio
  
  // jlc : 2014-12-04 Richemont DNS Inc.
  jlc
  
  // jll : 2015-04-02 Jones Lang LaSalle Incorporated
  jll
  
  // jmp : 2015-03-26 Matrix IP LLC
  jmp
  
  // jnj : 2015-06-18 Johnson & Johnson Services, Inc.
  jnj
  
  // joburg : 2014-03-24 ZA Central Registry NPC trading as ZA Central Registry
  joburg
  
  // jot : 2014-12-18 Amazon EU S. r.l.
  jot
  
  // joy : 2014-12-18 Amazon EU S. r.l.
  joy
  
  // jpmorgan : 2015-04-30 JPMorgan Chase & Co.
  jpmorgan
  
  // jprs : 2014-09-18 Japan Registry Services Co., Ltd.
  jprs
  
  // juegos : 2014-03-20 Uniregistry, Corp.
  juegos
  
  // juniper : 2015-07-30 JUNIPER NETWORKS, INC.
  juniper
  
  // kaufen : 2013-11-07 United TLD Holdco Ltd.
  kaufen
  
  // kddi : 2014-09-12 KDDI CORPORATION
  kddi
  
  // kerryhotels : 2015-04-30 Kerry Trading Co. Limited
  kerryhotels
  
  // kerrylogistics : 2015-04-09 Kerry Trading Co. Limited
  kerrylogistics
  
  // kerryproperties : 2015-04-09 Kerry Trading Co. Limited
  kerryproperties
  
  // kfh : 2014-12-04 Kuwait Finance House
  kfh
  
  // kia : 2015-07-09 KIA MOTORS CORPORATION
  kia
  
  // kim : 2013-09-23 Afilias Limited
  kim
  
  // kinder : 2014-11-07 Ferrero Trading Lux S.A.
  kinder
  
  // kindle : 2015-06-25 Amazon EU S. r.l.
  kindle
  
  // kitchen : 2013-09-20 Just Goodbye, LLC
  kitchen
  
  // kiwi : 2013-09-20 DOT KIWI LIMITED
  kiwi
  
  // koeln : 2014-01-09 NetCologne Gesellschaft fr Telekommunikation mbH
  koeln
  
  // komatsu : 2015-01-08 Komatsu Ltd.
  komatsu
  
  // kosher : 2015-08-20 Kosher Marketing Assets LLC
  kosher
  
  // kpmg : 2015-04-23 KPMG International Cooperative (KPMG International Genossenschaft)
  kpmg
  
  // kpn : 2015-01-08 Koninklijke KPN N.V.
  kpn
  
  // krd : 2013-12-05 KRG Department of Information Technology
  krd
  
  // kred : 2013-12-19 KredTLD Pty Ltd
  kred
  
  // kuokgroup : 2015-04-09 Kerry Trading Co. Limited
  kuokgroup
  
  // kyoto : 2014-11-07 Academic Institution: Kyoto Jyoho Gakuen
  kyoto
  
  // lacaixa : 2014-01-09 CAIXA D'ESTALVIS I PENSIONS DE BARCELONA
  lacaixa
  
  // ladbrokes : 2015-08-06 LADBROKES INTERNATIONAL PLC
  ladbrokes
  
  // lamborghini : 2015-06-04 Automobili Lamborghini S.p.A.
  lamborghini
  
  // lamer : 2015-10-01 The Este Lauder Companies Inc.
  lamer
  
  // lancaster : 2015-02-12 LANCASTER
  lancaster
  
  // lancia : 2015-07-31 Fiat Chrysler Automobiles N.V.
  lancia
  
  // lancome : 2015-07-23 L'Oral
  lancome
  
  // land : 2013-09-10 Pine Moon, LLC
  land
  
  // landrover : 2014-11-13 Jaguar Land Rover Ltd
  landrover
  
  // lanxess : 2015-07-30 LANXESS Corporation
  lanxess
  
  // lasalle : 2015-04-02 Jones Lang LaSalle Incorporated
  lasalle
  
  // lat : 2014-10-16 ECOM-LAC Federacin de Latinoamrica y el Caribe para Internet y el Comercio Electrnico
  lat
  
  // latino : 2015-07-30 Dish DBS Corporation
  latino
  
  // latrobe : 2014-06-16 La Trobe University
  latrobe
  
  // law : 2015-01-22 Minds + Machines Group Limited
  law
  
  // lawyer : 2014-03-20
  lawyer
  
  // lds : 2014-03-20 IRI Domain Management, LLC ("Applicant")
  lds
  
  // lease : 2014-03-06 Victor Trail, LLC
  lease
  
  // leclerc : 2014-08-07 A.C.D. LEC Association des Centres Distributeurs Edouard Leclerc
  leclerc
  
  // lefrak : 2015-07-16 LeFrak Organization, Inc.
  lefrak
  
  // legal : 2014-10-16 Blue Falls, LLC
  legal
  
  // lego : 2015-07-16 LEGO Juris A/S
  lego
  
  // lexus : 2015-04-23 TOYOTA MOTOR CORPORATION
  lexus
  
  // lgbt : 2014-05-08 Afilias Limited
  lgbt
  
  // liaison : 2014-10-02 Liaison Technologies, Incorporated
  liaison
  
  // lidl : 2014-09-18 Schwarz Domains und Services GmbH & Co. KG
  lidl
  
  // life : 2014-02-06 Trixy Oaks, LLC
  life
  
  // lifeinsurance : 2015-01-15 American Council of Life Insurers
  lifeinsurance
  
  // lifestyle : 2014-12-11 Lifestyle Domain Holdings, Inc.
  lifestyle
  
  // lighting : 2013-08-27 John McCook, LLC
  lighting
  
  // like : 2014-12-18 Amazon EU S. r.l.
  like
  
  // lilly : 2015-07-31 Eli Lilly and Company
  lilly
  
  // limited : 2014-03-06 Big Fest, LLC
  limited
  
  // limo : 2013-10-17 Hidden Frostbite, LLC
  limo
  
  // lincoln : 2014-11-13 Ford Motor Company
  lincoln
  
  // linde : 2014-12-04 Linde Aktiengesellschaft
  linde
  
  // link : 2013-11-14 Uniregistry, Corp.
  link
  
  // lipsy : 2015-06-25 Lipsy Ltd
  lipsy
  
  // live : 2014-12-04
  live
  
  // living : 2015-07-30 Lifestyle Domain Holdings, Inc.
  living
  
  // lixil : 2015-03-19 LIXIL Group Corporation
  lixil
  
  // loan : 2014-11-20 dot Loan Limited
  loan
  
  // loans : 2014-03-20 June Woods, LLC
  loans
  
  // locker : 2015-06-04 Dish DBS Corporation
  locker
  
  // locus : 2015-06-25 Locus Analytics LLC
  locus
  
  // loft : 2015-07-30 Annco, Inc.
  loft
  
  // lol : 2015-01-30 Uniregistry, Corp.
  lol
  
  // london : 2013-11-14 Dot London Domains Limited
  london
  
  // lotte : 2014-11-07 Lotte Holdings Co., Ltd.
  lotte
  
  // lotto : 2014-04-10 Afilias Limited
  lotto
  
  // love : 2014-12-22 Merchant Law Group LLP
  love
  
  // lpl : 2015-07-30 LPL Holdings, Inc.
  lpl
  
  // lplfinancial : 2015-07-30 LPL Holdings, Inc.
  lplfinancial
  
  // ltd : 2014-09-25 Over Corner, LLC
  ltd
  
  // ltda : 2014-04-17 DOMAIN ROBOT SERVICOS DE HOSPEDAGEM NA INTERNET LTDA
  ltda
  
  // lundbeck : 2015-08-06 H. Lundbeck A/S
  lundbeck
  
  // lupin : 2014-11-07 LUPIN LIMITED
  lupin
  
  // luxe : 2014-01-09 Top Level Domain Holdings Limited
  luxe
  
  // luxury : 2013-10-17 Luxury Partners, LLC
  luxury
  
  // macys : 2015-07-31 Macys, Inc.
  macys
  
  // madrid : 2014-05-01 Comunidad de Madrid
  madrid
  
  // maif : 2014-10-02 Mutuelle Assurance Instituteur France (MAIF)
  maif
  
  // maison : 2013-12-05 Victor Frostbite, LLC
  maison
  
  // makeup : 2015-01-15 L'Oral
  makeup
  
  // man : 2014-12-04 MAN SE
  man
  
  // management : 2013-11-07 John Goodbye, LLC
  management
  
  // mango : 2013-10-24 PUNTO FA S.L.
  mango
  
  // map : 2016-06-09 Charleston Road Registry Inc.
  map
  
  // market : 2014-03-06
  market
  
  // marketing : 2013-11-07 Fern Pass, LLC
  marketing
  
  // markets : 2014-12-11 IG Group Holdings PLC
  markets
  
  // marriott : 2014-10-09 Marriott Worldwide Corporation
  marriott
  
  // marshalls : 2015-07-16 The TJX Companies, Inc.
  marshalls
  
  // maserati : 2015-07-31 Fiat Chrysler Automobiles N.V.
  maserati
  
  // mattel : 2015-08-06 Mattel Sites, Inc.
  mattel
  
  // mba : 2015-04-02 Lone Hollow, LLC
  mba
  
  // mckinsey : 2015-07-31 McKinsey Holdings, Inc.
  mckinsey
  
  // med : 2015-08-06 Medistry LLC
  med
  
  // media : 2014-03-06 Grand Glen, LLC
  media
  
  // meet : 2014-01-16
  meet
  
  // melbourne : 2014-05-29 The Crown in right of the State of Victoria, represented by its Department of State Development, Business and Innovation
  melbourne
  
  // meme : 2014-01-30 Charleston Road Registry Inc.
  meme
  
  // memorial : 2014-10-16 Dog Beach, LLC
  memorial
  
  // men : 2015-02-26 Exclusive Registry Limited
  men
  
  // menu : 2013-09-11 Wedding TLD2, LLC
  menu
  
  // meo : 2014-11-07 PT Comunicacoes S.A.
  meo
  
  // merckmsd : 2016-07-14 MSD Registry Holdings, Inc.
  merckmsd
  
  // metlife : 2015-05-07 MetLife Services and Solutions, LLC
  metlife
  
  // miami : 2013-12-19 Top Level Domain Holdings Limited
  miami
  
  // microsoft : 2014-12-18 Microsoft Corporation
  microsoft
  
  // mini : 2014-01-09 Bayerische Motoren Werke Aktiengesellschaft
  mini
  
  // mint : 2015-07-30 Intuit Administrative Services, Inc.
  mint
  
  // mit : 2015-07-02 Massachusetts Institute of Technology
  mit
  
  // mitsubishi : 2015-07-23 Mitsubishi Corporation
  mitsubishi
  
  // mlb : 2015-05-21 MLB Advanced Media DH, LLC
  mlb
  
  // mls : 2015-04-23 The Canadian Real Estate Association
  mls
  
  // mma : 2014-11-07 MMA IARD
  mma
  
  // mobile : 2016-06-02 Dish DBS Corporation
  mobile
  
  // mobily : 2014-12-18 GreenTech Consultancy Company W.L.L.
  mobily
  
  // moda : 2013-11-07 United TLD Holdco Ltd.
  moda
  
  // moe : 2013-11-13 Interlink Co., Ltd.
  moe
  
  // moi : 2014-12-18 Amazon EU S. r.l.
  moi
  
  // mom : 2015-04-16 Uniregistry, Corp.
  mom
  
  // monash : 2013-09-30 Monash University
  monash
  
  // money : 2014-10-16 Outer McCook, LLC
  money
  
  // monster : 2015-09-11 Monster Worldwide, Inc.
  monster
  
  // mopar : 2015-07-30 FCA US LLC.
  mopar
  
  // mormon : 2013-12-05 IRI Domain Management, LLC ("Applicant")
  mormon
  
  // mortgage : 2014-03-20
  mortgage
  
  // moscow : 2013-12-19 Foundation for Assistance for Internet Technologies and Infrastructure Development (FAITID)
  moscow
  
  // moto : 2015-06-04
  moto
  
  // motorcycles : 2014-01-09 DERMotorcycles, LLC
  motorcycles
  
  // mov : 2014-01-30 Charleston Road Registry Inc.
  mov
  
  // movie : 2015-02-05 New Frostbite, LLC
  movie
  
  // movistar : 2014-10-16 Telefnica S.A.
  movistar
  
  // msd : 2015-07-23 MSD Registry Holdings, Inc.
  msd
  
  // mtn : 2014-12-04 MTN Dubai Limited
  mtn
  
  // mtpc : 2014-11-20 Mitsubishi Tanabe Pharma Corporation
  mtpc
  
  // mtr : 2015-03-12 MTR Corporation Limited
  mtr
  
  // mutual : 2015-04-02 Northwestern Mutual MU TLD Registry, LLC
  mutual
  
  // nab : 2015-08-20 National Australia Bank Limited
  nab
  
  // nadex : 2014-12-11 IG Group Holdings PLC
  nadex
  
  // nagoya : 2013-10-24 GMO Registry, Inc.
  nagoya
  
  // nationwide : 2015-07-23 Nationwide Mutual Insurance Company
  nationwide
  
  // natura : 2015-03-12 NATURA COSMTICOS S.A.
  natura
  
  // navy : 2014-03-06 United TLD Holdco Ltd.
  navy
  
  // nba : 2015-07-31 NBA REGISTRY, LLC
  nba
  
  // nec : 2015-01-08 NEC Corporation
  nec
  
  // netbank : 2014-06-26 COMMONWEALTH BANK OF AUSTRALIA
  netbank
  
  // netflix : 2015-06-18 Netflix, Inc.
  netflix
  
  // network : 2013-11-14 Trixy Manor, LLC
  network
  
  // neustar : 2013-12-05 NeuStar, Inc.
  neustar
  
  // new : 2014-01-30 Charleston Road Registry Inc.
  new
  
  // newholland : 2015-09-03 CNH Industrial N.V.
  newholland
  
  // news : 2014-12-18
  news
  
  // next : 2015-06-18 Next plc
  next
  
  // nextdirect : 2015-06-18 Next plc
  nextdirect
  
  // nexus : 2014-07-24 Charleston Road Registry Inc.
  nexus
  
  // nfl : 2015-07-23 NFL Reg Ops LLC
  nfl
  
  // ngo : 2014-03-06 Public Interest Registry
  ngo
  
  // nhk : 2014-02-13 Japan Broadcasting Corporation (NHK)
  nhk
  
  // nico : 2014-12-04 DWANGO Co., Ltd.
  nico
  
  // nike : 2015-07-23 NIKE, Inc.
  nike
  
  // nikon : 2015-05-21 NIKON CORPORATION
  nikon
  
  // ninja : 2013-11-07 United TLD Holdco Ltd.
  ninja
  
  // nissan : 2014-03-27 NISSAN MOTOR CO., LTD.
  nissan
  
  // nissay : 2015-10-29 Nippon Life Insurance Company
  nissay
  
  // nokia : 2015-01-08 Nokia Corporation
  nokia
  
  // northwesternmutual : 2015-06-18 Northwestern Mutual Registry, LLC
  northwesternmutual
  
  // norton : 2014-12-04 Symantec Corporation
  norton
  
  // now : 2015-06-25 Amazon EU S. r.l.
  now
  
  // nowruz : 2014-09-04 Asia Green IT System Bilgisayar San. ve Tic. Ltd. Sti.
  nowruz
  
  // nowtv : 2015-05-14 Starbucks (HK) Limited
  nowtv
  
  // nra : 2014-05-22 NRA Holdings Company, INC.
  nra
  
  // nrw : 2013-11-21 Minds + Machines GmbH
  nrw
  
  // ntt : 2014-10-31 NIPPON TELEGRAPH AND TELEPHONE CORPORATION
  ntt
  
  // nyc : 2014-01-23 The City of New York by and through the New York City Department of Information Technology & Telecommunications
  nyc
  
  // obi : 2014-09-25 OBI Group Holding SE & Co. KGaA
  obi
  
  // observer : 2015-04-30
  observer
  
  // off : 2015-07-23 Johnson Shareholdings, Inc.
  off
  
  // office : 2015-03-12 Microsoft Corporation
  office
  
  // okinawa : 2013-12-05 BusinessRalliart Inc.
  okinawa
  
  // olayan : 2015-05-14 Crescent Holding GmbH
  olayan
  
  // olayangroup : 2015-05-14 Crescent Holding GmbH
  olayangroup
  
  // oldnavy : 2015-07-31 The Gap, Inc.
  oldnavy
  
  // ollo : 2015-06-04 Dish DBS Corporation
  ollo
  
  // omega : 2015-01-08 The Swatch Group Ltd
  omega
  
  // one : 2014-11-07 One.com A/S
  one
  
  // ong : 2014-03-06 Public Interest Registry
  ong
  
  // onl : 2013-09-16 I-Registry Ltd.
  onl
  
  // online : 2015-01-15 DotOnline Inc.
  online
  
  // onyourside : 2015-07-23 Nationwide Mutual Insurance Company
  onyourside
  
  // ooo : 2014-01-09 INFIBEAM INCORPORATION LIMITED
  ooo
  
  // open : 2015-07-31 American Express Travel Related Services Company, Inc.
  open
  
  // oracle : 2014-06-19 Oracle Corporation
  oracle
  
  // orange : 2015-03-12 Orange Brand Services Limited
  orange
  
  // organic : 2014-03-27 Afilias Limited
  organic
  
  // origins : 2015-10-01 The Este Lauder Companies Inc.
  origins
  
  // osaka : 2014-09-04 Interlink Co., Ltd.
  osaka
  
  // otsuka : 2013-10-11 Otsuka Holdings Co., Ltd.
  otsuka
  
  // ott : 2015-06-04 Dish DBS Corporation
  ott
  
  // ovh : 2014-01-16 OVH SAS
  ovh
  
  // page : 2014-12-04 Charleston Road Registry Inc.
  page
  
  // panasonic : 2015-07-30 Panasonic Corporation
  panasonic
  
  // panerai : 2014-11-07 Richemont DNS Inc.
  panerai
  
  // paris : 2014-01-30 City of Paris
  paris
  
  // pars : 2014-09-04 Asia Green IT System Bilgisayar San. ve Tic. Ltd. Sti.
  pars
  
  // partners : 2013-12-05 Magic Glen, LLC
  partners
  
  // parts : 2013-12-05 Sea Goodbye, LLC
  parts
  
  // party : 2014-09-11 Blue Sky Registry Limited
  party
  
  // passagens : 2015-03-05 Travel Reservations SRL
  passagens
  
  // pay : 2015-08-27 Amazon EU S. r.l.
  pay
  
  // pccw : 2015-05-14 PCCW Enterprises Limited
  pccw
  
  // pet : 2015-05-07 Afilias plc
  pet
  
  // pfizer : 2015-09-11 Pfizer Inc.
  pfizer
  
  // pharmacy : 2014-06-19 National Association of Boards of Pharmacy
  pharmacy
  
  // phd : 2016-07-28 Charleston Road Registry Inc.
  phd
  
  // philips : 2014-11-07 Koninklijke Philips N.V.
  philips
  
  // phone : 2016-06-02 Dish DBS Corporation
  phone
  
  // photo : 2013-11-14 Uniregistry, Corp.
  photo
  
  // photography : 2013-09-20 Sugar Glen, LLC
  photography
  
  // photos : 2013-10-17 Sea Corner, LLC
  photos
  
  // physio : 2014-05-01 PhysBiz Pty Ltd
  physio
  
  // piaget : 2014-10-16 Richemont DNS Inc.
  piaget
  
  // pics : 2013-11-14 Uniregistry, Corp.
  pics
  
  // pictet : 2014-06-26 Pictet Europe S.A.
  pictet
  
  // pictures : 2014-03-06 Foggy Sky, LLC
  pictures
  
  // pid : 2015-01-08 Top Level Spectrum, Inc.
  pid
  
  // pin : 2014-12-18 Amazon EU S. r.l.
  pin
  
  // ping : 2015-06-11 Ping Registry Provider, Inc.
  ping
  
  // pink : 2013-10-01 Afilias Limited
  pink
  
  // pioneer : 2015-07-16 Pioneer Corporation
  pioneer
  
  // pizza : 2014-06-26 Foggy Moon, LLC
  pizza
  
  // place : 2014-04-24 Snow Galley, LLC
  place
  
  // play : 2015-03-05 Charleston Road Registry Inc.
  play
  
  // playstation : 2015-07-02 Sony Computer Entertainment Inc.
  playstation
  
  // plumbing : 2013-09-10 Spring Tigers, LLC
  plumbing
  
  // plus : 2015-02-05 Sugar Mill, LLC
  plus
  
  // pnc : 2015-07-02 PNC Domain Co., LLC
  pnc
  
  // pohl : 2014-06-23 Deutsche Vermgensberatung Aktiengesellschaft DVAG
  pohl
  
  // poker : 2014-07-03 Afilias Domains No. 5 Limited
  poker
  
  // politie : 2015-08-20 Politie Nederland
  politie
  
  // porn : 2014-10-16 ICM Registry PN LLC
  porn
  
  // pramerica : 2015-07-30 Prudential Financial, Inc.
  pramerica
  
  // praxi : 2013-12-05 Praxi S.p.A.
  praxi
  
  // press : 2014-04-03 DotPress Inc.
  press
  
  // prime : 2015-06-25 Amazon EU S. r.l.
  prime
  
  // prod : 2014-01-23 Charleston Road Registry Inc.
  prod
  
  // productions : 2013-12-05 Magic Birch, LLC
  productions
  
  // prof : 2014-07-24 Charleston Road Registry Inc.
  prof
  
  // progressive : 2015-07-23 Progressive Casualty Insurance Company
  progressive
  
  // promo : 2014-12-18
  promo
  
  // properties : 2013-12-05 Big Pass, LLC
  properties
  
  // property : 2014-05-22 Uniregistry, Corp.
  property
  
  // protection : 2015-04-23
  protection
  
  // pru : 2015-07-30 Prudential Financial, Inc.
  pru
  
  // prudential : 2015-07-30 Prudential Financial, Inc.
  prudential
  
  // pub : 2013-12-12 United TLD Holdco Ltd.
  pub
  
  // pwc : 2015-10-29 PricewaterhouseCoopers LLP
  pwc
  
  // qpon : 2013-11-14 dotCOOL, Inc.
  qpon
  
  // quebec : 2013-12-19 PointQubec Inc
  quebec
  
  // quest : 2015-03-26 Quest ION Limited
  quest
  
  // qvc : 2015-07-30 QVC, Inc.
  qvc
  
  // racing : 2014-12-04 Premier Registry Limited
  racing
  
  // radio : 2016-07-21 European Broadcasting Union (EBU)
  radio
  
  // raid : 2015-07-23 Johnson Shareholdings, Inc.
  raid
  
  // read : 2014-12-18 Amazon EU S. r.l.
  read
  
  // realestate : 2015-09-11 dotRealEstate LLC
  realestate
  
  // realtor : 2014-05-29 Real Estate Domains LLC
  realtor
  
  // realty : 2015-03-19 Fegistry, LLC
  realty
  
  // recipes : 2013-10-17 Grand Island, LLC
  recipes
  
  // red : 2013-11-07 Afilias Limited
  red
  
  // redstone : 2014-10-31 Redstone Haute Couture Co., Ltd.
  redstone
  
  // redumbrella : 2015-03-26 Travelers TLD, LLC
  redumbrella
  
  // rehab : 2014-03-06 United TLD Holdco Ltd.
  rehab
  
  // reise : 2014-03-13
  reise
  
  // reisen : 2014-03-06 New Cypress, LLC
  reisen
  
  // reit : 2014-09-04 National Association of Real Estate Investment Trusts, Inc.
  reit
  
  // reliance : 2015-04-02 Reliance Industries Limited
  reliance
  
  // ren : 2013-12-12 Beijing Qianxiang Wangjing Technology Development Co., Ltd.
  ren
  
  // rent : 2014-12-04 DERRent, LLC
  rent
  
  // rentals : 2013-12-05 Big Hollow,LLC
  rentals
  
  // repair : 2013-11-07 Lone Sunset, LLC
  repair
  
  // report : 2013-12-05 Binky Glen, LLC
  report
  
  // republican : 2014-03-20 United TLD Holdco Ltd.
  republican
  
  // rest : 2013-12-19 Punto 2012 Sociedad Anonima Promotora de Inversion de Capital Variable
  rest
  
  // restaurant : 2014-07-03 Snow Avenue, LLC
  restaurant
  
  // review : 2014-11-20 dot Review Limited
  review
  
  // reviews : 2013-09-13
  reviews
  
  // rexroth : 2015-06-18 Robert Bosch GMBH
  rexroth
  
  // rich : 2013-11-21 I-Registry Ltd.
  rich
  
  // richardli : 2015-05-14 Pacific Century Asset Management (HK) Limited
  richardli
  
  // ricoh : 2014-11-20 Ricoh Company, Ltd.
  ricoh
  
  // rightathome : 2015-07-23 Johnson Shareholdings, Inc.
  rightathome
  
  // ril : 2015-04-02 Reliance Industries Limited
  ril
  
  // rio : 2014-02-27 Empresa Municipal de Informtica SA - IPLANRIO
  rio
  
  // rip : 2014-07-10 United TLD Holdco Ltd.
  rip
  
  // rmit : 2015-11-19 Royal Melbourne Institute of Technology
  rmit
  
  // rocher : 2014-12-18 Ferrero Trading Lux S.A.
  rocher
  
  // rocks : 2013-11-14
  rocks
  
  // rodeo : 2013-12-19 Top Level Domain Holdings Limited
  rodeo
  
  // rogers : 2015-08-06 Rogers Communications Partnership
  rogers
  
  // room : 2014-12-18 Amazon EU S. r.l.
  room
  
  // rsvp : 2014-05-08 Charleston Road Registry Inc.
  rsvp
  
  // rugby : 2016-12-15 World Rugby Strategic Developments Limited
  rugby
  
  // ruhr : 2013-10-02 regiodot GmbH & Co. KG
  ruhr
  
  // run : 2015-03-19 Snow Park, LLC
  run
  
  // rwe : 2015-04-02 RWE AG
  rwe
  
  // ryukyu : 2014-01-09 BusinessRalliart Inc.
  ryukyu
  
  // saarland : 2013-12-12 dotSaarland GmbH
  saarland
  
  // safe : 2014-12-18 Amazon EU S. r.l.
  safe
  
  // safety : 2015-01-08 Safety Registry Services, LLC.
  safety
  
  // sakura : 2014-12-18 SAKURA Internet Inc.
  sakura
  
  // sale : 2014-10-16
  sale
  
  // salon : 2014-12-11 Outer Orchard, LLC
  salon
  
  // samsclub : 2015-07-31 Wal-Mart Stores, Inc.
  samsclub
  
  // samsung : 2014-04-03 SAMSUNG SDS CO., LTD
  samsung
  
  // sandvik : 2014-11-13 Sandvik AB
  sandvik
  
  // sandvikcoromant : 2014-11-07 Sandvik AB
  sandvikcoromant
  
  // sanofi : 2014-10-09 Sanofi
  sanofi
  
  // sap : 2014-03-27 SAP AG
  sap
  
  // sapo : 2014-11-07 PT Comunicacoes S.A.
  sapo
  
  // sarl : 2014-07-03 Delta Orchard, LLC
  sarl
  
  // sas : 2015-04-02 Research IP LLC
  sas
  
  // save : 2015-06-25 Amazon EU S. r.l.
  save
  
  // saxo : 2014-10-31 Saxo Bank A/S
  saxo
  
  // sbi : 2015-03-12 STATE BANK OF INDIA
  sbi
  
  // sbs : 2014-11-07 SPECIAL BROADCASTING SERVICE CORPORATION
  sbs
  
  // sca : 2014-03-13 SVENSKA CELLULOSA AKTIEBOLAGET SCA (publ)
  sca
  
  // scb : 2014-02-20 The Siam Commercial Bank Public Company Limited ("SCB")
  scb
  
  // schaeffler : 2015-08-06 Schaeffler Technologies AG & Co. KG
  schaeffler
  
  // schmidt : 2014-04-03 SALM S.A.S.
  schmidt
  
  // scholarships : 2014-04-24 Scholarships.com, LLC
  scholarships
  
  // school : 2014-12-18 Little Galley, LLC
  school
  
  // schule : 2014-03-06 Outer Moon, LLC
  schule
  
  // schwarz : 2014-09-18 Schwarz Domains und Services GmbH & Co. KG
  schwarz
  
  // science : 2014-09-11 dot Science Limited
  science
  
  // scjohnson : 2015-07-23 Johnson Shareholdings, Inc.
  scjohnson
  
  // scor : 2014-10-31 SCOR SE
  scor
  
  // scot : 2014-01-23 Dot Scot Registry Limited
  scot
  
  // search : 2016-06-09 Charleston Road Registry Inc.
  search
  
  // seat : 2014-05-22 SEAT, S.A. (Sociedad Unipersonal)
  seat
  
  // secure : 2015-08-27 Amazon EU S. r.l.
  secure
  
  // security : 2015-05-14
  security
  
  // seek : 2014-12-04 Seek Limited
  seek
  
  // select : 2015-10-08 iSelect Ltd
  select
  
  // sener : 2014-10-24 Sener Ingeniera y Sistemas, S.A.
  sener
  
  // services : 2014-02-27 Fox Castle, LLC
  services
  
  // ses : 2015-07-23 SES
  ses
  
  // seven : 2015-08-06 Seven West Media Ltd
  seven
  
  // sew : 2014-07-17 SEW-EURODRIVE GmbH & Co KG
  sew
  
  // sex : 2014-11-13 ICM Registry SX LLC
  sex
  
  // sexy : 2013-09-11 Uniregistry, Corp.
  sexy
  
  // sfr : 2015-08-13 Societe Francaise du Radiotelephone - SFR
  sfr
  
  // shangrila : 2015-09-03 ShangriLa International Hotel Management Limited
  shangrila
  
  // sharp : 2014-05-01 Sharp Corporation
  sharp
  
  // shaw : 2015-04-23 Shaw Cablesystems G.P.
  shaw
  
  // shell : 2015-07-30 Shell Information Technology International Inc
  shell
  
  // shia : 2014-09-04 Asia Green IT System Bilgisayar San. ve Tic. Ltd. Sti.
  shia
  
  // shiksha : 2013-11-14 Afilias Limited
  shiksha
  
  // shoes : 2013-10-02 Binky Galley, LLC
  shoes
  
  // shop : 2016-04-08 GMO Registry, Inc.
  shop
  
  // shopping : 2016-03-31
  shopping
  
  // shouji : 2015-01-08 QIHOO 360 TECHNOLOGY CO. LTD.
  shouji
  
  // show : 2015-03-05 Snow Beach, LLC
  show
  
  // showtime : 2015-08-06 CBS Domains Inc.
  showtime
  
  // shriram : 2014-01-23 Shriram Capital Ltd.
  shriram
  
  // silk : 2015-06-25 Amazon EU S. r.l.
  silk
  
  // sina : 2015-03-12 Sina Corporation
  sina
  
  // singles : 2013-08-27 Fern Madison, LLC
  singles
  
  // site : 2015-01-15 DotSite Inc.
  site
  
  // ski : 2015-04-09 STARTING DOT LIMITED
  ski
  
  // skin : 2015-01-15 L'Oral
  skin
  
  // sky : 2014-06-19 Sky IP International Ltd, a company incorporated in England and Wales, operating via its registered Swiss branch
  sky
  
  // skype : 2014-12-18 Microsoft Corporation
  skype
  
  // sling : 2015-07-30 Hughes Satellite Systems Corporation
  sling
  
  // smart : 2015-07-09 Smart Communications, Inc. (SMART)
  smart
  
  // smile : 2014-12-18 Amazon EU S. r.l.
  smile
  
  // sncf : 2015-02-19 Socit Nationale des Chemins de fer Francais S N C F
  sncf
  
  // soccer : 2015-03-26 Foggy Shadow, LLC
  soccer
  
  // social : 2013-11-07 United TLD Holdco Ltd.
  social
  
  // softbank : 2015-07-02 SoftBank Corp.
  softbank
  
  // software : 2014-03-20
  software
  
  // sohu : 2013-12-19 Sohu.com Limited
  sohu
  
  // solar : 2013-11-07 Ruby Town, LLC
  solar
  
  // solutions : 2013-11-07 Silver Cover, LLC
  solutions
  
  // song : 2015-02-26 Amazon EU S. r.l.
  song
  
  // sony : 2015-01-08 Sony Corporation
  sony
  
  // soy : 2014-01-23 Charleston Road Registry Inc.
  soy
  
  // space : 2014-04-03 DotSpace Inc.
  space
  
  // spiegel : 2014-02-05 SPIEGEL-Verlag Rudolf Augstein GmbH & Co. KG
  spiegel
  
  // spot : 2015-02-26 Amazon EU S. r.l.
  spot
  
  // spreadbetting : 2014-12-11 IG Group Holdings PLC
  spreadbetting
  
  // srl : 2015-05-07 mySRL GmbH
  srl
  
  // srt : 2015-07-30 FCA US LLC.
  srt
  
  // stada : 2014-11-13 STADA Arzneimittel AG
  stada
  
  // staples : 2015-07-30 Staples, Inc.
  staples
  
  // star : 2015-01-08 Star India Private Limited
  star
  
  // starhub : 2015-02-05 StarHub Ltd
  starhub
  
  // statebank : 2015-03-12 STATE BANK OF INDIA
  statebank
  
  // statefarm : 2015-07-30 State Farm Mutual Automobile Insurance Company
  statefarm
  
  // statoil : 2014-12-04 Statoil ASA
  statoil
  
  // stc : 2014-10-09 Saudi Telecom Company
  stc
  
  // stcgroup : 2014-10-09 Saudi Telecom Company
  stcgroup
  
  // stockholm : 2014-12-18 Stockholms kommun
  stockholm
  
  // storage : 2014-12-22 Self Storage Company LLC
  storage
  
  // store : 2015-04-09 DotStore Inc.
  store
  
  // stream : 2016-01-08 dot Stream Limited
  stream
  
  // studio : 2015-02-11
  studio
  
  // study : 2014-12-11 OPEN UNIVERSITIES AUSTRALIA PTY LTD
  study
  
  // style : 2014-12-04 Binky Moon, LLC
  style
  
  // sucks : 2014-12-22 Vox Populi Registry Inc.
  sucks
  
  // supplies : 2013-12-19 Atomic Fields, LLC
  supplies
  
  // supply : 2013-12-19 Half Falls, LLC
  supply
  
  // support : 2013-10-24 Grand Orchard, LLC
  support
  
  // surf : 2014-01-09 Top Level Domain Holdings Limited
  surf
  
  // surgery : 2014-03-20 Tin Avenue, LLC
  surgery
  
  // suzuki : 2014-02-20 SUZUKI MOTOR CORPORATION
  suzuki
  
  // swatch : 2015-01-08 The Swatch Group Ltd
  swatch
  
  // swiftcover : 2015-07-23 Swiftcover Insurance Services Limited
  swiftcover
  
  // swiss : 2014-10-16 Swiss Confederation
  swiss
  
  // sydney : 2014-09-18 State of New South Wales, Department of Premier and Cabinet
  sydney
  
  // symantec : 2014-12-04 Symantec Corporation
  symantec
  
  // systems : 2013-11-07 Dash Cypress, LLC
  systems
  
  // tab : 2014-12-04 Tabcorp Holdings Limited
  tab
  
  // taipei : 2014-07-10 Taipei City Government
  taipei
  
  // talk : 2015-04-09 Amazon EU S. r.l.
  talk
  
  // taobao : 2015-01-15 Alibaba Group Holding Limited
  taobao
  
  // target : 2015-07-31 Target Domain Holdings, LLC
  target
  
  // tatamotors : 2015-03-12 Tata Motors Ltd
  tatamotors
  
  // tatar : 2014-04-24 Limited Liability Company "Coordination Center of Regional Domain of Tatarstan Republic"
  tatar
  
  // tattoo : 2013-08-30 Uniregistry, Corp.
  tattoo
  
  // tax : 2014-03-20 Storm Orchard, LLC
  tax
  
  // taxi : 2015-03-19 Pine Falls, LLC
  taxi
  
  // tci : 2014-09-12 Asia Green IT System Bilgisayar San. ve Tic. Ltd. Sti.
  tci
  
  // tdk : 2015-06-11 TDK Corporation
  tdk
  
  // team : 2015-03-05 Atomic Lake, LLC
  team
  
  // tech : 2015-01-30 Dot Tech LLC
  tech
  
  // technology : 2013-09-13 Auburn Falls
  technology
  
  // telecity : 2015-02-19 TelecityGroup International Limited
  telecity
  
  // telefonica : 2014-10-16 Telefnica S.A.
  telefonica
  
  // temasek : 2014-08-07 Temasek Holdings (Private) Limited
  temasek
  
  // tennis : 2014-12-04 Cotton Bloom, LLC
  tennis
  
  // teva : 2015-07-02 Teva Pharmaceutical Industries Limited
  teva
  
  // thd : 2015-04-02 Homer TLC, Inc.
  thd
  
  // theater : 2015-03-19 Blue Tigers, LLC
  theater
  
  // theatre : 2015-05-07
  theatre
  
  // tiaa : 2015-07-23 Teachers Insurance and Annuity Association of America
  tiaa
  
  // tickets : 2015-02-05 Accent Media Limited
  tickets
  
  // tienda : 2013-11-14 Victor Manor, LLC
  tienda
  
  // tiffany : 2015-01-30 Tiffany and Company
  tiffany
  
  // tips : 2013-09-20 Corn Willow, LLC
  tips
  
  // tires : 2014-11-07 Dog Edge, LLC
  tires
  
  // tirol : 2014-04-24 punkt Tirol GmbH
  tirol
  
  // tjmaxx : 2015-07-16 The TJX Companies, Inc.
  tjmaxx
  
  // tjx : 2015-07-16 The TJX Companies, Inc.
  tjx
  
  // tkmaxx : 2015-07-16 The TJX Companies, Inc.
  tkmaxx
  
  // tmall : 2015-01-15 Alibaba Group Holding Limited
  tmall
  
  // today : 2013-09-20 Pearl Woods, LLC
  today
  
  // tokyo : 2013-11-13 GMO Registry, Inc.
  tokyo
  
  // tools : 2013-11-21 Pioneer North, LLC
  tools
  
  // top : 2014-03-20 Jiangsu Bangning Science & Technology Co.,Ltd.
  top
  
  // toray : 2014-12-18 Toray Industries, Inc.
  toray
  
  // toshiba : 2014-04-10 TOSHIBA Corporation
  toshiba
  
  // total : 2015-08-06 Total SA
  total
  
  // tours : 2015-01-22 Sugar Station, LLC
  tours
  
  // town : 2014-03-06 Koko Moon, LLC
  town
  
  // toyota : 2015-04-23 TOYOTA MOTOR CORPORATION
  toyota
  
  // toys : 2014-03-06 Pioneer Orchard, LLC
  toys
  
  // trade : 2014-01-23 Elite Registry Limited
  trade
  
  // trading : 2014-12-11 IG Group Holdings PLC
  trading
  
  // training : 2013-11-07 Wild Willow, LLC
  training
  
  // travelchannel : 2015-07-02 Lifestyle Domain Holdings, Inc.
  travelchannel
  
  // travelers : 2015-03-26 Travelers TLD, LLC
  travelers
  
  // travelersinsurance : 2015-03-26 Travelers TLD, LLC
  travelersinsurance
  
  // trust : 2014-10-16
  trust
  
  // trv : 2015-03-26 Travelers TLD, LLC
  trv
  
  // tube : 2015-06-11 Latin American Telecom LLC
  tube
  
  // tui : 2014-07-03 TUI AG
  tui
  
  // tunes : 2015-02-26 Amazon EU S. r.l.
  tunes
  
  // tushu : 2014-12-18 Amazon EU S. r.l.
  tushu
  
  // tvs : 2015-02-19 T V SUNDRAM IYENGAR  & SONS LIMITED
  tvs
  
  // ubank : 2015-08-20 National Australia Bank Limited
  ubank
  
  // ubs : 2014-12-11 UBS AG
  ubs
  
  // uconnect : 2015-07-30 FCA US LLC.
  uconnect
  
  // unicom : 2015-10-15 China United Network Communications Corporation Limited
  unicom
  
  // university : 2014-03-06 Little Station, LLC
  university
  
  // uno : 2013-09-11 Dot Latin LLC
  uno
  
  // uol : 2014-05-01 UBN INTERNET LTDA.
  uol
  
  // ups : 2015-06-25 UPS Market Driver, Inc.
  ups
  
  // vacations : 2013-12-05 Atomic Tigers, LLC
  vacations
  
  // vana : 2014-12-11 Lifestyle Domain Holdings, Inc.
  vana
  
  // vanguard : 2015-09-03 The Vanguard Group, Inc.
  vanguard
  
  // vegas : 2014-01-16 Dot Vegas, Inc.
  vegas
  
  // ventures : 2013-08-27 Binky Lake, LLC
  ventures
  
  // verisign : 2015-08-13 VeriSign, Inc.
  verisign
  
  // versicherung : 2014-03-20
  versicherung
  
  // vet : 2014-03-06
  vet
  
  // viajes : 2013-10-17 Black Madison, LLC
  viajes
  
  // video : 2014-10-16
  video
  
  // vig : 2015-05-14 VIENNA INSURANCE GROUP AG Wiener Versicherung Gruppe
  vig
  
  // viking : 2015-04-02 Viking River Cruises (Bermuda) Ltd.
  viking
  
  // villas : 2013-12-05 New Sky, LLC
  villas
  
  // vin : 2015-06-18 Holly Shadow, LLC
  vin
  
  // vip : 2015-01-22 Minds + Machines Group Limited
  vip
  
  // virgin : 2014-09-25 Virgin Enterprises Limited
  virgin
  
  // visa : 2015-07-30 Visa Worldwide Pte. Limited
  visa
  
  // vision : 2013-12-05 Koko Station, LLC
  vision
  
  // vista : 2014-09-18 Vistaprint Limited
  vista
  
  // vistaprint : 2014-09-18 Vistaprint Limited
  vistaprint
  
  // viva : 2014-11-07 Saudi Telecom Company
  viva
  
  // vivo : 2015-07-31 Telefonica Brasil S.A.
  vivo
  
  // vlaanderen : 2014-02-06 DNS.be vzw
  vlaanderen
  
  // vodka : 2013-12-19 Top Level Domain Holdings Limited
  vodka
  
  // volkswagen : 2015-05-14 Volkswagen Group of America Inc.
  volkswagen
  
  // volvo : 2015-11-12 Volvo Holding Sverige Aktiebolag
  volvo
  
  // vote : 2013-11-21 Monolith Registry LLC
  vote
  
  // voting : 2013-11-13 Valuetainment Corp.
  voting
  
  // voto : 2013-11-21 Monolith Registry LLC
  voto
  
  // voyage : 2013-08-27 Ruby House, LLC
  voyage
  
  // vuelos : 2015-03-05 Travel Reservations SRL
  vuelos
  
  // wales : 2014-05-08 Nominet UK
  wales
  
  // walmart : 2015-07-31 Wal-Mart Stores, Inc.
  walmart
  
  // walter : 2014-11-13 Sandvik AB
  walter
  
  // wang : 2013-10-24 Zodiac Leo Limited
  wang
  
  // wanggou : 2014-12-18 Amazon EU S. r.l.
  wanggou
  
  // warman : 2015-06-18 Weir Group IP Limited
  warman
  
  // watch : 2013-11-14 Sand Shadow, LLC
  watch
  
  // watches : 2014-12-22 Richemont DNS Inc.
  watches
  
  // weather : 2015-01-08 The Weather Channel, LLC
  weather
  
  // weatherchannel : 2015-03-12 The Weather Channel, LLC
  weatherchannel
  
  // webcam : 2014-01-23 dot Webcam Limited
  webcam
  
  // weber : 2015-06-04 Saint-Gobain Weber SA
  weber
  
  // website : 2014-04-03 DotWebsite Inc.
  website
  
  // wed : 2013-10-01 Atgron, Inc.
  wed
  
  // wedding : 2014-04-24 Top Level Domain Holdings Limited
  wedding
  
  // weibo : 2015-03-05 Sina Corporation
  weibo
  
  // weir : 2015-01-29 Weir Group IP Limited
  weir
  
  // whoswho : 2014-02-20 Who's Who Registry
  whoswho
  
  // wien : 2013-10-28 punkt.wien GmbH
  wien
  
  // wiki : 2013-11-07 Top Level Design, LLC
  wiki
  
  // williamhill : 2014-03-13 William Hill Organization Limited
  williamhill
  
  // win : 2014-11-20 First Registry Limited
  win
  
  // windows : 2014-12-18 Microsoft Corporation
  windows
  
  // wine : 2015-06-18 June Station, LLC
  wine
  
  // winners : 2015-07-16 The TJX Companies, Inc.
  winners
  
  // wme : 2014-02-13 William Morris Endeavor Entertainment, LLC
  wme
  
  // wolterskluwer : 2015-08-06 Wolters Kluwer N.V.
  wolterskluwer
  
  // woodside : 2015-07-09 Woodside Petroleum Limited
  woodside
  
  // work : 2013-12-19 Top Level Domain Holdings Limited
  work
  
  // works : 2013-11-14 Little Dynamite, LLC
  works
  
  // world : 2014-06-12 Bitter Fields, LLC
  world
  
  // wow : 2015-10-08 Amazon EU S. r.l.
  wow
  
  // wtc : 2013-12-19 World Trade Centers Association, Inc.
  wtc
  
  // wtf : 2014-03-06 Hidden Way, LLC
  wtf
  
  // xbox : 2014-12-18 Microsoft Corporation
  xbox
  
  // xerox : 2014-10-24 Xerox DNHC LLC
  xerox
  
  // xfinity : 2015-07-09 Comcast IP Holdings I, LLC
  xfinity
  
  // xihuan : 2015-01-08 QIHOO 360 TECHNOLOGY CO. LTD.
  xihuan
  
  // xin : 2014-12-11 Elegant Leader Limited
  xin
  
  // xn--11b4c3d : 2015-01-15 VeriSign Sarl
  xn--11b4c3d
  
  // xn--1ck2e1b : 2015-02-26 Amazon EU S. r.l.
  xn--1ck2e1b
  
  // xn--1qqw23a : 2014-01-09 Guangzhou YU Wei Information Technology Co., Ltd.
  xn--1qqw23a
  
  // xn--30rr7y : 2014-06-12 Excellent First Limited
  xn--30rr7y
  
  // xn--3bst00m : 2013-09-13 Eagle Horizon Limited
  xn--3bst00m
  
  // xn--3ds443g : 2013-09-08 TLD REGISTRY LIMITED
  xn--3ds443g
  
  // xn--3oq18vl8pn36a : 2015-07-02 Volkswagen (China) Investment Co., Ltd.
  xn--3oq18vl8pn36a
  
  // xn--3pxu8k : 2015-01-15 VeriSign Sarl
  xn--3pxu8k
  
  // xn--42c2d9a : 2015-01-15 VeriSign Sarl
  xn--42c2d9a
  
  // xn--45q11c : 2013-11-21 Zodiac Scorpio Limited
  xn--45q11c
  
  // xn--4gbrim : 2013-10-04 Suhub Electronic Establishment
  xn--4gbrim
  
  // xn--55qw42g : 2013-11-08 China Organizational Name Administration Center
  xn--55qw42g
  
  // xn--55qx5d : 2013-11-14 Computer Network Information Center of Chinese Academy of Sciences China Internet Network Information Center
  xn--55qx5d
  
  // xn--5su34j936bgsg : 2015-09-03 ShangriLa International Hotel Management Limited
  xn--5su34j936bgsg
  
  // xn--5tzm5g : 2014-12-22 Global Website TLD Asia Limited
  xn--5tzm5g
  
  // xn--6frz82g : 2013-09-23 Afilias Limited
  xn--6frz82g
  
  // xn--6qq986b3xl : 2013-09-13 Tycoon Treasure Limited
  xn--6qq986b3xl
  
  // xn--80adxhks : 2013-12-19 Foundation for Assistance for Internet Technologies and Infrastructure Development (FAITID)
  xn--80adxhks
  
  // xn--80aqecdr1a : 2015-10-21 Pontificium Consilium de Comunicationibus Socialibus (PCCS) (Pontifical Council for Social Communication)
  xn--80aqecdr1a
  
  // xn--80asehdb : 2013-07-14 CORE Association
  xn--80asehdb
  
  // xn--80aswg : 2013-07-14 CORE Association
  xn--80aswg
  
  // xn--8y0a063a : 2015-03-26 China United Network Communications Corporation Limited
  xn--8y0a063a
  
  // xn--9dbq2a : 2015-01-15 VeriSign Sarl
  xn--9dbq2a
  
  // xn--9et52u : 2014-06-12 RISE VICTORY LIMITED
  xn--9et52u
  
  // xn--9krt00a : 2015-03-12 Sina Corporation
  xn--9krt00a
  
  // xn--b4w605ferd : 2014-08-07 Temasek Holdings (Private) Limited
  xn--b4w605ferd
  
  // xn--bck1b9a5dre4c : 2015-02-26 Amazon EU S. r.l.
  xn--bck1b9a5dre4c
  
  // xn--c1avg : 2013-11-14 Public Interest Registry
  xn--c1avg
  
  // xn--c2br7g : 2015-01-15 VeriSign Sarl
  xn--c2br7g
  
  // xn--cck2b3b : 2015-02-26 Amazon EU S. r.l.
  xn--cck2b3b
  
  // xn--cg4bki : 2013-09-27 SAMSUNG SDS CO., LTD
  xn--cg4bki
  
  // xn--czr694b : 2014-01-16 Dot Trademark TLD Holding Company Limited
  xn--czr694b
  
  // xn--czrs0t : 2013-12-19 Wild Island, LLC
  xn--czrs0t
  
  // xn--czru2d : 2013-11-21 Zodiac Capricorn Limited
  xn--czru2d
  
  // xn--d1acj3b : 2013-11-20 The Foundation for Network Initiatives The Smart Internet
  xn--d1acj3b
  
  // xn--eckvdtc9d : 2014-12-18 Amazon EU S. r.l.
  xn--eckvdtc9d
  
  // xn--efvy88h : 2014-08-22 Xinhua News Agency Guangdong Branch 
  xn--efvy88h
  
  // xn--estv75g : 2015-02-19 Industrial and Commercial Bank of China Limited
  xn--estv75g
  
  // xn--fct429k : 2015-04-09 Amazon EU S. r.l.
  xn--fct429k
  
  // xn--fhbei : 2015-01-15 VeriSign Sarl
  xn--fhbei
  
  // xn--fiq228c5hs : 2013-09-08 TLD REGISTRY LIMITED
  xn--fiq228c5hs
  
  // xn--fiq64b : 2013-10-14 CITIC Group Corporation
  xn--fiq64b
  
  // xn--fjq720a : 2014-05-22 Will Bloom, LLC
  xn--fjq720a
  
  // xn--flw351e : 2014-07-31 Charleston Road Registry Inc.
  xn--flw351e
  
  // xn--fzys8d69uvgm : 2015-05-14 PCCW Enterprises Limited
  xn--fzys8d69uvgm
  
  // xn--g2xx48c : 2015-01-30 Minds + Machines Group Limited
  xn--g2xx48c
  
  // xn--gckr3f0f : 2015-02-26 Amazon EU S. r.l.
  xn--gckr3f0f
  
  // xn--gk3at1e : 2015-10-08 Amazon EU S. r.l.
  xn--gk3at1e
  
  // xn--hxt814e : 2014-05-15 Zodiac Libra Limited
  xn--hxt814e
  
  // xn--i1b6b1a6a2e : 2013-11-14 Public Interest Registry
  xn--i1b6b1a6a2e
  
  // xn--imr513n : 2014-12-11 Dot Trademark TLD Holding Company Limited
  xn--imr513n
  
  // xn--io0a7i : 2013-11-14 Computer Network Information Center of Chinese Academy of Sciences China Internet Network Information Center
  xn--io0a7i
  
  // xn--j1aef : 2015-01-15 VeriSign Sarl
  xn--j1aef
  
  // xn--jlq61u9w7b : 2015-01-08 Nokia Corporation
  xn--jlq61u9w7b
  
  // xn--jvr189m : 2015-02-26 Amazon EU S. r.l.
  xn--jvr189m
  
  // xn--kcrx77d1x4a : 2014-11-07 Koninklijke Philips N.V.
  xn--kcrx77d1x4a
  
  // xn--kpu716f : 2014-12-22 Richemont DNS Inc.
  xn--kpu716f
  
  // xn--kput3i : 2014-02-13 Beijing RITT-Net Technology Development Co., Ltd
  xn--kput3i
  
  // xn--mgba3a3ejt : 2014-11-20 Aramco Services Company
  xn--mgba3a3ejt
  
  // xn--mgba7c0bbn0a : 2015-05-14 Crescent Holding GmbH
  xn--mgba7c0bbn0a
  
  // xn--mgbaakc7dvf : 2015-09-03 Emirates Telecommunications Corporation (trading as Etisalat)
  xn--mgbaakc7dvf
  
  // xn--mgbab2bd : 2013-10-31 CORE Association
  xn--mgbab2bd
  
  // xn--mgbb9fbpob : 2014-12-18 GreenTech Consultancy Company W.L.L.
  xn--mgbb9fbpob
  
  // xn--mgbca7dzdo : 2015-07-30 Abu Dhabi Systems and Information Centre
  xn--mgbca7dzdo
  
  // xn--mgbi4ecexp : 2015-10-21 Pontificium Consilium de Comunicationibus Socialibus (PCCS) (Pontifical Council for Social Communication)
  xn--mgbi4ecexp
  
  // xn--mgbt3dhd : 2014-09-04 Asia Green IT System Bilgisayar San. ve Tic. Ltd. Sti.
  xn--mgbt3dhd
  
  // xn--mk1bu44c : 2015-01-15 VeriSign Sarl
  xn--mk1bu44c
  
  // xn--mxtq1m : 2014-03-06 Net-Chinese Co., Ltd.
  xn--mxtq1m
  
  // xn--ngbc5azd : 2013-07-13 International Domain Registry Pty. Ltd.
  xn--ngbc5azd
  
  // xn--ngbe9e0a : 2014-12-04 Kuwait Finance House
  xn--ngbe9e0a
  
  // xn--ngbrx : 2015-11-12 League of Arab States
  xn--ngbrx
  
  // xn--nqv7f : 2013-11-14 Public Interest Registry
  xn--nqv7f
  
  // xn--nqv7fs00ema : 2013-11-14 Public Interest Registry
  xn--nqv7fs00ema
  
  // xn--nyqy26a : 2014-11-07 Stable Tone Limited
  xn--nyqy26a
  
  // xn--p1acf : 2013-12-12 Rusnames Limited
  xn--p1acf
  
  // xn--pbt977c : 2014-12-22 Richemont DNS Inc.
  xn--pbt977c
  
  // xn--pssy2u : 2015-01-15 VeriSign Sarl
  xn--pssy2u
  
  // xn--q9jyb4c : 2013-09-17 Charleston Road Registry Inc.
  xn--q9jyb4c
  
  // xn--qcka1pmc : 2014-07-31 Charleston Road Registry Inc.
  xn--qcka1pmc
  
  // xn--rhqv96g : 2013-09-11 Stable Tone Limited
  xn--rhqv96g
  
  // xn--rovu88b : 2015-02-26 Amazon EU S. r.l.
  xn--rovu88b
  
  // xn--ses554g : 2014-01-16
  xn--ses554g
  
  // xn--t60b56a : 2015-01-15 VeriSign Sarl
  xn--t60b56a
  
  // xn--tckwe : 2015-01-15 VeriSign Sarl
  xn--tckwe
  
  // xn--tiq49xqyj : 2015-10-21 Pontificium Consilium de Comunicationibus Socialibus (PCCS) (Pontifical Council for Social Communication)
  xn--tiq49xqyj
  
  // xn--unup4y : 2013-07-14 Spring Fields, LLC
  xn--unup4y
  
  // xn--vermgensberater-ctb : 2014-06-23 Deutsche Vermgensberatung Aktiengesellschaft DVAG
  xn--vermgensberater-ctb
  
  // xn--vermgensberatung-pwb : 2014-06-23 Deutsche Vermgensberatung Aktiengesellschaft DVAG
  xn--vermgensberatung-pwb
  
  // xn--vhquv : 2013-08-27 Dash McCook, LLC
  xn--vhquv
  
  // xn--vuq861b : 2014-10-16 Beijing Tele-info Network Technology Co., Ltd.
  xn--vuq861b
  
  // xn--w4r85el8fhu5dnra : 2015-04-30 Kerry Trading Co. Limited
  xn--w4r85el8fhu5dnra
  
  // xn--w4rs40l : 2015-07-30 Kerry Trading Co. Limited
  xn--w4rs40l
  
  // xn--xhq521b : 2013-11-14 Guangzhou YU Wei Information Technology Co., Ltd.
  xn--xhq521b
  
  // xn--zfr164b : 2013-11-08 China Organizational Name Administration Center
  xn--zfr164b
  
  // xperia : 2015-05-14 Sony Mobile Communications AB
  xperia
  
  // xyz : 2013-12-05 XYZ.COM LLC
  xyz
  
  // yachts : 2014-01-09 DERYachts, LLC
  yachts
  
  // yahoo : 2015-04-02 Yahoo! Domain Services Inc.
  yahoo
  
  // yamaxun : 2014-12-18 Amazon EU S. r.l.
  yamaxun
  
  // yandex : 2014-04-10 YANDEX, LLC
  yandex
  
  // yodobashi : 2014-11-20 YODOBASHI CAMERA CO.,LTD.
  yodobashi
  
  // yoga : 2014-05-29 Top Level Domain Holdings Limited
  yoga
  
  // yokohama : 2013-12-12 GMO Registry, Inc.
  yokohama
  
  // you : 2015-04-09 Amazon EU S. r.l.
  you
  
  // youtube : 2014-05-01 Charleston Road Registry Inc.
  youtube
  
  // yun : 2015-01-08 QIHOO 360 TECHNOLOGY CO. LTD.
  yun
  
  // zappos : 2015-06-25 Amazon EU S. r.l.
  zappos
  
  // zara : 2014-11-07 Industria de Diseo Textil, S.A. (INDITEX, S.A.)
  zara
  
  // zero : 2014-12-18 Amazon EU S. r.l.
  zero
  
  // zip : 2014-05-08 Charleston Road Registry Inc.
  zip
  
  // zippo : 2015-07-02 Zadco Company
  zippo
  
  // zone : 2013-11-14 Outer Falls, LLC
  zone
  
  // zuerich : 2014-11-07 Kanton Zrich (Canton of Zurich)
  zuerich
  
  
  // ===END ICANN DOMAINS===
  // ===BEGIN PRIVATE DOMAINS===
  // (Note: these are in alphabetical order by company name)
  
  // 1GB LLC : https://www.1gb.ua/
  // Submitted by 1GB LLC <noc@1gb.com.ua>
  cc.ua
  inf.ua
  ltd.ua
  
  // AgileBits Inc : https://agilebits.com
  // Submitted by Roustem Karimov <roustem@agilebits.com>
  1password.ca
  1password.com
  1password.eu
  
  // Agnat sp. z o.o. : https://domena.pl
  // Submitted by Przemyslaw Plewa <it-admin@domena.pl>
  beep.pl
  
  // Alces Software Ltd : http://alces-software.com
  // Submitted by Mark J. Titorenko <mark.titorenko@alces-software.com>
  *.compute.estate
  *.alces.network
  
  // alwaysdata : https://www.alwaysdata.com
  // Submitted by Cyril <admin@alwaysdata.com>
  alwaysdata.net
  
  // Amazon CloudFront : https://aws.amazon.com/cloudfront/
  // Submitted by Donavan Miller <donavanm@amazon.com>
  cloudfront.net
  
  // Amazon Elastic Compute Cloud : https://aws.amazon.com/ec2/
  // Submitted by Luke Wells <psl-maintainers@amazon.com>
  *.compute.amazonaws.com
  *.compute-1.amazonaws.com
  *.compute.amazonaws.com.cn
  us-east-1.amazonaws.com
  
  // Amazon Elastic Beanstalk : https://aws.amazon.com/elasticbeanstalk/
  // Submitted by Luke Wells <psl-maintainers@amazon.com>
  cn-north-1.eb.amazonaws.com.cn
  elasticbeanstalk.com
  ap-northeast-1.elasticbeanstalk.com
  ap-northeast-2.elasticbeanstalk.com
  ap-south-1.elasticbeanstalk.com
  ap-southeast-1.elasticbeanstalk.com
  ap-southeast-2.elasticbeanstalk.com
  ca-central-1.elasticbeanstalk.com
  eu-central-1.elasticbeanstalk.com
  eu-west-1.elasticbeanstalk.com
  eu-west-2.elasticbeanstalk.com
  eu-west-3.elasticbeanstalk.com
  sa-east-1.elasticbeanstalk.com
  us-east-1.elasticbeanstalk.com
  us-east-2.elasticbeanstalk.com
  us-gov-west-1.elasticbeanstalk.com
  us-west-1.elasticbeanstalk.com
  us-west-2.elasticbeanstalk.com
  
  // Amazon Elastic Load Balancing : https://aws.amazon.com/elasticloadbalancing/
  // Submitted by Luke Wells <psl-maintainers@amazon.com>
  *.elb.amazonaws.com
  *.elb.amazonaws.com.cn
  
  // Amazon S3 : https://aws.amazon.com/s3/
  // Submitted by Luke Wells <psl-maintainers@amazon.com>
  s3.amazonaws.com
  s3-ap-northeast-1.amazonaws.com
  s3-ap-northeast-2.amazonaws.com
  s3-ap-south-1.amazonaws.com
  s3-ap-southeast-1.amazonaws.com
  s3-ap-southeast-2.amazonaws.com
  s3-ca-central-1.amazonaws.com
  s3-eu-central-1.amazonaws.com
  s3-eu-west-1.amazonaws.com
  s3-eu-west-2.amazonaws.com
  s3-eu-west-3.amazonaws.com
  s3-external-1.amazonaws.com
  s3-fips-us-gov-west-1.amazonaws.com
  s3-sa-east-1.amazonaws.com
  s3-us-gov-west-1.amazonaws.com
  s3-us-east-2.amazonaws.com
  s3-us-west-1.amazonaws.com
  s3-us-west-2.amazonaws.com
  s3.ap-northeast-2.amazonaws.com
  s3.ap-south-1.amazonaws.com
  s3.cn-north-1.amazonaws.com.cn
  s3.ca-central-1.amazonaws.com
  s3.eu-central-1.amazonaws.com
  s3.eu-west-2.amazonaws.com
  s3.eu-west-3.amazonaws.com
  s3.us-east-2.amazonaws.com
  s3.dualstack.ap-northeast-1.amazonaws.com
  s3.dualstack.ap-northeast-2.amazonaws.com
  s3.dualstack.ap-south-1.amazonaws.com
  s3.dualstack.ap-southeast-1.amazonaws.com
  s3.dualstack.ap-southeast-2.amazonaws.com
  s3.dualstack.ca-central-1.amazonaws.com
  s3.dualstack.eu-central-1.amazonaws.com
  s3.dualstack.eu-west-1.amazonaws.com
  s3.dualstack.eu-west-2.amazonaws.com
  s3.dualstack.eu-west-3.amazonaws.com
  s3.dualstack.sa-east-1.amazonaws.com
  s3.dualstack.us-east-1.amazonaws.com
  s3.dualstack.us-east-2.amazonaws.com
  s3-website-us-east-1.amazonaws.com
  s3-website-us-west-1.amazonaws.com
  s3-website-us-west-2.amazonaws.com
  s3-website-ap-northeast-1.amazonaws.com
  s3-website-ap-southeast-1.amazonaws.com
  s3-website-ap-southeast-2.amazonaws.com
  s3-website-eu-west-1.amazonaws.com
  s3-website-sa-east-1.amazonaws.com
  s3-website.ap-northeast-2.amazonaws.com
  s3-website.ap-south-1.amazonaws.com
  s3-website.ca-central-1.amazonaws.com
  s3-website.eu-central-1.amazonaws.com
  s3-website.eu-west-2.amazonaws.com
  s3-website.eu-west-3.amazonaws.com
  s3-website.us-east-2.amazonaws.com
  
  // Amune : https://amune.org/
  // Submitted by Team Amune <cert@amune.org>
  t3l3p0rt.net
  tele.amune.org
  
  // Aptible : https://www.aptible.com/
  // Submitted by Thomas Orozco <thomas@aptible.com>
  on-aptible.com
  
  // Asociacin Amigos de la Informtica "Euskalamiga" : http://encounter.eus/
  // Submitted by Hector Martin <marcan@euskalencounter.org>
  user.party.eus
  
  // Association potager.org : https://potager.org/
  // Submitted by Lunar <jardiniers@potager.org>
  pimienta.org
  poivron.org
  potager.org
  sweetpepper.org
  
  // ASUSTOR Inc. : http://www.asustor.com
  // Submitted by Vincent Tseng <vincenttseng@asustor.com>
  myasustor.com
  
  // AVM : https://avm.de
  // Submitted by Andreas Weise <a.weise@avm.de>
  myfritz.net
  
  // AW AdvisorWebsites.com Software Inc : https://advisorwebsites.com
  // Submitted by James Kennedy <domains@advisorwebsites.com>
  *.awdev.ca
  *.advisor.ws
  
  // backplane : https://www.backplane.io
  // Submitted by Anthony Voutas <anthony@backplane.io>
  backplaneapp.io
  
  // BetaInABox
  // Submitted by Adrian <adrian@betainabox.com>
  betainabox.com
  
  // BinaryLane : http://www.binarylane.com
  // Submitted by Nathan O'Sullivan <nathan@mammoth.com.au>
  bnr.la
  
  // Boomla : https://boomla.com
  // Submitted by Tibor Halter <thalter@boomla.com>
  boomla.net
  
  // Boxfuse : https://boxfuse.com
  // Submitted by Axel Fontaine <axel@boxfuse.com>
  boxfuse.io
  
  // bplaced : https://www.bplaced.net/
  // Submitted by Miroslav Bozic <security@bplaced.net>
  square7.ch
  bplaced.com
  bplaced.de
  square7.de
  bplaced.net
  square7.net
  
  // BrowserSafetyMark
  // Submitted by Dave Tharp <browsersafetymark.io@quicinc.com>
  browsersafetymark.io
  
  // callidomus : https://www.callidomus.com/
  // Submitted by Marcus Popp <admin@callidomus.com>
  mycd.eu
  
  // CentralNic : http://www.centralnic.com/names/domains
  // Submitted by registry <gavin.brown@centralnic.com>
  ae.org
  ar.com
  br.com
  cn.com
  com.de
  com.se
  de.com
  eu.com
  gb.com
  gb.net
  hu.com
  hu.net
  jp.net
  jpn.com
  kr.com
  mex.com
  no.com
  qc.com
  ru.com
  sa.com
  se.com
  se.net
  uk.com
  uk.net
  us.com
  uy.com
  za.bz
  za.com
  
  // Africa.com Web Solutions Ltd : https://registry.africa.com
  // Submitted by Gavin Brown <gavin.brown@centralnic.com>
  africa.com
  
  // iDOT Services Limited : http://www.domain.gr.com
  // Submitted by Gavin Brown <gavin.brown@centralnic.com>
  gr.com
  
  // Radix FZC : http://domains.in.net
  // Submitted by Gavin Brown <gavin.brown@centralnic.com>
  in.net
  
  // US REGISTRY LLC : http://us.org
  // Submitted by Gavin Brown <gavin.brown@centralnic.com>
  us.org
  
  // co.com Registry, LLC : https://registry.co.com
  // Submitted by Gavin Brown <gavin.brown@centralnic.com>
  co.com
  
  // c.la : http://www.c.la/
  c.la
  
  // certmgr.org : https://certmgr.org
  // Submitted by B. Blechschmidt <hostmaster@certmgr.org>
  certmgr.org
  
  // Citrix : https://citrix.com
  // Submitted by Alex Stoddard <alex.stoddard@citrix.com>
  xenapponazure.com
  
  // ClearVox : http://www.clearvox.nl/
  // Submitted by Leon Rowland <leon@clearvox.nl>
  virtueeldomein.nl
  
  // Cloud66 : https://www.cloud66.com/
  // Submitted by Khash Sajadi <khash@cloud66.com>
  c66.me
  cloud66.ws
  
  // CloudAccess.net : https://www.cloudaccess.net/
  // Submitted by Pawel Panek <noc@cloudaccess.net>
  jdevcloud.com
  wpdevcloud.com
  cloudaccess.host
  freesite.host
  cloudaccess.net
  
  // cloudControl : https://www.cloudcontrol.com/
  // Submitted by Tobias Wilken <tw@cloudcontrol.com>
  cloudcontrolled.com
  cloudcontrolapp.com
  
  // co.ca : http://registry.co.ca/
  co.ca
  
  // i-registry s.r.o. : http://www.i-registry.cz/
  // Submitted by Martin Semrad <semrad@i-registry.cz>
  co.cz
  
  // CDN77.com : http://www.cdn77.com
  // Submitted by Jan Krpes <jan.krpes@cdn77.com>
  c.cdn77.org
  cdn77-ssl.net
  r.cdn77.net
  rsc.cdn77.org
  ssl.origin.cdn77-secure.org
  
  // Cloud DNS Ltd : http://www.cloudns.net
  // Submitted by Aleksander Hristov <noc@cloudns.net>
  cloudns.asia
  cloudns.biz
  cloudns.club
  cloudns.cc
  cloudns.eu
  cloudns.in
  cloudns.info
  cloudns.org
  cloudns.pro
  cloudns.pw
  cloudns.us
  
  // CoDNS B.V.
  co.nl
  co.no
  
  // Combell.com : https://www.combell.com
  // Submitted by Thomas Wouters <thomas.wouters@combellgroup.com>
  webhosting.be
  hosting-cluster.nl
  
  // COSIMO GmbH : http://www.cosimo.de
  // Submitted by Rene Marticke <rmarticke@cosimo.de>
  dyn.cosidns.de
  dynamisches-dns.de
  dnsupdater.de
  internet-dns.de
  l-o-g-i-n.de
  dynamic-dns.info
  feste-ip.net
  knx-server.net
  static-access.net
  
  // Craynic, s.r.o. : http://www.craynic.com/
  // Submitted by Ales Krajnik <ales.krajnik@craynic.com>
  realm.cz
  
  // Cryptonomic : https://cryptonomic.net/
  // Submitted by Andrew Cady <public-suffix-list@cryptonomic.net>
  *.cryptonomic.net
  
  // Cupcake : https://cupcake.io/
  // Submitted by Jonathan Rudenberg <jonathan@cupcake.io>
  cupcake.is
  
  // cyon GmbH : https://www.cyon.ch/
  // Submitted by Dominic Luechinger <dol@cyon.ch>
  cyon.link
  cyon.site
  
  // Daplie, Inc : https://daplie.com
  // Submitted by AJ ONeal <aj@daplie.com>
  daplie.me
  localhost.daplie.me
  
  // Dansk.net : http://www.dansk.net/
  // Submitted by Anani Voule <digital@digital.co.dk>
  biz.dk
  co.dk
  firm.dk
  reg.dk
  store.dk
  
  // Debian : https://www.debian.org/
  // Submitted by Peter Palfrader / Debian Sysadmin Team <dsa-publicsuffixlist@debian.org>
  debian.net
  
  // deSEC : https://desec.io/
  // Submitted by Peter Thomassen <peter@desec.io>
  dedyn.io
  
  // DNShome : https://www.dnshome.de/
  // Submitted by Norbert Auler <mail@dnshome.de>
  dnshome.de
  
  // DrayTek Corp. : https://www.draytek.com/
  // Submitted by Paul Fang <mis@draytek.com>
  drayddns.com
  
  // DreamHost : http://www.dreamhost.com/
  // Submitted by Andrew Farmer <andrew.farmer@dreamhost.com>
  dreamhosters.com
  
  // Drobo : http://www.drobo.com/
  // Submitted by Ricardo Padilha <rpadilha@drobo.com>
  mydrobo.com
  
  // Drud Holdings, LLC. : https://www.drud.com/
  // Submitted by Kevin Bridges <kevin@drud.com>
  drud.io
  drud.us
  
  // DuckDNS : http://www.duckdns.org/
  // Submitted by Richard Harper <richard@duckdns.org>
  duckdns.org
  
  // dy.fi : http://dy.fi/
  // Submitted by Heikki Hannikainen <hessu@hes.iki.fi>
  dy.fi
  tunk.org
  
  // DynDNS.com : http://www.dyndns.com/services/dns/dyndns/
  dyndns-at-home.com
  dyndns-at-work.com
  dyndns-blog.com
  dyndns-free.com
  dyndns-home.com
  dyndns-ip.com
  dyndns-mail.com
  dyndns-office.com
  dyndns-pics.com
  dyndns-remote.com
  dyndns-server.com
  dyndns-web.com
  dyndns-wiki.com
  dyndns-work.com
  dyndns.biz
  dyndns.info
  dyndns.org
  dyndns.tv
  at-band-camp.net
  ath.cx
  barrel-of-knowledge.info
  barrell-of-knowledge.info
  better-than.tv
  blogdns.com
  blogdns.net
  blogdns.org
  blogsite.org
  boldlygoingnowhere.org
  broke-it.net
  buyshouses.net
  cechire.com
  dnsalias.com
  dnsalias.net
  dnsalias.org
  dnsdojo.com
  dnsdojo.net
  dnsdojo.org
  does-it.net
  doesntexist.com
  doesntexist.org
  dontexist.com
  dontexist.net
  dontexist.org
  doomdns.com
  doomdns.org
  dvrdns.org
  dyn-o-saur.com
  dynalias.com
  dynalias.net
  dynalias.org
  dynathome.net
  dyndns.ws
  endofinternet.net
  endofinternet.org
  endoftheinternet.org
  est-a-la-maison.com
  est-a-la-masion.com
  est-le-patron.com
  est-mon-blogueur.com
  for-better.biz
  for-more.biz
  for-our.info
  for-some.biz
  for-the.biz
  forgot.her.name
  forgot.his.name
  from-ak.com
  from-al.com
  from-ar.com
  from-az.net
  from-ca.com
  from-co.net
  from-ct.com
  from-dc.com
  from-de.com
  from-fl.com
  from-ga.com
  from-hi.com
  from-ia.com
  from-id.com
  from-il.com
  from-in.com
  from-ks.com
  from-ky.com
  from-la.net
  from-ma.com
  from-md.com
  from-me.org
  from-mi.com
  from-mn.com
  from-mo.com
  from-ms.com
  from-mt.com
  from-nc.com
  from-nd.com
  from-ne.com
  from-nh.com
  from-nj.com
  from-nm.com
  from-nv.com
  from-ny.net
  from-oh.com
  from-ok.com
  from-or.com
  from-pa.com
  from-pr.com
  from-ri.com
  from-sc.com
  from-sd.com
  from-tn.com
  from-tx.com
  from-ut.com
  from-va.com
  from-vt.com
  from-wa.com
  from-wi.com
  from-wv.com
  from-wy.com
  ftpaccess.cc
  fuettertdasnetz.de
  game-host.org
  game-server.cc
  getmyip.com
  gets-it.net
  go.dyndns.org
  gotdns.com
  gotdns.org
  groks-the.info
  groks-this.info
  ham-radio-op.net
  here-for-more.info
  hobby-site.com
  hobby-site.org
  home.dyndns.org
  homedns.org
  homeftp.net
  homeftp.org
  homeip.net
  homelinux.com
  homelinux.net
  homelinux.org
  homeunix.com
  homeunix.net
  homeunix.org
  iamallama.com
  in-the-band.net
  is-a-anarchist.com
  is-a-blogger.com
  is-a-bookkeeper.com
  is-a-bruinsfan.org
  is-a-bulls-fan.com
  is-a-candidate.org
  is-a-caterer.com
  is-a-celticsfan.org
  is-a-chef.com
  is-a-chef.net
  is-a-chef.org
  is-a-conservative.com
  is-a-cpa.com
  is-a-cubicle-slave.com
  is-a-democrat.com
  is-a-designer.com
  is-a-doctor.com
  is-a-financialadvisor.com
  is-a-geek.com
  is-a-geek.net
  is-a-geek.org
  is-a-green.com
  is-a-guru.com
  is-a-hard-worker.com
  is-a-hunter.com
  is-a-knight.org
  is-a-landscaper.com
  is-a-lawyer.com
  is-a-liberal.com
  is-a-libertarian.com
  is-a-linux-user.org
  is-a-llama.com
  is-a-musician.com
  is-a-nascarfan.com
  is-a-nurse.com
  is-a-painter.com
  is-a-patsfan.org
  is-a-personaltrainer.com
  is-a-photographer.com
  is-a-player.com
  is-a-republican.com
  is-a-rockstar.com
  is-a-socialist.com
  is-a-soxfan.org
  is-a-student.com
  is-a-teacher.com
  is-a-techie.com
  is-a-therapist.com
  is-an-accountant.com
  is-an-actor.com
  is-an-actress.com
  is-an-anarchist.com
  is-an-artist.com
  is-an-engineer.com
  is-an-entertainer.com
  is-by.us
  is-certified.com
  is-found.org
  is-gone.com
  is-into-anime.com
  is-into-cars.com
  is-into-cartoons.com
  is-into-games.com
  is-leet.com
  is-lost.org
  is-not-certified.com
  is-saved.org
  is-slick.com
  is-uberleet.com
  is-very-bad.org
  is-very-evil.org
  is-very-good.org
  is-very-nice.org
  is-very-sweet.org
  is-with-theband.com
  isa-geek.com
  isa-geek.net
  isa-geek.org
  isa-hockeynut.com
  issmarterthanyou.com
  isteingeek.de
  istmein.de
  kicks-ass.net
  kicks-ass.org
  knowsitall.info
  land-4-sale.us
  lebtimnetz.de
  leitungsen.de
  likes-pie.com
  likescandy.com
  merseine.nu
  mine.nu
  misconfused.org
  mypets.ws
  myphotos.cc
  neat-url.com
  office-on-the.net
  on-the-web.tv
  podzone.net
  podzone.org
  readmyblog.org
  saves-the-whales.com
  scrapper-site.net
  scrapping.cc
  selfip.biz
  selfip.com
  selfip.info
  selfip.net
  selfip.org
  sells-for-less.com
  sells-for-u.com
  sells-it.net
  sellsyourhome.org
  servebbs.com
  servebbs.net
  servebbs.org
  serveftp.net
  serveftp.org
  servegame.org
  shacknet.nu
  simple-url.com
  space-to-rent.com
  stuff-4-sale.org
  stuff-4-sale.us
  teaches-yoga.com
  thruhere.net
  traeumtgerade.de
  webhop.biz
  webhop.info
  webhop.net
  webhop.org
  worse-than.tv
  writesthisblog.com
  
  // ddnss.de : https://www.ddnss.de/
  // Submitted by Robert Niedziela <webmaster@ddnss.de>
  ddnss.de
  dyn.ddnss.de
  dyndns.ddnss.de
  dyndns1.de
  dyn-ip24.de
  home-webserver.de
  dyn.home-webserver.de
  myhome-server.de
  ddnss.org
  
  // Definima : http://www.definima.com/
  // Submitted by Maxence Bitterli <maxence@definima.com>
  definima.net
  definima.io
  
  // Dynu.com : https://www.dynu.com/
  // Submitted by Sue Ye <sue@dynu.com>
  ddnsfree.com
  ddnsgeek.com
  giize.com
  gleeze.com
  kozow.com
  loseyourip.com
  ooguy.com
  theworkpc.com
  casacam.net
  dynu.net
  accesscam.org
  camdvr.org
  freeddns.org
  mywire.org
  webredirect.org
  myddns.rocks
  blogsite.xyz
  
  // dynv6 : https://dynv6.com
  // Submitted by Dominik Menke <dom@digineo.de>
  dynv6.net
  
  // E4YOU spol. s.r.o. : https://e4you.cz/
  // Submitted by Vladimir Dudr <info@e4you.cz>
  e4.cz
  
  // Enalean SAS: https://www.enalean.com
  // Submitted by Thomas Cottier <thomas.cottier@enalean.com>
  mytuleap.com
  
  // Enonic : http://enonic.com/
  // Submitted by Erik Kaareng-Sunde <esu@enonic.com>
  enonic.io
  customer.enonic.io
  
  // EU.org https://eu.org/
  // Submitted by Pierre Beyssac <hostmaster@eu.org>
  eu.org
  al.eu.org
  asso.eu.org
  at.eu.org
  au.eu.org
  be.eu.org
  bg.eu.org
  ca.eu.org
  cd.eu.org
  ch.eu.org
  cn.eu.org
  cy.eu.org
  cz.eu.org
  de.eu.org
  dk.eu.org
  edu.eu.org
  ee.eu.org
  es.eu.org
  fi.eu.org
  fr.eu.org
  gr.eu.org
  hr.eu.org
  hu.eu.org
  ie.eu.org
  il.eu.org
  in.eu.org
  int.eu.org
  is.eu.org
  it.eu.org
  jp.eu.org
  kr.eu.org
  lt.eu.org
  lu.eu.org
  lv.eu.org
  mc.eu.org
  me.eu.org
  mk.eu.org
  mt.eu.org
  my.eu.org
  net.eu.org
  ng.eu.org
  nl.eu.org
  no.eu.org
  nz.eu.org
  paris.eu.org
  pl.eu.org
  pt.eu.org
  q-a.eu.org
  ro.eu.org
  ru.eu.org
  se.eu.org
  si.eu.org
  sk.eu.org
  tr.eu.org
  uk.eu.org
  us.eu.org
  
  // Evennode : http://www.evennode.com/
  // Submitted by Michal Kralik <support@evennode.com>
  eu-1.evennode.com
  eu-2.evennode.com
  eu-3.evennode.com
  eu-4.evennode.com
  us-1.evennode.com
  us-2.evennode.com
  us-3.evennode.com
  us-4.evennode.com
  
  // eDirect Corp. : https://hosting.url.com.tw/
  // Submitted by C.S. chang <cschang@corp.url.com.tw>
  twmail.cc
  twmail.net
  twmail.org
  mymailer.com.tw
  url.tw
  
  // Facebook, Inc.
  // Submitted by Peter Ruibal <public-suffix@fb.com>
  apps.fbsbx.com
  
  // FAITID : https://faitid.org/
  // Submitted by Maxim Alzoba <tech.contact@faitid.org>
  // https://www.flexireg.net/stat_info
  ru.net
  adygeya.ru
  bashkiria.ru
  bir.ru
  cbg.ru
  com.ru
  dagestan.ru
  grozny.ru
  kalmykia.ru
  kustanai.ru
  marine.ru
  mordovia.ru
  msk.ru
  mytis.ru
  nalchik.ru
  nov.ru
  pyatigorsk.ru
  spb.ru
  vladikavkaz.ru
  vladimir.ru
  abkhazia.su
  adygeya.su
  aktyubinsk.su
  arkhangelsk.su
  armenia.su
  ashgabad.su
  azerbaijan.su
  balashov.su
  bashkiria.su
  bryansk.su
  bukhara.su
  chimkent.su
  dagestan.su
  east-kazakhstan.su
  exnet.su
  georgia.su
  grozny.su
  ivanovo.su
  jambyl.su
  kalmykia.su
  kaluga.su
  karacol.su
  karaganda.su
  karelia.su
  khakassia.su
  krasnodar.su
  kurgan.su
  kustanai.su
  lenug.su
  mangyshlak.su
  mordovia.su
  msk.su
  murmansk.su
  nalchik.su
  navoi.su
  north-kazakhstan.su
  nov.su
  obninsk.su
  penza.su
  pokrovsk.su
  sochi.su
  spb.su
  tashkent.su
  termez.su
  togliatti.su
  troitsk.su
  tselinograd.su
  tula.su
  tuva.su
  vladikavkaz.su
  vladimir.su
  vologda.su
  
  // Fancy Bits, LLC : http://getchannels.com
  // Submitted by Aman Gupta <aman@getchannels.com>
  channelsdvr.net
  
  // Fastly Inc. : http://www.fastly.com/
  // Submitted by Fastly Security <security@fastly.com>
  fastlylb.net
  map.fastlylb.net
  freetls.fastly.net
  map.fastly.net
  a.prod.fastly.net
  global.prod.fastly.net
  a.ssl.fastly.net
  b.ssl.fastly.net
  global.ssl.fastly.net
  
  // Featherhead : https://featherhead.xyz/
  // Submitted by Simon Menke <simon@featherhead.xyz>
  fhapp.xyz
  
  // Fedora : https://fedoraproject.org/
  // submitted by Patrick Uiterwijk <puiterwijk@fedoraproject.org>
  fedorainfracloud.org
  fedorapeople.org
  cloud.fedoraproject.org
  app.os.fedoraproject.org
  app.os.stg.fedoraproject.org
  
  // Filegear Inc. : https://www.filegear.com
  // Submitted by Jason Zhu <jason@owtware.com>
  filegear.me
  
  // Firebase, Inc.
  // Submitted by Chris Raynor <chris@firebase.com>
  firebaseapp.com
  
  // Flynn : https://flynn.io
  // Submitted by Jonathan Rudenberg <jonathan@flynn.io>
  flynnhub.com
  flynnhosting.net
  
  // Freebox : http://www.freebox.fr
  // Submitted by Romain Fliedel <rfliedel@freebox.fr>
  freebox-os.com
  freeboxos.com
  fbx-os.fr
  fbxos.fr
  freebox-os.fr
  freeboxos.fr
  
  // Futureweb OG : http://www.futureweb.at
  // Submitted by Andreas Schnederle-Wagner <schnederle@futureweb.at>
  *.futurecms.at
  futurehosting.at
  futuremailing.at
  *.ex.ortsinfo.at
  *.kunden.ortsinfo.at
  *.statics.cloud
  
  // GDS : https://www.gov.uk/service-manual/operations/operating-servicegovuk-subdomains
  // Submitted by David Illsley <david.illsley@digital.cabinet-office.gov.uk>
  service.gov.uk
  
  // GitHub, Inc.
  // Submitted by Patrick Toomey <security@github.com>
  github.io
  githubusercontent.com
  
  // GitLab, Inc.
  // Submitted by Alex Hanselka <alex@gitlab.com>
  gitlab.io
  
  // UKHomeOffice : https://www.gov.uk/government/organisations/home-office
  // Submitted by Jon Shanks <jon.shanks@digital.homeoffice.gov.uk>
  homeoffice.gov.uk
  
  // GlobeHosting, Inc.
  // Submitted by Zoltan Egresi <egresi@globehosting.com>
  ro.im
  shop.ro
  
  // GoIP DNS Services : http://www.goip.de
  // Submitted by Christian Poulter <milchstrasse@goip.de>
  goip.de
  
  // Google, Inc.
  // Submitted by Eduardo Vela <evn@google.com>
  *.0emm.com
  appspot.com
  blogspot.ae
  blogspot.al
  blogspot.am
  blogspot.ba
  blogspot.be
  blogspot.bg
  blogspot.bj
  blogspot.ca
  blogspot.cf
  blogspot.ch
  blogspot.cl
  blogspot.co.at
  blogspot.co.id
  blogspot.co.il
  blogspot.co.ke
  blogspot.co.nz
  blogspot.co.uk
  blogspot.co.za
  blogspot.com
  blogspot.com.ar
  blogspot.com.au
  blogspot.com.br
  blogspot.com.by
  blogspot.com.co
  blogspot.com.cy
  blogspot.com.ee
  blogspot.com.eg
  blogspot.com.es
  blogspot.com.mt
  blogspot.com.ng
  blogspot.com.tr
  blogspot.com.uy
  blogspot.cv
  blogspot.cz
  blogspot.de
  blogspot.dk
  blogspot.fi
  blogspot.fr
  blogspot.gr
  blogspot.hk
  blogspot.hr
  blogspot.hu
  blogspot.ie
  blogspot.in
  blogspot.is
  blogspot.it
  blogspot.jp
  blogspot.kr
  blogspot.li
  blogspot.lt
  blogspot.lu
  blogspot.md
  blogspot.mk
  blogspot.mr
  blogspot.mx
  blogspot.my
  blogspot.nl
  blogspot.no
  blogspot.pe
  blogspot.pt
  blogspot.qa
  blogspot.re
  blogspot.ro
  blogspot.rs
  blogspot.ru
  blogspot.se
  blogspot.sg
  blogspot.si
  blogspot.sk
  blogspot.sn
  blogspot.td
  blogspot.tw
  blogspot.ug
  blogspot.vn
  cloudfunctions.net
  cloud.goog
  codespot.com
  googleapis.com
  googlecode.com
  pagespeedmobilizer.com
  publishproxy.com
  withgoogle.com
  withyoutube.com
  
  // Hashbang : https://hashbang.sh
  hashbang.sh
  
  // Hasura : https://hasura.io
  // Submitted by Shahidh K Muhammed <shahidh@hasura.io>
  hasura-app.io
  
  // Hepforge : https://www.hepforge.org
  // Submitted by David Grellscheid <admin@hepforge.org>
  hepforge.org
  
  // Heroku : https://www.heroku.com/
  // Submitted by Tom Maher <tmaher@heroku.com>
  herokuapp.com
  herokussl.com
  
  // Ici la Lune : http://www.icilalune.com/
  // Submitted by Simon Morvan <simon@icilalune.com>
  moonscale.net
  
  // iki.fi
  // Submitted by Hannu Aronsson <haa@iki.fi>
  iki.fi
  
  // info.at : http://www.info.at/
  biz.at
  info.at
  
  // info.cx : http://info.cx
  // Submitted by Jacob Slater <whois@igloo.to>
  info.cx
  
  // Interlegis : http://www.interlegis.leg.br
  // Submitted by Gabriel Ferreira <registrobr@interlegis.leg.br>
  ac.leg.br
  al.leg.br
  am.leg.br
  ap.leg.br
  ba.leg.br
  ce.leg.br
  df.leg.br
  es.leg.br
  go.leg.br
  ma.leg.br
  mg.leg.br
  ms.leg.br
  mt.leg.br
  pa.leg.br
  pb.leg.br
  pe.leg.br
  pi.leg.br
  pr.leg.br
  rj.leg.br
  rn.leg.br
  ro.leg.br
  rr.leg.br
  rs.leg.br
  sc.leg.br
  se.leg.br
  sp.leg.br
  to.leg.br
  
  // intermetrics GmbH : https://pixolino.com/
  // Submitted by Wolfgang Schwarz <admin@intermetrics.de>
  pixolino.com
  
  // IPiFony Systems, Inc. : https://www.ipifony.com/
  // Submitted by Matthew Hardeman <mhardeman@ipifony.com>
  ipifony.net
  
  // Joyent : https://www.joyent.com/
  // Submitted by Brian Bennett <brian.bennett@joyent.com>
  *.triton.zone
  *.cns.joyent.com
  
  // JS.ORG : http://dns.js.org
  // Submitted by Stefan Keim <admin@js.org>
  js.org
  
  // Keyweb AG : https://www.keyweb.de
  // Submitted by Martin Dannehl <postmaster@keymachine.de>
  keymachine.de
  
  // KnightPoint Systems, LLC : http://www.knightpoint.com/
  // Submitted by Roy Keene <rkeene@knightpoint.com>
  knightpoint.systems
  
  // .KRD : http://nic.krd/data/krd/Registration%20Policy.pdf
  co.krd
  edu.krd
  
  // LCube - Professional hosting e.K. : https://www.lcube-webhosting.de
  // Submitted by Lars Laehn <info@lcube.de>
  git-repos.de
  lcube-server.de
  svn-repos.de
  
  // linkyard ldt: https://www.linkyard.ch/
  // Submitted by Mario Siegenthaler <mario.siegenthaler@linkyard.ch>
  linkyard.cloud
  linkyard-cloud.ch
  
  // LiquidNet Ltd : http://www.liquidnetlimited.com/
  // Submitted by Victor Velchev <admin@liquidnetlimited.com>
  we.bs
  
  // Lukanet Ltd : https://lukanet.com
  // Submitted by Anton Avramov <register@lukanet.com>
  barsy.bg
  barsyonline.com
  barsy.de
  barsy.eu
  barsy.in
  barsy.net
  barsy.online
  barsy.support
  
  // Magento Commerce
  // Submitted by Damien Tournoud <dtournoud@magento.cloud>
  *.magentosite.cloud
  
  // Mail.Ru Group : https://hb.cldmail.ru
  // Submitted by Ilya Zaretskiy <zaretskiy@corp.mail.ru>
  hb.cldmail.ru
  
  // MetaCentrum, CESNET z.s.p.o. : https://www.metacentrum.cz/en/
  // Submitted by Zdenk ustr <zdenek.sustr@cesnet.cz>
  cloud.metacentrum.cz
  custom.metacentrum.cz
  
  // Meteor Development Group : https://www.meteor.com/hosting
  // Submitted by Pierre Carrier <pierre@meteor.com>
  meteorapp.com
  eu.meteorapp.com
  
  // Michau Enterprises Limited : http://www.co.pl/
  co.pl
  
  // Microsoft : http://microsoft.com
  // Submitted by Barry Dorrans <bdorrans@microsoft.com>
  azurewebsites.net
  azure-mobile.net
  cloudapp.net
  
  // Mozilla Foundation : https://mozilla.org/
  // Submitted by glob <glob@mozilla.com>
  bmoattachments.org
  
  // MSK-IX : https://www.msk-ix.ru/
  // Submitted by Khannanov Roman <r.khannanov@msk-ix.ru>
  net.ru
  org.ru
  pp.ru
  
  // Netlify : https://www.netlify.com
  // Submitted by Jessica Parsons <jessica@netlify.com>
  bitballoon.com
  netlify.com
  
  // Neustar Inc.
  // Submitted by Trung Tran <Trung.Tran@neustar.biz>
  4u.com
  
  // ngrok : https://ngrok.com/
  // Submitted by Alan Shreve <alan@ngrok.com>
  ngrok.io
  
  // Nimbus Hosting Ltd. : https://www.nimbushosting.co.uk/
  // Submitted by Nicholas Ford <nick@nimbushosting.co.uk>
  nh-serv.co.uk
  
  // NFSN, Inc. : https://www.NearlyFreeSpeech.NET/
  // Submitted by Jeff Wheelhouse <support@nearlyfreespeech.net>
  nfshost.com
  
  // nsupdate.info : https://www.nsupdate.info/
  // Submitted by Thomas Waldmann <info@nsupdate.info>
  nsupdate.info
  nerdpol.ovh
  
  // No-IP.com : https://noip.com/
  // Submitted by Deven Reza <publicsuffixlist@noip.com>
  blogsyte.com
  brasilia.me
  cable-modem.org
  ciscofreak.com
  collegefan.org
  couchpotatofries.org
  damnserver.com
  ddns.me
  ditchyourip.com
  dnsfor.me
  dnsiskinky.com
  dvrcam.info
  dynns.com
  eating-organic.net
  fantasyleague.cc
  geekgalaxy.com
  golffan.us
  health-carereform.com
  homesecuritymac.com
  homesecuritypc.com
  hopto.me
  ilovecollege.info
  loginto.me
  mlbfan.org
  mmafan.biz
  myactivedirectory.com
  mydissent.net
  myeffect.net
  mymediapc.net
  mypsx.net
  mysecuritycamera.com
  mysecuritycamera.net
  mysecuritycamera.org
  net-freaks.com
  nflfan.org
  nhlfan.net
  no-ip.ca
  no-ip.co.uk
  no-ip.net
  noip.us
  onthewifi.com
  pgafan.net
  point2this.com
  pointto.us
  privatizehealthinsurance.net
  quicksytes.com
  read-books.org
  securitytactics.com
  serveexchange.com
  servehumour.com
  servep2p.com
  servesarcasm.com
  stufftoread.com
  ufcfan.org
  unusualperson.com
  workisboring.com
  3utilities.com
  bounceme.net
  ddns.net
  ddnsking.com
  gotdns.ch
  hopto.org
  myftp.biz
  myftp.org
  myvnc.com
  no-ip.biz
  no-ip.info
  no-ip.org
  noip.me
  redirectme.net
  servebeer.com
  serveblog.net
  servecounterstrike.com
  serveftp.com
  servegame.com
  servehalflife.com
  servehttp.com
  serveirc.com
  serveminecraft.net
  servemp3.com
  servepics.com
  servequake.com
  sytes.net
  webhop.me
  zapto.org
  
  // NodeArt : https://nodeart.io
  // Submitted by Konstantin Nosov <Nosov@nodeart.io>
  stage.nodeart.io
  
  // Nodum B.V. : https://nodum.io/
  // Submitted by Wietse Wind <hello+publicsuffixlist@nodum.io>
  nodum.co
  nodum.io
  
  // NYC.mn : http://www.information.nyc.mn
  // Submitted by Matthew Brown <mattbrown@nyc.mn>
  nyc.mn
  
  // NymNom : https://nymnom.com/
  // Submitted by Dave McCormack <dave.mccormack@nymnom.com>
  nom.ae
  nom.ai
  nom.al
  nym.by
  nym.bz
  nom.cl
  nom.gd
  nom.gl
  nym.gr
  nom.gt
  nom.hn
  nom.im
  nym.kz
  nym.la
  nom.li
  nym.li
  nym.lt
  nym.lu
  nym.me
  nom.mk
  nym.mx
  nom.nu
  nym.nz
  nym.pe
  nym.pt
  nom.pw
  nom.qa
  nom.rs
  nom.si
  nym.sk
  nym.su
  nym.sx
  nym.tw
  nom.ug
  nom.uy
  nom.vc
  nom.vg
  
  // Octopodal Solutions, LLC. : https://ulterius.io/
  // Submitted by Andrew Sampson <andrew@ulterius.io>
  cya.gg
  
  // One Fold Media : http://www.onefoldmedia.com/
  // Submitted by Eddie Jones <eddie@onefoldmedia.com>
  nid.io
  
  // OpenCraft GmbH : http://opencraft.com/
  // Submitted by Sven Marnach <sven@opencraft.com>
  opencraft.hosting
  
  // Opera Software, A.S.A.
  // Submitted by Yngve Pettersen <yngve@opera.com>
  operaunite.com
  
  // OutSystems
  // Submitted by Duarte Santos <domain-admin@outsystemscloud.com>
  outsystemscloud.com
  
  // OwnProvider : http://www.ownprovider.com
  // Submitted by Jan Moennich <jan.moennich@ownprovider.com>
  ownprovider.com
  
  // oy.lc
  // Submitted by Charly Coste <changaco@changaco.oy.lc>
  oy.lc
  
  // Pagefog : https://pagefog.com/
  // Submitted by Derek Myers <derek@pagefog.com>
  pgfog.com
  
  // Pagefront : https://www.pagefronthq.com/
  // Submitted by Jason Kriss <jason@pagefronthq.com>
  pagefrontapp.com
  
  // .pl domains (grandfathered)
  art.pl
  gliwice.pl
  krakow.pl
  poznan.pl
  wroc.pl
  zakopane.pl
  
  // Pantheon Systems, Inc. : https://pantheon.io/
  // Submitted by Gary Dylina <gary@pantheon.io>
  pantheonsite.io
  gotpantheon.com
  
  // Peplink | Pepwave : http://peplink.com/
  // Submitted by Steve Leung <steveleung@peplink.com>
  mypep.link
  
  // Planet-Work : https://www.planet-work.com/
  // Submitted by Frdric VANNIRE <f.vanniere@planet-work.com>
  on-web.fr
  
  // Platform.sh : https://platform.sh
  // Submitted by Nikola Kotur <nikola@platform.sh>
  *.platform.sh
  *.platformsh.site
  
  // prgmr.com : https://prgmr.com/
  // Submitted by Sarah Newman <owner@prgmr.com>
  xen.prgmr.com
  
  // priv.at : http://www.nic.priv.at/
  // Submitted by registry <lendl@nic.at>
  priv.at
  
  // Protonet GmbH : http://protonet.io
  // Submitted by Martin Meier <admin@protonet.io>
  protonet.io
  
  // Publication Presse Communication SARL : https://ppcom.fr
  // Submitted by Yaacov Akiba Slama <admin@chirurgiens-dentistes-en-france.fr>
  chirurgiens-dentistes-en-france.fr
  byen.site
  
  // QA2
  // Submitted by Daniel Dent (https://www.danieldent.com/)
  qa2.com
  
  // QNAP System Inc : https://www.qnap.com
  // Submitted by Nick Chang <nickchang@qnap.com>
  dev-myqnapcloud.com
  alpha-myqnapcloud.com
  myqnapcloud.com
  
  // Quip : https://quip.com
  // Submitted by Patrick Linehan <plinehan@quip.com>
  *.quipelements.com
  
  // Qutheory LLC : http://qutheory.io
  // Submitted by Jonas Schwartz <jonas@qutheory.io>
  vapor.cloud
  vaporcloud.io
  
  // Rackmaze LLC : https://www.rackmaze.com
  // Submitted by Kirill Pertsev <kika@rackmaze.com>
  rackmaze.com
  rackmaze.net
  
  // Red Hat, Inc. OpenShift : https://openshift.redhat.com/
  // Submitted by Tim Kramer <tkramer@rhcloud.com>
  rhcloud.com
  
  // Resin.io : https://resin.io
  // Submitted by Tim Perry <tim@resin.io>
  resindevice.io
  devices.resinstaging.io
  
  // RethinkDB : https://www.rethinkdb.com/
  // Submitted by Chris Kastorff <info@rethinkdb.com>
  hzc.io
  
  // Revitalised Limited : http://www.revitalised.co.uk
  // Submitted by Jack Price <jack@revitalised.co.uk>
  wellbeingzone.eu
  ptplus.fit
  wellbeingzone.co.uk
  
  // Sandstorm Development Group, Inc. : https://sandcats.io/
  // Submitted by Asheesh Laroia <asheesh@sandstorm.io>
  sandcats.io
  
  // SBE network solutions GmbH : https://www.sbe.de/
  // Submitted by Norman Meilick <nm@sbe.de>
  logoip.de
  logoip.com
  
  // schokokeks.org GbR : https://schokokeks.org/
  // Submitted by Hanno Bck <hanno@schokokeks.org>
  schokokeks.net
  
  // Scry Security : http://www.scrysec.com
  // Submitted by Shante Adam <shante@skyhat.io>
  scrysec.com
  
  // Securepoint GmbH : https://www.securepoint.de
  // Submitted by Erik Anders <erik.anders@securepoint.de>
  firewall-gateway.com
  firewall-gateway.de
  my-gateway.de
  my-router.de
  spdns.de
  spdns.eu
  firewall-gateway.net
  my-firewall.org
  myfirewall.org
  spdns.org
  
  // SensioLabs, SAS : https://sensiolabs.com/
  // Submitted by Fabien Potencier <fabien.potencier@sensiolabs.com>
  *.s5y.io
  *.sensiosite.cloud
  
  // Service Online LLC : http://drs.ua/
  // Submitted by Serhii Bulakh <support@drs.ua>
  biz.ua
  co.ua
  pp.ua
  
  // ShiftEdit : https://shiftedit.net/
  // Submitted by Adam Jimenez <adam@shiftcreate.com>
  shiftedit.io
  
  // Shopblocks : http://www.shopblocks.com/
  // Submitted by Alex Bowers <alex@shopblocks.com>
  myshopblocks.com
  
  // SinaAppEngine : http://sae.sina.com.cn/
  // Submitted by SinaAppEngine <saesupport@sinacloud.com>
  1kapp.com
  appchizi.com
  applinzi.com
  sinaapp.com
  vipsinaapp.com
  
  // Skyhat : http://www.skyhat.io
  // Submitted by Shante Adam <shante@skyhat.io>
  bounty-full.com
  alpha.bounty-full.com
  beta.bounty-full.com
  
  // staticland : https://static.land
  // Submitted by Seth Vincent <sethvincent@gmail.com>
  static.land
  dev.static.land
  sites.static.land
  
  // SourceLair PC : https://www.sourcelair.com
  // Submitted by Antonis Kalipetis <akalipetis@sourcelair.com>
  apps.lair.io
  *.stolos.io
  
  // SpaceKit : https://www.spacekit.io/
  // Submitted by Reza Akhavan <spacekit.io@gmail.com>
  spacekit.io
  
  // Stackspace : https://www.stackspace.io/
  // Submitted by Lina He <info@stackspace.io>
  stackspace.space
  
  // Storj Labs Inc. : https://storj.io/
  // Submitted by Philip Hutchins <hostmaster@storj.io>
  storj.farm
  
  // Sub 6 Limited: http://www.sub6.com
  // Submitted by Dan Miller <dm@sub6.com>
  temp-dns.com
  
  // Synology, Inc. : https://www.synology.com/
  // Submitted by Rony Weng <ronyweng@synology.com>
  diskstation.me
  dscloud.biz
  dscloud.me
  dscloud.mobi
  dsmynas.com
  dsmynas.net
  dsmynas.org
  familyds.com
  familyds.net
  familyds.org
  i234.me
  myds.me
  synology.me
  vpnplus.to
  
  // TAIFUN Software AG : http://taifun-software.de
  // Submitted by Bjoern Henke <dev-server@taifun-software.de>
  taifun-dns.de
  
  // TASK geographical domains (www.task.gda.pl/uslugi/dns)
  gda.pl
  gdansk.pl
  gdynia.pl
  med.pl
  sopot.pl
  
  // Thingdust AG : https://thingdust.com/
  // Submitted by Adrian Imboden <adi@thingdust.com>
  cust.dev.thingdust.io
  cust.disrec.thingdust.io
  cust.prod.thingdust.io
  cust.testing.thingdust.io
  
  // TownNews.com : http://www.townnews.com
  // Submitted by Dustin Ward <dward@townnews.com>
  bloxcms.com
  townnews-staging.com
  
  // TrafficPlex GmbH : https://www.trafficplex.de/
  // Submitted by Phillipp Rll <phillipp.roell@trafficplex.de>
  12hp.at
  2ix.at
  4lima.at
  lima-city.at
  12hp.ch
  2ix.ch
  4lima.ch
  lima-city.ch
  trafficplex.cloud
  de.cool
  12hp.de
  2ix.de
  4lima.de
  lima-city.de
  1337.pictures
  clan.rip
  lima-city.rocks
  webspace.rocks
  lima.zone
  
  // TransIP : htts://www.transip.nl
  // Submitted by Rory Breuk <rbreuk@transip.nl>
  *.transurl.be
  *.transurl.eu
  *.transurl.nl
  
  // TuxFamily : http://tuxfamily.org
  // Submitted by TuxFamily administrators <adm@staff.tuxfamily.org>
  tuxfamily.org
  
  // TwoDNS : https://www.twodns.de/
  // Submitted by TwoDNS-Support <support@two-dns.de>
  dd-dns.de
  diskstation.eu
  diskstation.org
  dray-dns.de
  draydns.de
  dyn-vpn.de
  dynvpn.de
  mein-vigor.de
  my-vigor.de
  my-wan.de
  syno-ds.de
  synology-diskstation.de
  synology-ds.de
  
  // Uberspace : https://uberspace.de
  // Submitted by Moritz Werner <mwerner@jonaspasche.com>
  uber.space
  
  // UDR Limited : http://www.udr.hk.com
  // Submitted by registry <hostmaster@udr.hk.com>
  hk.com
  hk.org
  ltd.hk
  inc.hk
  
  // .US
  // Submitted by Ed Moore <Ed.Moore@lib.de.us>
  lib.de.us
  
  // VeryPositive SIA : http://very.lv
  // Submitted by Danko Aleksejevs <danko@very.lv>
  2038.io
  
  // Viprinet Europe GmbH : http://www.viprinet.com
  // Submitted by Simon Kissel <hostmaster@viprinet.com>
  router.management
  
  // Virtual-Info : https://www.virtual-info.info/
  // Submitted by Adnan RIHAN <hostmaster@v-info.info>
  v-info.info
  
  // WeDeploy by Liferay, Inc. : https://www.wedeploy.com
  // Submitted by Henrique Vicente <security@wedeploy.com>
  wedeploy.io
  wedeploy.me
  wedeploy.sh
  
  // Western Digital Technologies, Inc : https://www.wdc.com
  // Submitted by Jung Jin <jungseok.jin@wdc.com>
  remotewd.com
  
  // Wikimedia Labs : https://wikitech.wikimedia.org
  // Submitted by Yuvi Panda <yuvipanda@wikimedia.org>
  wmflabs.org
  
  // XS4ALL Internet bv : https://www.xs4all.nl/
  // Submitted by Daniel Mostertman <unixbeheer+publicsuffix@xs4all.net>
  cistron.nl
  demon.nl
  xs4all.space
  
  // YesCourse Pty Ltd : https://yescourse.com
  // Submitted by Atul Bhouraskar <atul@yescourse.com>
  official.academy
  
  // Yola : https://www.yola.com/
  // Submitted by Stefano Rivera <stefano@yola.com>
  yolasite.com
  
  // Yombo : https://yombo.net
  // Submitted by Mitch Schwenk <mitch@yombo.net>
  ybo.faith
  yombo.me
  homelink.one
  ybo.party
  ybo.review
  ybo.science
  ybo.trade
  
  // ZaNiC : http://www.za.net/
  // Submitted by registry <hostmaster@nic.za.net>
  za.net
  za.org
  
  // Zeit, Inc. : https://zeit.domains/
  // Submitted by Olli Vanhoja <olli@zeit.co>
  now.sh
  
  // ===END PRIVATE DOMAINS===
  END_BUILTIN_DATA
  1;
IO_SOCKET_SSL_PUBLICSUFFIX

$fatpacked{"IO/Socket/SSL/Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_SOCKET_SSL_UTILS';
  
  package IO::Socket::SSL::Utils;
  use strict;
  use warnings;
  use Carp 'croak';
  use Net::SSLeay;
  
  # old versions of Exporter do not export 'import' yet
  require Exporter;
  *import = \&Exporter::import;
  
  our $VERSION = '2.014';
  our @EXPORT = qw(
      PEM_file2cert PEM_string2cert PEM_cert2file PEM_cert2string
      PEM_file2key PEM_string2key PEM_key2file PEM_key2string
      KEY_free CERT_free
      KEY_create_rsa CERT_asHash CERT_create
  );
  
  sub PEM_file2cert {
      my $file = shift;
      my $bio = Net::SSLeay::BIO_new_file($file,'r') or
  	croak "cannot read $file: $!";
      my $cert = Net::SSLeay::PEM_read_bio_X509($bio);
      Net::SSLeay::BIO_free($bio);
      $cert or croak "cannot parse $file as PEM X509 cert: ".
  	Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
      return $cert;
  }
  
  sub PEM_cert2file {
      my ($cert,$file) = @_;
      my $string = Net::SSLeay::PEM_get_string_X509($cert)
  	or croak("cannot get string from cert");
      open( my $fh,'>',$file ) or croak("cannot write $file: $!");
      print $fh $string;
  }
  
  sub PEM_string2cert {
      my $string = shift;
      my $bio = Net::SSLeay::BIO_new( Net::SSLeay::BIO_s_mem());
      Net::SSLeay::BIO_write($bio,$string);
      my $cert = Net::SSLeay::PEM_read_bio_X509($bio);
      Net::SSLeay::BIO_free($bio);
      $cert or croak "cannot parse string as PEM X509 cert: ".
  	Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
      return $cert;
  }
  
  sub PEM_cert2string {
      my $cert = shift;
      return Net::SSLeay::PEM_get_string_X509($cert)
  	|| croak("cannot get string from cert");
  }
  
  sub PEM_file2key {
      my $file = shift;
      my $bio = Net::SSLeay::BIO_new_file($file,'r') or
  	croak "cannot read $file: $!";
      my $key = Net::SSLeay::PEM_read_bio_PrivateKey($bio);
      Net::SSLeay::BIO_free($bio);
      $key or croak "cannot parse $file as PEM private key: ".
  	Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
      return $key;
  }
  
  sub PEM_key2file {
      my ($key,$file) = @_;
      my $string = Net::SSLeay::PEM_get_string_PrivateKey($key)
  	or croak("cannot get string from key");
      open( my $fh,'>',$file ) or croak("cannot write $file: $!");
      print $fh $string;
  }
  
  sub PEM_string2key {
      my $string = shift;
      my $bio = Net::SSLeay::BIO_new( Net::SSLeay::BIO_s_mem());
      Net::SSLeay::BIO_write($bio,$string);
      my $key = Net::SSLeay::PEM_read_bio_PrivateKey($bio);
      Net::SSLeay::BIO_free($bio);
      $key or croak "cannot parse string as PEM private key: ".
  	Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
      return $key;
  }
  
  sub PEM_key2string {
      my $key = shift;
      return Net::SSLeay::PEM_get_string_PrivateKey($key)
  	|| croak("cannot get string from key");
  }
  
  sub CERT_free {
      my $cert = shift or return;
      Net::SSLeay::X509_free($cert);
  }
  
  sub KEY_free {
      my $key = shift or return;
      Net::SSLeay::EVP_PKEY_free($key);
  }
  
  sub KEY_create_rsa {
      my $bits = shift || 2048;
      my $key = Net::SSLeay::EVP_PKEY_new();
      my $rsa = Net::SSLeay::RSA_generate_key($bits, 0x10001); # 0x10001 = RSA_F4
      Net::SSLeay::EVP_PKEY_assign_RSA($key,$rsa);
      return $key;
  }
  
  if (defined &Net::SSLeay::EC_KEY_generate_key) {
      push @EXPORT,'KEY_create_ec';
      *KEY_create_ec = sub {
  	my $curve = shift || 'prime256v1';
  	my $key = Net::SSLeay::EVP_PKEY_new();
  	my $ec = Net::SSLeay::EC_KEY_generate_key($curve);
  	Net::SSLeay::EVP_PKEY_assign_EC_KEY($key,$ec);
  	return $key;
      }
  }
  
  # extract information from cert
  my %gen2i = qw( OTHERNAME 0 EMAIL 1 DNS 2 X400 3 DIRNAME 4 EDIPARTY 5 URI 6 IP 7 RID 8 );
  my %i2gen = reverse %gen2i;
  sub CERT_asHash {
      my $cert = shift;
      my $digest_name = shift || 'sha256';
  
      my %hash = (
  	version => Net::SSLeay::X509_get_version($cert),
  	not_before => _asn1t2t(Net::SSLeay::X509_get_notBefore($cert)),
  	not_after => _asn1t2t(Net::SSLeay::X509_get_notAfter($cert)),
  	serial => Net::SSLeay::P_ASN1_INTEGER_get_dec(
  	    Net::SSLeay::X509_get_serialNumber($cert)),
  	signature_alg => Net::SSLeay::OBJ_obj2txt (
  	    Net::SSLeay::P_X509_get_signature_alg($cert)),
  	crl_uri  => [ Net::SSLeay::P_X509_get_crl_distribution_points($cert) ],
  	keyusage => [ Net::SSLeay::P_X509_get_key_usage($cert) ],
  	extkeyusage => {
  	    oid => [ Net::SSLeay::P_X509_get_ext_key_usage($cert,0) ],
  	    nid => [ Net::SSLeay::P_X509_get_ext_key_usage($cert,1) ],
  	    sn  => [ Net::SSLeay::P_X509_get_ext_key_usage($cert,2) ],
  	    ln  => [ Net::SSLeay::P_X509_get_ext_key_usage($cert,3) ],
  	},
  	"pubkey_digest_$digest_name" => Net::SSLeay::X509_pubkey_digest(
  	    $cert,_digest($digest_name)),
  	"x509_digest_$digest_name" => Net::SSLeay::X509_digest(
  	    $cert,_digest($digest_name)),
  	"fingerprint_$digest_name" => Net::SSLeay::X509_get_fingerprint(
  	    $cert,_digest($digest_name)),
      );
  
      my $subj = Net::SSLeay::X509_get_subject_name($cert);
      my %subj;
      for ( 0..Net::SSLeay::X509_NAME_entry_count($subj)-1 ) {
  	my $e = Net::SSLeay::X509_NAME_get_entry($subj,$_);
  	my $o = Net::SSLeay::X509_NAME_ENTRY_get_object($e);
  	$subj{ Net::SSLeay::OBJ_obj2txt($o) } =
  	    Net::SSLeay::P_ASN1_STRING_get(
  		Net::SSLeay::X509_NAME_ENTRY_get_data($e));
      }
      $hash{subject} = \%subj;
  
      if ( my @names = Net::SSLeay::X509_get_subjectAltNames($cert) ) {
  	my $alt = $hash{subjectAltNames} = [];
  	while (my ($t,$v) = splice(@names,0,2)) {
  	    $t = $i2gen{$t} || die "unknown type $t in subjectAltName";
  	    if ( $t eq 'IP' ) {
  		if (length($v) == 4) {
  		    $v = join('.',unpack("CCCC",$v));
  		} elsif ( length($v) == 16 ) {
  		    my @v = unpack("nnnnnnnn",$v);
  		    my ($best0,$last0);
  		    for(my $i=0;$i<@v;$i++) {
  			if ($v[$i] == 0) {
  			    if ($last0) {
  				$last0->[1] = $i;
  				$last0->[2]++;
  				$best0 = $last0 if ++$last0->[2]>$best0->[2];
  			    } else {
  				$last0 = [ $i,$i,0 ];
  				$best0 ||= $last0;
  			    }
  			} else {
  			    $last0 = undef;
  			}
  		    }
  		    if ($best0) {
  			$v = '';
  			$v .= join(':', map { sprintf( "%x",$_) } @v[0..$best0->[0]-1]) if $best0->[0]>0;
  			$v .= '::';
  			$v .= join(':', map { sprintf( "%x",$_) } @v[$best0->[1]+1..$#v]) if $best0->[1]<$#v;
  		    } else {
  			$v = join(':', map { sprintf( "%x",$_) } @v);
  		    }
  		}
  	    }
  	    push @$alt,[$t,$v]
  	}
      }
  
      my $issuer = Net::SSLeay::X509_get_issuer_name($cert);
      my %issuer;
      for ( 0..Net::SSLeay::X509_NAME_entry_count($issuer)-1 ) {
  	my $e = Net::SSLeay::X509_NAME_get_entry($issuer,$_);
  	my $o = Net::SSLeay::X509_NAME_ENTRY_get_object($e);
  	$issuer{ Net::SSLeay::OBJ_obj2txt($o) } =
  	    Net::SSLeay::P_ASN1_STRING_get(
  		Net::SSLeay::X509_NAME_ENTRY_get_data($e));
      }
      $hash{issuer} = \%issuer;
  
      my @ext;
      for( 0..Net::SSLeay::X509_get_ext_count($cert)-1 ) {
  	my $e = Net::SSLeay::X509_get_ext($cert,$_);
  	my $o = Net::SSLeay::X509_EXTENSION_get_object($e);
  	my $nid = Net::SSLeay::OBJ_obj2nid($o);
  	push @ext, {
  	    oid => Net::SSLeay::OBJ_obj2txt($o),
  	    nid => ( $nid > 0 ) ? $nid : undef,
  	    sn  => ( $nid > 0 ) ? Net::SSLeay::OBJ_nid2sn($nid) : undef,
  	    critical => Net::SSLeay::X509_EXTENSION_get_critical($e),
  	    data => Net::SSLeay::X509V3_EXT_print($e),
  	}
      }
      $hash{ext} = \@ext;
  
      if ( defined(&Net::SSLeay::P_X509_get_ocsp_uri)) {
  	$hash{ocsp_uri} = [ Net::SSLeay::P_X509_get_ocsp_uri($cert) ];
      } else {
  	$hash{ocsp_uri} = [];
  	for( @ext ) {
  	    $_->{sn} or next;
  	    $_->{sn} eq 'authorityInfoAccess' or next;
  	    push @{ $hash{ocsp_uri}}, $_->{data} =~m{\bOCSP - URI:(\S+)}g;
  	}
      }
  
      return \%hash;
  }
  
  sub CERT_create {
      my %args = @_%2 ? %{ shift() } :  @_;
  
      my $cert = Net::SSLeay::X509_new();
      my $digest_name = delete $args{digest} || 'sha256';
  
      Net::SSLeay::ASN1_INTEGER_set(
  	Net::SSLeay::X509_get_serialNumber($cert),
  	delete $args{serial} || rand(2**32),
      );
  
      # version default to 2 (V3)
      Net::SSLeay::X509_set_version($cert,
  	delete $args{version} || 2 );
  
      # not_before default to now
      Net::SSLeay::ASN1_TIME_set(
  	Net::SSLeay::X509_get_notBefore($cert),
  	delete $args{not_before} || time()
      );
  
      # not_after default to now+365 days
      Net::SSLeay::ASN1_TIME_set(
  	Net::SSLeay::X509_get_notAfter($cert),
  	delete $args{not_after} || time() + 365*86400
      );
  
      # set subject
      my $subj_e = Net::SSLeay::X509_get_subject_name($cert);
      my $subj = delete $args{subject} || {
  	organizationName => 'IO::Socket::SSL',
  	commonName => 'IO::Socket::SSL Test'
      };
      while ( my ($k,$v) = each %$subj ) {
  	# Not everything we get is nice - try with MBSTRING_UTF8 first and if it
  	# fails try V_ASN1_T61STRING and finally V_ASN1_OCTET_STRING
  	Net::SSLeay::X509_NAME_add_entry_by_txt($subj_e,$k,0x1000,$v,-1,0)
  	    or Net::SSLeay::X509_NAME_add_entry_by_txt($subj_e,$k,20,$v,-1,0)
  	    or Net::SSLeay::X509_NAME_add_entry_by_txt($subj_e,$k,4,$v,-1,0)
  	    or croak("failed to add entry for $k - ".
  	    Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error()));
      }
  
      my @ext = (
  	&Net::SSLeay::NID_subject_key_identifier => 'hash',
  	&Net::SSLeay::NID_authority_key_identifier => 'keyid',
      );
      if ( my $altsubj = delete $args{subjectAltNames} ) {
  	push @ext,
  	    &Net::SSLeay::NID_subject_alt_name =>
  	    join(',', map { "$_->[0]:$_->[1]" } @$altsubj)
      }
  
      my $key = delete $args{key} || KEY_create_rsa();
      Net::SSLeay::X509_set_pubkey($cert,$key);
  
      my $is = delete $args{issuer};
      my $issuer_cert = delete $args{issuer_cert} || $is && $is->[0] || $cert;
      my $issuer_key  = delete $args{issuer_key}  || $is && $is->[1] || $key;
  
      my %purpose;
      if (my $p = delete $args{purpose}) {
  	if (!ref($p)) {
  	    $purpose{lc($2)} = (!$1 || $1 eq '+') ? 1:0
  		while $p =~m{([+-]?)(\w+)}g;
  	} elsif (ref($p) eq 'ARRAY') {
  	    for(@$p) {
  		m{^([+-]?)(\w+)$} or die "invalid entry in purpose: $_";
  		$purpose{lc($2)} = (!$1 || $1 eq '+') ? 1:0
  	    }
  	} else {
  	    while( my ($k,$v) = each %$p) {
  		$purpose{lc($k)} = ($v && $v ne '-')?1:0;
  	    }
  	}
      }
      if (delete $args{CA}) {
  	# add defaults for CA
  	%purpose = (
  	    ca => 1, sslca => 1, emailca => 1, objca => 1,
  	    %purpose
  	);
      }
      if (!%purpose) {
  	%purpose = (server => 1, client => 1);
      }
  
      my (%key_usage,%ext_key_usage,%cert_type,%basic_constraints);
  
      my %dS = ( digitalSignature => \%key_usage );
      my %kE = ( keyEncipherment => \%key_usage );
      my %CA = ( 'CA:TRUE' => \%basic_constraints, %dS, keyCertSign => \%key_usage );
      my @disable;
      for(
  	[ client  => { %dS, %kE, clientAuth => \%ext_key_usage, client  => \%cert_type } ],
  	[ server  => { %dS, %kE, serverAuth => \%ext_key_usage, server  => \%cert_type } ],
  	[ email   => { %dS, %kE, emailProtection => \%ext_key_usage, email => \%cert_type } ],
  	[ objsign => { %dS, %kE, codeSigning => \%ext_key_usage, objsign => \%cert_type } ],
  
  	[ CA      => { %CA }],
  	[ sslCA   => { %CA, sslCA => \%cert_type }],
  	[ emailCA => { %CA, emailCA => \%cert_type }],
  	[ objCA   => { %CA, objCA => \%cert_type }],
  
  	[ emailProtection  => { %dS, %kE, emailProtection => \%ext_key_usage, email => \%cert_type } ],
  	[ codeSigning      => { %dS, %kE, codeSigning => \%ext_key_usage, objsign => \%cert_type } ],
  
  	[ timeStamping     => { timeStamping => \%ext_key_usage } ],
  	[ digitalSignature => { digitalSignature => \%key_usage } ],
  	[ nonRepudiation   => { nonRepudiation => \%key_usage } ],
  	[ keyEncipherment  => { keyEncipherment => \%key_usage } ],
  	[ dataEncipherment => { dataEncipherment => \%key_usage } ],
  	[ keyAgreement     => { keyAgreement => \%key_usage } ],
  	[ keyCertSign      => { keyCertSign => \%key_usage } ],
  	[ cRLSign          => { cRLSign => \%key_usage } ],
  	[ encipherOnly     => { encipherOnly => \%key_usage } ],
  	[ decipherOnly     => { decipherOnly => \%key_usage } ],
  	[ clientAuth       => { clientAuth   => \%ext_key_usage } ],
  	[ serverAuth       => { serverAuth   => \%ext_key_usage } ],
      ) {
  	exists $purpose{lc($_->[0])} or next;
  	if (delete $purpose{lc($_->[0])}) {
  	    while (my($k,$h) = each %{$_->[1]}) {
  		$h->{$k} = 1;
  	    }
  	} else {
  	    push @disable, $_->[1];
  	}
      }
      die "unknown purpose ".join(",",keys %purpose) if %purpose;
      for(@disable) {
  	while (my($k,$h) = each %$_) {
  	    delete $h->{$k};
  	}
      }
  
      if (%basic_constraints) {
  	push @ext,&Net::SSLeay::NID_basic_constraints,
  	    => join(",",'critical', sort keys %basic_constraints);
      } else {
  	push @ext, &Net::SSLeay::NID_basic_constraints => 'critical,CA:FALSE';
      }
      push @ext,&Net::SSLeay::NID_key_usage
  	=> join(",",'critical', sort keys %key_usage) if %key_usage;
      push @ext,&Net::SSLeay::NID_netscape_cert_type
  	=> join(",",sort keys %cert_type) if %cert_type;
      push @ext,&Net::SSLeay::NID_ext_key_usage
  	=> join(",",sort keys %ext_key_usage) if %ext_key_usage;
      Net::SSLeay::P_X509_add_extensions($cert, $issuer_cert, @ext);
  
      my %have_ext;
      for(my $i=0;$i<@ext;$i+=2) {
  	$have_ext{ $ext[$i] }++
      }
      for my $ext (@{ $args{ext} || [] }) {
  	my $nid = $ext->{nid}
  	    || $ext->{sn} && Net::SSLeay::OBJ_sn2nid($ext->{sn})
  	    || croak "cannot determine NID of extension";
  	$have_ext{$nid} and next;
  	my $val = $ext->{data};
  	if ($nid == 177) {
  	    # authorityInfoAccess:
  	    # OpenSSL i2v does not output the same way as expected by i2v :(
  	    for (split(/\n/,$val)) {
  		s{ - }{;}; # "OCSP - URI:..." -> "OCSP;URI:..."
  		$_ = "critical,$_" if $ext->{critical};
  		Net::SSLeay::P_X509_add_extensions($cert,$issuer_cert,$nid,$_);
  	    }
  	} else {
  	    $val = "critical,$val" if $ext->{critical};
  	    Net::SSLeay::P_X509_add_extensions($cert, $issuer_cert, $nid, $val);
  	}
      }
  
      Net::SSLeay::X509_set_issuer_name($cert,
  	Net::SSLeay::X509_get_subject_name($issuer_cert));
      Net::SSLeay::X509_sign($cert,$issuer_key,_digest($digest_name));
  
      return ($cert,$key);
  }
  
  
  
  if ( defined &Net::SSLeay::ASN1_TIME_timet ) {
      *_asn1t2t = \&Net::SSLeay::ASN1_TIME_timet
  } else {
      require Time::Local;
      my %mon2i = qw(
  	Jan 0 Feb 1 Mar 2 Apr 3 May 4 Jun 5
  	Jul 6 Aug 7 Sep 8 Oct 9 Nov 10 Dec 11
      );
      *_asn1t2t = sub {
  	my $t = Net::SSLeay::P_ASN1_TIME_put2string( shift );
  	my ($mon,$d,$h,$m,$s,$y,$tz) = split(/[\s:]+/,$t);
  	defined( $mon = $mon2i{$mon} ) or die "invalid month in $t";
  	$tz ||= $y =~s{^(\d+)([A-Z]\S*)}{$1} && $2;
  	if ( ! $tz ) {
  	    return Time::Local::timelocal($s,$m,$h,$d,$mon,$y)
  	} elsif ( $tz eq 'GMT' ) {
  	    return Time::Local::timegm($s,$m,$h,$d,$mon,$y)
  	} else {
  	    die "unexpected TZ $tz from ASN1_TIME_print";
  	}
      }
  }
  
  {
      my %digest;
      sub _digest {
  	my $digest_name = shift;
  	return $digest{$digest_name} ||= do {
  	    Net::SSLeay::SSLeay_add_ssl_algorithms();
  	    Net::SSLeay::EVP_get_digestbyname($digest_name)
  		or die "Digest algorithm $digest_name is not available";
  	};
      }
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Socket::SSL::Utils -- loading, storing, creating certificates and keys
  
  =head1 SYNOPSIS
  
      use IO::Socket::SSL::Utils;
      my $cert = PEM_file2cert('cert.pem');  # load certificate from file
      my $string = PEM_cert2string($cert);   # convert certificate to PEM string
      CERT_free($cert);                      # free memory within OpenSSL
  
      my $key = KEY_create_rsa(2048);        # create new 2048-bit RSA key
      PEM_string2file($key,"key.pem");       # and write it to file
      KEY_free($key);                        # free memory within OpenSSL
  
  
  =head1 DESCRIPTION
  
  This module provides various utility functions to work with certificates and
  private keys, shielding some of the complexity of the underlying Net::SSLeay and
  OpenSSL.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item *
  
  Functions converting between string or file and certificates and keys.
  They croak if the operation cannot be completed.
  
  =over 8
  
  =item PEM_file2cert(file) -> cert
  
  =item PEM_cert2file(cert,file)
  
  =item PEM_string2cert(string) -> cert
  
  =item PEM_cert2string(cert) -> string
  
  =item PEM_file2key(file) -> key
  
  =item PEM_key2file(key,file)
  
  =item PEM_string2key(string) -> key
  
  =item PEM_key2string(key) -> string
  
  =back
  
  =item *
  
  Functions for cleaning up.
  Each loaded or created cert and key must be freed to not leak memory.
  
  =over 8
  
  =item CERT_free(cert)
  
  =item KEY_free(key)
  
  =back
  
  =item * KEY_create_rsa(bits) -> key
  
  Creates an RSA key pair, bits defaults to 2048.
  
  =item * KEY_create_ec(curve) -> key
  
  Creates an EC key, curve defaults to C<prime256v1>.
  
  =item * CERT_asHash(cert,[digest_algo]) -> hash
  
  Extracts the information from the certificate into a hash and uses the given
  digest_algo (default: SHA-256) to determine digest of pubkey and cert.
  The resulting hash contains:
  
  =over 8
  
  =item subject
  
  Hash with the parts of the subject, e.g. commonName, countryName,
  organizationName, stateOrProvinceName, localityName.
  
  =item subjectAltNames
  
  Array with list of alternative names. Each entry in the list is of
  C<[type,value]>, where C<type> can be OTHERNAME, EMAIL, DNS, X400, DIRNAME,
  EDIPARTY, URI, IP or RID.
  
  =item issuer
  
  Hash with the parts of the issuer, e.g. commonName, countryName,
  organizationName, stateOrProvinceName, localityName.
  
  =item not_before, not_after
  
  The time frame, where the certificate is valid, as time_t, e.g. can be converted
  with localtime or similar functions.
  
  =item serial
  
  The serial number
  
  =item crl_uri
  
  List of URIs for CRL distribution.
  
  =item ocsp_uri
  
  List of URIs for revocation checking using OCSP.
  
  =item keyusage
  
  List of keyUsage information in the certificate.
  
  =item extkeyusage
  
  List of extended key usage information from the certificate. Each entry in
  this list consists of a hash with oid, nid, ln and sn.
  
  =item pubkey_digest_xxx
  
  Binary digest of the pubkey using the given digest algorithm, e.g.
  pubkey_digest_sha256 if (the default) SHA-256 was used.
  
  =item x509_digest_xxx
  
  Binary digest of the X.509 certificate using the given digest algorithm, e.g.
  x509_digest_sha256 if (the default) SHA-256 was used.
  
  =item fingerprint_xxx
  
  Fingerprint of the certificate using the given digest algorithm, e.g.
  fingerprint_sha256 if (the default) SHA-256 was used. Contrary to digest_* this
  is an ASCII string with a list if hexadecimal numbers, e.g.
  "73:59:75:5C:6D...".
  
  =item signature_alg
  
  Algorithm used to sign certificate, e.g. C<sha256WithRSAEncryption>.
  
  =item ext
  
  List of extensions.
  Each entry in the list is a hash with oid, nid, sn, critical flag (boolean) and
  data (string representation given by X509V3_EXT_print).
  
  =item version
  
  Certificate version, usually 2 (x509v3)
  
  =back
  
  =item * CERT_create(hash) -> (cert,key)
  
  Creates a certificate based on the given hash.
  If the issuer is not specified the certificate will be self-signed.
  The following keys can be given:
  
  =over 8
  
  =item subject
  
  Hash with the parts of the subject, e.g. commonName, countryName, ... as
  described in C<CERT_asHash>.
  Default points to IO::Socket::SSL.
  
  =item not_before
  
  A time_t value when the certificate starts to be valid. Defaults to current
  time.
  
  =item not_after
  
  A time_t value when the certificate ends to be valid. Defaults to current
  time plus one 365 days.
  
  =item serial
  
  The serial number. If not given a random number will be used.
  
  =item version
  
  The version of the certificate, default 2 (x509v3).
  
  =item CA true|false
  
  If true declare certificate as CA, defaults to false.
  
  =item purpose string|array|hash
  
  Set the purpose of the certificate.
  The different purposes can be given as a string separated by non-word character,
  as array or hash. With string or array each purpose can be prefixed with '+'
  (enable) or '-' (disable) and same can be done with the value when given as a
  hash. By default enabling the purpose is assumed.
  
  If the CA option is given and true the defaults "ca,sslca,emailca,objca" are
  assumed, but can be overridden with explicit purpose.
  If the CA option is given and false the defaults "server,client" are assumed.
  If no CA option and no purpose is given it defaults to "server,client".
  
  Purpose affects basicConstraints, keyUsage, extKeyUsage and netscapeCertType.
  The following purposes are defined (case is not important):
  
      client
      server
      email
      objsign
  
      CA
      sslCA
      emailCA
      objCA
  
      emailProtection
      codeSigning
      timeStamping
  
      digitalSignature
      nonRepudiation
      keyEncipherment
      dataEncipherment
      keyAgreement
      keyCertSign
      cRLSign
      encipherOnly
      decipherOnly
  
  Examples:
  
       # root-CA for SSL certificates
       purpose => 'sslCA'   # or CA => 1
  
       # server certificate and CA (typically self-signed)
       purpose => 'sslCA,server'
  
       # client certificate
       purpose => 'client',
  
  
  =item ext [{ sn => .., data => ... }, ... ]
  
  List of extensions. The type of the extension can be specified as name with
  C<sn> or as NID with C<nid> and the data with C<data>. These data must be in the
  same syntax as expected within openssl.cnf, e.g. something like
  C<OCSP;URI=http://...>. Additionally the critical flag can be set with
  C<critical => 1>.
  
  =item key key
  
  use given key as key for certificate, otherwise a new one will be generated and
  returned
  
  =item issuer_cert cert
  
  set issuer for new certificate
  
  =item issuer_key key
  
  sign new certificate with given key
  
  =item issuer [ cert, key ]
  
  Instead of giving issuer_key and issuer_cert as separate arguments they can be
  given both together.
  
  =item digest algorithm
  
  specify the algorithm used to sign the certificate, default SHA-256.
  
  =back
  
  =back
  
  =head1 AUTHOR
  
  Steffen Ullrich
IO_SOCKET_SSL_UTILS

$fatpacked{"JSON/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP';
  package JSON::PP;
  
  # JSON-2.0
  
  use 5.005;
  use strict;
  
  use Exporter ();
  BEGIN { @JSON::PP::ISA = ('Exporter') }
  
  use overload ();
  use JSON::PP::Boolean;
  
  use Carp ();
  #use Devel::Peek;
  
  $JSON::PP::VERSION = '2.97001';
  
  @JSON::PP::EXPORT = qw(encode_json decode_json from_json to_json);
  
  # instead of hash-access, i tried index-access for speed.
  # but this method is not faster than what i expected. so it will be changed.
  
  use constant P_ASCII                => 0;
  use constant P_LATIN1               => 1;
  use constant P_UTF8                 => 2;
  use constant P_INDENT               => 3;
  use constant P_CANONICAL            => 4;
  use constant P_SPACE_BEFORE         => 5;
  use constant P_SPACE_AFTER          => 6;
  use constant P_ALLOW_NONREF         => 7;
  use constant P_SHRINK               => 8;
  use constant P_ALLOW_BLESSED        => 9;
  use constant P_CONVERT_BLESSED      => 10;
  use constant P_RELAXED              => 11;
  
  use constant P_LOOSE                => 12;
  use constant P_ALLOW_BIGNUM         => 13;
  use constant P_ALLOW_BAREKEY        => 14;
  use constant P_ALLOW_SINGLEQUOTE    => 15;
  use constant P_ESCAPE_SLASH         => 16;
  use constant P_AS_NONBLESSED        => 17;
  
  use constant P_ALLOW_UNKNOWN        => 18;
  
  use constant OLD_PERL => $] < 5.008 ? 1 : 0;
  use constant USE_B => 0;
  
  BEGIN {
  if (USE_B) {
      require B;
  }
  }
  
  BEGIN {
      my @xs_compati_bit_properties = qw(
              latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink
              allow_blessed convert_blessed relaxed allow_unknown
      );
      my @pp_bit_properties = qw(
              allow_singlequote allow_bignum loose
              allow_barekey escape_slash as_nonblessed
      );
  
      # Perl version check, Unicode handling is enabled?
      # Helper module sets @JSON::PP::_properties.
      if ( OLD_PERL ) {
          my $helper = $] >= 5.006 ? 'JSON::PP::Compat5006' : 'JSON::PP::Compat5005';
          eval qq| require $helper |;
          if ($@) { Carp::croak $@; }
      }
  
      for my $name (@xs_compati_bit_properties, @pp_bit_properties) {
          my $property_id = 'P_' . uc($name);
  
          eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$property_id] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$property_id] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$property_id] ? 1 : '';
              }
          /;
      }
  
  }
  
  
  
  # Functions
  
  my $JSON; # cache
  
  sub encode_json ($) { # encode
      ($JSON ||= __PACKAGE__->new->utf8)->encode(@_);
  }
  
  
  sub decode_json { # decode
      ($JSON ||= __PACKAGE__->new->utf8)->decode(@_);
  }
  
  # Obsoleted
  
  sub to_json($) {
     Carp::croak ("JSON::PP::to_json has been renamed to encode_json.");
  }
  
  
  sub from_json($) {
     Carp::croak ("JSON::PP::from_json has been renamed to decode_json.");
  }
  
  
  # Methods
  
  sub new {
      my $class = shift;
      my $self  = {
          max_depth   => 512,
          max_size    => 0,
          indent_length => 3,
      };
  
      bless $self, $class;
  }
  
  
  sub encode {
      return $_[0]->PP_encode_json($_[1]);
  }
  
  
  sub decode {
      return $_[0]->PP_decode_json($_[1], 0x00000000);
  }
  
  
  sub decode_prefix {
      return $_[0]->PP_decode_json($_[1], 0x00000001);
  }
  
  
  # accessor
  
  
  # pretty printing
  
  sub pretty {
      my ($self, $v) = @_;
      my $enable = defined $v ? $v : 1;
  
      if ($enable) { # indent_length(3) for JSON::XS compatibility
          $self->indent(1)->space_before(1)->space_after(1);
      }
      else {
          $self->indent(0)->space_before(0)->space_after(0);
      }
  
      $self;
  }
  
  # etc
  
  sub max_depth {
      my $max  = defined $_[1] ? $_[1] : 0x80000000;
      $_[0]->{max_depth} = $max;
      $_[0];
  }
  
  
  sub get_max_depth { $_[0]->{max_depth}; }
  
  
  sub max_size {
      my $max  = defined $_[1] ? $_[1] : 0;
      $_[0]->{max_size} = $max;
      $_[0];
  }
  
  
  sub get_max_size { $_[0]->{max_size}; }
  
  
  sub filter_json_object {
      if (defined $_[1] and ref $_[1] eq 'CODE') {
          $_[0]->{cb_object} = $_[1];
      } else {
          delete $_[0]->{cb_object};
      }
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub filter_json_single_key_object {
      if (@_ == 1 or @_ > 3) {
          Carp::croak("Usage: JSON::PP::filter_json_single_key_object(self, key, callback = undef)");
      }
      if (defined $_[2] and ref $_[2] eq 'CODE') {
          $_[0]->{cb_sk_object}->{$_[1]} = $_[2];
      } else {
          delete $_[0]->{cb_sk_object}->{$_[1]};
          delete $_[0]->{cb_sk_object} unless %{$_[0]->{cb_sk_object} || {}};
      }
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub indent_length {
      if (!defined $_[1] or $_[1] > 15 or $_[1] < 0) {
          Carp::carp "The acceptable range of indent_length() is 0 to 15.";
      }
      else {
          $_[0]->{indent_length} = $_[1];
      }
      $_[0];
  }
  
  sub get_indent_length {
      $_[0]->{indent_length};
  }
  
  sub sort_by {
      $_[0]->{sort_by} = defined $_[1] ? $_[1] : 1;
      $_[0];
  }
  
  sub allow_bigint {
      Carp::carp("allow_bigint() is obsoleted. use allow_bignum() instead.");
      $_[0]->allow_bignum;
  }
  
  ###############################
  
  ###
  ### Perl => JSON
  ###
  
  
  { # Convert
  
      my $max_depth;
      my $indent;
      my $ascii;
      my $latin1;
      my $utf8;
      my $space_before;
      my $space_after;
      my $canonical;
      my $allow_blessed;
      my $convert_blessed;
  
      my $indent_length;
      my $escape_slash;
      my $bignum;
      my $as_nonblessed;
  
      my $depth;
      my $indent_count;
      my $keysort;
  
  
      sub PP_encode_json {
          my $self = shift;
          my $obj  = shift;
  
          $indent_count = 0;
          $depth        = 0;
  
          my $props = $self->{PROPS};
  
          ($ascii, $latin1, $utf8, $indent, $canonical, $space_before, $space_after, $allow_blessed,
              $convert_blessed, $escape_slash, $bignum, $as_nonblessed)
           = @{$props}[P_ASCII .. P_SPACE_AFTER, P_ALLOW_BLESSED, P_CONVERT_BLESSED,
                      P_ESCAPE_SLASH, P_ALLOW_BIGNUM, P_AS_NONBLESSED];
  
          ($max_depth, $indent_length) = @{$self}{qw/max_depth indent_length/};
  
          $keysort = $canonical ? sub { $a cmp $b } : undef;
  
          if ($self->{sort_by}) {
              $keysort = ref($self->{sort_by}) eq 'CODE' ? $self->{sort_by}
                       : $self->{sort_by} =~ /\D+/       ? $self->{sort_by}
                       : sub { $a cmp $b };
          }
  
          encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")
               if(!ref $obj and !$props->[ P_ALLOW_NONREF ]);
  
          my $str  = $self->object_to_json($obj);
  
          $str .= "\n" if ( $indent ); # JSON::XS 2.26 compatible
  
          unless ($ascii or $latin1 or $utf8) {
              utf8::upgrade($str);
          }
  
          if ($props->[ P_SHRINK ]) {
              utf8::downgrade($str, 1);
          }
  
          return $str;
      }
  
  
      sub object_to_json {
          my ($self, $obj) = @_;
          my $type = ref($obj);
  
          if($type eq 'HASH'){
              return $self->hash_to_json($obj);
          }
          elsif($type eq 'ARRAY'){
              return $self->array_to_json($obj);
          }
          elsif ($type) { # blessed object?
              if (blessed($obj)) {
  
                  return $self->value_to_json($obj) if ( $obj->isa('JSON::PP::Boolean') );
  
                  if ( $convert_blessed and $obj->can('TO_JSON') ) {
                      my $result = $obj->TO_JSON();
                      if ( defined $result and ref( $result ) ) {
                          if ( refaddr( $obj ) eq refaddr( $result ) ) {
                              encode_error( sprintf(
                                  "%s::TO_JSON method returned same object as was passed instead of a new one",
                                  ref $obj
                              ) );
                          }
                      }
  
                      return $self->object_to_json( $result );
                  }
  
                  return "$obj" if ( $bignum and _is_bignum($obj) );
  
                  if ($allow_blessed) {
                      return $self->blessed_to_json($obj) if ($as_nonblessed); # will be removed.
                      return 'null';
                  }
                  encode_error( sprintf("encountered object '%s', but neither allow_blessed "
                      . "nor convert_blessed settings are enabled", $obj)
                  );
              }
              else {
                  return $self->value_to_json($obj);
              }
          }
          else{
              return $self->value_to_json($obj);
          }
      }
  
  
      sub hash_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
          my $del = ($space_before ? ' ' : '') . ':' . ($space_after ? ' ' : '');
  
          for my $k ( _sort( $obj ) ) {
              if ( OLD_PERL ) { utf8::decode($k) } # key for Perl 5.6 / be optimized
              push @res, $self->string_to_json( $k )
                            .  $del
                            . ( ref $obj->{$k} ? $self->object_to_json( $obj->{$k} ) : $self->value_to_json( $obj->{$k} ) );
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return '{}' unless @res;
          return '{' . $pre . join( ",$pre", @res ) . $post . '}';
      }
  
  
      sub array_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
  
          for my $v (@$obj){
              push @res, ref($v) ? $self->object_to_json($v) : $self->value_to_json($v);
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return '[]' unless @res;
          return '[' . $pre . join( ",$pre", @res ) . $post . ']';
      }
  
      sub _looks_like_number {
          my $value = shift;
          if (USE_B) {
              my $b_obj = B::svref_2object(\$value);
              my $flags = $b_obj->FLAGS;
              return 1 if $flags & ( B::SVp_IOK() | B::SVp_NOK() ) and !( $flags & B::SVp_POK() );
              return;
          } else {
              no warnings 'numeric';
              # if the utf8 flag is on, it almost certainly started as a string
              return if utf8::is_utf8($value);
              # detect numbers
              # string & "" -> ""
              # number & "" -> 0 (with warning)
              # nan and inf can detect as numbers, so check with * 0
              return unless length((my $dummy = "") & $value);
              return unless 0 + $value eq $value;
              return 1 if $value * 0 == 0;
              return -1; # inf/nan
          }
      }
  
      sub value_to_json {
          my ($self, $value) = @_;
  
          return 'null' if(!defined $value);
  
          my $type = ref($value);
  
          if (!$type) {
              if (_looks_like_number($value)) {
                  return $value;
              }
              return $self->string_to_json($value);
          }
          elsif( blessed($value) and  $value->isa('JSON::PP::Boolean') ){
              return $$value == 1 ? 'true' : 'false';
          }
          else {
              if ((overload::StrVal($value) =~ /=(\w+)/)[0]) {
                  return $self->value_to_json("$value");
              }
  
              if ($type eq 'SCALAR' and defined $$value) {
                  return   $$value eq '1' ? 'true'
                         : $$value eq '0' ? 'false'
                         : $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ? 'null'
                         : encode_error("cannot encode reference to scalar");
              }
  
              if ( $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ) {
                  return 'null';
              }
              else {
                  if ( $type eq 'SCALAR' or $type eq 'REF' ) {
                      encode_error("cannot encode reference to scalar");
                  }
                  else {
                      encode_error("encountered $value, but JSON can only represent references to arrays or hashes");
                  }
              }
  
          }
      }
  
  
      my %esc = (
          "\n" => '\n',
          "\r" => '\r',
          "\t" => '\t',
          "\f" => '\f',
          "\b" => '\b',
          "\"" => '\"',
          "\\" => '\\\\',
          "\'" => '\\\'',
      );
  
  
      sub string_to_json {
          my ($self, $arg) = @_;
  
          $arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;
          $arg =~ s/\//\\\//g if ($escape_slash);
          $arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;
  
          if ($ascii) {
              $arg = JSON_PP_encode_ascii($arg);
          }
  
          if ($latin1) {
              $arg = JSON_PP_encode_latin1($arg);
          }
  
          if ($utf8) {
              utf8::encode($arg);
          }
  
          return '"' . $arg . '"';
      }
  
  
      sub blessed_to_json {
          my $reftype = reftype($_[1]) || '';
          if ($reftype eq 'HASH') {
              return $_[0]->hash_to_json($_[1]);
          }
          elsif ($reftype eq 'ARRAY') {
              return $_[0]->array_to_json($_[1]);
          }
          else {
              return 'null';
          }
      }
  
  
      sub encode_error {
          my $error  = shift;
          Carp::croak "$error";
      }
  
  
      sub _sort {
          defined $keysort ? (sort $keysort (keys %{$_[0]})) : keys %{$_[0]};
      }
  
  
      sub _up_indent {
          my $self  = shift;
          my $space = ' ' x $indent_length;
  
          my ($pre,$post) = ('','');
  
          $post = "\n" . $space x $indent_count;
  
          $indent_count++;
  
          $pre = "\n" . $space x $indent_count;
  
          return ($pre,$post);
      }
  
  
      sub _down_indent { $indent_count--; }
  
  
      sub PP_encode_box {
          {
              depth        => $depth,
              indent_count => $indent_count,
          };
      }
  
  } # Convert
  
  
  sub _encode_ascii {
      join('',
          map {
              $_ <= 127 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_latin1 {
      join('',
          map {
              $_ <= 255 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_surrogates { # from perlunicode
      my $uni = $_[0] - 0x10000;
      return ($uni / 0x400 + 0xD800, $uni % 0x400 + 0xDC00);
  }
  
  
  sub _is_bignum {
      $_[0]->isa('Math::BigInt') or $_[0]->isa('Math::BigFloat');
  }
  
  
  
  #
  # JSON => Perl
  #
  
  my $max_intsize;
  
  BEGIN {
      my $checkint = 1111;
      for my $d (5..64) {
          $checkint .= 1;
          my $int   = eval qq| $checkint |;
          if ($int =~ /[eE]/) {
              $max_intsize = $d - 1;
              last;
          }
      }
  }
  
  { # PARSE 
  
      my %escapes = ( #  by Jeremy Muhlich <jmuhlich [at] bitflood.org>
          b    => "\x8",
          t    => "\x9",
          n    => "\xA",
          f    => "\xC",
          r    => "\xD",
          '\\' => '\\',
          '"'  => '"',
          '/'  => '/',
      );
  
      my $text; # json data
      my $at;   # offset
      my $ch;   # first character
      my $len;  # text length (changed according to UTF8 or NON UTF8)
      # INTERNAL
      my $depth;          # nest counter
      my $encoding;       # json text encoding
      my $is_valid_utf8;  # temp variable
      my $utf8_len;       # utf8 byte length
      # FLAGS
      my $utf8;           # must be utf8
      my $max_depth;      # max nest number of objects and arrays
      my $max_size;
      my $relaxed;
      my $cb_object;
      my $cb_sk_object;
  
      my $F_HOOK;
  
      my $allow_bignum;   # using Math::BigInt/BigFloat
      my $singlequote;    # loosely quoting
      my $loose;          # 
      my $allow_barekey;  # bareKey
  
      sub _detect_utf_encoding {
          my $text = shift;
          my @octets = unpack('C4', $text);
          return 'unknown' unless defined $octets[3];
          return ( $octets[0] and  $octets[1]) ? 'UTF-8'
               : (!$octets[0] and  $octets[1]) ? 'UTF-16BE'
               : (!$octets[0] and !$octets[1]) ? 'UTF-32BE'
               : ( $octets[2]                ) ? 'UTF-16LE'
               : (!$octets[2]                ) ? 'UTF-32LE'
               : 'unknown';
      }
  
      sub PP_decode_json {
          my ($self, $want_offset);
  
          ($self, $text, $want_offset) = @_;
  
          ($at, $ch, $depth) = (0, '', 0);
  
          if ( !defined $text or ref $text ) {
              decode_error("malformed JSON string, neither array, object, number, string or atom");
          }
  
          my $props = $self->{PROPS};
  
          ($utf8, $relaxed, $loose, $allow_bignum, $allow_barekey, $singlequote)
              = @{$props}[P_UTF8, P_RELAXED, P_LOOSE .. P_ALLOW_SINGLEQUOTE];
  
          if ( $utf8 ) {
              $encoding = _detect_utf_encoding($text);
              if ($encoding ne 'UTF-8' and $encoding ne 'unknown') {
                  require Encode;
                  Encode::from_to($text, $encoding, 'utf-8');
              } else {
                  utf8::downgrade( $text, 1 ) or Carp::croak("Wide character in subroutine entry");
              }
          }
          else {
              utf8::upgrade( $text );
              utf8::encode( $text );
          }
  
          $len = length $text;
  
          ($max_depth, $max_size, $cb_object, $cb_sk_object, $F_HOOK)
               = @{$self}{qw/max_depth  max_size cb_object cb_sk_object F_HOOK/};
  
          if ($max_size > 1) {
              use bytes;
              my $bytes = length $text;
              decode_error(
                  sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s"
                      , $bytes, $max_size), 1
              ) if ($bytes > $max_size);
          }
  
          white(); # remove head white space
  
          decode_error("malformed JSON string, neither array, object, number, string or atom") unless defined $ch; # Is there a first character for JSON structure?
  
          my $result = value();
  
          if ( !$props->[ P_ALLOW_NONREF ] and !ref $result ) {
                  decode_error(
                  'JSON text must be an object or array (but found number, string, true, false or null,'
                         . ' use allow_nonref to allow this)', 1);
          }
  
          Carp::croak('something wrong.') if $len < $at; # we won't arrive here.
  
          my $consumed = defined $ch ? $at - 1 : $at; # consumed JSON text length
  
          white(); # remove tail white space
  
          return ( $result, $consumed ) if $want_offset; # all right if decode_prefix
  
          decode_error("garbage after JSON object") if defined $ch;
  
          $result;
      }
  
  
      sub next_chr {
          return $ch = undef if($at >= $len);
          $ch = substr($text, $at++, 1);
      }
  
  
      sub value {
          white();
          return          if(!defined $ch);
          return object() if($ch eq '{');
          return array()  if($ch eq '[');
          return string() if($ch eq '"' or ($singlequote and $ch eq "'"));
          return number() if($ch =~ /[0-9]/ or $ch eq '-');
          return word();
      }
  
      sub string {
          my $utf16;
          my $is_utf8;
  
          ($is_valid_utf8, $utf8_len) = ('', 0);
  
          my $s = ''; # basically UTF8 flag on
  
          if($ch eq '"' or ($singlequote and $ch eq "'")){
              my $boundChar = $ch;
  
              OUTER: while( defined(next_chr()) ){
  
                  if($ch eq $boundChar){
                      next_chr();
  
                      if ($utf16) {
                          decode_error("missing low surrogate character in surrogate pair");
                      }
  
                      utf8::decode($s) if($is_utf8);
  
                      return $s;
                  }
                  elsif($ch eq '\\'){
                      next_chr();
                      if(exists $escapes{$ch}){
                          $s .= $escapes{$ch};
                      }
                      elsif($ch eq 'u'){ # UNICODE handling
                          my $u = '';
  
                          for(1..4){
                              $ch = next_chr();
                              last OUTER if($ch !~ /[0-9a-fA-F]/);
                              $u .= $ch;
                          }
  
                          # U+D800 - U+DBFF
                          if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/) { # UTF-16 high surrogate?
                              $utf16 = $u;
                          }
                          # U+DC00 - U+DFFF
                          elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/) { # UTF-16 low surrogate?
                              unless (defined $utf16) {
                                  decode_error("missing high surrogate character in surrogate pair");
                              }
                              $is_utf8 = 1;
                              $s .= JSON_PP_decode_surrogates($utf16, $u) || next;
                              $utf16 = undef;
                          }
                          else {
                              if (defined $utf16) {
                                  decode_error("surrogate pair expected");
                              }
  
                              if ( ( my $hex = hex( $u ) ) > 127 ) {
                                  $is_utf8 = 1;
                                  $s .= JSON_PP_decode_unicode($u) || next;
                              }
                              else {
                                  $s .= chr $hex;
                              }
                          }
  
                      }
                      else{
                          unless ($loose) {
                              $at -= 2;
                              decode_error('illegal backslash escape sequence in string');
                          }
                          $s .= $ch;
                      }
                  }
                  else{
  
                      if ( ord $ch  > 127 ) {
                          unless( $ch = is_valid_utf8($ch) ) {
                              $at -= 1;
                              decode_error("malformed UTF-8 character in JSON string");
                          }
                          else {
                              $at += $utf8_len - 1;
                          }
  
                          $is_utf8 = 1;
                      }
  
                      if (!$loose) {
                          if ($ch =~ /[\x00-\x1f\x22\x5c]/)  { # '/' ok
                              $at--;
                              decode_error('invalid character encountered while parsing JSON string');
                          }
                      }
  
                      $s .= $ch;
                  }
              }
          }
  
          decode_error("unexpected end of string while parsing JSON string");
      }
  
  
      sub white {
          while( defined $ch  ){
              if($ch eq '' or $ch =~ /\A[ \t\r\n]\z/){
                  next_chr();
              }
              elsif($relaxed and $ch eq '/'){
                  next_chr();
                  if(defined $ch and $ch eq '/'){
                      1 while(defined(next_chr()) and $ch ne "\n" and $ch ne "\r");
                  }
                  elsif(defined $ch and $ch eq '*'){
                      next_chr();
                      while(1){
                          if(defined $ch){
                              if($ch eq '*'){
                                  if(defined(next_chr()) and $ch eq '/'){
                                      next_chr();
                                      last;
                                  }
                              }
                              else{
                                  next_chr();
                              }
                          }
                          else{
                              decode_error("Unterminated comment");
                          }
                      }
                      next;
                  }
                  else{
                      $at--;
                      decode_error("malformed JSON string, neither array, object, number, string or atom");
                  }
              }
              else{
                  if ($relaxed and $ch eq '#') { # correctly?
                      pos($text) = $at;
                      $text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;
                      $at = pos($text);
                      next_chr;
                      next;
                  }
  
                  last;
              }
          }
      }
  
  
      sub array {
          my $a  = $_[0] || []; # you can use this code to use another array ref object.
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                      if (++$depth > $max_depth);
  
          next_chr();
          white();
  
          if(defined $ch and $ch eq ']'){
              --$depth;
              next_chr();
              return $a;
          }
          else {
              while(defined($ch)){
                  push @$a, value();
  
                  white();
  
                  if (!defined $ch) {
                      last;
                  }
  
                  if($ch eq ']'){
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq ']') {
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
              }
          }
  
          $at-- if defined $ch and $ch ne '';
          decode_error(", or ] expected while parsing array");
      }
  
  
      sub object {
          my $o = $_[0] || {}; # you can use this code to use another hash ref object.
          my $k;
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                  if (++$depth > $max_depth);
          next_chr();
          white();
  
          if(defined $ch and $ch eq '}'){
              --$depth;
              next_chr();
              if ($F_HOOK) {
                  return _json_object_hook($o);
              }
              return $o;
          }
          else {
              while (defined $ch) {
                  $k = ($allow_barekey and $ch ne '"' and $ch ne "'") ? bareKey() : string();
                  white();
  
                  if(!defined $ch or $ch ne ':'){
                      $at--;
                      decode_error("':' expected");
                  }
  
                  next_chr();
                  $o->{$k} = value();
                  white();
  
                  last if (!defined $ch);
  
                  if($ch eq '}'){
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq '}') {
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
              }
  
          }
  
          $at-- if defined $ch and $ch ne '';
          decode_error(", or } expected while parsing object/hash");
      }
  
  
      sub bareKey { # doesn't strictly follow Standard ECMA-262 3rd Edition
          my $key;
          while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){
              $key .= $ch;
              next_chr();
          }
          return $key;
      }
  
  
      sub word {
          my $word =  substr($text,$at-1,4);
  
          if($word eq 'true'){
              $at += 3;
              next_chr;
              return $JSON::PP::true;
          }
          elsif($word eq 'null'){
              $at += 3;
              next_chr;
              return undef;
          }
          elsif($word eq 'fals'){
              $at += 3;
              if(substr($text,$at,1) eq 'e'){
                  $at++;
                  next_chr;
                  return $JSON::PP::false;
              }
          }
  
          $at--; # for decode_error report
  
          decode_error("'null' expected")  if ($word =~ /^n/);
          decode_error("'true' expected")  if ($word =~ /^t/);
          decode_error("'false' expected") if ($word =~ /^f/);
          decode_error("malformed JSON string, neither array, object, number, string or atom");
      }
  
  
      sub number {
          my $n    = '';
          my $v;
          my $is_dec;
          my $is_exp;
  
          if($ch eq '-'){
              $n = '-';
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after initial minus)");
              }
          }
  
          # According to RFC4627, hex or oct digits are invalid.
          if($ch eq '0'){
              my $peek = substr($text,$at,1);
              if($peek =~ /^[0-9a-dfA-DF]/){ # e may be valid (exponential)
                  decode_error("malformed number (leading zero must not be followed by another digit)");
              }
              $n .= $ch;
              next_chr;
          }
  
          while(defined $ch and $ch =~ /\d/){
              $n .= $ch;
              next_chr;
          }
  
          if(defined $ch and $ch eq '.'){
              $n .= '.';
              $is_dec = 1;
  
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after decimal point)");
              }
              else {
                  $n .= $ch;
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
          }
  
          if(defined $ch and ($ch eq 'e' or $ch eq 'E')){
              $n .= $ch;
              $is_exp = 1;
              next_chr;
  
              if(defined($ch) and ($ch eq '+' or $ch eq '-')){
                  $n .= $ch;
                  next_chr;
                  if (!defined $ch or $ch =~ /\D/) {
                      decode_error("malformed number (no digits after exp sign)");
                  }
                  $n .= $ch;
              }
              elsif(defined($ch) and $ch =~ /\d/){
                  $n .= $ch;
              }
              else {
                  decode_error("malformed number (no digits after exp sign)");
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
  
          }
  
          $v .= $n;
  
          if ($is_dec or $is_exp) {
              if ($allow_bignum) {
                  require Math::BigFloat;
                  return Math::BigFloat->new($v);
              }
          } else {
              if (length $v > $max_intsize) {
                  if ($allow_bignum) { # from Adam Sussman
                      require Math::BigInt;
                      return Math::BigInt->new($v);
                  }
                  else {
                      return "$v";
                  }
              }
          }
  
          return $is_dec ? $v/1.0 : 0+$v;
      }
  
  
      sub is_valid_utf8 {
  
          $utf8_len = $_[0] =~ /[\x00-\x7F]/  ? 1
                    : $_[0] =~ /[\xC2-\xDF]/  ? 2
                    : $_[0] =~ /[\xE0-\xEF]/  ? 3
                    : $_[0] =~ /[\xF0-\xF4]/  ? 4
                    : 0
                    ;
  
          return unless $utf8_len;
  
          my $is_valid_utf8 = substr($text, $at - 1, $utf8_len);
  
          return ( $is_valid_utf8 =~ /^(?:
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
          )$/x )  ? $is_valid_utf8 : '';
      }
  
  
      sub decode_error {
          my $error  = shift;
          my $no_rep = shift;
          my $str    = defined $text ? substr($text, $at) : '';
          my $mess   = '';
          my $type   = 'U*';
  
          if ( OLD_PERL ) {
              my $type   =  $] <  5.006           ? 'C*'
                          : utf8::is_utf8( $str ) ? 'U*' # 5.6
                          : 'C*'
                          ;
          }
  
          for my $c ( unpack( $type, $str ) ) { # emulate pv_uni_display() ?
              $mess .=  $c == 0x07 ? '\a'
                      : $c == 0x09 ? '\t'
                      : $c == 0x0a ? '\n'
                      : $c == 0x0d ? '\r'
                      : $c == 0x0c ? '\f'
                      : $c <  0x20 ? sprintf('\x{%x}', $c)
                      : $c == 0x5c ? '\\\\'
                      : $c <  0x80 ? chr($c)
                      : sprintf('\x{%x}', $c)
                      ;
              if ( length $mess >= 20 ) {
                  $mess .= '...';
                  last;
              }
          }
  
          unless ( length $mess ) {
              $mess = '(end of string)';
          }
  
          Carp::croak (
              $no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")"
          );
  
      }
  
  
      sub _json_object_hook {
          my $o    = $_[0];
          my @ks = keys %{$o};
  
          if ( $cb_sk_object and @ks == 1 and exists $cb_sk_object->{ $ks[0] } and ref $cb_sk_object->{ $ks[0] } ) {
              my @val = $cb_sk_object->{ $ks[0] }->( $o->{$ks[0]} );
              if (@val == 1) {
                  return $val[0];
              }
          }
  
          my @val = $cb_object->($o) if ($cb_object);
          if (@val == 0 or @val > 1) {
              return $o;
          }
          else {
              return $val[0];
          }
      }
  
  
      sub PP_decode_box {
          {
              text    => $text,
              at      => $at,
              ch      => $ch,
              len     => $len,
              depth   => $depth,
              encoding      => $encoding,
              is_valid_utf8 => $is_valid_utf8,
          };
      }
  
  } # PARSE
  
  
  sub _decode_surrogates { # from perlunicode
      my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00);
      my $un  = pack('U*', $uni);
      utf8::encode( $un );
      return $un;
  }
  
  
  sub _decode_unicode {
      my $un = pack('U', hex shift);
      utf8::encode( $un );
      return $un;
  }
  
  #
  # Setup for various Perl versions (the code from JSON::PP58)
  #
  
  BEGIN {
  
      unless ( defined &utf8::is_utf8 ) {
         require Encode;
         *utf8::is_utf8 = *Encode::is_utf8;
      }
  
      if ( !OLD_PERL ) {
          *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
          *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
          *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
          *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
  
          if ($] < 5.008003) { # join() in 5.8.0 - 5.8.2 is broken.
              package JSON::PP;
              require subs;
              subs->import('join');
              eval q|
                  sub join {
                      return '' if (@_ < 2);
                      my $j   = shift;
                      my $str = shift;
                      for (@_) { $str .= $j . $_; }
                      return $str;
                  }
              |;
          }
      }
  
  
      sub JSON::PP::incr_parse {
          local $Carp::CarpLevel = 1;
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_parse( @_ );
      }
  
  
      sub JSON::PP::incr_skip {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_skip;
      }
  
  
      sub JSON::PP::incr_reset {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_reset;
      }
  
      eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_pos} ) {
                  Carp::croak("incr_text cannot be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ( $] >= 5.006 );
  
  } # Setup for various Perl versions (the code from JSON::PP58)
  
  
  ###############################
  # Utilities
  #
  
  BEGIN {
      eval 'require Scalar::Util';
      unless($@){
          *JSON::PP::blessed = \&Scalar::Util::blessed;
          *JSON::PP::reftype = \&Scalar::Util::reftype;
          *JSON::PP::refaddr = \&Scalar::Util::refaddr;
      }
      else{ # This code is from Scalar::Util.
          # warn $@;
          eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';
          *JSON::PP::blessed = sub {
              local($@, $SIG{__DIE__}, $SIG{__WARN__});
              ref($_[0]) ? eval { $_[0]->a_sub_not_likely_to_be_here } : undef;
          };
          require B;
          my %tmap = qw(
              B::NULL   SCALAR
              B::HV     HASH
              B::AV     ARRAY
              B::CV     CODE
              B::IO     IO
              B::GV     GLOB
              B::REGEXP REGEXP
          );
          *JSON::PP::reftype = sub {
              my $r = shift;
  
              return undef unless length(ref($r));
  
              my $t = ref(B::svref_2object($r));
  
              return
                  exists $tmap{$t} ? $tmap{$t}
                : length(ref($$r)) ? 'REF'
                :                    'SCALAR';
          };
          *JSON::PP::refaddr = sub {
            return undef unless length(ref($_[0]));
  
            my $addr;
            if(defined(my $pkg = blessed($_[0]))) {
              $addr .= bless $_[0], 'Scalar::Util::Fake';
              bless $_[0], $pkg;
            }
            else {
              $addr .= $_[0]
            }
  
            $addr =~ /0x(\w+)/;
            local $^W;
            #no warnings 'portable';
            hex($1);
          }
      }
  }
  
  
  # shamelessly copied and modified from JSON::XS code.
  
  $JSON::PP::true  = do { bless \(my $dummy = 1), "JSON::PP::Boolean" };
  $JSON::PP::false = do { bless \(my $dummy = 0), "JSON::PP::Boolean" };
  
  sub is_bool { blessed $_[0] and $_[0]->isa("JSON::PP::Boolean"); }
  
  sub true  { $JSON::PP::true  }
  sub false { $JSON::PP::false }
  sub null  { undef; }
  
  ###############################
  
  package JSON::PP::IncrParser;
  
  use strict;
  
  use constant INCR_M_WS   => 0; # initial whitespace skipping
  use constant INCR_M_STR  => 1; # inside string
  use constant INCR_M_BS   => 2; # inside backslash
  use constant INCR_M_JSON => 3; # outside anything, count nesting
  use constant INCR_M_C0   => 4;
  use constant INCR_M_C1   => 5;
  
  $JSON::PP::IncrParser::VERSION = '1.01';
  
  sub new {
      my ( $class ) = @_;
  
      bless {
          incr_nest    => 0,
          incr_text    => undef,
          incr_pos     => 0,
          incr_mode    => 0,
      }, $class;
  }
  
  
  sub incr_parse {
      my ( $self, $coder, $text ) = @_;
  
      $self->{incr_text} = '' unless ( defined $self->{incr_text} );
  
      if ( defined $text ) {
          if ( utf8::is_utf8( $text ) and !utf8::is_utf8( $self->{incr_text} ) ) {
              utf8::upgrade( $self->{incr_text} ) ;
              utf8::decode( $self->{incr_text} ) ;
          }
          $self->{incr_text} .= $text;
      }
  
      if ( defined wantarray ) {
          my $max_size = $coder->get_max_size;
          my $p = $self->{incr_pos};
          my @ret;
          {
              do {
                  unless ( $self->{incr_nest} <= 0 and $self->{incr_mode} == INCR_M_JSON ) {
                      $self->_incr_parse( $coder );
  
                      if ( $max_size and $self->{incr_pos} > $max_size ) {
                          Carp::croak("attempted decode of JSON text of $self->{incr_pos} bytes size, but max_size is set to $max_size");
                      }
                      unless ( $self->{incr_nest} <= 0 and $self->{incr_mode} == INCR_M_JSON ) {
                          # as an optimisation, do not accumulate white space in the incr buffer
                          if ( $self->{incr_mode} == INCR_M_WS and $self->{incr_pos} ) {
                              $self->{incr_pos} = 0;
                              $self->{incr_text} = '';
                          }
                          last;
                      }
                  }
  
                  my ($obj, $offset) = $coder->PP_decode_json( $self->{incr_text}, 0x00000001 );
                  push @ret, $obj;
                  use bytes;
                  $self->{incr_text} = substr( $self->{incr_text}, $offset || 0 );
                  $self->{incr_pos} = 0;
                  $self->{incr_nest} = 0;
                  $self->{incr_mode} = 0;
                  last unless wantarray;
              } while ( wantarray );
          }
  
          if ( wantarray ) {
              return @ret;
          }
          else { # in scalar context
              return $ret[0] ? $ret[0] : undef;
          }
      }
  }
  
  
  sub _incr_parse {
      my ($self, $coder) = @_;
      my $text = $self->{incr_text};
      my $len = length $text;
      my $p = $self->{incr_pos};
  
  INCR_PARSE:
      while ( $len > $p ) {
          my $s = substr( $text, $p, 1 );
          last INCR_PARSE unless defined $s;
          my $mode = $self->{incr_mode};
  
          if ( $mode == INCR_M_WS ) {
              while ( $len > $p ) {
                  $s = substr( $text, $p, 1 );
                  last INCR_PARSE unless defined $s;
                  if ( ord($s) > 0x20 ) {
                      if ( $s eq '#' ) {
                          $self->{incr_mode} = INCR_M_C0;
                          redo INCR_PARSE;
                      } else {
                          $self->{incr_mode} = INCR_M_JSON;
                          redo INCR_PARSE;
                      }
                  }
                  $p++;
              }
          } elsif ( $mode == INCR_M_BS ) {
              $p++;
              $self->{incr_mode} = INCR_M_STR;
              redo INCR_PARSE;
          } elsif ( $mode == INCR_M_C0 or $mode == INCR_M_C1 ) {
              while ( $len > $p ) {
                  $s = substr( $text, $p, 1 );
                  last INCR_PARSE unless defined $s;
                  if ( $s eq "\n" ) {
                      $self->{incr_mode} = $self->{incr_mode} == INCR_M_C0 ? INCR_M_WS : INCR_M_JSON;
                      last;
                  }
                  $p++;
              }
              next;
          } elsif ( $mode == INCR_M_STR ) {
              while ( $len > $p ) {
                  $s = substr( $text, $p, 1 );
                  last INCR_PARSE unless defined $s;
                  if ( $s eq '"' ) {
                      $p++;
                      $self->{incr_mode} = INCR_M_JSON;
  
                      last INCR_PARSE unless $self->{incr_nest};
                      redo INCR_PARSE;
                  }
                  elsif ( $s eq '\\' ) {
                      $p++;
                      if ( !defined substr($text, $p, 1) ) {
                          $self->{incr_mode} = INCR_M_BS;
                          last INCR_PARSE;
                      }
                  }
                  $p++;
              }
          } elsif ( $mode == INCR_M_JSON ) {
              while ( $len > $p ) {
                  $s = substr( $text, $p++, 1 );
                  if ( $s eq "\x00" ) {
                      $p--;
                      last INCR_PARSE;
                  } elsif ( $s eq "\x09" or $s eq "\x0a" or $s eq "\x0d" or $s eq "\x20" ) {
                      if ( !$self->{incr_nest} ) {
                          $p--; # do not eat the whitespace, let the next round do it
                          last INCR_PARSE;
                      }
                      next;
                  } elsif ( $s eq '"' ) {
                      $self->{incr_mode} = INCR_M_STR;
                      redo INCR_PARSE;
                  } elsif ( $s eq '[' or $s eq '{' ) {
                      if ( ++$self->{incr_nest} > $coder->get_max_depth ) {
                          Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)');
                      }
                      next;
                  } elsif ( $s eq ']' or $s eq '}' ) {
                      if ( --$self->{incr_nest} <= 0 ) {
                          last INCR_PARSE;
                      }
                  } elsif ( $s eq '#' ) {
                      $self->{incr_mode} = INCR_M_C1;
                      redo INCR_PARSE;
                  }
              }
          }
      }
  
      $self->{incr_pos} = $p;
      $self->{incr_parsing} = $p ? 1 : 0; # for backward compatibility
  }
  
  
  sub incr_text {
      if ( $_[0]->{incr_pos} ) {
          Carp::croak("incr_text cannot be called when the incremental parser already started parsing");
      }
      $_[0]->{incr_text};
  }
  
  
  sub incr_skip {
      my $self  = shift;
      $self->{incr_text} = substr( $self->{incr_text}, $self->{incr_pos} );
      $self->{incr_pos}     = 0;
      $self->{incr_mode}    = 0;
      $self->{incr_nest}    = 0;
  }
  
  
  sub incr_reset {
      my $self = shift;
      $self->{incr_text}    = undef;
      $self->{incr_pos}     = 0;
      $self->{incr_mode}    = 0;
      $self->{incr_nest}    = 0;
  }
  
  ###############################
  
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  JSON::PP - JSON::XS compatible pure-Perl module.
  
  =head1 SYNOPSIS
  
   use JSON::PP;
  
   # exported functions, they croak on error
   # and expect/generate UTF-8
  
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
  
   # OO-interface
  
   $json = JSON::PP->new->ascii->pretty->allow_nonref;
   
   $pretty_printed_json_text = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   # Note that JSON version 2.0 and above will automatically use
   # JSON::XS or JSON::PP, so you should be able to just:
   
   use JSON;
  
  
  =head1 VERSION
  
      2.97001
  
  =head1 DESCRIPTION
  
  JSON::PP is a pure perl JSON decoder/encoder (as of RFC4627, which
  we know is obsolete but we still stick to; see below for an option
  to support part of RFC7159), and (almost) compatible to much
  faster L<JSON::XS> written by Marc Lehmann in C. JSON::PP works as
  a fallback module when you use L<JSON> module without having
  installed JSON::XS.
  
  Because of this fallback feature of JSON.pm, JSON::PP tries not to
  be more JavaScript-friendly than JSON::XS (i.e. not to escape extra
  characters such as U+2028 and U+2029 nor support RFC7159/ECMA-404),
  in order for you not to lose such JavaScript-friendliness silently
  when you use JSON.pm and install JSON::XS for speed or by accident.
  If you need JavaScript-friendly RFC7159-compliant pure perl module,
  try L<JSON::Tiny>, which is derived from L<Mojolicious> web
  framework and is also smaller and faster than JSON::PP.
  
  JSON::PP has been in the Perl core since Perl 5.14, mainly for
  CPAN toolchain modules to parse META.json.
  
  =head1 FUNCTIONAL INTERFACE
  
  This section is taken from JSON::XS almost verbatim. C<encode_json>
  and C<decode_json> are exported by default.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string
  (that is, the string contains octets only). Croaks on error.
  
  This function call is functionally identical to:
  
      $json_text = JSON::PP->new->utf8->encode($perl_scalar)
  
  Except being faster.
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference. Croaks on error.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON::PP->new->utf8->decode($json_text)
  
  Except being faster.
  
  =head2 JSON::PP::is_bool
  
      $is_boolean = JSON::PP::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::PP::true or
  JSON::PP::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  =head1 OBJECT-ORIENTED INTERFACE
  
  This section is also taken from JSON::XS.
  
  The object oriented interface lets you configure your own encoding or
  decoding style, within the limits of supported formats.
  
  =head2 new
  
      $json = JSON::PP->new
  
  Creates a new JSON::PP object that can be used to de/encode JSON
  strings. All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the JSON::PP object again and thus calls can
  be chained:
  
     my $json = JSON::PP->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  generate characters outside the code range C<0..127> (which is ASCII). Any
  Unicode characters outside that range will be escaped using either a
  single \uXXXX (BMP characters) or a double \uHHHH\uLLLLL escape sequence,
  as per RFC4627. The resulting encoded JSON text can be treated as a native
  Unicode string, an ascii-encoded, latin1-encoded or UTF-8 encoded string,
  or any other superset of ASCII.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags. This results
  in a faster and more compact format.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  The main use for this flag is to produce JSON texts that can be
  transmitted over a 7-bit channel, as the encoded JSON texts will not
  contain any 8 bit characters.
  
    JSON::PP->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the resulting JSON text as latin1 (or iso-8859-1), escaping any characters
  outside the code range C<0..255>. The resulting string can be treated as a
  latin1-encoded JSON text or a native Unicode string. The C<decode> method
  will not be affected in any way by this flag, as C<decode> by default
  expects Unicode, which is a strict superset of latin1.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  The main use for this flag is efficiently encoding binary data as JSON
  text, as most octets will not be escaped, resulting in a smaller encoded
  size. The disadvantage is that the resulting JSON text is encoded
  in latin1 (and must correctly be treated as such when storing and
  transferring), a rare encoding for JSON. It is therefore most useful when
  you want to store data structures known to contain binary data efficiently
  in files or databases, not when talking to other JSON encoders/decoders.
  
    JSON::PP->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the JSON result into UTF-8, as required by many protocols, while the
  C<decode> method expects to be handled an UTF-8-encoded string.  Please
  note that UTF-8-encoded strings do not contain any characters outside the
  range C<0..255>, they are thus useful for bytewise/binary I/O. In future
  versions, enabling this option might enable autodetection of the UTF-16
  and UTF-32 encoding families, as described in RFC4627.
  
  If C<$enable> is false, then the C<encode> method will return the JSON
  string as a (non-encoded) Unicode string, while C<decode> expects thus a
  Unicode string.  Any decoding or encoding (e.g. to UTF-8 or UTF-16) needs
  to be done yourself, e.g. using the Encode module.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON::PP->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON::PP->new->decode (decode "UTF-32LE", $jsontext);
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> (and in the future possibly more) flags in one call to
  generate the most readable (or most compact) form possible.
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  If C<$enable> is true (or missing), then the C<encode> method will use a multiline
  format as output, putting every array member or object/hash key-value pair
  into its own line, indenting them properly.
  
  If C<$enable> is false, no newlines or indenting will be produced, and the
  resulting JSON text is guaranteed not to contain any C<newlines>.
  
  This setting has no effect when decoding JSON texts.
  
  The default indent space length is three.
  You can use C<indent_length> to change the length.
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts. You will also
  most likely combine this setting with C<space_after>.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =item * C-style multiple-line '/* */'-comments (JSON::PP only)
  
  Whenever JSON allows whitespace, C-style multiple-line comments are additionally
  allowed. Everything between C</*> and C<*/> is a comment, after which
  more white-space and comments are allowed.
  
    [
       1, /* this comment not allowed in JSON */
          /* neither this one... */
    ]
  
  =item * C++-style one-line '//'-comments (JSON::PP only)
  
  Whenever JSON allows whitespace, C++-style one-line comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, // this comment not allowed in JSON
          // neither this one...
    ]
  
  =back
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script, and can change even within the same run from 5.18
  onwards).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  This setting has currently no effect on tied hashes.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
  Example, encode a Perl scalar as JSON value with enabled C<allow_nonref>,
  resulting in an invalid JSON text:
  
     JSON::PP->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown ([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If C<$enable> is true (or missing), then C<encode> will I<not> throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON C<null> value. Note
  that blessed objects are not included here and are handled separately by
  c<allow_blessed>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect C<decode> in any way, and it is recommended to
  leave it off unless you know your communications partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference that it cannot convert
  otherwise. Instead, a JSON C<null> value is encoded instead of the object.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object that it cannot convert
  otherwise.
  
  This setting has no effect on C<decode>.
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context and
  the resulting scalar will be encoded instead of the object.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with any C<to_json>
  function or method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion.
  
  This setting has no effect on C<decode>.
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument is a reference to the
  newly-created hash. If the code references returns a single scalar (which
  need not be a reference), this value (i.e. a copy of that scalar to avoid
  aliasing) is inserted into the deserialised data structure. If it returns
  an empty list (NOTE: I<not> C<undef>, which is a valid scalar), the
  original deserialised hash will be inserted. This setting can slow down
  decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON::PP->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]'); # the given subroutine takes a hash reference.
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON::PP
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =head2 shrink
  
      $json = $json->shrink([$enable])
      
      $enabled = $json->get_shrink
  
  If C<$enable> is true (or missing), the string returned by C<encode> will
  be shrunk (i.e. downgraded if possible).
  
  The actual definition of what shrink does might change in future versions,
  but it will always try to save space at the expense of time.
  
  If C<$enable> is false, then JSON::PP does nothing.
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  Setting the maximum depth to one disallows any nesting, so that ensures
  that the object is only a single hash/object or array.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl value or data structure to its JSON
  representation. Croaks on error.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
  This is useful if your JSON texts are not delimited by an outer protocol
  and you need to know where the JSON text ends.
  
     JSON::PP->new->decode_prefix ("[1] the tail")
     => ([1], 3)
  
  =head1 FLAGS FOR JSON::PP ONLY
  
  The following flags and properties are for JSON::PP only. If you use
  any of these, you can't make your application run faster by replacing
  JSON::PP with JSON::XS. If you need these and also speed boost,
  try L<Cpanel::JSON::XS>, a fork of JSON::XS by Reini Urban, which
  supports some of these.
  
  =head2 allow_singlequote
  
      $json = $json->allow_singlequote([$enable])
      $enabled = $json->get_allow_singlequote
  
  If C<$enable> is true (or missing), then C<decode> will accept
  invalid JSON texts that contain strings that begin and end with
  single quotation marks. C<encode> will not be affected in anyway.
  I<Be aware that this option makes you accept invalid JSON texts
  as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration
  files, resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
      $json->allow_singlequote->decode(qq|{"foo":'bar'}|);
      $json->allow_singlequote->decode(qq|{'foo':"bar"}|);
      $json->allow_singlequote->decode(qq|{'foo':'bar'}|);
  
  =head2 allow_barekey
  
      $json = $json->allow_barekey([$enable])
      $enabled = $json->get_allow_barekey
  
  If C<$enable> is true (or missing), then C<decode> will accept
  invalid JSON texts that contain JSON objects whose names don't
  begin and end with quotation marks. C<encode> will not be affected
  in anyway. I<Be aware that this option makes you accept invalid JSON
  texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration
  files, resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
      $json->allow_barekey->decode(qq|{foo:"bar"}|);
  
  =head2 allow_bignum
  
      $json = $json->allow_bignum([$enable])
      $enabled = $json->get_allow_bignum
  
  If C<$enable> is true (or missing), then C<decode> will convert
  big integers Perl cannot handle as integer into L<Math::BigInt>
  objects and convert floating numbers into L<Math::BigFloat>
  objects. C<encode> will convert C<Math::BigInt> and C<Math::BigFloat>
  objects into JSON numbers.
  
     $json->allow_nonref->allow_bignum;
     $bigfloat = $json->decode('2.000000000000000000000000001');
     print $json->encode($bigfloat);
     # => 2.000000000000000000000000001
  
  See also L<MAPPING>.
  
  =head2 loose
  
      $json = $json->loose([$enable])
      $enabled = $json->get_loose
  
  If C<$enable> is true (or missing), then C<decode> will accept
  invalid JSON texts that contain unescaped [\x00-\x1f\x22\x5c]
  characters. C<encode> will not be affected in anyway.
  I<Be aware that this option makes you accept invalid JSON texts
  as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration
  files, resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
      $json->loose->decode(qq|["abc
                                     def"]|);
  
  =head2 escape_slash
  
      $json = $json->escape_slash([$enable])
      $enabled = $json->get_escape_slash
  
  If C<$enable> is true (or missing), then C<encode> will explicitly
  escape I<slash> (solidus; C<U+002F>) characters to reduce the risk of
  XSS (cross site scripting) that may be caused by C<< </script> >>
  in a JSON text, with the cost of bloating the size of JSON texts.
  
  This option may be useful when you embed JSON in HTML, but embedding
  arbitrary JSON in HTML (by some HTML template toolkit or by string
  interpolation) is risky in general. You must escape necessary
  characters in correct order, depending on the context.
  
  C<decode> will not be affected in anyway.
  
  =head2 indent_length
  
      $json = $json->indent_length($number_of_spaces)
      $length = $json->get_indent_length
  
  This option is only useful when you also enable C<indent> or C<pretty>.
  
  JSON::XS indents with three spaces when you C<encode> (if requested
  by C<indent> or C<pretty>), and the number cannot be changed.
  JSON::PP allows you to change/get the number of indent spaces with these
  mutator/accessor. The default number of spaces is three (the same as
  JSON::XS), and the acceptable range is from C<0> (no indentation;
  it'd be better to disable indentation by C<indent(0)>) to C<15>.
  
  =head2 sort_by
  
      $json = $json->sort_by($code_ref)
      $json = $json->sort_by($subroutine_name)
  
  If you just want to sort keys (names) in JSON objects when you
  C<encode>, enable C<canonical> option (see above) that allows you to
  sort object keys alphabetically.
  
  If you do need to sort non-alphabetically for whatever reasons,
  you can give a code reference (or a subroutine name) to C<sort_by>,
  then the argument will be passed to Perl's C<sort> built-in function.
  
  As the sorting is done in the JSON::PP scope, you usually need to
  prepend C<JSON::PP::> to the subroutine name, and the special variables
  C<$a> and C<$b> used in the subrontine used by C<sort> function.
  
  Example:
  
     my %ORDER = (id => 1, class => 2, name => 3);
     $json->sort_by(sub {
         ($ORDER{$JSON::PP::a} // 999) <=> ($ORDER{$JSON::PP::b} // 999)
         or $JSON::PP::a cmp $JSON::PP::b
     });
     print $json->encode([
         {name => 'CPAN', id => 1, href => 'http://cpan.org'}
     ]);
     # [{"id":1,"name":"CPAN","href":"http://cpan.org"}]
  
  Note that C<sort_by> affects all the plain hashes in the data structure.
  If you need finer control, C<tie> necessary hashes with a module that
  implements ordered hash (such as L<Hash::Ordered> and L<Tie::IxHash>).
  C<canonical> and C<sort_by> don't affect the key order in C<tie>d
  hashes.
  
     use Hash::Ordered;
     tie my %hash, 'Hash::Ordered',
         (name => 'CPAN', id => 1, href => 'http://cpan.org');
     print $json->encode([\%hash]);
     # [{"name":"CPAN","id":1,"href":"http://cpan.org"}] # order is kept
  
  =head1 INCREMENTAL PARSING
  
  This section is also taken from JSON::XS.
  
  In some cases, there is the need for incremental parsing of JSON
  texts. While this module always has to keep both JSON text and resulting
  Perl data structure in memory at one time, it does allow you to parse a
  JSON stream incrementally. It does so by accumulating text until it has
  a full JSON object, which it then can decode. This process is similar to
  using C<decode_prefix> to see if a full JSON object is available, but
  is much more efficient (and can be implemented with a minimum of method
  calls).
  
  JSON::PP will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect mismatched
  parentheses. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators (other than
  whitespace) between the JSON objects or arrays, instead they must be
  concatenated back-to-back. If an error occurs, an exception will be
  raised as in the scalar context case. Note that in this case, any
  previously-parsed JSON texts will be lost.
  
  Example: Parse some JSON arrays/objects in a given string and return
  them.
  
      my @objs = JSON::PP->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  That means you can only use this function to look at or manipulate text
  before or after complete JSON objects, not while the parser is in the
  middle of parsing a JSON object.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove
  the parsed text from the input buffer so far. This is useful after
  C<incr_parse> died, in which case the input buffer and incremental parser
  state is left unchanged, to skip the text parsed so far and to reset the
  parse state.
  
  The difference to C<incr_reset> is that only text until the parse error
  occurred is removed.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  =head1 MAPPING
  
  Most of this section is also taken from JSON::XS.
  
  This section describes how JSON::PP maps Perl values to JSON values and
  vice versa. These mappings are designed to "do the right thing" in most
  circumstances automatically, preserving round-tripping characteristics
  (what you put in comes out as something equivalent).
  
  For the more enlightened: note that in the following descriptions,
  lowercase I<perl> refers to the Perl interpreter, while uppercase I<Perl>
  refers to the abstract Perl language itself.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserve object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, JSON::PP will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, JSON::PP only guarantees precision up to but not including
  the least significant bit.
  
  When C<allow_bignum> is enabled, big integer values and any numeric
  values will be converted into L<Math::BigInt> and L<Math::BigFloat>
  objects respectively, without becoming string scalars or losing
  precision.
  
  =item true, false
  
  These JSON atoms become C<JSON::PP::true> and C<JSON::PP::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check whether a scalar is a JSON boolean by using
  the C<JSON::PP::is_bool> function.
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  =item shell-style comments (C<< # I<text> >>)
  
  As a nonstandard extension to the JSON syntax that is enabled by the
  C<relaxed> setting, shell-style comments are allowed. They can start
  anywhere outside strings and go till the end of the line.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent
  ordering in hash keys (or JSON objects), they will usually be encoded
  in a pseudo-random order. JSON::PP can optionally sort the hash keys
  (determined by the I<canonical> flag and/or I<sort_by> property), so
  the same data structure will serialise to the same JSON text (given
  same settings and version of JSON::PP), but this incurs a runtime
  overhead and is only rarely useful, e.g. when you want to compare some
  JSON text against another for equality.
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::PP::false> and C<JSON::PP::true> to improve
  readability.
  
     to_json [\0, JSON::PP::true]      # yields [false,true]
  
  =item JSON::PP::true, JSON::PP::false
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  =item JSON::PP::null
  
  This special value becomes JSON null.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON, but C<JSON::PP>
  allows various ways of handling objects. See L<OBJECT SERIALISATION>,
  below, for details.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: JSON::PP will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
                  # (but for older perls)
  
  You can force the type to be a number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  You cannot currently force the type in other, less obscure, ways.
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  JSON::PP (and JSON::XS) trusts what you pass to C<encode> method
  (or C<encode_json> function) is a clean, validated data structure with
  values that can be represented as valid JSON values only, because it's
  not from an external data source (as opposed to JSON texts you pass to
  C<decode> or C<decode_json>, which JSON::PP considers tainted and
  doesn't trust). As JSON::PP doesn't know exactly what you and consumers
  of your JSON texts want the unexpected values to be (you may want to
  convert them into null, or to stringify them with or without
  normalisation (string representation of infinities/NaN may vary
  depending on platforms), or to croak without conversion), you're advised
  to do what you and your consumers need before you encode, and also not
  to numify values that may start with values that look like a number
  (including infinities/NaN), without validating.
  
  =back
  
  =head2 OBJECT SERIALISATION
  
  As for Perl objects, JSON::PP only supports a pure JSON representation (without the ability to deserialise the object automatically again).
  
  =head3 SERIALISATION
  
  What happens when C<JSON::PP> encounters a Perl object depends on the
  C<allow_blessed>, C<convert_blessed> and C<allow_bignum> settings, which are
  used in this order:
  
  =over 4
  
  =item 1. C<convert_blessed> is enabled and the object has a C<TO_JSON> method.
  
  In this case, the C<TO_JSON> method of the object is invoked in scalar
  context. It must return a single scalar that can be directly encoded into
  JSON. This scalar replaces the object in the JSON text.
  
  For example, the following C<TO_JSON> method will convert all L<URI>
  objects to JSON strings when serialised. The fact that these values
  originally were L<URI> objects is lost.
  
     sub URI::TO_JSON {
        my ($uri) = @_;
        $uri->as_string
     }
  
  =item 2. C<allow_bignum> is enabled and the object is a C<Math::BigInt> or C<Math::BigFloat>.
  
  The object will be serialised as a JSON number value.
  
  =item 3. C<allow_blessed> is enabled.
  
  The object will be serialised as a JSON null value.
  
  =item 4. none of the above
  
  If none of the settings are enabled or the respective methods are missing,
  C<JSON::PP> throws an exception.
  
  =back
  
  =head1 ENCODING/CODESET FLAG NOTES
  
  This section is taken from JSON::XS.
  
  The interested reader might have seen a number of flags that signify
  encodings or codesets - C<utf8>, C<latin1> and C<ascii>. There seems to be
  some confusion on what these do, so here is a short comparison:
  
  C<utf8> controls whether the JSON text created by C<encode> (and expected
  by C<decode>) is UTF-8 encoded or not, while C<latin1> and C<ascii> only
  control whether C<encode> escapes character values outside their respective
  codeset range. Neither of these flags conflict with each other, although
  some combinations make less sense than others.
  
  Care has been taken to make all flags symmetrical with respect to
  C<encode> and C<decode>, that is, texts encoded with any combination of
  these flag values will be correctly decoded when the same flags are used
  - in general, if you use different flag settings while encoding vs. when
  decoding you likely have a bug somewhere.
  
  Below comes a verbose discussion of these flags. Note that a "codeset" is
  simply an abstract set of character-codepoint pairs, while an encoding
  takes those codepoint numbers and I<encodes> them, in our case into
  octets. Unicode is (among other things) a codeset, UTF-8 is an encoding,
  and ISO-8859-1 (= latin 1) and ASCII are both codesets I<and> encodings at
  the same time, which can be confusing.
  
  =over 4
  
  =item C<utf8> flag disabled
  
  When C<utf8> is disabled (the default), then C<encode>/C<decode> generate
  and expect Unicode strings, that is, characters with high ordinal Unicode
  values (> 255) will be encoded as such characters, and likewise such
  characters are decoded as-is, no changes to them will be done, except
  "(re-)interpreting" them as Unicode codepoints or Unicode characters,
  respectively (to Perl, these are the same thing in strings unless you do
  funny/weird/dumb stuff).
  
  This is useful when you want to do the encoding yourself (e.g. when you
  want to have UTF-16 encoded JSON texts) or when some other layer does
  the encoding for you (for example, when printing to a terminal using a
  filehandle that transparently encodes to UTF-8 you certainly do NOT want
  to UTF-8 encode your data first and have Perl encode it another time).
  
  =item C<utf8> flag enabled
  
  If the C<utf8>-flag is enabled, C<encode>/C<decode> will encode all
  characters using the corresponding UTF-8 multi-byte sequence, and will
  expect your input strings to be encoded as UTF-8, that is, no "character"
  of the input string must have any value > 255, as UTF-8 does not allow
  that.
  
  The C<utf8> flag therefore switches between two modes: disabled means you
  will get a Unicode string in Perl, enabled means you get an UTF-8 encoded
  octet/binary string in Perl.
  
  =item C<latin1> or C<ascii> flags enabled
  
  With C<latin1> (or C<ascii>) enabled, C<encode> will escape characters
  with ordinal values > 255 (> 127 with C<ascii>) and encode the remaining
  characters as specified by the C<utf8> flag.
  
  If C<utf8> is disabled, then the result is also correctly encoded in those
  character sets (as both are proper subsets of Unicode, meaning that a
  Unicode string with all character values < 256 is the same thing as a
  ISO-8859-1 string, and a Unicode string with all character values < 128 is
  the same thing as an ASCII string in Perl).
  
  If C<utf8> is enabled, you still get a correct UTF-8-encoded string,
  regardless of these flags, just some more characters will be escaped using
  C<\uXXXX> then before.
  
  Note that ISO-8859-1-I<encoded> strings are not compatible with UTF-8
  encoding, while ASCII-encoded strings are. That is because the ISO-8859-1
  encoding is NOT a subset of UTF-8 (despite the ISO-8859-1 I<codeset> being
  a subset of Unicode), while ASCII is.
  
  Surprisingly, C<decode> will ignore these flags and so treat all input
  values as governed by the C<utf8> flag. If it is disabled, this allows you
  to decode ISO-8859-1- and ASCII-encoded strings, as both strict subsets of
  Unicode. If it is enabled, you can correctly decode UTF-8 encoded strings.
  
  So neither C<latin1> nor C<ascii> are incompatible with the C<utf8> flag -
  they only govern when the JSON output engine escapes a character or not.
  
  The main use for C<latin1> is to relatively efficiently store binary data
  as JSON, at the expense of breaking compatibility with most JSON decoders.
  
  The main use for C<ascii> is to force the output to not contain characters
  with values > 127, which means you can interpret the resulting string
  as UTF-8, ISO-8859-1, ASCII, KOI8-R or most about any character set and
  8-bit-encoding, and still get the same data structure back. This is useful
  when your channel for JSON transfer is not 8-bit clean or the encoding
  might be mangled in between (e.g. in mail), and works because ASCII is a
  proper subset of most 8-bit and multibyte encodings in use in the world.
  
  =back
  
  =head1 SEE ALSO
  
  The F<json_pp> command line utility for quick experiments.
  
  L<JSON::XS>, L<Cpanel::JSON::XS>, and L<JSON::Tiny> for faster alternatives.
  L<JSON> and L<JSON::MaybeXS> for easy migration.
  
  L<JSON::PP::Compat5005> and L<JSON::PP::Compat5006> for older perl users.
  
  RFC4627 (L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2016 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
JSON_PP

$fatpacked{"JSON/PP/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP_BOOLEAN';
  package JSON::PP::Boolean;
  
  use strict;
  use overload (
      "0+"     => sub { ${$_[0]} },
      "++"     => sub { $_[0] = ${$_[0]} + 1 },
      "--"     => sub { $_[0] = ${$_[0]} - 1 },
      fallback => 1,
  );
  
  $JSON::PP::Boolean::VERSION = '2.97001';
  
  1;
  
  __END__
  
  =head1 NAME
  
  JSON::PP::Boolean - dummy module providing JSON::PP::Boolean
  
  =head1 SYNOPSIS
  
   # do not "use" yourself
  
  =head1 DESCRIPTION
  
  This module exists only to provide overload resolution for Storable and similar modules. See
  L<JSON::PP> for more info about this class.
  
  =head1 AUTHOR
  
  This idea is from L<JSON::XS::Boolean> written by Marc Lehmann <schmorp[at]schmorp.de>
  
  =cut
  
JSON_PP_BOOLEAN

$fatpacked{"Mojo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO';
  package Mojo;
  use Mojo::Base -strict;
  
  # "Professor: These old Doomsday devices are dangerously unstable. I'll rest
  #             easier not knowing where they are."
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo - Web development toolkit
  
  =head1 SYNOPSIS
  
    # HTTP/WebSocket user agent
    use Mojo::UserAgent;
    my $ua = Mojo::UserAgent->new;
    say $ua->get('www.mojolicious.org')->result->headers->server;
  
    # HTML/XML DOM parser with CSS selectors
    use Mojo::DOM;
    my $dom = Mojo::DOM->new('<div><b>Hello Mojo!</b></div>');
    say $dom->at('div > b')->text;
  
    # Perl-ish templates
    use Mojo::Template;
    my $mt = Mojo::Template->new(vars => 1);
    say $mt->render('Hello <%= $what %>!', {what => 'Mojo'});
  
    # HTTP/WebSocket server
    use Mojo::Server::Daemon;
    my $daemon = Mojo::Server::Daemon->new(listen => ['http://*:8080']);
    $daemon->unsubscribe('request')->on(request => sub {
      my ($daemon, $tx) = @_;
      $tx->res->code(200);
      $tx->res->body('Hello Mojo!');
      $tx->resume;
    });
    $daemon->run;
  
    # Event loop
    use Mojo::IOLoop;
    for my $seconds (1 .. 5) {
      Mojo::IOLoop->timer($seconds => sub { say $seconds });
    }
    Mojo::IOLoop->start;
  
  =head1 DESCRIPTION
  
  A powerful web development toolkit, with all the basic tools and helpers needed
  to write simple web applications and higher level web frameworks, such as
  L<Mojolicious>. Some of the most commonly used tools are L<Mojo::UserAgent>,
  L<Mojo::DOM>, L<Mojo::JSON>, L<Mojo::Server::Daemon>, L<Mojo::Server::Prefork>,
  L<Mojo::IOLoop> and L<Mojo::Template>.
  
  See L<Mojolicious::Guides> for more!
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO

$fatpacked{"Mojo/Asset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_ASSET';
  package Mojo::Asset;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  
  has 'end_range';
  has start_range => 0;
  
  sub add_chunk { croak 'Method "add_chunk" not implemented by subclass' }
  sub contains  { croak 'Method "contains" not implemented by subclass' }
  sub get_chunk { croak 'Method "get_chunk" not implemented by subclass' }
  
  sub is_file {undef}
  
  sub is_range { !!($_[0]->end_range || $_[0]->start_range) }
  
  sub move_to { croak 'Method "move_to" not implemented by subclass' }
  sub mtime   { croak 'Method "mtime" not implemented by subclass' }
  sub size    { croak 'Method "size" not implemented by subclass' }
  sub slurp   { croak 'Method "slurp" not implemented by subclass' }
  sub to_file { croak 'Method "to_file" not implemented by subclass' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Asset - HTTP content storage base class
  
  =head1 SYNOPSIS
  
    package Mojo::Asset::MyAsset;
    use Mojo::Base 'Mojo::Asset';
  
    sub add_chunk {...}
    sub contains  {...}
    sub get_chunk {...}
    sub move_to   {...}
    sub mtime     {...}
    sub size      {...}
    sub slurp     {...}
    sub to_file   {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Asset> is an abstract base class for HTTP content storage backends,
  like L<Mojo::Asset::File> and L<Mojo::Asset::Memory>.
  
  =head1 EVENTS
  
  L<Mojo::Asset> inherits all events from L<Mojo::EventEmitter>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Asset> implements the following attributes.
  
  =head2 end_range
  
    my $end = $asset->end_range;
    $asset  = $asset->end_range(8);
  
  Pretend file ends earlier.
  
  =head2 start_range
  
    my $start = $asset->start_range;
    $asset    = $asset->start_range(3);
  
  Pretend file starts later.
  
  =head1 METHODS
  
  L<Mojo::Asset> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 add_chunk
  
    $asset = $asset->add_chunk('foo bar baz');
  
  Add chunk of data to asset. Meant to be overloaded in a subclass.
  
  =head2 contains
  
    my $position = $asset->contains('bar');
  
  Check if asset contains a specific string. Meant to be overloaded in a
  subclass.
  
  =head2 get_chunk
  
    my $bytes = $asset->get_chunk($offset);
    my $bytes = $asset->get_chunk($offset, $max);
  
  Get chunk of data starting from a specific position, defaults to a maximum
  chunk size of C<131072> bytes (128KiB). Meant to be overloaded in a subclass.
  
  =head2 is_file
  
    my $bool = $asset->is_file;
  
  False, this is not a L<Mojo::Asset::File> object.
  
  =head2 is_range
  
    my $bool = $asset->is_range;
  
  Check if asset has a L</"start_range"> or L</"end_range">.
  
  =head2 move_to
  
    $asset = $asset->move_to('/home/sri/foo.txt');
  
  Move asset data into a specific file. Meant to be overloaded in a subclass.
  
  =head2 mtime
  
    my $mtime = $asset->mtime;
  
  Modification time of asset. Meant to be overloaded in a subclass.
  
  =head2 size
  
    my $size = $asset->size;
  
  Size of asset data in bytes. Meant to be overloaded in a subclass.
  
  =head2 slurp
  
    my $bytes = $asset->slurp;
  
  Read all asset data at once. Meant to be overloaded in a subclass.
  
  =head2 to_file
  
    my $file = $asset->to_file;
  
  Convert asset to L<Mojo::Asset::File> object. Meant to be overloaded in a
  subclass.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_ASSET

$fatpacked{"Mojo/Asset/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_ASSET_FILE';
  package Mojo::Asset::File;
  use Mojo::Base 'Mojo::Asset';
  
  use Carp 'croak';
  use Fcntl 'SEEK_SET';
  use File::Spec::Functions ();
  use Mojo::File 'tempfile';
  
  has [qw(cleanup path)];
  has handle => sub {
    my $self = shift;
  
    # Open existing file
    my $path = $self->path;
    return Mojo::File->new($path)->open('<') if defined $path && -e $path;
  
    $self->cleanup(1) unless defined $self->cleanup;
  
    # Create a specific file
    return Mojo::File->new($path)->open('+>>') if defined $path;
  
    # Create a temporary file
    my $template = 'mojo.tmp.XXXXXXXXXXXXXXXX';
    my $file = tempfile DIR => $self->tmpdir, TEMPLATE => $template, UNLINK => 0;
    $self->path($file->to_string);
    return $file->open('+>>');
  };
  has tmpdir => sub { $ENV{MOJO_TMPDIR} || File::Spec::Functions::tmpdir };
  
  sub DESTROY {
    my $self = shift;
  
    return unless $self->cleanup && defined(my $path = $self->path);
    if (my $handle = $self->handle) { close $handle }
  
    # Only the process that created the file is allowed to remove it
    unlink $path if -w $path && ($self->{pid} // $$) == $$;
  }
  
  sub add_chunk {
    my ($self, $chunk) = @_;
    ($self->handle->syswrite($chunk) // -1) == length $chunk
      or croak "Can't write to asset: $!";
    return $self;
  }
  
  sub contains {
    my ($self, $str) = @_;
  
    my $handle = $self->handle;
    $handle->sysseek($self->start_range, SEEK_SET);
  
    # Calculate window size
    my $end  = $self->end_range // $self->size;
    my $len  = length $str;
    my $size = $len > 131072 ? $len : 131072;
    $size = $end - $self->start_range if $size > $end - $self->start_range;
  
    # Sliding window search
    my $offset = 0;
    my $start = $handle->sysread(my $window, $len);
    while ($offset < $end) {
  
      # Read as much as possible
      my $diff = $end - ($start + $offset);
      my $read = $handle->sysread(my $buffer, $diff < $size ? $diff : $size);
      $window .= $buffer;
  
      # Search window
      my $pos = index $window, $str;
      return $offset + $pos if $pos >= 0;
      return -1 if $read == 0 || ($offset += $read) == $end;
  
      # Resize window
      substr $window, 0, $read, '';
    }
  
    return -1;
  }
  
  sub get_chunk {
    my ($self, $offset, $max) = @_;
    $max //= 131072;
  
    $offset += $self->start_range;
    my $handle = $self->handle;
    $handle->sysseek($offset, SEEK_SET);
  
    my $buffer;
    if (defined(my $end = $self->end_range)) {
      return '' if (my $chunk = $end + 1 - $offset) <= 0;
      $handle->sysread($buffer, $chunk > $max ? $max : $chunk);
    }
    else { $handle->sysread($buffer, $max) }
  
    return $buffer;
  }
  
  sub is_file {1}
  
  sub move_to {
    my ($self, $to) = @_;
  
    # Windows requires that the handle is closed
    close $self->handle;
    delete $self->{handle};
  
    # Move file and prevent clean up
    Mojo::File->new($self->path)->move_to($to);
    return $self->path($to)->cleanup(0);
  }
  
  sub mtime { (stat shift->handle)[9] }
  
  sub new {
    my $file = shift->SUPER::new(@_);
    $file->{pid} = $$;
    return $file;
  }
  
  sub size { -s shift->handle }
  
  sub slurp {
    my $handle = shift->handle;
    $handle->sysseek(0, SEEK_SET);
    my $ret = my $content = '';
    while ($ret = $handle->sysread(my $buffer, 131072, 0)) { $content .= $buffer }
    return defined $ret ? $content : croak "Can't read from asset: $!";
  }
  
  sub to_file {shift}
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Asset::File - File storage for HTTP content
  
  =head1 SYNOPSIS
  
    use Mojo::Asset::File;
  
    # Temporary file
    my $file = Mojo::Asset::File->new;
    $file->add_chunk('foo bar baz');
    say 'File contains "bar"' if $file->contains('bar') >= 0;
    say $file->slurp;
  
    # Existing file
    my $file = Mojo::Asset::File->new(path => '/home/sri/foo.txt');
    $file->move_to('/yada.txt');
    say $file->slurp;
  
  =head1 DESCRIPTION
  
  L<Mojo::Asset::File> is a file storage backend for HTTP content.
  
  =head1 EVENTS
  
  L<Mojo::Asset::File> inherits all events from L<Mojo::Asset>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Asset::File> inherits all attributes from L<Mojo::Asset> and implements
  the following new ones.
  
  =head2 cleanup
  
    my $bool = $file->cleanup;
    $file    = $file->cleanup($bool);
  
  Delete L</"path"> automatically once the file is not used anymore.
  
  =head2 handle
  
    my $handle = $file->handle;
    $file      = $file->handle(IO::File->new);
  
  Filehandle, created on demand for L</"path">, which can be generated
  automatically and safely based on L</"tmpdir">.
  
  =head2 path
  
    my $path = $file->path;
    $file    = $file->path('/home/sri/foo.txt');
  
  File path used to create L</"handle">.
  
  =head2 tmpdir
  
    my $tmpdir = $file->tmpdir;
    $file      = $file->tmpdir('/tmp');
  
  Temporary directory used to generate L</"path">, defaults to the value of the
  C<MOJO_TMPDIR> environment variable or auto-detection.
  
  =head1 METHODS
  
  L<Mojo::Asset::File> inherits all methods from L<Mojo::Asset> and implements
  the following new ones.
  
  =head2 add_chunk
  
    $file = $file->add_chunk('foo bar baz');
  
  Add chunk of data.
  
  =head2 contains
  
    my $position = $file->contains('bar');
  
  Check if asset contains a specific string.
  
  =head2 get_chunk
  
    my $bytes = $file->get_chunk($offset);
    my $bytes = $file->get_chunk($offset, $max);
  
  Get chunk of data starting from a specific position, defaults to a maximum
  chunk size of C<131072> bytes (128KiB).
  
  =head2 is_file
  
    my $bool = $file->is_file;
  
  True, this is a L<Mojo::Asset::File> object.
  
  =head2 move_to
  
    $file = $file->move_to('/home/sri/bar.txt');
  
  Move asset data into a specific file and disable L</"cleanup">.
  
  =head2 mtime
  
    my $mtime = $file->mtime;
  
  Modification time of asset.
  
  =head2 new
  
    my $file = Mojo::Asset::File->new;
    my $file = Mojo::Asset::File->new(path => '/home/sri/test.txt');
    my $file = Mojo::Asset::File->new({path => '/home/sri/test.txt'});
  
  Construct a new L<Mojo::Asset::File> object.
  
  =head2 size
  
    my $size = $file->size;
  
  Size of asset data in bytes.
  
  =head2 slurp
  
    my $bytes = $file->slurp;
  
  Read all asset data at once.
  
  =head2 to_file
  
    $file = $file->to_file;
  
  Does nothing but return the invocant, since we already have a
  L<Mojo::Asset::File> object.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_ASSET_FILE

$fatpacked{"Mojo/Asset/Memory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_ASSET_MEMORY';
  package Mojo::Asset::Memory;
  use Mojo::Base 'Mojo::Asset';
  
  use Mojo::Asset::File;
  use Mojo::File 'path';
  
  has 'auto_upgrade';
  has max_memory_size => sub { $ENV{MOJO_MAX_MEMORY_SIZE} || 262144 };
  has mtime => sub {$^T};
  
  sub add_chunk {
    my ($self, $chunk) = @_;
  
    # Upgrade if necessary
    $self->{content} .= $chunk;
    return $self if !$self->auto_upgrade || $self->size <= $self->max_memory_size;
    $self->emit(upgrade => my $file = $self->to_file);
    return $file;
  }
  
  sub contains {
    my ($self, $str) = @_;
  
    my $start = $self->start_range;
    my $pos = index $self->{content} // '', $str, $start;
    $pos -= $start if $start && $pos >= 0;
    my $end = $self->end_range;
  
    return $end && ($pos + length $str) >= $end ? -1 : $pos;
  }
  
  sub get_chunk {
    my ($self, $offset, $max) = @_;
    $max //= 131072;
  
    $offset += $self->start_range;
    if (my $end = $self->end_range) {
      $max = $end + 1 - $offset if ($offset + $max) > $end;
    }
  
    return substr shift->{content} // '', $offset, $max;
  }
  
  sub move_to { path($_[1])->spurt($_[0]{content} // '') and return $_[0] }
  
  sub size { length(shift->{content} // '') }
  
  sub slurp { shift->{content} // '' }
  
  sub to_file { Mojo::Asset::File->new->add_chunk(shift->slurp) }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Asset::Memory - In-memory storage for HTTP content
  
  =head1 SYNOPSIS
  
    use Mojo::Asset::Memory;
  
    my $mem = Mojo::Asset::Memory->new;
    $mem->add_chunk('foo bar baz');
    say $mem->slurp;
  
  =head1 DESCRIPTION
  
  L<Mojo::Asset::Memory> is an in-memory storage backend for HTTP content.
  
  =head1 EVENTS
  
  L<Mojo::Asset::Memory> inherits all events from L<Mojo::Asset> and can emit the
  following new ones.
  
  =head2 upgrade
  
    $mem->on(upgrade => sub {
      my ($mem, $file) = @_;
      ...
    });
  
  Emitted when asset gets upgraded to a L<Mojo::Asset::File> object.
  
    $mem->on(upgrade => sub {
      my ($mem, $file) = @_;
      $file->tmpdir('/tmp');
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Asset::Memory> inherits all attributes from L<Mojo::Asset> and
  implements the following new ones.
  
  =head2 auto_upgrade
  
    my $bool = $mem->auto_upgrade;
    $mem     = $mem->auto_upgrade($bool);
  
  Try to detect if content size exceeds L</"max_memory_size"> limit and
  automatically upgrade to a L<Mojo::Asset::File> object.
  
  =head2 max_memory_size
  
    my $size = $mem->max_memory_size;
    $mem     = $mem->max_memory_size(1024);
  
  Maximum size in bytes of data to keep in memory before automatically upgrading
  to a L<Mojo::Asset::File> object, defaults to the value of the
  C<MOJO_MAX_MEMORY_SIZE> environment variable or C<262144> (256KiB).
  
  =head2 mtime
  
    my $mtime = $mem->mtime;
    $mem      = $mem->mtime(1408567500);
  
  Modification time of asset, defaults to the value of C<$^T>.
  
  =head1 METHODS
  
  L<Mojo::Asset::Memory> inherits all methods from L<Mojo::Asset> and implements
  the following new ones.
  
  =head2 add_chunk
  
    $mem     = $mem->add_chunk('foo bar baz');
    my $file = $mem->add_chunk('abc' x 262144);
  
  Add chunk of data and upgrade to L<Mojo::Asset::File> object if necessary.
  
  =head2 contains
  
    my $position = $mem->contains('bar');
  
  Check if asset contains a specific string.
  
  =head2 get_chunk
  
    my $bytes = $mem->get_chunk($offset);
    my $bytes = $mem->get_chunk($offset, $max);
  
  Get chunk of data starting from a specific position, defaults to a maximum
  chunk size of C<131072> bytes (128KiB).
  
  =head2 move_to
  
    $mem = $mem->move_to('/home/sri/foo.txt');
  
  Move asset data into a specific file.
  
  =head2 size
  
    my $size = $mem->size;
  
  Size of asset data in bytes.
  
  =head2 slurp
  
    my $bytes = mem->slurp;
  
  Read all asset data at once.
  
  =head2 to_file
  
    my $file = $mem->to_file;
  
  Convert asset to L<Mojo::Asset::File> object.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_ASSET_MEMORY

$fatpacked{"Mojo/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_BASE';
  package Mojo::Base;
  
  use strict;
  use warnings;
  use utf8;
  use feature ();
  
  # No imports because we get subclassed, a lot!
  use Carp         ();
  use Scalar::Util ();
  
  # Defer to runtime so Mojo::Util can use "-strict"
  require Mojo::Util;
  
  # Only Perl 5.14+ requires it on demand
  use IO::Handle ();
  
  # Role support requires Role::Tiny 2.000001+
  use constant ROLES =>
    !!(eval { require Role::Tiny; Role::Tiny->VERSION('2.000001'); 1 });
  
  # Protect subclasses using AUTOLOAD
  sub DESTROY { }
  
  sub attr {
    my ($self, $attrs, $value) = @_;
    return unless (my $class = ref $self || $self) && $attrs;
  
    Carp::croak 'Default has to be a code reference or constant value'
      if ref $value && ref $value ne 'CODE';
  
    for my $attr (@{ref $attrs eq 'ARRAY' ? $attrs : [$attrs]}) {
      Carp::croak qq{Attribute "$attr" invalid} unless $attr =~ /^[a-zA-Z_]\w*$/;
  
      # Very performance-sensitive code with lots of micro-optimizations
      if (ref $value) {
        my $sub = sub {
          return
            exists $_[0]{$attr} ? $_[0]{$attr} : ($_[0]{$attr} = $value->($_[0]))
            if @_ == 1;
          $_[0]{$attr} = $_[1];
          $_[0];
        };
        Mojo::Util::monkey_patch($class, $attr, $sub);
      }
      elsif (defined $value) {
        my $sub = sub {
          return exists $_[0]{$attr} ? $_[0]{$attr} : ($_[0]{$attr} = $value)
            if @_ == 1;
          $_[0]{$attr} = $_[1];
          $_[0];
        };
        Mojo::Util::monkey_patch($class, $attr, $sub);
      }
      else {
        Mojo::Util::monkey_patch($class, $attr,
          sub { return $_[0]{$attr} if @_ == 1; $_[0]{$attr} = $_[1]; $_[0] });
      }
    }
  }
  
  sub import {
    my ($class, $caller) = (shift, caller);
    return unless my @flags = @_;
  
    # Base
    if ($flags[0] eq '-base') { $flags[0] = $class }
  
    # Role
    if ($flags[0] eq '-role') {
      Carp::croak 'Role::Tiny 2.000001+ is required for roles' unless ROLES;
      Mojo::Util::monkey_patch($caller, 'has', sub { attr($caller, @_) });
      eval "package $caller; use Role::Tiny; 1" or die $@;
    }
  
    # Module and not -strict
    elsif ($flags[0] !~ /^-/) {
      no strict 'refs';
      require(Mojo::Util::class_to_path($flags[0])) unless $flags[0]->can('new');
      push @{"${caller}::ISA"}, $flags[0];
      Mojo::Util::monkey_patch($caller, 'has', sub { attr($caller, @_) });
    }
  
    # Mojo modules are strict!
    $_->import for qw(strict warnings utf8);
    feature->import(':5.10');
  
    # Signatures (Perl 5.20+)
    if (($flags[1] || '') eq '-signatures') {
      Carp::croak 'Subroutine signatures require Perl 5.20+' if $] < 5.020;
      require experimental;
      experimental->import('signatures');
    }
  }
  
  sub new {
    my $class = shift;
    bless @_ ? @_ > 1 ? {@_} : {%{$_[0]}} : {}, ref $class || $class;
  }
  
  sub tap {
    my ($self, $cb) = (shift, shift);
    $_->$cb(@_) for $self;
    return $self;
  }
  
  sub with_roles {
    Carp::croak 'Role::Tiny 2.000001+ is required for roles' unless ROLES;
    my ($self, @roles) = @_;
  
    return Role::Tiny->create_class_with_roles($self,
      map { /^\+(.+)$/ ? "${self}::Role::$1" : $_ } @roles)
      unless my $class = Scalar::Util::blessed $self;
  
    return Role::Tiny->apply_roles_to_object($self,
      map { /^\+(.+)$/ ? "${class}::Role::$1" : $_ } @roles);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Base - Minimal base class for Mojo projects
  
  =head1 SYNOPSIS
  
    package Cat;
    use Mojo::Base -base;
  
    has name => 'Nyan';
    has ['age', 'weight'] => 4;
  
    package Tiger;
    use Mojo::Base 'Cat';
  
    has friend  => sub { Cat->new };
    has stripes => 42;
  
    package main;
    use Mojo::Base -strict;
  
    my $mew = Cat->new(name => 'Longcat');
    say $mew->age;
    say $mew->age(3)->weight(5)->age;
  
    my $rawr = Tiger->new(stripes => 38, weight => 250);
    say $rawr->tap(sub { $_->friend->name('Tacgnol') })->weight;
  
  =head1 DESCRIPTION
  
  L<Mojo::Base> is a simple base class for L<Mojo> projects with fluent
  interfaces.
  
    # Automatically enables "strict", "warnings", "utf8" and Perl 5.10 features
    use Mojo::Base -strict;
    use Mojo::Base -base;
    use Mojo::Base 'SomeBaseClass';
    use Mojo::Base -role;
  
  All four forms save a lot of typing. Note that role support depends on
  L<Role::Tiny> (2.000001+).
  
    # use Mojo::Base -strict;
    use strict;
    use warnings;
    use utf8;
    use feature ':5.10';
    use IO::Handle ();
  
    # use Mojo::Base -base;
    use strict;
    use warnings;
    use utf8;
    use feature ':5.10';
    use IO::Handle ();
    push @ISA, 'Mojo::Base';
    sub has { Mojo::Base::attr(__PACKAGE__, @_) }
  
    # use Mojo::Base 'SomeBaseClass';
    use strict;
    use warnings;
    use utf8;
    use feature ':5.10';
    use IO::Handle ();
    require SomeBaseClass;
    push @ISA, 'SomeBaseClass';
    sub has { Mojo::Base::attr(__PACKAGE__, @_) }
  
    # use Mojo::Base -role;
    use strict;
    use warnings;
    use utf8;
    use feature ':5.10';
    use IO::Handle ();
    use Role::Tiny;
    sub has { Mojo::Base::attr(__PACKAGE__, @_) }
  
  On Perl 5.20+ you can also append a C<-signatures> flag to all three forms and
  enable support for L<subroutine signatures|perlsub/"Signatures">.
  
    # Also enable signatures
    use Mojo::Base -strict, -signatures;
    use Mojo::Base -base, -signatures;
    use Mojo::Base 'SomeBaseClass', -signatures;
    use Mojo::Base -role, -signatures;
  
  This will also disable experimental warnings on versions of Perl where this
  feature was still experimental.
  
  =head1 FLUENT INTERFACES
  
  Fluent interfaces are a way to design object-oriented APIs around method
  chaining to create domain-specific languages, with the goal of making the
  readablity of the source code close to written prose.
  
    package Duck;
    use Mojo::Base -base;
  
    has 'name';
  
    sub quack {
      my $self = shift;
      my $name = $self->name;
      say "$name: Quack!"
    }
  
  L<Mojo::Base> will help you with this by having all attribute accessors created
  with L</"has"> (or L</"attr">) return their invocant (C<$self>) whenever they
  are used to assign a new attribute value.
  
    Duck->new->name('Donald')->quack;
  
  In this case the C<name> attribute accessor is called on the object created by
  C<Duck-E<gt>new>. It assigns a new attribute value and then returns the C<Duck>
  object, so the C<quack> method can be called on it afterwards. These method
  chains can continue until one of the methods called does not return the C<Duck>
  object.
  
  =head1 FUNCTIONS
  
  L<Mojo::Base> implements the following functions, which can be imported with
  the C<-base> flag or by setting a base class.
  
  =head2 has
  
    has 'name';
    has ['name1', 'name2', 'name3'];
    has name => 'foo';
    has name => sub {...};
    has ['name1', 'name2', 'name3'] => 'foo';
    has ['name1', 'name2', 'name3'] => sub {...};
  
  Create attributes for hash-based objects, just like the L</"attr"> method.
  
  =head1 METHODS
  
  L<Mojo::Base> implements the following methods.
  
  =head2 attr
  
    $object->attr('name');
    SubClass->attr('name');
    SubClass->attr(['name1', 'name2', 'name3']);
    SubClass->attr(name => 'foo');
    SubClass->attr(name => sub {...});
    SubClass->attr(['name1', 'name2', 'name3'] => 'foo');
    SubClass->attr(['name1', 'name2', 'name3'] => sub {...});
  
  Create attribute accessors for hash-based objects, an array reference can be
  used to create more than one at a time. Pass an optional second argument to set
  a default value, it should be a constant or a callback. The callback will be
  executed at accessor read time if there's no set value, and gets passed the
  current instance of the object as first argument. Accessors can be chained, that
  means they return their invocant when they are called with an argument.
  
  =head2 new
  
    my $object = SubClass->new;
    my $object = SubClass->new(name => 'value');
    my $object = SubClass->new({name => 'value'});
  
  This base class provides a basic constructor for hash-based objects. You can
  pass it either a hash or a hash reference with attribute values.
  
  =head2 tap
  
    $object = $object->tap(sub {...});
    $object = $object->tap('some_method');
    $object = $object->tap('some_method', @args);
  
  Tap into a method chain to perform operations on an object within the chain
  (also known as a K combinator or Kestrel). The object will be the first argument
  passed to the callback, and is also available as C<$_>. The callback's return
  value will be ignored; instead, the object (the callback's first argument) will
  be the return value. In this way, arbitrary code can be used within (i.e.,
  spliced or tapped into) a chained set of object method calls.
  
    # Longer version
    $object = $object->tap(sub { $_->some_method(@args) });
  
    # Inject side effects into a method chain
    $object->foo('A')->tap(sub { say $_->foo })->foo('B');
  
  =head2 with_roles
  
    my $new_class = SubClass->with_roles('SubClass::Role::One');
    my $new_class = SubClass->with_roles('+One', '+Two');
    $object       = $object->with_roles('+One', '+Two');
  
  Create a new class with one or more L<Role::Tiny> roles. If called on a class
  returns the new class, or if called on an object reblesses the object into the
  new class. For roles following the naming scheme C<MyClass::Role::RoleName> you
  can use the shorthand C<+RoleName>. Note that role support depends on
  L<Role::Tiny> (2.000001+).
  
    # Create a new class with the role "SubClass::Role::Foo" and instantiate it
    my $new_class = SubClass->with_roles('+Foo');
    my $object    = $new_class->new;
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_BASE

$fatpacked{"Mojo/ByteStream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_BYTESTREAM';
  package Mojo::ByteStream;
  use Mojo::Base -strict;
  use overload bool => sub {1}, '""' => sub { ${$_[0]} }, fallback => 1;
  
  use Exporter 'import';
  use Mojo::Collection;
  use Mojo::Util;
  
  our @EXPORT_OK = ('b');
  
  # Turn most functions from Mojo::Util into methods
  my @UTILS = (
    qw(b64_decode b64_encode camelize decamelize hmac_sha1_sum html_unescape),
    qw(md5_bytes md5_sum punycode_decode punycode_encode quote sha1_bytes),
    qw(sha1_sum slugify term_escape trim unindent unquote url_escape),
    qw(url_unescape xml_escape xor_encode)
  );
  for my $name (@UTILS) {
    my $sub = Mojo::Util->can($name);
    Mojo::Util::monkey_patch __PACKAGE__, $name, sub {
      my $self = shift;
      $$self = $sub->($$self, @_);
      return $self;
    };
  }
  
  sub b { __PACKAGE__->new(@_) }
  
  sub clone { $_[0]->new(${$_[0]}) }
  
  sub decode { shift->_delegate(\&Mojo::Util::decode, @_) }
  sub encode { shift->_delegate(\&Mojo::Util::encode, @_) }
  
  sub new {
    my $class = shift;
    return bless \(my $dummy = join '', @_), ref $class || $class;
  }
  
  sub say {
    my ($self, $handle) = @_;
    $handle ||= \*STDOUT;
    say $handle $$self;
    return $self;
  }
  
  sub secure_compare { Mojo::Util::secure_compare ${shift()}, shift }
  
  sub size { length ${$_[0]} }
  
  sub split {
    my ($self, $pattern) = @_;
    return Mojo::Collection->new(map { $self->new($_) } split $pattern, $$self);
  }
  
  sub tap { shift->Mojo::Base::tap(@_) }
  
  sub to_string { ${$_[0]} }
  
  sub with_roles { shift->Mojo::Base::with_roles(@_) }
  
  sub _delegate {
    my ($self, $sub) = (shift, shift);
    $$self = $sub->(shift || 'UTF-8', $$self);
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::ByteStream - ByteStream
  
  =head1 SYNOPSIS
  
    use Mojo::ByteStream;
  
    # Manipulate bytestream
    my $stream = Mojo::ByteStream->new('foo_bar_baz');
    say $stream->camelize;
  
    # Chain methods
    my $stream = Mojo::ByteStream->new('foo bar baz')->quote;
    $stream = $stream->unquote->encode('UTF-8')->b64_encode('');
    say "$stream";
  
    # Use the alternative constructor
    use Mojo::ByteStream 'b';
    my $stream = b('foobarbaz')->b64_encode('')->say;
  
  =head1 DESCRIPTION
  
  L<Mojo::ByteStream> is a scalar-based container for bytestreams that provides a
  more friendly API for many of the functions in L<Mojo::Util>.
  
    # Access scalar directly to manipulate bytestream
    my $stream = Mojo::ByteStream->new('foo');
    $$stream .= 'bar';
  
  =head1 FUNCTIONS
  
  L<Mojo::ByteStream> implements the following functions, which can be imported
  individually.
  
  =head2 b
  
    my $stream = b('test123');
  
  Construct a new scalar-based L<Mojo::ByteStream> object.
  
  =head1 METHODS
  
  L<Mojo::ByteStream> implements the following methods.
  
  =head2 b64_decode
  
    $stream = $stream->b64_decode;
  
  Base64 decode bytestream with L<Mojo::Util/"b64_decode">.
  
  =head2 b64_encode
  
    $stream = $stream->b64_encode;
    $stream = $stream->b64_encode("\n");
  
  Base64 encode bytestream with L<Mojo::Util/"b64_encode">.
  
    # "Zm9vIGJhciBiYXo="
    b('foo bar baz')->b64_encode('');
  
  =head2 camelize
  
    $stream = $stream->camelize;
  
  Camelize bytestream with L<Mojo::Util/"camelize">.
  
  =head2 clone
  
    my $stream2 = $stream->clone;
  
  Return a new L<Mojo::ByteStream> object cloned from this bytestream.
  
  =head2 decamelize
  
    $stream = $stream->decamelize;
  
  Decamelize bytestream with L<Mojo::Util/"decamelize">.
  
  =head2 decode
  
    $stream = $stream->decode;
    $stream = $stream->decode('iso-8859-1');
  
  Decode bytestream with L<Mojo::Util/"decode">, defaults to using C<UTF-8>.
  
    # ""
    b('%E2%99%A5')->url_unescape->decode;
  
  =head2 encode
  
    $stream = $stream->encode;
    $stream = $stream->encode('iso-8859-1');
  
  Encode bytestream with L<Mojo::Util/"encode">, defaults to using C<UTF-8>.
  
    # "%E2%99%A5"
    b('')->encode->url_escape;
  
  =head2 hmac_sha1_sum
  
    $stream = $stream->hmac_sha1_sum('passw0rd');
  
  Generate HMAC-SHA1 checksum for bytestream with L<Mojo::Util/"hmac_sha1_sum">.
  
    # "7fbdc89263974a89210ea71f171c77d3f8c21471"
    b('foo bar baz')->hmac_sha1_sum('secr3t');
  
  =head2 html_unescape
  
    $stream = $stream->html_unescape;
  
  Unescape all HTML entities in bytestream with L<Mojo::Util/"html_unescape">.
  
    # "%3Chtml%3E"
    b('&lt;html&gt;')->html_unescape->url_escape;
  
  =head2 md5_bytes
  
    $stream = $stream->md5_bytes;
  
  Generate binary MD5 checksum for bytestream with L<Mojo::Util/"md5_bytes">.
  
  =head2 md5_sum
  
    $stream = $stream->md5_sum;
  
  Generate MD5 checksum for bytestream with L<Mojo::Util/"md5_sum">.
  
  =head2 new
  
    my $stream = Mojo::ByteStream->new('test123');
  
  Construct a new scalar-based L<Mojo::ByteStream> object.
  
  =head2 punycode_decode
  
    $stream = $stream->punycode_decode;
  
  Punycode decode bytestream with L<Mojo::Util/"punycode_decode">.
  
  =head2 punycode_encode
  
    $stream = $stream->punycode_encode;
  
  Punycode encode bytestream with L<Mojo::Util/"punycode_encode">.
  
  =head2 quote
  
    $stream = $stream->quote;
  
  Quote bytestream with L<Mojo::Util/"quote">.
  
  =head2 say
  
    $stream = $stream->say;
    $stream = $stream->say(*STDERR);
  
  Print bytestream to handle and append a newline, defaults to using C<STDOUT>.
  
  =head2 secure_compare
  
    my $bool = $stream->secure_compare($str);
  
  Compare bytestream with L<Mojo::Util/"secure_compare">.
  
  =head2 sha1_bytes
  
    $stream = $stream->sha1_bytes;
  
  Generate binary SHA1 checksum for bytestream with L<Mojo::Util/"sha1_bytes">.
  
  =head2 sha1_sum
  
    $stream = $stream->sha1_sum;
  
  Generate SHA1 checksum for bytestream with L<Mojo::Util/"sha1_sum">.
  
  =head2 size
  
    my $size = $stream->size;
  
  Size of bytestream.
  
  =head2 slugify
  
    $stream = $stream->slugify;
    $stream = $stream->slugify($bool);
  
  Generate URL slug for bytestream with L<Mojo::Util/"slugify">.
  
  =head2 split
  
    my $collection = $stream->split(',');
  
  Turn bytestream into L<Mojo::Collection> object containing L<Mojo::ByteStream>
  objects.
  
    # "One,Two,Three"
    b("one,two,three")->split(',')->map('camelize')->join(',');
  
  =head2 tap
  
    $stream = $stream->tap(sub {...});
  
  Alias for L<Mojo::Base/"tap">.
  
  =head2 term_escape
  
    $stream = $stream->term_escape;
  
  Escape POSIX control characters in bytestream with L<Mojo::Util/"term_escape">.
  
    # Print binary checksum to terminal
    b('foo')->sha1_bytes->term_escape->say;
  
  =head2 to_string
  
    my $str = $stream->to_string;
  
  Stringify bytestream.
  
  =head2 trim
  
    $stream = $stream->trim;
  
  Trim whitespace characters from both ends of bytestream with
  L<Mojo::Util/"trim">.
  
  =head2 unindent
  
    $stream = $stream->unindent;
  
  Unindent bytestream with L<Mojo::Util/"unindent">.
  
  =head2 unquote
  
    $stream = $stream->unquote;
  
  Unquote bytestream with L<Mojo::Util/"unquote">.
  
  =head2 url_escape
  
    $stream = $stream->url_escape;
    $stream = $stream->url_escape('^A-Za-z0-9\-._~');
  
  Percent encode all unsafe characters in bytestream with
  L<Mojo::Util/"url_escape">.
  
    # "%E2%98%83"
    b('')->encode->url_escape;
  
  =head2 url_unescape
  
    $stream = $stream->url_unescape;
  
  Decode percent encoded characters in bytestream with
  L<Mojo::Util/"url_unescape">.
  
    # "&lt;html&gt;"
    b('%3Chtml%3E')->url_unescape->xml_escape;
  
  =head2 with_roles
  
    my $new_class = Mojo::ByteStream->with_roles('Mojo::ByteStream::Role::One');
    my $new_class = Mojo::ByteStream->with_roles('+One', '+Two');
    $stream       = $stream->with_roles('+One', '+Two');
  
  Alias for L<Mojo::Base/"with_roles">.
  
  =head2 xml_escape
  
    $stream = $stream->xml_escape;
  
  Escape only the characters C<&>, C<E<lt>>, C<E<gt>>, C<"> and C<'> in
  bytestream with L<Mojo::Util/"xml_escape">.
  
  =head2 xor_encode
  
    $stream = $stream->xor_encode($key);
  
  XOR encode bytestream with L<Mojo::Util/"xor_encode">.
  
    # "%04%0E%15B%03%1B%10"
    b('foo bar')->xor_encode('baz')->url_escape;
  
  =head1 OPERATORS
  
  L<Mojo::ByteStream> overloads the following operators.
  
  =head2 bool
  
    my $bool = !!$bytestream;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$bytestream";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_BYTESTREAM

$fatpacked{"Mojo/Cache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_CACHE';
  package Mojo::Cache;
  use Mojo::Base -base;
  
  has 'max_keys' => 100;
  
  sub get { (shift->{cache} || {})->{shift()} }
  
  sub set {
    my ($self, $key, $value) = @_;
  
    return $self unless (my $max = $self->max_keys) > 0;
  
    my $cache = $self->{cache} ||= {};
    my $queue = $self->{queue} ||= [];
    delete $cache->{shift @$queue} while @$queue >= $max;
    push @$queue, $key unless exists $cache->{$key};
    $cache->{$key} = $value;
  
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Cache - Naive in-memory cache
  
  =head1 SYNOPSIS
  
    use Mojo::Cache;
  
    my $cache = Mojo::Cache->new(max_keys => 50);
    $cache->set(foo => 'bar');
    my $foo = $cache->get('foo');
  
  =head1 DESCRIPTION
  
  L<Mojo::Cache> is a naive in-memory cache with size limits.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Cache> implements the following attributes.
  
  =head2 max_keys
  
    my $max = $cache->max_keys;
    $cache  = $cache->max_keys(50);
  
  Maximum number of cache keys, defaults to C<100>. Setting the value to C<0>
  will disable caching.
  
  =head1 METHODS
  
  L<Mojo::Cache> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 get
  
    my $value = $cache->get('foo');
  
  Get cached value.
  
  =head2 set
  
    $cache = $cache->set(foo => 'bar');
  
  Set cached value.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_CACHE

$fatpacked{"Mojo/Collection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_COLLECTION';
  package Mojo::Collection;
  use Mojo::Base -strict;
  
  use Carp 'croak';
  use Exporter 'import';
  use List::Util;
  use Mojo::ByteStream;
  use Scalar::Util 'blessed';
  
  our @EXPORT_OK = ('c');
  
  sub TO_JSON { [@{shift()}] }
  
  sub c { __PACKAGE__->new(@_) }
  
  sub compact {
    my $self = shift;
    return $self->new(grep { defined && (ref || length) } @$self);
  }
  
  sub each {
    my ($self, $cb) = @_;
    return @$self unless $cb;
    my $i = 1;
    $_->$cb($i++) for @$self;
    return $self;
  }
  
  sub first {
    my ($self, $cb) = (shift, shift);
    return $self->[0] unless $cb;
    return List::Util::first { $_ =~ $cb } @$self if ref $cb eq 'Regexp';
    return List::Util::first { $_->$cb(@_) } @$self;
  }
  
  sub flatten { $_[0]->new(_flatten(@{$_[0]})) }
  
  sub grep {
    my ($self, $cb) = (shift, shift);
    return $self->new(grep { $_ =~ $cb } @$self) if ref $cb eq 'Regexp';
    return $self->new(grep { $_->$cb(@_) } @$self);
  }
  
  sub join {
    Mojo::ByteStream->new(join $_[1] // '', map {"$_"} @{$_[0]});
  }
  
  sub last { shift->[-1] }
  
  sub map {
    my ($self, $cb) = (shift, shift);
    return $self->new(map { $_->$cb(@_) } @$self);
  }
  
  sub new {
    my $class = shift;
    return bless [@_], ref $class || $class;
  }
  
  sub reduce {
    my $self = shift;
    @_ = (@_, @$self);
    goto &List::Util::reduce;
  }
  
  sub reverse { $_[0]->new(reverse @{$_[0]}) }
  
  sub shuffle { $_[0]->new(List::Util::shuffle @{$_[0]}) }
  
  sub size { scalar @{$_[0]} }
  
  sub slice {
    my $self = shift;
    return $self->new(@$self[@_]);
  }
  
  sub sort {
    my ($self, $cb) = @_;
  
    return $self->new(sort @$self) unless $cb;
  
    my $caller = caller;
    no strict 'refs';
    my @sorted = sort {
      local (*{"${caller}::a"}, *{"${caller}::b"}) = (\$a, \$b);
      $a->$cb($b);
    } @$self;
    return $self->new(@sorted);
  }
  
  sub tap { shift->Mojo::Base::tap(@_) }
  
  sub to_array { [@{shift()}] }
  
  sub uniq {
    my ($self, $cb) = (shift, shift);
    my %seen;
    return $self->new(grep { !$seen{$_->$cb(@_) // ''}++ } @$self) if $cb;
    return $self->new(grep { !$seen{$_ // ''}++ } @$self);
  }
  
  sub with_roles { shift->Mojo::Base::with_roles(@_) }
  
  sub _flatten {
    map { _ref($_) ? _flatten(@$_) : $_ } @_;
  }
  
  sub _ref { ref $_[0] eq 'ARRAY' || blessed $_[0] && $_[0]->isa(__PACKAGE__) }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Collection - Collection
  
  =head1 SYNOPSIS
  
    use Mojo::Collection;
  
    # Manipulate collection
    my $collection = Mojo::Collection->new(qw(just works));
    unshift @$collection, 'it';
    say $collection->join("\n");
  
    # Chain methods
    $collection->map(sub { ucfirst })->shuffle->each(sub {
      my ($word, $num) = @_;
      say "$num: $word";
    });
  
    # Use the alternative constructor
    use Mojo::Collection 'c';
    c(qw(a b c))->join('/')->url_escape->say;
  
  =head1 DESCRIPTION
  
  L<Mojo::Collection> is an array-based container for collections.
  
    # Access array directly to manipulate collection
    my $collection = Mojo::Collection->new(1 .. 25);
    $collection->[23] += 100;
    say for @$collection;
  
  =head1 FUNCTIONS
  
  L<Mojo::Collection> implements the following functions, which can be imported
  individually.
  
  =head2 c
  
    my $collection = c(1, 2, 3);
  
  Construct a new array-based L<Mojo::Collection> object.
  
  =head1 METHODS
  
  L<Mojo::Collection> implements the following methods.
  
  =head2 TO_JSON
  
    my $array = $collection->TO_JSON;
  
  Alias for L</"to_array">.
  
  =head2 compact
  
    my $new = $collection->compact;
  
  Create a new collection with all elements that are defined and not an empty
  string.
  
    # "0, 1, 2, 3"
    c(0, 1, undef, 2, '', 3)->compact->join(', ');
  
  =head2 each
  
    my @elements = $collection->each;
    $collection  = $collection->each(sub {...});
  
  Evaluate callback for each element in collection, or return all elements as a
  list if none has been provided. The element will be the first argument passed
  to the callback, and is also available as C<$_>.
  
    # Make a numbered list
    $collection->each(sub {
      my ($e, $num) = @_;
      say "$num: $e";
    });
  
  =head2 first
  
    my $first = $collection->first;
    my $first = $collection->first(qr/foo/);
    my $first = $collection->first(sub {...});
    my $first = $collection->first('some_method');
    my $first = $collection->first('some_method', @args);
  
  Evaluate regular expression/callback for, or call method on, each element in
  collection and return the first one that matched the regular expression, or for
  which the callback/method returned true. The element will be the first argument
  passed to the callback, and is also available as C<$_>.
  
    # Longer version
    my $first = $collection->first(sub { $_->some_method(@args) });
  
    # Find first value that contains the word "mojo"
    my $interesting = $collection->first(qr/mojo/i);
  
    # Find first value that is greater than 5
    my $greater = $collection->first(sub { $_ > 5 });
  
  =head2 flatten
  
    my $new = $collection->flatten;
  
  Flatten nested collections/arrays recursively and create a new collection with
  all elements.
  
    # "1, 2, 3, 4, 5, 6, 7"
    c(1, [2, [3, 4], 5, [6]], 7)->flatten->join(', ');
  
  =head2 grep
  
    my $new = $collection->grep(qr/foo/);
    my $new = $collection->grep(sub {...});
    my $new = $collection->grep('some_method');
    my $new = $collection->grep('some_method', @args);
  
  Evaluate regular expression/callback for, or call method on, each element in
  collection and create a new collection with all elements that matched the
  regular expression, or for which the callback/method returned true. The element
  will be the first argument passed to the callback, and is also available as
  C<$_>.
  
    # Longer version
    my $new = $collection->grep(sub { $_->some_method(@args) });
  
    # Find all values that contain the word "mojo"
    my $interesting = $collection->grep(qr/mojo/i);
  
    # Find all values that are greater than 5
    my $greater = $collection->grep(sub { $_ > 5 });
  
  =head2 join
  
    my $stream = $collection->join;
    my $stream = $collection->join("\n");
  
  Turn collection into L<Mojo::ByteStream>.
  
    # Join all values with commas
    $collection->join(', ')->say;
  
  =head2 last
  
    my $last = $collection->last;
  
  Return the last element in collection.
  
  =head2 map
  
    my $new = $collection->map(sub {...});
    my $new = $collection->map('some_method');
    my $new = $collection->map('some_method', @args);
  
  Evaluate callback for, or call method on, each element in collection and create
  a new collection from the results. The element will be the first argument
  passed to the callback, and is also available as C<$_>.
  
    # Longer version
    my $new = $collection->map(sub { $_->some_method(@args) });
  
    # Append the word "mojo" to all values
    my $mojoified = $collection->map(sub { $_ . 'mojo' });
  
  =head2 new
  
    my $collection = Mojo::Collection->new(1, 2, 3);
  
  Construct a new array-based L<Mojo::Collection> object.
  
  =head2 reduce
  
    my $result = $collection->reduce(sub {...});
    my $result = $collection->reduce(sub {...}, $initial);
  
  Reduce elements in collection with a callback and return its final result,
  setting C<$a> and C<$b> each time the callback is executed. The first time C<$a>
  will be set to an optional initial value or the first element in the collection.
  And from then on C<$a> will be set to the return value of the callback, while
  C<$b> will always be set to the next element in the collection.
  
    # Calculate the sum of all values
    my $sum = $collection->reduce(sub { $a + $b });
  
    # Count how often each value occurs in collection
    my $hash = $collection->reduce(sub { $a->{$b}++; $a }, {});
  
  =head2 reverse
  
    my $new = $collection->reverse;
  
  Create a new collection with all elements in reverse order.
  
  =head2 slice
  
    my $new = $collection->slice(4 .. 7);
  
  Create a new collection with all selected elements.
  
    # "B C E"
    c('A', 'B', 'C', 'D', 'E')->slice(1, 2, 4)->join(' ');
  
  =head2 shuffle
  
    my $new = $collection->shuffle;
  
  Create a new collection with all elements in random order.
  
  =head2 size
  
    my $size = $collection->size;
  
  Number of elements in collection.
  
  =head2 sort
  
    my $new = $collection->sort;
    my $new = $collection->sort(sub {...});
  
  Sort elements based on return value of a callback and create a new collection
  from the results, setting C<$a> and C<$b> to the elements being compared, each
  time the callback is executed.
  
    # Sort values case-insensitive
    my $case_insensitive = $collection->sort(sub { uc($a) cmp uc($b) });
  
  =head2 tap
  
    $collection = $collection->tap(sub {...});
  
  Alias for L<Mojo::Base/"tap">.
  
  =head2 to_array
  
    my $array = $collection->to_array;
  
  Turn collection into array reference.
  
  =head2 uniq
  
    my $new = $collection->uniq;
    my $new = $collection->uniq(sub {...});
    my $new = $collection->uniq('some_method');
    my $new = $collection->uniq('some_method', @args);
  
  Create a new collection without duplicate elements, using the string
  representation of either the elements or the return value of the
  callback/method to decide uniqueness. Note that C<undef> and empty string are
  treated the same.
  
    # Longer version
    my $new = $collection->uniq(sub { $_->some_method(@args) });
  
    # "foo bar baz"
    c('foo', 'bar', 'bar', 'baz')->uniq->join(' ');
  
    # "[[1, 2], [2, 1]]"
    c([1, 2], [2, 1], [3, 2])->uniq(sub{ $_->[1] })->to_array;
  
  =head2 with_roles
  
    my $new_class = Mojo::Collection->with_roles('Mojo::Collection::Role::One');
    my $new_class = Mojo::Collection->with_roles('+One', '+Two');
    $collection   = $collection->with_roles('+One', '+Two');
  
  Alias for L<Mojo::Base/"with_roles">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_COLLECTION

$fatpacked{"Mojo/Content.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_CONTENT';
  package Mojo::Content;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Compress::Raw::Zlib qw(WANT_GZIP Z_STREAM_END);
  use Mojo::Headers;
  use Scalar::Util 'looks_like_number';
  
  has [qw(auto_decompress auto_relax expect_close relaxed skip_body)];
  has headers           => sub { Mojo::Headers->new };
  has max_buffer_size   => sub { $ENV{MOJO_MAX_BUFFER_SIZE} || 262144 };
  has max_leftover_size => sub { $ENV{MOJO_MAX_LEFTOVER_SIZE} || 262144 };
  
  my $BOUNDARY_RE
    = qr!multipart.*boundary\s*=\s*(?:"([^"]+)"|([\w'(),.:?\-+/]+))!i;
  
  sub body_contains {
    croak 'Method "body_contains" not implemented by subclass';
  }
  
  sub body_size { croak 'Method "body_size" not implemented by subclass' }
  
  sub boundary {
    (shift->headers->content_type // '') =~ $BOUNDARY_RE ? $1 // $2 : undef;
  }
  
  sub charset {
    my $type = shift->headers->content_type // '';
    return $type =~ /charset\s*=\s*"?([^"\s;]+)"?/i ? $1 : undef;
  }
  
  sub clone {
    my $self = shift;
    return undef if $self->is_dynamic;
    return $self->new(headers => $self->headers->clone);
  }
  
  sub generate_body_chunk {
    my ($self, $offset) = @_;
  
    $self->emit(drain => $offset) unless length($self->{body_buffer} //= '');
    my $len = $self->headers->content_length;
    return '' if looks_like_number $len && $len == $offset;
    my $chunk = delete $self->{body_buffer};
    return $self->{eof} ? '' : undef unless length $chunk;
  
    return $chunk;
  }
  
  sub get_body_chunk {
    croak 'Method "get_body_chunk" not implemented by subclass';
  }
  
  sub get_header_chunk { substr shift->_headers->{header_buffer}, shift, 131072 }
  
  sub header_size { length shift->_headers->{header_buffer} }
  
  sub headers_contain { index(shift->_headers->{header_buffer}, shift) >= 0 }
  
  sub is_chunked { !!shift->headers->transfer_encoding }
  
  sub is_compressed { lc(shift->headers->content_encoding // '') eq 'gzip' }
  
  sub is_dynamic { !!$_[0]{dynamic} }
  
  sub is_finished { (shift->{state} // '') eq 'finished' }
  
  sub is_limit_exceeded { !!shift->{limit} }
  
  sub is_multipart {undef}
  
  sub is_parsing_body { (shift->{state} // '') eq 'body' }
  
  sub leftovers { shift->{buffer} }
  
  sub parse {
    my $self = shift;
  
    # Headers
    $self->_parse_until_body(@_);
    return $self if $self->{state} eq 'headers';
  
    # Chunked content
    $self->{real_size} //= 0;
    if ($self->is_chunked && $self->{state} ne 'headers') {
      $self->_parse_chunked;
      $self->{state} = 'finished' if ($self->{chunk_state} // '') eq 'finished';
    }
  
    # Not chunked, pass through to second buffer
    else {
      $self->{real_size} += length $self->{pre_buffer};
      my $limit = $self->is_finished
        && length($self->{buffer}) > $self->max_leftover_size;
      $self->{buffer} .= $self->{pre_buffer} unless $limit;
      $self->{pre_buffer} = '';
    }
  
    # No content
    if ($self->skip_body) {
      $self->{state} = 'finished';
      return $self;
    }
  
    # Relaxed parsing
    my $headers = $self->headers;
    my $len     = $headers->content_length // '';
    if ($self->auto_relax && !length $len) {
      my $connection = lc($headers->connection // '');
      $self->relaxed(1)
        if $connection eq 'close' || (!$connection && $self->expect_close);
    }
  
    # Chunked or relaxed content
    if ($self->is_chunked || $self->relaxed) {
      $self->_decompress($self->{buffer} //= '');
      $self->{size} += length $self->{buffer};
      $self->{buffer} = '';
      return $self;
    }
  
    # Normal content
    $len = 0 unless looks_like_number $len;
    if ((my $need = $len - ($self->{size} ||= 0)) > 0) {
      my $len = length $self->{buffer};
      my $chunk = substr $self->{buffer}, 0, $need > $len ? $len : $need, '';
      $self->_decompress($chunk);
      $self->{size} += length $chunk;
    }
    $self->{state} = 'finished' if $len <= $self->progress;
  
    return $self;
  }
  
  sub parse_body {
    my $self = shift;
    $self->{state} = 'body';
    return $self->parse(@_);
  }
  
  sub progress {
    my $self = shift;
    return 0 unless my $state = $self->{state};
    return 0 unless $state eq 'body' || $state eq 'finished';
    return $self->{raw_size} - ($self->{header_size} || 0);
  }
  
  sub write {
    my ($self, $chunk, $cb) = @_;
  
    $self->{dynamic} = 1;
    $self->{body_buffer} .= $chunk if defined $chunk;
    $self->once(drain => $cb) if $cb;
    $self->{eof} = 1 if defined $chunk && !length $chunk;
  
    return $self;
  }
  
  sub write_chunk {
    my ($self, $chunk, $cb) = @_;
    $self->headers->transfer_encoding('chunked') unless $self->is_chunked;
    $self->write(defined $chunk ? $self->_build_chunk($chunk) : $chunk, $cb);
    $self->{eof} = 1 if defined $chunk && !length $chunk;
    return $self;
  }
  
  sub _build_chunk {
    my ($self, $chunk) = @_;
  
    # End
    return "\x0d\x0a0\x0d\x0a\x0d\x0a" unless length $chunk;
  
    # First chunk has no leading CRLF
    my $crlf = $self->{chunks}++ ? "\x0d\x0a" : '';
    return $crlf . sprintf('%x', length $chunk) . "\x0d\x0a$chunk";
  }
  
  sub _decompress {
    my ($self, $chunk) = @_;
  
    # No compression
    return $self->emit(read => $chunk)
      unless $self->auto_decompress && $self->is_compressed;
  
    # Decompress
    $self->{post_buffer} .= $chunk;
    my $gz = $self->{gz}
      //= Compress::Raw::Zlib::Inflate->new(WindowBits => WANT_GZIP);
    my $status = $gz->inflate(\$self->{post_buffer}, my $out);
    $self->emit(read => $out) if defined $out;
  
    # Replace Content-Encoding with Content-Length
    $self->headers->content_length($gz->total_out)->remove('Content-Encoding')
      if $status == Z_STREAM_END;
  
    # Check buffer size
    @$self{qw(state limit)} = ('finished', 1)
      if length($self->{post_buffer} // '') > $self->max_buffer_size;
  }
  
  sub _headers {
    my $self = shift;
    return $self if defined $self->{header_buffer};
    my $headers = $self->headers->to_string;
    $self->{header_buffer} = $headers ? "$headers\x0d\x0a\x0d\x0a" : "\x0d\x0a";
    return $self;
  }
  
  sub _parse_chunked {
    my $self = shift;
  
    # Trailing headers
    return $self->_parse_chunked_trailing_headers
      if ($self->{chunk_state} // '') eq 'trailing_headers';
  
    while (my $len = length $self->{pre_buffer}) {
  
      # Start new chunk (ignore the chunk extension)
      unless ($self->{chunk_len}) {
        last
          unless $self->{pre_buffer} =~ s/^(?:\x0d?\x0a)?([0-9a-fA-F]+).*\x0a//;
        next if $self->{chunk_len} = hex $1;
  
        # Last chunk
        $self->{chunk_state} = 'trailing_headers';
        last;
      }
  
      # Remove as much as possible from payload
      $len = $self->{chunk_len} if $self->{chunk_len} < $len;
      $self->{buffer} .= substr $self->{pre_buffer}, 0, $len, '';
      $self->{real_size} += $len;
      $self->{chunk_len} -= $len;
    }
  
    # Trailing headers
    $self->_parse_chunked_trailing_headers
      if ($self->{chunk_state} // '') eq 'trailing_headers';
  
    # Check buffer size
    @$self{qw(state limit)} = ('finished', 1)
      if length($self->{pre_buffer} // '') > $self->max_buffer_size;
  }
  
  sub _parse_chunked_trailing_headers {
    my $self = shift;
  
    my $headers = $self->headers->parse(delete $self->{pre_buffer});
    return unless $headers->is_finished;
    $self->{chunk_state} = 'finished';
  
    # Take care of leftover and replace Transfer-Encoding with Content-Length
    $self->{buffer} .= $headers->leftovers;
    $headers->remove('Transfer-Encoding');
    $headers->content_length($self->{real_size}) unless $headers->content_length;
  }
  
  sub _parse_headers {
    my $self = shift;
  
    my $headers = $self->headers->parse(delete $self->{pre_buffer});
    return unless $headers->is_finished;
    $self->{state} = 'body';
  
    # Take care of leftovers
    my $leftovers = $self->{pre_buffer} = $headers->leftovers;
    $self->{header_size} = $self->{raw_size} - length $leftovers;
  }
  
  sub _parse_until_body {
    my ($self, $chunk) = @_;
  
    $self->{raw_size} += length($chunk //= '');
    $self->{pre_buffer} .= $chunk;
    $self->_parse_headers if ($self->{state} ||= 'headers') eq 'headers';
    $self->emit('body') if $self->{state} ne 'headers' && !$self->{body}++;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Content - HTTP content base class
  
  =head1 SYNOPSIS
  
    package Mojo::Content::MyContent;
    use Mojo::Base 'Mojo::Content';
  
    sub body_contains  {...}
    sub body_size      {...}
    sub get_body_chunk {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Content> is an abstract base class for HTTP content containers, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230> and
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>, like
  L<Mojo::Content::MultiPart> and L<Mojo::Content::Single>.
  
  =head1 EVENTS
  
  L<Mojo::Content> inherits all events from L<Mojo::EventEmitter> and can emit
  the following new ones.
  
  =head2 body
  
    $content->on(body => sub {
      my $content = shift;
      ...
    });
  
  Emitted once all headers have been parsed and the body starts.
  
    $content->on(body => sub {
      my $content = shift;
      $content->auto_upgrade(0) if $content->headers->header('X-No-MultiPart');
    });
  
  =head2 drain
  
    $content->on(drain => sub {
      my ($content, $offset) = @_;
      ...
    });
  
  Emitted once all data has been written.
  
    $content->on(drain => sub {
      my $content = shift;
      $content->write_chunk(time);
    });
  
  =head2 read
  
    $content->on(read => sub {
      my ($content, $bytes) = @_;
      ...
    });
  
  Emitted when a new chunk of content arrives.
  
    $content->on(read => sub {
      my ($content, $bytes) = @_;
      say "Streaming: $bytes";
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Content> implements the following attributes.
  
  =head2 auto_decompress
  
    my $bool = $content->auto_decompress;
    $content = $content->auto_decompress($bool);
  
  Decompress content automatically if L</"is_compressed"> is true.
  
  =head2 auto_relax
  
    my $bool = $content->auto_relax;
    $content = $content->auto_relax($bool);
  
  Try to detect when relaxed parsing is necessary.
  
  =head2 expect_close
  
    my $bool = $content->expect_close;
    $content = $content->expect_close($bool);
  
  Expect a response that is terminated with a connection close.
  
  =head2 headers
  
    my $headers = $content->headers;
    $content    = $content->headers(Mojo::Headers->new);
  
  Content headers, defaults to a L<Mojo::Headers> object.
  
  =head2 max_buffer_size
  
    my $size = $content->max_buffer_size;
    $content = $content->max_buffer_size(1024);
  
  Maximum size in bytes of buffer for content parser, defaults to the value of
  the C<MOJO_MAX_BUFFER_SIZE> environment variable or C<262144> (256KiB).
  
  =head2 max_leftover_size
  
    my $size = $content->max_leftover_size;
    $content = $content->max_leftover_size(1024);
  
  Maximum size in bytes of buffer for pipelined HTTP requests, defaults to the
  value of the C<MOJO_MAX_LEFTOVER_SIZE> environment variable or C<262144>
  (256KiB).
  
  =head2 relaxed
  
    my $bool = $content->relaxed;
    $content = $content->relaxed($bool);
  
  Activate relaxed parsing for responses that are terminated with a connection
  close.
  
  =head2 skip_body
  
    my $bool = $content->skip_body;
    $content = $content->skip_body($bool);
  
  Skip body parsing and finish after headers.
  
  =head1 METHODS
  
  L<Mojo::Content> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 body_contains
  
    my $bool = $content->body_contains('foo bar baz');
  
  Check if content contains a specific string. Meant to be overloaded in a
  subclass.
  
  =head2 body_size
  
    my $size = $content->body_size;
  
  Content size in bytes. Meant to be overloaded in a subclass.
  
  =head2 boundary
  
    my $boundary = $content->boundary;
  
  Extract multipart boundary from C<Content-Type> header.
  
  =head2 charset
  
    my $charset = $content->charset;
  
  Extract charset from C<Content-Type> header.
  
  =head2 clone
  
    my $clone = $content->clone;
  
  Return a new L<Mojo::Content> object cloned from this content if possible,
  otherwise return C<undef>.
  
  =head2 generate_body_chunk
  
    my $bytes = $content->generate_body_chunk(0);
  
  Generate dynamic content.
  
  =head2 get_body_chunk
  
    my $bytes = $content->get_body_chunk(0);
  
  Get a chunk of content starting from a specific position. Meant to be
  overloaded in a subclass.
  
  =head2 get_header_chunk
  
    my $bytes = $content->get_header_chunk(13);
  
  Get a chunk of the headers starting from a specific position. Note that this
  method finalizes the content.
  
  =head2 header_size
  
    my $size = $content->header_size;
  
  Size of headers in bytes. Note that this method finalizes the content.
  
  =head2 headers_contain
  
    my $bool = $content->headers_contain('foo bar baz');
  
  Check if headers contain a specific string. Note that this method finalizes the
  content.
  
  =head2 is_chunked
  
    my $bool = $content->is_chunked;
  
  Check if C<Transfer-Encoding> header indicates chunked transfer encoding.
  
  =head2 is_compressed
  
    my $bool = $content->is_compressed;
  
  Check C<Content-Encoding> header for C<gzip> value.
  
  =head2 is_dynamic
  
    my $bool = $content->is_dynamic;
  
  Check if content will be dynamically generated, which prevents L</"clone"> from
  working.
  
  =head2 is_finished
  
    my $bool = $content->is_finished;
  
  Check if parser is finished.
  
  =head2 is_limit_exceeded
  
    my $bool = $content->is_limit_exceeded;
  
  Check if buffer has exceeded L</"max_buffer_size">.
  
  =head2 is_multipart
  
    my $bool = $content->is_multipart;
  
  False, this is not a L<Mojo::Content::MultiPart> object.
  
  =head2 is_parsing_body
  
    my $bool = $content->is_parsing_body;
  
  Check if body parsing started yet.
  
  =head2 leftovers
  
    my $bytes = $content->leftovers;
  
  Get leftover data from content parser.
  
  =head2 parse
  
    $content
      = $content->parse("Content-Length: 12\x0d\x0a\x0d\x0aHello World!");
  
  Parse content chunk.
  
  =head2 parse_body
  
    $content = $content->parse_body('Hi!');
  
  Parse body chunk and skip headers.
  
  =head2 progress
  
    my $size = $content->progress;
  
  Size of content already received from message in bytes.
  
  =head2 write
  
    $content = $content->write;
    $content = $content->write('');
    $content = $content->write($bytes);
    $content = $content->write($bytes => sub {...});
  
  Write dynamic content non-blocking, the optional drain callback will be executed
  once all data has been written. Calling this method without a chunk of data
  will finalize the L</"headers"> and allow for dynamic content to be written
  later. You can write an empty chunk of data at any time to end the stream.
  
    # Make sure previous chunk of data has been written before continuing
    $content->write('He' => sub {
      my $content = shift;
      $content->write('llo!' => sub {
        my $content = shift;
        $content->write('');
      });
    });
  
  =head2 write_chunk
  
    $content = $content->write_chunk;
    $content = $content->write_chunk('');
    $content = $content->write_chunk($bytes);
    $content = $content->write_chunk($bytes => sub {...});
  
  Write dynamic content non-blocking with chunked transfer encoding, the optional
  drain callback will be executed once all data has been written. Calling this
  method without a chunk of data will finalize the L</"headers"> and allow for
  dynamic content to be written later. You can write an empty chunk of data at any
  time to end the stream.
  
    # Make sure previous chunk of data has been written before continuing
    $content->write_chunk('He' => sub {
      my $content = shift;
      $content->write_chunk('llo!' => sub {
        my $content = shift;
        $content->write_chunk('');
      });
    });
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_CONTENT

$fatpacked{"Mojo/Content/MultiPart.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_CONTENT_MULTIPART';
  package Mojo::Content::MultiPart;
  use Mojo::Base 'Mojo::Content';
  
  use Mojo::Util 'b64_encode';
  
  has parts => sub { [] };
  
  sub body_contains {
    my ($self, $chunk) = @_;
    ($_->headers_contain($chunk) or $_->body_contains($chunk)) and return 1
      for @{$self->parts};
    return undef;
  }
  
  sub body_size {
    my $self = shift;
  
    # Check for existing Content-Lenght header
    if (my $len = $self->headers->content_length) { return $len }
  
    # Calculate length of whole body
    my $len = my $boundary_len = length($self->build_boundary) + 6;
    $len += $_->header_size + $_->body_size + $boundary_len for @{$self->parts};
  
    return $len;
  }
  
  sub build_boundary {
    my $self = shift;
  
    # Check for existing boundary
    my $boundary;
    return $boundary if defined($boundary = $self->boundary);
  
    # Generate and check boundary
    my $size = 1;
    do {
      $boundary = b64_encode join('', map chr(rand 256), 1 .. $size++ * 3);
      $boundary =~ s/\W/X/g;
    } while $self->body_contains($boundary);
  
    # Add boundary to Content-Type header
    my $headers = $self->headers;
    ($headers->content_type // '') =~ m!^(.*multipart/[^;]+)(.*)$!;
    my $before = $1 || 'multipart/mixed';
    my $after  = $2 || '';
    $headers->content_type("$before; boundary=$boundary$after");
  
    return $boundary;
  }
  
  sub clone {
    my $self = shift;
    return undef unless my $clone = $self->SUPER::clone();
    return $clone->parts($self->parts);
  }
  
  sub get_body_chunk {
    my ($self, $offset) = @_;
  
    # Body generator
    return $self->generate_body_chunk($offset) if $self->is_dynamic;
  
    # First boundary
    my $boundary     = $self->{boundary} //= $self->build_boundary;
    my $boundary_len = length($boundary) + 6;
    my $len          = $boundary_len - 2;
    return substr "--$boundary\x0d\x0a", $offset if $len > $offset;
  
    # Skip parts that have already been processed
    my $start = 0;
    ($len, $start) = ($self->{last_len}, $self->{last_part} + 1)
      if $self->{offset} && $offset > $self->{offset};
  
    # Prepare content part by part
    my $parts = $self->parts;
    for (my $i = $start; $i < @$parts; $i++) {
      my $part = $parts->[$i];
  
      # Headers
      my $header_len = $part->header_size;
      return $part->get_header_chunk($offset - $len)
        if ($len + $header_len) > $offset;
      $len += $header_len;
  
      # Content
      my $content_len = $part->body_size;
      return $part->get_body_chunk($offset - $len)
        if ($len + $content_len) > $offset;
      $len += $content_len;
  
      # Boundary
      if ($#$parts == $i) {
        $boundary .= '--';
        $boundary_len += 2;
      }
      return substr "\x0d\x0a--$boundary\x0d\x0a", $offset - $len
        if ($len + $boundary_len) > $offset;
      $len += $boundary_len;
  
      @{$self}{qw(last_len last_part offset)} = ($len, $i, $offset);
    }
  }
  
  sub is_multipart {1}
  
  sub new {
    my $self = shift->SUPER::new(@_);
    $self->on(read => \&_read);
    return $self;
  }
  
  sub _parse_multipart_body {
    my ($self, $boundary) = @_;
  
    # Whole part in buffer
    my $pos = index $self->{multipart}, "\x0d\x0a--$boundary";
    if ($pos < 0) {
      my $len = length($self->{multipart}) - (length($boundary) + 8);
      return undef unless $len > 0;
  
      # Store chunk
      my $chunk = substr $self->{multipart}, 0, $len, '';
      $self->parts->[-1] = $self->parts->[-1]->parse($chunk);
      return undef;
    }
  
    # Store chunk
    my $chunk = substr $self->{multipart}, 0, $pos, '';
    $self->parts->[-1] = $self->parts->[-1]->parse($chunk);
    return !!($self->{multi_state} = 'multipart_boundary');
  }
  
  sub _parse_multipart_boundary {
    my ($self, $boundary) = @_;
  
    # Boundary begins
    if ((index $self->{multipart}, "\x0d\x0a--$boundary\x0d\x0a") == 0) {
      substr $self->{multipart}, 0, length($boundary) + 6, '';
  
      # New part
      my $part = Mojo::Content::Single->new(relaxed => 1);
      $self->emit(part => $part);
      push @{$self->parts}, $part;
      return !!($self->{multi_state} = 'multipart_body');
    }
  
    # Boundary ends
    my $end = "\x0d\x0a--$boundary--";
    if ((index $self->{multipart}, $end) == 0) {
      substr $self->{multipart}, 0, length $end, '';
      $self->{multi_state} = 'finished';
    }
  
    return undef;
  }
  
  sub _parse_multipart_preamble {
    my ($self, $boundary) = @_;
  
    # No boundary yet
    return undef if (my $pos = index $self->{multipart}, "--$boundary") < 0;
  
    # Replace preamble with carriage return and line feed
    substr $self->{multipart}, 0, $pos, "\x0d\x0a";
  
    # Parse boundary
    return !!($self->{multi_state} = 'multipart_boundary');
  }
  
  sub _read {
    my ($self, $chunk) = @_;
  
    $self->{multipart} .= $chunk;
    my $boundary = $self->boundary;
    until (($self->{multi_state} //= 'multipart_preamble') eq 'finished') {
  
      # Preamble
      if ($self->{multi_state} eq 'multipart_preamble') {
        last unless $self->_parse_multipart_preamble($boundary);
      }
  
      # Boundary
      elsif ($self->{multi_state} eq 'multipart_boundary') {
        last unless $self->_parse_multipart_boundary($boundary);
      }
  
      # Body
      elsif ($self->{multi_state} eq 'multipart_body') {
        last unless $self->_parse_multipart_body($boundary);
      }
    }
  
    # Check buffer size
    @$self{qw(state limit)} = ('finished', 1)
      if length($self->{multipart} // '') > $self->max_buffer_size;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Content::MultiPart - HTTP multipart content
  
  =head1 SYNOPSIS
  
    use Mojo::Content::MultiPart;
  
    my $multi = Mojo::Content::MultiPart->new;
    $multi->parse('Content-Type: multipart/mixed; boundary=---foobar');
    my $single = $multi->parts->[4];
  
  =head1 DESCRIPTION
  
  L<Mojo::Content::MultiPart> is a container for HTTP multipart content, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230>,
  L<RFC 7231|http://tools.ietf.org/html/rfc7231> and
  L<RFC 2388|http://tools.ietf.org/html/rfc2388>.
  
  =head1 EVENTS
  
  L<Mojo::Content::Multipart> inherits all events from L<Mojo::Content> and can
  emit the following new ones.
  
  =head2 part
  
    $multi->on(part => sub {
      my ($multi, $single) = @_;
      ...
    });
  
  Emitted when a new L<Mojo::Content::Single> part starts.
  
    $multi->on(part => sub {
      my ($multi, $single) = @_;
      return unless $single->headers->content_disposition =~ /name="([^"]+)"/;
      say "Field: $1";
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Content::MultiPart> inherits all attributes from L<Mojo::Content> and
  implements the following new ones.
  
  =head2 parts
  
    my $parts = $multi->parts;
    $multi    = $multi->parts([Mojo::Content::Single->new]);
  
  Content parts embedded in this multipart content, usually
  L<Mojo::Content::Single> objects.
  
  =head1 METHODS
  
  L<Mojo::Content::MultiPart> inherits all methods from L<Mojo::Content> and
  implements the following new ones.
  
  =head2 body_contains
  
    my $bool = $multi->body_contains('foobarbaz');
  
  Check if content parts contain a specific string.
  
  =head2 body_size
  
    my $size = $multi->body_size;
  
  Content size in bytes.
  
  =head2 build_boundary
  
    my $boundary = $multi->build_boundary;
  
  Generate a suitable boundary for content and add it to C<Content-Type> header.
  
  =head2 clone
  
    my $clone = $multi->clone;
  
  Return a new L<Mojo::Content::MultiPart> object cloned from this content if
  possible, otherwise return C<undef>.
  
  =head2 get_body_chunk
  
    my $bytes = $multi->get_body_chunk(0);
  
  Get a chunk of content starting from a specific position. Note that it might
  not be possible to get the same chunk twice if content was generated
  dynamically.
  
  =head2 is_multipart
  
    my $bool = $multi->is_multipart;
  
  True, this is a L<Mojo::Content::MultiPart> object.
  
  =head2 new
  
    my $multi = Mojo::Content::MultiPart->new;
    my $multi
      = Mojo::Content::MultiPart->new(parts => [Mojo::Content::Single->new]);
    my $multi
      = Mojo::Content::MultiPart->new({parts => [Mojo::Content::Single->new]});
  
  Construct a new L<Mojo::Content::MultiPart> object and subscribe to L</"read">
  event with default content parser.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_CONTENT_MULTIPART

$fatpacked{"Mojo/Content/Single.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_CONTENT_SINGLE';
  package Mojo::Content::Single;
  use Mojo::Base 'Mojo::Content';
  
  use Mojo::Asset::Memory;
  use Mojo::Content::MultiPart;
  
  has asset => sub { Mojo::Asset::Memory->new(auto_upgrade => 1) };
  has auto_upgrade => 1;
  
  sub body_contains { shift->asset->contains(shift) >= 0 }
  
  sub body_size {
    my $self = shift;
    return ($self->headers->content_length || 0) if $self->is_dynamic;
    return $self->{body_size} //= $self->asset->size;
  }
  
  sub clone {
    my $self = shift;
    return undef unless my $clone = $self->SUPER::clone();
    return $clone->asset($self->asset);
  }
  
  sub get_body_chunk {
    my ($self, $offset) = @_;
    return $self->generate_body_chunk($offset) if $self->is_dynamic;
    return $self->asset->get_chunk($offset);
  }
  
  sub new {
    my $self = shift->SUPER::new(@_);
    $self->{read}
      = $self->on(read => sub { $_[0]->asset($_[0]->asset->add_chunk($_[1])) });
    return $self;
  }
  
  sub parse {
    my $self = shift;
  
    # Parse headers
    $self->_parse_until_body(@_);
  
    # Parse body
    return $self->SUPER::parse
      unless $self->auto_upgrade && defined $self->boundary;
  
    # Content needs to be upgraded to multipart
    $self->unsubscribe(read => $self->{read});
    my $multi = Mojo::Content::MultiPart->new(%$self);
    $self->emit(upgrade => $multi);
    return $multi->parse;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Content::Single - HTTP content
  
  =head1 SYNOPSIS
  
    use Mojo::Content::Single;
  
    my $single = Mojo::Content::Single->new;
    $single->parse("Content-Length: 12\x0d\x0a\x0d\x0aHello World!");
    say $single->headers->content_length;
  
  =head1 DESCRIPTION
  
  L<Mojo::Content::Single> is a container for HTTP content, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230> and
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>.
  
  =head1 EVENTS
  
  L<Mojo::Content::Single> inherits all events from L<Mojo::Content> and can emit
  the following new ones.
  
  =head2 upgrade
  
    $single->on(upgrade => sub {
      my ($single, $multi) = @_;
      ...
    });
  
  Emitted when content gets upgraded to a L<Mojo::Content::MultiPart> object.
  
    $single->on(upgrade => sub {
      my ($single, $multi) = @_;
      return unless $multi->headers->content_type =~ /multipart\/([^;]+)/i;
      say "Multipart: $1";
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Content::Single> inherits all attributes from L<Mojo::Content> and
  implements the following new ones.
  
  =head2 asset
  
    my $asset = $single->asset;
    $single   = $single->asset(Mojo::Asset::Memory->new);
  
  The actual content, defaults to a L<Mojo::Asset::Memory> object with
  L<Mojo::Asset::Memory/"auto_upgrade"> enabled.
  
  =head2 auto_upgrade
  
    my $bool = $single->auto_upgrade;
    $single  = $single->auto_upgrade($bool);
  
  Try to detect multipart content and automatically upgrade to a
  L<Mojo::Content::MultiPart> object, defaults to a true value.
  
  =head1 METHODS
  
  L<Mojo::Content::Single> inherits all methods from L<Mojo::Content> and
  implements the following new ones.
  
  =head2 body_contains
  
    my $bool = $single->body_contains('1234567');
  
  Check if content contains a specific string.
  
  =head2 body_size
  
    my $size = $single->body_size;
  
  Content size in bytes.
  
  =head2 clone
  
    my $clone = $single->clone;
  
  Return a new L<Mojo::Content::Single> object cloned from this content if
  possible, otherwise return C<undef>.
  
  =head2 get_body_chunk
  
    my $bytes = $single->get_body_chunk(0);
  
  Get a chunk of content starting from a specific position. Note that it might
  not be possible to get the same chunk twice if content was generated
  dynamically.
  
  =head2 new
  
    my $single = Mojo::Content::Single->new;
    my $single = Mojo::Content::Single->new(asset => Mojo::Asset::File->new);
    my $single = Mojo::Content::Single->new({asset => Mojo::Asset::File->new});
  
  Construct a new L<Mojo::Content::Single> object and subscribe to L</"read">
  event with default content parser.
  
  =head2 parse
  
    $single = $single->parse("Content-Length: 12\x0d\x0a\x0d\x0aHello World!");
    my $multi
      = $single->parse("Content-Type: multipart/form-data\x0d\x0a\x0d\x0a");
  
  Parse content chunk and upgrade to L<Mojo::Content::MultiPart> object if
  necessary.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_CONTENT_SINGLE

$fatpacked{"Mojo/Cookie.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_COOKIE';
  package Mojo::Cookie;
  use Mojo::Base -base;
  use overload bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;
  
  use Carp 'croak';
  
  has [qw(name value)];
  
  sub parse     { croak 'Method "parse" not implemented by subclass' }
  sub to_string { croak 'Method "to_string" not implemented by subclass' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Cookie - HTTP cookie base class
  
  =head1 SYNOPSIS
  
    package Mojo::Cookie::MyCookie;
    use Mojo::Base 'Mojo::Cookie';
  
    sub parse     {...}
    sub to_string {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Cookie> is an abstract base class for HTTP cookie containers, based on
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>, like L<Mojo::Cookie::Request>
  and L<Mojo::Cookie::Response>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Cookie> implements the following attributes.
  
  =head2 name
  
    my $name = $cookie->name;
    $cookie  = $cookie->name('foo');
  
  Cookie name.
  
  =head2 value
  
    my $value = $cookie->value;
    $cookie   = $cookie->value('/test');
  
  Cookie value.
  
  =head1 METHODS
  
  L<Mojo::Cookie> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 parse
  
    my $cookies = $cookie->parse($str);
  
  Parse cookies. Meant to be overloaded in a subclass.
  
  =head2 to_string
  
    my $str = $cookie->to_string;
  
  Render cookie. Meant to be overloaded in a subclass.
  
  =head1 OPERATORS
  
  L<Mojo::Cookie> overloads the following operators.
  
  =head2 bool
  
    my $bool = !!$cookie;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$cookie";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_COOKIE

$fatpacked{"Mojo/Cookie/Request.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_COOKIE_REQUEST';
  package Mojo::Cookie::Request;
  use Mojo::Base 'Mojo::Cookie';
  
  use Mojo::Util qw(quote split_header);
  
  sub parse {
    my ($self, $str) = @_;
  
    my @cookies;
    my @pairs = map {@$_} @{split_header $str // ''};
    while (my ($name, $value) = splice @pairs, 0, 2) {
      next if $name =~ /^\$/;
      push @cookies, $self->new(name => $name, value => $value // '');
    }
  
    return \@cookies;
  }
  
  sub to_string {
    my $self = shift;
    return '' unless length(my $name = $self->name // '');
    my $value = $self->value // '';
    return join '=', $name, $value =~ /[,;" ]/ ? quote $value : $value;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Cookie::Request - HTTP request cookie
  
  =head1 SYNOPSIS
  
    use Mojo::Cookie::Request;
  
    my $cookie = Mojo::Cookie::Request->new;
    $cookie->name('foo');
    $cookie->value('bar');
    say "$cookie";
  
  =head1 DESCRIPTION
  
  L<Mojo::Cookie::Request> is a container for HTTP request cookies, based on
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Cookie::Request> inherits all attributes from L<Mojo::Cookie>.
  
  =head1 METHODS
  
  L<Mojo::Cookie::Request> inherits all methods from L<Mojo::Cookie> and
  implements the following new ones.
  
  =head2 parse
  
    my $cookies = Mojo::Cookie::Request->parse('f=b; g=a');
  
  Parse cookies.
  
  =head2 to_string
  
    my $str = $cookie->to_string;
  
  Render cookie.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_COOKIE_REQUEST

$fatpacked{"Mojo/Cookie/Response.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_COOKIE_RESPONSE';
  package Mojo::Cookie::Response;
  use Mojo::Base 'Mojo::Cookie';
  
  use Mojo::Date;
  use Mojo::Util qw(quote split_cookie_header);
  
  has [qw(domain expires host_only httponly max_age path secure)];
  
  my %ATTRS = map { $_ => 1 } qw(domain expires httponly max-age path secure);
  
  sub parse {
    my ($self, $str) = @_;
  
    my @cookies;
    my $tree = split_cookie_header $str // '';
    while (my $pairs = shift @$tree) {
      my ($name, $value) = splice @$pairs, 0, 2;
      push @cookies, $self->new(name => $name, value => $value // '');
  
      while (my ($name, $value) = splice @$pairs, 0, 2) {
        next unless $ATTRS{my $attr = lc $name};
        $value =~ s/^\.// if $attr eq 'domain' && defined $value;
        $value = Mojo::Date->new($value // '')->epoch if $attr eq 'expires';
        $value = 1 if $attr eq 'secure' || $attr eq 'httponly';
        $cookies[-1]{$attr eq 'max-age' ? 'max_age' : $attr} = $value;
      }
    }
  
    return \@cookies;
  }
  
  sub to_string {
    my $self = shift;
  
    # Name and value
    return '' unless length(my $name = $self->name // '');
    my $value = $self->value // '';
    my $cookie = join '=', $name, $value =~ /[,;" ]/ ? quote $value : $value;
  
    # "expires"
    my $expires = $self->expires;
    $cookie .= '; expires=' . Mojo::Date->new($expires) if defined $expires;
  
    # "domain"
    if (my $domain = $self->domain) { $cookie .= "; domain=$domain" }
  
    # "path"
    if (my $path = $self->path) { $cookie .= "; path=$path" }
  
    # "secure"
    $cookie .= "; secure" if $self->secure;
  
    # "HttpOnly"
    $cookie .= "; HttpOnly" if $self->httponly;
  
    # "Max-Age"
    if (defined(my $max = $self->max_age)) { $cookie .= "; Max-Age=$max" }
  
    return $cookie;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Cookie::Response - HTTP response cookie
  
  =head1 SYNOPSIS
  
    use Mojo::Cookie::Response;
  
    my $cookie = Mojo::Cookie::Response->new;
    $cookie->name('foo');
    $cookie->value('bar');
    say "$cookie";
  
  =head1 DESCRIPTION
  
  L<Mojo::Cookie::Response> is a container for HTTP response cookies, based on
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Cookie::Response> inherits all attributes from L<Mojo::Cookie> and
  implements the following new ones.
  
  =head2 domain
  
    my $domain = $cookie->domain;
    $cookie    = $cookie->domain('localhost');
  
  Cookie domain.
  
  =head2 expires
  
    my $expires = $cookie->expires;
    $cookie     = $cookie->expires(time + 60);
  
  Expiration for cookie.
  
  =head2 host_only
  
    my $bool = $cookie->host_only;
    $cookie  = $cookie->host_only($bool);
  
  Host-only flag, indicating that the canonicalized request-host is identical to
  the cookie's L</"domain">.
  
  =head2 httponly
  
    my $bool = $cookie->httponly;
    $cookie  = $cookie->httponly($bool);
  
  HttpOnly flag, which can prevent client-side scripts from accessing this
  cookie.
  
  =head2 max_age
  
    my $max_age = $cookie->max_age;
    $cookie     = $cookie->max_age(60);
  
  Max age for cookie.
  
  =head2 path
  
    my $path = $cookie->path;
    $cookie  = $cookie->path('/test');
  
  Cookie path.
  
  =head2 secure
  
    my $bool = $cookie->secure;
    $cookie  = $cookie->secure($bool);
  
  Secure flag, which instructs browsers to only send this cookie over HTTPS
  connections.
  
  =head1 METHODS
  
  L<Mojo::Cookie::Response> inherits all methods from L<Mojo::Cookie> and
  implements the following new ones.
  
  =head2 parse
  
    my $cookies = Mojo::Cookie::Response->parse('f=b; path=/');
  
  Parse cookies.
  
  =head2 to_string
  
    my $str = $cookie->to_string;
  
  Render cookie.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_COOKIE_RESPONSE

$fatpacked{"Mojo/DOM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_DOM';
  package Mojo::DOM;
  use Mojo::Base -strict;
  use overload
    '@{}'    => sub { shift->child_nodes },
    '%{}'    => sub { shift->attr },
    bool     => sub {1},
    '""'     => sub { shift->to_string },
    fallback => 1;
  
  # "Fry: This snow is beautiful. I'm glad global warming never happened.
  #  Leela: Actually, it did. But thank God nuclear winter canceled it out."
  use Mojo::Collection;
  use Mojo::DOM::CSS;
  use Mojo::DOM::HTML;
  use Scalar::Util qw(blessed weaken);
  use Storable 'dclone';
  
  sub all_text { _text(_nodes(shift->tree), 1) }
  
  sub ancestors { _select($_[0]->_collect([_ancestors($_[0]->tree)]), $_[1]) }
  
  sub append { shift->_add(1, @_) }
  sub append_content { shift->_content(1, 0, @_) }
  
  sub at {
    my $self = shift;
    return undef unless my $result = $self->_css->select_one(@_);
    return $self->_build($result, $self->xml);
  }
  
  sub attr {
    my $self = shift;
  
    # Hash
    my $tree = $self->tree;
    my $attrs = $tree->[0] ne 'tag' ? {} : $tree->[2];
    return $attrs unless @_;
  
    # Get
    return $attrs->{$_[0]} unless @_ > 1 || ref $_[0];
  
    # Set
    my $values = ref $_[0] ? $_[0] : {@_};
    @$attrs{keys %$values} = values %$values;
  
    return $self;
  }
  
  sub child_nodes { $_[0]->_collect(_nodes($_[0]->tree)) }
  
  sub children { _select($_[0]->_collect(_nodes($_[0]->tree, 1)), $_[1]) }
  
  sub content {
    my $self = shift;
  
    my $type = $self->type;
    if ($type eq 'root' || $type eq 'tag') {
      return $self->_content(0, 1, @_) if @_;
      my $html = Mojo::DOM::HTML->new(xml => $self->xml);
      return join '', map { $html->tree($_)->render } @{_nodes($self->tree)};
    }
  
    return $self->tree->[1] unless @_;
    $self->tree->[1] = shift;
    return $self;
  }
  
  sub descendant_nodes { $_[0]->_collect(_all(_nodes($_[0]->tree))) }
  
  sub find {
    my $self = shift;
    return $self->_collect($self->_css->select(@_));
  }
  
  sub following { _select($_[0]->_collect(_siblings($_[0]->tree, 1, 1)), $_[1]) }
  sub following_nodes { $_[0]->_collect(_siblings($_[0]->tree, 0, 1)) }
  
  sub matches { shift->_css->matches(@_) }
  
  sub namespace {
    my $self = shift;
  
    return undef if (my $tree = $self->tree)->[0] ne 'tag';
  
    # Extract namespace prefix and search parents
    my $ns = $tree->[1] =~ /^(.*?):/ ? "xmlns:$1" : undef;
    for my $node ($tree, _ancestors($tree)) {
  
      # Namespace for prefix
      my $attrs = $node->[2];
      if ($ns) { $_ eq $ns and return $attrs->{$_} for keys %$attrs }
  
      # Namespace attribute
      elsif (defined $attrs->{xmlns}) { return $attrs->{xmlns} }
    }
  
    return undef;
  }
  
  sub new {
    my $class = shift;
    my $self = bless \Mojo::DOM::HTML->new, ref $class || $class;
    return @_ ? $self->parse(@_) : $self;
  }
  
  sub new_tag {
    my $self = shift;
    my $new  = $self->new;
    $$new->tag(@_);
    $$new->xml($$self->xml) if ref $self;
    return $new;
  }
  
  sub next      { $_[0]->_maybe(_siblings($_[0]->tree, 1, 1, 0)) }
  sub next_node { $_[0]->_maybe(_siblings($_[0]->tree, 0, 1, 0)) }
  
  sub parent {
    my $self = shift;
    return undef if (my $tree = $self->tree)->[0] eq 'root';
    return $self->_build(_parent($tree), $self->xml);
  }
  
  sub parse { ${$_[0]}->parse($_[1]) and return $_[0] }
  
  sub preceding { _select($_[0]->_collect(_siblings($_[0]->tree, 1, 0)), $_[1]) }
  sub preceding_nodes { $_[0]->_collect(_siblings($_[0]->tree, 0)) }
  
  sub prepend { shift->_add(0, @_) }
  sub prepend_content { shift->_content(0, 0, @_) }
  
  sub previous      { $_[0]->_maybe(_siblings($_[0]->tree, 1, 0, -1)) }
  sub previous_node { $_[0]->_maybe(_siblings($_[0]->tree, 0, 0, -1)) }
  
  sub remove { shift->replace('') }
  
  sub replace {
    my ($self, $new) = @_;
    return $self->parse($new) if (my $tree = $self->tree)->[0] eq 'root';
    return $self->_replace(_parent($tree), $tree, _nodes($self->_parse($new)));
  }
  
  sub root {
    my $self = shift;
    return $self unless my $tree = _ancestors($self->tree, 1);
    return $self->_build($tree, $self->xml);
  }
  
  sub selector {
    return undef unless (my $tree = shift->tree)->[0] eq 'tag';
    return join ' > ',
      reverse map { $_->[1] . ':nth-child(' . (@{_siblings($_, 1)} + 1) . ')' }
      $tree, _ancestors($tree);
  }
  
  sub strip {
    my $self = shift;
    return $self if (my $tree = $self->tree)->[0] ne 'tag';
    return $self->_replace($tree->[3], $tree, _nodes($tree));
  }
  
  sub tag {
    my ($self, $tag) = @_;
    return undef if (my $tree = $self->tree)->[0] ne 'tag';
    return $tree->[1] unless $tag;
    $tree->[1] = $tag;
    return $self;
  }
  
  sub tap { shift->Mojo::Base::tap(@_) }
  
  sub text { _text(_nodes(shift->tree), 0) }
  
  sub to_string { ${shift()}->render }
  
  sub tree { @_ > 1 ? (${$_[0]}->tree($_[1]) and return $_[0]) : ${$_[0]}->tree }
  
  sub type { shift->tree->[0] }
  
  sub val {
    my $self = shift;
  
    # "option"
    return $self->{value} // $self->text if (my $tag = $self->tag) eq 'option';
  
    # "input" ("type=checkbox" and "type=radio")
    my $type = $self->{type} // '';
    return $self->{value} // 'on'
      if $tag eq 'input' && ($type eq 'radio' || $type eq 'checkbox');
  
    # "textarea", "input" or "button"
    return $tag eq 'textarea' ? $self->text : $self->{value} if $tag ne 'select';
  
    # "select"
    my $v = $self->find('option:checked:not([disabled])')
      ->grep(sub { !$_->ancestors('optgroup[disabled]')->size })->map('val');
    return exists $self->{multiple} ? $v->size ? $v->to_array : undef : $v->last;
  }
  
  sub with_roles { shift->Mojo::Base::with_roles(@_) }
  
  sub wrap         { shift->_wrap(0, @_) }
  sub wrap_content { shift->_wrap(1, @_) }
  
  sub xml { @_ > 1 ? (${$_[0]}->xml($_[1]) and return $_[0]) : ${$_[0]}->xml }
  
  sub _add {
    my ($self, $offset, $new) = @_;
  
    return $self if (my $tree = $self->tree)->[0] eq 'root';
  
    my $parent = _parent($tree);
    splice @$parent, _offset($parent, $tree) + $offset, 0,
      @{_link($parent, _nodes($self->_parse($new)))};
  
    return $self;
  }
  
  sub _all {
    my $nodes = shift;
    @$nodes = map { $_->[0] eq 'tag' ? ($_, @{_all(_nodes($_))}) : ($_) } @$nodes;
    return $nodes;
  }
  
  sub _ancestors {
    my ($tree, $root) = @_;
  
    return () unless $tree = _parent($tree);
    my @ancestors;
    do { push @ancestors, $tree }
      while ($tree->[0] eq 'tag') && ($tree = $tree->[3]);
    return $root ? $ancestors[-1] : @ancestors[0 .. $#ancestors - 1];
  }
  
  sub _build { shift->new->tree(shift)->xml(shift) }
  
  sub _collect {
    my ($self, $nodes) = (shift, shift // []);
    my $xml = $self->xml;
    return Mojo::Collection->new(map { $self->_build($_, $xml) } @$nodes);
  }
  
  sub _content {
    my ($self, $start, $offset, $new) = @_;
  
    my $tree = $self->tree;
    unless ($tree->[0] eq 'root' || $tree->[0] eq 'tag') {
      my $old = $self->content;
      return $self->content($start ? $old . $new : $new . $old);
    }
  
    $start  = $start  ? ($#$tree + 1) : _start($tree);
    $offset = $offset ? $#$tree       : 0;
    splice @$tree, $start, $offset, @{_link($tree, _nodes($self->_parse($new)))};
  
    return $self;
  }
  
  sub _css { Mojo::DOM::CSS->new(tree => shift->tree) }
  
  sub _fragment { _link(my $r = ['root', @_], [@_]); $r }
  
  sub _link {
    my ($parent, $children) = @_;
  
    # Link parent to children
    for my $node (@$children) {
      my $offset = $node->[0] eq 'tag' ? 3 : 2;
      $node->[$offset] = $parent;
      weaken $node->[$offset];
    }
  
    return $children;
  }
  
  sub _maybe { $_[1] ? $_[0]->_build($_[1], $_[0]->xml) : undef }
  
  sub _nodes {
    return () unless my $tree = shift;
    my @nodes = @$tree[_start($tree) .. $#$tree];
    return shift() ? [grep { $_->[0] eq 'tag' } @nodes] : \@nodes;
  }
  
  sub _offset {
    my ($parent, $child) = @_;
    my $i = _start($parent);
    $_ eq $child ? last : $i++ for @$parent[$i .. $#$parent];
    return $i;
  }
  
  sub _parent { $_[0]->[$_[0][0] eq 'tag' ? 3 : 2] }
  
  sub _parse {
    my ($self, $input) = @_;
    return Mojo::DOM::HTML->new(xml => $self->xml)->parse($input)->tree
      unless blessed $input && $input->isa('Mojo::DOM');
    my $tree = dclone $input->tree;
    return $tree->[0] eq 'root' ? $tree : _fragment($tree);
  }
  
  sub _replace {
    my ($self, $parent, $child, $nodes) = @_;
    splice @$parent, _offset($parent, $child), 1, @{_link($parent, $nodes)};
    return $self->parent;
  }
  
  sub _select { $_[1] ? $_[0]->grep(matches => $_[1]) : $_[0] }
  
  sub _siblings {
    my ($tree, $tags, $tail, $i) = @_;
  
    return defined $i ? undef : [] if $tree->[0] eq 'root';
  
    my $nodes = _nodes(_parent($tree));
    my $match = -1;
    defined($match++) and $_ eq $tree and last for @$nodes;
  
    if ($tail) { splice @$nodes, 0, $match + 1 }
    else       { splice @$nodes, $match, ($#$nodes + 1) - $match }
  
    @$nodes = grep { $_->[0] eq 'tag' } @$nodes if $tags;
  
    return defined $i ? $i == -1 && !@$nodes ? undef : $nodes->[$i] : $nodes;
  }
  
  sub _start { $_[0][0] eq 'root' ? 1 : 4 }
  
  sub _text {
    my ($nodes, $all) = @_;
  
    my $text = '';
    while (my $node = shift @$nodes) {
      my $type = $node->[0];
  
      # Text
      if ($type eq 'text' || $type eq 'cdata' || $type eq 'raw') {
        $text .= $node->[1];
      }
  
      # Nested tag
      elsif ($type eq 'tag' && $all) { unshift @$nodes, @{_nodes($node)} }
    }
  
    return $text;
  }
  
  sub _wrap {
    my ($self, $content, $new) = @_;
  
    return $self if (my $tree = $self->tree)->[0] eq 'root' && !$content;
    return $self if $tree->[0] ne 'root' && $tree->[0] ne 'tag' && $content;
  
    # Find innermost tag
    my $current;
    my $first = $new = $self->_parse($new);
    $current = $first while $first = _nodes($first, 1)->[0];
    return $self unless $current;
  
    # Wrap content
    if ($content) {
      push @$current, @{_link($current, _nodes($tree))};
      splice @$tree, _start($tree), $#$tree, @{_link($tree, _nodes($new))};
      return $self;
    }
  
    # Wrap element
    $self->_replace(_parent($tree), $tree, _nodes($new));
    push @$current, @{_link($current, [$tree])};
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::DOM - Minimalistic HTML/XML DOM parser with CSS selectors
  
  =head1 SYNOPSIS
  
    use Mojo::DOM;
  
    # Parse
    my $dom = Mojo::DOM->new('<div><p id="a">Test</p><p id="b">123</p></div>');
  
    # Find
    say $dom->at('#b')->text;
    say $dom->find('p')->map('text')->join("\n");
    say $dom->find('[id]')->map(attr => 'id')->join("\n");
  
    # Iterate
    $dom->find('p[id]')->reverse->each(sub { say $_->{id} });
  
    # Loop
    for my $e ($dom->find('p[id]')->each) {
      say $e->{id}, ':', $e->text;
    }
  
    # Modify
    $dom->find('div p')->last->append('<p id="c">456</p>');
    $dom->at('#c')->prepend($dom->new_tag('p', id => 'd', '789'));
    $dom->find(':not(p)')->map('strip');
  
    # Render
    say "$dom";
  
  =head1 DESCRIPTION
  
  L<Mojo::DOM> is a minimalistic and relaxed HTML/XML DOM parser with CSS
  selector support. It will even try to interpret broken HTML and XML, so you
  should not use it for validation.
  
  =head1 NODES AND ELEMENTS
  
  When we parse an HTML/XML fragment, it gets turned into a tree of nodes.
  
    <!DOCTYPE html>
    <html>
      <head><title>Hello</title></head>
      <body>World!</body>
    </html>
  
  There are currently eight different kinds of nodes, C<cdata>, C<comment>,
  C<doctype>, C<pi>, C<raw>, C<root>, C<tag> and C<text>. Elements are nodes of
  the type C<tag>.
  
    root
    |- doctype (html)
    +- tag (html)
       |- tag (head)
       |  +- tag (title)
       |     +- raw (Hello)
       +- tag (body)
          +- text (World!)
  
  While all node types are represented as L<Mojo::DOM> objects, some methods like
  L</"attr"> and L</"namespace"> only apply to elements.
  
  =head1 CASE-SENSITIVITY
  
  L<Mojo::DOM> defaults to HTML semantics, that means all tags and attribute
  names are lowercased and selectors need to be lowercase as well.
  
    # HTML semantics
    my $dom = Mojo::DOM->new('<P ID="greeting">Hi!</P>');
    say $dom->at('p[id]')->text;
  
  If an XML declaration is found, the parser will automatically switch into XML
  mode and everything becomes case-sensitive.
  
    # XML semantics
    my $dom = Mojo::DOM->new('<?xml version="1.0"?><P ID="greeting">Hi!</P>');
    say $dom->at('P[ID]')->text;
  
  HTML or XML semantics can also be forced with the L</"xml"> method.
  
    # Force HTML semantics
    my $dom = Mojo::DOM->new->xml(0)->parse('<P ID="greeting">Hi!</P>');
    say $dom->at('p[id]')->text;
  
    # Force XML semantics
    my $dom = Mojo::DOM->new->xml(1)->parse('<P ID="greeting">Hi!</P>');
    say $dom->at('P[ID]')->text;
  
  =head1 METHODS
  
  L<Mojo::DOM> implements the following methods.
  
  =head2 all_text
  
    my $text = $dom->all_text;
  
  Extract text content from all descendant nodes of this element.
  
    # "foo\nbarbaz\n"
    $dom->parse("<div>foo\n<p>bar</p>baz\n</div>")->at('div')->all_text;
  
  =head2 ancestors
  
    my $collection = $dom->ancestors;
    my $collection = $dom->ancestors('div ~ p');
  
  Find all ancestor elements of this node matching the CSS selector and return a
  L<Mojo::Collection> object containing these elements as L<Mojo::DOM> objects.
  All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # List tag names of ancestor elements
    say $dom->ancestors->map('tag')->join("\n");
  
  =head2 append
  
    $dom = $dom->append('<p>I  Mojolicious!</p>');
    $dom = $dom->append(Mojo::DOM->new);
  
  Append HTML/XML fragment to this node (for all node types other than C<root>).
  
    # "<div><h1>Test</h1><h2>123</h2></div>"
    $dom->parse('<div><h1>Test</h1></div>')
      ->at('h1')->append('<h2>123</h2>')->root;
  
    # "<p>Test 123</p>"
    $dom->parse('<p>Test</p>')->at('p')
      ->child_nodes->first->append(' 123')->root;
  
  =head2 append_content
  
    $dom = $dom->append_content('<p>I  Mojolicious!</p>');
    $dom = $dom->append_content(Mojo::DOM->new);
  
  Append HTML/XML fragment (for C<root> and C<tag> nodes) or raw content to this
  node's content.
  
    # "<div><h1>Test123</h1></div>"
    $dom->parse('<div><h1>Test</h1></div>')
      ->at('h1')->append_content('123')->root;
  
    # "<!-- Test 123 --><br>"
    $dom->parse('<!-- Test --><br>')
      ->child_nodes->first->append_content('123 ')->root;
  
    # "<p>Test<i>123</i></p>"
    $dom->parse('<p>Test</p>')->at('p')->append_content('<i>123</i>')->root;
  
  =head2 at
  
    my $result = $dom->at('div ~ p');
    my $result = $dom->at('svg|line', svg => 'http://www.w3.org/2000/svg');
  
  Find first descendant element of this element matching the CSS selector and
  return it as a L<Mojo::DOM> object, or C<undef> if none could be found. All
  selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # Find first element with "svg" namespace definition
    my $namespace = $dom->at('[xmlns\:svg]')->{'xmlns:svg'};
  
  Trailing key/value pairs can be used to declare xml namespace aliases.
  
    # "<rect />"
    $dom->parse('<svg xmlns="http://www.w3.org/2000/svg"><rect /></svg>')
      ->at('svg|rect', svg => 'http://www.w3.org/2000/svg');
  
  =head2 attr
  
    my $hash = $dom->attr;
    my $foo  = $dom->attr('foo');
    $dom     = $dom->attr({foo => 'bar'});
    $dom     = $dom->attr(foo => 'bar');
  
  This element's attributes.
  
    # Remove an attribute
    delete $dom->attr->{id};
  
    # Attribute without value
    $dom->attr(selected => undef);
  
    # List id attributes
    say $dom->find('*')->map(attr => 'id')->compact->join("\n");
  
  =head2 child_nodes
  
    my $collection = $dom->child_nodes;
  
  Return a L<Mojo::Collection> object containing all child nodes of this element
  as L<Mojo::DOM> objects.
  
    # "<p><b>123</b></p>"
    $dom->parse('<p>Test<b>123</b></p>')->at('p')->child_nodes->first->remove;
  
    # "<!DOCTYPE html>"
    $dom->parse('<!DOCTYPE html><b>123</b>')->child_nodes->first;
  
    # " Test "
    $dom->parse('<b>123</b><!-- Test -->')->child_nodes->last->content;
  
  =head2 children
  
    my $collection = $dom->children;
    my $collection = $dom->children('div ~ p');
  
  Find all child elements of this element matching the CSS selector and return a
  L<Mojo::Collection> object containing these elements as L<Mojo::DOM> objects.
  All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # Show tag name of random child element
    say $dom->children->shuffle->first->tag;
  
  =head2 content
  
    my $str = $dom->content;
    $dom    = $dom->content('<p>I  Mojolicious!</p>');
    $dom    = $dom->content(Mojo::DOM->new);
  
  Return this node's content or replace it with HTML/XML fragment (for C<root>
  and C<tag> nodes) or raw content.
  
    # "<b>Test</b>"
    $dom->parse('<div><b>Test</b></div>')->at('div')->content;
  
    # "<div><h1>123</h1></div>"
    $dom->parse('<div><h1>Test</h1></div>')->at('h1')->content('123')->root;
  
    # "<p><i>123</i></p>"
    $dom->parse('<p>Test</p>')->at('p')->content('<i>123</i>')->root;
  
    # "<div><h1></h1></div>"
    $dom->parse('<div><h1>Test</h1></div>')->at('h1')->content('')->root;
  
    # " Test "
    $dom->parse('<!-- Test --><br>')->child_nodes->first->content;
  
    # "<div><!-- 123 -->456</div>"
    $dom->parse('<div><!-- Test -->456</div>')
      ->at('div')->child_nodes->first->content(' 123 ')->root;
  
  =head2 descendant_nodes
  
    my $collection = $dom->descendant_nodes;
  
  Return a L<Mojo::Collection> object containing all descendant nodes of this
  element as L<Mojo::DOM> objects.
  
    # "<p><b>123</b></p>"
    $dom->parse('<p><!-- Test --><b>123<!-- 456 --></b></p>')
      ->descendant_nodes->grep(sub { $_->type eq 'comment' })
      ->map('remove')->first;
  
    # "<p><b>test</b>test</p>"
    $dom->parse('<p><b>123</b>456</p>')
      ->at('p')->descendant_nodes->grep(sub { $_->type eq 'text' })
      ->map(content => 'test')->first->root;
  
  =head2 find
  
    my $collection = $dom->find('div ~ p');
    my $collection = $dom->find('svg|line', svg => 'http://www.w3.org/2000/svg');
  
  Find all descendant elements of this element matching the CSS selector and
  return a L<Mojo::Collection> object containing these elements as L<Mojo::DOM>
  objects. All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # Find a specific element and extract information
    my $id = $dom->find('div')->[23]{id};
  
    # Extract information from multiple elements
    my @headers = $dom->find('h1, h2, h3')->map('text')->each;
  
    # Count all the different tags
    my $hash = $dom->find('*')->reduce(sub { $a->{$b->tag}++; $a }, {});
  
    # Find elements with a class that contains dots
    my @divs = $dom->find('div.foo\.bar')->each;
  
  Trailing key/value pairs can be used to declare xml namespace aliases.
  
    # "<rect />"
    $dom->parse('<svg xmlns="http://www.w3.org/2000/svg"><rect /></svg>')
      ->find('svg|rect', svg => 'http://www.w3.org/2000/svg')->first;
  
  =head2 following
  
    my $collection = $dom->following;
    my $collection = $dom->following('div ~ p');
  
  Find all sibling elements after this node matching the CSS selector and return
  a L<Mojo::Collection> object containing these elements as L<Mojo::DOM> objects.
  All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # List tags of sibling elements after this node
    say $dom->following->map('tag')->join("\n");
  
  =head2 following_nodes
  
    my $collection = $dom->following_nodes;
  
  Return a L<Mojo::Collection> object containing all sibling nodes after this
  node as L<Mojo::DOM> objects.
  
    # "C"
    $dom->parse('<p>A</p><!-- B -->C')->at('p')->following_nodes->last->content;
  
  =head2 matches
  
    my $bool = $dom->matches('div ~ p');
    my $bool = $dom->matches('svg|line', svg => 'http://www.w3.org/2000/svg');
  
  Check if this element matches the CSS selector. All selectors from
  L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # True
    $dom->parse('<p class="a">A</p>')->at('p')->matches('.a');
    $dom->parse('<p class="a">A</p>')->at('p')->matches('p[class]');
  
    # False
    $dom->parse('<p class="a">A</p>')->at('p')->matches('.b');
    $dom->parse('<p class="a">A</p>')->at('p')->matches('p[id]');
  
  Trailing key/value pairs can be used to declare xml namespace aliases.
  
    # True
    $dom->parse('<svg xmlns="http://www.w3.org/2000/svg"><rect /></svg>')
      ->matches('svg|rect', svg => 'http://www.w3.org/2000/svg');
  
  =head2 namespace
  
    my $namespace = $dom->namespace;
  
  Find this element's namespace, or return C<undef> if none could be found.
  
    # Find namespace for an element with namespace prefix
    my $namespace = $dom->at('svg > svg\:circle')->namespace;
  
    # Find namespace for an element that may or may not have a namespace prefix
    my $namespace = $dom->at('svg > circle')->namespace;
  
  =head2 new
  
    my $dom = Mojo::DOM->new;
    my $dom = Mojo::DOM->new('<foo bar="baz">I  Mojolicious!</foo>');
  
  Construct a new scalar-based L<Mojo::DOM> object and L</"parse"> HTML/XML
  fragment if necessary.
  
  =head2 new_tag
  
    my $tag = Mojo::DOM->new_tag('div');
    my $tag = $dom->new_tag('div');
    my $tag = $dom->new_tag('div', id => 'foo', hidden => undef);
    my $tag = $dom->new_tag('div', 'safe content');
    my $tag = $dom->new_tag('div', id => 'foo', 'safe content');
    my $tag = $dom->new_tag('div', data => {mojo => 'rocks'}, 'safe content');
    my $tag = $dom->new_tag('div', id => 'foo', sub { 'unsafe content' });
  
  Construct a new L<Mojo::DOM> object for an HTML/XML tag with or without
  attributes and content. The C<data> attribute may contain a hash reference with
  key/value pairs to generate attributes from.
  
    # "<br>"
    $dom->new_tag('br');
  
    # "<div></div>"
    $dom->new_tag('div');
  
    # "<div id="foo" hidden></div>"
    $dom->new_tag('div', id => 'foo', hidden => undef);
  
    # "<div>test &amp; 123</div>"
    $dom->new_tag('div', 'test & 123');
  
    # "<div id="foo">test &amp; 123</div>"
    $dom->new_tag('div', id => 'foo', 'test & 123');
  
    # "<div data-foo="1" data-bar="test">test &amp; 123</div>""
    $dom->new_tag('div', data => {foo => 1, Bar => 'test'}, 'test & 123');
  
    # "<div id="foo">test & 123</div>"
    $dom->new_tag('div', id => 'foo', sub { 'test & 123' });
  
    # "<div>Hello<b>Mojo!</b></div>"
    $dom->parse('<div>Hello</div>')->at('div')
      ->append_content($dom->new_tag('b', 'Mojo!'))->root;
  
  =head2 next
  
    my $sibling = $dom->next;
  
  Return L<Mojo::DOM> object for next sibling element, or C<undef> if there are no
  more siblings.
  
    # "<h2>123</h2>"
    $dom->parse('<div><h1>Test</h1><h2>123</h2></div>')->at('h1')->next;
  
  =head2 next_node
  
    my $sibling = $dom->next_node;
  
  Return L<Mojo::DOM> object for next sibling node, or C<undef> if there are no
  more siblings.
  
    # "456"
    $dom->parse('<p><b>123</b><!-- Test -->456</p>')
      ->at('b')->next_node->next_node;
  
    # " Test "
    $dom->parse('<p><b>123</b><!-- Test -->456</p>')
      ->at('b')->next_node->content;
  
  =head2 parent
  
    my $parent = $dom->parent;
  
  Return L<Mojo::DOM> object for parent of this node, or C<undef> if this node has
  no parent.
  
    # "<b><i>Test</i></b>"
    $dom->parse('<p><b><i>Test</i></b></p>')->at('i')->parent;
  
  =head2 parse
  
    $dom = $dom->parse('<foo bar="baz">I  Mojolicious!</foo>');
  
  Parse HTML/XML fragment with L<Mojo::DOM::HTML>.
  
    # Parse XML
    my $dom = Mojo::DOM->new->xml(1)->parse('<foo>I  Mojolicious!</foo>');
  
  =head2 preceding
  
    my $collection = $dom->preceding;
    my $collection = $dom->preceding('div ~ p');
  
  Find all sibling elements before this node matching the CSS selector and return
  a L<Mojo::Collection> object containing these elements as L<Mojo::DOM> objects.
  All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # List tags of sibling elements before this node
    say $dom->preceding->map('tag')->join("\n");
  
  =head2 preceding_nodes
  
    my $collection = $dom->preceding_nodes;
  
  Return a L<Mojo::Collection> object containing all sibling nodes before this
  node as L<Mojo::DOM> objects.
  
    # "A"
    $dom->parse('A<!-- B --><p>C</p>')->at('p')->preceding_nodes->first->content;
  
  =head2 prepend
  
    $dom = $dom->prepend('<p>I  Mojolicious!</p>');
    $dom = $dom->prepend(Mojo::DOM->new);
  
  Prepend HTML/XML fragment to this node (for all node types other than C<root>).
  
    # "<div><h1>Test</h1><h2>123</h2></div>"
    $dom->parse('<div><h2>123</h2></div>')
      ->at('h2')->prepend('<h1>Test</h1>')->root;
  
    # "<p>Test 123</p>"
    $dom->parse('<p>123</p>')
      ->at('p')->child_nodes->first->prepend('Test ')->root;
  
  =head2 prepend_content
  
    $dom = $dom->prepend_content('<p>I  Mojolicious!</p>');
    $dom = $dom->prepend_content(Mojo::DOM->new);
  
  Prepend HTML/XML fragment (for C<root> and C<tag> nodes) or raw content to this
  node's content.
  
    # "<div><h2>Test123</h2></div>"
    $dom->parse('<div><h2>123</h2></div>')
      ->at('h2')->prepend_content('Test')->root;
  
    # "<!-- Test 123 --><br>"
    $dom->parse('<!-- 123 --><br>')
      ->child_nodes->first->prepend_content(' Test')->root;
  
    # "<p><i>123</i>Test</p>"
    $dom->parse('<p>Test</p>')->at('p')->prepend_content('<i>123</i>')->root;
  
  =head2 previous
  
    my $sibling = $dom->previous;
  
  Return L<Mojo::DOM> object for previous sibling element, or C<undef> if there
  are no more siblings.
  
    # "<h1>Test</h1>"
    $dom->parse('<div><h1>Test</h1><h2>123</h2></div>')->at('h2')->previous;
  
  =head2 previous_node
  
    my $sibling = $dom->previous_node;
  
  Return L<Mojo::DOM> object for previous sibling node, or C<undef> if there are
  no more siblings.
  
    # "123"
    $dom->parse('<p>123<!-- Test --><b>456</b></p>')
      ->at('b')->previous_node->previous_node;
  
    # " Test "
    $dom->parse('<p>123<!-- Test --><b>456</b></p>')
      ->at('b')->previous_node->content;
  
  =head2 remove
  
    my $parent = $dom->remove;
  
  Remove this node and return L</"root"> (for C<root> nodes) or L</"parent">.
  
    # "<div></div>"
    $dom->parse('<div><h1>Test</h1></div>')->at('h1')->remove;
  
    # "<p><b>456</b></p>"
    $dom->parse('<p>123<b>456</b></p>')
      ->at('p')->child_nodes->first->remove->root;
  
  =head2 replace
  
    my $parent = $dom->replace('<div>I  Mojolicious!</div>');
    my $parent = $dom->replace(Mojo::DOM->new);
  
  Replace this node with HTML/XML fragment and return L</"root"> (for C<root>
  nodes) or L</"parent">.
  
    # "<div><h2>123</h2></div>"
    $dom->parse('<div><h1>Test</h1></div>')->at('h1')->replace('<h2>123</h2>');
  
    # "<p><b>123</b></p>"
    $dom->parse('<p>Test</p>')
      ->at('p')->child_nodes->[0]->replace('<b>123</b>')->root;
  
  =head2 root
  
    my $root = $dom->root;
  
  Return L<Mojo::DOM> object for C<root> node.
  
  =head2 selector
  
    my $selector = $dom->selector;
  
  Get a unique CSS selector for this element.
  
    # "ul:nth-child(1) > li:nth-child(2)"
    $dom->parse('<ul><li>Test</li><li>123</li></ul>')->find('li')->last->selector;
  
    # "p:nth-child(1) > b:nth-child(1) > i:nth-child(1)"
    $dom->parse('<p><b><i>Test</i></b></p>')->at('i')->selector;
  
  =head2 strip
  
    my $parent = $dom->strip;
  
  Remove this element while preserving its content and return L</"parent">.
  
    # "<div>Test</div>"
    $dom->parse('<div><h1>Test</h1></div>')->at('h1')->strip;
  
  =head2 tag
  
    my $tag = $dom->tag;
    $dom    = $dom->tag('div');
  
  This element's tag name.
  
    # List tag names of child elements
    say $dom->children->map('tag')->join("\n");
  
  =head2 tap
  
    $dom = $dom->tap(sub {...});
  
  Alias for L<Mojo::Base/"tap">.
  
  =head2 text
  
    my $text = $dom->text;
  
  Extract text content from this element only (not including child elements).
  
    # "bar"
    $dom->parse("<div>foo<p>bar</p>baz</div>")->at('p')->text;
  
    # "foo\nbaz\n"
    $dom->parse("<div>foo\n<p>bar</p>baz\n</div>")->at('div')->text;
  
  =head2 to_string
  
    my $str = $dom->to_string;
  
  Render this node and its content to HTML/XML.
  
    # "<b>Test</b>"
    $dom->parse('<div><b>Test</b></div>')->at('div b')->to_string;
  
  =head2 tree
  
    my $tree = $dom->tree;
    $dom     = $dom->tree(['root']);
  
  Document Object Model. Note that this structure should only be used very
  carefully since it is very dynamic.
  
  =head2 type
  
    my $type = $dom->type;
  
  This node's type, usually C<cdata>, C<comment>, C<doctype>, C<pi>, C<raw>,
  C<root>, C<tag> or C<text>.
  
    # "cdata"
    $dom->parse('<![CDATA[Test]]>')->child_nodes->first->type;
  
    # "comment"
    $dom->parse('<!-- Test -->')->child_nodes->first->type;
  
    # "doctype"
    $dom->parse('<!DOCTYPE html>')->child_nodes->first->type;
  
    # "pi"
    $dom->parse('<?xml version="1.0"?>')->child_nodes->first->type;
  
    # "raw"
    $dom->parse('<title>Test</title>')->at('title')->child_nodes->first->type;
  
    # "root"
    $dom->parse('<p>Test</p>')->type;
  
    # "tag"
    $dom->parse('<p>Test</p>')->at('p')->type;
  
    # "text"
    $dom->parse('<p>Test</p>')->at('p')->child_nodes->first->type;
  
  =head2 val
  
    my $value = $dom->val;
  
  Extract value from form element (such as C<button>, C<input>, C<option>,
  C<select> and C<textarea>), or return C<undef> if this element has no value. In
  the case of C<select> with C<multiple> attribute, find C<option> elements with
  C<selected> attribute and return an array reference with all values, or C<undef>
  if none could be found.
  
    # "a"
    $dom->parse('<input name=test value=a>')->at('input')->val;
  
    # "b"
    $dom->parse('<textarea>b</textarea>')->at('textarea')->val;
  
    # "c"
    $dom->parse('<option value="c">Test</option>')->at('option')->val;
  
    # "d"
    $dom->parse('<select><option selected>d</option></select>')
      ->at('select')->val;
  
    # "e"
    $dom->parse('<select multiple><option selected>e</option></select>')
      ->at('select')->val->[0];
  
    # "on"
    $dom->parse('<input name=test type=checkbox>')->at('input')->val;
  
  =head2 with_roles
  
    my $new_class = Mojo::DOM->with_roles('Mojo::DOM::Role::One');
    my $new_class = Mojo::DOM->with_roles('+One', '+Two');
    $dom          = $dom->with_roles('+One', '+Two');
  
  Alias for L<Mojo::Base/"with_roles">.
  
  =head2 wrap
  
    $dom = $dom->wrap('<div></div>');
    $dom = $dom->wrap(Mojo::DOM->new);
  
  Wrap HTML/XML fragment around this node (for all node types other than C<root>),
  placing it as the last child of the first innermost element.
  
    # "<p>123<b>Test</b></p>"
    $dom->parse('<b>Test</b>')->at('b')->wrap('<p>123</p>')->root;
  
    # "<div><p><b>Test</b></p>123</div>"
    $dom->parse('<b>Test</b>')->at('b')->wrap('<div><p></p>123</div>')->root;
  
    # "<p><b>Test</b></p><p>123</p>"
    $dom->parse('<b>Test</b>')->at('b')->wrap('<p></p><p>123</p>')->root;
  
    # "<p><b>Test</b></p>"
    $dom->parse('<p>Test</p>')->at('p')->child_nodes->first->wrap('<b>')->root;
  
  =head2 wrap_content
  
    $dom = $dom->wrap_content('<div></div>');
    $dom = $dom->wrap_content(Mojo::DOM->new);
  
  Wrap HTML/XML fragment around this node's content (for C<root> and C<tag>
  nodes), placing it as the last children of the first innermost element.
  
    # "<p><b>123Test</b></p>"
    $dom->parse('<p>Test<p>')->at('p')->wrap_content('<b>123</b>')->root;
  
    # "<p><b>Test</b></p><p>123</p>"
    $dom->parse('<b>Test</b>')->wrap_content('<p></p><p>123</p>');
  
  =head2 xml
  
    my $bool = $dom->xml;
    $dom     = $dom->xml($bool);
  
  Disable HTML semantics in parser and activate case-sensitivity, defaults to
  auto-detection based on XML declarations.
  
  =head1 OPERATORS
  
  L<Mojo::DOM> overloads the following operators.
  
  =head2 array
  
    my @nodes = @$dom;
  
  Alias for L</"child_nodes">.
  
    # "<!-- Test -->"
    $dom->parse('<!-- Test --><b>123</b>')->[0];
  
  =head2 bool
  
    my $bool = !!$dom;
  
  Always true.
  
  =head2 hash
  
    my %attrs = %$dom;
  
  Alias for L</"attr">.
  
    # "test"
    $dom->parse('<div id="test">Test</div>')->at('div')->{id};
  
  =head2 stringify
  
    my $str = "$dom";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_DOM

$fatpacked{"Mojo/DOM/CSS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_DOM_CSS';
  package Mojo::DOM::CSS;
  use Mojo::Base -base;
  
  use Mojo::Util 'trim';
  
  has 'tree';
  
  my $ESCAPE_RE = qr/\\[^0-9a-fA-F]|\\[0-9a-fA-F]{1,6}/;
  my $ATTR_RE   = qr/
    \[
    ((?:$ESCAPE_RE|[\w\-])+)                              # Key
    (?:
      (\W)?=                                              # Operator
      (?:"((?:\\"|[^"])*)"|'((?:\\'|[^'])*)'|([^\]]+?))   # Value
      (?:\s+(i))?                                         # Case-sensitivity
    )?
    \]
  /x;
  
  sub matches {
    my $tree = shift->tree;
    return $tree->[0] ne 'tag' ? undef : _match(_compile(@_), $tree, $tree);
  }
  
  sub select     { _select(0, shift->tree, _compile(@_)) }
  sub select_one { _select(1, shift->tree, _compile(@_)) }
  
  sub _ancestor {
    my ($selectors, $current, $tree, $one, $pos) = @_;
  
    while ($current = $current->[3]) {
      return undef if $current->[0] eq 'root' || $current eq $tree;
      return 1 if _combinator($selectors, $current, $tree, $pos);
      last if $one;
    }
  
    return undef;
  }
  
  sub _attr {
    my ($name_re, $value_re, $current) = @_;
  
    my $attrs = $current->[2];
    for my $name (keys %$attrs) {
      my $value = $attrs->{$name};
      next if $name !~ $name_re || (!defined $value && defined $value_re);
      return 1 if !(defined $value && defined $value_re) || $value =~ $value_re;
    }
  
    return undef;
  }
  
  sub _combinator {
    my ($selectors, $current, $tree, $pos) = @_;
  
    # Selector
    return undef unless my $c = $selectors->[$pos];
    if (ref $c) {
      return undef unless _selector($c, $current);
      return 1 unless $c = $selectors->[++$pos];
    }
  
    # ">" (parent only)
    return _ancestor($selectors, $current, $tree, 1, ++$pos) if $c eq '>';
  
    # "~" (preceding siblings)
    return _sibling($selectors, $current, $tree, 0, ++$pos) if $c eq '~';
  
    # "+" (immediately preceding siblings)
    return _sibling($selectors, $current, $tree, 1, ++$pos) if $c eq '+';
  
    # " " (ancestor)
    return _ancestor($selectors, $current, $tree, 0, ++$pos);
  }
  
  sub _compile {
    my ($css, %ns) = (trim('' . shift), @_);
  
    my $group = [[]];
    while (my $selectors = $group->[-1]) {
      push @$selectors, [] unless @$selectors && ref $selectors->[-1];
      my $last = $selectors->[-1];
  
      # Separator
      if ($css =~ /\G\s*,\s*/gc) { push @$group, [] }
  
      # Combinator
      elsif ($css =~ /\G\s*([ >+~])\s*/gc) { push @$selectors, $1 }
  
      # Class or ID
      elsif ($css =~ /\G([.#])((?:$ESCAPE_RE\s|\\.|[^,.#:[ >~+])+)/gco) {
        my ($name, $op) = $1 eq '.' ? ('class', '~') : ('id', '');
        push @$last, ['attr', _name($name), _value($op, $2)];
      }
  
      # Attributes
      elsif ($css =~ /\G$ATTR_RE/gco) {
        push @$last, ['attr', _name($1), _value($2 // '', $3 // $4 // $5, $6)];
      }
  
      # Pseudo-class
      elsif ($css =~ /\G:([\w\-]+)(?:\(((?:\([^)]+\)|[^)])+)\))?/gcs) {
        my ($name, $args) = (lc $1, $2);
  
        # ":matches" and ":not" (contains more selectors)
        $args = _compile($args, %ns) if $name eq 'matches' || $name eq 'not';
  
        # ":nth-*" (with An+B notation)
        $args = _equation($args) if $name =~ /^nth-/;
  
        # ":first-*" (rewrite to ":nth-*")
        ($name, $args) = ("nth-$1", [0, 1]) if $name =~ /^first-(.+)$/;
  
        # ":last-*" (rewrite to ":nth-*")
        ($name, $args) = ("nth-$name", [-1, 1]) if $name =~ /^last-/;
  
        push @$last, ['pc', $name, $args];
      }
  
      # Tag
      elsif ($css =~ /\G((?:$ESCAPE_RE\s|\\.|[^,.#:[ >~+])+)/gco) {
        my $alias = (my $name = $1) =~ s/^([^|]*)\|// && $1 ne '*' ? $1 : undef;
        my $ns = length $alias ? $ns{$alias} // return [['invalid']] : $alias;
        push @$last, ['tag', $name eq '*' ? undef : _name($name), _unescape($ns)];
      }
  
      else {last}
    }
  
    return $group;
  }
  
  sub _empty { $_[0][0] eq 'comment' || $_[0][0] eq 'pi' }
  
  sub _equation {
    return [0, 0] unless my $equation = shift;
  
    # "even"
    return [2, 2] if $equation =~ /^\s*even\s*$/i;
  
    # "odd"
    return [2, 1] if $equation =~ /^\s*odd\s*$/i;
  
    # "4", "+4" or "-4"
    return [0, $1] if $equation =~ /^\s*((?:\+|-)?\d+)\s*$/;
  
    # "n", "4n", "+4n", "-4n", "n+1", "4n-1", "+4n-1" (and other variations)
    return [0, 0]
      unless $equation =~ /^\s*((?:\+|-)?(?:\d+)?)?n\s*((?:\+|-)\s*\d+)?\s*$/i;
    return [$1 eq '-' ? -1 : !length $1 ? 1 : $1, join('', split(' ', $2 // 0))];
  }
  
  sub _match {
    my ($group, $current, $tree) = @_;
    _combinator([reverse @$_], $current, $tree, 0) and return 1 for @$group;
    return undef;
  }
  
  sub _name {qr/(?:^|:)\Q@{[_unescape(shift)]}\E$/}
  
  sub _namespace {
    my ($ns, $current) = @_;
  
    my $attr = $current->[1] =~ /^([^:]+):/ ? "xmlns:$1" : 'xmlns';
    while ($current) {
      last if $current->[0] eq 'root';
      return $current->[2]{$attr} eq $ns if exists $current->[2]{$attr};
  
      $current = $current->[3];
    }
  
    # Failing to match yields true if searching for no namespace, false otherwise
    return !length $ns;
  }
  
  sub _pc {
    my ($class, $args, $current) = @_;
  
    # ":checked"
    return exists $current->[2]{checked} || exists $current->[2]{selected}
      if $class eq 'checked';
  
    # ":not"
    return !_match($args, $current, $current) if $class eq 'not';
  
    # ":matches"
    return !!_match($args, $current, $current) if $class eq 'matches';
  
    # ":empty"
    return !grep { !_empty($_) } @$current[4 .. $#$current] if $class eq 'empty';
  
    # ":root"
    return $current->[3] && $current->[3][0] eq 'root' if $class eq 'root';
  
    # ":link" and ":visited"
    if ($class eq 'link' || $class eq 'visited') {
      return undef unless $current->[0] eq 'tag' && exists $current->[2]{href};
      return !!grep { $current->[1] eq $_ } qw(a area link);
    }
  
    # ":only-child" or ":only-of-type"
    if ($class eq 'only-child' || $class eq 'only-of-type') {
      my $type = $class eq 'only-of-type' ? $current->[1] : undef;
      $_ ne $current and return undef for @{_siblings($current, $type)};
      return 1;
    }
  
    # ":nth-child", ":nth-last-child", ":nth-of-type" or ":nth-last-of-type"
    if (ref $args) {
      my $type = $class eq 'nth-of-type'
        || $class eq 'nth-last-of-type' ? $current->[1] : undef;
      my @siblings = @{_siblings($current, $type)};
      @siblings = reverse @siblings
        if $class eq 'nth-last-child' || $class eq 'nth-last-of-type';
  
      for my $i (0 .. $#siblings) {
        next if (my $result = $args->[0] * $i + $args->[1]) < 1;
        return undef unless my $sibling = $siblings[$result - 1];
        return 1 if $sibling eq $current;
      }
    }
  
    # Everything else
    return undef;
  }
  
  sub _select {
    my ($one, $tree, $group) = @_;
  
    my @results;
    my @queue = @$tree[($tree->[0] eq 'root' ? 1 : 4) .. $#$tree];
    while (my $current = shift @queue) {
      next unless $current->[0] eq 'tag';
  
      unshift @queue, @$current[4 .. $#$current];
      next unless _match($group, $current, $tree);
      $one ? return $current : push @results, $current;
    }
  
    return $one ? undef : \@results;
  }
  
  sub _selector {
    my ($selector, $current) = @_;
  
    for my $s (@$selector) {
      my $type = $s->[0];
  
      # Tag
      if ($type eq 'tag') {
        return undef if defined $s->[1] && $current->[1] !~ $s->[1];
        return undef if defined $s->[2] && !_namespace($s->[2], $current);
      }
  
      # Attribute
      elsif ($type eq 'attr') { return undef unless _attr(@$s[1, 2], $current) }
  
      # Pseudo-class
      elsif ($type eq 'pc') { return undef unless _pc(@$s[1, 2], $current) }
  
      # Invalid selector
      else { return undef }
    }
  
    return 1;
  }
  
  sub _sibling {
    my ($selectors, $current, $tree, $immediate, $pos) = @_;
  
    my $found;
    for my $sibling (@{_siblings($current)}) {
      return $found if $sibling eq $current;
  
      # "+" (immediately preceding sibling)
      if ($immediate) { $found = _combinator($selectors, $sibling, $tree, $pos) }
  
      # "~" (preceding sibling)
      else { return 1 if _combinator($selectors, $sibling, $tree, $pos) }
    }
  
    return undef;
  }
  
  sub _siblings {
    my ($current, $type) = @_;
  
    my $parent = $current->[3];
    my @siblings = grep { $_->[0] eq 'tag' }
      @$parent[($parent->[0] eq 'root' ? 1 : 4) .. $#$parent];
    @siblings = grep { $type eq $_->[1] } @siblings if defined $type;
  
    return \@siblings;
  }
  
  sub _unescape {
    return undef unless defined(my $value = shift);
  
    # Remove escaped newlines
    $value =~ s/\\\n//g;
  
    # Unescape Unicode characters
    $value =~ s/\\([0-9a-fA-F]{1,6})\s?/pack 'U', hex $1/ge;
  
    # Remove backslash
    $value =~ s/\\//g;
  
    return $value;
  }
  
  sub _value {
    my ($op, $value, $insensitive) = @_;
    return undef unless defined $value;
    $value = ($insensitive ? '(?i)' : '') . quotemeta _unescape($value);
  
    # "~=" (word)
    return qr/(?:^|\s+)$value(?:\s+|$)/ if $op eq '~';
  
    # "|=" (hyphen-separated)
    return qr/^$value(?:-|$)/ if $op eq '|';
  
    # "*=" (contains)
    return qr/$value/ if $op eq '*';
  
    # "^=" (begins with)
    return qr/^$value/ if $op eq '^';
  
    # "$=" (ends with)
    return qr/$value$/ if $op eq '$';
  
    # Everything else
    return qr/^$value$/;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::DOM::CSS - CSS selector engine
  
  =head1 SYNOPSIS
  
    use Mojo::DOM::CSS;
  
    # Select elements from DOM tree
    my $css = Mojo::DOM::CSS->new(tree => $tree);
    my $elements = $css->select('h1, h2, h3');
  
  =head1 DESCRIPTION
  
  L<Mojo::DOM::CSS> is the CSS selector engine used by L<Mojo::DOM>, based on the
  L<HTML Living Standard|https://html.spec.whatwg.org> and
  L<Selectors Level 3|http://www.w3.org/TR/css3-selectors/>.
  
  =head1 SELECTORS
  
  All CSS selectors that make sense for a standalone parser are supported.
  
  =head2 *
  
  Any element.
  
    my $all = $css->select('*');
  
  =head2 E
  
  An element of type C<E>.
  
    my $title = $css->select('title');
  
  =head2 E[foo]
  
  An C<E> element with a C<foo> attribute.
  
    my $links = $css->select('a[href]');
  
  =head2 E[foo="bar"]
  
  An C<E> element whose C<foo> attribute value is exactly equal to C<bar>.
  
    my $case_sensitive = $css->select('input[type="hidden"]');
    my $case_sensitive = $css->select('input[type=hidden]');
  
  =head2 E[foo="bar" i]
  
  An C<E> element whose C<foo> attribute value is exactly equal to any
  (ASCII-range) case-permutation of C<bar>. Note that this selector is
  EXPERIMENTAL and might change without warning!
  
    my $case_insensitive = $css->select('input[type="hidden" i]');
    my $case_insensitive = $css->select('input[type=hidden i]');
    my $case_insensitive = $css->select('input[class~="foo" i]');
  
  This selector is part of
  L<Selectors Level 4|http://dev.w3.org/csswg/selectors-4>, which is still a work
  in progress.
  
  =head2 E[foo~="bar"]
  
  An C<E> element whose C<foo> attribute value is a list of whitespace-separated
  values, one of which is exactly equal to C<bar>.
  
    my $foo = $css->select('input[class~="foo"]');
    my $foo = $css->select('input[class~=foo]');
  
  =head2 E[foo^="bar"]
  
  An C<E> element whose C<foo> attribute value begins exactly with the string
  C<bar>.
  
    my $begins_with = $css->select('input[name^="f"]');
    my $begins_with = $css->select('input[name^=f]');
  
  =head2 E[foo$="bar"]
  
  An C<E> element whose C<foo> attribute value ends exactly with the string
  C<bar>.
  
    my $ends_with = $css->select('input[name$="o"]');
    my $ends_with = $css->select('input[name$=o]');
  
  =head2 E[foo*="bar"]
  
  An C<E> element whose C<foo> attribute value contains the substring C<bar>.
  
    my $contains = $css->select('input[name*="fo"]');
    my $contains = $css->select('input[name*=fo]');
  
  =head2 E[foo|="en"]
  
  An C<E> element whose C<foo> attribute has a hyphen-separated list of values
  beginning (from the left) with C<en>.
  
    my $english = $css->select('link[hreflang|=en]');
  
  =head2 E:root
  
  An C<E> element, root of the document.
  
    my $root = $css->select(':root');
  
  =head2 E:nth-child(n)
  
  An C<E> element, the C<n-th> child of its parent.
  
    my $third = $css->select('div:nth-child(3)');
    my $odd   = $css->select('div:nth-child(odd)');
    my $even  = $css->select('div:nth-child(even)');
    my $top3  = $css->select('div:nth-child(-n+3)');
  
  =head2 E:nth-last-child(n)
  
  An C<E> element, the C<n-th> child of its parent, counting from the last one.
  
    my $third    = $css->select('div:nth-last-child(3)');
    my $odd      = $css->select('div:nth-last-child(odd)');
    my $even     = $css->select('div:nth-last-child(even)');
    my $bottom3  = $css->select('div:nth-last-child(-n+3)');
  
  =head2 E:nth-of-type(n)
  
  An C<E> element, the C<n-th> sibling of its type.
  
    my $third = $css->select('div:nth-of-type(3)');
    my $odd   = $css->select('div:nth-of-type(odd)');
    my $even  = $css->select('div:nth-of-type(even)');
    my $top3  = $css->select('div:nth-of-type(-n+3)');
  
  =head2 E:nth-last-of-type(n)
  
  An C<E> element, the C<n-th> sibling of its type, counting from the last one.
  
    my $third    = $css->select('div:nth-last-of-type(3)');
    my $odd      = $css->select('div:nth-last-of-type(odd)');
    my $even     = $css->select('div:nth-last-of-type(even)');
    my $bottom3  = $css->select('div:nth-last-of-type(-n+3)');
  
  =head2 E:first-child
  
  An C<E> element, first child of its parent.
  
    my $first = $css->select('div p:first-child');
  
  =head2 E:last-child
  
  An C<E> element, last child of its parent.
  
    my $last = $css->select('div p:last-child');
  
  =head2 E:first-of-type
  
  An C<E> element, first sibling of its type.
  
    my $first = $css->select('div p:first-of-type');
  
  =head2 E:last-of-type
  
  An C<E> element, last sibling of its type.
  
    my $last = $css->select('div p:last-of-type');
  
  =head2 E:only-child
  
  An C<E> element, only child of its parent.
  
    my $lonely = $css->select('div p:only-child');
  
  =head2 E:only-of-type
  
  An C<E> element, only sibling of its type.
  
    my $lonely = $css->select('div p:only-of-type');
  
  =head2 E:empty
  
  An C<E> element that has no children (including text nodes).
  
    my $empty = $css->select(':empty');
  
  =head2 E:link
  
  An C<E> element being the source anchor of a hyperlink of which the target is
  not yet visited (C<:link>) or already visited (C<:visited>). Note that
  L<Mojo::DOM::CSS> is not stateful, therefore C<:link> and C<:visited> yield
  exactly the same results.
  
    my $links = $css->select(':link');
    my $links = $css->select(':visited');
  
  =head2 E:visited
  
  Alias for L</"E:link">.
  
  =head2 E:checked
  
  A user interface element C<E> which is checked (for instance a radio-button or
  checkbox).
  
    my $input = $css->select(':checked');
  
  =head2 E.warning
  
  An C<E> element whose class is "warning".
  
    my $warning = $css->select('div.warning');
  
  =head2 E#myid
  
  An C<E> element with C<ID> equal to "myid".
  
    my $foo = $css->select('div#foo');
  
  =head2 E:not(s1, s2)
  
  An C<E> element that does not match either compound selector C<s1> or compound
  selector C<s2>. Note that support for compound selectors is EXPERIMENTAL and
  might change without warning!
  
    my $others = $css->select('div p:not(:first-child, :last-child)');
  
  Support for compound selectors was added as part of
  L<Selectors Level 4|http://dev.w3.org/csswg/selectors-4>, which is still a work
  in progress.
  
  =head2 E:matches(s1, s2)
  
  An C<E> element that matches compound selector C<s1> and/or compound selector
  C<s2>. Note that this selector is EXPERIMENTAL and might change without warning!
  
    my $headers = $css->select(':matches(section, article, aside, nav) h1');
  
  This selector is part of
  L<Selectors Level 4|http://dev.w3.org/csswg/selectors-4>, which is still a work
  in progress.
  
  =head2 A|E
  
  An C<E> element that belongs to the namespace alias C<A> from
  L<CSS Namespaces Module Level 3|https://www.w3.org/TR/css-namespaces-3/>.
  Key/value pairs passed to selector methods are used to declare namespace
  aliases.
  
    my $elem = $css->select('lq|elem', lq => 'http://example.com/q-markup');
  
  Using an empty alias searches for an element that belongs to no namespace.
  
    my $div = $c->select('|div');
  
  =head2 E F
  
  An C<F> element descendant of an C<E> element.
  
    my $headlines = $css->select('div h1');
  
  =head2 E E<gt> F
  
  An C<F> element child of an C<E> element.
  
    my $headlines = $css->select('html > body > div > h1');
  
  =head2 E + F
  
  An C<F> element immediately preceded by an C<E> element.
  
    my $second = $css->select('h1 + h2');
  
  =head2 E ~ F
  
  An C<F> element preceded by an C<E> element.
  
    my $second = $css->select('h1 ~ h2');
  
  =head2 E, F, G
  
  Elements of type C<E>, C<F> and C<G>.
  
    my $headlines = $css->select('h1, h2, h3');
  
  =head2 E[foo=bar][bar=baz]
  
  An C<E> element whose attributes match all following attribute selectors.
  
    my $links = $css->select('a[foo^=b][foo$=ar]');
  
  =head1 ATTRIBUTES
  
  L<Mojo::DOM::CSS> implements the following attributes.
  
  =head2 tree
  
    my $tree = $css->tree;
    $css     = $css->tree(['root']);
  
  Document Object Model. Note that this structure should only be used very
  carefully since it is very dynamic.
  
  =head1 METHODS
  
  L<Mojo::DOM::CSS> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 matches
  
    my $bool = $css->matches('head > title');
    my $bool = $css->matches('svg|line', svg => 'http://www.w3.org/2000/svg');
  
  Check if first node in L</"tree"> matches the CSS selector. Trailing key/value
  pairs can be used to declare xml namespace aliases.
  
  =head2 select
  
    my $results = $css->select('head > title');
    my $results = $css->select('svg|line', svg => 'http://www.w3.org/2000/svg');
  
  Run CSS selector against L</"tree">. Trailing key/value pairs can be used to
  declare xml namespace aliases.
  
  =head2 select_one
  
    my $result = $css->select_one('head > title');
    my $result =
      $css->select_one('svg|line', svg => 'http://www.w3.org/2000/svg');
  
  Run CSS selector against L</"tree"> and stop as soon as the first node matched.
  Trailing key/value pairs can be used to declare xml namespace aliases.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_DOM_CSS

$fatpacked{"Mojo/DOM/HTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_DOM_HTML';
  package Mojo::DOM::HTML;
  use Mojo::Base -base;
  
  use Exporter 'import';
  use Mojo::Util qw(html_attr_unescape html_unescape xml_escape);
  use Scalar::Util 'weaken';
  
  our @EXPORT_OK = ('tag_to_html');
  
  has tree => sub { ['root'] };
  has 'xml';
  
  my $ATTR_RE = qr/
    ([^<>=\s\/]+|\/)                     # Key
    (?:
      \s*=\s*
      (?s:(["'])(.*?)\g{-2}|([^>\s]*))   # Value
    )?
    \s*
  /x;
  my $TOKEN_RE = qr/
    ([^<]+)?                                            # Text
    (?:
      <(?:
        !(?:
          DOCTYPE(
          \s+\w+                                        # Doctype
          (?:(?:\s+\w+)?(?:\s+(?:"[^"]*"|'[^']*'))+)?   # External ID
          (?:\s+\[.+?\])?                               # Int Subset
          \s*)
        |
          --(.*?)--\s*                                  # Comment
        |
          \[CDATA\[(.*?)\]\]                            # CDATA
        )
      |
        \?(.*?)\?                                       # Processing Instruction
      |
        \s*([^<>\s]+\s*(?:(?:$ATTR_RE){0,32766})*+)     # Tag
      )>
    |
      (<)                                               # Runaway "<"
    )??
  /xis;
  
  # HTML elements that only contain raw text
  my %RAW = map { $_ => 1 } qw(script style);
  
  # HTML elements that only contain raw text and entities
  my %RCDATA = map { $_ => 1 } qw(title textarea);
  
  # HTML elements with optional end tags
  my %END = (body => 'head', optgroup => 'optgroup', option => 'option');
  
  # HTML elements that break paragraphs
  map { $END{$_} = 'p' } (
    qw(address article aside blockquote details div dl fieldset figcaption),
    qw(figure footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p),
    qw(pre section table ul)
  );
  
  # HTML table elements with optional end tags
  my %TABLE = map { $_ => 1 } qw(colgroup tbody td tfoot th thead tr);
  
  # HTML elements with optional end tags and scoping rules
  my %CLOSE
    = (li => [{li => 1}, {ul => 1, ol => 1}], tr => [{tr => 1}, {table => 1}]);
  $CLOSE{$_} = [\%TABLE, {table => 1}] for qw(colgroup tbody tfoot thead);
  $CLOSE{$_} = [{dd => 1, dt => 1}, {dl    => 1}] for qw(dd dt);
  $CLOSE{$_} = [{rp => 1, rt => 1}, {ruby  => 1}] for qw(rp rt);
  $CLOSE{$_} = [{th => 1, td => 1}, {table => 1}] for qw(td th);
  
  # HTML elements without end tags
  my %EMPTY = map { $_ => 1 } (
    qw(area base br col embed hr img input keygen link menuitem meta param),
    qw(source track wbr)
  );
  
  # HTML elements categorized as phrasing content (and obsolete inline elements)
  my @PHRASING = (
    qw(a abbr area audio b bdi bdo br button canvas cite code data datalist),
    qw(del dfn em embed i iframe img input ins kbd keygen label link map mark),
    qw(math meta meter noscript object output picture progress q ruby s samp),
    qw(script select slot small span strong sub sup svg template textarea time u),
    qw(var video wbr)
  );
  my @OBSOLETE = qw(acronym applet basefont big font strike tt);
  my %PHRASING = map { $_ => 1 } @OBSOLETE, @PHRASING;
  
  # HTML elements that don't get their self-closing flag acknowledged
  my %BLOCK = map { $_ => 1 } (
    qw(a address applet article aside b big blockquote body button caption),
    qw(center code col colgroup dd details dialog dir div dl dt em fieldset),
    qw(figcaption figure font footer form frameset h1 h2 h3 h4 h5 h6 head),
    qw(header hgroup html i iframe li listing main marquee menu nav nobr),
    qw(noembed noframes noscript object ol optgroup option p plaintext pre rp),
    qw(rt s script section select small strike strong style summary table),
    qw(tbody td template textarea tfoot th thead title tr tt u ul xmp)
  );
  
  sub parse {
    my ($self, $html) = (shift, "$_[0]");
  
    my $xml = $self->xml;
    my $current = my $tree = ['root'];
    while ($html =~ /\G$TOKEN_RE/gcso) {
      my ($text, $doctype, $comment, $cdata, $pi, $tag, $runaway)
        = ($1, $2, $3, $4, $5, $6, $11);
  
      # Text (and runaway "<")
      $text .= '<' if defined $runaway;
      _node($current, 'text', html_unescape $text) if defined $text;
  
      # Tag
      if (defined $tag) {
  
        # End
        if ($tag =~ /^\/\s*(\S+)/) { _end($xml ? $1 : lc $1, $xml, \$current) }
  
        # Start
        elsif ($tag =~ m!^([^\s/]+)([\s\S]*)!) {
          my ($start, $attr) = ($xml ? $1 : lc $1, $2);
  
          # Attributes
          my (%attrs, $closing);
          while ($attr =~ /$ATTR_RE/go) {
            my ($key, $value) = ($xml ? $1 : lc $1, $3 // $4);
  
            # Empty tag
            ++$closing and next if $key eq '/';
  
            $attrs{$key} = defined $value ? html_attr_unescape $value : $value;
          }
  
          # "image" is an alias for "img"
          $start = 'img' if !$xml && $start eq 'image';
          _start($start, \%attrs, $xml, \$current);
  
          # Element without end tag (self-closing)
          _end($start, $xml, \$current)
            if !$xml && $EMPTY{$start} || ($xml || !$BLOCK{$start}) && $closing;
  
          # Raw text elements
          next if $xml || !$RAW{$start} && !$RCDATA{$start};
          next unless $html =~ m!\G(.*?)<\s*/\s*\Q$start\E\s*>!gcsi;
          _node($current, 'raw', $RCDATA{$start} ? html_unescape $1 : $1);
          _end($start, 0, \$current);
        }
      }
  
      # DOCTYPE
      elsif (defined $doctype) { _node($current, 'doctype', $doctype) }
  
      # Comment
      elsif (defined $comment) { _node($current, 'comment', $comment) }
  
      # CDATA
      elsif (defined $cdata) { _node($current, 'cdata', $cdata) }
  
      # Processing instruction (try to detect XML)
      elsif (defined $pi) {
        $self->xml($xml = 1) if !exists $self->{xml} && $pi =~ /xml/i;
        _node($current, 'pi', $pi);
      }
    }
  
    return $self->tree($tree);
  }
  
  sub render { _render($_[0]->tree, $_[0]->xml) }
  
  sub tag { shift->tree(['root', _tag(@_)]) }
  
  sub tag_to_html { _render(_tag(@_), undef) }
  
  sub _end {
    my ($end, $xml, $current) = @_;
  
    # Search stack for start tag
    my $next = $$current;
    do {
  
      # Ignore useless end tag
      return if $next->[0] eq 'root';
  
      # Right tag
      return $$current = $next->[3] if $next->[1] eq $end;
  
      # Phrasing content can only cross phrasing content
      return if !$xml && $PHRASING{$end} && !$PHRASING{$next->[1]};
  
    } while $next = $next->[3];
  }
  
  sub _node {
    my ($current, $type, $content) = @_;
    push @$current, my $new = [$type, $content, $current];
    weaken $new->[2];
  }
  
  sub _render {
    my ($tree, $xml) = @_;
  
    # Tag
    my $type = $tree->[0];
    if ($type eq 'tag') {
  
      # Start tag
      my $tag    = $tree->[1];
      my $result = "<$tag";
  
      # Attributes
      for my $key (sort keys %{$tree->[2]}) {
        my $value = $tree->[2]{$key};
        $result .= $xml ? qq{ $key="$key"} : " $key" and next
          unless defined $value;
        $result .= qq{ $key="} . xml_escape($value) . '"';
      }
  
      # No children
      return $xml ? "$result />" : $EMPTY{$tag} ? "$result>" : "$result></$tag>"
        unless $tree->[4];
  
      # Children
      no warnings 'recursion';
      $result .= '>' . join '', map { _render($_, $xml) } @$tree[4 .. $#$tree];
  
      # End tag
      return "$result</$tag>";
    }
  
    # Text (escaped)
    return xml_escape $tree->[1] if $type eq 'text';
  
    # Raw text
    return $tree->[1] if $type eq 'raw';
  
    # Root
    return join '', map { _render($_, $xml) } @$tree[1 .. $#$tree]
      if $type eq 'root';
  
    # DOCTYPE
    return '<!DOCTYPE' . $tree->[1] . '>' if $type eq 'doctype';
  
    # Comment
    return '<!--' . $tree->[1] . '-->' if $type eq 'comment';
  
    # CDATA
    return '<![CDATA[' . $tree->[1] . ']]>' if $type eq 'cdata';
  
    # Processing instruction
    return '<?' . $tree->[1] . '?>' if $type eq 'pi';
  
    # Everything else
    return '';
  }
  
  sub _start {
    my ($start, $attrs, $xml, $current) = @_;
  
    # Autoclose optional HTML elements
    if (!$xml && $$current->[0] ne 'root') {
      if (my $end = $END{$start}) { _end($end, 0, $current) }
  
      elsif (my $close = $CLOSE{$start}) {
        my ($allowed, $scope) = @$close;
  
        # Close allowed parent elements in scope
        my $parent = $$current;
        while ($parent->[0] ne 'root' && !$scope->{$parent->[1]}) {
          _end($parent->[1], 0, $current) if $allowed->{$parent->[1]};
          $parent = $parent->[3];
        }
      }
    }
  
    # New tag
    push @$$current, my $new = ['tag', $start, $attrs, $$current];
    weaken $new->[3];
    $$current = $new;
  }
  
  sub _tag {
    my $tree = ['tag', shift, undef, undef];
  
    # Content
    push @$tree, ref $_[-1] eq 'CODE' ? ['raw', pop->()] : ['text', pop]
      if @_ % 2;
  
    # Attributes
    my $attrs = $tree->[2] = {@_};
    return $tree unless exists $attrs->{data} && ref $attrs->{data} eq 'HASH';
    my $data = delete $attrs->{data};
    @$attrs{map { y/_/-/; lc "data-$_" } keys %$data} = values %$data;
    return $tree;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::DOM::HTML - HTML/XML engine
  
  =head1 SYNOPSIS
  
    use Mojo::DOM::HTML;
  
    # Turn HTML into DOM tree
    my $html = Mojo::DOM::HTML->new;
    $html->parse('<div><p id="a">Test</p><p id="b">123</p></div>');
    my $tree = $html->tree;
  
  =head1 DESCRIPTION
  
  L<Mojo::DOM::HTML> is the HTML/XML engine used by L<Mojo::DOM>, based on the
  L<HTML Living Standard|https://html.spec.whatwg.org> and the
  L<Extensible Markup Language (XML) 1.0|http://www.w3.org/TR/xml/>.
  
  =head1 FUNCTIONS
  
  L<Mojo::DOM::HTML> implements the following functions, which can be imported
  individually.
  
  =head2 tag_to_html
  
    my $str = tag_to_html 'div', id => 'foo', 'safe content';
  
  Generate HTML/XML tag and render it right away. This is a significantly faster
  alternative to L</"tag"> for template systems that have to generate a lot of
  tags. Note that this function is EXPERIMENTAL and might change without warning!
  
  =head1 ATTRIBUTES
  
  L<Mojo::DOM::HTML> implements the following attributes.
  
  =head2 tree
  
    my $tree = $html->tree;
    $html    = $html->tree(['root']);
  
  Document Object Model. Note that this structure should only be used very
  carefully since it is very dynamic.
  
  =head2 xml
  
    my $bool = $html->xml;
    $html    = $html->xml($bool);
  
  Disable HTML semantics in parser and activate case-sensitivity, defaults to
  auto-detection based on XML declarations.
  
  =head1 METHODS
  
  L<Mojo::DOM::HTML> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 parse
  
    $html = $html->parse('<foo bar="baz">I  Mojolicious!</foo>');
  
  Parse HTML/XML fragment.
  
  =head2 render
  
    my $str = $html->render;
  
  Render DOM to HTML/XML.
  
  =head2 tag
  
    $html = $html->tag('div', id => 'foo', 'safe content');
  
  Generate HTML/XML tag. Note that this method is EXPERIMENTAL and might change
  without warning!
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_DOM_HTML

$fatpacked{"Mojo/Date.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_DATE';
  package Mojo::Date;
  use Mojo::Base -base;
  use overload bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;
  
  use Time::Local 'timegm';
  
  has epoch => sub {time};
  
  my $RFC3339_RE = qr/
    ^(\d+)-(\d+)-(\d+)\D+(\d+):(\d+):(\d+(?:\.\d+)?)   # Date and time
    (?:Z|([+-])(\d+):(\d+))?$                          # Offset
  /xi;
  
  my @DAYS   = qw(Sun Mon Tue Wed Thu Fri Sat);
  my @MONTHS = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
  my %MONTHS;
  @MONTHS{@MONTHS} = (0 .. 11);
  
  sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }
  
  sub parse {
    my ($self, $date) = @_;
  
    # epoch (784111777)
    return $self->epoch($date) if $date =~ /^\d+$|^\d+\.\d+$/;
  
    # RFC 822/1123 (Sun, 06 Nov 1994 08:49:37 GMT)
    # RFC 850/1036 (Sunday, 06-Nov-94 08:49:37 GMT)
    my $offset = 0;
    my ($day, $month, $year, $h, $m, $s);
    if ($date =~ /^\w+\W+(\d+)\W+(\w+)\W+(\d+)\W+(\d+):(\d+):(\d+)\W*\w+$/) {
      ($day, $month, $year, $h, $m, $s) = ($1, $MONTHS{$2}, $3, $4, $5, $6);
    }
  
    # RFC 3339 (1994-11-06T08:49:37Z)
    elsif ($date =~ $RFC3339_RE) {
      ($year, $month, $day, $h, $m, $s) = ($1, $2 - 1, $3, $4, $5, $6);
      $offset = (($8 * 3600) + ($9 * 60)) * ($7 eq '+' ? -1 : 1) if $7;
    }
  
    # ANSI C asctime() (Sun Nov  6 08:49:37 1994)
    elsif ($date =~ /^\w+\s+(\w+)\s+(\d+)\s+(\d+):(\d+):(\d+)\s+(\d+)$/) {
      ($month, $day, $h, $m, $s, $year) = ($MONTHS{$1}, $2, $3, $4, $5, $6);
    }
  
    # Invalid
    else { return $self->epoch(undef) }
  
    my $epoch = eval { timegm $s, $m, $h, $day, $month, $year };
    return $self->epoch(
      (defined $epoch && ($epoch += $offset) >= 0) ? $epoch : undef);
  }
  
  sub to_datetime {
  
    # RFC 3339 (1994-11-06T08:49:37Z)
    my ($s, $m, $h, $day, $month, $year) = gmtime(my $epoch = shift->epoch);
    my $str = sprintf '%04d-%02d-%02dT%02d:%02d:%02d', $year + 1900, $month + 1,
      $day, $h, $m, $s;
    return $str . ($epoch =~ /(\.\d+)$/ ? $1 : '') . 'Z';
  }
  
  sub to_string {
  
    # RFC 7231 (Sun, 06 Nov 1994 08:49:37 GMT)
    my ($s, $m, $h, $mday, $month, $year, $wday) = gmtime shift->epoch;
    return sprintf '%s, %02d %s %04d %02d:%02d:%02d GMT', $DAYS[$wday], $mday,
      $MONTHS[$month], $year + 1900, $h, $m, $s;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Date - HTTP date
  
  =head1 SYNOPSIS
  
    use Mojo::Date;
  
    # Parse
    my $date = Mojo::Date->new('Sun, 06 Nov 1994 08:49:37 GMT');
    say $date->epoch;
  
    # Build
    my $date = Mojo::Date->new(time + 60);
    say "$date";
  
  =head1 DESCRIPTION
  
  L<Mojo::Date> implements HTTP date and time functions, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230>,
  L<RFC 7231|http://tools.ietf.org/html/rfc7231> and
  L<RFC 3339|http://tools.ietf.org/html/rfc3339>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Date> implements the following attributes.
  
  =head2 epoch
  
    my $epoch = $date->epoch;
    $date     = $date->epoch(784111777);
  
  Epoch seconds, defaults to the current time.
  
  =head1 METHODS
  
  L<Mojo::Date> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 new
  
    my $date = Mojo::Date->new;
    my $date = Mojo::Date->new('Sun Nov  6 08:49:37 1994');
  
  Construct a new L<Mojo::Date> object and L</"parse"> date if necessary.
  
  =head2 parse
  
    $date = $date->parse('Sun Nov  6 08:49:37 1994');
  
  Parse date.
  
    # Epoch
    say Mojo::Date->new('784111777')->epoch;
    say Mojo::Date->new('784111777.21')->epoch;
  
    # RFC 822/1123
    say Mojo::Date->new('Sun, 06 Nov 1994 08:49:37 GMT')->epoch;
  
    # RFC 850/1036
    say Mojo::Date->new('Sunday, 06-Nov-94 08:49:37 GMT')->epoch;
  
    # Ansi C asctime()
    say Mojo::Date->new('Sun Nov  6 08:49:37 1994')->epoch;
  
    # RFC 3339
    say Mojo::Date->new('1994-11-06T08:49:37Z')->epoch;
    say Mojo::Date->new('1994-11-06T08:49:37')->epoch;
    say Mojo::Date->new('1994-11-06T08:49:37.21Z')->epoch;
    say Mojo::Date->new('1994-11-06T08:49:37+01:00')->epoch;
    say Mojo::Date->new('1994-11-06T08:49:37-01:00')->epoch;
  
  =head2 to_datetime
  
    my $str = $date->to_datetime;
  
  Render L<RFC 3339|http://tools.ietf.org/html/rfc3339> date and time.
  
    # "1994-11-06T08:49:37Z"
    Mojo::Date->new(784111777)->to_datetime;
  
    # "1994-11-06T08:49:37.21Z"
    Mojo::Date->new(784111777.21)->to_datetime;
  
  =head2 to_string
  
    my $str = $date->to_string;
  
  Render date suitable for HTTP messages.
  
    # "Sun, 06 Nov 1994 08:49:37 GMT"
    Mojo::Date->new(784111777)->to_string;
  
  =head1 OPERATORS
  
  L<Mojo::Date> overloads the following operators.
  
  =head2 bool
  
    my $bool = !!$date;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$date";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_DATE

$fatpacked{"Mojo/EventEmitter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_EVENTEMITTER';
  package Mojo::EventEmitter;
  use Mojo::Base -base;
  
  use Scalar::Util qw(blessed weaken);
  
  use constant DEBUG => $ENV{MOJO_EVENTEMITTER_DEBUG} || 0;
  
  sub catch { $_[0]->on(error => $_[1]) and return $_[0] }
  
  sub emit {
    my ($self, $name) = (shift, shift);
  
    if (my $s = $self->{events}{$name}) {
      warn "-- Emit $name in @{[blessed $self]} (@{[scalar @$s]})\n" if DEBUG;
      for my $cb (@$s) { $self->$cb(@_) }
    }
    else {
      warn "-- Emit $name in @{[blessed $self]} (0)\n" if DEBUG;
      die "@{[blessed $self]}: $_[0]" if $name eq 'error';
    }
  
    return $self;
  }
  
  sub has_subscribers { !!shift->{events}{shift()} }
  
  sub on { push @{$_[0]{events}{$_[1]}}, $_[2] and return $_[2] }
  
  sub once {
    my ($self, $name, $cb) = @_;
  
    weaken $self;
    my $wrapper;
    $wrapper = sub {
      $self->unsubscribe($name => $wrapper);
      $cb->(@_);
    };
    $self->on($name => $wrapper);
    weaken $wrapper;
  
    return $wrapper;
  }
  
  sub subscribers { shift->{events}{shift()} ||= [] }
  
  sub unsubscribe {
    my ($self, $name, $cb) = @_;
  
    # One
    if ($cb) {
      $self->{events}{$name} = [grep { $cb ne $_ } @{$self->{events}{$name}}];
      delete $self->{events}{$name} unless @{$self->{events}{$name}};
    }
  
    # All
    else { delete $self->{events}{$name} }
  
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::EventEmitter - Event emitter base class
  
  =head1 SYNOPSIS
  
    package Cat;
    use Mojo::Base 'Mojo::EventEmitter';
  
    # Emit events
    sub poke {
      my $self = shift;
      $self->emit(roar => 3);
    }
  
    package main;
  
    # Subscribe to events
    my $tiger = Cat->new;
    $tiger->on(roar => sub {
      my ($tiger, $times) = @_;
      say 'RAWR!' for 1 .. $times;
    });
    $tiger->poke;
  
  =head1 DESCRIPTION
  
  L<Mojo::EventEmitter> is a simple base class for event emitting objects.
  
  =head1 EVENTS
  
  L<Mojo::EventEmitter> can emit the following events.
  
  =head2 error
  
    $e->on(error => sub {
      my ($e, $err) = @_;
      ...
    });
  
  This is a special event for errors, it will not be emitted directly by this
  class, but is fatal if unhandled. Subclasses may choose to emit it, but are not
  required to do so.
  
    $e->on(error => sub {
      my ($e, $err) = @_;
      say "This looks bad: $err";
    });
  
  =head1 METHODS
  
  L<Mojo::EventEmitter> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 catch
  
    $e = $e->catch(sub {...});
  
  Subscribe to L</"error"> event.
  
    # Longer version
    $e->on(error => sub {...});
  
  =head2 emit
  
    $e = $e->emit('foo');
    $e = $e->emit('foo', 123);
  
  Emit event.
  
  =head2 has_subscribers
  
    my $bool = $e->has_subscribers('foo');
  
  Check if event has subscribers.
  
  =head2 on
  
    my $cb = $e->on(foo => sub {...});
  
  Subscribe to event.
  
    $e->on(foo => sub {
      my ($e, @args) = @_;
      ...
    });
  
  =head2 once
  
    my $cb = $e->once(foo => sub {...});
  
  Subscribe to event and unsubscribe again after it has been emitted once.
  
    $e->once(foo => sub {
      my ($e, @args) = @_;
      ...
    });
  
  =head2 subscribers
  
    my $subscribers = $e->subscribers('foo');
  
  All subscribers for event.
  
    # Unsubscribe last subscriber
    $e->unsubscribe(foo => $e->subscribers('foo')->[-1]);
  
    # Change order of subscribers
    @{$e->subscribers('foo')} = reverse @{$e->subscribers('foo')};
  
  =head2 unsubscribe
  
    $e = $e->unsubscribe('foo');
    $e = $e->unsubscribe(foo => $cb);
  
  Unsubscribe from event.
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_EVENTEMITTER_DEBUG> environment variable to get some
  advanced diagnostics information printed to C<STDERR>.
  
    MOJO_EVENTEMITTER_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_EVENTEMITTER

$fatpacked{"Mojo/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_EXCEPTION';
  package Mojo::Exception;
  use Mojo::Base -base;
  use overload bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;
  
  use Mojo::Util 'decode';
  
  has [qw(frames line lines_after lines_before)] => sub { [] };
  has message => 'Exception!';
  has 'verbose';
  
  sub inspect {
    my ($self, @sources) = @_;
  
    # Extract file and line from message
    my @files;
    my $msg = $self->lines_before([])->line([])->lines_after([])->message;
    while ($msg =~ /at\s+(.+?)\s+line\s+(\d+)/g) { unshift @files, [$1, $2] }
  
    # Extract file and line from stack trace
    if (my $zero = $self->frames->[0]) { push @files, [$zero->[1], $zero->[2]] }
  
    # Search for context in files
    for my $file (@files) {
      next unless -r $file->[0] && open my $handle, '<', $file->[0];
      $self->_context($file->[1], [[<$handle>]]);
      return $self;
    }
  
    # Search for context in sources
    $self->_context($files[-1][1], [map { [split "\n"] } @sources]) if @sources;
  
    return $self;
  }
  
  sub new { @_ > 1 ? shift->SUPER::new(message => shift) : shift->SUPER::new }
  
  sub to_string {
    my $self = shift;
  
    my $str = $self->message;
    return $str unless $self->verbose;
  
    $str .= "\n" unless $str =~ /\n$/;
    $str .= $_->[0] . ': ' . $_->[1] . "\n" for @{$self->lines_before};
    $str .= $self->line->[0] . ': ' . $self->line->[1] . "\n" if $self->line->[0];
    $str .= $_->[0] . ': ' . $_->[1] . "\n" for @{$self->lines_after};
  
    return $str;
  }
  
  sub throw { CORE::die shift->new(shift)->trace(2)->inspect }
  
  sub trace {
    my ($self, $start) = (shift, shift // 1);
    my @frames;
    while (my @trace = caller($start++)) { push @frames, \@trace }
    return $self->frames(\@frames);
  }
  
  sub _append {
    my ($stack, $line) = @_;
    $line = decode('UTF-8', $line) // $line;
    chomp $line;
    push @$stack, $line;
  }
  
  sub _context {
    my ($self, $num, $sources) = @_;
  
    # Line
    return unless defined $sources->[0][$num - 1];
    $self->line([$num]);
    _append($self->line, $_->[$num - 1]) for @$sources;
  
    # Before
    for my $i (2 .. 6) {
      last if ((my $previous = $num - $i) < 0);
      unshift @{$self->lines_before}, [$previous + 1];
      _append($self->lines_before->[0], $_->[$previous]) for @$sources;
    }
  
    # After
    for my $i (0 .. 4) {
      next if ((my $next = $num + $i) < 0);
      next unless defined $sources->[0][$next];
      push @{$self->lines_after}, [$next + 1];
      _append($self->lines_after->[-1], $_->[$next]) for @$sources;
    }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Exception - Exceptions with context
  
  =head1 SYNOPSIS
  
    use Mojo::Exception;
  
    # Throw exception and show stack trace
    eval { Mojo::Exception->throw('Something went wrong!') };
    say "$_->[1]:$_->[2]" for @{$@->frames};
  
    # Customize exception
    eval {
      my $e = Mojo::Exception->new('Died at test.pl line 3.');
      die $e->trace(2)->inspect->verbose(1);
    };
    say $@;
  
  =head1 DESCRIPTION
  
  L<Mojo::Exception> is a container for exceptions with context information.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Exception> implements the following attributes.
  
  =head2 frames
  
    my $frames = $e->frames;
    $e         = $e->frames([$frame1, $frame2]);
  
  Stack trace if available.
  
    # Extract information from the last frame
    my ($package, $filename, $line, $subroutine, $hasargs, $wantarray, $evaltext,
        $is_require, $hints, $bitmask, $hinthash) = @{$e->frames->[-1]};
  
  =head2 line
  
    my $line = $e->line;
    $e       = $e->line([3, 'die;']);
  
  The line where the exception occurred if available.
  
  =head2 lines_after
  
    my $lines = $e->lines_after;
    $e        = $e->lines_after([[4, 'say $foo;'], [5, 'say $bar;']]);
  
  Lines after the line where the exception occurred if available.
  
  =head2 lines_before
  
    my $lines = $e->lines_before;
    $e        = $e->lines_before([[1, 'my $foo = 23;'], [2, 'my $bar = 24;']]);
  
  Lines before the line where the exception occurred if available.
  
  =head2 message
  
    my $msg = $e->message;
    $e      = $e->message('Died at test.pl line 3.');
  
  Exception message, defaults to C<Exception!>.
  
  =head2 verbose
  
    my $bool = $e->verbose;
    $e       = $e->verbose($bool);
  
  Enable context information for L</"to_string">.
  
  =head1 METHODS
  
  L<Mojo::Exception> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 inspect
  
    $e = $e->inspect;
    $e = $e->inspect($source1, $source2);
  
  Inspect L</"message">, L</"frames"> and optional additional sources to fill
  L</"lines_before">, L</"line"> and L</"lines_after"> with context information.
  
  =head2 new
  
    my $e = Mojo::Exception->new;
    my $e = Mojo::Exception->new('Died at test.pl line 3.');
  
  Construct a new L<Mojo::Exception> object and assign L</"message"> if necessary.
  
  =head2 to_string
  
    my $str = $e->to_string;
  
  Render exception.
  
    # Render exception with context
    say $e->verbose(1)->to_string;
  
  =head2 throw
  
    Mojo::Exception->throw('Something went wrong!');
  
  Throw exception from the current execution context.
  
    # Longer version
    die Mojo::Exception->new('Something went wrong!')->trace->inspect;
  
  =head2 trace
  
    $e = $e->trace;
    $e = $e->trace($skip);
  
  Generate stack trace and store all L</"frames">, defaults to skipping C<1> call
  frame.
  
    # Skip 3 call frames
    $e->trace(3);
  
    # Skip no call frames
    $e->trace(0);
  
  =head1 OPERATORS
  
  L<Mojo::Exception> overloads the following operators.
  
  =head2 bool
  
    my $bool = !!$e;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$e";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_EXCEPTION

$fatpacked{"Mojo/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_FILE';
  package Mojo::File;
  use Mojo::Base -strict;
  use overload
    '@{}'    => sub { shift->to_array },
    bool     => sub {1},
    '""'     => sub { ${$_[0]} },
    fallback => 1;
  
  use Carp 'croak';
  use Cwd 'getcwd';
  use Exporter 'import';
  use File::Basename ();
  use File::Copy qw(copy move);
  use File::Find 'find';
  use File::Path ();
  use File::Spec::Functions
    qw(abs2rel canonpath catfile file_name_is_absolute rel2abs splitdir);
  use File::Temp ();
  use IO::File   ();
  use Mojo::Collection;
  
  our @EXPORT_OK = ('path', 'tempdir', 'tempfile');
  
  sub basename { File::Basename::basename ${shift()}, @_ }
  
  sub child { $_[0]->new(@_) }
  
  sub copy_to {
    my ($self, $to) = @_;
    copy($$self, $to) or croak qq{Can't copy file "$$self" to "$to": $!};
    return $self->new(-d $to ? ($to, File::Basename::basename $self) : $to);
  }
  
  sub dirname { $_[0]->new(scalar File::Basename::dirname ${$_[0]}) }
  
  sub is_abs { file_name_is_absolute ${shift()} }
  
  sub list {
    my ($self, $options) = (shift, shift // {});
  
    return Mojo::Collection->new unless -d $$self;
    opendir(my $dir, $$self) or croak qq{Can't open directory "$$self": $!};
    my @files = grep { $_ ne '.' && $_ ne '..' } readdir $dir;
    @files = grep { !/^\./ } @files unless $options->{hidden};
    @files = map { catfile $$self, $_ } @files;
    @files = grep { !-d } @files unless $options->{dir};
  
    return Mojo::Collection->new(map { $self->new($_) } sort @files);
  }
  
  sub list_tree {
    my ($self, $options) = (shift, shift // {});
  
    # This may break in the future, but is worth it for performance
    local $File::Find::skip_pattern = qr/^\./ unless $options->{hidden};
  
    # The File::Find documentation lies, this is needed for CIFS
    local $File::Find::dont_use_nlink = 1 if $options->{dont_use_nlink};
  
    my %all;
    my $wanted = {wanted => sub { $all{$File::Find::name}++ }, no_chdir => 1};
    $wanted->{postprocess} = sub { delete $all{$File::Find::dir} }
      unless $options->{dir};
    find $wanted, $$self if -d $$self;
    delete $all{$$self};
  
    return Mojo::Collection->new(map { $self->new(canonpath $_) } sort keys %all);
  }
  
  sub make_path {
    my $self = shift;
    File::Path::make_path $$self, @_;
    return $self;
  }
  
  sub move_to {
    my ($self, $to) = @_;
    move($$self, $to) or croak qq{Can't move file "$$self" to "$to": $!};
    return $self->new(-d $to ? ($to, File::Basename::basename $self) : $to);
  }
  
  sub new {
    my $class = shift;
    my $value = @_ == 1 ? $_[0] : @_ > 1 ? catfile @_ : canonpath getcwd;
    return bless \$value, ref $class || $class;
  }
  
  sub open {
    my $self   = shift;
    my $handle = IO::File->new;
    $handle->open($$self, @_) or croak qq{Can't open file "$$self": $!};
    return $handle;
  }
  
  sub path { __PACKAGE__->new(@_) }
  
  sub realpath { $_[0]->new(Cwd::realpath ${$_[0]}) }
  
  sub remove_tree {
    my $self = shift;
    File::Path::remove_tree $$self, @_;
    return $self;
  }
  
  sub sibling {
    my $self = shift;
    return $self->new(scalar File::Basename::dirname($self), @_);
  }
  
  sub slurp {
    my $self = shift;
  
    CORE::open my $file, '<', $$self or croak qq{Can't open file "$$self": $!};
    my $ret = my $content = '';
    while ($ret = $file->sysread(my $buffer, 131072, 0)) { $content .= $buffer }
    croak qq{Can't read from file "$$self": $!} unless defined $ret;
  
    return $content;
  }
  
  sub spurt {
    my ($self, $content) = (shift, join '', @_);
    CORE::open my $file, '>', $$self or croak qq{Can't open file "$$self": $!};
    ($file->syswrite($content) // -1) == length $content
      or croak qq{Can't write to file "$$self": $!};
    return $self;
  }
  
  sub tap { shift->Mojo::Base::tap(@_) }
  
  sub tempdir { __PACKAGE__->new(File::Temp->newdir(@_)) }
  
  sub tempfile { __PACKAGE__->new(File::Temp->new(@_)) }
  
  sub to_abs { $_[0]->new(rel2abs ${$_[0]}) }
  
  sub to_array { [splitdir ${shift()}] }
  
  sub to_rel { $_[0]->new(abs2rel(${$_[0]}, $_[1])) }
  
  sub to_string {"${$_[0]}"}
  
  sub with_roles { shift->Mojo::Base::with_roles(@_) }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::File - File system paths
  
  =head1 SYNOPSIS
  
    use Mojo::File;
  
    # Portably deal with file system paths
    my $path = Mojo::File->new('/home/sri/.vimrc');
    say $path->slurp;
    say $path->dirname;
    say $path->basename;
    say $path->sibling('.bashrc');
  
    # Use the alternative constructor
    use Mojo::File 'path';
    my $path = path('/tmp/foo/bar')->make_path;
    $path->child('test.txt')->spurt('Hello Mojo!');
  
  =head1 DESCRIPTION
  
  L<Mojo::File> is a scalar-based container for file system paths that provides a
  friendly API for dealing with different operating systems.
  
    # Access scalar directly to manipulate path
    my $path = Mojo::File->new('/home/sri/test');
    $$path .= '.txt';
  
  =head1 FUNCTIONS
  
  L<Mojo::File> implements the following functions, which can be imported
  individually.
  
  =head2 path
  
    my $path = path;
    my $path = path('/home/sri/.vimrc');
    my $path = path('/home', 'sri', '.vimrc');
    my $path = path(File::Temp->newdir);
  
  Construct a new scalar-based L<Mojo::File> object, defaults to using the current
  working directory.
  
    # "foo/bar/baz.txt" (on UNIX)
    path('foo', 'bar', 'baz.txt');
  
  =head2 tempdir
  
    my $path = tempdir;
    my $path = tempdir('tempXXXXX');
  
  Construct a new scalar-based L<Mojo::File> object for a temporary directory with
  L<File::Temp>.
  
    # Longer version
    my $path = path(File::Temp->newdir('tempXXXXX'));
  
  =head2 tempfile
  
    my $path = tempfile;
    my $path = tempfile(DIR => '/tmp');
  
  Construct a new scalar-based L<Mojo::File> object for a temporary file with
  L<File::Temp>.
  
    # Longer version
    my $path = path(File::Temp->new(DIR => '/tmp'));
  
  =head1 METHODS
  
  L<Mojo::File> implements the following methods.
  
  =head2 basename
  
    my $name = $path->basename;
    my $name = $path->basename('.txt');
  
  Return the last level of the path with L<File::Basename>.
  
    # ".vimrc" (on UNIX)
    path('/home/sri/.vimrc')->basename;
  
    # "test" (on UNIX)
    path('/home/sri/test.txt')->basename('.txt');
  
  =head2 child
  
    my $child = $path->child('.vimrc');
  
  Return a new L<Mojo::File> object relative to the path.
  
    # "/home/sri/.vimrc" (on UNIX)
    path('/home')->child('sri', '.vimrc');
  
  =head2 copy_to
  
    my $destination = $path->copy_to('/home/sri');
    my $destination = $path->copy_to('/home/sri/.vimrc.backup');
  
  Copy file with L<File::Copy> and return the destination as a L<Mojo::File>
  object.
  
  =head2 dirname
  
    my $name = $path->dirname;
  
  Return all but the last level of the path with L<File::Basename> as a
  L<Mojo::File> object.
  
    # "/home/sri" (on UNIX)
    path('/home/sri/.vimrc')->dirname;
  
  =head2 is_abs
  
    my $bool = $path->is_abs;
  
  Check if the path is absolute.
  
    # True (on UNIX)
    path('/home/sri/.vimrc')->is_abs;
  
    # False (on UNIX)
    path('.vimrc')->is_abs;
  
  =head2 list
  
    my $collection = $path->list;
    my $collection = $path->list({hidden => 1});
  
  List all files in the directory and return a L<Mojo::Collection> object
  containing the results as L<Mojo::File> objects. The list does not include C<.>
  and C<..>.
  
    # List files
    say for path('/home/sri/myapp')->list->each;
  
  These options are currently available:
  
  =over 2
  
  =item dir
  
    dir => 1
  
  Include directories.
  
  =item hidden
  
    hidden => 1
  
  Include hidden files.
  
  =back
  
  =head2 list_tree
  
    my $collection = $path->list_tree;
    my $collection = $path->list_tree({hidden => 1});
  
  List all files recursively in the directory and return a L<Mojo::Collection>
  object containing the results as L<Mojo::File> objects. The list does not
  include C<.> and C<..>.
  
    # List all templates
    say for path('/home/sri/myapp/templates')->list_tree->each;
  
  These options are currently available:
  
  =over 2
  
  =item dir
  
    dir => 1
  
  Include directories.
  
  =item dont_use_nlink
  
    dont_use_nlink => 1
  
  Force L<File::Find> to always stat directories.
  
  =item hidden
  
    hidden => 1
  
  Include hidden files and directories.
  
  =back
  
  =head2 make_path
  
    $path = $path->make_path;
    $path = $path->make_path({mode => 0711});
  
  Create the directories if they don't already exist, any additional arguments are
  passed through to L<File::Path>.
  
  =head2 move_to
  
    my $destination = $path->move_to('/home/sri');
    my $destination = $path->move_to('/home/sri/.vimrc.backup');
  
  Move file with L<File::Copy> and return the destination as a L<Mojo::File>
  object.
  
  =head2 new
  
    my $path = Mojo::File->new;
    my $path = Mojo::File->new('/home/sri/.vimrc');
    my $path = Mojo::File->new('/home', 'sri', '.vimrc');
    my $path = Mojo::File->new(File::Temp->new);
    my $path = Mojo::File->new(File::Temp->newdir);
  
  Construct a new L<Mojo::File> object, defaults to using the current working
  directory.
  
    # "foo/bar/baz.txt" (on UNIX)
    Mojo::File->new('foo', 'bar', 'baz.txt');
  
  =head2 open
  
    my $handle = $path->open('+<');
    my $handle = $path->open('r+');
    my $handle = $path->open(O_RDWR);
    my $handle = $path->open('<:encoding(UTF-8)');
  
  Open file with L<IO::File>.
  
    # Combine "fcntl.h" constants
    use Fcntl qw(O_CREAT O_EXCL O_RDWR);
    my $handle = path('/home/sri/test.pl')->open(O_RDWR | O_CREAT | O_EXCL);
  
  =head2 realpath
  
    my $realpath = $path->realpath;
  
  Resolve the path with L<Cwd> and return the result as a L<Mojo::File> object.
  
  =head2 remove_tree
  
    $path = $path->remove_tree;
    $path = $path->remove_tree({keep_root => 1});
  
  Delete this directory and any files and subdirectories it may contain, any
  additional arguments are passed through to L<File::Path>.
  
  =head2 sibling
  
    my $sibling = $path->sibling('.vimrc');
  
  Return a new L<Mojo::File> object relative to the directory part of the path.
  
    # "/home/sri/.vimrc" (on UNIX)
    path('/home/sri/.bashrc')->sibling('.vimrc');
  
    # "/home/sri/.ssh/known_hosts" (on UNIX)
    path('/home/sri/.bashrc')->sibling('.ssh', 'known_hosts');
  
  =head2 slurp
  
    my $bytes = $path->slurp;
  
  Read all data at once from the file.
  
  =head2 spurt
  
    $path = $path->spurt($bytes);
    $path = $path->spurt(@chunks_of_bytes);
  
  Write all data at once to the file.
  
  =head2 tap
  
    $path = $path->tap(sub {...});
  
  Alias for L<Mojo::Base/"tap">.
  
  =head2 to_abs
  
    my $absolute = $path->to_abs;
  
  Return absolute path as a L<Mojo::File> object, the path does not need to exist
  on the file system.
  
  =head2 to_array
  
    my $parts = $path->to_array;
  
  Split the path on directory separators.
  
    # "home:sri:.vimrc" (on UNIX)
    join ':', @{path('/home/sri/.vimrc')->to_array};
  
  =head2 to_rel
  
    my $relative = $path->to_rel('/some/base/path');
  
  Return a relative path from the original path to the destination path as a
  L<Mojo::File> object.
  
    # "sri/.vimrc" (on UNIX)
    path('/home/sri/.vimrc')->to_rel('/home');
  
  =head2 to_string
  
    my $str = $path->to_string;
  
  Stringify the path.
  
  =head2 with_roles
  
    my $new_class = Mojo::File->with_roles('Mojo::File::Role::One');
    my $new_class = Mojo::File->with_roles('+One', '+Two');
    $path         = $path->with_roles('+One', '+Two');
  
  Alias for L<Mojo::Base/"with_roles">.
  
  =head1 OPERATORS
  
  L<Mojo::File> overloads the following operators.
  
  =head2 array
  
    my @parts = @$path;
  
  Alias for L</"to_array">.
  
  =head2 bool
  
    my $bool = !!$path;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$path";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_FILE

$fatpacked{"Mojo/Headers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_HEADERS';
  package Mojo::Headers;
  use Mojo::Base -base;
  
  use Mojo::Util 'monkey_patch';
  
  has max_line_size => sub { $ENV{MOJO_MAX_LINE_SIZE} || 8192 };
  has max_lines     => sub { $ENV{MOJO_MAX_LINES}     || 100 };
  
  # Common headers
  my %NAMES = map { lc() => $_ } (
    qw(Accept Accept-Charset Accept-Encoding Accept-Language Accept-Ranges),
    qw(Access-Control-Allow-Origin Allow Authorization Cache-Control Connection),
    qw(Content-Disposition Content-Encoding Content-Language Content-Length),
    qw(Content-Location Content-Range Content-Security-Policy Content-Type),
    qw(Cookie DNT Date ETag Expect Expires Host If-Modified-Since If-None-Match),
    qw(Last-Modified Link Location Origin Proxy-Authenticate),
    qw(Proxy-Authorization Range Sec-WebSocket-Accept Sec-WebSocket-Extensions),
    qw(Sec-WebSocket-Key Sec-WebSocket-Protocol Sec-WebSocket-Version Server),
    qw(Server-Timing Set-Cookie Status Strict-Transport-Security TE Trailer),
    qw(Transfer-Encoding Upgrade User-Agent Vary WWW-Authenticate)
  );
  for my $header (keys %NAMES) {
    my $name = $header;
    $name =~ y/-/_/;
    monkey_patch __PACKAGE__, $name, sub {
      my $self = shift;
      $self->{headers}{$header} = [@_] and return $self if @_;
      return undef unless my $headers = $self->{headers}{$header};
      return join ', ', @$headers;
    };
  }
  
  sub add {
    my ($self, $name) = (shift, shift);
  
    # Make sure we have a normal case entry for name
    my $key = lc $name;
    $self->{names}{$key} //= $name unless $NAMES{$key};
    push @{$self->{headers}{$key}}, @_;
  
    return $self;
  }
  
  sub append {
    my ($self, $name, $value) = @_;
    my $old = $self->header($name);
    return $self->header($name => defined $old ? "$old, $value" : $value);
  }
  
  sub clone { $_[0]->new->from_hash($_[0]->to_hash(1)) }
  
  sub every_header { shift->{headers}{lc shift} || [] }
  
  sub from_hash {
    my ($self, $hash) = @_;
  
    # Empty hash deletes all headers
    delete $self->{headers} if keys %{$hash} == 0;
  
    # Merge
    for my $header (keys %$hash) {
      my $value = $hash->{$header};
      $self->add($header => ref $value eq 'ARRAY' ? @$value : $value);
    }
  
    return $self;
  }
  
  sub header {
    my ($self, $name) = (shift, shift);
  
    # Replace
    return $self->remove($name)->add($name, @_) if @_;
  
    return undef unless my $headers = $self->{headers}{lc $name};
    return join ', ', @$headers;
  }
  
  sub is_finished { (shift->{state} // '') eq 'finished' }
  
  sub is_limit_exceeded { !!shift->{limit} }
  
  sub leftovers { delete shift->{buffer} }
  
  sub names {
    my $self = shift;
    return [map { $NAMES{$_} || $self->{names}{$_} } keys %{$self->{headers}}];
  }
  
  sub parse {
    my ($self, $chunk) = @_;
  
    $self->{state} = 'headers';
    $self->{buffer} .= $chunk;
    my $headers = $self->{cache} ||= [];
    my $size    = $self->max_line_size;
    my $lines   = $self->max_lines;
    while ($self->{buffer} =~ s/^(.*?)\x0d?\x0a//) {
      my $line = $1;
  
      # Check line size limit
      if ($+[0] > $size || @$headers >= $lines) {
        @$self{qw(state limit)} = ('finished', 1);
        return $self;
      }
  
      # New header
      if ($line =~ /^(\S[^:]*)\s*:\s*(.*)$/) { push @$headers, [$1, $2] }
  
      # Multi-line
      elsif ($line =~ s/^\s+// && @$headers) { $headers->[-1][1] .= " $line" }
  
      # Empty line
      else {
        $self->add(@$_) for @$headers;
        @$self{qw(state cache)} = ('finished', []);
        return $self;
      }
    }
  
    # Check line size limit
    @$self{qw(state limit)} = ('finished', 1) if length $self->{buffer} > $size;
  
    return $self;
  }
  
  sub referrer { shift->header(Referer => @_) }
  
  sub remove {
    my ($self, $name) = @_;
    delete $self->{headers}{lc $name};
    return $self;
  }
  
  sub to_hash {
    my ($self, $multi) = @_;
    return {map { $_ => $self->{headers}{lc $_} } @{$self->names}} if $multi;
    return {map { $_ => $self->header($_) } @{$self->names}};
  }
  
  sub to_string {
    my $self = shift;
  
    # Make sure multi-line values are formatted correctly
    my @headers;
    for my $name (@{$self->names}) {
      push @headers, "$name: $_" for @{$self->{headers}{lc $name}};
    }
  
    return join "\x0d\x0a", @headers;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Headers - HTTP headers
  
  =head1 SYNOPSIS
  
    use Mojo::Headers;
  
    # Parse
    my $headers = Mojo::Headers->new;
    $headers->parse("Content-Length: 42\x0d\x0a");
    $headers->parse("Content-Type: text/html\x0d\x0a\x0d\x0a");
    say $headers->content_length;
    say $headers->content_type;
  
    # Build
    my $headers = Mojo::Headers->new;
    $headers->content_length(42);
    $headers->content_type('text/plain');
    say $headers->to_string;
  
  =head1 DESCRIPTION
  
  L<Mojo::Headers> is a container for HTTP headers, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230> and
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Headers> implements the following attributes.
  
  =head2 max_line_size
  
    my $size = $headers->max_line_size;
    $headers = $headers->max_line_size(1024);
  
  Maximum header line size in bytes, defaults to the value of the
  C<MOJO_MAX_LINE_SIZE> environment variable or C<8192> (8KiB).
  
  =head2 max_lines
  
    my $num  = $headers->max_lines;
    $headers = $headers->max_lines(200);
  
  Maximum number of header lines, defaults to the value of the C<MOJO_MAX_LINES>
  environment variable or C<100>.
  
  =head1 METHODS
  
  L<Mojo::Headers> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 accept
  
    my $accept = $headers->accept;
    $headers   = $headers->accept('application/json');
  
  Get or replace current header value, shortcut for the C<Accept> header.
  
  =head2 accept_charset
  
    my $charset = $headers->accept_charset;
    $headers    = $headers->accept_charset('UTF-8');
  
  Get or replace current header value, shortcut for the C<Accept-Charset> header.
  
  =head2 accept_encoding
  
    my $encoding = $headers->accept_encoding;
    $headers     = $headers->accept_encoding('gzip');
  
  Get or replace current header value, shortcut for the C<Accept-Encoding> header.
  
  =head2 accept_language
  
    my $language = $headers->accept_language;
    $headers     = $headers->accept_language('de, en');
  
  Get or replace current header value, shortcut for the C<Accept-Language> header.
  
  =head2 accept_ranges
  
    my $ranges = $headers->accept_ranges;
    $headers   = $headers->accept_ranges('bytes');
  
  Get or replace current header value, shortcut for the C<Accept-Ranges> header.
  
  =head2 access_control_allow_origin
  
    my $origin = $headers->access_control_allow_origin;
    $headers   = $headers->access_control_allow_origin('*');
  
  Get or replace current header value, shortcut for the
  C<Access-Control-Allow-Origin> header from
  L<Cross-Origin Resource Sharing|http://www.w3.org/TR/cors/>.
  
  =head2 add
  
    $headers = $headers->add(Foo => 'one value');
    $headers = $headers->add(Foo => 'first value', 'second value');
  
  Add header with one or more lines.
  
    # "Vary: Accept
    #  Vary: Accept-Encoding"
    $headers->add(Vary => 'Accept')->add(Vary => 'Accept-Encoding')->to_string;
  
  =head2 allow
  
    my $allow = $headers->allow;
    $headers  = $headers->allow('GET, POST');
  
  Get or replace current header value, shortcut for the C<Allow> header.
  
  =head2 append
  
    $headers = $headers->append(Vary => 'Accept-Encoding');
  
  Append value to header and flatten it if necessary.
  
    # "Vary: Accept"
    $headers->append(Vary => 'Accept')->to_string;
  
    # "Vary: Accept, Accept-Encoding"
    $headers->vary('Accept')->append(Vary => 'Accept-Encoding')->to_string;
  
  =head2 authorization
  
    my $authorization = $headers->authorization;
    $headers          = $headers->authorization('Basic Zm9vOmJhcg==');
  
  Get or replace current header value, shortcut for the C<Authorization> header.
  
  =head2 cache_control
  
    my $cache_control = $headers->cache_control;
    $headers          = $headers->cache_control('max-age=1, no-cache');
  
  Get or replace current header value, shortcut for the C<Cache-Control> header.
  
  =head2 clone
  
    my $clone = $headers->clone;
  
  Return a new L<Mojo::Headers> object cloned from these headers.
  
  =head2 connection
  
    my $connection = $headers->connection;
    $headers       = $headers->connection('close');
  
  Get or replace current header value, shortcut for the C<Connection> header.
  
  =head2 content_disposition
  
    my $disposition = $headers->content_disposition;
    $headers        = $headers->content_disposition('foo');
  
  Get or replace current header value, shortcut for the C<Content-Disposition>
  header.
  
  =head2 content_encoding
  
    my $encoding = $headers->content_encoding;
    $headers     = $headers->content_encoding('gzip');
  
  Get or replace current header value, shortcut for the C<Content-Encoding>
  header.
  
  =head2 content_language
  
    my $language = $headers->content_language;
    $headers     = $headers->content_language('en');
  
  Get or replace current header value, shortcut for the C<Content-Language>
  header.
  
  =head2 content_length
  
    my $len  = $headers->content_length;
    $headers = $headers->content_length(4000);
  
  Get or replace current header value, shortcut for the C<Content-Length> header.
  
  =head2 content_location
  
    my $location = $headers->content_location;
    $headers     = $headers->content_location('http://127.0.0.1/foo');
  
  Get or replace current header value, shortcut for the C<Content-Location>
  header.
  
  =head2 content_range
  
    my $range = $headers->content_range;
    $headers  = $headers->content_range('bytes 2-8/100');
  
  Get or replace current header value, shortcut for the C<Content-Range> header.
  
  =head2 content_security_policy
  
    my $policy = $headers->content_security_policy;
    $headers   = $headers->content_security_policy('default-src https:');
  
  Get or replace current header value, shortcut for the C<Content-Security-Policy>
  header from L<Content Security Policy 1.0|http://www.w3.org/TR/CSP/>.
  
  =head2 content_type
  
    my $type = $headers->content_type;
    $headers = $headers->content_type('text/plain');
  
  Get or replace current header value, shortcut for the C<Content-Type> header.
  
  =head2 cookie
  
    my $cookie = $headers->cookie;
    $headers   = $headers->cookie('f=b');
  
  Get or replace current header value, shortcut for the C<Cookie> header from
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head2 date
  
    my $date = $headers->date;
    $headers = $headers->date('Sun, 17 Aug 2008 16:27:35 GMT');
  
  Get or replace current header value, shortcut for the C<Date> header.
  
  =head2 dnt
  
    my $dnt  = $headers->dnt;
    $headers = $headers->dnt(1);
  
  Get or replace current header value, shortcut for the C<DNT> (Do Not Track)
  header, which has no specification yet, but is very commonly used.
  
  =head2 etag
  
    my $etag = $headers->etag;
    $headers = $headers->etag('"abc321"');
  
  Get or replace current header value, shortcut for the C<ETag> header.
  
  =head2 every_header
  
    my $all = $headers->every_header('Location');
  
  Similar to L</"header">, but returns all headers sharing the same name as an
  array reference.
  
    # Get first header value
    say $headers->every_header('Location')->[0];
  
  =head2 expect
  
    my $expect = $headers->expect;
    $headers   = $headers->expect('100-continue');
  
  Get or replace current header value, shortcut for the C<Expect> header.
  
  =head2 expires
  
    my $expires = $headers->expires;
    $headers    = $headers->expires('Thu, 01 Dec 1994 16:00:00 GMT');
  
  Get or replace current header value, shortcut for the C<Expires> header.
  
  =head2 from_hash
  
    $headers = $headers->from_hash({'Cookie' => 'a=b'});
    $headers = $headers->from_hash({'Cookie' => ['a=b', 'c=d']});
    $headers = $headers->from_hash({});
  
  Parse headers from a hash reference, an empty hash removes all headers.
  
  =head2 header
  
    my $value = $headers->header('Foo');
    $headers  = $headers->header(Foo => 'one value');
    $headers  = $headers->header(Foo => 'first value', 'second value');
  
  Get or replace the current header values.
  
  =head2 host
  
    my $host = $headers->host;
    $headers = $headers->host('127.0.0.1');
  
  Get or replace current header value, shortcut for the C<Host> header.
  
  =head2 if_modified_since
  
    my $date = $headers->if_modified_since;
    $headers = $headers->if_modified_since('Sun, 17 Aug 2008 16:27:35 GMT');
  
  Get or replace current header value, shortcut for the C<If-Modified-Since>
  header.
  
  =head2 if_none_match
  
    my $etag = $headers->if_none_match;
    $headers = $headers->if_none_match('"abc321"');
  
  Get or replace current header value, shortcut for the C<If-None-Match> header.
  
  =head2 is_finished
  
    my $bool = $headers->is_finished;
  
  Check if header parser is finished.
  
  =head2 is_limit_exceeded
  
    my $bool = $headers->is_limit_exceeded;
  
  Check if headers have exceeded L</"max_line_size"> or L</"max_lines">.
  
  =head2 last_modified
  
    my $date = $headers->last_modified;
    $headers = $headers->last_modified('Sun, 17 Aug 2008 16:27:35 GMT');
  
  Get or replace current header value, shortcut for the C<Last-Modified> header.
  
  =head2 leftovers
  
    my $bytes = $headers->leftovers;
  
  Get and remove leftover data from header parser.
  
  =head2 link
  
    my $link = $headers->link;
    $headers = $headers->link('<http://127.0.0.1/foo/3>; rel="next"');
  
  Get or replace current header value, shortcut for the C<Link> header from
  L<RFC 5988|http://tools.ietf.org/html/rfc5988>.
  
  =head2 location
  
    my $location = $headers->location;
    $headers     = $headers->location('http://127.0.0.1/foo');
  
  Get or replace current header value, shortcut for the C<Location> header.
  
  =head2 names
  
    my $names = $headers->names;
  
  Return an array reference with all currently defined headers.
  
    # Names of all headers
    say for @{$headers->names};
  
  =head2 origin
  
    my $origin = $headers->origin;
    $headers   = $headers->origin('http://example.com');
  
  Get or replace current header value, shortcut for the C<Origin> header from
  L<RFC 6454|http://tools.ietf.org/html/rfc6454>.
  
  =head2 parse
  
    $headers = $headers->parse("Content-Type: text/plain\x0d\x0a\x0d\x0a");
  
  Parse formatted headers.
  
  =head2 proxy_authenticate
  
    my $authenticate = $headers->proxy_authenticate;
    $headers         = $headers->proxy_authenticate('Basic "realm"');
  
  Get or replace current header value, shortcut for the C<Proxy-Authenticate>
  header.
  
  =head2 proxy_authorization
  
    my $authorization = $headers->proxy_authorization;
    $headers          = $headers->proxy_authorization('Basic Zm9vOmJhcg==');
  
  Get or replace current header value, shortcut for the C<Proxy-Authorization>
  header.
  
  =head2 range
  
    my $range = $headers->range;
    $headers  = $headers->range('bytes=2-8');
  
  Get or replace current header value, shortcut for the C<Range> header.
  
  =head2 referrer
  
    my $referrer = $headers->referrer;
    $headers     = $headers->referrer('http://example.com');
  
  Get or replace current header value, shortcut for the C<Referer> header, there
  was a typo in L<RFC 2068|http://tools.ietf.org/html/rfc2068> which resulted in
  C<Referer> becoming an official header.
  
  =head2 remove
  
    $headers = $headers->remove('Foo');
  
  Remove a header.
  
  =head2 sec_websocket_accept
  
    my $accept = $headers->sec_websocket_accept;
    $headers   = $headers->sec_websocket_accept('s3pPLMBiTxaQ9kYGzzhZRbK+xOo=');
  
  Get or replace current header value, shortcut for the C<Sec-WebSocket-Accept>
  header from L<RFC 6455|http://tools.ietf.org/html/rfc6455>.
  
  =head2 sec_websocket_extensions
  
    my $extensions = $headers->sec_websocket_extensions;
    $headers       = $headers->sec_websocket_extensions('foo');
  
  Get or replace current header value, shortcut for the
  C<Sec-WebSocket-Extensions> header from
  L<RFC 6455|http://tools.ietf.org/html/rfc6455>.
  
  =head2 sec_websocket_key
  
    my $key  = $headers->sec_websocket_key;
    $headers = $headers->sec_websocket_key('dGhlIHNhbXBsZSBub25jZQ==');
  
  Get or replace current header value, shortcut for the C<Sec-WebSocket-Key>
  header from L<RFC 6455|http://tools.ietf.org/html/rfc6455>.
  
  =head2 sec_websocket_protocol
  
    my $proto = $headers->sec_websocket_protocol;
    $headers  = $headers->sec_websocket_protocol('sample');
  
  Get or replace current header value, shortcut for the C<Sec-WebSocket-Protocol>
  header from L<RFC 6455|http://tools.ietf.org/html/rfc6455>.
  
  =head2 sec_websocket_version
  
    my $version = $headers->sec_websocket_version;
    $headers    = $headers->sec_websocket_version(13);
  
  Get or replace current header value, shortcut for the C<Sec-WebSocket-Version>
  header from L<RFC 6455|http://tools.ietf.org/html/rfc6455>.
  
  =head2 server
  
    my $server = $headers->server;
    $headers   = $headers->server('Mojo');
  
  Get or replace current header value, shortcut for the C<Server> header.
  
  =head2 server_timing
  
    my $timing = $headers->server_timing;
    $headers   = $headers->server_timing('app;desc=Mojolicious;dur=0.0001');
  
  Get or replace current header value, shortcut for the C<Server-Timing> header
  from L<Server Timing|https://www.w3.org/TR/server-timing/>.
  Note that this method is EXPERIMENTAL and might change without warning!
  
  =head2 set_cookie
  
    my $cookie = $headers->set_cookie;
    $headers   = $headers->set_cookie('f=b; path=/');
  
  Get or replace current header value, shortcut for the C<Set-Cookie> header from
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head2 status
  
    my $status = $headers->status;
    $headers   = $headers->status('200 OK');
  
  Get or replace current header value, shortcut for the C<Status> header from
  L<RFC 3875|http://tools.ietf.org/html/rfc3875>.
  
  =head2 strict_transport_security
  
    my $policy = $headers->strict_transport_security;
    $headers   = $headers->strict_transport_security('max-age=31536000');
  
  Get or replace current header value, shortcut for the
  C<Strict-Transport-Security> header from
  L<RFC 6797|http://tools.ietf.org/html/rfc6797>.
  
  =head2 te
  
    my $te   = $headers->te;
    $headers = $headers->te('chunked');
  
  Get or replace current header value, shortcut for the C<TE> header.
  
  =head2 to_hash
  
    my $single = $headers->to_hash;
    my $multi  = $headers->to_hash(1);
  
  Turn headers into hash reference, array references to represent multiple
  headers with the same name are disabled by default.
  
    say $headers->to_hash->{DNT};
  
  =head2 to_string
  
    my $str = $headers->to_string;
  
  Turn headers into a string, suitable for HTTP messages.
  
  =head2 trailer
  
    my $trailer = $headers->trailer;
    $headers    = $headers->trailer('X-Foo');
  
  Get or replace current header value, shortcut for the C<Trailer> header.
  
  =head2 transfer_encoding
  
    my $encoding = $headers->transfer_encoding;
    $headers     = $headers->transfer_encoding('chunked');
  
  Get or replace current header value, shortcut for the C<Transfer-Encoding>
  header.
  
  =head2 upgrade
  
    my $upgrade = $headers->upgrade;
    $headers    = $headers->upgrade('websocket');
  
  Get or replace current header value, shortcut for the C<Upgrade> header.
  
  =head2 user_agent
  
    my $agent = $headers->user_agent;
    $headers  = $headers->user_agent('Mojo/1.0');
  
  Get or replace current header value, shortcut for the C<User-Agent> header.
  
  =head2 vary
  
    my $vary = $headers->vary;
    $headers = $headers->vary('*');
  
  Get or replace current header value, shortcut for the C<Vary> header.
  
  =head2 www_authenticate
  
    my $authenticate = $headers->www_authenticate;
    $headers         = $headers->www_authenticate('Basic realm="realm"');
  
  Get or replace current header value, shortcut for the C<WWW-Authenticate>
  header.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_HEADERS

$fatpacked{"Mojo/HelloWorld.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_HELLOWORLD';
  package Mojo::HelloWorld;
  use Mojo::Base 'Mojolicious';
  
  sub startup {
    my $self = shift;
    $self->log->level('error')->path(undef);
    $self->routes->any(
      '/*whatever' => {whatever => '', text => 'Your Mojo is working!'});
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::HelloWorld - Hello World!
  
  =head1 SYNOPSIS
  
    use Mojo::HelloWorld;
  
    my $hello = Mojo::HelloWorld->new;
    $hello->start;
  
  =head1 DESCRIPTION
  
  L<Mojo::HelloWorld> is the default L<Mojolicious> application, used mostly for
  testing.
  
  =head1 ATTRIBUTES
  
  L<Mojo::HelloWorld> inherits all attributes from L<Mojolicious>.
  
  =head1 METHODS
  
  L<Mojo::HelloWorld> inherits all methods from L<Mojolicious> and implements the
  following new ones.
  
  =head2 startup
  
    $hello->startup;
  
  Creates a catch-all route that renders a text message.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_HELLOWORLD

$fatpacked{"Mojo/Home.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_HOME';
  package Mojo::Home;
  use Mojo::Base 'Mojo::File';
  
  use Mojo::Util 'class_to_path';
  
  sub detect {
    my ($self, $class) = @_;
  
    # Environment variable
    my $home;
    if ($ENV{MOJO_HOME}) { $home = Mojo::File->new($ENV{MOJO_HOME})->to_array }
  
    # Location of the application class (Windows mixes backslash and slash)
    elsif ($class && (my $path = $INC{my $file = class_to_path $class})) {
      $home = Mojo::File->new($path)->to_array;
      splice @$home, (my @dummy = split('/', $file)) * -1;
      @$home && $home->[-1] eq $_ && pop @$home for qw(lib blib);
    }
  
    $$self = Mojo::File->new(@$home)->to_abs->to_string if $home;
    return $self;
  }
  
  sub mojo_lib_dir { shift->new(__FILE__)->sibling('..') }
  
  sub rel_file { shift->child(split('/', shift)) }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Home - Home sweet home
  
  =head1 SYNOPSIS
  
    use Mojo::Home;
  
    # Find and manage the project root directory
    my $home = Mojo::Home->new;
    $home->detect;
    say $home->child('templates', 'layouts', 'default.html.ep');
    say "$home";
  
  =head1 DESCRIPTION
  
  L<Mojo::Home> is a container for home directories based on L<Mojo::File>.
  
  =head1 METHODS
  
  L<Mojo::Home> inherits all methods from L<Mojo::File> and implements the
  following new ones.
  
  =head2 detect
  
    $home = $home->detect;
    $home = $home->detect('My::App');
  
  Detect home directory from the value of the C<MOJO_HOME> environment variable or
  the location of the application class.
  
  =head2 mojo_lib_dir
  
    my $path = $home->mojo_lib_dir;
  
  Path to C<lib> directory in which L<Mojolicious> is installed as a L<Mojo::Home>
  object.
  
  =head2 rel_file
  
    my $path = $home->rel_file('foo/bar.html');
  
  Return a new L<Mojo::Home> object relative to the home directory.
  
  =head1 OPERATORS
  
  L<Mojo::Home> inherits all overloaded operators from L<Mojo::File>.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_HOME

$fatpacked{"Mojo/IOLoop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP';
  package Mojo::IOLoop;
  use Mojo::Base 'Mojo::EventEmitter';
  
  # "Professor: Amy, technology isn't intrinsically good or evil. It's how it's
  #             used. Like the death ray."
  use Carp 'croak';
  use Mojo::IOLoop::Client;
  use Mojo::IOLoop::Delay;
  use Mojo::IOLoop::Server;
  use Mojo::IOLoop::Stream;
  use Mojo::IOLoop::Subprocess;
  use Mojo::Reactor::Poll;
  use Mojo::Util qw(md5_sum steady_time);
  use Scalar::Util qw(blessed weaken);
  
  use constant DEBUG => $ENV{MOJO_IOLOOP_DEBUG} || 0;
  
  has max_accepts     => 0;
  has max_connections => 1000;
  has reactor         => sub {
    my $class = Mojo::Reactor::Poll->detect;
    warn "-- Reactor initialized ($class)\n" if DEBUG;
    return $class->new->catch(sub { warn "@{[blessed $_[0]]}: $_[1]" });
  };
  
  # Ignore PIPE signal
  $SIG{PIPE} = 'IGNORE';
  
  # Initialize singleton reactor early
  __PACKAGE__->singleton->reactor;
  
  sub acceptor {
    my ($self, $acceptor) = (_instance(shift), @_);
  
    # Find acceptor for id
    return $self->{acceptors}{$acceptor} unless ref $acceptor;
  
    # Connect acceptor with reactor
    $self->{acceptors}{my $id = $self->_id} = $acceptor;
    weaken $acceptor->reactor($self->reactor)->{reactor};
  
    # Allow new acceptor to get picked up
    $self->_not_accepting->_maybe_accepting;
  
    return $id;
  }
  
  sub client {
    my ($self, $cb) = (_instance(shift), pop);
    my $args = ref $_[0] ? $_[0] : {@_};
  
    my $id = $self->_id;
    my $client = $self->{out}{$id}{client} = Mojo::IOLoop::Client->new;
    weaken $client->reactor($self->reactor)->{reactor};
    my $class = delete $args->{stream_class} || 'Mojo::IOLoop::Stream';
  
    weaken $self;
    $client->on(
      connect => sub {
        delete $self->{out}{$id}{client};
        my $stream = $class->new(pop);
        $self->_stream($stream => $id);
        $self->$cb(undef, $stream);
      }
    );
    $client->on(error => sub { $self->_remove($id); $self->$cb(pop, undef) });
    $client->connect($args);
  
    return $id;
  }
  
  sub delay {
    my $delay = Mojo::IOLoop::Delay->new;
    weaken $delay->ioloop(_instance(shift))->{ioloop};
    return @_ ? $delay->steps(@_) : $delay;
  }
  
  sub is_running { _instance(shift)->reactor->is_running }
  
  sub next_tick {
    my ($self, $cb) = (_instance(shift), @_);
    weaken $self;
    return $self->reactor->next_tick(sub { $self->$cb });
  }
  
  sub one_tick {
    my $self = _instance(shift);
    croak 'Mojo::IOLoop already running' if $self->is_running;
    $self->reactor->one_tick;
  }
  
  sub recurring { shift->_timer(recurring => @_) }
  
  sub remove {
    my ($self, $id) = (_instance(shift), @_);
    my $c = $self->{in}{$id} || $self->{out}{$id};
    if ($c && (my $stream = $c->{stream})) { return $stream->close_gracefully }
    $self->_remove($id);
  }
  
  sub reset {
    my $self = _instance(shift);
    delete @$self{qw(accepting acceptors events in out stop)};
    $self->reactor->reset;
    $self->stop;
  }
  
  sub server {
    my ($self, $cb) = (_instance(shift), pop);
    my $args = ref $_[0] ? $_[0] : {@_};
  
    my $server = Mojo::IOLoop::Server->new;
    my $class = delete $args->{stream_class} || 'Mojo::IOLoop::Stream';
    weaken $self;
    $server->on(
      accept => sub {
        my $stream = $class->new(pop);
        $self->$cb($stream, $self->_stream($stream, $self->_id, 1));
  
        # Enforce connection limit (randomize to improve load balancing)
        if (my $max = $self->max_accepts) {
          $self->{accepts} //= $max - int rand $max / 2;
          $self->stop_gracefully if ($self->{accepts} -= 1) <= 0;
        }
  
        # Stop accepting if connection limit has been reached
        $self->_not_accepting if $self->_limit;
      }
    );
    $server->listen($args);
  
    return $self->acceptor($server);
  }
  
  sub singleton { state $loop = shift->SUPER::new }
  
  sub start {
    my $self = _instance(shift);
    croak 'Mojo::IOLoop already running' if $self->is_running;
    $self->reactor->start;
  }
  
  sub stop { _instance(shift)->reactor->stop }
  
  sub stop_gracefully {
    my $self = _instance(shift)->_not_accepting;
    ++$self->{stop} and !$self->emit('finish')->_in and $self->stop;
  }
  
  sub stream {
    my ($self, $stream) = (_instance(shift), @_);
    return $self->_stream($stream => $self->_id) if ref $stream;
    my $c = $self->{in}{$stream} || $self->{out}{$stream} || {};
    return $c->{stream};
  }
  
  sub subprocess {
    my $subprocess = Mojo::IOLoop::Subprocess->new;
    weaken $subprocess->ioloop(_instance(shift))->{ioloop};
    return @_ ? $subprocess->run(@_) : $subprocess;
  }
  
  sub timer { shift->_timer(timer => @_) }
  
  sub transition {
    my ($self, $id, $class) = (_instance(shift), @_);
    my $new = $class->new($self->stream($id)->steal_handle);
    $self->_stream($new, $id, !!$self->{in}{$id});
    return $new;
  }
  
  sub _id {
    my $self = shift;
    my $id;
    do { $id = md5_sum 'c' . steady_time . rand }
      while $self->{in}{$id} || $self->{out}{$id} || $self->{acceptors}{$id};
    return $id;
  }
  
  sub _in { scalar keys %{shift->{in} || {}} }
  
  sub _instance { ref $_[0] ? $_[0] : $_[0]->singleton }
  
  sub _limit { $_[0]{stop} ? 1 : $_[0]->_in >= $_[0]->max_connections }
  
  sub _maybe_accepting {
    my $self = shift;
    return if $self->{accepting} || $self->_limit;
    $_->start for values %{$self->{acceptors} || {}};
    $self->{accepting} = 1;
  }
  
  sub _not_accepting {
    my $self = shift;
    return $self unless delete $self->{accepting};
    $_->stop for values %{$self->{acceptors} || {}};
    return $self;
  }
  
  sub _out { scalar keys %{shift->{out} || {}} }
  
  sub _remove {
    my ($self, $id) = @_;
  
    # Timer
    return unless my $reactor = $self->reactor;
    return if $reactor->remove($id);
  
    # Acceptor
    return $self->_not_accepting->_maybe_accepting
      if delete $self->{acceptors}{$id};
  
    # Connection
    return unless delete $self->{in}{$id} || delete $self->{out}{$id};
    return $self->stop if $self->{stop} && !$self->_in;
    $self->_maybe_accepting;
    warn "-- $id <<< $$ (@{[$self->_in]}:@{[$self->_out]})\n" if DEBUG;
  }
  
  sub _stream {
    my ($self, $stream, $id, $server) = @_;
  
    # Connect stream with reactor
    $self->{$server ? 'in' : 'out'}{$id}{stream} = $stream;
    warn "-- $id >>> $$ (@{[$self->_in]}:@{[$self->_out]})\n" if DEBUG;
    weaken $stream->reactor($self->reactor)->{reactor};
    weaken $self;
    $stream->on(close => sub { $self && $self->_remove($id) });
    $stream->start;
  
    return $id;
  }
  
  sub _timer {
    my ($self, $method, $after, $cb) = (_instance(shift), @_);
    weaken $self;
    return $self->reactor->$method($after => sub { $self->$cb });
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop - Minimalistic event loop
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop;
  
    # Listen on port 3000
    Mojo::IOLoop->server({port => 3000} => sub {
      my ($loop, $stream) = @_;
  
      $stream->on(read => sub {
        my ($stream, $bytes) = @_;
  
        # Process input chunk
        say $bytes;
  
        # Write response
        $stream->write('HTTP/1.1 200 OK');
      });
    });
  
    # Connect to port 3000
    my $id = Mojo::IOLoop->client({port => 3000} => sub {
      my ($loop, $err, $stream) = @_;
  
      $stream->on(read => sub {
        my ($stream, $bytes) = @_;
  
        # Process input
        say "Input: $bytes";
      });
  
      # Write request
      $stream->write("GET / HTTP/1.1\x0d\x0a\x0d\x0a");
    });
  
    # Add a timer
    Mojo::IOLoop->timer(5 => sub {
      my $loop = shift;
      $loop->remove($id);
    });
  
    # Start event loop if necessary
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop> is a very minimalistic event loop based on L<Mojo::Reactor>, it
  has been reduced to the absolute minimal feature set required to build solid
  and scalable non-blocking clients and servers.
  
  Depending on operating system, the default per-process and system-wide file
  descriptor limits are often very low and need to be tuned for better
  scalability. The C<LIBEV_FLAGS> environment variable should also be used to
  select the best possible L<EV> backend, which usually defaults to the not very
  scalable C<select>.
  
    LIBEV_FLAGS=1   # select
    LIBEV_FLAGS=2   # poll
    LIBEV_FLAGS=4   # epoll (Linux)
    LIBEV_FLAGS=8   # kqueue (*BSD, OS X)
  
  The event loop will be resilient to time jumps if a monotonic clock is
  available through L<Time::HiRes>. A TLS certificate and key are also built
  right in, to make writing test servers as easy as possible. Also note that for
  convenience the C<PIPE> signal will be set to C<IGNORE> when L<Mojo::IOLoop> is
  loaded.
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (2.009+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NNR>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"REAL-TIME WEB"> for more.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop> inherits all events from L<Mojo::EventEmitter> and can emit the
  following new ones.
  
  =head2 finish
  
    $loop->on(finish => sub {
      my $loop = shift;
      ...
    });
  
  Emitted when the event loop wants to shut down gracefully and is just waiting
  for all existing connections to be closed.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop> implements the following attributes.
  
  =head2 max_accepts
  
    my $max = $loop->max_accepts;
    $loop   = $loop->max_accepts(1000);
  
  The maximum number of connections this event loop is allowed to accept, before
  shutting down gracefully without interrupting existing connections, defaults to
  C<0>. Setting the value to C<0> will allow this event loop to accept new
  connections indefinitely. Note that up to half of this value can be subtracted
  randomly to improve load balancing between multiple server processes, and to
  make sure that not all of them restart at the same time.
  
  =head2 max_connections
  
    my $max = $loop->max_connections;
    $loop   = $loop->max_connections(100);
  
  The maximum number of accepted connections this event loop is allowed to handle
  concurrently, before stopping to accept new incoming connections, defaults to
  C<1000>.
  
  =head2 reactor
  
    my $reactor = $loop->reactor;
    $loop       = $loop->reactor(Mojo::Reactor->new);
  
  Low-level event reactor, usually a L<Mojo::Reactor::Poll> or
  L<Mojo::Reactor::EV> object with a default subscriber to the event
  L<Mojo::Reactor/"error">.
  
    # Watch if handle becomes readable or writable
    Mojo::IOLoop->singleton->reactor->io($handle => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Handle is writable' : 'Handle is readable';
    });
  
    # Change to watching only if handle becomes writable
    Mojo::IOLoop->singleton->reactor->watch($handle, 0, 1);
  
    # Remove handle again
    Mojo::IOLoop->singleton->reactor->remove($handle);
  
  =head1 METHODS
  
  L<Mojo::IOLoop> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 acceptor
  
    my $server = Mojo::IOLoop->acceptor($id);
    my $server = $loop->acceptor($id);
    my $id     = $loop->acceptor(Mojo::IOLoop::Server->new);
  
  Get L<Mojo::IOLoop::Server> object for id or turn object into an acceptor.
  
  =head2 client
  
    my $id
      = Mojo::IOLoop->client(address => '127.0.0.1', port => 3000, sub {...});
    my $id = $loop->client(address => '127.0.0.1', port => 3000, sub {...});
    my $id = $loop->client({address => '127.0.0.1', port => 3000} => sub {...});
  
  Open a TCP/IP or UNIX domain socket connection with L<Mojo::IOLoop::Client> and
  create a stream object (usually L<Mojo::IOLoop::Stream>), takes the same
  arguments as L<Mojo::IOLoop::Client/"connect"> in addition to C<stream_class>.
  
    # Connect to 127.0.0.1 on port 3000 with a custom stream class
    my $class = 'Mojo::IOLoop::Stream::HTTPClient';
    Mojo::IOLoop->client({port => 3000, stream_class => $class} => sub {
      my ($loop, $err, $stream) = @_;
      ...
    });
  
  =head2 delay
  
    my $delay = Mojo::IOLoop->delay;
    my $delay = $loop->delay;
    my $delay = $loop->delay(sub {...});
    my $delay = $loop->delay(sub {...}, sub {...});
  
  Build L<Mojo::IOLoop::Delay> object to use as a promise and/or for flow-control.
  Callbacks will be passed along to L<Mojo::IOLoop::Delay/"steps">.
  
    # Wrap continuation-passing style APIs with promises
    my $ua = Mojo::UserAgent->new;
    sub get {
      my $promise = Mojo::IOLoop->delay;
      $ua->get(@_ => sub {
        my ($ua, $tx) = @_;
        my $err = $tx->error;
        $promise->resolve($tx) if !$err || $err->{code};
        $promise->reject($err->{message});
      });
      return $promise;
    }
    my $mojo = get('https://mojolicious.org');
    my $cpan = get('https://metacpan.org');
    Mojo::Promise->race($mojo, $cpan)->then(sub { say shift->req->url })->wait;
  
    # Synchronize multiple non-blocking operations
    my $delay = Mojo::IOLoop->delay(sub { say 'BOOM!' });
    for my $i (1 .. 10) {
      my $end = $delay->begin;
      Mojo::IOLoop->timer($i => sub {
        say 10 - $i;
        $end->();
      });
    }
    $delay->wait;
  
    # Sequentialize multiple non-blocking operations
    Mojo::IOLoop->delay(
  
      # First step (simple timer)
      sub {
        my $delay = shift;
        Mojo::IOLoop->timer(2 => $delay->begin);
        say 'Second step in 2 seconds.';
      },
  
      # Second step (concurrent timers)
      sub {
        my $delay = shift;
        Mojo::IOLoop->timer(1 => $delay->begin);
        Mojo::IOLoop->timer(3 => $delay->begin);
        say 'Third step in 3 seconds.';
      },
  
      # Third step (the end)
      sub { say 'And done after 5 seconds total.' }
    )->wait;
  
  =head2 is_running
  
    my $bool = Mojo::IOLoop->is_running;
    my $bool = $loop->is_running;
  
  Check if event loop is running.
  
    exit unless Mojo::IOLoop->is_running;
  
  =head2 next_tick
  
    my $undef = Mojo::IOLoop->next_tick(sub {...});
    my $undef = $loop->next_tick(sub {...});
  
  Execute callback as soon as possible, but not before returning or other
  callbacks that have been registered with this method, always returns C<undef>.
  
    # Perform operation on next reactor tick
    Mojo::IOLoop->next_tick(sub {
      my $loop = shift;
      ...
    });
  
  =head2 one_tick
  
    Mojo::IOLoop->one_tick;
    $loop->one_tick;
  
  Run event loop until an event occurs.
  
    # Don't block longer than 0.5 seconds
    my $id = Mojo::IOLoop->timer(0.5 => sub {});
    Mojo::IOLoop->one_tick;
    Mojo::IOLoop->remove($id);
  
  =head2 recurring
  
    my $id = Mojo::IOLoop->recurring(3 => sub {...});
    my $id = $loop->recurring(0 => sub {...});
    my $id = $loop->recurring(0.25 => sub {...});
  
  Create a new recurring timer, invoking the callback repeatedly after a given
  amount of time in seconds.
  
    # Perform operation every 5 seconds
    Mojo::IOLoop->recurring(5 => sub {
      my $loop = shift;
      ...
    });
  
  =head2 remove
  
    Mojo::IOLoop->remove($id);
    $loop->remove($id);
  
  Remove anything with an id, connections will be dropped gracefully by allowing
  them to finish writing all data in their write buffers.
  
  =head2 reset
  
    Mojo::IOLoop->reset;
    $loop->reset;
  
  Remove everything and stop the event loop.
  
  =head2 server
  
    my $id = Mojo::IOLoop->server(port => 3000, sub {...});
    my $id = $loop->server(port => 3000, sub {...});
    my $id = $loop->server({port => 3000} => sub {...});
  
  Accept TCP/IP and UNIX domain socket connections with L<Mojo::IOLoop::Server>
  and create stream objects (usually L<Mojo::IOLoop::Stream>, takes the same
  arguments as L<Mojo::IOLoop::Server/"listen"> in addition to C<stream_class>.
  
    # Listen on port 3000 with a custom stream class
    my $class = 'Mojo::IOLoop::Stream::HTTPServer';
    Mojo::IOLoop->server({port => 3000, stream_class => $class} => sub {
      my ($loop, $stream, $id) = @_;
      ...
    });
  
    # Listen on random port
    my $id = Mojo::IOLoop->server({address => '127.0.0.1'} => sub {
      my ($loop, $stream, $id) = @_;
      ...
    });
    my $port = Mojo::IOLoop->acceptor($id)->port;
  
  =head2 singleton
  
    my $loop = Mojo::IOLoop->singleton;
  
  The global L<Mojo::IOLoop> singleton, used to access a single shared event loop
  object from everywhere inside the process.
  
    # Many methods also allow you to take shortcuts
    Mojo::IOLoop->timer(2 => sub { Mojo::IOLoop->stop });
    Mojo::IOLoop->start;
  
    # Restart active timer
    my $id = Mojo::IOLoop->timer(3 => sub { say 'Timeout!' });
    Mojo::IOLoop->singleton->reactor->again($id);
  
    # Turn file descriptor into handle and watch if it becomes readable
    my $handle = IO::Handle->new_from_fd($fd, 'r');
    Mojo::IOLoop->singleton->reactor->io($handle => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Handle is writable' : 'Handle is readable';
    })->watch($handle, 1, 0);
  
  =head2 start
  
    Mojo::IOLoop->start;
    $loop->start;
  
  Start the event loop, this will block until L</"stop"> is called. Note that
  some reactors stop automatically if there are no events being watched anymore.
  
    # Start event loop only if it is not running already
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 stop
  
    Mojo::IOLoop->stop;
    $loop->stop;
  
  Stop the event loop, this will not interrupt any existing connections and the
  event loop can be restarted by running L</"start"> again.
  
  =head2 stop_gracefully
  
    Mojo::IOLoop->stop_gracefully;
    $loop->stop_gracefully;
  
  Stop accepting new connections and wait for already accepted connections to be
  closed, before stopping the event loop.
  
  =head2 stream
  
    my $stream = Mojo::IOLoop->stream($id);
    my $stream = $loop->stream($id);
    my $id     = $loop->stream(Mojo::IOLoop::Stream->new);
  
  Get L<Mojo::IOLoop::Stream> object for id or turn object into a connection.
  
    # Increase inactivity timeout for connection to 300 seconds
    Mojo::IOLoop->stream($id)->timeout(300);
  
  =head2 subprocess
  
    my $subprocess = Mojo::IOLoop->subprocess(sub {...}, sub {...});
    my $subprocess = $loop->subprocess;
    my $subprocess = $loop->subprocess(sub {...}, sub {...});
  
  Build L<Mojo::IOLoop::Subprocess> object to perform computationally expensive
  operations in subprocesses, without blocking the event loop. Callbacks will be
  passed along to L<Mojo::IOLoop::Subprocess/"run">.
  
    # Operation that would block the event loop for 5 seconds
    Mojo::IOLoop->subprocess(
      sub {
        my $subprocess = shift;
        sleep 5;
        return '', 'Mojolicious';
      },
      sub {
        my ($subprocess, $err, @results) = @_;
        say "Subprocess error: $err" and return if $err;
        say "I $results[0] $results[1]!";
      }
    );
  
  =head2 timer
  
    my $id = Mojo::IOLoop->timer(3 => sub {...});
    my $id = $loop->timer(0 => sub {...});
    my $id = $loop->timer(0.25 => sub {...});
  
  Create a new timer, invoking the callback after a given amount of time in
  seconds.
  
    # Perform operation in 5 seconds
    Mojo::IOLoop->timer(5 => sub {
      my $loop = shift;
      ...
    });
  
  =head2 transition
  
    my $stream =
      Mojo::IOLoop->transition($id => 'Mojo::IOLoop::Stream::HTTPClient');
    my $stream = $loop->transition($id => 'Mojo::IOLoop::Stream::HTTPClient');
  
  Transition stream to a different class.
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_IOLOOP_DEBUG> environment variable to get some advanced
  diagnostics information printed to C<STDERR>.
  
    MOJO_IOLOOP_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_IOLOOP

$fatpacked{"Mojo/IOLoop/Client.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_CLIENT';
  package Mojo::IOLoop::Client;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Errno 'EINPROGRESS';
  use IO::Socket::IP;
  use IO::Socket::UNIX;
  use Mojo::IOLoop;
  use Mojo::IOLoop::TLS;
  use Scalar::Util 'weaken';
  use Socket qw(IPPROTO_TCP SOCK_STREAM TCP_NODELAY);
  
  # Non-blocking name resolution requires Net::DNS::Native
  use constant NNR => $ENV{MOJO_NO_NNR}
    ? 0
    : eval { require Net::DNS::Native; Net::DNS::Native->VERSION('0.15'); 1 };
  my $NDN;
  
  # SOCKS support requires IO::Socket::Socks
  use constant SOCKS => $ENV{MOJO_NO_SOCKS}
    ? 0
    : eval { require IO::Socket::Socks; IO::Socket::Socks->VERSION('0.64'); 1 };
  use constant READ  => SOCKS ? IO::Socket::Socks::SOCKS_WANT_READ()  : 0;
  use constant WRITE => SOCKS ? IO::Socket::Socks::SOCKS_WANT_WRITE() : 0;
  
  has reactor => sub { Mojo::IOLoop->singleton->reactor };
  
  sub DESTROY { shift->_cleanup }
  
  sub can_nnr   {NNR}
  sub can_socks {SOCKS}
  
  sub connect {
    my ($self, $args) = (shift, ref $_[0] ? $_[0] : {@_});
  
    # Timeout
    weaken $self;
    my $reactor = $self->reactor;
    $self->{timer} = $reactor->timer($args->{timeout} || 10,
      sub { $self->emit(error => 'Connect timeout') });
  
    # Blocking name resolution
    $_ && s/[[\]]//g for @$args{qw(address socks_address)};
    my $address = $args->{socks_address} || ($args->{address} ||= '127.0.0.1');
    return $reactor->next_tick(sub { $self && $self->_connect($args) })
      if !NNR || $args->{handle} || $args->{path};
  
    # Non-blocking name resolution
    $NDN //= Net::DNS::Native->new(pool => 5, extra_thread => 1);
    my $handle = $self->{dns} = $NDN->getaddrinfo($address, _port($args),
      {protocol => IPPROTO_TCP, socktype => SOCK_STREAM});
    $reactor->io(
      $handle => sub {
        my $reactor = shift;
  
        $reactor->remove($self->{dns});
        my ($err, @res) = $NDN->get_result(delete $self->{dns});
        return $self->emit(error => "Can't resolve: $err") if $err;
  
        $args->{addr_info} = \@res;
        $self->_connect($args);
      }
    )->watch($handle, 1, 0);
  }
  
  sub _cleanup {
    my $self = shift;
    $NDN->timedout($self->{dns}) if $NDN && $self->{dns};
    return unless my $reactor = $self->reactor;
    $self->{$_} && $reactor->remove(delete $self->{$_}) for qw(dns timer handle);
    return $self;
  }
  
  sub _connect {
    my ($self, $args) = @_;
  
    my $path = $args->{path};
    my $handle = $self->{handle} = $args->{handle};
  
    unless ($handle) {
      my $class = $path ? 'IO::Socket::UNIX' : 'IO::Socket::IP';
      my %options = (Blocking => 0);
  
      # UNIX domain socket
      if ($path) { $options{Peer} = $path }
  
      # IP socket
      else {
        if (my $info = $args->{addr_info}) { $options{PeerAddrInfo} = $info }
        else {
          $options{PeerAddr} = $args->{socks_address} || $args->{address};
          $options{PeerPort} = _port($args);
        }
        $options{LocalAddr} = $args->{local_address} if $args->{local_address};
      }
  
      return $self->emit(error => "Can't connect: $@")
        unless $self->{handle} = $handle = $class->new(%options);
    }
    $handle->blocking(0);
  
    $path ? $self->_try_socks($args) : $self->_wait('_ready', $handle, $args);
  }
  
  sub _port { $_[0]{socks_port} || $_[0]{port} || ($_[0]{tls} ? 443 : 80) }
  
  sub _ready {
    my ($self, $args) = @_;
  
    # Socket changes in between attempts and needs to be re-added for epoll/kqueue
    my $handle = $self->{handle};
    unless ($handle->connect) {
      return $self->emit(error => $!) unless $! == EINPROGRESS;
      $self->reactor->remove($handle);
      return $self->_wait('_ready', $handle, $args);
    }
  
    return $self->emit(error => $! || 'Not connected') unless $handle->connected;
  
    # Disable Nagle's algorithm
    setsockopt $handle, IPPROTO_TCP, TCP_NODELAY, 1;
  
    $self->_try_socks($args);
  }
  
  sub _socks {
    my ($self, $args) = @_;
  
    # Connected
    my $handle = $self->{handle};
    return $self->_try_tls($args) if $handle->ready;
  
    # Switch between reading and writing
    my $err = $IO::Socket::Socks::SOCKS_ERROR;
    if    ($err == READ)  { $self->reactor->watch($handle, 1, 0) }
    elsif ($err == WRITE) { $self->reactor->watch($handle, 1, 1) }
    else                  { $self->emit(error => $err) }
  }
  
  sub _try_socks {
    my ($self, $args) = @_;
  
    my $handle = $self->{handle};
    return $self->_try_tls($args) unless $args->{socks_address};
    return $self->emit(
      error => 'IO::Socket::Socks 0.64+ required for SOCKS support')
      unless SOCKS;
  
    my %options = (ConnectAddr => $args->{address}, ConnectPort => $args->{port});
    @options{qw(AuthType Username Password)}
      = ('userpass', @$args{qw(socks_user socks_pass)})
      if $args->{socks_user};
    my $reactor = $self->reactor;
    $reactor->remove($handle);
    return $self->emit(error => 'SOCKS upgrade failed')
      unless IO::Socket::Socks->start_SOCKS($handle, %options);
  
    $self->_wait('_socks', $handle, $args);
  }
  
  sub _try_tls {
    my ($self, $args) = @_;
  
    my $handle = $self->{handle};
    return $self->_cleanup->emit(connect => $handle) unless $args->{tls};
    my $reactor = $self->reactor;
    $reactor->remove($handle);
  
    # Start TLS handshake
    weaken $self;
    my $tls = Mojo::IOLoop::TLS->new($handle)->reactor($self->reactor);
    $tls->on(upgrade => sub { $self->_cleanup->emit(connect => pop) });
    $tls->on(error => sub { $self->emit(error => pop) });
    $tls->negotiate(%$args);
  }
  
  sub _wait {
    my ($self, $next, $handle, $args) = @_;
    weaken $self;
    $self->reactor->io($handle => sub { $self->$next($args) })
      ->watch($handle, 0, 1);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Client - Non-blocking TCP/IP and UNIX domain socket client
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Client;
  
    # Create socket connection
    my $client = Mojo::IOLoop::Client->new;
    $client->on(connect => sub {
      my ($client, $handle) = @_;
      ...
    });
    $client->on(error => sub {
      my ($client, $err) = @_;
      ...
    });
    $client->connect(address => 'example.com', port => 80);
  
    # Start reactor if necessary
    $client->reactor->start unless $client->reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Client> opens TCP/IP and UNIX domain socket connections for
  L<Mojo::IOLoop>.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Client> inherits all events from L<Mojo::EventEmitter> and can
  emit the following new ones.
  
  =head2 connect
  
    $client->on(connect => sub {
      my ($client, $handle) = @_;
      ...
    });
  
  Emitted once the connection is established.
  
  =head2 error
  
    $client->on(error => sub {
      my ($client, $err) = @_;
      ...
    });
  
  Emitted if an error occurs on the connection, fatal if unhandled.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Client> implements the following attributes.
  
  =head2 reactor
  
    my $reactor = $client->reactor;
    $client     = $client->reactor(Mojo::Reactor::Poll->new);
  
  Low-level event reactor, defaults to the C<reactor> attribute value of the
  global L<Mojo::IOLoop> singleton.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Client> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 can_nnr
  
    my $bool = Mojo::IOLoop::Client->can_nnr;
  
  True if L<Net::DNS::Native> 0.15+ is installed and non-blocking name resolution
  support enabled.
  
  =head2 can_socks
  
    my $bool = Mojo::IOLoop::Client->can_socks;
  
  True if L<IO::Socket::SOCKS> 0.64+ is installed and SOCKS5 support enabled.
  
  =head2 connect
  
    $client->connect(address => '127.0.0.1', port => 3000);
    $client->connect({address => '127.0.0.1', port => 3000});
  
  Open a socket connection to a remote host. Note that non-blocking name
  resolution depends on L<Net::DNS::Native> (0.15+), SOCKS5 support on
  L<IO::Socket::Socks> (0.64), and TLS support on L<IO::Socket::SSL> (2.009+).
  
  These options are currently available:
  
  =over 2
  
  =item address
  
    address => 'mojolicious.org'
  
  Address or host name of the peer to connect to, defaults to C<127.0.0.1>.
  
  =item handle
  
    handle => $handle
  
  Use an already prepared L<IO::Socket::IP> object.
  
  =item local_address
  
    local_address => '127.0.0.1'
  
  Local address to bind to.
  
  =item path
  
    path => '/tmp/myapp.sock'
  
  Path of UNIX domain socket to connect to.
  
  =item port
  
    port => 80
  
  Port to connect to, defaults to C<80> or C<443> with C<tls> option.
  
  =item socks_address
  
    socks_address => '127.0.0.1'
  
  Address or host name of SOCKS5 proxy server to use for connection.
  
  =item socks_pass
  
    socks_pass => 'secr3t'
  
  Password to use for SOCKS5 authentication.
  
  =item socks_port
  
    socks_port => 9050
  
  Port of SOCKS5 proxy server to use for connection.
  
  =item socks_user
  
    socks_user => 'sri'
  
  Username to use for SOCKS5 authentication.
  
  =item timeout
  
    timeout => 15
  
  Maximum amount of time in seconds establishing connection may take before
  getting canceled, defaults to C<10>.
  
  =item tls
  
    tls => 1
  
  Enable TLS.
  
  =item tls_ca
  
    tls_ca => '/etc/tls/ca.crt'
  
  Path to TLS certificate authority file.
  
  =item tls_cert
  
    tls_cert => '/etc/tls/client.crt'
  
  Path to the TLS certificate file.
  
  =item tls_key
  
    tls_key => '/etc/tls/client.key'
  
  Path to the TLS key file.
  
  =item tls_protocols
  
    tls_protocols => ['foo', 'bar']
  
  ALPN protocols to negotiate.
  
  =item tls_verify
  
    tls_verify => 0x00
  
  TLS verification mode.
  
  =back
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_IOLOOP_CLIENT

$fatpacked{"Mojo/IOLoop/Delay.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_DELAY';
  package Mojo::IOLoop::Delay;
  use Mojo::Base 'Mojo::Promise';
  
  # DEPRECATED!
  use base 'Mojo::EventEmitter';
  
  sub begin {
    my ($self, $offset, $len) = @_;
    $self->{pending}++;
    my $id = $self->{counter}++;
    return sub { $self->_step($id, $offset // 1, $len, @_) };
  }
  
  sub pass { $_[0]->begin->(@_) }
  
  sub steps {
    my ($self, @steps) = @_;
    $self->{steps} = \@steps;
    $self->ioloop->next_tick($self->begin);
  
    # DEPRECATED!
    $self->{deprecated} ||= $self->on(error => sub { });
  
    return $self;
  }
  
  sub _step {
    my ($self, $id, $offset, $len) = (shift, shift, shift, shift);
  
    $self->{args}[$id]
      = [@_ ? defined $len ? splice @_, $offset, $len : splice @_, $offset : ()];
    return $self if $self->{fail} || --$self->{pending} || $self->{lock};
    local $self->{lock} = 1;
    my @args = map {@$_} @{delete $self->{args}};
  
    $self->{counter} = 0;
    if (my $cb = shift @{$self->{steps}}) {
      unless (eval { $self->$cb(@args); 1 }) {
        my $err = $@;
        @{$self}{qw(fail steps)} = (1, []);
        return $self->reject($err)->emit(error => $err);
      }
    }
  
    ($self->{steps} = []) and return $self->resolve(@args)->emit(finish => @args)
      unless $self->{counter};
    $self->ioloop->next_tick($self->begin) unless $self->{pending};
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Delay - Promises/A+ and flow-control helpers
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Delay;
  
    # Synchronize multiple non-blocking operations
    my $delay = Mojo::IOLoop::Delay->new;
    $delay->steps(sub { say 'BOOM!' });
    for my $i (1 .. 10) {
      my $end = $delay->begin;
      Mojo::IOLoop->timer($i => sub {
        say 10 - $i;
        $end->();
      });
    }
    $delay->wait;
  
    # Sequentialize multiple non-blocking operations
    Mojo::IOLoop::Delay->new->steps(
  
      # First step (simple timer)
      sub {
        my $delay = shift;
        Mojo::IOLoop->timer(2 => $delay->begin);
        say 'Second step in 2 seconds.';
      },
  
      # Second step (concurrent timers)
      sub {
        my ($delay, @args) = @_;
        Mojo::IOLoop->timer(1 => $delay->begin);
        Mojo::IOLoop->timer(3 => $delay->begin);
        say 'Third step in 3 seconds.';
      },
  
      # Third step (the end)
      sub {
        my ($delay, @args) = @_;
        say 'And done after 5 seconds total.';
      }
    )->wait;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Delay> adds flow-control helpers to L<Mojo::Promise>, which can
  help you avoid deep nested closures that often result from continuation-passing
  style.
  
    use Mojo::IOLoop;
  
    # These deep nested closures are often referred to as "Callback Hell"
    Mojo::IOLoop->timer(3 => sub {
      my loop = shift;
  
      say '3 seconds';
      Mojo::IOLoop->timer(3 => sub {
        my $loop = shift;
  
        say '6 seconds';
        Mojo::IOLoop->timer(3 => sub {
          my $loop = shift;
  
          say '9 seconds';
          Mojo::IOLoop->stop;
        });
      });
    });
  
    Mojo::IOLoop->start;
  
  The idea behind L<Mojo::IOLoop::Delay> is to turn the nested closures above into
  a flat series of closures. In the example below, the call to L</"begin"> creates
  a code reference that we can pass to L<Mojo::IOLoop/"timer"> as a callback, and
  that leads to the next closure in the series when executed.
  
    use Mojo::IOLoop;
  
    # Instead of nested closures we now have a simple chain of steps
    my $delay = Mojo::IOLoop->delay(
      sub {
        my $delay = shift;
        Mojo::IOLoop->timer(3 => $delay->begin);
      },
      sub {
        my $delay = shift;
        say '3 seconds';
        Mojo::IOLoop->timer(3 => $delay->begin);
      },
      sub {
        my $delay = shift;
        say '6 seconds';
        Mojo::IOLoop->timer(3 => $delay->begin);
      },
      sub {
        my $delay = shift;
        say '9 seconds';
      }
    );
    $delay->wait;
  
  Another positive side effect of this pattern is that we do not need to call
  L<Mojo::IOLoop/"start"> and L<Mojo::IOLoop/"stop"> manually, because we know
  exactly when our chain of L</"steps"> has reached the end. So
  L<Mojo::Promise/"wait"> can stop the event loop automatically if it had to be
  started at all in the first place.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Delay> inherits all attributes from L<Mojo::Promise>.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Delay> inherits all methods from L<Mojo::Promise> and implements
  the following new ones.
  
  =head2 begin
  
    my $cb = $delay->begin;
    my $cb = $delay->begin($offset);
    my $cb = $delay->begin($offset, $len);
  
  Indicate an active event by incrementing the event counter, the returned
  code reference can be used as a callback, and needs to be executed when the
  event has completed to decrement the event counter again. When all code
  references generated by this method have been executed and the event counter has
  reached zero, L</"steps"> will continue.
  
    # Capture all arguments except for the first one (invocant)
    my $delay = Mojo::IOLoop->delay(sub {
      my ($delay, $err, $stream) = @_;
      ...
    });
    Mojo::IOLoop->client({port => 3000} => $delay->begin);
    $delay->wait;
  
  Arguments passed to the returned code reference are spliced with the given
  offset and length, defaulting to an offset of C<1> with no default length. The
  arguments are then combined in the same order L</"begin"> was called, and passed
  together to the next step.
  
    # Capture all arguments
    my $delay = Mojo::IOLoop->delay(sub {
      my ($delay, $loop, $err, $stream) = @_;
      ...
    });
    Mojo::IOLoop->client({port => 3000} => $delay->begin(0));
    $delay->wait;
  
    # Capture only the second argument
    my $delay = Mojo::IOLoop->delay(sub {
      my ($delay, $err) = @_;
      ...
    });
    Mojo::IOLoop->client({port => 3000} => $delay->begin(1, 1));
    $delay->wait;
  
    # Capture and combine arguments
    my $delay = Mojo::IOLoop->delay(sub {
      my ($delay, $three_err, $three_stream, $four_err, $four_stream) = @_;
      ...
    });
    Mojo::IOLoop->client({port => 3000} => $delay->begin);
    Mojo::IOLoop->client({port => 4000} => $delay->begin);
    $delay->wait;
  
  =head2 pass
  
    $delay = $delay->pass;
    $delay = $delay->pass(@args);
  
  Shortcut for passing values between L</"steps">.
  
    # Longer version
    $delay->begin(0)->(@args);
  
  =head2 steps
  
    $delay = $delay->steps(sub {...}, sub {...});
  
  Sequentialize multiple events, every time the event counter reaches zero a
  callback will run, the first one automatically runs during the next reactor tick
  unless it is delayed by incrementing the event counter. This chain will continue
  until there are no remaining callbacks, a callback does not increment the event
  counter or an exception gets thrown in a callback. Finishing the chain will also
  result in the promise being fulfilled, or if an exception got thrown it will be
  rejected.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_IOLOOP_DELAY

$fatpacked{"Mojo/IOLoop/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_SERVER';
  package Mojo::IOLoop::Server;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use IO::Socket::IP;
  use IO::Socket::UNIX;
  use Mojo::IOLoop;
  use Mojo::IOLoop::TLS;
  use Scalar::Util 'weaken';
  use Socket qw(IPPROTO_TCP TCP_NODELAY);
  
  has reactor => sub { Mojo::IOLoop->singleton->reactor };
  
  sub DESTROY {
    my $self = shift;
    $ENV{MOJO_REUSE} =~ s/(?:^|\,)\Q$self->{reuse}\E// if $self->{reuse};
    $self->stop if $self->{handle} && $self->reactor;
  }
  
  sub generate_port {
    IO::Socket::IP->new(Listen => 5, LocalAddr => '127.0.0.1')->sockport;
  }
  
  sub handle { shift->{handle} }
  
  sub is_accepting { !!shift->{active} }
  
  sub listen {
    my ($self, $args) = (shift, ref $_[0] ? $_[0] : {@_});
  
    # Look for reusable file descriptor
    my $path    = $args->{path};
    my $address = $args->{address} || '0.0.0.0';
    my $port    = $args->{port};
    $ENV{MOJO_REUSE} ||= '';
    my $fd
      = ($path && $ENV{MOJO_REUSE} =~ /(?:^|\,)unix:\Q$path\E:(\d+)/)
      || ($port && $ENV{MOJO_REUSE} =~ /(?:^|\,)\Q$address:$port\E:(\d+)/)
      ? $1
      : undef;
  
    # Allow file descriptor inheritance
    local $^F = 1023;
  
    # Reuse file descriptor
    my $handle;
    my $class = $path ? 'IO::Socket::UNIX' : 'IO::Socket::IP';
    if (defined($fd //= $args->{fd})) {
      $handle = $class->new_from_fd($fd, 'r')
        or croak "Can't open file descriptor $fd: $!";
    }
  
    else {
      my %options
        = (Listen => $args->{backlog} // SOMAXCONN, Type => SOCK_STREAM);
  
      # UNIX domain socket
      my $reuse;
      if ($path) {
        unlink $path if -S $path;
        $options{Local} = $path;
        $handle = $class->new(%options) or croak "Can't create listen socket: $!";
        $reuse = $self->{reuse} = join ':', 'unix', $path, fileno $handle;
      }
  
      # IP socket
      else {
        $options{LocalAddr} = $address;
        $options{LocalAddr} =~ s/[\[\]]//g;
        $options{LocalPort} = $port if $port;
        $options{ReuseAddr} = 1;
        $options{ReusePort} = $args->{reuse};
        $handle = $class->new(%options) or croak "Can't create listen socket: $@";
        $fd     = fileno $handle;
        $reuse  = $self->{reuse} = join ':', $address, $handle->sockport, $fd;
      }
  
      $ENV{MOJO_REUSE} .= length $ENV{MOJO_REUSE} ? ",$reuse" : "$reuse";
    }
    $handle->blocking(0);
    @$self{qw(args handle)} = ($args, $handle);
  
    croak 'IO::Socket::SSL 2.009+ required for TLS support'
      if !Mojo::IOLoop::TLS->can_tls && $args->{tls};
  }
  
  sub port { shift->{handle}->sockport }
  
  sub start {
    my $self = shift;
    weaken $self;
    ++$self->{active}
      and $self->reactor->io($self->{handle} => sub { $self->_accept });
  }
  
  sub stop { delete($_[0]{active}) and $_[0]->reactor->remove($_[0]{handle}) }
  
  sub _accept {
    my $self = shift;
  
    # Greedy accept
    my $args     = $self->{args};
    my $accepted = 0;
    while ($self->{active} && !($args->{single_accept} && $accepted++)) {
      return unless my $handle = $self->{handle}->accept;
      $handle->blocking(0);
  
      # Disable Nagle's algorithm
      setsockopt $handle, IPPROTO_TCP, TCP_NODELAY, 1;
  
      $self->emit(accept => $handle) and next unless $args->{tls};
  
      # Start TLS handshake
      my $tls = Mojo::IOLoop::TLS->new($handle)->reactor($self->reactor);
      $tls->on(upgrade => sub { $self->emit(accept => pop) });
      $tls->on(error => sub { });
      $tls->negotiate(%$args, server => 1);
    }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Server - Non-blocking TCP and UNIX domain socket server
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Server;
  
    # Create listen socket
    my $server = Mojo::IOLoop::Server->new;
    $server->on(accept => sub {
      my ($server, $handle) = @_;
      ...
    });
    $server->listen(port => 3000);
  
    # Start and stop accepting connections
    $server->start;
    $server->stop;
  
    # Start reactor if necessary
    $server->reactor->start unless $server->reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Server> accepts TCP/IP and UNIX domain socket connections for
  L<Mojo::IOLoop>.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Server> inherits all events from L<Mojo::EventEmitter> and can
  emit the following new ones.
  
  =head2 accept
  
    $server->on(accept => sub {
      my ($server, $handle) = @_;
      ...
    });
  
  Emitted for each accepted connection.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Server> implements the following attributes.
  
  =head2 reactor
  
    my $reactor = $server->reactor;
    $server     = $server->reactor(Mojo::Reactor::Poll->new);
  
  Low-level event reactor, defaults to the C<reactor> attribute value of the
  global L<Mojo::IOLoop> singleton.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Server> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 generate_port
  
    my $port = Mojo::IOLoop::Server->generate_port;
  
  Find a free TCP port, primarily used for tests.
  
  =head2 handle
  
    my $handle = $server->handle;
  
  Get handle for server, usually an L<IO::Socket::IP> object.
  
  =head2 is_accepting
  
    my $bool = $server->is_accepting;
  
  Check if connections are currently being accepted.
  
  =head2 listen
  
    $server->listen(port => 3000);
    $server->listen({port => 3000});
  
  Create a new listen socket. Note that TLS support depends on L<IO::Socket::SSL>
  (2.009+).
  
  These options are currently available:
  
  =over 2
  
  =item address
  
    address => '127.0.0.1'
  
  Local address to listen on, defaults to C<0.0.0.0>.
  
  =item backlog
  
    backlog => 128
  
  Maximum backlog size, defaults to C<SOMAXCONN>.
  
  =item fd
  
    fd => 3
  
  File descriptor with an already prepared listen socket.
  
  =item path
  
    path => '/tmp/myapp.sock'
  
  Path for UNIX domain socket to listen on.
  
  =item port
  
    port => 80
  
  Port to listen on, defaults to a random port.
  
  =item reuse
  
    reuse => 1
  
  Allow multiple servers to use the same port with the C<SO_REUSEPORT> socket
  option.
  
  =item single_accept
  
    single_accept => 1
  
  Only accept one connection at a time.
  
  =item tls
  
    tls => 1
  
  Enable TLS.
  
  =item tls_ca
  
    tls_ca => '/etc/tls/ca.crt'
  
  Path to TLS certificate authority file.
  
  =item tls_cert
  
    tls_cert => '/etc/tls/server.crt'
    tls_cert => {'mojolicious.org' => '/etc/tls/mojo.crt'}
  
  Path to the TLS cert file, defaults to a built-in test certificate.
  
  =item tls_ciphers
  
    tls_ciphers => 'AES128-GCM-SHA256:RC4:HIGH:!MD5:!aNULL:!EDH'
  
  TLS cipher specification string. For more information about the format see
  L<https://www.openssl.org/docs/manmaster/apps/ciphers.html#CIPHER-STRINGS>.
  
  =item tls_key
  
    tls_key => '/etc/tls/server.key'
    tls_key => {'mojolicious.org' => '/etc/tls/mojo.key'}
  
  Path to the TLS key file, defaults to a built-in test key.
  
  =item tls_protocols
  
    tls_protocols => ['foo', 'bar']
  
  ALPN protocols to negotiate.
  
  =item tls_verify
  
    tls_verify => 0x00
  
  TLS verification mode.
  
  =item tls_version
  
    tls_version => 'TLSv1_2'
  
  TLS protocol version.
  
  =back
  
  =head2 port
  
    my $port = $server->port;
  
  Get port this server is listening on.
  
  =head2 start
  
    $server->start;
  
  Start or resume accepting connections.
  
  =head2 stop
  
    $server->stop;
  
  Stop accepting connections.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_IOLOOP_SERVER

$fatpacked{"Mojo/IOLoop/Stream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_STREAM';
  package Mojo::IOLoop::Stream;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Errno qw(EAGAIN ECONNRESET EINTR EWOULDBLOCK);
  use Mojo::IOLoop;
  use Mojo::Util;
  use Scalar::Util 'weaken';
  
  has reactor => sub { Mojo::IOLoop->singleton->reactor };
  
  sub DESTROY { Mojo::Util::_global_destruction() or shift->close }
  
  sub close {
    my $self = shift;
    return unless my $reactor = $self->reactor;
    return unless my $handle  = delete $self->timeout(0)->{handle};
    $reactor->remove($handle);
    $self->emit('close');
  }
  
  sub close_gracefully { $_[0]->is_writing ? $_[0]{graceful}++ : $_[0]->close }
  
  sub handle { shift->{handle} }
  
  sub is_readable {
    my $self = shift;
    $self->_again;
    return $self->{handle} && Mojo::Util::_readable(0, fileno $self->{handle});
  }
  
  sub is_writing {
    my $self = shift;
    return undef unless $self->{handle};
    return !!length($self->{buffer}) || $self->has_subscribers('drain');
  }
  
  sub new { shift->SUPER::new(handle => shift, buffer => '', timeout => 15) }
  
  sub start {
    my $self = shift;
  
    # Resume
    my $reactor = $self->reactor;
    return $reactor->watch($self->{handle}, 1, $self->is_writing)
      if delete $self->{paused};
  
    weaken $self;
    my $cb = sub { pop() ? $self->_write : $self->_read };
    $reactor->io($self->timeout($self->{timeout})->{handle} => $cb);
  }
  
  sub steal_handle {
    my $self = shift;
    $self->reactor->remove($self->{handle});
    return delete $self->{handle};
  }
  
  sub stop {
    my $self = shift;
    $self->reactor->watch($self->{handle}, 0, $self->is_writing)
      unless $self->{paused}++;
  }
  
  sub timeout {
    my $self = shift;
  
    return $self->{timeout} unless @_;
  
    my $reactor = $self->reactor;
    $reactor->remove(delete $self->{timer}) if $self->{timer};
    return $self unless my $timeout = $self->{timeout} = shift;
    weaken $self;
    $self->{timer}
      = $reactor->timer($timeout => sub { $self->emit('timeout')->close });
  
    return $self;
  }
  
  sub write {
    my ($self, $chunk, $cb) = @_;
  
    # IO::Socket::SSL will corrupt data with the wrong internal representation
    utf8::downgrade $chunk;
    $self->{buffer} .= $chunk;
    if ($cb) { $self->once(drain => $cb) }
    elsif (!length $self->{buffer}) { return $self }
    $self->reactor->watch($self->{handle}, !$self->{paused}, 1)
      if $self->{handle};
  
    return $self;
  }
  
  sub _again { $_[0]->reactor->again($_[0]{timer}) if $_[0]{timer} }
  
  sub _read {
    my $self = shift;
  
    my $read = $self->{handle}->sysread(my $buffer, 131072, 0);
    return $read == 0 ? $self->close : $self->emit(read => $buffer)->_again
      if defined $read;
  
    # Retry
    return if $! == EAGAIN || $! == EINTR || $! == EWOULDBLOCK;
  
    # Closed (maybe real error)
    $! == ECONNRESET ? $self->close : $self->emit(error => $!)->close;
  }
  
  sub _write {
    my $self = shift;
  
    # Handle errors only when reading (to avoid timing problems)
    my $handle = $self->{handle};
    if (length $self->{buffer}) {
      return unless defined(my $written = $handle->syswrite($self->{buffer}));
      $self->emit(write => substr($self->{buffer}, 0, $written, ''))->_again;
    }
  
    $self->emit('drain') unless length $self->{buffer};
    return if $self->is_writing;
    return $self->close if $self->{graceful};
    $self->reactor->watch($handle, !$self->{paused}, 0) if $self->{handle};
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Stream - Non-blocking I/O stream
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Stream;
  
    # Create stream
    my $stream = Mojo::IOLoop::Stream->new($handle);
    $stream->on(read => sub {
      my ($stream, $bytes) = @_;
      ...
    });
    $stream->on(close => sub {
      my $stream = shift;
      ...
    });
    $stream->on(error => sub {
      my ($stream, $err) = @_;
      ...
    });
  
    # Start and stop watching for new data
    $stream->start;
    $stream->stop;
  
    # Start reactor if necessary
    $stream->reactor->start unless $stream->reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Stream> is a container for I/O streams used by L<Mojo::IOLoop>.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Stream> inherits all events from L<Mojo::EventEmitter> and can
  emit the following new ones.
  
  =head2 close
  
    $stream->on(close => sub {
      my $stream = shift;
      ...
    });
  
  Emitted if the stream gets closed.
  
  =head2 drain
  
    $stream->on(drain => sub {
      my $stream = shift;
      ...
    });
  
  Emitted once all data has been written.
  
  =head2 error
  
    $stream->on(error => sub {
      my ($stream, $err) = @_;
      ...
    });
  
  Emitted if an error occurs on the stream, fatal if unhandled.
  
  =head2 read
  
    $stream->on(read => sub {
      my ($stream, $bytes) = @_;
      ...
    });
  
  Emitted if new data arrives on the stream.
  
  =head2 timeout
  
    $stream->on(timeout => sub {
      my $stream = shift;
      ...
    });
  
  Emitted if the stream has been inactive for too long and will get closed
  automatically.
  
  =head2 write
  
    $stream->on(write => sub {
      my ($stream, $bytes) = @_;
      ...
    });
  
  Emitted if new data has been written to the stream.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Stream> implements the following attributes.
  
  =head2 reactor
  
    my $reactor = $stream->reactor;
    $stream     = $stream->reactor(Mojo::Reactor::Poll->new);
  
  Low-level event reactor, defaults to the C<reactor> attribute value of the
  global L<Mojo::IOLoop> singleton.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Stream> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 close
  
    $stream->close;
  
  Close stream immediately.
  
  =head2 close_gracefully
  
    $stream->close_gracefully;
  
  Close stream gracefully.
  
  =head2 handle
  
    my $handle = $stream->handle;
  
  Get handle for stream, usually an L<IO::Socket::IP> or L<IO::Socket::SSL>
  object.
  
  =head2 is_readable
  
    my $bool = $stream->is_readable;
  
  Quick non-blocking check if stream is readable, useful for identifying tainted
  sockets.
  
  =head2 is_writing
  
    my $bool = $stream->is_writing;
  
  Check if stream is writing.
  
  =head2 new
  
    my $stream = Mojo::IOLoop::Stream->new($handle);
  
  Construct a new L<Mojo::IOLoop::Stream> object.
  
  =head2 start
  
    $stream->start;
  
  Start or resume watching for new data on the stream.
  
  =head2 steal_handle
  
    my $handle = $stream->steal_handle;
  
  Steal L</"handle"> and prevent it from getting closed automatically.
  
  =head2 stop
  
    $stream->stop;
  
  Stop watching for new data on the stream.
  
  =head2 timeout
  
    my $timeout = $stream->timeout;
    $stream     = $stream->timeout(45);
  
  Maximum amount of time in seconds stream can be inactive before getting closed
  automatically, defaults to C<15>. Setting the value to C<0> will allow this
  stream to be inactive indefinitely.
  
  =head2 write
  
    $stream = $stream->write($bytes);
    $stream = $stream->write($bytes => sub {...});
  
  Write data to stream, the optional drain callback will be executed once all data
  has been written.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_IOLOOP_STREAM

$fatpacked{"Mojo/IOLoop/Stream/HTTPClient.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_STREAM_HTTPCLIENT';
  package Mojo::IOLoop::Stream::HTTPClient;
  use Mojo::Base 'Mojo::IOLoop::Stream';
  
  use Mojo::Transaction::WebSocket;
  use Mojo::Util 'term_escape';
  use Mojo::WebSocket 'challenge';
  use Scalar::Util 'weaken';
  
  use constant DEBUG => $ENV{MOJO_CLIENT_DEBUG} || 0;
  
  has request_timeout => 0;
  
  sub new {
    my $self = shift->SUPER::new(@_);
    $self->on(read => sub { shift->_read_content(shift) });
    $self->on(close => sub { $_[0]->{closing}++ || $_[0]->_finish(1) });
    return $self;
  }
  
  sub process {
    my ($self, $tx) = @_;
  
    $self->{tx} = $tx;
    my $handle = $self->handle;
    unless ($handle->isa('IO::Socket::UNIX')) {
      $tx->local_address($handle->sockhost)->local_port($handle->sockport);
      $tx->remote_address($handle->peerhost)->remote_port($handle->peerport);
    }
  
    weaken $self;
    $tx->on(resume => sub { $self->_write_content });
    if (my $timeout = $self->request_timeout) {
      $self->{req_timeout} = $self->reactor->timer(
        $timeout => sub { $self->_error('Request timeout') });
    }
    $self->_write_content;
  }
  
  sub _error {
    my ($self, $err) = @_;
    $self->{tx}->res->error({message => $err}) if $self->{tx};
    $self->_finish(1);
  }
  
  sub _finish {
    my ($self, $close) = @_;
  
    # Remove request timeout and finish transaction
    $self->reactor->remove($self->{req_timeout}) if $self->{req_timeout};
    return ++$self->{closing} && $self->close unless my $tx = delete $self->{tx};
  
    # Premature connection close
    my $res = $tx->res->finish;
    if ($close && !$res->code && !$res->error) {
      $res->error({message => 'Premature connection close'});
    }
  
    # Upgrade connection to WebSocket
    if (my $ws = $self->_upgrade($tx)) {
      $self->emit(upgrade => $ws);
      return $ws->client_read($ws->handshake->res->content->leftovers);
    }
  
    ++$self->{closing} && $self->close_gracefully
      if $tx->error || !$tx->keep_alive;
    $res->error({message => $res->message, code => $res->code}) if $res->is_error;
    $tx->closed;
  }
  
  sub _read_content {
    my ($self, $chunk) = @_;
  
    # Corrupted connection
    return $self->close unless my $tx = $self->{tx};
  
    warn term_escape "-- Client <<< Server (@{[_url($tx)]})\n$chunk\n" if DEBUG;
    $tx->client_read($chunk);
    $self->_finish if $tx->is_finished;
  }
  
  sub _upgrade {
    my ($self, $tx) = @_;
    my $code = $tx->res->code // 0;
    return undef unless $tx->req->is_handshake && $code == 101;
    my $ws = Mojo::Transaction::WebSocket->new(handshake => $tx, masked => 1);
    return challenge($ws) ? $ws->established(1) : undef;
  }
  
  sub _url { shift->req->url->to_abs }
  
  sub _write_content {
    my $self = shift;
  
    # Protect from resume event recursion
    return if !(my $tx = $self->{tx}) || $self->{write_lock};
    local $self->{write_lock} = 1;
    my $chunk = $tx->client_write;
    warn term_escape "-- Client >>> Server (@{[_url($tx)]})\n$chunk\n" if DEBUG;
    return unless length $chunk;
    $self->write($chunk => sub { $_[0]->_write_content });
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Stream::HTTPClient - Non-blocking I/O HTTP client stream
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Client;
    use Mojo::IOLoop::Stream::HTTPClient;
    use Mojo::Transaction::HTTP;
    
    # Create transaction
    my $tx = Mojo::Transaction::HTTP->new;
    $tx->req->method('GET')
    $tx->url->parse('https://mojolicious.org');
    $tx->on(
      finish => sub {
        my $tx = shift;
        say $tx->res->code;
      }
    );
    
    # Create socket connection
    my $client = Mojo::IOLoop::Client->new;
    $client->on(
      connect => sub {
        my $stream = Mojo::IOLoop::Stream::HTTPClient->new(pop);
        $stream->start;
        $stream->process($tx);
      }
    );
    $client->connect(address => 'mojolicious.org', port => 80);
  
    # Start reactor if necessary
    $stream->reactor->start unless $stream->reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Stream::HTTPClient> is a container for I/O streams used by
  L<Mojo::IOLoop> to support the HTTP protocol client-side.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Stream::HTTPClient> inherits all events from
  L<Mojo::IOLoop::Stream> and can emit the following new ones.
  
  =head2 upgrade
  
    $stream->on(upgrade => sub {
      my ($stream, $ws) = @_;
      ...
    });
  
  Emitted when the connection should be upgraded to the WebSocket protocol.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Stream::HTTPClient> inherits all attributes from
  L<Mojo::IOLoop::Stream> and implements the following ones.
  
  =head2 request_timeout
  
    my $timeout = $stream->request_timeout;
    $stream     = $stream->request_timeout(5);
  
  Maximum amount of time in seconds sending the request and receiving a whole
  response may take before getting canceled, defaults to C<0>. Setting the value
  to C<0> will allow to wait indefinitely.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Stream::HTTPClient> inherits all methods from
  L<Mojo::IOLoop::Stream> and implements the following new ones.
  
  =head2 new
  
    my $stream = Mojo::IOLoop::Stream::HTTPClient->new($handle);
  
  Construct a new L<Mojo::IOLoop::Stream::HTTPClient> object.
  
  =head2 process
  
    $stream->process(Mojo::Transaction::HTTP->new);
  
  Process a L<Mojo::Transaction::HTTP> object with the current connection.
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_CLIENT_DEBUG> environment variable to get some advanced
  diagnostics information printed to C<STDERR>.
  
    MOJO_CLIENT_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
  
MOJO_IOLOOP_STREAM_HTTPCLIENT

$fatpacked{"Mojo/IOLoop/Stream/HTTPServer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_STREAM_HTTPSERVER';
  package Mojo::IOLoop::Stream::HTTPServer;
  use Mojo::Base 'Mojo::IOLoop::Stream';
  
  use Mojo::Server;
  use Mojo::Transaction::WebSocket;
  use Mojo::Util 'term_escape';
  use Mojo::WebSocket 'server_handshake';
  use Scalar::Util 'weaken';
  
  use constant DEBUG => $ENV{MOJO_SERVER_DEBUG} || 0;
  
  has app => sub { Mojo::Server->new->build_app('Mojo::HelloWorld') };
  has max_requests => 100;
  
  sub new {
    my $self = shift->SUPER::new(@_);
    $self->on(read  => sub { shift->_read_content(shift) });
    $self->on(close => sub { shift->_close });
    return $self;
  }
  
  sub _build_tx {
    my $self = shift;
  
    my $tx = $self->app->build_tx;
    $tx->res->headers->server('Mojolicious (Perl)');
    my $handle = $self->handle;
    unless ($handle->isa('IO::Socket::UNIX')) {
      $tx->local_address($handle->sockhost)->local_port($handle->sockport);
      $tx->remote_address($handle->peerhost)->remote_port($handle->peerport);
    }
    $tx->req->url->base->scheme('https') if $handle->isa('IO::Socket::SSL');
  
    weaken $self;
    $tx->on(
      request => sub {
        my $tx = shift;
  
        # WebSocket
        my $req = $tx->req;
        if ($req->is_handshake) {
          my $ws = $self->{next}
            = Mojo::Transaction::WebSocket->new(handshake => $tx);
          $self->emit(request => server_handshake $ws);
        }
  
        # HTTP
        else { $self->emit(request => $tx) }
  
        # Last keep-alive request or corrupted connection
        $tx->res->headers->connection('close')
          if ($self->{keep_alive} || 1) >= $self->max_requests || $req->error;
  
        $tx->on(resume => sub { $self->_write_content });
        $self->_write_content;
      }
    );
  
    $self->emit(start => $tx);
  
    # Kept alive if we have more than one request on the connection
    return ++$self->{keep_alive} > 1 ? $tx->kept_alive(1) : $tx;
  }
  
  sub _close { delete($_[0]->{tx})->closed if $_[0]->{tx} }
  
  sub _finish {
    my $self = shift;
  
    # Always remove connection for WebSockets
    return unless my $tx = $self->{tx};
  
    # Finish transaction
    delete($self->{tx})->closed;
  
    # Upgrade connection to WebSocket
    if (my $ws = delete $self->{next}) {
  
      # Successful upgrade
      if ($ws->handshake->res->code == 101) {
        $self->emit(upgrade => $ws->established(1));
      }
  
      # Failed upgrade
      else { $ws->closed }
    }
  
    # Close connection if necessary
    return $self->close_gracefully if $tx->error || !$tx->keep_alive;
  
    # Build new transaction for leftovers
    return unless length(my $leftovers = $tx->req->content->leftovers);
    $self->{tx} = $tx = $self->_build_tx;
    $tx->server_read($leftovers);
  }
  
  sub _read_content {
    my ($self, $chunk) = @_;
    my $tx = $self->{tx} ||= $self->_build_tx;
    warn term_escape "-- Server <<< Client (@{[_url($tx)]})\n$chunk\n" if DEBUG;
    $tx->server_read($chunk);
  }
  
  sub _url { shift->req->url->to_abs }
  
  sub _write_content {
    my $self = shift;
  
    # Protect from resume event recursion
    return if !(my $tx = $self->{tx}) || $self->{write_lock};
    local $self->{write_lock} = 1;
    my $chunk = $tx->server_write;
    warn term_escape "-- Server >>> Client (@{[_url($tx)]})\n$chunk\n" if DEBUG;
    my $next
      = $tx->is_finished ? '_finish' : length $chunk ? '_write_content' : undef;
    return $self->write($chunk) unless $next;
    $self->write($chunk => sub { shift->$next() });
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Stream::HTTPServer - Non-blocking I/O HTTP server stream
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Server;
    use Mojo::IOLoop::Stream::HTTPServer;
    
    # Create listen socket
    my $server = Mojo::IOLoop::Server->new;
    $server->on(
      accept => sub {
        my $stream = Mojo::IOLoop::Stream::HTTPServer->new(pop);
    
        $stream->on(
          request => sub {
            my ($stream, $tx) = @_;
            $tx->res->code(200);
            $tx->res->headers->content_type('text/plain');
            $tx->res->body('Hello World!');
            $tx->resume;
          }
        );
        $stream->start;
      }
    );
    $server->listen(port => 3000);
    
    # Start reactor if necessary
    $stream->reactor->start unless $stream->reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Stream::HTTPServer> is a container for I/O streams used by
  L<Mojo::IOLoop> to support the HTTP protocol server-side.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Stream::HTTPServer> inherits all events from
  L<Mojo::IOLoop::Stream> and can emit the following new ones.
  
  =head2 request
  
    $stream->on(request => sub {
      my ($sream, $tx) = @_;
      ...
    });
  
  Emitted when a request is ready and needs to be handled.
  
    $stream->on(request => sub {
      my ($stream, $tx) = @_;
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body('Hello World!');
      $tx->resume;
    });
  
  =head2 start
  
    $stream->on(start => sub {
      my ($stream, $tx) = @_;
      ...
    });
  
  Emitted whenever a transaction for a new request is about to start.
  
  =head2 upgrade
  
    $stream->on(upgrade => sub {
      my ($stream, $ws) = @_;
      ...
    });
  
  Emitted when the connection should be upgraded to the WebSocket protocol.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Stream::HTTPServer> inherits all attributes from
  L<Mojo::IOLoop::Stream> and implements the following ones.
  
  =head2 app
  
    my $app = $stream->app;
    $stream = $stream->app(Mojolicious->new);
  
  Application responsible for building transactions, defaults to a
  L<Mojo::HelloWorld> object.
  
  =head2 max_requests
  
    my $max = $stream->max_requests;
    $stream = $stream->max_requests(250);
  
  Maximum number of keep-alive requests per connection, defaults to C<100>.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Stream::HTTPServer> inherits all methods from
  L<Mojo::IOLoop::Stream> and implements the following new ones.
  
  =head2 new
  
    my $stream = Mojo::IOLoop::Stream::HTTPServer->new($handle);
  
  Construct a new L<Mojo::IOLoop::Stream::HTTPServer> object.
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_SERVER_DEBUG> environment variable to get some advanced
  diagnostics information printed to C<STDERR>.
  
    MOJO_SERVER_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
  
MOJO_IOLOOP_STREAM_HTTPSERVER

$fatpacked{"Mojo/IOLoop/Stream/WebSocketClient.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_STREAM_WEBSOCKETCLIENT';
  package Mojo::IOLoop::Stream::WebSocketClient;
  use Mojo::Base 'Mojo::IOLoop::Stream::HTTPClient';
  
  use Scalar::Util 'weaken';
  
  sub process {
    my ($self, $tx) = @_;
    $self->{tx} = $tx;
    weaken $self;
    $tx->on(resume => sub { $self->_write_content });
    $self->_write_content;
  }
  
  sub _finish {
    my $self = shift;
    return ++$self->{closing} && $self->close unless $self->{tx};
    delete($self->{tx})->closed;
    ++$self->{closing} && $self->close_gracefully;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Stream::WebSocketClient - Non-blocking I/O WebSocket client stream
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Stream::WebSocketClient;
    use Mojo::Transaction::WebSocket;
    
    # Create transaction
    my $ws = Mojo::Transaction::WebSocket->new;
    $ws->on(message => sub {
      my ($ws, $msg) = @_;
      say "Message: $msg";
    });
    
    # Create stream and process transaction with it
    my $stream = Mojo::IOLoop::Stream::WebSocketClient->new($handle);
    $stream->process($ws);
  
    # Start reactor if necessary
    $stream->reactor->start unless $stream->reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Stream::WebSocketClient> is a container for I/O streams used by
  L<Mojo::IOLoop> to support the WebSocket protocol client-side.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Stream::WebSocketClient> inherits all events from
  L<Mojo::IOLoop::Stream::HTTPClient>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Stream::WebSocketClient> inherits all attributes from
  L<Mojo::IOLoop::Stream::HTTPClient>.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Stream::WebSocketClient> inherits all methods from
  L<Mojo::IOLoop::Stream::HTTPClient> and implements the following new ones.
  
  =head2 process
  
    $stream->process(Mojo::Transaction::WebSocket->new);
  
  Process a L<Mojo::Transaction::WebSocket> object.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
  
MOJO_IOLOOP_STREAM_WEBSOCKETCLIENT

$fatpacked{"Mojo/IOLoop/Stream/WebSocketServer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_STREAM_WEBSOCKETSERVER';
  package Mojo::IOLoop::Stream::WebSocketServer;
  use Mojo::Base 'Mojo::IOLoop::Stream::HTTPServer';
  
  use Scalar::Util 'weaken';
  
  sub process {
    my ($self, $tx) = @_;
    $self->{tx} = $tx;
    weaken $self;
    $tx->on(resume => sub { $self->_write_content });
    $self->_write_content;
  }
  
  sub _close { delete($_[0]->{tx})->closed if $_[0]->{tx} }
  
  sub _finish { shift->close_gracefully }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Stream::WebSocketServer - Non-blocking I/O WebSocket server stream
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Stream::WebSocketServer;
    use Mojo::Transaction::WebSocket;
    
    # Create transaction
    my $ws = Mojo::Transaction::WebSocket->new;
    $ws->on(message => sub {
      my ($ws, $msg) = @_;
      say "Message: $msg";
    });
  
    # Create stream and process transaction with it
    my $stream = Mojo::IOLoop::Stream::WebSocketServer->new($handle);
    $stream->process($ws);
  
    # Start reactor if necessary
    $stream->reactor->start unless $stream->reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Stream::WebSocketServer> is a container for I/O streams used by
  L<Mojo::IOLoop> to support the WebSocket protocol server-side.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Stream::WEBSocketServer> inherits all events from
  L<Mojo::IOLoop::Stream::HTTPServer>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Stream::WebSocketServer> inherits all attributes from
  L<Mojo::IOLoop::Stream::HTTPServer>.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Stream::WebSocketServer> inherits all methods from
  L<Mojo::IOLoop::Stream::HTTPServer> and implements the following new ones.
  
  =head2 process
  
    $stream->process(Mojo::Transaction::WebSocket->new);
  
  Process a L<Mojo::Transaction::WebSocket> object.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
  
MOJO_IOLOOP_STREAM_WEBSOCKETSERVER

$fatpacked{"Mojo/IOLoop/Subprocess.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_SUBPROCESS';
  package Mojo::IOLoop::Subprocess;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Config;
  use Mojo::IOLoop;
  use Mojo::IOLoop::Stream;
  use POSIX ();
  use Storable;
  
  has deserialize => sub { \&Storable::thaw };
  has ioloop      => sub { Mojo::IOLoop->singleton };
  has serialize   => sub { \&Storable::freeze };
  
  sub pid { shift->{pid} }
  
  sub run {
    my ($self, @args) = @_;
    $self->ioloop->next_tick(sub { $self->_start(@args) });
    return $self;
  }
  
  sub _start {
    my ($self, $child, $parent) = @_;
  
    # No fork emulation support
    return $self->$parent('Subprocesses do not support fork emulation')
      if $Config{d_pseudofork};
  
    # Pipe for subprocess communication
    return $self->$parent("Can't create pipe: $!")
      unless pipe(my $reader, my $writer);
    $writer->autoflush(1);
  
    # Child
    return $self->$parent("Can't fork: $!")
      unless defined(my $pid = $self->{pid} = fork);
    unless ($pid) {
      $self->ioloop->reset;
      my $results = eval { [$self->$child] } || [];
      print $writer $self->serialize->([$@, @$results]);
      POSIX::_exit(0);
    }
  
    # Parent
    my $me     = $$;
    my $stream = Mojo::IOLoop::Stream->new($reader)->timeout(0);
    $self->emit('spawn')->ioloop->stream($stream);
    my $buffer = '';
    $stream->on(read => sub { $buffer .= pop });
    $stream->on(
      close => sub {
        return unless $$ == $me;
        waitpid $pid, 0;
        my $results = eval { $self->deserialize->($buffer) } || [];
        $self->$parent(shift(@$results) // $@, @$results);
      }
    );
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Subprocess - Subprocesses
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Subprocess;
  
    # Operation that would block the event loop for 5 seconds
    my $subprocess = Mojo::IOLoop::Subprocess->new;
    $subprocess->run(
      sub {
        my $subprocess = shift;
        sleep 5;
        return '', 'Mojolicious';
      },
      sub {
        my ($subprocess, $err, @results) = @_;
        say "Subprocess error: $err" and return if $err;
        say "I $results[0] $results[1]!";
      }
    );
  
    # Start event loop if necessary
    $subprocess->ioloop->start unless $subprocess->ioloop->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Subprocess> allows L<Mojo::IOLoop> to perform computationally
  expensive operations in subprocesses, without blocking the event loop.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Subprocess> inherits all events from L<Mojo::EventEmitter> and
  can emit the following new ones.
  
  =head2 spawn
  
    $subprocess->on(spawn => sub {
      my $subprocess = shift;
      ...
    });
  
  Emitted in the parent process when the subprocess has been spawned.
  
    $subprocess->on(spawn => sub {
      my $subprocess = shift;
      my $pid = $subprocess->pid;
      say "Performing work in process $pid";
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Subprocess> implements the following attributes.
  
  =head2 deserialize
  
    my $cb      = $subprocess->deserialize;
    $subprocess = $subprocess->deserialize(sub {...});
  
  A callback used to deserialize subprocess return values, defaults to using
  L<Storable>.
  
    $subprocess->deserialize(sub {
      my $bytes = shift;
      return [];
    });
  
  =head2 ioloop
  
    my $loop    = $subprocess->ioloop;
    $subprocess = $subprocess->ioloop(Mojo::IOLoop->new);
  
  Event loop object to control, defaults to the global L<Mojo::IOLoop> singleton.
  
  =head2 serialize
  
    my $cb      = $subprocess->serialize;
    $subprocess = $subprocess->serialize(sub {...});
  
  A callback used to serialize subprocess return values, defaults to using
  L<Storable>.
  
    $subprocess->serialize(sub {
      my $array = shift;
      return '';
    });
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Subprocess> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 pid
  
    my $pid = $subprocess->pid;
  
  Process id of the spawned subprocess if available.
  
  =head2 run
  
    $subprocess = $subprocess->run(sub {...}, sub {...});
  
  Execute the first callback in a child process and wait for it to return one or
  more values, without blocking L</"ioloop"> in the parent process. Then execute
  the second callback in the parent process with the results. The return values of
  the first callback and exceptions thrown by it, will be serialized with
  L<Storable>, so they can be shared between processes.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_IOLOOP_SUBPROCESS

$fatpacked{"Mojo/IOLoop/TLS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_TLS';
  package Mojo::IOLoop::TLS;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Mojo::File 'path';
  use Mojo::IOLoop;
  use Scalar::Util 'weaken';
  
  # TLS support requires IO::Socket::SSL
  use constant TLS => $ENV{MOJO_NO_TLS}
    ? 0
    : eval { require IO::Socket::SSL; IO::Socket::SSL->VERSION('2.009'); 1 };
  use constant READ  => TLS ? IO::Socket::SSL::SSL_WANT_READ()  : 0;
  use constant WRITE => TLS ? IO::Socket::SSL::SSL_WANT_WRITE() : 0;
  
  has reactor => sub { Mojo::IOLoop->singleton->reactor };
  
  # To regenerate the certificate run this command (18.04.2012)
  # openssl req -new -x509 -keyout server.key -out server.crt -nodes -days 7300
  my $CERT = path(__FILE__)->sibling('resources', 'server.crt')->to_string;
  my $KEY  = path(__FILE__)->sibling('resources', 'server.key')->to_string;
  
  sub DESTROY { shift->_cleanup }
  
  sub can_tls {TLS}
  
  sub negotiate {
    my ($self, $args) = (shift, ref $_[0] ? $_[0] : {@_});
  
    return $self->emit(error => 'IO::Socket::SSL 2.009+ required for TLS support')
      unless TLS;
  
    my $handle = $self->{handle};
    return $self->emit(error => $IO::Socket::SSL::SSL_ERROR)
      unless IO::Socket::SSL->start_SSL($handle, %{$self->_expand($args)});
    $self->reactor->io($handle
        = $handle => sub { $self->_tls($handle, $args->{server}) });
  }
  
  sub new { shift->SUPER::new(handle => shift) }
  
  sub _cleanup {
    my $self = shift;
    return unless my $reactor = $self->reactor;
    $reactor->remove($self->{handle}) if $self->{handle};
    return $self;
  }
  
  sub _expand {
    my ($self, $args) = @_;
  
    weaken $self;
    my $tls = {
      SSL_error_trap     => sub { $self->_cleanup->emit(error => $_[1]) },
      SSL_startHandshake => 0
    };
    $tls->{SSL_alpn_protocols} = $args->{tls_protocols} if $args->{tls_protocols};
    $tls->{SSL_ca_file} = $args->{tls_ca}
      if $args->{tls_ca} && -T $args->{tls_ca};
    $tls->{SSL_cert_file}   = $args->{tls_cert}    if $args->{tls_cert};
    $tls->{SSL_cipher_list} = $args->{tls_ciphers} if $args->{tls_ciphers};
    $tls->{SSL_key_file}    = $args->{tls_key}     if $args->{tls_key};
    $tls->{SSL_server}      = $args->{server}      if $args->{server};
    $tls->{SSL_verify_mode} = $args->{tls_verify}  if defined $args->{tls_verify};
    $tls->{SSL_version}     = $args->{tls_version} if $args->{tls_version};
  
    if ($args->{server}) {
      $tls->{SSL_cert_file} ||= $CERT;
      $tls->{SSL_key_file}  ||= $KEY;
    }
    else {
      $tls->{SSL_hostname}
        = IO::Socket::SSL->can_client_sni ? $args->{address} : '';
      $tls->{SSL_verifycn_name} = $args->{address};
    }
  
    return $tls;
  }
  
  sub _tls {
    my ($self, $handle, $server) = @_;
  
    return $self->_cleanup->emit(upgrade => delete $self->{handle})
      if $server ? $handle->accept_SSL : $handle->connect_SSL;
  
    # Switch between reading and writing
    my $err = $IO::Socket::SSL::SSL_ERROR;
    if    ($err == READ)  { $self->reactor->watch($handle, 1, 0) }
    elsif ($err == WRITE) { $self->reactor->watch($handle, 1, 1) }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::TLS - Non-blocking TLS handshake
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::TLS;
  
    # Negotiate TLS
    my $tls = Mojo::IOLoop::TLS->new($old_handle);
    $tls->on(upgrade => sub {
      my ($tls, $new_handle) = @_;
      ...
    });
    $tls->on(error => sub {
      my ($tls, $err) = @_;
      ...
    });
    $tls->negotiate(server => 1, tls_version => 'TLSv1_2');
  
    # Start reactor if necessary
    $tls->reactor->start unless $tls->reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::TLS> negotiates TLS for L<Mojo::IOLoop>.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::TLS> inherits all events from L<Mojo::EventEmitter> and can
  emit the following new ones.
  
  =head2 upgrade
  
    $tls->on(upgrade => sub {
      my ($tls, $handle) = @_;
      ...
    });
  
  Emitted once TLS has been negotiated.
  
  =head2 error
  
    $tls->on(error => sub {
      my ($tls, $err) = @_;
      ...
    });
  
  Emitted if an error occurs during negotiation, fatal if unhandled.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::TLS> implements the following attributes.
  
  =head2 reactor
  
    my $reactor = $tls->reactor;
    $tls        = $tls->reactor(Mojo::Reactor::Poll->new);
  
  Low-level event reactor, defaults to the C<reactor> attribute value of the
  global L<Mojo::IOLoop> singleton.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::TLS> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 can_tls
  
    my $bool = Mojo::IOLoop::TLS->can_tls;
  
  True if L<IO::Socket::SSL> 2.009+ is installed and TLS support enabled.
  
  =head2 negotiate
  
    $tls->negotiate(server => 1, tls_version => 'TLSv1_2');
    $tls->negotiate({server => 1, tls_version => 'TLSv1_2'});
  
  Negotiate TLS.
  
  These options are currently available:
  
  =over 2
  
  =item server
  
    server => 1
  
  Negotiate TLS from the server-side, defaults to the client-side.
  
  =item tls_ca
  
    tls_ca => '/etc/tls/ca.crt'
  
  Path to TLS certificate authority file.
  
  =item tls_cert
  
    tls_cert => '/etc/tls/server.crt'
    tls_cert => {'mojolicious.org' => '/etc/tls/mojo.crt'}
  
  Path to the TLS cert file, defaults to a built-in test certificate on the
  server-side.
  
  =item tls_ciphers
  
    tls_ciphers => 'AES128-GCM-SHA256:RC4:HIGH:!MD5:!aNULL:!EDH'
  
  TLS cipher specification string. For more information about the format see
  L<https://www.openssl.org/docs/manmaster/apps/ciphers.html#CIPHER-STRINGS>.
  
  =item tls_key
  
    tls_key => '/etc/tls/server.key'
    tls_key => {'mojolicious.org' => '/etc/tls/mojo.key'}
  
  Path to the TLS key file, defaults to a built-in test key on the server-side.
  
  =item tls_protocols
  
    tls_protocols => ['foo', 'bar']
  
  ALPN protocols to negotiate.
  
  =item tls_verify
  
    tls_verify => 0x00
  
  TLS verification mode.
  
  =item tls_version
  
    tls_version => 'TLSv1_2'
  
  TLS protocol version.
  
  =back
  
  =head2 new
  
    my $tls = Mojo::IOLoop::TLS->new($handle);
  
  Construct a new L<Mojo::IOLoop::Stream> object.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_IOLOOP_TLS

$fatpacked{"Mojo/JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_JSON';
  package Mojo::JSON;
  use Mojo::Base -strict;
  
  use Carp 'croak';
  use Exporter 'import';
  use JSON::PP ();
  use Mojo::Util qw(decode encode monkey_patch);
  use Scalar::Util 'blessed';
  
  # For better performance Cpanel::JSON::XS is required
  use constant JSON_XS => $ENV{MOJO_NO_JSON_XS}
    ? 0
    : eval { require Cpanel::JSON::XS; Cpanel::JSON::XS->VERSION('4.04'); 1 };
  
  our @EXPORT_OK = qw(decode_json encode_json false from_json j to_json true);
  
  # Escaped special character map
  my %ESCAPE = (
    '"'  => '"',
    '\\' => '\\',
    '/'  => '/',
    'b'  => "\x08",
    'f'  => "\x0c",
    'n'  => "\x0a",
    'r'  => "\x0d",
    't'  => "\x09"
  );
  my %REVERSE = map { $ESCAPE{$_} => "\\$_" } keys %ESCAPE;
  for (0x00 .. 0x1f) { $REVERSE{pack 'C', $_} //= sprintf '\u%.4X', $_ }
  
  # Replace pure-Perl fallbacks if Cpanel::JSON::XS is available
  if (JSON_XS) {
    my $BINARY = Cpanel::JSON::XS->new->utf8;
    my $TEXT   = Cpanel::JSON::XS->new;
    $_->canonical->allow_nonref->allow_unknown->allow_blessed->convert_blessed
      ->stringify_infnan->escape_slash
      for $BINARY, $TEXT;
    monkey_patch __PACKAGE__, 'encode_json', sub { $BINARY->encode($_[0]) };
    monkey_patch __PACKAGE__, 'decode_json', sub { $BINARY->decode($_[0]) };
    monkey_patch __PACKAGE__, 'to_json',     sub { $TEXT->encode($_[0]) };
    monkey_patch __PACKAGE__, 'from_json',   sub { $TEXT->decode($_[0]) };
  }
  
  sub decode_json {
    my $err = _decode(\my $value, shift);
    return defined $err ? croak $err : $value;
  }
  
  sub encode_json { encode('UTF-8', _encode_value(shift)) }
  
  sub false () {JSON::PP::false}
  
  sub from_json {
    my $err = _decode(\my $value, shift, 1);
    return defined $err ? croak $err : $value;
  }
  
  sub j {
    return encode_json($_[0]) if ref $_[0] eq 'ARRAY' || ref $_[0] eq 'HASH';
    return eval { decode_json($_[0]) };
  }
  
  sub to_json { _encode_value(shift) }
  
  sub true () {JSON::PP::true}
  
  sub _decode {
    my $valueref = shift;
  
    eval {
  
      # Missing input
      die "Missing or empty input\n" unless length(local $_ = shift);
  
      # UTF-8
      $_ = decode('UTF-8', $_) unless shift;
      die "Input is not UTF-8 encoded\n" unless defined;
  
      # Value
      $$valueref = _decode_value();
  
      # Leftover data
      /\G[\x20\x09\x0a\x0d]*\z/gc or _throw('Unexpected data');
    } ? return undef : chomp $@;
  
    return $@;
  }
  
  sub _decode_array {
    my @array;
    until (m/\G[\x20\x09\x0a\x0d]*\]/gc) {
  
      # Value
      push @array, _decode_value();
  
      # Separator
      redo if /\G[\x20\x09\x0a\x0d]*,/gc;
  
      # End
      last if /\G[\x20\x09\x0a\x0d]*\]/gc;
  
      # Invalid character
      _throw('Expected comma or right square bracket while parsing array');
    }
  
    return \@array;
  }
  
  sub _decode_object {
    my %hash;
    until (m/\G[\x20\x09\x0a\x0d]*\}/gc) {
  
      # Quote
      /\G[\x20\x09\x0a\x0d]*"/gc
        or _throw('Expected string while parsing object');
  
      # Key
      my $key = _decode_string();
  
      # Colon
      /\G[\x20\x09\x0a\x0d]*:/gc or _throw('Expected colon while parsing object');
  
      # Value
      $hash{$key} = _decode_value();
  
      # Separator
      redo if /\G[\x20\x09\x0a\x0d]*,/gc;
  
      # End
      last if /\G[\x20\x09\x0a\x0d]*\}/gc;
  
      # Invalid character
      _throw('Expected comma or right curly bracket while parsing object');
    }
  
    return \%hash;
  }
  
  sub _decode_string {
    my $pos = pos;
  
    # Extract string with escaped characters
    m!\G((?:(?:[^\x00-\x1f\\"]|\\(?:["\\/bfnrt]|u[0-9a-fA-F]{4})){0,32766})*)!gc;
    my $str = $1;
  
    # Invalid character
    unless (m/\G"/gc) {
      _throw('Unexpected character or invalid escape while parsing string')
        if /\G[\x00-\x1f\\]/;
      _throw('Unterminated string');
    }
  
    # Unescape popular characters
    if (index($str, '\\u') < 0) {
      $str =~ s!\\(["\\/bfnrt])!$ESCAPE{$1}!gs;
      return $str;
    }
  
    # Unescape everything else
    my $buffer = '';
    while ($str =~ /\G([^\\]*)\\(?:([^u])|u(.{4}))/gc) {
      $buffer .= $1;
  
      # Popular character
      if ($2) { $buffer .= $ESCAPE{$2} }
  
      # Escaped
      else {
        my $ord = hex $3;
  
        # Surrogate pair
        if (($ord & 0xf800) == 0xd800) {
  
          # High surrogate
          ($ord & 0xfc00) == 0xd800
            or pos = $pos + pos($str), _throw('Missing high-surrogate');
  
          # Low surrogate
          $str =~ /\G\\u([Dd][C-Fc-f]..)/gc
            or pos = $pos + pos($str), _throw('Missing low-surrogate');
  
          $ord = 0x10000 + ($ord - 0xd800) * 0x400 + (hex($1) - 0xdc00);
        }
  
        # Character
        $buffer .= pack 'U', $ord;
      }
    }
  
    # The rest
    return $buffer . substr $str, pos($str), length($str);
  }
  
  sub _decode_value {
  
    # Leading whitespace
    /\G[\x20\x09\x0a\x0d]*/gc;
  
    # String
    return _decode_string() if /\G"/gc;
  
    # Object
    return _decode_object() if /\G\{/gc;
  
    # Array
    return _decode_array() if /\G\[/gc;
  
    # Number
    return 0 + $1
      if /\G([-]?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?)/gc;
  
    # True
    return true() if /\Gtrue/gc;
  
    # False
    return false() if /\Gfalse/gc;
  
    # Null
    return undef if /\Gnull/gc;
  
    # Invalid character
    _throw('Expected string, array, object, number, boolean or null');
  }
  
  sub _encode_array {
    '[' . join(',', map { _encode_value($_) } @{$_[0]}) . ']';
  }
  
  sub _encode_object {
    my $object = shift;
    my @pairs = map { _encode_string($_) . ':' . _encode_value($object->{$_}) }
      sort keys %$object;
    return '{' . join(',', @pairs) . '}';
  }
  
  sub _encode_string {
    my $str = shift;
    $str =~ s!([\x00-\x1f\\"/])!$REVERSE{$1}!gs;
    return "\"$str\"";
  }
  
  sub _encode_value {
    my $value = shift;
  
    # Reference
    if (my $ref = ref $value) {
  
      # Object
      return _encode_object($value) if $ref eq 'HASH';
  
      # Array
      return _encode_array($value) if $ref eq 'ARRAY';
  
      # True or false
      return $$value ? 'true' : 'false' if $ref eq 'SCALAR';
      return $value  ? 'true' : 'false' if $ref eq 'JSON::PP::Boolean';
  
      # Everything else
      return 'null' unless blessed $value;
      return _encode_string($value) unless my $sub = $value->can('TO_JSON');
      return _encode_value($value->$sub);
    }
  
    # Null
    return 'null' unless defined $value;
  
    # Number
    no warnings 'numeric';
    return $value
      if !utf8::is_utf8($value)
      && length((my $dummy = '') & $value)
      && 0 + $value eq $value
      && $value * 0 == 0;
  
    # String
    return _encode_string($value);
  }
  
  sub _throw {
  
    # Leading whitespace
    /\G[\x20\x09\x0a\x0d]*/gc;
  
    # Context
    my $context = 'Malformed JSON: ' . shift;
    if (m/\G\z/gc) { $context .= ' before end of data' }
    else {
      my @lines = split "\n", substr($_, 0, pos);
      $context .= ' at line ' . @lines . ', offset ' . length(pop @lines || '');
    }
  
    die "$context\n";
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::JSON - Minimalistic JSON
  
  =head1 SYNOPSIS
  
    use Mojo::JSON qw(decode_json encode_json);
  
    my $bytes = encode_json {foo => [1, 2], bar => 'hello!', baz => \1};
    my $hash  = decode_json $bytes;
  
  =head1 DESCRIPTION
  
  L<Mojo::JSON> is a minimalistic and possibly the fastest pure-Perl
  implementation of L<RFC 8259|http://tools.ietf.org/html/rfc8259>.
  
  It supports normal Perl data types like scalar, array reference, hash reference
  and will try to call the C<TO_JSON> method on blessed references, or stringify
  them if it doesn't exist. Differentiating between strings and numbers in Perl
  is hard, depending on how it has been used, a scalar can be both at the same
  time. The string value has a higher precedence unless both representations are
  equivalent.
  
    [1, -2, 3]     -> [1, -2, 3]
    {"foo": "bar"} -> {foo => 'bar'}
  
  Literal names will be translated to and from L<Mojo::JSON> constants or a
  similar native Perl value.
  
    true  -> Mojo::JSON->true
    false -> Mojo::JSON->false
    null  -> undef
  
  In addition scalar references will be used to generate booleans, based on if
  their values are true or false.
  
    \1 -> true
    \0 -> false
  
  The character C</> will always be escaped to prevent XSS attacks.
  
    "</script>" -> "<\/script>"
  
  For better performance the optional module L<Cpanel::JSON::XS> (4.04+) will be
  used automatically if possible. This can also be disabled with the
  C<MOJO_NO_JSON_XS> environment variable.
  
  =head1 FUNCTIONS
  
  L<Mojo::JSON> implements the following functions, which can be imported
  individually.
  
  =head2 decode_json
  
    my $value = decode_json $bytes;
  
  Decode JSON to Perl value and die if decoding fails.
  
  =head2 encode_json
  
    my $bytes = encode_json {i => ' mojolicious'};
  
  Encode Perl value to JSON.
  
  =head2 false
  
    my $false = false;
  
  False value, used because Perl has no native equivalent.
  
  =head2 from_json
  
    my $value = from_json $chars;
  
  Decode JSON text that is not C<UTF-8> encoded to Perl value and die if decoding
  fails.
  
  =head2 j
  
    my $bytes = j [1, 2, 3];
    my $bytes = j {i => ' mojolicious'};
    my $value = j $bytes;
  
  Encode Perl data structure (which may only be an array reference or hash
  reference) or decode JSON, an C<undef> return value indicates a bare C<null> or
  that decoding failed.
  
  =head2 to_json
  
    my $chars = to_json {i => ' mojolicious'};
  
  Encode Perl value to JSON text without C<UTF-8> encoding it.
  
  =head2 true
  
    my $true = true;
  
  True value, used because Perl has no native equivalent.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_JSON

$fatpacked{"Mojo/JSON/Pointer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_JSON_POINTER';
  package Mojo::JSON::Pointer;
  use Mojo::Base -base;
  
  has 'data';
  
  sub contains { shift->_pointer(1, @_) }
  sub get      { shift->_pointer(0, @_) }
  
  sub new { @_ > 1 ? shift->SUPER::new(data => shift) : shift->SUPER::new }
  
  sub _pointer {
    my ($self, $contains, $pointer) = @_;
  
    my $data = $self->data;
    return $contains ? 1 : $data unless $pointer =~ s!^/!!;
    for my $p (length $pointer ? (split '/', $pointer, -1) : ($pointer)) {
      $p =~ s!~1!/!g;
      $p =~ s/~0/~/g;
  
      # Hash
      if (ref $data eq 'HASH' && exists $data->{$p}) { $data = $data->{$p} }
  
      # Array
      elsif (ref $data eq 'ARRAY' && $p =~ /^\d+$/ && @$data > $p) {
        $data = $data->[$p];
      }
  
      # Nothing
      else { return undef }
    }
  
    return $contains ? 1 : $data;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::JSON::Pointer - JSON Pointers
  
  =head1 SYNOPSIS
  
    use Mojo::JSON::Pointer;
  
    my $pointer = Mojo::JSON::Pointer->new({foo => [23, 'bar']});
    say $pointer->get('/foo/1');
    say 'Contains "/foo".' if $pointer->contains('/foo');
  
  =head1 DESCRIPTION
  
  L<Mojo::JSON::Pointer> is an implementation of
  L<RFC 6901|http://tools.ietf.org/html/rfc6901>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::JSON::Pointer> implements the following attributes.
  
  =head2 data
  
    my $data = $pointer->data;
    $pointer = $pointer->data({foo => 'bar'});
  
  Data structure to be processed.
  
  =head1 METHODS
  
  L<Mojo::JSON::Pointer> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 contains
  
    my $bool = $pointer->contains('/foo/1');
  
  Check if L</"data"> contains a value that can be identified with the given JSON
  Pointer.
  
    # True
    Mojo::JSON::Pointer->new('just a string')->contains('');
    Mojo::JSON::Pointer->new({'' => 'mojolicious'})->contains('/');
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5]})->contains('/foo');
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5]})->contains('/baz/1');
  
    # False
    Mojo::JSON::Pointer->new({'' => 'mojolicious'})->contains('/');
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5]})->contains('/bar');
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5]})->contains('/baz/9');
  
  =head2 get
  
    my $value = $pointer->get('/foo/bar');
  
  Extract value from L</"data"> identified by the given JSON Pointer.
  
    # "just a string"
    Mojo::JSON::Pointer->new('just a string')->get('');
  
    # "mojolicious"
    Mojo::JSON::Pointer->new({'' => 'mojolicious'})->get('/');
  
    # "bar"
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5, 6]})->get('/foo');
  
    # "4"
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5, 6]})->get('/baz/0');
  
    # "6"
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5, 6]})->get('/baz/2');
  
  =head2 new
  
    my $pointer = Mojo::JSON::Pointer->new;
    my $pointer = Mojo::JSON::Pointer->new({foo => 'bar'});
  
  Build new L<Mojo::JSON::Pointer> object.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_JSON_POINTER

$fatpacked{"Mojo/Loader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_LOADER';
  package Mojo::Loader;
  use Mojo::Base -strict;
  
  use Exporter 'import';
  use Mojo::Exception;
  use Mojo::File 'path';
  use Mojo::Util qw(b64_decode class_to_path);
  
  our @EXPORT_OK
    = qw(data_section file_is_binary find_modules find_packages load_class);
  
  my (%BIN, %CACHE);
  
  sub data_section { $_[0] ? $_[1] ? _all($_[0])->{$_[1]} : _all($_[0]) : undef }
  
  sub file_is_binary { keys %{_all($_[0])} ? !!$BIN{$_[0]}{$_[1]} : undef }
  
  sub find_modules {
    my $ns = shift;
  
    my %modules;
    for my $directory (@INC) {
      next unless -d (my $path = path($directory, split(/::|'/, $ns)));
      $modules{"${ns}::$_"}++
        for $path->list->grep(qr/\.pm$/)->map('basename', '.pm')->each;
    }
  
    return sort keys %modules;
  }
  
  sub find_packages {
    my $ns = shift;
    no strict 'refs';
    return sort map { /^(.+)::$/ ? "${ns}::$1" : () } keys %{"${ns}::"};
  }
  
  sub load_class {
    my $class = shift;
  
    # Invalid class name
    return 1 if ($class || '') !~ /^\w(?:[\w:']*\w)?$/;
  
    # Load if not already loaded
    return undef if $class->can('new') || eval "require $class; 1";
  
    # Does not exist
    return 1 if $@ =~ /^Can't locate \Q@{[class_to_path $class]}\E in \@INC/;
  
    # Real error
    return Mojo::Exception->new($@)->inspect;
  }
  
  sub _all {
    my $class = shift;
  
    return $CACHE{$class} if $CACHE{$class};
    local $.;
    my $handle = do { no strict 'refs'; \*{"${class}::DATA"} };
    return {} unless fileno $handle;
    seek $handle, 0, 0;
    my $data = join '', <$handle>;
  
    # Ignore everything before __DATA__ (some versions seek to start of file)
    $data =~ s/^.*\n__DATA__\r?\n/\n/s;
  
    # Ignore everything after __END__
    $data =~ s/\n__END__\r?\n.*$/\n/s;
  
    # Split files
    (undef, my @files) = split /^@@\s*(.+?)\s*\r?\n/m, $data;
  
    # Find data
    my $all = $CACHE{$class} = {};
    while (@files) {
      my ($name, $data) = splice @files, 0, 2;
      $all->{$name} = $name =~ s/\s*\(\s*base64\s*\)$//
        && ++$BIN{$class}{$name} ? b64_decode $data : $data;
    }
  
    return $all;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Loader - Load all kinds of things
  
  =head1 SYNOPSIS
  
    use Mojo::Loader qw(data_section find_modules load_class);
  
    # Find modules in a namespace
    for my $module (find_modules 'Some::Namespace') {
  
      # Load them safely
      my $e = load_class $module;
      warn qq{Loading "$module" failed: $e} and next if ref $e;
  
      # And extract files from the DATA section
      say data_section($module, 'some_file.txt');
    }
  
  =head1 DESCRIPTION
  
  L<Mojo::Loader> is a class loader and plugin framework. Aside from finding
  modules and loading classes, it allows multiple files to be stored in the
  C<DATA> section of a class, which can then be accessed individually.
  
    package Foo;
  
    1;
    __DATA__
  
    @@ test.txt
    This is the first file.
  
    @@ test2.html (base64)
    VGhpcyBpcyB0aGUgc2Vjb25kIGZpbGUu
  
    @@ test
    This is the
    third file.
  
  Each file has a header starting with C<@@>, followed by the file name and
  optional instructions for decoding its content. Currently only the Base64
  encoding is supported, which can be quite convenient for the storage of binary
  data.
  
  =head1 FUNCTIONS
  
  L<Mojo::Loader> implements the following functions, which can be imported
  individually.
  
  =head2 data_section
  
    my $all   = data_section 'Foo::Bar';
    my $index = data_section 'Foo::Bar', 'index.html';
  
  Extract embedded file from the C<DATA> section of a class, all files will be
  cached once they have been accessed for the first time.
  
    # List embedded files
    say for keys %{data_section 'Foo::Bar'};
  
  =head2 file_is_binary
  
    my $bool = file_is_binary 'Foo::Bar', 'test.png';
  
  Check if embedded file from the C<DATA> section of a class was Base64 encoded.
  
  =head2 find_packages
  
    my @pkgs = find_packages 'MyApp::Namespace';
  
  Search for packages in a namespace non-recursively.
  
  =head2 find_modules
  
    my @modules = find_modules 'MyApp::Namespace';
  
  Search for modules in a namespace non-recursively.
  
  =head2 load_class
  
    my $e = load_class 'Foo::Bar';
  
  Load a class and catch exceptions, returns a false value if loading was
  successful, a true value if the class was not found, or a L<Mojo::Exception>
  object if loading failed. Note that classes are checked for a C<new> method to
  see if they are already loaded, so trying to load the same class multiple times
  may yield different results.
  
    # Handle exceptions
    if (my $e = load_class 'Foo::Bar') {
      die ref $e ? "Exception: $e" : 'Not found!';
    }
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_LOADER

$fatpacked{"Mojo/Log.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_LOG';
  package Mojo::Log;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Fcntl ':flock';
  use Mojo::File;
  use Mojo::Util 'encode';
  
  has format => sub { shift->short ? \&_short : \&_default };
  has handle => sub {
  
    # STDERR
    return \*STDERR unless my $path = shift->path;
  
    # File
    return Mojo::File->new($path)->open('>>');
  };
  has history          => sub { [] };
  has level            => 'debug';
  has max_history_size => 10;
  has 'path';
  has short => sub { $ENV{MOJO_LOG_SHORT} };
  
  # Supported log levels
  my %LEVEL = (debug => 1, info => 2, warn => 3, error => 4, fatal => 5);
  
  # Systemd magic numbers
  my %MAGIC = (debug => 7, info => 6, warn => 4, error => 3, fatal => 2);
  
  sub append {
    my ($self, $msg) = @_;
  
    return unless my $handle = $self->handle;
    flock $handle, LOCK_EX;
    $handle->print(encode('UTF-8', $msg)) or croak "Can't write to log: $!";
    flock $handle, LOCK_UN;
  }
  
  sub debug { shift->_log(debug => @_) }
  sub error { shift->_log(error => @_) }
  sub fatal { shift->_log(fatal => @_) }
  sub info  { shift->_log(info  => @_) }
  
  sub is_level { $LEVEL{pop()} >= $LEVEL{$ENV{MOJO_LOG_LEVEL} || shift->level} }
  
  sub new {
    my $self = shift->SUPER::new(@_);
    $self->on(message => \&_message);
    return $self;
  }
  
  sub warn { shift->_log(warn => @_) }
  
  sub _default {
    '[' . localtime(shift) . '] [' . shift() . '] ' . join "\n", @_, '';
  }
  
  sub _log { shift->emit('message', shift, @_) }
  
  sub _message {
    my ($self, $level) = (shift, shift);
  
    return unless $self->is_level($level);
  
    my $max     = $self->max_history_size;
    my $history = $self->history;
    push @$history, my $msg = [time, $level, @_];
    shift @$history while @$history > $max;
  
    $self->append($self->format->(@$msg));
  }
  
  sub _short {
    my ($time, $level) = (shift, shift);
    my ($magic, $short) = ("<$MAGIC{$level}>", substr($level, 0, 1));
    return "${magic}[$short] " . join("\n$magic", @_) . "\n";
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Log - Simple logger
  
  =head1 SYNOPSIS
  
    use Mojo::Log;
  
    # Log to STDERR
    my $log = Mojo::Log->new;
  
    # Customize log file location and minimum log level
    my $log = Mojo::Log->new(path => '/var/log/mojo.log', level => 'warn');
  
    # Log messages
    $log->debug('Not sure what is happening here');
    $log->info('FYI: it happened again');
    $log->warn('This might be a problem');
    $log->error('Garden variety error');
    $log->fatal('Boom');
  
  =head1 DESCRIPTION
  
  L<Mojo::Log> is a simple logger for L<Mojo> projects.
  
  =head1 EVENTS
  
  L<Mojo::Log> inherits all events from L<Mojo::EventEmitter> and can emit the
  following new ones.
  
  =head2 message
  
    $log->on(message => sub {
      my ($log, $level, @lines) = @_;
      ...
    });
  
  Emitted when a new message gets logged.
  
    $log->on(message => sub {
      my ($log, $level, @lines) = @_;
      say "$level: ", @lines;
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Log> implements the following attributes.
  
  =head2 format
  
    my $cb = $log->format;
    $log   = $log->format(sub {...});
  
  A callback for formatting log messages.
  
    $log->format(sub {
      my ($time, $level, @lines) = @_;
      return "[Thu May 15 17:47:04 2014] [info] I  Mojolicious\n";
    });
  
  =head2 handle
  
    my $handle = $log->handle;
    $log       = $log->handle(IO::Handle->new);
  
  Log filehandle used by default L</"message"> event, defaults to opening
  L</"path"> or C<STDERR>.
  
  =head2 history
  
    my $history = $log->history;
    $log        = $log->history([[time, 'debug', 'That went wrong']]);
  
  The last few logged messages.
  
  =head2 level
  
    my $level = $log->level;
    $log      = $log->level('debug');
  
  Active log level, defaults to C<debug>. Available log levels are C<debug>,
  C<info>, C<warn>, C<error> and C<fatal>, in that order. Note that the
  C<MOJO_LOG_LEVEL> environment variable can override this value.
  
  =head2 max_history_size
  
    my $size = $log->max_history_size;
    $log     = $log->max_history_size(5);
  
  Maximum number of logged messages to store in L</"history">, defaults to C<10>.
  
  =head2 path
  
    my $path = $log->path
    $log     = $log->path('/var/log/mojo.log');
  
  Log file path used by L</"handle">.
  
  =head2 short
  
    my $bool = $log->short;
    $log     = $log->short($bool);
  
  Generate short log messages without a timestamp, suitable for systemd, defaults
  to the value of the C<MOJO_LOG_SHORT> environment variables.
  
  =head1 METHODS
  
  L<Mojo::Log> inherits all methods from L<Mojo::EventEmitter> and implements the
  following new ones.
  
  =head2 append
  
    $log->append("[Thu May 15 17:47:04 2014] [info] I  Mojolicious\n");
  
  Append message to L</"handle">.
  
  =head2 debug
  
    $log = $log->debug('You screwed up, but that is ok');
    $log = $log->debug('All', 'cool');
  
  Emit L</"message"> event and log C<debug> message.
  
  =head2 error
  
    $log = $log->error('You really screwed up this time');
    $log = $log->error('Wow', 'seriously');
  
  Emit L</"message"> event and log C<error> message.
  
  =head2 fatal
  
    $log = $log->fatal('Its over...');
    $log = $log->fatal('Bye', 'bye');
  
  Emit L</"message"> event and log C<fatal> message.
  
  =head2 info
  
    $log = $log->info('You are bad, but you prolly know already');
    $log = $log->info('Ok', 'then');
  
  Emit L</"message"> event and log C<info> message.
  
  =head2 is_level
  
    my $bool = $log->is_level('debug');
  
  Check active log L</"level">.
  
    # True
    $log->level('debug')->is_level('debug');
    $log->level('debug')->is_level('info');
  
    # False
    $log->level('info')->is_level('debug');
    $log->level('fatal')->is_level('warn');
  
  =head2 new
  
    my $log = Mojo::Log->new;
    my $log = Mojo::Log->new(level => 'warn');
    my $log = Mojo::Log->new({level => 'warn'});
  
  Construct a new L<Mojo::Log> object and subscribe to L</"message"> event with
  default logger.
  
  =head2 warn
  
    $log = $log->warn('Dont do that Dave...');
    $log = $log->warn('No', 'really');
  
  Emit L</"message"> event and log C<warn> message.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_LOG

$fatpacked{"Mojo/Message.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_MESSAGE';
  package Mojo::Message;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Mojo::Asset::Memory;
  use Mojo::Content::Single;
  use Mojo::DOM;
  use Mojo::JSON 'j';
  use Mojo::JSON::Pointer;
  use Mojo::Parameters;
  use Mojo::Upload;
  use Mojo::Util 'decode';
  
  has content          => sub { Mojo::Content::Single->new };
  has default_charset  => 'UTF-8';
  has max_line_size    => sub { $ENV{MOJO_MAX_LINE_SIZE} || 8192 };
  has max_message_size => sub { $ENV{MOJO_MAX_MESSAGE_SIZE} // 16777216 };
  has version          => '1.1';
  
  sub body {
    my $self = shift;
  
    # Get
    my $content = $self->content;
    return $content->is_multipart ? '' : $content->asset->slurp unless @_;
  
    # Set (multipart content needs to be downgraded)
    $content = $self->content(Mojo::Content::Single->new)->content
      if $content->is_multipart;
    $content->asset(Mojo::Asset::Memory->new->add_chunk(@_));
  
    return $self;
  }
  
  sub body_params {
    my $self = shift;
  
    return $self->{body_params} if $self->{body_params};
    my $params = $self->{body_params} = Mojo::Parameters->new;
    $params->charset($self->content->charset || $self->default_charset);
  
    # "application/x-www-form-urlencoded"
    my $type = $self->headers->content_type // '';
    if ($type =~ m!application/x-www-form-urlencoded!i) {
      $params->parse($self->content->asset->slurp);
    }
  
    # "multipart/form-data"
    elsif ($type =~ m!multipart/form-data!i) {
      $params->append(@$_[0, 1]) for @{$self->_parse_formdata};
    }
  
    return $params;
  }
  
  sub body_size { shift->content->body_size }
  
  sub build_body       { shift->_build('get_body_chunk') }
  sub build_headers    { shift->_build('get_header_chunk') }
  sub build_start_line { shift->_build('get_start_line_chunk') }
  
  sub cookie { shift->_cache('cookies', 0, @_) }
  
  sub cookies { croak 'Method "cookies" not implemented by subclass' }
  
  sub dom {
    my $self = shift;
    return undef if $self->content->is_multipart;
    my $dom = $self->{dom} ||= Mojo::DOM->new($self->text);
    return @_ ? $dom->find(@_) : $dom;
  }
  
  sub error {
    my $self = shift;
    return $self->{error} unless @_;
    $self->{error} = shift;
    return $self->finish;
  }
  
  sub every_cookie { shift->_cache('cookies', 1, @_) }
  sub every_upload { shift->_cache('uploads', 1, @_) }
  
  sub extract_start_line {
    croak 'Method "extract_start_line" not implemented by subclass';
  }
  
  sub finish {
    my $self = shift;
    $self->{state} = 'finished';
    return $self->{finished}++ ? $self : $self->emit('finish');
  }
  
  sub fix_headers {
    my $self = shift;
    return $self if $self->{fix}++;
  
    # Content-Length or Connection (unless chunked transfer encoding is used)
    my $content = $self->content;
    my $headers = $content->headers;
    if ($content->is_multipart) { $headers->remove('Content-Length') }
    elsif ($content->is_chunked || $headers->content_length) { return $self }
    if   ($content->is_dynamic) { $headers->connection('close') }
    else                        { $headers->content_length($self->body_size) }
  
    return $self;
  }
  
  sub get_body_chunk {
    my ($self, $offset) = @_;
  
    $self->emit('progress', 'body', $offset);
    my $chunk = $self->content->get_body_chunk($offset);
    return $chunk if !defined $chunk || length $chunk;
    $self->finish;
  
    return $chunk;
  }
  
  sub get_header_chunk {
    my ($self, $offset) = @_;
    $self->emit('progress', 'headers', $offset);
    return $self->fix_headers->content->get_header_chunk($offset);
  }
  
  sub get_start_line_chunk {
    croak 'Method "get_start_line_chunk" not implemented by subclass';
  }
  
  sub header_size { shift->fix_headers->content->header_size }
  
  sub headers { shift->content->headers }
  
  sub is_finished { (shift->{state} // '') eq 'finished' }
  
  sub is_limit_exceeded { !!shift->{limit} }
  
  sub json {
    my ($self, $pointer) = @_;
    return undef if $self->content->is_multipart;
    my $data = $self->{json} //= j($self->body);
    return $pointer ? Mojo::JSON::Pointer->new($data)->get($pointer) : $data;
  }
  
  sub parse {
    my ($self, $chunk) = @_;
  
    return $self if $self->{error};
    $self->{raw_size} += length $chunk;
    $self->{buffer} .= $chunk;
  
    # Start-line
    unless ($self->{state}) {
  
      # Check start-line size
      my $len = index $self->{buffer}, "\x0a";
      $len = length $self->{buffer} if $len < 0;
      return $self->_limit('Maximum start-line size exceeded')
        if $len > $self->max_line_size;
  
      $self->{state} = 'content' if $self->extract_start_line(\$self->{buffer});
    }
  
    # Content
    my $state = $self->{state} // '';
    $self->content($self->content->parse(delete $self->{buffer}))
      if $state eq 'content' || $state eq 'finished';
  
    # Check message size
    my $max = $self->max_message_size;
    return $self->_limit('Maximum message size exceeded')
      if $max && $max < $self->{raw_size};
  
    # Check header size
    return $self->_limit('Maximum header size exceeded')
      if $self->headers->is_limit_exceeded;
  
    # Check buffer size
    return $self->_limit('Maximum buffer size exceeded')
      if $self->content->is_limit_exceeded;
  
    return $self->emit('progress')->content->is_finished ? $self->finish : $self;
  }
  
  sub start_line_size {
    croak 'Method "start_line_size" not implemented by subclass';
  }
  
  sub text {
    my $self    = shift;
    my $body    = $self->body;
    my $charset = $self->content->charset || $self->default_charset;
    return $charset ? decode($charset, $body) // $body : $body;
  }
  
  sub to_string {
    my $self = shift;
    return $self->build_start_line . $self->build_headers . $self->build_body;
  }
  
  sub upload { shift->_cache('uploads', 0, @_) }
  
  sub uploads {
    my $self = shift;
  
    my @uploads;
    for my $data (@{$self->_parse_formdata(1)}) {
      my $upload = Mojo::Upload->new(
        name     => $data->[0],
        filename => $data->[2],
        asset    => $data->[1]->asset,
        headers  => $data->[1]->headers
      );
      push @uploads, $upload;
    }
  
    return \@uploads;
  }
  
  sub _build {
    my ($self, $method) = @_;
  
    my ($buffer, $offset) = ('', 0);
    while (1) {
  
      # No chunk yet, try again
      next unless defined(my $chunk = $self->$method($offset));
  
      # End of part
      last unless my $len = length $chunk;
  
      $offset += $len;
      $buffer .= $chunk;
    }
  
    return $buffer;
  }
  
  sub _cache {
    my ($self, $method, $all, $name) = @_;
  
    # Cache objects by name
    unless ($self->{$method}) {
      $self->{$method} = {};
      push @{$self->{$method}{$_->name}}, $_ for @{$self->$method};
    }
  
    my $objects = $self->{$method}{$name} || [];
    return $all ? $objects : $objects->[-1];
  }
  
  sub _limit { ++$_[0]{limit} and return $_[0]->error({message => $_[1]}) }
  
  sub _parse_formdata {
    my ($self, $upload) = @_;
  
    my @formdata;
    my $content = $self->content;
    return \@formdata unless $content->is_multipart;
    my $charset = $content->charset || $self->default_charset;
  
    # Check all parts recursively
    my @parts = ($content);
    while (my $part = shift @parts) {
  
      if ($part->is_multipart) {
        unshift @parts, @{$part->parts};
        next;
      }
  
      next unless my $disposition = $part->headers->content_disposition;
      my ($filename) = $disposition =~ /[; ]filename="((?:\\"|[^"])*)"/;
      next if $upload && !defined $filename || !$upload && defined $filename;
      my ($name) = $disposition =~ /[; ]name="((?:\\"|[^;"])*)"/;
      $part = $part->asset->slurp unless $upload;
  
      if ($charset) {
        $name     = decode($charset, $name) // $name         if $name;
        $filename = decode($charset, $filename) // $filename if $filename;
        $part = decode($charset, $part) // $part unless $upload;
      }
  
      push @formdata, [$name, $part, $filename];
    }
  
    return \@formdata;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Message - HTTP message base class
  
  =head1 SYNOPSIS
  
    package Mojo::Message::MyMessage;
    use Mojo::Base 'Mojo::Message';
  
    sub cookies              {...}
    sub extract_start_line   {...}
    sub get_start_line_chunk {...}
    sub start_line_size      {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Message> is an abstract base class for HTTP message containers, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230>,
  L<RFC 7231|http://tools.ietf.org/html/rfc7231> and
  L<RFC 2388|http://tools.ietf.org/html/rfc2388>, like L<Mojo::Message::Request>
  and L<Mojo::Message::Response>.
  
  =head1 EVENTS
  
  L<Mojo::Message> inherits all events from L<Mojo::EventEmitter> and can emit
  the following new ones.
  
  =head2 finish
  
    $msg->on(finish => sub {
      my $msg = shift;
      ...
    });
  
  Emitted after message building or parsing is finished.
  
    my $before = time;
    $msg->on(finish => sub {
      my $msg = shift;
      $msg->headers->header('X-Parser-Time' => time - $before);
    });
  
  =head2 progress
  
    $msg->on(progress => sub {
      my $msg = shift;
      ...
    });
  
  Emitted when message building or parsing makes progress.
  
    # Building
    $msg->on(progress => sub {
      my ($msg, $state, $offset) = @_;
      say qq{Building "$state" at offset $offset};
    });
  
    # Parsing
    $msg->on(progress => sub {
      my $msg = shift;
      return unless my $len = $msg->headers->content_length;
      my $size = $msg->content->progress;
      say 'Progress: ', $size == $len ? 100 : int($size / ($len / 100)), '%';
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Message> implements the following attributes.
  
  =head2 content
  
    my $msg = $msg->content;
    $msg    = $msg->content(Mojo::Content::Single->new);
  
  Message content, defaults to a L<Mojo::Content::Single> object.
  
  =head2 default_charset
  
    my $charset = $msg->default_charset;
    $msg        = $msg->default_charset('UTF-8');
  
  Default charset used by L</"text"> and to extract data from
  C<application/x-www-form-urlencoded> or C<multipart/form-data> message body,
  defaults to C<UTF-8>.
  
  =head2 max_line_size
  
    my $size = $msg->max_line_size;
    $msg     = $msg->max_line_size(1024);
  
  Maximum start-line size in bytes, defaults to the value of the
  C<MOJO_MAX_LINE_SIZE> environment variable or C<8192> (8KiB).
  
  =head2 max_message_size
  
    my $size = $msg->max_message_size;
    $msg     = $msg->max_message_size(1024);
  
  Maximum message size in bytes, defaults to the value of the
  C<MOJO_MAX_MESSAGE_SIZE> environment variable or C<16777216> (16MiB). Setting
  the value to C<0> will allow messages of indefinite size.
  
  =head2 version
  
    my $version = $msg->version;
    $msg        = $msg->version('1.1');
  
  HTTP version of message, defaults to C<1.1>.
  
  =head1 METHODS
  
  L<Mojo::Message> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 body
  
    my $bytes = $msg->body;
    $msg      = $msg->body('Hello!');
  
  Slurp or replace L</"content">.
  
  =head2 body_params
  
    my $params = $msg->body_params;
  
  C<POST> parameters extracted from C<application/x-www-form-urlencoded> or
  C<multipart/form-data> message body, usually a L<Mojo::Parameters> object. Note
  that this method caches all data, so it should not be called before the entire
  message body has been received. Parts of the message body need to be loaded
  into memory to parse C<POST> parameters, so you have to make sure it is not
  excessively large. There's a 16MiB limit for requests and a 2GiB limit for
  responses by default.
  
    # Get POST parameter names and values
    my $hash = $msg->body_params->to_hash;
  
  =head2 body_size
  
    my $size = $msg->body_size;
  
  Content size in bytes.
  
  =head2 build_body
  
    my $bytes = $msg->build_body;
  
  Render whole body with L</"get_body_chunk">.
  
  =head2 build_headers
  
    my $bytes = $msg->build_headers;
  
  Render all headers with L</"get_header_chunk">.
  
  =head2 build_start_line
  
    my $bytes = $msg->build_start_line;
  
  Render start-line with L</"get_start_line_chunk">.
  
  =head2 cookie
  
    my $cookie = $msg->cookie('foo');
  
  Access message cookies, usually L<Mojo::Cookie::Request> or
  L<Mojo::Cookie::Response> objects. If there are multiple cookies sharing the
  same name, and you want to access more than just the last one, you can use
  L</"every_cookie">. Note that this method caches all data, so it should not be
  called before all headers have been received.
  
    # Get cookie value
    say $msg->cookie('foo')->value;
  
  =head2 cookies
  
    my $cookies = $msg->cookies;
  
  Access message cookies. Meant to be overloaded in a subclass.
  
  =head2 dom
  
    my $dom        = $msg->dom;
    my $collection = $msg->dom('a[href]');
  
  Retrieve message body from L</"text"> and turn it into a L<Mojo::DOM> object,
  an optional selector can be used to call the method L<Mojo::DOM/"find"> on it
  right away, which then returns a L<Mojo::Collection> object. Note that this
  method caches all data, so it should not be called before the entire message
  body has been received. The whole message body needs to be loaded into memory
  to parse it, so you have to make sure it is not excessively large. There's a
  16MiB limit for requests and a 2GiB limit for responses by default.
  
    # Perform "find" right away
    say $msg->dom('h1, h2, h3')->map('text')->join("\n");
  
    # Use everything else Mojo::DOM has to offer
    say $msg->dom->at('title')->text;
    say $msg->dom->at('body')->children->map('tag')->uniq->join("\n");
  
  =head2 error
  
    my $err = $msg->error;
    $msg    = $msg->error({message => 'Parser error'});
  
  Get or set message error, an C<undef> return value indicates that there is no
  error.
  
    # Connection or parser error
    $msg->error({message => 'Connection refused'});
  
    # 4xx/5xx response
    $msg->error({message => 'Internal Server Error', code => 500});
  
  =head2 every_cookie
  
    my $cookies = $msg->every_cookie('foo');
  
  Similar to L</"cookie">, but returns all message cookies sharing the same name
  as an array reference.
  
    # Get first cookie value
    say $msg->every_cookie('foo')->[0]->value;
  
  =head2 every_upload
  
    my $uploads = $msg->every_upload('foo');
  
  Similar to L</"upload">, but returns all file uploads sharing the same name as
  an array reference.
  
    # Get content of first uploaded file
    say $msg->every_upload('foo')->[0]->asset->slurp;
  
  =head2 extract_start_line
  
    my $bool = $msg->extract_start_line(\$str);
  
  Extract start-line from string. Meant to be overloaded in a subclass.
  
  =head2 finish
  
    $msg = $msg->finish;
  
  Finish message parser/generator.
  
  =head2 fix_headers
  
    $msg = $msg->fix_headers;
  
  Make sure message has all required headers.
  
  =head2 get_body_chunk
  
    my $bytes = $msg->get_body_chunk($offset);
  
  Get a chunk of body data starting from a specific position. Note that it might
  not be possible to get the same chunk twice if content was generated
  dynamically.
  
  =head2 get_header_chunk
  
    my $bytes = $msg->get_header_chunk($offset);
  
  Get a chunk of header data, starting from a specific position. Note that this
  method finalizes the message.
  
  =head2 get_start_line_chunk
  
    my $bytes = $msg->get_start_line_chunk($offset);
  
  Get a chunk of start-line data starting from a specific position. Meant to be
  overloaded in a subclass.
  
  =head2 header_size
  
    my $size = $msg->header_size;
  
  Size of headers in bytes. Note that this method finalizes the message.
  
  =head2 headers
  
    my $headers = $msg->headers;
  
  Message headers, usually a L<Mojo::Headers> object.
  
    # Longer version
    my $headers = $msg->content->headers;
  
  =head2 is_finished
  
    my $bool = $msg->is_finished;
  
  Check if message parser/generator is finished.
  
  =head2 is_limit_exceeded
  
    my $bool = $msg->is_limit_exceeded;
  
  Check if message has exceeded L</"max_line_size">, L</"max_message_size">,
  L<Mojo::Content/"max_buffer_size"> or L<Mojo::Headers/"max_line_size">.
  
  =head2 json
  
    my $value = $msg->json;
    my $value = $msg->json('/foo/bar');
  
  Decode JSON message body directly using L<Mojo::JSON> if possible, an C<undef>
  return value indicates a bare C<null> or that decoding failed. An optional JSON
  Pointer can be used to extract a specific value with L<Mojo::JSON::Pointer>.
  Note that this method caches all data, so it should not be called before the
  entire message body has been received. The whole message body needs to be
  loaded into memory to parse it, so you have to make sure it is not excessively
  large. There's a 16MiB limit for requests and a 2GiB limit for responses by
  default.
  
    # Extract JSON values
    say $msg->json->{foo}{bar}[23];
    say $msg->json('/foo/bar/23');
  
  =head2 parse
  
    $msg = $msg->parse('HTTP/1.1 200 OK...');
  
  Parse message chunk.
  
  =head2 start_line_size
  
    my $size = $msg->start_line_size;
  
  Size of the start-line in bytes. Meant to be overloaded in a subclass.
  
  =head2 text
  
    my $str = $msg->text;
  
  Retrieve L</"body"> and try to decode it with L<Mojo::Content/"charset"> or
  L</"default_charset">.
  
  =head2 to_string
  
    my $str = $msg->to_string;
  
  Render whole message. Note that this method finalizes the message, and that it
  might not be possible to render the same message twice if content was generated
  dynamically.
  
  =head2 upload
  
    my $upload = $msg->upload('foo');
  
  Access C<multipart/form-data> file uploads, usually L<Mojo::Upload> objects. If
  there are multiple uploads sharing the same name, and you want to access more
  than just the last one, you can use L</"every_upload">. Note that this method
  caches all data, so it should not be called before the entire message body has
  been received.
  
    # Get content of uploaded file
    say $msg->upload('foo')->asset->slurp;
  
  =head2 uploads
  
    my $uploads = $msg->uploads;
  
  All C<multipart/form-data> file uploads, usually L<Mojo::Upload> objects.
  
    # Names of all uploads
    say $_->name for @{$msg->uploads};
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_MESSAGE

$fatpacked{"Mojo/Message/Request.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_MESSAGE_REQUEST';
  package Mojo::Message::Request;
  use Mojo::Base 'Mojo::Message';
  
  use Mojo::Cookie::Request;
  use Mojo::Util qw(b64_encode b64_decode sha1_sum);
  use Mojo::URL;
  
  my ($SEED, $COUNTER) = (rand, int rand 0xffffff);
  
  has env => sub { {} };
  has method => 'GET';
  has [qw(proxy reverse_proxy)];
  has request_id => sub {
    substr sha1_sum($SEED . $$ . ($COUNTER = ($COUNTER + 1) % 0xffffff)), 0, 8;
  };
  has url => sub { Mojo::URL->new };
  has via_proxy => 1;
  
  sub clone {
    my $self = shift;
  
    # Dynamic requests cannot be cloned
    return undef unless my $content = $self->content->clone;
    my $clone = $self->new(
      content => $content,
      method  => $self->method,
      url     => $self->url->clone,
      version => $self->version
    );
    $clone->{proxy} = $self->{proxy}->clone if $self->{proxy};
  
    return $clone;
  }
  
  sub cookies {
    my $self = shift;
  
    # Parse cookies
    my $headers = $self->headers;
    return [map { @{Mojo::Cookie::Request->parse($_)} } $headers->cookie]
      unless @_;
  
    # Add cookies
    my @cookies = map { ref $_ eq 'HASH' ? Mojo::Cookie::Request->new($_) : $_ }
      $headers->cookie || (), @_;
    $headers->cookie(join '; ', @cookies);
  
    return $self;
  }
  
  sub every_param { shift->params->every_param(@_) }
  
  sub extract_start_line {
    my ($self, $bufref) = @_;
  
    # Ignore any leading empty lines
    return undef unless $$bufref =~ s/^\s*(.*?)\x0d?\x0a//;
  
    # We have a (hopefully) full request-line
    return !$self->error({message => 'Bad request start-line'})
      unless $1 =~ /^(\S+)\s+(\S+)\s+HTTP\/(\d\.\d)$/;
    my $url    = $self->method($1)->version($3)->url;
    my $target = $2;
    return !!$url->host_port($target) if $1 eq 'CONNECT';
    return !!$url->parse($target)->fragment(undef) if $target =~ /^[^:\/?#]+:/;
    return !!$url->path_query($target);
  }
  
  sub fix_headers {
    my $self = shift;
    $self->{fix} ? return $self : $self->SUPER::fix_headers(@_);
  
    # Host
    my $url     = $self->url;
    my $headers = $self->headers;
    $headers->host($url->host_port) unless $headers->host;
  
    # Basic authentication
    if ((my $info = $url->userinfo) && !$headers->authorization) {
      $headers->authorization('Basic ' . b64_encode($info, ''));
    }
  
    # Basic proxy authentication
    return $self unless (my $proxy = $self->proxy) && $self->via_proxy;
    return $self unless my $info = $proxy->userinfo;
    $headers->proxy_authorization('Basic ' . b64_encode($info, ''))
      unless $headers->proxy_authorization;
    return $self;
  }
  
  sub get_start_line_chunk {
    my ($self, $offset) = @_;
    $self->_start_line->emit(progress => 'start_line', $offset);
    return substr $self->{start_buffer}, $offset, 131072;
  }
  
  sub is_handshake { lc($_[0]->headers->upgrade // '') eq 'websocket' }
  
  sub is_secure {
    my $url = shift->url;
    return ($url->protocol || $url->base->protocol) eq 'https';
  }
  
  sub is_xhr {
    (shift->headers->header('X-Requested-With') // '') =~ /XMLHttpRequest/i;
  }
  
  sub param { shift->params->param(@_) }
  
  sub params {
    my $self = shift;
    return $self->{params}
      ||= $self->body_params->clone->append($self->query_params);
  }
  
  sub parse {
    my $self = shift;
    my ($env, $chunk) = ref $_[0] ? (shift, '') : (undef, shift);
  
    # Parse CGI environment
    $self->env($env)->_parse_env($env) if $env;
  
    # Parse normal message
    if (($self->{state} // '') ne 'cgi') { $self->SUPER::parse($chunk) }
  
    # Parse CGI content
    else { $self->content($self->content->parse_body($chunk))->SUPER::parse('') }
  
    # Check if we can fix things that require all headers
    return $self unless $self->is_finished;
  
    # Base URL
    my $base = $self->url->base;
    $base->scheme('http') unless $base->scheme;
    my $headers = $self->headers;
    if (!$base->host && (my $host = $headers->host)) { $base->host_port($host) }
  
    # Basic authentication
    if (my $basic = _basic($headers->authorization)) { $base->userinfo($basic) }
  
    # Basic proxy authentication
    my $basic = _basic($headers->proxy_authorization);
    $self->proxy(Mojo::URL->new->userinfo($basic)) if $basic;
  
    # "X-Forwarded-Proto"
    $base->scheme('https')
      if $self->reverse_proxy
      && ($headers->header('X-Forwarded-Proto') // '') eq 'https';
  
    return $self;
  }
  
  sub query_params { shift->url->query }
  
  sub start_line_size { length shift->_start_line->{start_buffer} }
  
  sub _basic { $_[0] && $_[0] =~ /Basic (.+)$/ ? b64_decode $1 : undef }
  
  sub _parse_env {
    my ($self, $env) = @_;
  
    # Bypass normal message parser
    $self->{state} = 'cgi';
  
    # Extract headers
    my $headers = $self->headers;
    my $url     = $self->url;
    my $base    = $url->base;
    for my $name (keys %$env) {
      my $value = $env->{$name};
      next unless $name =~ s/^HTTP_//i;
      $name =~ y/_/-/;
      $headers->header($name => $value);
  
      # Host/Port
      $value =~ s/:(\d+)$// ? $base->host($value)->port($1) : $base->host($value)
        if $name eq 'HOST';
    }
  
    # Content-Type is a special case on some servers
    $headers->content_type($env->{CONTENT_TYPE}) if $env->{CONTENT_TYPE};
  
    # Content-Length is a special case on some servers
    $headers->content_length($env->{CONTENT_LENGTH}) if $env->{CONTENT_LENGTH};
  
    # Query
    $url->query->parse($env->{QUERY_STRING}) if $env->{QUERY_STRING};
  
    # Method
    $self->method($env->{REQUEST_METHOD}) if $env->{REQUEST_METHOD};
  
    # Scheme/Version
    $base->scheme($1) and $self->version($2)
      if ($env->{SERVER_PROTOCOL} // '') =~ m!^([^/]+)/([^/]+)$!;
  
    # HTTPS
    $base->scheme('https') if uc($env->{HTTPS} // '') eq 'ON';
  
    # Path
    my $path = $url->path->parse($env->{PATH_INFO} ? $env->{PATH_INFO} : '');
  
    # Base path
    if (my $value = $env->{SCRIPT_NAME}) {
  
      # Make sure there is a trailing slash (important for merging)
      $base->path->parse($value =~ m!/$! ? $value : "$value/");
  
      # Remove SCRIPT_NAME prefix if necessary
      my $buffer = $path->to_string;
      $value =~ s!^/|/$!!g;
      $buffer =~ s!^/?\Q$value\E/?!!;
      $buffer =~ s!^/!!;
      $path->parse($buffer);
    }
  }
  
  sub _start_line {
    my $self = shift;
  
    return $self if defined $self->{start_buffer};
  
    # Path
    my $url  = $self->url;
    my $path = $url->path_query;
    $path = "/$path" unless $path =~ m!^/!;
  
    # CONNECT
    my $method = uc $self->method;
    if ($method eq 'CONNECT') {
      my $port = $url->port // ($url->protocol eq 'https' ? '443' : '80');
      $path = $url->ihost . ":$port";
    }
  
    # Proxy
    elsif ($self->proxy && $self->via_proxy && $url->protocol ne 'https') {
      $path = $url->clone->userinfo(undef) unless $self->is_handshake;
    }
  
    $self->{start_buffer} = "$method $path HTTP/@{[$self->version]}\x0d\x0a";
  
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Message::Request - HTTP request
  
  =head1 SYNOPSIS
  
    use Mojo::Message::Request;
  
    # Parse
    my $req = Mojo::Message::Request->new;
    $req->parse("GET /foo HTTP/1.0\x0d\x0a");
    $req->parse("Content-Length: 12\x0d\x0a");
    $req->parse("Content-Type: text/plain\x0d\x0a\x0d\x0a");
    $req->parse('Hello World!');
    say $req->method;
    say $req->headers->content_type;
    say $req->body;
  
    # Build
    my $req = Mojo::Message::Request->new;
    $req->url->parse('http://127.0.0.1/foo/bar');
    $req->method('GET');
    say $req->to_string;
  
  =head1 DESCRIPTION
  
  L<Mojo::Message::Request> is a container for HTTP requests, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230>,
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>,
  L<RFC 7235|http://tools.ietf.org/html/rfc7235> and
  L<RFC 2817|http://tools.ietf.org/html/rfc2817>.
  
  =head1 EVENTS
  
  L<Mojo::Message::Request> inherits all events from L<Mojo::Message>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Message::Request> inherits all attributes from L<Mojo::Message> and
  implements the following new ones.
  
  =head2 env
  
    my $env = $req->env;
    $req    = $req->env({PATH_INFO => '/'});
  
  Direct access to the C<CGI> or C<PSGI> environment hash if available.
  
    # Check CGI version
    my $version = $req->env->{GATEWAY_INTERFACE};
  
    # Check PSGI version
    my $version = $req->env->{'psgi.version'};
  
  =head2 method
  
    my $method = $req->method;
    $req       = $req->method('POST');
  
  HTTP request method, defaults to C<GET>.
  
  =head2 proxy
  
    my $url = $req->proxy;
    $req    = $req->proxy(Mojo::URL->new('http://127.0.0.1:3000'));
  
  Proxy URL for request.
  
  =head2 reverse_proxy
  
    my $bool = $req->reverse_proxy;
    $req     = $req->reverse_proxy($bool);
  
  Request has been performed through a reverse proxy.
  
  =head2 request_id
  
    my $id = $req->request_id;
    $req   = $req->request_id('aee7d5d8');
  
  Request ID, defaults to a reasonably unique value.
  
  =head2 url
  
    my $url = $req->url;
    $req    = $req->url(Mojo::URL->new);
  
  HTTP request URL, defaults to a L<Mojo::URL> object.
  
    # Get request information
    my $info = $req->url->to_abs->userinfo;
    my $host = $req->url->to_abs->host;
    my $path = $req->url->to_abs->path;
  
  =head2 via_proxy
  
    my $bool = $req->via_proxy;
    $req     = $req->via_proxy($bool);
  
  Request can be performed through a proxy server.
  
  =head1 METHODS
  
  L<Mojo::Message::Request> inherits all methods from L<Mojo::Message> and
  implements the following new ones.
  
  =head2 clone
  
    my $clone = $req->clone;
  
  Return a new L<Mojo::Message::Request> object cloned from this request if
  possible, otherwise return C<undef>.
  
  =head2 cookies
  
    my $cookies = $req->cookies;
    $req        = $req->cookies(Mojo::Cookie::Request->new);
    $req        = $req->cookies({name => 'foo', value => 'bar'});
  
  Access request cookies, usually L<Mojo::Cookie::Request> objects.
  
    # Names of all cookies
    say $_->name for @{$req->cookies};
  
  =head2 every_param
  
    my $values = $req->every_param('foo');
  
  Similar to L</"param">, but returns all values sharing the same name as an
  array reference.
  
    # Get first value
    say $req->every_param('foo')->[0];
  
  =head2 extract_start_line
  
    my $bool = $req->extract_start_line(\$str);
  
  Extract request-line from string.
  
  =head2 fix_headers
  
    $req = $req->fix_headers;
  
  Make sure request has all required headers.
  
  =head2 get_start_line_chunk
  
    my $bytes = $req->get_start_line_chunk($offset);
  
  Get a chunk of request-line data starting from a specific position. Note that
  this method finalizes the request.
  
  =head2 is_handshake
  
    my $bool = $req->is_handshake;
  
  Check C<Upgrade> header for C<websocket> value.
  
  =head2 is_secure
  
    my $bool = $req->is_secure;
  
  Check if connection is secure.
  
  =head2 is_xhr
  
    my $bool = $req->is_xhr;
  
  Check C<X-Requested-With> header for C<XMLHttpRequest> value.
  
  =head2 param
  
    my $value = $req->param('foo');
  
  Access C<GET> and C<POST> parameters extracted from the query string and
  C<application/x-www-form-urlencoded> or C<multipart/form-data> message body. If
  there are multiple values sharing the same name, and you want to access more
  than just the last one, you can use L</"every_param">. Note that this method
  caches all data, so it should not be called before the entire request body has
  been received. Parts of the request body need to be loaded into memory to parse
  C<POST> parameters, so you have to make sure it is not excessively large.
  There's a 16MiB limit for requests by default.
  
  =head2 params
  
    my $params = $req->params;
  
  All C<GET> and C<POST> parameters extracted from the query string and
  C<application/x-www-form-urlencoded> or C<multipart/form-data> message body,
  usually a L<Mojo::Parameters> object. Note that this method caches all data, so
  it should not be called before the entire request body has been received. Parts
  of the request body need to be loaded into memory to parse C<POST> parameters,
  so you have to make sure it is not excessively large. There's a 16MiB limit for
  requests by default.
  
    # Get parameter names and values
    my $hash = $req->params->to_hash;
  
  =head2 parse
  
    $req = $req->parse('GET /foo/bar HTTP/1.1');
    $req = $req->parse({PATH_INFO => '/'});
  
  Parse HTTP request chunks or environment hash.
  
  =head2 query_params
  
    my $params = $req->query_params;
  
  All C<GET> parameters, usually a L<Mojo::Parameters> object.
  
    # Turn GET parameters to hash and extract value
    say $req->query_params->to_hash->{foo};
  
  =head2 start_line_size
  
    my $size = $req->start_line_size;
  
  Size of the request-line in bytes. Note that this method finalizes the request.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_MESSAGE_REQUEST

$fatpacked{"Mojo/Message/Response.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_MESSAGE_RESPONSE';
  package Mojo::Message::Response;
  use Mojo::Base 'Mojo::Message';
  
  use Mojo::Cookie::Response;
  use Mojo::Date;
  
  has [qw(code message)];
  has max_message_size => sub { $ENV{MOJO_MAX_MESSAGE_SIZE} // 2147483648 };
  
  # Umarked codes are from RFC 7231
  my %MESSAGES = (
    100 => 'Continue',
    101 => 'Switching Protocols',
    102 => 'Processing',                         # RFC 2518 (WebDAV)
    103 => 'Early Hints',                        # RFC 8297
    200 => 'OK',
    201 => 'Created',
    202 => 'Accepted',
    203 => 'Non-Authoritative Information',
    204 => 'No Content',
    205 => 'Reset Content',
    206 => 'Partial Content',
    207 => 'Multi-Status',                       # RFC 2518 (WebDAV)
    208 => 'Already Reported',                   # RFC 5842
    226 => 'IM Used',                            # RFC 3229
    300 => 'Multiple Choices',
    301 => 'Moved Permanently',
    302 => 'Found',
    303 => 'See Other',
    304 => 'Not Modified',
    305 => 'Use Proxy',
    307 => 'Temporary Redirect',
    308 => 'Permanent Redirect',                 # RFC 7538
    400 => 'Bad Request',
    401 => 'Unauthorized',
    402 => 'Payment Required',
    403 => 'Forbidden',
    404 => 'Not Found',
    405 => 'Method Not Allowed',
    406 => 'Not Acceptable',
    407 => 'Proxy Authentication Required',
    408 => 'Request Timeout',
    409 => 'Conflict',
    410 => 'Gone',
    411 => 'Length Required',
    412 => 'Precondition Failed',
    413 => 'Request Entity Too Large',
    414 => 'Request-URI Too Long',
    415 => 'Unsupported Media Type',
    416 => 'Request Range Not Satisfiable',
    417 => 'Expectation Failed',
    418 => "I'm a teapot",                       # RFC 2324 :)
    421 => 'Misdirected Request',                # RFC 7540
    422 => 'Unprocessable Entity',               # RFC 2518 (WebDAV)
    423 => 'Locked',                             # RFC 2518 (WebDAV)
    424 => 'Failed Dependency',                  # RFC 2518 (WebDAV)
    425 => 'Unordered Colection',                # RFC 3648 (WebDAV)
    426 => 'Upgrade Required',                   # RFC 2817
    428 => 'Precondition Required',              # RFC 6585
    429 => 'Too Many Requests',                  # RFC 6585
    431 => 'Request Header Fields Too Large',    # RFC 6585
    451 => 'Unavailable For Legal Reasons',      # RFC 7725
    500 => 'Internal Server Error',
    501 => 'Not Implemented',
    502 => 'Bad Gateway',
    503 => 'Service Unavailable',
    504 => 'Gateway Timeout',
    505 => 'HTTP Version Not Supported',
    506 => 'Variant Also Negotiates',            # RFC 2295
    507 => 'Insufficient Storage',               # RFC 2518 (WebDAV)
    508 => 'Loop Detected',                      # RFC 5842
    509 => 'Bandwidth Limit Exceeded',           # Unofficial
    510 => 'Not Extended',                       # RFC 2774
    511 => 'Network Authentication Required'     # RFC 6585
  );
  
  sub cookies {
    my $self = shift;
  
    # Parse cookies
    my $headers = $self->headers;
    return [@{Mojo::Cookie::Response->parse($headers->set_cookie)}] unless @_;
  
    # Add cookies
    $headers->add('Set-Cookie' => "$_")
      for map { ref $_ eq 'HASH' ? Mojo::Cookie::Response->new($_) : $_ } @_;
  
    return $self;
  }
  
  sub default_message { $MESSAGES{$_[1] || $_[0]->code // 404} || '' }
  
  sub extract_start_line {
    my ($self, $bufref) = @_;
  
    # We have a full response line
    return undef unless $$bufref =~ s/^(.*?)\x0d?\x0a//;
    return !$self->error({message => 'Bad response start-line'})
      unless $1 =~ m!^\s*HTTP/(\d\.\d)\s+(\d\d\d)\s*(.+)?$!;
  
    my $content = $self->content;
    $content->skip_body(1) if $self->code($2)->is_empty;
    defined $content->$_ or $content->$_(1) for qw(auto_decompress auto_relax);
    $content->expect_close(1) if $1 eq '1.0';
    return !!$self->version($1)->message($3);
  }
  
  sub fix_headers {
    my $self = shift;
    $self->{fix} ? return $self : $self->SUPER::fix_headers(@_);
  
    # Date
    my $headers = $self->headers;
    $headers->date(Mojo::Date->new->to_string) unless $headers->date;
  
    # RFC 7230 3.3.2
    $headers->remove('Content-Length') if $self->is_empty;
  
    return $self;
  }
  
  sub get_start_line_chunk {
    my ($self, $offset) = @_;
    $self->_start_line->emit(progress => 'start_line', $offset);
    return substr $self->{start_buffer}, $offset, 131072;
  }
  
  sub is_client_error { shift->_status_class(400) }
  
  sub is_empty {
    my $self = shift;
    return undef unless my $code = $self->code;
    return $self->is_info || $code == 204 || $code == 304;
  }
  
  sub is_error { shift->_status_class(400, 500) }
  sub is_info { shift->_status_class(100) }
  sub is_redirect     { shift->_status_class(300) }
  sub is_server_error { shift->_status_class(500) }
  
  sub is_success { shift->_status_class(200) }
  
  sub start_line_size { length shift->_start_line->{start_buffer} }
  
  sub _start_line {
    my $self = shift;
  
    return $self if defined $self->{start_buffer};
    my $code = $self->code    || 404;
    my $msg  = $self->message || $self->default_message;
    $self->{start_buffer} = "HTTP/@{[$self->version]} $code $msg\x0d\x0a";
  
    return $self;
  }
  
  sub _status_class {
    my ($self, @classes) = @_;
    return undef unless my $code = $self->code;
    return !!grep { $code >= $_ && $code < ($_ + 100) } @classes;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Message::Response - HTTP response
  
  =head1 SYNOPSIS
  
    use Mojo::Message::Response;
  
    # Parse
    my $res = Mojo::Message::Response->new;
    $res->parse("HTTP/1.0 200 OK\x0d\x0a");
    $res->parse("Content-Length: 12\x0d\x0a");
    $res->parse("Content-Type: text/plain\x0d\x0a\x0d\x0a");
    $res->parse('Hello World!');
    say $res->code;
    say $res->headers->content_type;
    say $res->body;
  
    # Build
    my $res = Mojo::Message::Response->new;
    $res->code(200);
    $res->headers->content_type('text/plain');
    $res->body('Hello World!');
    say $res->to_string;
  
  =head1 DESCRIPTION
  
  L<Mojo::Message::Response> is a container for HTTP responses, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230> and
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>.
  
  =head1 EVENTS
  
  L<Mojo::Message::Response> inherits all events from L<Mojo::Message>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Message::Response> inherits all attributes from L<Mojo::Message> and
  implements the following new ones.
  
  =head2 code
  
    my $code = $res->code;
    $res     = $res->code(200);
  
  HTTP response status code.
  
  =head2 max_message_size
  
    my $size = $res->max_message_size;
    $res     = $res->max_message_size(1024);
  
  Maximum message size in bytes, defaults to the value of the
  C<MOJO_MAX_MESSAGE_SIZE> environment variable or C<2147483648> (2GiB). Setting
  the value to C<0> will allow messages of indefinite size.
  
  =head2 message
  
    my $msg = $res->message;
    $res    = $res->message('OK');
  
  HTTP response status message.
  
  =head1 METHODS
  
  L<Mojo::Message::Response> inherits all methods from L<Mojo::Message> and
  implements the following new ones.
  
  =head2 cookies
  
    my $cookies = $res->cookies;
    $res        = $res->cookies(Mojo::Cookie::Response->new);
    $res        = $res->cookies({name => 'foo', value => 'bar'});
  
  Access response cookies, usually L<Mojo::Cookie::Response> objects.
  
    # Names of all cookies
    say $_->name for @{$res->cookies};
  
  =head2 default_message
  
    my $msg = $res->default_message;
    my $msg = $res->default_message(418);
  
  Generate default response message for status code, defaults to using
  L</"code">.
  
  =head2 extract_start_line
  
    my $bool = $res->extract_start_line(\$str);
  
  Extract status-line from string.
  
  =head2 fix_headers
  
    $res = $res->fix_headers;
  
  Make sure response has all required headers.
  
  =head2 get_start_line_chunk
  
    my $bytes = $res->get_start_line_chunk($offset);
  
  Get a chunk of status-line data starting from a specific position. Note that
  this method finalizes the response.
  
  =head2 is_client_error
  
    my $bool = $res->is_client_error;
  
  Check if this response has a C<4xx> status L</"code">.
  
  =head2 is_empty
  
    my $bool = $res->is_empty;
  
  Check if this response has a C<1xx>, C<204> or C<304> status L</"code">.
  
  =head2 is_error
  
    my $bool = $res->is_error;
  
  Check if this response has a C<4xx> or C<5xx> status L</"code">.
  
  =head2 is_info
  
    my $bool = $res->is_info;
  
  Check if this response has a C<1xx> status L</"code">.
  
  =head2 is_redirect
  
    my $bool = $res->is_redirect;
  
  Check if this response has a C<3xx> status L</"code">.
  
  =head2 is_server_error
  
    my $bool = $res->is_server_error;
  
  Check if this response has a C<5xx> status L</"code">.
  
  =head2 is_success
  
    my $bool = $res->is_success;
  
  Check if this response has a C<2xx> status L</"code">.
  
  =head2 start_line_size
  
    my $size = $req->start_line_size;
  
  Size of the status-line in bytes. Note that this method finalizes the response.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_MESSAGE_RESPONSE

$fatpacked{"Mojo/Parameters.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_PARAMETERS';
  package Mojo::Parameters;
  use Mojo::Base -base;
  use overload
    '@{}'    => sub { shift->pairs },
    bool     => sub {1},
    '""'     => sub { shift->to_string },
    fallback => 1;
  
  use Mojo::Util qw(decode encode url_escape url_unescape);
  
  has charset => 'UTF-8';
  
  sub append {
    my $self = shift;
  
    my $old = $self->pairs;
    my @new = @_ == 1 ? @{shift->pairs} : @_;
    while (my ($name, $value) = splice @new, 0, 2) {
  
      # Multiple values
      if (ref $value eq 'ARRAY') { push @$old, $name => $_ // '' for @$value }
  
      # Single value
      elsif (defined $value) { push @$old, $name => $value }
    }
  
    return $self;
  }
  
  sub clone {
    my $self = shift;
  
    my $clone = $self->new;
    if   (exists $self->{charset}) { $clone->{charset} = $self->{charset} }
    if   (defined $self->{string}) { $clone->{string}  = $self->{string} }
    else                           { $clone->{pairs}   = [@{$self->pairs}] }
  
    return $clone;
  }
  
  sub every_param {
    my ($self, $name) = @_;
  
    my @values;
    my $pairs = $self->pairs;
    for (my $i = 0; $i < @$pairs; $i += 2) {
      push @values, $pairs->[$i + 1] if $pairs->[$i] eq $name;
    }
  
    return \@values;
  }
  
  sub merge {
    my $self = shift;
  
    my @pairs = @_ == 1 ? @{shift->pairs} : @_;
    while (my ($name, $value) = splice @pairs, 0, 2) {
      defined $value ? $self->param($name => $value) : $self->remove($name);
    }
  
    return $self;
  }
  
  sub names { [sort keys %{shift->to_hash}] }
  
  sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }
  
  sub pairs {
    my $self = shift;
  
    # Replace parameters
    if (@_) {
      $self->{pairs} = shift;
      delete $self->{string};
      return $self;
    }
  
    # Parse string
    if (defined(my $str = delete $self->{string})) {
      my $pairs = $self->{pairs} = [];
      return $pairs unless length $str;
  
      my $charset = $self->charset;
      for my $pair (split '&', $str) {
        next unless $pair =~ /^([^=]+)(?:=(.*))?$/;
        my ($name, $value) = ($1, $2 // '');
  
        # Replace "+" with whitespace, unescape and decode
        s/\+/ /g for $name, $value;
        $name  = url_unescape $name;
        $name  = decode($charset, $name) // $name if $charset;
        $value = url_unescape $value;
        $value = decode($charset, $value) // $value if $charset;
  
        push @$pairs, $name, $value;
      }
    }
  
    return $self->{pairs} ||= [];
  }
  
  sub param {
    my ($self, $name) = (shift, shift);
    return $self->every_param($name)->[-1] unless @_;
    $self->remove($name);
    return $self->append($name => ref $_[0] eq 'ARRAY' ? $_[0] : [@_]);
  }
  
  sub parse {
    my $self = shift;
  
    # Pairs
    return $self->append(@_) if @_ > 1;
  
    # String
    $self->{string} = shift;
    return $self;
  }
  
  sub remove {
    my ($self, $name) = @_;
    my $pairs = $self->pairs;
    my $i     = 0;
    $pairs->[$i] eq $name ? splice @$pairs, $i, 2 : ($i += 2) while $i < @$pairs;
    return $self;
  }
  
  sub to_hash {
    my $self = shift;
  
    my %hash;
    my $pairs = $self->pairs;
    for (my $i = 0; $i < @$pairs; $i += 2) {
      my ($name, $value) = @{$pairs}[$i, $i + 1];
  
      # Array
      if (exists $hash{$name}) {
        $hash{$name} = [$hash{$name}] if ref $hash{$name} ne 'ARRAY';
        push @{$hash{$name}}, $value;
      }
  
      # String
      else { $hash{$name} = $value }
    }
  
    return \%hash;
  }
  
  sub to_string {
    my $self = shift;
  
    # String (RFC 3986)
    my $charset = $self->charset;
    if (defined(my $str = $self->{string})) {
      $str = encode $charset, $str if $charset;
      return url_escape $str, '^A-Za-z0-9\-._~%!$&\'()*+,;=:@/?';
    }
  
    # Build pairs (HTML Living Standard)
    my $pairs = $self->pairs;
    return '' unless @$pairs;
    my @pairs;
    for (my $i = 0; $i < @$pairs; $i += 2) {
      my ($name, $value) = @{$pairs}[$i, $i + 1];
  
      # Escape and replace whitespace with "+"
      $name  = encode $charset,   $name if $charset;
      $name  = url_escape $name,  '^*\-.0-9A-Z_a-z';
      $value = encode $charset,   $value if $charset;
      $value = url_escape $value, '^*\-.0-9A-Z_a-z';
      s/\%20/\+/g for $name, $value;
  
      push @pairs, "$name=$value";
    }
  
    return join '&', @pairs;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Parameters - Parameters
  
  =head1 SYNOPSIS
  
    use Mojo::Parameters;
  
    # Parse
    my $params = Mojo::Parameters->new('foo=bar&baz=23');
    say $params->param('baz');
  
    # Build
    my $params = Mojo::Parameters->new(foo => 'bar', baz => 23);
    push @$params, i => ' mojolicious';
    say "$params";
  
  =head1 DESCRIPTION
  
  L<Mojo::Parameters> is a container for form parameters used by L<Mojo::URL>,
  based on L<RFC 3986|http://tools.ietf.org/html/rfc3986> and the
  L<HTML Living Standard|https://html.spec.whatwg.org>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Parameters> implements the following attributes.
  
  =head2 charset
  
    my $charset = $params->charset;
    $params     = $params->charset('UTF-8');
  
  Charset used for encoding and decoding parameters, defaults to C<UTF-8>.
  
    # Disable encoding and decoding
    $params->charset(undef);
  
  =head1 METHODS
  
  L<Mojo::Parameters> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 append
  
    $params = $params->append(foo => 'ba&r');
    $params = $params->append(foo => ['ba&r', 'baz']);
    $params = $params->append(foo => ['bar', 'baz'], bar => 23);
    $params = $params->append(Mojo::Parameters->new);
  
  Append parameters. Note that this method will normalize the parameters.
  
    # "foo=bar&foo=baz"
    Mojo::Parameters->new('foo=bar')->append(Mojo::Parameters->new('foo=baz'));
  
    # "foo=bar&foo=baz"
    Mojo::Parameters->new('foo=bar')->append(foo => 'baz');
  
    # "foo=bar&foo=baz&foo=yada"
    Mojo::Parameters->new('foo=bar')->append(foo => ['baz', 'yada']);
  
    # "foo=bar&foo=baz&foo=yada&bar=23"
    Mojo::Parameters->new('foo=bar')->append(foo => ['baz', 'yada'], bar => 23);
  
  =head2 clone
  
    my $params2 = $params->clone;
  
  Return a new L<Mojo::Parameters> object cloned from these parameters.
  
  =head2 every_param
  
    my $values = $params->every_param('foo');
  
  Similar to L</"param">, but returns all values sharing the same name as an
  array reference. Note that this method will normalize the parameters.
  
    # Get first value
    say $params->every_param('foo')->[0];
  
  =head2 merge
  
    $params = $params->merge(foo => 'ba&r');
    $params = $params->merge(foo => ['ba&r', 'baz']);
    $params = $params->merge(foo => ['bar', 'baz'], bar => 23);
    $params = $params->merge(Mojo::Parameters->new);
  
  Merge parameters. Note that this method will normalize the parameters.
  
    # "foo=baz"
    Mojo::Parameters->new('foo=bar')->merge(Mojo::Parameters->new('foo=baz'));
  
    # "yada=yada&foo=baz"
    Mojo::Parameters->new('foo=bar&yada=yada')->merge(foo => 'baz');
  
    # "yada=yada"
    Mojo::Parameters->new('foo=bar&yada=yada')->merge(foo => undef);
  
  =head2 names
  
    my $names = $params->names;
  
  Return an array reference with all parameter names.
  
    # Names of all parameters
    say for @{$params->names};
  
  =head2 new
  
    my $params = Mojo::Parameters->new;
    my $params = Mojo::Parameters->new('foo=b%3Bar&baz=23');
    my $params = Mojo::Parameters->new(foo => 'b&ar');
    my $params = Mojo::Parameters->new(foo => ['ba&r', 'baz']);
    my $params = Mojo::Parameters->new(foo => ['bar', 'baz'], bar => 23);
  
  Construct a new L<Mojo::Parameters> object and L</"parse"> parameters if
  necessary.
  
  =head2 pairs
  
    my $array = $params->pairs;
    $params   = $params->pairs([foo => 'b&ar', baz => 23]);
  
  Parsed parameter pairs. Note that this method will normalize the parameters.
  
    # Remove all parameters
    $params->pairs([]);
  
  =head2 param
  
    my $value = $params->param('foo');
    $params   = $params->param(foo => 'ba&r');
    $params   = $params->param(foo => qw(ba&r baz));
    $params   = $params->param(foo => ['ba;r', 'baz']);
  
  Access parameter values. If there are multiple values sharing the same name,
  and you want to access more than just the last one, you can use
  L</"every_param">. Note that this method will normalize the parameters.
  
  =head2 parse
  
    $params = $params->parse('foo=b%3Bar&baz=23');
  
  Parse parameters.
  
  =head2 remove
  
    $params = $params->remove('foo');
  
  Remove parameters. Note that this method will normalize the parameters.
  
    # "bar=yada"
    Mojo::Parameters->new('foo=bar&foo=baz&bar=yada')->remove('foo');
  
  =head2 to_hash
  
    my $hash = $params->to_hash;
  
  Turn parameters into a hash reference. Note that this method will normalize the
  parameters.
  
    # "baz"
    Mojo::Parameters->new('foo=bar&foo=baz')->to_hash->{foo}[1];
  
  =head2 to_string
  
    my $str = $params->to_string;
  
  Turn parameters into a string.
  
    # "foo=bar&baz=23"
    Mojo::Parameters->new->pairs([foo => 'bar', baz => 23])->to_string;
  
  =head1 OPERATORS
  
  L<Mojo::Parameters> overloads the following operators.
  
  =head2 array
  
    my @pairs = @$params;
  
  Alias for L</"pairs">. Note that this will normalize the parameters.
  
    say $params->[0];
    say for @$params;
  
  =head2 bool
  
    my $bool = !!$params;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$params";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_PARAMETERS

$fatpacked{"Mojo/Path.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_PATH';
  package Mojo::Path;
  use Mojo::Base -base;
  use overload
    '@{}'    => sub { shift->parts },
    bool     => sub {1},
    '""'     => sub { shift->to_string },
    fallback => 1;
  
  use Mojo::Util qw(decode encode url_escape url_unescape);
  
  has charset => 'UTF-8';
  
  sub canonicalize {
    my $self = shift;
  
    my $parts = $self->parts;
    for (my $i = 0; $i <= $#$parts;) {
      if (!length $parts->[$i] || $parts->[$i] eq '.' || $parts->[$i] eq '...') {
        splice @$parts, $i, 1;
      }
      elsif ($i < 1 || $parts->[$i] ne '..' || $parts->[$i - 1] eq '..') { $i++ }
      else { splice @$parts, --$i, 2 }
    }
  
    return @$parts ? $self : $self->trailing_slash(undef);
  }
  
  sub clone {
    my $self = shift;
  
    my $clone = $self->new;
    if (exists $self->{charset}) { $clone->{charset} = $self->{charset} }
    if (my $parts = $self->{parts}) {
      $clone->{$_} = $self->{$_} for qw(leading_slash trailing_slash);
      $clone->{parts} = [@$parts];
    }
    else { $clone->{path} = $self->{path} }
  
    return $clone;
  }
  
  sub contains { $_[1] eq '/' || $_[0]->to_route =~ m!^\Q$_[1]\E(?:/|$)! }
  
  sub leading_slash { shift->_parse(leading_slash => @_) }
  
  sub merge {
    my ($self, $path) = @_;
  
    # Replace
    return $self->parse($path) if $path =~ m!^/!;
  
    # Merge
    pop @{$self->parts} unless $self->trailing_slash;
    $path = $self->new($path);
    push @{$self->parts}, @{$path->parts};
    return $self->trailing_slash($path->trailing_slash);
  }
  
  sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }
  
  sub parse {
    my $self = shift;
    $self->{path} = shift;
    delete @$self{qw(leading_slash parts trailing_slash)};
    return $self;
  }
  
  sub parts { shift->_parse(parts => @_) }
  
  sub to_abs_string {
    my $path = shift->to_string;
    return $path =~ m!^/! ? $path : "/$path";
  }
  
  sub to_dir {
    my $clone = shift->clone;
    pop @{$clone->parts} unless $clone->trailing_slash;
    return $clone->trailing_slash(!!@{$clone->parts});
  }
  
  sub to_route {
    my $clone = shift->clone;
    return '/' . join '/', @{$clone->parts}, $clone->trailing_slash ? '' : ();
  }
  
  sub to_string {
    my $self = shift;
  
    # Path
    my $charset = $self->charset;
    if (defined(my $path = $self->{path})) {
      $path = encode $charset, $path if $charset;
      return url_escape $path, '^A-Za-z0-9\-._~!$&\'()*+,;=%:@/';
    }
  
    # Build path
    my @parts = @{$self->parts};
    @parts = map { encode $charset, $_ } @parts if $charset;
    my $path = join '/',
      map { url_escape $_, '^A-Za-z0-9\-._~!$&\'()*+,;=:@' } @parts;
    $path = "/$path" if $self->leading_slash;
    $path = "$path/" if $self->trailing_slash;
    return $path;
  }
  
  sub trailing_slash { shift->_parse(trailing_slash => @_) }
  
  sub _parse {
    my ($self, $name) = (shift, shift);
  
    unless ($self->{parts}) {
      my $path    = url_unescape delete($self->{path}) // '';
      my $charset = $self->charset;
      $path = decode($charset, $path) // $path if $charset;
      $self->{leading_slash}  = $path =~ s!^/!!;
      $self->{trailing_slash} = $path =~ s!/$!!;
      $self->{parts}          = [split '/', $path, -1];
    }
  
    return $self->{$name} unless @_;
    $self->{$name} = shift;
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Path - Path
  
  =head1 SYNOPSIS
  
    use Mojo::Path;
  
    # Parse
    my $path = Mojo::Path->new('/foo%2Fbar%3B/baz.html');
    say $path->[0];
  
    # Build
    my $path = Mojo::Path->new('/i/');
    push @$path, 'mojolicious';
    say "$path";
  
  =head1 DESCRIPTION
  
  L<Mojo::Path> is a container for paths used by L<Mojo::URL>, based on
  L<RFC 3986|http://tools.ietf.org/html/rfc3986>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Path> implements the following attributes.
  
  =head2 charset
  
    my $charset = $path->charset;
    $path       = $path->charset('UTF-8');
  
  Charset used for encoding and decoding, defaults to C<UTF-8>.
  
    # Disable encoding and decoding
    $path->charset(undef);
  
  =head1 METHODS
  
  L<Mojo::Path> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 canonicalize
  
    $path = $path->canonicalize;
  
  Canonicalize path by resolving C<.> and C<..>, in addition C<...> will be
  treated as C<.> to protect from path traversal attacks.
  
    # "/foo/baz"
    Mojo::Path->new('/foo/./bar/../baz')->canonicalize;
  
    # "/../baz"
    Mojo::Path->new('/foo/../bar/../../baz')->canonicalize;
  
    # "/foo/bar"
    Mojo::Path->new('/foo/.../bar')->canonicalize;
  
  =head2 clone
  
    my $clone = $path->clone;
  
  Return a new L<Mojo::Path> object cloned from this path.
  
  =head2 contains
  
    my $bool = $path->contains('/i//mojolicious');
  
  Check if path contains given prefix.
  
    # True
    Mojo::Path->new('/foo/bar')->contains('/');
    Mojo::Path->new('/foo/bar')->contains('/foo');
    Mojo::Path->new('/foo/bar')->contains('/foo/bar');
  
    # False
    Mojo::Path->new('/foo/bar')->contains('/f');
    Mojo::Path->new('/foo/bar')->contains('/bar');
    Mojo::Path->new('/foo/bar')->contains('/whatever');
  
  =head2 leading_slash
  
    my $bool = $path->leading_slash;
    $path    = $path->leading_slash($bool);
  
  Path has a leading slash. Note that this method will normalize the path and
  that C<%2F> will be treated as C</> for security reasons.
  
    # "/foo/bar"
    Mojo::Path->new('foo/bar')->leading_slash(1);
  
    # "foo/bar"
    Mojo::Path->new('/foo/bar')->leading_slash(0);
  
  =head2 merge
  
    $path = $path->merge('/foo/bar');
    $path = $path->merge('foo/bar');
    $path = $path->merge(Mojo::Path->new);
  
  Merge paths. Note that this method will normalize both paths if necessary and
  that C<%2F> will be treated as C</> for security reasons.
  
    # "/baz/yada"
    Mojo::Path->new('/foo/bar')->merge('/baz/yada');
  
    # "/foo/baz/yada"
    Mojo::Path->new('/foo/bar')->merge('baz/yada');
  
    # "/foo/bar/baz/yada"
    Mojo::Path->new('/foo/bar/')->merge('baz/yada');
  
  =head2 new
  
    my $path = Mojo::Path->new;
    my $path = Mojo::Path->new('/foo%2Fbar%3B/baz.html');
  
  Construct a new L<Mojo::Path> object and L</"parse"> path if necessary.
  
  =head2 parse
  
    $path = $path->parse('/foo%2Fbar%3B/baz.html');
  
  Parse path.
  
  =head2 to_abs_string
  
    my $str = $path->to_abs_string;
  
  Turn path into an absolute string.
  
    # "/i/%E2%99%A5/mojolicious"
    Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_abs_string;
    Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_abs_string;
  
  =head2 parts
  
    my $parts = $path->parts;
    $path     = $path->parts([qw(foo bar baz)]);
  
  The path parts. Note that this method will normalize the path and that C<%2F>
  will be treated as C</> for security reasons.
  
    # Part with slash
    push @{$path->parts}, 'foo/bar';
  
  =head2 to_dir
  
    my $dir = $route->to_dir;
  
  Clone path and remove everything after the right-most slash.
  
    # "/i/%E2%99%A5/"
    Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_dir->to_abs_string;
  
    # "i/%E2%99%A5/"
    Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_dir->to_abs_string;
  
  =head2 to_route
  
    my $route = $path->to_route;
  
  Turn path into a route.
  
    # "/i//mojolicious"
    Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_route;
    Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_route;
  
  =head2 to_string
  
    my $str = $path->to_string;
  
  Turn path into a string.
  
    # "/i/%E2%99%A5/mojolicious"
    Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_string;
  
    # "i/%E2%99%A5/mojolicious"
    Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_string;
  
  =head2 trailing_slash
  
    my $bool = $path->trailing_slash;
    $path    = $path->trailing_slash($bool);
  
  Path has a trailing slash. Note that this method will normalize the path and
  that C<%2F> will be treated as C</> for security reasons.
  
    # "/foo/bar/"
    Mojo::Path->new('/foo/bar')->trailing_slash(1);
  
    # "/foo/bar"
    Mojo::Path->new('/foo/bar/')->trailing_slash(0);
  
  =head1 OPERATORS
  
  L<Mojo::Path> overloads the following operators.
  
  =head2 array
  
    my @parts = @$path;
  
  Alias for L</"parts">. Note that this will normalize the path and that C<%2F>
  will be treated as C</> for security reasons.
  
    say $path->[0];
    say for @$path;
  
  =head2 bool
  
    my $bool = !!$path;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$path";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_PATH

$fatpacked{"Mojo/Promise.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_PROMISE';
  package Mojo::Promise;
  use Mojo::Base -base;
  
  use Mojo::IOLoop;
  use Scalar::Util qw(blessed weaken);
  
  has ioloop => sub { Mojo::IOLoop->singleton };
  
  sub all {
    my ($class, @promises) = @_;
  
    my $all       = $class->new;
    my $results   = [];
    my $remaining = scalar @promises;
    for my $i (0 .. $#promises) {
      $promises[$i]->then(
        sub {
          $results->[$i] = [@_];
          $all->resolve(@$results) if --$remaining <= 0;
        },
        sub { $all->reject(@_) }
      );
    }
  
    return @promises ? $all : $all->resolve;
  }
  
  sub catch { shift->then(undef, shift) }
  
  sub finally {
    my ($self, $finally) = @_;
  
    my $new = $self->_clone;
    push @{$self->{resolve}}, sub { _finally($new, $finally, 'resolve', @_) };
    push @{$self->{reject}},  sub { _finally($new, $finally, 'reject',  @_) };
  
    $self->_defer if $self->{result};
  
    return $new;
  }
  
  sub race {
    my ($class, @promises) = @_;
    my $new = $class->new;
    $_->then(sub { $new->resolve(@_) }, sub { $new->reject(@_) }) for @promises;
    return $new;
  }
  
  sub reject  { shift->_settle('reject',  @_) }
  sub resolve { shift->_settle('resolve', @_) }
  
  sub then {
    my ($self, $resolve, $reject) = @_;
  
    my $new = $self->_clone;
    push @{$self->{resolve}}, sub { _then($new, $resolve, 'resolve', @_) };
    push @{$self->{reject}},  sub { _then($new, $reject,  'reject',  @_) };
  
    $self->_defer if $self->{result};
  
    return $new;
  }
  
  sub wait {
    my $self = shift;
    return if (my $loop = $self->ioloop)->is_running;
    $self->finally(sub { $loop->stop });
    $loop->start;
  }
  
  sub _clone {
    my $self  = shift;
    my $clone = $self->new;
    weaken $clone->ioloop($self->ioloop)->{ioloop};
    return $clone;
  }
  
  sub _defer {
    my $self = shift;
  
    return unless my $result = $self->{result};
    my $cbs = $self->{status} eq 'resolve' ? $self->{resolve} : $self->{reject};
    @{$self}{qw(resolve reject)} = ([], []);
  
    $self->ioloop->next_tick(sub { $_->(@$result) for @$cbs });
  }
  
  sub _finally {
    my ($new, $finally, $method, @result) = @_;
    my ($res) = eval { $finally->(@result) };
    return $new->$method(@result)
      unless $res && blessed $res && $res->can('then');
    $res->then(sub { $new->$method(@result) }, sub { $new->$method(@result) });
  }
  
  sub _settle {
    my ($self, $status) = (shift, shift);
  
    $_[0]->then(sub { $self->resolve(@_); () }, sub { $self->reject(@_); () })
      and return $self
      if blessed $_[0] && $_[0]->can('then');
  
    return $self if $self->{result};
  
    @{$self}{qw(result status)} = ([@_], $status);
    $self->_defer;
    return $self;
  }
  
  sub _then {
    my ($new, $cb, $method, @result) = @_;
  
    return $new->$method(@result) unless defined $cb;
  
    my @res;
    return $new->reject($@) unless eval { @res = $cb->(@result); 1 };
    return $new->resolve(@res);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Promise - Promises/A+
  
  =head1 SYNOPSIS
  
    use Mojo::Promise;
    use Mojo::UserAgent;
  
    # Wrap continuation-passing style APIs with promises
    my $ua = Mojo::UserAgent->new;
    sub get {
      my $promise = Mojo::Promise->new;
      $ua->get(@_ => sub {
        my ($ua, $tx) = @_;
        my $err = $tx->error;
        $promise->resolve($tx) if !$err || $err->{code};
        $promise->reject($err->{message});
      });
      return $promise;
    }
  
    # Perform non-blocking operations sequentially
    get('https://mojolicious.org')->then(sub {
      my $mojo = shift;
      say $mojo->res->code;
      return get('https://metacpan.org');
    })->then(sub {
      my $cpan = shift;
      say $cpan->res->code;
    })->catch(sub {
      my $err = shift;
      warn "Something went wrong: $err";
    })->wait;
  
    # Synchronize non-blocking operations (all)
    my $mojo = get('https://mojolicious.org');
    my $cpan = get('https://metacpan.org');
    Mojo::Promise->all($mojo, $cpan)->then(sub {
      my ($mojo, $cpan) = @_;
      say $mojo->[0]->res->code;
      say $cpan->[0]->res->code;
    })->catch(sub {
      my $err = shift;
      warn "Something went wrong: $err";
    })->wait;
  
    # Synchronize non-blocking operations (race)
    my $mojo = get('https://mojolicious.org');
    my $cpan = get('https://metacpan.org');
    Mojo::Promise->race($mojo, $cpan)->then(sub {
      my $tx = shift;
      say $tx->req->url, ' won!';
    })->catch(sub {
      my $err = shift;
      warn "Something went wrong: $err";
    })->wait;
  
  =head1 DESCRIPTION
  
  L<Mojo::Promise> is a Perl-ish implementation of
  L<Promises/A+|https://promisesaplus.com>.
  
  =head1 STATES
  
  A promise is an object representing the eventual completion or failure of a
  non-blocking operation. It allows non-blocking functions to return values, like
  blocking functions. But instead of immediately returning the final value, the
  non-blocking function returns a promise to supply the value at some point in the
  future.
  
  A promise can be in one of three states:
  
  =over 2
  
  =item pending
  
  Initial state, neither fulfilled nor rejected.
  
  =item fulfilled
  
  Meaning that the operation completed successfully.
  
  =item rejected
  
  Meaning that the operation failed.
  
  =back
  
  A pending promise can either be fulfilled with a value or rejected with a
  reason. When either happens, the associated handlers queued up by a promise's
  L</"then"> method are called.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Promise> implements the following attributes.
  
  =head2 ioloop
  
    my $loop = $promise->ioloop;
    $promise = $promise->ioloop(Mojo::IOLoop->new);
  
  Event loop object to control, defaults to the global L<Mojo::IOLoop> singleton.
  
  =head1 METHODS
  
  L<Mojo::Promise> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 all
  
    my $new = Mojo::Promise->all(@promises);
  
  Returns a new L<Mojo::Promise> object that either fulfills when all of the
  passed L<Mojo::Promise> objects have fulfilled or rejects as soon as one of them
  rejects. If the returned promise fulfills, it is fulfilled with the values from
  the fulfilled promises in the same order as the passed promises. This method can
  be useful for aggregating results of multiple promises.
  
  =head2 catch
  
    my $new = $promise->catch(sub {...});
  
  Appends a rejection handler callback to the promise, and returns a new
  L<Mojo::Promise> object resolving to the return value of the callback if it is
  called, or to its original fulfillment value if the promise is instead
  fulfilled.
  
    # Longer version
    my $new = $promise->then(undef, sub {...});
  
    # Pass along the rejection reason
    $promise->catch(sub {
      my @reason = @_;
      warn "Something went wrong: $reason[0]";
      return @reason;
    });
  
    # Change the rejection reason
    $promise->catch(sub {
      my @reason = @_;
      return "This is bad: $reason[0]";
    });
  
  =head2 finally
  
    my $new = $promise->finally(sub {...});
  
  Appends a fulfillment and rejection handler to the promise, and returns a new
  L<Mojo::Promise> object resolving to the original fulfillment value or rejection
  reason.
  
    # Do something on fulfillment and rejection
    $promise->finally(sub {
      my @value_or_reason = @_;
      say "We are done!";
    });
  
  =head2 race
  
    my $new = Mojo::Promise->race(@promises);
  
  Returns a new L<Mojo::Promise> object that fulfills or rejects as soon as one of
  the passed L<Mojo::Promise> objects fulfills or rejects, with the value or
  reason from that promise.
  
  =head2 reject
  
    $promise = $promise->reject(@reason);
  
  Reject the promise with one or more rejection reasons.
  
    # Generate rejected promise
    my $promise = Mojo::Promise->new->reject('Something went wrong: Oops');
  
  =head2 resolve
  
    $promise = $promise->resolve(@value);
  
  Resolve the promise with one or more fulfillment values.
  
    # Generate fulfilled promise
    my $promise = Mojo::Promise->new->resolve('The result is: 24');
  
  =head2 then
  
    my $new = $promise->then(sub {...});
    my $new = $promise->then(sub {...}, sub {...});
    my $new = $promise->then(undef, sub {...});
  
  Appends fulfillment and rejection handlers to the promise, and returns a new
  L<Mojo::Promise> object resolving to the return value of the called handler.
  
    # Pass along the fulfillment value or rejection reason
    $promise->then(
      sub {
        my @value = @_;
        say "The result is $value[0]";
        return @value;
      },
      sub {
        my @reason = @_;
        warn "Something went wrong: $reason[0]";
        return @reason;
      }
    );
  
    # Change the fulfillment value or rejection reason
    $promise->then(
      sub {
        my @value = @_;
        return "This is good: $value[0]";
      },
      sub {
        my @reason = @_;
        return "This is bad: $reason[0]";
      }
    );
  
  =head2 wait
  
    $promise->wait;
  
  Start L</"ioloop"> and stop it again once the promise has been fulfilled or
  rejected, does nothing when L</"ioloop"> is already running.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_PROMISE

$fatpacked{"Mojo/Reactor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_REACTOR';
  package Mojo::Reactor;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Config;
  use Mojo::Loader 'load_class';
  
  my %DETECTED;
  
  sub again { croak 'Method "again" not implemented by subclass' }
  
  sub detect {
    my $default = 'Mojo::Reactor::' . ($Config{d_pseudofork} ? 'Poll' : 'EV');
    my $try = $ENV{MOJO_REACTOR} || $default;
    return $DETECTED{$try} ||= load_class($try) ? 'Mojo::Reactor::Poll' : $try;
  }
  
  sub io         { croak 'Method "io" not implemented by subclass' }
  sub is_running { croak 'Method "is_running" not implemented by subclass' }
  sub next_tick  { croak 'Method "next_tick" not implemented by subclass' }
  sub one_tick   { croak 'Method "one_tick" not implemented by subclass' }
  sub recurring  { croak 'Method "recurring" not implemented by subclass' }
  sub remove     { croak 'Method "remove" not implemented by subclass' }
  sub reset      { croak 'Method "reset" not implemented by subclass' }
  sub start      { croak 'Method "start" not implemented by subclass' }
  sub stop       { croak 'Method "stop" not implemented by subclass' }
  sub timer      { croak 'Method "timer" not implemented by subclass' }
  sub watch      { croak 'Method "watch" not implemented by subclass' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Reactor - Low-level event reactor base class
  
  =head1 SYNOPSIS
  
    package Mojo::Reactor::MyEventLoop;
    use Mojo::Base 'Mojo::Reactor';
  
    sub again      {...}
    sub io         {...}
    sub is_running {...}
    sub next_tick  {...}
    sub one_tick   {...}
    sub recurring  {...}
    sub remove     {...}
    sub reset      {...}
    sub start      {...}
    sub stop       {...}
    sub timer      {...}
    sub watch      {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Reactor> is an abstract base class for low-level event reactors, like
  L<Mojo::Reactor::EV> and L<Mojo::Reactor::Poll>.
  
  =head1 EVENTS
  
  L<Mojo::Reactor> inherits all events from L<Mojo::EventEmitter> and can emit
  the following new ones.
  
  =head2 error
  
    $reactor->on(error => sub {
      my ($reactor, $err) = @_;
      ...
    });
  
  Emitted for exceptions caught in callbacks, fatal if unhandled. Note that if
  this event is unhandled or fails it might kill your program, so you need to be
  careful.
  
    $reactor->on(error => sub {
      my ($reactor, $err) = @_;
      say "Something very bad happened: $err";
    });
  
  =head1 METHODS
  
  L<Mojo::Reactor> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 again
  
    $reactor->again($id);
  
  Restart timer. Meant to be overloaded in a subclass. Note that this method
  requires an active timer.
  
  =head2 detect
  
    my $class = Mojo::Reactor->detect;
  
  Detect and load the best reactor implementation available, will try the value
  of the C<MOJO_REACTOR> environment variable, L<Mojo::Reactor::EV> or
  L<Mojo::Reactor::Poll>.
  
    # Instantiate best reactor implementation available
    my $reactor = Mojo::Reactor->detect->new;
  
  =head2 io
  
    $reactor = $reactor->io($handle => sub {...});
  
  Watch handle for I/O events, invoking the callback whenever handle becomes
  readable or writable. Meant to be overloaded in a subclass.
  
    # Callback will be executed twice if handle becomes readable and writable
    $reactor->io($handle => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Handle is writable' : 'Handle is readable';
    });
  
  =head2 is_running
  
    my $bool = $reactor->is_running;
  
  Check if reactor is running. Meant to be overloaded in a subclass.
  
  =head2 next_tick
  
    my $undef = $reactor->next_tick(sub {...});
  
  Execute callback as soon as possible, but not before returning or other
  callbacks that have been registered with this method, always returns C<undef>.
  Meant to be overloaded in a subclass.
  
  =head2 one_tick
  
    $reactor->one_tick;
  
  Run reactor until an event occurs. Note that this method can recurse back into
  the reactor, so you need to be careful. Meant to be overloaded in a subclass.
  
    # Don't block longer than 0.5 seconds
    my $id = $reactor->timer(0.5 => sub {});
    $reactor->one_tick;
    $reactor->remove($id);
  
  =head2 recurring
  
    my $id = $reactor->recurring(0.25 => sub {...});
  
  Create a new recurring timer, invoking the callback repeatedly after a given
  amount of time in seconds. Meant to be overloaded in a subclass.
  
  =head2 remove
  
    my $bool = $reactor->remove($handle);
    my $bool = $reactor->remove($id);
  
  Remove handle or timer. Meant to be overloaded in a subclass.
  
  =head2 reset
  
    $reactor->reset;
  
  Remove all handles and timers. Meant to be overloaded in a subclass.
  
  =head2 start
  
    $reactor->start;
  
  Start watching for I/O and timer events, this will block until L</"stop"> is
  called. Note that some reactors stop automatically if there are no events being
  watched anymore. Meant to be overloaded in a subclass.
  
    # Start reactor only if it is not running already
    $reactor->start unless $reactor->is_running;
  
  =head2 stop
  
    $reactor->stop;
  
  Stop watching for I/O and timer events. Meant to be overloaded in a subclass.
  
  =head2 timer
  
    my $id = $reactor->timer(0.5 => sub {...});
  
  Create a new timer, invoking the callback after a given amount of time in
  seconds. Meant to be overloaded in a subclass.
  
  =head2 watch
  
    $reactor = $reactor->watch($handle, $readable, $writable);
  
  Change I/O events to watch handle for with true and false values. Meant to be
  overloaded in a subclass. Note that this method requires an active I/O watcher.
  
    # Watch only for readable events
    $reactor->watch($handle, 1, 0);
  
    # Watch only for writable events
    $reactor->watch($handle, 0, 1);
  
    # Watch for readable and writable events
    $reactor->watch($handle, 1, 1);
  
    # Pause watching for events
    $reactor->watch($handle, 0, 0);
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_REACTOR

$fatpacked{"Mojo/Reactor/EV.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_REACTOR_EV';
  package Mojo::Reactor::EV;
  use Mojo::Base 'Mojo::Reactor::Poll';
  
  use Carp 'croak';
  use EV 4.0;
  
  my $EV;
  
  sub DESTROY { undef $EV }
  
  sub again {
    croak 'Timer not active' unless my $timer = shift->{timers}{shift()};
    $timer->{watcher}->again;
  }
  
  sub is_running { !!EV::depth }
  
  # We have to fall back to Mojo::Reactor::Poll, since EV is unique
  sub new { $EV++ ? Mojo::Reactor::Poll->new : shift->SUPER::new }
  
  sub one_tick { EV::run(EV::RUN_ONCE) }
  
  sub recurring { shift->_timer(1, @_) }
  
  sub start {EV::run}
  
  sub stop { EV::break(EV::BREAK_ALL) }
  
  sub timer { shift->_timer(0, @_) }
  
  sub watch {
    my ($self, $handle, $read, $write) = @_;
  
    my $fd = fileno $handle;
    croak 'I/O watcher not active' unless my $io = $self->{io}{$fd};
  
    my $mode = 0;
    $mode |= EV::READ  if $read;
    $mode |= EV::WRITE if $write;
  
    if ($mode == 0) { delete $io->{watcher} }
    elsif (my $w = $io->{watcher}) { $w->events($mode) }
    else {
      my $cb = sub {
        my ($w, $revents) = @_;
        $self->_try('I/O watcher', $self->{io}{$fd}{cb}, 0)
          if EV::READ & $revents;
        $self->_try('I/O watcher', $self->{io}{$fd}{cb}, 1)
          if EV::WRITE & $revents && $self->{io}{$fd};
      };
      $io->{watcher} = EV::io($fd, $mode, $cb);
    }
  
    return $self;
  }
  
  sub _timer {
    my ($self, $recurring, $after, $cb) = @_;
    $after ||= 0.0001 if $recurring;
  
    my $id      = $self->_id;
    my $wrapper = sub {
      delete $self->{timers}{$id} unless $recurring;
      $self->_try('Timer', $cb);
    };
    EV::now_update() if $after > 0;
    $self->{timers}{$id}{watcher} = EV::timer($after, $after, $wrapper);
  
    return $id;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Reactor::EV - Low-level event reactor with libev support
  
  =head1 SYNOPSIS
  
    use Mojo::Reactor::EV;
  
    # Watch if handle becomes readable or writable
    my $reactor = Mojo::Reactor::EV->new;
    $reactor->io($first => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'First handle is writable' : 'First handle is readable';
    });
  
    # Change to watching only if handle becomes writable
    $reactor->watch($first, 0, 1);
  
    # Turn file descriptor into handle and watch if it becomes readable
    my $second = IO::Handle->new_from_fd($fd, 'r');
    $reactor->io($second => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Second handle is writable' : 'Second handle is readable';
    })->watch($second, 1, 0);
  
    # Add a timer
    $reactor->timer(15 => sub {
      my $reactor = shift;
      $reactor->remove($first);
      $reactor->remove($second);
      say 'Timeout!';
    });
  
    # Start reactor if necessary
    $reactor->start unless $reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::Reactor::EV> is a low-level event reactor based on L<EV> (4.0+).
  
  =head1 EVENTS
  
  L<Mojo::Reactor::EV> inherits all events from L<Mojo::Reactor::Poll>.
  
  =head1 METHODS
  
  L<Mojo::Reactor::EV> inherits all methods from L<Mojo::Reactor::Poll> and
  implements the following new ones.
  
  =head2 again
  
    $reactor->again($id);
  
  Restart timer. Note that this method requires an active timer.
  
  =head2 is_running
  
    my $bool = $reactor->is_running;
  
  Check if reactor is running.
  
  =head2 new
  
    my $reactor = Mojo::Reactor::EV->new;
  
  Construct a new L<Mojo::Reactor::EV> object.
  
  =head2 one_tick
  
    $reactor->one_tick;
  
  Run reactor until an event occurs or no events are being watched anymore.
  
    # Don't block longer than 0.5 seconds
    my $id = $reactor->timer(0.5 => sub {});
    $reactor->one_tick;
    $reactor->remove($id);
  
  =head2 recurring
  
    my $id = $reactor->recurring(0.25 => sub {...});
  
  Create a new recurring timer, invoking the callback repeatedly after a given
  amount of time in seconds.
  
  =head2 start
  
    $reactor->start;
  
  Start watching for I/O and timer events, this will block until L</"stop"> is
  called or no events are being watched anymore.
  
    # Start reactor only if it is not running already
    $reactor->start unless $reactor->is_running;
  
  =head2 stop
  
    $reactor->stop;
  
  Stop watching for I/O and timer events.
  
  =head2 timer
  
    my $id = $reactor->timer(0.5 => sub {...});
  
  Create a new timer, invoking the callback after a given amount of time in
  seconds.
  
  =head2 watch
  
    $reactor = $reactor->watch($handle, $readable, $writable);
  
  Change I/O events to watch handle for with true and false values. Note that
  this method requires an active I/O watcher.
  
    # Watch only for readable events
    $reactor->watch($handle, 1, 0);
  
    # Watch only for writable events
    $reactor->watch($handle, 0, 1);
  
    # Watch for readable and writable events
    $reactor->watch($handle, 1, 1);
  
    # Pause watching for events
    $reactor->watch($handle, 0, 0);
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_REACTOR_EV

$fatpacked{"Mojo/Reactor/Poll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_REACTOR_POLL';
  package Mojo::Reactor::Poll;
  use Mojo::Base 'Mojo::Reactor';
  
  use Carp 'croak';
  use IO::Poll qw(POLLERR POLLHUP POLLIN POLLNVAL POLLOUT POLLPRI);
  use List::Util 'min';
  use Mojo::Util qw(md5_sum steady_time);
  use Time::HiRes 'usleep';
  
  sub again {
    croak 'Timer not active' unless my $timer = shift->{timers}{shift()};
    $timer->{time} = steady_time + $timer->{after};
  }
  
  sub io {
    my ($self, $handle, $cb) = @_;
    $self->{io}{fileno($handle) // croak 'Handle is closed'} = {cb => $cb};
    return $self->watch($handle, 1, 1);
  }
  
  sub is_running { !!shift->{running} }
  
  sub next_tick {
    my ($self, $cb) = @_;
    push @{$self->{next_tick}}, $cb;
    $self->{next_timer} //= $self->timer(0 => \&_next);
    return undef;
  }
  
  sub one_tick {
    my $self = shift;
  
    # Just one tick
    local $self->{running} = 1 unless $self->{running};
  
    # Wait for one event
    my $i;
    until ($i || !$self->{running}) {
  
      # Stop automatically if there is nothing to watch
      return $self->stop unless keys %{$self->{timers}} || keys %{$self->{io}};
  
      # Calculate ideal timeout based on timers and round up to next millisecond
      my $min = min map { $_->{time} } values %{$self->{timers}};
      my $timeout = defined $min ? $min - steady_time : 0.5;
      $timeout = $timeout <= 0 ? 0 : int($timeout * 1000) + 1;
  
      # I/O
      if (keys %{$self->{io}}) {
        my @poll = map { $_ => $self->{io}{$_}{mode} } keys %{$self->{io}};
  
        # This may break in the future, but is worth it for performance
        if (IO::Poll::_poll($timeout, @poll) > 0) {
          while (my ($fd, $mode) = splice @poll, 0, 2) {
  
            if ($mode & (POLLIN | POLLPRI | POLLNVAL | POLLHUP | POLLERR)) {
              next unless my $io = $self->{io}{$fd};
              ++$i and $self->_try('I/O watcher', $io->{cb}, 0);
            }
            next unless $mode & POLLOUT && (my $io = $self->{io}{$fd});
            ++$i and $self->_try('I/O watcher', $io->{cb}, 1);
          }
        }
      }
  
      # Wait for timeout if poll can't be used
      elsif ($timeout) { usleep($timeout * 1000) }
  
      # Timers (time should not change in between timers)
      my $now = steady_time;
      for my $id (keys %{$self->{timers}}) {
        next unless my $t = $self->{timers}{$id};
        next unless $t->{time} <= $now;
  
        # Recurring timer
        if (exists $t->{recurring}) { $t->{time} = $now + $t->{recurring} }
  
        # Normal timer
        else { $self->remove($id) }
  
        ++$i and $self->_try('Timer', $t->{cb}) if $t->{cb};
      }
    }
  }
  
  sub recurring { shift->_timer(1, @_) }
  
  sub remove {
    my ($self, $remove) = @_;
    return !!delete $self->{timers}{$remove} unless ref $remove;
    return !!delete $self->{io}{fileno($remove) // croak 'Handle is closed'};
  }
  
  sub reset { delete @{shift()}{qw(events io next_tick next_timer timers)} }
  
  sub start {
    my $self = shift;
    local $self->{running} = ($self->{running} || 0) + 1;
    $self->one_tick while $self->{running};
  }
  
  sub stop { delete shift->{running} }
  
  sub timer { shift->_timer(0, @_) }
  
  sub watch {
    my ($self, $handle, $read, $write) = @_;
  
    croak 'I/O watcher not active' unless my $io = $self->{io}{fileno $handle};
    $io->{mode} = 0;
    $io->{mode} |= POLLIN | POLLPRI if $read;
    $io->{mode} |= POLLOUT if $write;
  
    return $self;
  }
  
  sub _id {
    my $self = shift;
    my $id;
    do { $id = md5_sum 't' . steady_time . rand } while $self->{timers}{$id};
    return $id;
  }
  
  sub _next {
    my $self = shift;
    delete $self->{next_timer};
    while (my $cb = shift @{$self->{next_tick}}) { $self->$cb }
  }
  
  sub _timer {
    my ($self, $recurring, $after, $cb) = @_;
  
    my $id    = $self->_id;
    my $timer = $self->{timers}{$id}
      = {cb => $cb, after => $after, time => steady_time + $after};
    $timer->{recurring} = $after if $recurring;
  
    return $id;
  }
  
  sub _try {
    my ($self, $what, $cb) = (shift, shift, shift);
    eval { $self->$cb(@_); 1 } or $self->emit(error => "$what failed: $@");
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Reactor::Poll - Low-level event reactor with poll support
  
  =head1 SYNOPSIS
  
    use Mojo::Reactor::Poll;
  
    # Watch if handle becomes readable or writable
    my $reactor = Mojo::Reactor::Poll->new;
    $reactor->io($first => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'First handle is writable' : 'First handle is readable';
    });
  
    # Change to watching only if handle becomes writable
    $reactor->watch($first, 0, 1);
  
    # Turn file descriptor into handle and watch if it becomes readable
    my $second = IO::Handle->new_from_fd($fd, 'r');
    $reactor->io($second => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Second handle is writable' : 'Second handle is readable';
    })->watch($second, 1, 0);
  
    # Add a timer
    $reactor->timer(15 => sub {
      my $reactor = shift;
      $reactor->remove($first);
      $reactor->remove($second);
      say 'Timeout!';
    });
  
    # Start reactor if necessary
    $reactor->start unless $reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::Reactor::Poll> is a low-level event reactor based on L<IO::Poll>.
  
  =head1 EVENTS
  
  L<Mojo::Reactor::Poll> inherits all events from L<Mojo::Reactor>.
  
  =head1 METHODS
  
  L<Mojo::Reactor::Poll> inherits all methods from L<Mojo::Reactor> and
  implements the following new ones.
  
  =head2 again
  
    $reactor->again($id);
  
  Restart timer. Note that this method requires an active timer.
  
  =head2 io
  
    $reactor = $reactor->io($handle => sub {...});
  
  Watch handle for I/O events, invoking the callback whenever handle becomes
  readable or writable.
  
    # Callback will be executed twice if handle becomes readable and writable
    $reactor->io($handle => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Handle is writable' : 'Handle is readable';
    });
  
  =head2 is_running
  
    my $bool = $reactor->is_running;
  
  Check if reactor is running.
  
  =head2 next_tick
  
    my $undef = $reactor->next_tick(sub {...});
  
  Execute callback as soon as possible, but not before returning or other
  callbacks that have been registered with this method, always returns C<undef>.
  
  =head2 one_tick
  
    $reactor->one_tick;
  
  Run reactor until an event occurs or no events are being watched anymore.
  
    # Don't block longer than 0.5 seconds
    my $id = $reactor->timer(0.5 => sub {});
    $reactor->one_tick;
    $reactor->remove($id);
  
  =head2 recurring
  
    my $id = $reactor->recurring(0.25 => sub {...});
  
  Create a new recurring timer, invoking the callback repeatedly after a given
  amount of time in seconds.
  
  =head2 remove
  
    my $bool = $reactor->remove($handle);
    my $bool = $reactor->remove($id);
  
  Remove handle or timer.
  
  =head2 reset
  
    $reactor->reset;
  
  Remove all handles and timers.
  
  =head2 start
  
    $reactor->start;
  
  Start watching for I/O and timer events, this will block until L</"stop"> is
  called or no events are being watched anymore.
  
    # Start reactor only if it is not running already
    $reactor->start unless $reactor->is_running;
  
  =head2 stop
  
    $reactor->stop;
  
  Stop watching for I/O and timer events.
  
  =head2 timer
  
    my $id = $reactor->timer(0.5 => sub {...});
  
  Create a new timer, invoking the callback after a given amount of time in
  seconds.
  
  =head2 watch
  
    $reactor = $reactor->watch($handle, $readable, $writable);
  
  Change I/O events to watch handle for with true and false values. Note that
  this method requires an active I/O watcher.
  
    # Watch only for readable events
    $reactor->watch($handle, 1, 0);
  
    # Watch only for writable events
    $reactor->watch($handle, 0, 1);
  
    # Watch for readable and writable events
    $reactor->watch($handle, 1, 1);
  
    # Pause watching for events
    $reactor->watch($handle, 0, 0);
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_REACTOR_POLL

$fatpacked{"Mojo/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER';
  package Mojo::Server;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Mojo::File 'path';
  use Mojo::Loader 'load_class';
  use Mojo::Util 'md5_sum';
  use POSIX ();
  use Scalar::Util 'blessed';
  
  has app           => sub { shift->build_app('Mojo::HelloWorld') };
  has reverse_proxy => sub { $ENV{MOJO_REVERSE_PROXY} };
  
  sub build_app {
    my ($self, $app) = (shift, shift);
    local $ENV{MOJO_EXE};
    return $self->app($app->new(@_))->app unless my $e = load_class $app;
    die ref $e ? $e : qq{Can't find application class "$app" in \@INC. (@INC)\n};
  }
  
  sub build_tx {
    my $self = shift;
    my $tx   = $self->app->build_tx;
    $tx->req->reverse_proxy(1) if $self->reverse_proxy;
    return $tx;
  }
  
  sub daemonize {
  
    # Fork and kill parent
    die "Can't fork: $!" unless defined(my $pid = fork);
    exit 0 if $pid;
    POSIX::setsid or die "Can't start a new session: $!";
  
    # Close filehandles
    open STDIN,  '</dev/null';
    open STDOUT, '>/dev/null';
    open STDERR, '>&STDOUT';
  }
  
  sub load_app {
    my ($self, $path) = @_;
  
    # Clean environment (reset FindBin defensively)
    {
      local $0 = $path = path($path)->to_abs->to_string;
      require FindBin;
      FindBin->again;
      local $ENV{MOJO_APP_LOADER} = 1;
      local $ENV{MOJO_EXE};
  
      # Try to load application from script into sandbox
      delete $INC{$path};
      my $app = eval
        "package Mojo::Server::Sandbox::@{[md5_sum $path]}; require \$path";
      die qq{Can't load application from file "$path": $@} if $@;
      die qq{File "$path" did not return an application object.\n}
        unless blessed $app && $app->can('handler');
      $self->app($app);
    };
    FindBin->again;
  
    return $self->app;
  }
  
  sub new {
    my $self = shift->SUPER::new(@_);
    $self->on(request => sub { shift->app->handler(shift) });
    return $self;
  }
  
  sub run { croak 'Method "run" not implemented by subclass' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server - HTTP/WebSocket server base class
  
  =head1 SYNOPSIS
  
    package Mojo::Server::MyServer;
    use Mojo::Base 'Mojo::Server';
  
    sub run {
      my $self = shift;
  
      # Get a transaction
      my $tx = $self->build_tx;
  
      # Emit "request" event
      $self->emit(request => $tx);
    }
  
  =head1 DESCRIPTION
  
  L<Mojo::Server> is an abstract base class for HTTP/WebSocket servers and server
  interfaces, like L<Mojo::Server::CGI>, L<Mojo::Server::Daemon>,
  L<Mojo::Server::Hypnotoad>, L<Mojo::Server::Morbo>, L<Mojo::Server::Prefork>
  and L<Mojo::Server::PSGI>.
  
  =head1 EVENTS
  
  L<Mojo::Server> inherits all events from L<Mojo::EventEmitter> and can emit the
  following new ones.
  
  =head2 request
  
    $server->on(request => sub {
      my ($server, $tx) = @_;
      ...
    });
  
  Emitted when a request is ready and needs to be handled.
  
    $server->on(request => sub {
      my ($server, $tx) = @_;
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body('Hello World!');
      $tx->resume;
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server> implements the following attributes.
  
  =head2 app
  
    my $app = $server->app;
    $server = $server->app(MojoSubclass->new);
  
  Application this server handles, defaults to a L<Mojo::HelloWorld> object.
  
  =head2 reverse_proxy
  
    my $bool = $server->reverse_proxy;
    $server  = $server->reverse_proxy($bool);
  
  This server operates behind a reverse proxy, defaults to the value of the
  C<MOJO_REVERSE_PROXY> environment variable.
  
  =head1 METHODS
  
  L<Mojo::Server> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 build_app
  
    my $app = $server->build_app('MyApp');
    my $app = $server->build_app('MyApp', log => Mojo::Log->new);
    my $app = $server->build_app('MyApp', {log => Mojo::Log->new});
  
  Build application from class and assign it to L</"app">.
  
  =head2 build_tx
  
    my $tx = $server->build_tx;
  
  Let application build a transaction.
  
  =head2 daemonize
  
    $server->daemonize;
  
  Daemonize server process.
  
  =head2 load_app
  
    my $app = $server->load_app('/home/sri/myapp.pl');
  
  Load application from script and assign it to L</"app">.
  
    say Mojo::Server->new->load_app('./myapp.pl')->home;
  
  =head2 new
  
    my $server = Mojo::Server->new;
    my $server = Mojo::Server->new(reverse_proxy => 1);
    my $server = Mojo::Server->new({reverse_proxy => 1});
  
  Construct a new L<Mojo::Server> object and subscribe to L</"request"> event
  with default request handling.
  
  =head2 run
  
    $server->run;
  
  Run server. Meant to be overloaded in a subclass.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_SERVER

$fatpacked{"Mojo/Server/CGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_CGI';
  package Mojo::Server::CGI;
  use Mojo::Base 'Mojo::Server';
  
  has 'nph';
  
  sub run {
    my $self = shift;
  
    my $tx  = $self->build_tx;
    my $req = $tx->req->parse(\%ENV);
    $tx->local_port($ENV{SERVER_PORT})->remote_address($ENV{REMOTE_ADDR});
  
    # Request body (may block if we try to read too much)
    binmode STDIN;
    my $len = $req->headers->content_length;
    until ($req->is_finished) {
      my $chunk = ($len && $len < 131072) ? $len : 131072;
      last unless my $read = STDIN->read(my $buffer, $chunk, 0);
      $req->parse($buffer);
      last if ($len -= $read) <= 0;
    }
  
    $self->emit(request => $tx);
  
    # Response start-line
    STDOUT->autoflush(1);
    binmode STDOUT;
    my $res = $tx->res->fix_headers;
    return undef if $self->nph && !_write($res, 'get_start_line_chunk');
  
    # Response headers
    my $code = $res->code    || 404;
    my $msg  = $res->message || $res->default_message;
    $res->headers->status("$code $msg") unless $self->nph;
    return undef unless _write($res, 'get_header_chunk');
  
    # Response body
    return undef unless $tx->is_empty || _write($res, 'get_body_chunk');
  
    # Finish transaction
    $tx->closed;
  
    return $res->code;
  }
  
  sub _write {
    my ($res, $method) = @_;
  
    my $offset = 0;
    while (1) {
  
      # No chunk yet, try again
      sleep 1 and next unless defined(my $chunk = $res->$method($offset));
  
      # End of part
      last unless my $len = length $chunk;
  
      # Make sure we can still write
      $offset += $len;
      return undef unless STDOUT->opened;
      print STDOUT $chunk;
    }
  
    return 1;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::CGI - CGI server
  
  =head1 SYNOPSIS
  
    use Mojo::Server::CGI;
  
    my $cgi = Mojo::Server::CGI->new;
    $cgi->unsubscribe('request')->on(request => sub {
      my ($cgi, $tx) = @_;
  
      # Request
      my $method = $tx->req->method;
      my $path   = $tx->req->url->path;
  
      # Response
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body("$method request for $path!");
  
      # Resume transaction
      $tx->resume;
    });
    $cgi->run;
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::CGI> is a simple and portable implementation of
  L<RFC 3875|http://tools.ietf.org/html/rfc3875>.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 EVENTS
  
  L<Mojo::Server::CGI> inherits all events from L<Mojo::Server>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::CGI> inherits all attributes from L<Mojo::Server> and
  implements the following new ones.
  
  =head2 nph
  
    my $bool = $cgi->nph;
    $cgi     = $cgi->nph($bool);
  
  Activate non-parsed header mode.
  
  =head1 METHODS
  
  L<Mojo::Server::CGI> inherits all methods from L<Mojo::Server> and implements
  the following new ones.
  
  =head2 run
  
    my $status = $cgi->run;
  
  Run CGI.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_SERVER_CGI

$fatpacked{"Mojo/Server/Daemon.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_DAEMON';
  package Mojo::Server::Daemon;
  use Mojo::Base 'Mojo::Server';
  
  use Carp 'croak';
  use Mojo::IOLoop;
  use Mojo::IOLoop::Stream::HTTPServer;
  use Mojo::IOLoop::Stream::WebSocketServer;
  use Mojo::URL;
  use Scalar::Util 'weaken';
  
  use constant DEBUG => $ENV{MOJO_SERVER_DEBUG} || 0;
  
  has acceptors => sub { [] };
  has [qw(backlog max_clients silent)];
  has inactivity_timeout => sub { $ENV{MOJO_INACTIVITY_TIMEOUT} // 15 };
  has ioloop             => sub { Mojo::IOLoop->singleton };
  has listen => sub { [split ',', $ENV{MOJO_LISTEN} || 'http://*:3000'] };
  has max_requests => 100;
  
  sub DESTROY {
    return if Mojo::Util::_global_destruction();
    my $self = shift;
    my $loop = $self->ioloop;
    $loop->remove($_) for keys %{$self->{connections} || {}}, @{$self->acceptors};
  }
  
  sub close_connections {
    my $self = shift;
    my $loop = $self->ioloop;
    $_->max_requests(1)
      for map { $loop->stream($_) || () } keys %{$self->{connections} || {}};
  }
  
  sub ports { [map { $_[0]->ioloop->acceptor($_)->port } @{$_[0]->acceptors}] }
  
  sub run {
    my $self = shift;
  
    # Make sure the event loop can be stopped in regular intervals
    my $loop = $self->ioloop;
    my $int = $loop->recurring(1 => sub { });
    local $SIG{INT} = local $SIG{TERM} = sub { $loop->stop };
    $self->start->ioloop->start;
    $loop->remove($int);
  }
  
  sub start {
    my $self = shift;
  
    my $loop = $self->ioloop;
    if (my $max = $self->max_clients) { $loop->max_connections($max) }
  
    # Resume accepting connections
    if (my $servers = $self->{servers}) {
      push @{$self->acceptors}, $loop->acceptor(delete $servers->{$_})
        for keys %$servers;
    }
  
    # Start listening
    elsif (!@{$self->acceptors}) {
      $self->app->server($self);
      $self->_listen($_) for @{$self->listen};
    }
  
    return $self;
  }
  
  sub stop {
    my $self = shift;
  
    # Suspend accepting connections but keep listen sockets open
    my $loop = $self->ioloop;
    while (my $id = shift @{$self->acceptors}) {
      my $server = $self->{servers}{$id} = $loop->acceptor($id);
      $loop->remove($id);
      $server->stop;
    }
  
    return $self;
  }
  
  sub _debug { $_[0]->app->log->debug($_[2]) if $_[0]{connections}{$_[1]}{tx} }
  
  sub _listen {
    my ($self, $listen) = @_;
  
    my $url   = Mojo::URL->new($listen);
    my $proto = $url->protocol;
    croak qq{Invalid listen location "$listen"}
      unless $proto eq 'http' || $proto eq 'https' || $proto eq 'http+unix';
  
    my $query   = $url->query;
    my $options = {
      backlog      => $self->backlog,
      stream_class => 'Mojo::IOLoop::Stream::HTTPServer'
    };
    $options->{$_} = $query->param($_) for qw(fd single_accept reuse);
    if ($proto eq 'http+unix') { $options->{path} = $url->host }
    else {
      if ((my $host = $url->host) ne '*') { $options->{address} = $host }
      if (my $port = $url->port) { $options->{port} = $port }
    }
    $options->{"tls_$_"} = $query->param($_) for qw(ca ciphers version);
    /^(.*)_(cert|key)$/ and $options->{"tls_$2"}{$1} = $query->param($_)
      for @{$query->names};
    if (my $cert = $query->param('cert')) { $options->{'tls_cert'}{''} = $cert }
    if (my $key  = $query->param('key'))  { $options->{'tls_key'}{''}  = $key }
    my $verify = $query->param('verify');
    $options->{tls_verify} = hex $verify if defined $verify;
    $options->{tls} = $proto eq 'https';
  
    weaken $self;
    push @{$self->acceptors}, $self->ioloop->server(
      $options => sub {
        my ($loop, $stream, $id) = @_;
  
        my $c = $self->{connections}{$id} = {};
        warn "-- Accept $id (@{[$stream->handle->peerhost]})\n" if DEBUG;
        $stream->timeout($self->inactivity_timeout);
        $stream->max_requests($self->max_requests);
        weaken $stream->app($self)->{app};
  
        $stream->on(close => sub { $self && $self->_remove($id) });
        $stream->on(error =>
            sub { $self && $self->app->log->error(pop) && $self->_remove($id) });
        $stream->on(request => sub { $self->_request($id, pop) });
        $stream->on(start => sub { $c->{tx} = pop->connection($id) });
        $stream->on(timeout => sub { $self->_debug($id, 'Inactivity timeout') });
        $stream->on(upgrade => sub { $self->_upgrade($id, pop) });
      }
    );
  
    return if $self->silent;
    $self->app->log->info(qq{Listening at "$url"});
    $query->pairs([]);
    $url->host('127.0.0.1') if $url->host eq '*';
    say 'Server available at ', $options->{path} // $url;
  }
  
  sub _remove {
    my ($self, $id) = @_;
    $self->ioloop->remove($id);
    delete $self->{connections}{$id};
  }
  
  sub _request {
    my ($self, $id, $tx) = @_;
    if (my $error = $tx->error) { $self->_debug($id, $error->{message}) }
  
    weaken $self;
    $tx->on(finish => sub { delete $self->{connections}{$id}{tx} });
    $self->emit(request => $tx);
  }
  
  sub _upgrade {
    my ($self, $id, $ws) = @_;
  
    my $loop    = $self->ioloop;
    my $timeout = $loop->stream($id)->timeout;
    my $stream  = $loop->transition($id, 'Mojo::IOLoop::Stream::WebSocketServer');
    $stream->timeout($timeout);
  
    weaken $self;
    $stream->on(timeout => sub { $self->_debug($id, 'Inactivity timeout') });
    $stream->on(close => sub { $self && $self->_remove($id) });
    $stream->on(
      error => sub { $self && $self->app->log->error(pop) && $self->_remove($id) }
    );
  
    $self->{connections}{$id} = {tx => $ws};
    $stream->process($ws);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::Daemon - Non-blocking I/O HTTP and WebSocket server
  
  =head1 SYNOPSIS
  
    use Mojo::Server::Daemon;
  
    my $daemon = Mojo::Server::Daemon->new(listen => ['http://*:8080']);
    $daemon->unsubscribe('request')->on(request => sub {
      my ($daemon, $tx) = @_;
  
      # Request
      my $method = $tx->req->method;
      my $path   = $tx->req->url->path;
  
      # Response
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body("$method request for $path!");
  
      # Resume transaction
      $tx->resume;
    });
    $daemon->run;
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::Daemon> is a full featured, highly portable non-blocking I/O
  HTTP and WebSocket server, with IPv6, TLS, SNI, Comet (long polling), keep-alive
  and multiple event loop support.
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (2.009+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NNR>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 SIGNALS
  
  The L<Mojo::Server::Daemon> process can be controlled at runtime with the
  following signals.
  
  =head2 INT, TERM
  
  Shut down server immediately.
  
  =head1 EVENTS
  
  L<Mojo::Server::Daemon> inherits all events from L<Mojo::Server>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::Daemon> inherits all attributes from L<Mojo::Server> and
  implements the following new ones.
  
  =head2 acceptors
  
    my $acceptors = $daemon->acceptors;
    $daemon       = $daemon->acceptors(['6be0c140ef00a389c5d039536b56d139']);
  
  Active acceptor ids.
  
    # Check port
    mu $port = $daemon->ioloop->acceptor($daemon->acceptors->[0])->port;
  
  =head2 backlog
  
    my $backlog = $daemon->backlog;
    $daemon     = $daemon->backlog(128);
  
  Listen backlog size, defaults to C<SOMAXCONN>.
  
  =head2 inactivity_timeout
  
    my $timeout = $daemon->inactivity_timeout;
    $daemon     = $daemon->inactivity_timeout(5);
  
  Maximum amount of time in seconds a connection can be inactive before getting
  closed, defaults to the value of the C<MOJO_INACTIVITY_TIMEOUT> environment
  variable or C<15>. Setting the value to C<0> will allow connections to be
  inactive indefinitely.
  
  =head2 ioloop
  
    my $loop = $daemon->ioloop;
    $daemon  = $daemon->ioloop(Mojo::IOLoop->new);
  
  Event loop object to use for I/O operations, defaults to the global
  L<Mojo::IOLoop> singleton.
  
  =head2 listen
  
    my $listen = $daemon->listen;
    $daemon    = $daemon->listen(['https://127.0.0.1:8080']);
  
  Array reference with one or more locations to listen on, defaults to the value
  of the C<MOJO_LISTEN> environment variable or C<http://*:3000> (shortcut for
  C<http://0.0.0.0:3000>).
  
    # Listen on all IPv4 interfaces
    $daemon->listen(['http://*:3000']);
  
    # Listen on all IPv4 and IPv6 interfaces
    $daemon->listen(['http://[::]:3000']);
  
    # Listen on IPv6 interface
    $daemon->listen(['http://[::1]:4000']);
  
    # Listen on IPv4 and IPv6 interfaces
    $daemon->listen(['http://127.0.0.1:3000', 'http://[::1]:3000']);
  
    # Listen on UNIX domain socket "/tmp/myapp.sock" (percent encoded slash)
    $daemon->listen(['http+unix://%2Ftmp%2Fmyapp.sock']);
  
    # File descriptor, as used by systemd
    $daemon->listen(['http://127.0.0.1?fd=3']);
  
    # Allow multiple servers to use the same port (SO_REUSEPORT)
    $daemon->listen(['http://*:8080?reuse=1']);
  
    # Listen on two ports with HTTP and HTTPS at the same time
    $daemon->listen(['http://*:3000', 'https://*:4000']);
  
    # Use a custom certificate and key
    $daemon->listen(['https://*:3000?cert=/x/server.crt&key=/y/server.key']);
  
    # Domain specific certificates and keys (SNI)
    $daemon->listen(
      ['https://*:3000?example.com_cert=/x/my.crt&example.com_key=/y/my.key']);
  
    # Or even a custom certificate authority
    $daemon->listen(
      ['https://*:3000?cert=/x/server.crt&key=/y/server.key&ca=/z/ca.crt']);
  
  These parameters are currently available:
  
  =over 2
  
  =item ca
  
    ca=/etc/tls/ca.crt
  
  Path to TLS certificate authority file used to verify the peer certificate.
  
  =item cert
  
    cert=/etc/tls/server.crt
    mojolicious.org_cert=/etc/tls/mojo.crt
  
  Path to the TLS cert file, defaults to a built-in test certificate.
  
  =item ciphers
  
    ciphers=AES128-GCM-SHA256:RC4:HIGH:!MD5:!aNULL:!EDH
  
  TLS cipher specification string. For more information about the format see
  L<https://www.openssl.org/docs/manmaster/apps/ciphers.html#CIPHER-STRINGS>.
  
  =item fd
  
    fd=3
  
  File descriptor with an already prepared listen socket.
  
  =item key
  
    key=/etc/tls/server.key
    mojolicious.org_key=/etc/tls/mojo.key
  
  Path to the TLS key file, defaults to a built-in test key.
  
  =item reuse
  
    reuse=1
  
  Allow multiple servers to use the same port with the C<SO_REUSEPORT> socket
  option.
  
  =item single_accept
  
    single_accept=1
  
  Only accept one connection at a time.
  
  =item verify
  
    verify=0x00
  
  TLS verification mode.
  
  =item version
  
    version=TLSv1_2
  
  TLS protocol version.
  
  =back
  
  =head2 max_clients
  
    my $max = $daemon->max_clients;
    $daemon = $daemon->max_clients(100);
  
  Maximum number of accepted connections this server is allowed to handle
  concurrently, before stopping to accept new incoming connections, passed along
  to L<Mojo::IOLoop/"max_connections">.
  
  =head2 max_requests
  
    my $max = $daemon->max_requests;
    $daemon = $daemon->max_requests(250);
  
  Maximum number of keep-alive requests per connection, defaults to C<100>.
  
  =head2 silent
  
    my $bool = $daemon->silent;
    $daemon  = $daemon->silent($bool);
  
  Disable console messages.
  
  =head1 METHODS
  
  L<Mojo::Server::Daemon> inherits all methods from L<Mojo::Server> and
  implements the following new ones.
  
  =head2 close_connections
  
    $daemon->close_connections;
  
  Stop accepting new requests and close all connections after finising those
  currently being processed.
  
  =head2 ports
  
    my $ports = $daemon->ports;
  
  Get all ports this server is currently listening on.
  
    # All ports
    say for @{$daemon->ports};
  
  =head2 run
  
    $daemon->run;
  
  Run server and wait for L</"SIGNALS">.
  
  =head2 start
  
    $daemon = $daemon->start;
  
  Start or resume accepting connections through L</"ioloop">.
  
    # Listen on random port
    my $port = $daemon->listen(['http://127.0.0.1'])->start->ports->[0];
  
    # Run multiple web servers concurrently
    my $daemon1 = Mojo::Server::Daemon->new(listen => ['http://*:3000'])->start;
    my $daemon2 = Mojo::Server::Daemon->new(listen => ['http://*:4000'])->start;
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 stop
  
    $daemon = $daemon->stop;
  
  Stop accepting connections through L</"ioloop">.
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_SERVER_DEBUG> environment variable to get some advanced
  diagnostics information printed to C<STDERR>.
  
    MOJO_SERVER_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_SERVER_DAEMON

$fatpacked{"Mojo/Server/Hypnotoad.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_HYPNOTOAD';
  package Mojo::Server::Hypnotoad;
  use Mojo::Base -base;
  
  # "Bender: I was God once.
  #  God: Yes, I saw. You were doing well, until everyone died."
  use Config;
  use Mojo::File 'path';
  use Mojo::Server::Prefork;
  use Mojo::Util 'steady_time';
  use Scalar::Util 'weaken';
  
  has prefork => sub { Mojo::Server::Prefork->new(listen => ['http://*:8080']) };
  has upgrade_timeout => 180;
  
  sub configure {
    my ($self, $name) = @_;
  
    # Hypnotoad settings
    my $prefork = $self->prefork;
    my $c = $prefork->app->config($name) || {};
    $self->upgrade_timeout($c->{upgrade_timeout}) if $c->{upgrade_timeout};
  
    # Pre-fork settings
    $prefork->reverse_proxy($c->{proxy})   if defined $c->{proxy};
    $prefork->max_clients($c->{clients})   if $c->{clients};
    $prefork->max_requests($c->{requests}) if $c->{requests};
    defined $c->{$_} and $prefork->$_($c->{$_})
      for qw(accepts backlog graceful_timeout heartbeat_interval),
      qw(heartbeat_timeout inactivity_timeout listen pid_file spare workers);
  }
  
  sub run {
    my ($self, $app) = @_;
  
    # No fork emulation support
    _exit('Hypnotoad does not support fork emulation.') if $Config{d_pseudofork};
  
    # Remember executable and application for later
    $ENV{HYPNOTOAD_EXE} ||= $0;
    $0 = $ENV{HYPNOTOAD_APP} ||= path($app)->to_abs->to_string;
  
    # This is a production server
    $ENV{MOJO_MODE} ||= 'production';
  
    # Clean start (to make sure everything works)
    die "Can't exec: $!"
      if !$ENV{HYPNOTOAD_REV}++ && !exec $^X, $ENV{HYPNOTOAD_EXE};
  
    # Preload application and configure server
    my $prefork = $self->prefork->cleanup(0);
    $prefork->load_app($app)->config->{hypnotoad}{pid_file}
      //= path($ENV{HYPNOTOAD_APP})->sibling('hypnotoad.pid')->to_string;
    $self->configure('hypnotoad');
    weaken $self;
    $prefork->on(wait   => sub { $self->_manage });
    $prefork->on(reap   => sub { $self->_cleanup(pop) });
    $prefork->on(finish => sub { $self->_finish });
  
    # Testing
    _exit('Everything looks good!') if $ENV{HYPNOTOAD_TEST};
  
    # Stop running server
    $self->_stop if $ENV{HYPNOTOAD_STOP};
  
    # Initiate hot deployment
    $self->_hot_deploy unless $ENV{HYPNOTOAD_PID};
  
    # Daemonize as early as possible (but not for restarts)
    local $SIG{USR2} = sub { $self->{upgrade} ||= steady_time };
    $prefork->start;
    $prefork->daemonize if !$ENV{HYPNOTOAD_FOREGROUND} && $ENV{HYPNOTOAD_REV} < 3;
  
    # Start accepting connections
    $prefork->cleanup(1)->run;
  }
  
  sub _cleanup {
    my ($self, $pid) = @_;
  
    # Clean up failed upgrade
    return unless ($self->{new} || '') eq $pid;
    $self->prefork->app->log->error('Zero downtime software upgrade failed');
    delete @$self{qw(new upgrade)};
  }
  
  sub _exit { say shift and exit 0 }
  
  sub _finish {
    my $self = shift;
  
    $self->{finish} = 1;
    return unless my $new = $self->{new};
  
    my $prefork = $self->prefork->cleanup(0);
    unlink $prefork->pid_file;
    $prefork->ensure_pid_file($new);
  }
  
  sub _hot_deploy {
  
    # Make sure server is running
    return unless my $pid = shift->prefork->check_pid;
  
    # Start hot deployment
    kill 'USR2', $pid;
    _exit("Starting hot deployment for Hypnotoad server $pid.");
  }
  
  sub _manage {
    my $self = shift;
  
    # Upgraded (wait for all workers to send a heartbeat)
    my $prefork = $self->prefork;
    my $log     = $prefork->app->log;
    if ($ENV{HYPNOTOAD_PID} && $ENV{HYPNOTOAD_PID} ne $$) {
      return unless $prefork->healthy == $prefork->workers;
      $log->info("Upgrade successful, stopping $ENV{HYPNOTOAD_PID}");
      kill 'QUIT', $ENV{HYPNOTOAD_PID};
    }
    $ENV{HYPNOTOAD_PID} = $$ unless ($ENV{HYPNOTOAD_PID} // '') eq $$;
  
    # Upgrade
    if ($self->{upgrade} && !$self->{finished}) {
  
      # Fresh start
      my $ut = $self->upgrade_timeout;
      unless ($self->{new}) {
        $log->info("Starting zero downtime software upgrade ($ut seconds)");
        die "Can't fork: $!" unless defined(my $pid = $self->{new} = fork);
        exec $^X, $ENV{HYPNOTOAD_EXE} or die "Can't exec: $!" unless $pid;
      }
  
      # Timeout
      kill 'KILL', $self->{new} if $self->{upgrade} + $ut <= steady_time;
    }
  }
  
  sub _stop {
    _exit('Hypnotoad server not running.')
      unless my $pid = shift->prefork->check_pid;
    kill 'QUIT', $pid;
    _exit("Stopping Hypnotoad server $pid gracefully.");
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::Hypnotoad - A production web serv...ALL GLORY TO THE HYPNOTOAD!
  
  =head1 SYNOPSIS
  
    use Mojo::Server::Hypnotoad;
  
    my $hypnotoad = Mojo::Server::Hypnotoad->new;
    $hypnotoad->run('/home/sri/myapp.pl');
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::Hypnotoad> is a full featured, UNIX optimized, pre-forking
  non-blocking I/O HTTP and WebSocket server, built around the very well tested
  and reliable L<Mojo::Server::Prefork>, with IPv6, TLS, SNI, UNIX domain socket,
  Comet (long polling), keep-alive, multiple event loop and hot deployment support
  that just works. Note that the server uses signals for process management, so
  you should avoid modifying signal handlers in your applications.
  
  To start applications with it you can use the L<hypnotoad> script, which
  listens on port C<8080>, automatically daemonizes the server process and
  defaults to C<production> mode for L<Mojolicious> and L<Mojolicious::Lite>
  applications.
  
    $ hypnotoad ./myapp.pl
  
  You can run the same command again for automatic hot deployment.
  
    $ hypnotoad ./myapp.pl
    Starting hot deployment for Hypnotoad server 31841.
  
  This second invocation will load the application again, detect the process id
  file with it, and send a L</"USR2"> signal to the already running server.
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (2.009+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NNR>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 MANAGER SIGNALS
  
  The L<Mojo::Server::Hypnotoad> manager process can be controlled at runtime
  with the following signals.
  
  =head2 INT, TERM
  
  Shut down server immediately.
  
  =head2 QUIT
  
  Shut down server gracefully.
  
  =head2 TTIN
  
  Increase worker pool by one.
  
  =head2 TTOU
  
  Decrease worker pool by one.
  
  =head2 USR2
  
  Attempt zero downtime software upgrade (hot deployment) without losing any
  incoming connections.
  
    Manager (old)
    |- Worker [1]
    |- Worker [2]
    |- Worker [3]
    |- Worker [4]
    +- Manager (new)
       |- Worker [1]
       |- Worker [2]
       |- Worker [3]
       +- Worker [4]
  
  The new manager will automatically send a L</"QUIT"> signal to the old manager
  and take over serving requests after starting up successfully.
  
  =head1 WORKER SIGNALS
  
  L<Mojo::Server::Hypnotoad> worker processes can be controlled at runtime with
  the following signals.
  
  =head2 QUIT
  
  Stop worker gracefully.
  
  =head1 SETTINGS
  
  L<Mojo::Server::Hypnotoad> can be configured with the following settings, see
  L<Mojolicious::Guides::Cookbook/"Hypnotoad"> for examples.
  
  =head2 accepts
  
    accepts => 100
  
  Maximum number of connections a worker is allowed to accept, before stopping
  gracefully and then getting replaced with a newly started worker, defaults to
  the value of L<Mojo::Server::Prefork/"accepts">. Setting the value to C<0> will
  allow workers to accept new connections indefinitely. Note that up to half of
  this value can be subtracted randomly to improve load balancing, and to make
  sure that not all workers restart at the same time.
  
  =head2 backlog
  
    backlog => 128
  
  Listen backlog size, defaults to the value of
  L<Mojo::Server::Daemon/"backlog">.
  
  =head2 clients
  
    clients => 100
  
  Maximum number of accepted connections each worker process is allowed to handle
  concurrently, before stopping to accept new incoming connections, defaults to
  the value of L<Mojo::IOLoop/"max_connections">. Note that high concurrency works
  best with applications that perform mostly non-blocking operations, to optimize
  for blocking operations you can decrease this value and increase L</"workers">
  instead for better performance.
  
  =head2 graceful_timeout
  
    graceful_timeout => 15
  
  Maximum amount of time in seconds stopping a worker gracefully may take before
  being forced, defaults to the value of
  L<Mojo::Server::Prefork/"graceful_timeout">. Note that this value should usually
  be a little larger than the maximum amount of time you expect any one request to
  take.
  
  =head2 heartbeat_interval
  
    heartbeat_interval => 3
  
  Heartbeat interval in seconds, defaults to the value of
  L<Mojo::Server::Prefork/"heartbeat_interval">.
  
  =head2 heartbeat_timeout
  
    heartbeat_timeout => 2
  
  Maximum amount of time in seconds before a worker without a heartbeat will be
  stopped gracefully, defaults to the value of
  L<Mojo::Server::Prefork/"heartbeat_timeout">. Note that this value should
  usually be a little larger than the maximum amount of time you expect any one
  operation to block the event loop.
  
  =head2 inactivity_timeout
  
    inactivity_timeout => 10
  
  Maximum amount of time in seconds a connection can be inactive before getting
  closed, defaults to the value of L<Mojo::Server::Daemon/"inactivity_timeout">.
  Setting the value to C<0> will allow connections to be inactive indefinitely.
  
  =head2 listen
  
    listen => ['http://*:80']
  
  Array reference with one or more locations to listen on, defaults to
  C<http://*:8080>. See also L<Mojo::Server::Daemon/"listen"> for more examples.
  
  =head2 pid_file
  
    pid_file => '/var/run/hypnotoad.pid'
  
  Full path to process id file, defaults to C<hypnotoad.pid> in the same
  directory as the application. Note that this value can only be changed after
  the server has been stopped.
  
  =head2 proxy
  
    proxy => 1
  
  Activate reverse proxy support, which allows for the C<X-Forwarded-For> and
  C<X-Forwarded-Proto> headers to be picked up automatically, defaults to the
  value of L<Mojo::Server/"reverse_proxy">.
  
  =head2 requests
  
    requests => 50
  
  Number of keep-alive requests per connection, defaults to the value of
  L<Mojo::Server::Daemon/"max_requests">.
  
  =head2 spare
  
    spare => 4
  
  Temporarily spawn up to this number of additional workers if there is a need,
  defaults to the value of L<Mojo::Server::Prefork/"spare">. This allows for new
  workers to be started while old ones are still shutting down gracefully,
  drastically reducing the performance cost of worker restarts.
  
  =head2 upgrade_timeout
  
    upgrade_timeout => 45
  
  Maximum amount of time in seconds a zero downtime software upgrade may take
  before getting canceled, defaults to C<180>.
  
  =head2 workers
  
    workers => 10
  
  Number of worker processes, defaults to the value of
  L<Mojo::Server::Prefork/"workers">. A good rule of thumb is two worker
  processes per CPU core for applications that perform mostly non-blocking
  operations, blocking operations often require more and benefit from decreasing
  concurrency with L</"clients"> (often as low as C<1>). Note that during zero
  downtime software upgrades there will be twice as many workers active for a
  short amount of time.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::Hypnotoad> implements the following attributes.
  
  =head2 prefork
  
    my $prefork = $hypnotoad->prefork;
    $hypnotoad  = $hypnotoad->prefork(Mojo::Server::Prefork->new);
  
  L<Mojo::Server::Prefork> object this server manages.
  
  =head2 upgrade_timeout
  
    my $timeout = $hypnotoad->upgrade_timeout;
    $hypnotoad  = $hypnotoad->upgrade_timeout(15);
  
  Maximum amount of time in seconds a zero downtime software upgrade may take
  before getting canceled, defaults to C<180>.
  
  =head1 METHODS
  
  L<Mojo::Server::Hypnotoad> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 configure
  
    $hypnotoad->configure('hypnotoad');
  
  Configure server from application settings.
  
  =head2 run
  
    $hypnotoad->run('script/my_app');
  
  Run server for application and wait for L</"MANAGER SIGNALS">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_SERVER_HYPNOTOAD

$fatpacked{"Mojo/Server/Morbo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_MORBO';
  package Mojo::Server::Morbo;
  use Mojo::Base -base;
  
  # "Linda: With Haley's Comet out of ice, Earth is experiencing the devastating
  #         effects of sudden, intense global warming.
  #  Morbo: Morbo is pleased but sticky."
  use Mojo::Loader 'load_class';
  use Mojo::Server::Daemon;
  use POSIX 'WNOHANG';
  
  has backend => sub {
    my $backend = $ENV{MOJO_MORBO_BACKEND} || 'Poll';
    $backend = "Mojo::Server::Morbo::Backend::$backend";
    return $backend->new unless my $e = load_class $backend;
    die $e if ref $e;
    die qq{Can't find Morbo backend class "$backend" in \@INC. (@INC)\n};
  };
  has daemon => sub { Mojo::Server::Daemon->new };
  
  sub run {
    my ($self, $app) = @_;
  
    # Clean manager environment
    local $SIG{INT} = local $SIG{TERM} = sub {
      $self->{finished} = 1;
      kill 'TERM', $self->{worker} if $self->{worker};
    };
    unshift @{$self->backend->watch}, $0 = $app;
    $self->{modified} = 1;
  
    # Prepare and cache listen sockets for smooth restarting
    $self->daemon->start->stop;
  
    $self->_manage until $self->{finished} && !$self->{worker};
    exit 0;
  }
  
  sub _manage {
    my $self = shift;
  
    if (my @files = @{$self->backend->modified_files}) {
      say @files == 1
        ? qq{File "@{[$files[0]]}" changed, restarting.}
        : qq{@{[scalar @files]} files changed, restarting.}
        if $ENV{MORBO_VERBOSE};
      kill 'TERM', $self->{worker} if $self->{worker};
      $self->{modified} = 1;
    }
  
    if (my $pid = $self->{worker}) {
      delete $self->{worker} if waitpid($pid, WNOHANG) == $pid;
    }
  
    $self->_spawn if !$self->{worker} && delete $self->{modified};
  }
  
  sub _spawn {
    my $self = shift;
  
    # Manager
    my $manager = $$;
    die "Can't fork: $!" unless defined(my $pid = $self->{worker} = fork);
    return if $pid;
  
    # Worker
    my $daemon = $self->daemon;
    $daemon->load_app($self->backend->watch->[0]);
    $daemon->ioloop->recurring(1 => sub { shift->stop unless kill 0, $manager });
    $daemon->run;
    exit 0;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::Morbo - Tonight at 11...DOOOOOOOOOOOOOOOM!
  
  =head1 SYNOPSIS
  
    use Mojo::Server::Morbo;
  
    my $morbo = Mojo::Server::Morbo->new;
    $morbo->run('/home/sri/myapp.pl');
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::Morbo> is a full featured, self-restart capable non-blocking
  I/O HTTP and WebSocket server, built around the very well tested and reliable
  L<Mojo::Server::Daemon>, with IPv6, TLS, SNI, UNIX domain socket, Comet (long
  polling), keep-alive and multiple event loop support. Note that the server uses
  signals for process management, so you should avoid modifying signal handlers in
  your applications.
  
  To start applications with it you can use the L<morbo> script.
  
    $ morbo ./myapp.pl
    Server available at http://127.0.0.1:3000
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (2.009+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NNR>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 SIGNALS
  
  The L<Mojo::Server::Morbo> process can be controlled at runtime with the
  following signals.
  
  =head2 INT, TERM
  
  Shut down server immediately.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::Morbo> implements the following attributes.
  
  =head2 backend
  
    my $backend = $morbo->backend;
    $morbo      = $morbo->backend(Mojo::Server::Morbo::Backend::Poll->new);
  
  Backend, usually a L<Mojo::Server::Morbo::Backend::Poll> object.
  
  =head2 daemon
  
    my $daemon = $morbo->daemon;
    $morbo     = $morbo->daemon(Mojo::Server::Daemon->new);
  
  L<Mojo::Server::Daemon> object this server manages.
  
  =head1 METHODS
  
  L<Mojo::Server::Morbo> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 run
  
    $morbo->run('script/my_app');
  
  Run server for application and wait for L</"SIGNALS">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_SERVER_MORBO

$fatpacked{"Mojo/Server/Morbo/Backend.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_MORBO_BACKEND';
  package Mojo::Server::Morbo::Backend;
  use Mojo::Base -base;
  
  use Carp 'croak';
  
  has watch => sub { [qw(lib templates)] };
  has watch_timeout => sub { $ENV{MOJO_MORBO_TIMEOUT} || 1 };
  
  sub modified_files {
    croak 'Method "modified_files" not implemented by subclass';
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::Morbo::Backend - Morbo backend base class
  
  =head1 SYNOPSIS
  
    package Mojo::Server::Morbo::Backend::Inotify:
    use Mojo::Base 'Mojo::Server::Morbo::Backend';
  
    sub modified_files {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::Morbo::Backend> is an abstract base class for Morbo backends,
  like L<Mojo::Server::Morbo::Backend::Poll>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::Morbo::Backend> implements the following attributes.
  
  =head2 watch
  
    my $watch = $backend->watch;
    $backend  = $backend->watch(['/home/sri/my_app']);
  
  Files and directories to watch for changes, defaults to the application script
  as well as the C<lib> and C<templates> directories in the current working
  directory.
  
  =head2 watch_timeout
  
    my $timeout = $backend->watch_timeout;
    $backend    = $backend->watch_timeout(10);
  
  Maximum amount of time in seconds a backend may block when waiting for files to
  change, defaults to the value of the C<MOJO_MORBO_TIMEOUT> environment variable
  or C<1>.
  
  =head1 METHODS
  
  L<Mojo::Server::Morbo::Backend> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 modified_files
  
    my $files = $backend->modified_files;
  
  Check if files from L</"watch"> have been modified since the last check and
  return an array reference with the results. Meant to be overloaded in a
  subclass.
  
    # All files that have been modified
    say for @{$backend->modified_files};
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_SERVER_MORBO_BACKEND

$fatpacked{"Mojo/Server/Morbo/Backend/Poll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_MORBO_BACKEND_POLL';
  package Mojo::Server::Morbo::Backend::Poll;
  use Mojo::Base 'Mojo::Server::Morbo::Backend';
  
  use Mojo::File 'path';
  
  sub modified_files {
    my $self = shift;
  
    my $cache = $self->{cache} ||= {};
    my @files;
    for my $file (map { -f $_ && -r _ ? $_ : _list($_) } @{$self->watch}) {
      my ($size, $mtime) = (stat $file)[7, 9];
      next unless defined $size and defined $mtime;
      my $stats = $cache->{$file} ||= [$^T, $size];
      next if $mtime <= $stats->[0] && $size == $stats->[1];
      @$stats = ($mtime, $size);
      push @files, $file;
    }
    sleep $self->watch_timeout unless @files;
  
    return \@files;
  }
  
  sub _list { path(shift)->list_tree->map('to_string')->each }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::Morbo::Backend::Poll - Morbo default backend
  
  =head1 SYNOPSIS
  
    use Mojo::Server::Morbo::Backend::Poll;
  
    my $backend = Mojo::Server::Morbo::Backend::Poll->new;
    if (my $files = $backend->modified_files) {
      ...
    }
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::Morbo::Backend:Poll> is the default backend for
  L<Mojo::Server::Morbo>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::Morbo::Backend::Poll> inherits all attributes from
  L<Mojo::Server::Morbo::Backend>.
  
  =head1 METHODS
  
  L<Mojo::Server::Morbo::Backend::Poll> inherits all methods from
  L<Mojo::Server::Morbo::Backend> and implements the following new ones.
  
  =head2 modified_files
  
    my $files = $backend->modified_files;
  
  Check file size and mtime to determine which files have changed, this is not
  particularly efficient, but very portable.
  
    # All files that have been modified
    say for @{$backend->modified_files};
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_SERVER_MORBO_BACKEND_POLL

$fatpacked{"Mojo/Server/PSGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_PSGI';
  package Mojo::Server::PSGI;
  use Mojo::Base 'Mojo::Server';
  
  sub run {
    my ($self, $env) = @_;
  
    my $tx  = $self->build_tx;
    my $req = $tx->req->parse($env);
    $tx->local_port($env->{SERVER_PORT})->remote_address($env->{REMOTE_ADDR});
  
    # Request body (may block if we try to read too much)
    my $len = $env->{CONTENT_LENGTH};
    until ($req->is_finished) {
      my $chunk = ($len && $len < 131072) ? $len : 131072;
      last unless my $read = $env->{'psgi.input'}->read(my $buffer, $chunk, 0);
      $req->parse($buffer);
      last if ($len -= $read) <= 0;
    }
  
    $self->emit(request => $tx);
  
    # Response headers
    my $res  = $tx->res->fix_headers;
    my $hash = $res->headers->to_hash(1);
    my @headers;
    for my $name (keys %$hash) { push @headers, $name, $_ for @{$hash->{$name}} }
  
    # PSGI response
    my $io = Mojo::Server::PSGI::_IO->new(tx => $tx, empty => $tx->is_empty);
    return [$res->code // 404, \@headers, $io];
  }
  
  sub to_psgi_app {
    my $self = shift;
  
    # Preload application and wrap it
    $self->app->server($self);
    return sub { $self->run(@_) }
  }
  
  package Mojo::Server::PSGI::_IO;
  use Mojo::Base -base;
  
  # Finish transaction
  sub close { shift->{tx}->closed }
  
  sub getline {
    my $self = shift;
  
    # Empty
    return undef if $self->{empty};
  
    # No content yet, try again later
    my $chunk = $self->{tx}->res->get_body_chunk($self->{offset} //= 0);
    return '' unless defined $chunk;
  
    # End of content
    return undef unless length $chunk;
  
    $self->{offset} += length $chunk;
    return $chunk;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::PSGI - PSGI server
  
  =head1 SYNOPSIS
  
    use Mojo::Server::PSGI;
  
    my $psgi = Mojo::Server::PSGI->new;
    $psgi->unsubscribe('request')->on(request => sub {
      my ($psgi, $tx) = @_;
  
      # Request
      my $method = $tx->req->method;
      my $path   = $tx->req->url->path;
  
      # Response
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body("$method request for $path!");
  
      # Resume transaction
      $tx->resume;
    });
    my $app = $psgi->to_psgi_app;
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::PSGI> allows L<Mojolicious> applications to run on all L<PSGI>
  compatible servers.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 EVENTS
  
  L<Mojo::Server::PSGI> inherits all events from L<Mojo::Server>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::PSGI> inherits all attributes from L<Mojo::Server>.
  
  =head1 METHODS
  
  L<Mojo::Server::PSGI> inherits all methods from L<Mojo::Server> and implements
  the following new ones.
  
  =head2 run
  
    my $res = $psgi->run($env);
  
  Run L<PSGI>.
  
  =head2 to_psgi_app
  
    my $app = $psgi->to_psgi_app;
  
  Turn L<Mojolicious> application into L<PSGI> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_SERVER_PSGI

$fatpacked{"Mojo/Server/Prefork.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_PREFORK';
  package Mojo::Server::Prefork;
  use Mojo::Base 'Mojo::Server::Daemon';
  
  use Config;
  use File::Spec::Functions 'tmpdir';
  use Mojo::File 'path';
  use Mojo::Util 'steady_time';
  use POSIX 'WNOHANG';
  use Scalar::Util 'weaken';
  
  has accepts            => 10000;
  has cleanup            => 1;
  has graceful_timeout   => 120;
  has heartbeat_timeout  => 30;
  has heartbeat_interval => 5;
  has pid_file           => sub { path(tmpdir, 'prefork.pid')->to_string };
  has spare              => 2;
  has workers            => 4;
  
  sub DESTROY { unlink $_[0]->pid_file if $_[0]->cleanup }
  
  sub check_pid {
    my $file = shift->pid_file;
    return undef unless open my $handle, '<', $file;
    my $pid = <$handle>;
    chomp $pid;
  
    # Running
    return $pid if $pid && kill 0, $pid;
  
    # Not running
    unlink $file;
    return undef;
  }
  
  sub ensure_pid_file {
    my ($self, $pid) = @_;
  
    # Check if PID file already exists
    return if -e (my $file = $self->pid_file);
  
    # Create PID file
    $self->app->log->error(qq{Can't create process id file "$file": $!})
      and die qq{Can't create process id file "$file": $!}
      unless open my $handle, '>', $file;
    $self->app->log->info(qq{Creating process id file "$file"});
    chmod 0644, $handle;
    print $handle "$pid\n";
  }
  
  sub healthy {
    scalar grep { $_->{healthy} } values %{shift->{pool}};
  }
  
  sub run {
    my $self = shift;
  
    # No fork emulation support
    say 'Pre-forking does not support fork emulation.' and exit 0
      if $Config{d_pseudofork};
  
    # Pipe for worker communication
    pipe($self->{reader}, $self->{writer}) or die "Can't create pipe: $!";
  
    # Clean manager environment
    local $SIG{CHLD} = sub {
      while ((my $pid = waitpid -1, WNOHANG) > 0) {
        $self->emit(reap => $pid)->_stopped($pid);
      }
    };
    local $SIG{INT} = local $SIG{TERM} = sub { $self->_term };
    local $SIG{QUIT} = sub { $self->_term(1) };
    local $SIG{TTIN} = sub { $self->workers($self->workers + 1) };
    local $SIG{TTOU} = sub {
      $self->workers > 0 ? $self->workers($self->workers - 1) : return;
      for my $w (values %{$self->{pool}}) {
        ($w->{graceful} = steady_time) and last unless $w->{graceful};
      }
    };
  
    # Preload application before starting workers
    $self->start->app->log->info("Manager $$ started");
    $self->ioloop->max_accepts($self->accepts);
    $self->{running} = 1;
    $self->_manage while $self->{running};
    $self->app->log->info("Manager $$ stopped");
  }
  
  sub _heartbeat { shift->{writer}->syswrite("$$:$_[0]\n") or exit 0 }
  
  sub _manage {
    my $self = shift;
  
    # Spawn more workers if necessary and check PID file
    if (!$self->{finished}) {
      my $graceful = grep { $_->{graceful} } values %{$self->{pool}};
      my $spare = $self->spare;
      $spare = $graceful ? $graceful > $spare ? $spare : $graceful : 0;
      my $need = ($self->workers - keys %{$self->{pool}}) + $spare;
      $self->_spawn while $need-- > 0;
      $self->ensure_pid_file($$);
    }
  
    # Shutdown
    elsif (!keys %{$self->{pool}}) { return delete $self->{running} }
  
    # Wait for heartbeats
    $self->_wait;
  
    my $interval = $self->heartbeat_interval;
    my $ht       = $self->heartbeat_timeout;
    my $gt       = $self->graceful_timeout;
    my $log      = $self->app->log;
    my $time     = steady_time;
  
    for my $pid (keys %{$self->{pool}}) {
      next unless my $w = $self->{pool}{$pid};
  
      # No heartbeat (graceful stop)
      $log->error("Worker $pid has no heartbeat ($ht seconds), restarting")
        and $w->{graceful} = $time
        if !$w->{graceful} && ($w->{time} + $interval + $ht <= $time);
  
      # Graceful stop with timeout
      my $graceful = $w->{graceful} ||= $self->{graceful} ? $time : undef;
      $log->info("Stopping worker $pid gracefully ($gt seconds)")
        and (kill 'QUIT', $pid or $self->_stopped($pid))
        if $graceful && !$w->{quit}++;
      $w->{force} = 1 if $graceful && $graceful + $gt <= $time;
  
      # Normal stop
      $log->warn("Stopping worker $pid immediately")
        and (kill 'KILL', $pid or $self->_stopped($pid))
        if $w->{force} || ($self->{finished} && !$graceful);
    }
  }
  
  sub _spawn {
    my $self = shift;
  
    # Manager
    die "Can't fork: $!" unless defined(my $pid = fork);
    return $self->emit(spawn => $pid)->{pool}{$pid} = {time => steady_time}
      if $pid;
  
    # Heartbeat messages
    my $loop     = $self->cleanup(0)->ioloop;
    my $finished = 0;
    $loop->on(finish => sub { $finished = 1 });
    weaken $self;
    my $cb = sub { $self->_heartbeat($finished) };
    $loop->next_tick($cb);
    $loop->recurring($self->heartbeat_interval => $cb);
  
    # Clean worker environment
    $SIG{$_} = 'DEFAULT' for qw(CHLD INT TERM TTIN TTOU);
    $SIG{QUIT} = sub { $loop->stop_gracefully };
    $loop->on(finish => sub { $self->max_requests(1)->close_connections });
    delete $self->{reader};
    srand;
  
    $self->app->log->info("Worker $$ started");
    $loop->start;
    exit 0;
  }
  
  sub _stopped {
    my ($self, $pid) = @_;
  
    return unless my $w = delete $self->{pool}{$pid};
  
    my $log = $self->app->log;
    $log->info("Worker $pid stopped");
    $log->error("Worker $pid stopped too early, shutting down") and $self->_term
      unless $w->{healthy};
  }
  
  sub _term {
    my ($self, $graceful) = @_;
    @{$self->emit(finish => $graceful)}{qw(finished graceful)} = (1, $graceful);
  }
  
  sub _wait {
    my $self = shift;
  
    # Poll for heartbeats
    my $reader = $self->emit('wait')->{reader};
    return unless Mojo::Util::_readable(1000, fileno($reader));
    return unless $reader->sysread(my $chunk, 4194304);
  
    # Update heartbeats (and stop gracefully if necessary)
    my $time = steady_time;
    while ($chunk =~ /(\d+):(\d)\n/g) {
      next unless my $w = $self->{pool}{$1};
      @$w{qw(healthy time)} = (1, $time) and $self->emit(heartbeat => $1);
      $w->{graceful} ||= $time if $2;
    }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::Prefork - Pre-forking non-blocking I/O HTTP and WebSocket server
  
  =head1 SYNOPSIS
  
    use Mojo::Server::Prefork;
  
    my $prefork = Mojo::Server::Prefork->new(listen => ['http://*:8080']);
    $prefork->unsubscribe('request')->on(request => sub {
      my ($prefork, $tx) = @_;
  
      # Request
      my $method = $tx->req->method;
      my $path   = $tx->req->url->path;
  
      # Response
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body("$method request for $path!");
  
      # Resume transaction
      $tx->resume;
    });
    $prefork->run;
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::Prefork> is a full featured, UNIX optimized, pre-forking
  non-blocking I/O HTTP and WebSocket server, built around the very well tested
  and reliable L<Mojo::Server::Daemon>, with IPv6, TLS, SNI, UNIX domain socket,
  Comet (long polling), keep-alive and multiple event loop support. Note that the
  server uses signals for process management, so you should avoid modifying signal
  handlers in your applications.
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (1.84+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NNR>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 MANAGER SIGNALS
  
  The L<Mojo::Server::Prefork> manager process can be controlled at runtime with
  the following signals.
  
  =head2 INT, TERM
  
  Shut down server immediately.
  
  =head2 QUIT
  
  Shut down server gracefully.
  
  =head2 TTIN
  
  Increase worker pool by one.
  
  =head2 TTOU
  
  Decrease worker pool by one.
  
  =head1 WORKER SIGNALS
  
  L<Mojo::Server::Prefork> worker processes can be controlled at runtime with the
  following signals.
  
  =head2 QUIT
  
  Stop worker gracefully.
  
  =head1 EVENTS
  
  L<Mojo::Server::Prefork> inherits all events from L<Mojo::Server::Daemon> and
  can emit the following new ones.
  
  =head2 finish
  
    $prefork->on(finish => sub {
      my ($prefork, $graceful) = @_;
      ...
    });
  
  Emitted when the server shuts down.
  
    $prefork->on(finish => sub {
      my ($prefork, $graceful) = @_;
      say $graceful ? 'Graceful server shutdown' : 'Server shutdown';
    });
  
  =head2 heartbeat
  
    $prefork->on(heartbeat => sub {
      my ($prefork, $pid) = @_;
      ...
    });
  
  Emitted when a heartbeat message has been received from a worker.
  
    $prefork->on(heartbeat => sub {
      my ($prefork, $pid) = @_;
      say "Worker $pid has a heartbeat";
    });
  
  =head2 reap
  
    $prefork->on(reap => sub {
      my ($prefork, $pid) = @_;
      ...
    });
  
  Emitted when a child process exited.
  
    $prefork->on(reap => sub {
      my ($prefork, $pid) = @_;
      say "Worker $pid stopped";
    });
  
  =head2 spawn
  
    $prefork->on(spawn => sub {
      my ($prefork, $pid) = @_;
      ...
    });
  
  Emitted when a worker process is spawned.
  
    $prefork->on(spawn => sub {
      my ($prefork, $pid) = @_;
      say "Worker $pid started";
    });
  
  =head2 wait
  
    $prefork->on(wait => sub {
      my $prefork = shift;
      ...
    });
  
  Emitted when the manager starts waiting for new heartbeat messages.
  
    $prefork->on(wait => sub {
      my $prefork = shift;
      my $workers = $prefork->workers;
      say "Waiting for heartbeat messages from $workers workers";
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::Prefork> inherits all attributes from L<Mojo::Server::Daemon>
  and implements the following new ones.
  
  =head2 accepts
  
    my $accepts = $prefork->accepts;
    $prefork    = $prefork->accepts(100);
  
  Maximum number of connections a worker is allowed to accept, before stopping
  gracefully and then getting replaced with a newly started worker, passed along
  to L<Mojo::IOLoop/"max_accepts">, defaults to C<10000>. Setting the value to
  C<0> will allow workers to accept new connections indefinitely. Note that up to
  half of this value can be subtracted randomly to improve load balancing, and to
  make sure that not all workers restart at the same time.
  
  =head2 cleanup
  
    my $bool = $prefork->cleanup;
    $prefork = $prefork->cleanup($bool);
  
  Delete L</"pid_file"> automatically once it is not needed anymore, defaults to
  a true value.
  
  =head2 graceful_timeout
  
    my $timeout = $prefork->graceful_timeout;
    $prefork    = $prefork->graceful_timeout(15);
  
  Maximum amount of time in seconds stopping a worker gracefully may take before
  being forced, defaults to C<120>. Note that this value should usually be a
  little larger than the maximum amount of time you expect any one request to
  take.
  
  =head2 heartbeat_interval
  
    my $interval = $prefork->heartbeat_interval;
    $prefork     = $prefork->heartbeat_interval(3);
  
  Heartbeat interval in seconds, defaults to C<5>.
  
  =head2 heartbeat_timeout
  
    my $timeout = $prefork->heartbeat_timeout;
    $prefork    = $prefork->heartbeat_timeout(2);
  
  Maximum amount of time in seconds before a worker without a heartbeat will be
  stopped gracefully, defaults to C<30>. Note that this value should usually be a
  little larger than the maximum amount of time you expect any one operation to
  block the event loop.
  
  =head2 pid_file
  
    my $file = $prefork->pid_file;
    $prefork = $prefork->pid_file('/tmp/prefork.pid');
  
  Full path of process id file, defaults to C<prefork.pid> in a temporary
  directory.
  
  =head2 spare
  
    my $spare = $prefork->spare;
    $prefork  = $prefork->spare(4);
  
  Temporarily spawn up to this number of additional workers if there is a need,
  defaults to C<2>. This allows for new workers to be started while old ones are
  still shutting down gracefully, drastically reducing the performance cost of
  worker restarts.
  
  =head2 workers
  
    my $workers = $prefork->workers;
    $prefork    = $prefork->workers(10);
  
  Number of worker processes, defaults to C<4>. A good rule of thumb is two
  worker processes per CPU core for applications that perform mostly non-blocking
  operations, blocking operations often require more and benefit from decreasing
  concurrency with L<Mojo::Server::Daemon/"clients"> (often as low as C<1>).
  
  =head1 METHODS
  
  L<Mojo::Server::Prefork> inherits all methods from L<Mojo::Server::Daemon> and
  implements the following new ones.
  
  =head2 check_pid
  
    my $pid = $prefork->check_pid;
  
  Get process id for running server from L</"pid_file"> or delete it if server is
  not running.
  
    say 'Server is not running' unless $prefork->check_pid;
  
  =head2 ensure_pid_file
  
    $prefork->ensure_pid_file($pid);
  
  Ensure L</"pid_file"> exists.
  
  =head2 healthy
  
    my $healthy = $prefork->healthy;
  
  Number of currently active worker processes with a heartbeat.
  
  =head2 run
  
    $prefork->run;
  
  Run server and wait for L</"MANAGER SIGNALS">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_SERVER_PREFORK

$fatpacked{"Mojo/Template.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_TEMPLATE';
  package Mojo::Template;
  use Mojo::Base -base;
  
  use Carp 'croak';
  use Mojo::ByteStream;
  use Mojo::Exception;
  use Mojo::File 'path';
  use Mojo::Util qw(decode encode monkey_patch);
  
  use constant DEBUG => $ENV{MOJO_TEMPLATE_DEBUG} || 0;
  
  has [qw(append code prepend unparsed)] => '';
  has [qw(auto_escape compiled vars)];
  has capture_end   => 'end';
  has capture_start => 'begin';
  has comment_mark  => '#';
  has encoding      => 'UTF-8';
  has escape        => sub { \&Mojo::Util::xml_escape };
  has [qw(escape_mark expression_mark trim_mark)] => '=';
  has [qw(line_start replace_mark)] => '%';
  has name      => 'template';
  has namespace => 'Mojo::Template::SandBox';
  has tag_start => '<%';
  has tag_end   => '%>';
  has tree      => sub { [] };
  
  sub parse {
    my ($self, $template) = @_;
  
    # Clean start
    $self->unparsed($template)->tree(\my @tree)->compiled(undef);
  
    my $tag     = $self->tag_start;
    my $replace = $self->replace_mark;
    my $expr    = $self->expression_mark;
    my $escp    = $self->escape_mark;
    my $cpen    = $self->capture_end;
    my $cmnt    = $self->comment_mark;
    my $cpst    = $self->capture_start;
    my $trim    = $self->trim_mark;
    my $end     = $self->tag_end;
    my $start   = $self->line_start;
  
    my $line_re
      = qr/^(\s*)\Q$start\E(?:(\Q$replace\E)|(\Q$cmnt\E)|(\Q$expr\E))?(.*)$/;
    my $token_re = qr/
      (
        \Q$tag\E(?:\Q$replace\E|\Q$cmnt\E)                   # Replace
      |
        \Q$tag$expr\E(?:\Q$escp\E)?(?:\s*\Q$cpen\E(?!\w))?   # Expression
      |
        \Q$tag\E(?:\s*\Q$cpen\E(?!\w))?                      # Code
      |
        (?:(?<!\w)\Q$cpst\E\s*)?(?:\Q$trim\E)?\Q$end\E       # End
      )
    /x;
    my $cpen_re = qr/^\Q$tag\E(?:\Q$expr\E)?(?:\Q$escp\E)?\s*\Q$cpen\E(.*)$/;
    my $end_re  = qr/^(?:(\Q$cpst\E)\s*)?(\Q$trim\E)?\Q$end\E$/;
  
    # Split lines
    my $op = 'text';
    my ($trimming, $capture);
    for my $line (split "\n", $template) {
  
      # Turn Perl line into mixed line
      if ($op eq 'text' && $line =~ $line_re) {
  
        # Escaped start
        if ($2) { $line = "$1$start$5" }
  
        # Comment
        elsif ($3) { $line = "$tag$3 $trim$end" }
  
        # Expression or code
        else { $line = $4 ? "$1$tag$4$5 $end" : "$tag$5 $trim$end" }
      }
  
      # Escaped line ending
      $line .= "\n" if $line !~ s/\\\\$/\\\n/ && $line !~ s/\\$//;
  
      # Mixed line
      for my $token (split $token_re, $line) {
  
        # Capture end
        ($token, $capture) = ("$tag$1", 1) if $token =~ $cpen_re;
  
        # End
        if ($op ne 'text' && $token =~ $end_re) {
  
          # Capture start
          splice @tree, -1, 0, ['cpst'] if $1;
  
          # Trim left side
          _trim(\@tree) if ($trimming = $2) && @tree > 1;
  
          # Hint at end
          push @tree, [$op = 'text', ''];
        }
  
        # Code
        elsif ($token eq $tag) { $op = 'code' }
  
        # Expression
        elsif ($token eq "$tag$expr") { $op = 'expr' }
  
        # Expression that needs to be escaped
        elsif ($token eq "$tag$expr$escp") { $op = 'escp' }
  
        # Comment
        elsif ($token eq "$tag$cmnt") { $op = 'cmnt' }
  
        # Text (comments are just ignored)
        elsif ($op ne 'cmnt') {
  
          # Replace
          $token = $tag if $token eq "$tag$replace";
  
          # Trim right side (convert whitespace to line noise)
          if ($trimming && $token =~ s/^(\s+)//) {
            push @tree, ['code', $1];
            $trimming = 0;
          }
  
          # Token (with optional capture end)
          push @tree, $capture ? ['cpen'] : (), [$op, $token];
          $capture = 0;
        }
      }
  
      # Optimize successive text lines separated by a newline
      push @tree, ['line'] and next
        if $tree[-4] && $tree[-4][0] ne 'line'
        || (!$tree[-3] || $tree[-3][0] ne 'text' || $tree[-3][1] !~ /\n$/)
        || ($tree[-2][0] ne 'line' || $tree[-1][0] ne 'text');
      $tree[-3][1] .= pop(@tree)->[1];
    }
  
    return $self;
  }
  
  sub process {
    my $self = shift;
  
    # Use a local stack trace for compile exceptions
    my $compiled = $self->compiled;
    unless ($compiled) {
      my $code = $self->_compile->code;
      monkey_patch $self->namespace, '_escape', $self->escape;
      return Mojo::Exception->new($@)->inspect($self->unparsed, $code)
        ->trace->verbose(1)
        unless $compiled = eval $self->_wrap($code, @_);
      $self->compiled($compiled);
    }
  
    # Use a real stack trace for normal exceptions
    local $SIG{__DIE__} = sub {
      CORE::die $_[0] if ref $_[0];
      CORE::die Mojo::Exception->new(shift)
        ->trace->inspect($self->unparsed, $self->code)->verbose(1);
    };
  
    my $output;
    return eval { $output = $compiled->(@_); 1 } ? $output : $@;
  }
  
  sub render { shift->parse(shift)->process(@_) }
  
  sub render_file {
    my ($self, $path) = (shift, shift);
  
    $self->name($path) unless defined $self->{name};
    my $template = path($path)->slurp;
    my $encoding = $self->encoding;
    croak qq{Template "$path" has invalid encoding}
      if $encoding && !defined($template = decode $encoding, $template);
  
    return $self->render($template, @_);
  }
  
  sub _compile {
    my $self = shift;
  
    my $tree   = $self->tree;
    my $escape = $self->auto_escape;
  
    my @blocks = ('');
    my ($i, $capture, $multi);
    while (++$i <= @$tree && (my $next = $tree->[$i])) {
      my ($op, $value) = @{$tree->[$i - 1]};
      push @blocks, '' and next if $op eq 'line';
      my $newline = chomp($value //= '');
  
      # Text (quote and fix line ending)
      if ($op eq 'text') {
        $value = join "\n", map { quotemeta $_ } split("\n", $value, -1);
        $value .= '\n' if $newline;
        $blocks[-1] .= "\$_O .= \"" . $value . "\";" if length $value;
      }
  
      # Code or multi-line expression
      elsif ($op eq 'code' || $multi) { $blocks[-1] .= $value }
  
      # Capture end
      elsif ($op eq 'cpen') {
        $blocks[-1] .= 'return Mojo::ByteStream->new($_O) }';
  
        # No following code
        $blocks[-1] .= ';' if ($next->[1] // '') =~ /^\s*$/;
      }
  
      # Expression
      if ($op eq 'expr' || $op eq 'escp') {
  
        # Escaped
        if (!$multi && ($op eq 'escp' && !$escape || $op eq 'expr' && $escape)) {
          $blocks[-1] .= "\$_O .= _escape scalar + $value";
        }
  
        # Raw
        elsif (!$multi) { $blocks[-1] .= "\$_O .= scalar + $value" }
  
        # Multi-line
        $multi = !$next || $next->[0] ne 'text';
  
        # Append semicolon
        $blocks[-1] .= ';' unless $multi || $capture;
      }
  
      # Capture start
      if ($op eq 'cpst') { $capture = 1 }
      elsif ($capture) {
        $blocks[-1] .= "sub { my \$_O = ''; ";
        $capture = 0;
      }
    }
  
    return $self->code(join "\n", @blocks)->tree([]);
  }
  
  sub _line {
    my $name = shift->name;
    $name =~ y/"//d;
    return qq{#line @{[shift]} "$name"};
  }
  
  sub _trim {
    my $tree = shift;
  
    # Skip captures
    my $i = $tree->[-2][0] eq 'cpst' || $tree->[-2][0] eq 'cpen' ? -3 : -2;
  
    # Only trim text
    return unless $tree->[$i][0] eq 'text';
  
    # Convert whitespace text to line noise
    splice @$tree, $i, 0, ['code', $1] if $tree->[$i][1] =~ s/(\s+)$//;
  }
  
  sub _wrap {
    my ($self, $body, $vars) = @_;
  
    # Variables
    my $args = '';
    if ($self->vars && (my @vars = grep {/^\w+$/} keys %$vars)) {
      $args = 'my (' . join(',', map {"\$$_"} @vars) . ')';
      $args .= '= @{shift()}{qw(' . join(' ', @vars) . ')};';
    }
  
    # Wrap lines
    my $num = () = $body =~ /\n/g;
    my $code = $self->_line(1) . "\npackage @{[$self->namespace]};";
    $code .= "use Mojo::Base -strict; no warnings 'ambiguous';";
    $code .= "sub { my \$_O = ''; @{[$self->prepend]};{ $args { $body\n";
    $code .= $self->_line($num + 1) . "\n;}@{[$self->append]}; } \$_O };";
  
    warn "-- Code for @{[$self->name]}\n@{[encode 'UTF-8', $code]}\n\n" if DEBUG;
    return $code;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Template - Perl-ish templates
  
  =head1 SYNOPSIS
  
    use Mojo::Template;
  
    # Use Perl modules
    my $mt = Mojo::Template->new;
    say $mt->render(<<'EOF');
    % use Time::Piece;
    <div>
      % my $now = localtime;
      Time: <%= $now->hms %>
    </div>
    EOF
  
    # Render with arguments
    say $mt->render(<<'EOF', [1 .. 13], 'Hello World!');
    % my ($numbers, $title) = @_;
    <div>
      <h1><%= $title %></h1>
      % for my $i (@$numbers) {
        Test <%= $i %>
      % }
    </div>
    EOF
  
    # Render with named variables
    say $mt->vars(1)->render(<<'EOF', {title => 'Hello World!'});
    <div>
      <h1><%= $title %></h1>
      %= 5 + 5
    </div>
    EOF
  
  =head1 DESCRIPTION
  
  L<Mojo::Template> is a minimalistic, fast, and very Perl-ish template engine,
  designed specifically for all those small tasks that come up during big
  projects. Like preprocessing a configuration file, generating text from heredocs
  and stuff like that.
  
  See L<Mojolicious::Guides::Rendering> for information on how to generate
  content with the L<Mojolicious> renderer.
  
  =head1 SYNTAX
  
  For all templates L<strict>, L<warnings>, L<utf8> and Perl 5.10
  L<features|feature> are automatically enabled.
  
    <% Perl code %>
    <%= Perl expression, replaced with result %>
    <%== Perl expression, replaced with XML escaped result %>
    <%# Comment, useful for debugging %>
    <%% Replaced with "<%", useful for generating templates %>
    % Perl code line, treated as "<% line =%>" (explained later)
    %= Perl expression line, treated as "<%= line %>"
    %== Perl expression line, treated as "<%== line %>"
    %# Comment line, useful for debugging
    %% Replaced with "%", useful for generating templates
  
  Escaping behavior can be reversed with the L</"auto_escape"> attribute, this is
  the default in L<Mojolicious> C<.ep> templates, for example.
  
    <%= Perl expression, replaced with XML escaped result %>
    <%== Perl expression, replaced with result %>
  
  L<Mojo::ByteStream> objects are always excluded from automatic escaping.
  
    % use Mojo::ByteStream 'b';
    <%= b('<div>excluded!</div>') %>
  
  Whitespace characters around tags can be trimmed by adding an additional equal
  sign to the end of a tag.
  
    <% for (1 .. 3) { %>
      <%= 'Trim all whitespace characters around this expression' =%>
    <% } %>
  
  Newline characters can be escaped with a backslash.
  
    This is <%= 1 + 1 %> a\
    single line
  
  And a backslash in front of a newline character can be escaped with another
  backslash.
  
    This will <%= 1 + 1 %> result\\
    in multiple\\
    lines
  
  A newline character gets appended automatically to every template, unless the
  last character is a backslash. And empty lines at the end of a template are
  ignored.
  
    There is <%= 1 + 1 %> no newline at the end here\
  
  You can capture whole template blocks for reuse later with the C<begin> and
  C<end> keywords. Just be aware that both keywords are part of the surrounding
  tag and not actual Perl code, so there can only be whitespace after C<begin>
  and before C<end>.
  
    <% my $block = begin %>
      <% my $name = shift; =%>
      Hello <%= $name %>.
    <% end %>
    <%= $block->('Baerbel') %>
    <%= $block->('Wolfgang') %>
  
  Perl lines can also be indented freely.
  
    % my $block = begin
      % my $name = shift;
      Hello <%= $name %>.
    % end
    %= $block->('Baerbel')
    %= $block->('Wolfgang')
  
  L<Mojo::Template> templates get compiled to a Perl subroutine, that means you
  can access arguments simply via C<@_>.
  
    % my ($foo, $bar) = @_;
    % my $x = shift;
    test 123 <%= $foo %>
  
  The compilation of templates to Perl code can make debugging a bit tricky, but
  L<Mojo::Template> will return L<Mojo::Exception> objects that stringify to
  error messages with context.
  
    Bareword "xx" not allowed while "strict subs" in use at template line 4.
    2: </head>
    3: <body>
    4: % my $i = 2; xx
    5: %= $i * 2
    6: </body>
  
  =head1 ATTRIBUTES
  
  L<Mojo::Template> implements the following attributes.
  
  =head2 auto_escape
  
    my $bool = $mt->auto_escape;
    $mt      = $mt->auto_escape($bool);
  
  Activate automatic escaping.
  
    # "&lt;html&gt;"
    Mojo::Template->new(auto_escape => 1)->render("<%= '<html>' %>");
  
  =head2 append
  
    my $code = $mt->append;
    $mt      = $mt->append('warn "Processed template"');
  
  Append Perl code to compiled template. Note that this code should not contain
  newline characters, or line numbers in error messages might end up being wrong.
  
  =head2 capture_end
  
    my $end = $mt->capture_end;
    $mt     = $mt->capture_end('end');
  
  Keyword indicating the end of a capture block, defaults to C<end>.
  
    <% my $block = begin %>
      Some data!
    <% end %>
  
  =head2 capture_start
  
    my $start = $mt->capture_start;
    $mt       = $mt->capture_start('begin');
  
  Keyword indicating the start of a capture block, defaults to C<begin>.
  
    <% my $block = begin %>
      Some data!
    <% end %>
  
  =head2 code
  
    my $code = $mt->code;
    $mt      = $mt->code($code);
  
  Perl code for template if available.
  
  =head2 comment_mark
  
    my $mark = $mt->comment_mark;
    $mt      = $mt->comment_mark('#');
  
  Character indicating the start of a comment, defaults to C<#>.
  
    <%# This is a comment %>
  
  =head2 compiled
  
    my $compiled = $mt->compiled;
    $mt          = $mt->compiled($compiled);
  
  Compiled template code if available.
  
  =head2 encoding
  
    my $encoding = $mt->encoding;
    $mt          = $mt->encoding('UTF-8');
  
  Encoding used for template files, defaults to C<UTF-8>.
  
  =head2 escape
  
    my $cb = $mt->escape;
    $mt    = $mt->escape(sub {...});
  
  A callback used to escape the results of escaped expressions, defaults to
  L<Mojo::Util/"xml_escape">.
  
    $mt->escape(sub {
      my $str = shift;
      return reverse $str;
    });
  
  =head2 escape_mark
  
    my $mark = $mt->escape_mark;
    $mt      = $mt->escape_mark('=');
  
  Character indicating the start of an escaped expression, defaults to C<=>.
  
    <%== $foo %>
  
  =head2 expression_mark
  
    my $mark = $mt->expression_mark;
    $mt      = $mt->expression_mark('=');
  
  Character indicating the start of an expression, defaults to C<=>.
  
    <%= $foo %>
  
  =head2 line_start
  
    my $start = $mt->line_start;
    $mt       = $mt->line_start('%');
  
  Character indicating the start of a code line, defaults to C<%>.
  
    % $foo = 23;
  
  =head2 name
  
    my $name = $mt->name;
    $mt      = $mt->name('foo.mt');
  
  Name of template currently being processed, defaults to C<template>. Note that
  this value should not contain quotes or newline characters, or error messages
  might end up being wrong.
  
  =head2 namespace
  
    my $namespace = $mt->namespace;
    $mt           = $mt->namespace('main');
  
  Namespace used to compile templates, defaults to C<Mojo::Template::SandBox>.
  Note that namespaces should only be shared very carefully between templates,
  since functions and global variables will not be cleared automatically.
  
  =head2 prepend
  
    my $code = $mt->prepend;
    $mt      = $mt->prepend('my $self = shift;');
  
  Prepend Perl code to compiled template. Note that this code should not contain
  newline characters, or line numbers in error messages might end up being wrong.
  
  =head2 replace_mark
  
    my $mark = $mt->replace_mark;
    $mt      = $mt->replace_mark('%');
  
  Character used for escaping the start of a tag or line, defaults to C<%>.
  
    <%% my $foo = 23; %>
  
  =head2 tag_start
  
    my $start = $mt->tag_start;
    $mt       = $mt->tag_start('<%');
  
  Characters indicating the start of a tag, defaults to C<E<lt>%>.
  
    <% $foo = 23; %>
  
  =head2 tag_end
  
    my $end = $mt->tag_end;
    $mt     = $mt->tag_end('%>');
  
  Characters indicating the end of a tag, defaults to C<%E<gt>>.
  
    <%= $foo %>
  
  =head2 tree
  
    my $tree = $mt->tree;
    $mt      = $mt->tree([['text', 'foo'], ['line']]);
  
  Template in parsed form if available. Note that this structure should only be
  used very carefully since it is very dynamic.
  
  =head2 trim_mark
  
    my $mark = $mt->trim_mark;
    $mt      = $mt->trim_mark('-');
  
  Character activating automatic whitespace trimming, defaults to C<=>.
  
    <%= $foo =%>
  
  =head2 unparsed
  
    my $unparsed = $mt->unparsed;
    $mt          = $mt->unparsed('<%= 1 + 1 %>');
  
  Raw unparsed template if available.
  
  =head2 vars
  
    my $bool = $mt->vars;
    $mt      = $mt->vars($bool);
  
  Instead of a list of values, use a hash reference with named variables to pass
  data to templates.
  
    # "works!"
    Mojo::Template->new(vars => 1)->render('<%= $test %>!', {test => 'works'});
  
  =head1 METHODS
  
  L<Mojo::Template> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 parse
  
    $mt = $mt->parse('<%= 1 + 1 %>');
  
  Parse template into L</"tree">.
  
  =head2 process
  
    my $output = $mt->process;
    my $output = $mt->process(@args);
    my $output = $mt->process({foo => 'bar'});
  
  Process previously parsed template and return the result, or a
  L<Mojo::Exception> object if rendering failed.
  
    # Parse and process
    say Mojo::Template->new->parse('Hello <%= $_[0] %>')->process('Bender');
  
    # Reuse template (for much better performance)
    my $mt = Mojo::Template->new;
    say $mt->render('Hello <%= $_[0] %>!', 'Bender');
    say $mt->process('Fry');
    say $mt->process('Leela');
  
  =head2 render
  
    my $output = $mt->render('<%= 1 + 1 %>');
    my $output = $mt->render('<%= shift() + shift() %>', @args);
    my $output = $mt->render('<%= $foo %>', {foo => 'bar'});
  
  Render template and return the result, or a L<Mojo::Exception> object if
  rendering failed.
  
    # Longer version
    my $output = $mt->parse('<%= 1 + 1 %>')->process;
  
    # Render with arguments
    say Mojo::Template->new->render('<%= $_[0] %>', 'bar');
  
    # Render with named variables
    say Mojo::Template->new(vars => 1)->render('<%= $foo %>', {foo => 'bar'});
  
  =head2 render_file
  
    my $output = $mt->render_file('/tmp/foo.mt');
    my $output = $mt->render_file('/tmp/foo.mt', @args);
    my $output = $mt->render_file('/tmp/bar.mt', {foo => 'bar'});
  
  Same as L</"render">, but renders a template file.
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_TEMPLATE_DEBUG> environment variable to get some
  advanced diagnostics information printed to C<STDERR>.
  
    MOJO_TEMPLATE_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_TEMPLATE

$fatpacked{"Mojo/Transaction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_TRANSACTION';
  package Mojo::Transaction;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Mojo::Message::Request;
  use Mojo::Message::Response;
  
  has [
    qw(kept_alive local_address local_port original_remote_address remote_port)];
  has req => sub { Mojo::Message::Request->new };
  has res => sub { Mojo::Message::Response->new };
  
  sub client_read  { croak 'Method "client_read" not implemented by subclass' }
  sub client_write { croak 'Method "client_write" not implemented by subclass' }
  
  sub closed { shift->completed->emit('finish') }
  
  sub completed { ++$_[0]{completed} and return $_[0] }
  
  sub connection {
    my $self = shift;
    return $self->emit(connection => $self->{connection} = shift) if @_;
    return $self->{connection};
  }
  
  sub error { $_[0]->req->error || $_[0]->res->error }
  
  sub is_finished { !!shift->{completed} }
  
  sub is_websocket {undef}
  
  sub remote_address {
    my $self = shift;
  
    return $self->original_remote_address(@_) if @_;
    return $self->original_remote_address unless $self->req->reverse_proxy;
  
    # Reverse proxy
    return ($self->req->headers->header('X-Forwarded-For') // '') =~ /([^,\s]+)$/
      ? $1
      : $self->original_remote_address;
  }
  
  sub result {
    my $self = shift;
    my $err  = $self->error;
    return !$err || $err->{code} ? $self->res : croak $err->{message};
  }
  
  sub server_read  { croak 'Method "server_read" not implemented by subclass' }
  sub server_write { croak 'Method "server_write" not implemented by subclass' }
  
  sub success { $_[0]->error ? undef : $_[0]->res }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Transaction - Transaction base class
  
  =head1 SYNOPSIS
  
    package Mojo::Transaction::MyTransaction;
    use Mojo::Base 'Mojo::Transaction';
  
    sub client_read  {...}
    sub client_write {...}
    sub server_read  {...}
    sub server_write {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Transaction> is an abstract base class for transactions, like
  L<Mojo::Transaction::HTTP> and L<Mojo::Transaction::WebSocket>.
  
  =head1 EVENTS
  
  L<Mojo::Transaction> inherits all events from L<Mojo::EventEmitter> and can
  emit the following new ones.
  
  =head2 connection
  
    $tx->on(connection => sub {
      my ($tx, $connection) = @_;
      ...
    });
  
  Emitted when a connection has been assigned to transaction.
  
  =head2 finish
  
    $tx->on(finish => sub {
      my $tx = shift;
      ...
    });
  
  Emitted when transaction is finished.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Transaction> implements the following attributes.
  
  =head2 kept_alive
  
    my $bool = $tx->kept_alive;
    $tx      = $tx->kept_alive($bool);
  
  Connection has been kept alive.
  
  =head2 local_address
  
    my $address = $tx->local_address;
    $tx         = $tx->local_address('127.0.0.1');
  
  Local interface address.
  
  =head2 local_port
  
    my $port = $tx->local_port;
    $tx      = $tx->local_port(8080);
  
  Local interface port.
  
  =head2 original_remote_address
  
    my $address = $tx->original_remote_address;
    $tx         = $tx->original_remote_address('127.0.0.1');
  
  Remote interface address.
  
  =head2 remote_port
  
    my $port = $tx->remote_port;
    $tx      = $tx->remote_port(8081);
  
  Remote interface port.
  
  =head2 req
  
    my $req = $tx->req;
    $tx     = $tx->req(Mojo::Message::Request->new);
  
  HTTP request, defaults to a L<Mojo::Message::Request> object.
  
    # Access request information
    my $method = $tx->req->method;
    my $url    = $tx->req->url->to_abs;
    my $info   = $tx->req->url->to_abs->userinfo;
    my $host   = $tx->req->url->to_abs->host;
    my $agent  = $tx->req->headers->user_agent;
    my $custom = $tx->req->headers->header('Custom-Header');
    my $bytes  = $tx->req->body;
    my $str    = $tx->req->text;
    my $hash   = $tx->req->params->to_hash;
    my $all    = $tx->req->uploads;
    my $value  = $tx->req->json;
    my $foo    = $tx->req->json('/23/foo');
    my $dom    = $tx->req->dom;
    my $bar    = $tx->req->dom('div.bar')->first->text;
  
  =head2 res
  
    my $res = $tx->res;
    $tx     = $tx->res(Mojo::Message::Response->new);
  
  HTTP response, defaults to a L<Mojo::Message::Response> object.
  
    # Access response information
    my $code    = $tx->res->code;
    my $message = $tx->res->message;
    my $server  = $tx->res->headers->server;
    my $custom  = $tx->res->headers->header('Custom-Header');
    my $bytes   = $tx->res->body;
    my $str     = $tx->res->text;
    my $value   = $tx->res->json;
    my $foo     = $tx->res->json('/23/foo');
    my $dom     = $tx->res->dom;
    my $bar     = $tx->res->dom('div.bar')->first->text;
  
  =head1 METHODS
  
  L<Mojo::Transaction> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 client_read
  
    $tx->client_read($bytes);
  
  Read data client-side, used to implement user agents such as L<Mojo::UserAgent>.
  Meant to be overloaded in a subclass.
  
  =head2 client_write
  
    my $bytes = $tx->client_write;
  
  Write data client-side, used to implement user agents such as
  L<Mojo::UserAgent>. Meant to be overloaded in a subclass.
  
  =head2 closed
  
    $tx = $tx->closed;
  
  Same as L</"completed">, but also indicates that all transaction data has been
  sent.
  
  =head2 completed
  
    $tx = $tx->completed;
  
  Low-level method to finalize transaction.
  
  =head2 connection
  
    my $id = $tx->connection;
    $tx    = $tx->connection($id);
  
  Connection identifier.
  
  =head2 error
  
    my $err = $tx->error;
  
  Get request or response error and return C<undef> if there is no error,
  commonly used together with L</"success">.
  
    # Longer version
    my $err = $tx->req->error || $tx->res->error;
  
    # Check for 4xx/5xx response and connection errors
    if (my $err = $tx->error) {
      die "$err->{code} response: $err->{message}" if $err->{code};
      die "Connection error: $err->{message}";
    }
  
  =head2 is_finished
  
    my $bool = $tx->is_finished;
  
  Check if transaction is finished.
  
  =head2 is_websocket
  
    my $bool = $tx->is_websocket;
  
  False, this is not a L<Mojo::Transaction::WebSocket> object.
  
  =head2 remote_address
  
    my $address = $tx->remote_address;
    $tx         = $tx->remote_address('127.0.0.1');
  
  Same as L</"original_remote_address"> or the last value of the
  C<X-Forwarded-For> header if L</"req"> has been performed through a reverse
  proxy.
  
  =head2 result
  
    my $res = $tx->result;
  
  Returns the L<Mojo::Message::Response> object from L</"res"> or dies if a
  connection error has occurred.
  
    # Fine grained response handling (dies on connection errors)
    my $res = $tx->result;
    if    ($res->is_success)  { say $res->body }
    elsif ($res->is_error)    { say $res->message }
    elsif ($res->code == 301) { say $res->headers->location }
    else                      { say 'Whatever...' }
  
  =head2 server_read
  
    $tx->server_read($bytes);
  
  Read data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>. Meant to be overloaded in a subclass.
  
  =head2 server_write
  
    my $bytes = $tx->server_write;
  
  Write data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>. Meant to be overloaded in a subclass.
  
  =head2 success
  
    my $res = $tx->success;
  
  Returns the L<Mojo::Message::Response> object from L</"res"> if transaction was
  successful or C<undef> otherwise. Connection and parser errors have only a
  message in L</"error">, C<400> and C<500> responses also a code.
  
    # Manual exception handling
    if (my $res = $tx->success) { say $res->body }
    else {
      my $err = $tx->error;
      die "$err->{code} response: $err->{message}" if $err->{code};
      die "Connection error: $err->{message}";
    }
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_TRANSACTION

$fatpacked{"Mojo/Transaction/HTTP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_TRANSACTION_HTTP';
  package Mojo::Transaction::HTTP;
  use Mojo::Base 'Mojo::Transaction';
  
  has 'previous';
  
  sub client_read {
    my ($self, $chunk) = @_;
  
    # Skip body for HEAD request
    my $res = $self->res;
    $res->content->skip_body(1) if uc $self->req->method eq 'HEAD';
    return unless $res->parse($chunk)->is_finished;
  
    # Unexpected 1xx response
    return $self->completed if !$res->is_info || $res->headers->upgrade;
    $self->res($res->new)->emit(unexpected => $res);
    return unless length(my $leftovers = $res->content->leftovers);
    $self->client_read($leftovers);
  }
  
  sub client_write { shift->_write(0) }
  
  sub is_empty { !!(uc $_[0]->req->method eq 'HEAD' || $_[0]->res->is_empty) }
  
  sub keep_alive {
    my $self = shift;
  
    # Close
    my $req      = $self->req;
    my $res      = $self->res;
    my $req_conn = lc($req->headers->connection // '');
    my $res_conn = lc($res->headers->connection // '');
    return undef if $req_conn eq 'close' || $res_conn eq 'close';
  
    # Keep-alive is optional for 1.0
    return $res_conn eq 'keep-alive' if $res->version eq '1.0';
    return $req_conn eq 'keep-alive' if $req->version eq '1.0';
  
    # Keep-alive is the default for 1.1
    return 1;
  }
  
  sub redirects {
    my $previous = shift;
    my @redirects;
    unshift @redirects, $previous while $previous = $previous->previous;
    return \@redirects;
  }
  
  sub resume { ++$_[0]{writing} and return $_[0]->emit('resume') }
  
  sub server_read {
    my ($self, $chunk) = @_;
  
    # Parse request
    my $req = $self->req;
    $req->parse($chunk) unless $req->error;
  
    # Generate response
    $self->emit('request') if $req->is_finished && !$self->{handled}++;
  }
  
  sub server_write { shift->_write(1) }
  
  sub _body {
    my ($self, $msg, $finish) = @_;
  
    # Prepare body chunk
    my $buffer = $msg->get_body_chunk($self->{offset});
    my $written = defined $buffer ? length $buffer : 0;
    $self->{write} = $msg->content->is_dynamic ? 1 : ($self->{write} - $written);
    $self->{offset} += $written;
  
    # Delayed
    $self->{writing} = 0 unless defined $buffer;
  
    # Finished
    $finish ? $self->completed : ($self->{writing} = 0)
      if $self->{write} <= 0 || defined $buffer && !length $buffer;
  
    return $buffer // '';
  }
  
  sub _headers {
    my ($self, $msg, $head) = @_;
  
    # Prepare header chunk
    my $buffer = $msg->get_header_chunk($self->{offset});
    my $written = defined $buffer ? length $buffer : 0;
    $self->{write} -= $written;
    $self->{offset} += $written;
  
    # Switch to body
    if ($self->{write} <= 0) {
      @$self{qw(http_state offset)} = ('body', 0);
  
      # Response without body
      if ($head && $self->is_empty) { $self->completed->{http_state} = 'empty' }
  
      # Body
      else { $self->{write} = $msg->content->is_dynamic ? 1 : $msg->body_size }
    }
  
    return $buffer;
  }
  
  sub _start_line {
    my ($self, $msg) = @_;
  
    # Prepare start-line chunk
    my $buffer = $msg->get_start_line_chunk($self->{offset});
    my $written = defined $buffer ? length $buffer : 0;
    $self->{write} -= $written;
    $self->{offset} += $written;
  
    # Switch to headers
    @$self{qw(http_state write offset)} = ('headers', $msg->header_size, 0)
      if $self->{write} <= 0;
  
    return $buffer;
  }
  
  sub _write {
    my ($self, $server) = @_;
  
    # Client starts writing right away
    return '' unless $server ? $self->{writing} : ($self->{writing} //= 1);
  
    # Nothing written yet
    $self->{$_} ||= 0 for qw(offset write);
    my $msg = $server ? $self->res : $self->req;
    @$self{qw(http_state write)} = ('start_line', $msg->start_line_size)
      unless $self->{http_state};
  
    # Start-line
    my $chunk = '';
    $chunk .= $self->_start_line($msg) if $self->{http_state} eq 'start_line';
  
    # Headers
    $chunk .= $self->_headers($msg, $server) if $self->{http_state} eq 'headers';
  
    # Body
    $chunk .= $self->_body($msg, $server) if $self->{http_state} eq 'body';
  
    return $chunk;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Transaction::HTTP - HTTP transaction
  
  =head1 SYNOPSIS
  
    use Mojo::Transaction::HTTP;
  
    # Client
    my $tx = Mojo::Transaction::HTTP->new;
    $tx->req->method('GET');
    $tx->req->url->parse('http://example.com');
    $tx->req->headers->accept('application/json');
    say $tx->res->code;
    say $tx->res->headers->content_type;
    say $tx->res->body;
    say $tx->remote_address;
  
    # Server
    my $tx = Mojo::Transaction::HTTP->new;
    say $tx->req->method;
    say $tx->req->url->to_abs;
    say $tx->req->headers->accept;
    say $tx->remote_address;
    $tx->res->code(200);
    $tx->res->headers->content_type('text/plain');
    $tx->res->body('Hello World!');
  
  =head1 DESCRIPTION
  
  L<Mojo::Transaction::HTTP> is a container for HTTP transactions, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230> and
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>.
  
  =head1 EVENTS
  
  L<Mojo::Transaction::HTTP> inherits all events from L<Mojo::Transaction> and
  can emit the following new ones.
  
  =head2 request
  
    $tx->on(request => sub {
      my $tx = shift;
      ...
    });
  
  Emitted when a request is ready and needs to be handled.
  
    $tx->on(request => sub {
      my $tx = shift;
      $tx->res->headers->header('X-Bender' => 'Bite my shiny metal ass!');
    });
  
  =head2 resume
  
    $tx->on(resume => sub {
      my $tx = shift;
      ...
    });
  
  Emitted when transaction is resumed.
  
  =head2 unexpected
  
    $tx->on(unexpected => sub {
      my ($tx, $res) = @_;
      ...
    });
  
  Emitted for unexpected C<1xx> responses that will be ignored.
  
    $tx->on(unexpected => sub {
      my $tx = shift;
      $tx->res->on(finish => sub { say 'Follow-up response is finished.' });
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Transaction::HTTP> inherits all attributes from L<Mojo::Transaction>
  and implements the following new ones.
  
  =head2 previous
  
    my $previous = $tx->previous;
    $tx          = $tx->previous(Mojo::Transaction::HTTP->new);
  
  Previous transaction that triggered this follow-up transaction, usually a
  L<Mojo::Transaction::HTTP> object.
  
    # Paths of previous requests
    say $tx->previous->previous->req->url->path;
    say $tx->previous->req->url->path;
  
  =head1 METHODS
  
  L<Mojo::Transaction::HTTP> inherits all methods from L<Mojo::Transaction> and
  implements the following new ones.
  
  =head2 client_read
  
    $tx->client_read($bytes);
  
  Read data client-side, used to implement user agents such as L<Mojo::UserAgent>.
  
  =head2 client_write
  
    my $bytes = $tx->client_write;
  
  Write data client-side, used to implement user agents such as
  L<Mojo::UserAgent>.
  
  =head2 is_empty
  
    my $bool = $tx->is_empty;
  
  Check transaction for C<HEAD> request and C<1xx>, C<204> or C<304> response.
  
  =head2 keep_alive
  
    my $bool = $tx->keep_alive;
  
  Check if connection can be kept alive.
  
  =head2 redirects
  
    my $redirects = $tx->redirects;
  
  Return an array reference with all previous transactions that preceded this
  follow-up transaction.
  
    # Paths of all previous requests
    say $_->req->url->path for @{$tx->redirects};
  
  =head2 resume
  
    $tx = $tx->resume;
  
  Resume transaction.
  
  =head2 server_read
  
    $tx->server_read($bytes);
  
  Read data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>.
  
  =head2 server_write
  
    my $bytes = $tx->server_write;
  
  Write data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_TRANSACTION_HTTP

$fatpacked{"Mojo/Transaction/WebSocket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_TRANSACTION_WEBSOCKET';
  package Mojo::Transaction::WebSocket;
  use Mojo::Base 'Mojo::Transaction';
  
  use Compress::Raw::Zlib 'Z_SYNC_FLUSH';
  use List::Util 'first';
  use Mojo::JSON qw(encode_json j);
  use Mojo::Util qw(decode encode trim);
  use Mojo::WebSocket
    qw(WS_BINARY WS_CLOSE WS_CONTINUATION WS_PING WS_PONG WS_TEXT);
  
  has [qw(compressed established handshake masked)];
  has max_websocket_size => sub { $ENV{MOJO_MAX_WEBSOCKET_SIZE} || 262144 };
  
  sub build_message {
    my ($self, $frame) = @_;
  
    # Text
    $frame = {text => encode('UTF-8', $frame)} if ref $frame ne 'HASH';
  
    # JSON
    $frame->{text} = encode_json($frame->{json}) if exists $frame->{json};
  
    # Raw text or binary
    if (exists $frame->{text}) { $frame = [1, 0, 0, 0, WS_TEXT, $frame->{text}] }
    else { $frame = [1, 0, 0, 0, WS_BINARY, $frame->{binary}] }
  
    # "permessage-deflate" extension
    return $frame unless $self->compressed;
    my $deflate = $self->{deflate} ||= Compress::Raw::Zlib::Deflate->new(
      AppendOutput => 1,
      MemLevel     => 8,
      WindowBits   => -15
    );
    $deflate->deflate($frame->[5], my $out);
    $deflate->flush($out, Z_SYNC_FLUSH);
    @$frame[1, 5] = (1, substr($out, 0, length($out) - 4));
  
    return $frame;
  }
  
  sub client_read  { shift->server_read(@_) }
  sub client_write { shift->server_write(@_) }
  
  sub closed {
    my $self = shift->completed;
    return $self->emit(finish => $self->{close} ? (@{$self->{close}}) : 1006);
  }
  
  sub connection { shift->handshake->connection }
  
  sub finish {
    my $self = shift;
  
    my $close = $self->{close} = [@_];
    my $payload = $close->[0] ? pack('n', $close->[0]) : '';
    $payload .= encode 'UTF-8', $close->[1] if defined $close->[1];
    $close->[0] //= 1005;
    $self->send([1, 0, 0, 0, WS_CLOSE, $payload])->{closing} = 1;
  
    return $self;
  }
  
  sub is_websocket {1}
  
  sub kept_alive    { shift->handshake->kept_alive }
  sub local_address { shift->handshake->local_address }
  sub local_port    { shift->handshake->local_port }
  
  sub parse_message {
    my ($self, $frame) = @_;
  
    $self->emit(frame => $frame);
  
    # Ping/Pong
    my $op = $frame->[4];
    return $self->send([1, 0, 0, 0, WS_PONG, $frame->[5]]) if $op == WS_PING;
    return if $op == WS_PONG;
  
    # Close
    if ($op == WS_CLOSE) {
      return $self->finish unless length $frame->[5] >= 2;
      return $self->finish(unpack('n', substr($frame->[5], 0, 2, '')),
        decode('UTF-8', $frame->[5]));
    }
  
    # Append chunk and check message size
    $self->{op} = $op unless exists $self->{op};
    $self->{message} .= $frame->[5];
    my $max = $self->max_websocket_size;
    return $self->finish(1009) if length $self->{message} > $max;
  
    # No FIN bit (Continuation)
    return unless $frame->[0];
  
    # "permessage-deflate" extension (handshake and RSV1)
    my $msg = delete $self->{message};
    if ($self->compressed && $frame->[1]) {
      my $inflate = $self->{inflate} ||= Compress::Raw::Zlib::Inflate->new(
        Bufsize     => $max,
        LimitOutput => 1,
        WindowBits  => -15
      );
      $inflate->inflate(($msg .= "\x00\x00\xff\xff"), my $out);
      return $self->finish(1009) if length $msg;
      $msg = $out;
    }
  
    $self->emit(json => j($msg)) if $self->has_subscribers('json');
    $op = delete $self->{op};
    $self->emit($op == WS_TEXT ? 'text' : 'binary' => $msg);
    $self->emit(message => $op == WS_TEXT ? decode 'UTF-8', $msg : $msg)
      if $self->has_subscribers('message');
  }
  
  sub protocol { shift->res->headers->sec_websocket_protocol }
  
  sub remote_address { shift->handshake->remote_address }
  sub remote_port    { shift->handshake->remote_port }
  sub req            { shift->handshake->req }
  sub res            { shift->handshake->res }
  
  sub resume { $_[0]->handshake->resume and return $_[0] }
  
  sub send {
    my ($self, $msg, $cb) = @_;
    $self->once(drain => $cb) if $cb;
    $msg = $self->build_message($msg) unless ref $msg eq 'ARRAY';
    $self->{write} .= Mojo::WebSocket::build_frame($self->masked, @$msg);
    return $self->emit('resume');
  }
  
  sub server_read {
    my ($self, $chunk) = @_;
  
    $self->{read} .= $chunk;
    my $max = $self->max_websocket_size;
    while (my $frame = Mojo::WebSocket::parse_frame(\$self->{read}, $max)) {
      $self->finish(1009) and last unless ref $frame;
      $self->parse_message($frame);
    }
  
    $self->emit('resume');
  }
  
  sub server_write {
    my $self = shift;
    $self->emit('drain') unless length($self->{write} //= '');
    $self->completed if !length $self->{write} && $self->{closing};
    return delete $self->{write};
  }
  
  sub with_compression {
    my $self = shift;
  
    # "permessage-deflate" extension
    $self->compressed(1)
      and $self->res->headers->sec_websocket_extensions('permessage-deflate')
      if ($self->req->headers->sec_websocket_extensions // '')
      =~ /permessage-deflate/;
  }
  
  sub with_protocols {
    my $self = shift;
  
    my %protos = map { trim($_) => 1 } split ',',
      $self->req->headers->sec_websocket_protocol // '';
    return undef unless defined(my $proto = first { $protos{$_} } @_);
  
    $self->res->headers->sec_websocket_protocol($proto);
    return $proto;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Transaction::WebSocket - WebSocket transaction
  
  =head1 SYNOPSIS
  
    use Mojo::Transaction::WebSocket;
  
    # Send and receive WebSocket messages
    my $ws = Mojo::Transaction::WebSocket->new;
    $ws->send('Hello World!');
    $ws->on(message => sub {
      my ($ws, $msg) = @_;
      say "Message: $msg";
    });
    $ws->on(finish => sub {
      my ($ws, $code, $reason) = @_;
      say "WebSocket closed with status $code.";
    });
  
  =head1 DESCRIPTION
  
  L<Mojo::Transaction::WebSocket> is a container for WebSocket transactions, based
  on L<RFC 6455|http://tools.ietf.org/html/rfc6455> and
  L<RFC 7692|http://tools.ietf.org/html/rfc7692>.
  
  =head1 EVENTS
  
  L<Mojo::Transaction::WebSocket> inherits all events from L<Mojo::Transaction>
  and can emit the following new ones.
  
  =head2 binary
  
    $ws->on(binary => sub {
      my ($ws, $bytes) = @_;
      ...
    });
  
  Emitted when a complete WebSocket binary message has been received.
  
    $ws->on(binary => sub {
      my ($ws, $bytes) = @_;
      say "Binary: $bytes";
    });
  
  =head2 drain
  
    $ws->on(drain => sub {
      my $ws = shift;
      ...
    });
  
  Emitted once all data has been sent.
  
    $ws->on(drain => sub {
      my $ws = shift;
      $ws->send(time);
    });
  
  =head2 finish
  
    $ws->on(finish => sub {
      my ($ws, $code, $reason) = @_;
      ...
    });
  
  Emitted when the WebSocket connection has been closed.
  
  =head2 frame
  
    $ws->on(frame => sub {
      my ($ws, $frame) = @_;
      ...
    });
  
  Emitted when a WebSocket frame has been received.
  
    $ws->on(frame => sub {
      my ($ws, $frame) = @_;
      say "FIN: $frame->[0]";
      say "RSV1: $frame->[1]";
      say "RSV2: $frame->[2]";
      say "RSV3: $frame->[3]";
      say "Opcode: $frame->[4]";
      say "Payload: $frame->[5]";
    });
  
  =head2 json
  
    $ws->on(json => sub {
      my ($ws, $json) = @_;
      ...
    });
  
  Emitted when a complete WebSocket message has been received, all text and
  binary messages will be automatically JSON decoded. Note that this event only
  gets emitted when it has at least one subscriber.
  
    $ws->on(json => sub {
      my ($ws, $hash) = @_;
      say "Message: $hash->{msg}";
    });
  
  =head2 message
  
    $ws->on(message => sub {
      my ($ws, $msg) = @_;
      ...
    });
  
  Emitted when a complete WebSocket message has been received, text messages will
  be automatically decoded. Note that this event only gets emitted when it has at
  least one subscriber.
  
    $ws->on(message => sub {
      my ($ws, $msg) = @_;
      say "Message: $msg";
    });
  
  =head2 resume
  
    $tx->on(resume => sub {
      my $tx = shift;
      ...
    });
  
  Emitted when transaction is resumed.
  
  =head2 text
  
    $ws->on(text => sub {
      my ($ws, $bytes) = @_;
      ...
    });
  
  Emitted when a complete WebSocket text message has been received.
  
    $ws->on(text => sub {
      my ($ws, $bytes) = @_;
      say "Text: $bytes";
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Transaction::WebSocket> inherits all attributes from
  L<Mojo::Transaction> and implements the following new ones.
  
  =head2 compressed
  
    my $bool = $ws->compressed;
    $ws      = $ws->compressed($bool);
  
  Compress messages with C<permessage-deflate> extension.
  
  =head2 established
  
    my $bool = $ws->established;
    $ws      = $ws->established($bool);
  
  WebSocket connection established.
  
  =head2 handshake
  
    my $handshake = $ws->handshake;
    $ws           = $ws->handshake(Mojo::Transaction::HTTP->new);
  
  The original handshake transaction, usually a L<Mojo::Transaction::HTTP> object.
  
  =head2 masked
  
    my $bool = $ws->masked;
    $ws      = $ws->masked($bool);
  
  Mask outgoing frames with XOR cipher and a random 32-bit key.
  
  =head2 max_websocket_size
  
    my $size = $ws->max_websocket_size;
    $ws      = $ws->max_websocket_size(1024);
  
  Maximum WebSocket message size in bytes, defaults to the value of the
  C<MOJO_MAX_WEBSOCKET_SIZE> environment variable or C<262144> (256KiB).
  
  =head1 METHODS
  
  L<Mojo::Transaction::WebSocket> inherits all methods from L<Mojo::Transaction>
  and implements the following new ones.
  
  =head2 build_message
  
    my $frame = $ws->build_message({binary => $bytes});
    my $frame = $ws->build_message({text   => $bytes});
    my $frame = $ws->build_message({json   => {test => [1, 2, 3]}});
    my $frame = $ws->build_message($chars);
  
  Build WebSocket message.
  
  =head2 client_read
  
    $ws->client_read($data);
  
  Read data client-side, used to implement user agents such as L<Mojo::UserAgent>.
  
  =head2 client_write
  
    my $bytes = $ws->client_write;
  
  Write data client-side, used to implement user agents such as
  L<Mojo::UserAgent>.
  
  =head2 closed
  
    $tx = $tx->closed;
  
  Same as L<Mojo::Transaction/"completed">, but also indicates that all
  transaction data has been sent.
  
  =head2 connection
  
    my $id = $ws->connection;
  
  Connection identifier.
  
  =head2 finish
  
    $ws = $ws->finish;
    $ws = $ws->finish(1000);
    $ws = $ws->finish(1003 => 'Cannot accept data!');
  
  Close WebSocket connection gracefully.
  
  =head2 is_websocket
  
    my $bool = $ws->is_websocket;
  
  True, this is a L<Mojo::Transaction::WebSocket> object.
  
  =head2 kept_alive
  
    my $bool = $ws->kept_alive;
  
  Connection has been kept alive.
  
  =head2 local_address
  
    my $address = $ws->local_address;
  
  Local interface address.
  
  =head2 local_port
  
    my $port = $ws->local_port;
  
  Local interface port.
  
  =head2 parse_message
  
    $ws->parse_message([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);
  
  Parse WebSocket message.
  
  =head2 protocol
  
    my $proto = $ws->protocol;
  
  Return negotiated subprotocol or C<undef>.
  
  =head2 remote_address
  
    my $address = $ws->remote_address;
  
  Remote interface address.
  
  =head2 remote_port
  
    my $port = $ws->remote_port;
  
  Remote interface port.
  
  =head2 req
  
    my $req = $ws->req;
  
  Handshake request, usually a L<Mojo::Message::Request> object.
  
  =head2 res
  
    my $res = $ws->res;
  
  Handshake response, usually a L<Mojo::Message::Response> object.
  
  =head2 resume
  
    $ws = $ws->resume;
  
  Resume L</"handshake"> transaction.
  
  =head2 send
  
    $ws = $ws->send({binary => $bytes});
    $ws = $ws->send({text   => $bytes});
    $ws = $ws->send({json   => {test => [1, 2, 3]}});
    $ws = $ws->send([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);
    $ws = $ws->send($chars);
    $ws = $ws->send($chars => sub {...});
  
  Send message or frame non-blocking via WebSocket, the optional drain callback
  will be executed once all data has been written.
  
    # Send "Ping" frame
    use Mojo::WebSocket 'WS_PING';
    $ws->send([1, 0, 0, 0, WS_PING, 'Hello World!']);
  
  =head2 server_read
  
    $ws->server_read($data);
  
  Read data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>.
  
  =head2 server_write
  
    my $bytes = $ws->server_write;
  
  Write data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>.
  
  =head2 with_compression
  
    $ws->with_compression;
  
  Negotiate C<permessage-deflate> extension for this WebSocket connection.
  
  =head2 with_protocols
  
    my $proto = $ws->with_protocols('v2.proto', 'v1.proto');
  
  Negotiate subprotocol for this WebSocket connection.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_TRANSACTION_WEBSOCKET

$fatpacked{"Mojo/URL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_URL';
  package Mojo::URL;
  use Mojo::Base -base;
  use overload bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;
  
  use Mojo::Parameters;
  use Mojo::Path;
  use Mojo::Util
    qw(decode encode punycode_decode punycode_encode url_escape url_unescape);
  
  has base => sub { Mojo::URL->new };
  has [qw(fragment host port scheme userinfo)];
  
  sub clone {
    my $self  = shift;
    my $clone = $self->new;
    @$clone{keys %$self} = values %$self;
    $clone->{$_} && ($clone->{$_} = $clone->{$_}->clone) for qw(base path query);
    return $clone;
  }
  
  sub host_port {
    my ($self, $host_port) = @_;
  
    if (defined $host_port) {
      $self->port($1) if $host_port =~ s/:(\d+)$//;
      my $host = url_unescape $host_port;
      return $host =~ /[^\x00-\x7f]/ ? $self->ihost($host) : $self->host($host);
    }
  
    return undef unless defined(my $host = $self->ihost);
    return $host unless defined(my $port = $self->port);
    return "$host:$port";
  }
  
  sub ihost {
    my $self = shift;
  
    # Decode
    return $self->host(join '.',
      map { /^xn--(.+)$/ ? punycode_decode $1 : $_ } split(/\./, shift, -1))
      if @_;
  
    # Check if host needs to be encoded
    return undef unless defined(my $host = $self->host);
    return $host unless $host =~ /[^\x00-\x7f]/;
  
    # Encode
    return join '.',
      map { /[^\x00-\x7f]/ ? ('xn--' . punycode_encode $_) : $_ }
      split(/\./, $host, -1);
  }
  
  sub is_abs { !!shift->scheme }
  
  sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }
  
  sub parse {
    my ($self, $url) = @_;
  
    # Official regex from RFC 3986
    $url =~ m!^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?!;
    $self->scheme($2)                         if defined $2;
    $self->path($5)                           if defined $5;
    $self->query($7)                          if defined $7;
    $self->fragment(_decode(url_unescape $9)) if defined $9;
    if (defined(my $auth = $4)) {
      $self->userinfo(_decode(url_unescape $1)) if $auth =~ s/^([^\@]+)\@//;
      $self->host_port($auth);
    }
  
    return $self;
  }
  
  sub password { (shift->userinfo // '') =~ /:(.*)$/ ? $1 : undef }
  
  sub path {
    my $self = shift;
  
    # Old path
    $self->{path} ||= Mojo::Path->new;
    return $self->{path} unless @_;
  
    # New path
    $self->{path} = ref $_[0] ? $_[0] : $self->{path}->merge($_[0]);
  
    return $self;
  }
  
  sub path_query {
    my ($self, $pq) = @_;
  
    if (defined $pq) {
      return $self unless $pq =~ /^([^?#]*)(?:\?([^#]*))?/;
      return defined $2 ? $self->path($1)->query($2) : $self->path($1);
    }
  
    my $query = $self->query->to_string;
    return $self->path->to_string . (length $query ? "?$query" : '');
  }
  
  sub protocol { lc(shift->scheme // '') }
  
  sub query {
    my $self = shift;
  
    # Old parameters
    my $q = $self->{query} ||= Mojo::Parameters->new;
    return $q unless @_;
  
    # Replace with list
    if (@_ > 1) { $q->pairs([])->parse(@_) }
  
    # Merge with array
    elsif (ref $_[0] eq 'ARRAY') { $q->merge(@{$_[0]}) }
  
    # Append hash
    elsif (ref $_[0] eq 'HASH') { $q->append(%{$_[0]}) }
  
    # New parameters
    else { $self->{query} = ref $_[0] ? $_[0] : $q->parse($_[0]) }
  
    return $self;
  }
  
  sub to_abs {
    my $self = shift;
  
    my $abs = $self->clone;
    return $abs if $abs->is_abs;
  
    # Scheme
    my $base = shift || $abs->base;
    $abs->base($base)->scheme($base->scheme);
  
    # Authority
    return $abs if $abs->host;
    $abs->userinfo($base->userinfo)->host($base->host)->port($base->port);
  
    # Absolute path
    my $path = $abs->path;
    return $abs if $path->leading_slash;
  
    # Inherit path
    if (!@{$path->parts}) {
      $abs->path($base->path->clone->canonicalize);
  
      # Query
      $abs->query($base->query->clone) unless length $abs->query->to_string;
    }
  
    # Merge paths
    else { $abs->path($base->path->clone->merge($path)->canonicalize) }
  
    return $abs;
  }
  
  sub to_string        { shift->_string(0) }
  sub to_unsafe_string { shift->_string(1) }
  
  sub username { (shift->userinfo // '') =~ /^([^:]+)/ ? $1 : undef }
  
  sub _decode { decode('UTF-8', $_[0]) // $_[0] }
  
  sub _encode { url_escape encode('UTF-8', $_[0]), $_[1] }
  
  sub _string {
    my ($self, $unsafe) = @_;
  
    # Scheme
    my $url = '';
    if (my $proto = $self->protocol) { $url .= "$proto:" }
  
    # Authority
    my $auth = $self->host_port;
    $auth = _encode($auth, '^A-Za-z0-9\-._~!$&\'()*+,;=:\[\]') if defined $auth;
    if ($unsafe && defined(my $info = $self->userinfo)) {
      $auth = _encode($info, '^A-Za-z0-9\-._~!$&\'()*+,;=:') . '@' . $auth;
    }
    $url .= "//$auth" if defined $auth;
  
    # Path and query
    my $path = $self->path_query;
    $url .= !$auth || !length $path || $path =~ m!^[/?]! ? $path : "/$path";
  
    # Fragment
    return $url unless defined(my $fragment = $self->fragment);
    return $url . '#' . _encode($fragment, '^A-Za-z0-9\-._~!$&\'()*+,;=:@/?');
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::URL - Uniform Resource Locator
  
  =head1 SYNOPSIS
  
    use Mojo::URL;
  
    # Parse
    my $url = Mojo::URL->new('http://sri:foo@example.com:3000/foo?foo=bar#23');
    say $url->scheme;
    say $url->userinfo;
    say $url->host;
    say $url->port;
    say $url->path;
    say $url->query;
    say $url->fragment;
  
    # Build
    my $url = Mojo::URL->new;
    $url->scheme('http');
    $url->host('example.com');
    $url->port(3000);
    $url->path('/foo/bar');
    $url->query(foo => 'bar');
    $url->fragment(23);
    say "$url";
  
  =head1 DESCRIPTION
  
  L<Mojo::URL> implements a subset of
  L<RFC 3986|http://tools.ietf.org/html/rfc3986>,
  L<RFC 3987|http://tools.ietf.org/html/rfc3987> and the
  L<URL Living Standard|https://url.spec.whatwg.org> for Uniform Resource
  Locators with support for IDNA and IRIs.
  
  =head1 ATTRIBUTES
  
  L<Mojo::URL> implements the following attributes.
  
  =head2 base
  
    my $base = $url->base;
    $url     = $url->base(Mojo::URL->new);
  
  Base of this URL, defaults to a L<Mojo::URL> object.
  
    "http://example.com/a/b?c"
    Mojo::URL->new("/a/b?c")->base(Mojo::URL->new("http://example.com"))->to_abs;
  
  =head2 fragment
  
    my $fragment = $url->fragment;
    $url         = $url->fragment('mojolicious');
  
  Fragment part of this URL.
  
    # "yada"
    Mojo::URL->new('http://example.com/foo?bar=baz#yada')->fragment;
  
  =head2 host
  
    my $host = $url->host;
    $url     = $url->host('127.0.0.1');
  
  Host part of this URL.
  
    # "example.com"
    Mojo::URL->new('http://sri:t3st@example.com:8080/foo')->host;
  
  =head2 port
  
    my $port = $url->port;
    $url     = $url->port(8080);
  
  Port part of this URL.
  
    # "8080"
    Mojo::URL->new('http://sri:t3st@example.com:8080/foo')->port;
  
  =head2 scheme
  
    my $scheme = $url->scheme;
    $url       = $url->scheme('http');
  
  Scheme part of this URL.
  
    # "http"
    Mojo::URL->new('http://example.com/foo')->scheme;
  
  =head2 userinfo
  
    my $info = $url->userinfo;
    $url     = $url->userinfo('root:');
  
  Userinfo part of this URL.
  
    # "sri:t3st"
    Mojo::URL->new('https://sri:t3st@example.com/foo')->userinfo;
  
  =head1 METHODS
  
  L<Mojo::URL> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 clone
  
    my $url2 = $url->clone;
  
  Return a new L<Mojo::URL> object cloned from this URL.
  
  =head2 host_port
  
    my $host_port = $url->host_port;
    $url          = $url->host_port('example.com:8080');
  
  Normalized version of L</"host"> and L</"port">.
  
    # "xn--n3h.net:8080"
    Mojo::URL->new('http://.net:8080/test')->host_port;
  
    # "example.com"
    Mojo::URL->new('http://example.com/test')->host_port;
  
  =head2 ihost
  
    my $ihost = $url->ihost;
    $url      = $url->ihost('xn--bcher-kva.ch');
  
  Host part of this URL in punycode format.
  
    # "xn--n3h.net"
    Mojo::URL->new('http://.net')->ihost;
  
    # "example.com"
    Mojo::URL->new('http://example.com')->ihost;
  
  =head2 is_abs
  
    my $bool = $url->is_abs;
  
  Check if URL is absolute.
  
    # True
    Mojo::URL->new('http://example.com')->is_abs;
    Mojo::URL->new('http://example.com/test/index.html')->is_abs;
  
    # False
    Mojo::URL->new('test/index.html')->is_abs;
    Mojo::URL->new('/test/index.html')->is_abs;
    Mojo::URL->new('//example.com/test/index.html')->is_abs;
  
  =head2 new
  
    my $url = Mojo::URL->new;
    my $url = Mojo::URL->new('http://127.0.0.1:3000/foo?f=b&baz=2#foo');
  
  Construct a new L<Mojo::URL> object and L</"parse"> URL if necessary.
  
  =head2 parse
  
    $url = $url->parse('http://127.0.0.1:3000/foo/bar?fo=o&baz=23#foo');
  
  Parse relative or absolute URL.
  
    # "/test/123"
    $url->parse('/test/123?foo=bar')->path;
  
    # "example.com"
    $url->parse('http://example.com/test/123?foo=bar')->host;
  
    # "sri@example.com"
    $url->parse('mailto:sri@example.com')->path;
  
  =head2 password
  
    my $password = $url->password;
  
  Password part of L</"userinfo">.
  
    # "s3cret"
    Mojo::URL->new('http://isabel:s3cret@mojolicious.org')->password;
  
    # "s:3:c:r:e:t"
    Mojo::URL->new('http://isabel:s:3:c:r:e:t@mojolicious.org')->password;
  
  =head2 path
  
    my $path = $url->path;
    $url     = $url->path('foo/bar');
    $url     = $url->path('/foo/bar');
    $url     = $url->path(Mojo::Path->new);
  
  Path part of this URL, relative paths will be merged with
  L<Mojo::Path/"merge">, defaults to a L<Mojo::Path> object.
  
    # "perldoc"
    Mojo::URL->new('http://example.com/perldoc/Mojo')->path->parts->[0];
  
    # "/perldoc/DOM/HTML"
    Mojo::URL->new('http://example.com/perldoc/Mojo')->path->merge('DOM/HTML');
  
    # "http://example.com/DOM/HTML"
    Mojo::URL->new('http://example.com/perldoc/Mojo')->path('/DOM/HTML');
  
    # "http://example.com/perldoc/DOM/HTML"
    Mojo::URL->new('http://example.com/perldoc/Mojo')->path('DOM/HTML');
  
    # "http://example.com/perldoc/Mojo/DOM/HTML"
    Mojo::URL->new('http://example.com/perldoc/Mojo/')->path('DOM/HTML');
  
  =head2 path_query
  
    my $path_query = $url->path_query;
    $url           = $url->path_query('/foo/bar?a=1&b=2');
  
  Normalized version of L</"path"> and L</"query">.
  
    # "/test?a=1&b=2"
    Mojo::URL->new('http://example.com/test?a=1&b=2')->path_query;
  
    # "/"
    Mojo::URL->new('http://example.com/')->path_query;
  
  =head2 protocol
  
    my $proto = $url->protocol;
  
  Normalized version of L</"scheme">.
  
    # "http"
    Mojo::URL->new('HtTp://example.com')->protocol;
  
  =head2 query
  
    my $query = $url->query;
    $url      = $url->query([merge => 'with']);
    $url      = $url->query({append => 'to'});
    $url      = $url->query(replace => 'with');
    $url      = $url->query('a=1&b=2');
    $url      = $url->query(Mojo::Parameters->new);
  
  Query part of this URL, key/value pairs in an array reference will be merged
  with L<Mojo::Parameters/"merge">, and key/value pairs in a hash reference
  appended with L<Mojo::Parameters/"append">, defaults to a L<Mojo::Parameters>
  object.
  
    # "2"
    Mojo::URL->new('http://example.com?a=1&b=2')->query->param('b');
  
    # "a=2&b=2&c=3"
    Mojo::URL->new('http://example.com?a=1&b=2')->query->merge(a => 2, c => 3);
  
    # "http://example.com?a=2&c=3"
    Mojo::URL->new('http://example.com?a=1&b=2')->query(a => 2, c => 3);
  
    # "http://example.com?a=2&a=3"
    Mojo::URL->new('http://example.com?a=1&b=2')->query(a => [2, 3]);
  
    # "http://example.com?a=2&b=2&c=3"
    Mojo::URL->new('http://example.com?a=1&b=2')->query([a => 2, c => 3]);
  
    # "http://example.com?b=2"
    Mojo::URL->new('http://example.com?a=1&b=2')->query([a => undef]);
  
    # "http://example.com?a=1&b=2&a=2&c=3"
    Mojo::URL->new('http://example.com?a=1&b=2')->query({a => 2, c => 3});
  
  =head2 to_abs
  
    my $abs = $url->to_abs;
    my $abs = $url->to_abs(Mojo::URL->new('http://example.com/foo'));
  
  Return a new L<Mojo::URL> object cloned from this relative URL and turn it into
  an absolute one using L</"base"> or provided base URL.
  
    # "http://example.com/foo/baz.xml?test=123"
    Mojo::URL->new('baz.xml?test=123')
      ->to_abs(Mojo::URL->new('http://example.com/foo/bar.html'));
  
    # "http://example.com/baz.xml?test=123"
    Mojo::URL->new('/baz.xml?test=123')
      ->to_abs(Mojo::URL->new('http://example.com/foo/bar.html'));
  
    # "http://example.com/foo/baz.xml?test=123"
    Mojo::URL->new('//example.com/foo/baz.xml?test=123')
      ->to_abs(Mojo::URL->new('http://example.com/foo/bar.html'));
  
  =head2 to_string
  
    my $str = $url->to_string;
  
  Turn URL into a string. Note that L</"userinfo"> will not be included for
  security reasons.
  
    # "http://mojolicious.org"
    Mojo::URL->new->scheme('http')->host('mojolicious.org')->to_string;
  
    # "http://mojolicious.org"
    Mojo::URL->new('http://daniel:s3cret@mojolicious.org')->to_string;
  
  =head2 to_unsafe_string
  
    my $str = $url->to_unsafe_string;
  
  Same as L</"to_string">, but includes L</"userinfo">.
  
    # "http://daniel:s3cret@mojolicious.org"
    Mojo::URL->new('http://daniel:s3cret@mojolicious.org')->to_unsafe_string;
  
  =head2 username
  
    my $username = $url->username;
  
  Username part of L</"userinfo">.
  
    # "isabel"
    Mojo::URL->new('http://isabel:s3cret@mojolicious.org')->username;
  
  =head1 OPERATORS
  
  L<Mojo::URL> overloads the following operators.
  
  =head2 bool
  
    my $bool = !!$url;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$url";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_URL

$fatpacked{"Mojo/Upload.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_UPLOAD';
  package Mojo::Upload;
  use Mojo::Base -base;
  
  has [qw(asset filename headers name)];
  
  sub move_to { $_[0]->asset->move_to($_[1]) and return $_[0] }
  
  sub size  { shift->asset->size }
  sub slurp { shift->asset->slurp }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Upload - Upload
  
  =head1 SYNOPSIS
  
    use Mojo::Upload;
  
    my $upload = Mojo::Upload->new;
    say $upload->filename;
    $upload->move_to('/home/sri/foo.txt');
  
  =head1 DESCRIPTION
  
  L<Mojo::Upload> is a container for uploaded files.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Upload> implements the following attributes.
  
  =head2 asset
  
    my $asset = $upload->asset;
    $upload   = $upload->asset(Mojo::Asset::File->new);
  
  Asset containing the uploaded data, usually a L<Mojo::Asset::File> or
  L<Mojo::Asset::Memory> object.
  
  =head2 filename
  
    my $filename = $upload->filename;
    $upload      = $upload->filename('foo.txt');
  
  Name of the uploaded file.
  
  =head2 headers
  
    my $headers = $upload->headers;
    $upload     = $upload->headers(Mojo::Headers->new);
  
  Headers for upload, usually a L<Mojo::Headers> object.
  
  =head2 name
  
    my $name = $upload->name;
    $upload  = $upload->name('foo');
  
  Name of the upload.
  
  =head1 METHODS
  
  L<Mojo::Upload> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 move_to
  
    $upload = $upload->move_to('/home/sri/foo.txt');
  
  Move uploaded data into a specific file.
  
  =head2 size
  
    my $size = $upload->size;
  
  Size of uploaded data in bytes.
  
  =head2 slurp
  
    my $bytes = $upload->slurp;
  
  Read all uploaded data at once.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_UPLOAD

$fatpacked{"Mojo/UserAgent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT';
  package Mojo::UserAgent;
  use Mojo::Base 'Mojo::EventEmitter';
  
  # "Fry: Since when is the Internet about robbing people of their privacy?
  #  Bender: August 6, 1991."
  use Mojo::IOLoop;
  use Mojo::IOLoop::Stream::HTTPClient;
  use Mojo::IOLoop::Stream::WebSocketClient;
  use Mojo::Promise;
  use Mojo::Util 'monkey_patch';
  use Mojo::UserAgent::CookieJar;
  use Mojo::UserAgent::Proxy;
  use Mojo::UserAgent::Server;
  use Mojo::UserAgent::Transactor;
  use Scalar::Util 'weaken';
  
  use constant DEBUG => $ENV{MOJO_CLIENT_DEBUG} || 0;
  
  has ca                 => sub { $ENV{MOJO_CA_FILE} };
  has cert               => sub { $ENV{MOJO_CERT_FILE} };
  has connect_timeout    => sub { $ENV{MOJO_CONNECT_TIMEOUT} || 10 };
  has cookie_jar         => sub { Mojo::UserAgent::CookieJar->new };
  has inactivity_timeout => sub { $ENV{MOJO_INACTIVITY_TIMEOUT} // 20 };
  has insecure           => sub { $ENV{MOJO_INSECURE} };
  has [qw(local_address max_response_size)];
  has ioloop => sub { Mojo::IOLoop->new };
  has key    => sub { $ENV{MOJO_KEY_FILE} };
  has max_connections => 5;
  has max_redirects   => sub { $ENV{MOJO_MAX_REDIRECTS} || 0 };
  has proxy           => sub { Mojo::UserAgent::Proxy->new };
  has request_timeout => sub { $ENV{MOJO_REQUEST_TIMEOUT} // 0 };
  has server => sub { Mojo::UserAgent::Server->new(ioloop => shift->ioloop) };
  has transactor => sub { Mojo::UserAgent::Transactor->new };
  
  # Common HTTP methods
  for my $name (qw(DELETE GET HEAD OPTIONS PATCH POST PUT)) {
    monkey_patch __PACKAGE__, lc $name, sub {
      my ($self, $cb) = (shift, ref $_[-1] eq 'CODE' ? pop : undef);
      return $self->start($self->build_tx($name, @_), $cb);
    };
    monkey_patch __PACKAGE__, lc($name) . '_p', sub {
      my $self = shift;
      return $self->start_p($self->build_tx($name, @_));
    };
  }
  
  sub DESTROY { Mojo::Util::_global_destruction() or shift->_cleanup }
  
  sub build_tx           { shift->transactor->tx(@_) }
  sub build_websocket_tx { shift->transactor->websocket(@_) }
  
  sub start {
    my ($self, $tx, $cb) = @_;
  
    # Fork-safety
    $self->_cleanup->server->restart unless ($self->{pid} //= $$) eq $$;
  
    # Non-blocking
    if ($cb) {
      warn "-- Non-blocking request (@{[_url($tx)]})\n" if DEBUG;
      return $self->_start(Mojo::IOLoop->singleton, $tx, $cb);
    }
  
    # Blocking
    warn "-- Blocking request (@{[_url($tx)]})\n" if DEBUG;
    $self->_start($self->ioloop, $tx => sub { shift->ioloop->stop; $tx = shift });
    $self->ioloop->start;
  
    return $tx;
  }
  
  sub start_p {
    my ($self, $tx) = @_;
    my $promise = Mojo::Promise->new;
    $self->start($tx => sub { shift->transactor->promisify($promise, shift) });
    return $promise;
  }
  
  sub websocket {
    my ($self, $cb) = (shift, pop);
    $self->start($self->build_websocket_tx(@_), $cb);
  }
  
  sub websocket_p {
    my $self = shift;
    return $self->start_p($self->build_websocket_tx(@_));
  }
  
  sub _cleanup {
    my $self = shift;
    delete $self->{pid};
    $self->_error($_, 'Premature connection close')
      for keys %{$self->{connections} || {}};
    return $self;
  }
  
  sub _connect {
    my ($self, $loop, $tx, $handle) = @_;
  
    my $t = $self->transactor;
    my ($proto, $host, $port) = $handle ? $t->endpoint($tx) : $t->peer($tx);
  
    my %options = (
      timeout      => $self->connect_timeout,
      stream_class => 'Mojo::IOLoop::Stream::HTTPClient'
    );
    if ($proto eq 'http+unix') { $options{path} = $host }
    else                       { @options{qw(address port)} = ($host, $port) }
    if (my $local = $self->local_address) { $options{local_address} = $local }
    $options{handle} = $handle if $handle;
  
    # SOCKS
    if ($proto eq 'socks') {
      @options{qw(socks_address socks_port)} = @options{qw(address port)};
      ($proto, @options{qw(address port)}) = $t->endpoint($tx);
      my $userinfo = $tx->req->via_proxy(0)->proxy->userinfo;
      @options{qw(socks_user socks_pass)} = split ':', $userinfo if $userinfo;
    }
  
    # TLS
    if ($options{tls} = $proto eq 'https') {
      map { $options{"tls_$_"} = $self->$_ } qw(ca cert key);
      $options{tls_verify} = 0x00 if $self->insecure;
    }
  
    weaken $self;
    my $id;
    return $id = $loop->client(
      %options => sub {
        my ($loop, $err, $stream) = @_;
  
        # Connection error
        return unless $self;
        return $self->_error($id, $err) if $err;
  
        # Connection established
        $stream->on(timeout => sub { $self->_error($id, 'Inactivity timeout') });
        $stream->on(close => sub { $self && $self->_finish($id, 1) });
        $stream->on(error => sub { $self && $self->_error($id, pop) });
        $stream->on(upgrade => sub { $self->_upgrade($id, pop) });
        $self->_process($id);
      }
    );
  }
  
  sub _connect_proxy {
    my ($self, $loop, $old, $cb) = @_;
  
    # Start CONNECT request
    return undef unless my $new = $self->transactor->proxy_connect($old);
    my $id;
    return $id = $self->_start(
      ($loop, $new) => sub {
        my ($self, $tx) = @_;
  
        # Real transaction
        $old->previous($tx)->req->via_proxy(0);
        my $c = $self->{connections}{$id}
          = {cb => $cb, ioloop => $loop, tx => $old};
  
        # CONNECT failed
        return $self->_error($id, 'Proxy connection failed')
          if $tx->error || !$tx->res->is_success || !$tx->keep_alive;
  
        # Start real transaction without TLS upgrade
        return $self->_process($id) unless $tx->req->url->protocol eq 'https';
  
        # TLS upgrade before starting the real transaction
        my $handle = $loop->stream($id)->steal_handle;
        $self->_remove($id);
        $id = $self->_connect($loop, $old, $handle);
        $self->{connections}{$id} = $c;
      }
    );
  }
  
  sub _connection {
    my ($self, $loop, $tx, $cb) = @_;
  
    # Reuse connection
    my ($proto, $host, $port) = $self->transactor->endpoint($tx);
    my $id;
    if ($id = $self->_dequeue($loop, "$proto:$host:$port", 1)) {
      warn "-- Reusing connection $id ($proto://$host:$port)\n" if DEBUG;
      @{$self->{connections}{$id}}{qw(cb tx)} = ($cb, $tx);
      $tx->kept_alive(1) unless $tx->connection;
      $self->_process($id);
      return $id;
    }
  
    # CONNECT request to proxy required
    if (my $id = $self->_connect_proxy($loop, $tx, $cb)) { return $id }
  
    # New connection
    $tx->res->error({message => "Unsupported protocol: $proto"})
      and return $loop->next_tick(sub { $self->$cb($tx) })
      unless $proto eq 'http' || $proto eq 'https' || $proto eq 'http+unix';
    $id = $self->_connect($loop, $tx);
    warn "-- Connect $id ($proto://$host:$port)\n" if DEBUG;
    $self->{connections}{$id} = {cb => $cb, ioloop => $loop, tx => $tx};
  
    return $id;
  }
  
  sub _dequeue {
    my ($self, $loop, $name, $test) = @_;
  
    my $old = $self->{queue}{$loop} ||= [];
    my ($found, @new);
    for my $queued (@$old) {
      push @new, $queued and next if $found || !grep { $_ eq $name } @$queued;
  
      # Search for id/name and sort out corrupted connections if necessary
      next unless my $stream = $loop->stream($queued->[1]);
      $test && $stream->is_readable ? $stream->close : ($found = $queued->[1]);
    }
    @$old = @new;
  
    return $found;
  }
  
  sub _error {
    my ($self, $id, $err) = @_;
    my $tx = $self->{connections}{$id}{tx};
    $tx->closed->res->finish->error({message => $err}) if $tx;
    $self->_finish($id, 1);
  }
  
  sub _finish {
    my ($self, $id, $close) = @_;
  
    return unless my $c = $self->{connections}{$id};
    return $self->_reuse($id, $close) unless my $tx = $c->{tx};
  
    $self->cookie_jar->collect($tx);
    $self->_reuse($id, $close) unless uc $tx->req->method eq 'CONNECT';
    $c->{cb}($self, $tx) unless $self->_redirect($c, $tx);
  }
  
  sub _process {
    my ($self, $id) = @_;
  
    my $c      = $self->{connections}{$id};
    my $stream = $c->{ioloop}->stream($id)->timeout($self->inactivity_timeout)
      ->request_timeout($self->request_timeout);
    my $tx = $c->{tx}->connection($id);
  
    weaken $self;
    $tx->on(finish => sub { $self->_finish($id) });
    $stream->process($tx);
  }
  
  sub _redirect {
    my ($self, $c, $old) = @_;
    return undef unless my $new = $self->transactor->redirect($old);
    return undef unless @{$old->redirects} < $self->max_redirects;
    return $self->_start($c->{ioloop}, $new, delete $c->{cb});
  }
  
  sub _remove {
    my ($self, $id) = @_;
    my $c = delete $self->{connections}{$id};
    $self->_dequeue($c->{ioloop}, $id);
    $c->{ioloop}->remove($id);
  }
  
  sub _reuse {
    my ($self, $id, $close) = @_;
  
    # Connection close
    my $c   = $self->{connections}{$id};
    my $tx  = delete $c->{tx};
    my $max = $self->max_connections;
    return $self->_remove($id) if $close || !$tx || !$max;
  
    # Keep connection alive
    my $queue = $self->{queue}{$c->{ioloop}} ||= [];
    $self->_remove(shift(@$queue)->[1]) while @$queue && @$queue >= $max;
    push @$queue, [join(':', $self->transactor->endpoint($tx)), $id];
  }
  
  sub _start {
    my ($self, $loop, $tx, $cb) = @_;
  
    # Application server
    my $url = $tx->req->url;
    if (!$url->is_abs && (my $server = $self->server)) {
      my $base = $loop == $self->ioloop ? $server->url : $server->nb_url;
      $url->scheme($base->scheme)->host($base->host)->port($base->port);
    }
  
    $_->prepare($tx) for $self->proxy, $self->cookie_jar;
    my $max = $self->max_response_size;
    $tx->res->max_message_size($max) if defined $max;
    $self->emit(start => $tx);
    return $self->_connection($loop, $tx, $cb);
  }
  
  sub _upgrade {
    my ($self, $id, $ws) = @_;
  
    my $c       = $self->{connections}{$id};
    my $loop    = $c->{ioloop};
    my $timeout = $loop->stream($id)->timeout;
    my $stream  = $loop->transition($id, 'Mojo::IOLoop::Stream::WebSocketClient');
    $stream->timeout($timeout);
  
    weaken $self;
    $stream->on(timeout => sub { $self->_error($id, 'Inactivity timeout') });
    $stream->on(close => sub { $self && $self->_remove($id) });
  
    $self->cookie_jar->collect($ws);
    $c->{cb}($self, $c->{tx} = $ws);
    $stream->process($ws);
  }
  
  sub _url { shift->req->url->to_abs }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::UserAgent - Non-blocking I/O HTTP and WebSocket user agent
  
  =head1 SYNOPSIS
  
    use Mojo::UserAgent;
  
    # Fine grained response handling (dies on connection errors)
    my $ua  = Mojo::UserAgent->new;
    my $res = $ua->get('mojolicious.org/perldoc')->result;
    if    ($res->is_success)  { say $res->body }
    elsif ($res->is_error)    { say $res->message }
    elsif ($res->code == 301) { say $res->headers->location }
    else                      { say 'Whatever...' }
  
    # Say hello to the Unicode snowman and include an Accept header
    say $ua->get('www..net?hello=there' => {Accept => '*/*'})->result->body;
  
    # Extract data from HTML and XML resources with CSS selectors
    say $ua->get('www.perl.org')->result->dom->at('title')->text;
  
    # Scrape the latest headlines from a news site
    say $ua->get('blogs.perl.org')
      ->result->dom->find('h2 > a')->map('text')->join("\n");
  
    # IPv6 PUT request with Content-Type header and content
    my $tx = $ua->put('[::1]:3000' => {'Content-Type' => 'text/plain'} => 'Hi!');
  
    # Quick JSON API request with Basic authentication
    my $value = $ua->get('https://sri:t3st@example.com/test.json')->result->json;
  
    # JSON POST (application/json) with TLS certificate authentication
    my $tx = $ua->cert('tls.crt')->key('tls.key')
      ->post('https://example.com' => json => {top => 'secret'});
  
    # Search DuckDuckGo anonymously through Tor
    $ua->proxy->http('socks://127.0.0.1:9050');
    say $ua->get('api.3g2upl4pq6kufc4m.onion/?q=mojolicious&format=json')
      ->result->json('/Abstract');
  
    # GET request via UNIX domain socket "/tmp/myapp.sock" (percent encoded slash)
    say $ua->get('http+unix://%2Ftmp%2Fmyapp.sock/perldoc')->result->body;
  
    # Follow redirects to download Mojolicious from GitHub
    $ua->max_redirects(5)
      ->get('https://www.github.com/kraih/mojo/tarball/master')
      ->result->content->asset->move_to('/home/sri/mojo.tar.gz');
  
    # Form POST (application/x-www-form-urlencoded) with manual exception handling
    my $tx = $ua->post('https://metacpan.org/search' => form => {q => 'mojo'});
    if (my $res = $tx->success) { say $res->body }
    else {
      my $err = $tx->error;
      die "$err->{code} response: $err->{message}" if $err->{code};
      die "Connection error: $err->{message}";
    }
  
    # Non-blocking request
    $ua->get('mojolicious.org' => sub {
      my ($ua, $tx) = @_;
      say $tx->result->dom->at('title')->text;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
    # Concurrent non-blocking requests (synchronized with promises)
    my $mojo = $ua->get_p('mojolicious.org');
    my $cpan = $ua->get_p('cpan.org');
    Mojo::Promise->all($mojo, $cpan)->then(sub {
      my ($mojo, $cpan) = @_;
      say $mojo->[0]->result->dom->at('title')->text;
      say $cpan->[0]->result->dom->at('title')->text;
    })->wait;
  
    # WebSocket connection sending and receiving JSON via UNIX domain socket
    $ua->websocket('ws+unix://%2Ftmp%2Fmyapp.sock/echo.json' => sub {
      my ($ua, $tx) = @_;
      say 'WebSocket handshake failed!' and return unless $tx->is_websocket;
      $tx->on(json => sub {
        my ($tx, $hash) = @_;
        say "WebSocket message via JSON: $hash->{msg}";
        $tx->finish;
      });
      $tx->send({json => {msg => 'Hello World!'}});
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::UserAgent> is a full featured non-blocking I/O HTTP and WebSocket user
  agent, with IPv6, TLS, SNI, IDNA, HTTP/SOCKS5 proxy, UNIX domain socket, Comet
  (long polling), Promises/A+, keep-alive, connection pooling, timeout, cookie,
  multipart, gzip compression and multiple event loop support.
  
  All connections will be reset automatically if a new process has been forked,
  this allows multiple processes to share the same L<Mojo::UserAgent> object
  safely.
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (2.009+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NNR>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"USER AGENT"> for more.
  
  =head1 EVENTS
  
  L<Mojo::UserAgent> inherits all events from L<Mojo::EventEmitter> and can emit
  the following new ones.
  
  =head2 start
  
    $ua->on(start => sub {
      my ($ua, $tx) = @_;
      ...
    });
  
  Emitted whenever a new transaction is about to start, this includes
  automatically prepared proxy C<CONNECT> requests and followed redirects.
  
    $ua->on(start => sub {
      my ($ua, $tx) = @_;
      $tx->req->headers->header('X-Bender' => 'Bite my shiny metal ass!');
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::UserAgent> implements the following attributes.
  
  =head2 ca
  
    my $ca = $ua->ca;
    $ua    = $ua->ca('/etc/tls/ca.crt');
  
  Path to TLS certificate authority file used to verify the peer certificate,
  defaults to the value of the C<MOJO_CA_FILE> environment variable.
  
    # Show certificate authorities for debugging
    IO::Socket::SSL::set_defaults(
      SSL_verify_callback => sub { say "Authority: $_[2]" and return $_[0] });
  
  =head2 cert
  
    my $cert = $ua->cert;
    $ua      = $ua->cert('/etc/tls/client.crt');
  
  Path to TLS certificate file, defaults to the value of the C<MOJO_CERT_FILE>
  environment variable.
  
  =head2 connect_timeout
  
    my $timeout = $ua->connect_timeout;
    $ua         = $ua->connect_timeout(5);
  
  Maximum amount of time in seconds establishing a connection may take before
  getting canceled, defaults to the value of the C<MOJO_CONNECT_TIMEOUT>
  environment variable or C<10>.
  
  =head2 cookie_jar
  
    my $cookie_jar = $ua->cookie_jar;
    $ua            = $ua->cookie_jar(Mojo::UserAgent::CookieJar->new);
  
  Cookie jar to use for requests performed by this user agent, defaults to a
  L<Mojo::UserAgent::CookieJar> object.
  
    # Ignore all cookies
    $ua->cookie_jar->ignore(sub { 1 });
  
    # Ignore cookies for public suffixes
    my $ps = IO::Socket::SSL::PublicSuffix->default;
    $ua->cookie_jar->ignore(sub {
      my $cookie = shift;
      return undef unless my $domain = $cookie->domain;
      return ($ps->public_suffix($domain))[0] eq '';
    });
  
    # Add custom cookie to the jar
    $ua->cookie_jar->add(
      Mojo::Cookie::Response->new(
        name   => 'foo',
        value  => 'bar',
        domain => 'mojolicious.org',
        path   => '/perldoc'
      )
    );
  
  =head2 inactivity_timeout
  
    my $timeout = $ua->inactivity_timeout;
    $ua         = $ua->inactivity_timeout(15);
  
  Maximum amount of time in seconds a connection can be inactive before getting
  closed, defaults to the value of the C<MOJO_INACTIVITY_TIMEOUT> environment
  variable or C<20>. Setting the value to C<0> will allow connections to be
  inactive indefinitely.
  
  =head2 insecure
  
    my $bool = $ua->insecure;
    $ua      = $ua->insecure($bool);
  
  Do not require a valid TLS certificate to access HTTPS/WSS sites, defaults to
  the value of the C<MOJO_INSECURE> environment variable.
  
    # Disable TLS certificate verification for testing
    say $ua->insecure(1)->get('https://127.0.0.1:3000')->result->code;
  
  =head2 ioloop
  
    my $loop = $ua->ioloop;
    $ua      = $ua->ioloop(Mojo::IOLoop->new);
  
  Event loop object to use for blocking I/O operations, defaults to a
  L<Mojo::IOLoop> object.
  
  =head2 key
  
    my $key = $ua->key;
    $ua     = $ua->key('/etc/tls/client.crt');
  
  Path to TLS key file, defaults to the value of the C<MOJO_KEY_FILE> environment
  variable.
  
  =head2 local_address
  
    my $address = $ua->local_address;
    $ua         = $ua->local_address('127.0.0.1');
  
  Local address to bind to.
  
  =head2 max_connections
  
    my $max = $ua->max_connections;
    $ua     = $ua->max_connections(5);
  
  Maximum number of keep-alive connections that the user agent will retain before
  it starts closing the oldest ones, defaults to C<5>. Setting the value to C<0>
  will prevent any connections from being kept alive.
  
  =head2 max_redirects
  
    my $max = $ua->max_redirects;
    $ua     = $ua->max_redirects(3);
  
  Maximum number of redirects the user agent will follow before it fails,
  defaults to the value of the C<MOJO_MAX_REDIRECTS> environment variable or
  C<0>.
  
  =head2 max_response_size
  
    my $max = $ua->max_response_size;
    $ua     = $ua->max_response_size(16777216);
  
  Maximum response size in bytes, defaults to the value of
  L<Mojo::Message::Response/"max_message_size">. Setting the value to C<0> will
  allow responses of indefinite size. Note that increasing this value can also
  drastically increase memory usage, should you for example attempt to parse an
  excessively large response body with the methods L<Mojo::Message/"dom"> or
  L<Mojo::Message/"json">.
  
  =head2 proxy
  
    my $proxy = $ua->proxy;
    $ua       = $ua->proxy(Mojo::UserAgent::Proxy->new);
  
  Proxy manager, defaults to a L<Mojo::UserAgent::Proxy> object.
  
    # Detect proxy servers from environment
    $ua->proxy->detect;
  
    # Manually configure HTTP proxy (using CONNECT for HTTPS/WebSockets)
    $ua->proxy->http('http://127.0.0.1:8080')->https('http://127.0.0.1:8080');
  
    # Manually configure Tor (SOCKS5)
    $ua->proxy->http('socks://127.0.0.1:9050')->https('socks://127.0.0.1:9050');
  
    # Manually configure UNIX domain socket (using CONNECT for HTTPS/WebSockets)
    $ua->proxy->http('http+unix://%2Ftmp%2Fproxy.sock')
      ->https('http+unix://%2Ftmp%2Fproxy.sock');
  
  =head2 request_timeout
  
    my $timeout = $ua->request_timeout;
    $ua         = $ua->request_timeout(5);
  
  Maximum amount of time in seconds sending the request and receiving a whole
  response may take before getting canceled, defaults to the value of the
  C<MOJO_REQUEST_TIMEOUT> environment variable or C<0>. This does not include
  L</"connect_timeout">. Setting the value to C<0> will allow the user agent to
  wait indefinitely. The timeout will reset for every followed redirect.
  
    # Allow 3 seconds to establish connection and 5 seconds to process request
    $ua->max_redirects(0)->connect_timeout(3)->request_timeout(5);
  
  =head2 server
  
    my $server = $ua->server;
    $ua        = $ua->server(Mojo::UserAgent::Server->new);
  
  Application server relative URLs will be processed with, defaults to a
  L<Mojo::UserAgent::Server> object.
  
    # Mock web service
    $ua->server->app(Mojolicious->new);
    $ua->server->app->routes->get('/time' => sub {
      my $c = shift;
      $c->render(json => {now => time});
    });
    my $time = $ua->get('/time')->result->json->{now};
  
    # Change log level
    $ua->server->app->log->level('fatal');
  
    # Port currently used for processing relative URLs blocking
    say $ua->server->url->port;
  
    # Port currently used for processing relative URLs non-blocking
    say $ua->server->nb_url->port;
  
  =head2 transactor
  
    my $t = $ua->transactor;
    $ua   = $ua->transactor(Mojo::UserAgent::Transactor->new);
  
  Transaction builder, defaults to a L<Mojo::UserAgent::Transactor> object.
  
    # Change name of user agent
    $ua->transactor->name('MyUA 1.0');
  
  =head1 METHODS
  
  L<Mojo::UserAgent> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 build_tx
  
    my $tx = $ua->build_tx(GET => 'example.com');
    my $tx = $ua->build_tx(
      PUT => 'http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->build_tx(
      PUT => 'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->build_tx(
      PUT => 'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Generate L<Mojo::Transaction::HTTP> object with
  L<Mojo::UserAgent::Transactor/"tx">.
  
    # Request with custom cookie
    my $tx = $ua->build_tx(GET => 'https://example.com/account');
    $tx->req->cookies({name => 'user', value => 'sri'});
    $tx = $ua->start($tx);
  
    # Deactivate gzip compression
    my $tx = $ua->build_tx(GET => 'example.com');
    $tx->req->headers->remove('Accept-Encoding');
    $tx = $ua->start($tx);
  
    # Interrupt response by raising an error
    my $tx = $ua->build_tx(GET => 'http://example.com');
    $tx->res->on(progress => sub {
      my $res = shift;
      return unless my $server = $res->headers->server;
      $res->error({message => 'Oh noes, it is IIS!'}) if $server =~ /IIS/;
    });
    $tx = $ua->start($tx);
  
  =head2 build_websocket_tx
  
    my $tx = $ua->build_websocket_tx('ws://example.com');
    my $tx = $ua->build_websocket_tx(
      'ws://example.com' => {DNT => 1} => ['v1.proto']);
  
  Generate L<Mojo::Transaction::HTTP> object with
  L<Mojo::UserAgent::Transactor/"websocket">.
  
    # Custom WebSocket handshake with cookie
    my $tx = $ua->build_websocket_tx('wss://example.com/echo');
    $tx->req->cookies({name => 'user', value => 'sri'});
    $ua->start($tx => sub {
      my ($ua, $tx) = @_;
      say 'WebSocket handshake failed!' and return unless $tx->is_websocket;
      $tx->on(message => sub {
        my ($tx, $msg) = @_;
        say "WebSocket message: $msg";
        $tx->finish;
      });
      $tx->send('Hi!');
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 delete
  
    my $tx = $ua->delete('example.com');
    my $tx = $ua->delete('http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->delete(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->delete(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<DELETE> request and return resulting
  L<Mojo::Transaction::HTTP> object, takes the same arguments as
  L<Mojo::UserAgent::Transactor/"tx"> (except for the C<DELETE> method, which is
  implied). You can also append a callback to perform requests non-blocking.
  
    $ua->delete('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 delete_p
  
    my $promise = $ua->delete_p('http://example.com');
  
  Same as L</"delete">, but performs all requests non-blocking and returns a
  L<Mojo::Promise> object instead of accepting a callback.
  
    $ua->delete_p('http://example.com' => json => {a => 'b'})->then(sub {
      my $tx = shift;
      say $tx->result->body;
    })->catch(sub {
      my $err = shift;
      warn "Connection error: $err";
    })->wait;
  
  =head2 get
  
    my $tx = $ua->get('example.com');
    my $tx = $ua->get('http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->get(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->get(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<GET> request and return resulting L<Mojo::Transaction::HTTP>
  object, takes the same arguments as L<Mojo::UserAgent::Transactor/"tx"> (except
  for the C<GET> method, which is implied). You can also append a callback to
  perform requests non-blocking.
  
    $ua->get('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 get_p
  
    my $promise = $ua->get_p('http://example.com');
  
  Same as L</"get">, but performs all requests non-blocking and returns a
  L<Mojo::Promise> object instead of accepting a callback.
  
    $ua->get_p('http://example.com' => json => {a => 'b'})->then(sub {
      my $tx = shift;
      say $tx->result->body;
    })->catch(sub {
      my $err = shift;
      warn "Connection error: $err";
    })->wait;
  
  =head2 head
  
    my $tx = $ua->head('example.com');
    my $tx = $ua->head('http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->head(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->head(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<HEAD> request and return resulting
  L<Mojo::Transaction::HTTP> object, takes the same arguments as
  L<Mojo::UserAgent::Transactor/"tx"> (except for the C<HEAD> method, which is
  implied). You can also append a callback to perform requests non-blocking.
  
    $ua->head('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 head_p
  
    my $promise = $ua->head_p('http://example.com');
  
  Same as L</"head">, but performs all requests non-blocking and returns a
  L<Mojo::Promise> object instead of accepting a callback.
  
    $ua->head_p('http://example.com' => json => {a => 'b'})->then(sub {
      my $tx = shift;
      say $tx->result->body;
    })->catch(sub {
      my $err = shift;
      warn "Connection error: $err";
    })->wait;
  
  =head2 options
  
    my $tx = $ua->options('example.com');
    my $tx = $ua->options('http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->options(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->options(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<OPTIONS> request and return resulting
  L<Mojo::Transaction::HTTP> object, takes the same arguments as
  L<Mojo::UserAgent::Transactor/"tx"> (except for the C<OPTIONS> method, which is
  implied). You can also append a callback to perform requests non-blocking.
  
    $ua->options('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 options_p
  
    my $promise = $ua->options_p('http://example.com');
  
  Same as L</"options">, but performs all requests non-blocking and returns a
  L<Mojo::Promise> object instead of accepting a callback.
  
    $ua->options_p('http://example.com' => json => {a => 'b'})->then(sub {
      my $tx = shift;
      say $tx->result->body;
    })->catch(sub {
      my $err = shift;
      warn "Connection error: $err";
    })->wait;
  
  =head2 patch
  
    my $tx = $ua->patch('example.com');
    my $tx = $ua->patch('http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->patch(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->patch(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<PATCH> request and return resulting
  L<Mojo::Transaction::HTTP> object, takes the same arguments as
  L<Mojo::UserAgent::Transactor/"tx"> (except for the C<PATCH> method, which is
  implied). You can also append a callback to perform requests non-blocking.
  
    $ua->patch('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 patch_p
  
    my $promise = $ua->patch_p('http://example.com');
  
  Same as L</"patch">, but performs all requests non-blocking and returns a
  L<Mojo::Promise> object instead of accepting a callback.
  
    $ua->patch_p('http://example.com' => json => {a => 'b'})->then(sub {
      my $tx = shift;
      say $tx->result->body;
    })->catch(sub {
      my $err = shift;
      warn "Connection error: $err";
    })->wait;
  
  =head2 post
  
    my $tx = $ua->post('example.com');
    my $tx = $ua->post('http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->post(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->post(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<POST> request and return resulting
  L<Mojo::Transaction::HTTP> object, takes the same arguments as
  L<Mojo::UserAgent::Transactor/"tx"> (except for the C<POST> method, which is
  implied). You can also append a callback to perform requests non-blocking.
  
    $ua->post('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 post_p
  
    my $promise = $ua->post_p('http://example.com');
  
  Same as L</"post">, but performs all requests non-blocking and returns a
  L<Mojo::Promise> object instead of accepting a callback.
  
    $ua->post_p('http://example.com' => json => {a => 'b'})->then(sub {
      my $tx = shift;
      say $tx->result->body;
    })->catch(sub {
      my $err = shift;
      warn "Connection error: $err";
    })->wait;
  
  =head2 put
  
    my $tx = $ua->put('example.com');
    my $tx = $ua->put('http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->put(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->put(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<PUT> request and return resulting L<Mojo::Transaction::HTTP>
  object, takes the same arguments as L<Mojo::UserAgent::Transactor/"tx"> (except
  for the C<PUT> method, which is implied). You can also append a callback to
  perform requests non-blocking.
  
    $ua->put('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 put_p
  
    my $promise = $ua->put_p('http://example.com');
  
  Same as L</"put">, but performs all requests non-blocking and returns a
  L<Mojo::Promise> object instead of accepting a callback.
  
    $ua->put_p('http://example.com' => json => {a => 'b'})->then(sub {
      my $tx = shift;
      say $tx->result->body;
    })->catch(sub {
      my $err = shift;
      warn "Connection error: $err";
    })->wait;
  
  =head2 start
  
    my $tx = $ua->start(Mojo::Transaction::HTTP->new);
  
  Perform blocking request for a custom L<Mojo::Transaction::HTTP> object, which
  can be prepared manually or with L</"build_tx">. You can also append a callback
  to perform requests non-blocking.
  
    my $tx = $ua->build_tx(GET => 'http://example.com');
    $ua->start($tx => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 start_p
  
    my $promise = $ua->start_p(Mojo::Transaction::HTTP->new);
  
  Same as L</"start">, but performs all requests non-blocking and returns a
  L<Mojo::Promise> object instead of accepting a callback.
  
    my $tx = $ua->build_tx(GET => 'http://example.com');
    $ua->start_p($tx)->then(sub {
      my $tx = shift;
      say $tx->result->body;
    })->catch(sub {
      my $err = shift;
      warn "Connection error: $err";
    })->wait;
  
  =head2 websocket
  
    $ua->websocket('ws://example.com' => sub {...});
    $ua->websocket(
      'ws://example.com' => {DNT => 1} => ['v1.proto'] => sub {...});
  
  Open a non-blocking WebSocket connection with transparent handshake, takes the
  same arguments as L<Mojo::UserAgent::Transactor/"websocket">. The callback will
  receive either a L<Mojo::Transaction::WebSocket> or L<Mojo::Transaction::HTTP>
  object, depending on if the handshake was successful.
  
    $ua->websocket('wss://example.com/echo' => ['v1.proto'] => sub {
      my ($ua, $tx) = @_;
      say 'WebSocket handshake failed!' and return unless $tx->is_websocket;
      say 'Subprotocol negotiation failed!' and return unless $tx->protocol;
      $tx->on(finish => sub {
        my ($tx, $code, $reason) = @_;
        say "WebSocket closed with status $code.";
      });
      $tx->on(message => sub {
        my ($tx, $msg) = @_;
        say "WebSocket message: $msg";
        $tx->finish;
      });
      $tx->send('Hi!');
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  You can activate C<permessage-deflate> compression by setting the
  C<Sec-WebSocket-Extensions> header, this can result in much better performance,
  but also increases memory usage by up to 300KiB per connection.
  
    $ua->websocket('ws://example.com/foo' => {
      'Sec-WebSocket-Extensions' => 'permessage-deflate'
    } => sub {...});
  
  =head2 websocket_p
  
    my $promise = $ua->websocket_p('ws://example.com');
  
  Same as L</"websocket">, but returns a L<Mojo::Promise> object instead of
  accepting a callback.
  
    $ua->websocket_p('wss://example.com/echo')->then(sub {
      my $tx = shift;
      my $promise = Mojo::Promise->new;
      $tx->on(finish => sub { $promise->resolve });
      $tx->on(message => sub {
        my ($tx, $msg) = @_;
        say "WebSocket message: $msg";
        $tx->finish;
      });
      $tx->send('Hi!');
      return $promise;
    })->catch(sub {
      my $err = shift;
      warn "WebSocket error: $err";
    })->wait;
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_CLIENT_DEBUG> environment variable to get some advanced
  diagnostics information printed to C<STDERR>.
  
    MOJO_CLIENT_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_USERAGENT

$fatpacked{"Mojo/UserAgent/CookieJar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT_COOKIEJAR';
  package Mojo::UserAgent::CookieJar;
  use Mojo::Base -base;
  
  use Mojo::Cookie::Request;
  use Mojo::Path;
  use Scalar::Util 'looks_like_number';
  
  has 'ignore';
  has max_cookie_size => 4096;
  
  sub add {
    my ($self, @cookies) = @_;
  
    my $size = $self->max_cookie_size;
    for my $cookie (@cookies) {
  
      # Convert max age to expires
      my $age = $cookie->max_age;
      $cookie->expires($age <= 0 ? 0 : $age + time) if looks_like_number $age;
  
      # Check cookie size
      next if length($cookie->value // '') > $size;
  
      # Replace cookie
      next unless my $domain = lc($cookie->domain // '');
      next unless my $path   = $cookie->path;
      next unless length(my $name = $cookie->name // '');
      my $jar = $self->{jar}{$domain} ||= [];
      @$jar = (grep({ _compare($_, $path, $name, $domain) } @$jar), $cookie);
    }
  
    return $self;
  }
  
  sub all {
    my $jar = shift->{jar};
    return [map { @{$jar->{$_}} } sort keys %$jar];
  }
  
  sub collect {
    my ($self, $tx) = @_;
  
    my $url = $tx->req->url;
    for my $cookie (@{$tx->res->cookies}) {
  
      # Validate domain
      my $host = lc $url->ihost;
      $cookie->domain($host)->host_only(1) unless $cookie->domain;
      my $domain = lc $cookie->domain;
      if (my $cb = $self->ignore) { next if $cb->($cookie) }
      next if $host ne $domain && ($host !~ /\Q.$domain\E$/ || $host =~ /\.\d+$/);
  
      # Validate path
      my $path = $cookie->path // $url->path->to_dir->to_abs_string;
      $path = Mojo::Path->new($path)->trailing_slash(0)->to_abs_string;
      next unless _path($path, $url->path->to_abs_string);
      $self->add($cookie->path($path));
    }
  }
  
  sub empty { delete shift->{jar} }
  
  sub find {
    my ($self, $url) = @_;
  
    my @found;
    my $domain = my $host = lc $url->ihost;
    my $path = $url->path->to_abs_string;
    while ($domain) {
      next unless my $old = $self->{jar}{$domain};
  
      # Grab cookies
      my $new = $self->{jar}{$domain} = [];
      for my $cookie (@$old) {
        next if $cookie->host_only && $host ne $cookie->domain;
  
        # Check if cookie has expired
        if (defined(my $expires = $cookie->expires)) { next if time > $expires }
        push @$new, $cookie;
  
        # Taste cookie
        next if $cookie->secure && $url->protocol ne 'https';
        next unless _path($cookie->path, $path);
        my $name  = $cookie->name;
        my $value = $cookie->value;
        push @found, Mojo::Cookie::Request->new(name => $name, value => $value);
      }
    }
  
    # Remove another part
    continue { $domain =~ s/^[^.]*\.*// }
  
    return \@found;
  }
  
  sub prepare {
    my ($self, $tx) = @_;
    return unless keys %{$self->{jar}};
    my $req = $tx->req;
    $req->cookies(@{$self->find($req->url)});
  }
  
  sub _compare {
    my ($cookie, $path, $name, $domain) = @_;
    return
         $cookie->path ne $path
      || $cookie->name ne $name
      || $cookie->domain ne $domain;
  }
  
  sub _path { $_[0] eq '/' || $_[0] eq $_[1] || index($_[1], "$_[0]/") == 0 }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::UserAgent::CookieJar - Cookie jar for HTTP user agents
  
  =head1 SYNOPSIS
  
    use Mojo::UserAgent::CookieJar;
  
    # Add response cookies
    my $jar = Mojo::UserAgent::CookieJar->new;
    $jar->add(
      Mojo::Cookie::Response->new(
        name   => 'foo',
        value  => 'bar',
        domain => 'localhost',
        path   => '/test'
      )
    );
  
    # Find request cookies
    for my $cookie (@{$jar->find(Mojo::URL->new('http://localhost/test'))}) {
      say $cookie->name;
      say $cookie->value;
    }
  
  =head1 DESCRIPTION
  
  L<Mojo::UserAgent::CookieJar> is a minimalistic and relaxed cookie jar used by
  L<Mojo::UserAgent>, based on L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::UserAgent::CookieJar> implements the following attributes.
  
  =head2 ignore
  
    my $ignore = $jar->ignore;
    $jar       = $jar->ignore(sub {...});
  
  A callback used to decide if a cookie should be ignored by L</"collect">.
  
    # Ignore all cookies
    $jar->ignore(sub { 1 });
  
    # Ignore cookies for domains "com", "net" and "org"
    $jar->ignore(sub {
      my $cookie = shift;
      return undef unless my $domain = $cookie->domain;
      return $domain eq 'com' || $domain eq 'net' || $domain eq 'org';
    });
  
  =head2 max_cookie_size
  
    my $size = $jar->max_cookie_size;
    $jar     = $jar->max_cookie_size(4096);
  
  Maximum cookie size in bytes, defaults to C<4096> (4KiB).
  
  =head1 METHODS
  
  L<Mojo::UserAgent::CookieJar> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 add
  
    $jar = $jar->add(@cookies);
  
  Add multiple L<Mojo::Cookie::Response> objects to the jar.
  
  =head2 all
  
    my $cookies = $jar->all;
  
  Return all L<Mojo::Cookie::Response> objects that are currently stored in the
  jar.
  
    # Names of all cookies
    say $_->name for @{$jar->all};
  
  =head2 collect
  
    $jar->collect(Mojo::Transaction::HTTP->new);
  
  Collect response cookies from transaction.
  
  =head2 empty
  
    $jar->empty;
  
  Empty the jar.
  
  =head2 find
  
    my $cookies = $jar->find(Mojo::URL->new);
  
  Find L<Mojo::Cookie::Request> objects in the jar for L<Mojo::URL> object.
  
    # Names of all cookies found
    say $_->name for @{$jar->find(Mojo::URL->new('http://example.com/foo'))};
  
  =head2 prepare
  
    $jar->prepare(Mojo::Transaction::HTTP->new);
  
  Prepare request cookies for transaction.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_USERAGENT_COOKIEJAR

$fatpacked{"Mojo/UserAgent/Proxy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT_PROXY';
  package Mojo::UserAgent::Proxy;
  use Mojo::Base -base;
  
  use Mojo::URL;
  
  has [qw(http https not)];
  
  sub detect {
    my $self = shift;
    $self->http($ENV{HTTP_PROXY}   || $ENV{http_proxy});
    $self->https($ENV{HTTPS_PROXY} || $ENV{https_proxy});
    return $self->not([split ',', $ENV{NO_PROXY} || $ENV{no_proxy} || '']);
  }
  
  sub is_needed {
    !grep { $_[1] =~ /\Q$_\E$/ } @{$_[0]->not || []};
  }
  
  sub prepare {
    my ($self, $tx) = @_;
  
    $self->detect if $ENV{MOJO_PROXY};
    my $req = $tx->req;
    my $url = $req->url;
    return unless $self->is_needed($url->host);
  
    # HTTP proxy
    my $proto = $url->protocol;
    my $http  = $self->http;
    $req->proxy(Mojo::URL->new($http)) if $http && $proto eq 'http';
  
    # HTTPS proxy
    my $https = $self->https;
    $req->proxy(Mojo::URL->new($https)) if $https && $proto eq 'https';
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::UserAgent::Proxy - User agent proxy manager
  
  =head1 SYNOPSIS
  
    use Mojo::UserAgent::Proxy;
  
    my $proxy = Mojo::UserAgent::Proxy->new;
    $proxy->detect;
    say $proxy->http;
  
  =head1 DESCRIPTION
  
  L<Mojo::UserAgent::Proxy> manages proxy servers for L<Mojo::UserAgent>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::UserAgent::Proxy> implements the following attributes.
  
  =head2 http
  
    my $http = $proxy->http;
    $proxy   = $proxy->http('socks://sri:secret@127.0.0.1:8080');
  
  Proxy server to use for HTTP and WebSocket requests.
  
  =head2 https
  
    my $https = $proxy->https;
    $proxy    = $proxy->https('http://sri:secret@127.0.0.1:8080');
  
  Proxy server to use for HTTPS and WebSocket requests.
  
  =head2 not
  
    my $not = $proxy->not;
    $proxy  = $proxy->not(['localhost', 'intranet.mojolicious.org']);
  
  Domains that don't require a proxy server to be used.
  
  =head1 METHODS
  
  L<Mojo::UserAgent::Proxy> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 detect
  
    $proxy = $proxy->detect;
  
  Check environment variables C<HTTP_PROXY>, C<http_proxy>, C<HTTPS_PROXY>,
  C<https_proxy>, C<NO_PROXY> and C<no_proxy> for proxy information. Automatic
  proxy detection can be enabled with the C<MOJO_PROXY> environment variable.
  
  =head2 is_needed
  
    my $bool = $proxy->is_needed('intranet.example.com');
  
  Check if request for domain would use a proxy server.
  
  =head2 prepare
  
    $proxy->prepare(Mojo::Transaction::HTTP->new);
  
  Prepare proxy server information for transaction.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_USERAGENT_PROXY

$fatpacked{"Mojo/UserAgent/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT_SERVER';
  package Mojo::UserAgent::Server;
  use Mojo::Base -base;
  
  use Mojo::IOLoop;
  use Mojo::Server::Daemon;
  use Scalar::Util 'weaken';
  
  has ioloop => sub { Mojo::IOLoop->singleton };
  
  sub app {
    my ($self, $app) = @_;
  
    # Singleton application
    state $singleton;
    return $singleton = $app ? $app : $singleton unless ref $self;
  
    # Default to singleton application
    return $self->{app} || $singleton unless $app;
    $self->{app} = $app;
    return $self;
  }
  
  sub nb_url { shift->_url(1, @_) }
  
  sub restart { delete @{$_[0]}{qw(nb_port nb_server port server)} }
  
  sub url { shift->_url(0, @_) }
  
  sub _url {
    my ($self, $nb, $proto) = @_;
  
    if (!$self->{server} || $proto) {
      $proto = $self->{proto} = $proto || 'http';
  
      # Blocking
      my $server = $self->{server}
        = Mojo::Server::Daemon->new(ioloop => $self->ioloop, silent => 1);
      weaken $server->app($self->app)->{app};
      my $port = $self->{port} ? ":$self->{port}" : '';
      $self->{port}
        = $server->listen(["$proto://127.0.0.1$port"])->start->ports->[0];
  
      # Non-blocking
      $server = $self->{nb_server} = Mojo::Server::Daemon->new(silent => 1);
      weaken $server->app($self->app)->{app};
      $port = $self->{nb_port} ? ":$self->{nb_port}" : '';
      $self->{nb_port}
        = $server->listen(["$proto://127.0.0.1$port"])->start->ports->[0];
    }
  
    my $port = $nb ? $self->{nb_port} : $self->{port};
    return Mojo::URL->new("$self->{proto}://127.0.0.1:$port/");
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::UserAgent::Server - Application server
  
  =head1 SYNOPSIS
  
    use Mojo::UserAgent::Server;
  
    my $server = Mojo::UserAgent::Server->new;
    say $server->url;
  
  =head1 DESCRIPTION
  
  L<Mojo::UserAgent::Server> is an embedded web server based on
  L<Mojo::Server::Daemon> that processes requests for L<Mojo::UserAgent>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::UserAgent::Server> implements the following attributes.
  
  =head2 ioloop
  
    my $loop = $server->ioloop;
    $server  = $server->ioloop(Mojo::IOLoop->new);
  
  Event loop object to use for I/O operations, defaults to the global
  L<Mojo::IOLoop> singleton.
  
  =head1 METHODS
  
  L<Mojo::UserAgent::Server> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 app
  
    my $app = Mojo::UserAgent::Server->app;
              Mojo::UserAgent::Server->app(Mojolicious->new);
    my $app = $server->app;
    $server = $server->app(Mojolicious->new);
  
  Application this server handles, instance specific applications override the
  global default.
  
    # Change application behavior
    $server->app->defaults(testing => 'oh yea!');
  
  =head2 nb_url
  
    my $url = $ua->nb_url;
    my $url = $ua->nb_url('http');
    my $url = $ua->nb_url('https');
  
  Get absolute L<Mojo::URL> object for server processing non-blocking requests
  with L</"app"> and switch protocol if necessary.
  
  =head2 restart
  
    $server->restart;
  
  Restart server with new port.
  
  =head2 url
  
    my $url = $ua->url;
    my $url = $ua->url('http');
    my $url = $ua->url('https');
  
  Get absolute L<Mojo::URL> object for server processing blocking requests with
  L</"app"> and switch protocol if necessary.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_USERAGENT_SERVER

$fatpacked{"Mojo/UserAgent/Transactor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT_TRANSACTOR';
  package Mojo::UserAgent::Transactor;
  use Mojo::Base -base;
  
  use Mojo::Asset::File;
  use Mojo::Asset::Memory;
  use Mojo::Content::MultiPart;
  use Mojo::Content::Single;
  use Mojo::File 'path';
  use Mojo::JSON 'encode_json';
  use Mojo::Parameters;
  use Mojo::Transaction::HTTP;
  use Mojo::Transaction::WebSocket;
  use Mojo::URL;
  use Mojo::Util qw(encode url_escape);
  use Mojo::WebSocket qw(challenge client_handshake);
  
  has generators =>
    sub { {form => \&_form, json => \&_json, multipart => \&_multipart} };
  has name => 'Mojolicious (Perl)';
  
  sub add_generator { $_[0]->generators->{$_[1]} = $_[2] and return $_[0] }
  
  sub endpoint {
    my ($self, $tx) = @_;
  
    # Basic endpoint
    my $req   = $tx->req;
    my $url   = $req->url;
    my $proto = $url->protocol || 'http';
    my $host  = $url->ihost;
    my $port  = $url->port // ($proto eq 'https' ? 443 : 80);
  
    # Proxy for normal HTTP requests
    my $socks;
    if (my $proxy = $req->proxy) { $socks = $proxy->protocol eq 'socks' }
    return _proxy($tx, $proto, $host, $port)
      if $proto eq 'http' && !$req->is_handshake && !$socks;
  
    return $proto, $host, $port;
  }
  
  sub peer { _proxy($_[1], $_[0]->endpoint($_[1])) }
  
  sub promisify {
    my ($self, $promise, $tx) = @_;
    my $err = $tx->error;
    return $promise->reject($err->{message}) if $err && !$err->{code};
    return $promise->reject('WebSocket handshake failed')
      if $tx->req->is_handshake && !$tx->is_websocket;
    $promise->resolve($tx);
  }
  
  sub proxy_connect {
    my ($self, $old) = @_;
  
    # Already a CONNECT request
    my $req = $old->req;
    return undef if uc $req->method eq 'CONNECT';
  
    # No proxy
    return undef unless (my $proxy = $req->proxy) && $req->via_proxy;
    return undef if $proxy->protocol eq 'socks';
  
    # WebSocket and/or HTTPS
    my $url = $req->url;
    return undef unless $req->is_handshake || $url->protocol eq 'https';
  
    # CONNECT request (expect a bad response)
    my $new = $self->tx(CONNECT => $url->clone->userinfo(undef));
    $new->req->proxy($proxy);
    $new->res->content->auto_relax(0)->headers->connection('keep-alive');
  
    return $new;
  }
  
  sub redirect {
    my ($self, $old) = @_;
  
    # Commonly used codes
    my $res  = $old->res;
    my $code = $res->code // 0;
    return undef unless grep { $_ == $code } 301, 302, 303, 307, 308;
  
    # CONNECT requests cannot be redirected
    my $req = $old->req;
    return undef if uc $req->method eq 'CONNECT';
  
    # Fix location without authority and/or scheme
    return undef
      unless my $location = $res->headers->every_header('Location')->[0];
    $location = Mojo::URL->new($location);
    $location = $location->base($req->url)->to_abs unless $location->is_abs;
    my $proto = $location->protocol;
    return undef if ($proto ne 'http' && $proto ne 'https') || !$location->host;
  
    # Clone request if necessary
    my $new = Mojo::Transaction::HTTP->new;
    if ($code == 307 || $code == 308) {
      return undef unless my $clone = $req->clone;
      $new->req($clone);
    }
    else {
      my $m = uc $req->method;
      my $headers = $new->req->method($code == 303 || $m eq 'POST' ? 'GET' : $m)
        ->content->headers($req->headers->clone)->headers;
      $headers->remove($_) for grep {/^content-/i} @{$headers->names};
    }
    my $headers = $new->req->url($location)->headers;
    $headers->remove($_) for qw(Authorization Cookie Host Referer);
    return $new->previous($old);
  }
  
  sub tx {
    my ($self, $method, $url) = (shift, shift, shift);
  
    # Method and URL
    my $tx  = Mojo::Transaction::HTTP->new;
    my $req = $tx->req->method($method);
    if   (ref $url) { $req->url($url) }
    else            { $req->url->parse($url =~ m!^/|://! ? $url : "http://$url") }
  
    # Headers (we identify ourselves and accept gzip compression)
    my $headers = $req->headers;
    $headers->from_hash(shift) if ref $_[0] eq 'HASH';
    $headers->user_agent($self->name) unless $headers->user_agent;
    $headers->accept_encoding('gzip') unless $headers->accept_encoding;
  
    # Generator
    if (@_ > 1) {
      my $cb = $self->generators->{shift()};
      $self->$cb($tx, @_);
    }
  
    # Body
    elsif (@_) { $req->body(shift) }
  
    return $tx;
  }
  
  sub upgrade {
    my ($self, $tx) = @_;
    my $code = $tx->res->code // 0;
    return undef unless $tx->req->is_handshake && $code == 101;
    my $ws = Mojo::Transaction::WebSocket->new(handshake => $tx, masked => 1);
    return challenge($ws) ? $ws->established(1) : undef;
  }
  
  sub websocket {
    my $self = shift;
  
    # New WebSocket transaction
    my $sub = ref $_[-1] eq 'ARRAY' ? pop : [];
    my $tx = $self->tx(GET => @_);
    my $req = $tx->req;
    $req->headers->sec_websocket_protocol(join ', ', @$sub) if @$sub;
  
    # Handshake protocol
    my $url   = $req->url;
    my $proto = $url->protocol // '';
    if    ($proto eq 'ws')      { $url->scheme('http') }
    elsif ($proto eq 'wss')     { $url->scheme('https') }
    elsif ($proto eq 'ws+unix') { $url->scheme('http+unix') }
  
    return client_handshake $tx;
  }
  
  sub _content { Mojo::Content::MultiPart->new(headers => $_[0], parts => $_[1]) }
  
  sub _form {
    my ($self, $tx, $form, %options) = @_;
    $options{charset} = 'UTF-8' unless exists $options{charset};
  
    # Check for uploads and force multipart if necessary
    my $req       = $tx->req;
    my $headers   = $req->headers;
    my $multipart = ($headers->content_type // '') =~ m!multipart/form-data!i;
    for my $value (map { ref $_ eq 'ARRAY' ? @$_ : $_ } values %$form) {
      ++$multipart and last if ref $value eq 'HASH';
    }
  
    # Multipart
    if ($multipart) {
      $req->content(_content($headers, _form_parts($options{charset}, $form)));
      _type($headers, 'multipart/form-data');
      return $tx;
    }
  
    # Query parameters or urlencoded
    my $method = uc $req->method;
    my @form = map { $_ => $form->{$_} } sort keys %$form;
    if ($method eq 'GET' || $method eq 'HEAD') { $req->url->query->merge(@form) }
    else {
      $req->body(
        Mojo::Parameters->new(@form)->charset($options{charset})->to_string);
      _type($headers, 'application/x-www-form-urlencoded');
    }
    return $tx;
  }
  
  sub _form_parts {
    my ($charset, $form) = @_;
  
    my @parts;
    for my $name (sort keys %$form) {
      next unless defined(my $values = $form->{$name});
      $values = [$values] unless ref $values eq 'ARRAY';
      push @parts, @{_parts($charset, $name, $values)};
    }
  
    return \@parts;
  }
  
  sub _json {
    my ($self, $tx, $data) = @_;
    _type($tx->req->body(encode_json $data)->headers, 'application/json');
    return $tx;
  }
  
  sub _multipart {
    my ($self, $tx, $parts) = @_;
    my $req = $tx->req;
    $req->content(_content($req->headers, _parts(undef, undef, $parts)));
    return $tx;
  }
  
  sub _parts {
    my ($charset, $name, $values) = @_;
  
    my @parts;
    for my $value (@$values) {
      push @parts, my $part = Mojo::Content::Single->new;
  
      my $filename;
      my $headers = $part->headers;
      if (ref $value eq 'HASH') {
  
        # File
        if (my $file = delete $value->{file}) {
          $file = Mojo::Asset::File->new(path => $file) unless ref $file;
          $part->asset($file);
          $value->{filename} //= path($file->path)->basename
            if $file->isa('Mojo::Asset::File');
        }
  
        # Memory
        elsif (defined(my $content = delete $value->{content})) {
          $part->asset(Mojo::Asset::Memory->new->add_chunk($content));
        }
  
        # Filename and headers
        $filename = delete $value->{filename};
        $headers->from_hash($value);
        next unless defined $name;
        $filename = url_escape $filename // $name, '"';
        $filename = encode $charset, $filename if $charset;
      }
  
      # Field
      else {
        $value = encode $charset, $value if $charset;
        $part->asset(Mojo::Asset::Memory->new->add_chunk($value));
      }
  
      # Content-Disposition
      next unless defined $name;
      $name = url_escape $name, '"';
      $name = encode $charset, $name if $charset;
      my $disposition = qq{form-data; name="$name"};
      $disposition .= qq{; filename="$filename"} if defined $filename;
      $headers->content_disposition($disposition);
    }
  
    return \@parts;
  }
  
  sub _proxy {
    my ($tx, $proto, $host, $port) = @_;
  
    my $req = $tx->req;
    if ($req->via_proxy && (my $proxy = $req->proxy)) {
      return $proxy->protocol, $proxy->ihost,
        $proxy->port // ($proto eq 'https' ? 443 : 80);
    }
  
    return $proto, $host, $port;
  }
  
  sub _type { $_[0]->content_type($_[1]) unless $_[0]->content_type }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::UserAgent::Transactor - User agent transactor
  
  =head1 SYNOPSIS
  
    use Mojo::UserAgent::Transactor;
  
    # GET request with Accept header
    my $t = Mojo::UserAgent::Transactor->new;
    say $t->tx(GET => 'http://example.com' => {Accept => '*/*'})->req->to_string;
  
    # POST request with form-data
    say $t->tx(POST => 'example.com' => form => {a => 'b'})->req->to_string;
  
    # PUT request with JSON data
    say $t->tx(PUT => 'example.com' => json => {a => 'b'})->req->to_string;
  
  =head1 DESCRIPTION
  
  L<Mojo::UserAgent::Transactor> is the transaction building and manipulation
  framework used by L<Mojo::UserAgent>.
  
  =head1 GENERATORS
  
  These content generators are available by default.
  
  =head2 form
  
    $t->tx(POST => 'http://example.com' => form => {a => 'b'});
  
  Generate query string, C<application/x-www-form-urlencoded> or
  C<multipart/form-data> content. See L</"tx"> for more.
  
  =head2 json
  
    $t->tx(PATCH => 'http://example.com' => json => {a => 'b'});
  
  Generate JSON content with L<Mojo::JSON>. See L</"tx"> for more.
  
  =head2 multipart
  
    $t->tx(PUT => 'http://example.com' => multipart => ['Hello', 'World!']);
  
  Generate multipart content. See L</"tx"> for more.
  
  =head1 ATTRIBUTES
  
  L<Mojo::UserAgent::Transactor> implements the following attributes.
  
  =head2 generators
  
    my $generators = $t->generators;
    $t             = $t->generators({foo => sub {...}});
  
  Registered content generators, by default only C<form>, C<json> and C<multipart>
  are already defined.
  
  =head2 name
  
    my $name = $t->name;
    $t       = $t->name('Mojolicious');
  
  Value for C<User-Agent> request header of generated transactions, defaults to
  C<Mojolicious (Perl)>.
  
  =head1 METHODS
  
  L<Mojo::UserAgent::Transactor> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 add_generator
  
    $t = $t->add_generator(foo => sub {...});
  
  Register a content generator.
  
    $t->add_generator(foo => sub {
      my ($t, $tx, @args) = @_;
      ...
    });
  
  =head2 endpoint
  
    my ($proto, $host, $port) = $t->endpoint(Mojo::Transaction::HTTP->new);
  
  Actual endpoint for transaction.
  
  =head2 peer
  
    my ($proto, $host, $port) = $t->peer(Mojo::Transaction::HTTP->new);
  
  Actual peer for transaction.
  
  =head2 promisify
  
    $t->promisify(Mojo::Promise->new, Mojo::Transaction::HTTP->new);
  
  Resolve or reject L<Mojo::Promise> object with L<Mojo::Transaction::HTTP>
  object.
  
  =head2 proxy_connect
  
    my $tx = $t->proxy_connect(Mojo::Transaction::HTTP->new);
  
  Build L<Mojo::Transaction::HTTP> proxy C<CONNECT> request for transaction if
  possible.
  
  =head2 redirect
  
    my $tx = $t->redirect(Mojo::Transaction::HTTP->new);
  
  Build L<Mojo::Transaction::HTTP> follow-up request for C<301>, C<302>, C<303>,
  C<307> or C<308> redirect response if possible.
  
  =head2 tx
  
    my $tx = $t->tx(GET  => 'example.com');
    my $tx = $t->tx(POST => 'http://example.com');
    my $tx = $t->tx(GET  => 'http://example.com' => {Accept => '*/*'});
    my $tx = $t->tx(PUT  => 'http://example.com' => 'Content!');
    my $tx = $t->tx(PUT  => 'http://example.com' => form => {a => 'b'});
    my $tx = $t->tx(PUT  => 'http://example.com' => json => {a => 'b'});
    my $tx = $t->tx(PUT  => 'https://example.com' => multipart => ['a', 'b']);
    my $tx = $t->tx(POST => 'example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $t->tx(
      PUT => 'example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $t->tx(
      PUT => 'example.com' => {Accept => '*/*'} => json => {a => 'b'});
    my $tx = $t->tx(
      PUT => 'example.com' => {Accept => '*/*'} => multipart => ['a', 'b']);
  
  Versatile general purpose L<Mojo::Transaction::HTTP> transaction builder for
  requests, with support for L</"GENERATORS">.
  
    # Generate and inspect custom GET request with DNT header and content
    say $t->tx(GET => 'example.com' => {DNT => 1} => 'Bye!')->req->to_string;
  
    # Stream response content to STDOUT
    my $tx = $t->tx(GET => 'http://example.com');
    $tx->res->content->unsubscribe('read')->on(read => sub { say $_[1] });
  
    # PUT request with content streamed from file
    my $tx = $t->tx(PUT => 'http://example.com');
    $tx->req->content->asset(Mojo::Asset::File->new(path => '/foo.txt'));
  
  The C<json> content generator uses L<Mojo::JSON> for encoding and sets the
  content type to C<application/json>.
  
    # POST request with "application/json" content
    my $tx = $t->tx(
      POST => 'http://example.com' => json => {a => 'b', c => [1, 2, 3]});
  
  The C<form> content generator will automatically use query parameters for
  C<GET> and C<HEAD> requests.
  
    # GET request with query parameters
    my $tx = $t->tx(GET => 'http://example.com' => form => {a => 'b'});
  
  For all other request methods the C<application/x-www-form-urlencoded> content
  type is used.
  
    # POST request with "application/x-www-form-urlencoded" content
    my $tx = $t->tx(
      POST => 'http://example.com' => form => {a => 'b', c => 'd'});
  
  Parameters may be encoded with the C<charset> option.
  
    # PUT request with Shift_JIS encoded form values
    my $tx = $t->tx(
      PUT => 'example.com' => form => {a => 'b'} => charset => 'Shift_JIS');
  
  An array reference can be used for multiple form values sharing the same name.
  
    # POST request with form values sharing the same name
    my $tx = $t->tx(
      POST => 'http://example.com' => form => {a => ['b', 'c', 'd']});
  
  A hash reference with a C<content> or C<file> value can be used to switch to
  the C<multipart/form-data> content type for file uploads.
  
    # POST request with "multipart/form-data" content
    my $tx = $t->tx(
      POST => 'http://example.com' => form => {mytext => {content => 'lala'}});
  
    # POST request with multiple files sharing the same name
    my $tx = $t->tx(POST => 'http://example.com' =>
      form => {mytext => [{content => 'first'}, {content => 'second'}]});
  
  The C<file> value should contain the path to the file you want to upload or an
  asset object, like L<Mojo::Asset::File> or L<Mojo::Asset::Memory>.
  
    # POST request with upload streamed from file
    my $tx = $t->tx(
      POST => 'http://example.com' => form => {mytext => {file => '/foo.txt'}});
  
    # POST request with upload streamed from asset
    my $asset = Mojo::Asset::Memory->new->add_chunk('lalala');
    my $tx    = $t->tx(
      POST => 'http://example.com' => form => {mytext => {file => $asset}});
  
  A C<filename> value will be generated automatically, but can also be set
  manually if necessary. All remaining values in the hash reference get merged
  into the C<multipart/form-data> content as headers.
  
    # POST request with form values and customized upload (filename and header)
    my $tx = $t->tx(POST => 'http://example.com' => form => {
      a      => 'b',
      c      => 'd',
      mytext => {
        content        => 'lalala',
        filename       => 'foo.txt',
        'Content-Type' => 'text/plain'
      }
    });
  
  The C<multipart/form-data> content type can also be enforced by setting the
  C<Content-Type> header manually.
  
    # Force "multipart/form-data"
    my $headers = {'Content-Type' => 'multipart/form-data'};
    my $tx = $t->tx(POST => 'example.com' => $headers => form => {a => 'b'});
  
  The C<multipart> content generator can be used to build custom multipart
  requests and does not set a content type.
  
    # POST request with multipart content ("foo" and "bar")
    my $tx = $t->tx(POST => 'http://example.com' => multipart => ['foo', 'bar']);
  
  Similar to the C<form> content generator you can also pass hash references with
  C<content> or C<file> values, as well as headers.
  
    # POST request with multipart content streamed from file
    my $tx = $t->tx(
      POST => 'http://example.com' => multipart => [{file => '/foo.txt'}]);
  
    # PUT request with multipart content streamed from asset
    my $headers = {'Content-Type' => 'multipart/custom'};
    my $asset   = Mojo::Asset::Memory->new->add_chunk('lalala');
    my $tx      = $t->tx(
      PUT => 'http://example.com' => $headers => multipart => [{file => $asset}]);
  
    # POST request with multipart content and custom headers
    my $tx = $t->tx(POST => 'http://example.com' => multipart => [
      {
        content            => 'Hello',
        'Content-Type'     => 'text/plain',
        'Content-Language' => 'en-US'
      },
      {
        content            => 'World!',
        'Content-Type'     => 'text/plain',
        'Content-Language' => 'en-US'
      }
    ]);
  
  =head2 upgrade
  
    my $tx = $t->upgrade(Mojo::Transaction::HTTP->new);
  
  Build L<Mojo::Transaction::WebSocket> follow-up transaction for WebSocket
  handshake if possible.
  
  =head2 websocket
  
    my $tx = $t->websocket('ws://example.com');
    my $tx = $t->websocket('ws://example.com' => {DNT => 1} => ['v1.proto']);
  
  Versatile L<Mojo::Transaction::HTTP> transaction builder for WebSocket
  handshake requests.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_USERAGENT_TRANSACTOR

$fatpacked{"Mojo/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_UTIL';
  package Mojo::Util;
  use Mojo::Base -strict;
  
  use Carp qw(carp croak);
  use Data::Dumper ();
  use Digest::MD5 qw(md5 md5_hex);
  use Digest::SHA qw(hmac_sha1_hex sha1 sha1_hex);
  use Encode 'find_encoding';
  use Exporter 'import';
  use Getopt::Long 'GetOptionsFromArray';
  use IO::Poll qw(POLLIN POLLPRI);
  use List::Util 'min';
  use MIME::Base64 qw(decode_base64 encode_base64);
  use Pod::Usage 'pod2usage';
  use Symbol 'delete_package';
  use Time::HiRes        ();
  use Unicode::Normalize ();
  
  # Check for monotonic clock support
  use constant MONOTONIC =>
    eval { !!Time::HiRes::clock_gettime(Time::HiRes::CLOCK_MONOTONIC()) };
  
  # Punycode bootstring parameters
  use constant {
    PC_BASE         => 36,
    PC_TMIN         => 1,
    PC_TMAX         => 26,
    PC_SKEW         => 38,
    PC_DAMP         => 700,
    PC_INITIAL_BIAS => 72,
    PC_INITIAL_N    => 128
  };
  
  # Supported on Perl 5.22+
  my $NAME
    = eval { require Sub::Util; Sub::Util->can('set_subname') } || sub { $_[1] };
  
  # To generate a new HTML entity table run this command
  # perl examples/entities.pl
  my %ENTITIES;
  for my $line (split "\n", join('', <DATA>)) {
    next unless $line =~ /^(\S+)\s+U\+(\S+)(?:\s+U\+(\S+))?/;
    $ENTITIES{$1} = defined $3 ? (chr(hex $2) . chr(hex $3)) : chr(hex $2);
  }
  close DATA;
  
  # Characters that should be escaped in XML
  my %XML = (
    '&'  => '&amp;',
    '<'  => '&lt;',
    '>'  => '&gt;',
    '"'  => '&quot;',
    '\'' => '&#39;'
  );
  
  # "Sun, 06 Nov 1994 08:49:37 GMT" and "Sunday, 06-Nov-94 08:49:37 GMT"
  my $EXPIRES_RE = qr/(\w+\W+\d+\W+\w+\W+\d+\W+\d+:\d+:\d+\W*\w+)/;
  
  # HTML entities
  my $ENTITY_RE = qr/&(?:\#((?:[0-9]{1,7}|x[0-9a-fA-F]{1,6}));|(\w+[;=]?))/;
  
  # Encoding and pattern cache
  my (%ENCODING, %PATTERN);
  
  our @EXPORT_OK = (
    qw(b64_decode b64_encode camelize class_to_file class_to_path decamelize),
    qw(decode deprecated dumper encode extract_usage getopt hmac_sha1_sum),
    qw(html_attr_unescape html_unescape md5_bytes md5_sum monkey_patch),
    qw(punycode_decode punycode_encode quote secure_compare sha1_bytes sha1_sum),
    qw(slugify split_cookie_header split_header steady_time tablify term_escape),
    qw(trim unindent unquote url_escape url_unescape xml_escape xor_encode)
  );
  
  # Aliases
  monkey_patch(__PACKAGE__, 'b64_decode',    \&decode_base64);
  monkey_patch(__PACKAGE__, 'b64_encode',    \&encode_base64);
  monkey_patch(__PACKAGE__, 'hmac_sha1_sum', \&hmac_sha1_hex);
  monkey_patch(__PACKAGE__, 'md5_bytes',     \&md5);
  monkey_patch(__PACKAGE__, 'md5_sum',       \&md5_hex);
  monkey_patch(__PACKAGE__, 'sha1_bytes',    \&sha1);
  monkey_patch(__PACKAGE__, 'sha1_sum',      \&sha1_hex);
  
  # Use a monotonic clock if possible
  monkey_patch(__PACKAGE__, 'steady_time',
    MONOTONIC
    ? sub () { Time::HiRes::clock_gettime(Time::HiRes::CLOCK_MONOTONIC()) }
    : \&Time::HiRes::time);
  
  sub camelize {
    my $str = shift;
    return $str if $str =~ /^[A-Z]/;
  
    # CamelCase words
    return join '::', map {
      join('', map { ucfirst lc } split '_')
    } split '-', $str;
  }
  
  sub class_to_file {
    my $class = shift;
    $class =~ s/::|'//g;
    $class =~ s/([A-Z])([A-Z]*)/$1 . lc $2/ge;
    return decamelize($class);
  }
  
  sub class_to_path { join '.', join('/', split(/::|'/, shift)), 'pm' }
  
  sub decamelize {
    my $str = shift;
    return $str if $str !~ /^[A-Z]/;
  
    # snake_case words
    return join '-', map {
      join('_', map {lc} grep {length} split /([A-Z]{1}[^A-Z]*)/)
    } split '::', $str;
  }
  
  sub decode {
    my ($encoding, $bytes) = @_;
    return undef
      unless eval { $bytes = _encoding($encoding)->decode("$bytes", 1); 1 };
    return $bytes;
  }
  
  sub deprecated {
    local $Carp::CarpLevel = 1;
    $ENV{MOJO_FATAL_DEPRECATIONS} ? croak @_ : carp @_;
  }
  
  sub dumper {
    Data::Dumper->new([@_])->Indent(1)->Sortkeys(1)->Terse(1)->Useqq(1)->Dump;
  }
  
  sub encode { _encoding($_[0])->encode("$_[1]", 0) }
  
  sub extract_usage {
    my $file = @_ ? "$_[0]" : (caller)[1];
  
    open my $handle, '>', \my $output;
    pod2usage -exitval => 'noexit', -input => $file, -output => $handle;
    $output =~ s/^.*\n|\n$//;
    $output =~ s/\n$//;
  
    return unindent($output);
  }
  
  sub getopt {
    my ($array, $opts) = map { ref $_[0] eq 'ARRAY' ? shift : $_ } \@ARGV, [];
    my $save = Getopt::Long::Configure(qw(default no_auto_abbrev no_ignore_case),
      @$opts);
    GetOptionsFromArray $array, @_;
    Getopt::Long::Configure($save);
  }
  
  sub html_attr_unescape { _html(shift, 1) }
  sub html_unescape      { _html(shift, 0) }
  
  sub monkey_patch {
    my ($class, %patch) = @_;
    no strict 'refs';
    no warnings 'redefine';
    *{"${class}::$_"} = $NAME->("${class}::$_", $patch{$_}) for keys %patch;
  }
  
  # Direct translation of RFC 3492
  sub punycode_decode {
    my $input = shift;
    use integer;
  
    my ($n, $i, $bias, @output) = (PC_INITIAL_N, 0, PC_INITIAL_BIAS);
  
    # Consume all code points before the last delimiter
    push @output, split('', $1) if $input =~ s/(.*)\x2d//s;
  
    while (length $input) {
      my ($oldi, $w) = ($i, 1);
  
      # Base to infinity in steps of base
      for (my $k = PC_BASE; 1; $k += PC_BASE) {
        my $digit = ord substr $input, 0, 1, '';
        $digit = $digit < 0x40 ? $digit + (26 - 0x30) : ($digit & 0x1f) - 1;
        $i += $digit * $w;
        my $t = $k - $bias;
        $t = $t < PC_TMIN ? PC_TMIN : $t > PC_TMAX ? PC_TMAX : $t;
        last if $digit < $t;
        $w *= PC_BASE - $t;
      }
  
      $bias = _adapt($i - $oldi, @output + 1, $oldi == 0);
      $n += $i / (@output + 1);
      $i = $i % (@output + 1);
      splice @output, $i++, 0, chr $n;
    }
  
    return join '', @output;
  }
  
  # Direct translation of RFC 3492
  sub punycode_encode {
    my $output = shift;
    use integer;
  
    my ($n, $delta, $bias) = (PC_INITIAL_N, 0, PC_INITIAL_BIAS);
  
    # Extract basic code points
    my @input = map {ord} split '', $output;
    $output =~ s/[^\x00-\x7f]+//gs;
    my $h = my $basic = length $output;
    $output .= "\x2d" if $basic > 0;
  
    for my $m (sort grep { $_ >= PC_INITIAL_N } @input) {
      next if $m < $n;
      $delta += ($m - $n) * ($h + 1);
      $n = $m;
  
      for my $c (@input) {
  
        if ($c < $n) { $delta++ }
        elsif ($c == $n) {
          my $q = $delta;
  
          # Base to infinity in steps of base
          for (my $k = PC_BASE; 1; $k += PC_BASE) {
            my $t = $k - $bias;
            $t = $t < PC_TMIN ? PC_TMIN : $t > PC_TMAX ? PC_TMAX : $t;
            last if $q < $t;
            my $o = $t + (($q - $t) % (PC_BASE - $t));
            $output .= chr $o + ($o < 26 ? 0x61 : 0x30 - 26);
            $q = ($q - $t) / (PC_BASE - $t);
          }
  
          $output .= chr $q + ($q < 26 ? 0x61 : 0x30 - 26);
          $bias = _adapt($delta, $h + 1, $h == $basic);
          $delta = 0;
          $h++;
        }
      }
  
      $delta++;
      $n++;
    }
  
    return $output;
  }
  
  sub quote {
    my $str = shift;
    $str =~ s/(["\\])/\\$1/g;
    return qq{"$str"};
  }
  
  sub secure_compare {
    my ($one, $two) = @_;
    return undef if length $one != length $two;
    my $r = 0;
    $r |= ord(substr $one, $_) ^ ord(substr $two, $_) for 0 .. length($one) - 1;
    return $r == 0;
  }
  
  sub slugify {
    my ($value, $allow_unicode) = @_;
  
    if ($allow_unicode) {
  
      # Force unicode semantics by upgrading string
      utf8::upgrade($value = Unicode::Normalize::NFKC($value));
      $value =~ s/[^\w\s-]+//g;
    }
    else {
      $value = Unicode::Normalize::NFKD($value);
      $value =~ s/[^a-zA-Z0-9_\p{PosixSpace}-]+//g;
    }
    (my $new = lc trim($value)) =~ s/[-\s]+/-/g;
  
    return $new;
  }
  
  sub split_cookie_header { _header(shift, 1) }
  sub split_header        { _header(shift, 0) }
  
  sub tablify {
    my $rows = shift;
  
    my @spec;
    for my $row (@$rows) {
      for my $i (0 .. $#$row) {
        ($row->[$i] //= '') =~ s/[\r\n]//g;
        my $len = length $row->[$i];
        $spec[$i] = $len if $len >= ($spec[$i] // 0);
      }
    }
  
    my @fm = (map({"\%-${_}s"} @spec[0 .. $#spec - 1]), '%s');
    return join '', map { sprintf join('  ', @fm[0 .. $#$_]) . "\n", @$_ } @$rows;
  }
  
  sub term_escape {
    my $str = shift;
    $str =~ s/([\x00-\x09\x0b-\x1f\x7f\x80-\x9f])/sprintf '\\x%02x', ord $1/ge;
    return $str;
  }
  
  sub trim {
    my $str = shift;
    $str =~ s/^\s+//;
    $str =~ s/\s+$//;
    return $str;
  }
  
  sub unindent {
    my $str = shift;
    my $min = min map { m/^([ \t]*)/; length $1 || () } split "\n", $str;
    $str =~ s/^[ \t]{0,$min}//gm if $min;
    return $str;
  }
  
  sub unquote {
    my $str = shift;
    return $str unless $str =~ s/^"(.*)"$/$1/g;
    $str =~ s/\\\\/\\/g;
    $str =~ s/\\"/"/g;
    return $str;
  }
  
  sub url_escape {
    my ($str, $pattern) = @_;
  
    if ($pattern) {
      unless (exists $PATTERN{$pattern}) {
        (my $quoted = $pattern) =~ s!([/\$\[])!\\$1!g;
        $PATTERN{$pattern}
          = eval "sub { \$_[0] =~ s/([$quoted])/sprintf '%%%02X', ord \$1/ge }"
          or croak $@;
      }
      $PATTERN{$pattern}->($str);
    }
    else { $str =~ s/([^A-Za-z0-9\-._~])/sprintf '%%%02X', ord $1/ge }
  
    return $str;
  }
  
  sub url_unescape {
    my $str = shift;
    $str =~ s/%([0-9a-fA-F]{2})/chr hex $1/ge;
    return $str;
  }
  
  sub xml_escape {
    return $_[0] if ref $_[0] && ref $_[0] eq 'Mojo::ByteStream';
    my $str = shift // '';
    $str =~ s/([&<>"'])/$XML{$1}/ge;
    return $str;
  }
  
  sub xor_encode {
    my ($input, $key) = @_;
  
    # Encode with variable key length
    my $len = length $key;
    my $buffer = my $output = '';
    $output .= $buffer ^ $key
      while length($buffer = substr($input, 0, $len, '')) == $len;
    return $output .= $buffer ^ substr($key, 0, length $buffer, '');
  }
  
  sub _adapt {
    my ($delta, $numpoints, $firsttime) = @_;
    use integer;
  
    $delta = $firsttime ? $delta / PC_DAMP : $delta / 2;
    $delta += $delta / $numpoints;
    my $k = 0;
    while ($delta > ((PC_BASE - PC_TMIN) * PC_TMAX) / 2) {
      $delta /= PC_BASE - PC_TMIN;
      $k += PC_BASE;
    }
  
    return $k + (((PC_BASE - PC_TMIN + 1) * $delta) / ($delta + PC_SKEW));
  }
  
  sub _encoding {
    $ENCODING{$_[0]} //= find_encoding($_[0]) // croak "Unknown encoding '$_[0]'";
  }
  
  sub _entity {
    my ($point, $name, $attr) = @_;
  
    # Code point
    return chr($point !~ /^x/ ? $point : hex $point) unless defined $name;
  
    # Named character reference
    my $rest = my $last = '';
    while (length $name) {
      return $ENTITIES{$name} . reverse $rest
        if exists $ENTITIES{$name}
        && (!$attr || $name =~ /;$/ || $last !~ /[A-Za-z0-9=]/);
      $rest .= $last = chop $name;
    }
    return '&' . reverse $rest;
  }
  
  # Supported on Perl 5.14+
  sub _global_destruction {
    defined ${^GLOBAL_PHASE} && ${^GLOBAL_PHASE} eq 'DESTRUCT';
  }
  
  sub _header {
    my ($str, $cookie) = @_;
  
    my (@tree, @part);
    while ($str =~ /\G[,;\s]*([^=;, ]+)\s*/gc) {
      push @part, $1, undef;
      my $expires = $cookie && @part > 2 && lc $1 eq 'expires';
  
      # Special "expires" value
      if ($expires && $str =~ /\G=\s*$EXPIRES_RE/gco) { $part[-1] = $1 }
  
      # Quoted value
      elsif ($str =~ /\G=\s*("(?:\\\\|\\"|[^"])*")/gc) { $part[-1] = unquote $1 }
  
      # Unquoted value
      elsif ($str =~ /\G=\s*([^;, ]*)/gc) { $part[-1] = $1 }
  
      # Separator
      next unless $str =~ /\G[;\s]*,\s*/gc;
      push @tree, [@part];
      @part = ();
    }
  
    # Take care of final part
    return [@part ? (@tree, \@part) : @tree];
  }
  
  sub _html {
    my ($str, $attr) = @_;
    $str =~ s/$ENTITY_RE/_entity($1, $2, $attr)/geo;
    return $str;
  }
  
  sub _options {
  
    # Hash or name (one)
    return ref $_[0] eq 'HASH' ? (undef, %{shift()}) : @_ if @_ == 1;
  
    # Name and values (odd)
    return shift, @_ if @_ % 2;
  
    # Name and hash or just values (even)
    return ref $_[1] eq 'HASH' ? (shift, %{shift()}) : (undef, @_);
  }
  
  # This may break in the future, but is worth it for performance
  sub _readable { !!(IO::Poll::_poll(@_[0, 1], my $m = POLLIN | POLLPRI) > 0) }
  
  sub _stash {
    my ($name, $object) = (shift, shift);
  
    # Hash
    return $object->{$name} ||= {} unless @_;
  
    # Get
    return $object->{$name}{$_[0]} unless @_ > 1 || ref $_[0];
  
    # Set
    my $values = ref $_[0] ? $_[0] : {@_};
    @{$object->{$name}}{keys %$values} = values %$values;
  
    return $object;
  }
  
  sub _teardown {
    return unless my $class = shift;
  
    # @ISA has to be cleared first because of circular references
    no strict 'refs';
    @{"${class}::ISA"} = ();
    delete_package $class;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Util - Portable utility functions
  
  =head1 SYNOPSIS
  
    use Mojo::Util qw(b64_encode url_escape url_unescape);
  
    my $str = 'test=23';
    my $escaped = url_escape $str;
    say url_unescape $escaped;
    say b64_encode $escaped, '';
  
  =head1 DESCRIPTION
  
  L<Mojo::Util> provides portable utility functions for L<Mojo>.
  
  =head1 FUNCTIONS
  
  L<Mojo::Util> implements the following functions, which can be imported
  individually.
  
  =head2 b64_decode
  
    my $bytes = b64_decode $b64;
  
  Base64 decode bytes with L<MIME::Base64>.
  
  =head2 b64_encode
  
    my $b64 = b64_encode $bytes;
    my $b64 = b64_encode $bytes, "\n";
  
  Base64 encode bytes with L<MIME::Base64>, the line ending defaults to a newline.
  
  =head2 camelize
  
    my $camelcase = camelize $snakecase;
  
  Convert C<snake_case> string to C<CamelCase> and replace C<-> with C<::>.
  
    # "FooBar"
    camelize 'foo_bar';
  
    # "FooBar::Baz"
    camelize 'foo_bar-baz';
  
    # "FooBar::Baz"
    camelize 'FooBar::Baz';
  
  =head2 class_to_file
  
    my $file = class_to_file 'Foo::Bar';
  
  Convert a class name to a file.
  
    # "foo_bar"
    class_to_file 'Foo::Bar';
  
    # "foobar"
    class_to_file 'FOO::Bar';
  
    # "foo_bar"
    class_to_file 'FooBar';
  
    # "foobar"
    class_to_file 'FOOBar';
  
  =head2 class_to_path
  
    my $path = class_to_path 'Foo::Bar';
  
  Convert class name to path, as used by C<%INC>.
  
    # "Foo/Bar.pm"
    class_to_path 'Foo::Bar';
  
    # "FooBar.pm"
    class_to_path 'FooBar';
  
  =head2 decamelize
  
    my $snakecase = decamelize $camelcase;
  
  Convert C<CamelCase> string to C<snake_case> and replace C<::> with C<->.
  
    # "foo_bar"
    decamelize 'FooBar';
  
    # "foo_bar-baz"
    decamelize 'FooBar::Baz';
  
    # "foo_bar-baz"
    decamelize 'foo_bar-baz';
  
  =head2 decode
  
    my $chars = decode 'UTF-8', $bytes;
  
  Decode bytes to characters with L<Encode>, or return C<undef> if decoding
  failed.
  
  =head2 deprecated
  
    deprecated 'foo is DEPRECATED in favor of bar';
  
  Warn about deprecated feature from perspective of caller. You can also set the
  C<MOJO_FATAL_DEPRECATIONS> environment variable to make them die instead.
  
  =head2 dumper
  
    my $perl = dumper {some => 'data'};
  
  Dump a Perl data structure with L<Data::Dumper>.
  
  =head2 encode
  
    my $bytes = encode 'UTF-8', $chars;
  
  Encode characters to bytes with L<Encode>.
  
  =head2 extract_usage
  
    my $usage = extract_usage;
    my $usage = extract_usage '/home/sri/foo.pod';
  
  Extract usage message from the SYNOPSIS section of a file containing POD
  documentation, defaults to using the file this function was called from.
  
    # "Usage: APPLICATION test [OPTIONS]\n"
    extract_usage;
  
    =head1 SYNOPSIS
  
      Usage: APPLICATION test [OPTIONS]
  
    =cut
  
  =head2 getopt
  
    getopt
      'H|headers=s' => \my @headers,
      't|timeout=i' => \my $timeout,
      'v|verbose'   => \my $verbose;
    getopt $array,
      'H|headers=s' => \my @headers,
      't|timeout=i' => \my $timeout,
      'v|verbose'   => \my $verbose;
    getopt $array, ['pass_through'],
      'H|headers=s' => \my @headers,
      't|timeout=i' => \my $timeout,
      'v|verbose'   => \my $verbose;
  
  Extract options from an array reference with L<Getopt::Long>, but without
  changing its global configuration, defaults to using C<@ARGV>. The configuration
  options C<no_auto_abbrev> and C<no_ignore_case> are enabled by default.
  
    # Extract "charset" option
    getopt ['--charset', 'UTF-8'], 'charset=s' => \my $charset;
    say $charset;
  
  =head2 hmac_sha1_sum
  
    my $checksum = hmac_sha1_sum $bytes, 'passw0rd';
  
  Generate HMAC-SHA1 checksum for bytes with L<Digest::SHA>.
  
    # "11cedfd5ec11adc0ec234466d8a0f2a83736aa68"
    hmac_sha1_sum 'foo', 'passw0rd';
  
  =head2 html_attr_unescape
  
    my $str = html_attr_unescape $escaped;
  
  Same as L</"html_unescape">, but handles special rules from the
  L<HTML Living Standard|https://html.spec.whatwg.org> for HTML attributes.
  
    # "foo=bar&ltest=baz"
    html_attr_unescape 'foo=bar&ltest=baz';
  
    # "foo=bar<est=baz"
    html_attr_unescape 'foo=bar&lt;est=baz';
  
  =head2 html_unescape
  
    my $str = html_unescape $escaped;
  
  Unescape all HTML entities in string.
  
    # "<div>"
    html_unescape '&lt;div&gt;';
  
  =head2 md5_bytes
  
    my $checksum = md5_bytes $bytes;
  
  Generate binary MD5 checksum for bytes with L<Digest::MD5>.
  
  =head2 md5_sum
  
    my $checksum = md5_sum $bytes;
  
  Generate MD5 checksum for bytes with L<Digest::MD5>.
  
    # "acbd18db4cc2f85cedef654fccc4a4d8"
    md5_sum 'foo';
  
  =head2 monkey_patch
  
    monkey_patch $package, foo => sub {...};
    monkey_patch $package, foo => sub {...}, bar => sub {...};
  
  Monkey patch functions into package.
  
    monkey_patch 'MyApp',
      one   => sub { say 'One!' },
      two   => sub { say 'Two!' },
      three => sub { say 'Three!' };
  
  =head2 punycode_decode
  
    my $str = punycode_decode $punycode;
  
  Punycode decode string as described in
  L<RFC 3492|http://tools.ietf.org/html/rfc3492>.
  
    # "bcher"
    punycode_decode 'bcher-kva';
  
  =head2 punycode_encode
  
    my $punycode = punycode_encode $str;
  
  Punycode encode string as described in
  L<RFC 3492|http://tools.ietf.org/html/rfc3492>.
  
    # "bcher-kva"
    punycode_encode 'bcher';
  
  =head2 quote
  
    my $quoted = quote $str;
  
  Quote string.
  
  =head2 secure_compare
  
    my $bool = secure_compare $str1, $str2;
  
  Constant time comparison algorithm to prevent timing attacks.
  
  =head2 sha1_bytes
  
    my $checksum = sha1_bytes $bytes;
  
  Generate binary SHA1 checksum for bytes with L<Digest::SHA>.
  
  =head2 sha1_sum
  
    my $checksum = sha1_sum $bytes;
  
  Generate SHA1 checksum for bytes with L<Digest::SHA>.
  
    # "0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33"
    sha1_sum 'foo';
  
  =head2 slugify
  
    my $slug = slugify $string;
    my $slug = slugify $string, $bool;
  
  Returns a URL slug generated from the input string. Non-word characters are
  removed, the string is trimmed and lowercased, and whitespace characters are
  replaced by a dash. By default, non-ASCII characters are normalized to ASCII
  word characters or removed, but if a true value is passed as the second
  parameter, all word characters will be allowed in the result according to
  unicode semantics.
  
    # "joel-is-a-slug"
    slugify 'Joel is a slug';
  
    # "this-is-my-resume"
    slugify 'This is: my - rsum!  ';
  
    # "this-is-my-rsum"
    slugify 'This is: my - rsum!  ', 1;
  
  =head2 split_cookie_header
  
    my $tree = split_cookie_header 'a=b; expires=Thu, 07 Aug 2008 07:07:59 GMT';
  
  Same as L</"split_header">, but handles C<expires> values from
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head2 split_header
  
     my $tree = split_header 'foo="bar baz"; test=123, yada';
  
  Split HTTP header value into key/value pairs, each comma separated part gets
  its own array reference, and keys without a value get C<undef> assigned.
  
    # "one"
    split_header('one; two="three four", five=six')->[0][0];
  
    # "two"
    split_header('one; two="three four", five=six')->[0][2];
  
    # "three four"
    split_header('one; two="three four", five=six')->[0][3];
  
    # "five"
    split_header('one; two="three four", five=six')->[1][0];
  
    # "six"
    split_header('one; two="three four", five=six')->[1][1];
  
  =head2 steady_time
  
    my $time = steady_time;
  
  High resolution time elapsed from an arbitrary fixed point in the past,
  resilient to time jumps if a monotonic clock is available through
  L<Time::HiRes>.
  
  =head2 tablify
  
    my $table = tablify [['foo', 'bar'], ['baz', 'yada']];
  
  Row-oriented generator for text tables.
  
    # "foo   bar\nyada  yada\nbaz   yada\n"
    tablify [['foo', 'bar'], ['yada', 'yada'], ['baz', 'yada']];
  
  =head2 term_escape
  
    my $escaped = term_escape $str;
  
  Escape all POSIX control characters except for C<\n>.
  
    # "foo\\x09bar\\x0d\n"
    term_escape "foo\tbar\r\n";
  
  =head2 trim
  
    my $trimmed = trim $str;
  
  Trim whitespace characters from both ends of string.
  
    # "foo bar"
    trim '  foo bar  ';
  
  =head2 unindent
  
    my $unindented = unindent $str;
  
  Unindent multi-line string.
  
    # "foo\nbar\nbaz\n"
    unindent "  foo\n  bar\n  baz\n";
  
  =head2 unquote
  
    my $str = unquote $quoted;
  
  Unquote string.
  
  =head2 url_escape
  
    my $escaped = url_escape $str;
    my $escaped = url_escape $str, '^A-Za-z0-9\-._~';
  
  Percent encode unsafe characters in string as described in
  L<RFC 3986|http://tools.ietf.org/html/rfc3986>, the pattern used defaults to
  C<^A-Za-z0-9\-._~>.
  
    # "foo%3Bbar"
    url_escape 'foo;bar';
  
  =head2 url_unescape
  
    my $str = url_unescape $escaped;
  
  Decode percent encoded characters in string as described in
  L<RFC 3986|http://tools.ietf.org/html/rfc3986>.
  
    # "foo;bar"
    url_unescape 'foo%3Bbar';
  
  =head2 xml_escape
  
    my $escaped = xml_escape $str;
  
  Escape unsafe characters C<&>, C<E<lt>>, C<E<gt>>, C<"> and C<'> in string, but
  do not escape L<Mojo::ByteStream> objects.
  
    # "&lt;div&gt;"
    xml_escape '<div>';
  
    # "<div>"
    use Mojo::ByteStream 'b';
    xml_escape b('<div>');
  
  =head2 xor_encode
  
    my $encoded = xor_encode $str, $key;
  
  XOR encode string with variable length key.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
  
  __DATA__
  Aacute; U+000C1
  Aacute U+000C1
  aacute; U+000E1
  aacute U+000E1
  Abreve; U+00102
  abreve; U+00103
  ac; U+0223E
  acd; U+0223F
  acE; U+0223E U+00333
  Acirc; U+000C2
  Acirc U+000C2
  acirc; U+000E2
  acirc U+000E2
  acute; U+000B4
  acute U+000B4
  Acy; U+00410
  acy; U+00430
  AElig; U+000C6
  AElig U+000C6
  aelig; U+000E6
  aelig U+000E6
  af; U+02061
  Afr; U+1D504
  afr; U+1D51E
  Agrave; U+000C0
  Agrave U+000C0
  agrave; U+000E0
  agrave U+000E0
  alefsym; U+02135
  aleph; U+02135
  Alpha; U+00391
  alpha; U+003B1
  Amacr; U+00100
  amacr; U+00101
  amalg; U+02A3F
  AMP; U+00026
  AMP U+00026
  amp; U+00026
  amp U+00026
  And; U+02A53
  and; U+02227
  andand; U+02A55
  andd; U+02A5C
  andslope; U+02A58
  andv; U+02A5A
  ang; U+02220
  ange; U+029A4
  angle; U+02220
  angmsd; U+02221
  angmsdaa; U+029A8
  angmsdab; U+029A9
  angmsdac; U+029AA
  angmsdad; U+029AB
  angmsdae; U+029AC
  angmsdaf; U+029AD
  angmsdag; U+029AE
  angmsdah; U+029AF
  angrt; U+0221F
  angrtvb; U+022BE
  angrtvbd; U+0299D
  angsph; U+02222
  angst; U+000C5
  angzarr; U+0237C
  Aogon; U+00104
  aogon; U+00105
  Aopf; U+1D538
  aopf; U+1D552
  ap; U+02248
  apacir; U+02A6F
  apE; U+02A70
  ape; U+0224A
  apid; U+0224B
  apos; U+00027
  ApplyFunction; U+02061
  approx; U+02248
  approxeq; U+0224A
  Aring; U+000C5
  Aring U+000C5
  aring; U+000E5
  aring U+000E5
  Ascr; U+1D49C
  ascr; U+1D4B6
  Assign; U+02254
  ast; U+0002A
  asymp; U+02248
  asympeq; U+0224D
  Atilde; U+000C3
  Atilde U+000C3
  atilde; U+000E3
  atilde U+000E3
  Auml; U+000C4
  Auml U+000C4
  auml; U+000E4
  auml U+000E4
  awconint; U+02233
  awint; U+02A11
  backcong; U+0224C
  backepsilon; U+003F6
  backprime; U+02035
  backsim; U+0223D
  backsimeq; U+022CD
  Backslash; U+02216
  Barv; U+02AE7
  barvee; U+022BD
  Barwed; U+02306
  barwed; U+02305
  barwedge; U+02305
  bbrk; U+023B5
  bbrktbrk; U+023B6
  bcong; U+0224C
  Bcy; U+00411
  bcy; U+00431
  bdquo; U+0201E
  becaus; U+02235
  Because; U+02235
  because; U+02235
  bemptyv; U+029B0
  bepsi; U+003F6
  bernou; U+0212C
  Bernoullis; U+0212C
  Beta; U+00392
  beta; U+003B2
  beth; U+02136
  between; U+0226C
  Bfr; U+1D505
  bfr; U+1D51F
  bigcap; U+022C2
  bigcirc; U+025EF
  bigcup; U+022C3
  bigodot; U+02A00
  bigoplus; U+02A01
  bigotimes; U+02A02
  bigsqcup; U+02A06
  bigstar; U+02605
  bigtriangledown; U+025BD
  bigtriangleup; U+025B3
  biguplus; U+02A04
  bigvee; U+022C1
  bigwedge; U+022C0
  bkarow; U+0290D
  blacklozenge; U+029EB
  blacksquare; U+025AA
  blacktriangle; U+025B4
  blacktriangledown; U+025BE
  blacktriangleleft; U+025C2
  blacktriangleright; U+025B8
  blank; U+02423
  blk12; U+02592
  blk14; U+02591
  blk34; U+02593
  block; U+02588
  bne; U+0003D U+020E5
  bnequiv; U+02261 U+020E5
  bNot; U+02AED
  bnot; U+02310
  Bopf; U+1D539
  bopf; U+1D553
  bot; U+022A5
  bottom; U+022A5
  bowtie; U+022C8
  boxbox; U+029C9
  boxDL; U+02557
  boxDl; U+02556
  boxdL; U+02555
  boxdl; U+02510
  boxDR; U+02554
  boxDr; U+02553
  boxdR; U+02552
  boxdr; U+0250C
  boxH; U+02550
  boxh; U+02500
  boxHD; U+02566
  boxHd; U+02564
  boxhD; U+02565
  boxhd; U+0252C
  boxHU; U+02569
  boxHu; U+02567
  boxhU; U+02568
  boxhu; U+02534
  boxminus; U+0229F
  boxplus; U+0229E
  boxtimes; U+022A0
  boxUL; U+0255D
  boxUl; U+0255C
  boxuL; U+0255B
  boxul; U+02518
  boxUR; U+0255A
  boxUr; U+02559
  boxuR; U+02558
  boxur; U+02514
  boxV; U+02551
  boxv; U+02502
  boxVH; U+0256C
  boxVh; U+0256B
  boxvH; U+0256A
  boxvh; U+0253C
  boxVL; U+02563
  boxVl; U+02562
  boxvL; U+02561
  boxvl; U+02524
  boxVR; U+02560
  boxVr; U+0255F
  boxvR; U+0255E
  boxvr; U+0251C
  bprime; U+02035
  Breve; U+002D8
  breve; U+002D8
  brvbar; U+000A6
  brvbar U+000A6
  Bscr; U+0212C
  bscr; U+1D4B7
  bsemi; U+0204F
  bsim; U+0223D
  bsime; U+022CD
  bsol; U+0005C
  bsolb; U+029C5
  bsolhsub; U+027C8
  bull; U+02022
  bullet; U+02022
  bump; U+0224E
  bumpE; U+02AAE
  bumpe; U+0224F
  Bumpeq; U+0224E
  bumpeq; U+0224F
  Cacute; U+00106
  cacute; U+00107
  Cap; U+022D2
  cap; U+02229
  capand; U+02A44
  capbrcup; U+02A49
  capcap; U+02A4B
  capcup; U+02A47
  capdot; U+02A40
  CapitalDifferentialD; U+02145
  caps; U+02229 U+0FE00
  caret; U+02041
  caron; U+002C7
  Cayleys; U+0212D
  ccaps; U+02A4D
  Ccaron; U+0010C
  ccaron; U+0010D
  Ccedil; U+000C7
  Ccedil U+000C7
  ccedil; U+000E7
  ccedil U+000E7
  Ccirc; U+00108
  ccirc; U+00109
  Cconint; U+02230
  ccups; U+02A4C
  ccupssm; U+02A50
  Cdot; U+0010A
  cdot; U+0010B
  cedil; U+000B8
  cedil U+000B8
  Cedilla; U+000B8
  cemptyv; U+029B2
  cent; U+000A2
  cent U+000A2
  CenterDot; U+000B7
  centerdot; U+000B7
  Cfr; U+0212D
  cfr; U+1D520
  CHcy; U+00427
  chcy; U+00447
  check; U+02713
  checkmark; U+02713
  Chi; U+003A7
  chi; U+003C7
  cir; U+025CB
  circ; U+002C6
  circeq; U+02257
  circlearrowleft; U+021BA
  circlearrowright; U+021BB
  circledast; U+0229B
  circledcirc; U+0229A
  circleddash; U+0229D
  CircleDot; U+02299
  circledR; U+000AE
  circledS; U+024C8
  CircleMinus; U+02296
  CirclePlus; U+02295
  CircleTimes; U+02297
  cirE; U+029C3
  cire; U+02257
  cirfnint; U+02A10
  cirmid; U+02AEF
  cirscir; U+029C2
  ClockwiseContourIntegral; U+02232
  CloseCurlyDoubleQuote; U+0201D
  CloseCurlyQuote; U+02019
  clubs; U+02663
  clubsuit; U+02663
  Colon; U+02237
  colon; U+0003A
  Colone; U+02A74
  colone; U+02254
  coloneq; U+02254
  comma; U+0002C
  commat; U+00040
  comp; U+02201
  compfn; U+02218
  complement; U+02201
  complexes; U+02102
  cong; U+02245
  congdot; U+02A6D
  Congruent; U+02261
  Conint; U+0222F
  conint; U+0222E
  ContourIntegral; U+0222E
  Copf; U+02102
  copf; U+1D554
  coprod; U+02210
  Coproduct; U+02210
  COPY; U+000A9
  COPY U+000A9
  copy; U+000A9
  copy U+000A9
  copysr; U+02117
  CounterClockwiseContourIntegral; U+02233
  crarr; U+021B5
  Cross; U+02A2F
  cross; U+02717
  Cscr; U+1D49E
  cscr; U+1D4B8
  csub; U+02ACF
  csube; U+02AD1
  csup; U+02AD0
  csupe; U+02AD2
  ctdot; U+022EF
  cudarrl; U+02938
  cudarrr; U+02935
  cuepr; U+022DE
  cuesc; U+022DF
  cularr; U+021B6
  cularrp; U+0293D
  Cup; U+022D3
  cup; U+0222A
  cupbrcap; U+02A48
  CupCap; U+0224D
  cupcap; U+02A46
  cupcup; U+02A4A
  cupdot; U+0228D
  cupor; U+02A45
  cups; U+0222A U+0FE00
  curarr; U+021B7
  curarrm; U+0293C
  curlyeqprec; U+022DE
  curlyeqsucc; U+022DF
  curlyvee; U+022CE
  curlywedge; U+022CF
  curren; U+000A4
  curren U+000A4
  curvearrowleft; U+021B6
  curvearrowright; U+021B7
  cuvee; U+022CE
  cuwed; U+022CF
  cwconint; U+02232
  cwint; U+02231
  cylcty; U+0232D
  Dagger; U+02021
  dagger; U+02020
  daleth; U+02138
  Darr; U+021A1
  dArr; U+021D3
  darr; U+02193
  dash; U+02010
  Dashv; U+02AE4
  dashv; U+022A3
  dbkarow; U+0290F
  dblac; U+002DD
  Dcaron; U+0010E
  dcaron; U+0010F
  Dcy; U+00414
  dcy; U+00434
  DD; U+02145
  dd; U+02146
  ddagger; U+02021
  ddarr; U+021CA
  DDotrahd; U+02911
  ddotseq; U+02A77
  deg; U+000B0
  deg U+000B0
  Del; U+02207
  Delta; U+00394
  delta; U+003B4
  demptyv; U+029B1
  dfisht; U+0297F
  Dfr; U+1D507
  dfr; U+1D521
  dHar; U+02965
  dharl; U+021C3
  dharr; U+021C2
  DiacriticalAcute; U+000B4
  DiacriticalDot; U+002D9
  DiacriticalDoubleAcute; U+002DD
  DiacriticalGrave; U+00060
  DiacriticalTilde; U+002DC
  diam; U+022C4
  Diamond; U+022C4
  diamond; U+022C4
  diamondsuit; U+02666
  diams; U+02666
  die; U+000A8
  DifferentialD; U+02146
  digamma; U+003DD
  disin; U+022F2
  div; U+000F7
  divide; U+000F7
  divide U+000F7
  divideontimes; U+022C7
  divonx; U+022C7
  DJcy; U+00402
  djcy; U+00452
  dlcorn; U+0231E
  dlcrop; U+0230D
  dollar; U+00024
  Dopf; U+1D53B
  dopf; U+1D555
  Dot; U+000A8
  dot; U+002D9
  DotDot; U+020DC
  doteq; U+02250
  doteqdot; U+02251
  DotEqual; U+02250
  dotminus; U+02238
  dotplus; U+02214
  dotsquare; U+022A1
  doublebarwedge; U+02306
  DoubleContourIntegral; U+0222F
  DoubleDot; U+000A8
  DoubleDownArrow; U+021D3
  DoubleLeftArrow; U+021D0
  DoubleLeftRightArrow; U+021D4
  DoubleLeftTee; U+02AE4
  DoubleLongLeftArrow; U+027F8
  DoubleLongLeftRightArrow; U+027FA
  DoubleLongRightArrow; U+027F9
  DoubleRightArrow; U+021D2
  DoubleRightTee; U+022A8
  DoubleUpArrow; U+021D1
  DoubleUpDownArrow; U+021D5
  DoubleVerticalBar; U+02225
  DownArrow; U+02193
  Downarrow; U+021D3
  downarrow; U+02193
  DownArrowBar; U+02913
  DownArrowUpArrow; U+021F5
  DownBreve; U+00311
  downdownarrows; U+021CA
  downharpoonleft; U+021C3
  downharpoonright; U+021C2
  DownLeftRightVector; U+02950
  DownLeftTeeVector; U+0295E
  DownLeftVector; U+021BD
  DownLeftVectorBar; U+02956
  DownRightTeeVector; U+0295F
  DownRightVector; U+021C1
  DownRightVectorBar; U+02957
  DownTee; U+022A4
  DownTeeArrow; U+021A7
  drbkarow; U+02910
  drcorn; U+0231F
  drcrop; U+0230C
  Dscr; U+1D49F
  dscr; U+1D4B9
  DScy; U+00405
  dscy; U+00455
  dsol; U+029F6
  Dstrok; U+00110
  dstrok; U+00111
  dtdot; U+022F1
  dtri; U+025BF
  dtrif; U+025BE
  duarr; U+021F5
  duhar; U+0296F
  dwangle; U+029A6
  DZcy; U+0040F
  dzcy; U+0045F
  dzigrarr; U+027FF
  Eacute; U+000C9
  Eacute U+000C9
  eacute; U+000E9
  eacute U+000E9
  easter; U+02A6E
  Ecaron; U+0011A
  ecaron; U+0011B
  ecir; U+02256
  Ecirc; U+000CA
  Ecirc U+000CA
  ecirc; U+000EA
  ecirc U+000EA
  ecolon; U+02255
  Ecy; U+0042D
  ecy; U+0044D
  eDDot; U+02A77
  Edot; U+00116
  eDot; U+02251
  edot; U+00117
  ee; U+02147
  efDot; U+02252
  Efr; U+1D508
  efr; U+1D522
  eg; U+02A9A
  Egrave; U+000C8
  Egrave U+000C8
  egrave; U+000E8
  egrave U+000E8
  egs; U+02A96
  egsdot; U+02A98
  el; U+02A99
  Element; U+02208
  elinters; U+023E7
  ell; U+02113
  els; U+02A95
  elsdot; U+02A97
  Emacr; U+00112
  emacr; U+00113
  empty; U+02205
  emptyset; U+02205
  EmptySmallSquare; U+025FB
  emptyv; U+02205
  EmptyVerySmallSquare; U+025AB
  emsp; U+02003
  emsp13; U+02004
  emsp14; U+02005
  ENG; U+0014A
  eng; U+0014B
  ensp; U+02002
  Eogon; U+00118
  eogon; U+00119
  Eopf; U+1D53C
  eopf; U+1D556
  epar; U+022D5
  eparsl; U+029E3
  eplus; U+02A71
  epsi; U+003B5
  Epsilon; U+00395
  epsilon; U+003B5
  epsiv; U+003F5
  eqcirc; U+02256
  eqcolon; U+02255
  eqsim; U+02242
  eqslantgtr; U+02A96
  eqslantless; U+02A95
  Equal; U+02A75
  equals; U+0003D
  EqualTilde; U+02242
  equest; U+0225F
  Equilibrium; U+021CC
  equiv; U+02261
  equivDD; U+02A78
  eqvparsl; U+029E5
  erarr; U+02971
  erDot; U+02253
  Escr; U+02130
  escr; U+0212F
  esdot; U+02250
  Esim; U+02A73
  esim; U+02242
  Eta; U+00397
  eta; U+003B7
  ETH; U+000D0
  ETH U+000D0
  eth; U+000F0
  eth U+000F0
  Euml; U+000CB
  Euml U+000CB
  euml; U+000EB
  euml U+000EB
  euro; U+020AC
  excl; U+00021
  exist; U+02203
  Exists; U+02203
  expectation; U+02130
  ExponentialE; U+02147
  exponentiale; U+02147
  fallingdotseq; U+02252
  Fcy; U+00424
  fcy; U+00444
  female; U+02640
  ffilig; U+0FB03
  fflig; U+0FB00
  ffllig; U+0FB04
  Ffr; U+1D509
  ffr; U+1D523
  filig; U+0FB01
  FilledSmallSquare; U+025FC
  FilledVerySmallSquare; U+025AA
  fjlig; U+00066 U+0006A
  flat; U+0266D
  fllig; U+0FB02
  fltns; U+025B1
  fnof; U+00192
  Fopf; U+1D53D
  fopf; U+1D557
  ForAll; U+02200
  forall; U+02200
  fork; U+022D4
  forkv; U+02AD9
  Fouriertrf; U+02131
  fpartint; U+02A0D
  frac12; U+000BD
  frac12 U+000BD
  frac13; U+02153
  frac14; U+000BC
  frac14 U+000BC
  frac15; U+02155
  frac16; U+02159
  frac18; U+0215B
  frac23; U+02154
  frac25; U+02156
  frac34; U+000BE
  frac34 U+000BE
  frac35; U+02157
  frac38; U+0215C
  frac45; U+02158
  frac56; U+0215A
  frac58; U+0215D
  frac78; U+0215E
  frasl; U+02044
  frown; U+02322
  Fscr; U+02131
  fscr; U+1D4BB
  gacute; U+001F5
  Gamma; U+00393
  gamma; U+003B3
  Gammad; U+003DC
  gammad; U+003DD
  gap; U+02A86
  Gbreve; U+0011E
  gbreve; U+0011F
  Gcedil; U+00122
  Gcirc; U+0011C
  gcirc; U+0011D
  Gcy; U+00413
  gcy; U+00433
  Gdot; U+00120
  gdot; U+00121
  gE; U+02267
  ge; U+02265
  gEl; U+02A8C
  gel; U+022DB
  geq; U+02265
  geqq; U+02267
  geqslant; U+02A7E
  ges; U+02A7E
  gescc; U+02AA9
  gesdot; U+02A80
  gesdoto; U+02A82
  gesdotol; U+02A84
  gesl; U+022DB U+0FE00
  gesles; U+02A94
  Gfr; U+1D50A
  gfr; U+1D524
  Gg; U+022D9
  gg; U+0226B
  ggg; U+022D9
  gimel; U+02137
  GJcy; U+00403
  gjcy; U+00453
  gl; U+02277
  gla; U+02AA5
  glE; U+02A92
  glj; U+02AA4
  gnap; U+02A8A
  gnapprox; U+02A8A
  gnE; U+02269
  gne; U+02A88
  gneq; U+02A88
  gneqq; U+02269
  gnsim; U+022E7
  Gopf; U+1D53E
  gopf; U+1D558
  grave; U+00060
  GreaterEqual; U+02265
  GreaterEqualLess; U+022DB
  GreaterFullEqual; U+02267
  GreaterGreater; U+02AA2
  GreaterLess; U+02277
  GreaterSlantEqual; U+02A7E
  GreaterTilde; U+02273
  Gscr; U+1D4A2
  gscr; U+0210A
  gsim; U+02273
  gsime; U+02A8E
  gsiml; U+02A90
  GT; U+0003E
  GT U+0003E
  Gt; U+0226B
  gt; U+0003E
  gt U+0003E
  gtcc; U+02AA7
  gtcir; U+02A7A
  gtdot; U+022D7
  gtlPar; U+02995
  gtquest; U+02A7C
  gtrapprox; U+02A86
  gtrarr; U+02978
  gtrdot; U+022D7
  gtreqless; U+022DB
  gtreqqless; U+02A8C
  gtrless; U+02277
  gtrsim; U+02273
  gvertneqq; U+02269 U+0FE00
  gvnE; U+02269 U+0FE00
  Hacek; U+002C7
  hairsp; U+0200A
  half; U+000BD
  hamilt; U+0210B
  HARDcy; U+0042A
  hardcy; U+0044A
  hArr; U+021D4
  harr; U+02194
  harrcir; U+02948
  harrw; U+021AD
  Hat; U+0005E
  hbar; U+0210F
  Hcirc; U+00124
  hcirc; U+00125
  hearts; U+02665
  heartsuit; U+02665
  hellip; U+02026
  hercon; U+022B9
  Hfr; U+0210C
  hfr; U+1D525
  HilbertSpace; U+0210B
  hksearow; U+02925
  hkswarow; U+02926
  hoarr; U+021FF
  homtht; U+0223B
  hookleftarrow; U+021A9
  hookrightarrow; U+021AA
  Hopf; U+0210D
  hopf; U+1D559
  horbar; U+02015
  HorizontalLine; U+02500
  Hscr; U+0210B
  hscr; U+1D4BD
  hslash; U+0210F
  Hstrok; U+00126
  hstrok; U+00127
  HumpDownHump; U+0224E
  HumpEqual; U+0224F
  hybull; U+02043
  hyphen; U+02010
  Iacute; U+000CD
  Iacute U+000CD
  iacute; U+000ED
  iacute U+000ED
  ic; U+02063
  Icirc; U+000CE
  Icirc U+000CE
  icirc; U+000EE
  icirc U+000EE
  Icy; U+00418
  icy; U+00438
  Idot; U+00130
  IEcy; U+00415
  iecy; U+00435
  iexcl; U+000A1
  iexcl U+000A1
  iff; U+021D4
  Ifr; U+02111
  ifr; U+1D526
  Igrave; U+000CC
  Igrave U+000CC
  igrave; U+000EC
  igrave U+000EC
  ii; U+02148
  iiiint; U+02A0C
  iiint; U+0222D
  iinfin; U+029DC
  iiota; U+02129
  IJlig; U+00132
  ijlig; U+00133
  Im; U+02111
  Imacr; U+0012A
  imacr; U+0012B
  image; U+02111
  ImaginaryI; U+02148
  imagline; U+02110
  imagpart; U+02111
  imath; U+00131
  imof; U+022B7
  imped; U+001B5
  Implies; U+021D2
  in; U+02208
  incare; U+02105
  infin; U+0221E
  infintie; U+029DD
  inodot; U+00131
  Int; U+0222C
  int; U+0222B
  intcal; U+022BA
  integers; U+02124
  Integral; U+0222B
  intercal; U+022BA
  Intersection; U+022C2
  intlarhk; U+02A17
  intprod; U+02A3C
  InvisibleComma; U+02063
  InvisibleTimes; U+02062
  IOcy; U+00401
  iocy; U+00451
  Iogon; U+0012E
  iogon; U+0012F
  Iopf; U+1D540
  iopf; U+1D55A
  Iota; U+00399
  iota; U+003B9
  iprod; U+02A3C
  iquest; U+000BF
  iquest U+000BF
  Iscr; U+02110
  iscr; U+1D4BE
  isin; U+02208
  isindot; U+022F5
  isinE; U+022F9
  isins; U+022F4
  isinsv; U+022F3
  isinv; U+02208
  it; U+02062
  Itilde; U+00128
  itilde; U+00129
  Iukcy; U+00406
  iukcy; U+00456
  Iuml; U+000CF
  Iuml U+000CF
  iuml; U+000EF
  iuml U+000EF
  Jcirc; U+00134
  jcirc; U+00135
  Jcy; U+00419
  jcy; U+00439
  Jfr; U+1D50D
  jfr; U+1D527
  jmath; U+00237
  Jopf; U+1D541
  jopf; U+1D55B
  Jscr; U+1D4A5
  jscr; U+1D4BF
  Jsercy; U+00408
  jsercy; U+00458
  Jukcy; U+00404
  jukcy; U+00454
  Kappa; U+0039A
  kappa; U+003BA
  kappav; U+003F0
  Kcedil; U+00136
  kcedil; U+00137
  Kcy; U+0041A
  kcy; U+0043A
  Kfr; U+1D50E
  kfr; U+1D528
  kgreen; U+00138
  KHcy; U+00425
  khcy; U+00445
  KJcy; U+0040C
  kjcy; U+0045C
  Kopf; U+1D542
  kopf; U+1D55C
  Kscr; U+1D4A6
  kscr; U+1D4C0
  lAarr; U+021DA
  Lacute; U+00139
  lacute; U+0013A
  laemptyv; U+029B4
  lagran; U+02112
  Lambda; U+0039B
  lambda; U+003BB
  Lang; U+027EA
  lang; U+027E8
  langd; U+02991
  langle; U+027E8
  lap; U+02A85
  Laplacetrf; U+02112
  laquo; U+000AB
  laquo U+000AB
  Larr; U+0219E
  lArr; U+021D0
  larr; U+02190
  larrb; U+021E4
  larrbfs; U+0291F
  larrfs; U+0291D
  larrhk; U+021A9
  larrlp; U+021AB
  larrpl; U+02939
  larrsim; U+02973
  larrtl; U+021A2
  lat; U+02AAB
  lAtail; U+0291B
  latail; U+02919
  late; U+02AAD
  lates; U+02AAD U+0FE00
  lBarr; U+0290E
  lbarr; U+0290C
  lbbrk; U+02772
  lbrace; U+0007B
  lbrack; U+0005B
  lbrke; U+0298B
  lbrksld; U+0298F
  lbrkslu; U+0298D
  Lcaron; U+0013D
  lcaron; U+0013E
  Lcedil; U+0013B
  lcedil; U+0013C
  lceil; U+02308
  lcub; U+0007B
  Lcy; U+0041B
  lcy; U+0043B
  ldca; U+02936
  ldquo; U+0201C
  ldquor; U+0201E
  ldrdhar; U+02967
  ldrushar; U+0294B
  ldsh; U+021B2
  lE; U+02266
  le; U+02264
  LeftAngleBracket; U+027E8
  LeftArrow; U+02190
  Leftarrow; U+021D0
  leftarrow; U+02190
  LeftArrowBar; U+021E4
  LeftArrowRightArrow; U+021C6
  leftarrowtail; U+021A2
  LeftCeiling; U+02308
  LeftDoubleBracket; U+027E6
  LeftDownTeeVector; U+02961
  LeftDownVector; U+021C3
  LeftDownVectorBar; U+02959
  LeftFloor; U+0230A
  leftharpoondown; U+021BD
  leftharpoonup; U+021BC
  leftleftarrows; U+021C7
  LeftRightArrow; U+02194
  Leftrightarrow; U+021D4
  leftrightarrow; U+02194
  leftrightarrows; U+021C6
  leftrightharpoons; U+021CB
  leftrightsquigarrow; U+021AD
  LeftRightVector; U+0294E
  LeftTee; U+022A3
  LeftTeeArrow; U+021A4
  LeftTeeVector; U+0295A
  leftthreetimes; U+022CB
  LeftTriangle; U+022B2
  LeftTriangleBar; U+029CF
  LeftTriangleEqual; U+022B4
  LeftUpDownVector; U+02951
  LeftUpTeeVector; U+02960
  LeftUpVector; U+021BF
  LeftUpVectorBar; U+02958
  LeftVector; U+021BC
  LeftVectorBar; U+02952
  lEg; U+02A8B
  leg; U+022DA
  leq; U+02264
  leqq; U+02266
  leqslant; U+02A7D
  les; U+02A7D
  lescc; U+02AA8
  lesdot; U+02A7F
  lesdoto; U+02A81
  lesdotor; U+02A83
  lesg; U+022DA U+0FE00
  lesges; U+02A93
  lessapprox; U+02A85
  lessdot; U+022D6
  lesseqgtr; U+022DA
  lesseqqgtr; U+02A8B
  LessEqualGreater; U+022DA
  LessFullEqual; U+02266
  LessGreater; U+02276
  lessgtr; U+02276
  LessLess; U+02AA1
  lesssim; U+02272
  LessSlantEqual; U+02A7D
  LessTilde; U+02272
  lfisht; U+0297C
  lfloor; U+0230A
  Lfr; U+1D50F
  lfr; U+1D529
  lg; U+02276
  lgE; U+02A91
  lHar; U+02962
  lhard; U+021BD
  lharu; U+021BC
  lharul; U+0296A
  lhblk; U+02584
  LJcy; U+00409
  ljcy; U+00459
  Ll; U+022D8
  ll; U+0226A
  llarr; U+021C7
  llcorner; U+0231E
  Lleftarrow; U+021DA
  llhard; U+0296B
  lltri; U+025FA
  Lmidot; U+0013F
  lmidot; U+00140
  lmoust; U+023B0
  lmoustache; U+023B0
  lnap; U+02A89
  lnapprox; U+02A89
  lnE; U+02268
  lne; U+02A87
  lneq; U+02A87
  lneqq; U+02268
  lnsim; U+022E6
  loang; U+027EC
  loarr; U+021FD
  lobrk; U+027E6
  LongLeftArrow; U+027F5
  Longleftarrow; U+027F8
  longleftarrow; U+027F5
  LongLeftRightArrow; U+027F7
  Longleftrightarrow; U+027FA
  longleftrightarrow; U+027F7
  longmapsto; U+027FC
  LongRightArrow; U+027F6
  Longrightarrow; U+027F9
  longrightarrow; U+027F6
  looparrowleft; U+021AB
  looparrowright; U+021AC
  lopar; U+02985
  Lopf; U+1D543
  lopf; U+1D55D
  loplus; U+02A2D
  lotimes; U+02A34
  lowast; U+02217
  lowbar; U+0005F
  LowerLeftArrow; U+02199
  LowerRightArrow; U+02198
  loz; U+025CA
  lozenge; U+025CA
  lozf; U+029EB
  lpar; U+00028
  lparlt; U+02993
  lrarr; U+021C6
  lrcorner; U+0231F
  lrhar; U+021CB
  lrhard; U+0296D
  lrm; U+0200E
  lrtri; U+022BF
  lsaquo; U+02039
  Lscr; U+02112
  lscr; U+1D4C1
  Lsh; U+021B0
  lsh; U+021B0
  lsim; U+02272
  lsime; U+02A8D
  lsimg; U+02A8F
  lsqb; U+0005B
  lsquo; U+02018
  lsquor; U+0201A
  Lstrok; U+00141
  lstrok; U+00142
  LT; U+0003C
  LT U+0003C
  Lt; U+0226A
  lt; U+0003C
  lt U+0003C
  ltcc; U+02AA6
  ltcir; U+02A79
  ltdot; U+022D6
  lthree; U+022CB
  ltimes; U+022C9
  ltlarr; U+02976
  ltquest; U+02A7B
  ltri; U+025C3
  ltrie; U+022B4
  ltrif; U+025C2
  ltrPar; U+02996
  lurdshar; U+0294A
  luruhar; U+02966
  lvertneqq; U+02268 U+0FE00
  lvnE; U+02268 U+0FE00
  macr; U+000AF
  macr U+000AF
  male; U+02642
  malt; U+02720
  maltese; U+02720
  Map; U+02905
  map; U+021A6
  mapsto; U+021A6
  mapstodown; U+021A7
  mapstoleft; U+021A4
  mapstoup; U+021A5
  marker; U+025AE
  mcomma; U+02A29
  Mcy; U+0041C
  mcy; U+0043C
  mdash; U+02014
  mDDot; U+0223A
  measuredangle; U+02221
  MediumSpace; U+0205F
  Mellintrf; U+02133
  Mfr; U+1D510
  mfr; U+1D52A
  mho; U+02127
  micro; U+000B5
  micro U+000B5
  mid; U+02223
  midast; U+0002A
  midcir; U+02AF0
  middot; U+000B7
  middot U+000B7
  minus; U+02212
  minusb; U+0229F
  minusd; U+02238
  minusdu; U+02A2A
  MinusPlus; U+02213
  mlcp; U+02ADB
  mldr; U+02026
  mnplus; U+02213
  models; U+022A7
  Mopf; U+1D544
  mopf; U+1D55E
  mp; U+02213
  Mscr; U+02133
  mscr; U+1D4C2
  mstpos; U+0223E
  Mu; U+0039C
  mu; U+003BC
  multimap; U+022B8
  mumap; U+022B8
  nabla; U+02207
  Nacute; U+00143
  nacute; U+00144
  nang; U+02220 U+020D2
  nap; U+02249
  napE; U+02A70 U+00338
  napid; U+0224B U+00338
  napos; U+00149
  napprox; U+02249
  natur; U+0266E
  natural; U+0266E
  naturals; U+02115
  nbsp; U+000A0
  nbsp U+000A0
  nbump; U+0224E U+00338
  nbumpe; U+0224F U+00338
  ncap; U+02A43
  Ncaron; U+00147
  ncaron; U+00148
  Ncedil; U+00145
  ncedil; U+00146
  ncong; U+02247
  ncongdot; U+02A6D U+00338
  ncup; U+02A42
  Ncy; U+0041D
  ncy; U+0043D
  ndash; U+02013
  ne; U+02260
  nearhk; U+02924
  neArr; U+021D7
  nearr; U+02197
  nearrow; U+02197
  nedot; U+02250 U+00338
  NegativeMediumSpace; U+0200B
  NegativeThickSpace; U+0200B
  NegativeThinSpace; U+0200B
  NegativeVeryThinSpace; U+0200B
  nequiv; U+02262
  nesear; U+02928
  nesim; U+02242 U+00338
  NestedGreaterGreater; U+0226B
  NestedLessLess; U+0226A
  NewLine; U+0000A
  nexist; U+02204
  nexists; U+02204
  Nfr; U+1D511
  nfr; U+1D52B
  ngE; U+02267 U+00338
  nge; U+02271
  ngeq; U+02271
  ngeqq; U+02267 U+00338
  ngeqslant; U+02A7E U+00338
  nges; U+02A7E U+00338
  nGg; U+022D9 U+00338
  ngsim; U+02275
  nGt; U+0226B U+020D2
  ngt; U+0226F
  ngtr; U+0226F
  nGtv; U+0226B U+00338
  nhArr; U+021CE
  nharr; U+021AE
  nhpar; U+02AF2
  ni; U+0220B
  nis; U+022FC
  nisd; U+022FA
  niv; U+0220B
  NJcy; U+0040A
  njcy; U+0045A
  nlArr; U+021CD
  nlarr; U+0219A
  nldr; U+02025
  nlE; U+02266 U+00338
  nle; U+02270
  nLeftarrow; U+021CD
  nleftarrow; U+0219A
  nLeftrightarrow; U+021CE
  nleftrightarrow; U+021AE
  nleq; U+02270
  nleqq; U+02266 U+00338
  nleqslant; U+02A7D U+00338
  nles; U+02A7D U+00338
  nless; U+0226E
  nLl; U+022D8 U+00338
  nlsim; U+02274
  nLt; U+0226A U+020D2
  nlt; U+0226E
  nltri; U+022EA
  nltrie; U+022EC
  nLtv; U+0226A U+00338
  nmid; U+02224
  NoBreak; U+02060
  NonBreakingSpace; U+000A0
  Nopf; U+02115
  nopf; U+1D55F
  Not; U+02AEC
  not; U+000AC
  not U+000AC
  NotCongruent; U+02262
  NotCupCap; U+0226D
  NotDoubleVerticalBar; U+02226
  NotElement; U+02209
  NotEqual; U+02260
  NotEqualTilde; U+02242 U+00338
  NotExists; U+02204
  NotGreater; U+0226F
  NotGreaterEqual; U+02271
  NotGreaterFullEqual; U+02267 U+00338
  NotGreaterGreater; U+0226B U+00338
  NotGreaterLess; U+02279
  NotGreaterSlantEqual; U+02A7E U+00338
  NotGreaterTilde; U+02275
  NotHumpDownHump; U+0224E U+00338
  NotHumpEqual; U+0224F U+00338
  notin; U+02209
  notindot; U+022F5 U+00338
  notinE; U+022F9 U+00338
  notinva; U+02209
  notinvb; U+022F7
  notinvc; U+022F6
  NotLeftTriangle; U+022EA
  NotLeftTriangleBar; U+029CF U+00338
  NotLeftTriangleEqual; U+022EC
  NotLess; U+0226E
  NotLessEqual; U+02270
  NotLessGreater; U+02278
  NotLessLess; U+0226A U+00338
  NotLessSlantEqual; U+02A7D U+00338
  NotLessTilde; U+02274
  NotNestedGreaterGreater; U+02AA2 U+00338
  NotNestedLessLess; U+02AA1 U+00338
  notni; U+0220C
  notniva; U+0220C
  notnivb; U+022FE
  notnivc; U+022FD
  NotPrecedes; U+02280
  NotPrecedesEqual; U+02AAF U+00338
  NotPrecedesSlantEqual; U+022E0
  NotReverseElement; U+0220C
  NotRightTriangle; U+022EB
  NotRightTriangleBar; U+029D0 U+00338
  NotRightTriangleEqual; U+022ED
  NotSquareSubset; U+0228F U+00338
  NotSquareSubsetEqual; U+022E2
  NotSquareSuperset; U+02290 U+00338
  NotSquareSupersetEqual; U+022E3
  NotSubset; U+02282 U+020D2
  NotSubsetEqual; U+02288
  NotSucceeds; U+02281
  NotSucceedsEqual; U+02AB0 U+00338
  NotSucceedsSlantEqual; U+022E1
  NotSucceedsTilde; U+0227F U+00338
  NotSuperset; U+02283 U+020D2
  NotSupersetEqual; U+02289
  NotTilde; U+02241
  NotTildeEqual; U+02244
  NotTildeFullEqual; U+02247
  NotTildeTilde; U+02249
  NotVerticalBar; U+02224
  npar; U+02226
  nparallel; U+02226
  nparsl; U+02AFD U+020E5
  npart; U+02202 U+00338
  npolint; U+02A14
  npr; U+02280
  nprcue; U+022E0
  npre; U+02AAF U+00338
  nprec; U+02280
  npreceq; U+02AAF U+00338
  nrArr; U+021CF
  nrarr; U+0219B
  nrarrc; U+02933 U+00338
  nrarrw; U+0219D U+00338
  nRightarrow; U+021CF
  nrightarrow; U+0219B
  nrtri; U+022EB
  nrtrie; U+022ED
  nsc; U+02281
  nsccue; U+022E1
  nsce; U+02AB0 U+00338
  Nscr; U+1D4A9
  nscr; U+1D4C3
  nshortmid; U+02224
  nshortparallel; U+02226
  nsim; U+02241
  nsime; U+02244
  nsimeq; U+02244
  nsmid; U+02224
  nspar; U+02226
  nsqsube; U+022E2
  nsqsupe; U+022E3
  nsub; U+02284
  nsubE; U+02AC5 U+00338
  nsube; U+02288
  nsubset; U+02282 U+020D2
  nsubseteq; U+02288
  nsubseteqq; U+02AC5 U+00338
  nsucc; U+02281
  nsucceq; U+02AB0 U+00338
  nsup; U+02285
  nsupE; U+02AC6 U+00338
  nsupe; U+02289
  nsupset; U+02283 U+020D2
  nsupseteq; U+02289
  nsupseteqq; U+02AC6 U+00338
  ntgl; U+02279
  Ntilde; U+000D1
  Ntilde U+000D1
  ntilde; U+000F1
  ntilde U+000F1
  ntlg; U+02278
  ntriangleleft; U+022EA
  ntrianglelefteq; U+022EC
  ntriangleright; U+022EB
  ntrianglerighteq; U+022ED
  Nu; U+0039D
  nu; U+003BD
  num; U+00023
  numero; U+02116
  numsp; U+02007
  nvap; U+0224D U+020D2
  nVDash; U+022AF
  nVdash; U+022AE
  nvDash; U+022AD
  nvdash; U+022AC
  nvge; U+02265 U+020D2
  nvgt; U+0003E U+020D2
  nvHarr; U+02904
  nvinfin; U+029DE
  nvlArr; U+02902
  nvle; U+02264 U+020D2
  nvlt; U+0003C U+020D2
  nvltrie; U+022B4 U+020D2
  nvrArr; U+02903
  nvrtrie; U+022B5 U+020D2
  nvsim; U+0223C U+020D2
  nwarhk; U+02923
  nwArr; U+021D6
  nwarr; U+02196
  nwarrow; U+02196
  nwnear; U+02927
  Oacute; U+000D3
  Oacute U+000D3
  oacute; U+000F3
  oacute U+000F3
  oast; U+0229B
  ocir; U+0229A
  Ocirc; U+000D4
  Ocirc U+000D4
  ocirc; U+000F4
  ocirc U+000F4
  Ocy; U+0041E
  ocy; U+0043E
  odash; U+0229D
  Odblac; U+00150
  odblac; U+00151
  odiv; U+02A38
  odot; U+02299
  odsold; U+029BC
  OElig; U+00152
  oelig; U+00153
  ofcir; U+029BF
  Ofr; U+1D512
  ofr; U+1D52C
  ogon; U+002DB
  Ograve; U+000D2
  Ograve U+000D2
  ograve; U+000F2
  ograve U+000F2
  ogt; U+029C1
  ohbar; U+029B5
  ohm; U+003A9
  oint; U+0222E
  olarr; U+021BA
  olcir; U+029BE
  olcross; U+029BB
  oline; U+0203E
  olt; U+029C0
  Omacr; U+0014C
  omacr; U+0014D
  Omega; U+003A9
  omega; U+003C9
  Omicron; U+0039F
  omicron; U+003BF
  omid; U+029B6
  ominus; U+02296
  Oopf; U+1D546
  oopf; U+1D560
  opar; U+029B7
  OpenCurlyDoubleQuote; U+0201C
  OpenCurlyQuote; U+02018
  operp; U+029B9
  oplus; U+02295
  Or; U+02A54
  or; U+02228
  orarr; U+021BB
  ord; U+02A5D
  order; U+02134
  orderof; U+02134
  ordf; U+000AA
  ordf U+000AA
  ordm; U+000BA
  ordm U+000BA
  origof; U+022B6
  oror; U+02A56
  orslope; U+02A57
  orv; U+02A5B
  oS; U+024C8
  Oscr; U+1D4AA
  oscr; U+02134
  Oslash; U+000D8
  Oslash U+000D8
  oslash; U+000F8
  oslash U+000F8
  osol; U+02298
  Otilde; U+000D5
  Otilde U+000D5
  otilde; U+000F5
  otilde U+000F5
  Otimes; U+02A37
  otimes; U+02297
  otimesas; U+02A36
  Ouml; U+000D6
  Ouml U+000D6
  ouml; U+000F6
  ouml U+000F6
  ovbar; U+0233D
  OverBar; U+0203E
  OverBrace; U+023DE
  OverBracket; U+023B4
  OverParenthesis; U+023DC
  par; U+02225
  para; U+000B6
  para U+000B6
  parallel; U+02225
  parsim; U+02AF3
  parsl; U+02AFD
  part; U+02202
  PartialD; U+02202
  Pcy; U+0041F
  pcy; U+0043F
  percnt; U+00025
  period; U+0002E
  permil; U+02030
  perp; U+022A5
  pertenk; U+02031
  Pfr; U+1D513
  pfr; U+1D52D
  Phi; U+003A6
  phi; U+003C6
  phiv; U+003D5
  phmmat; U+02133
  phone; U+0260E
  Pi; U+003A0
  pi; U+003C0
  pitchfork; U+022D4
  piv; U+003D6
  planck; U+0210F
  planckh; U+0210E
  plankv; U+0210F
  plus; U+0002B
  plusacir; U+02A23
  plusb; U+0229E
  pluscir; U+02A22
  plusdo; U+02214
  plusdu; U+02A25
  pluse; U+02A72
  PlusMinus; U+000B1
  plusmn; U+000B1
  plusmn U+000B1
  plussim; U+02A26
  plustwo; U+02A27
  pm; U+000B1
  Poincareplane; U+0210C
  pointint; U+02A15
  Popf; U+02119
  popf; U+1D561
  pound; U+000A3
  pound U+000A3
  Pr; U+02ABB
  pr; U+0227A
  prap; U+02AB7
  prcue; U+0227C
  prE; U+02AB3
  pre; U+02AAF
  prec; U+0227A
  precapprox; U+02AB7
  preccurlyeq; U+0227C
  Precedes; U+0227A
  PrecedesEqual; U+02AAF
  PrecedesSlantEqual; U+0227C
  PrecedesTilde; U+0227E
  preceq; U+02AAF
  precnapprox; U+02AB9
  precneqq; U+02AB5
  precnsim; U+022E8
  precsim; U+0227E
  Prime; U+02033
  prime; U+02032
  primes; U+02119
  prnap; U+02AB9
  prnE; U+02AB5
  prnsim; U+022E8
  prod; U+0220F
  Product; U+0220F
  profalar; U+0232E
  profline; U+02312
  profsurf; U+02313
  prop; U+0221D
  Proportion; U+02237
  Proportional; U+0221D
  propto; U+0221D
  prsim; U+0227E
  prurel; U+022B0
  Pscr; U+1D4AB
  pscr; U+1D4C5
  Psi; U+003A8
  psi; U+003C8
  puncsp; U+02008
  Qfr; U+1D514
  qfr; U+1D52E
  qint; U+02A0C
  Qopf; U+0211A
  qopf; U+1D562
  qprime; U+02057
  Qscr; U+1D4AC
  qscr; U+1D4C6
  quaternions; U+0210D
  quatint; U+02A16
  quest; U+0003F
  questeq; U+0225F
  QUOT; U+00022
  QUOT U+00022
  quot; U+00022
  quot U+00022
  rAarr; U+021DB
  race; U+0223D U+00331
  Racute; U+00154
  racute; U+00155
  radic; U+0221A
  raemptyv; U+029B3
  Rang; U+027EB
  rang; U+027E9
  rangd; U+02992
  range; U+029A5
  rangle; U+027E9
  raquo; U+000BB
  raquo U+000BB
  Rarr; U+021A0
  rArr; U+021D2
  rarr; U+02192
  rarrap; U+02975
  rarrb; U+021E5
  rarrbfs; U+02920
  rarrc; U+02933
  rarrfs; U+0291E
  rarrhk; U+021AA
  rarrlp; U+021AC
  rarrpl; U+02945
  rarrsim; U+02974
  Rarrtl; U+02916
  rarrtl; U+021A3
  rarrw; U+0219D
  rAtail; U+0291C
  ratail; U+0291A
  ratio; U+02236
  rationals; U+0211A
  RBarr; U+02910
  rBarr; U+0290F
  rbarr; U+0290D
  rbbrk; U+02773
  rbrace; U+0007D
  rbrack; U+0005D
  rbrke; U+0298C
  rbrksld; U+0298E
  rbrkslu; U+02990
  Rcaron; U+00158
  rcaron; U+00159
  Rcedil; U+00156
  rcedil; U+00157
  rceil; U+02309
  rcub; U+0007D
  Rcy; U+00420
  rcy; U+00440
  rdca; U+02937
  rdldhar; U+02969
  rdquo; U+0201D
  rdquor; U+0201D
  rdsh; U+021B3
  Re; U+0211C
  real; U+0211C
  realine; U+0211B
  realpart; U+0211C
  reals; U+0211D
  rect; U+025AD
  REG; U+000AE
  REG U+000AE
  reg; U+000AE
  reg U+000AE
  ReverseElement; U+0220B
  ReverseEquilibrium; U+021CB
  ReverseUpEquilibrium; U+0296F
  rfisht; U+0297D
  rfloor; U+0230B
  Rfr; U+0211C
  rfr; U+1D52F
  rHar; U+02964
  rhard; U+021C1
  rharu; U+021C0
  rharul; U+0296C
  Rho; U+003A1
  rho; U+003C1
  rhov; U+003F1
  RightAngleBracket; U+027E9
  RightArrow; U+02192
  Rightarrow; U+021D2
  rightarrow; U+02192
  RightArrowBar; U+021E5
  RightArrowLeftArrow; U+021C4
  rightarrowtail; U+021A3
  RightCeiling; U+02309
  RightDoubleBracket; U+027E7
  RightDownTeeVector; U+0295D
  RightDownVector; U+021C2
  RightDownVectorBar; U+02955
  RightFloor; U+0230B
  rightharpoondown; U+021C1
  rightharpoonup; U+021C0
  rightleftarrows; U+021C4
  rightleftharpoons; U+021CC
  rightrightarrows; U+021C9
  rightsquigarrow; U+0219D
  RightTee; U+022A2
  RightTeeArrow; U+021A6
  RightTeeVector; U+0295B
  rightthreetimes; U+022CC
  RightTriangle; U+022B3
  RightTriangleBar; U+029D0
  RightTriangleEqual; U+022B5
  RightUpDownVector; U+0294F
  RightUpTeeVector; U+0295C
  RightUpVector; U+021BE
  RightUpVectorBar; U+02954
  RightVector; U+021C0
  RightVectorBar; U+02953
  ring; U+002DA
  risingdotseq; U+02253
  rlarr; U+021C4
  rlhar; U+021CC
  rlm; U+0200F
  rmoust; U+023B1
  rmoustache; U+023B1
  rnmid; U+02AEE
  roang; U+027ED
  roarr; U+021FE
  robrk; U+027E7
  ropar; U+02986
  Ropf; U+0211D
  ropf; U+1D563
  roplus; U+02A2E
  rotimes; U+02A35
  RoundImplies; U+02970
  rpar; U+00029
  rpargt; U+02994
  rppolint; U+02A12
  rrarr; U+021C9
  Rrightarrow; U+021DB
  rsaquo; U+0203A
  Rscr; U+0211B
  rscr; U+1D4C7
  Rsh; U+021B1
  rsh; U+021B1
  rsqb; U+0005D
  rsquo; U+02019
  rsquor; U+02019
  rthree; U+022CC
  rtimes; U+022CA
  rtri; U+025B9
  rtrie; U+022B5
  rtrif; U+025B8
  rtriltri; U+029CE
  RuleDelayed; U+029F4
  ruluhar; U+02968
  rx; U+0211E
  Sacute; U+0015A
  sacute; U+0015B
  sbquo; U+0201A
  Sc; U+02ABC
  sc; U+0227B
  scap; U+02AB8
  Scaron; U+00160
  scaron; U+00161
  sccue; U+0227D
  scE; U+02AB4
  sce; U+02AB0
  Scedil; U+0015E
  scedil; U+0015F
  Scirc; U+0015C
  scirc; U+0015D
  scnap; U+02ABA
  scnE; U+02AB6
  scnsim; U+022E9
  scpolint; U+02A13
  scsim; U+0227F
  Scy; U+00421
  scy; U+00441
  sdot; U+022C5
  sdotb; U+022A1
  sdote; U+02A66
  searhk; U+02925
  seArr; U+021D8
  searr; U+02198
  searrow; U+02198
  sect; U+000A7
  sect U+000A7
  semi; U+0003B
  seswar; U+02929
  setminus; U+02216
  setmn; U+02216
  sext; U+02736
  Sfr; U+1D516
  sfr; U+1D530
  sfrown; U+02322
  sharp; U+0266F
  SHCHcy; U+00429
  shchcy; U+00449
  SHcy; U+00428
  shcy; U+00448
  ShortDownArrow; U+02193
  ShortLeftArrow; U+02190
  shortmid; U+02223
  shortparallel; U+02225
  ShortRightArrow; U+02192
  ShortUpArrow; U+02191
  shy; U+000AD
  shy U+000AD
  Sigma; U+003A3
  sigma; U+003C3
  sigmaf; U+003C2
  sigmav; U+003C2
  sim; U+0223C
  simdot; U+02A6A
  sime; U+02243
  simeq; U+02243
  simg; U+02A9E
  simgE; U+02AA0
  siml; U+02A9D
  simlE; U+02A9F
  simne; U+02246
  simplus; U+02A24
  simrarr; U+02972
  slarr; U+02190
  SmallCircle; U+02218
  smallsetminus; U+02216
  smashp; U+02A33
  smeparsl; U+029E4
  smid; U+02223
  smile; U+02323
  smt; U+02AAA
  smte; U+02AAC
  smtes; U+02AAC U+0FE00
  SOFTcy; U+0042C
  softcy; U+0044C
  sol; U+0002F
  solb; U+029C4
  solbar; U+0233F
  Sopf; U+1D54A
  sopf; U+1D564
  spades; U+02660
  spadesuit; U+02660
  spar; U+02225
  sqcap; U+02293
  sqcaps; U+02293 U+0FE00
  sqcup; U+02294
  sqcups; U+02294 U+0FE00
  Sqrt; U+0221A
  sqsub; U+0228F
  sqsube; U+02291
  sqsubset; U+0228F
  sqsubseteq; U+02291
  sqsup; U+02290
  sqsupe; U+02292
  sqsupset; U+02290
  sqsupseteq; U+02292
  squ; U+025A1
  Square; U+025A1
  square; U+025A1
  SquareIntersection; U+02293
  SquareSubset; U+0228F
  SquareSubsetEqual; U+02291
  SquareSuperset; U+02290
  SquareSupersetEqual; U+02292
  SquareUnion; U+02294
  squarf; U+025AA
  squf; U+025AA
  srarr; U+02192
  Sscr; U+1D4AE
  sscr; U+1D4C8
  ssetmn; U+02216
  ssmile; U+02323
  sstarf; U+022C6
  Star; U+022C6
  star; U+02606
  starf; U+02605
  straightepsilon; U+003F5
  straightphi; U+003D5
  strns; U+000AF
  Sub; U+022D0
  sub; U+02282
  subdot; U+02ABD
  subE; U+02AC5
  sube; U+02286
  subedot; U+02AC3
  submult; U+02AC1
  subnE; U+02ACB
  subne; U+0228A
  subplus; U+02ABF
  subrarr; U+02979
  Subset; U+022D0
  subset; U+02282
  subseteq; U+02286
  subseteqq; U+02AC5
  SubsetEqual; U+02286
  subsetneq; U+0228A
  subsetneqq; U+02ACB
  subsim; U+02AC7
  subsub; U+02AD5
  subsup; U+02AD3
  succ; U+0227B
  succapprox; U+02AB8
  succcurlyeq; U+0227D
  Succeeds; U+0227B
  SucceedsEqual; U+02AB0
  SucceedsSlantEqual; U+0227D
  SucceedsTilde; U+0227F
  succeq; U+02AB0
  succnapprox; U+02ABA
  succneqq; U+02AB6
  succnsim; U+022E9
  succsim; U+0227F
  SuchThat; U+0220B
  Sum; U+02211
  sum; U+02211
  sung; U+0266A
  Sup; U+022D1
  sup; U+02283
  sup1; U+000B9
  sup1 U+000B9
  sup2; U+000B2
  sup2 U+000B2
  sup3; U+000B3
  sup3 U+000B3
  supdot; U+02ABE
  supdsub; U+02AD8
  supE; U+02AC6
  supe; U+02287
  supedot; U+02AC4
  Superset; U+02283
  SupersetEqual; U+02287
  suphsol; U+027C9
  suphsub; U+02AD7
  suplarr; U+0297B
  supmult; U+02AC2
  supnE; U+02ACC
  supne; U+0228B
  supplus; U+02AC0
  Supset; U+022D1
  supset; U+02283
  supseteq; U+02287
  supseteqq; U+02AC6
  supsetneq; U+0228B
  supsetneqq; U+02ACC
  supsim; U+02AC8
  supsub; U+02AD4
  supsup; U+02AD6
  swarhk; U+02926
  swArr; U+021D9
  swarr; U+02199
  swarrow; U+02199
  swnwar; U+0292A
  szlig; U+000DF
  szlig U+000DF
  Tab; U+00009
  target; U+02316
  Tau; U+003A4
  tau; U+003C4
  tbrk; U+023B4
  Tcaron; U+00164
  tcaron; U+00165
  Tcedil; U+00162
  tcedil; U+00163
  Tcy; U+00422
  tcy; U+00442
  tdot; U+020DB
  telrec; U+02315
  Tfr; U+1D517
  tfr; U+1D531
  there4; U+02234
  Therefore; U+02234
  therefore; U+02234
  Theta; U+00398
  theta; U+003B8
  thetasym; U+003D1
  thetav; U+003D1
  thickapprox; U+02248
  thicksim; U+0223C
  ThickSpace; U+0205F U+0200A
  thinsp; U+02009
  ThinSpace; U+02009
  thkap; U+02248
  thksim; U+0223C
  THORN; U+000DE
  THORN U+000DE
  thorn; U+000FE
  thorn U+000FE
  Tilde; U+0223C
  tilde; U+002DC
  TildeEqual; U+02243
  TildeFullEqual; U+02245
  TildeTilde; U+02248
  times; U+000D7
  times U+000D7
  timesb; U+022A0
  timesbar; U+02A31
  timesd; U+02A30
  tint; U+0222D
  toea; U+02928
  top; U+022A4
  topbot; U+02336
  topcir; U+02AF1
  Topf; U+1D54B
  topf; U+1D565
  topfork; U+02ADA
  tosa; U+02929
  tprime; U+02034
  TRADE; U+02122
  trade; U+02122
  triangle; U+025B5
  triangledown; U+025BF
  triangleleft; U+025C3
  trianglelefteq; U+022B4
  triangleq; U+0225C
  triangleright; U+025B9
  trianglerighteq; U+022B5
  tridot; U+025EC
  trie; U+0225C
  triminus; U+02A3A
  TripleDot; U+020DB
  triplus; U+02A39
  trisb; U+029CD
  tritime; U+02A3B
  trpezium; U+023E2
  Tscr; U+1D4AF
  tscr; U+1D4C9
  TScy; U+00426
  tscy; U+00446
  TSHcy; U+0040B
  tshcy; U+0045B
  Tstrok; U+00166
  tstrok; U+00167
  twixt; U+0226C
  twoheadleftarrow; U+0219E
  twoheadrightarrow; U+021A0
  Uacute; U+000DA
  Uacute U+000DA
  uacute; U+000FA
  uacute U+000FA
  Uarr; U+0219F
  uArr; U+021D1
  uarr; U+02191
  Uarrocir; U+02949
  Ubrcy; U+0040E
  ubrcy; U+0045E
  Ubreve; U+0016C
  ubreve; U+0016D
  Ucirc; U+000DB
  Ucirc U+000DB
  ucirc; U+000FB
  ucirc U+000FB
  Ucy; U+00423
  ucy; U+00443
  udarr; U+021C5
  Udblac; U+00170
  udblac; U+00171
  udhar; U+0296E
  ufisht; U+0297E
  Ufr; U+1D518
  ufr; U+1D532
  Ugrave; U+000D9
  Ugrave U+000D9
  ugrave; U+000F9
  ugrave U+000F9
  uHar; U+02963
  uharl; U+021BF
  uharr; U+021BE
  uhblk; U+02580
  ulcorn; U+0231C
  ulcorner; U+0231C
  ulcrop; U+0230F
  ultri; U+025F8
  Umacr; U+0016A
  umacr; U+0016B
  uml; U+000A8
  uml U+000A8
  UnderBar; U+0005F
  UnderBrace; U+023DF
  UnderBracket; U+023B5
  UnderParenthesis; U+023DD
  Union; U+022C3
  UnionPlus; U+0228E
  Uogon; U+00172
  uogon; U+00173
  Uopf; U+1D54C
  uopf; U+1D566
  UpArrow; U+02191
  Uparrow; U+021D1
  uparrow; U+02191
  UpArrowBar; U+02912
  UpArrowDownArrow; U+021C5
  UpDownArrow; U+02195
  Updownarrow; U+021D5
  updownarrow; U+02195
  UpEquilibrium; U+0296E
  upharpoonleft; U+021BF
  upharpoonright; U+021BE
  uplus; U+0228E
  UpperLeftArrow; U+02196
  UpperRightArrow; U+02197
  Upsi; U+003D2
  upsi; U+003C5
  upsih; U+003D2
  Upsilon; U+003A5
  upsilon; U+003C5
  UpTee; U+022A5
  UpTeeArrow; U+021A5
  upuparrows; U+021C8
  urcorn; U+0231D
  urcorner; U+0231D
  urcrop; U+0230E
  Uring; U+0016E
  uring; U+0016F
  urtri; U+025F9
  Uscr; U+1D4B0
  uscr; U+1D4CA
  utdot; U+022F0
  Utilde; U+00168
  utilde; U+00169
  utri; U+025B5
  utrif; U+025B4
  uuarr; U+021C8
  Uuml; U+000DC
  Uuml U+000DC
  uuml; U+000FC
  uuml U+000FC
  uwangle; U+029A7
  vangrt; U+0299C
  varepsilon; U+003F5
  varkappa; U+003F0
  varnothing; U+02205
  varphi; U+003D5
  varpi; U+003D6
  varpropto; U+0221D
  vArr; U+021D5
  varr; U+02195
  varrho; U+003F1
  varsigma; U+003C2
  varsubsetneq; U+0228A U+0FE00
  varsubsetneqq; U+02ACB U+0FE00
  varsupsetneq; U+0228B U+0FE00
  varsupsetneqq; U+02ACC U+0FE00
  vartheta; U+003D1
  vartriangleleft; U+022B2
  vartriangleright; U+022B3
  Vbar; U+02AEB
  vBar; U+02AE8
  vBarv; U+02AE9
  Vcy; U+00412
  vcy; U+00432
  VDash; U+022AB
  Vdash; U+022A9
  vDash; U+022A8
  vdash; U+022A2
  Vdashl; U+02AE6
  Vee; U+022C1
  vee; U+02228
  veebar; U+022BB
  veeeq; U+0225A
  vellip; U+022EE
  Verbar; U+02016
  verbar; U+0007C
  Vert; U+02016
  vert; U+0007C
  VerticalBar; U+02223
  VerticalLine; U+0007C
  VerticalSeparator; U+02758
  VerticalTilde; U+02240
  VeryThinSpace; U+0200A
  Vfr; U+1D519
  vfr; U+1D533
  vltri; U+022B2
  vnsub; U+02282 U+020D2
  vnsup; U+02283 U+020D2
  Vopf; U+1D54D
  vopf; U+1D567
  vprop; U+0221D
  vrtri; U+022B3
  Vscr; U+1D4B1
  vscr; U+1D4CB
  vsubnE; U+02ACB U+0FE00
  vsubne; U+0228A U+0FE00
  vsupnE; U+02ACC U+0FE00
  vsupne; U+0228B U+0FE00
  Vvdash; U+022AA
  vzigzag; U+0299A
  Wcirc; U+00174
  wcirc; U+00175
  wedbar; U+02A5F
  Wedge; U+022C0
  wedge; U+02227
  wedgeq; U+02259
  weierp; U+02118
  Wfr; U+1D51A
  wfr; U+1D534
  Wopf; U+1D54E
  wopf; U+1D568
  wp; U+02118
  wr; U+02240
  wreath; U+02240
  Wscr; U+1D4B2
  wscr; U+1D4CC
  xcap; U+022C2
  xcirc; U+025EF
  xcup; U+022C3
  xdtri; U+025BD
  Xfr; U+1D51B
  xfr; U+1D535
  xhArr; U+027FA
  xharr; U+027F7
  Xi; U+0039E
  xi; U+003BE
  xlArr; U+027F8
  xlarr; U+027F5
  xmap; U+027FC
  xnis; U+022FB
  xodot; U+02A00
  Xopf; U+1D54F
  xopf; U+1D569
  xoplus; U+02A01
  xotime; U+02A02
  xrArr; U+027F9
  xrarr; U+027F6
  Xscr; U+1D4B3
  xscr; U+1D4CD
  xsqcup; U+02A06
  xuplus; U+02A04
  xutri; U+025B3
  xvee; U+022C1
  xwedge; U+022C0
  Yacute; U+000DD
  Yacute U+000DD
  yacute; U+000FD
  yacute U+000FD
  YAcy; U+0042F
  yacy; U+0044F
  Ycirc; U+00176
  ycirc; U+00177
  Ycy; U+0042B
  ycy; U+0044B
  yen; U+000A5
  yen U+000A5
  Yfr; U+1D51C
  yfr; U+1D536
  YIcy; U+00407
  yicy; U+00457
  Yopf; U+1D550
  yopf; U+1D56A
  Yscr; U+1D4B4
  yscr; U+1D4CE
  YUcy; U+0042E
  yucy; U+0044E
  Yuml; U+00178
  yuml; U+000FF
  yuml U+000FF
  Zacute; U+00179
  zacute; U+0017A
  Zcaron; U+0017D
  zcaron; U+0017E
  Zcy; U+00417
  zcy; U+00437
  Zdot; U+0017B
  zdot; U+0017C
  zeetrf; U+02128
  ZeroWidthSpace; U+0200B
  Zeta; U+00396
  zeta; U+003B6
  Zfr; U+02128
  zfr; U+1D537
  ZHcy; U+00416
  zhcy; U+00436
  zigrarr; U+021DD
  Zopf; U+02124
  zopf; U+1D56B
  Zscr; U+1D4B5
  zscr; U+1D4CF
  zwj; U+0200D
  zwnj; U+0200C
MOJO_UTIL

$fatpacked{"Mojo/WebSocket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_WEBSOCKET';
  package Mojo::WebSocket;
  use Mojo::Base -strict;
  
  use Config;
  use Exporter 'import';
  use Mojo::Util qw(b64_encode dumper sha1_bytes xor_encode);
  
  use constant DEBUG => $ENV{MOJO_WEBSOCKET_DEBUG} || 0;
  
  # Unique value from RFC 6455
  use constant GUID => '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';
  
  # Perl with support for quads
  use constant MODERN =>
    (($Config{use64bitint} // '') eq 'define' || $Config{longsize} >= 8);
  
  # Opcodes
  use constant {
    WS_CONTINUATION => 0x0,
    WS_TEXT         => 0x1,
    WS_BINARY       => 0x2,
    WS_CLOSE        => 0x8,
    WS_PING         => 0x9,
    WS_PONG         => 0xa
  };
  
  our @EXPORT_OK = (
    qw(WS_BINARY WS_CLOSE WS_CONTINUATION WS_PING WS_PONG WS_TEXT),
    qw(build_frame challenge client_handshake parse_frame server_handshake)
  );
  
  sub build_frame {
    my ($masked, $fin, $rsv1, $rsv2, $rsv3, $op, $payload) = @_;
    warn "-- Building frame ($fin, $rsv1, $rsv2, $rsv3, $op)\n" if DEBUG;
  
    # Head
    my $head = $op + ($fin ? 128 : 0);
    $head |= 0b01000000 if $rsv1;
    $head |= 0b00100000 if $rsv2;
    $head |= 0b00010000 if $rsv3;
    my $frame = pack 'C', $head;
  
    # Small payload
    my $len = length $payload;
    if ($len < 126) {
      warn "-- Small payload ($len)\n@{[dumper $payload]}" if DEBUG;
      $frame .= pack 'C', $masked ? ($len | 128) : $len;
    }
  
    # Extended payload (16-bit)
    elsif ($len < 65536) {
      warn "-- Extended 16-bit payload ($len)\n@{[dumper $payload]}" if DEBUG;
      $frame .= pack 'Cn', $masked ? (126 | 128) : 126, $len;
    }
  
    # Extended payload (64-bit with 32-bit fallback)
    else {
      warn "-- Extended 64-bit payload ($len)\n@{[dumper $payload]}" if DEBUG;
      $frame .= pack 'C', $masked ? (127 | 128) : 127;
      $frame .= MODERN ? pack('Q>', $len) : pack('NN', 0, $len & 0xffffffff);
    }
  
    # Mask payload
    if ($masked) {
      my $mask = pack 'N', int(rand 9 x 7);
      $payload = $mask . xor_encode($payload, $mask x 128);
    }
  
    return $frame . $payload;
  }
  
  sub challenge {
    my $tx = shift;
  
    # "permessage-deflate" extension
    my $headers = $tx->res->headers;
    $tx->compressed(1)
      if ($headers->sec_websocket_extensions // '') =~ /permessage-deflate/;
  
    return _challenge($tx->req->headers->sec_websocket_key) eq
      $headers->sec_websocket_accept;
  }
  
  sub client_handshake {
    my $tx = shift;
  
    my $headers = $tx->req->headers;
    $headers->upgrade('websocket')      unless $headers->upgrade;
    $headers->connection('Upgrade')     unless $headers->connection;
    $headers->sec_websocket_version(13) unless $headers->sec_websocket_version;
  
    # Generate 16 byte WebSocket challenge
    my $challenge = b64_encode sprintf('%16u', int(rand 9 x 16)), '';
    $headers->sec_websocket_key($challenge) unless $headers->sec_websocket_key;
  
    return $tx;
  }
  
  sub parse_frame {
    my ($buffer, $max) = @_;
  
    # Head
    return undef unless length $$buffer >= 2;
    my ($first, $second) = unpack 'C2', $$buffer;
  
    # FIN
    my $fin = ($first & 0b10000000) == 0b10000000 ? 1 : 0;
  
    # RSV1-3
    my $rsv1 = ($first & 0b01000000) == 0b01000000 ? 1 : 0;
    my $rsv2 = ($first & 0b00100000) == 0b00100000 ? 1 : 0;
    my $rsv3 = ($first & 0b00010000) == 0b00010000 ? 1 : 0;
  
    # Opcode
    my $op = $first & 0b00001111;
    warn "-- Parsing frame ($fin, $rsv1, $rsv2, $rsv3, $op)\n" if DEBUG;
  
    # Small payload
    my ($hlen, $len) = (2, $second & 0b01111111);
    if ($len < 126) { warn "-- Small payload ($len)\n" if DEBUG }
  
    # Extended payload (16-bit)
    elsif ($len == 126) {
      return undef unless length $$buffer > 4;
      $hlen = 4;
      $len = unpack 'x2n', $$buffer;
      warn "-- Extended 16-bit payload ($len)\n" if DEBUG;
    }
  
    # Extended payload (64-bit with 32-bit fallback)
    elsif ($len == 127) {
      return undef unless length $$buffer > 10;
      $hlen = 10;
      $len = MODERN ? unpack('x2Q>', $$buffer) : unpack('x2x4N', $$buffer);
      warn "-- Extended 64-bit payload ($len)\n" if DEBUG;
    }
  
    # Check message size
    return 1 if $len > $max;
  
    # Check if whole packet has arrived
    $len += 4 if my $masked = $second & 0b10000000;
    return undef if length $$buffer < ($hlen + $len);
    substr $$buffer, 0, $hlen, '';
  
    # Payload
    my $payload = $len ? substr($$buffer, 0, $len, '') : '';
    $payload = xor_encode($payload, substr($payload, 0, 4, '') x 128) if $masked;
    warn dumper $payload if DEBUG;
  
    return [$fin, $rsv1, $rsv2, $rsv3, $op, $payload];
  }
  
  sub server_handshake {
    my $tx = shift;
  
    my $headers = $tx->res->headers;
    $headers->upgrade('websocket')->connection('Upgrade');
    $headers->sec_websocket_accept(
      _challenge($tx->req->headers->sec_websocket_key));
  
    return $tx;
  }
  
  sub _challenge { b64_encode(sha1_bytes(($_[0] || '') . GUID), '') }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::WebSocket - The WebSocket protocol
  
  =head1 SYNOPSIS
  
    use Mojo::WebSocket qw(WS_TEXT build_frame parse_frame);
  
    my $bytes = build_frame 0, 1, 0, 0, 0, WS_TEXT, 'Hello World!';
    my $frame = parse_frame \$bytes, 262144;
  
  =head1 DESCRIPTION
  
  L<Mojo::WebSocket> implements the WebSocket protocol as described in
  L<RFC 6455|http://tools.ietf.org/html/rfc6455>. Note that 64-bit frames require
  a Perl with support for quads or they are limited to 32-bit.
  
  =head1 FUNCTIONS
  
  L<Mojo::WebSocket> implements the following functions, which can be imported
  individually.
  
  =head2 build_frame
  
    my $bytes = build_frame $masked, $fin, $rsv1, $rsv2, $rsv3, $op, $payload;
  
  Build WebSocket frame.
  
    # Masked binary frame with FIN bit and payload
    say build_frame 1, 1, 0, 0, 0, WS_BINARY, 'Hello World!';
  
    # Text frame with payload but without FIN bit
    say build_frame 0, 0, 0, 0, 0, WS_TEXT, 'Hello ';
  
    # Continuation frame with FIN bit and payload
    say build_frame 0, 1, 0, 0, 0, WS_CONTINUATION, 'World!';
  
    # Close frame with FIN bit and without payload
    say build_frame 0, 1, 0, 0, 0, WS_CLOSE, '';
  
    # Ping frame with FIN bit and payload
    say build_frame 0, 1, 0, 0, 0, WS_PING, 'Test 123';
  
    # Pong frame with FIN bit and payload
    say build_frame 0, 1, 0, 0, 0, WS_PONG, 'Test 123';
  
  =head2 challenge
  
    my $bool = challenge Mojo::Transaction::WebSocket->new;
  
  Check WebSocket handshake challenge.
  
  =head2 client_handshake
  
    my $tx = client_handshake Mojo::Transaction::HTTP->new;
  
  Perform WebSocket handshake client-side.
  
  =head2 parse_frame
  
    my $frame = parse_frame \$bytes, $limit;
  
  Parse WebSocket frame.
  
    # Parse single frame and remove it from buffer
    my $frame = parse_frame \$buffer, 262144;
    say "FIN: $frame->[0]";
    say "RSV1: $frame->[1]";
    say "RSV2: $frame->[2]";
    say "RSV3: $frame->[3]";
    say "Opcode: $frame->[4]";
    say "Payload: $frame->[5]";
  
  =head2 server_handshake
  
    my $tx = server_handshake Mojo::Transaction::HTTP->new;
  
  Perform WebSocket handshake server-side.
  
  =head1 CONSTANTS
  
  L<Mojo::WebSocket> implements the following constants, which can be imported
  individually.
  
  =head2 WS_BINARY
  
  Opcode for C<Binary> frames.
  
  =head2 WS_CLOSE
  
  Opcode for C<Close> frames.
  
  =head2 WS_CONTINUATION
  
  Opcode for C<Continuation> frames.
  
  =head2 WS_PING
  
  Opcode for C<Ping> frames.
  
  =head2 WS_PONG
  
  Opcode for C<Pong> frames.
  
  =head2 WS_TEXT
  
  Opcode for C<Text> frames.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_WEBSOCKET

$fatpacked{"Mojolicious.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS';
  package Mojolicious;
  use Mojo::Base -base;
  
  # "Fry: Shut up and take my money!"
  use Carp ();
  use Mojo::Exception;
  use Mojo::Home;
  use Mojo::Log;
  use Mojo::Util;
  use Mojo::UserAgent;
  use Mojolicious::Commands;
  use Mojolicious::Controller;
  use Mojolicious::Plugins;
  use Mojolicious::Renderer;
  use Mojolicious::Routes;
  use Mojolicious::Sessions;
  use Mojolicious::Static;
  use Mojolicious::Types;
  use Mojolicious::Validator;
  use Scalar::Util ();
  
  has commands => sub {
    my $commands = Mojolicious::Commands->new(app => shift);
    Scalar::Util::weaken $commands->{app};
    return $commands;
  };
  has controller_class => 'Mojolicious::Controller';
  has home             => sub { Mojo::Home->new->detect(ref shift) };
  has log              => sub {
    my $self = shift;
  
    # Check if we have a log directory that is writable
    my $log  = Mojo::Log->new;
    my $home = $self->home;
    my $mode = $self->mode;
    $log->path($home->child('log', "$mode.log"))
      if -d $home->child('log') && -w _;
  
    # Reduced log output outside of development mode
    return $mode eq 'development' ? $log : $log->level('info');
  };
  has 'max_request_size';
  has mode     => sub { $ENV{MOJO_MODE} || $ENV{PLACK_ENV} || 'development' };
  has moniker  => sub { Mojo::Util::decamelize ref shift };
  has plugins  => sub { Mojolicious::Plugins->new };
  has renderer => sub { Mojolicious::Renderer->new };
  has routes   => sub { Mojolicious::Routes->new };
  has secrets  => sub {
    my $self = shift;
  
    # Warn developers about insecure default
    $self->log->debug('Your secret passphrase needs to be changed');
  
    # Default to moniker
    return [$self->moniker];
  };
  has sessions => sub { Mojolicious::Sessions->new };
  has static   => sub { Mojolicious::Static->new };
  has types    => sub { Mojolicious::Types->new };
  has ua       => sub {
    my $ua = Mojo::UserAgent->new;
    Scalar::Util::weaken $ua->server->app(shift)->{app};
    return $ua;
  };
  has validator => sub { Mojolicious::Validator->new };
  
  our $CODENAME = 'Doughnut';
  our $VERSION  = '7.87';
  
  sub AUTOLOAD {
    my $self = shift;
  
    my ($package, $method) = our $AUTOLOAD =~ /^(.+)::(.+)$/;
    Carp::croak "Undefined subroutine &${package}::$method called"
      unless Scalar::Util::blessed $self && $self->isa(__PACKAGE__);
  
    # Call helper with fresh controller
    Carp::croak qq{Can't locate object method "$method" via package "$package"}
      unless my $helper = $self->renderer->get_helper($method);
    return $self->build_controller->$helper(@_);
  }
  
  sub build_controller {
    my ($self, $tx) = @_;
    $tx ||= $self->build_tx;
  
    # Embedded application
    my $stash = {};
    if (my $sub = $tx->can('stash')) { ($stash, $tx) = ($tx->$sub, $tx->tx) }
  
    # Build default controller
    my $defaults = $self->defaults;
    @$stash{keys %$defaults} = values %$defaults;
    my $c
      = $self->controller_class->new(app => $self, stash => $stash, tx => $tx);
    Scalar::Util::weaken $c->{app};
  
    return $c;
  }
  
  sub build_tx {
    my $self = shift;
  
    my $tx  = Mojo::Transaction::HTTP->new;
    my $max = $self->max_request_size;
    $tx->req->max_message_size($max) if defined $max;
    $self->plugins->emit_hook(after_build_tx => $tx, $self);
  
    return $tx;
  }
  
  sub config   { Mojo::Util::_stash(config   => @_) }
  sub defaults { Mojo::Util::_stash(defaults => @_) }
  
  sub dispatch {
    my ($self, $c) = @_;
  
    my $plugins = $self->plugins->emit_hook(before_dispatch => $c);
  
    # Try to find a static file
    my $tx = $c->tx;
    $self->static->dispatch($c) and $plugins->emit_hook(after_static => $c)
      unless $tx->res->code;
  
    # Start timer (ignore static files)
    my $stash = $c->stash;
    unless ($stash->{'mojo.static'} || $stash->{'mojo.started'}) {
      my $req    = $c->req;
      my $method = $req->method;
      my $path   = $req->url->path->to_abs_string;
      my $id     = $req->request_id;
      $self->log->debug(qq{$method "$path" ($id)});
      $c->helpers->timing->begin('mojo.timer');
    }
  
    # Routes
    $plugins->emit_hook(before_routes => $c);
    $c->helpers->reply->not_found
      unless $tx->res->code || $self->routes->dispatch($c) || $tx->res->code;
  }
  
  sub handler {
    my $self = shift;
  
    # Dispatcher has to be last in the chain
    ++$self->{dispatch}
      and $self->hook(around_action   => sub { $_[2]($_[1]) })
      and $self->hook(around_dispatch => sub { $_[1]->app->dispatch($_[1]) })
      unless $self->{dispatch};
  
    # Process with chain
    my $c = $self->build_controller(@_);
    Scalar::Util::weaken $c->{tx};
    $self->plugins->emit_chain(around_dispatch => $c);
  
    # Delayed response
    $self->log->debug('Nothing has been rendered, expecting delayed response')
      unless $c->stash->{'mojo.rendered'};
  }
  
  sub helper { shift->renderer->add_helper(@_) }
  
  sub hook { shift->plugins->on(@_) }
  
  sub new {
    my $self = shift->SUPER::new(@_);
  
    my $home = $self->home;
    push @{$self->renderer->paths}, $home->child('templates')->to_string;
    push @{$self->static->paths},   $home->child('public')->to_string;
  
    # Default to controller and application namespace
    my $r = $self->routes->namespaces(["@{[ref $self]}::Controller", ref $self]);
  
    # Hide controller attributes/methods
    $r->hide(qw(app continue cookie every_cookie every_param));
    $r->hide(qw(every_signed_cookie finish flash helpers match on param));
    $r->hide(qw(redirect_to render render_later render_maybe render_to_string));
    $r->hide(qw(rendered req res respond_to send session signed_cookie stash));
    $r->hide(qw(tx url_for validation write write_chunk));
  
    $self->plugin($_)
      for qw(HeaderCondition DefaultHelpers TagHelpers EPLRenderer EPRenderer);
  
    # Exception handling should be first in chain
    $self->hook(around_dispatch => \&_exception);
  
    $self->startup;
  
    return $self;
  }
  
  sub plugin {
    my $self = shift;
    $self->plugins->register_plugin(shift, $self, @_);
  }
  
  sub server { $_[0]->plugins->emit_hook(before_server_start => @_[1, 0]) }
  
  sub start {
    my $self = shift;
    $_->warmup for $self->static, $self->renderer;
    return $self->commands->run(@_ ? @_ : @ARGV);
  }
  
  sub startup { }
  
  sub _exception {
    my ($next, $c) = @_;
    local $SIG{__DIE__}
      = sub { ref $_[0] ? CORE::die $_[0] : Mojo::Exception->throw(shift) };
    $c->helpers->reply->exception($@) unless eval { $next->(); 1 };
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious - Real-time web framework
  
  =head1 SYNOPSIS
  
    # Application
    package MyApp;
    use Mojo::Base 'Mojolicious';
  
    # Route
    sub startup {
      my $self = shift;
      $self->routes->get('/hello')->to('foo#hello');
    }
  
    # Controller
    package MyApp::Controller::Foo;
    use Mojo::Base 'Mojolicious::Controller';
  
    # Action
    sub hello {
      my $self = shift;
      $self->render(text => 'Hello World!');
    }
  
  =head1 DESCRIPTION
  
  An amazing real-time web framework built on top of the powerful L<Mojo> web
  development toolkit. With support for RESTful routes, plugins, commands,
  Perl-ish templates, content negotiation, session management, form validation,
  testing framework, static file server, C<CGI>/C<PSGI> detection, first class
  Unicode support and much more for you to discover.
  
  Take a look at our excellent documentation in L<Mojolicious::Guides>!
  
  =head1 HOOKS
  
  L<Mojolicious> will emit the following hooks in the listed order.
  
  =head2 before_server_start
  
  Emitted right before the application server is started, for web servers that
  support it, which includes all the built-in ones (except for
  L<Mojo::Server::CGI>). Note that this hook is EXPERIMENTAL and might change
  without warning!
  
    $app->hook(before_server_start => sub {
      my ($server, $app) = @_;
      ...
    });
  
  Useful for reconfiguring application servers dynamically or collecting server
  diagnostics information. (Passed the server and application objects)
  
  =head2 after_build_tx
  
  Emitted right after the transaction is built and before the HTTP request gets
  parsed.
  
    $app->hook(after_build_tx => sub {
      my ($tx, $app) = @_;
      ...
    });
  
  This is a very powerful hook and should not be used lightly, it makes some
  rather advanced features such as upload progress bars possible. Note that this
  hook will not work for embedded applications, because only the host application
  gets to build transactions. (Passed the transaction and application objects)
  
  =head2 around_dispatch
  
  Emitted right after a new request has been received and wraps around the whole
  dispatch process, so you have to manually forward to the next hook if you want
  to continue the chain. Default exception handling with
  L<Mojolicious::Plugin::DefaultHelpers/"reply-E<gt>exception"> is the first hook
  in the chain and a call to L</"dispatch"> the last, yours will be in between.
  
    $app->hook(around_dispatch => sub {
      my ($next, $c) = @_;
      ...
      $next->();
      ...
    });
  
  This is a very powerful hook and should not be used lightly, it allows you to,
  for example, customize application-wide exception handling, consider it the
  sledgehammer in your toolbox. (Passed a callback leading to the next hook and
  the default controller object)
  
  =head2 before_dispatch
  
  Emitted right before the static file server and router start their work.
  
    $app->hook(before_dispatch => sub {
      my $c = shift;
      ...
    });
  
  Very useful for rewriting incoming requests and other preprocessing tasks.
  (Passed the default controller object)
  
  =head2 after_static
  
  Emitted after a static file response has been generated by the static file
  server.
  
    $app->hook(after_static => sub {
      my $c = shift;
      ...
    });
  
  Mostly used for post-processing static file responses. (Passed the default
  controller object)
  
  =head2 before_routes
  
  Emitted after the static file server determined if a static file should be
  served and before the router starts its work.
  
    $app->hook(before_routes => sub {
      my $c = shift;
      ...
    });
  
  Mostly used for custom dispatchers and collecting metrics. (Passed the default
  controller object)
  
  =head2 around_action
  
  Emitted right before an action gets executed and wraps around it, so you have to
  manually forward to the next hook if you want to continue the chain. Default
  action dispatching is the last hook in the chain, yours will run before it.
  
    $app->hook(around_action => sub {
      my ($next, $c, $action, $last) = @_;
      ...
      return $next->();
    });
  
  This is a very powerful hook and should not be used lightly, it allows you for
  example to pass additional arguments to actions or handle return values
  differently. Note that this hook can trigger more than once for the same
  request if there are nested routes. (Passed a callback leading to the next hook,
  the current controller object, the action callback and a flag indicating if this
  action is an endpoint)
  
  =head2 before_render
  
  Emitted before content is generated by the renderer. Note that this hook can
  trigger out of order due to its dynamic nature, and with embedded applications
  will only work for the application that is rendering.
  
    $app->hook(before_render => sub {
      my ($c, $args) = @_;
      ...
    });
  
  Mostly used for pre-processing arguments passed to the renderer. (Passed the
  current controller object and the render arguments)
  
  =head2 after_render
  
  Emitted after content has been generated by the renderer that will be assigned
  to the response. Note that this hook can trigger out of order due to its
  dynamic nature, and with embedded applications will only work for the
  application that is rendering.
  
    $app->hook(after_render => sub {
      my ($c, $output, $format) = @_;
      ...
    });
  
  Mostly used for post-processing dynamically generated content. (Passed the
  current controller object, a reference to the content and the format)
  
  =head2 after_dispatch
  
  Emitted in reverse order after a response has been generated. Note that this
  hook can trigger out of order due to its dynamic nature, and with embedded
  applications will only work for the application that is generating the response.
  
    $app->hook(after_dispatch => sub {
      my $c = shift;
      ...
    });
  
  Useful for rewriting outgoing responses and other post-processing tasks.
  (Passed the current controller object)
  
  =head1 ATTRIBUTES
  
  L<Mojolicious> implements the following attributes.
  
  =head2 commands
  
    my $commands = $app->commands;
    $app         = $app->commands(Mojolicious::Commands->new);
  
  Command line interface for your application, defaults to a
  L<Mojolicious::Commands> object.
  
    # Add another namespace to load commands from
    push @{$app->commands->namespaces}, 'MyApp::Command';
  
  =head2 controller_class
  
    my $class = $app->controller_class;
    $app      = $app->controller_class('Mojolicious::Controller');
  
  Class to be used for the default controller, defaults to
  L<Mojolicious::Controller>. Note that this class needs to have already been
  loaded before the first request arrives.
  
  =head2 home
  
    my $home = $app->home;
    $app     = $app->home(Mojo::Home->new);
  
  The home directory of your application, defaults to a L<Mojo::Home> object
  which stringifies to the actual path.
  
    # Portably generate path relative to home directory
    my $path = $app->home->child('data', 'important.txt');
  
  =head2 log
  
    my $log = $app->log;
    $app    = $app->log(Mojo::Log->new);
  
  The logging layer of your application, defaults to a L<Mojo::Log> object. The
  level will default to C<debug> if the L</mode> is C<development>, or C<info>
  otherwise. All messages will be written to C<STDERR>, or a C<log/$mode.log> file
  if a C<log> directory exists.
  
    # Log debug message
    $app->log->debug('It works');
  
  =head2 max_request_size
  
    my $max = $app->max_request_size;
    $app    = $app->max_request_size(16777216);
  
  Maximum request size in bytes, defaults to the value of
  L<Mojo::Message/"max_message_size">. Setting the value to C<0> will allow
  requests of indefinite size. Note that increasing this value can also
  drastically increase memory usage, should you for example attempt to parse an
  excessively large request body with the methods L<Mojo::Message/"dom"> or
  L<Mojo::Message/"json">.
  
  =head2 mode
  
    my $mode = $app->mode;
    $app     = $app->mode('production');
  
  The operating mode for your application, defaults to a value from the
  C<MOJO_MODE> and C<PLACK_ENV> environment variables or C<development>.
  
  =head2 moniker
  
    my $moniker = $app->moniker;
    $app        = $app->moniker('foo_bar');
  
  Moniker of this application, often used as default filename for configuration
  files and the like, defaults to decamelizing the application class with
  L<Mojo::Util/"decamelize">.
  
  =head2 plugins
  
    my $plugins = $app->plugins;
    $app        = $app->plugins(Mojolicious::Plugins->new);
  
  The plugin manager, defaults to a L<Mojolicious::Plugins> object. See the
  L</"plugin"> method below if you want to load a plugin.
  
    # Add another namespace to load plugins from
    push @{$app->plugins->namespaces}, 'MyApp::Plugin';
  
  =head2 renderer
  
    my $renderer = $app->renderer;
    $app         = $app->renderer(Mojolicious::Renderer->new);
  
  Used to render content, defaults to a L<Mojolicious::Renderer> object. For more
  information about how to generate content see
  L<Mojolicious::Guides::Rendering>.
  
    # Add another "templates" directory
    push @{$app->renderer->paths}, '/home/sri/templates';
  
    # Add another "templates" directory with higher precedence
    unshift @{$app->renderer->paths}, '/home/sri/themes/blue/templates';
  
    # Add another class with templates in DATA section
    push @{$app->renderer->classes}, 'Mojolicious::Plugin::Fun';
  
  =head2 routes
  
    my $routes = $app->routes;
    $app       = $app->routes(Mojolicious::Routes->new);
  
  The router, defaults to a L<Mojolicious::Routes> object. You use this in your
  startup method to define the url endpoints for your application.
  
    # Add routes
    my $r = $app->routes;
    $r->get('/foo/bar')->to('test#foo', title => 'Hello Mojo!');
    $r->post('/baz')->to('test#baz');
  
    # Add another namespace to load controllers from
    push @{$app->routes->namespaces}, 'MyApp::MyController';
  
  =head2 secrets
  
    my $secrets = $app->secrets;
    $app        = $app->secrets([$bytes]);
  
  Secret passphrases used for signed cookies and the like, defaults to the
  L</"moniker"> of this application, which is not very secure, so you should
  change it!!! As long as you are using the insecure default there will be debug
  messages in the log file reminding you to change your passphrase. Only the
  first passphrase is used to create new signatures, but all of them for
  verification. So you can increase security without invalidating all your
  existing signed cookies by rotating passphrases, just add new ones to the front
  and remove old ones from the back.
  
    # Rotate passphrases
    $app->secrets(['new_passw0rd', 'old_passw0rd', 'very_old_passw0rd']);
  
  =head2 sessions
  
    my $sessions = $app->sessions;
    $app         = $app->sessions(Mojolicious::Sessions->new);
  
  Signed cookie based session manager, defaults to a L<Mojolicious::Sessions>
  object. You can usually leave this alone, see
  L<Mojolicious::Controller/"session"> for more information about working with
  session data.
  
    # Change name of cookie used for all sessions
    $app->sessions->cookie_name('mysession');
  
  =head2 static
  
    my $static = $app->static;
    $app       = $app->static(Mojolicious::Static->new);
  
  For serving static files from your C<public> directories, defaults to a
  L<Mojolicious::Static> object.
  
    # Add another "public" directory
    push @{$app->static->paths}, '/home/sri/public';
  
    # Add another "public" directory with higher precedence
    unshift @{$app->static->paths}, '/home/sri/themes/blue/public';
  
    # Add another class with static files in DATA section
    push @{$app->static->classes}, 'Mojolicious::Plugin::Fun';
  
    # Remove built-in favicon
    delete $app->static->extra->{'favicon.ico'};
  
  =head2 types
  
    my $types = $app->types;
    $app      = $app->types(Mojolicious::Types->new);
  
  Responsible for connecting file extensions with MIME types, defaults to a
  L<Mojolicious::Types> object.
  
    # Add custom MIME type
    $app->types->type(twt => 'text/tweet');
  
  =head2 ua
  
    my $ua = $app->ua;
    $app   = $app->ua(Mojo::UserAgent->new);
  
  A full featured HTTP user agent for use in your applications, defaults to a
  L<Mojo::UserAgent> object.
  
    # Perform blocking request
    say $app->ua->get('example.com')->result->body;
  
  =head2 validator
  
    my $validator = $app->validator;
    $app          = $app->validator(Mojolicious::Validator->new);
  
  Validate values, defaults to a L<Mojolicious::Validator> object.
  
    # Add validation check
    $app->validator->add_check(foo => sub {
      my ($v, $name, $value) = @_;
      return $value ne 'foo';
    });
  
    # Add validation filter
    $app->validator->add_filter(quotemeta => sub {
      my ($v, $name, $value) = @_;
      return quotemeta $value;
    });
  
  =head1 METHODS
  
  L<Mojolicious> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 build_controller
  
    my $c = $app->build_controller;
    my $c = $app->build_controller(Mojo::Transaction::HTTP->new);
    my $c = $app->build_controller(Mojolicious::Controller->new);
  
  Build default controller object with L</"controller_class">.
  
    # Render template from application
    my $foo = $app->build_controller->render_to_string(template => 'foo');
  
  =head2 build_tx
  
    my $tx = $app->build_tx;
  
  Build L<Mojo::Transaction::HTTP> object and emit L</"after_build_tx"> hook.
  
  =head2 config
  
    my $hash = $app->config;
    my $foo  = $app->config('foo');
    $app     = $app->config({foo => 'bar', baz => 23});
    $app     = $app->config(foo => 'bar', baz => 23);
  
  Application configuration.
  
    # Remove value
    my $foo = delete $app->config->{foo};
  
    # Assign multiple values at once
    $app->config(foo => 'test', bar => 23);
  
  =head2 defaults
  
    my $hash = $app->defaults;
    my $foo  = $app->defaults('foo');
    $app     = $app->defaults({foo => 'bar', baz => 23});
    $app     = $app->defaults(foo => 'bar', baz => 23);
  
  Default values for L<Mojolicious::Controller/"stash">, assigned for every new
  request.
  
    # Remove value
    my $foo = delete $app->defaults->{foo};
  
    # Assign multiple values at once
    $app->defaults(foo => 'test', bar => 23);
  
  =head2 dispatch
  
    $app->dispatch(Mojolicious::Controller->new);
  
  The heart of every L<Mojolicious> application, calls the L</"static"> and
  L</"routes"> dispatchers for every request and passes them a
  L<Mojolicious::Controller> object.
  
  =head2 handler
  
    $app->handler(Mojo::Transaction::HTTP->new);
    $app->handler(Mojolicious::Controller->new);
  
  Sets up the default controller and emits the L</"around_dispatch"> hook for
  every request.
  
  =head2 helper
  
    $app->helper(foo => sub {...});
  
  Add or replace a helper that will be available as a method of the controller
  object and the application object, as well as a function in C<ep> templates. For
  a full list of helpers that are available by default see
  L<Mojolicious::Plugin::DefaultHelpers> and L<Mojolicious::Plugin::TagHelpers>.
  
    # Helper
    $app->helper(cache => sub { state $cache = {} });
  
    # Application
    $app->cache->{foo} = 'bar';
    my $result = $app->cache->{foo};
  
    # Controller
    $c->cache->{foo} = 'bar';
    my $result = $c->cache->{foo};
  
    # Template
    % cache->{foo} = 'bar';
    %= cache->{foo}
  
  =head2 hook
  
    $app->hook(after_dispatch => sub {...});
  
  Extend L<Mojolicious> with hooks, which allow code to be shared with all
  requests indiscriminately, for a full list of available hooks see L</"HOOKS">.
  
    # Dispatchers will not run if there's already a response code defined
    $app->hook(before_dispatch => sub {
      my $c = shift;
      $c->render(text => 'Skipped static file server and router!')
        if $c->req->url->path->to_route =~ /do_not_dispatch/;
    });
  
  =head2 new
  
    my $app = Mojolicious->new;
    my $app = Mojolicious->new(moniker => 'foo_bar');
    my $app = Mojolicious->new({moniker => 'foo_bar'});
  
  Construct a new L<Mojolicious> application and call L</"startup">. Will
  automatically detect your home directory. Also sets up the renderer, static file
  server, a default set of plugins and an L</"around_dispatch"> hook with the
  default exception handling.
  
  =head2 plugin
  
    $app->plugin('some_thing');
    $app->plugin('some_thing', foo => 23);
    $app->plugin('some_thing', {foo => 23});
    $app->plugin('SomeThing');
    $app->plugin('SomeThing', foo => 23);
    $app->plugin('SomeThing', {foo => 23});
    $app->plugin('MyApp::Plugin::SomeThing');
    $app->plugin('MyApp::Plugin::SomeThing', foo => 23);
    $app->plugin('MyApp::Plugin::SomeThing', {foo => 23});
  
  Load a plugin, for a full list of example plugins included in the
  L<Mojolicious> distribution see L<Mojolicious::Plugins/"PLUGINS">.
  
  =head2 server
  
    $app->server(Mojo::Server->new);
  
  Emits the L</"before_server_start"> hook. Note that this method is EXPERIMENTAL
  and might change without warning!
  
  =head2 start
  
    $app->start;
    $app->start(@ARGV);
  
  Start the command line interface for your application. For a full list of
  commands that are available by default see L<Mojolicious::Commands/"COMMANDS">.
  Note that the options C<-h>/C<--help>, C<--home> and C<-m>/C<--mode>, which are
  shared by all commands, will be parsed from C<@ARGV> during compile time.
  
    # Always start daemon
    $app->start('daemon', '-l', 'http://*:8080');
  
  =head2 startup
  
    $app->startup;
  
  This is your main hook into the application, it will be called at application
  startup. Meant to be overloaded in a subclass.
  
    sub startup {
      my $self = shift;
      ...
    }
  
  =head1 AUTOLOAD
  
  In addition to the L</"ATTRIBUTES"> and L</"METHODS"> above you can also call
  helpers on L<Mojolicious> objects. This includes all helpers from
  L<Mojolicious::Plugin::DefaultHelpers> and L<Mojolicious::Plugin::TagHelpers>.
  Note that application helpers are always called with a new default controller
  object, so they can't depend on or change controller state, which includes
  request, response and stash.
  
    # Call helper
    say $app->dumper({foo => 'bar'});
  
    # Longer version
    say $app->build_controller->helpers->dumper({foo => 'bar'});
  
  =head1 BUNDLED FILES
  
  The L<Mojolicious> distribution includes a few files with different licenses
  that have been bundled for internal use.
  
  =head2 Mojolicious Artwork
  
    Copyright (C) 2010-2018, Sebastian Riedel.
  
  Licensed under the CC-SA License, Version 4.0
  L<http://creativecommons.org/licenses/by-sa/4.0>.
  
  =head2 jQuery
  
    Copyright (C) jQuery Foundation.
  
  Licensed under the MIT License, L<http://creativecommons.org/licenses/MIT>.
  
  =head2 prettify.js
  
    Copyright (C) 2006, 2013 Google Inc..
  
  Licensed under the Apache License, Version 2.0
  L<http://www.apache.org/licenses/LICENSE-2.0>.
  
  =head1 CODE NAMES
  
  Every major release of L<Mojolicious> has a code name, these are the ones that
  have been used in the past.
  
  7.0, C<Doughnut> (U+1F369)
  
  6.0, C<Clinking Beer Mugs> (U+1F37B)
  
  5.0, C<Tiger Face> (U+1F42F)
  
  4.0, C<Top Hat> (U+1F3A9)
  
  3.0, C<Rainbow> (U+1F308)
  
  2.0, C<Leaf Fluttering In Wind> (U+1F343)
  
  1.0, C<Snowflake> (U+2744)
  
  =head1 SPONSORS
  
  Some of the work on this distribution has been sponsored by
  L<The Perl Foundation|http://www.perlfoundation.org>, thank you!
  
  =head1 PROJECT FOUNDER
  
  Sebastian Riedel, C<kraih@mojolicious.org>
  
  =head1 CORE DEVELOPERS
  
  Current members of the core team in alphabetical order:
  
  =over 2
  
  Jan Henning Thorsen, C<batman@mojolicious.org>
  
  Joel Berger, C<jberger@mojolicious.org>
  
  Marcus Ramberg, C<marcus@mojolicious.org>
  
  =back
  
  The following members of the core team are currently on hiatus:
  
  =over 2
  
  Abhijit Menon-Sen, C<ams@cpan.org>
  
  Glen Hinkle, C<tempire@cpan.org>
  
  =back
  
  =head1 CREDITS
  
  In alphabetical order:
  
  =over 2
  
  Adam Kennedy
  
  Adriano Ferreira
  
  Al Newkirk
  
  Alex Efros
  
  Alex Salimon
  
  Alexey Likhatskiy
  
  Anatoly Sharifulin
  
  Andre Parker
  
  Andre Vieth
  
  Andreas Jaekel
  
  Andreas Koenig
  
  Andrew Fresh
  
  Andrew Nugged
  
  Andrey Khozov
  
  Andrey Kuzmin
  
  Andy Grundman
  
  Aristotle Pagaltzis
  
  Ashley Dev
  
  Ask Bjoern Hansen
  
  Audrey Tang
  
  Ben Tyler
  
  Ben van Staveren
  
  Benjamin Erhart
  
  Bernhard Graf
  
  Breno G. de Oliveira
  
  Brian Duggan
  
  Brian Medley
  
  Burak Gursoy
  
  Ch Lamprecht
  
  Charlie Brady
  
  Chas. J. Owens IV
  
  Chase Whitener
  
  Christian Hansen
  
  chromatic
  
  Curt Tilmes
  
  Dan Book
  
  Daniel Kimsey
  
  Daniel Mantovani
  
  Danijel Tasov
  
  Danny Thomas
  
  David Davis
  
  David Webb
  
  Diego Kuperman
  
  Dmitriy Shalashov
  
  Dmitry Konstantinov
  
  Dominik Jarmulowicz
  
  Dominique Dumont
  
  Dotan Dimet
  
  Douglas Christopher Wilson
  
  Ettore Di Giacinto
  
  Eugen Konkov
  
  Eugene Toropov
  
  Flavio Poletti
  
  Gisle Aas
  
  Graham Barr
  
  Graham Knop
  
  Henry Tang
  
  Hideki Yamamura
  
  Hiroki Toyokawa
  
  Ian Goodacre
  
  Ilya Chesnokov
  
  James Duncan
  
  Jan Jona Javorsek
  
  Jan Schmidt
  
  Jaroslav Muhin
  
  Jesse Vincent
  
  Johannes Plunien
  
  John Kingsley
  
  Jonathan Yu
  
  Josh Leder
  
  Kazuhiro Shibuya
  
  Kevin Old
  
  Kitamura Akatsuki
  
  Klaus S. Madsen
  
  Knut Arne Bjorndal
  
  Lars Balker Rasmussen
  
  Lee Johnson
  
  Leon Brocard
  
  Magnus Holm
  
  Maik Fischer
  
  Mark Fowler
  
  Mark Grimes
  
  Mark Stosberg
  
  Marty Tennison
  
  Matt S Trout
  
  Matthew Lineen
  
  Maksym Komar
  
  Maxim Vuets
  
  Michael Gregorowicz
  
  Michael Harris
  
  Mike Magowan
  
  Mirko Westermeier
  
  Mons Anderson
  
  Moritz Lenz
  
  Neil Watkiss
  
  Nic Sandfield
  
  Nils Diewald
  
  Oleg Zhelo
  
  Olivier Mengue
  
  Pascal Gaudette
  
  Paul Evans
  
  Paul Robins
  
  Paul Tomlin
  
  Pavel Shaydo
  
  Pedro Melo
  
  Peter Edwards
  
  Pierre-Yves Ritschard
  
  Piotr Roszatycki
  
  Quentin Carbonneaux
  
  Rafal Pocztarski
  
  Randal Schwartz
  
  Richard Elberger
  
  Rick Delaney
  
  Robert Hicks
  
  Robin Lee
  
  Roland Lammel
  
  Roy Storey
  
  Ryan Jendoubi
  
  Salvador Fandino
  
  Santiago Zarate
  
  Sascha Kiefer
  
  Scott Wiersdorf
  
  Sergey Zasenko
  
  Simon Bertrang
  
  Simone Tampieri
  
  Shu Cho
  
  Skye Shaw
  
  Stanis Trendelenburg
  
  Steffen Ullrich
  
  Stephan Kulow
  
  Stephane Este-Gracias
  
  Stevan Little
  
  Steve Atkins
  
  Tatsuhiko Miyagawa
  
  Terrence Brannon
  
  Tianon Gravi
  
  Tomas Znamenacek
  
  Tudor Constantin
  
  Ulrich Habel
  
  Ulrich Kautz
  
  Uwe Voelker
  
  Viacheslav Tykhanovskyi
  
  Victor Engmark
  
  Viliam Pucik
  
  Wes Cravens
  
  William Lindley
  
  Yaroslav Korshak
  
  Yuki Kimoto
  
  Zak B. Elep
  
  Zoffix Znet
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008-2018, Sebastian Riedel and others.
  
  This program is free software, you can redistribute it and/or modify it under
  the terms of the Artistic License version 2.0.
  
  =head1 SEE ALSO
  
  L<https://github.com/kraih/mojo>, L<Mojolicious::Guides>,
  L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS

$fatpacked{"Mojolicious/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND';
  package Mojolicious::Command;
  use Mojo::Base -base;
  
  use Carp 'croak';
  use Mojo::File 'path';
  use Mojo::Loader 'data_section';
  use Mojo::Server;
  use Mojo::Template;
  
  has app => sub { Mojo::Server->new->build_app('Mojo::HelloWorld') };
  has description => 'No description';
  has 'quiet';
  has template => sub { {} };
  has usage => "Usage: APPLICATION\n";
  
  sub chmod_file {
    my ($self, $path, $mod) = @_;
    chmod $mod, $path or croak qq{Can't chmod file "$path": $!};
    return $self->_loud("  [chmod] $path " . sprintf('%lo', $mod));
  }
  
  sub chmod_rel_file { $_[0]->chmod_file($_[0]->rel_file($_[1]), $_[2]) }
  
  sub create_dir {
    my ($self, $path) = @_;
    return $self->_loud("  [exist] $path") if -d $path;
    path($path)->make_path;
    return $self->_loud("  [mkdir] $path");
  }
  
  sub create_rel_dir { $_[0]->create_dir($_[0]->rel_file($_[1])) }
  
  sub extract_usage { Mojo::Util::extract_usage((caller)[1]) }
  
  sub help { print shift->usage }
  
  sub rel_file { path->child(split('/', pop)) }
  
  sub render_data {
    my ($self, $name) = (shift, shift);
    my $template = Mojo::Template->new($self->template)
      ->name("template $name from DATA section");
    my $output = $template->render(data_section(ref $self, $name), @_);
    return ref $output ? die $output : $output;
  }
  
  sub render_to_file {
    my ($self, $data, $path) = (shift, shift, shift);
    return $self->write_file($path, $self->render_data($data, @_));
  }
  
  sub render_to_rel_file {
    my $self = shift;
    $self->render_to_file(shift, $self->rel_file(shift), @_);
  }
  
  sub run { croak 'Method "run" not implemented by subclass' }
  
  sub write_file {
    my ($self, $path, $data) = @_;
    return $self->_loud("  [exist] $path") if -f $path;
    $self->create_dir(path($path)->dirname);
    path($path)->spurt($data);
    return $self->_loud("  [write] $path");
  }
  
  sub write_rel_file { $_[0]->write_file($_[0]->rel_file($_[1]), $_[2]) }
  
  sub _loud {
    my ($self, $msg) = @_;
    say $msg unless $self->quiet;
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command - Command base class
  
  =head1 SYNOPSIS
  
    # Lowercase command name
    package Mojolicious::Command::mycommand;
    use Mojo::Base 'Mojolicious::Command';
  
    # Short description
    has description => 'My first Mojo command';
  
    # Usage message from SYNOPSIS
    has usage => sub { shift->extract_usage };
  
    sub run {
      my ($self, @args) = @_;
  
      # Magic here! :)
    }
  
    1;
  
    =head1 SYNOPSIS
  
      Usage: APPLICATION mycommand [OPTIONS]
  
      Options:
        -s, --something   Does something
  
    =cut
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command> is an abstract base class for L<Mojolicious> commands.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command> implements the following attributes.
  
  =head2 app
  
    my $app  = $command->app;
    $command = $command->app(Mojolicious->new);
  
  Application for command, defaults to a L<Mojo::HelloWorld> object.
  
    # Introspect
    say "Template path: $_" for @{$command->app->renderer->paths};
  
  =head2 description
  
    my $description = $command->description;
    $command        = $command->description('Foo');
  
  Short description of command, used for the command list.
  
  =head2 quiet
  
    my $bool = $command->quiet;
    $command = $command->quiet($bool);
  
  Limited command output.
  
  =head2 template
  
    my $template = $command->template;
    $command     = $command->template({vars => 1});
  
  Attribute values passed to L<Mojo::Template> objects used to render templates
  with L</"render_data">.
  
  =head2 usage
  
    my $usage = $command->usage;
    $command  = $command->usage('Foo');
  
  Usage information for command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 chmod_file
  
    $command = $command->chmod_file('/home/sri/foo.txt', 0644);
  
  Change mode of a file.
  
  =head2 chmod_rel_file
  
    $command = $command->chmod_rel_file('foo/foo.txt', 0644);
  
  Portably change mode of a file relative to the current working directory.
  
  =head2 create_dir
  
    $command = $command->create_dir('/home/sri/foo/bar');
  
  Create a directory if it does not exist already.
  
  =head2 create_rel_dir
  
    $command = $command->create_rel_dir('foo/bar/baz');
  
  Portably create a directory relative to the current working directory if it does
  not exist already.
  
  =head2 extract_usage
  
    my $usage = $command->extract_usage;
  
  Extract usage message from the SYNOPSIS section of the file this method was
  called from with L<Mojo::Util/"extract_usage">.
  
  =head2 help
  
    $command->help;
  
  Print usage information for command.
  
  =head2 rel_file
  
    my $path = $command->rel_file('foo/bar.txt');
  
  Return a L<Mojo::File> object relative to the current working directory.
  
  =head2 render_data
  
    my $data = $command->render_data('foo_bar');
    my $data = $command->render_data('foo_bar', @args);
    my $data = $command->render_data('foo_bar', {foo => 'bar'});
  
  Render a template from the C<DATA> section of the command class with
  L<Mojo::Loader> and L<Mojo::Template>. The template can be configured with
  L</"template">.
  
  =head2 render_to_file
  
    $command = $command->render_to_file('foo_bar', '/home/sri/foo.txt');
    $command = $command->render_to_file('foo_bar', '/home/sri/foo.txt', @args);
    $command = $command->render_to_file(
      'foo_bar', '/home/sri/foo.txt', {foo => 'bar'});
  
  Render a template with L</"render_data"> to a file if it does not exist already,
  and create the directory if necessary.
  
  =head2 render_to_rel_file
  
    $command = $command->render_to_rel_file('foo_bar', 'foo/bar.txt');
    $command = $command->render_to_rel_file('foo_bar', 'foo/bar.txt', @args);
    $command = $command->render_to_rel_file(
      'foo_bar', 'foo/bar.txt', {foo => 'bar'});
  
  Portably render a template with L</"render_data"> to a file relative to the
  current working directory if it does not exist already, and create the directory
  if necessary.
  
  =head2 run
  
    $command->run;
    $command->run(@ARGV);
  
  Run command. Meant to be overloaded in a subclass.
  
  =head2 write_file
  
    $command = $command->write_file('/home/sri/foo.txt', 'Hello World!');
  
  Write text to a file if it does not exist already, and create the directory if
  necessary.
  
  =head2 write_rel_file
  
    $command = $command->write_rel_file('foo/bar.txt', 'Hello World!');
  
  Portably write text to a file relative to the current working directory if it
  does not exist already, and create the directory if necessary.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND

$fatpacked{"Mojolicious/Command/cgi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_CGI';
  package Mojolicious::Command::cgi;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Server::CGI;
  use Mojo::Util 'getopt';
  
  has description => 'Start application with CGI';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
    getopt \@args, nph => \(my $nph = 0);
    Mojo::Server::CGI->new(app => $self->app, nph => $nph)->run;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::cgi - CGI command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION cgi [OPTIONS]
  
      ./myapp.pl cgi
  
    Options:
      -h, --help          Show this summary of available options
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
          --nph           Enable non-parsed-header mode
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::cgi> starts applications with the L<Mojo::Server::CGI>
  backend.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::cgi> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $cgi->description;
    $cgi            = $cgi->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $cgi->usage;
    $cgi      = $cgi->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::cgi> inherits all methods from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 run
  
    $cgi->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_CGI

$fatpacked{"Mojolicious/Command/cpanify.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_CPANIFY';
  package Mojolicious::Command::cpanify;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::File 'path';
  use Mojo::Util 'getopt';
  
  has description => 'Upload distribution to CPAN';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    getopt \@args,
      'p|password=s' => \(my $password = ''),
      'u|user=s'     => \(my $user     = '');
    die $self->usage unless my $file = shift @args;
  
    my $tx = $self->app->ua->tap(sub { $_->proxy->detect })->post(
      "https://$user:$password\@pause.perl.org/pause/authenquery" => form => {
        HIDDENNAME                        => $user,
        CAN_MULTIPART                     => 1,
        pause99_add_uri_upload            => path($file)->basename,
        SUBMIT_pause99_add_uri_httpupload => ' Upload this file from my disk ',
        pause99_add_uri_uri               => '',
        pause99_add_uri_httpupload        => {file => $file},
      }
    );
  
    unless ($tx->success) {
      my $code = $tx->res->code // 0;
      my $msg  = $tx->error->{message};
      if    ($code == 401) { $msg = 'Wrong username or password.' }
      elsif ($code == 409) { $msg = 'File already exists on CPAN.' }
      die qq{Problem uploading file "$file": $msg\n};
    }
  
    say 'Upload successful!';
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::cpanify - CPAN-ify command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION cpanify [OPTIONS] [FILE]
  
      mojo cpanify -u sri -p secr3t Mojolicious-Plugin-MyPlugin-0.01.tar.gz
  
    Options:
      -h, --help                  Show this summary of available options
      -p, --password <password>   PAUSE password
      -u, --user <name>           PAUSE username
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::cpanify> uploads files to CPAN.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::cpanify> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $cpanify->description;
    $cpanify        = $cpanify->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $cpanify->usage;
    $cpanify  = $cpanify->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::cpanify> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $cpanify->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_CPANIFY

$fatpacked{"Mojolicious/Command/daemon.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_DAEMON';
  package Mojolicious::Command::daemon;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Server::Daemon;
  use Mojo::Util 'getopt';
  
  has description => 'Start application with HTTP and WebSocket server';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    my $daemon = Mojo::Server::Daemon->new(app => $self->app);
    getopt \@args,
      'b|backlog=i'            => sub { $daemon->backlog($_[1]) },
      'c|clients=i'            => sub { $daemon->max_clients($_[1]) },
      'i|inactivity-timeout=i' => sub { $daemon->inactivity_timeout($_[1]) },
      'l|listen=s'             => \my @listen,
      'p|proxy'                => sub { $daemon->reverse_proxy(1) },
      'r|requests=i'           => sub { $daemon->max_requests($_[1]) };
  
    $daemon->listen(\@listen) if @listen;
    $daemon->run;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::daemon - Daemon command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION daemon [OPTIONS]
  
      ./myapp.pl daemon
      ./myapp.pl daemon -m production -l http://*:8080
      ./myapp.pl daemon -l http://127.0.0.1:8080 -l https://[::]:8081
      ./myapp.pl daemon -l 'https://*:443?cert=./server.crt&key=./server.key'
      ./myapp.pl daemon -l http+unix://%2Ftmp%2Fmyapp.sock
  
    Options:
      -b, --backlog <size>                 Listen backlog size, defaults to
                                           SOMAXCONN
      -c, --clients <number>               Maximum number of concurrent
                                           connections, defaults to 1000
      -h, --help                           Show this summary of available options
          --home <path>                    Path to home directory of your
                                           application, defaults to the value of
                                           MOJO_HOME or auto-detection
      -i, --inactivity-timeout <seconds>   Inactivity timeout, defaults to the
                                           value of MOJO_INACTIVITY_TIMEOUT or 15
      -l, --listen <location>              One or more locations you want to
                                           listen on, defaults to the value of
                                           MOJO_LISTEN or "http://*:3000"
      -m, --mode <name>                    Operating mode for your application,
                                           defaults to the value of
                                           MOJO_MODE/PLACK_ENV or "development"
      -p, --proxy                          Activate reverse proxy support,
                                           defaults to the value of
                                           MOJO_REVERSE_PROXY
      -r, --requests <number>              Maximum number of requests per
                                           keep-alive connection, defaults to 100
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::daemon> starts applications with the
  L<Mojo::Server::Daemon> backend.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::daemon> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $daemon->description;
    $daemon         = $daemon->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $daemon->usage;
    $daemon   = $daemon->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::daemon> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $daemon->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_DAEMON

$fatpacked{"Mojolicious/Command/eval.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_EVAL';
  package Mojolicious::Command::eval;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Util 'getopt';
  
  has description => 'Run code against application';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    getopt \@args, 'v|verbose' => \my $v1, 'V' => \my $v2;
    my $code = shift @args || '';
  
    # Run code against application
    my $app = $self->app;
    no warnings;
    my $result = eval "package main; sub app; local *app = sub { \$app }; $code";
    return $@ ? die $@ : $result unless defined $result && ($v1 || $v2);
    $v2 ? print($app->dumper($result)) : say $result;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::eval - Eval command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION eval [OPTIONS] CODE
  
      ./myapp.pl eval 'say app->ua->get("/")->result->body'
      ./myapp.pl eval 'say for sort keys %{app->renderer->helpers}'
      ./myapp.pl eval -v 'app->home'
      ./myapp.pl eval -V 'app->renderer->paths'
  
    Options:
      -h, --help          Show this summary of available options
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
      -v, --verbose       Print return value to STDOUT
      -V                  Print returned data structure to STDOUT
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::eval> runs code against applications.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::eval> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $eval->description;
    $eval           = $eval->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $eval->usage;
    $eval     = $eval->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::eval> inherits all methods from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 run
  
    $eval->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_EVAL

$fatpacked{"Mojolicious/Command/generate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE';
  package Mojolicious::Command::generate;
  use Mojo::Base 'Mojolicious::Commands';
  
  has description => 'Generate files and directories from templates';
  has hint        => <<EOF;
  
  See 'APPLICATION generate help GENERATOR' for more information on a specific
  generator.
  EOF
  has message    => sub { shift->extract_usage . "\nGenerators:\n" };
  has namespaces => sub { ['Mojolicious::Command::generate'] };
  
  sub help { shift->run(@_) }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::generate - Generator command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION generate GENERATOR [OPTIONS]
  
      mojo generate app
      mojo generate lite_app
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::generate> lists available generators.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::generate> inherits all attributes from
  L<Mojolicious::Commands> and implements the following new ones.
  
  =head2 description
  
    my $description = $generator->description;
    $generator      = $generator->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 hint
  
    my $hint   = $generator->hint;
    $generator = $generator->hint('Foo');
  
  Short hint shown after listing available generator commands.
  
  =head2 message
  
    my $msg    = $generator->message;
    $generator = $generator->message('Bar');
  
  Short usage message shown before listing available generator commands.
  
  =head2 namespaces
  
    my $namespaces = $generator->namespaces;
    $generator     = $generator->namespaces(['MyApp::Command::generate']);
  
  Namespaces to search for available generator commands, defaults to
  L<Mojolicious::Command::generate>.
  
  =head1 METHODS
  
  L<Mojolicious::Command::generate> inherits all methods from
  L<Mojolicious::Commands> and implements the following new ones.
  
  =head2 help
  
    $generator->help('app');
  
  Print usage information for generator command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_GENERATE

$fatpacked{"Mojolicious/Command/generate/app.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE_APP';
  package Mojolicious::Command::generate::app;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Util qw(class_to_file class_to_path decamelize);
  
  has description => 'Generate Mojolicious application directory structure';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, $class) = (shift, shift || 'MyApp');
  
    # Prevent bad applications
    die <<EOF unless $class =~ /^[A-Z](?:\w|::)+$/;
  Your application name has to be a well formed (CamelCase) Perl module name
  like "MyApp".
  EOF
  
    # Script
    my $name = class_to_file $class;
    $self->template({vars => 1});
    $self->render_to_rel_file('mojo', "$name/script/$name", {class => $class});
    $self->chmod_rel_file("$name/script/$name", 0744);
  
    # Application class
    my $app = class_to_path $class;
    $self->render_to_rel_file('appclass', "$name/lib/$app", {class => $class});
  
    # Config file (using the default moniker)
    $self->render_to_rel_file('config', "$name/@{[decamelize $class]}.conf");
  
    # Controller
    my $controller = "${class}::Controller::Example";
    my $path       = class_to_path $controller;
    $self->render_to_rel_file('controller', "$name/lib/$path",
      {class => $controller});
  
    # Test
    $self->render_to_rel_file('test', "$name/t/basic.t", {class => $class});
  
    # Static file
    $self->render_to_rel_file('static', "$name/public/index.html");
  
    # Templates
    $self->render_to_rel_file('layout',
      "$name/templates/layouts/default.html.ep");
    $self->render_to_rel_file('welcome',
      "$name/templates/example/welcome.html.ep");
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::generate::app - App generator command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION generate app [OPTIONS] [NAME]
  
      mojo generate app
      mojo generate app TestApp
  
    Options:
      -h, --help   Show this summary of available options
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::generate::app> generates application directory
  structures for fully functional L<Mojolicious> applications.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::generate::app> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $app->description;
    $app            = $app->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $app->usage;
    $app      = $app->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::generate::app> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $app->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
  
  __DATA__
  
  @@ mojo
  #!/usr/bin/env perl
  
  use strict;
  use warnings;
  
  use FindBin;
  BEGIN { unshift @INC, "$FindBin::Bin/../lib" }
  use Mojolicious::Commands;
  
  # Start command line interface for application
  Mojolicious::Commands->start_app('<%= $class %>');
  
  @@ appclass
  package <%= $class %>;
  use Mojo::Base 'Mojolicious';
  
  # This method will run once at server start
  sub startup {
    my $self = shift;
  
    # Load configuration from hash returned by "my_app.conf"
    my $config = $self->plugin('Config');
  
    # Documentation browser under "/perldoc"
    $self->plugin('PODRenderer') if $config->{perldoc};
  
    # Router
    my $r = $self->routes;
  
    # Normal route to controller
    $r->get('/')->to('example#welcome');
  }
  
  1;
  
  @@ controller
  package <%= $class %>;
  use Mojo::Base 'Mojolicious::Controller';
  
  # This action will render a template
  sub welcome {
    my $self = shift;
  
    # Render template "example/welcome.html.ep" with message
    $self->render(msg => 'Welcome to the Mojolicious real-time web framework!');
  }
  
  1;
  
  @@ static
  <!DOCTYPE html>
  <html>
    <head>
      <title>Welcome to the Mojolicious real-time web framework!</title>
    </head>
    <body>
      <h2>Welcome to the Mojolicious real-time web framework!</h2>
      This is the static document "public/index.html",
      <a href="/">click here</a> to get back to the start.
    </body>
  </html>
  
  @@ test
  use Mojo::Base -strict;
  
  use Test::More;
  use Test::Mojo;
  
  my $t = Test::Mojo->new('<%= $class %>');
  $t->get_ok('/')->status_is(200)->content_like(qr/Mojolicious/i);
  
  done_testing();
  
  @@ layout
  <!DOCTYPE html>
  <html>
    <head><title><%%= title %></title></head>
    <body><%%= content %></body>
  </html>
  
  @@ welcome
  %% layout 'default';
  %% title 'Welcome';
  <h2><%%= $msg %></h2>
  <p>
    This page was generated from the template "templates/example/welcome.html.ep"
    and the layout "templates/layouts/default.html.ep",
    <%%= link_to 'click here' => url_for %> to reload the page or
    <%%= link_to 'here' => '/index.html' %> to move forward to a static page.
    %% if (config 'perldoc') {
      To learn more, you can also browse through the documentation
      <%%= link_to 'here' => '/perldoc' %>.
    %% }
  </p>
  
  @@ config
  % use Mojo::Util qw(sha1_sum steady_time);
  {
    perldoc => 1,
    secrets => ['<%= sha1_sum $$ . steady_time . rand  %>']
  }
MOJOLICIOUS_COMMAND_GENERATE_APP

$fatpacked{"Mojolicious/Command/generate/lite_app.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE_LITE_APP';
  package Mojolicious::Command::generate::lite_app;
  use Mojo::Base 'Mojolicious::Command';
  
  has description => 'Generate Mojolicious::Lite application';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, $name) = (shift, shift || 'myapp.pl');
    $self->render_to_rel_file('liteapp', $name);
    $self->chmod_rel_file($name, 0744);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::generate::lite_app - Lite app generator command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION generate lite_app [OPTIONS] [NAME]
  
      mojo generate lite_app
      mojo generate lite_app foo.pl
  
    Options:
      -h, --help   Show this summary of available options
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::generate::lite_app> generate fully functional
  L<Mojolicious::Lite> applications.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::generate::lite_app> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $app->description;
    $app            = $app->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $app->usage;
    $app      = $app->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::generate::lite_app> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $app->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
  
  __DATA__
  
  @@ liteapp
  #!/usr/bin/env perl
  use Mojolicious::Lite;
  
  # Documentation browser under "/perldoc"
  plugin 'PODRenderer';
  
  get '/' => sub {
    my $c = shift;
    $c->render(template => 'index');
  };
  
  app->start;
  <% %>__DATA__
  
  <% %>@@ index.html.ep
  %% layout 'default';
  %% title 'Welcome';
  <h1>Welcome to the Mojolicious real-time web framework!</h1>
  To learn more, you can browse through the documentation
  <%%= link_to 'here' => '/perldoc' %>.
  
  <% %>@@ layouts/default.html.ep
  <!DOCTYPE html>
  <html>
    <head><title><%%= title %></title></head>
    <body><%%= content %></body>
  </html>
MOJOLICIOUS_COMMAND_GENERATE_LITE_APP

$fatpacked{"Mojolicious/Command/generate/makefile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE_MAKEFILE';
  package Mojolicious::Command::generate::makefile;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojolicious;
  
  has description => 'Generate "Makefile.PL"';
  has usage => sub { shift->extract_usage };
  
  sub run { shift->render_to_rel_file('makefile', 'Makefile.PL') }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::generate::makefile - Makefile generator command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION generate makefile [OPTIONS]
  
      mojo generate makefile
  
    Options:
      -h, --help   Show this summary of available options
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::generate::makefile> generates C<Makefile.PL> files for
  applications.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::generate::makefile> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $makefile->description;
    $makefile       = $makefile->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $makefile->usage;
    $makefile = $makefile->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::generate::makefile> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $makefile->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
  
  __DATA__
  
  @@ makefile
  use strict;
  use warnings;
  
  use ExtUtils::MakeMaker;
  
  WriteMakefile(
    VERSION   => '0.01',
    PREREQ_PM => {'Mojolicious' => '<%= $Mojolicious::VERSION %>'},
    test      => {TESTS => 't/*.t'}
  );
MOJOLICIOUS_COMMAND_GENERATE_MAKEFILE

$fatpacked{"Mojolicious/Command/generate/plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE_PLUGIN';
  package Mojolicious::Command::generate::plugin;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Util qw(camelize class_to_path);
  use Mojolicious;
  
  has description => 'Generate Mojolicious plugin directory structure';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, $name) = (shift, shift || 'MyPlugin');
  
    # Class
    my $class = $name =~ /^[a-z]/ ? camelize $name : $name;
    $class = "Mojolicious::Plugin::$class";
    my $app = class_to_path $class;
    my $dir = join '-', split('::', $class);
    $self->template({vars => 1});
    $self->render_to_rel_file('class', "$dir/lib/$app",
      {class => $class, name => $name});
  
    # Test
    $self->render_to_rel_file('test', "$dir/t/basic.t", {name => $name});
  
    # Makefile
    $self->render_to_rel_file('makefile', "$dir/Makefile.PL",
      {class => $class, path => $app});
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::generate::plugin - Plugin generator command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION generate plugin [OPTIONS] [NAME]
  
      mojo generate plugin
      mojo generate plugin TestPlugin
  
    Options:
      -h, --help   Show this summary of available options
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::generate::plugin> generates directory structures for
  fully functional L<Mojolicious> plugins.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::generate::plugin> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $plugin->description;
    $plugin         = $plugin->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $plugin->usage;
    $plugin   = $plugin->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::generate::plugin> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $plugin->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
  
  __DATA__
  
  @@ class
  package <%= $class %>;
  use Mojo::Base 'Mojolicious::Plugin';
  
  our $VERSION = '0.01';
  
  sub register {
    my ($self, $app) = @_;
  }
  
  1;
  <% %>__END__
  
  <% %>=encoding utf8
  
  <% %>=head1 NAME
  
  <%= $class %> - Mojolicious Plugin
  
  <% %>=head1 SYNOPSIS
  
    # Mojolicious
    $self->plugin('<%= $name %>');
  
    # Mojolicious::Lite
    plugin '<%= $name %>';
  
  <% %>=head1 DESCRIPTION
  
  L<<%= $class %>> is a L<Mojolicious> plugin.
  
  <% %>=head1 METHODS
  
  L<<%= $class %>> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  <% %>=head2 register
  
    $plugin->register(Mojolicious->new);
  
  Register plugin in L<Mojolicious> application.
  
  <% %>=head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  <% %>=cut
  
  @@ test
  use Mojo::Base -strict;
  
  use Test::More;
  use Mojolicious::Lite;
  use Test::Mojo;
  
  plugin '<%= $name %>';
  
  get '/' => sub {
    my $c = shift;
    $c->render(text => 'Hello Mojo!');
  };
  
  my $t = Test::Mojo->new;
  $t->get_ok('/')->status_is(200)->content_is('Hello Mojo!');
  
  done_testing();
  
  @@ makefile
  use strict;
  use warnings;
  
  use ExtUtils::MakeMaker;
  
  WriteMakefile(
    NAME         => '<%= $class %>',
    VERSION_FROM => 'lib/<%= $path %>',
    AUTHOR       => 'A Good Programmer <nospam@cpan.org>',
    PREREQ_PM    => {'Mojolicious' => '<%= $Mojolicious::VERSION %>'},
    test         => {TESTS => 't/*.t'}
  );
MOJOLICIOUS_COMMAND_GENERATE_PLUGIN

$fatpacked{"Mojolicious/Command/get.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GET';
  package Mojolicious::Command::get;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::DOM;
  use Mojo::IOLoop;
  use Mojo::JSON qw(to_json j);
  use Mojo::JSON::Pointer;
  use Mojo::URL;
  use Mojo::UserAgent;
  use Mojo::Util qw(decode encode getopt);
  use Scalar::Util 'weaken';
  
  has description => 'Perform HTTP request';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    # Data from STDIN
    vec(my $r = '', fileno(STDIN), 1) = 1;
    my $in = !-t STDIN && select($r, undef, undef, 0) ? join '', <STDIN> : undef;
  
    my $ua = Mojo::UserAgent->new(ioloop => Mojo::IOLoop->singleton);
    my %form;
    getopt \@args,
      'C|charset=s' => \my $charset,
      'c|content=s' => \$in,
      'f|form=s'    => sub { _form(\%form) if $_[1] =~ /^(.+)=(\@?)(.+)$/ },
      'H|header=s'  => \my @headers,
      'i|inactivity-timeout=i' => sub { $ua->inactivity_timeout($_[1]) },
      'k|insecure'             => sub { $ua->insecure(1) },
      'M|method=s'             => \(my $method = 'GET'),
      'o|connect-timeout=i'    => sub { $ua->connect_timeout($_[1]) },
      'r|redirect'             => \my $redirect,
      'S|response-size=i'      => sub { $ua->max_response_size($_[1]) },
      'u|user=s'               => \my $user,
      'v|verbose'              => \my $verbose;
  
    @args = map { decode 'UTF-8', $_ } @args;
    die $self->usage unless my $url = shift @args;
    my $selector = shift @args;
  
    # Parse header pairs
    my %headers = map { /^\s*([^:]+)\s*:\s*(.*+)$/ ? ($1, $2) : () } @headers;
  
    # Detect proxy for absolute URLs
    $url !~ m!^/! ? $ua->proxy->detect : $ua->server->app($self->app);
    $url = Mojo::URL->new($url)->userinfo($user) if $user;
    $ua->max_redirects(10) if $redirect;
  
    my $buffer = '';
    $ua->on(
      start => sub {
        my ($ua, $tx) = @_;
  
        # Verbose
        weaken $tx;
        $tx->res->content->on(
          body => sub { warn _header($tx->req), _header($tx->res) })
          if $verbose;
  
        # Stream content (ignore redirects)
        $tx->res->content->unsubscribe('read')->on(
          read => sub {
            return if $redirect && $tx->res->is_redirect;
            defined $selector ? ($buffer .= pop) : print pop;
          }
        );
      }
    );
  
    # Switch to verbose for HEAD requests
    $verbose = 1 if $method eq 'HEAD';
    STDOUT->autoflush(1);
    my @content = %form ? (form => \%form) : defined $in ? ($in) : ();
    my $tx = $ua->start($ua->build_tx($method, $url, \%headers, @content));
    my $res = $tx->result;
  
    # JSON Pointer
    return unless defined $selector;
    return _json($buffer, $selector) if !length $selector || $selector =~ m!^/!;
  
    # Selector
    $charset //= $res->content->charset || $res->default_charset;
    _select($buffer, $selector, $charset, @args);
  }
  
  sub _form { push @{$_[0]{$1}}, $2 ? {file => $3} : $3 }
  
  sub _header { $_[0]->build_start_line, $_[0]->headers->to_string, "\n\n" }
  
  sub _json {
    return unless my $data = j(shift);
    return unless defined($data = Mojo::JSON::Pointer->new($data)->get(shift));
    _say(ref $data eq 'HASH' || ref $data eq 'ARRAY' ? to_json($data) : $data);
  }
  
  sub _say { length && say encode('UTF-8', $_) for @_ }
  
  sub _select {
    my ($buffer, $selector, $charset, @args) = @_;
  
    # Keep a strong reference to the root
    $buffer = decode($charset, $buffer) // $buffer if $charset;
    my $dom     = Mojo::DOM->new($buffer);
    my $results = $dom->find($selector);
  
    while (defined(my $command = shift @args)) {
  
      # Number
      ($results = $results->slice($command)) and next if $command =~ /^\d+$/;
  
      # Text
      return _say($results->map('text')->each) if $command eq 'text';
  
      # All text
      return _say($results->map('all_text')->each) if $command eq 'all';
  
      # Attribute
      return _say($results->map(attr => $args[0] // '')->each)
        if $command eq 'attr';
  
      # Unknown
      die qq{Unknown command "$command".\n};
    }
  
    _say($results->each);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::get - Get command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION get [OPTIONS] URL [SELECTOR|JSON-POINTER] [COMMANDS]
  
      ./myapp.pl get /
      ./myapp.pl get -H 'Accept: text/html' /hello.html 'head > title' text
      ./myapp.pl get //sri:secr3t@/secrets.json /1/content
      mojo get mojolicious.org
      mojo get -v -r -o 25 -i 50 google.com
      mojo get -v -H 'Host: mojolicious.org' -H 'Accept: */*' mojolicious.org
      mojo get -u 'sri:s3cret' https://mojolicious.org
      mojo get mojolicious.org > example.html
      mojo get -M PUT mojolicious.org < example.html
      mojo get -f 'q=Mojolicious' -f 'size=5' https://metacpan.org/search
      mojo get -M POST -f 'upload=@example.html' mojolicious.org
      mojo get mojolicious.org 'head > title' text
      mojo get mojolicious.org .footer all
      mojo get mojolicious.org a attr href
      mojo get mojolicious.org '*' attr id
      mojo get mojolicious.org 'h1, h2, h3' 3 text
      mojo get https://fastapi.metacpan.org/v1/author/SRI /name
      mojo get -H 'Host: example.com' http+unix://%2Ftmp%2Fmyapp.sock/index.html
  
    Options:
      -C, --charset <charset>              Charset of HTML/XML content, defaults
                                           to auto-detection
      -c, --content <content>              Content to send with request
      -f, --form <name=value>              One or more form values and file
                                           uploads
      -H, --header <name:value>            One or more additional HTTP headers
      -h, --help                           Show this summary of available options
          --home <path>                    Path to home directory of your
                                           application, defaults to the value of
                                           MOJO_HOME or auto-detection
      -i, --inactivity-timeout <seconds>   Inactivity timeout, defaults to the
                                           value of MOJO_INACTIVITY_TIMEOUT or 20
      -k, --insecure                       Do not require a valid TLS certificate
                                           to access HTTPS sites
      -M, --method <method>                HTTP method to use, defaults to "GET"
      -m, --mode <name>                    Operating mode for your application,
                                           defaults to the value of
                                           MOJO_MODE/PLACK_ENV or "development"
      -o, --connect-timeout <seconds>      Connect timeout, defaults to the value
                                           of MOJO_CONNECT_TIMEOUT or 10
      -r, --redirect                       Follow up to 10 redirects
      -S, --response-size <size>           Maximum response size in bytes,
                                           defaults to 2147483648 (2GiB)
      -u, --user <userinfo>                Alternate mechanism for specifying
                                           colon-separated username and password
      -v, --verbose                        Print request and response headers to
                                           STDERR
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::get> is a command line interface for
  L<Mojo::UserAgent>.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::get> performs requests to remote hosts or local
  applications.
  
  =head2 description
  
    my $description = $get->description;
    $get            = $get->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $get->usage;
    $get      = $get->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::get> inherits all methods from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 run
  
    $get->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_GET

$fatpacked{"Mojolicious/Command/inflate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_INFLATE';
  package Mojolicious::Command::inflate;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Loader qw(data_section file_is_binary);
  use Mojo::Util 'encode';
  
  has description => 'Inflate embedded files to real files';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my $self = shift;
  
    # Find all embedded files
    my %all;
    my $app = $self->app;
    for my $class (@{$app->renderer->classes}, @{$app->static->classes}) {
      for my $name (keys %{data_section $class}) {
        my $data = data_section $class, $name;
        $data = encode 'UTF-8', $data unless file_is_binary $class, $name;
        $all{$name} = $data;
      }
    }
  
    # Turn them into real files
    for my $name (grep {/\.\w+$/} keys %all) {
      my $prefix = $name =~ /\.\w+\.\w+$/ ? 'templates' : 'public';
      $self->write_file($self->rel_file("$prefix/$name"), $all{$name});
    }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::inflate - Inflate command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION inflate [OPTIONS]
  
      ./myapp.pl inflate
  
    Options:
      -h, --help          Show this summary of available options
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::inflate> turns templates and static files embedded in
  the C<DATA> sections of your application into real files.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::inflate> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $inflate->description;
    $inflate        = $inflate->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $inflate->usage;
    $inflate  = $inflate->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::inflate> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $inflate->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_INFLATE

$fatpacked{"Mojolicious/Command/prefork.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_PREFORK';
  package Mojolicious::Command::prefork;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Server::Prefork;
  use Mojo::Util 'getopt';
  
  has description =>
    'Start application with pre-forking HTTP and WebSocket server';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    my $prefork = Mojo::Server::Prefork->new(app => $self->app);
    getopt \@args,
      'a|accepts=i'            => sub { $prefork->accepts($_[1]) },
      'b|backlog=i'            => sub { $prefork->backlog($_[1]) },
      'c|clients=i'            => sub { $prefork->max_clients($_[1]) },
      'G|graceful-timeout=i'   => sub { $prefork->graceful_timeout($_[1]) },
      'I|heartbeat-interval=i' => sub { $prefork->heartbeat_interval($_[1]) },
      'H|heartbeat-timeout=i'  => sub { $prefork->heartbeat_timeout($_[1]) },
      'i|inactivity-timeout=i' => sub { $prefork->inactivity_timeout($_[1]) },
      'l|listen=s'             => \my @listen,
      'P|pid-file=s'           => sub { $prefork->pid_file($_[1]) },
      'p|proxy'                => sub { $prefork->reverse_proxy(1) },
      'r|requests=i'           => sub { $prefork->max_requests($_[1]) },
      's|spare=i'              => sub { $prefork->spare($_[1]) },
      'w|workers=i'            => sub { $prefork->workers($_[1]) };
  
    $prefork->listen(\@listen) if @listen;
    $prefork->run;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::prefork - Pre-fork command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION prefork [OPTIONS]
  
      ./myapp.pl prefork
      ./myapp.pl prefork -m production -l http://*:8080
      ./myapp.pl prefork -l http://127.0.0.1:8080 -l https://[::]:8081
      ./myapp.pl prefork -l 'https://*:443?cert=./server.crt&key=./server.key'
      ./myapp.pl prefork -l http+unix://%2Ftmp%2Fmyapp.sock -w 12
  
    Options:
      -a, --accepts <number>               Number of connections for workers to
                                           accept, defaults to 10000
      -b, --backlog <size>                 Listen backlog size, defaults to
                                           SOMAXCONN
      -c, --clients <number>               Maximum number of concurrent
                                           connections, defaults to 1000
      -G, --graceful-timeout <seconds>     Graceful timeout, defaults to 120.
      -I, --heartbeat-interval <seconds>   Heartbeat interval, defaults to 5
      -H, --heartbeat-timeout <seconds>    Heartbeat timeout, defaults to 30
      -h, --help                           Show this summary of available options
          --home <path>                    Path to home directory of your
                                           application, defaults to the value of
                                           MOJO_HOME or auto-detection
      -i, --inactivity-timeout <seconds>   Inactivity timeout, defaults to the
                                           value of MOJO_INACTIVITY_TIMEOUT or 15
      -l, --listen <location>              One or more locations you want to
                                           listen on, defaults to the value of
                                           MOJO_LISTEN or "http://*:3000"
      -m, --mode <name>                    Operating mode for your application,
                                           defaults to the value of
                                           MOJO_MODE/PLACK_ENV or "development"
      -P, --pid-file <path>                Path to process id file, defaults to
                                           "prefork.pid" in a temporary directory
      -p, --proxy                          Activate reverse proxy support,
                                           defaults to the value of
                                           MOJO_REVERSE_PROXY
      -r, --requests <number>              Maximum number of requests per
                                           keep-alive connection, defaults to 100
      -s, --spare <number>                 Temporarily spawn up to this number of
                                           additional workers, defaults to 2
      -w, --workers <number>               Number of workers, defaults to 4
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::prefork> starts applications with the
  L<Mojo::Server::Prefork> backend.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::prefork> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $prefork->description;
    $prefork        = $prefork->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $prefork->usage;
    $prefork  = $prefork->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::prefork> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $prefork->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_PREFORK

$fatpacked{"Mojolicious/Command/psgi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_PSGI';
  package Mojolicious::Command::psgi;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Server::PSGI;
  
  has description => 'Start application with PSGI';
  has usage => sub { shift->extract_usage };
  
  sub run { Mojo::Server::PSGI->new(app => shift->app)->to_psgi_app }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::psgi - PSGI command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION psgi [OPTIONS]
  
      ./myapp.pl psgi
  
    Options:
      -h, --help          Show this summary of available options
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::psgi> starts applications with the L<Mojo::Server::PSGI>
  backend.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::psgi> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $psgi->description;
    $psgi           = $psgi->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $psgi->usage;
    $psgi     = $psgi->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::psgi> inherits all methods from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 run
  
    my $app = $psgi->run;
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_PSGI

$fatpacked{"Mojolicious/Command/routes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_ROUTES';
  package Mojolicious::Command::routes;
  use Mojo::Base 'Mojolicious::Command';
  
  use re 'regexp_pattern';
  use Mojo::Util qw(encode getopt tablify);
  
  has description => 'Show available routes';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    getopt \@args, 'v|verbose' => \my $verbose;
  
    my $rows = [];
    _walk($_, 0, $rows, $verbose) for @{$self->app->routes->children};
    print encode('UTF-8', tablify($rows));
  }
  
  sub _walk {
    my ($route, $depth, $rows, $verbose) = @_;
  
    # Pattern
    my $prefix = '';
    if (my $i = $depth * 2) { $prefix .= ' ' x $i . '+' }
    push @$rows, my $row = [$prefix . ($route->pattern->unparsed || '/')];
  
    # Flags
    my @flags;
    push @flags, @{$route->over || []} ? 'C' : '.';
    push @flags, (my $partial = $route->partial) ? 'D' : '.';
    push @flags, $route->inline       ? 'U' : '.';
    push @flags, $route->is_websocket ? 'W' : '.';
    push @$row, join('', @flags) if $verbose;
  
    # Methods
    my $via = $route->via;
    push @$row, !$via ? '*' : uc join ',', @$via;
  
    # Name
    my $name = $route->name;
    push @$row, $route->has_custom_name ? qq{"$name"} : $name;
  
    # Regex (verbose)
    my $pattern = $route->pattern;
    $pattern->match('/', $route->is_endpoint && !$partial);
    push @$row, (regexp_pattern $pattern->regex)[0] if $verbose;
  
    $depth++;
    _walk($_, $depth, $rows, $verbose) for @{$route->children};
    $depth--;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::routes - Routes command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION routes [OPTIONS]
  
      ./myapp.pl routes
      ./myapp.pl routes -v
  
    Options:
      -h, --help          Show this summary of available options
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
      -v, --verbose       Print additional details about routes, flags indicate
                          C=Conditions, D=Detour, U=Under and W=WebSocket
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::routes> lists all your application routes.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::routes> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $routes->description;
    $routes         = $routes->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $routes->usage;
    $routes   = $routes->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::routes> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $routes->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_ROUTES

$fatpacked{"Mojolicious/Command/test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_TEST';
  package Mojolicious::Command::test;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Util 'getopt';
  
  has description => 'Run tests';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    getopt \@args, 'v|verbose' => \$ENV{HARNESS_VERBOSE};
  
    if (!@args && (my $tests = $self->app->home->child('t'))) {
      die "Can't find test directory.\n" unless -d $tests;
      @args = $tests->list_tree->grep(qr/\.t$/)->map('to_string')->each;
      say qq{Running tests from "$tests".};
    }
  
    $ENV{HARNESS_OPTIONS} //= 'c';
    require Test::Harness;
    local $Test::Harness::switches = '';
    Test::Harness::runtests(sort @args);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::test - Test command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION test [OPTIONS] [TESTS]
  
      ./myapp.pl test
      ./myapp.pl test t/foo.t
      ./myapp.pl test -v t/foo/*.t
  
    Options:
      -h, --help      Show this summary of available options
      -v, --verbose   Print verbose debug information to STDERR
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::test> runs application tests from the C<t> directory.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::test> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $test->description;
    $test           = $test->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $test->usage;
    $test     = $test->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::test> inherits all methods from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 run
  
    $test->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_TEST

$fatpacked{"Mojolicious/Command/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_VERSION';
  package Mojolicious::Command::version;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::IOLoop::Client;
  use Mojo::IOLoop::TLS;
  use Mojo::JSON;
  use Mojolicious;
  
  has description => 'Show versions of available modules';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my $self = shift;
  
    my $json = Mojo::JSON->JSON_XS ? $Cpanel::JSON::XS::VERSION : 'n/a';
    my $ev = eval { require Mojo::Reactor::EV; 1 } ? $EV::VERSION : 'n/a';
    my $socks
      = Mojo::IOLoop::Client->can_socks ? $IO::Socket::Socks::VERSION : 'n/a';
    my $tls = Mojo::IOLoop::TLS->can_tls    ? $IO::Socket::SSL::VERSION  : 'n/a';
    my $nnr = Mojo::IOLoop::Client->can_nnr ? $Net::DNS::Native::VERSION : 'n/a';
    my $roles = Mojo::Base->ROLES ? $Role::Tiny::VERSION : 'n/a';
  
    print <<EOF;
  CORE
    Perl        ($^V, $^O)
    Mojolicious ($Mojolicious::VERSION, $Mojolicious::CODENAME)
  
  OPTIONAL
    Cpanel::JSON::XS 4.04+  ($json)
    EV 4.0+                 ($ev)
    IO::Socket::Socks 0.64+ ($socks)
    IO::Socket::SSL 2.009+  ($tls)
    Net::DNS::Native 0.15+  ($nnr)
    Role::Tiny 2.000001+    ($roles)
  
  EOF
  
    # Check latest version on CPAN
    my $latest = eval {
      $self->app->ua->max_redirects(10)->tap(sub { $_->proxy->detect })
        ->get('fastapi.metacpan.org/v1/release/Mojolicious')
        ->result->json->{version};
    } or return;
  
    my $msg = 'This version is up to date, have fun!';
    $msg = 'Thanks for testing a development release, you are awesome!'
      if $latest < $Mojolicious::VERSION;
    $msg = "You might want to update your Mojolicious to $latest!"
      if $latest > $Mojolicious::VERSION;
    say $msg;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::version - Version command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION version [OPTIONS]
  
      mojo version
  
    Options:
      -h, --help   Show this summary of available options
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::version> shows version information for available core
  and optional modules.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::version> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $v->description;
    $v              = $v->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $v->usage;
    $v        = $v->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::version> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $v->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_VERSION

$fatpacked{"Mojolicious/Commands.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMANDS';
  package Mojolicious::Commands;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Loader qw(find_modules find_packages load_class);
  use Mojo::Server;
  use Mojo::Util qw(getopt tablify);
  
  has hint => <<EOF;
  
  See 'APPLICATION help COMMAND' for more information on a specific command.
  EOF
  has message    => sub { shift->extract_usage . "\nCommands:\n" };
  has namespaces => sub { ['Mojolicious::Command'] };
  
  sub detect {
  
    # PSGI (Plack only for now)
    return 'psgi' if defined $ENV{PLACK_ENV};
  
    # CGI
    return 'cgi' if defined $ENV{PATH_INFO} || defined $ENV{GATEWAY_INTERFACE};
  
    # Nothing
    return undef;
  }
  
  sub run {
    my ($self, $name, @args) = @_;
  
    # Application loader
    return $self->app if defined $ENV{MOJO_APP_LOADER};
  
    # Try to detect environment
    if (!$ENV{MOJO_NO_DETECT} && (my $env = $self->detect)) { $name = $env }
  
    # Run command
    if ($name && $name =~ /^\w+$/ && ($name ne 'help' || $args[0])) {
  
      # Help
      $name = shift @args if my $help = $name eq 'help';
      $help = $ENV{MOJO_HELP} ||= $help;
  
      # Remove options shared by all commands before loading the command
      _args(\@args);
      my $module;
      $module = _command("${_}::$name", 1) and last for @{$self->namespaces};
  
      # Unknown command
      die qq{Unknown command "$name", maybe you need to install it?\n}
        unless $module;
  
      # Run command
      my $command = $module->new(app => $self->app);
      return $help ? $command->help(@args) : $command->run(@args);
    }
  
    # Hide list for tests
    return 1 if $ENV{HARNESS_ACTIVE};
  
    # Find all available commands
    my %all;
    for my $ns (@{$self->namespaces}) {
      $all{substr $_, length "${ns}::"} //= $_->new->description
        for grep { _command($_) } find_modules($ns), find_packages($ns);
    }
  
    my @rows = map { [" $_", $all{$_}] } sort keys %all;
    return print $self->message, tablify(\@rows), $self->hint;
  }
  
  sub start_app { shift; Mojo::Server->new->build_app(shift)->start(@_) }
  
  # Command line options for MOJO_HELP, MOJO_HOME and MOJO_MODE
  sub _args {
    getopt shift, ['pass_through'],
      'h|help'   => \$ENV{MOJO_HELP},
      'home=s'   => \$ENV{MOJO_HOME},
      'm|mode=s' => \$ENV{MOJO_MODE}
      unless __PACKAGE__->detect;
  }
  
  # Do not remove options from @ARGV
  BEGIN { _args([@ARGV]) }
  
  sub _command {
    my ($module, $fatal) = @_;
    return $module->isa('Mojolicious::Command') ? $module : undef
      unless my $e = load_class $module;
    $fatal && ref $e ? die $e : return undef;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Commands - Command line interface
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION COMMAND [OPTIONS]
  
      mojo version
      mojo generate lite_app
      ./myapp.pl daemon -m production -l http://*:8080
      ./myapp.pl get /foo
      ./myapp.pl routes -v
  
    Tip: CGI and PSGI environments can be automatically detected very often and
         work without commands.
  
    Options (for all commands):
      -h, --help          Get more information on a specific command
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Commands> is the interactive command line interface for the
  L<Mojolicious> framework. It will automatically detect available commands in
  the C<Mojolicious::Command> namespace.
  
  =head1 COMMANDS
  
  These commands are available by default.
  
  =head2 cgi
  
    $ ./myapp.pl cgi
  
  Use L<Mojolicious::Command::cgi> to start application with CGI backend, usually
  auto detected.
  
  =head2 cpanify
  
    $ mojo cpanify -u sri -p secr3t Mojolicious-Plugin-Fun-0.1.tar.gz
  
  Use L<Mojolicious::Command::cpanify> for uploading files to CPAN.
  
  =head2 daemon
  
    $ ./myapp.pl daemon
  
  Use L<Mojolicious::Command::daemon> to start application with standalone HTTP
  and WebSocket server.
  
  =head2 eval
  
    $ ./myapp.pl eval 'say app->home'
  
  Use L<Mojolicious::Command::eval> to run code against application.
  
  =head2 generate
  
    $ mojo generate
    $ mojo generate help
    $ ./myapp.pl generate help
  
  List available generator commands with short descriptions.
  
    $ mojo generate help <generator>
    $ ./myapp.pl generate help <generator>
  
  List available options for generator command with short descriptions.
  
  =head2 generate app
  
    $ mojo generate app <AppName>
  
  Use L<Mojolicious::Command::generate::app> to generate application directory
  structure for a fully functional L<Mojolicious> application.
  
  =head2 generate lite_app
  
    $ mojo generate lite_app
  
  Use L<Mojolicious::Command::generate::lite_app> to generate a fully functional
  L<Mojolicious::Lite> application.
  
  =head2 generate makefile
  
    $ mojo generate makefile
    $ ./myapp.pl generate makefile
  
  Use L<Mojolicious::Command::generate::makefile> to generate C<Makefile.PL> file
  for application.
  
  =head2 generate plugin
  
    $ mojo generate plugin <PluginName>
  
  Use L<Mojolicious::Command::generate::plugin> to generate directory structure
  for a fully functional L<Mojolicious> plugin.
  
  =head2 get
  
    $ mojo get https://mojolicious.org
    $ ./myapp.pl get /foo
  
  Use L<Mojolicious::Command::get> to perform requests to remote host or local
  application.
  
  =head2 help
  
    $ mojo
    $ mojo help
    $ ./myapp.pl help
  
  List available commands with short descriptions.
  
    $ mojo help <command>
    $ ./myapp.pl help <command>
  
  List available options for the command with short descriptions.
  
  =head2 inflate
  
    $ ./myapp.pl inflate
  
  Use L<Mojolicious::Command::inflate> to turn templates and static files
  embedded in the C<DATA> sections of your application into real files.
  
  =head2 prefork
  
    $ ./myapp.pl prefork
  
  Use L<Mojolicious::Command::prefork> to start application with standalone
  pre-forking HTTP and WebSocket server.
  
  =head2 psgi
  
    $ ./myapp.pl psgi
  
  Use L<Mojolicious::Command::psgi> to start application with PSGI backend,
  usually auto detected.
  
  =head2 routes
  
    $ ./myapp.pl routes
  
  Use L<Mojolicious::Command::routes> to list application routes.
  
  =head2 test
  
    $ ./myapp.pl test
    $ ./myapp.pl test t/fun.t
  
  Use L<Mojolicious::Command::test> to run application tests from the C<t>
  directory.
  
  =head2 version
  
    $ mojo version
    $ ./myapp.pl version
  
  Use L<Mojolicious::Command::version> to show version information for available
  core and optional modules, very useful for debugging.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Commands> inherits all attributes from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 hint
  
    my $hint  = $commands->hint;
    $commands = $commands->hint('Foo');
  
  Short hint shown after listing available commands.
  
  =head2 message
  
    my $msg   = $commands->message;
    $commands = $commands->message('Hello World!');
  
  Short usage message shown before listing available commands.
  
  =head2 namespaces
  
    my $namespaces = $commands->namespaces;
    $commands      = $commands->namespaces(['MyApp::Command']);
  
  Namespaces to load commands from, defaults to C<Mojolicious::Command>.
  
    # Add another namespace to load commands from
    push @{$commands->namespaces}, 'MyApp::Command';
  
  =head1 METHODS
  
  L<Mojolicious::Commands> inherits all methods from L<Mojolicious::Command> and
  implements the following new ones.
  
  =head2 detect
  
    my $env = $commands->detect;
  
  Try to detect environment, or return C<undef> if none could be detected.
  
  =head2 run
  
    $commands->run;
    $commands->run(@ARGV);
  
  Load and run commands. Automatic deployment environment detection can be
  disabled with the C<MOJO_NO_DETECT> environment variable.
  
  =head2 start_app
  
    Mojolicious::Commands->start_app('MyApp');
    Mojolicious::Commands->start_app(MyApp => @ARGV);
  
  Load application from class and start the command line interface for it. Note
  that the options C<-h>/C<--help>, C<--home> and C<-m>/C<--mode>, which are
  shared by all commands, will be parsed from C<@ARGV> during compile time.
  
    # Always start daemon for application
    Mojolicious::Commands->start_app('MyApp', 'daemon', '-l', 'http://*:8080');
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMANDS

$fatpacked{"Mojolicious/Controller.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_CONTROLLER';
  package Mojolicious::Controller;
  use Mojo::Base -base;
  
  # No imports, for security reasons!
  use Carp ();
  use Mojo::ByteStream;
  use Mojo::URL;
  use Mojo::Util;
  use Mojolicious::Routes::Match;
  use Scalar::Util ();
  
  has [qw(app tx)];
  has match =>
    sub { Mojolicious::Routes::Match->new(root => shift->app->routes) };
  
  # Reserved stash values
  my %RESERVED = map { $_ => 1 } (
    qw(action app cb controller data extends format handler inline json layout),
    qw(namespace path status template text variant)
  );
  
  sub AUTOLOAD {
    my $self = shift;
  
    my ($package, $method) = our $AUTOLOAD =~ /^(.+)::(.+)$/;
    Carp::croak "Undefined subroutine &${package}::$method called"
      unless Scalar::Util::blessed $self && $self->isa(__PACKAGE__);
  
    # Call helper with current controller
    Carp::croak qq{Can't locate object method "$method" via package "$package"}
      unless my $helper = $self->app->renderer->get_helper($method);
    return $self->$helper(@_);
  }
  
  sub continue { $_[0]->app->routes->continue($_[0]) }
  
  sub cookie {
    my ($self, $name) = (shift, shift);
  
    # Response cookie
    if (@_) {
  
      # Cookie too big
      my $cookie = {name => $name, value => shift, %{shift || {}}};
      $self->app->log->error(qq{Cookie "$name" is bigger than 4096 bytes})
        if length $cookie->{value} > 4096;
  
      $self->res->cookies($cookie);
      return $self;
    }
  
    # Request cookies
    return undef unless my $cookie = $self->req->cookie($name);
    return $cookie->value;
  }
  
  sub every_cookie {
    [map { $_->value } @{shift->req->every_cookie(shift)}];
  }
  
  sub every_param {
    my ($self, $name) = @_;
  
    # Captured unreserved values
    my $captures = $self->stash->{'mojo.captures'} ||= {};
    if (!$RESERVED{$name} && exists $captures->{$name}) {
      my $value = $captures->{$name};
      return ref $value eq 'ARRAY' ? $value : [$value];
    }
  
    # Uploads or param values
    my $req     = $self->req;
    my $uploads = $req->every_upload($name);
    return @$uploads ? $uploads : $req->every_param($name);
  }
  
  sub every_signed_cookie {
    my ($self, $name) = @_;
  
    my $secrets = $self->app->secrets;
    my @results;
    for my $value (@{$self->every_cookie($name)}) {
  
      # Check signature with rotating secrets
      if ($value =~ s/--([^\-]+)$//) {
        my $signature = $1;
  
        my $valid;
        for my $secret (@$secrets) {
          my $check = Mojo::Util::hmac_sha1_sum($value, $secret);
          ++$valid and last if Mojo::Util::secure_compare($signature, $check);
        }
        if ($valid) { push @results, $value }
  
        else { $self->app->log->debug(qq{Cookie "$name" has a bad signature}) }
      }
  
      else { $self->app->log->debug(qq{Cookie "$name" is not signed}) }
    }
  
    return \@results;
  }
  
  sub finish {
    my $self = shift;
  
    # WebSocket
    my $tx = $self->tx || Carp::croak 'Connection already closed';
    $tx->finish(@_) and return $tx->established ? $self : $self->rendered(101)
      if $tx->is_websocket;
  
    # Chunked stream
    return @_ ? $self->write_chunk(@_)->write_chunk('') : $self->write_chunk('')
      if $tx->res->content->is_chunked;
  
    # Normal stream
    return @_ ? $self->write(@_)->write('') : $self->write('');
  }
  
  sub flash {
    my $self = shift;
  
    # Check old flash
    my $session = $self->session;
    return $session->{flash} ? $session->{flash}{$_[0]} : undef
      if @_ == 1 && !ref $_[0];
  
    # Initialize new flash and merge values
    my $values = ref $_[0] ? $_[0] : {@_};
    @{$session->{new_flash} ||= {}}{keys %$values} = values %$values;
  
    return $self;
  }
  
  sub helpers { $_[0]->app->renderer->get_helper('')->($_[0]) }
  
  sub on {
    my ($self, $name, $cb) = @_;
    my $tx = $self->tx || Carp::croak 'Connection already closed';
    $self->rendered(101) if $tx->is_websocket && !$tx->established;
    return $tx->on($name => sub { shift; $self->$cb(@_) });
  }
  
  sub param {
    my ($self, $name) = (shift, shift);
    return $self->every_param($name)->[-1] unless @_;
    $self->stash->{'mojo.captures'}{$name} = @_ > 1 ? [@_] : $_[0];
    return $self;
  }
  
  sub redirect_to {
    my $self = shift;
  
    # Don't override 3xx status
    my $res = $self->res;
    $res->headers->location($self->url_for(@_));
    return $self->rendered($res->is_redirect ? () : 302);
  }
  
  sub render {
    my $self = shift;
  
    # Template may be first argument
    my ($template, $args) = (@_ % 2 ? shift : undef, {@_});
    $args->{template} = $template if $template;
    my $app = $self->app;
    my $plugins = $app->plugins->emit_hook(before_render => $self, $args);
  
    # Localize "extends" and "layout" to allow argument overrides
    my ($maybe, $ts) = @{$args}{'mojo.maybe', 'mojo.string'};
    my $stash = $self->stash;
    local $stash->{layout}  = $stash->{layout}  if exists $stash->{layout};
    local $stash->{extends} = $stash->{extends} if exists $stash->{extends};
  
    # Rendering to string
    local @{$stash}{keys %$args} if $ts || $maybe;
    delete @{$stash}{qw(layout extends)} if $ts;
  
    # All other arguments just become part of the stash
    @$stash{keys %$args} = values %$args;
    my ($output, $format) = $app->renderer->render($self, $args);
  
    # Maybe no 404
    return defined $output ? Mojo::ByteStream->new($output) : undef if $ts;
    return $maybe ? undef : !$self->helpers->reply->not_found
      unless defined $output;
  
    $plugins->emit_hook(after_render => $self, \$output, $format);
    my $headers = $self->res->body($output)->headers;
    $headers->content_type($app->types->type($format) || 'text/plain')
      unless $headers->content_type;
    return !!$self->rendered($stash->{status});
  }
  
  sub render_later { shift->stash('mojo.rendered' => 1) }
  
  sub render_maybe { shift->render(@_, 'mojo.maybe' => 1) }
  
  sub render_to_string { shift->render(@_, 'mojo.string' => 1) }
  
  sub rendered {
    my ($self, $status) = @_;
  
    # Make sure we have a status
    my $res = $self->res;
    $res->code($status || 200) if $status || !$res->code;
  
    # Finish transaction
    my $stash = $self->stash;
    if (!$stash->{'mojo.finished'} && ++$stash->{'mojo.finished'}) {
  
      # Disable auto rendering and stop timer
      my $app    = $self->render_later->app;
      my $timing = $self->helpers->timing;
      if (defined(my $elapsed = $timing->elapsed('mojo.timer'))) {
        my $rps  = $timing->rps($elapsed) // '??';
        my $code = $res->code;
        my $msg  = $res->message || $res->default_message($code);
        $app->log->debug("$code $msg (${elapsed}s, $rps/s)");
      }
  
      $app->plugins->emit_hook_reverse(after_dispatch => $self);
      $app->sessions->store($self);
    }
    $self->tx->resume;
    return $self;
  }
  
  sub req { (shift->tx || Carp::croak 'Connection already closed')->req }
  sub res { (shift->tx || Carp::croak 'Connection already closed')->res }
  
  sub respond_to {
    my ($self, $args) = (shift, ref $_[0] ? $_[0] : {@_});
  
    # Find target
    my $target;
    my $renderer = $self->app->renderer;
    my @formats  = @{$renderer->accepts($self)};
    for my $format (@formats ? @formats : ($renderer->default_format)) {
      next unless $target = $args->{$format};
      $self->stash->{format} = $format;
      last;
    }
  
    # Fallback
    unless ($target) {
      return $self->rendered(204) unless $target = $args->{any};
      delete $self->stash->{format};
    }
  
    # Dispatch
    ref $target eq 'CODE' ? $target->($self) : $self->render(%$target);
  
    return $self;
  }
  
  sub send {
    my ($self, $msg, $cb) = @_;
    my $tx = $self->tx || Carp::croak 'Connection already closed';
    Carp::croak 'No WebSocket connection to send message to'
      unless $tx->is_websocket;
    $tx->send($msg, $cb ? sub { shift; $self->$cb(@_) } : ());
    return $tx->established ? $self : $self->rendered(101);
  }
  
  sub session {
    my $self = shift;
  
    my $stash = $self->stash;
    $self->app->sessions->load($self)
      unless exists $stash->{'mojo.active_session'};
  
    # Hash
    my $session = $stash->{'mojo.session'} ||= {};
    return $session unless @_;
  
    # Get
    return $session->{$_[0]} unless @_ > 1 || ref $_[0];
  
    # Set
    my $values = ref $_[0] ? $_[0] : {@_};
    @$session{keys %$values} = values %$values;
  
    return $self;
  }
  
  sub signed_cookie {
    my ($self, $name, $value, $options) = @_;
  
    # Request cookie
    return $self->every_signed_cookie($name)->[-1] unless defined $value;
  
    # Response cookie
    my $checksum = Mojo::Util::hmac_sha1_sum($value, $self->app->secrets->[0]);
    return $self->cookie($name, "$value--$checksum", $options);
  }
  
  sub stash { Mojo::Util::_stash(stash => @_) }
  
  sub url_for {
    my ($self, $target) = (shift, shift // '');
  
    # Absolute URL
    return $target if Scalar::Util::blessed $target && $target->isa('Mojo::URL');
    return Mojo::URL->new($target) if $target =~ m!^(?:[^:/?#]+:|//|#)!;
  
    # Base
    my $url  = Mojo::URL->new;
    my $req  = $self->req;
    my $base = $url->base($req->url->base->clone)->base->userinfo(undef);
  
    # Relative URL
    my $path = $url->path;
    if ($target =~ m!^/!) {
      if (defined(my $prefix = $self->stash->{path})) {
        my $real = $req->url->path->to_route;
        $real =~ s!/?\Q$prefix\E$!$target!;
        $target = $real;
      }
      $url->parse($target);
    }
  
    # Route
    else {
      my $generated = $self->match->path_for($target, @_);
      $path->parse($generated->{path}) if $generated->{path};
      $base->scheme($base->protocol eq 'https' ? 'wss' : 'ws')
        if $generated->{websocket};
    }
  
    # Make path absolute
    my $base_path = $base->path;
    unshift @{$path->parts}, @{$base_path->parts};
    $base_path->parts([])->trailing_slash(0);
  
    return $url;
  }
  
  sub validation {
    my $self = shift;
  
    my $stash = $self->stash;
    return $stash->{'mojo.validation'} if $stash->{'mojo.validation'};
  
    my $req    = $self->req;
    my $token  = $self->session->{csrf_token};
    my $header = $req->headers->header('X-CSRF-Token');
    my $hash   = $req->params->to_hash;
    $hash->{csrf_token} //= $header if $token && $header;
    $hash->{$_} = $req->every_upload($_) for map { $_->name } @{$req->uploads};
    my $v = $self->app->validator->validation->input($hash);
    return $stash->{'mojo.validation'} = $v->csrf_token($token);
  }
  
  sub write {
    my ($self, $chunk, $cb) = @_;
    $self->res->content->write($chunk, $cb ? sub { shift; $self->$cb(@_) } : ());
    return $self->rendered;
  }
  
  sub write_chunk {
    my ($self, $chunk, $cb) = @_;
    my $content = $self->res->content;
    $content->write_chunk($chunk, $cb ? sub { shift; $self->$cb(@_) } : ());
    return $self->rendered;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Controller - Controller base class
  
  =head1 SYNOPSIS
  
    # Controller
    package MyApp::Controller::Foo;
    use Mojo::Base 'Mojolicious::Controller';
  
    # Action
    sub bar {
      my $self = shift;
      my $name = $self->param('name');
      $self->res->headers->cache_control('max-age=1, no-cache');
      $self->render(json => {hello => $name});
    }
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Controller> is the base class for your L<Mojolicious>
  controllers. It is also the default controller class unless you set
  L<Mojolicious/"controller_class">.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Controller> inherits all attributes from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 app
  
    my $app = $c->app;
    $c      = $c->app(Mojolicious->new);
  
  A reference back to the application that dispatched to this controller, usually
  a L<Mojolicious> object.
  
    # Use application logger
    $c->app->log->debug('Hello Mojo');
  
    # Generate path
    my $path = $c->app->home->child('templates', 'foo', 'bar.html.ep');
  
  =head2 match
  
    my $m = $c->match;
    $c    = $c->match(Mojolicious::Routes::Match->new);
  
  Router results for the current request, defaults to a
  L<Mojolicious::Routes::Match> object.
  
    # Introspect
    my $name   = $c->match->endpoint->name;
    my $foo    = $c->match->endpoint->pattern->defaults->{foo};
    my $action = $c->match->stack->[-1]{action};
  
  =head2 tx
  
    my $tx = $c->tx;
    $c     = $c->tx(Mojo::Transaction::HTTP->new);
  
  The transaction that is currently being processed, usually a
  L<Mojo::Transaction::HTTP> or L<Mojo::Transaction::WebSocket> object. Note that
  this reference is usually weakened, so the object needs to be referenced
  elsewhere as well when you're performing non-blocking operations and the
  underlying connection might get closed early.
  
    # Check peer information
    my $address = $c->tx->remote_address;
    my $port    = $c->tx->remote_port;
  
    # Increase size limit for WebSocket messages to 16MiB
    $c->tx->max_websocket_size(16777216) if $c->tx->is_websocket;
  
    # Perform non-blocking operation without knowing the connection status
    my $tx = $c->tx;
    Mojo::IOLoop->timer(2 => sub {
      $c->app->log->debug($tx->is_finished ? 'Finished' : 'In progress');
    });
  
  =head1 METHODS
  
  L<Mojolicious::Controller> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 continue
  
    $c->continue;
  
  Continue dispatch chain from an intermediate destination with
  L<Mojolicious::Routes/"continue">.
  
  =head2 cookie
  
    my $value = $c->cookie('foo');
    $c        = $c->cookie(foo => 'bar');
    $c        = $c->cookie(foo => 'bar', {path => '/'});
  
  Access request cookie values and create new response cookies. If there are
  multiple values sharing the same name, and you want to access more than just
  the last one, you can use L</"every_cookie">.
  
    # Create response cookie with domain and expiration date
    $c->cookie(user => 'sri', {domain => 'example.com', expires => time + 60});
  
    # Create secure response cookie
    $c->cookie(secret => 'I <3 Mojolicious', {secure => 1, httponly => 1});
  
  =head2 every_cookie
  
    my $values = $c->every_cookie('foo');
  
  Similar to L</"cookie">, but returns all request cookie values sharing the same
  name as an array reference.
  
    $ Get first cookie value
    my $first = $c->every_cookie('foo')->[0];
  
  =head2 every_param
  
    my $values = $c->every_param('foo');
  
  Similar to L</"param">, but returns all values sharing the same name as an
  array reference.
  
    # Get first value
    my $first = $c->every_param('foo')->[0];
  
  =head2 every_signed_cookie
  
    my $values = $c->every_signed_cookie('foo');
  
  Similar to L</"signed_cookie">, but returns all signed request cookie values
  sharing the same name as an array reference.
  
    # Get first signed cookie value
    my $first = $c->every_signed_cookie('foo')->[0];
  
  =head2 finish
  
    $c = $c->finish;
    $c = $c->finish(1000);
    $c = $c->finish(1003 => 'Cannot accept data!');
    $c = $c->finish('Bye!');
  
  Close WebSocket connection or long poll stream gracefully. This method will
  automatically respond to WebSocket handshake requests with a C<101> response
  status, to establish the WebSocket connection.
  
  =head2 flash
  
    my $foo = $c->flash('foo');
    $c      = $c->flash({foo => 'bar'});
    $c      = $c->flash(foo => 'bar');
  
  Data storage persistent only for the next request, stored in the L</"session">.
  
    # Show message after redirect
    $c->flash(message => 'User created successfully!');
    $c->redirect_to('show_user', id => 23);
  
  =head2 helpers
  
    my $helpers = $c->helpers;
  
  Return a proxy object containing the current controller object and on which
  helpers provided by L</"app"> can be called. This includes all helpers from
  L<Mojolicious::Plugin::DefaultHelpers> and L<Mojolicious::Plugin::TagHelpers>.
  
    # Make sure to use the "title" helper and not the controller method
    $c->helpers->title('Welcome!');
  
    # Use a nested helper instead of the "reply" controller method
    $c->helpers->reply->not_found;
  
  =head2 on
  
    my $cb = $c->on(finish => sub {...});
  
  Subscribe to events of L</"tx">, which is usually a L<Mojo::Transaction::HTTP>
  or L<Mojo::Transaction::WebSocket> object. This method will automatically
  respond to WebSocket handshake requests with a C<101> response status, to
  establish the WebSocket connection.
  
    # Do something after the transaction has been finished
    $c->on(finish => sub {
      my $c = shift;
      $c->app->log->debug('All data has been sent');
    });
  
    # Receive WebSocket message
    $c->on(message => sub {
      my ($c, $msg) = @_;
      $c->app->log->debug("Message: $msg");
    });
  
    # Receive JSON object via WebSocket message
    $c->on(json => sub {
      my ($c, $hash) = @_;
      $c->app->log->debug("Test: $hash->{test}");
    });
  
    # Receive WebSocket "Binary" message
    $c->on(binary => sub {
      my ($c, $bytes) = @_;
      my $len = length $bytes;
      $c->app->log->debug("Received $len bytes");
    });
  
  =head2 param
  
    my $value = $c->param('foo');
    $c        = $c->param(foo => 'ba;r');
    $c        = $c->param(foo => 'ba;r', 'baz');
    $c        = $c->param(foo => ['ba;r', 'baz']);
  
  Access route placeholder values that are not reserved stash values, file
  uploads as well as C<GET> and C<POST> parameters extracted from the query
  string and C<application/x-www-form-urlencoded> or C<multipart/form-data>
  message body, in that order. If there are multiple values sharing the same
  name, and you want to access more than just the last one, you can use
  L</"every_param">. Parts of the request body need to be loaded into memory to
  parse C<POST> parameters, so you have to make sure it is not excessively large.
  There's a 16MiB limit for requests by default.
  
    # Get first value
    my $first = $c->every_param('foo')->[0];
  
  For more control you can also access request information directly.
  
    # Only GET parameters
    my $foo = $c->req->query_params->param('foo');
  
    # Only POST parameters
    my $foo = $c->req->body_params->param('foo');
  
    # Only GET and POST parameters
    my $foo = $c->req->param('foo');
  
    # Only file uploads
    my $foo = $c->req->upload('foo');
  
  =head2 redirect_to
  
    $c = $c->redirect_to('named', foo => 'bar');
    $c = $c->redirect_to('named', {foo => 'bar'});
    $c = $c->redirect_to('/index.html');
    $c = $c->redirect_to('http://example.com/index.html');
  
  Prepare a C<302> (if the status code is not already C<3xx>) redirect response
  with C<Location> header, takes the same arguments as L</"url_for">.
  
    # Moved Permanently
    $c->res->code(301);
    $c->redirect_to('some_route');
  
    # Temporary Redirect
    $c->res->code(307);
    $c->redirect_to('some_route');
  
  =head2 render
  
    my $bool = $c->render;
    my $bool = $c->render(foo => 'bar', baz => 23);
    my $bool = $c->render(template => 'foo/index');
    my $bool = $c->render(template => 'index', format => 'html');
    my $bool = $c->render(data => $bytes);
    my $bool = $c->render(text => 'Hello!');
    my $bool = $c->render(json => {foo => 'bar'});
    my $bool = $c->render(handler => 'something');
    my $bool = $c->render('foo/index');
  
  Render content with L<Mojolicious/"renderer"> and emit hooks
  L<Mojolicious/"before_render"> as well as L<Mojolicious/"after_render">, or
  call L<Mojolicious::Plugin::DefaultHelpers/"reply-E<gt>not_found"> if no
  response could be generated, all additional key/value pairs get merged into the
  L</"stash">.
  
    # Render characters
    $c->render(text => 'I  Mojolicious!');
  
    # Render characters (alternative)
    $c->stash(text => 'I  Mojolicious!')->render;
  
    # Render binary data
    use Mojo::JSON 'encode_json';
    $c->render(data => encode_json({test => 'I  Mojolicious!'}));
  
    # Render JSON
    $c->render(json => {test => 'I  Mojolicious!'});
  
    # Render inline template
    $c->render(inline => '<%= 1 + 1 %>');
  
    # Render template "foo/bar.html.ep"
    $c->render(template => 'foo/bar', format => 'html', handler => 'ep');
  
    # Render template "test.*.*" with arbitrary values "foo" and "bar"
    $c->render(template => 'test', foo => 'test', bar => 23);
  
    # Render template "test.xml.*"
    $c->render(template => 'test', format => 'xml');
  
    # Render template "test.xml.*" (alternative)
    $c->render('test', format => 'xml');
  
  =head2 render_later
  
    $c = $c->render_later;
  
  Disable automatic rendering to delay response generation, only necessary if
  automatic rendering would result in a response.
  
    # Delayed rendering
    $c->render_later;
    Mojo::IOLoop->timer(2 => sub {
      $c->render(text => 'Delayed by 2 seconds!');
    });
  
  =head2 render_maybe
  
    my $bool = $c->render_maybe;
    my $bool = $c->render_maybe(foo => 'bar', baz => 23);
    my $bool = $c->render_maybe('foo/index', format => 'html');
  
  Try to render content, but do not call
  L<Mojolicious::Plugin::DefaultHelpers/"reply-E<gt>not_found"> if no response
  could be generated, all arguments get localized automatically and are only
  available during this render operation, takes the same arguments as
  L</"render">.
  
    # Render template "index_local" only if it exists
    $c->render_maybe('index_local') or $c->render('index');
  
  =head2 render_to_string
  
    my $output = $c->render_to_string('foo/index', format => 'pdf');
  
  Try to render content and return it wrapped in a L<Mojo::ByteStream> object or
  return C<undef>, all arguments get localized automatically and are only
  available during this render operation, takes the same arguments as
  L</"render">.
  
    # Render inline template
    my $two = $c->render_to_string(inline => '<%= 1 + 1 %>');
  
  =head2 rendered
  
    $c = $c->rendered;
    $c = $c->rendered(302);
  
  Finalize response and emit hook L<Mojolicious/"after_dispatch">, defaults to
  using a C<200> response code.
  
    # Custom response
    $c->res->headers->content_type('text/plain');
    $c->res->body('Hello World!');
    $c->rendered(200);
  
  =head2 req
  
    my $req = $c->req;
  
  Get L<Mojo::Message::Request> object from L</"tx">.
  
    # Longer version
    my $req = $c->tx->req;
  
    # Extract request information
    my $method = $c->req->method;
    my $url    = $c->req->url->to_abs;
    my $info   = $c->req->url->to_abs->userinfo;
    my $host   = $c->req->url->to_abs->host;
    my $agent  = $c->req->headers->user_agent;
    my $custom = $c->req->headers->header('Custom-Header');
    my $bytes  = $c->req->body;
    my $str    = $c->req->text;
    my $hash   = $c->req->params->to_hash;
    my $all    = $c->req->uploads;
    my $value  = $c->req->json;
    my $foo    = $c->req->json('/23/foo');
    my $dom    = $c->req->dom;
    my $bar    = $c->req->dom('div.bar')->first->text;
  
  =head2 res
  
    my $res = $c->res;
  
  Get L<Mojo::Message::Response> object from L</"tx">.
  
    # Longer version
    my $res = $c->tx->res;
  
    # Force file download by setting a response header
    $c->res->headers->content_disposition('attachment; filename=foo.png;');
  
    # Use a custom response header
    $c->res->headers->header('Custom-Header' => 'whatever');
  
    # Make sure response is cached correctly
    $c->res->headers->cache_control('public, max-age=300');
    $c->res->headers->append(Vary => 'Accept-Encoding');
  
  =head2 respond_to
  
    $c = $c->respond_to(
      json => {json => {message => 'Welcome!'}},
      html => {template => 'welcome'},
      any  => sub {...}
    );
  
  Automatically select best possible representation for resource from C<format>
  C<GET>/C<POST> parameter, C<format> stash value or C<Accept> request header,
  defaults to L<Mojolicious::Renderer/"default_format"> or rendering an empty
  C<204> response. Each representation can be handled with a callback or a hash
  reference containing arguments to be passed to L</"render">.
  
    # Everything else than "json" and "xml" gets a 204 response
    $c->respond_to(
      json => sub { $c->render(json => {just => 'works'}) },
      xml  => {text => '<just>works</just>'},
      any  => {data => '', status => 204}
    );
  
  For more advanced negotiation logic you can also use the helper
  L<Mojolicious::Plugin::DefaultHelpers/"accepts">.
  
  =head2 send
  
    $c = $c->send({binary => $bytes});
    $c = $c->send({text   => $bytes});
    $c = $c->send({json   => {test => [1, 2, 3]}});
    $c = $c->send([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);
    $c = $c->send($chars);
    $c = $c->send($chars => sub {...});
  
  Send message or frame non-blocking via WebSocket, the optional drain callback
  will be executed once all data has been written. This method will automatically
  respond to WebSocket handshake requests with a C<101> response status, to
  establish the WebSocket connection.
  
    # Send "Text" message
    $c->send('I  Mojolicious!');
  
    # Send JSON object as "Text" message
    $c->send({json => {test => 'I  Mojolicious!'}});
  
    # Send JSON object as "Binary" message
    use Mojo::JSON 'encode_json';
    $c->send({binary => encode_json({test => 'I  Mojolicious!'})});
  
    # Send "Ping" frame
    use Mojo::WebSocket 'WS_PING';
    $c->send([1, 0, 0, 0, WS_PING, 'Hello World!']);
  
    # Make sure the first message has been written before continuing
    $c->send('First message!' => sub {
      my $c = shift;
      $c->send('Second message!');
    });
  
  For mostly idle WebSockets you might also want to increase the inactivity
  timeout with L<Mojolicious::Plugin::DefaultHelpers/"inactivity_timeout">, which
  usually defaults to C<15> seconds.
  
    # Increase inactivity timeout for connection to 300 seconds
    $c->inactivity_timeout(300);
  
  =head2 session
  
    my $session = $c->session;
    my $foo     = $c->session('foo');
    $c          = $c->session({foo => 'bar'});
    $c          = $c->session(foo => 'bar');
  
  Persistent data storage for the next few requests, all session data gets
  serialized with L<Mojo::JSON> and stored Base64 encoded in HMAC-SHA1 signed
  cookies, to prevent tampering. Note that cookies usually have a C<4096> byte
  (4KiB) limit, depending on browser.
  
    # Manipulate session
    $c->session->{foo} = 'bar';
    my $foo = $c->session->{foo};
    delete $c->session->{foo};
  
    # Expiration date in seconds from now (persists between requests)
    $c->session(expiration => 604800);
  
    # Expiration date as absolute epoch time (only valid for one request)
    $c->session(expires => time + 604800);
  
    # Delete whole session by setting an expiration date in the past
    $c->session(expires => 1);
  
  =head2 signed_cookie
  
    my $value = $c->signed_cookie('foo');
    $c        = $c->signed_cookie(foo => 'bar');
    $c        = $c->signed_cookie(foo => 'bar', {path => '/'});
  
  Access signed request cookie values and create new signed response cookies. If
  there are multiple values sharing the same name, and you want to access more
  than just the last one, you can use L</"every_signed_cookie">. Cookies are
  cryptographically signed with HMAC-SHA1, to prevent tampering, and the ones
  failing signature verification will be automatically discarded.
  
  =head2 stash
  
    my $hash = $c->stash;
    my $foo  = $c->stash('foo');
    $c       = $c->stash({foo => 'bar', baz => 23});
    $c       = $c->stash(foo => 'bar', baz => 23);
  
  Non-persistent data storage and exchange for the current request, application
  wide default values can be set with L<Mojolicious/"defaults">. Some stash
  values have a special meaning and are reserved, the full list is currently
  C<action>, C<app>, C<cb>, C<controller>, C<data>, C<extends>, C<format>,
  C<handler>, C<inline>, C<json>, C<layout>, C<namespace>, C<path>, C<status>,
  C<template>, C<text> and C<variant>. Note that all stash values with a
  C<mojo.*> prefix are reserved for internal use.
  
    # Remove value
    my $foo = delete $c->stash->{foo};
  
    # Assign multiple values at once
    $c->stash(foo => 'test', bar => 23);
  
  =head2 url_for
  
    my $url = $c->url_for;
    my $url = $c->url_for(name => 'sebastian');
    my $url = $c->url_for({name => 'sebastian'});
    my $url = $c->url_for('test', name => 'sebastian');
    my $url = $c->url_for('test', {name => 'sebastian'});
    my $url = $c->url_for('/index.html');
    my $url = $c->url_for('//example.com/index.html');
    my $url = $c->url_for('http://example.com/index.html');
    my $url = $c->url_for('mailto:sri@example.com');
    my $url = $c->url_for('#whatever');
  
  Generate a portable L<Mojo::URL> object with base for a path, URL or route.
  
    # Rebuild URL for the current route
    $c->url_for;
  
    # Rebuild URL for the current route, but replace the "name" placeholder value
    $c->url_for(name => 'sebastian');
  
    # Absolute URL for the current route
    $c->url_for->to_abs;
  
    # Build URL for route "test" with two placeholder values
    $c->url_for('test', name => 'sebastian', foo => 'bar');
  
    # "http://127.0.0.1:3000/index.html" if application was started with Morbo
    $c->url_for('/index.html')->to_abs;
  
    # "https://127.0.0.1:443/index.html" if application was started with Morbo
    $c->url_for('/index.html')->to_abs->scheme('https')->port(443);
  
    # "/index.html?foo=bar" if application is deployed under "/"
    $c->url_for('/index.html')->query(foo => 'bar');
  
    # "/myapp/index.html?foo=bar" if application is deployed under "/myapp"
    $c->url_for('/index.html')->query(foo => 'bar');
  
  You can also use the helper L<Mojolicious::Plugin::DefaultHelpers/"url_with">
  to inherit query parameters from the current request.
  
    # "/list?q=mojo&page=2" if current request was for "/list?q=mojo&page=1"
    $c->url_with->query([page => 2]);
  
  =head2 validation
  
    my $v = $c->validation;
  
  Get L<Mojolicious::Validator::Validation> object for current request to
  validate file uploads as well as C<GET> and C<POST> parameters extracted from
  the query string and C<application/x-www-form-urlencoded> or
  C<multipart/form-data> message body. Parts of the request body need to be loaded
  into memory to parse C<POST> parameters, so you have to make sure it is not
  excessively large. There's a 16MiB limit for requests by default.
  
    # Validate GET/POST parameter
    my $v = $c->validation;
    $v->required('title', 'trim')->size(3, 50);
    my $title = $v->param('title');
  
    # Validate file upload
    my $v = $c->validation;
    $v->required('tarball')->upload->size(1, 1048576);
    my $tarball = $v->param('tarball');
  
  =head2 write
  
    $c = $c->write;
    $c = $c->write('');
    $c = $c->write($bytes);
    $c = $c->write($bytes => sub {...});
  
  Write dynamic content non-blocking, the optional drain callback will be executed
  once all data has been written. Calling this method without a chunk of data
  will finalize the response headers and allow for dynamic content to be written
  later.
  
    # Keep connection alive (with Content-Length header)
    $c->res->headers->content_length(6);
    $c->write('Hel' => sub {
      my $c = shift;
      $c->write('lo!');
    });
  
    # Close connection when finished (without Content-Length header)
    $c->write('Hel' => sub {
      my $c = shift;
      $c->write('lo!' => sub {
        my $c = shift;
        $c->finish;
      });
    });
  
  You can call L</"finish"> or write an empty chunk of data at any time to end
  the stream.
  
    HTTP/1.1 200 OK
    Date: Sat, 13 Sep 2014 16:48:29 GMT
    Content-Length: 6
    Server: Mojolicious (Perl)
  
    Hello!
  
    HTTP/1.1 200 OK
    Connection: close
    Date: Sat, 13 Sep 2014 16:48:29 GMT
    Server: Mojolicious (Perl)
  
    Hello!
  
  For Comet (long polling) you might also want to increase the inactivity timeout
  with L<Mojolicious::Plugin::DefaultHelpers/"inactivity_timeout">, which usually
  defaults to C<15> seconds.
  
    # Increase inactivity timeout for connection to 300 seconds
    $c->inactivity_timeout(300);
  
  =head2 write_chunk
  
    $c = $c->write_chunk;
    $c = $c->write_chunk('');
    $c = $c->write_chunk($bytes);
    $c = $c->write_chunk($bytes => sub {...});
  
  Write dynamic content non-blocking with chunked transfer encoding, the optional
  drain callback will be executed once all data has been written. Calling this
  method without a chunk of data will finalize the response headers and allow for
  dynamic content to be written later.
  
    # Make sure previous chunk has been written before continuing
    $c->write_chunk('H' => sub {
      my $c = shift;
      $c->write_chunk('ell' => sub {
        my $c = shift;
        $c->finish('o!');
      });
    });
  
  You can call L</"finish"> or write an empty chunk of data at any time to end
  the stream.
  
    HTTP/1.1 200 OK
    Date: Sat, 13 Sep 2014 16:48:29 GMT
    Transfer-Encoding: chunked
    Server: Mojolicious (Perl)
  
    1
    H
    3
    ell
    2
    o!
    0
  
  =head1 AUTOLOAD
  
  In addition to the L</"ATTRIBUTES"> and L</"METHODS"> above you can also call
  helpers provided by L</"app"> on L<Mojolicious::Controller> objects. This
  includes all helpers from L<Mojolicious::Plugin::DefaultHelpers> and
  L<Mojolicious::Plugin::TagHelpers>.
  
    # Call helpers
    $c->layout('green');
    $c->title('Welcome!');
  
    # Longer version
    $c->helpers->layout('green');
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_CONTROLLER

$fatpacked{"Mojolicious/Lite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_LITE';
  package Mojolicious::Lite;
  use Mojo::Base 'Mojolicious';
  
  # "Bender: Bite my shiny metal ass!"
  use Mojo::File 'path';
  use Mojo::UserAgent::Server;
  use Mojo::Util 'monkey_patch';
  
  sub import {
  
    # Remember executable for later
    $ENV{MOJO_EXE} ||= (caller)[1];
  
    # Reuse home directory if possible
    local $ENV{MOJO_HOME} = path($ENV{MOJO_EXE})->dirname->to_string
      unless $ENV{MOJO_HOME};
  
    # Initialize application class
    my $caller = caller;
    no strict 'refs';
    push @{"${caller}::ISA"}, 'Mojolicious';
  
    # Generate moniker based on filename
    my $moniker = path($ENV{MOJO_EXE})->basename('.pl', '.pm', '.t');
    my $app = shift->new(moniker => $moniker);
  
    # Initialize routes without namespaces
    my $routes = $app->routes->namespaces([]);
    $app->static->classes->[0] = $app->renderer->classes->[0] = $caller;
  
    # The Mojolicious::Lite DSL
    my $root = $routes;
    for my $name (qw(any get options patch post put websocket)) {
      monkey_patch $caller, $name, sub { $routes->$name(@_) };
    }
    monkey_patch($caller, $_, sub {$app}) for qw(new app);
    monkey_patch $caller, del => sub { $routes->delete(@_) };
    monkey_patch $caller, group => sub (&) {
      (my $old, $root) = ($root, $routes);
      shift->();
      ($routes, $root) = ($root, $old);
    };
    monkey_patch $caller,
      helper => sub { $app->helper(@_) },
      hook   => sub { $app->hook(@_) },
      plugin => sub { $app->plugin(@_) },
      under  => sub { $routes = $root->under(@_) };
  
    # Make sure there's a default application for testing
    Mojo::UserAgent::Server->app($app) unless Mojo::UserAgent::Server->app;
  
    # Lite apps are strict!
    unshift @_, 'Mojo::Base', -strict;
    goto &Mojo::Base::import;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Lite - Micro real-time web framework
  
  =head1 SYNOPSIS
  
    # Automatically enables "strict", "warnings", "utf8" and Perl 5.10 features
    use Mojolicious::Lite;
  
    # Route with placeholder
    get '/:foo' => sub {
      my $c   = shift;
      my $foo = $c->param('foo');
      $c->render(text => "Hello from $foo.");
    };
  
    # Start the Mojolicious command system
    app->start;
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Lite> is a tiny domain specific language built around
  L<Mojolicious>, made up of only about a dozen Perl functions.
  
  On Perl 5.20+ you can also use a C<-signatures> flag to enable support for
  L<subroutine signatures|perlsub/"Signatures">.
  
    use Mojolicious::Lite -signatures;
  
    get '/:foo' => sub ($c) {
      my $foo = $c->param('foo');
      $c->render(text => "Hello from $foo.");
    };
  
    app->start;
  
  See L<Mojolicious::Guides::Tutorial> for more!
  
  =head1 GROWING
  
  While L<Mojolicious::Guides::Growing> will give you a detailed introduction to
  growing a L<Mojolicious::Lite> prototype into a well-structured L<Mojolicious>
  application, here we have collected a few snippets that illustrate very well
  just how similar both of them are.
  
  =head2 Routes
  
  The functions L</"get">, L</"post"> and friends all have equivalent methods.
  
    # Mojolicious::Lite
    get '/foo' => sub {
      my $c = shift;
      $c->render(text => 'Hello World!');
    };
  
    # Mojolicious
    sub startup {
      my $self = shift;
  
      my $routes = $self->routes;
      $routes->get('/foo' => sub {
        my $c = shift;
        $c->render(text => 'Hello World!');
      });
    }
  
  =head2 Application
  
  The application object you can access with the function L</"app"> is the first
  argument passed to the C<startup> method.
  
    # Mojolicious::Lite
    app->max_request_size(16777216);
  
    # Mojolicious
    sub startup {
      my $self = shift;
      $self->max_request_size(16777216);
    }
  
  =head2 Plugins
  
  Instead of the L</"plugin"> function you just use the method
  L<Mojolicious/"plugin">.
  
    # Mojolicious::Lite
    plugin 'Config';
  
    # Mojolicious
    sub startup {
      my $self = shift;
      $self->plugin('Config');
    }
  
  =head2 Helpers
  
  Similar to plugins, instead of the L</"helper"> function you just use the method
  L<Mojolicious/"helper">.
  
    # Mojolicious::Lite
    helper two => sub {
      my $c = shift;
      return 1 + 1;
    };
  
    # Mojolicious
    sub startup {
      my $self = shift;
      $self->helper(two => sub {
        my $c = shift;
        return 1 + 1;
      });
    }
  
  =head2 Under
  
  Instead of sequential function calls, we can use methods to build a tree with
  nested routes, that much better illustrates how routes work internally.
  
    # Mojolicious::Lite
    under '/foo';
    get '/bar' => sub {...};
  
    # Mojolicious
    sub startup {
      my $self = shift;
  
      my $routes = $self->routes;
      my $foo = $routes->under('/foo');
      $foo->get('/bar' => sub {...});
    }
  
  =head1 FUNCTIONS
  
  L<Mojolicious::Lite> implements the following functions, which are
  automatically exported.
  
  =head2 any
  
    my $route = any '/:foo' => sub {...};
    my $route = any '/:foo' => sub {...} => 'name';
    my $route = any '/:foo' => {foo => 'bar'} => sub {...};
    my $route = any '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = any ['GET', 'POST'] => '/:foo' => sub {...};
    my $route = any ['GET', 'POST'] => '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = any
      ['GET', 'POST'] => '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"any">, matching any of the
  listed HTTP request methods or all. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head2 app
  
    my $app = app;
  
  Returns the L<Mojolicious::Lite> application object, which is a subclass of
  L<Mojolicious>.
  
    # Use all the available attributes and methods
    app->log->level('error');
    app->defaults(foo => 'bar');
  
  =head2 del
  
    my $route = del '/:foo' => sub {...};
    my $route = del '/:foo' => sub {...} => 'name';
    my $route = del '/:foo' => {foo => 'bar'} => sub {...};
    my $route = del '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = del '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"delete">, matching only
  C<DELETE> requests. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head2 get
  
    my $route = get '/:foo' => sub {...};
    my $route = get '/:foo' => sub {...} => 'name';
    my $route = get '/:foo' => {foo => 'bar'} => sub {...};
    my $route = get '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = get '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"get">, matching only C<GET>
  requests. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head2 group
  
    group {...};
  
  Start a new route group.
  
  =head2 helper
  
    helper foo => sub {...};
  
  Add a new helper with L<Mojolicious/"helper">.
  
  =head2 hook
  
    hook after_dispatch => sub {...};
  
  Share code with L<Mojolicious/"hook">.
  
  =head2 options
  
    my $route = options '/:foo' => sub {...};
    my $route = options '/:foo' => sub {...} => 'name';
    my $route = options '/:foo' => {foo => 'bar'} => sub {...};
    my $route = options '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = options '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"options">, matching only
  C<OPTIONS> requests. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head2 patch
  
    my $route = patch '/:foo' => sub {...};
    my $route = patch '/:foo' => sub {...} => 'name';
    my $route = patch '/:foo' => {foo => 'bar'} => sub {...};
    my $route = patch '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = patch '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"patch">, matching only
  C<PATCH> requests. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head2 plugin
  
    plugin SomePlugin => {foo => 23};
  
  Load a plugin with L<Mojolicious/"plugin">.
  
  =head2 post
  
    my $route = post '/:foo' => sub {...};
    my $route = post '/:foo' => sub {...} => 'name';
    my $route = post '/:foo' => {foo => 'bar'} => sub {...};
    my $route = post '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = post '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"post">, matching only C<POST>
  requests. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head2 put
  
    my $route = put '/:foo' => sub {...};
    my $route = put '/:foo' => sub {...} => 'name';
    my $route = put '/:foo' => {foo => 'bar'} => sub {...};
    my $route = put '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = put '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"put">, matching only C<PUT>
  requests. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head2 under
  
    my $route = under sub {...};
    my $route = under '/:foo' => sub {...};
    my $route = under '/:foo' => {foo => 'bar'};
    my $route = under '/:foo' => [foo => qr/\w+/];
    my $route = under '/:foo' => (agent => qr/Firefox/);
    my $route = under [format => 0];
  
  Generate nested route with L<Mojolicious::Routes::Route/"under">, to which all
  following routes are automatically appended. See
  L<Mojolicious::Guides::Tutorial> and L<Mojolicious::Guides::Routing> for more
  information.
  
  =head2 websocket
  
    my $route = websocket '/:foo' => sub {...};
    my $route = websocket '/:foo' => sub {...} => 'name';
    my $route = websocket '/:foo' => {foo => 'bar'} => sub {...};
    my $route = websocket '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = websocket '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"websocket">, matching only
  WebSocket handshakes. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Lite> inherits all attributes from L<Mojolicious>.
  
  =head1 METHODS
  
  L<Mojolicious::Lite> inherits all methods from L<Mojolicious>.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_LITE

$fatpacked{"Mojolicious/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN';
  package Mojolicious::Plugin;
  use Mojo::Base -base;
  
  use Carp 'croak';
  
  sub register { croak 'Method "register" not implemented by subclass' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin - Plugin base class
  
  =head1 SYNOPSIS
  
    # CamelCase plugin name
    package Mojolicious::Plugin::MyPlugin;
    use Mojo::Base 'Mojolicious::Plugin';
  
    sub register {
      my ($self, $app, $conf) = @_;
  
      # Magic here! :)
    }
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin> is an abstract base class for L<Mojolicious> plugins.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
    $plugin->register(Mojolicious->new, {foo => 'bar'});
  
  This method will be called by L<Mojolicious::Plugins> at startup time. Meant to
  be overloaded in a subclass.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN

$fatpacked{"Mojolicious/Plugin/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_CONFIG';
  package Mojolicious::Plugin::Config;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use Mojo::File 'path';
  use Mojo::Util 'decode';
  
  sub load { $_[0]->parse(decode('UTF-8', path($_[1])->slurp), @_[1, 2, 3]) }
  
  sub parse {
    my ($self, $content, $file, $conf, $app) = @_;
  
    # Run Perl code in sandbox
    my $config = eval 'package Mojolicious::Plugin::Config::Sandbox; no warnings;'
      . "sub app; local *app = sub { \$app }; use Mojo::Base -strict; $content";
    die qq{Can't load configuration from file "$file": $@} if $@;
    die qq{Configuration file "$file" did not return a hash reference.\n}
      unless ref $config eq 'HASH';
  
    return $config;
  }
  
  sub register {
    my ($self, $app, $conf) = @_;
  
    # Override
    $app->defaults(config => $app->config);
    return $app->config if $app->config->{config_override};
  
    # Config file
    my $file = $conf->{file} || $ENV{MOJO_CONFIG};
    $file ||= $app->moniker . '.' . ($conf->{ext} || 'conf');
  
    # Mode specific config file
    my $mode = $file =~ /^(.*)\.([^.]+)$/ ? join('.', $1, $app->mode, $2) : '';
  
    my $home = $app->home;
    $file = $home->child($file) unless path($file)->is_abs;
    $mode = $home->child($mode) if $mode && !path($mode)->is_abs;
    $mode = undef unless $mode && -e $mode;
  
    # Read config file
    my $config = {};
    if (-e $file) { $config = $self->load($file, $conf, $app) }
  
    # Check for default and mode specific config file
    elsif (!$conf->{default} && !$mode) {
      die qq{Configuration file "$file" missing, maybe you need to create it?\n};
    }
  
    # Merge everything
    $config = {%$config, %{$self->load($mode, $conf, $app)}} if $mode;
    $config = {%{$conf->{default}}, %$config} if $conf->{default};
    return $app->config($config)->config;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::Config - Perl-ish configuration plugin
  
  =head1 SYNOPSIS
  
    # myapp.conf (it's just Perl returning a hash)
    {
      # Just a value
      foo => "bar",
  
      # Nested data structures are fine too
      baz => [''],
  
      # You have full access to the application
      music_dir => app->home->child('music')
    };
  
    # Mojolicious
    my $config = $app->plugin('Config');
    say $config->{foo};
  
    # Mojolicious::Lite
    my $config = plugin 'Config';
    say $config->{foo};
  
    # foo.html.ep
    %= $config->{foo}
  
    # The configuration is available application-wide
    my $config = app->config;
    say $config->{foo};
  
    # Everything can be customized with options
    my $config = plugin Config => {file => '/etc/myapp.stuff'};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::Config> is a Perl-ish configuration plugin.
  
  The application object can be accessed via C<$app> or the C<app> function,
  L<strict>, L<warnings>, L<utf8> and Perl 5.10 L<features|feature> are
  automatically enabled. A default configuration filename in the application home
  directory will be generated from the value of L<Mojolicious/"moniker">
  (C<$moniker.conf>). You can extend the normal configuration file
  C<$moniker.conf> with C<mode> specific ones like C<$moniker.$mode.conf>, which
  will be detected automatically.
  
  If the configuration value C<config_override> has been set in
  L<Mojolicious/"config"> when this plugin is loaded, it will not do anything.
  
  The code of this plugin is a good example for learning to build new plugins,
  you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 OPTIONS
  
  L<Mojolicious::Plugin::Config> supports the following options.
  
  =head2 default
  
    # Mojolicious::Lite
    plugin Config => {default => {foo => 'bar'}};
  
  Default configuration, making configuration files optional.
  
  =head2 ext
  
    # Mojolicious::Lite
    plugin Config => {ext => 'stuff'};
  
  File extension for generated configuration filenames, defaults to C<conf>.
  
  =head2 file
  
    # Mojolicious::Lite
    plugin Config => {file => 'myapp.conf'};
    plugin Config => {file => '/etc/foo.stuff'};
  
  Path to configuration file, absolute or relative to the application home
  directory, defaults to the value of the C<MOJO_CONFIG> environment variable or
  C<$moniker.conf> in the application home directory.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::Config> inherits all methods from L<Mojolicious::Plugin>
  and implements the following new ones.
  
  =head2 load
  
    $plugin->load($file, $conf, $app);
  
  Loads configuration file and passes the content to L</"parse">.
  
    sub load {
      my ($self, $file, $conf, $app) = @_;
      ...
      return $self->parse($content, $file, $conf, $app);
    }
  
  =head2 parse
  
    $plugin->parse($content, $file, $conf, $app);
  
  Parse configuration file.
  
    sub parse {
      my ($self, $content, $file, $conf, $app) = @_;
      ...
      return $hash;
    }
  
  =head2 register
  
    my $config = $plugin->register(Mojolicious->new);
    my $config = $plugin->register(Mojolicious->new, {file => '/etc/app.conf'});
  
  Register plugin in L<Mojolicious> application and merge configuration.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_CONFIG

$fatpacked{"Mojolicious/Plugin/DefaultHelpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_DEFAULTHELPERS';
  package Mojolicious::Plugin::DefaultHelpers;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use Mojo::Asset::File;
  use Mojo::ByteStream;
  use Mojo::Collection;
  use Mojo::Exception;
  use Mojo::IOLoop;
  use Mojo::Util qw(deprecated dumper hmac_sha1_sum steady_time);
  use Time::HiRes qw(gettimeofday tv_interval);
  use Scalar::Util 'blessed';
  
  sub register {
    my ($self, $app) = @_;
  
    # Controller alias helpers
    for my $name (qw(app flash param stash session url_for validation)) {
      $app->helper($name => sub { shift->$name(@_) });
    }
  
    # Stash key shortcuts (should not generate log messages)
    for my $name (qw(extends layout title)) {
      $app->helper($name => sub { shift->stash($name, @_) });
    }
  
    $app->helper(accepts => sub { $_[0]->app->renderer->accepts(@_) });
    $app->helper(b       => sub { shift; Mojo::ByteStream->new(@_) });
    $app->helper(c       => sub { shift; Mojo::Collection->new(@_) });
    $app->helper(config  => sub { shift->app->config(@_) });
  
    $app->helper(content      => sub { _content(0, 0, @_) });
    $app->helper(content_for  => sub { _content(1, 0, @_) });
    $app->helper(content_with => sub { _content(0, 1, @_) });
  
    # DEPRECATED!
    $app->helper(
      delay => sub {
        deprecated 'delay helper is DEPRECATED';
        my $c  = shift;
        my $tx = $c->render_later->tx;
        Mojo::IOLoop->delay(@_)
          ->catch(sub { $c->helpers->reply->exception(pop) and undef $tx })->wait;
      }
    );
  
    $app->helper($_ => $self->can("_$_"))
      for qw(csrf_token current_route inactivity_timeout is_fresh url_with);
  
    $app->helper(dumper => sub { shift; dumper @_ });
    $app->helper(include => sub { shift->render_to_string(@_) });
  
    $app->helper("reply.$_" => $self->can("_$_")) for qw(asset file static);
  
    $app->helper('reply.exception' => sub { _development('exception', @_) });
    $app->helper('reply.not_found' => sub { _development('not_found', @_) });
  
    $app->helper('timing.begin'         => \&_timing_begin);
    $app->helper('timing.elapsed'       => \&_timing_elapsed);
    $app->helper('timing.rps'           => \&_timing_rps);
    $app->helper('timing.server_timing' => \&_timing_server_timing);
  
    $app->helper(ua => sub { shift->app->ua });
  }
  
  sub _asset {
    my $c = shift;
    $c->app->static->serve_asset($c, @_);
    $c->rendered;
  }
  
  sub _block { ref $_[0] eq 'CODE' ? $_[0]() : $_[0] }
  
  sub _content {
    my ($append, $replace, $c, $name, $content) = @_;
    $name ||= 'content';
  
    my $hash = $c->stash->{'mojo.content'} ||= {};
    if (defined $content) {
      if ($append) { $hash->{$name} .= _block($content) }
      if ($replace) { $hash->{$name} = _block($content) }
      else          { $hash->{$name} //= _block($content) }
    }
  
    return Mojo::ByteStream->new($hash->{$name} // '');
  }
  
  sub _csrf_token {
    my $c = shift;
    return $c->session->{csrf_token}
      ||= hmac_sha1_sum($$ . steady_time . rand, $c->app->secrets->[0]);
  }
  
  sub _current_route {
    return '' unless my $route = shift->match->endpoint;
    return @_ ? $route->name eq shift : $route->name;
  }
  
  sub _development {
    my ($page, $c, $e) = @_;
  
    my $app = $c->app;
    $app->log->error($e = _exception($e) ? $e : Mojo::Exception->new($e)->inspect)
      if $page eq 'exception';
  
    # Filtered stash snapshot
    my $stash = $c->stash;
    %{$stash->{snapshot} = {}} = map { $_ => $stash->{$_} }
      grep { !/^mojo\./ and defined $stash->{$_} } keys %$stash;
    $stash->{exception} = $page eq 'exception' ? $e : undef;
  
    # Render with fallbacks
    my $mode    = $app->mode;
    my $options = {
      format   => $stash->{format} || $app->renderer->default_format,
      handler  => undef,
      status   => $page eq 'exception' ? 500 : 404,
      template => "$page.$mode"
    };
    my $bundled = 'mojo/' . ($mode eq 'development' ? 'debug' : $page);
    return $c if _fallbacks($c, $options, $page, $bundled);
    _fallbacks($c, {%$options, format => 'html'}, $page, $bundled);
    return $c;
  }
  
  sub _exception { blessed $_[0] && $_[0]->isa('Mojo::Exception') }
  
  sub _fallbacks {
    my ($c, $options, $template, $bundled) = @_;
  
    # Mode specific template
    return 1 if $c->render_maybe(%$options);
  
    # Normal template
    return 1 if $c->render_maybe(%$options, template => $template);
  
    # Inline template
    my $stash = $c->stash;
    return undef unless $options->{format} eq 'html';
    delete @$stash{qw(extends layout)};
    return $c->render_maybe($bundled, %$options, handler => 'ep');
  }
  
  sub _file { _asset(shift, Mojo::Asset::File->new(path => shift)) }
  
  sub _inactivity_timeout {
    my ($c, $timeout) = @_;
    my $stream = Mojo::IOLoop->stream($c->tx->connection // '');
    $stream->timeout($timeout) if $stream;
    return $c;
  }
  
  sub _is_fresh {
    my ($c, %options) = @_;
    return $c->app->static->is_fresh($c, \%options);
  }
  
  sub _static {
    my ($c, $file) = @_;
    return !!$c->rendered if $c->app->static->serve($c, $file);
    $c->app->log->debug(qq{Static file "$file" not found});
    return !$c->helpers->reply->not_found;
  }
  
  sub _timing_begin { shift->stash->{'mojo.timing'}{shift()} = [gettimeofday] }
  
  sub _timing_elapsed {
    my ($c, $name) = @_;
    return undef unless my $started = $c->stash->{'mojo.timing'}{$name};
    return tv_interval($started, [gettimeofday()]);
  }
  
  sub _timing_rps { $_[1] == 0 ? undef : sprintf '%.3f', 1 / $_[1] }
  
  sub _timing_server_timing {
    my ($c, $metric, $desc, $dur) = @_;
    my $value = $metric;
    $value .= qq{;desc="$desc"} if defined $desc;
    $value .= ";dur=$dur"       if defined $dur;
    $c->res->headers->append('Server-Timing' => $value);
  }
  
  sub _url_with {
    my $c = shift;
    return $c->url_for(@_)->query($c->req->url->query->clone);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::DefaultHelpers - Default helpers plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    $app->plugin('DefaultHelpers');
  
    # Mojolicious::Lite
    plugin 'DefaultHelpers';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::DefaultHelpers> is a collection of helpers for
  L<Mojolicious>.
  
  This is a core plugin, that means it is always enabled and its code a good
  example for learning to build new plugins, you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 HELPERS
  
  L<Mojolicious::Plugin::DefaultHelpers> implements the following helpers.
  
  =head2 accepts
  
    my $formats = $c->accepts;
    my $format  = $c->accepts('html', 'json', 'txt');
  
  Select best possible representation for resource from C<format> C<GET>/C<POST>
  parameter, C<format> stash value or C<Accept> request header with
  L<Mojolicious::Renderer/"accepts">, defaults to returning the first extension if
  no preference could be detected.
  
    # Check if JSON is acceptable
    $c->render(json => {hello => 'world'}) if $c->accepts('json');
  
    # Check if JSON was specifically requested
    $c->render(json => {hello => 'world'}) if $c->accepts('', 'json');
  
    # Unsupported representation
    $c->render(data => '', status => 204)
      unless my $format = $c->accepts('html', 'json');
  
    # Detected representations to select from
    my @formats = @{$c->accepts};
  
  =head2 app
  
    %= app->secrets->[0]
  
  Alias for L<Mojolicious::Controller/"app">.
  
  =head2 b
  
    %= b('Joel is a slug')->slugify
  
  Turn string into a L<Mojo::ByteStream> object.
  
  =head2 c
  
    %= c('a', 'b', 'c')->shuffle->join
  
  Turn list into a L<Mojo::Collection> object.
  
  =head2 config
  
    %= config 'something'
  
  Alias for L<Mojolicious/"config">.
  
  =head2 content
  
    %= content foo => begin
      test
    % end
    %= content bar => 'Hello World!'
    %= content 'foo'
    %= content 'bar'
    %= content
  
  Store partial rendered content in a named buffer and retrieve it later,
  defaults to retrieving the named buffer C<content>, which is used by the
  renderer for the C<layout> and C<extends> features. New content will be ignored
  if the named buffer is already in use.
  
  =head2 content_for
  
    % content_for foo => begin
      test
    % end
    %= content_for 'foo'
  
  Same as L</"content">, but appends content to named buffers if they are already
  in use.
  
    % content_for message => begin
      Hello
    % end
    % content_for message => begin
      world!
    % end
    %= content 'message'
  
  =head2 content_with
  
    % content_with foo => begin
      test
    % end
    %= content_with 'foo'
  
  Same as L</"content">, but replaces content of named buffers if they are
  already in use.
  
    % content message => begin
      world!
    % end
    % content_with message => begin
      Hello <%= content 'message' %>
    % end
    %= content 'message'
  
  =head2 csrf_token
  
    %= csrf_token
  
  Get CSRF token from L</"session">, and generate one if none exists.
  
  =head2 current_route
  
    % if (current_route 'login') {
      Welcome to Mojolicious!
    % }
    %= current_route
  
  Check or get name of current route.
  
  =head2 dumper
  
    %= dumper {some => 'data'}
  
  Dump a Perl data structure with L<Mojo::Util/"dumper">, very useful for
  debugging.
  
  =head2 extends
  
    % extends 'blue';
    % extends 'blue', title => 'Blue!';
  
  Set C<extends> stash value, all additional key/value pairs get merged into the
  L</"stash">.
  
  =head2 flash
  
    %= flash 'foo'
  
  Alias for L<Mojolicious::Controller/"flash">.
  
  =head2 inactivity_timeout
  
    $c = $c->inactivity_timeout(3600);
  
  Use L<Mojo::IOLoop/"stream"> to find the current connection and increase
  timeout if possible.
  
    # Longer version
    Mojo::IOLoop->stream($c->tx->connection)->timeout(3600);
  
  =head2 include
  
    %= include 'menubar'
    %= include 'menubar', format => 'txt'
  
  Alias for L<Mojolicious::Controller/"render_to_string">.
  
  =head2 is_fresh
  
    my $bool = $c->is_fresh;
    my $bool = $c->is_fresh(etag => 'abc');
    my $bool = $c->is_fresh(last_modified => $epoch);
  
  Check freshness of request by comparing the C<If-None-Match> and
  C<If-Modified-Since> request headers to the C<ETag> and C<Last-Modified>
  response headers with L<Mojolicious::Static/"is_fresh">.
  
    # Add ETag/Last-Modified headers and check freshness before rendering
    $c->is_fresh(etag => 'abc', last_modified => 1424985708)
      ? $c->rendered(304)
      : $c->render(text => 'I  Mojolicious!');
  
  =head2 layout
  
    % layout 'green';
    % layout 'green', title => 'Green!';
  
  Set C<layout> stash value, all additional key/value pairs get merged into the
  L</"stash">.
  
  =head2 param
  
    %= param 'foo'
  
  Alias for L<Mojolicious::Controller/"param">.
  
  =head2 reply->asset
  
    $c->reply->asset(Mojo::Asset::File->new);
  
  Reply with a L<Mojo::Asset::File> or L<Mojo::Asset::Memory> object using
  L<Mojolicious::Static/"serve_asset">, and perform content negotiation with
  C<Range>, C<If-Modified-Since> and C<If-None-Match> headers.
  
    # Serve asset with custom modification time
    my $asset = Mojo::Asset::Memory->new;
    $asset->add_chunk('Hello World!')->mtime(784111777);
    $c->res->headers->content_type('text/plain');
    $c->reply->asset($asset);
  
    # Serve static file if it exists
    if (my $asset = $c->app->static->file('images/logo.png')) {
      $c->res->headers->content_type('image/png');
      $c->reply->asset($asset);
    }
  
  =head2 reply->exception
  
    $c = $c->reply->exception('Oops!');
    $c = $c->reply->exception(Mojo::Exception->new);
  
  Render the exception template C<exception.$mode.$format.*> or
  C<exception.$format.*> and set the response status code to C<500>. Also sets
  the stash values C<exception> to a L<Mojo::Exception> object and C<snapshot> to
  a copy of the L</"stash"> for use in the templates.
  
  =head2 reply->file
  
    $c->reply->file('/etc/passwd');
  
  Reply with a static file from an absolute path anywhere on the file system using
  L<Mojolicious/"static">.
  
    # Longer version
    $c->reply->asset(Mojo::Asset::File->new(path => '/etc/passwd'));
  
    # Serve file from an absolute path with a custom content type
    $c->res->headers->content_type('application/myapp');
    $c->reply->file('/home/sri/foo.txt');
  
    # Serve file from a secret application directory
    $c->reply->file($c->app->home->child('secret', 'file.txt'));
  
  =head2 reply->not_found
  
    $c = $c->reply->not_found;
  
  Render the not found template C<not_found.$mode.$format.*> or
  C<not_found.$format.*> and set the response status code to C<404>. Also sets
  the stash value C<snapshot> to a copy of the L</"stash"> for use in the
  templates.
  
  =head2 reply->static
  
    my $bool = $c->reply->static('images/logo.png');
    my $bool = $c->reply->static('../lib/MyApp.pm');
  
  Reply with a static file using L<Mojolicious/"static">, usually from the
  C<public> directories or C<DATA> sections of your application. Note that this
  helper uses a relative path, but does not protect from traversing to parent
  directories.
  
    # Serve file from a relative path with a custom content type
    $c->res->headers->content_type('application/myapp');
    $c->reply->static('foo.txt');
  
  =head2 session
  
    %= session 'foo'
  
  Alias for L<Mojolicious::Controller/"session">.
  
  =head2 stash
  
    %= stash 'foo'
    % stash foo => 'bar';
  
  Alias for L<Mojolicious::Controller/"stash">.
  
    %= stash('name') // 'Somebody'
  
  =head2 timing->begin
  
    $c->timing->begin('foo');
  
  Create named timestamp for L<"timing-E<gt>elapsed">. Note that this helper is
  EXPERIMENTAL and might change without warning!
  
  =head2 timing->elapsed
  
    my $elapsed = $c->timing->elapsed('foo');
  
  Return fractional amount of time in seconds since named timstamp has been
  created with L</"timing-E<gt>begin"> or C<undef> if no such timestamp exists.
  Note that this helper is EXPERIMENTAL and might change without warning!
  
    # Log timing information
    $c->timing->begin('database_stuff');
    ...
    my $elapsed = $c->timing->elapsed('database_stuff');
    $c->app->log->debug("Database stuff took $elapsed seconds");
  
  =head2 timing->rps
  
    my $rps = $c->timing->rps('0.001');
  
  Return fractional number of requests that could be performed in one second if
  every singe one took the given amount of time in seconds or C<undef> if the
  number is too low. Note that this helper is EXPERIMENTAL and might change
  without warning!
  
    # Log more timing information
    $c->timing->begin('web_stuff');
    ...
    my $elapsed = $c->timing->elapsed('web_stuff');
    my $rps     = $c->timing->rps($elapsed);
    $c->app->log->debug("Web stuff took $elapsed seconds ($rps per second)");
  
  =head2 timing->server_timing
  
    $c->timing->server_timing('metric');
    $c->timing->server_timing('metric', 'Some Description');
    $c->timing->server_timing('metric', 'Some Description', '0.001');
  
  Create C<Server-Timing> header with optional description and duration. Note that
  this helper is EXPERIMENTAL and might change without warning!
  
    # "Server-Timing: miss"
    $c->timing->server_timing('miss');
  
    # "Server-Timing: dc;desc=atl"
    $c->timing->server_timing('dc', 'atl');
  
    # "Server-Timing: db;desc=Database;dur=0.0001"
    $c->timing->begin('database_stuff');
    ...
    my $elapsed = $c->timing->elapsed('database_stuff');
    $c->timing->server_timing('db', 'Database', $elapsed);
  
    # "Server-Timing: miss, dc;desc=atl"
    $c->timing->server_timing('miss');
    $c->timing->server_timing('dc', 'atl');
  
  =head2 title
  
    %= title
    % title 'Welcome!';
    % title 'Welcome!', foo => 'bar';
  
  Get or set C<title> stash value, all additional key/value pairs get merged into
  the L</"stash">.
  
  =head2 ua
  
    %= ua->get('mojolicious.org')->result->dom->at('title')->text
  
  Alias for L<Mojolicious/"ua">.
  
  =head2 url_for
  
    %= url_for 'named', controller => 'bar', action => 'baz'
  
  Alias for L<Mojolicious::Controller/"url_for">.
  
    %= url_for('/index.html')->query(foo => 'bar')
  
  =head2 url_with
  
    %= url_with 'named', controller => 'bar', action => 'baz'
  
  Does the same as L</"url_for">, but inherits query parameters from the current
  request.
  
    %= url_with->query([page => 2])
  
  =head2 validation
  
    %= validation->param('foo')
  
  Alias for L<Mojolicious::Controller/"validation">.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::DefaultHelpers> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
  
  Register helpers in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_DEFAULTHELPERS

$fatpacked{"Mojolicious/Plugin/EPLRenderer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_EPLRENDERER';
  package Mojolicious::Plugin::EPLRenderer;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use Mojo::Template;
  use Mojo::Util qw(encode md5_sum);
  
  sub register {
    my ($self, $app) = @_;
    $app->renderer->add_handler(
      epl => sub { _render(@_, Mojo::Template->new, $_[1]) });
  }
  
  sub _render {
    my ($renderer, $c, $output, $options, $mt, @args) = @_;
  
    # Cached
    if ($mt->compiled) {
      $c->app->log->debug("Rendering cached @{[$mt->name]}");
      $$output = $mt->process(@args);
    }
  
    # Not cached
    else {
      my $inline = $options->{inline};
      my $name = defined $inline ? md5_sum encode('UTF-8', $inline) : undef;
      return unless defined($name //= $renderer->template_name($options));
  
      # Inline
      if (defined $inline) {
        $c->app->log->debug(qq{Rendering inline template "$name"});
        $$output = $mt->name(qq{inline template "$name"})->render($inline, @args);
      }
  
      # File
      else {
        if (my $encoding = $renderer->encoding) { $mt->encoding($encoding) }
  
        # Try template
        if (defined(my $path = $renderer->template_path($options))) {
          $c->app->log->debug(qq{Rendering template "$name"});
          $$output = $mt->name(qq{template "$name"})->render_file($path, @args);
        }
  
        # Try DATA section
        elsif (defined(my $d = $renderer->get_data_template($options))) {
          $c->app->log->debug(qq{Rendering template "$name" from DATA section});
          $$output = $mt->name(qq{template "$name" from DATA section})
            ->render($d, @args);
        }
  
        # No template
        else { $c->app->log->debug(qq{Template "$name" not found}) }
      }
    }
  
    # Exception
    die $$output if ref $$output;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::EPLRenderer - Embedded Perl Lite renderer plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    $app->plugin('EPLRenderer');
  
    # Mojolicious::Lite
    plugin 'EPLRenderer';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::EPLRenderer> is a renderer for C<epl> templates, which
  are pretty much just raw L<Mojo::Template>.
  
  This is a core plugin, that means it is always enabled and its code a good
  example for learning to build new plugins, you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::EPLRenderer> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
  
  Register renderer in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_EPLRENDERER

$fatpacked{"Mojolicious/Plugin/EPRenderer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_EPRENDERER';
  package Mojolicious::Plugin::EPRenderer;
  use Mojo::Base 'Mojolicious::Plugin::EPLRenderer';
  
  use Mojo::Template;
  use Mojo::Util qw(encode md5_sum monkey_patch);
  
  sub DESTROY { Mojo::Util::_teardown(shift->{namespace}) }
  
  sub register {
    my ($self, $app, $conf) = @_;
  
    # Auto escape by default to prevent XSS attacks
    my $ep = {auto_escape => 1, %{$conf->{template} || {}}, vars => 1};
    my $ns = $self->{namespace} = $ep->{namespace}
      //= 'Mojo::Template::Sandbox::' . md5_sum "$self";
  
    # Make "$self" and "$c" available in templates
    $ep->{prepend} = 'my $self = my $c = _C;' . ($ep->{prepend} // '');
  
    # Add "ep" handler and make it the default
    $app->renderer->default_handler('ep')->add_handler(
      $conf->{name} || 'ep' => sub {
        my ($renderer, $c, $output, $options) = @_;
  
        my $name = $options->{inline} // $renderer->template_name($options);
        return unless defined $name;
        my $key = md5_sum encode 'UTF-8', $name;
  
        my $cache = $renderer->cache;
        my $mt    = $cache->get($key);
        $cache->set($key => $mt = Mojo::Template->new($ep)) unless $mt;
  
        # Export helpers only once
        ++$self->{helpers} and _helpers($ns, $renderer->helpers)
          unless $self->{helpers};
  
        # Make current controller available and render with "epl" handler
        no strict 'refs';
        no warnings 'redefine';
        local *{"${ns}::_C"} = sub {$c};
        Mojolicious::Plugin::EPLRenderer::_render($renderer, $c, $output,
          $options, $mt, $c->stash);
      }
    );
  }
  
  sub _helpers {
    my ($class, $helpers) = @_;
    for my $method (grep {/^\w+$/} keys %$helpers) {
      my $sub = $helpers->{$method};
      monkey_patch $class, $method, sub { $class->_C->$sub(@_) };
    }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::EPRenderer - Embedded Perl renderer plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    $app->plugin('EPRenderer');
    $app->plugin(EPRenderer => {name => 'foo'});
    $app->plugin(EPRenderer => {name => 'bar', template => {line_start => '.'}});
  
    # Mojolicious::Lite
    plugin 'EPRenderer';
    plugin EPRenderer => {name => 'foo'};
    plugin EPRenderer => {name => 'bar', template => {line_start => '.'}};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::EPRenderer> is a renderer for Embedded Perl templates.
  For more information see L<Mojolicious::Guides::Rendering/"Embedded Perl">.
  
  This is a core plugin, that means it is always enabled and its code a good
  example for learning to build new plugins, you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 OPTIONS
  
  L<Mojolicious::Plugin::EPRenderer> supports the following options.
  
  =head2 name
  
    # Mojolicious::Lite
    plugin EPRenderer => {name => 'foo'};
  
  Handler name, defaults to C<ep>.
  
  =head2 template
  
    # Mojolicious::Lite
    plugin EPRenderer => {template => {line_start => '.'}};
  
  Attribute values passed to L<Mojo::Template> objects used to render templates.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::EPRenderer> inherits all methods from
  L<Mojolicious::Plugin::EPLRenderer> and implements the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
    $plugin->register(Mojolicious->new, {name => 'foo'});
  
  Register renderer in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_EPRENDERER

$fatpacked{"Mojolicious/Plugin/HeaderCondition.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_HEADERCONDITION';
  package Mojolicious::Plugin::HeaderCondition;
  use Mojo::Base 'Mojolicious::Plugin';
  
  sub register {
    my ($self, $app) = @_;
  
    $app->routes->add_condition(headers => \&_headers);
    $app->routes->add_condition(
      agent => sub { _headers(@_[0 .. 2], {'User-Agent' => $_[3]}) });
    $app->routes->add_condition(
      host => sub { _check($_[1]->req->url->to_abs->host, $_[3]) });
  }
  
  sub _check {
    my ($value, $pattern) = @_;
    return 1
      if $value && $pattern && ref $pattern eq 'Regexp' && $value =~ $pattern;
    return $value && defined $pattern && $pattern eq $value;
  }
  
  sub _headers {
    my ($route, $c, $captures, $patterns) = @_;
    return undef unless $patterns && ref $patterns eq 'HASH' && keys %$patterns;
  
    # All headers need to match
    my $headers = $c->req->headers;
    _check($headers->header($_), $patterns->{$_}) || return undef
      for keys %$patterns;
    return 1;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::HeaderCondition - Header condition plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    $app->plugin('HeaderCondition');
    $app->routes->get('/:controller/:action')
      ->over(headers => {Referer => qr/example\.com/});
  
    # Mojolicious::Lite
    plugin 'HeaderCondition';
    get '/' => (headers => {Referer => qr/example\.com/}) => sub {...};
  
    # All headers need to match
    $app->routes->get('/:controller/:action')->over(headers => {
      'X-Secret-Header' => 'Foo',
      Referer => qr/example\.com/
    });
  
    # The "agent" condition is a shortcut for the "User-Agent" header
    get '/' => (agent => qr/Firefox/) => sub {...};
  
    # The "host" condition is a shortcut for the detected host
    get '/' => (host => qr/mojolicious\.org/) => sub {...};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::HeaderCondition> is a route condition for header-based
  routes.
  
  This is a core plugin, that means it is always enabled and its code a good
  example for learning to build new plugins, you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::HeaderCondition> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
  
  Register conditions in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_HEADERCONDITION

$fatpacked{"Mojolicious/Plugin/JSONConfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_JSONCONFIG';
  package Mojolicious::Plugin::JSONConfig;
  use Mojo::Base 'Mojolicious::Plugin::Config';
  
  use Mojo::JSON 'from_json';
  use Mojo::Template;
  
  sub parse {
    my ($self, $content, $file, $conf, $app) = @_;
  
    my $config = eval { from_json $self->render($content, $file, $conf, $app) };
    die qq{Can't parse config "$file": $@} if $@;
    die qq{Invalid config "$file"} unless ref $config eq 'HASH';
  
    return $config;
  }
  
  sub register { shift->SUPER::register(shift, {ext => 'json', %{shift()}}) }
  
  sub render {
    my ($self, $content, $file, $conf, $app) = @_;
  
    # Application instance and helper
    my $prepend = q[no strict 'refs'; no warnings 'redefine';];
    $prepend .= q[my $app = shift; sub app; local *app = sub { $app };];
    $prepend .= q[use Mojo::Base -strict; no warnings 'ambiguous';];
  
    my $mt = Mojo::Template->new($conf->{template} || {})->name($file);
    my $output = $mt->prepend($prepend . $mt->prepend)->render($content, $app);
    return ref $output ? die $output : $output;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::JSONConfig - JSON configuration plugin
  
  =head1 SYNOPSIS
  
    # myapp.json (it's just JSON with embedded Perl)
    {
      %# Just a value
      "foo": "bar",
  
      %# Nested data structures are fine too
      "baz": [""],
  
      %# You have full access to the application
      "music_dir": "<%= app->home->child('music') %>"
    }
  
    # Mojolicious
    my $config = $app->plugin('JSONConfig');
    say $config->{foo};
  
    # Mojolicious::Lite
    my $config = plugin 'JSONConfig';
    say $config->{foo};
  
    # foo.html.ep
    %= $config->{foo}
  
    # The configuration is available application-wide
    my $config = app->config;
    say $config->{foo};
  
    # Everything can be customized with options
    my $config = plugin JSONConfig => {file => '/etc/myapp.conf'};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::JSONConfig> is a JSON configuration plugin that
  preprocesses its input with L<Mojo::Template>.
  
  The application object can be accessed via C<$app> or the C<app> function. A
  default configuration filename in the application home directory will be
  generated from the value of L<Mojolicious/"moniker"> (C<$moniker.json>). You can
  extend the normal configuration file C<$moniker.json> with C<mode> specific ones
  like C<$moniker.$mode.json>, which will be detected automatically.
  
  If the configuration value C<config_override> has been set in
  L<Mojolicious/"config"> when this plugin is loaded, it will not do anything.
  
  The code of this plugin is a good example for learning to build new plugins,
  you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 OPTIONS
  
  L<Mojolicious::Plugin::JSONConfig> inherits all options from
  L<Mojolicious::Plugin::Config> and supports the following new ones.
  
  =head2 template
  
    # Mojolicious::Lite
    plugin JSONConfig => {template => {line_start => '.'}};
  
  Attribute values passed to L<Mojo::Template> object used to preprocess
  configuration files.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::JSONConfig> inherits all methods from
  L<Mojolicious::Plugin::Config> and implements the following new ones.
  
  =head2 parse
  
    $plugin->parse($content, $file, $conf, $app);
  
  Process content with L</"render"> and parse it with L<Mojo::JSON>.
  
    sub parse {
      my ($self, $content, $file, $conf, $app) = @_;
      ...
      $content = $self->render($content, $file, $conf, $app);
      ...
      return $hash;
    }
  
  =head2 register
  
    my $config = $plugin->register(Mojolicious->new);
    my $config = $plugin->register(Mojolicious->new, {file => '/etc/foo.conf'});
  
  Register plugin in L<Mojolicious> application and merge configuration.
  
  =head2 render
  
    $plugin->render($content, $file, $conf, $app);
  
  Process configuration file with L<Mojo::Template>.
  
    sub render {
      my ($self, $content, $file, $conf, $app) = @_;
      ...
      return $content;
    }
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_JSONCONFIG

$fatpacked{"Mojolicious/Plugin/Mount.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_MOUNT';
  package Mojolicious::Plugin::Mount;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use Mojo::Server;
  
  sub register {
    my ($self, $app, $conf) = @_;
  
    my $path  = (keys %$conf)[0];
    my $embed = Mojo::Server->new->load_app($conf->{$path});
    $embed->secrets($app->secrets);
  
    # Extract host
    my $host;
    ($host, $path) = ($1 ? qr/^(?:.*\.)?\Q$2\E$/i : qr/^\Q$2\E$/i, $3)
      if $path =~ m!^(\*\.)?([^/]+)(/.*)?$!;
  
    my $route = $app->routes->route($path)->detour(app => $embed);
    return $host ? $route->over(host => $host) : $route;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::Mount - Application mount plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    my $route = $app->plugin(Mount => {'/prefix' => '/home/sri/myapp.pl'});
  
    # Mojolicious::Lite
    my $route = plugin Mount => {'/prefix' => '/home/sri/myapp.pl'};
  
    # Adjust the generated route and mounted application
    my $example = plugin Mount => {'/example' => '/home/sri/example.pl'};
    $example->to(message => 'It works great!');
    my $app = $example->pattern->defaults->{app};
    $app->config(foo => 'bar');
    $app->log(app->log);
  
    # Mount application with host
    plugin Mount => {'example.com' => '/home/sri/myapp.pl'};
  
    # Host and path
    plugin Mount => {'example.com/myapp' => '/home/sri/myapp.pl'};
  
    # Or even hosts with wildcard subdomains
    plugin Mount => {'*.example.com/myapp' => '/home/sri/myapp.pl'};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::Mount> is a plugin that allows you to mount whole
  L<Mojolicious> applications.
  
  The code of this plugin is a good example for learning to build new plugins,
  you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::Mount> inherits all methods from L<Mojolicious::Plugin>
  and implements the following new ones.
  
  =head2 register
  
    my $route = $plugin->register(Mojolicious->new, {'/foo' => '/some/app.pl'});
  
  Mount L<Mojolicious> application and return the generated route, which is
  usually a L<Mojolicious::Routes::Route> object.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_MOUNT

$fatpacked{"Mojolicious/Plugin/PODRenderer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_PODRENDERER';
  package Mojolicious::Plugin::PODRenderer;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use Mojo::Asset::File;
  use Mojo::ByteStream;
  use Mojo::DOM;
  use Mojo::File 'path';
  use Mojo::URL;
  use Pod::Simple::XHTML;
  use Pod::Simple::Search;
  
  sub register {
    my ($self, $app, $conf) = @_;
  
    my $preprocess = $conf->{preprocess} || 'ep';
    $app->renderer->add_handler(
      $conf->{name} || 'pod' => sub {
        my ($renderer, $c, $output, $options) = @_;
        $renderer->handlers->{$preprocess}($renderer, $c, $output, $options);
        $$output = _pod_to_html($$output) if defined $$output;
      }
    );
  
    $app->helper(
      pod_to_html => sub { shift; Mojo::ByteStream->new(_pod_to_html(@_)) });
  
    # Perldoc browser
    return undef if $conf->{no_perldoc};
    my $defaults = {module => 'Mojolicious/Guides'};
    return $app->routes->any(
      '/perldoc/:module' => $defaults => [module => qr/[^.]+/] => \&_perldoc);
  }
  
  sub _indentation {
    (sort map {/^(\s+)/} @{shift()})[0];
  }
  
  sub _html {
    my ($c, $src) = @_;
  
    # Rewrite links
    my $dom     = Mojo::DOM->new(_pod_to_html($src));
    my $perldoc = $c->url_for('/perldoc/');
    $_->{href} =~ s!^https://metacpan\.org/pod/!$perldoc!
      and $_->{href} =~ s!::!/!gi
      for $dom->find('a[href]')->map('attr')->each;
  
    # Rewrite code blocks for syntax highlighting and correct indentation
    for my $e ($dom->find('pre > code')->each) {
      next if (my $str = $e->content) =~ /^\s*(?:\$|Usage:)\s+/m;
      next unless $str =~ /[\$\@\%]\w|-&gt;\w|^use\s+\w/m;
      my $attrs = $e->attr;
      my $class = $attrs->{class};
      $attrs->{class} = defined $class ? "$class prettyprint" : 'prettyprint';
    }
  
    # Rewrite headers
    my $toc = Mojo::URL->new->fragment('toc');
    my @parts;
    for my $e ($dom->find('h1, h2, h3, h4')->each) {
  
      push @parts, [] if $e->tag eq 'h1' || !@parts;
      my $link = Mojo::URL->new->fragment($e->{id});
      push @{$parts[-1]}, my $text = $e->all_text, $link;
      my $permalink = $c->link_to('#' => $link, class => 'permalink');
      $e->content($permalink . $c->link_to($text => $toc));
    }
  
    # Try to find a title
    my $title = 'Perldoc';
    $dom->find('h1 + p')->first(sub { $title = shift->text });
  
    # Combine everything to a proper response
    $c->content_for(perldoc => "$dom");
    $c->render('mojo/perldoc', title => $title, parts => \@parts);
  }
  
  sub _perldoc {
    my $c = shift;
  
    # Find module or redirect to CPAN
    my $module = join '::', split('/', $c->param('module'));
    $c->stash(cpan => "https://metacpan.org/pod/$module");
    my $path
      = Pod::Simple::Search->new->find($module, map { $_, "$_/pods" } @INC);
    return $c->redirect_to($c->stash('cpan')) unless $path && -r $path;
  
    my $src = path($path)->slurp;
    $c->respond_to(txt => {data => $src}, html => sub { _html($c, $src) });
  }
  
  sub _pod_to_html {
    return '' unless defined(my $pod = ref $_[0] eq 'CODE' ? shift->() : shift);
  
    my $parser = Pod::Simple::XHTML->new;
    $parser->perldoc_url_prefix('https://metacpan.org/pod/');
    $parser->$_('') for qw(html_header html_footer);
    $parser->strip_verbatim_indent(\&_indentation);
    $parser->output_string(\(my $output));
    return $@ unless eval { $parser->parse_string_document("$pod"); 1 };
  
    return $output;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::PODRenderer - POD renderer plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious (with documentation browser under "/perldoc")
    my $route = $app->plugin('PODRenderer');
    my $route = $app->plugin(PODRenderer => {name => 'foo'});
    my $route = $app->plugin(PODRenderer => {preprocess => 'epl'});
  
    # Mojolicious::Lite (with documentation browser under "/perldoc")
    my $route = plugin 'PODRenderer';
    my $route = plugin PODRenderer => {name => 'foo'};
    my $route = plugin PODRenderer => {preprocess => 'epl'};
  
    # Without documentation browser
    plugin PODRenderer => {no_perldoc => 1};
  
    # foo.html.ep
    %= pod_to_html "=head1 TEST\n\nC<123>"
  
    # foo.html.pod
    =head1 <%= uc 'test' %>
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::PODRenderer> is a renderer for true Perl hackers, rawr!
  
  The code of this plugin is a good example for learning to build new plugins,
  you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 OPTIONS
  
  L<Mojolicious::Plugin::PODRenderer> supports the following options.
  
  =head2 name
  
    # Mojolicious::Lite
    plugin PODRenderer => {name => 'foo'};
  
  Handler name, defaults to C<pod>.
  
  =head2 no_perldoc
  
    # Mojolicious::Lite
    plugin PODRenderer => {no_perldoc => 1};
  
  Disable L<Mojolicious::Guides> documentation browser that will otherwise be
  available under C</perldoc>.
  
  =head2 preprocess
  
    # Mojolicious::Lite
    plugin PODRenderer => {preprocess => 'epl'};
  
  Name of handler used to preprocess POD, defaults to C<ep>.
  
  =head1 HELPERS
  
  L<Mojolicious::Plugin::PODRenderer> implements the following helpers.
  
  =head2 pod_to_html
  
    %= pod_to_html '=head2 lalala'
    <%= pod_to_html begin %>=head2 lalala<% end %>
  
  Render POD to HTML without preprocessing.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::PODRenderer> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  =head2 register
  
    my $route = $plugin->register(Mojolicious->new);
    my $route = $plugin->register(Mojolicious->new, {name => 'foo'});
  
  Register renderer and helper in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_PODRENDERER

$fatpacked{"Mojolicious/Plugin/TagHelpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_TAGHELPERS';
  package Mojolicious::Plugin::TagHelpers;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use Mojo::ByteStream;
  use Mojo::DOM::HTML 'tag_to_html';
  use Scalar::Util 'blessed';
  
  sub register {
    my ($self, $app) = @_;
  
    # Text field variations
    my @time = qw(date month time week);
    for my $name (@time, qw(color email number range search tel text url)) {
      $app->helper("${name}_field" => sub { _input(@_, type => $name) });
    }
    $app->helper(datetime_field => sub { _input(@_, type => 'datetime-local') });
  
    my @helpers = (
      qw(csrf_field form_for hidden_field javascript label_for link_to),
      qw(select_field stylesheet submit_button tag_with_error text_area)
    );
    $app->helper($_ => __PACKAGE__->can("_$_")) for @helpers;
  
    $app->helper(button_to => sub { _button_to(0, @_) });
    $app->helper(check_box => sub { _input(@_, type => 'checkbox') });
    $app->helper(csrf_button_to => sub { _button_to(1, @_) });
    $app->helper(file_field => sub { _empty_field('file', @_) });
    $app->helper(image => sub { _tag('img', src => shift->url_for(shift), @_) });
    $app->helper(input_tag      => sub { _input(@_) });
    $app->helper(password_field => sub { _empty_field('password', @_) });
    $app->helper(radio_button   => sub { _input(@_, type => 'radio') });
  
    # "t" is just a shortcut for the "tag" helper
    $app->helper($_ => sub { shift; _tag(@_) }) for qw(t tag);
  }
  
  sub _button_to {
    my ($csrf, $c, $text) = (shift, shift, shift);
    my $prefix = $csrf ? _csrf_field($c) : '';
    return _form_for($c, @_, sub { $prefix . _submit_button($c, $text) });
  }
  
  sub _csrf_field {
    my $c = shift;
    return _hidden_field($c, csrf_token => $c->helpers->csrf_token, @_);
  }
  
  sub _empty_field {
    my ($type, $c, $name) = (shift, shift, shift);
    return _validation($c, $name, 'input', name => $name, @_, type => $type);
  }
  
  sub _form_for {
    my ($c, @url) = (shift, shift);
    push @url, shift if ref $_[0] eq 'HASH';
  
    # Method detection
    my $r      = $c->app->routes->lookup($url[0]);
    my $method = $r ? $r->suggested_method : 'GET';
    my @post   = $method ne 'GET' ? (method => 'POST') : ();
  
    my $url = $c->url_for(@url);
    $url->query({_method => $method}) if @post && $method ne 'POST';
    return _tag('form', action => $url, @post, @_);
  }
  
  sub _hidden_field {
    my ($c, $name, $value) = (shift, shift, shift);
    return _tag('input', name => $name, value => $value, @_, type => 'hidden');
  }
  
  sub _input {
    my ($c, $name) = (shift, shift);
    my %attrs = @_ % 2 ? (value => shift, @_) : @_;
  
    if (my @values = @{$c->every_param($name)}) {
  
      # Checkbox or radiobutton
      my $type = $attrs{type} || '';
      if ($type eq 'checkbox' || $type eq 'radio') {
        my $value = $attrs{value} // 'on';
        delete $attrs{checked};
        $attrs{checked} = undef if grep { $_ eq $value } @values;
      }
  
      # Others
      else { $attrs{value} = $values[-1] }
    }
  
    return _validation($c, $name, 'input', name => $name, %attrs);
  }
  
  sub _javascript {
    my $c = shift;
    my $content
      = ref $_[-1] eq 'CODE' ? "//<![CDATA[\n" . pop->() . "\n//]]>" : '';
    my @src = @_ % 2 ? (src => $c->url_for(shift)) : ();
    return _tag('script', @src, @_, sub {$content});
  }
  
  sub _label_for {
    my ($c, $name) = (shift, shift);
    my $content = ref $_[-1] eq 'CODE' ? pop : shift;
    return _validation($c, $name, 'label', for => $name, @_, $content);
  }
  
  sub _link_to {
    my ($c, $content) = (shift, shift);
    my @url = ($content);
  
    # Content
    unless (ref $_[-1] eq 'CODE') {
      @url = (shift);
      push @_, $content;
    }
  
    # Captures
    push @url, shift if ref $_[0] eq 'HASH';
  
    return _tag('a', href => $c->url_for(@url), @_);
  }
  
  sub _option {
    my ($values, $pair) = @_;
  
    $pair = [$pair => $pair] unless ref $pair eq 'ARRAY';
    my %attrs = (value => $pair->[1], @$pair[2 .. $#$pair]);
    delete $attrs{selected} if keys %$values;
    $attrs{selected} = undef if $values->{$pair->[1]};
  
    return _tag('option', %attrs, $pair->[0]);
  }
  
  sub _select_field {
    my ($c, $name, $options, %attrs) = (shift, shift, shift, @_);
  
    my %values = map { $_ => 1 } @{$c->every_param($name)};
  
    my $groups = '';
    for my $group (@$options) {
  
      # "optgroup" tag
      if (blessed $group && $group->isa('Mojo::Collection')) {
        my ($label, $values, %attrs) = @$group;
        my $content = join '', map { _option(\%values, $_) } @$values;
        $groups .= _tag('optgroup', label => $label, %attrs, sub {$content});
      }
  
      # "option" tag
      else { $groups .= _option(\%values, $group) }
    }
  
    return _validation($c, $name, 'select', name => $name, %attrs, sub {$groups});
  }
  
  sub _stylesheet {
    my $c = shift;
    my $content
      = ref $_[-1] eq 'CODE' ? "/*<![CDATA[*/\n" . pop->() . "\n/*]]>*/" : '';
    return _tag('style', @_, sub {$content}) unless @_ % 2;
    return _tag('link', rel => 'stylesheet', href => $c->url_for(shift), @_);
  }
  
  sub _submit_button {
    my ($c, $value) = (shift, shift // 'Ok');
    return _tag('input', value => $value, @_, type => 'submit');
  }
  
  sub _tag { Mojo::ByteStream->new(tag_to_html(@_)) }
  
  sub _tag_with_error {
    my ($c, $tag) = (shift, shift);
    my ($content, %attrs) = (@_ % 2 ? pop : undef, @_);
    $attrs{class} .= $attrs{class} ? ' field-with-error' : 'field-with-error';
    return _tag($tag, %attrs, defined $content ? $content : ());
  }
  
  sub _text_area {
    my ($c, $name) = (shift, shift);
  
    my $cb = ref $_[-1] eq 'CODE' ? pop : undef;
    my $content = @_ % 2 ? shift : undef;
    $content = $c->param($name) // $content // $cb // '';
  
    return _validation($c, $name, 'textarea', name => $name, @_, $content);
  }
  
  sub _validation {
    my ($c, $name) = (shift, shift);
    return _tag(@_) unless $c->validation->has_error($name);
    return $c->helpers->tag_with_error(@_);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::TagHelpers - Tag helpers plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    $app->plugin('TagHelpers');
  
    # Mojolicious::Lite
    plugin 'TagHelpers';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::TagHelpers> is a collection of HTML tag helpers for
  L<Mojolicious>, based on the
  L<HTML Living Standard|https://html.spec.whatwg.org>.
  
  Most form helpers can automatically pick up previous input values and will show
  them as default. You can also use
  L<Mojolicious::Plugin::DefaultHelpers/"param"> to set them manually and let
  necessary attributes always be generated automatically.
  
    % param country => 'germany' unless param 'country';
    <%= radio_button country => 'germany' %> Germany
    <%= radio_button country => 'france'  %> France
    <%= radio_button country => 'uk'      %> UK
  
  For fields that failed validation with L<Mojolicious::Controller/"validation">
  the C<field-with-error> class will be automatically added through
  L</"tag_with_error">, to make styling with CSS easier.
  
    <input class="field-with-error" name="age" type="text" value="250">
  
  This is a core plugin, that means it is always enabled and its code a good
  example for learning how to build new plugins, you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 HELPERS
  
  L<Mojolicious::Plugin::TagHelpers> implements the following helpers.
  
  =head2 button_to
  
    %= button_to Test => 'some_get_route'
    %= button_to Test => some_get_route => {id => 23} => (class => 'menu')
    %= button_to Test => 'http://example.com/test' => (class => 'menu')
    %= button_to Remove => 'some_delete_route'
  
  Generate portable C<form> tag with L</"form_for">, containing a single button.
  
    <form action="/path/to/get/route">
      <input type="submit" value="Test">
    </form>
    <form action="/path/to/get/route/23" class="menu">
      <input type="submit" value="Test">
    </form>
    <form action="http://example.com/test" class="menu">
      <input type="submit" value="Test">
    </form>
    <form action="/path/to/delete/route?_method=DELETE" method="POST">
      <input type="submit" value="Remove">
    </form>
  
  =head2 check_box
  
    %= check_box 'employed'
    %= check_box employed => 1
    %= check_box employed => 1, checked => undef, id => 'foo'
  
  Generate C<input> tag of type C<checkbox>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="employed" type="checkbox">
    <input name="employed" type="checkbox" value="1">
    <input checked id="foo" name="employed" type="checkbox" value="1">
  
  =head2 color_field
  
    %= color_field 'background'
    %= color_field background => '#ffffff'
    %= color_field background => '#ffffff', id => 'foo'
  
  Generate C<input> tag of type C<color>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="background" type="color">
    <input name="background" type="color" value="#ffffff">
    <input id="foo" name="background" type="color" value="#ffffff">
  
  =head2 csrf_button_to
  
    %= csrf_button_to Remove => 'some_delete_route'
  
  Same as L</"button_to">, but also includes a L</"csrf_field">.
  
    <form action="/path/to/delete/route?_method=DELETE" method="POST">
      <input name="csrf_token" type="hidden" value="fa6a08...">
      <input type="submit" value="Remove">
    </form>
  
  =head2 csrf_field
  
    %= csrf_field
  
  Generate C<input> tag of type C<hidden> with
  L<Mojolicious::Plugin::DefaultHelpers/"csrf_token">.
  
    <input name="csrf_token" type="hidden" value="fa6a08...">
  
  =head2 date_field
  
    %= date_field 'end'
    %= date_field end => '2012-12-21'
    %= date_field end => '2012-12-21', id => 'foo'
  
  Generate C<input> tag of type C<date>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="end" type="date">
    <input name="end" type="date" value="2012-12-21">
    <input id="foo" name="end" type="date" value="2012-12-21">
  
  =head2 datetime_field
  
    %= datetime_field 'end'
    %= datetime_field end => '2012-12-21T23:59:59'
    %= datetime_field end => '2012-12-21T23:59:59', id => 'foo'
  
  Generate C<input> tag of type C<datetime-local>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="end" type="datetime-local">
    <input name="end" type="datetime-local" value="2012-12-21T23:59:59">
    <input id="foo" name="end" type="datetime-local" value="2012-12-21T23:59:59">
  
  =head2 email_field
  
    %= email_field 'notify'
    %= email_field notify => 'nospam@example.com'
    %= email_field notify => 'nospam@example.com', id => 'foo'
  
  Generate C<input> tag of type C<email>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="notify" type="email">
    <input name="notify" type="email" value="nospam@example.com">
    <input id="foo" name="notify" type="email" value="nospam@example.com">
  
  =head2 file_field
  
    %= file_field 'avatar'
    %= file_field 'avatar', id => 'foo'
  
  Generate C<input> tag of type C<file>.
  
    <input name="avatar" type="file">
    <input id="foo" name="avatar" type="file">
  
  =head2 form_for
  
    %= form_for login => begin
      %= text_field 'first_name'
      %= submit_button
    % end
    %= form_for login => {format => 'txt'} => (method => 'POST') => begin
      %= text_field 'first_name'
      %= submit_button
    % end
    %= form_for '/login' => (enctype => 'multipart/form-data') => begin
      %= text_field 'first_name', disabled => 'disabled'
      %= submit_button
    % end
    %= form_for 'http://example.com/login' => (method => 'POST') => begin
      %= text_field 'first_name'
      %= submit_button
    % end
    %= form_for some_delete_route => begin
      %= submit_button 'Remove'
    % end
  
  Generate portable C<form> tag with L<Mojolicious::Controller/"url_for">. For
  routes that do not allow C<GET>, a C<method> attribute with the value C<POST>
  will be automatically added. And for methods other than C<GET> or C<POST>, an
  C<_method> query parameter will be added as well.
  
    <form action="/path/to/login">
      <input name="first_name" type="text">
      <input type="submit" value="Ok">
    </form>
    <form action="/path/to/login.txt" method="POST">
      <input name="first_name" type="text">
      <input type="submit" value="Ok">
    </form>
    <form action="/path/to/login" enctype="multipart/form-data">
      <input disabled="disabled" name="first_name" type="text">
      <input type="submit" value="Ok">
    </form>
    <form action="http://example.com/login" method="POST">
      <input name="first_name" type="text">
      <input type="submit" value="Ok">
    </form>
    <form action="/path/to/delete/route?_method=DELETE" method="POST">
      <input type="submit" value="Remove">
    </form>
  
  =head2 hidden_field
  
    %= hidden_field foo => 'bar'
    %= hidden_field foo => 'bar', id => 'bar'
  
  Generate C<input> tag of type C<hidden>.
  
    <input name="foo" type="hidden" value="bar">
    <input id="bar" name="foo" type="hidden" value="bar">
  
  =head2 image
  
    %= image '/images/foo.png'
    %= image '/images/foo.png', alt => 'Foo'
  
  Generate portable C<img> tag.
  
    <img src="/path/to/images/foo.png">
    <img alt="Foo" src="/path/to/images/foo.png">
  
  =head2 input_tag
  
    %= input_tag 'first_name'
    %= input_tag first_name => 'Default'
    %= input_tag 'employed', type => 'checkbox'
  
  Generate C<input> tag. Previous input values will automatically get picked up
  and shown as default.
  
    <input name="first_name">
    <input name="first_name" value="Default">
    <input name="employed" type="checkbox">
  
  =head2 javascript
  
    %= javascript '/script.js'
    %= javascript '/script.js', defer => undef
    %= javascript begin
      var a = 'b';
    % end
  
  Generate portable C<script> tag for JavaScript asset.
  
    <script src="/path/to/script.js"></script>
    <script defer src="/path/to/script.js"></script>
    <script><![CDATA[
      var a = 'b';
    ]]></script>
  
  =head2 label_for
  
    %= label_for first_name => 'First name'
    %= label_for first_name => 'First name', class => 'user'
    %= label_for first_name => begin
      First name
    % end
    %= label_for first_name => (class => 'user') => begin
      First name
    % end
  
  Generate C<label> tag.
  
    <label for="first_name">First name</label>
    <label class="user" for="first_name">First name</label>
    <label for="first_name">
      First name
    </label>
    <label class="user" for="first_name">
      First name
    </label>
  
  =head2 link_to
  
    %= link_to Home => 'index'
    %= link_to Home => 'index' => {format => 'txt'} => (class => 'menu')
    %= link_to index => {format => 'txt'} => (class => 'menu') => begin
      Home
    % end
    %= link_to Contact => 'mailto:sri@example.com'
    <%= link_to index => begin %>Home<% end %>
    <%= link_to '/file.txt' => begin %>File<% end %>
    <%= link_to 'https://mojolicious.org' => begin %>Mojolicious<% end %>
    <%= link_to url_for->query(foo => 'bar')->to_abs => begin %>Retry<% end %>
  
  Generate portable C<a> tag with L<Mojolicious::Controller/"url_for">, defaults
  to using the capitalized link target as content.
  
    <a href="/path/to/index">Home</a>
    <a class="menu" href="/path/to/index.txt">Home</a>
    <a class="menu" href="/path/to/index.txt">
      Home
    </a>
    <a href="mailto:sri@example.com">Contact</a>
    <a href="/path/to/index">Home</a>
    <a href="/path/to/file.txt">File</a>
    <a href="https://mojolicious.org">Mojolicious</a>
    <a href="http://127.0.0.1:3000/current/path?foo=bar">Retry</a>
  
  =head2 month_field
  
    %= month_field 'vacation'
    %= month_field vacation => '2012-12'
    %= month_field vacation => '2012-12', id => 'foo'
  
  Generate C<input> tag of type C<month>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="vacation" type="month">
    <input name="vacation" type="month" value="2012-12">
    <input id="foo" name="vacation" type="month" value="2012-12">
  
  =head2 number_field
  
    %= number_field 'age'
    %= number_field age => 25
    %= number_field age => 25, id => 'foo', min => 0, max => 200
  
  Generate C<input> tag of type C<number>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="age" type="number">
    <input name="age" type="number" value="25">
    <input id="foo" max="200" min="0" name="age" type="number" value="25">
  
  =head2 password_field
  
    %= password_field 'pass'
    %= password_field 'pass', id => 'foo'
  
  Generate C<input> tag of type C<password>.
  
    <input name="pass" type="password">
    <input id="foo" name="pass" type="password">
  
  =head2 radio_button
  
    %= radio_button 'test'
    %= radio_button country => 'germany'
    %= radio_button country => 'germany', checked => undef, id => 'foo'
  
  Generate C<input> tag of type C<radio>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="test" type="radio">
    <input name="country" type="radio" value="germany">
    <input checked id="foo" name="country" type="radio" value="germany">
  
  =head2 range_field
  
    %= range_field 'age'
    %= range_field age => 25
    %= range_field age => 25, id => 'foo', min => 0, max => 200
  
  Generate C<input> tag of type C<range>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="age" type="range">
    <input name="age" type="range" value="25">
    <input id="foo" max="200" min="200" name="age" type="range" value="25">
  
  =head2 search_field
  
    %= search_field 'q'
    %= search_field q => 'perl'
    %= search_field q => 'perl', id => 'foo'
  
  Generate C<input> tag of type C<search>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="q" type="search">
    <input name="q" type="search" value="perl">
    <input id="foo" name="q" type="search" value="perl">
  
  =head2 select_field
  
    %= select_field country => ['de', 'en']
    %= select_field country => [[Germany => 'de'], 'en'], id => 'eu'
    %= select_field country => [[Germany => 'de', selected => 'selected'], 'en']
    %= select_field country => [c(EU => [[Germany => 'de'], 'en'], id => 'eu')]
    %= select_field country => [c(EU => ['de', 'en']), c(Asia => ['cn', 'jp'])]
  
  Generate C<select> and C<option> tags from array references and C<optgroup>
  tags from L<Mojo::Collection> objects. Previous input values will automatically
  get picked up and shown as default.
  
    <select name="country">
      <option value="de">de</option>
      <option value="en">en</option>
    </select>
    <select id="eu" name="country">
      <option value="de">Germany</option>
      <option value="en">en</option>
    </select>
    <select name="country">
      <option selected="selected" value="de">Germany</option>
      <option value="en">en</option>
    </select>
    <select name="country">
      <optgroup id="eu" label="EU">
        <option value="de">Germany</option>
        <option value="en">en</option>
      </optgroup>
    </select>
    <select name="country">
      <optgroup label="EU">
        <option value="de">de</option>
        <option value="en">en</option>
      </optgroup>
      <optgroup label="Asia">
        <option value="cn">cn</option>
        <option value="jp">jp</option>
      </optgroup>
    </select>
  
  =head2 stylesheet
  
    %= stylesheet '/foo.css'
    %= stylesheet '/foo.css', title => 'Foo style'
    %= stylesheet begin
      body {color: #000}
    % end
  
  Generate portable C<style> or C<link> tag for CSS asset.
  
    <link href="/path/to/foo.css" rel="stylesheet">
    <link href="/path/to/foo.css" rel="stylesheet" title="Foo style">
    <style><![CDATA[
      body {color: #000}
    ]]></style>
  
  =head2 submit_button
  
    %= submit_button
    %= submit_button 'Ok!', id => 'foo'
  
  Generate C<input> tag of type C<submit>.
  
    <input type="submit" value="Ok">
    <input id="foo" type="submit" value="Ok!">
  
  =head2 t
  
    %= t div => 'test & 123'
  
  Alias for L</"tag">.
  
    <div>test &amp; 123</div>
  
  =head2 tag
  
    %= tag 'br'
    %= tag 'div'
    %= tag 'div', id => 'foo', hidden => undef
    %= tag 'div', 'test & 123'
    %= tag 'div', id => 'foo', 'test & 123'
    %= tag 'div', data => {my_id => 1, Name => 'test'}, 'test & 123'
    %= tag div => begin
      test & 123
    % end
    <%= tag div => (id => 'foo') => begin %>test & 123<% end %>
  
  Alias for L<Mojo::DOM/"new_tag">.
  
    <br>
    <div></div>
    <div id="foo" hidden></div>
    <div>test &amp; 123</div>
    <div id="foo">test &amp; 123</div>
    <div data-my-id="1" data-name="test">test &amp; 123</div>
    <div>
      test & 123
    </div>
    <div id="foo">test & 123</div>
  
  Very useful for reuse in more specific tag helpers.
  
    my $output = $c->tag('meta');
    my $output = $c->tag('meta', charset => 'UTF-8');
    my $output = $c->tag('div', '<p>This will be escaped</p>');
    my $output = $c->tag('div', sub { '<p>This will not be escaped</p>' });
  
  Results are automatically wrapped in L<Mojo::ByteStream> objects to prevent
  accidental double escaping in C<ep> templates.
  
  =head2 tag_with_error
  
    %= tag_with_error 'input', class => 'foo'
  
  Same as L</"tag">, but adds the class C<field-with-error>.
  
    <input class="foo field-with-error">
  
  =head2 tel_field
  
    %= tel_field 'work'
    %= tel_field work => '123456789'
    %= tel_field work => '123456789', id => 'foo'
  
  Generate C<input> tag of type C<tel>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="work" type="tel">
    <input name="work" type="tel" value="123456789">
    <input id="foo" name="work" type="tel" value="123456789">
  
  =head2 text_area
  
    %= text_area 'story'
    %= text_area 'story', cols => 40
    %= text_area story => 'Default', cols => 40
    %= text_area story => (cols => 40) => begin
      Default
    % end
  
  Generate C<textarea> tag. Previous input values will automatically get picked
  up and shown as default.
  
    <textarea name="story"></textarea>
    <textarea cols="40" name="story"></textarea>
    <textarea cols="40" name="story">Default</textarea>
    <textarea cols="40" name="story">
      Default
    </textarea>
  
  =head2 text_field
  
    %= text_field 'first_name'
    %= text_field first_name => 'Default'
    %= text_field first_name => 'Default', class => 'user'
  
  Generate C<input> tag of type C<text>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="first_name" type="text">
    <input name="first_name" type="text" value="Default">
    <input class="user" name="first_name" type="text" value="Default">
  
  =head2 time_field
  
    %= time_field 'start'
    %= time_field start => '23:59:59'
    %= time_field start => '23:59:59', id => 'foo'
  
  Generate C<input> tag of type C<time>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="start" type="time">
    <input name="start" type="time" value="23:59:59">
    <input id="foo" name="start" type="time" value="23:59:59">
  
  =head2 url_field
  
    %= url_field 'address'
    %= url_field address => 'https://mojolicious.org'
    %= url_field address => 'https://mojolicious.org', id => 'foo'
  
  Generate C<input> tag of type C<url>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="address" type="url">
    <input name="address" type="url" value="https://mojolicious.org">
    <input id="foo" name="address" type="url" value="https://mojolicious.org">
  
  =head2 week_field
  
    %= week_field 'vacation'
    %= week_field vacation => '2012-W17'
    %= week_field vacation => '2012-W17', id => 'foo'
  
  Generate C<input> tag of type C<week>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="vacation" type="week">
    <input name="vacation" type="week" value="2012-W17">
    <input id="foo" name="vacation" type="week" value="2012-W17">
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::TagHelpers> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
  
  Register helpers in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_TAGHELPERS

$fatpacked{"Mojolicious/Plugins.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGINS';
  package Mojolicious::Plugins;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Mojo::Loader 'load_class';
  use Mojo::Util 'camelize';
  
  has namespaces => sub { ['Mojolicious::Plugin'] };
  
  sub emit_chain {
    my ($self, $name, @args) = @_;
  
    my $wrapper;
    for my $cb (reverse @{$self->subscribers($name)}) {
      my $next = $wrapper;
      $wrapper = sub { $cb->($next, @args) };
    }
  
    !$wrapper ? return : return $wrapper->();
  }
  
  sub emit_hook {
    my $self = shift;
    for my $cb (@{$self->subscribers(shift)}) { $cb->(@_) }
    return $self;
  }
  
  sub emit_hook_reverse {
    my $self = shift;
    for my $cb (reverse @{$self->subscribers(shift)}) { $cb->(@_) }
    return $self;
  }
  
  sub load_plugin {
    my ($self, $name) = @_;
  
    # Try all namespaces and full module name
    my $suffix = $name =~ /^[a-z]/ ? camelize $name : $name;
    my @classes = map {"${_}::$suffix"} @{$self->namespaces};
    for my $class (@classes, $name) { return $class->new if _load($class) }
  
    # Not found
    die qq{Plugin "$name" missing, maybe you need to install it?\n};
  }
  
  sub register_plugin {
    shift->load_plugin(shift)->register(shift, ref $_[0] ? $_[0] : {@_});
  }
  
  sub _load {
    my $module = shift;
    return $module->isa('Mojolicious::Plugin') unless my $e = load_class $module;
    ref $e ? die $e : return undef;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugins - Plugin manager
  
  =head1 SYNOPSIS
  
    use Mojolicious::Plugins;
  
    my $plugins = Mojolicious::Plugins->new;
    push @{$plugins->namespaces}, 'MyApp::Plugin';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugins> is the plugin manager of L<Mojolicious>.
  
  =head1 PLUGINS
  
  The following plugins are included in the L<Mojolicious> distribution as
  examples.
  
  =over 2
  
  =item L<Mojolicious::Plugin::Config>
  
  Perl-ish configuration files.
  
  =item L<Mojolicious::Plugin::DefaultHelpers>
  
  General purpose helper collection, loaded automatically.
  
  =item L<Mojolicious::Plugin::EPLRenderer>
  
  Renderer for plain embedded Perl templates, loaded automatically.
  
  =item L<Mojolicious::Plugin::EPRenderer>
  
  Renderer for more sophisticated embedded Perl templates, loaded automatically.
  
  =item L<Mojolicious::Plugin::HeaderCondition>
  
  Route condition for all kinds of headers, loaded automatically.
  
  =item L<Mojolicious::Plugin::JSONConfig>
  
  JSON configuration files.
  
  =item L<Mojolicious::Plugin::Mount>
  
  Mount whole L<Mojolicious> applications.
  
  =item L<Mojolicious::Plugin::PODRenderer>
  
  Renderer for turning POD into HTML and documentation browser for
  L<Mojolicious::Guides>.
  
  =item L<Mojolicious::Plugin::TagHelpers>
  
  Template specific helper collection, loaded automatically.
  
  =back
  
  =head1 EVENTS
  
  L<Mojolicious::Plugins> inherits all events from L<Mojo::EventEmitter>.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Plugins> implements the following attributes.
  
  =head2 namespaces
  
    my $namespaces = $plugins->namespaces;
    $plugins       = $plugins->namespaces(['Mojolicious::Plugin']);
  
  Namespaces to load plugins from, defaults to L<Mojolicious::Plugin>.
  
    # Add another namespace to load plugins from
    push @{$plugins->namespaces}, 'MyApp::Plugin';
  
  =head1 METHODS
  
  L<Mojolicious::Plugins> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 emit_chain
  
    $plugins->emit_chain('foo');
    $plugins->emit_chain(foo => 123);
  
  Emit events as chained hooks.
  
  =head2 emit_hook
  
    $plugins = $plugins->emit_hook('foo');
    $plugins = $plugins->emit_hook(foo => 123);
  
  Emit events as hooks.
  
  =head2 emit_hook_reverse
  
    $plugins = $plugins->emit_hook_reverse('foo');
    $plugins = $plugins->emit_hook_reverse(foo => 123);
  
  Emit events as hooks in reverse order.
  
  =head2 load_plugin
  
    my $plugin = $plugins->load_plugin('some_thing');
    my $plugin = $plugins->load_plugin('SomeThing');
    my $plugin = $plugins->load_plugin('MyApp::Plugin::SomeThing');
  
  Load a plugin from the configured namespaces or by full module name.
  
  =head2 register_plugin
  
    $plugins->register_plugin('some_thing', Mojolicious->new);
    $plugins->register_plugin('some_thing', Mojolicious->new, foo => 23);
    $plugins->register_plugin('some_thing', Mojolicious->new, {foo => 23});
    $plugins->register_plugin('SomeThing', Mojolicious->new);
    $plugins->register_plugin('SomeThing', Mojolicious->new, foo => 23);
    $plugins->register_plugin('SomeThing', Mojolicious->new, {foo => 23});
    $plugins->register_plugin('MyApp::Plugin::SomeThing', Mojolicious->new);
    $plugins->register_plugin(
      'MyApp::Plugin::SomeThing', Mojolicious->new, foo => 23);
    $plugins->register_plugin(
      'MyApp::Plugin::SomeThing', Mojolicious->new, {foo => 23});
  
  Load a plugin from the configured namespaces or by full module name and run
  C<register>, optional arguments are passed through.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGINS

$fatpacked{"Mojolicious/Renderer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_RENDERER';
  package Mojolicious::Renderer;
  use Mojo::Base -base;
  
  use Mojo::Cache;
  use Mojo::File 'path';
  use Mojo::JSON 'encode_json';
  use Mojo::Home;
  use Mojo::Loader 'data_section';
  use Mojo::Util qw(decamelize encode md5_sum monkey_patch);
  
  has cache   => sub { Mojo::Cache->new };
  has classes => sub { ['main'] };
  has default_format => 'html';
  has 'default_handler';
  has encoding => 'UTF-8';
  has [qw(handlers helpers)] => sub { {} };
  has paths => sub { [] };
  
  # Bundled templates
  my $TEMPLATES = Mojo::Home->new->mojo_lib_dir->child('Mojolicious', 'resources',
    'templates');
  
  sub DESTROY { Mojo::Util::_teardown($_) for @{shift->{namespaces}} }
  
  sub accepts {
    my ($self, $c) = (shift, shift);
  
    # List representations
    my $req  = $c->req;
    my $fmt  = $req->param('format') || $c->stash->{format};
    my @exts = $fmt ? ($fmt) : ();
    push @exts, @{$c->app->types->detect($req->headers->accept)};
    return \@exts unless @_;
  
    # Find best representation
    for my $ext (@exts) { $ext eq $_ and return $ext for @_ }
    return @exts ? undef : shift;
  }
  
  sub add_handler { $_[0]->handlers->{$_[1]} = $_[2] and return $_[0] }
  
  sub add_helper {
    my ($self, $name, $cb) = @_;
    $self->helpers->{$name} = $cb;
    delete $self->{proxy};
    return $self;
  }
  
  sub get_data_template {
    my ($self, $options) = @_;
    return undef unless my $template = $self->template_name($options);
    return data_section $self->{index}{$template}, $template;
  }
  
  sub get_helper {
    my ($self, $name) = @_;
  
    if (my $h = $self->{proxy}{$name} || $self->helpers->{$name}) { return $h }
  
    my $found;
    my $class = 'Mojolicious::Renderer::Helpers::' . md5_sum "$name:$self";
    my $re = length $name ? qr/^(\Q$name\E\.([^.]+))/ : qr/^(([^.]+))/;
    for my $key (keys %{$self->helpers}) {
      $key =~ $re ? ($found, my $method) = (1, $2) : next;
      my $sub = $self->get_helper($1);
      monkey_patch $class, $method => sub { ${shift()}->$sub(@_) };
    }
  
    $found ? push @{$self->{namespaces}}, $class : return undef;
    return $self->{proxy}{$name} = sub { bless \(my $dummy = shift), $class };
  }
  
  sub render {
    my ($self, $c, $args) = @_;
  
    my $stash   = $c->stash;
    my $options = {
      encoding => $self->encoding,
      handler  => $stash->{handler},
      template => delete $stash->{template},
      variant  => $stash->{variant}
    };
    my $inline = $options->{inline} = delete $stash->{inline};
    $options->{handler} //= $self->default_handler if defined $inline;
    $options->{format} = $stash->{format} || $self->default_format;
  
    # Data
    return delete $stash->{data}, $options->{format} if defined $stash->{data};
  
    # Text
    return _maybe($options->{encoding}, delete $stash->{text}), $options->{format}
      if defined $stash->{text};
  
    # JSON
    return encode_json(delete $stash->{json}), 'json' if exists $stash->{json};
  
    # Template or templateless handler
    $options->{template} //= $self->template_for($c);
    return () unless $self->_render_template($c, \my $output, $options);
  
    # Inheritance
    my $content = $stash->{'mojo.content'} ||= {};
    local $content->{content} = $output =~ /\S/ ? $output : undef
      if $stash->{extends} || $stash->{layout};
    while ((my $next = _next($stash)) && !defined $inline) {
      @$options{qw(handler template)} = ($stash->{handler}, $next);
      $options->{format} = $stash->{format} || $self->default_format;
      if ($self->_render_template($c, \my $tmp, $options)) { $output = $tmp }
      $content->{content} //= $output if $output =~ /\S/;
    }
  
    return $output if $args->{'mojo.string'};
    return _maybe($options->{encoding}, $output), $options->{format};
  }
  
  sub template_for {
    my ($self, $c) = @_;
  
    # Normal default template
    my $stash = $c->stash;
    my ($controller, $action) = @$stash{qw(controller action)};
    return join '/', split('-', decamelize $controller), $action
      if $controller && $action;
  
    # Try the route name if we don't have controller and action
    return undef unless my $route = $c->match->endpoint;
    return $route->name;
  }
  
  sub template_handler {
    my ($self, $options) = @_;
    return undef unless my $file = $self->template_name($options);
    return $self->default_handler unless my $handlers = $self->{templates}{$file};
    return $handlers->[0];
  }
  
  sub template_name {
    my ($self, $options) = @_;
  
    return undef unless defined(my $template = $options->{template});
    return undef unless my $format = $options->{format};
    $template .= ".$format";
  
    $self->warmup unless $self->{templates};
  
    # Variants
    my $handler = $options->{handler};
    if (defined(my $variant = $options->{variant})) {
      $variant = "$template+$variant";
      my $handlers = $self->{templates}{$variant} // [];
      $template = $variant
        if @$handlers && !defined $handler || grep { $_ eq $handler } @$handlers;
    }
  
    return defined $handler ? "$template.$handler" : $template;
  }
  
  sub template_path {
    my ($self, $options) = @_;
    return undef unless my $name = $self->template_name($options);
    my @parts = split '/', $name;
    -r and return $_
      for map { path($_, @parts)->to_string } @{$self->paths}, $TEMPLATES;
    return undef;
  }
  
  sub warmup {
    my $self = shift;
  
    my ($index, $templates) = @$self{qw(index templates)} = ({}, {});
  
    # Handlers for templates
    for my $path (@{$self->paths}, $TEMPLATES) {
      s/\.(\w+)$// and push @{$templates->{$_}}, $1
        for path($path)->list_tree->map(sub { join '/', @{$_->to_rel($path)} })
        ->each;
    }
  
    # Handlers and classes for DATA templates
    for my $class (reverse @{$self->classes}) {
      $index->{$_} = $class for my @keys = sort keys %{data_section $class};
      s/\.(\w+)$// and unshift @{$templates->{$_}}, $1 for reverse @keys;
    }
  }
  
  sub _maybe { $_[0] ? encode @_ : $_[1] }
  
  sub _next {
    my $stash = shift;
    return delete $stash->{extends} if $stash->{extends};
    return undef unless my $layout = delete $stash->{layout};
    return join '/', 'layouts', $layout;
  }
  
  sub _render_template {
    my ($self, $c, $output, $options) = @_;
  
    my $handler = $options->{handler} ||= $self->template_handler($options);
    return undef unless $handler;
    $c->app->log->error(qq{No handler for "$handler" available}) and return undef
      unless my $renderer = $self->handlers->{$handler};
  
    $renderer->($self, $c, $output, $options);
    return 1 if defined $$output;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Renderer - Generate dynamic content
  
  =head1 SYNOPSIS
  
    use Mojolicious::Renderer;
  
    my $renderer = Mojolicious::Renderer->new;
    push @{$renderer->classes}, 'MyApp::Controller::Foo';
    push @{$renderer->paths}, '/home/sri/templates';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Renderer> is the standard L<Mojolicious> renderer.
  
  See L<Mojolicious::Guides::Rendering> for more.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Renderer> implements the following attributes.
  
  =head2 cache
  
    my $cache = $renderer->cache;
    $renderer = $renderer->cache(Mojo::Cache->new);
  
  Renderer cache, defaults to a L<Mojo::Cache> object.
  
  =head2 classes
  
    my $classes = $renderer->classes;
    $renderer   = $renderer->classes(['main']);
  
  Classes to use for finding templates in C<DATA> sections with L<Mojo::Loader>,
  first one has the highest precedence, defaults to C<main>. Only files with
  exactly two extensions will be used, like C<index.html.ep>. Note that for
  templates to be detected, these classes need to have already been loaded and
  added before L</"warmup"> is called, which usually happens automatically during
  application startup.
  
    # Add another class with templates in DATA section
    push @{$renderer->classes}, 'Mojolicious::Plugin::Fun';
  
    # Add another class with templates in DATA section and higher precedence
    unshift @{$renderer->classes}, 'Mojolicious::Plugin::MoreFun';
  
  =head2 default_format
  
    my $default = $renderer->default_format;
    $renderer   = $renderer->default_format('html');
  
  The default format to render if C<format> is not set in the stash, defaults to
  C<html>. Note that changing the default away from C<html> is not recommended, as
  it has the potential to break, for example, plugins with bundled templates.
  
  =head2 default_handler
  
    my $default = $renderer->default_handler;
    $renderer   = $renderer->default_handler('ep');
  
  The default template handler to use for rendering in cases where auto-detection
  doesn't work, like for C<inline> templates.
  
  =head2 encoding
  
    my $encoding = $renderer->encoding;
    $renderer    = $renderer->encoding('koi8-r');
  
  Will encode generated content if set, defaults to C<UTF-8>. Note that many
  renderers such as L<Mojolicious::Plugin::EPRenderer> also use this value to
  determine if template files should be decoded before processing.
  
  =head2 handlers
  
    my $handlers = $renderer->handlers;
    $renderer    = $renderer->handlers({epl => sub {...}});
  
  Registered handlers.
  
  =head2 helpers
  
    my $helpers = $renderer->helpers;
    $renderer   = $renderer->helpers({url_for => sub {...}});
  
  Registered helpers.
  
  =head2 paths
  
    my $paths = $renderer->paths;
    $renderer = $renderer->paths(['/home/sri/templates']);
  
  Directories to look for templates in, first one has the highest precedence.
  
    # Add another "templates" directory
    push @{$renderer->paths}, '/home/sri/templates';
  
    # Add another "templates" directory with higher precedence
    unshift @{$renderer->paths}, '/home/sri/themes/blue/templates';
  
  =head1 METHODS
  
  L<Mojolicious::Renderer> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 accepts
  
    my $all  = $renderer->accepts(Mojolicious::Controller->new);
    my $best = $renderer->accepts(Mojolicious::Controller->new, 'html', 'json');
  
  Select best possible representation for L<Mojolicious::Controller> object from
  C<format> C<GET>/C<POST> parameter, C<format> stash value, or C<Accept> request
  header, defaults to returning the first extension if no preference could be
  detected.
  
  =head2 add_handler
  
    $renderer = $renderer->add_handler(epl => sub {...});
  
  Register a handler.
  
    $renderer->add_handler(foo => sub {
      my ($renderer, $c, $output, $options) = @_;
      ...
      $$output = 'Hello World!';
    });
  
  =head2 add_helper
  
    $renderer = $renderer->add_helper(url_for => sub {...});
  
  Register a helper.
  
    $renderer->add_helper(foo => sub {
      my ($c, @args) = @_;
      ...
    });
  
  =head2 get_data_template
  
    my $template = $renderer->get_data_template({
      template       => 'foo/bar',
      format         => 'html',
      handler        => 'epl'
    });
  
  Return a C<DATA> section template from L</"classes"> for an options hash
  reference with C<template>, C<format>, C<variant> and C<handler> values, or
  C<undef> if no template could be found, usually used by handlers.
  
  =head2 get_helper
  
    my $helper = $renderer->get_helper('url_for');
  
  Get a helper by full name, generate a helper dynamically for a prefix, or return
  C<undef> if no helper or prefix could be found. Generated helpers return a
  proxy object containing the current controller object and on which nested
  helpers can be called.
  
  =head2 render
  
    my ($output, $format) = $renderer->render(Mojolicious::Controller->new, {
      template => 'foo/bar',
      foo      => 'bar'
    });
  
  Render output through one of the renderers. See
  L<Mojolicious::Controller/"render"> for a more user-friendly interface.
  
  =head2 template_for
  
    my $name = $renderer->template_for(Mojolicious::Controller->new);
  
  Return default template name for L<Mojolicious::Controller> object, or C<undef>
  if no name could be generated.
  
  =head2 template_handler
  
    my $handler = $renderer->template_handler({
      template => 'foo/bar',
      format   => 'html'
    });
  
  Return handler for an options hash reference with C<template>, C<format> and
  C<variant> values, or C<undef> if no handler could be found.
  
  =head2 template_name
  
    my $template = $renderer->template_name({
      template => 'foo/bar',
      format   => 'html',
      handler  => 'epl'
    });
  
  Return a template name for an options hash reference with C<template>,
  C<format>, C<variant> and C<handler> values, or C<undef> if no template could be
  found, usually used by handlers.
  
  =head2 template_path
  
    my $path = $renderer->template_path({
      template => 'foo/bar',
      format   => 'html',
      handler  => 'epl'
    });
  
  Return the full template path for an options hash reference with C<template>,
  C<format>, C<variant> and C<handler> values, or C<undef> if the file does not
  exist in L</"paths">, usually used by handlers.
  
  =head2 warmup
  
    $renderer->warmup;
  
  Prepare templates from L</"classes"> for future use.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_RENDERER

$fatpacked{"Mojolicious/Routes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_ROUTES';
  package Mojolicious::Routes;
  use Mojo::Base 'Mojolicious::Routes::Route';
  
  use List::Util 'first';
  use Mojo::Cache;
  use Mojo::Loader 'load_class';
  use Mojo::Util 'camelize';
  use Mojolicious::Routes::Match;
  use Scalar::Util 'weaken';
  
  has base_classes => sub { [qw(Mojolicious::Controller Mojolicious)] };
  has cache        => sub { Mojo::Cache->new };
  has [qw(conditions shortcuts)] => sub { {} };
  has types      => sub { {num => qr/[0-9]+/} };
  has hidden     => sub { [qw(attr has new tap)] };
  has namespaces => sub { [] };
  
  sub add_condition { $_[0]->conditions->{$_[1]} = $_[2] and return $_[0] }
  sub add_shortcut  { $_[0]->shortcuts->{$_[1]}  = $_[2] and return $_[0] }
  sub add_type      { $_[0]->types->{$_[1]}      = $_[2] and return $_[0] }
  
  sub continue {
    my ($self, $c) = @_;
  
    my $match    = $c->match;
    my $stack    = $match->stack;
    my $position = $match->position;
    return _render($c) unless my $field = $stack->[$position];
  
    # Merge captures into stash
    my $stash = $c->stash;
    @{$stash->{'mojo.captures'} //= {}}{keys %$field} = values %$field;
    @$stash{keys %$field} = values %$field;
  
    my $continue;
    my $last = !$stack->[++$position];
    if (my $cb = $field->{cb}) { $continue = $self->_callback($c, $cb, $last) }
    else { $continue = $self->_controller($c, $field, $last) }
    $match->position($position);
    $self->continue($c) if $last || $continue;
  }
  
  sub dispatch {
    my ($self, $c) = @_;
    $self->match($c);
    @{$c->match->stack} ? $self->continue($c) : return undef;
    return 1;
  }
  
  sub hide { push @{shift->hidden}, @_ }
  
  sub is_hidden {
    my ($self, $method) = @_;
    my $h = $self->{hiding} ||= {map { $_ => 1 } @{$self->hidden}};
    return !!($h->{$method} || $method =~ /^_/ || $method =~ /^[A-Z_]+$/);
  }
  
  sub lookup { ($_[0]{reverse} //= $_[0]->_index)->{$_[1]} }
  
  sub match {
    my ($self, $c) = @_;
  
    # Path (partial path gets priority)
    my $req  = $c->req;
    my $path = $c->stash->{path};
    if (defined $path) { $path = "/$path" if $path !~ m!^/! }
    else               { $path = $req->url->path->to_route }
  
    # Method (HEAD will be treated as GET)
    my $method = uc($req->url->query->clone->param('_method') || $req->method);
    $method = 'GET' if $method eq 'HEAD';
  
    # Check cache
    my $ws = $c->tx->is_websocket ? 1 : 0;
    my $match = Mojolicious::Routes::Match->new(root => $self);
    $c->match($match);
    my $cache = $self->cache;
    if (my $result = $cache->get("$method:$path:$ws")) {
      return $match->endpoint($result->{endpoint})->stack($result->{stack});
    }
  
    # Check routes
    $match->find($c => {method => $method, path => $path, websocket => $ws});
    return unless my $route = $match->endpoint;
    $cache->set(
      "$method:$path:$ws" => {endpoint => $route, stack => $match->stack});
  }
  
  sub _action { shift->plugins->emit_chain(around_action => @_) }
  
  sub _callback {
    my ($self, $c, $cb, $last) = @_;
    $c->stash->{'mojo.routed'} = 1 if $last;
    my $app = $c->app;
    $app->log->debug('Routing to a callback');
    return _action($app, $c, $cb, $last);
  }
  
  sub _class {
    my ($self, $c, $field) = @_;
  
    # Application instance
    return $field->{app} if ref $field->{app};
  
    # Application class
    my @classes;
    my $class = $field->{controller} ? camelize $field->{controller} : '';
    if ($field->{app}) { push @classes, $field->{app} }
  
    # Specific namespace
    elsif (defined(my $ns = $field->{namespace})) {
      if ($class) { push @classes, $ns ? "${ns}::$class" : $class }
      elsif ($ns) { push @classes, $ns }
    }
  
    # All namespaces
    elsif ($class) { push @classes, "${_}::$class" for @{$self->namespaces} }
  
    # Try to load all classes
    my $log = $c->app->log;
    for my $class (@classes) {
  
      # Failed
      next unless defined(my $found = $self->_load($class));
      return !$log->debug(qq{Class "$class" is not a controller}) unless $found;
  
      # Success
      my $new = $class->new(%$c);
      weaken $new->{$_} for qw(app tx);
      return $new;
    }
  
    # Nothing found
    $log->debug(qq{Controller "$classes[-1]" does not exist}) if @classes;
    return @classes ? undef : 0;
  }
  
  sub _controller {
    my ($self, $old, $field, $last) = @_;
  
    # Load and instantiate controller/application
    my $new;
    unless ($new = $self->_class($old, $field)) { return defined $new }
  
    # Application
    my $class = ref $new;
    my $app   = $old->app;
    my $log   = $app->log;
    if ($new->isa('Mojolicious')) {
      $log->debug(qq{Routing to application "$class"});
  
      # Try to connect routes
      if (my $sub = $new->can('routes')) {
        my $r = $new->$sub;
        weaken $r->parent($old->match->endpoint)->{parent} unless $r->parent;
      }
      $new->handler($old);
      $old->stash->{'mojo.routed'} = 1;
    }
  
    # Action
    elsif (my $method = $field->{action}) {
      if (!$self->is_hidden($method)) {
        $log->debug(qq{Routing to controller "$class" and action "$method"});
  
        if (my $sub = $new->can($method)) {
          $old->stash->{'mojo.routed'} = 1 if $last;
          return 1 if _action($app, $new, $sub, $last);
        }
  
        else { $log->debug('Action not found in controller') }
      }
      else { $log->debug(qq{Action "$method" is not allowed}) }
    }
  
    return undef;
  }
  
  sub _load {
    my ($self, $app) = @_;
  
    # Load unless already loaded
    return 1 if $self->{loaded}{$app};
    if (my $e = load_class $app) { ref $e ? die $e : return undef }
  
    # Check base classes
    return 0 unless first { $app->isa($_) } @{$self->base_classes};
    return $self->{loaded}{$app} = 1;
  }
  
  sub _render {
    my $c     = shift;
    my $stash = $c->stash;
    return if $stash->{'mojo.rendered'};
    $c->render_maybe or $stash->{'mojo.routed'} or $c->helpers->reply->not_found;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Routes - Always find your destination with routes
  
  =head1 SYNOPSIS
  
    use Mojolicious::Routes;
  
    # Simple route
    my $r = Mojolicious::Routes->new;
    $r->route('/')->to(controller => 'blog', action => 'welcome');
  
    # More advanced routes
    my $blog = $r->under('/blog');
    $blog->get('/list')->to('blog#list');
    $blog->get('/:id' => [id => qr/\d+/])->to('blog#show', id => 23);
    $blog->patch(sub { shift->render(text => 'Go away!', status => 405) });
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Routes> is the core of the L<Mojolicious> web framework.
  
  See L<Mojolicious::Guides::Routing> for more.
  
  =head1 TYPES
  
  These placeholder types are available by default.
  
  =head2 num
  
    $r->get('/article/<id:num>');
  
  Placeholder value needs to be a non-fractional number, similar to the regular
  expression C<([0-9]+)>.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Routes> inherits all attributes from
  L<Mojolicious::Routes::Route> and implements the following new ones.
  
  =head2 base_classes
  
    my $classes = $r->base_classes;
    $r          = $r->base_classes(['MyApp::Controller']);
  
  Base classes used to identify controllers, defaults to
  L<Mojolicious::Controller> and L<Mojolicious>.
  
  =head2 cache
  
    my $cache = $r->cache;
    $r        = $r->cache(Mojo::Cache->new);
  
  Routing cache, defaults to a L<Mojo::Cache> object.
  
  =head2 conditions
  
    my $conditions = $r->conditions;
    $r             = $r->conditions({foo => sub {...}});
  
  Contains all available conditions.
  
  =head2 hidden
  
    my $hidden = $r->hidden;
    $r         = $r->hidden(['attr', 'has', 'new']);
  
  Controller attributes and methods that are hidden from router, defaults to
  C<attr>, C<has>, C<new> and C<tap>.
  
  =head2 namespaces
  
    my $namespaces = $r->namespaces;
    $r             = $r->namespaces(['MyApp::Controller', 'MyApp']);
  
  Namespaces to load controllers from.
  
    # Add another namespace to load controllers from
    push @{$r->namespaces}, 'MyApp::MyController';
  
  =head2 shortcuts
  
    my $shortcuts = $r->shortcuts;
    $r            = $r->shortcuts({foo => sub {...}});
  
  Contains all available shortcuts.
  
  =head2 types
  
    my $types = $r->types;
    $r        = $r->types({lower => qr/[a-z]+/});
  
  Registered placeholder types, by default only L</"num"> is already defined.
  
  =head1 METHODS
  
  L<Mojolicious::Routes> inherits all methods from L<Mojolicious::Routes::Route>
  and implements the following new ones.
  
  =head2 add_condition
  
    $r = $r->add_condition(foo => sub {...});
  
  Register a condition.
  
    $r->add_condition(foo => sub {
      my ($route, $c, $captures, $arg) = @_;
      ...
      return 1;
    });
  
  =head2 add_shortcut
  
    $r = $r->add_shortcut(foo => sub {...});
  
  Register a shortcut.
  
    $r->add_shortcut(foo => sub {
      my ($route, @args) = @_;
      ...
    });
  
  =head2 add_type
  
    $r = $r->add_type(foo => qr/\w+/);
    $r = $r->add_type(foo => ['bar', 'baz']);
  
  Register a placeholder type.
  
    $r->add_type(lower => qr/[a-z]+/);
  
  =head2 continue
  
    $r->continue(Mojolicious::Controller->new);
  
  Continue dispatch chain and emit the hook L<Mojolicious/"around_action"> for
  every action.
  
  =head2 dispatch
  
    my $bool = $r->dispatch(Mojolicious::Controller->new);
  
  Match routes with L</"match"> and dispatch with L</"continue">.
  
  =head2 hide
  
    $r = $r->hide('foo', 'bar');
  
  Hide controller attributes and methods from router.
  
  =head2 is_hidden
  
    my $bool = $r->is_hidden('foo');
  
  Check if controller attribute or method is hidden from router.
  
  =head2 lookup
  
    my $route = $r->lookup('foo');
  
  Find route by name with L<Mojolicious::Routes::Route/"find"> and cache all
  results for future lookups.
  
  =head2 match
  
    $r->match(Mojolicious::Controller->new);
  
  Match routes with L<Mojolicious::Routes::Match>.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_ROUTES

$fatpacked{"Mojolicious/Routes/Match.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_ROUTES_MATCH';
  package Mojolicious::Routes::Match;
  use Mojo::Base -base;
  
  use Mojo::Util;
  
  has [qw(endpoint root)];
  has position => 0;
  has stack => sub { [] };
  
  sub find { $_[0]->_match($_[0]->root, $_[1], $_[2]) }
  
  sub path_for {
    my ($self, $name, %values) = (shift, Mojo::Util::_options(@_));
  
    # Current route
    my $route;
    if (!$name || $name eq 'current') {
      return {} unless $route = $self->endpoint;
    }
  
    # Find endpoint
    else { return {path => $name} unless $route = $self->root->lookup($name) }
  
    # Merge values (clear format)
    my $captures = $self->stack->[-1] || {};
    %values = (%$captures, format => undef, %values);
    my $pattern = $route->pattern;
    $values{format}
      //= defined $captures->{format}
      ? $captures->{format}
      : $pattern->defaults->{format}
      if $pattern->constraints->{format};
  
    my $path = $route->render(\%values);
    return {path => $path, websocket => $route->has_websocket};
  }
  
  sub _match {
    my ($self, $r, $c, $options) = @_;
  
    # Pattern
    my $path    = $options->{path};
    my $partial = $r->partial;
    my $detect  = (my $endpoint = $r->is_endpoint) && !$partial;
    return undef
      unless my $captures = $r->pattern->match_partial(\$path, $detect);
    local $options->{path} = $path;
    local @{$self->{captures} ||= {}}{keys %$captures} = values %$captures;
    $captures = $self->{captures};
  
    # Method
    my $methods = $r->via;
    return undef if $methods && !grep { $_ eq $options->{method} } @$methods;
  
    # Conditions
    if (my $over = $r->over) {
      my $conditions = $self->{conditions} ||= $self->root->conditions;
      for (my $i = 0; $i < @$over; $i += 2) {
        return undef unless my $condition = $conditions->{$over->[$i]};
        return undef if !$condition->($r, $c, $captures, $over->[$i + 1]);
      }
    }
  
    # WebSocket
    return undef if $r->is_websocket && !$options->{websocket};
  
    # Partial
    my $empty = !length $path || $path eq '/';
    if ($partial) {
      $captures->{path} = $path;
      $self->endpoint($r);
      $empty = 1;
    }
  
    # Endpoint (or intermediate destination)
    if (($endpoint && $empty) || $r->inline) {
      push @{$self->stack}, {%$captures};
      if ($endpoint && $empty) {
        my $format = $captures->{format};
        if ($format) { $_->{format} = $format for @{$self->stack} }
        return !!$self->endpoint($r);
      }
      delete @$captures{qw(app cb)};
    }
  
    # Match children
    my $snapshot = $r->parent ? [@{$self->stack}] : [];
    for my $child (@{$r->children}) {
      return 1 if $self->_match($child, $c, $options);
      $self->stack([@$snapshot]);
    }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Routes::Match - Find routes
  
  =head1 SYNOPSIS
  
    use Mojolicious::Controller;
    use Mojolicious::Routes;
    use Mojolicious::Routes::Match;
  
    # Routes
    my $r = Mojolicious::Routes->new;
    $r->get('/:controller/:action');
    $r->put('/:controller/:action');
  
    # Match
    my $c = Mojolicious::Controller->new;
    my $match = Mojolicious::Routes::Match->new(root => $r);
    $match->find($c => {method => 'PUT', path => '/foo/bar'});
    say $match->stack->[0]{controller};
    say $match->stack->[0]{action};
  
    # Render
    say $match->path_for->{path};
    say $match->path_for(action => 'baz')->{path};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Routes::Match> finds routes in L<Mojolicious::Routes>
  structures.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Routes::Match> implements the following attributes.
  
  =head2 endpoint
  
    my $route = $match->endpoint;
    $match    = $match->endpoint(Mojolicious::Routes::Route->new);
  
  The route endpoint that matched, usually a L<Mojolicious::Routes::Route>
  object.
  
  =head2 position
  
    my $position = $match->position;
    $match       = $match->position(2);
  
  Current position on the L</"stack">, defaults to C<0>.
  
  =head2 root
  
    my $root = $match->root;
    $match   = $match->root(Mojolicious::Routes->new);
  
  The root of the route structure, usually a L<Mojolicious::Routes> object.
  
  =head2 stack
  
    my $stack = $match->stack;
    $match    = $match->stack([{action => 'foo'}, {action => 'bar'}]);
  
  Captured parameters with nesting history.
  
  =head1 METHODS
  
  L<Mojolicious::Routes::Match> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 find
  
    $match->find(Mojolicious::Controller->new, {method => 'GET', path => '/'});
  
  Match controller and options against L</"root"> to find an appropriate
  L</"endpoint">.
  
  =head2 path_for
  
    my $info = $match->path_for;
    my $info = $match->path_for(foo => 'bar');
    my $info = $match->path_for({foo => 'bar'});
    my $info = $match->path_for('named');
    my $info = $match->path_for('named', foo => 'bar');
    my $info = $match->path_for('named', {foo => 'bar'});
  
  Render matching route with parameters into path.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_ROUTES_MATCH

$fatpacked{"Mojolicious/Routes/Pattern.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_ROUTES_PATTERN';
  package Mojolicious::Routes::Pattern;
  use Mojo::Base -base;
  
  use Carp 'croak';
  use Mojo::Util 'deprecated';
  
  has [qw(constraints defaults types)] => sub { {} };
  has [qw(placeholder_start type_start)] => ':';
  has [qw(placeholders tree)] => sub { [] };
  has quote_end   => '>';
  has quote_start => '<';
  has [qw(regex unparsed)];
  has relaxed_start  => '#';
  has wildcard_start => '*';
  
  sub match {
    my ($self, $path, $detect) = @_;
    my $captures = $self->match_partial(\$path, $detect);
    return !$path || $path eq '/' ? $captures : undef;
  }
  
  sub match_partial {
    my ($self, $pathref, $detect) = @_;
  
    # Compile on demand
    $self->_compile($detect) unless $self->{regex};
  
    return undef unless my @captures = $$pathref =~ $self->regex;
    $$pathref = ${^POSTMATCH};
    @captures = () if $#+ == 0;
    my $captures = {%{$self->defaults}};
    for my $placeholder (@{$self->placeholders}, 'format') {
      last unless @captures;
      my $capture = shift @captures;
      $captures->{$placeholder} = $capture if defined $capture;
    }
  
    return $captures;
  }
  
  sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }
  
  sub parse {
    my $self = shift;
  
    my $pattern = @_ % 2 ? (shift // '/') : '/';
    $pattern =~ s!^/*|/+!/!g;
    return $self->constraints({@_}) if $pattern eq '/';
  
    $pattern =~ s!/$!!;
    return $self->constraints({@_})->_tokenize($pattern);
  }
  
  sub render {
    my ($self, $values, $endpoint) = @_;
  
    my $start = $self->type_start;
  
    # Placeholders can only be optional without a format
    my $optional = !(my $format = $values->{format});
  
    my $str = '';
    for my $token (reverse @{$self->tree}) {
      my ($op, $value) = @$token;
      my $part = '';
  
      # Text
      if ($op eq 'text') { ($part, $optional) = ($value, 0) }
  
      # Slash
      elsif ($op eq 'slash') { $part = '/' unless $optional }
  
      # Placeholder
      else {
        my $name = (split $start, $value)[0] // '';
        my $default = $self->defaults->{$name};
        $part = $values->{$name} // $default // '';
        if (!defined $default || ($default ne $part)) { $optional = 0 }
        elsif ($optional) { $part = '' }
      }
  
      $str = $part . $str;
    }
  
    # Format can be optional
    return $endpoint && $format ? "$str.$format" : $str;
  }
  
  sub _compile {
    my ($self, $detect) = @_;
  
    my $placeholders = $self->placeholders;
    my $constraints  = $self->constraints;
    my $defaults     = $self->defaults;
    my $start        = $self->type_start;
    my $types        = $self->types;
  
    my $block = my $regex = '';
    my $optional = 1;
    for my $token (reverse @{$self->tree}) {
      my ($op, $value, $type) = @$token;
      my $part = '';
  
      # Text
      if ($op eq 'text') { ($part, $optional) = (quotemeta $value, 0) }
  
      # Slash
      elsif ($op eq 'slash') {
        $regex = ($optional ? "(?:/$block)?" : "/$block") . $regex;
        ($block, $optional) = ('', 1);
        next;
      }
  
      # Placeholder
      else {
        if ($value =~ /^(.+)\Q$start\E(.+)$/) {
          ($value, $part) = ($1, _compile_req($types->{$2} // '?!'));
        }
        else {
          $part = $type ? $type eq 'relaxed' ? '([^/]+)' : '(.+)' : '([^/.]+)';
        }
        unshift @$placeholders, $value;
  
        # Custom regex
        if (my $c = $constraints->{$value}) { $part = _compile_req($c) }
  
        # Optional placeholder
        exists $defaults->{$value} ? ($part .= '?') : ($optional = 0);
      }
  
      $block = $part . $block;
    }
  
    # Not rooted with a slash
    $regex = $block . $regex if $block;
  
    # Format
    $regex .= _compile_format($constraints->{format}, $defaults->{format})
      if $detect;
  
    $self->regex(qr/^$regex/ps);
  }
  
  sub _compile_format {
    my ($format, $default) = @_;
  
    # Default regex
    return '/?(?:\.([^/]+))?$' unless defined $format;
  
    # No regex
    return '' unless $format;
  
    # Compile custom regex
    my $regex = '\.' . _compile_req($format);
    return $default ? "/?(?:$regex)?\$" : "/?$regex\$";
  }
  
  sub _compile_req {
    my $req = shift;
    return "($req)" if ref $req ne 'ARRAY';
    return '(' . join('|', map {quotemeta} reverse sort @$req) . ')';
  }
  
  sub _tokenize {
    my ($self, $pattern) = @_;
  
    # DEPRECATED!
    deprecated 'Placeholder quoting with "(placeholder)" is DEPRECATED'
      . ' in favor of "<placeholder>"'
      if $pattern =~ tr/()/<>/;
  
    my $quote_end   = $self->quote_end;
    my $quote_start = $self->quote_start;
    my $start       = $self->placeholder_start;
    my $relaxed     = $self->relaxed_start;
    my $wildcard    = $self->wildcard_start;
  
    my (@tree, $spec, $more);
    for my $char (split '', $pattern) {
  
      # Quoted
      if ($char eq $quote_start) { push @tree, ['placeholder', ''] if ++$spec }
      elsif ($char eq $quote_end) { $spec = $more = 0 }
  
      # Placeholder
      elsif (!$more && $char eq $start) {
        push @tree, ['placeholder', ''] unless $spec++;
      }
  
      # Relaxed or wildcard (upgrade when quoted)
      elsif (!$more && ($char eq $relaxed || $char eq $wildcard)) {
        push @tree, ['placeholder', ''] unless $spec++;
        $tree[-1][2] = $char eq $relaxed ? 'relaxed' : 'wildcard';
      }
  
      # Slash
      elsif ($char eq '/') {
        push @tree, ['slash'];
        $spec = $more = 0;
      }
  
      # Placeholder
      elsif ($spec && ++$more) { $tree[-1][1] .= $char }
  
      # Text (optimize slash+text and *+text+slash+text)
      elsif ($tree[-1][0] eq 'text') { $tree[-1][-1] .= $char }
      elsif (!$tree[-2] && $tree[-1][0] eq 'slash') {
        @tree = (['text', "/$char"]);
      }
      elsif ($tree[-2] && $tree[-2][0] eq 'text' && $tree[-1][0] eq 'slash') {
        pop @tree && ($tree[-1][-1] .= "/$char");
      }
      else { push @tree, ['text', $char] }
    }
  
    return $self->unparsed($pattern)->tree(\@tree);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Routes::Pattern - Route pattern
  
  =head1 SYNOPSIS
  
    use Mojolicious::Routes::Pattern;
  
    # Create pattern
    my $pattern = Mojolicious::Routes::Pattern->new('/test/:name');
  
    # Match routes
    my $captures = $pattern->match('/test/sebastian');
    say $captures->{name};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Routes::Pattern> is the core of L<Mojolicious::Routes>.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Routes::Pattern> implements the following attributes.
  
  =head2 constraints
  
    my $constraints = $pattern->constraints;
    $pattern        = $pattern->constraints({foo => qr/\w+/});
  
  Regular expression constraints.
  
  =head2 defaults
  
    my $defaults = $pattern->defaults;
    $pattern     = $pattern->defaults({foo => 'bar'});
  
  Default parameters.
  
  =head2 placeholder_start
  
    my $start = $pattern->placeholder_start;
    $pattern  = $pattern->placeholder_start(':');
  
  Character indicating a placeholder, defaults to C<:>.
  
  =head2 placeholders
  
    my $placeholders = $pattern->placeholders;
    $pattern         = $pattern->placeholders(['foo', 'bar']);
  
  Placeholder names.
  
  =head2 quote_end
  
    my $end  = $pattern->quote_end;
    $pattern = $pattern->quote_end('}');
  
  Character indicating the end of a quoted placeholder, defaults to C<E<gt>>.
  
  =head2 quote_start
  
    my $start = $pattern->quote_start;
    $pattern  = $pattern->quote_start('{');
  
  Character indicating the start of a quoted placeholder, defaults to C<E<lt>>.
  
  =head2 regex
  
    my $regex = $pattern->regex;
    $pattern  = $pattern->regex($regex);
  
  Pattern in compiled regular expression form.
  
  =head2 relaxed_start
  
    my $start = $pattern->relaxed_start;
    $pattern  = $pattern->relaxed_start('*');
  
  Character indicating a relaxed placeholder, defaults to C<#>.
  
  =head2 tree
  
    my $tree = $pattern->tree;
    $pattern = $pattern->tree([['text', '/foo']]);
  
  Pattern in parsed form. Note that this structure should only be used very
  carefully since it is very dynamic.
  
  =head2 type_start
  
    my $start = $pattern->type_start;
    $pattern  = $pattern->type_start('|');
  
  Character indicating the start of a placeholder type, defaults to C<:>.
  
  =head2 types
  
    my $types = $pattern->types;
    $pattern  = $pattern->types({int => qr/[0-9]+/});
  
  Placeholder types.
  
  =head2 unparsed
  
    my $unparsed = $pattern->unparsed;
    $pattern     = $pattern->unparsed('/:foo/:bar');
  
  Raw unparsed pattern.
  
  =head2 wildcard_start
  
    my $start = $pattern->wildcard_start;
    $pattern  = $pattern->wildcard_start('*');
  
  Character indicating the start of a wildcard placeholder, defaults to C<*>.
  
  =head1 METHODS
  
  L<Mojolicious::Routes::Pattern> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 match
  
    my $captures = $pattern->match('/foo/bar');
    my $captures = $pattern->match('/foo/bar', 1);
  
  Match pattern against entire path, format detection is disabled by default.
  
  =head2 match_partial
  
    my $captures = $pattern->match_partial(\$path);
    my $captures = $pattern->match_partial(\$path, 1);
  
  Match pattern against path and remove matching parts, format detection is
  disabled by default.
  
  =head2 new
  
    my $pattern = Mojolicious::Routes::Pattern->new;
    my $pattern = Mojolicious::Routes::Pattern->new('/:action');
    my $pattern
      = Mojolicious::Routes::Pattern->new('/:action', action => qr/\w+/);
    my $pattern = Mojolicious::Routes::Pattern->new(format => 0);
  
  Construct a new L<Mojolicious::Routes::Pattern> object and L</"parse"> pattern
  if necessary.
  
  =head2 parse
  
    $pattern = $pattern->parse('/:action');
    $pattern = $pattern->parse('/:action', action => qr/\w+/);
    $pattern = $pattern->parse(format => 0);
  
  Parse pattern.
  
  =head2 render
  
    my $path = $pattern->render({action => 'foo'});
    my $path = $pattern->render({action => 'foo'}, 1);
  
  Render pattern into a path with parameters, format rendering is disabled by
  default.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_ROUTES_PATTERN

$fatpacked{"Mojolicious/Routes/Route.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_ROUTES_ROUTE';
  package Mojolicious::Routes::Route;
  use Mojo::Base -base;
  
  use Carp ();
  use Mojo::Util;
  use Mojolicious::Routes::Pattern;
  use Scalar::Util ();
  
  has [qw(inline parent partial)];
  has 'children' => sub { [] };
  has pattern    => sub { Mojolicious::Routes::Pattern->new };
  
  sub AUTOLOAD {
    my $self = shift;
  
    my ($package, $method) = our $AUTOLOAD =~ /^(.+)::(.+)$/;
    Carp::croak "Undefined subroutine &${package}::$method called"
      unless Scalar::Util::blessed $self && $self->isa(__PACKAGE__);
  
    # Call shortcut with current route
    Carp::croak qq{Can't locate object method "$method" via package "$package"}
      unless my $shortcut = $self->root->shortcuts->{$method};
    return $self->$shortcut(@_);
  }
  
  sub add_child {
    my ($self, $route) = @_;
    Scalar::Util::weaken $route->remove->parent($self)->{parent};
    push @{$self->children}, $route;
    $route->pattern->types($self->root->types);
    return $self;
  }
  
  sub any { shift->_generate_route(ref $_[0] eq 'ARRAY' ? shift : [], @_) }
  
  sub delete { shift->_generate_route(DELETE => @_) }
  
  sub detour { shift->partial(1)->to(@_) }
  
  sub find { shift->_index->{shift()} }
  
  sub get { shift->_generate_route(GET => @_) }
  
  sub has_custom_name { !!shift->{custom} }
  
  sub has_websocket {
    my $self = shift;
    return $self->{has_websocket} if exists $self->{has_websocket};
    return $self->{has_websocket} = grep { $_->is_websocket } @{$self->_chain};
  }
  
  sub is_endpoint { $_[0]->inline ? undef : !@{$_[0]->children} }
  
  sub is_websocket { !!shift->{websocket} }
  
  sub name {
    my $self = shift;
    return $self->{name} unless @_;
    @$self{qw(name custom)} = (shift, 1);
    return $self;
  }
  
  sub options { shift->_generate_route(OPTIONS => @_) }
  
  sub over {
    my $self = shift;
  
    # Routes with conditions can't be cached
    return $self->{over} unless @_;
    my $conditions = ref $_[0] eq 'ARRAY' ? $_[0] : [@_];
    return $self unless @$conditions;
    $self->{over} = $conditions;
    $self->root->cache->max_keys(0);
  
    return $self;
  }
  
  sub parse {
    my $self = shift;
    $self->{name} = $self->pattern->parse(@_)->unparsed // '';
    $self->{name} =~ s/\W+//g;
    return $self;
  }
  
  sub patch { shift->_generate_route(PATCH => @_) }
  sub post  { shift->_generate_route(POST  => @_) }
  sub put   { shift->_generate_route(PUT   => @_) }
  
  sub remove {
    my $self = shift;
    return $self unless my $parent = $self->parent;
    @{$parent->children} = grep { $_ ne $self } @{$parent->children};
    return $self->parent(undef);
  }
  
  sub render {
    my ($self, $values) = @_;
    my $path = join '',
      map { $_->pattern->render($values, !@{$_->children} && !$_->partial) }
      @{$self->_chain};
    return $path || '/';
  }
  
  sub root { shift->_chain->[0] }
  
  sub route {
    my $self   = shift;
    my $route  = $self->add_child(__PACKAGE__->new->parse(@_))->children->[-1];
    my $format = $self->pattern->constraints->{format};
    $route->pattern->constraints->{format} //= 0 if defined $format && !$format;
    return $route;
  }
  
  sub suggested_method {
    my $self = shift;
  
    my %via;
    for my $route (@{$self->_chain}) {
      next unless my @via = @{$route->via || []};
      %via = map { $_ => 1 } keys %via ? grep { $via{$_} } @via : @via;
    }
  
    return 'POST' if $via{POST} && !$via{GET};
    return $via{GET} ? 'GET' : (sort keys %via)[0] || 'GET';
  }
  
  sub to {
    my $self = shift;
  
    my $pattern = $self->pattern;
    return $pattern->defaults unless @_;
    my ($shortcut, %defaults) = Mojo::Util::_options(@_);
  
    if ($shortcut) {
  
      # Application
      if (ref $shortcut || $shortcut =~ /^[\w:]+$/) {
        $defaults{app} = $shortcut;
      }
  
      # Controller and action
      elsif ($shortcut =~ /^([\w\-:]+)?\#(\w+)?$/) {
        $defaults{controller} = $1 if defined $1;
        $defaults{action}     = $2 if defined $2;
      }
    }
  
    @{$pattern->defaults}{keys %defaults} = values %defaults;
  
    return $self;
  }
  
  sub to_string {
    join '', map { $_->pattern->unparsed // '' } @{shift->_chain};
  }
  
  sub under { shift->_generate_route(under => @_) }
  
  sub via {
    my $self = shift;
    return $self->{via} unless @_;
    my $methods = [map uc($_), @{ref $_[0] ? $_[0] : [@_]}];
    $self->{via} = $methods if @$methods;
    return $self;
  }
  
  sub websocket {
    my $route = shift->get(@_);
    $route->{websocket} = 1;
    return $route;
  }
  
  sub _chain {
    my @chain = (my $parent = shift);
    unshift @chain, $parent while $parent = $parent->parent;
    return \@chain;
  }
  
  sub _generate_route {
    my ($self, $methods, @args) = @_;
  
    my (@conditions, @constraints, %defaults, $name, $pattern);
    while (defined(my $arg = shift @args)) {
  
      # First scalar is the pattern
      if (!ref $arg && !$pattern) { $pattern = $arg }
  
      # Scalar
      elsif (!ref $arg && @args) { push @conditions, $arg, shift @args }
  
      # Last scalar is the route name
      elsif (!ref $arg) { $name = $arg }
  
      # Callback
      elsif (ref $arg eq 'CODE') { $defaults{cb} = $arg }
  
      # Constraints
      elsif (ref $arg eq 'ARRAY') { push @constraints, @$arg }
  
      # Defaults
      elsif (ref $arg eq 'HASH') { %defaults = (%defaults, %$arg) }
    }
  
    my $route
      = $self->route($pattern, @constraints)->over(\@conditions)->to(\%defaults);
    $methods eq 'under' ? $route->inline(1) : $route->via($methods);
  
    return defined $name ? $route->name($name) : $route;
  }
  
  sub _index {
    my $self = shift;
  
    my (%auto, %custom);
    my @children = (@{$self->children});
    while (my $child = shift @children) {
      if   ($child->has_custom_name) { $custom{$child->name} ||= $child }
      else                           { $auto{$child->name}   ||= $child }
      push @children, @{$child->children};
    }
  
    return {%auto, %custom};
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Routes::Route - Route
  
  =head1 SYNOPSIS
  
    use Mojolicious::Routes::Route;
  
    my $r = Mojolicious::Routes::Route->new;
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Routes::Route> is the route container used by
  L<Mojolicious::Routes>.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Routes::Route> implements the following attributes.
  
  =head2 children
  
    my $children = $r->children;
    $r           = $r->children([Mojolicious::Routes::Route->new]);
  
  The children of this route, used for nesting routes.
  
  =head2 inline
  
    my $bool = $r->inline;
    $r       = $r->inline($bool);
  
  Allow L</"under"> semantics for this route.
  
  =head2 parent
  
    my $parent = $r->parent;
    $r         = $r->parent(Mojolicious::Routes::Route->new);
  
  The parent of this route, usually a L<Mojolicious::Routes::Route> object.
  
  =head2 partial
  
    my $bool = $r->partial;
    $r       = $r->partial($bool);
  
  Route has no specific end, remaining characters will be captured in C<path>.
  
  =head2 pattern
  
    my $pattern = $r->pattern;
    $r          = $r->pattern(Mojolicious::Routes::Pattern->new);
  
  Pattern for this route, defaults to a L<Mojolicious::Routes::Pattern> object.
  
  =head1 METHODS
  
  L<Mojolicious::Routes::Route> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 add_child
  
    $r = $r->add_child(Mojolicious::Routes::Route->new);
  
  Add a child to this route, it will be automatically removed from its current
  parent if necessary.
  
    # Reattach route
    $r->add_child($r->find('foo'));
  
  =head2 any
  
    my $route = $r->any;
    my $route = $r->any('/:foo');
    my $route = $r->any('/:foo' => sub {...});
    my $route = $r->any('/:foo' => sub {...} => 'name');
    my $route = $r->any('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->any('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->any('/:foo' => (agent => qr/Firefox/) => sub {...});
    my $route = $r->any(['GET', 'POST'] => '/:foo' => sub {...});
    my $route = $r->any(['GET', 'POST'] => '/:foo' => [foo => qr/\w+/]);
  
  Generate L<Mojolicious::Routes::Route> object matching any of the listed HTTP
  request methods or all.
  
    # Route with pattern and destination
    $r->any('/user')->to('user#whatever');
  
  All arguments are optional, but some have to appear in a certain order, like the
  two supported array reference values, which contain the HTTP methods to match
  and restrictive placeholders.
  
    # Route with HTTP methods, pattern, restrictive placeholders and destination
    $r->any(['DELETE', 'PUT'] => '/:foo' => [foo => qr/\w+/])->to('foo#bar');
  
  There are also two supported string values, containing the route pattern and the
  route name, defaulting to the pattern C</> and a name based on the pattern.
  
    # Route with pattern, name and destination
    $r->any('/:foo' => 'foo_route')->to('foo#bar');
  
  An arbitrary number of key/value pairs in between the route pattern and name can
  be used to specify route conditions.
  
    # Route with pattern, condition and destination
    $r->any('/' => (agent => qr/Firefox/))->to('foo#bar');
  
  A hash reference is used to specify optional placeholders and default values for
  the stash.
  
    # Route with pattern, optional placeholder and destination
    $r->any('/:foo' => {foo => 'bar'})->to('foo#bar');
  
  And a code reference can be used to specify a C<cb> value to be merged into the
  default values for the stash.
  
    # Route with pattern and a closure as destination
    $r->any('/:foo' => sub {
      my $c = shift;
      $c->render(text => 'Hello World!');
    });
  
  See L<Mojolicious::Guides::Tutorial> and L<Mojolicious::Guides::Routing> for
  more information.
  
  =head2 delete
  
    my $route = $r->delete;
    my $route = $r->delete('/:foo');
    my $route = $r->delete('/:foo' => sub {...});
    my $route = $r->delete('/:foo' => sub {...} => 'name');
    my $route = $r->delete('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->delete('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->delete('/:foo' => (agent => qr/Firefox/) => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<DELETE> requests,
  takes the same arguments as L</"any"> (except for the HTTP methods to match,
  which are implied). See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
    # Route with destination
    $r->delete('/user')->to('user#remove');
  
  =head2 detour
  
    $r = $r->detour(action => 'foo');
    $r = $r->detour('controller#action');
    $r = $r->detour(Mojolicious->new, foo => 'bar');
    $r = $r->detour('MyApp', {foo => 'bar'});
  
  Set default parameters for this route and allow partial matching to simplify
  application embedding, takes the same arguments as L</"to">.
  
  =head2 find
  
    my $route = $r->find('foo');
  
  Find child route by name, custom names have precedence over automatically
  generated ones.
  
    # Change default parameters of a named route
    $r->find('show_user')->to(foo => 'bar');
  
  =head2 get
  
    my $route = $r->get;
    my $route = $r->get('/:foo');
    my $route = $r->get('/:foo' => sub {...});
    my $route = $r->get('/:foo' => sub {...} => 'name');
    my $route = $r->get('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->get('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->get('/:foo' => (agent => qr/Firefox/) => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<GET> requests,
  takes the same arguments as L</"any"> (except for the HTTP methods to match,
  which are implied). See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
    # Route with destination
    $r->get('/user')->to('user#show');
  
  =head2 has_custom_name
  
    my $bool = $r->has_custom_name;
  
  Check if this route has a custom name.
  
  =head2 has_websocket
  
    my $bool = $r->has_websocket;
  
  Check if this route has a WebSocket ancestor and cache the result for future
  checks.
  
  =head2 is_endpoint
  
    my $bool = $r->is_endpoint;
  
  Check if this route qualifies as an endpoint.
  
  =head2 is_websocket
  
    my $bool = $r->is_websocket;
  
  Check if this route is a WebSocket.
  
  =head2 name
  
    my $name = $r->name;
    $r       = $r->name('foo');
  
  The name of this route, defaults to an automatically generated name based on
  the route pattern. Note that the name C<current> is reserved for referring to
  the current route.
  
    # Route with destination and custom name
    $r->get('/user')->to('user#show')->name('show_user');
  
  =head2 options
  
    my $route = $r->options;
    my $route = $r->options('/:foo');
    my $route = $r->options('/:foo' => sub {...});
    my $route = $r->options('/:foo' => sub {...} => 'name');
    my $route = $r->options('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->options('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->options('/:foo' => (agent => qr/Firefox/) => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<OPTIONS>
  requests, takes the same arguments as L</"any"> (except for the HTTP methods to
  match, which are implied). See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
    # Route with destination
    $r->options('/user')->to('user#overview');
  
  =head2 over
  
    my $over = $r->over;
    $r       = $r->over(foo => 1);
    $r       = $r->over(foo => 1, bar => {baz => 'yada'});
    $r       = $r->over([foo => 1, bar => {baz => 'yada'}]);
  
  Activate conditions for this route. Note that this automatically disables the
  routing cache, since conditions are too complex for caching.
  
    # Route with condition and destination
    $r->get('/foo')->over(host => qr/mojolicious\.org/)->to('foo#bar');
  
  =head2 parse
  
    $r = $r->parse('/:action');
    $r = $r->parse('/:action', action => qr/\w+/);
    $r = $r->parse(format => 0);
  
  Parse pattern.
  
  =head2 patch
  
    my $route = $r->patch;
    my $route = $r->patch('/:foo');
    my $route = $r->patch('/:foo' => sub {...});
    my $route = $r->patch('/:foo' => sub {...} => 'name');
    my $route = $r->patch('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->patch('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->patch('/:foo' => (agent => qr/Firefox/) => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<PATCH> requests,
  takes the same arguments as L</"any"> (except for the HTTP methods to match,
  which are implied). See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
    # Route with destination
    $r->patch('/user')->to('user#update');
  
  =head2 post
  
    my $route = $r->post;
    my $route = $r->post('/:foo');
    my $route = $r->post('/:foo' => sub {...});
    my $route = $r->post('/:foo' => sub {...} => 'name');
    my $route = $r->post('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->post('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->post('/:foo' => (agent => qr/Firefox/) => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<POST> requests,
  takes the same arguments as L</"any"> (except for the HTTP methods to match,
  which are implied). See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
    # Route with destination
    $r->post('/user')->to('user#create');
  
  =head2 put
  
    my $route = $r->put;
    my $route = $r->put('/:foo');
    my $route = $r->put('/:foo' => sub {...});
    my $route = $r->put('/:foo' => sub {...} => 'name');
    my $route = $r->put('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->put('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->put('/:foo' => (agent => qr/Firefox/) => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<PUT> requests,
  takes the same arguments as L</"any"> (except for the HTTP methods to match,
  which are implied). See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
    # Route with destination
    $r->put('/user')->to('user#replace');
  
  =head2 remove
  
    $r = $r->remove;
  
  Remove route from parent.
  
    # Remove route completely
    $r->find('foo')->remove;
  
    # Reattach route to new parent
    $r->route('/foo')->add_child($r->find('bar')->remove);
  
  =head2 render
  
    my $path = $r->render({foo => 'bar'});
  
  Render route with parameters into a path.
  
  =head2 root
  
    my $root = $r->root;
  
  The L<Mojolicious::Routes> object this route is a descendant of.
  
  =head2 route
  
    my $route = $r->route;
    my $route = $r->route('/:action');
    my $route = $r->route('/:action', action => qr/\w+/);
    my $route = $r->route(format => 0);
  
  Low-level generator for routes matching all HTTP request methods, returns a
  L<Mojolicious::Routes::Route> object.
  
  =head2 suggested_method
  
    my $method = $r->suggested_method;
  
  Suggested HTTP method for reaching this route, C<GET> and C<POST> are
  preferred.
  
  =head2 to
  
    my $defaults = $r->to;
    $r           = $r->to(action => 'foo');
    $r           = $r->to({action => 'foo'});
    $r           = $r->to('controller#action');
    $r           = $r->to('controller#action', foo => 'bar');
    $r           = $r->to('controller#action', {foo => 'bar'});
    $r           = $r->to(Mojolicious->new);
    $r           = $r->to(Mojolicious->new, foo => 'bar');
    $r           = $r->to(Mojolicious->new, {foo => 'bar'});
    $r           = $r->to('MyApp');
    $r           = $r->to('MyApp', foo => 'bar');
    $r           = $r->to('MyApp', {foo => 'bar'});
  
  Set default parameters for this route.
  
  =head2 to_string
  
    my $str = $r->to_string;
  
  Stringify the whole route.
  
  =head2 under
  
    my $route = $r->under(sub {...});
    my $route = $r->under('/:foo' => sub {...});
    my $route = $r->under('/:foo' => {foo => 'bar'});
    my $route = $r->under('/:foo' => [foo => qr/\w+/]);
    my $route = $r->under('/:foo' => (agent => qr/Firefox/));
    my $route = $r->under([format => 0]);
  
  Generate L<Mojolicious::Routes::Route> object for a nested route with its own
  intermediate destination, takes the same arguments as L</"any"> (except for the
  HTTP methods to match, which are not available). See
  L<Mojolicious::Guides::Tutorial> and L<Mojolicious::Guides::Routing> for more
  information.
  
    # Intermediate destination and prefix shared between two routes
    my $auth = $r->under('/user')->to('user#auth');
    $auth->get('/show')->to('#show');
    $auth->post('/create')->to('#create');
  
  =head2 via
  
    my $methods = $r->via;
    $r          = $r->via('GET');
    $r          = $r->via('GET', 'POST');
    $r          = $r->via(['GET', 'POST']);
  
  Restrict HTTP methods this route is allowed to handle, defaults to no
  restrictions.
  
    # Route with two methods and destination
    $r->route('/foo')->via('GET', 'POST')->to('foo#bar');
  
  =head2 websocket
  
    my $route = $r->websocket;
    my $route = $r->websocket('/:foo');
    my $route = $r->websocket('/:foo' => sub {...});
    my $route = $r->websocket('/:foo' => sub {...} => 'name');
    my $route = $r->websocket('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->websocket('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->websocket('/:foo' => (agent => qr/Firefox/) => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only WebSocket
  handshakes, takes the same arguments as L</"any"> (except for the HTTP methods
  to match, which are implied). See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
    # Route with destination
    $r->websocket('/echo')->to('example#echo');
  
  =head1 AUTOLOAD
  
  In addition to the L</"ATTRIBUTES"> and L</"METHODS"> above you can also call
  shortcuts provided by L</"root"> on L<Mojolicious::Routes::Route> objects.
  
    # Add a "firefox" shortcut
    $r->root->add_shortcut(firefox => sub {
      my ($r, $path) = @_;
      $r->get($path, agent => qr/Firefox/);
    });
  
    # Use "firefox" shortcut to generate routes
    $r->firefox('/welcome')->to('firefox#welcome');
    $r->firefox('/bye')->to('firefox#bye');
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_ROUTES_ROUTE

$fatpacked{"Mojolicious/Sessions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_SESSIONS';
  package Mojolicious::Sessions;
  use Mojo::Base -base;
  
  use Mojo::JSON;
  use Mojo::Util qw(b64_decode b64_encode);
  
  has [qw(cookie_domain secure)];
  has cookie_name        => 'mojolicious';
  has cookie_path        => '/';
  has default_expiration => 3600;
  has deserialize        => sub { \&Mojo::JSON::j };
  has serialize          => sub { \&Mojo::JSON::encode_json };
  
  sub load {
    my ($self, $c) = @_;
  
    return unless my $value = $c->signed_cookie($self->cookie_name);
    $value =~ y/-/=/;
    return unless my $session = $self->deserialize->(b64_decode $value);
  
    # "expiration" value is inherited
    my $expiration = $session->{expiration} // $self->default_expiration;
    return if !(my $expires = delete $session->{expires}) && $expiration;
    return if defined $expires && $expires <= time;
  
    my $stash = $c->stash;
    return unless $stash->{'mojo.active_session'} = keys %$session;
    $stash->{'mojo.session'} = $session;
    $session->{flash} = delete $session->{new_flash} if $session->{new_flash};
  }
  
  sub store {
    my ($self, $c) = @_;
  
    # Make sure session was active
    my $stash = $c->stash;
    return unless my $session = $stash->{'mojo.session'};
    return unless keys %$session || $stash->{'mojo.active_session'};
  
    # Don't reset flash for static files
    my $old = delete $session->{flash};
    $session->{new_flash} = $old if $stash->{'mojo.static'};
    delete $session->{new_flash} unless keys %{$session->{new_flash}};
  
    # Generate "expires" value from "expiration" if necessary
    my $expiration = $session->{expiration} // $self->default_expiration;
    my $default    = delete $session->{expires};
    $session->{expires} = $default || time + $expiration
      if $expiration || $default;
  
    my $value = b64_encode $self->serialize->($session), '';
    $value =~ y/=/-/;
    my $options = {
      domain   => $self->cookie_domain,
      expires  => $session->{expires},
      httponly => 1,
      path     => $self->cookie_path,
      secure   => $self->secure
    };
    $c->signed_cookie($self->cookie_name, $value, $options);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Sessions - Session manager based on signed cookies
  
  =head1 SYNOPSIS
  
    use Mojolicious::Sessions;
  
    my $sessions = Mojolicious::Sessions->new;
    $sessions->cookie_name('myapp');
    $sessions->default_expiration(86400);
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Sessions> manages sessions based on signed cookies for
  L<Mojolicious>. All data gets serialized with L<Mojo::JSON> and stored Base64
  encoded on the client-side, but is protected from unwanted changes with a
  HMAC-SHA1 signature.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Sessions> implements the following attributes.
  
  =head2 cookie_domain
  
    my $domain = $sessions->cookie_domain;
    $sessions  = $sessions->cookie_domain('.example.com');
  
  Domain for session cookies, not defined by default.
  
  =head2 cookie_name
  
    my $name  = $sessions->cookie_name;
    $sessions = $sessions->cookie_name('session');
  
  Name for session cookies, defaults to C<mojolicious>.
  
  =head2 cookie_path
  
    my $path  = $sessions->cookie_path;
    $sessions = $sessions->cookie_path('/foo');
  
  Path for session cookies, defaults to C</>.
  
  =head2 default_expiration
  
    my $time  = $sessions->default_expiration;
    $sessions = $sessions->default_expiration(3600);
  
  Default time for sessions to expire in seconds from now, defaults to C<3600>.
  The expiration timeout gets refreshed for every request. Setting the value to
  C<0> will allow sessions to persist until the browser window is closed, this
  can have security implications though. For more control you can also use the
  C<expiration> and C<expires> session values.
  
    # Expiration date in seconds from now (persists between requests)
    $c->session(expiration => 604800);
  
    # Expiration date as absolute epoch time (only valid for one request)
    $c->session(expires => time + 604800);
  
    # Delete whole session by setting an expiration date in the past
    $c->session(expires => 1);
  
  =head2 deserialize
  
    my $cb    = $sessions->deserialize;
    $sessions = $sessions->deserialize(sub {...});
  
  A callback used to deserialize sessions, defaults to L<Mojo::JSON/"j">.
  
    $sessions->deserialize(sub {
      my $bytes = shift;
      return {};
    });
  
  =head2 secure
  
    my $bool  = $sessions->secure;
    $sessions = $sessions->secure($bool);
  
  Set the secure flag on all session cookies, so that browsers send them only
  over HTTPS connections.
  
  =head2 serialize
  
    my $cb    = $sessions->serialize;
    $sessions = $sessions->serialize(sub {...});
  
  A callback used to serialize sessions, defaults to L<Mojo::JSON/"encode_json">.
  
    $sessions->serialize(sub {
      my $hash = shift;
      return '';
    });
  
  =head1 METHODS
  
  L<Mojolicious::Sessions> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 load
  
    $sessions->load(Mojolicious::Controller->new);
  
  Load session data from signed cookie.
  
  =head2 store
  
    $sessions->store(Mojolicious::Controller->new);
  
  Store session data in signed cookie.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_SESSIONS

$fatpacked{"Mojolicious/Static.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_STATIC';
  package Mojolicious::Static;
  use Mojo::Base -base;
  
  use Mojo::Asset::File;
  use Mojo::Asset::Memory;
  use Mojo::Date;
  use Mojo::File 'path';
  use Mojo::Home;
  use Mojo::Loader qw(data_section file_is_binary);
  use Mojo::Util qw(encode md5_sum);
  
  # Bundled files
  my $PUBLIC = Mojo::Home->new(Mojo::Home->new->mojo_lib_dir)
    ->child('Mojolicious', 'resources', 'public');
  my %EXTRA = $PUBLIC->list_tree->map(
    sub { join('/', @{$_->to_rel($PUBLIC)}), $_->realpath->to_string })->each;
  
  has classes => sub { ['main'] };
  has extra   => sub { +{%EXTRA} };
  has paths   => sub { [] };
  
  sub dispatch {
    my ($self, $c) = @_;
  
    # Method (GET or HEAD)
    my $req    = $c->req;
    my $method = $req->method;
    return undef unless $method eq 'GET' || $method eq 'HEAD';
  
    # Canonical path
    my $stash = $c->stash;
    my $path  = $req->url->path;
    $path = $stash->{path} ? $path->new($stash->{path}) : $path->clone;
    return undef unless my @parts = @{$path->canonicalize->parts};
  
    # Serve static file and prevent path traversal
    my $canon_path = join '/', @parts;
    return undef if $canon_path =~ /^\.\.\/|\\/ || !$self->serve($c, $canon_path);
    $stash->{'mojo.static'} = 1;
    return !!$c->rendered;
  }
  
  sub file {
    my ($self, $rel) = @_;
  
    # Search all paths
    my @parts = split '/', $rel;
    for my $path (@{$self->paths}) {
      next unless my $asset = _get_file(path($path, @parts)->to_string);
      return $asset;
    }
  
    # Search DATA
    if (my $asset = $self->_get_data_file($rel)) { return $asset }
  
    # Search extra files
    my $extra = $self->extra;
    return exists $extra->{$rel} ? _get_file($extra->{$rel}) : undef;
  }
  
  sub is_fresh {
    my ($self, $c, $options) = @_;
  
    my $res_headers = $c->res->headers;
    my ($last, $etag) = @$options{qw(last_modified etag)};
    $res_headers->last_modified(Mojo::Date->new($last)->to_string) if $last;
    $res_headers->etag($etag = qq{"$etag"}) if $etag;
  
    # Unconditional
    my $req_headers = $c->req->headers;
    my $match       = $req_headers->if_none_match;
    return undef unless (my $since = $req_headers->if_modified_since) || $match;
  
    # If-None-Match
    return undef if $match && ($etag // $res_headers->etag // '') ne $match;
  
    # If-Modified-Since
    return !!$match unless ($last //= $res_headers->last_modified) && $since;
    return _epoch($last) <= (_epoch($since) // 0);
  }
  
  sub serve {
    my ($self, $c, $rel) = @_;
  
    return undef unless my $asset = $self->file($rel);
    my $headers = $c->res->headers;
    return !!$self->serve_asset($c, $asset) if $headers->content_type;
  
    # Content-Type
    my $types = $c->app->types;
    my $type = $rel =~ /\.(\w+)$/ ? $types->type($1) : undef;
    $headers->content_type($type || $types->type('txt'));
    return !!$self->serve_asset($c, $asset);
  }
  
  sub serve_asset {
    my ($self, $c, $asset) = @_;
  
    # Last-Modified and ETag
    my $res = $c->res;
    $res->code(200)->headers->accept_ranges('bytes');
    my $mtime = $asset->mtime;
    my $options = {etag => md5_sum($mtime), last_modified => $mtime};
    return $res->code(304) if $self->is_fresh($c, $options);
  
    # Range
    return $res->content->asset($asset)
      unless my $range = $c->req->headers->range;
  
    # Not satisfiable
    return $res->code(416) unless my $size = $asset->size;
    return $res->code(416) unless $range =~ /^bytes=(\d+)?-(\d+)?/;
    my ($start, $end) = ($1 // 0, defined $2 && $2 < $size ? $2 : $size - 1);
    return $res->code(416) if $start > $end;
  
    # Satisfiable
    $res->code(206)->headers->content_length($end - $start + 1)
      ->content_range("bytes $start-$end/$size");
    return $res->content->asset($asset->start_range($start)->end_range($end));
  }
  
  sub warmup {
    my $self = shift;
    my $index = $self->{index} = {};
    for my $class (reverse @{$self->classes}) {
      $index->{$_} = $class for keys %{data_section $class};
    }
  }
  
  sub _epoch { Mojo::Date->new(shift)->epoch }
  
  sub _get_data_file {
    my ($self, $rel) = @_;
  
    # Protect files without extensions and templates with two extensions
    return undef if $rel !~ /\.\w+$/ || $rel =~ /\.\w+\.\w+$/;
  
    $self->warmup unless $self->{index};
  
    # Find file
    my @args = ($self->{index}{$rel}, $rel);
    return undef unless defined(my $data = data_section(@args));
    return Mojo::Asset::Memory->new->add_chunk(
      file_is_binary(@args) ? $data : encode 'UTF-8', $data);
  }
  
  sub _get_file {
    my $path = shift;
    no warnings 'newline';
    return -f $path && -r _ ? Mojo::Asset::File->new(path => $path) : undef;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Static - Serve static files
  
  =head1 SYNOPSIS
  
    use Mojolicious::Static;
  
    my $static = Mojolicious::Static->new;
    push @{$static->classes}, 'MyApp::Controller::Foo';
    push @{$static->paths}, '/home/sri/public';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Static> is a static file server with C<Range>,
  C<If-Modified-Since> and C<If-None-Match> support, based on
  L<RFC 7232|http://tools.ietf.org/html/rfc7232> and
  L<RFC 7233|http://tools.ietf.org/html/rfc7233>.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Static> implements the following attributes.
  
  =head2 classes
  
    my $classes = $static->classes;
    $static     = $static->classes(['main']);
  
  Classes to use for finding files in C<DATA> sections with L<Mojo::Loader>,
  first one has the highest precedence, defaults to C<main>. Only files with
  exactly one extension will be used, like C<index.html>. Note that for files to
  be detected, these classes need to have already been loaded and added before
  L</"warmup"> is called, which usually happens automatically during application
  startup.
  
    # Add another class with static files in DATA section
    push @{$static->classes}, 'Mojolicious::Plugin::Fun';
  
    # Add another class with static files in DATA section and higher precedence
    unshift @{$static->classes}, 'Mojolicious::Plugin::MoreFun';
  
  =head2 extra
  
    my $extra = $static->extra;
    $static   = $static->extra({'foo/bar.txt' => '/home/sri/myapp/bar.txt'});
  
  Paths for extra files to be served from locations other than L</"paths">, such
  as the images used by the built-in exception and not found pages. Note that
  extra files are only served if no better alternative could be found in
  L</"paths"> and L</"classes">.
  
    # Remove built-in favicon
    delete $static->extra->{'favicon.ico'};
  
  =head2 paths
  
    my $paths = $static->paths;
    $static   = $static->paths(['/home/sri/public']);
  
  Directories to serve static files from, first one has the highest precedence.
  
    # Add another "public" directory
    push @{$static->paths}, '/home/sri/public';
  
    # Add another "public" directory with higher precedence
    unshift @{$static->paths}, '/home/sri/themes/blue/public';
  
  =head1 METHODS
  
  L<Mojolicious::Static> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 dispatch
  
    my $bool = $static->dispatch(Mojolicious::Controller->new);
  
  Serve static file for L<Mojolicious::Controller> object.
  
  =head2 file
  
    my $asset = $static->file('images/logo.png');
    my $asset = $static->file('../lib/MyApp.pm');
  
  Build L<Mojo::Asset::File> or L<Mojo::Asset::Memory> object for a file,
  relative to L</"paths"> or from L</"classes">, or return C<undef> if it doesn't
  exist. Note that this method uses a relative path, but does not protect from
  traversing to parent directories.
  
    my $content = $static->file('foo/bar.html')->slurp;
  
  =head2 is_fresh
  
    my $bool = $static->is_fresh(Mojolicious::Controller->new, {etag => 'abc'});
  
  Check freshness of request by comparing the C<If-None-Match> and
  C<If-Modified-Since> request headers to the C<ETag> and C<Last-Modified>
  response headers.
  
  These options are currently available:
  
  =over 2
  
  =item etag
  
    etag => 'abc'
  
  Add C<ETag> header before comparing.
  
  =item last_modified
  
    last_modified => $epoch
  
  Add C<Last-Modified> header before comparing.
  
  =back
  
  =head2 serve
  
    my $bool = $static->serve(Mojolicious::Controller->new, 'images/logo.png');
    my $bool = $static->serve(Mojolicious::Controller->new, '../lib/MyApp.pm');
  
  Serve a specific file, relative to L</"paths"> or from L</"classes">. Note that
  this method uses a relative path, but does not protect from traversing to parent
  directories.
  
  =head2 serve_asset
  
    $static->serve_asset(Mojolicious::Controller->new, Mojo::Asset::File->new);
  
  Serve a L<Mojo::Asset::File> or L<Mojo::Asset::Memory> object with C<Range>,
  C<If-Modified-Since> and C<If-None-Match> support.
  
  =head2 warmup
  
    $static->warmup;
  
  Prepare static files from L</"classes"> for future use.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_STATIC

$fatpacked{"Mojolicious/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_TYPES';
  package Mojolicious::Types;
  use Mojo::Base -base;
  
  has mapping => sub {
    {
      appcache => ['text/cache-manifest'],
      atom     => ['application/atom+xml'],
      bin      => ['application/octet-stream'],
      css      => ['text/css'],
      gif      => ['image/gif'],
      gz       => ['application/x-gzip'],
      htm      => ['text/html'],
      html     => ['text/html;charset=UTF-8'],
      ico      => ['image/x-icon'],
      jpeg     => ['image/jpeg'],
      jpg      => ['image/jpeg'],
      js       => ['application/javascript'],
      json     => ['application/json;charset=UTF-8'],
      mp3      => ['audio/mpeg'],
      mp4      => ['video/mp4'],
      ogg      => ['audio/ogg'],
      ogv      => ['video/ogg'],
      pdf      => ['application/pdf'],
      png      => ['image/png'],
      rss      => ['application/rss+xml'],
      svg      => ['image/svg+xml'],
      txt      => ['text/plain;charset=UTF-8'],
      webm     => ['video/webm'],
      woff     => ['application/font-woff'],
      xml      => ['application/xml', 'text/xml'],
      zip      => ['application/zip']
    };
  };
  
  sub detect {
    my ($self, $accept) = @_;
  
    # Extract and prioritize MIME types
    my %types;
    /^\s*([^,; ]+)(?:\s*\;\s*q\s*=\s*(\d+(?:\.\d+)?))?\s*$/i
      and $types{lc $1} = $2 // 1
      for split ',', $accept // '';
    my @detected = sort { $types{$b} <=> $types{$a} } sort keys %types;
  
    # Detect extensions from MIME types
    my %reverse;
    my $mapping = $self->mapping;
    for my $ext (sort keys %$mapping) {
      my @types = @{$mapping->{$ext}};
      push @{$reverse{$_}}, $ext for map { s/\;.*$//; lc $_ } @types;
    }
  
    return [map { @{$reverse{$_} // []} } @detected];
  }
  
  sub type {
    my ($self, $ext, $type) = @_;
    return $self->mapping->{lc $ext}[0] unless $type;
    $self->mapping->{lc $ext} = ref $type ? $type : [$type];
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Types - MIME types
  
  =head1 SYNOPSIS
  
    use Mojolicious::Types;
  
    my $types = Mojolicious::Types->new;
    $types->type(foo => 'text/foo');
    say $types->type('foo');
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Types> manages MIME types for L<Mojolicious>.
  
    appcache -> text/cache-manifest
    atom     -> application/atom+xml
    bin      -> application/octet-stream
    css      -> text/css
    gif      -> image/gif
    gz       -> application/x-gzip
    htm      -> text/html
    html     -> text/html;charset=UTF-8
    ico      -> image/x-icon
    jpeg     -> image/jpeg
    jpg      -> image/jpeg
    js       -> application/javascript
    json     -> application/json;charset=UTF-8
    mp3      -> audio/mpeg
    mp4      -> video/mp4
    ogg      -> audio/ogg
    ogv      -> video/ogg
    pdf      -> application/pdf
    png      -> image/png
    rss      -> application/rss+xml
    svg      -> image/svg+xml
    txt      -> text/plain;charset=UTF-8
    webm     -> video/webm
    woff     -> application/font-woff
    xml      -> application/xml,text/xml
    zip      -> application/zip
  
  The most common ones are already defined.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Types> implements the following attributes.
  
  =head2 mapping
  
    my $mapping = $types->mapping;
    $types      = $types->mapping({png => ['image/png']});
  
  MIME type mapping.
  
  =head1 METHODS
  
  L<Mojolicious::Types> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 detect
  
    my $exts = $types->detect('text/html, application/json;q=9');
  
  Detect file extensions from C<Accept> header value.
  
    # List detected extensions prioritized
    say for @{$types->detect('application/json, text/xml;q=0.1', 1)};
  
  =head2 type
  
    my $type = $types->type('png');
    $types   = $types->type(png => 'image/png');
    $types   = $types->type(json => ['application/json', 'text/x-json']);
  
  Get or set MIME types for file extension, alternatives are only used for
  detection.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_TYPES

$fatpacked{"Mojolicious/Validator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_VALIDATOR';
  package Mojolicious::Validator;
  use Mojo::Base -base;
  
  use Mojo::Util 'trim';
  use Mojolicious::Validator::Validation;
  
  has checks => sub {
    {
      equal_to => \&_equal_to,
      in       => \&_in,
      like     => sub { $_[2] !~ $_[3] },
      num      => \&_num,
      size     => \&_size,
      upload   => sub { !ref $_[2] || !$_[2]->isa('Mojo::Upload') }
    };
  };
  has filters => sub { {trim => \&_trim} };
  
  sub add_check  { $_[0]->checks->{$_[1]}  = $_[2] and return $_[0] }
  sub add_filter { $_[0]->filters->{$_[1]} = $_[2] and return $_[0] }
  
  sub validation {
    Mojolicious::Validator::Validation->new(validator => shift);
  }
  
  sub _equal_to {
    my ($v, $name, $value, $to) = @_;
    return 1 unless defined(my $other = $v->input->{$to});
    return $value ne $other;
  }
  
  sub _in {
    my ($v, $name, $value) = (shift, shift, shift);
    $value eq $_ && return undef for @_;
    return 1;
  }
  
  sub _num {
    my ($v, $name, $value, $min, $max) = @_;
    return 1 if $value !~ /^[0-9]+$/;
    return defined $min && $min > $value || defined $max && $max < $value;
  }
  
  sub _size {
    my ($v, $name, $value, $min, $max) = @_;
    my $len = ref $value ? $value->size : length $value;
    return $len < $min || $len > $max;
  }
  
  sub _trim { trim $_[2] // '' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Validator - Validate values
  
  =head1 SYNOPSIS
  
    use Mojolicious::Validator;
  
    my $validator = Mojolicious::Validator->new;
    my $v = $validator->validation;
    $v->input({foo => 'bar'});
    $v->required('foo')->like(qr/ar$/);
    say $v->param('foo');
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Validator> validates values for L<Mojolicious>.
  
  =head1 CHECKS
  
  These validation checks are available by default.
  
  =head2 equal_to
  
    $v = $v->equal_to('foo');
  
  String value needs to be equal to the value of another field.
  
  =head2 in
  
    $v = $v->in('foo', 'bar', 'baz');
  
  String value needs to match one of the values in the list.
  
  =head2 like
  
    $v = $v->like(qr/^[A-Z]/);
  
  String value needs to match the regular expression.
  
  =head2 num
  
    $v = $v->num;
    $v = $v->num(2, 5);
    $v = $v->num(2, undef);
    $v = $v->num(undef, 5);
  
  String value needs to be a non-fractional number and if provided in the given
  range.
  
  =head2 size
  
    $v = $v->size(2, 5);
  
  String value length or size of L<Mojo::Upload> object in bytes needs to be
  between these two values.
  
  =head2 upload
  
    $v = $v->upload;
  
  Value needs to be a L<Mojo::Upload> object, representing a file upload.
  
  =head1 FILTERS
  
  These filters are available by default.
  
  =head2 trim
  
    $v = $v->optional('foo', 'trim');
  
  Trim whitespace characters from both ends of string value with
  L<Mojo::Util/"trim">.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Validator> implements the following attributes.
  
  =head2 checks
  
    my $checks = $validator->checks;
    $validator = $validator->checks({size => sub {...}});
  
  Registered validation checks, by default only L</"equal_to">, L</"in">,
  L</"like">, L</"num">, L</"size"> and L</"upload"> are already defined.
  
  =head1 METHODS
  
  L<Mojolicious::Validator> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 add_check
  
    $validator = $validator->add_check(size => sub {...});
  
  Register a validation check.
  
    $validator->add_check(foo => sub {
      my ($v, $name, $value, @args) = @_;
      ...
      return undef;
    });
  
  =head2 add_filter
  
    $validator = $validator->add_filter(trim => sub {...});
  
  Register a new filter.
  
    $validator->add_filter(foo => sub {
      my ($v, $name, $value) = @_;
      ...
      return $value;
    });
  
  =head2 validation
  
    my $v = $validator->validation;
  
  Build L<Mojolicious::Validator::Validation> object to perform validations.
  
    my $v = $validator->validation;
    $v->input({foo => 'bar'});
    $v->required('foo')->size(1, 5);
    say $v->param('foo');
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_VALIDATOR

$fatpacked{"Mojolicious/Validator/Validation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_VALIDATOR_VALIDATION';
  package Mojolicious::Validator::Validation;
  use Mojo::Base -base;
  
  use Carp         ();
  use Scalar::Util ();
  
  has [qw(csrf_token topic validator)];
  has [qw(input output)] => sub { {} };
  
  sub AUTOLOAD {
    my $self = shift;
  
    my ($package, $method) = our $AUTOLOAD =~ /^(.+)::(.+)$/;
    Carp::croak "Undefined subroutine &${package}::$method called"
      unless Scalar::Util::blessed $self && $self->isa(__PACKAGE__);
  
    return $self->check($method => @_) if $self->validator->checks->{$method};
    Carp::croak qq{Can't locate object method "$method" via package "$package"};
  }
  
  sub check {
    my ($self, $check) = (shift, shift);
  
    return $self unless $self->is_valid;
  
    my $cb     = $self->validator->checks->{$check};
    my $name   = $self->topic;
    my $values = $self->output->{$name};
    for my $value (ref $values eq 'ARRAY' ? @$values : $values) {
      next unless my $result = $self->$cb($name, $value, @_);
      return $self->error($name => [$check, $result, @_]);
    }
  
    return $self;
  }
  
  sub csrf_protect {
    my $self  = shift;
    my $token = $self->input->{csrf_token};
    $self->error(csrf_token => ['csrf_protect'])
      unless $token && $token eq ($self->csrf_token // '');
    return $self;
  }
  
  sub error {
    my ($self, $name) = (shift, shift);
    return $self->{error}{$name} unless @_;
    $self->{error}{$name} = shift;
    delete $self->output->{$name};
    return $self;
  }
  
  sub every_param {
    return [] unless defined(my $value = $_[0]->output->{$_[1] // $_[0]->topic});
    return [ref $value eq 'ARRAY' ? @$value : $value];
  }
  
  sub failed { [sort keys %{shift->{error}}] }
  
  sub has_data { !!keys %{shift->input} }
  
  sub has_error { $_[1] ? exists $_[0]{error}{$_[1]} : !!keys %{$_[0]{error}} }
  
  sub is_valid { exists $_[0]->output->{$_[1] // $_[0]->topic} }
  
  sub optional {
    my ($self, $name, @filters) = @_;
  
    return $self->topic($name) unless defined(my $input = $self->input->{$name});
  
    my @input = ref $input eq 'ARRAY' ? @$input : ($input);
    for my $cb (map { $self->validator->filters->{$_} } @filters) {
      @input = map { $self->$cb($name, $_) } @input;
    }
    $self->output->{$name} = ref $input eq 'ARRAY' ? \@input : $input[0]
      if @input && !grep { !length } @input;
  
    return $self->topic($name);
  }
  
  sub param { shift->every_param(shift)->[-1] }
  
  sub passed { [sort keys %{shift->output}] }
  
  sub required {
    my ($self, $name) = (shift, shift);
    return $self if $self->optional($name, @_)->is_valid;
    return $self->error($name => ['required']);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Validator::Validation - Perform validations
  
  =head1 SYNOPSIS
  
    use Mojolicious::Validator;
    use Mojolicious::Validator::Validation;
  
    my $validator = Mojolicious::Validator->new;
    my $v = Mojolicious::Validator::Validation->new(validator => $validator);
    $v->input({foo => 'bar'});
    $v->required('foo')->in('bar', 'baz');
    say $v->param('foo');
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Validator::Validation> performs L<Mojolicious::Validator>
  validation checks.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Validator::Validation> implements the following attributes.
  
  =head2 csrf_token
  
    my $token = $v->csrf_token;
    $v        = $v->csrf_token('fa6a08...');
  
  CSRF token.
  
  =head2 input
  
    my $input = $v->input;
    $v        = $v->input({foo => 'bar', baz => [123, 'yada']});
  
  Data to be validated.
  
  =head2 output
  
    my $output = $v->output;
    $v         = $v->output({foo => 'bar', baz => [123, 'yada']});
  
  Validated data.
  
  =head2 topic
  
    my $topic = $v->topic;
    $v        = $v->topic('foo');
  
  Name of field currently being validated.
  
  =head2 validator
  
    my $v = $v->validator;
    $v    = $v->validator(Mojolicious::Validator->new);
  
  L<Mojolicious::Validator> object this validation belongs to.
  
  =head1 METHODS
  
  L<Mojolicious::Validator::Validation> inherits all methods from L<Mojo::Base>
  and implements the following new ones.
  
  =head2 check
  
    $v = $v->check('size', 2, 7);
  
  Perform validation check on all values of the current L</"topic">, no more
  checks will be performed on them after the first one failed. All checks from
  L<Mojolicious::Validator/"CHECKS"> are supported.
  
  =head2 csrf_protect
  
    $v = $v->csrf_protect;
  
  Validate C<csrf_token> and protect from cross-site request forgery.
  
  =head2 error
  
    my $err = $v->error('foo');
    $v      = $v->error(foo => ['custom_check']);
    $v      = $v->error(foo => [$check, $result, @args]);
  
  Get or set details for failed validation check, at any given time there can
  only be one per field.
  
    # Details about failed validation
    my ($check, $result, @args) = @{$v->error('foo')};
  
    # Force validation to fail for a field without performing a check
    $v->error(foo => ['some_made_up_check_name']);
  
  =head2 every_param
  
    my $values = $v->every_param;
    my $values = $v->every_param('foo');
  
  Similar to L</"param">, but returns all values sharing the same name as an
  array reference.
  
    # Get first value
    my $first = $v->every_param('foo')->[0];
  
  =head2 failed
  
    my $names = $v->failed;
  
  Return an array reference with all names for values that failed validation.
  
    # Names of all values that failed
    say for @{$v->failed};
  
  =head2 has_data
  
    my $bool = $v->has_data;
  
  Check if L</"input"> is available for validation.
  
  =head2 has_error
  
    my $bool = $v->has_error;
    my $bool = $v->has_error('foo');
  
  Check if validation resulted in errors, defaults to checking all fields.
  
  =head2 is_valid
  
    my $bool = $v->is_valid;
    my $bool = $v->is_valid('foo');
  
  Check if validation was successful and field has a value, defaults to checking
  the current L</"topic">.
  
  =head2 optional
  
    $v = $v->optional('foo');
    $v = $v->optional('foo', 'filter1', 'filter2');
  
  Change validation L</"topic"> and apply filters. All filters from
  L<Mojolicious::Validator/"FILTERS"> are supported.
  
    # Trim value and check size
    $v->optional('user', 'trim')->size(1, 15);
  
  =head2 param
  
    my $value = $v->param;
    my $value = $v->param('foo');
  
  Access validated values, defaults to the current L</"topic">. If there are
  multiple values sharing the same name, and you want to access more than just the
  last one, you can use L</"every_param">.
  
    # Get value right away
    my $user = $v->optional('user')->size(1, 15)->param;
  
  =head2 passed
  
    my $names = $v->passed;
  
  Return an array reference with all names for values that passed validation.
  
    # Names of all values that passed
    say for @{$v->passed};
  
  =head2 required
  
    $v = $v->required('foo');
    $v = $v->required('foo', 'filter1', 'filter2');
  
  Change validation L</"topic">, apply filters, and make sure a value is present
  and not an empty string. All filters from L<Mojolicious::Validator/"FILTERS">
  are supported.
  
    # Trim value and check size
    $v->required('user', 'trim')->size(1, 15);
  
  =head1 AUTOLOAD
  
  In addition to the L</"ATTRIBUTES"> and L</"METHODS"> above, you can also call
  validation checks provided by L</"validator"> on
  L<Mojolicious::Validator::Validation> objects, similar to L</"check">.
  
    # Call validation checks
    $v->required('foo')->size(2, 5)->like(qr/^[A-Z]/);
    $v->optional('bar')->equal_to('foo');
    $v->optional('baz')->in('test', '123');
  
    # Longer version
    $v->required('foo')->check('size', 2, 5)->check('like', qr/^[A-Z]/);
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_VALIDATOR_VALIDATION

$fatpacked{"Role/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY';
  package Role::Tiny;
  
  sub _getglob { \*{$_[0]} }
  sub _getstash { \%{"$_[0]::"} }
  
  use strict;
  use warnings;
  
  our $VERSION = '2.000006';
  $VERSION =~ tr/_//d;
  
  our %INFO;
  our %APPLIED_TO;
  our %COMPOSED;
  our %COMPOSITE_INFO;
  our @ON_ROLE_CREATE;
  
  # Module state workaround totally stolen from Zefram's Module::Runtime.
  
  BEGIN {
    *_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
    *_WORK_AROUND_HINT_LEAKAGE
      = "$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
        ? sub(){1} : sub(){0};
    *_MRO_MODULE = "$]" < 5.010 ? sub(){"MRO/Compat.pm"} : sub(){"mro.pm"};
  }
  
  sub croak {
    require Carp;
    no warnings 'redefine';
    *croak = \&Carp::croak;
    goto &Carp::croak;
  }
  
  sub Role::Tiny::__GUARD__::DESTROY {
    delete $INC{$_[0]->[0]} if @{$_[0]};
  }
  
  sub _load_module {
    my ($module) = @_;
    (my $file = "$module.pm") =~ s{::}{/}g;
    return 1
      if $INC{$file};
  
    # can't just ->can('can') because a sub-package Foo::Bar::Baz
    # creates a 'Baz::' key in Foo::Bar's symbol table
    return 1
      if grep !/::\z/, keys %{_getstash($module)};
    my $guard = _WORK_AROUND_BROKEN_MODULE_STATE
      && bless([ $file ], 'Role::Tiny::__GUARD__');
    local %^H if _WORK_AROUND_HINT_LEAKAGE;
    require $file;
    pop @$guard if _WORK_AROUND_BROKEN_MODULE_STATE;
    return 1;
  }
  
  sub import {
    my $target = caller;
    my $me = shift;
    strict->import;
    warnings->import;
    $me->_install_subs($target);
    return if $me->is_role($target); # already exported into this package
    $INFO{$target}{is_role} = 1;
    # get symbol table reference
    my $stash = _getstash($target);
    # grab all *non-constant* (stash slot is not a scalarref) subs present
    # in the symbol table and store their refaddrs (no need to forcibly
    # inflate constant subs into real subs) with a map to the coderefs in
    # case of copying or re-use
    my @not_methods = map +(ref $_ eq 'CODE' ? $_ : ref $_ ? () : *$_{CODE}||()), values %$stash;
    @{$INFO{$target}{not_methods}={}}{@not_methods} = @not_methods;
    # a role does itself
    $APPLIED_TO{$target} = { $target => undef };
    foreach my $hook (@ON_ROLE_CREATE) {
      $hook->($target);
    }
  }
  
  sub _install_subs {
    my ($me, $target) = @_;
    return if $me->is_role($target);
    # install before/after/around subs
    foreach my $type (qw(before after around)) {
      *{_getglob "${target}::${type}"} = sub {
        push @{$INFO{$target}{modifiers}||=[]}, [ $type => @_ ];
        return;
      };
    }
    *{_getglob "${target}::requires"} = sub {
      push @{$INFO{$target}{requires}||=[]}, @_;
      return;
    };
    *{_getglob "${target}::with"} = sub {
      $me->apply_roles_to_package($target, @_);
      return;
    };
  }
  
  sub role_application_steps {
    qw(_install_methods _check_requires _install_modifiers _copy_applied_list);
  }
  
  sub apply_single_role_to_package {
    my ($me, $to, $role) = @_;
  
    _load_module($role);
  
    croak "This is apply_role_to_package" if ref($to);
    croak "${role} is not a Role::Tiny" unless $me->is_role($role);
  
    foreach my $step ($me->role_application_steps) {
      $me->$step($to, $role);
    }
  }
  
  sub _copy_applied_list {
    my ($me, $to, $role) = @_;
    # copy our role list into the target's
    @{$APPLIED_TO{$to}||={}}{keys %{$APPLIED_TO{$role}}} = ();
  }
  
  sub apply_roles_to_object {
    my ($me, $object, @roles) = @_;
    croak "No roles supplied!" unless @roles;
    my $class = ref($object);
    # on perl < 5.8.9, magic isn't copied to all ref copies. bless the parameter
    # directly, so at least the variable passed to us will get any magic applied
    bless($_[1], $me->create_class_with_roles($class, @roles));
  }
  
  my $role_suffix = 'A000';
  sub _composite_name {
    my ($me, $superclass, @roles) = @_;
  
    my $new_name = join(
      '__WITH__', $superclass, my $compose_name = join '__AND__', @roles
    );
  
    if (length($new_name) > 252) {
      $new_name = $COMPOSED{abbrev}{$new_name} ||= do {
        my $abbrev = substr $new_name, 0, 250 - length $role_suffix;
        $abbrev =~ s/(?<!:):$//;
        $abbrev.'__'.$role_suffix++;
      };
    }
    return wantarray ? ($new_name, $compose_name) : $new_name;
  }
  
  sub create_class_with_roles {
    my ($me, $superclass, @roles) = @_;
  
    croak "No roles supplied!" unless @roles;
  
    _load_module($superclass);
    {
      my %seen;
      if (my @dupes = grep 1 == $seen{$_}++, @roles) {
        croak "Duplicated roles: ".join(', ', @dupes);
      }
    }
  
    my ($new_name, $compose_name) = $me->_composite_name($superclass, @roles);
  
    return $new_name if $COMPOSED{class}{$new_name};
  
    foreach my $role (@roles) {
      _load_module($role);
      croak "${role} is not a Role::Tiny" unless $me->is_role($role);
    }
  
    require(_MRO_MODULE);
  
    my $composite_info = $me->_composite_info_for(@roles);
    my %conflicts = %{$composite_info->{conflicts}};
    if (keys %conflicts) {
      my $fail =
        join "\n",
          map {
            "Method name conflict for '$_' between roles "
            ."'".join("' and '", sort values %{$conflicts{$_}})."'"
            .", cannot apply these simultaneously to an object."
          } keys %conflicts;
      croak $fail;
    }
  
    my @composable = map $me->_composable_package_for($_), reverse @roles;
  
    # some methods may not exist in the role, but get generated by
    # _composable_package_for (Moose accessors via Moo).  filter out anything
    # provided by the composable packages, excluding the subs we generated to
    # make modifiers work.
    my @requires = grep {
      my $method = $_;
      !grep $_->can($method) && !$COMPOSED{role}{$_}{modifiers_only}{$method},
        @composable
    } @{$composite_info->{requires}};
  
    $me->_check_requires(
      $superclass, $compose_name, \@requires
    );
  
    *{_getglob("${new_name}::ISA")} = [ @composable, $superclass ];
  
    @{$APPLIED_TO{$new_name}||={}}{
      map keys %{$APPLIED_TO{$_}}, @roles
    } = ();
  
    $COMPOSED{class}{$new_name} = 1;
    return $new_name;
  }
  
  # preserved for compat, and apply_roles_to_package calls it to allow an
  # updated Role::Tiny to use a non-updated Moo::Role
  
  sub apply_role_to_package { shift->apply_single_role_to_package(@_) }
  
  sub apply_roles_to_package {
    my ($me, $to, @roles) = @_;
  
    return $me->apply_role_to_package($to, $roles[0]) if @roles == 1;
  
    my %conflicts = %{$me->_composite_info_for(@roles)->{conflicts}};
    my @have = grep $to->can($_), keys %conflicts;
    delete @conflicts{@have};
  
    if (keys %conflicts) {
      my $fail =
        join "\n",
          map {
            "Due to a method name conflict between roles "
            ."'".join(' and ', sort values %{$conflicts{$_}})."'"
            .", the method '$_' must be implemented by '${to}'"
          } keys %conflicts;
      croak $fail;
    }
  
    # conflicting methods are supposed to be treated as required by the
    # composed role. we don't have an actual composed role, but because
    # we know the target class already provides them, we can instead
    # pretend that the roles don't do for the duration of application.
    my @role_methods = map $me->_concrete_methods_of($_), @roles;
    # separate loops, since local ..., delete ... for ...; creates a scope
    local @{$_}{@have} for @role_methods;
    delete @{$_}{@have} for @role_methods;
  
    # the if guard here is essential since otherwise we accidentally create
    # a $INFO for something that isn't a Role::Tiny (or Moo::Role) because
    # autovivification hates us and wants us to die()
    if ($INFO{$to}) {
      delete $INFO{$to}{methods}; # reset since we're about to add methods
    }
  
    # backcompat: allow subclasses to use apply_single_role_to_package
    # to apply changes.  set a local var so ours does nothing.
    our %BACKCOMPAT_HACK;
    if($me ne __PACKAGE__
        and exists $BACKCOMPAT_HACK{$me} ? $BACKCOMPAT_HACK{$me} :
        $BACKCOMPAT_HACK{$me} =
          $me->can('role_application_steps')
            == \&role_application_steps
          && $me->can('apply_single_role_to_package')
            != \&apply_single_role_to_package
    ) {
      foreach my $role (@roles) {
        $me->apply_single_role_to_package($to, $role);
      }
    }
    else {
      foreach my $step ($me->role_application_steps) {
        foreach my $role (@roles) {
          $me->$step($to, $role);
        }
      }
    }
    $APPLIED_TO{$to}{join('|',@roles)} = 1;
  }
  
  sub _composite_info_for {
    my ($me, @roles) = @_;
    $COMPOSITE_INFO{join('|', sort @roles)} ||= do {
      foreach my $role (@roles) {
        _load_module($role);
      }
      my %methods;
      foreach my $role (@roles) {
        my $this_methods = $me->_concrete_methods_of($role);
        $methods{$_}{$this_methods->{$_}} = $role for keys %$this_methods;
      }
      my %requires;
      @requires{map @{$INFO{$_}{requires}||[]}, @roles} = ();
      delete $requires{$_} for keys %methods;
      delete $methods{$_} for grep keys(%{$methods{$_}}) == 1, keys %methods;
      +{ conflicts => \%methods, requires => [keys %requires] }
    };
  }
  
  sub _composable_package_for {
    my ($me, $role) = @_;
    my $composed_name = 'Role::Tiny::_COMPOSABLE::'.$role;
    return $composed_name if $COMPOSED{role}{$composed_name};
    $me->_install_methods($composed_name, $role);
    my $base_name = $composed_name.'::_BASE';
    # force stash to exist so ->can doesn't complain
    _getstash($base_name);
    # Not using _getglob, since setting @ISA via the typeglob breaks
    # inheritance on 5.10.0 if the stash has previously been accessed an
    # then a method called on the class (in that order!), which
    # ->_install_methods (with the help of ->_install_does) ends up doing.
    { no strict 'refs'; @{"${composed_name}::ISA"} = ( $base_name ); }
    my $modifiers = $INFO{$role}{modifiers}||[];
    my @mod_base;
    my @modifiers = grep !$composed_name->can($_),
      do { my %h; @h{map @{$_}[1..$#$_-1], @$modifiers} = (); keys %h };
    foreach my $modified (@modifiers) {
      push @mod_base, "sub ${modified} { shift->next::method(\@_) }";
    }
    my $e;
    {
      local $@;
      eval(my $code = join "\n", "package ${base_name};", @mod_base);
      $e = "Evaling failed: $@\nTrying to eval:\n${code}" if $@;
    }
    die $e if $e;
    $me->_install_modifiers($composed_name, $role);
    $COMPOSED{role}{$composed_name} = {
      modifiers_only => { map { $_ => 1 } @modifiers },
    };
    return $composed_name;
  }
  
  sub _check_requires {
    my ($me, $to, $name, $requires) = @_;
    return unless my @requires = @{$requires||$INFO{$name}{requires}||[]};
    if (my @requires_fail = grep !$to->can($_), @requires) {
      # role -> role, add to requires, role -> class, error out
      if (my $to_info = $INFO{$to}) {
        push @{$to_info->{requires}||=[]}, @requires_fail;
      } else {
        croak "Can't apply ${name} to ${to} - missing ".join(', ', @requires_fail);
      }
    }
  }
  
  sub _concrete_methods_of {
    my ($me, $role) = @_;
    my $info = $INFO{$role};
    # grab role symbol table
    my $stash = _getstash($role);
    # reverse so our keys become the values (captured coderefs) in case
    # they got copied or re-used since
    my $not_methods = { reverse %{$info->{not_methods}||{}} };
    $info->{methods} ||= +{
      # grab all code entries that aren't in the not_methods list
      map {;
        no strict 'refs';
        my $code = exists &{"${role}::$_"} ? \&{"${role}::$_"} : undef;
        ( ! $code or exists $not_methods->{$code} ) ? () : ($_ => $code)
      } grep +(!ref($stash->{$_}) || ref($stash->{$_}) eq 'CODE'), keys %$stash
    };
  }
  
  sub methods_provided_by {
    my ($me, $role) = @_;
    croak "${role} is not a Role::Tiny" unless $me->is_role($role);
    (keys %{$me->_concrete_methods_of($role)}, @{$INFO{$role}->{requires}||[]});
  }
  
  sub _install_methods {
    my ($me, $to, $role) = @_;
  
    my $info = $INFO{$role};
  
    my $methods = $me->_concrete_methods_of($role);
  
    # grab target symbol table
    my $stash = _getstash($to);
  
    # determine already extant methods of target
    my %has_methods;
    @has_methods{grep
      +(ref($stash->{$_}) || *{$stash->{$_}}{CODE}),
      keys %$stash
    } = ();
  
    foreach my $i (grep !exists $has_methods{$_}, keys %$methods) {
      no warnings 'once';
      my $glob = _getglob "${to}::${i}";
      *$glob = $methods->{$i};
  
      # overloads using method names have the method stored in the scalar slot
      # and &overload::nil in the code slot.
      next
        unless $i =~ /^\(/
          && ((defined &overload::nil && $methods->{$i} == \&overload::nil)
              || (defined &overload::_nil && $methods->{$i} == \&overload::_nil));
  
      my $overload = ${ *{_getglob "${role}::${i}"}{SCALAR} };
      next
        unless defined $overload;
  
      *$glob = \$overload;
    }
  
    $me->_install_does($to);
  }
  
  sub _install_modifiers {
    my ($me, $to, $name) = @_;
    return unless my $modifiers = $INFO{$name}{modifiers};
    my $info = $INFO{$to};
    my $existing = ($info ? $info->{modifiers} : $COMPOSED{modifiers}{$to}) ||= [];
    my @modifiers = grep {
      my $modifier = $_;
      !grep $_ == $modifier, @$existing;
    } @{$modifiers||[]};
    push @$existing, @modifiers;
  
    if (!$info) {
      foreach my $modifier (@modifiers) {
        $me->_install_single_modifier($to, @$modifier);
      }
    }
  }
  
  my $vcheck_error;
  
  sub _install_single_modifier {
    my ($me, @args) = @_;
    defined($vcheck_error) or $vcheck_error = do {
      local $@;
      eval {
        require Class::Method::Modifiers;
        Class::Method::Modifiers->VERSION(1.05);
        1;
      } ? 0 : $@;
    };
    $vcheck_error and die $vcheck_error;
    Class::Method::Modifiers::install_modifier(@args);
  }
  
  my $FALLBACK = sub { 0 };
  sub _install_does {
    my ($me, $to) = @_;
  
    # only add does() method to classes
    return if $me->is_role($to);
  
    my $does = $me->can('does_role');
    # add does() only if they don't have one
    *{_getglob "${to}::does"} = $does unless $to->can('does');
  
    return
      if $to->can('DOES') and $to->can('DOES') != (UNIVERSAL->can('DOES') || 0);
  
    my $existing = $to->can('DOES') || $to->can('isa') || $FALLBACK;
    my $new_sub = sub {
      my ($proto, $role) = @_;
      $proto->$does($role) or $proto->$existing($role);
    };
    no warnings 'redefine';
    return *{_getglob "${to}::DOES"} = $new_sub;
  }
  
  sub does_role {
    my ($proto, $role) = @_;
    require(_MRO_MODULE);
    foreach my $class (@{mro::get_linear_isa(ref($proto)||$proto)}) {
      return 1 if exists $APPLIED_TO{$class}{$role};
    }
    return 0;
  }
  
  sub is_role {
    my ($me, $role) = @_;
    return !!($INFO{$role} && ($INFO{$role}{is_role} || $INFO{$role}{not_methods}));
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Role::Tiny - Roles. Like a nouvelle cuisine portion size slice of Moose.
  
  =head1 SYNOPSIS
  
   package Some::Role;
  
   use Role::Tiny;
  
   sub foo { ... }
  
   sub bar { ... }
  
   around baz => sub { ... };
  
   1;
  
  elsewhere
  
   package Some::Class;
  
   use Role::Tiny::With;
  
   # bar gets imported, but not foo
   with 'Some::Role';
  
   sub foo { ... }
  
   # baz is wrapped in the around modifier by Class::Method::Modifiers
   sub baz { ... }
  
   1;
  
  If you wanted attributes as well, look at L<Moo::Role>.
  
  =head1 DESCRIPTION
  
  C<Role::Tiny> is a minimalist role composition tool.
  
  =head1 ROLE COMPOSITION
  
  Role composition can be thought of as much more clever and meaningful multiple
  inheritance.  The basics of this implementation of roles is:
  
  =over 2
  
  =item *
  
  If a method is already defined on a class, that method will not be composed in
  from the role. A method inherited by a class gets overridden by the role's
  method of the same name, though.
  
  =item *
  
  If a method that the role L</requires> to be implemented is not implemented,
  role application will fail loudly.
  
  =back
  
  Unlike L<Class::C3>, where the B<last> class inherited from "wins," role
  composition is the other way around, where the class wins. If multiple roles
  are applied in a single call (single with statement), then if any of their
  provided methods clash, an exception is raised unless the class provides
  a method since this conflict indicates a potential problem.
  
  =head1 IMPORTED SUBROUTINES
  
  =head2 requires
  
   requires qw(foo bar);
  
  Declares a list of methods that must be defined to compose role.
  
  =head2 with
  
   with 'Some::Role1';
  
   with 'Some::Role1', 'Some::Role2';
  
  Composes another role into the current role (or class via L<Role::Tiny::With>).
  
  If you have conflicts and want to resolve them in favour of Some::Role1 you
  can instead write:
  
   with 'Some::Role1';
   with 'Some::Role2';
  
  If you have conflicts and want to resolve different conflicts in favour of
  different roles, please refactor your codebase.
  
  =head2 before
  
   before foo => sub { ... };
  
  See L<< Class::Method::Modifiers/before method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head2 around
  
   around foo => sub { ... };
  
  See L<< Class::Method::Modifiers/around method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head2 after
  
   after foo => sub { ... };
  
  See L<< Class::Method::Modifiers/after method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head2 Strict and Warnings
  
  In addition to importing subroutines, using C<Role::Tiny> applies L<strict> and
  L<warnings> to the caller.
  
  =head1 SUBROUTINES
  
  =head2 does_role
  
   if (Role::Tiny::does_role($foo, 'Some::Role')) {
     ...
   }
  
  Returns true if class has been composed with role.
  
  This subroutine is also installed as ->does on any class a Role::Tiny is
  composed into unless that class already has an ->does method, so
  
    if ($foo->does('Some::Role')) {
      ...
    }
  
  will work for classes but to test a role, one must use ::does_role directly.
  
  Additionally, Role::Tiny will override the standard Perl C<DOES> method
  for your class. However, if C<any> class in your class' inheritance
  hierarchy provides C<DOES>, then Role::Tiny will not override it.
  
  =head1 METHODS
  
  =head2 apply_roles_to_package
  
   Role::Tiny->apply_roles_to_package(
     'Some::Package', 'Some::Role', 'Some::Other::Role'
   );
  
  Composes role with package.  See also L<Role::Tiny::With>.
  
  =head2 apply_roles_to_object
  
   Role::Tiny->apply_roles_to_object($foo, qw(Some::Role1 Some::Role2));
  
  Composes roles in order into object directly. Object is reblessed into the
  resulting class. Note that the object's methods get overridden by the role's
  ones with the same names.
  
  =head2 create_class_with_roles
  
   Role::Tiny->create_class_with_roles('Some::Base', qw(Some::Role1 Some::Role2));
  
  Creates a new class based on base, with the roles composed into it in order.
  New class is returned.
  
  =head2 is_role
  
   Role::Tiny->is_role('Some::Role1')
  
  Returns true if the given package is a role.
  
  =head1 CAVEATS
  
  =over 4
  
  =item * On perl 5.8.8 and earlier, applying a role to an object won't apply any
  overloads from the role to other copies of the object.
  
  =item * On perl 5.16 and earlier, applying a role to a class won't apply any
  overloads from the role to any existing instances of the class.
  
  =back
  
  =head1 SEE ALSO
  
  L<Role::Tiny> is the attribute-less subset of L<Moo::Role>; L<Moo::Role> is
  a meta-protocol-less subset of the king of role systems, L<Moose::Role>.
  
  Ovid's L<Role::Basic> provides roles with a similar scope, but without method
  modifiers, and having some extra usage restrictions.
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  hobbs - Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
  
  jnap - John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  chip - Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
  
  ajgb - Alex J. G. Burzyski (cpan:AJGB) <ajgb@cpan.org>
  
  doy - Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
  
  perigrin - Chris Prather (cpan:PERIGRIN) <chris@prather.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  ilmari - Dagfinn Ilmari Mannsker (cpan:ILMARI) <ilmari@ilmari.org>
  
  tobyink - Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@haarg.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2012 the Role::Tiny L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
ROLE_TINY

$fatpacked{"Role/Tiny/With.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY_WITH';
  package Role::Tiny::With;
  
  use strict;
  use warnings;
  
  our $VERSION = '2.000006';
  $VERSION = eval $VERSION;
  
  use Role::Tiny ();
  
  use Exporter 'import';
  our @EXPORT = qw( with );
  
  sub with {
      my $target = caller;
      Role::Tiny->apply_roles_to_package($target, @_)
  }
  
  1;
  
  =head1 NAME
  
  Role::Tiny::With - Neat interface for consumers of Role::Tiny roles
  
  =head1 SYNOPSIS
  
   package Some::Class;
  
   use Role::Tiny::With;
  
   with 'Some::Role';
  
   # The role is now mixed in
  
  =head1 DESCRIPTION
  
  C<Role::Tiny> is a minimalist role composition tool.  C<Role::Tiny::With>
  provides a C<with> function to compose such roles.
  
  =head1 AUTHORS
  
  See L<Role::Tiny> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Role::Tiny> for the copyright and license.
  
  =cut
  
  
ROLE_TINY_WITH

$fatpacked{"Test/Mojo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_MOJO';
  package Test::Mojo;
  use Mojo::Base -base;
  
  # "Amy: He knows when you are sleeping.
  #  Professor: He knows when you're on the can.
  #  Leela: He'll hunt you down and blast your ass from here to Pakistan.
  #  Zoidberg: Oh.
  #  Hermes: You'd better not breathe, you'd better not move.
  #  Bender: You're better off dead, I'm telling you, dude.
  #  Fry: Santa Claus is gunning you down!"
  use Mojo::IOLoop;
  use Mojo::JSON 'j';
  use Mojo::JSON::Pointer;
  use Mojo::Server;
  use Mojo::UserAgent;
  use Mojo::Util qw(decode encode);
  use Test::More ();
  
  has [qw(message success tx)];
  has ua =>
    sub { Mojo::UserAgent->new(insecure => 1)->ioloop(Mojo::IOLoop->singleton) };
  
  # Silent or loud tests
  $ENV{MOJO_LOG_LEVEL} ||= $ENV{HARNESS_IS_VERBOSE} ? 'debug' : 'fatal';
  
  sub app {
    my ($self, $app) = @_;
    return $self->ua->server->app unless $app;
    $self->ua->server->app($app);
    return $self;
  }
  
  sub content_is {
    my ($self, $value, $desc) = @_;
    return $self->_test('is', $self->tx->res->text,
      $value, _desc($desc, 'exact match for content'));
  }
  
  sub content_isnt {
    my ($self, $value, $desc) = @_;
    return $self->_test('isnt', $self->tx->res->text,
      $value, _desc($desc, 'no match for content'));
  }
  
  sub content_like {
    my ($self, $regex, $desc) = @_;
    return $self->_test('like', $self->tx->res->text,
      $regex, _desc($desc, 'content is similar'));
  }
  
  sub content_type_is {
    my ($self, $type, $desc) = @_;
    $desc = _desc($desc, "Content-Type: $type");
    return $self->_test('is', $self->tx->res->headers->content_type, $type,
      $desc);
  }
  
  sub content_type_isnt {
    my ($self, $type, $desc) = @_;
    $desc = _desc($desc, "not Content-Type: $type");
    return $self->_test('isnt', $self->tx->res->headers->content_type, $type,
      $desc);
  }
  
  sub content_type_like {
    my ($self, $regex, $desc) = @_;
    $desc = _desc($desc, 'Content-Type is similar');
    return $self->_test('like', $self->tx->res->headers->content_type, $regex,
      $desc);
  }
  
  sub content_type_unlike {
    my ($self, $regex, $desc) = @_;
    $desc = _desc($desc, 'Content-Type is not similar');
    return $self->_test('unlike', $self->tx->res->headers->content_type, $regex,
      $desc);
  }
  
  sub content_unlike {
    my ($self, $regex, $desc) = @_;
    return $self->_test('unlike', $self->tx->res->text,
      $regex, _desc($desc, 'content is not similar'));
  }
  
  sub delete_ok { shift->_build_ok(DELETE => @_) }
  
  sub element_count_is {
    my ($self, $selector, $count, $desc) = @_;
    my $size = $self->tx->res->dom->find($selector)->size;
    return $self->_test('is', $size, $count,
      _desc($desc, qq{element count for selector "$selector"}));
  }
  
  sub element_exists {
    my ($self, $selector, $desc) = @_;
    $desc = _desc($desc, qq{element for selector "$selector" exists});
    return $self->_test('ok', $self->tx->res->dom->at($selector), $desc);
  }
  
  sub element_exists_not {
    my ($self, $selector, $desc) = @_;
    $desc = _desc($desc, qq{no element for selector "$selector"});
    return $self->_test('ok', !$self->tx->res->dom->at($selector), $desc);
  }
  
  sub finish_ok {
    my $self = shift;
    $self->tx->finish(@_) if $self->tx->is_websocket;
    Mojo::IOLoop->one_tick while !$self->{finished};
    return $self->_test('ok', 1, 'closed WebSocket');
  }
  
  sub finished_ok {
    my ($self, $code) = @_;
    Mojo::IOLoop->one_tick while !$self->{finished};
    Test::More::diag "WebSocket closed with status $self->{finished}[0]"
      unless my $ok = $self->{finished}[0] == $code;
    return $self->_test('ok', $ok, "WebSocket closed with status $code");
  }
  
  sub get_ok  { shift->_build_ok(GET  => @_) }
  sub head_ok { shift->_build_ok(HEAD => @_) }
  
  sub header_is {
    my ($self, $name, $value, $desc) = @_;
    $desc = _desc($desc, "$name: " . ($value // ''));
    return $self->_test('is', $self->tx->res->headers->header($name), $value,
      $desc);
  }
  
  sub header_isnt {
    my ($self, $name, $value, $desc) = @_;
    $desc = _desc($desc, "not $name: " . ($value // ''));
    return $self->_test('isnt', $self->tx->res->headers->header($name), $value,
      $desc);
  }
  
  sub header_like {
    my ($self, $name, $regex, $desc) = @_;
    $desc = _desc($desc, "$name is similar");
    return $self->_test('like', $self->tx->res->headers->header($name), $regex,
      $desc);
  }
  
  sub header_unlike {
    my ($self, $name, $regex, $desc) = @_;
    $desc = _desc($desc, "$name is not similar");
    return $self->_test('unlike', $self->tx->res->headers->header($name),
      $regex, $desc);
  }
  
  sub json_has {
    my ($self, $p, $desc) = @_;
    $desc = _desc($desc, qq{has value for JSON Pointer "$p"});
    return $self->_test('ok',
      !!Mojo::JSON::Pointer->new($self->tx->res->json)->contains($p), $desc);
  }
  
  sub json_hasnt {
    my ($self, $p, $desc) = @_;
    $desc = _desc($desc, qq{has no value for JSON Pointer "$p"});
    return $self->_test('ok',
      !Mojo::JSON::Pointer->new($self->tx->res->json)->contains($p), $desc);
  }
  
  sub json_is {
    my $self = shift;
    my ($p, $data) = @_ > 1 ? (shift, shift) : ('', shift);
    my $desc = _desc(shift, qq{exact match for JSON Pointer "$p"});
    return $self->_test('is_deeply', $self->tx->res->json($p), $data, $desc);
  }
  
  sub json_like {
    my ($self, $p, $regex, $desc) = @_;
    return $self->_test('like', $self->tx->res->json($p),
      $regex, _desc($desc, qq{similar match for JSON Pointer "$p"}));
  }
  
  sub json_message_has {
    my ($self, $p, $desc) = @_;
    $desc = _desc($desc, qq{has value for JSON Pointer "$p"});
    return $self->_test('ok', $self->_json(contains => $p), $desc);
  }
  
  sub json_message_hasnt {
    my ($self, $p, $desc) = @_;
    $desc = _desc($desc, qq{has no value for JSON Pointer "$p"});
    return $self->_test('ok', !$self->_json(contains => $p), $desc);
  }
  
  sub json_message_is {
    my $self = shift;
    my ($p, $data) = @_ > 1 ? (shift, shift) : ('', shift);
    my $desc = _desc(shift, qq{exact match for JSON Pointer "$p"});
    return $self->_test('is_deeply', $self->_json(get => $p), $data, $desc);
  }
  
  sub json_message_like {
    my ($self, $p, $regex, $desc) = @_;
    return $self->_test('like', $self->_json(get => $p),
      $regex, _desc($desc, qq{similar match for JSON Pointer "$p"}));
  }
  
  sub json_message_unlike {
    my ($self, $p, $regex, $desc) = @_;
    return $self->_test('unlike', $self->_json(get => $p),
      $regex, _desc($desc, qq{no similar match for JSON Pointer "$p"}));
  }
  
  sub json_unlike {
    my ($self, $p, $regex, $desc) = @_;
    return $self->_test('unlike', $self->tx->res->json($p),
      $regex, _desc($desc, qq{no similar match for JSON Pointer "$p"}));
  }
  
  sub message_is {
    my ($self, $value, $desc) = @_;
    return $self->_message('is', $value, _desc($desc, 'exact match for message'));
  }
  
  sub message_isnt {
    my ($self, $value, $desc) = @_;
    return $self->_message('isnt', $value, _desc($desc, 'no match for message'));
  }
  
  sub message_like {
    my ($self, $regex, $desc) = @_;
    return $self->_message('like', $regex, _desc($desc, 'message is similar'));
  }
  
  sub message_ok {
    my ($self, $desc) = @_;
    return $self->_test('ok', !!$self->_wait, _desc($desc, 'message received'));
  }
  
  sub message_unlike {
    my ($self, $regex, $desc) = @_;
    return $self->_message('unlike', $regex,
      _desc($desc, 'message is not similar'));
  }
  
  sub new {
    my $self = shift->SUPER::new;
  
    return $self unless my $app = shift;
  
    my @args = @_ ? {config => {config_override => 1, %{shift()}}} : ();
    return $self->app(
      ref $app ? $app : Mojo::Server->new->build_app($app, @args));
  }
  
  sub options_ok { shift->_build_ok(OPTIONS => @_) }
  
  sub or {
    my ($self, $cb) = @_;
    $self->$cb unless $self->success;
    return $self;
  }
  
  sub patch_ok { shift->_build_ok(PATCH => @_) }
  sub post_ok  { shift->_build_ok(POST  => @_) }
  sub put_ok   { shift->_build_ok(PUT   => @_) }
  
  sub request_ok { shift->_request_ok($_[0], $_[0]->req->url->to_string) }
  
  sub reset_session {
    my $self = shift;
    $self->ua->cookie_jar->empty;
    return $self->tx(undef);
  }
  
  sub send_ok {
    my ($self, $msg, $desc) = @_;
  
    $desc = _desc($desc, 'send message');
    return $self->_test('ok', 0, $desc) unless $self->tx->is_websocket;
  
    $self->tx->send($msg => sub { Mojo::IOLoop->stop });
    Mojo::IOLoop->start;
    return $self->_test('ok', 1, $desc);
  }
  
  sub status_is {
    my ($self, $status, $desc) = @_;
    $desc = _desc($desc, "$status " . $self->tx->res->default_message($status));
    return $self->_test('is', $self->tx->res->code, $status, $desc);
  }
  
  sub status_isnt {
    my ($self, $status, $desc) = @_;
    return $self->_test('isnt', $self->tx->res->code,
      $status,
      _desc($desc, "not $status " . $self->tx->res->default_message($status)));
  }
  
  sub text_is {
    my ($self, $selector, $value, $desc) = @_;
    return $self->_test('is', $self->_text($selector),
      $value, _desc($desc, qq{exact match for selector "$selector"}));
  }
  
  sub text_isnt {
    my ($self, $selector, $value, $desc) = @_;
    return $self->_test('isnt', $self->_text($selector),
      $value, _desc($desc, qq{no match for selector "$selector"}));
  }
  
  sub text_like {
    my ($self, $selector, $regex, $desc) = @_;
    return $self->_test('like', $self->_text($selector),
      $regex, _desc($desc, qq{similar match for selector "$selector"}));
  }
  
  sub text_unlike {
    my ($self, $selector, $regex, $desc) = @_;
    return $self->_test('unlike', $self->_text($selector),
      $regex, _desc($desc, qq{no similar match for selector "$selector"}));
  }
  
  sub websocket_ok {
    my $self = shift;
    return $self->_request_ok($self->ua->build_websocket_tx(@_), $_[0]);
  }
  
  sub _build_ok {
    my ($self, $method, $url) = (shift, shift, shift);
    local $Test::Builder::Level = $Test::Builder::Level + 1;
    return $self->_request_ok($self->ua->build_tx($method, $url, @_), $url);
  }
  
  sub _desc { encode 'UTF-8', shift || shift }
  
  sub _json {
    my ($self, $method, $p) = @_;
    return Mojo::JSON::Pointer->new(j(@{$self->message // []}[1]))->$method($p);
  }
  
  sub _message {
    my ($self, $name, $value, $desc) = @_;
    local $Test::Builder::Level = $Test::Builder::Level + 1;
    my ($type, $msg) = @{$self->message // []};
  
    # Type check
    if (ref $value eq 'HASH') {
      my $expect = exists $value->{text} ? 'text' : 'binary';
      $value = $value->{$expect};
      $msg = '' unless ($type // '') eq $expect;
    }
  
    # Decode text frame if there is no type check
    else { $msg = decode 'UTF-8', $msg if ($type // '') eq 'text' }
  
    return $self->_test($name, $msg // '', $value, $desc);
  }
  
  sub _request_ok {
    my ($self, $tx, $url) = @_;
  
    local $Test::Builder::Level = $Test::Builder::Level + 1;
  
    # Establish WebSocket connection
    if ($tx->req->is_handshake) {
      @$self{qw(finished messages)} = (undef, []);
      $self->ua->start(
        $tx => sub {
          my ($ua, $tx) = @_;
          $self->{finished} = [] unless $self->tx($tx)->tx->is_websocket;
          $tx->on(finish => sub { shift; $self->{finished} = [@_] });
          $tx->on(binary => sub { push @{$self->{messages}}, [binary => pop] });
          $tx->on(text   => sub { push @{$self->{messages}}, [text   => pop] });
          Mojo::IOLoop->stop;
        }
      );
      Mojo::IOLoop->start;
  
      my $desc = _desc("WebSocket handshake with $url");
      return $self->_test('ok', $self->tx->is_websocket, $desc);
    }
  
    # Perform request
    $self->tx($self->ua->start($tx));
    my $err = $self->tx->error;
    Test::More::diag $err->{message}
      if !(my $ok = !$err->{message} || $err->{code}) && $err;
    return $self->_test('ok', $ok, _desc("@{[uc $tx->req->method]} $url"));
  }
  
  sub _test {
    my ($self, $name, @args) = @_;
    local $Test::Builder::Level = $Test::Builder::Level + 2;
    return $self->success(!!Test::More->can($name)->(@args));
  }
  
  sub _text {
    return '' unless my $e = shift->tx->res->dom->at(shift);
    return $e->text;
  }
  
  sub _wait {
    my $self = shift;
    Mojo::IOLoop->one_tick while !$self->{finished} && !@{$self->{messages}};
    return $self->message(shift @{$self->{messages}})->message;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Test::Mojo - Testing Mojo
  
  =head1 SYNOPSIS
  
    use Test::More;
    use Test::Mojo;
  
    my $t = Test::Mojo->new('MyApp');
  
    # HTML/XML
    $t->get_ok('/welcome')->status_is(200)->text_is('div#message' => 'Hello!');
  
    # JSON
    $t->post_ok('/search.json' => form => {q => 'Perl'})
      ->status_is(200)
      ->header_is('Server' => 'Mojolicious (Perl)')
      ->header_isnt('X-Bender' => 'Bite my shiny metal ass!')
      ->json_is('/results/4/title' => 'Perl rocks!')
      ->json_like('/results/7/title' => qr/Perl/);
  
    # WebSocket
    $t->websocket_ok('/echo')
      ->send_ok('hello')
      ->message_ok
      ->message_is('echo: hello')
      ->finish_ok;
  
    done_testing();
  
  =head1 DESCRIPTION
  
  L<Test::Mojo> is a test user agent based on L<Mojo::UserAgent>, it is usually
  used together with L<Test::More> to test L<Mojolicious> applications. Just run
  your tests with the command L<Mojolicious::Command::test> or L<prove>.
  
    $ ./script/my_app test
    $ ./script/my_app test -v t/foo.t
    $ prove -l -v t/foo.t
  
  If it is not already defined, the C<MOJO_LOG_LEVEL> environment variable will
  be set to C<debug> or C<fatal>, depending on the value of the
  C<HARNESS_IS_VERBOSE> environment variable. And to make it esier to test
  HTTPS/WSS web services L<Mojo::UserAgent/"insecure"> will be activated by
  default for L</"ua">.
  
  See L<Mojolicious::Guides::Testing> for more.
  
  =head1 ATTRIBUTES
  
  L<Test::Mojo> implements the following attributes.
  
  =head2 message
  
    my $msg = $t->message;
    $t      = $t->message([text => $bytes]);
  
  Current WebSocket message represented as an array reference containing the
  frame type and payload.
  
    # More specific tests
    use Mojo::JSON 'decode_json';
    my $hash = decode_json $t->message->[1];
    is ref $hash, 'HASH', 'right reference';
    is $hash->{foo}, 'bar', 'right value';
  
    # Test custom message
    $t->message([binary => $bytes])
      ->json_message_has('/foo/bar')
      ->json_message_hasnt('/bar')
      ->json_message_is('/foo/baz' => {yada => [1, 2, 3]});
  
  =head2 success
  
    my $bool = $t->success;
    $t       = $t->success($bool);
  
  True if the last test was successful.
  
    # Build custom tests
    my $location_is = sub {
      my ($t, $value, $desc) = @_;
      $desc ||= "Location: $value";
      local $Test::Builder::Level = $Test::Builder::Level + 1;
      return $t->success(is($t->tx->res->headers->location, $value, $desc));
    };
    $t->get_ok('/')
      ->status_is(302)
      ->$location_is('https://mojolicious.org')
      ->or(sub { diag 'Must have been Joel!' });
  
  =head2 tx
  
    my $tx = $t->tx;
    $t     = $t->tx(Mojo::Transaction::HTTP->new);
  
  Current transaction, usually a L<Mojo::Transaction::HTTP> or
  L<Mojo::Transaction::WebSocket> object.
  
    # More specific tests
    is $t->tx->res->json->{foo}, 'bar', 'right value';
    ok $t->tx->res->content->is_multipart, 'multipart content';
    is $t->tx->previous->res->code, 302, 'right status';
  
  =head2 ua
  
    my $ua = $t->ua;
    $t     = $t->ua(Mojo::UserAgent->new);
  
  User agent used for testing, defaults to a L<Mojo::UserAgent> object.
  
    # Allow redirects
    $t->ua->max_redirects(10);
    $t->get_ok('/redirect')->status_is(200)->content_like(qr/redirected/);
  
    # Switch protocol from HTTP to HTTPS
    $t->ua->server->url('https');
    $t->get_ok('/secure')->status_is(200)->content_like(qr/secure/);
  
    # Use absolute URL for request with Basic authentication
    my $url = $t->ua->server->url->userinfo('sri:secr3t')->path('/secrets.json');
    $t->post_ok($url => json => {limit => 10})
      ->status_is(200)
      ->json_is('/1/content', 'Mojo rocks!');
  
    # Customize all transactions (including followed redirects)
    $t->ua->on(start => sub {
      my ($ua, $tx) = @_;
      $tx->req->headers->accept_language('en-US');
    });
    $t->get_ok('/hello')->status_is(200)->content_like(qr/Howdy/);
  
  =head1 METHODS
  
  L<Test::Mojo> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 app
  
    my $app = $t->app;
    $t      = $t->app(Mojolicious->new);
  
  Access application with L<Mojo::UserAgent::Server/"app">.
  
    # Change log level
    $t->app->log->level('fatal');
  
    # Test application directly
    is $t->app->defaults->{foo}, 'bar', 'right value';
    ok $t->app->routes->find('echo')->is_websocket, 'WebSocket route';
    my $c = $t->app->build_controller;
    ok $c->render(template => 'foo'), 'rendering was successful';
    is $c->res->status, 200, 'right status';
    is $c->res->body, 'Foo!', 'right content';
  
    # Change application behavior
    $t->app->hook(before_dispatch => sub {
      my $c = shift;
      $c->render(text => 'This request did not reach the router.')
        if $c->req->url->path->contains('/user');
    });
    $t->get_ok('/user')->status_is(200)->content_like(qr/not reach the router/);
  
    # Extract additional information
    my $stash;
    $t->app->hook(after_dispatch => sub { $stash = shift->stash });
    $t->get_ok('/hello')->status_is(200);
    is $stash->{foo}, 'bar', 'right value';
  
  =head2 content_is
  
    $t = $t->content_is('working!');
    $t = $t->content_is('working!', 'right content');
  
  Check response content for exact match after retrieving it from
  L<Mojo::Message/"text">.
  
  =head2 content_isnt
  
    $t = $t->content_isnt('working!');
    $t = $t->content_isnt('working!', 'different content');
  
  Opposite of L</"content_is">.
  
  =head2 content_like
  
    $t = $t->content_like(qr/working!/);
    $t = $t->content_like(qr/working!/, 'right content');
  
  Check response content for similar match after retrieving it from
  L<Mojo::Message/"text">.
  
  =head2 content_type_is
  
    $t = $t->content_type_is('text/html');
    $t = $t->content_type_is('text/html', 'right content type');
  
  Check response C<Content-Type> header for exact match.
  
  =head2 content_type_isnt
  
    $t = $t->content_type_isnt('text/html');
    $t = $t->content_type_isnt('text/html', 'different content type');
  
  Opposite of L</"content_type_is">.
  
  =head2 content_type_like
  
    $t = $t->content_type_like(qr/text/);
    $t = $t->content_type_like(qr/text/, 'right content type');
  
  Check response C<Content-Type> header for similar match.
  
  =head2 content_type_unlike
  
    $t = $t->content_type_unlike(qr/text/);
    $t = $t->content_type_unlike(qr/text/, 'different content type');
  
  Opposite of L</"content_type_like">.
  
  =head2 content_unlike
  
    $t = $t->content_unlike(qr/working!/);
    $t = $t->content_unlike(qr/working!/, 'different content');
  
  Opposite of L</"content_like">.
  
  =head2 delete_ok
  
    $t = $t->delete_ok('http://example.com/foo');
    $t = $t->delete_ok('/foo');
    $t = $t->delete_ok('/foo' => {Accept => '*/*'} => 'Content!');
    $t = $t->delete_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->delete_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<DELETE> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"delete">, except for the callback.
  
  =head2 element_count_is
  
    $t = $t->element_count_is('div.foo[x=y]', 5);
    $t = $t->element_count_is('html body div', 30, 'thirty elements');
  
  Checks the number of HTML/XML elements matched by the CSS selector with
  L<Mojo::DOM/"find">.
  
  =head2 element_exists
  
    $t = $t->element_exists('div.foo[x=y]');
    $t = $t->element_exists('html head title', 'has a title');
  
  Checks for existence of the CSS selectors first matching HTML/XML element with
  L<Mojo::DOM/"at">.
  
    # Check attribute values
    $t->get_ok('/login')
      ->element_exists('label[for=email]')
      ->element_exists('input[name=email][type=text][value*="example.com"]')
      ->element_exists('label[for=pass]')
      ->element_exists('input[name=pass][type=password]')
      ->element_exists('input[type=submit][value]');
  
  =head2 element_exists_not
  
    $t = $t->element_exists_not('div.foo[x=y]');
    $t = $t->element_exists_not('html head title', 'has no title');
  
  Opposite of L</"element_exists">.
  
  =head2 finish_ok
  
    $t = $t->finish_ok;
    $t = $t->finish_ok(1000);
    $t = $t->finish_ok(1003 => 'Cannot accept data!');
  
  Close WebSocket connection gracefully.
  
  =head2 finished_ok
  
    $t = $t->finished_ok(1000);
  
  Wait for WebSocket connection to be closed gracefully and check status.
  
  =head2 get_ok
  
    $t = $t->get_ok('http://example.com/foo');
    $t = $t->get_ok('/foo');
    $t = $t->get_ok('/foo' => {Accept => '*/*'} => 'Content!');
    $t = $t->get_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->get_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<GET> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"get">, except for the callback.
  
    # Run tests against remote host
    $t->get_ok('https://mojolicious.org/perldoc')->status_is(200);
  
    # Use relative URL for request with Basic authentication
    $t->get_ok('//sri:secr3t@/secrets.json')
      ->status_is(200)
      ->json_is('/1/content', 'Mojo rocks!');
  
    # Run additional tests on the transaction
    $t->get_ok('/foo')->status_is(200);
    is $t->tx->res->dom->at('input')->val, 'whatever', 'right value';
  
  =head2 head_ok
  
    $t = $t->head_ok('http://example.com/foo');
    $t = $t->head_ok('/foo');
    $t = $t->head_ok('/foo' => {Accept => '*/*'} => 'Content!');
    $t = $t->head_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->head_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<HEAD> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"head">, except for the callback.
  
  =head2 header_is
  
    $t = $t->header_is(ETag => '"abc321"');
    $t = $t->header_is(ETag => '"abc321"', 'right header');
  
  Check response header for exact match.
  
  =head2 header_isnt
  
    $t = $t->header_isnt(Etag => '"abc321"');
    $t = $t->header_isnt(ETag => '"abc321"', 'different header');
  
  Opposite of L</"header_is">.
  
  =head2 header_like
  
    $t = $t->header_like(ETag => qr/abc/);
    $t = $t->header_like(ETag => qr/abc/, 'right header');
  
  Check response header for similar match.
  
  =head2 header_unlike
  
    $t = $t->header_unlike(ETag => qr/abc/);
    $t = $t->header_unlike(ETag => qr/abc/, 'different header');
  
  Opposite of L</"header_like">.
  
  =head2 json_has
  
    $t = $t->json_has('/foo');
    $t = $t->json_has('/minibar', 'has a minibar');
  
  Check if JSON response contains a value that can be identified using the given
  JSON Pointer with L<Mojo::JSON::Pointer>.
  
  =head2 json_hasnt
  
    $t = $t->json_hasnt('/foo');
    $t = $t->json_hasnt('/minibar', 'no minibar');
  
  Opposite of L</"json_has">.
  
  =head2 json_is
  
    $t = $t->json_is({foo => [1, 2, 3]});
    $t = $t->json_is('/foo' => [1, 2, 3]);
    $t = $t->json_is('/foo/1' => 2, 'right value');
  
  Check the value extracted from JSON response using the given JSON Pointer with
  L<Mojo::JSON::Pointer>, which defaults to the root value if it is omitted.
  
  =head2 json_like
  
    $t = $t->json_like('/foo/1' => qr/^\d+$/);
    $t = $t->json_like('/foo/1' => qr/^\d+$/, 'right value');
  
  Check the value extracted from JSON response using the given JSON Pointer with
  L<Mojo::JSON::Pointer> for similar match.
  
  =head2 json_message_has
  
    $t = $t->json_message_has('/foo');
    $t = $t->json_message_has('/minibar', 'has a minibar');
  
  Check if JSON WebSocket message contains a value that can be identified using
  the given JSON Pointer with L<Mojo::JSON::Pointer>.
  
  =head2 json_message_hasnt
  
    $t = $t->json_message_hasnt('/foo');
    $t = $t->json_message_hasnt('/minibar', 'no minibar');
  
  Opposite of L</"json_message_has">.
  
  =head2 json_message_is
  
    $t = $t->json_message_is({foo => [1, 2, 3]});
    $t = $t->json_message_is('/foo' => [1, 2, 3]);
    $t = $t->json_message_is('/foo/1' => 2, 'right value');
  
  Check the value extracted from JSON WebSocket message using the given JSON
  Pointer with L<Mojo::JSON::Pointer>, which defaults to the root value if it is
  omitted.
  
  =head2 json_message_like
  
    $t = $t->json_message_like('/foo/1' => qr/^\d+$/);
    $t = $t->json_message_like('/foo/1' => qr/^\d+$/, 'right value');
  
  Check the value extracted from JSON WebSocket message using the given JSON
  Pointer with L<Mojo::JSON::Pointer> for similar match.
  
  =head2 json_message_unlike
  
    $t = $t->json_message_unlike('/foo/1' => qr/^\d+$/);
    $t = $t->json_message_unlike('/foo/1' => qr/^\d+$/, 'different value');
  
  Opposite of L</"json_message_like">.
  
  =head2 json_unlike
  
    $t = $t->json_unlike('/foo/1' => qr/^\d+$/);
    $t = $t->json_unlike('/foo/1' => qr/^\d+$/, 'different value');
  
  Opposite of L</"json_like">.
  
  =head2 message_is
  
    $t = $t->message_is({binary => $bytes});
    $t = $t->message_is({text   => $bytes});
    $t = $t->message_is('working!');
    $t = $t->message_is('working!', 'right message');
  
  Check WebSocket message for exact match.
  
  =head2 message_isnt
  
    $t = $t->message_isnt({binary => $bytes});
    $t = $t->message_isnt({text   => $bytes});
    $t = $t->message_isnt('working!');
    $t = $t->message_isnt('working!', 'different message');
  
  Opposite of L</"message_is">.
  
  =head2 message_like
  
    $t = $t->message_like({binary => qr/$bytes/});
    $t = $t->message_like({text   => qr/$bytes/});
    $t = $t->message_like(qr/working!/);
    $t = $t->message_like(qr/working!/, 'right message');
  
  Check WebSocket message for similar match.
  
  =head2 message_ok
  
    $t = $t->message_ok;
    $t = $t->message_ok('got a message');
  
  Wait for next WebSocket message to arrive.
  
    # Wait for message and perform multiple tests on it
    $t->websocket_ok('/time')
      ->message_ok
      ->message_like(qr/\d+/)
      ->message_unlike(qr/\w+/)
      ->finish_ok;
  
  =head2 message_unlike
  
    $t = $t->message_unlike({binary => qr/$bytes/});
    $t = $t->message_unlike({text   => qr/$bytes/});
    $t = $t->message_unlike(qr/working!/);
    $t = $t->message_unlike(qr/working!/, 'different message');
  
  Opposite of L</"message_like">.
  
  =head2 new
  
    my $t = Test::Mojo->new;
    my $t = Test::Mojo->new('MyApp');
    my $t = Test::Mojo->new(MyApp => {foo => 'bar', baz => 23});
    my $t = Test::Mojo->new(MyApp->new);
  
  Construct a new L<Test::Mojo> object. In addition to a class name, you can pass
  along a hash reference with configuration values that will be used to
  instantiate the application. The special configuration value C<config_override>
  will be set in L<Mojolicious/"config"> as well, which is used to disable
  configuration plugins like L<Mojolicious::Plugin::Config> and
  L<Mojolicious::Plugin::JSONConfig> for tests.
  
  =head2 options_ok
  
    $t = $t->options_ok('http://example.com/foo');
    $t = $t->options_ok('/foo');
    $t = $t->options_ok('/foo' => {Accept => '*/*'} => 'Content!');
    $t = $t->options_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->options_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<OPTIONS> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"options">, except for the callback.
  
  =head2 or
  
    $t = $t->or(sub {...});
  
  Execute callback if the value of L</"success"> is false.
  
    # Diagnostics
    $t->get_ok('/bad')->or(sub { diag 'Must have been Glen!' })
      ->status_is(200)->or(sub { diag $t->tx->res->dom->at('title')->text });
  
  =head2 patch_ok
  
    $t = $t->patch_ok('http://example.com/foo');
    $t = $t->patch_ok('/foo');
    $t = $t->patch_ok('/foo' => {Accept => '*/*'} => 'Content!');
    $t = $t->patch_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->patch_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<PATCH> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"patch">, except for the callback.
  
  =head2 post_ok
  
    $t = $t->post_ok('http://example.com/foo');
    $t = $t->post_ok('/foo');
    $t = $t->post_ok('/foo' => {Accept => '*/*'} => 'Content!');
    $t = $t->post_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->post_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<POST> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"post">, except for the callback.
  
    # Test file upload
    my $upload = {foo => {content => 'bar', filename => 'baz.txt'}};
    $t->post_ok('/upload' => form => $upload)->status_is(200);
  
    # Test JSON API
    $t->post_ok('/hello.json' => json => {hello => 'world'})
      ->status_is(200)
      ->json_is({bye => 'world'});
  
  =head2 put_ok
  
    $t = $t->put_ok('http://example.com/foo');
    $t = $t->put_ok('/foo');
    $t = $t->put_ok('/foo' => {Accept => '*/*'} => 'Content!');
    $t = $t->put_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->put_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<PUT> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"put">, except for the callback.
  
  =head2 request_ok
  
    $t = $t->request_ok(Mojo::Transaction::HTTP->new);
  
  Perform request and check for transport errors.
  
    # Request with custom method
    my $tx = $t->ua->build_tx(FOO => '/test.json' => json => {foo => 1});
    $t->request_ok($tx)->status_is(200)->json_is({success => 1});
  
    # Request with custom cookie
    my $tx = $t->ua->build_tx(GET => '/account');
    $tx->req->cookies({name => 'user', value => 'sri'});
    $t->request_ok($tx)->status_is(200)->text_is('head > title' => 'Hello sri');
  
    # Custom WebSocket handshake
    my $tx = $t->ua->build_websocket_tx('/foo');
    $tx->req->headers->remove('User-Agent');
    $t->request_ok($tx)->message_ok->message_is('bar')->finish_ok;
  
  =head2 reset_session
  
    $t = $t->reset_session;
  
  Reset user agent session.
  
  =head2 send_ok
  
    $t = $t->send_ok({binary => $bytes});
    $t = $t->send_ok({text   => $bytes});
    $t = $t->send_ok({json   => {test => [1, 2, 3]}});
    $t = $t->send_ok([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);
    $t = $t->send_ok($chars);
    $t = $t->send_ok($chars, 'sent successfully');
  
  Send message or frame via WebSocket.
  
    # Send JSON object as "Text" message
    $t->websocket_ok('/echo.json')
      ->send_ok({json => {test => 'I  Mojolicious!'}})
      ->message_ok
      ->json_message_is('/test' => 'I  Mojolicious!')
      ->finish_ok;
  
  =head2 status_is
  
    $t = $t->status_is(200);
    $t = $t->status_is(200, 'right status');
  
  Check response status for exact match.
  
  =head2 status_isnt
  
    $t = $t->status_isnt(200);
    $t = $t->status_isnt(200, 'different status');
  
  Opposite of L</"status_is">.
  
  =head2 text_is
  
    $t = $t->text_is('div.foo[x=y]' => 'Hello!');
    $t = $t->text_is('html head title' => 'Hello!', 'right title');
  
  Checks text content of the CSS selectors first matching HTML/XML element for
  exact match with L<Mojo::DOM/"at">.
  
  =head2 text_isnt
  
    $t = $t->text_isnt('div.foo[x=y]' => 'Hello!');
    $t = $t->text_isnt('html head title' => 'Hello!', 'different title');
  
  Opposite of L</"text_is">.
  
  =head2 text_like
  
    $t = $t->text_like('div.foo[x=y]' => qr/Hello/);
    $t = $t->text_like('html head title' => qr/Hello/, 'right title');
  
  Checks text content of the CSS selectors first matching HTML/XML element for
  similar match with L<Mojo::DOM/"at">.
  
  =head2 text_unlike
  
    $t = $t->text_unlike('div.foo[x=y]' => qr/Hello/);
    $t = $t->text_unlike('html head title' => qr/Hello/, 'different title');
  
  Opposite of L</"text_like">.
  
  =head2 websocket_ok
  
    $t = $t->websocket_ok('http://example.com/echo');
    $t = $t->websocket_ok('/echo');
    $t = $t->websocket_ok('/echo' => {DNT => 1} => ['v1.proto']);
  
  Open a WebSocket connection with transparent handshake, takes the same
  arguments as L<Mojo::UserAgent/"websocket">, except for the callback.
  
    # WebSocket with permessage-deflate compression
    $t->websocket_ok('/' => {'Sec-WebSocket-Extensions' => 'permessage-deflate'})
      ->send_ok('y' x 50000)
      ->message_ok
      ->message_is('z' x 50000)
      ->finish_ok;
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
TEST_MOJO

$fatpacked{"URI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI';
  package URI;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  our ($ABS_REMOTE_LEADING_DOTS, $ABS_ALLOW_RELATIVE_SCHEME, $DEFAULT_QUERY_FORM_DELIMITER);
  
  my %implements;  # mapping from scheme to implementor class
  
  # Some "official" character classes
  
  our $reserved   = q(;/?:@&=+$,[]);
  our $mark       = q(-_.!~*'());                                    #'; emacs
  our $unreserved = "A-Za-z0-9\Q$mark\E";
  our $uric       = quotemeta($reserved) . $unreserved . "%";
  
  our $scheme_re  = '[a-zA-Z][a-zA-Z0-9.+\-]*';
  
  use Carp ();
  use URI::Escape ();
  
  use overload ('""'     => sub { ${$_[0]} },
                '=='     => sub { _obj_eq(@_) },
                '!='     => sub { !_obj_eq(@_) },
                fallback => 1,
               );
  
  # Check if two objects are the same object
  sub _obj_eq {
      return overload::StrVal($_[0]) eq overload::StrVal($_[1]);
  }
  
  sub new
  {
      my($class, $uri, $scheme) = @_;
  
      $uri = defined ($uri) ? "$uri" : "";   # stringify
      # Get rid of potential wrapping
      $uri =~ s/^<(?:URL:)?(.*)>$/$1/;  # 
      $uri =~ s/^"(.*)"$/$1/;
      $uri =~ s/^\s+//;
      $uri =~ s/\s+$//;
  
      my $impclass;
      if ($uri =~ m/^($scheme_re):/so) {
  	$scheme = $1;
      }
      else {
  	if (($impclass = ref($scheme))) {
  	    $scheme = $scheme->scheme;
  	}
  	elsif ($scheme && $scheme =~ m/^($scheme_re)(?::|$)/o) {
  	    $scheme = $1;
          }
      }
      $impclass ||= implementor($scheme) ||
  	do {
  	    require URI::_foreign;
  	    $impclass = 'URI::_foreign';
  	};
  
      return $impclass->_init($uri, $scheme);
  }
  
  
  sub new_abs
  {
      my($class, $uri, $base) = @_;
      $uri = $class->new($uri, $base);
      $uri->abs($base);
  }
  
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      # find all funny characters and encode the bytes.
      $str = $class->_uric_escape($str);
      $str = "$scheme:$str" unless $str =~ /^$scheme_re:/o ||
                                   $class->_no_scheme_ok;
      my $self = bless \$str, $class;
      $self;
  }
  
  
  sub _uric_escape
  {
      my($class, $str) = @_;
      $str =~ s*([^$uric\#])* URI::Escape::escape_char($1) *ego;
      utf8::downgrade($str);
      return $str;
  }
  
  my %require_attempted;
  
  sub implementor
  {
      my($scheme, $impclass) = @_;
      if (!$scheme || $scheme !~ /\A$scheme_re\z/o) {
  	require URI::_generic;
  	return "URI::_generic";
      }
  
      $scheme = lc($scheme);
  
      if ($impclass) {
  	# Set the implementor class for a given scheme
          my $old = $implements{$scheme};
          $impclass->_init_implementor($scheme);
          $implements{$scheme} = $impclass;
          return $old;
      }
  
      my $ic = $implements{$scheme};
      return $ic if $ic;
  
      # scheme not yet known, look for internal or
      # preloaded (with 'use') implementation
      $ic = "URI::$scheme";  # default location
  
      # turn scheme into a valid perl identifier by a simple transformation...
      $ic =~ s/\+/_P/g;
      $ic =~ s/\./_O/g;
      $ic =~ s/\-/_/g;
  
      no strict 'refs';
      # check we actually have one for the scheme:
      unless (@{"${ic}::ISA"}) {
          if (not exists $require_attempted{$ic}) {
              # Try to load it
              my $_old_error = $@;
              eval "require $ic";
              die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
              $@ = $_old_error;
          }
          return undef unless @{"${ic}::ISA"};
      }
  
      $ic->_init_implementor($scheme);
      $implements{$scheme} = $ic;
      $ic;
  }
  
  
  sub _init_implementor
  {
      my($class, $scheme) = @_;
      # Remember that one implementor class may actually
      # serve to implement several URI schemes.
  }
  
  
  sub clone
  {
      my $self = shift;
      my $other = $$self;
      bless \$other, ref $self;
  }
  
  sub TO_JSON { ${$_[0]} }
  
  sub _no_scheme_ok { 0 }
  
  sub _scheme
  {
      my $self = shift;
  
      unless (@_) {
  	return undef unless $$self =~ /^($scheme_re):/o;
  	return $1;
      }
  
      my $old;
      my $new = shift;
      if (defined($new) && length($new)) {
  	Carp::croak("Bad scheme '$new'") unless $new =~ /^$scheme_re$/o;
  	$old = $1 if $$self =~ s/^($scheme_re)://o;
  	my $newself = URI->new("$new:$$self");
  	$$self = $$newself; 
  	bless $self, ref($newself);
      }
      else {
  	if ($self->_no_scheme_ok) {
  	    $old = $1 if $$self =~ s/^($scheme_re)://o;
  	    Carp::carp("Oops, opaque part now look like scheme")
  		if $^W && $$self =~ m/^$scheme_re:/o
  	}
  	else {
  	    $old = $1 if $$self =~ m/^($scheme_re):/o;
  	}
      }
  
      return $old;
  }
  
  sub scheme
  {
      my $scheme = shift->_scheme(@_);
      return undef unless defined $scheme;
      lc($scheme);
  }
  
  sub has_recognized_scheme {
      my $self = shift;
      return ref($self) !~ /^URI::_(?:foreign|generic)\z/;
  }
  
  sub opaque
  {
      my $self = shift;
  
      unless (@_) {
  	$$self =~ /^(?:$scheme_re:)?([^\#]*)/o or die;
  	return $1;
      }
  
      $$self =~ /^($scheme_re:)?    # optional scheme
  	        ([^\#]*)          # opaque
                  (\#.*)?           # optional fragment
                $/sx or die;
  
      my $old_scheme = $1;
      my $old_opaque = $2;
      my $old_frag   = $3;
  
      my $new_opaque = shift;
      $new_opaque = "" unless defined $new_opaque;
      $new_opaque =~ s/([^$uric])/ URI::Escape::escape_char($1)/ego;
      utf8::downgrade($new_opaque);
  
      $$self = defined($old_scheme) ? $old_scheme : "";
      $$self .= $new_opaque;
      $$self .= $old_frag if defined $old_frag;
  
      $old_opaque;
  }
  
  sub path { goto &opaque }  # alias
  
  
  sub fragment
  {
      my $self = shift;
      unless (@_) {
  	return undef unless $$self =~ /\#(.*)/s;
  	return $1;
      }
  
      my $old;
      $old = $1 if $$self =~ s/\#(.*)//s;
  
      my $new_frag = shift;
      if (defined $new_frag) {
  	$new_frag =~ s/([^$uric])/ URI::Escape::escape_char($1) /ego;
  	utf8::downgrade($new_frag);
  	$$self .= "#$new_frag";
      }
      $old;
  }
  
  
  sub as_string
  {
      my $self = shift;
      $$self;
  }
  
  
  sub as_iri
  {
      my $self = shift;
      my $str = $$self;
      if ($str =~ s/%([89a-fA-F][0-9a-fA-F])/chr(hex($1))/eg) {
  	# All this crap because the more obvious:
  	#
  	#   Encode::decode("UTF-8", $str, sub { sprintf "%%%02X", shift })
  	#
  	# doesn't work before Encode 2.39.  Wait for a standard release
  	# to bundle that version.
  
  	require Encode;
  	my $enc = Encode::find_encoding("UTF-8");
  	my $u = "";
  	while (length $str) {
  	    $u .= $enc->decode($str, Encode::FB_QUIET());
  	    if (length $str) {
  		# escape next char
  		$u .= URI::Escape::escape_char(substr($str, 0, 1, ""));
  	    }
  	}
  	$str = $u;
      }
      return $str;
  }
  
  
  sub canonical
  {
      # Make sure scheme is lowercased, that we don't escape unreserved chars,
      # and that we use upcase escape sequences.
  
      my $self = shift;
      my $scheme = $self->_scheme || "";
      my $uc_scheme = $scheme =~ /[A-Z]/;
      my $esc = $$self =~ /%[a-fA-F0-9]{2}/;
      return $self unless $uc_scheme || $esc;
  
      my $other = $self->clone;
      if ($uc_scheme) {
  	$other->_scheme(lc $scheme);
      }
      if ($esc) {
  	$$other =~ s{%([0-9a-fA-F]{2})}
  	            { my $a = chr(hex($1));
                        $a =~ /^[$unreserved]\z/o ? $a : "%\U$1"
                      }ge;
      }
      return $other;
  }
  
  # Compare two URIs, subclasses will provide a more correct implementation
  sub eq {
      my($self, $other) = @_;
      $self  = URI->new($self, $other) unless ref $self;
      $other = URI->new($other, $self) unless ref $other;
      ref($self) eq ref($other) &&                # same class
  	$self->canonical->as_string eq $other->canonical->as_string;
  }
  
  # generic-URI transformation methods
  sub abs { $_[0]; }
  sub rel { $_[0]; }
  
  sub secure { 0 }
  
  # help out Storable
  sub STORABLE_freeze {
         my($self, $cloning) = @_;
         return $$self;
  }
  
  sub STORABLE_thaw {
         my($self, $cloning, $str) = @_;
         $$self = $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI - Uniform Resource Identifiers (absolute and relative)
  
  =head1 SYNOPSIS
  
   use URI;
  
   $u1 = URI->new("http://www.perl.com");
   $u2 = URI->new("foo", "http");
   $u3 = $u2->abs($u1);
   $u4 = $u3->clone;
   $u5 = URI->new("HTTP://WWW.perl.com:80")->canonical;
  
   $str = $u->as_string;
   $str = "$u";
  
   $scheme = $u->scheme;
   $opaque = $u->opaque;
   $path   = $u->path;
   $frag   = $u->fragment;
  
   $u->scheme("ftp");
   $u->host("ftp.perl.com");
   $u->path("cpan/");
  
  =head1 DESCRIPTION
  
  This module implements the C<URI> class.  Objects of this class
  represent "Uniform Resource Identifier references" as specified in RFC
  2396 (and updated by RFC 2732).
  
  A Uniform Resource Identifier is a compact string of characters that
  identifies an abstract or physical resource.  A Uniform Resource
  Identifier can be further classified as either a Uniform Resource Locator
  (URL) or a Uniform Resource Name (URN).  The distinction between URL
  and URN does not matter to the C<URI> class interface. A
  "URI-reference" is a URI that may have additional information attached
  in the form of a fragment identifier.
  
  An absolute URI reference consists of three parts:  a I<scheme>, a
  I<scheme-specific part> and a I<fragment> identifier.  A subset of URI
  references share a common syntax for hierarchical namespaces.  For
  these, the scheme-specific part is further broken down into
  I<authority>, I<path> and I<query> components.  These URIs can also
  take the form of relative URI references, where the scheme (and
  usually also the authority) component is missing, but implied by the
  context of the URI reference.  The three forms of URI reference
  syntax are summarized as follows:
  
    <scheme>:<scheme-specific-part>#<fragment>
    <scheme>://<authority><path>?<query>#<fragment>
    <path>?<query>#<fragment>
  
  The components into which a URI reference can be divided depend on the
  I<scheme>.  The C<URI> class provides methods to get and set the
  individual components.  The methods available for a specific
  C<URI> object depend on the scheme.
  
  =head1 CONSTRUCTORS
  
  The following methods construct new C<URI> objects:
  
  =over 4
  
  =item $uri = URI->new( $str )
  
  =item $uri = URI->new( $str, $scheme )
  
  Constructs a new URI object.  The string
  representation of a URI is given as argument, together with an optional
  scheme specification.  Common URI wrappers like "" and <>, as well as
  leading and trailing white space, are automatically removed from
  the $str argument before it is processed further.
  
  The constructor determines the scheme, maps this to an appropriate
  URI subclass, constructs a new object of that class and returns it.
  
  If the scheme isn't one of those that URI recognizes, you still get
  an URI object back that you can access the generic methods on.  The
  C<< $uri->has_recognized_scheme >> method can be used to test for
  this.
  
  The $scheme argument is only used when $str is a
  relative URI.  It can be either a simple string that
  denotes the scheme, a string containing an absolute URI reference, or
  an absolute C<URI> object.  If no $scheme is specified for a relative
  URI $str, then $str is simply treated as a generic URI (no scheme-specific
  methods available).
  
  The set of characters available for building URI references is
  restricted (see L<URI::Escape>).  Characters outside this set are
  automatically escaped by the URI constructor.
  
  =item $uri = URI->new_abs( $str, $base_uri )
  
  Constructs a new absolute URI object.  The $str argument can
  denote a relative or absolute URI.  If relative, then it is
  absolutized using $base_uri as base. The $base_uri must be an absolute
  URI.
  
  =item $uri = URI::file->new( $filename )
  
  =item $uri = URI::file->new( $filename, $os )
  
  Constructs a new I<file> URI from a file name.  See L<URI::file>.
  
  =item $uri = URI::file->new_abs( $filename )
  
  =item $uri = URI::file->new_abs( $filename, $os )
  
  Constructs a new absolute I<file> URI from a file name.  See
  L<URI::file>.
  
  =item $uri = URI::file->cwd
  
  Returns the current working directory as a I<file> URI.  See
  L<URI::file>.
  
  =item $uri->clone
  
  Returns a copy of the $uri.
  
  =back
  
  =head1 COMMON METHODS
  
  The methods described in this section are available for all C<URI>
  objects.
  
  Methods that give access to components of a URI always return the
  old value of the component.  The value returned is C<undef> if the
  component was not present.  There is generally a difference between a
  component that is empty (represented as C<"">) and a component that is
  missing (represented as C<undef>).  If an accessor method is given an
  argument, it updates the corresponding component in addition to
  returning the old value of the component.  Passing an undefined
  argument removes the component (if possible).  The description of
  each accessor method indicates whether the component is passed as
  an escaped (percent-encoded) or an unescaped string.  A component that can be further
  divided into sub-parts are usually passed escaped, as unescaping might
  change its semantics.
  
  The common methods available for all URI are:
  
  =over 4
  
  =item $uri->scheme
  
  =item $uri->scheme( $new_scheme )
  
  Sets and returns the scheme part of the $uri.  If the $uri is
  relative, then $uri->scheme returns C<undef>.  If called with an
  argument, it updates the scheme of $uri, possibly changing the
  class of $uri, and returns the old scheme value.  The method croaks
  if the new scheme name is illegal; a scheme name must begin with a
  letter and must consist of only US-ASCII letters, numbers, and a few
  special marks: ".", "+", "-".  This restriction effectively means
  that the scheme must be passed unescaped.  Passing an undefined
  argument to the scheme method makes the URI relative (if possible).
  
  Letter case does not matter for scheme names.  The string
  returned by $uri->scheme is always lowercase.  If you want the scheme
  just as it was written in the URI in its original case,
  you can use the $uri->_scheme method instead.
  
  =item $uri->has_recognized_scheme
  
  Returns TRUE if the URI scheme is one that URI recognizes.
  
  It will also be TRUE for relative URLs where a recognized
  scheme was provided to the constructor, even if C<< $uri->scheme >>
  returns C<undef> for these.
  
  =item $uri->opaque
  
  =item $uri->opaque( $new_opaque )
  
  Sets and returns the scheme-specific part of the $uri
  (everything between the scheme and the fragment)
  as an escaped string.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the same value as $uri->opaque unless the URI
  supports the generic syntax for hierarchical namespaces.
  In that case the generic method is overridden to set and return
  the part of the URI between the I<host name> and the I<fragment>.
  
  =item $uri->fragment
  
  =item $uri->fragment( $new_frag )
  
  Returns the fragment identifier of a URI reference
  as an escaped string.
  
  =item $uri->as_string
  
  Returns a URI object to a plain ASCII string.  URI objects are
  also converted to plain strings automatically by overloading.  This
  means that $uri objects can be used as plain strings in most Perl
  constructs.
  
  =item $uri->as_iri
  
  Returns a Unicode string representing the URI.  Escaped UTF-8 sequences
  representing non-ASCII characters are turned into their corresponding Unicode
  code point.
  
  =item $uri->canonical
  
  Returns a normalized version of the URI.  The rules
  for normalization are scheme-dependent.  They usually involve
  lowercasing the scheme and Internet host name components,
  removing the explicit port specification if it matches the default port,
  uppercasing all escape sequences, and unescaping octets that can be
  better represented as plain characters.
  
  For efficiency reasons, if the $uri is already in normalized form,
  then a reference to it is returned instead of a copy.
  
  =item $uri->eq( $other_uri )
  
  =item URI::eq( $first_uri, $other_uri )
  
  Tests whether two URI references are equal.  URI references
  that normalize to the same string are considered equal.  The method
  can also be used as a plain function which can also test two string
  arguments.
  
  If you need to test whether two C<URI> object references denote the
  same object, use the '==' operator.
  
  =item $uri->abs( $base_uri )
  
  Returns an absolute URI reference.  If $uri is already
  absolute, then a reference to it is simply returned.  If the $uri
  is relative, then a new absolute URI is constructed by combining the
  $uri and the $base_uri, and returned.
  
  =item $uri->rel( $base_uri )
  
  Returns a relative URI reference if it is possible to
  make one that denotes the same resource relative to $base_uri.
  If not, then $uri is simply returned.
  
  =item $uri->secure
  
  Returns a TRUE value if the URI is considered to point to a resource on
  a secure channel, such as an SSL or TLS encrypted one.
  
  =back
  
  =head1 GENERIC METHODS
  
  The following methods are available to schemes that use the
  common/generic syntax for hierarchical namespaces.  The descriptions of
  schemes below indicate which these are.  Unrecognized schemes are
  assumed to support the generic syntax, and therefore the following
  methods:
  
  =over 4
  
  =item $uri->authority
  
  =item $uri->authority( $new_authority )
  
  Sets and returns the escaped authority component
  of the $uri.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the escaped path component of
  the $uri (the part between the host name and the query or fragment).
  The path can never be undefined, but it can be the empty string.
  
  =item $uri->path_query
  
  =item $uri->path_query( $new_path_query )
  
  Sets and returns the escaped path and query
  components as a single entity.  The path and the query are
  separated by a "?" character, but the query can itself contain "?".
  
  =item $uri->path_segments
  
  =item $uri->path_segments( $segment, ... )
  
  Sets and returns the path.  In a scalar context, it returns
  the same value as $uri->path.  In a list context, it returns the
  unescaped path segments that make up the path.  Path segments that
  have parameters are returned as an anonymous array.  The first element
  is the unescaped path segment proper;  subsequent elements are escaped
  parameter strings.  Such an anonymous array uses overloading so it can
  be treated as a string too, but this string does not include the
  parameters.
  
  Note that absolute paths have the empty string as their first
  I<path_segment>, i.e. the I<path> C</foo/bar> have 3
  I<path_segments>; "", "foo" and "bar".
  
  =item $uri->query
  
  =item $uri->query( $new_query )
  
  Sets and returns the escaped query component of
  the $uri.
  
  =item $uri->query_form
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ... )
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ..., $delim )
  
  =item $uri->query_form( \@key_value_pairs )
  
  =item $uri->query_form( \@key_value_pairs, $delim )
  
  =item $uri->query_form( \%hash )
  
  =item $uri->query_form( \%hash, $delim )
  
  Sets and returns query components that use the
  I<application/x-www-form-urlencoded> format.  Key/value pairs are
  separated by "&", and the key is separated from the value by a "="
  character.
  
  The form can be set either by passing separate key/value pairs, or via
  an array or hash reference.  Passing an empty array or an empty hash
  removes the query component, whereas passing no arguments at all leaves
  the component unchanged.  The order of keys is undefined if a hash
  reference is passed.  The old value is always returned as a list of
  separate key/value pairs.  Assigning this list to a hash is unwise as
  the keys returned might repeat.
  
  The values passed when setting the form can be plain strings or
  references to arrays of strings.  Passing an array of values has the
  same effect as passing the key repeatedly with one value at a time.
  All the following statements have the same effect:
  
      $uri->query_form(foo => 1, foo => 2);
      $uri->query_form(foo => [1, 2]);
      $uri->query_form([ foo => 1, foo => 2 ]);
      $uri->query_form([ foo => [1, 2] ]);
      $uri->query_form({ foo => [1, 2] });
  
  The $delim parameter can be passed as ";" to force the key/value pairs
  to be delimited by ";" instead of "&" in the query string.  This
  practice is often recommended for URLs embedded in HTML or XML
  documents as this avoids the trouble of escaping the "&" character.
  You might also set the $URI::DEFAULT_QUERY_FORM_DELIMITER variable to
  ";" for the same global effect.
  
  The C<URI::QueryParam> module can be loaded to add further methods to
  manipulate the form of a URI.  See L<URI::QueryParam> for details.
  
  =item $uri->query_keywords
  
  =item $uri->query_keywords( $keywords, ... )
  
  =item $uri->query_keywords( \@keywords )
  
  Sets and returns query components that use the
  keywords separated by "+" format.
  
  The keywords can be set either by passing separate keywords directly
  or by passing a reference to an array of keywords.  Passing an empty
  array removes the query component, whereas passing no arguments at
  all leaves the component unchanged.  The old value is always returned
  as a list of separate words.
  
  =back
  
  =head1 SERVER METHODS
  
  For schemes where the I<authority> component denotes an Internet host,
  the following methods are available in addition to the generic
  methods.
  
  =over 4
  
  =item $uri->userinfo
  
  =item $uri->userinfo( $new_userinfo )
  
  Sets and returns the escaped userinfo part of the
  authority component.
  
  For some schemes this is a user name and a password separated by
  a colon.  This practice is not recommended. Embedding passwords in
  clear text (such as URI) has proven to be a security risk in almost
  every case where it has been used.
  
  =item $uri->host
  
  =item $uri->host( $new_host )
  
  Sets and returns the unescaped hostname.
  
  If the $new_host string ends with a colon and a number, then this
  number also sets the port.
  
  For IPv6 addresses the brackets around the raw address is removed in the return
  value from $uri->host.  When setting the host attribute to an IPv6 address you
  can use a raw address or one enclosed in brackets.  The address needs to be
  enclosed in brackets if you want to pass in a new port value as well.
  
  =item $uri->ihost
  
  Returns the host in Unicode form.  Any IDNA A-labels are turned into U-labels.
  
  =item $uri->port
  
  =item $uri->port( $new_port )
  
  Sets and returns the port.  The port is a simple integer
  that should be greater than 0.
  
  If a port is not specified explicitly in the URI, then the URI scheme's default port
  is returned. If you don't want the default port
  substituted, then you can use the $uri->_port method instead.
  
  =item $uri->host_port
  
  =item $uri->host_port( $new_host_port )
  
  Sets and returns the host and port as a single
  unit.  The returned value includes a port, even if it matches the
  default port.  The host part and the port part are separated by a
  colon: ":".
  
  For IPv6 addresses the bracketing is preserved; thus
  URI->new("http://[::1]/")->host_port returns "[::1]:80".  Contrast this with
  $uri->host which will remove the brackets.
  
  =item $uri->default_port
  
  Returns the default port of the URI scheme to which $uri
  belongs.  For I<http> this is the number 80, for I<ftp> this
  is the number 21, etc.  The default port for a scheme can not be
  changed.
  
  =back
  
  =head1 SCHEME-SPECIFIC SUPPORT
  
  Scheme-specific support is provided for the following URI schemes.  For C<URI>
  objects that do not belong to one of these, you can only use the common and
  generic methods.
  
  =over 4
  
  =item B<data>:
  
  The I<data> URI scheme is specified in RFC 2397.  It allows inclusion
  of small data items as "immediate" data, as if it had been included
  externally.
  
  C<URI> objects belonging to the data scheme support the common methods
  and two new methods to access their scheme-specific components:
  $uri->media_type and $uri->data.  See L<URI::data> for details.
  
  =item B<file>:
  
  An old specification of the I<file> URI scheme is found in RFC 1738.
  A new RFC 2396 based specification in not available yet, but file URI
  references are in common use.
  
  C<URI> objects belonging to the file scheme support the common and
  generic methods.  In addition, they provide two methods for mapping file URIs
  back to local file names; $uri->file and $uri->dir.  See L<URI::file>
  for details.
  
  =item B<ftp>:
  
  An old specification of the I<ftp> URI scheme is found in RFC 1738.  A
  new RFC 2396 based specification in not available yet, but ftp URI
  references are in common use.
  
  C<URI> objects belonging to the ftp scheme support the common,
  generic and server methods.  In addition, they provide two methods for
  accessing the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<gopher>:
  
  The I<gopher> URI scheme is specified in
  <draft-murali-url-gopher-1996-12-04> and will hopefully be available
  as a RFC 2396 based specification.
  
  C<URI> objects belonging to the gopher scheme support the common,
  generic and server methods. In addition, they support some methods for
  accessing gopher-specific path components: $uri->gopher_type,
  $uri->selector, $uri->search, $uri->string.
  
  =item B<http>:
  
  The I<http> URI scheme is specified in RFC 2616.
  The scheme is used to reference resources hosted by HTTP servers.
  
  C<URI> objects belonging to the http scheme support the common,
  generic and server methods.
  
  =item B<https>:
  
  The I<https> URI scheme is a Netscape invention which is commonly
  implemented.  The scheme is used to reference HTTP servers through SSL
  connections.  Its syntax is the same as http, but the default
  port is different.
  
  =item B<ldap>:
  
  The I<ldap> URI scheme is specified in RFC 2255.  LDAP is the
  Lightweight Directory Access Protocol.  An ldap URI describes an LDAP
  search operation to perform to retrieve information from an LDAP
  directory.
  
  C<URI> objects belonging to the ldap scheme support the common,
  generic and server methods as well as ldap-specific methods: $uri->dn,
  $uri->attributes, $uri->scope, $uri->filter, $uri->extensions.  See
  L<URI::ldap> for details.
  
  =item B<ldapi>:
  
  Like the I<ldap> URI scheme, but uses a UNIX domain socket.  The
  server methods are not supported, and the local socket path is
  available as $uri->un_path.  The I<ldapi> scheme is used by the
  OpenLDAP package.  There is no real specification for it, but it is
  mentioned in various OpenLDAP manual pages.
  
  =item B<ldaps>:
  
  Like the I<ldap> URI scheme, but uses an SSL connection.  This
  scheme is deprecated, as the preferred way is to use the I<start_tls>
  mechanism.
  
  =item B<mailto>:
  
  The I<mailto> URI scheme is specified in RFC 2368.  The scheme was
  originally used to designate the Internet mailing address of an
  individual or service.  It has (in RFC 2368) been extended to allow
  setting of other mail header fields and the message body.
  
  C<URI> objects belonging to the mailto scheme support the common
  methods and the generic query methods.  In addition, they support the
  following mailto-specific methods: $uri->to, $uri->headers.
  
  Note that the "foo@example.com" part of a mailto is I<not> the
  C<userinfo> and C<host> but instead the C<path>.  This allows a
  mailto URI to contain multiple comma separated email addresses.
  
  =item B<mms>:
  
  The I<mms> URL specification can be found at L<http://sdp.ppona.com/>.
  C<URI> objects belonging to the mms scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<news>:
  
  The I<news>, I<nntp> and I<snews> URI schemes are specified in
  <draft-gilman-news-url-01> and will hopefully be available as an RFC
  2396 based specification soon.
  
  C<URI> objects belonging to the news scheme support the common,
  generic and server methods.  In addition, they provide some methods to
  access the path: $uri->group and $uri->message.
  
  =item B<nntp>:
  
  See I<news> scheme.
  
  =item B<pop>:
  
  The I<pop> URI scheme is specified in RFC 2384. The scheme is used to
  reference a POP3 mailbox.
  
  C<URI> objects belonging to the pop scheme support the common, generic
  and server methods.  In addition, they provide two methods to access the
  userinfo components: $uri->user and $uri->auth
  
  =item B<rlogin>:
  
  An old specification of the I<rlogin> URI scheme is found in RFC
  1738. C<URI> objects belonging to the rlogin scheme support the
  common, generic and server methods.
  
  =item B<rtsp>:
  
  The I<rtsp> URL specification can be found in section 3.2 of RFC 2326.
  C<URI> objects belonging to the rtsp scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<rtspu>:
  
  The I<rtspu> URI scheme is used to talk to RTSP servers over UDP
  instead of TCP.  The syntax is the same as rtsp.
  
  =item B<rsync>:
  
  Information about rsync is available from L<http://rsync.samba.org/>.
  C<URI> objects belonging to the rsync scheme support the common,
  generic and server methods.  In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<sip>:
  
  The I<sip> URI specification is described in sections 19.1 and 25
  of RFC 3261.  C<URI> objects belonging to the sip scheme support the
  common, generic, and server methods with the exception of path related
  sub-components.  In addition, they provide two methods to get and set
  I<sip> parameters: $uri->params_form and $uri->params.
  
  =item B<sips>:
  
  See I<sip> scheme.  Its syntax is the same as sip, but the default
  port is different.
  
  =item B<snews>:
  
  See I<news> scheme.  Its syntax is the same as news, but the default
  port is different.
  
  =item B<telnet>:
  
  An old specification of the I<telnet> URI scheme is found in RFC
  1738. C<URI> objects belonging to the telnet scheme support the
  common, generic and server methods.
  
  =item B<tn3270>:
  
  These URIs are used like I<telnet> URIs but for connections to IBM
  mainframes.  C<URI> objects belonging to the tn3270 scheme support the
  common, generic and server methods.
  
  =item B<ssh>:
  
  Information about ssh is available at L<http://www.openssh.com/>.
  C<URI> objects belonging to the ssh scheme support the common,
  generic and server methods. In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<sftp>:
  
  C<URI> objects belonging to the sftp scheme support the common,
  generic and server methods. In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<urn>:
  
  The syntax of Uniform Resource Names is specified in RFC 2141.  C<URI>
  objects belonging to the urn scheme provide the common methods, and also the
  methods $uri->nid and $uri->nss, which return the Namespace Identifier
  and the Namespace-Specific String respectively.
  
  The Namespace Identifier basically works like the Scheme identifier of
  URIs, and further divides the URN namespace.  Namespace Identifier
  assignments are maintained at
  L<http://www.iana.org/assignments/urn-namespaces>.
  
  Letter case is not significant for the Namespace Identifier.  It is
  always returned in lower case by the $uri->nid method.  The $uri->_nid
  method can be used if you want it in its original case.
  
  =item B<urn>:B<isbn>:
  
  The C<urn:isbn:> namespace contains International Standard Book
  Numbers (ISBNs) and is described in RFC 3187.  A C<URI> object belonging
  to this namespace has the following extra methods (if the
  Business::ISBN module is available): $uri->isbn,
  $uri->isbn_publisher_code, $uri->isbn_group_code (formerly isbn_country_code,
  which is still supported by issues a deprecation warning), $uri->isbn_as_ean.
  
  =item B<urn>:B<oid>:
  
  The C<urn:oid:> namespace contains Object Identifiers (OIDs) and is
  described in RFC 3061.  An object identifier consists of sequences of digits
  separated by dots.  A C<URI> object belonging to this namespace has an
  additional method called $uri->oid that can be used to get/set the oid
  value.  In a list context, oid numbers are returned as separate elements.
  
  =back
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over 4
  
  =item $URI::ABS_ALLOW_RELATIVE_SCHEME
  
  Some older parsers used to allow the scheme name to be present in the
  relative URL if it was the same as the base URL scheme.  RFC 2396 says
  that this should be avoided, but you can enable this old behaviour by
  setting the $URI::ABS_ALLOW_RELATIVE_SCHEME variable to a TRUE value.
  The difference is demonstrated by the following examples:
  
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:foo"
  
    local $URI::ABS_ALLOW_RELATIVE_SCHEME = 1;
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:/host/a/foo"
  
  
  =item $URI::ABS_REMOTE_LEADING_DOTS
  
  You can also have the abs() method ignore excess ".."
  segments in the relative URI by setting $URI::ABS_REMOTE_LEADING_DOTS
  to a TRUE value.  The difference is demonstrated by the following
  examples:
  
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/../../foo"
  
    local $URI::ABS_REMOTE_LEADING_DOTS = 1;
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/foo"
  
  =item $URI::DEFAULT_QUERY_FORM_DELIMITER
  
  This value can be set to ";" to have the query form C<key=value> pairs
  delimited by ";" instead of "&" which is the default.
  
  =back
  
  =head1 BUGS
  
  There are some things that are not quite right:
  
  =over
  
  =item *
  
  Using regexp variables like $1 directly as arguments to the URI accessor methods
  does not work too well with current perl implementations.  I would argue
  that this is actually a bug in perl.  The workaround is to quote
  them. Example:
  
     /(...)/ || die;
     $u->query("$1");
  
  
  =item *
  
  The escaping (percent encoding) of chars in the 128 .. 255 range passed to the
  URI constructor or when setting URI parts using the accessor methods depend on
  the state of the internal UTF8 flag (see utf8::is_utf8) of the string passed.
  If the UTF8 flag is set the UTF-8 encoded version of the character is percent
  encoded.  If the UTF8 flag isn't set the Latin-1 version (byte) of the
  character is percent encoded.  This basically exposes the internal encoding of
  Perl strings.
  
  =back
  
  =head1 PARSING URIs WITH REGEXP
  
  As an alternative to this module, the following (official) regular
  expression can be used to decode a URI:
  
    my($scheme, $authority, $path, $query, $fragment) =
    $uri =~ m|(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?|;
  
  The C<URI::Split> module provides the function uri_split() as a
  readable alternative.
  
  =head1 SEE ALSO
  
  L<URI::file>, L<URI::WithBase>, L<URI::QueryParam>, L<URI::Escape>,
  L<URI::Split>, L<URI::Heuristic>
  
  RFC 2396: "Uniform Resource Identifiers (URI): Generic Syntax",
  Berners-Lee, Fielding, Masinter, August 1998.
  
  L<http://www.iana.org/assignments/uri-schemes>
  
  L<http://www.iana.org/assignments/urn-namespaces>
  
  L<http://www.w3.org/Addressing/>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2009 Gisle Aas.
  
  Copyright 1995 Martijn Koster.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHORS / ACKNOWLEDGMENTS
  
  This module is based on the C<URI::URL> module, which in turn was
  (distantly) based on the C<wwwurl.pl> code in the libwww-perl for
  perl4 developed by Roy Fielding, as part of the Arcadia project at the
  University of California, Irvine, with contributions from Brooks
  Cutter.
  
  C<URI::URL> was developed by Gisle Aas, Tim Bunce, Roy Fielding and
  Martijn Koster with input from other people on the libwww-perl mailing
  list.
  
  C<URI> and related subclasses was developed by Gisle Aas.
  
  =cut
URI

$fatpacked{"URI/Escape.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_ESCAPE';
  package URI::Escape;
  
  use strict;
  use warnings;
  
  =head1 NAME
  
  URI::Escape - Percent-encode and percent-decode unsafe characters
  
  =head1 SYNOPSIS
  
   use URI::Escape;
   $safe = uri_escape("10% is enough\n");
   $verysafe = uri_escape("foo", "\0-\377");
   $str  = uri_unescape($safe);
  
  =head1 DESCRIPTION
  
  This module provides functions to percent-encode and percent-decode URI strings as
  defined by RFC 3986. Percent-encoding URI's is informally called "URI escaping".
  This is the terminology used by this module, which predates the formalization of the
  terms by the RFC by several years.
  
  A URI consists of a restricted set of characters.  The restricted set
  of characters consists of digits, letters, and a few graphic symbols
  chosen from those common to most of the character encodings and input
  facilities available to Internet users.  They are made up of the
  "unreserved" and "reserved" character sets as defined in RFC 3986.
  
     unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
     reserved      = ":" / "/" / "?" / "#" / "[" / "]" / "@"
                     "!" / "$" / "&" / "'" / "(" / ")"
                   / "*" / "+" / "," / ";" / "="
  
  In addition, any byte (octet) can be represented in a URI by an escape
  sequence: a triplet consisting of the character "%" followed by two
  hexadecimal digits.  A byte can also be represented directly by a
  character, using the US-ASCII character for that octet.
  
  Some of the characters are I<reserved> for use as delimiters or as
  part of certain URI components.  These must be escaped if they are to
  be treated as ordinary data.  Read RFC 3986 for further details.
  
  The functions provided (and exported by default) from this module are:
  
  =over 4
  
  =item uri_escape( $string )
  
  =item uri_escape( $string, $unsafe )
  
  Replaces each unsafe character in the $string with the corresponding
  escape sequence and returns the result.  The $string argument should
  be a string of bytes.  The uri_escape() function will croak if given a
  characters with code above 255.  Use uri_escape_utf8() if you know you
  have such chars or/and want chars in the 128 .. 255 range treated as
  UTF-8.
  
  The uri_escape() function takes an optional second argument that
  overrides the set of characters that are to be escaped.  The set is
  specified as a string that can be used in a regular expression
  character class (between [ ]).  E.g.:
  
    "\x00-\x1f\x7f-\xff"          # all control and hi-bit characters
    "a-z"                         # all lower case characters
    "^A-Za-z"                     # everything not a letter
  
  The default set of characters to be escaped is all those which are
  I<not> part of the C<unreserved> character class shown above as well
  as the reserved characters.  I.e. the default is:
  
      "^A-Za-z0-9\-\._~"
  
  =item uri_escape_utf8( $string )
  
  =item uri_escape_utf8( $string, $unsafe )
  
  Works like uri_escape(), but will encode chars as UTF-8 before
  escaping them.  This makes this function able to deal with characters
  with code above 255 in $string.  Note that chars in the 128 .. 255
  range will be escaped differently by this function compared to what
  uri_escape() would.  For chars in the 0 .. 127 range there is no
  difference.
  
  Equivalent to:
  
      utf8::encode($string);
      my $uri = uri_escape($string);
  
  Note: JavaScript has a function called escape() that produces the
  sequence "%uXXXX" for chars in the 256 .. 65535 range.  This function
  has really nothing to do with URI escaping but some folks got confused
  since it "does the right thing" in the 0 .. 255 range.  Because of
  this you sometimes see "URIs" with these kind of escapes.  The
  JavaScript encodeURIComponent() function is similar to uri_escape_utf8().
  
  =item uri_unescape($string,...)
  
  Returns a string with each %XX sequence replaced with the actual byte
  (octet).
  
  This does the same as:
  
     $string =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
  
  but does not modify the string in-place as this RE would.  Using the
  uri_unescape() function instead of the RE might make the code look
  cleaner and is a few characters less to type.
  
  In a simple benchmark test I did,
  calling the function (instead of the inline RE above) if a few chars
  were unescaped was something like 40% slower, and something like 700% slower if none were.  If
  you are going to unescape a lot of times it might be a good idea to
  inline the RE.
  
  If the uri_unescape() function is passed multiple strings, then each
  one is returned unescaped.
  
  =back
  
  The module can also export the C<%escapes> hash, which contains the
  mapping from all 256 bytes to the corresponding escape codes.  Lookup
  in this hash is faster than evaluating C<sprintf("%%%02X", ord($byte))>
  each time.
  
  =head1 SEE ALSO
  
  L<URI>
  
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  use Exporter 5.57 'import';
  our %escapes;
  our @EXPORT = qw(uri_escape uri_unescape uri_escape_utf8);
  our @EXPORT_OK = qw(%escapes);
  our $VERSION = "3.31";
  
  use Carp ();
  
  # Build a char->hex map
  for (0..255) {
      $escapes{chr($_)} = sprintf("%%%02X", $_);
  }
  
  my %subst;  # compiled patterns
  
  my %Unsafe = (
      RFC2732 => qr/[^A-Za-z0-9\-_.!~*'()]/,
      RFC3986 => qr/[^A-Za-z0-9\-\._~]/,
  );
  
  sub uri_escape {
      my($text, $patn) = @_;
      return undef unless defined $text;
      if (defined $patn){
          unless (exists  $subst{$patn}) {
              # Because we can't compile the regex we fake it with a cached sub
              (my $tmp = $patn) =~ s,/,\\/,g;
              eval "\$subst{\$patn} = sub {\$_[0] =~ s/([$tmp])/\$escapes{\$1} || _fail_hi(\$1)/ge; }";
              Carp::croak("uri_escape: $@") if $@;
          }
          &{$subst{$patn}}($text);
      } else {
          $text =~ s/($Unsafe{RFC3986})/$escapes{$1} || _fail_hi($1)/ge;
      }
      $text;
  }
  
  sub _fail_hi {
      my $chr = shift;
      Carp::croak(sprintf "Can't escape \\x{%04X}, try uri_escape_utf8() instead", ord($chr));
  }
  
  sub uri_escape_utf8 {
      my $text = shift;
      return undef unless defined $text;
      utf8::encode($text);
      return uri_escape($text, @_);
  }
  
  sub uri_unescape {
      # Note from RFC1630:  "Sequences which start with a percent sign
      # but are not followed by two hexadecimal characters are reserved
      # for future extension"
      my $str = shift;
      if (@_ && wantarray) {
          # not executed for the common case of a single argument
          my @str = ($str, @_);  # need to copy
          for (@str) {
              s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
          }
          return @str;
      }
      $str =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg if defined $str;
      $str;
  }
  
  # XXX FIXME escape_char is buggy as it assigns meaning to the string's storage format.
  sub escape_char {
      # Old versions of utf8::is_utf8() didn't properly handle magical vars (e.g. $1).
      # The following forces a fetch to occur beforehand.
      my $dummy = substr($_[0], 0, 0);
  
      if (utf8::is_utf8($_[0])) {
          my $s = shift;
          utf8::encode($s);
          unshift(@_, $s);
      }
  
      return join '', @URI::Escape::escapes{split //, $_[0]};
  }
  
  1;
URI_ESCAPE

$fatpacked{"URI/Heuristic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HEURISTIC';
  package URI::Heuristic;
  
  =head1 NAME
  
  URI::Heuristic - Expand URI using heuristics
  
  =head1 SYNOPSIS
  
   use URI::Heuristic qw(uf_uristr);
   $u = uf_uristr("perl");             # http://www.perl.com
   $u = uf_uristr("www.sol.no/sol");   # http://www.sol.no/sol
   $u = uf_uristr("aas");              # http://www.aas.no
   $u = uf_uristr("ftp.funet.fi");     # ftp://ftp.funet.fi
   $u = uf_uristr("/etc/passwd");      # file:/etc/passwd
  
  =head1 DESCRIPTION
  
  This module provides functions that expand strings into real absolute
  URIs using some built-in heuristics.  Strings that already represent
  absolute URIs (i.e. that start with a C<scheme:> part) are never modified
  and are returned unchanged.  The main use of these functions is to
  allow abbreviated URIs similar to what many web browsers allow for URIs
  typed in by the user.
  
  The following functions are provided:
  
  =over 4
  
  =item uf_uristr($str)
  
  Tries to make the argument string
  into a proper absolute URI string.  The "uf_" prefix stands for "User 
  Friendly".  Under MacOS, it assumes that any string with a common URL 
  scheme (http, ftp, etc.) is a URL rather than a local path.  So don't name 
  your volumes after common URL schemes and expect uf_uristr() to construct 
  valid file: URL's on those volumes for you, because it won't.
  
  =item uf_uri($str)
  
  Works the same way as uf_uristr() but
  returns a C<URI> object.
  
  =back
  
  =head1 ENVIRONMENT
  
  If the hostname portion of a URI does not contain any dots, then
  certain qualified guesses are made.  These guesses are governed by
  the following environment variables:
  
  =over 10
  
  =item COUNTRY
  
  The two-letter country code (ISO 3166) for your location.  If
  the domain name of your host ends with two letters, then it is taken
  to be the default country. See also L<Locale::Country>.
  
  =item HTTP_ACCEPT_LANGUAGE, LC_ALL, LANG
  
  If COUNTRY is not set, these standard environment variables are
  examined and country (not language) information possibly found in them
  is used as the default country.
  
  =item URL_GUESS_PATTERN
  
  Contains a space-separated list of URL patterns to try.  The string
  "ACME" is for some reason used as a placeholder for the host name in
  the URL provided.  Example:
  
   URL_GUESS_PATTERN="www.ACME.no www.ACME.se www.ACME.com"
   export URL_GUESS_PATTERN
  
  Specifying URL_GUESS_PATTERN disables any guessing rules based on
  country.  An empty URL_GUESS_PATTERN disables any guessing that
  involves host name lookups.
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 1997-1998, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT_OK = qw(uf_uri uf_uristr uf_url uf_urlstr);
  our $VERSION = "4.20";
  
  our ($MY_COUNTRY, $DEBUG);
  
  sub MY_COUNTRY() {
      for ($MY_COUNTRY) {
  	return $_ if defined;
  
  	# First try the environment.
  	$_ = $ENV{COUNTRY};
  	return $_ if defined;
  
  	# Try the country part of LC_ALL and LANG from environment
  	my @srcs = ($ENV{LC_ALL}, $ENV{LANG});
  	# ...and HTTP_ACCEPT_LANGUAGE before those if present
  	if (my $httplang = $ENV{HTTP_ACCEPT_LANGUAGE}) {
  	    # TODO: q-value processing/ordering
  	    for $httplang (split(/\s*,\s*/, $httplang)) {
  		if ($httplang =~ /^\s*([a-zA-Z]+)[_-]([a-zA-Z]{2})\s*$/) {
  		    unshift(@srcs, "${1}_${2}");
  		    last;
  		}
  	    }
  	}
  	for (@srcs) {
  	    next unless defined;
  	    return lc($1) if /^[a-zA-Z]+_([a-zA-Z]{2})(?:[.@]|$)/;
  	}
  
  	# Last bit of domain name.  This may access the network.
  	require Net::Domain;
  	my $fqdn = Net::Domain::hostfqdn();
  	$_ = lc($1) if $fqdn =~ /\.([a-zA-Z]{2})$/;
  	return $_ if defined;
  
  	# Give up.  Defined but false.
  	return ($_ = 0);
      }
  }
  
  our %LOCAL_GUESSING =
  (
   'us' => [qw(www.ACME.gov www.ACME.mil)],
   'gb' => [qw(www.ACME.co.uk www.ACME.org.uk www.ACME.ac.uk)],
   'au' => [qw(www.ACME.com.au www.ACME.org.au www.ACME.edu.au)],
   'il' => [qw(www.ACME.co.il www.ACME.org.il www.ACME.net.il)],
   # send corrections and new entries to <gisle@aas.no>
  );
  # Backwards compatibility; uk != United Kingdom in ISO 3166
  $LOCAL_GUESSING{uk} = $LOCAL_GUESSING{gb};
  
  
  sub uf_uristr ($)
  {
      local($_) = @_;
      print STDERR "uf_uristr: resolving $_\n" if $DEBUG;
      return unless defined;
  
      s/^\s+//;
      s/\s+$//;
  
      if (/^(www|web|home)[a-z0-9-]*(?:\.|$)/i) {
  	$_ = "http://$_";
  
      } elsif (/^(ftp|gopher|news|wais|https|http)[a-z0-9-]*(?:\.|$)/i) {
  	$_ = lc($1) . "://$_";
  
      } elsif ($^O ne "MacOS" && 
  	    (m,^/,      ||          # absolute file name
  	     m,^\.\.?/, ||          # relative file name
  	     m,^[a-zA-Z]:[/\\],)    # dosish file name
  	    )
      {
  	$_ = "file:$_";
  
      } elsif ($^O eq "MacOS" && m/:/) {
          # potential MacOS file name
  	unless (m/^(ftp|gopher|news|wais|http|https|mailto):/) {
  	    require URI::file;
  	    my $a = URI::file->new($_)->as_string;
  	    $_ = ($a =~ m/^file:/) ? $a : "file:$a";
  	}
      } elsif (/^\w+([\.\-]\w+)*\@(\w+\.)+\w{2,3}$/) {
  	$_ = "mailto:$_";
  
      } elsif (!/^[a-zA-Z][a-zA-Z0-9.+\-]*:/) {      # no scheme specified
  	if (s/^([-\w]+(?:\.[-\w]+)*)([\/:\?\#]|$)/$2/) {
  	    my $host = $1;
  
  	    my $scheme = "http";
  	    if (/^:(\d+)\b/) {
  		# Some more or less well known ports
  		if ($1 =~ /^[56789]?443$/) {
  		    $scheme = "https";
  		} elsif ($1 eq "21") {
  		    $scheme = "ftp";
  		}
  	    }
  
  	    if ($host !~ /\./ && $host ne "localhost") {
  		my @guess;
  		if (exists $ENV{URL_GUESS_PATTERN}) {
  		    @guess = map { s/\bACME\b/$host/; $_ }
  		             split(' ', $ENV{URL_GUESS_PATTERN});
  		} else {
  		    if (MY_COUNTRY()) {
  			my $special = $LOCAL_GUESSING{MY_COUNTRY()};
  			if ($special) {
  			    my @special = @$special;
  			    push(@guess, map { s/\bACME\b/$host/; $_ }
                                                 @special);
  			} else {
  			    push(@guess, "www.$host." . MY_COUNTRY());
  			}
  		    }
  		    push(@guess, map "www.$host.$_",
  			             "com", "org", "net", "edu", "int");
  		}
  
  
  		my $guess;
  		for $guess (@guess) {
  		    print STDERR "uf_uristr: gethostbyname('$guess.')..."
  		      if $DEBUG;
  		    if (gethostbyname("$guess.")) {
  			print STDERR "yes\n" if $DEBUG;
  			$host = $guess;
  			last;
  		    }
  		    print STDERR "no\n" if $DEBUG;
  		}
  	    }
  	    $_ = "$scheme://$host$_";
  
  	} else {
  	    # pure junk, just return it unchanged...
  
  	}
      }
      print STDERR "uf_uristr: ==> $_\n" if $DEBUG;
  
      $_;
  }
  
  sub uf_uri ($)
  {
      require URI;
      URI->new(uf_uristr($_[0]));
  }
  
  # legacy
  *uf_urlstr = \*uf_uristr;
  
  sub uf_url ($)
  {
      require URI::URL;
      URI::URL->new(uf_uristr($_[0]));
  }
  
  1;
URI_HEURISTIC

$fatpacked{"URI/IRI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_IRI';
  package URI::IRI;
  
  # Experimental
  
  use strict;
  use warnings;
  use URI ();
  
  use overload '""' => sub { shift->as_string };
  
  our $VERSION = '1.74';
  
  sub new {
      my($class, $uri, $scheme) = @_;
      utf8::upgrade($uri);
      return bless {
  	uri => URI->new($uri, $scheme),
      }, $class;
  }
  
  sub clone {
      my $self = shift;
      return bless {
  	uri => $self->{uri}->clone,
      }, ref($self);
  }
  
  sub as_string {
      my $self = shift;
      return $self->{uri}->as_iri;
  }
  
  our $AUTOLOAD;
  sub AUTOLOAD
  {
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
  
      # We create the function here so that it will not need to be
      # autoloaded the next time.
      no strict 'refs';
      *$method = sub { shift->{uri}->$method(@_) };
      goto &$method;
  }
  
  sub DESTROY {}   # avoid AUTOLOADing it
  
  1;
URI_IRI

$fatpacked{"URI/QueryParam.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_QUERYPARAM';
  package URI::QueryParam;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  sub URI::_query::query_param {
      my $self = shift;
      my @old = $self->query_form;
  
      if (@_ == 0) {
  	# get keys
  	my (%seen, $i);
  	return grep !($i++ % 2 || $seen{$_}++), @old;
      }
  
      my $key = shift;
      my @i = grep $_ % 2 == 0 && $old[$_] eq $key, 0 .. $#old;
  
      if (@_) {
  	my @new = @old;
  	my @new_i = @i;
  	my @vals = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
  
  	while (@new_i > @vals) {
  	    splice @new, pop @new_i, 2;
  	}
  	if (@vals > @new_i) {
  	    my $i = @new_i ? $new_i[-1] + 2 : @new;
  	    my @splice = splice @vals, @new_i, @vals - @new_i;
  
  	    splice @new, $i, 0, map { $key => $_ } @splice;
  	}
  	if (@vals) {
  	    #print "SET $new_i[0]\n";
  	    @new[ map $_ + 1, @new_i ] = @vals;
  	}
  
  	$self->query_form(\@new);
      }
  
      return wantarray ? @old[map $_+1, @i] : @i ? $old[$i[0]+1] : undef;
  }
  
  sub URI::_query::query_param_append {
      my $self = shift;
      my $key = shift;
      my @vals = map { ref $_ eq 'ARRAY' ? @$_ : $_ } @_;
      $self->query_form($self->query_form, $key => \@vals);  # XXX
      return;
  }
  
  sub URI::_query::query_param_delete {
      my $self = shift;
      my $key = shift;
      my @old = $self->query_form;
      my @vals;
  
      for (my $i = @old - 2; $i >= 0; $i -= 2) {
  	next if $old[$i] ne $key;
  	push(@vals, (splice(@old, $i, 2))[1]);
      }
      $self->query_form(\@old) if @vals;
      return wantarray ? reverse @vals : $vals[-1];
  }
  
  sub URI::_query::query_form_hash {
      my $self = shift;
      my @old = $self->query_form;
      if (@_) {
  	$self->query_form(@_ == 1 ? %{shift(@_)} : @_);
      }
      my %hash;
      while (my($k, $v) = splice(@old, 0, 2)) {
  	if (exists $hash{$k}) {
  	    for ($hash{$k}) {
  		$_ = [$_] unless ref($_) eq "ARRAY";
  		push(@$_, $v);
  	    }
  	}
  	else {
  	    $hash{$k} = $v;
  	}
      }
      return \%hash;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::QueryParam - Additional query methods for URIs
  
  =head1 SYNOPSIS
  
    use URI;
    use URI::QueryParam;
  
    $u = URI->new("", "http");
    $u->query_param(foo => 1, 2, 3);
    print $u->query;    # prints foo=1&foo=2&foo=3
  
    for my $key ($u->query_param) {
        print "$key: ", join(", ", $u->query_param($key)), "\n";
    }
  
  =head1 DESCRIPTION
  
  Loading the C<URI::QueryParam> module adds some extra methods to
  URIs that support query methods.  These methods provide an alternative
  interface to the $u->query_form data.
  
  The query_param_* methods have deliberately been made identical to the
  interface of the corresponding C<CGI.pm> methods.
  
  The following additional methods are made available:
  
  =over
  
  =item @keys = $u->query_param
  
  =item @values = $u->query_param( $key )
  
  =item $first_value = $u->query_param( $key )
  
  =item $u->query_param( $key, $value,... )
  
  If $u->query_param is called with no arguments, it returns all the
  distinct parameter keys of the URI.  In a scalar context it returns the
  number of distinct keys.
  
  When a $key argument is given, the method returns the parameter values with the
  given key.  In a scalar context, only the first parameter value is
  returned.
  
  If additional arguments are given, they are used to update successive
  parameters with the given key.  If any of the values provided are
  array references, then the array is dereferenced to get the actual
  values.
  
  Please note that you can supply multiple values to this method, but you cannot
  supply multiple keys.
  
  Do this:
  
      $uri->query_param( widget_id => 1, 5, 9 );
  
  Do NOT do this:
  
      $uri->query_param( widget_id => 1, frobnicator_id => 99 );
  
  =item $u->query_param_append($key, $value,...)
  
  Adds new parameters with the given
  key without touching any old parameters with the same key.  It
  can be explained as a more efficient version of:
  
     $u->query_param($key,
                     $u->query_param($key),
                     $value,...);
  
  One difference is that this expression would return the old values
  of $key, whereas the query_param_append() method does not.
  
  =item @values = $u->query_param_delete($key)
  
  =item $first_value = $u->query_param_delete($key)
  
  Deletes all key/value pairs with the given key.
  The old values are returned.  In a scalar context, only the first value
  is returned.
  
  Using the query_param_delete() method is slightly more efficient than
  the equivalent:
  
     $u->query_param($key, []);
  
  =item $hashref = $u->query_form_hash
  
  =item $u->query_form_hash( \%new_form )
  
  Returns a reference to a hash that represents the
  query form's key/value pairs.  If a key occurs multiple times, then the hash
  value becomes an array reference.
  
  Note that sequence information is lost.  This means that:
  
     $u->query_form_hash($u->query_form_hash);
  
  is not necessarily a no-op, as it may reorder the key/value pairs.
  The values returned by the query_param() method should stay the same
  though.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<CGI>
  
  =head1 COPYRIGHT
  
  Copyright 2002 Gisle Aas.
  
  =cut
URI_QUERYPARAM

$fatpacked{"URI/Split.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SPLIT';
  package URI::Split;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use Exporter 5.57 'import';
  our @EXPORT_OK = qw(uri_split uri_join);
  
  use URI::Escape ();
  
  sub uri_split {
       return $_[0] =~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,;
  }
  
  sub uri_join {
      my($scheme, $auth, $path, $query, $frag) = @_;
      my $uri = defined($scheme) ? "$scheme:" : "";
      $path = "" unless defined $path;
      if (defined $auth) {
  	$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;
  	$uri .= "//$auth";
  	$path = "/$path" if length($path) && $path !~ m,^/,;
      }
      elsif ($path =~ m,^//,) {
  	$uri .= "//";  # XXX force empty auth
      }
      unless (length $uri) {
  	$path =~ s,(:), URI::Escape::escape_char($1),e while $path =~ m,^[^:/?\#]+:,;
      }
      $path =~ s,([?\#]), URI::Escape::escape_char($1),eg;
      $uri .= $path;
      if (defined $query) {
  	$query =~ s,(\#), URI::Escape::escape_char($1),eg;
  	$uri .= "?$query";
      }
      $uri .= "#$frag" if defined $frag;
      $uri;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::Split - Parse and compose URI strings
  
  =head1 SYNOPSIS
  
   use URI::Split qw(uri_split uri_join);
   ($scheme, $auth, $path, $query, $frag) = uri_split($uri);
   $uri = uri_join($scheme, $auth, $path, $query, $frag);
  
  =head1 DESCRIPTION
  
  Provides functions to parse and compose URI
  strings.  The following functions are provided:
  
  =over
  
  =item ($scheme, $auth, $path, $query, $frag) = uri_split($uri)
  
  Breaks up a URI string into its component
  parts.  An C<undef> value is returned for those parts that are not
  present.  The $path part is always present (but can be the empty
  string) and is thus never returned as C<undef>.
  
  No sensible value is returned if this function is called in a scalar
  context.
  
  =item $uri = uri_join($scheme, $auth, $path, $query, $frag)
  
  Puts together a URI string from its parts.
  Missing parts are signaled by passing C<undef> for the corresponding
  argument.
  
  Minimal escaping is applied to parts that contain reserved chars
  that would confuse a parser.  For instance, any occurrence of '?' or '#'
  in $path is always escaped, as it would otherwise be parsed back
  as a query or fragment.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::Escape>
  
  =head1 COPYRIGHT
  
  Copyright 2003, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_SPLIT

$fatpacked{"URI/URL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URL';
  package URI::URL;
  
  use strict;
  use warnings;
  
  use parent 'URI::WithBase';
  
  our $VERSION = "5.04";
  
  # Provide as much as possible of the old URI::URL interface for backwards
  # compatibility...
  
  use Exporter 5.57 'import';
  our @EXPORT = qw(url);
  
  # Easy to use constructor
  sub url ($;$) { URI::URL->new(@_); }
  
  use URI::Escape qw(uri_unescape);
  
  sub new
  {
      my $class = shift;
      my $self = $class->SUPER::new(@_);
      $self->[0] = $self->[0]->canonical;
      $self;
  }
  
  sub newlocal
  {
      my $class = shift;
      require URI::file;
      bless [URI::file->new_abs(shift)], $class;
  }
  
  {package URI::_foreign;
      sub _init  # hope it is not defined
      {
  	my $class = shift;
  	die "Unknown URI::URL scheme $_[1]:" if $URI::URL::STRICT;
  	$class->SUPER::_init(@_);
      }
  }
  
  sub strict
  {
      my $old = $URI::URL::STRICT;
      $URI::URL::STRICT = shift if @_;
      $old;
  }
  
  sub print_on
  {
      my $self = shift;
      require Data::Dumper;
      print STDERR Data::Dumper::Dumper($self);
  }
  
  sub _try
  {
      my $self = shift;
      my $method = shift;
      scalar(eval { $self->$method(@_) });
  }
  
  sub crack
  {
      # should be overridden by subclasses
      my $self = shift;
      (scalar($self->scheme),
       $self->_try("user"),
       $self->_try("password"),
       $self->_try("host"),
       $self->_try("port"),
       $self->_try("path"),
       $self->_try("params"),
       $self->_try("query"),
       scalar($self->fragment),
      )
  }
  
  sub full_path
  {
      my $self = shift;
      my $path = $self->path_query;
      $path = "/" unless length $path;
      $path;
  }
  
  sub netloc
  {
      shift->authority(@_);
  }
  
  sub epath
  {
      my $path = shift->SUPER::path(@_);
      $path =~ s/;.*//;
      $path;
  }
  
  sub eparams
  {
      my $self = shift;
      my @p = $self->path_segments;
      return undef unless ref($p[-1]);
      @p = @{$p[-1]};
      shift @p;
      join(";", @p);
  }
  
  sub params { shift->eparams(@_); }
  
  sub path {
      my $self = shift;
      my $old = $self->epath(@_);
      return unless defined wantarray;
      return '/' if !defined($old) || !length($old);
      Carp::croak("Path components contain '/' (you must call epath)")
  	if $old =~ /%2[fF]/ and !@_;
      $old = "/$old" if $old !~ m|^/| && defined $self->netloc;
      return uri_unescape($old);
  }
  
  sub path_components {
      shift->path_segments(@_);
  }
  
  sub query {
      my $self = shift;
      my $old = $self->equery(@_);
      if (defined(wantarray) && defined($old)) {
  	if ($old =~ /%(?:26|2[bB]|3[dD])/) {  # contains escaped '=' '&' or '+'
  	    my $mess;
  	    for ($old) {
  		$mess = "Query contains both '+' and '%2B'"
  		  if /\+/ && /%2[bB]/;
  		$mess = "Form query contains escaped '=' or '&'"
  		  if /=/  && /%(?:3[dD]|26)/;
  	    }
  	    if ($mess) {
  		Carp::croak("$mess (you must call equery)");
  	    }
  	}
  	# Now it should be safe to unescape the string without losing
  	# information
  	return uri_unescape($old);
      }
      undef;
  
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift;
      my $allow_scheme = shift;
      $allow_scheme = $URI::URL::ABS_ALLOW_RELATIVE_SCHEME
  	unless defined $allow_scheme;
      local $URI::ABS_ALLOW_RELATIVE_SCHEME = $allow_scheme;
      local $URI::ABS_REMOTE_LEADING_DOTS = $URI::URL::ABS_REMOTE_LEADING_DOTS;
      $self->SUPER::abs($base);
  }
  
  sub frag { shift->fragment(@_); }
  sub keywords { shift->query_keywords(@_); }
  
  # file:
  sub local_path { shift->file; }
  sub unix_path  { shift->file("unix"); }
  sub dos_path   { shift->file("dos");  }
  sub mac_path   { shift->file("mac");  }
  sub vms_path   { shift->file("vms");  }
  
  # mailto:
  sub address { shift->to(@_); }
  sub encoded822addr { shift->to(@_); }
  sub URI::mailto::authority { shift->to(@_); }  # make 'netloc' method work
  
  # news:
  sub groupart { shift->_group(@_); }
  sub article  { shift->message(@_); }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::URL - Uniform Resource Locators
  
  =head1 SYNOPSIS
  
   $u1 = URI::URL->new($str, $base);
   $u2 = $u1->abs;
  
  =head1 DESCRIPTION
  
  This module is provided for backwards compatibility with modules that
  depend on the interface provided by the C<URI::URL> class that used to
  be distributed with the libwww-perl library.
  
  The following differences exist compared to the C<URI> class interface:
  
  =over 3
  
  =item *
  
  The URI::URL module exports the url() function as an alternate
  constructor interface.
  
  =item *
  
  The constructor takes an optional $base argument.  The C<URI::URL>
  class is a subclass of C<URI::WithBase>.
  
  =item *
  
  The URI::URL->newlocal class method is the same as URI::file->new_abs.
  
  =item *
  
  URI::URL::strict(1)
  
  =item *
  
  $url->print_on method
  
  =item *
  
  $url->crack method
  
  =item *
  
  $url->full_path: same as ($uri->abs_path || "/")
  
  =item *
  
  $url->netloc: same as $uri->authority
  
  =item *
  
  $url->epath, $url->equery: same as $uri->path, $uri->query
  
  =item *
  
  $url->path and $url->query pass unescaped strings.
  
  =item *
  
  $url->path_components: same as $uri->path_segments (if you don't
  consider path segment parameters)
  
  =item *
  
  $url->params and $url->eparams methods
  
  =item *
  
  $url->base method.  See L<URI::WithBase>.
  
  =item *
  
  $url->abs and $url->rel have an optional $base argument.  See
  L<URI::WithBase>.
  
  =item *
  
  $url->frag: same as $uri->fragment
  
  =item *
  
  $url->keywords: same as $uri->query_keywords
  
  =item *
  
  $url->localpath and friends map to $uri->file.
  
  =item *
  
  $url->address and $url->encoded822addr: same as $uri->to for mailto URI
  
  =item *
  
  $url->groupart method for news URI
  
  =item *
  
  $url->article: same as $uri->message
  
  =back
  
  
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::WithBase>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2000 Gisle Aas.
  
  =cut
URI_URL

$fatpacked{"URI/WithBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_WITHBASE';
  package URI::WithBase;
  
  use strict;
  use warnings;
  
  use URI;
  use Scalar::Util 'blessed';
  
  our $VERSION = "2.20";
  
  use overload '""' => "as_string", fallback => 1;
  
  sub as_string;  # help overload find it
  
  sub new
  {
      my($class, $uri, $base) = @_;
      my $ibase = $base;
      if ($base && blessed($base) && $base->isa(__PACKAGE__)) {
  	$base = $base->abs;
  	$ibase = $base->[0];
      }
      bless [URI->new($uri, $ibase), $base], $class;
  }
  
  sub new_abs
  {
      my $class = shift;
      my $self = $class->new(@_);
      $self->abs;
  }
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      bless [URI->new($str, $scheme), undef], $class;
  }
  
  sub eq
  {
      my($self, $other) = @_;
      $other = $other->[0] if blessed($other) and $other->isa(__PACKAGE__);
      $self->[0]->eq($other);
  }
  
  our $AUTOLOAD;
  sub AUTOLOAD
  {
      my $self = shift;
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
      return if $method eq "DESTROY";
      $self->[0]->$method(@_);
  }
  
  sub can {                                  # override UNIVERSAL::can
      my $self = shift;
      $self->SUPER::can(@_) || (
        ref($self)
        ? $self->[0]->can(@_)
        : undef
      )
  }
  
  sub base {
      my $self = shift;
      my $base  = $self->[1];
  
      if (@_) { # set
  	my $new_base = shift;
  	# ensure absoluteness
  	$new_base = $new_base->abs if ref($new_base) && $new_base->isa(__PACKAGE__);
  	$self->[1] = $new_base;
      }
      return unless defined wantarray;
  
      # The base attribute supports 'lazy' conversion from URL strings
      # to URL objects. Strings may be stored but when a string is
      # fetched it will automatically be converted to a URL object.
      # The main benefit is to make it much cheaper to say:
      #   URI::WithBase->new($random_url_string, 'http:')
      if (defined($base) && !ref($base)) {
  	$base = ref($self)->new($base);
  	$self->[1] = $base unless @_;
      }
      $base;
  }
  
  sub clone
  {
      my $self = shift;
      my $base = $self->[1];
      $base = $base->clone if ref($base);
      bless [$self->[0]->clone, $base], ref($self);
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->abs($base, @_), $base], ref($self);
  }
  
  sub rel
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->rel($base, @_), $base], ref($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::WithBase - URIs which remember their base
  
  =head1 SYNOPSIS
  
   $u1 = URI::WithBase->new($str, $base);
   $u2 = $u1->abs;
  
   $base = $u1->base;
   $u1->base( $new_base )
  
  =head1 DESCRIPTION
  
  This module provides the C<URI::WithBase> class.  Objects of this class
  are like C<URI> objects, but can keep their base too.  The base
  represents the context where this URI was found and can be used to
  absolutize or relativize the URI.  All the methods described in L<URI>
  are supported for C<URI::WithBase> objects.
  
  The methods provided in addition to or modified from those of C<URI> are:
  
  =over 4
  
  =item $uri = URI::WithBase->new($str, [$base])
  
  The constructor takes an optional base URI as the second argument.
  If provided, this argument initializes the base attribute.
  
  =item $uri->base( [$new_base] )
  
  Can be used to get or set the value of the base attribute.
  The return value, which is the old value, is a URI object or C<undef>.
  
  =item $uri->abs( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is returned even if $uri is already
  absolute (while plain URI objects simply return themselves in
  that case).
  
  =item $uri->rel( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is always returned.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2002 Gisle Aas.
  
  =cut
URI_WITHBASE

$fatpacked{"URI/_foreign.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__FOREIGN';
  package URI::_foreign;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  
  our $VERSION = '1.74';
  
  1;
URI__FOREIGN

$fatpacked{"URI/_generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__GENERIC';
  package URI::_generic;
  
  use strict;
  use warnings;
  
  use parent qw(URI URI::_query);
  
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  our $VERSION = '1.74';
  
  my $ACHAR = $URI::uric;  $ACHAR =~ s,\\[/?],,g;
  my $PCHAR = $URI::uric;  $PCHAR =~ s,\\[?],,g;
  
  sub _no_scheme_ok { 1 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?://([^/?\#]*))?(.*)$,os or die;
  
      if (@_) {
  	my $auth = shift;
  	$$self = $1;
  	my $rest = $3;
  	if (defined $auth) {
  	    $auth =~ s/([^$ACHAR])/ URI::Escape::escape_char($1)/ego;
  	    utf8::downgrade($auth);
  	    $$self .= "//$auth";
  	}
  	_check_path($rest, $$self);
  	$$self .= $rest;
      }
      $2;
  }
  
  sub path
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^?\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$PCHAR])/ URI::Escape::escape_char($1)/ego;
  	utf8::downgrade($new_path);
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub path_query
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
  	utf8::downgrade($new_path);
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub _check_path
  {
      my($path, $pre) = @_;
      my $prefix;
      if ($pre =~ m,/,) {  # authority present
  	$prefix = "/" if length($path) && $path !~ m,^[/?\#],;
      }
      else {
  	if ($path =~ m,^//,) {
  	    Carp::carp("Path starting with double slash is confusing")
  		if $^W;
  	}
  	elsif (!length($pre) && $path =~ m,^[^:/?\#]+:,) {
  	    Carp::carp("Path might look like scheme, './' prepended")
  		if $^W;
  	    $prefix = "./";
  	}
      }
      substr($_[0], 0, 0) = $prefix if defined $prefix;
  }
  
  sub path_segments
  {
      my $self = shift;
      my $path = $self->path;
      if (@_) {
  	my @arg = @_;  # make a copy
  	for (@arg) {
  	    if (ref($_)) {
  		my @seg = @$_;
  		$seg[0] =~ s/%/%25/g;
  		for (@seg) { s/;/%3B/g; }
  		$_ = join(";", @seg);
  	    }
  	    else {
  		 s/%/%25/g; s/;/%3B/g;
  	    }
  	    s,/,%2F,g;
  	}
  	$self->path(join("/", @arg));
      }
      return $path unless wantarray;
      map {/;/ ? $self->_split_segment($_)
               : uri_unescape($_) }
          split('/', $path, -1);
  }
  
  
  sub _split_segment
  {
      my $self = shift;
      require URI::_segment;
      URI::_segment->new(@_);
  }
  
  
  sub abs
  {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
  
      if (my $scheme = $self->scheme) {
  	return $self unless $URI::ABS_ALLOW_RELATIVE_SCHEME;
  	$base = URI->new($base) unless ref $base;
  	return $self unless $scheme eq $base->scheme;
      }
  
      $base = URI->new($base) unless ref $base;
      my $abs = $self->clone;
      $abs->scheme($base->scheme);
      return $abs if $$self =~ m,^(?:$URI::scheme_re:)?//,o;
      $abs->authority($base->authority);
  
      my $path = $self->path;
      return $abs if $path =~ m,^/,;
  
      if (!length($path)) {
  	my $abs = $base->clone;
  	my $query = $self->query;
  	$abs->query($query) if defined $query;
  	my $fragment = $self->fragment;
  	$abs->fragment($fragment) if defined $fragment;
  	return $abs;
      }
  
      my $p = $base->path;
      $p =~ s,[^/]+$,,;
      $p .= $path;
      my @p = split('/', $p, -1);
      shift(@p) if @p && !length($p[0]);
      my $i = 1;
      while ($i < @p) {
  	#print "$i ", join("/", @p), " ($p[$i])\n";
  	if ($p[$i-1] eq ".") {
  	    splice(@p, $i-1, 1);
  	    $i-- if $i > 1;
  	}
  	elsif ($p[$i] eq ".." && $p[$i-1] ne "..") {
  	    splice(@p, $i-1, 2);
  	    if ($i > 1) {
  		$i--;
  		push(@p, "") if $i == @p;
  	    }
  	}
  	else {
  	    $i++;
  	}
      }
      $p[-1] = "" if @p && $p[-1] eq ".";  # trailing "/."
      if ($URI::ABS_REMOTE_LEADING_DOTS) {
          shift @p while @p && $p[0] =~ /^\.\.?$/;
      }
      $abs->path("/" . join("/", @p));
      $abs;
  }
  
  # The opposite of $url->abs.  Return a URI which is as relative as possible
  sub rel {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
      my $rel = $self->clone;
      $base = URI->new($base) unless ref $base;
  
      #my($scheme, $auth, $path) = @{$rel}{qw(scheme authority path)};
      my $scheme = $rel->scheme;
      my $auth   = $rel->canonical->authority;
      my $path   = $rel->path;
  
      if (!defined($scheme) && !defined($auth)) {
  	# it is already relative
  	return $rel;
      }
  
      #my($bscheme, $bauth, $bpath) = @{$base}{qw(scheme authority path)};
      my $bscheme = $base->scheme;
      my $bauth   = $base->canonical->authority;
      my $bpath   = $base->path;
  
      for ($bscheme, $bauth, $auth) {
  	$_ = '' unless defined
      }
  
      unless ($scheme eq $bscheme && $auth eq $bauth) {
  	# different location, can't make it relative
  	return $rel;
      }
  
      for ($path, $bpath) {  $_ = "/$_" unless m,^/,; }
  
      # Make it relative by eliminating scheme and authority
      $rel->scheme(undef);
      $rel->authority(undef);
  
      # This loop is based on code from Nicolai Langfeldt <janl@ifi.uio.no>.
      # First we calculate common initial path components length ($li).
      my $li = 1;
      while (1) {
  	my $i = index($path, '/', $li);
  	last if $i < 0 ||
                  $i != index($bpath, '/', $li) ||
  	        substr($path,$li,$i-$li) ne substr($bpath,$li,$i-$li);
  	$li=$i+1;
      }
      # then we nuke it from both paths
      substr($path, 0,$li) = '';
      substr($bpath,0,$li) = '';
  
      if ($path eq $bpath &&
          defined($rel->fragment) &&
          !defined($rel->query)) {
          $rel->path("");
      }
      else {
          # Add one "../" for each path component left in the base path
          $path = ('../' x $bpath =~ tr|/|/|) . $path;
  	$path = "./" if $path eq "";
          $rel->path($path);
      }
  
      $rel;
  }
  
  1;
URI__GENERIC

$fatpacked{"URI/_idna.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__IDNA';
  package URI::_idna;
  
  # This module implements the RFCs 3490 (IDNA) and 3491 (Nameprep)
  # based on Python-2.6.4/Lib/encodings/idna.py
  
  use strict;
  use warnings;
  
  use URI::_punycode qw(encode_punycode decode_punycode);
  use Carp qw(croak);
  
  our $VERSION = '1.74';
  
  BEGIN {
    *URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS = "$]" < 5.008_003
      ? sub () { 1 }
      : sub () { 0 }
    ;
  }
  
  my $ASCII = qr/^[\x00-\x7F]*\z/;
  
  sub encode {
      my $idomain = shift;
      my @labels = split(/\./, $idomain, -1);
      my @last_empty;
      push(@last_empty, pop @labels) if @labels > 1 && $labels[-1] eq "";
      for (@labels) {
  	$_ = ToASCII($_);
      }
  
      return eval 'join(".", @labels, @last_empty)' if URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS;
      return join(".", @labels, @last_empty);
  }
  
  sub decode {
      my $domain = shift;
      return join(".", map ToUnicode($_), split(/\./, $domain, -1))
  }
  
  sub nameprep { # XXX real implementation missing
      my $label = shift;
      $label = lc($label);
      return $label;
  }
  
  sub check_size {
      my $label = shift;
      croak "Label empty" if $label eq "";
      croak "Label too long" if length($label) > 63;
      return $label;
  }
  
  sub ToASCII {
      my $label = shift;
      return check_size($label) if $label =~ $ASCII;
  
      # Step 2: nameprep
      $label = nameprep($label);
      # Step 3: UseSTD3ASCIIRules is false
      # Step 4: try ASCII again
      return check_size($label) if $label =~ $ASCII;
  
      # Step 5: Check ACE prefix
      if ($label =~ /^xn--/) {
          croak "Label starts with ACE prefix";
      }
  
      # Step 6: Encode with PUNYCODE
      $label = encode_punycode($label);
  
      # Step 7: Prepend ACE prefix
      $label = "xn--$label";
  
      # Step 8: Check size
      return check_size($label);
  }
  
  sub ToUnicode {
      my $label = shift;
      $label = nameprep($label) unless $label =~ $ASCII;
      return $label unless $label =~ /^xn--/;
      my $result = decode_punycode(substr($label, 4));
      my $label2 = ToASCII($result);
      if (lc($label) ne $label2) {
  	croak "IDNA does not round-trip: '\L$label\E' vs '$label2'";
      }
      return $result;
  }
  
  1;
URI__IDNA

$fatpacked{"URI/_ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::_ldap;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use URI::Escape qw(uri_unescape);
  
  sub _ldap_elem {
    my $self  = shift;
    my $elem  = shift;
    my $query = $self->query;
    my @bits  = (split(/\?/,defined($query) ? $query : ""),("")x4);
    my $old   = $bits[$elem];
  
    if (@_) {
      my $new = shift;
      $new =~ s/\?/%3F/g;
      $bits[$elem] = $new;
      $query = join("?",@bits);
      $query =~ s/\?+$//;
      $query = undef unless length($query);
      $self->query($query);
    }
  
    $old;
  }
  
  sub dn {
    my $old = shift->path(@_);
    $old =~ s:^/::;
    uri_unescape($old);
  }
  
  sub attributes {
    my $self = shift;
    my $old = _ldap_elem($self,0, @_ ? join(",", map { my $tmp = $_; $tmp =~ s/,/%2C/g; $tmp } @_) : ());
    return $old unless wantarray;
    map { uri_unescape($_) } split(/,/,$old);
  }
  
  sub _scope {
    my $self = shift;
    my $old = _ldap_elem($self,1, @_);
    return undef unless defined wantarray && defined $old;
    uri_unescape($old);
  }
  
  sub scope {
    my $old = &_scope;
    $old = "base" unless length $old;
    $old;
  }
  
  sub _filter {
    my $self = shift;
    my $old = _ldap_elem($self,2, @_);
    return undef unless defined wantarray && defined $old;
    uri_unescape($old); # || "(objectClass=*)";
  }
  
  sub filter {
    my $old = &_filter;
    $old = "(objectClass=*)" unless length $old;
    $old;
  }
  
  sub extensions {
    my $self = shift;
    my @ext;
    while (@_) {
      my $key = shift;
      my $value = shift;
      push(@ext, join("=", map { $_="" unless defined; s/,/%2C/g; $_ } $key, $value));
    }
    @ext = join(",", @ext) if @ext;
    my $old = _ldap_elem($self,3, @ext);
    return $old unless wantarray;
    map { uri_unescape($_) } map { /^([^=]+)=(.*)$/ } split(/,/,$old);
  }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->_nonldap_canonical;
  
      # The stuff below is not as efficient as one might hope...
  
      $other = $other->clone if $other == $self;
  
      $other->dn(_normalize_dn($other->dn));
  
      # Should really know about mixed case "postalAddress", etc...
      $other->attributes(map lc, $other->attributes);
  
      # Lowercase scope, remove default
      my $old_scope = $other->scope;
      my $new_scope = lc($old_scope);
      $new_scope = "" if $new_scope eq "base";
      $other->scope($new_scope) if $new_scope ne $old_scope;
  
      # Remove filter if default
      my $old_filter = $other->filter;
      $other->filter("") if lc($old_filter) eq "(objectclass=*)" ||
  	                  lc($old_filter) eq "objectclass=*";
  
      # Lowercase extensions types and deal with known extension values
      my @ext = $other->extensions;
      for (my $i = 0; $i < @ext; $i += 2) {
  	my $etype = $ext[$i] = lc($ext[$i]);
  	if ($etype =~ /^!?bindname$/) {
  	    $ext[$i+1] = _normalize_dn($ext[$i+1]);
  	}
      }
      $other->extensions(@ext) if @ext;
      
      $other;
  }
  
  sub _normalize_dn  # RFC 2253
  {
      my $dn = shift;
  
      return $dn;
      # The code below will fail if the "+" or "," is embedding in a quoted
      # string or simply escaped...
  
      my @dn = split(/([+,])/, $dn);
      for (@dn) {
  	s/^([a-zA-Z]+=)/lc($1)/e;
      }
      join("", @dn);
  }
  
  1;
URI__LDAP

$fatpacked{"URI/_login.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LOGIN';
  package URI::_login;
  
  use strict;
  use warnings;
  
  use parent qw(URI::_server URI::_userpass);
  
  our $VERSION = '1.74';
  
  # Generic terminal logins.  This is used as a base class for 'telnet',
  # 'tn3270', and 'rlogin' URL schemes.
  
  1;
URI__LOGIN

$fatpacked{"URI/_punycode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__PUNYCODE';
  package URI::_punycode;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use Exporter 'import';
  our @EXPORT = qw(encode_punycode decode_punycode);
  
  use integer;
  
  our $DEBUG = 0;
  
  use constant BASE => 36;
  use constant TMIN => 1;
  use constant TMAX => 26;
  use constant SKEW => 38;
  use constant DAMP => 700;
  use constant INITIAL_BIAS => 72;
  use constant INITIAL_N => 128;
  
  my $Delimiter = chr 0x2D;
  my $BasicRE   = qr/[\x00-\x7f]/;
  
  sub _croak { require Carp; Carp::croak(@_); }
  
  sub digit_value {
      my $code = shift;
      return ord($code) - ord("A") if $code =~ /[A-Z]/;
      return ord($code) - ord("a") if $code =~ /[a-z]/;
      return ord($code) - ord("0") + 26 if $code =~ /[0-9]/;
      return;
  }
  
  sub code_point {
      my $digit = shift;
      return $digit + ord('a') if 0 <= $digit && $digit <= 25;
      return $digit + ord('0') - 26 if 26 <= $digit && $digit <= 36;
      die 'NOT COME HERE';
  }
  
  sub adapt {
      my($delta, $numpoints, $firsttime) = @_;
      $delta = $firsttime ? $delta / DAMP : $delta / 2;
      $delta += $delta / $numpoints;
      my $k = 0;
      while ($delta > ((BASE - TMIN) * TMAX) / 2) {
  	$delta /= BASE - TMIN;
  	$k += BASE;
      }
      return $k + (((BASE - TMIN + 1) * $delta) / ($delta + SKEW));
  }
  
  sub decode_punycode {
      my $code = shift;
  
      my $n      = INITIAL_N;
      my $i      = 0;
      my $bias   = INITIAL_BIAS;
      my @output;
  
      if ($code =~ s/(.*)$Delimiter//o) {
  	push @output, map ord, split //, $1;
  	return _croak('non-basic code point') unless $1 =~ /^$BasicRE*$/o;
      }
  
      while ($code) {
  	my $oldi = $i;
  	my $w    = 1;
      LOOP:
  	for (my $k = BASE; 1; $k += BASE) {
  	    my $cp = substr($code, 0, 1, '');
  	    my $digit = digit_value($cp);
  	    defined $digit or return _croak("invalid punycode input");
  	    $i += $digit * $w;
  	    my $t = ($k <= $bias) ? TMIN
  		: ($k >= $bias + TMAX) ? TMAX : $k - $bias;
  	    last LOOP if $digit < $t;
  	    $w *= (BASE - $t);
  	}
  	$bias = adapt($i - $oldi, @output + 1, $oldi == 0);
  	warn "bias becomes $bias" if $DEBUG;
  	$n += $i / (@output + 1);
  	$i = $i % (@output + 1);
  	splice(@output, $i, 0, $n);
  	warn join " ", map sprintf('%04x', $_), @output if $DEBUG;
  	$i++;
      }
      return join '', map chr, @output;
  }
  
  sub encode_punycode {
      my $input = shift;
      my @input = split //, $input;
  
      my $n     = INITIAL_N;
      my $delta = 0;
      my $bias  = INITIAL_BIAS;
  
      my @output;
      my @basic = grep /$BasicRE/, @input;
      my $h = my $b = @basic;
      push @output, @basic;
      push @output, $Delimiter if $b && $h < @input;
      warn "basic codepoints: (@output)" if $DEBUG;
  
      while ($h < @input) {
  	my $m = min(grep { $_ >= $n } map ord, @input);
  	warn sprintf "next code point to insert is %04x", $m if $DEBUG;
  	$delta += ($m - $n) * ($h + 1);
  	$n = $m;
  	for my $i (@input) {
  	    my $c = ord($i);
  	    $delta++ if $c < $n;
  	    if ($c == $n) {
  		my $q = $delta;
  	    LOOP:
  		for (my $k = BASE; 1; $k += BASE) {
  		    my $t = ($k <= $bias) ? TMIN :
  			($k >= $bias + TMAX) ? TMAX : $k - $bias;
  		    last LOOP if $q < $t;
  		    my $cp = code_point($t + (($q - $t) % (BASE - $t)));
  		    push @output, chr($cp);
  		    $q = ($q - $t) / (BASE - $t);
  		}
  		push @output, chr(code_point($q));
  		$bias = adapt($delta, $h + 1, $h == $b);
  		warn "bias becomes $bias" if $DEBUG;
  		$delta = 0;
  		$h++;
  	    }
  	}
  	$delta++;
  	$n++;
      }
      return join '', @output;
  }
  
  sub min {
      my $min = shift;
      for (@_) { $min = $_ if $_ <= $min }
      return $min;
  }
  
  1;
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  URI::_punycode - encodes Unicode string in Punycode
  
  =head1 SYNOPSIS
  
    use strict;
    use warnings;
    use utf8;
  
    use URI::_punycode qw(encode_punycode decode_punycode);
  
    # encode a unicode string
    my $punycode = encode_punycode('http://.net'); # http://.net-xc8g
    $punycode = encode_punycode('bcher'); # bcher-kva
    $punycode = encode_punycode(''); # ihqwcrb4cv8a8dqg056pqjye
  
    # decode a punycode string back into a unicode string
    my $unicode = decode_punycode('http://.net-xc8g'); # http://.net
    $unicode = decode_punycode('bcher-kva'); # bcher
    $unicode = decode_punycode('ihqwcrb4cv8a8dqg056pqjye'); # 
  
  =head1 DESCRIPTION
  
  L<URI::_punycode> is a module to encode / decode Unicode strings into
  L<Punycode|https://tools.ietf.org/html/rfc3492>, an efficient
  encoding of Unicode for use with L<IDNA|https://tools.ietf.org/html/rfc5890>.
  
  =head1 FUNCTIONS
  
  All functions throw exceptions on failure. You can C<catch> them with
  L<Syntax::Keyword::Try> or L<Try::Tiny>. The following functions are exported
  by default.
  
  =head2 encode_punycode
  
    my $punycode = encode_punycode('http://.net');  # http://.net-xc8g
    $punycode = encode_punycode('bcher'); # bcher-kva
    $punycode = encode_punycode('') # ihqwcrb4cv8a8dqg056pqjye
  
  Takes a Unicode string (UTF8-flagged variable) and returns a Punycode
  encoding for it.
  
  =head2 decode_punycode
  
    my $unicode = decode_punycode('http://.net-xc8g'); # http://.net
    $unicode = decode_punycode('bcher-kva'); # bcher
    $unicode = decode_punycode('ihqwcrb4cv8a8dqg056pqjye'); # 
  
  Takes a Punycode encoding and returns original Unicode string.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa <F<miyagawa@bulknews.net>> is the author of
  L<IDNA::Punycode> which was the basis for this module.
  
  =head1 SEE ALSO
  
  L<IDNA::Punycode>, L<RFC 3492|https://tools.ietf.org/html/rfc3492>,
  L<RFC 5891|https://tools.ietf.org/html/rfc5891>
  
  =head1 COPYRIGHT AND LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
URI__PUNYCODE

$fatpacked{"URI/_query.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__QUERY';
  package URI::_query;
  
  use strict;
  use warnings;
  
  use URI ();
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub query
  {
      my $self = shift;
      $$self =~ m,^([^?\#]*)(?:\?([^\#]*))?(.*)$,s or die;
  
      if (@_) {
  	my $q = shift;
  	$$self = $1;
  	if (defined $q) {
  	    $q =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
  	    utf8::downgrade($q);
  	    $$self .= "?$q";
  	}
  	$$self .= $3;
      }
      $2;
  }
  
  # Handle ...?foo=bar&bar=foo type of query
  sub query_form {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
          my $delim;
          my $r = $_[0];
          if (ref($r) eq "ARRAY") {
              $delim = $_[1];
              @_ = @$r;
          }
          elsif (ref($r) eq "HASH") {
              $delim = $_[1];
              @_ = map { $_ => $r->{$_} } sort keys %$r;
          }
          $delim = pop if @_ % 2;
  
          my @query;
          while (my($key,$vals) = splice(@_, 0, 2)) {
              $key = '' unless defined $key;
  	    $key =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;
  	    $key =~ s/ /+/g;
  	    $vals = [ref($vals) eq "ARRAY" ? @$vals : $vals];
              for my $val (@$vals) {
                  $val = '' unless defined $val;
  		$val =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;
                  $val =~ s/ /+/g;
                  push(@query, "$key=$val");
              }
          }
          if (@query) {
              unless ($delim) {
                  $delim = $1 if $old && $old =~ /([&;])/;
                  $delim ||= $URI::DEFAULT_QUERY_FORM_DELIMITER || "&";
              }
              $self->query(join($delim, @query));
          }
          else {
              $self->query(undef);
          }
      }
      return if !defined($old) || !length($old) || !defined(wantarray);
      return unless $old =~ /=/; # not a form
      map { s/\+/ /g; uri_unescape($_) }
           map { /=/ ? split(/=/, $_, 2) : ($_ => '')} split(/[&;]/, $old);
  }
  
  # Handle ...?dog+bones type of query
  sub query_keywords
  {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
  	my @copy = @_;
  	@copy = @{$copy[0]} if @copy == 1 && ref($copy[0]) eq "ARRAY";
  	for (@copy) { s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg; }
  	$self->query(@copy ? join('+', @copy) : undef);
      }
      return if !defined($old) || !defined(wantarray);
      return if $old =~ /=/;  # not keywords, but a form
      map { uri_unescape($_) } split(/\+/, $old, -1);
  }
  
  # Some URI::URL compatibility stuff
  sub equery { goto &query }
  
  1;
URI__QUERY

$fatpacked{"URI/_segment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SEGMENT';
  package URI::_segment;
  
  # Represents a generic path_segment so that it can be treated as
  # a string too.
  
  use strict;
  use warnings;
  
  use URI::Escape qw(uri_unescape);
  
  use overload '""' => sub { $_[0]->[0] },
               fallback => 1;
  
  our $VERSION = '1.74';
  
  sub new
  {
      my $class = shift;
      my @segment = split(';', shift, -1);
      $segment[0] = uri_unescape($segment[0]);
      bless \@segment, $class;
  }
  
  1;
URI__SEGMENT

$fatpacked{"URI/_server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SERVER';
  package URI::_server;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub _uric_escape {
      my($class, $str) = @_;
      if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os) {
  	my($scheme, $host, $rest) = ($1, $2, $3);
  	my $ui = $host =~ s/(.*@)// ? $1 : "";
  	my $port = $host =~ s/(:\d+)\z// ? $1 : "";
  	if (_host_escape($host)) {
  	    $str = "$scheme//$ui$host$port$rest";
  	}
      }
      return $class->SUPER::_uric_escape($str);
  }
  
  sub _host_escape {
      return unless $_[0] =~ /[^$URI::uric]/;
      eval {
  	require URI::_idna;
  	$_[0] = URI::_idna::encode($_[0]);
      };
      return 0 if $@;
      return 1;
  }
  
  sub as_iri {
      my $self = shift;
      my $str = $self->SUPER::as_iri;
      if ($str =~ /\bxn--/) {
  	if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os) {
  	    my($scheme, $host, $rest) = ($1, $2, $3);
  	    my $ui = $host =~ s/(.*@)// ? $1 : "";
  	    my $port = $host =~ s/(:\d+)\z// ? $1 : "";
  	    require URI::_idna;
  	    $host = URI::_idna::decode($host);
  	    $str = "$scheme//$ui$host$port$rest";
  	}
      }
      return $str;
  }
  
  sub userinfo
  {
      my $self = shift;
      my $old = $self->authority;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/.*@//;  # remove old stuff
  	my $ui = shift;
  	if (defined $ui) {
  	    $ui =~ s/@/%40/g;   # protect @
  	    $new = "$ui\@$new";
  	}
  	$self->authority($new);
      }
      return undef if !defined($old) || $old !~ /(.*)@/;
      return $1;
  }
  
  sub host
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $tmp = $old;
  	$tmp = "" unless defined $tmp;
  	my $ui = ($tmp =~ /(.*@)/) ? $1 : "";
  	my $port = ($tmp =~ /(:\d+)$/) ? $1 : "";
  	my $new = shift;
  	$new = "" unless defined $new;
  	if (length $new) {
  	    $new =~ s/[@]/%40/g;   # protect @
  	    if ($new =~ /^[^:]*:\d*\z/ || $new =~ /]:\d*\z/) {
  		$new =~ s/(:\d*)\z// || die "Assert";
  		$port = $1;
  	    }
  	    $new = "[$new]" if $new =~ /:/ && $new !~ /^\[/; # IPv6 address
  	    _host_escape($new);
  	}
  	$self->authority("$ui$new$port");
      }
      return undef unless defined $old;
      $old =~ s/.*@//;
      $old =~ s/:\d+$//;          # remove the port
      $old =~ s{^\[(.*)\]$}{$1};  # remove brackets around IPv6 (RFC 3986 3.2.2)
      return uri_unescape($old);
  }
  
  sub ihost
  {
      my $self = shift;
      my $old = $self->host(@_);
      if ($old =~ /(^|\.)xn--/) {
  	require URI::_idna;
  	$old = URI::_idna::decode($old);
      }
      return $old;
  }
  
  sub _port
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $new = $old;
  	$new =~ s/:\d*$//;
  	my $port = shift;
  	$new .= ":$port" if defined $port;
  	$self->authority($new);
      }
      return $1 if defined($old) && $old =~ /:(\d*)$/;
      return;
  }
  
  sub port
  {
      my $self = shift;
      my $port = $self->_port(@_);
      $port = $self->default_port if !defined($port) || $port eq "";
      $port;
  }
  
  sub host_port
  {
      my $self = shift;
      my $old = $self->authority;
      $self->host(shift) if @_;
      return undef unless defined $old;
      $old =~ s/.*@//;        # zap userinfo
      $old =~ s/:$//;         # empty port should be treated the same a no port
      $old .= ":" . $self->port unless $old =~ /:\d+$/;
      $old;
  }
  
  
  sub default_port { undef }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
      my $host = $other->host || "";
      my $port = $other->_port;
      my $uc_host = $host =~ /[A-Z]/;
      my $def_port = defined($port) && ($port eq "" ||
                                        $port == $self->default_port);
      if ($uc_host || $def_port) {
  	$other = $other->clone if $other == $self;
  	$other->host(lc $host) if $uc_host;
  	$other->port(undef)    if $def_port;
      }
      $other;
  }
  
  1;
URI__SERVER

$fatpacked{"URI/_userpass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__USERPASS';
  package URI::_userpass;
  
  use strict;
  use warnings;
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub user
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $pass = defined($info) ? $info : "";
  	$pass =~ s/^[^:]*//;
  
  	if (!defined($new) && !length($pass)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $new =~ s/:/%3A/g;
  	    $self->userinfo("$new$pass");
  	}
      }
      return undef unless defined $info;
      $info =~ s/:.*//;
      uri_unescape($info);
  }
  
  sub password
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $user = defined($info) ? $info : "";
  	$user =~ s/:.*//;
  
  	if (!defined($new) && !length($user)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $self->userinfo("$user:$new");
  	}
      }
      return undef unless defined $info;
      return undef unless $info =~ s/^[^:]*://;
      uri_unescape($info);
  }
  
  1;
URI__USERPASS

$fatpacked{"URI/data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_DATA';
  package URI::data;  # RFC 2397
  
  use strict;
  use warnings;
  
  use parent 'URI';
  
  our $VERSION = '1.74';
  
  use MIME::Base64 qw(encode_base64 decode_base64);
  use URI::Escape  qw(uri_unescape);
  
  sub media_type
  {
      my $self = shift;
      my $opaque = $self->opaque;
      $opaque =~ /^([^,]*),?/ or die;
      my $old = $1;
      my $base64;
      $base64 = $1 if $old =~ s/(;base64)$//i;
      if (@_) {
  	my $new = shift;
  	$new = "" unless defined $new;
  	$new =~ s/%/%25/g;
  	$new =~ s/,/%2C/g;
  	$base64 = "" unless defined $base64;
  	$opaque =~ s/^[^,]*,?/$new$base64,/;
  	$self->opaque($opaque);
      }
      return uri_unescape($old) if $old;  # media_type can't really be "0"
      "text/plain;charset=US-ASCII";      # default type
  }
  
  sub data
  {
      my $self = shift;
      my($enc, $data) = split(",", $self->opaque, 2);
      unless (defined $data) {
  	$data = "";
  	$enc  = "" unless defined $enc;
      }
      my $base64 = ($enc =~ /;base64$/i);
      if (@_) {
  	$enc =~ s/;base64$//i if $base64;
  	my $new = shift;
  	$new = "" unless defined $new;
  	my $uric_count = _uric_count($new);
  	my $urienc_len = $uric_count + (length($new) - $uric_count) * 3;
  	my $base64_len = int((length($new)+2) / 3) * 4;
  	$base64_len += 7;  # because of ";base64" marker
  	if ($base64_len < $urienc_len || $_[0]) {
  	    $enc .= ";base64";
  	    $new = encode_base64($new, "");
  	} else {
  	    $new =~ s/%/%25/g;
  	}
  	$self->opaque("$enc,$new");
      }
      return unless defined wantarray;
      $data = uri_unescape($data);
      return $base64 ? decode_base64($data) : $data;
  }
  
  # I could not find a better way to interpolate the tr/// chars from
  # a variable.
  my $ENC = $URI::uric;
  $ENC =~ s/%//;
  
  eval <<EOT; die $@ if $@;
  sub _uric_count
  {
      \$_[0] =~ tr/$ENC//;
  }
  EOT
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::data - URI that contains immediate data
  
  =head1 SYNOPSIS
  
   use URI;
  
   $u = URI->new("data:");
   $u->media_type("image/gif");
   $u->data(scalar(`cat camel.gif`));
   print "$u\n";
   open(XV, "|xv -") and print XV $u->data;
  
  =head1 DESCRIPTION
  
  The C<URI::data> class supports C<URI> objects belonging to the I<data>
  URI scheme.  The I<data> URI scheme is specified in RFC 2397.  It
  allows inclusion of small data items as "immediate" data, as if it had
  been included externally.  Examples:
  
    data:,Perl%20is%20good
  
    data:image/gif;base64,R0lGODdhIAAgAIAAAAAAAPj8+CwAAAAAI
      AAgAAAClYyPqcu9AJyCjtIKc5w5xP14xgeO2tlY3nWcajmZZdeJcG
      Kxrmimms1KMTa1Wg8UROx4MNUq1HrycMjHT9b6xKxaFLM6VRKzI+p
      KS9XtXpcbdun6uWVxJXA8pNPkdkkxhxc21LZHFOgD2KMoQXa2KMWI
      JtnE2KizVUkYJVZZ1nczBxXlFopZBtoJ2diXGdNUymmJdFMAADs=
  
  
  
  C<URI> objects belonging to the data scheme support the common methods
  (described in L<URI>) and the following two scheme-specific methods:
  
  =over 4
  
  =item $uri->media_type( [$new_media_type] )
  
  Can be used to get or set the media type specified in the
  URI.  If no media type is specified, then the default
  C<"text/plain;charset=US-ASCII"> is returned.
  
  =item $uri->data( [$new_data] )
  
  Can be used to get or set the data contained in the URI.
  The data is passed unescaped (in binary form).  The decision about
  whether to base64 encode the data in the URI is taken automatically,
  based on the encoding that produces the shorter URI string.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_DATA

$fatpacked{"URI/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE';
  package URI::file;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  our $VERSION = "4.21";
  
  use URI::Escape qw(uri_unescape);
  
  our $DEFAULT_AUTHORITY = "";
  
  # Map from $^O values to implementation classes.  The Unix
  # class is the default.
  our %OS_CLASS = (
       os2     => "OS2",
       mac     => "Mac",
       MacOS   => "Mac",
       MSWin32 => "Win32",
       win32   => "Win32",
       msdos   => "FAT",
       dos     => "FAT",
       qnx     => "QNX",
  );
  
  sub os_class
  {
      my($OS) = shift || $^O;
  
      my $class = "URI::file::" . ($OS_CLASS{$OS} || "Unix");
      no strict 'refs';
      unless (%{"$class\::"}) {
  	eval "require $class";
  	die $@ if $@;
      }
      $class;
  }
  
  sub host { uri_unescape(shift->authority(@_)) }
  
  sub new
  {
      my($class, $path, $os) = @_;
      os_class($os)->new($path);
  }
  
  sub new_abs
  {
      my $class = shift;
      my $file = $class->new(@_);
      return $file->abs($class->cwd) unless $$file =~ /^file:/;
      $file;
  }
  
  sub cwd
  {
      my $class = shift;
      require Cwd;
      my $cwd = Cwd::cwd();
      $cwd = VMS::Filespec::unixpath($cwd) if $^O eq 'VMS';
      $cwd = $class->new($cwd);
      $cwd .= "/" unless substr($cwd, -1, 1) eq "/";
      $cwd;
  }
  
  sub canonical {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $scheme = $other->scheme;
      my $auth = $other->authority;
      return $other if !defined($scheme) && !defined($auth);  # relative
  
      if (!defined($auth) ||
  	$auth eq "" ||
  	lc($auth) eq "localhost" ||
  	(defined($DEFAULT_AUTHORITY) && lc($auth) eq lc($DEFAULT_AUTHORITY))
         )
      {
  	# avoid cloning if $auth already match
  	if ((defined($auth) || defined($DEFAULT_AUTHORITY)) &&
  	    (!defined($auth) || !defined($DEFAULT_AUTHORITY) || $auth ne $DEFAULT_AUTHORITY)
  	   )
  	{
  	    $other = $other->clone if $self == $other;
  	    $other->authority($DEFAULT_AUTHORITY);
          }
      }
  
      $other;
  }
  
  sub file
  {
      my($self, $os) = @_;
      os_class($os)->file($self);
  }
  
  sub dir
  {
      my($self, $os) = @_;
      os_class($os)->dir($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::file - URI that maps to local file names
  
  =head1 SYNOPSIS
  
   use URI::file;
   
   $u1 = URI->new("file:/foo/bar");
   $u2 = URI->new("foo/bar", "file");
   
   $u3 = URI::file->new($path);
   $u4 = URI::file->new("c:\\windows\\", "win32");
   
   $u1->file;
   $u1->file("mac");
  
  =head1 DESCRIPTION
  
  The C<URI::file> class supports C<URI> objects belonging to the I<file>
  URI scheme.  This scheme allows us to map the conventional file names
  found on various computer systems to the URI name space.  An old
  specification of the I<file> URI scheme is found in RFC 1738.  Some
  older background information is also in RFC 1630. There are no newer
  specifications as far as I know.
  
  If you simply want to construct I<file> URI objects from URI strings,
  use the normal C<URI> constructor.  If you want to construct I<file>
  URI objects from the actual file names used by various systems, then
  use one of the following C<URI::file> constructors:
  
  =over 4
  
  =item $u = URI::file->new( $filename, [$os] )
  
  Maps a file name to the I<file:> URI name space, creates a URI object
  and returns it.  The $filename is interpreted as belonging to the
  indicated operating system ($os), which defaults to the value of the
  $^O variable.  The $filename can be either absolute or relative, and
  the corresponding type of URI object for $os is returned.
  
  =item $u = URI::file->new_abs( $filename, [$os] )
  
  Same as URI::file->new, but makes sure that the URI returned
  represents an absolute file name.  If the $filename argument is
  relative, then the name is resolved relative to the current directory,
  i.e. this constructor is really the same as:
  
    URI::file->new($filename)->abs(URI::file->cwd);
  
  =item $u = URI::file->cwd
  
  Returns a I<file> URI that represents the current working directory.
  See L<Cwd>.
  
  =back
  
  The following methods are supported for I<file> URI (in addition to
  the common and generic methods described in L<URI>):
  
  =over 4
  
  =item $u->file( [$os] )
  
  Returns a file name.  It maps from the URI name space
  to the file name space of the indicated operating system.
  
  It might return C<undef> if the name can not be represented in the
  indicated file system.
  
  =item $u->dir( [$os] )
  
  Some systems use a different form for names of directories than for plain
  files.  Use this method if you know you want to use the name for
  a directory.
  
  =back
  
  The C<URI::file> module can be used to map generic file names to names
  suitable for the current system.  As such, it can work as a nice
  replacement for the C<File::Spec> module.  For instance, the following
  code translates the UNIX-style file name F<Foo/Bar.pm> to a name
  suitable for the local system:
  
    $file = URI::file->new("Foo/Bar.pm", "unix")->file;
    die "Can't map filename Foo/Bar.pm for $^O" unless defined $file;
    open(FILE, $file) || die "Can't open '$file': $!";
    # do something with FILE
  
  =head1 MAPPING NOTES
  
  Most computer systems today have hierarchically organized file systems.
  Mapping the names used in these systems to the generic URI syntax
  allows us to work with relative file URIs that behave as they should
  when resolved using the generic algorithm for URIs (specified in RFC
  2396).  Mapping a file name to the generic URI syntax involves mapping
  the path separator character to "/" and encoding any reserved
  characters that appear in the path segments of the file name.  If
  path segments consisting of the strings "." or ".." have a
  different meaning than what is specified for generic URIs, then these
  must be encoded as well.
  
  If the file system has device, volume or drive specifications as
  the root of the name space, then it makes sense to map them to the
  authority field of the generic URI syntax.  This makes sure that
  relative URIs can not be resolved "above" them, i.e. generally how
  relative file names work in those systems.
  
  Another common use of the authority field is to encode the host on which
  this file name is valid.  The host name "localhost" is special and
  generally has the same meaning as a missing or empty authority
  field.  This use is in conflict with using it as a device
  specification, but can often be resolved for device specifications
  having characters not legal in plain host names.
  
  File name to URI mapping in normally not one-to-one.  There are
  usually many URIs that map to any given file name.  For instance, an
  authority of "localhost" maps the same as a URI with a missing or empty
  authority.
  
  Example 1: The Mac classic (Mac OS 9 and earlier) used ":" as path separator,
  but not in the same way as a generic URI. ":foo" was a relative name.  "foo:bar"
  was an absolute name.  Also, path segments could contain the "/" character as well
  as the literal "." or "..".  So the mapping looks like this:
  
    Mac classic           URI
    ----------            -------------------
    :foo:bar     <==>     foo/bar
    :            <==>     ./
    ::foo:bar    <==>     ../foo/bar
    :::          <==>     ../../
    foo:bar      <==>     file:/foo/bar
    foo:bar:     <==>     file:/foo/bar/
    ..           <==>     %2E%2E
    <undef>      <==      /
    foo/         <==      file:/foo%2F
    ./foo.txt    <==      file:/.%2Ffoo.txt
  
  Note that if you want a relative URL, you *must* begin the path with a :.  Any
  path that begins with [^:] is treated as absolute.
  
  Example 2: The UNIX file system is easy to map, as it uses the same path
  separator as URIs, has a single root, and segments of "." and ".."
  have the same meaning.  URIs that have the character "\0" or "/" as
  part of any path segment can not be turned into valid UNIX file names.
  
    UNIX                  URI
    ----------            ------------------
    foo/bar      <==>     foo/bar
    /foo/bar     <==>     file:/foo/bar
    /foo/bar     <==      file://localhost/foo/bar
    file:         ==>     ./file:
    <undef>      <==      file:/fo%00/bar
    /            <==>     file:/
  
  =cut
  
  
  RFC 1630
  
     [...]
  
     There is clearly a danger of confusion that a link made to a local
     file should be followed by someone on a different system, with
     unexpected and possibly harmful results.  Therefore, the convention
     is that even a "file" URL is provided with a host part.  This allows
     a client on another system to know that it cannot access the file
     system, or perhaps to use some other local mechanism to access the
     file.
  
     The special value "localhost" is used in the host field to indicate
     that the filename should really be used on whatever host one is.
     This for example allows links to be made to files which are
     distributed on many machines, or to "your unix local password file"
     subject of course to consistency across the users of the data.
  
     A void host field is equivalent to "localhost".
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over
  
  =item %URI::file::OS_CLASS
  
  This hash maps OS identifiers to implementation classes.  You might
  want to add or modify this if you want to plug in your own file
  handler class.  Normally the keys should match the $^O values in use.
  
  If there is no mapping then the "Unix" implementation is used.
  
  =item $URI::file::DEFAULT_AUTHORITY
  
  This determine what "authority" string to include in absolute file
  URIs.  It defaults to "".  If you prefer verbose URIs you might set it
  to be "localhost".
  
  Setting this value to C<undef> force behaviour compatible to URI v1.31
  and earlier.  In this mode host names in UNC paths and drive letters
  are mapped to the authority component on Windows, while we produce
  authority-less URIs on Unix.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>, L<File::Spec>, L<perlport>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998,2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_FILE

$fatpacked{"URI/file/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_BASE';
  package URI::file::Base;
  
  use strict;
  use warnings;
  
  use URI::Escape qw();
  
  our $VERSION = '1.74';
  
  sub new
  {
      my $class = shift;
      my $path  = shift;
      $path = "" unless defined $path;
  
      my($auth, $escaped_auth, $escaped_path);
  
      ($auth, $escaped_auth) = $class->_file_extract_authority($path);
      ($path, $escaped_path) = $class->_file_extract_path($path);
  
      if (defined $auth) {
  	$auth =~ s,%,%25,g unless $escaped_auth;
  	$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;
  	$auth = "//$auth";
  	if (defined $path) {
  	    $path = "/$path" unless substr($path, 0, 1) eq "/";
  	} else {
  	    $path = "";
  	}
      } else {
  	return undef unless defined $path;
  	$auth = "";
      }
  
      $path =~ s,([%;?]), URI::Escape::escape_char($1),eg unless $escaped_path;
      $path =~ s/\#/%23/g;
  
      my $uri = $auth . $path;
      $uri = "file:$uri" if substr($uri, 0, 1) eq "/";
  
      URI->new($uri, "file");
  }
  
  sub _file_extract_authority
  {
      my($class, $path) = @_;
      return undef unless $class->_file_is_absolute($path);
      return $URI::file::DEFAULT_AUTHORITY;
  }
  
  sub _file_extract_path
  {
      return undef;
  }
  
  sub _file_is_absolute
  {
      return 0;
  }
  
  sub _file_is_localhost
  {
      shift; # class
      my $host = lc(shift);
      return 1 if $host eq "localhost";
      eval {
  	require Net::Domain;
  	lc(Net::Domain::hostfqdn() || '') eq $host ||
  	lc(Net::Domain::hostname() || '') eq $host;
      };
  }
  
  sub file
  {
      undef;
  }
  
  sub dir
  {
      my $self = shift;
      $self->file(@_);
  }
  
  1;
URI_FILE_BASE

$fatpacked{"URI/file/FAT.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_FAT';
  package URI::file::FAT;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Win32';
  
  our $VERSION = '1.74';
  
  sub fix_path
  {
      shift; # class
      for (@_) {
  	# turn it into 8.3 names
  	my @p = map uc, split(/\./, $_, -1);
  	return if @p > 2;     # more than 1 dot is not allowed
  	@p = ("") unless @p;  # split bug? (returns nothing when splitting "")
  	$_ = substr($p[0], 0, 8);
          if (@p > 1) {
  	    my $ext = substr($p[1], 0, 3);
  	    $_ .= ".$ext" if length $ext;
  	}
      }
      1;  # ok
  }
  
  1;
URI_FILE_FAT

$fatpacked{"URI/file/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_MAC';
  package URI::file::Mac;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub _file_extract_path
  {
      my $class = shift;
      my $path = shift;
  
      my @pre;
      if ($path =~ s/^(:+)//) {
  	if (length($1) == 1) {
  	    @pre = (".") unless length($path);
  	} else {
  	    @pre = ("..") x (length($1) - 1);
  	}
      } else { #absolute
  	$pre[0] = "";
      }
  
      my $isdir = ($path =~ s/:$//);
      $path =~ s,([%/;]), URI::Escape::escape_char($1),eg;
  
      my @path = split(/:/, $path, -1);
      for (@path) {
  	if ($_ eq "." || $_ eq "..") {
  	    $_ = "%2E" x length($_);
  	}
  	$_ = ".." unless length($_);
      }
      push (@path,"") if $isdir;
      (join("/", @pre, @path), 1);
  }
  
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined $auth) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    my $u_auth = uri_unescape($auth);
  	    if (!$class->_file_is_localhost($u_auth)) {
  		# some other host (use it as volume name)
  		@path = ("", $auth);
  		# XXX or just return to make it illegal;
  	    }
  	}
      }
      my @ps = split("/", $uri->path, -1);
      shift @ps if @path;
      push(@path, @ps);
  
      my $pre = "";
      if (!@path) {
  	return;  # empty path; XXX return ":" instead?
      } elsif ($path[0] eq "") {
  	# absolute
  	shift(@path);
  	if (@path == 1) {
  	    return if $path[0] eq "";  # not root directory
  	    push(@path, "");           # volume only, effectively append ":"
  	}
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      } else {
  	$pre = ":";
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      }
      return unless $pre || @path;
      for (@path) {
  	s/;.*//;  # get rid of parameters
  	#return unless length; # XXX
  	$_ = uri_unescape($_);
  	return if /\0/;
  	return if /:/;  # Should we?
      }
      $pre . join(":", @path);
  }
  
  sub dir
  {
      my $class = shift;
      my $path = $class->file(@_);
      return unless defined $path;
      $path .= ":" unless $path =~ /:$/;
      $path;
  }
  
  1;
URI_FILE_MAC

$fatpacked{"URI/file/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_OS2';
  package URI::file::OS2;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Win32';
  
  our $VERSION = '1.74';
  
  # The Win32 version translates k:/foo to file://k:/foo  (?!)
  # We add an empty host
  
  sub _file_extract_authority
  {
      my $class = shift;
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ m#^[a-zA-Z]{1,2}:#) {	      # allow for ab: drives
  	return "";
      }
      return;
  }
  
  sub file {
    my $p = &URI::file::Win32::file;
    return unless defined $p;
    $p =~ s,\\,/,g;
    $p;
  }
  
  1;
URI_FILE_OS2

$fatpacked{"URI/file/QNX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_QNX';
  package URI::file::QNX;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Unix';
  
  our $VERSION = '1.74';
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      # tidy path
      $path =~ s,(.)//+,$1/,g; # ^// is correct
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
      $path;
  }
  
  1;
URI_FILE_QNX

$fatpacked{"URI/file/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_UNIX';
  package URI::file::Unix;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
  
      # tidy path
      $path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^/,;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined($auth)) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    $auth = uri_unescape($auth);
  	    unless ($class->_file_is_localhost($auth)) {
  		push(@path, "", "", $auth);
  	    }
  	}
      }
  
      my @ps = $uri->path_segments;
      shift @ps if @path;
      push(@path, @ps);
  
      for (@path) {
  	# Unix file/directory names are not allowed to contain '\0' or '/'
  	return undef if /\0/;
  	return undef if /\//;  # should we really?
      }
  
      return join("/", @path);
  }
  
  1;
URI_FILE_UNIX

$fatpacked{"URI/file/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_WIN32';
  package URI::file::Win32;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub _file_extract_authority
  {
      my $class = shift;
  
      return $class->SUPER::_file_extract_authority($_[0])
  	if defined $URI::file::DEFAULT_AUTHORITY;
  
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ s,^([a-zA-Z]:),,) {
  	my $auth = $1;
  	$auth .= "relative" if $_[0] !~ m,^[\\/],;
  	return $auth;
      }
      return undef;
  }
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      $path =~ s,\\,/,g;
      #$path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
  
      if (defined $URI::file::DEFAULT_AUTHORITY) {
  	$path =~ s,^([a-zA-Z]:),/$1,;
      }
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^[a-zA-Z]:, || $path =~ m,^[/\\],;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my $auth = $uri->authority;
      my $rel; # is filename relative to drive specified in authority
      if (defined $auth) {
          $auth = uri_unescape($auth);
  	if ($auth =~ /^([a-zA-Z])[:|](relative)?/) {
  	    $auth = uc($1) . ":";
  	    $rel++ if $2;
  	} elsif (lc($auth) eq "localhost") {
  	    $auth = "";
  	} elsif (length $auth) {
  	    $auth = "\\\\" . $auth;  # UNC
  	}
      } else {
  	$auth = "";
      }
  
      my @path = $uri->path_segments;
      for (@path) {
  	return undef if /\0/;
  	return undef if /\//;
  	#return undef if /\\/;        # URLs with "\" is not uncommon
      }
      return undef unless $class->fix_path(@path);
  
      my $path = join("\\", @path);
      $path =~ s/^\\// if $rel;
      $path = $auth . $path;
      $path =~ s,^\\([a-zA-Z])[:|],\u$1:,;
  
      return $path;
  }
  
  sub fix_path { 1; }
  
  1;
URI_FILE_WIN32

$fatpacked{"URI/ftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FTP';
  package URI::ftp;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent qw(URI::_server URI::_userpass);
  
  sub default_port { 21 }
  
  sub path { shift->path_query(@_) }  # XXX
  
  sub _user     { shift->SUPER::user(@_);     }
  sub _password { shift->SUPER::password(@_); }
  
  sub user
  {
      my $self = shift;
      my $user = $self->_user(@_);
      $user = "anonymous" unless defined $user;
      $user;
  }
  
  sub password
  {
      my $self = shift;
      my $pass = $self->_password(@_);
      unless (defined $pass) {
  	my $user = $self->user;
  	if ($user eq 'anonymous' || $user eq 'ftp') {
  	    # anonymous ftp login password
              # If there is no ftp anonymous password specified
              # then we'll just use 'anonymous@'
              # We don't try to send the read e-mail address because:
              # - We want to remain anonymous
              # - We want to stop SPAM
              # - We don't want to let ftp sites to discriminate by the user,
              #   host, country or ftp client being used.
  	    $pass = 'anonymous@';
  	}
      }
      $pass;
  }
  
  1;
URI_FTP

$fatpacked{"URI/gopher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_GOPHER';
  package URI::gopher;  # <draft-murali-url-gopher>, Dec 4, 1996
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  
  #  A Gopher URL follows the common internet scheme syntax as defined in 
  #  section 4.3 of [RFC-URL-SYNTAX]:
  #
  #        gopher://<host>[:<port>]/<gopher-path>
  #
  #  where
  #
  #        <gopher-path> :=  <gopher-type><selector> | 
  #                          <gopher-type><selector>%09<search> |
  #                          <gopher-type><selector>%09<search>%09<gopher+_string>
  #
  #        <gopher-type> := '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'
  #                         '8' | '9' | '+' | 'I' | 'g' | 'T'
  #
  #        <selector>    := *pchar     Refer to RFC 1808 [4]
  #        <search>      := *pchar
  #        <gopher+_string> := *uchar  Refer to RFC 1738 [3]
  #        
  #  If the optional port is omitted, the port defaults to 70. 
  
  sub default_port { 70 }
  
  sub _gopher_type
  {
      my $self = shift;
      my $path = $self->path_query;
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s/^(.)//s;
      if (@_) {
  	my $new_type = shift;
  	if (defined($new_type)) {
  	    Carp::croak("Bad gopher type '$new_type'")
                 unless length($new_type) == 1;
  	    substr($path, 0, 0) = $new_type;
  	    $self->path_query($path);
  	} else {
  	    Carp::croak("Can't delete gopher type when selector is present")
  		if length($path);
  	    $self->path_query(undef);
  	}
      }
      return $gtype;
  }
  
  sub gopher_type
  {
      my $self = shift;
      my $gtype = $self->_gopher_type(@_);
      $gtype = "1" unless defined $gtype;
      $gtype;
  }
  
  sub gtype { goto &gopher_type }  # URI::URL compatibility
  
  sub selector { shift->_gfield(0, @_) }
  sub search   { shift->_gfield(1, @_) }
  sub string   { shift->_gfield(2, @_) }
  
  sub _gfield
  {
      my $self = shift;
      my $fno  = shift;
      my $path = $self->path_query;
  
      # not according to spec., but many popular browsers accept
      # gopher URLs with a '?' before the search string.
      $path =~ s/\?/\t/;
      $path = uri_unescape($path);
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s,^(.),,s;
      my @path = split(/\t/, $path, 3);
      if (@_) {
  	# modify
  	my $new = shift;
  	$path[$fno] = $new;
  	pop(@path) while @path && !defined($path[-1]);
  	for (@path) { $_="" unless defined }
  	$path = $gtype;
  	$path = "1" unless defined $path;
  	$path .= join("\t", @path);
  	$self->path_query($path);
      }
      $path[$fno];
  }
  
  1;
URI_GOPHER

$fatpacked{"URI/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTP';
  package URI::http;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_server';
  
  sub default_port { 80 }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $slash_path = defined($other->authority) &&
          !length($other->path) && !defined($other->query);
  
      if ($slash_path) {
  	$other = $other->clone if $other == $self;
  	$other->path("/");
      }
      $other;
  }
  
  1;
URI_HTTP

$fatpacked{"URI/https.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTPS';
  package URI::https;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::http';
  
  sub default_port { 443 }
  
  sub secure { 1 }
  
  1;
URI_HTTPS

$fatpacked{"URI/ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::ldap;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent qw(URI::_ldap URI::_server);
  
  sub default_port { 389 }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_server::canonical(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::ldap - LDAP Uniform Resource Locators
  
  =head1 SYNOPSIS
  
    use URI;
  
    $uri = URI->new("ldap:$uri_string");
    $dn     = $uri->dn;
    $filter = $uri->filter;
    @attr   = $uri->attributes;
    $scope  = $uri->scope;
    %extn   = $uri->extensions;
    
    $uri = URI->new("ldap:");  # start empty
    $uri->host("ldap.itd.umich.edu");
    $uri->dn("o=University of Michigan,c=US");
    $uri->attributes(qw(postalAddress));
    $uri->scope('sub');
    $uri->filter('(cn=Babs Jensen)');
    print $uri->as_string,"\n";
  
  =head1 DESCRIPTION
  
  C<URI::ldap> provides an interface to parse an LDAP URI into its
  constituent parts and also to build a URI as described in
  RFC 2255.
  
  =head1 METHODS
  
  C<URI::ldap> supports all the generic and server methods defined by
  L<URI>, plus the following.
  
  Each of the following methods can be used to set or get the value in
  the URI. The values are passed in unescaped form.  None of these
  return undefined values, but elements without a default can be empty.
  If arguments are given, then a new value is set for the given part
  of the URI.
  
  =over 4
  
  =item $uri->dn( [$new_dn] )
  
  Sets or gets the I<Distinguished Name> part of the URI.  The DN
  identifies the base object of the LDAP search.
  
  =item $uri->attributes( [@new_attrs] )
  
  Sets or gets the list of attribute names which are
  returned by the search.
  
  =item $uri->scope( [$new_scope] )
  
  Sets or gets the scope to be used by the search. The value can be one of
  C<"base">, C<"one"> or C<"sub">. If none is given in the URI then the
  return value defaults to C<"base">.
  
  =item $uri->_scope( [$new_scope] )
  
  Same as scope(), but does not default to anything.
  
  =item $uri->filter( [$new_filter] )
  
  Sets or gets the filter to be used by the search. If none is given in
  the URI then the return value defaults to C<"(objectClass=*)">.
  
  =item $uri->_filter( [$new_filter] )
  
  Same as filter(), but does not default to anything.
  
  =item $uri->extensions( [$etype => $evalue,...] )
  
  Sets or gets the extensions used for the search. The list passed should
  be in the form etype1 => evalue1, etype2 => evalue2,... This is also
  the form of list that is returned.
  
  =back
  
  =head1 SEE ALSO
  
  L<http://tools.ietf.org/html/rfc2255>
  
  =head1 AUTHOR
  
  Graham Barr E<lt>F<gbarr@pobox.com>E<gt>
  
  Slightly modified by Gisle Aas to fit into the URI distribution.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1998 Graham Barr. All rights reserved. This program is
  free software; you can redistribute it and/or modify it under the same
  terms as Perl itself.
  
  =cut
URI_LDAP

$fatpacked{"URI/ldapi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPI';
  package URI::ldapi;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent qw(URI::_ldap URI::_generic);
  
  require URI::Escape;
  
  sub un_path {
      my $self = shift;
      my $old = URI::Escape::uri_unescape($self->authority);
      if (@_) {
  	my $p = shift;
  	$p =~ s/:/%3A/g;
  	$p =~ s/\@/%40/g;
  	$self->authority($p);
      }
      return $old;
  }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_generic::canonical(@_);
  }
  
  1;
URI_LDAPI

$fatpacked{"URI/ldaps.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPS';
  package URI::ldaps;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::ldap';
  
  sub default_port { 636 }
  
  sub secure { 1 }
  
  1;
URI_LDAPS

$fatpacked{"URI/mailto.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MAILTO';
  package URI::mailto;  # RFC 2368
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent qw(URI URI::_query);
  
  sub to
  {
      my $self = shift;
      my @old = $self->headers;
      if (@_) {
  	my @new = @old;
  	# get rid of any other to: fields
  	for (my $i = 0; $i < @new; $i += 2) {
  	    if (lc($new[$i] || '') eq "to") {
  		splice(@new, $i, 2);
  		redo;
  	    }
  	}
  
  	my $to = shift;
  	$to = "" unless defined $to;
  	unshift(@new, "to" => $to);
  	$self->headers(@new);
      }
      return unless defined wantarray;
  
      my @to;
      while (@old) {
  	my $h = shift @old;
  	my $v = shift @old;
  	push(@to, $v) if lc($h) eq "to";
      }
      join(",", @to);
  }
  
  
  sub headers
  {
      my $self = shift;
  
      # The trick is to just treat everything as the query string...
      my $opaque = "to=" . $self->opaque;
      $opaque =~ s/\?/&/;
  
      if (@_) {
  	my @new = @_;
  
  	# strip out any "to" fields
  	my @to;
  	for (my $i=0; $i < @new; $i += 2) {
  	    if (lc($new[$i] || '') eq "to") {
  		push(@to, (splice(@new, $i, 2))[1]);  # remove header
  		redo;
  	    }
  	}
  
  	my $new = join(",",@to);
  	$new =~ s/%/%25/g;
  	$new =~ s/\?/%3F/g;
  	$self->opaque($new);
  	$self->query_form(@new) if @new;
      }
      return unless defined wantarray;
  
      # I am lazy today...
      URI->new("mailto:?$opaque")->query_form;
  }
  
  1;
URI_MAILTO

$fatpacked{"URI/mms.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MMS';
  package URI::mms;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::http';
  
  sub default_port { 1755 }
  
  1;
URI_MMS

$fatpacked{"URI/news.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NEWS';
  package URI::news;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  sub default_port { 119 }
  
  #   newsURL      =  scheme ":" [ news-server ] [ refbygroup | message ]
  #   scheme       =  "news" | "snews" | "nntp"
  #   news-server  =  "//" server "/"
  #   refbygroup   = group [ "/" messageno [ "-" messageno ] ]
  #   message      = local-part "@" domain
  
  sub _group
  {
      my $self = shift;
      my $old = $self->path;
      if (@_) {
  	my($group,$from,$to) = @_;
  	if ($group =~ /\@/) {
              $group =~ s/^<(.*)>$/$1/;  # "<" and ">" should not be part of it
  	}
  	$group =~ s,%,%25,g;
  	$group =~ s,/,%2F,g;
  	my $path = $group;
  	if (defined $from) {
  	    $path .= "/$from";
  	    $path .= "-$to" if defined $to;
  	}
  	$self->path($path);
      }
  
      $old =~ s,^/,,;
      if ($old !~ /\@/ && $old =~ s,/(.*),, && wantarray) {
  	my $extra = $1;
  	return (uri_unescape($old), split(/-/, $extra));
      }
      uri_unescape($old);
  }
  
  
  sub group
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Group name can't contain '\@'") if $_[0] =~ /\@/;
      }
      my @old = $self->_group(@_);
      return if $old[0] =~ /\@/;
      wantarray ? @old : $old[0];
  }
  
  sub message
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Message must contain '\@'") unless $_[0] =~ /\@/;
      }
      my $old = $self->_group(@_);
      return undef unless $old =~ /\@/;
      return $old;
  }
  
  1;
URI_NEWS

$fatpacked{"URI/nntp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NNTP';
  package URI::nntp;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::news';
  
  1;
URI_NNTP

$fatpacked{"URI/pop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_POP';
  package URI::pop;   # RFC 2384
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  
  sub default_port { 110 }
  
  #pop://<user>;auth=<auth>@<host>:<port>
  
  sub user
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new_info = $old;
  	$new_info = "" unless defined $new_info;
  	$new_info =~ s/^[^;]*//;
  
  	my $new = shift;
  	if (!defined($new) && !length($new_info)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined $new;
  	    $new =~ s/%/%25/g;
  	    $new =~ s/;/%3B/g;
  	    $self->userinfo("$new$new_info");
  	}
      }
  
      return undef unless defined $old;
      $old =~ s/;.*//;
      return uri_unescape($old);
  }
  
  sub auth
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/(^[^;]*)//;
  	my $user = $1;
  	$new =~ s/;auth=[^;]*//i;
  
  	
  	my $auth = shift;
  	if (defined $auth) {
  	    $auth =~ s/%/%25/g;
  	    $auth =~ s/;/%3B/g;
  	    $new = ";AUTH=$auth$new";
  	}
  	$self->userinfo("$user$new");
  	
      }
  
      return undef unless defined $old;
      $old =~ s/^[^;]*//;
      return uri_unescape($1) if $old =~ /;auth=(.*)/i;
      return;
  }
  
  1;
URI_POP

$fatpacked{"URI/rlogin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RLOGIN';
  package URI::rlogin;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_login';
  
  sub default_port { 513 }
  
  1;
URI_RLOGIN

$fatpacked{"URI/rsync.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RSYNC';
  package URI::rsync;  # http://rsync.samba.org/
  
  # rsync://[USER@]HOST[:PORT]/SRC
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent qw(URI::_server URI::_userpass);
  
  sub default_port { 873 }
  
  1;
URI_RSYNC

$fatpacked{"URI/rtsp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSP';
  package URI::rtsp;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::http';
  
  sub default_port { 554 }
  
  1;
URI_RTSP

$fatpacked{"URI/rtspu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSPU';
  package URI::rtspu;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::rtsp';
  
  sub default_port { 554 }
  
  1;
URI_RTSPU

$fatpacked{"URI/sftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SFTP';
  package URI::sftp;
  
  use strict;
  use warnings;
  
  use parent 'URI::ssh';
  
  our $VERSION = '1.74';
  
  1;
URI_SFTP

$fatpacked{"URI/sip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIP';
  #
  # Written by Ryan Kereliuk <ryker@ryker.org>.  This file may be
  # distributed under the same terms as Perl itself.
  #
  # The RFC 3261 sip URI is <scheme>:<authority>;<params>?<query>.
  #
  
  package URI::sip;
  
  use strict;
  use warnings;
  
  use parent qw(URI::_server URI::_userpass);
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub default_port { 5060 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^($URI::scheme_re:)?([^;?]*)(.*)$,os or die;
      my $old = $2;
  
      if (@_) {
          my $auth = shift;
          $$self = defined($1) ? $1 : "";
          my $rest = $3;
          if (defined $auth) {
              $auth =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
              $$self .= "$auth";
          }
          $$self .= $rest;
      }
      $old;
  }
  
  sub params_form
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my @args = @_; 
          $$self = $1 . $2;
          my $rest = $4;
  	my @new;
  	for (my $i=0; $i < @args; $i += 2) {
  	    push(@new, "$args[$i]=$args[$i+1]");
  	}
  	$paramstr = join(";", @new);
  	$$self .= ";" . $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return split(/[;=]/, $paramstr);
  }
  
  sub params
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my $new = shift; 
          $$self = $1 . $2;
          my $rest = $4;
  	$$self .= $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return $paramstr;
  }
  
  # Inherited methods that make no sense for a SIP URI.
  sub path {}
  sub path_query {}
  sub path_segments {}
  sub abs { shift }
  sub rel { shift }
  sub query_keywords {}
  
  1;
URI_SIP

$fatpacked{"URI/sips.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIPS';
  package URI::sips;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::sip';
  
  sub default_port { 5061 }
  
  sub secure { 1 }
  
  1;
URI_SIPS

$fatpacked{"URI/snews.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SNEWS';
  package URI::snews;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::news';
  
  sub default_port { 563 }
  
  sub secure { 1 }
  
  1;
URI_SNEWS

$fatpacked{"URI/ssh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SSH';
  package URI::ssh;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_login';
  
  # ssh://[USER@]HOST[:PORT]/SRC
  
  sub default_port { 22 }
  
  sub secure { 1 }
  
  1;
URI_SSH

$fatpacked{"URI/telnet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TELNET';
  package URI::telnet;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_login';
  
  sub default_port { 23 }
  
  1;
URI_TELNET

$fatpacked{"URI/tn3270.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TN3270';
  package URI::tn3270;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_login';
  
  sub default_port { 23 }
  
  1;
URI_TN3270

$fatpacked{"URI/urn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN';
  package URI::urn;  # RFC 2141
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI';
  
  use Carp qw(carp);
  
  my %implementor;
  my %require_attempted;
  
  sub _init {
      my $class = shift;
      my $self = $class->SUPER::_init(@_);
      my $nid = $self->nid;
  
      my $impclass = $implementor{$nid};
      return $impclass->_urn_init($self, $nid) if $impclass;
  
      $impclass = "URI::urn";
      if ($nid =~ /^[A-Za-z\d][A-Za-z\d\-]*\z/) {
  	my $id = $nid;
  	# make it a legal perl identifier
  	$id =~ s/-/_/g;
  	$id = "_$id" if $id =~ /^\d/;
  
  	$impclass = "URI::urn::$id";
  	no strict 'refs';
  	unless (@{"${impclass}::ISA"}) {
              if (not exists $require_attempted{$impclass}) {
                  # Try to load it
                  my $_old_error = $@;
                  eval "require $impclass";
                  die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
                  $@ = $_old_error;
              }
  	    $impclass = "URI::urn" unless @{"${impclass}::ISA"};
  	}
      }
      else {
  	carp("Illegal namespace identifier '$nid' for URN '$self'") if $^W;
      }
      $implementor{$nid} = $impclass;
  
      return $impclass->_urn_init($self, $nid);
  }
  
  sub _urn_init {
      my($class, $self, $nid) = @_;
      bless $self, $class;
  }
  
  sub _nid {
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	$v =~ s/[^:]*/$new/;
  	$self->opaque($v);
  	# XXX possible rebless
      }
      $opaque =~ s/:.*//s;
      return $opaque;
  }
  
  sub nid {  # namespace identifier
      my $self = shift;
      my $nid = $self->_nid(@_);
      $nid = lc($nid) if defined($nid);
      return $nid;
  }
  
  sub nss {  # namespace specific string
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	if (defined $new) {
  	    $v =~ s/(:|\z).*/:$new/;
  	}
  	else {
  	    $v =~ s/:.*//s;
  	}
  	$self->opaque($v);
      }
      return undef unless $opaque =~ s/^[^:]*://;
      return $opaque;
  }
  
  sub canonical {
      my $self = shift;
      my $nid = $self->_nid;
      my $new = $self->SUPER::canonical;
      return $new if $nid !~ /[A-Z]/ || $nid =~ /%/;
      $new = $new->clone if $new == $self;
      $new->nid(lc($nid));
      return $new;
  }
  
  1;
URI_URN

$fatpacked{"URI/urn/isbn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_ISBN';
  package URI::urn::isbn;  # RFC 3187
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::urn';
  
  use Carp qw(carp);
  
  BEGIN {
      require Business::ISBN;
      
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      warn "Using Business::ISBN version " . Business::ISBN->VERSION . 
          " which is deprecated.\nUpgrade to Business::ISBN version 2\n"
          if Business::ISBN->VERSION < 2;
      }
      
  sub _isbn {
      my $nss = shift;
      $nss = $nss->nss if ref($nss);
      my $isbn = Business::ISBN->new($nss);
      $isbn = undef if $isbn && !$isbn->is_valid;
      return $isbn;
  }
  
  sub _nss_isbn {
      my $self = shift;
      my $nss = $self->nss(@_);
      my $isbn = _isbn($nss);
      $isbn = $isbn->as_string if $isbn;
      return($nss, $isbn);
  }
  
  sub isbn {
      my $self = shift;
      my $isbn;
      (undef, $isbn) = $self->_nss_isbn(@_);
      return $isbn;
  }
  
  sub isbn_publisher_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->publisher_code;
  }
  
  BEGIN {
  my $group_method = do {
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      Business::ISBN->VERSION >= 2 ? 'group_code' : 'country_code';
      };
  
  sub isbn_group_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->$group_method;
  }
  }
  
  sub isbn_country_code {
      my $name = (caller(0))[3]; $name =~ s/.*:://;
      carp "$name is DEPRECATED. Use isbn_group_code instead";
      
      no strict 'refs';
      &isbn_group_code;
  }
  
  BEGIN {
  my $isbn13_method = do {
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      Business::ISBN->VERSION >= 2 ? 'as_isbn13' : 'as_ean';
      };
  
  sub isbn13 {
      my $isbn = shift->_isbn || return undef;
      
      # Business::ISBN 1.x didn't put hyphens in the EAN, and it was just a string
      # Business::ISBN 2.0 doesn't do EAN, but it does ISBN-13 objects
      #   and it uses the hyphens, so call as_string with an empty anon array
      # or, adjust the test and features to say that it comes out with hyphens.
      my $thingy = $isbn->$isbn13_method;
      return eval { $thingy->can( 'as_string' ) } ? $thingy->as_string([]) : $thingy;
  }
  }
  
  sub isbn_as_ean {
      my $name = (caller(0))[3]; $name =~ s/.*:://;
      carp "$name is DEPRECATED. Use isbn13 instead";
  
      no strict 'refs';
      &isbn13;
  }
  
  sub canonical {
      my $self = shift;
      my($nss, $isbn) = $self->_nss_isbn;
      my $new = $self->SUPER::canonical;
      return $new unless $nss && $isbn && $nss ne $isbn;
      $new = $new->clone if $new == $self;
      $new->nss($isbn);
      return $new;
  }
  
  1;
URI_URN_ISBN

$fatpacked{"URI/urn/oid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_OID';
  package URI::urn::oid;  # RFC 2061
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::urn';
  
  sub oid {
      my $self = shift;
      my $old = $self->nss;
      if (@_) {
  	$self->nss(join(".", @_));
      }
      return split(/\./, $old) if wantarray;
      return $old;
  }
  
  1;
URI_URN_OID

$fatpacked{"darwin-2level/Net/SSLeay.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_NET_SSLEAY';
  # Net::SSLeay.pm - Perl module for using Eric Young's implementation of SSL
  #
  # Copyright (c) 1996-2003 Sampo Kellomaki <sampo@iki.fi>, All Rights Reserved.
  # Copyright (C) 2005 Florian Ragwitz <rafl@debian.org>, All Rights Reserved.
  # Copyright (C) 2005 Mike McCauley <mikem@airspayce.com>, All Rights Reserved.
  #
  # $Id: SSLeay.pm 516 2018-01-17 03:10:55Z mikem-guest $
  #
  # Change data removed from here. See Changes
  # The distribution and use of this module are subject to the conditions
  # listed in LICENSE file at the root of the Net-SSLeay
  # distribution (i.e. same license as Perl itself).
  
  package Net::SSLeay;
  
  use strict;
  use Carp;
  use vars qw($VERSION @ISA @EXPORT @EXPORT_OK $AUTOLOAD $CRLF);
  use Socket;
  use Errno;
  require 5.005_000;
  
  require Exporter;
  use AutoLoader;
  
  # 0=no warns, 1=only errors, 2=ciphers, 3=progress, 4=dump data
  $Net::SSLeay::trace = 0;  # Do not change here, use
                            # $Net::SSLeay::trace = [1-4]  in caller
  
  # 2 = insist on v2 SSL protocol
  # 3 = insist on v3 SSL
  # 10 = insist on TLSv1
  # 11 = insist on TLSv1.1
  # 12 = insist on TLSv1.2
  # 0 or undef = guess (v23)
  #
  $Net::SSLeay::ssl_version = 0;  # don't change here, use
                                  # Net::SSLeay::version=[2,3,0] in caller
  
  #define to enable the "cat /proc/$$/stat" stuff
  $Net::SSLeay::linux_debug = 0;
  
  # Number of seconds to sleep after sending message and before half
  # closing connection. Useful with antiquated broken servers.
  $Net::SSLeay::slowly = 0;
  
  # RANDOM NUMBER INITIALIZATION
  #
  # Edit to your taste. Using /dev/random would be more secure, but may
  # block if randomness is not available, thus the default is
  # /dev/urandom. $how_random determines how many bits of randomness to take
  # from the device. You should take enough (read SSLeay/doc/rand), but
  # beware that randomness is limited resource so you should not waste
  # it either or you may end up with randomness depletion (situation where
  # /dev/random would block and /dev/urandom starts to return predictable
  # numbers).
  #
  # N.B. /dev/urandom does not exist on all systems, such as Solaris 2.6. In that
  #      case you should get a third party package that emulates /dev/urandom
  #      (e.g. via named pipe) or supply a random number file. Some such
  #      packages are documented in Caveat section of the POD documentation.
  
  $Net::SSLeay::random_device = '/dev/urandom';
  $Net::SSLeay::how_random = 512;
  
  $VERSION = '1.85'; # Dont forget to set version in META.yml too
  @ISA = qw(Exporter);
  
  #BEWARE:
  # 3-columns part of @EXPORT_OK related to constants is the output of command:
  # perl helper_script/regen_openssl_constants.pl -gen-pod
  # if you add/remove any constant you need to update it manually
  
  @EXPORT_OK = qw(
  ASN1_STRFLGS_ESC_CTRL           NID_ms_sgc                                R_SSL_SESSION_ID_IS_DIFFERENT
   ASN1_STRFLGS_ESC_MSB            NID_name                                  R_UNABLE_TO_EXTRACT_PUBLIC_KEY
   ASN1_STRFLGS_ESC_QUOTE          NID_netscape                              R_UNKNOWN_REMOTE_ERROR_TYPE
   ASN1_STRFLGS_RFC2253            NID_netscape_base_url                     R_UNKNOWN_STATE
   CB_ACCEPT_EXIT                  NID_netscape_ca_policy_url                R_X509_LIB
   CB_ACCEPT_LOOP                  NID_netscape_ca_revocation_url            SENT_SHUTDOWN
   CB_ALERT                        NID_netscape_cert_extension               SESSION_ASN1_VERSION
   CB_CONNECT_EXIT                 NID_netscape_cert_sequence                SESS_CACHE_BOTH
   CB_CONNECT_LOOP                 NID_netscape_cert_type                    SESS_CACHE_CLIENT
   CB_EXIT                         NID_netscape_comment                      SESS_CACHE_NO_AUTO_CLEAR
   CB_HANDSHAKE_DONE               NID_netscape_data_type                    SESS_CACHE_NO_INTERNAL
   CB_HANDSHAKE_START              NID_netscape_renewal_url                  SESS_CACHE_NO_INTERNAL_LOOKUP
   CB_LOOP                         NID_netscape_revocation_url               SESS_CACHE_NO_INTERNAL_STORE
   CB_READ                         NID_netscape_ssl_server_name              SESS_CACHE_OFF
   CB_READ_ALERT                   NID_ns_sgc                                SESS_CACHE_SERVER
   CB_WRITE                        NID_organizationName                      SSL3_VERSION
   CB_WRITE_ALERT                  NID_organizationalUnitName                SSLEAY_BUILT_ON
   ERROR_NONE                      NID_pbeWithMD2AndDES_CBC                  SSLEAY_CFLAGS
   ERROR_SSL                       NID_pbeWithMD2AndRC2_CBC                  SSLEAY_DIR
   ERROR_SYSCALL                   NID_pbeWithMD5AndCast5_CBC                SSLEAY_PLATFORM
   ERROR_WANT_ACCEPT               NID_pbeWithMD5AndDES_CBC                  SSLEAY_VERSION
   ERROR_WANT_CONNECT              NID_pbeWithMD5AndRC2_CBC                  ST_ACCEPT
   ERROR_WANT_READ                 NID_pbeWithSHA1AndDES_CBC                 ST_BEFORE
   ERROR_WANT_WRITE                NID_pbeWithSHA1AndRC2_CBC                 ST_CONNECT
   ERROR_WANT_X509_LOOKUP          NID_pbe_WithSHA1And128BitRC2_CBC          ST_INIT
   ERROR_ZERO_RETURN               NID_pbe_WithSHA1And128BitRC4              ST_OK
   EVP_PKS_DSA                     NID_pbe_WithSHA1And2_Key_TripleDES_CBC    ST_READ_BODY
   EVP_PKS_EC                      NID_pbe_WithSHA1And3_Key_TripleDES_CBC    ST_READ_HEADER
   EVP_PKS_RSA                     NID_pbe_WithSHA1And40BitRC2_CBC           TLS1_1_VERSION
   EVP_PKT_ENC                     NID_pbe_WithSHA1And40BitRC4               TLS1_2_VERSION
   EVP_PKT_EXCH                    NID_pbes2                                 TLS1_3_VERSION
   EVP_PKT_EXP                     NID_pbmac1                                TLS1_VERSION
   EVP_PKT_SIGN                    NID_pkcs                                  TLSEXT_STATUSTYPE_ocsp
   EVP_PK_DH                       NID_pkcs3                                 VERIFY_CLIENT_ONCE
   EVP_PK_DSA                      NID_pkcs7                                 VERIFY_FAIL_IF_NO_PEER_CERT
   EVP_PK_EC                       NID_pkcs7_data                            VERIFY_NONE
   EVP_PK_RSA                      NID_pkcs7_digest                          VERIFY_PEER
   FILETYPE_ASN1                   NID_pkcs7_encrypted                       V_OCSP_CERTSTATUS_GOOD
   FILETYPE_PEM                    NID_pkcs7_enveloped                       V_OCSP_CERTSTATUS_REVOKED
   F_CLIENT_CERTIFICATE            NID_pkcs7_signed                          V_OCSP_CERTSTATUS_UNKNOWN
   F_CLIENT_HELLO                  NID_pkcs7_signedAndEnveloped              WRITING
   F_CLIENT_MASTER_KEY             NID_pkcs8ShroudedKeyBag                   X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT
   F_D2I_SSL_SESSION               NID_pkcs9                                 X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS
   F_GET_CLIENT_FINISHED           NID_pkcs9_challengePassword               X509_CHECK_FLAG_NEVER_CHECK_SUBJECT
   F_GET_CLIENT_HELLO              NID_pkcs9_contentType                     X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS
   F_GET_CLIENT_MASTER_KEY         NID_pkcs9_countersignature                X509_CHECK_FLAG_NO_WILDCARDS
   F_GET_SERVER_FINISHED           NID_pkcs9_emailAddress                    X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS
   F_GET_SERVER_HELLO              NID_pkcs9_extCertAttributes               X509_LOOKUP
   F_GET_SERVER_VERIFY             NID_pkcs9_messageDigest                   X509_PURPOSE_ANY
   F_I2D_SSL_SESSION               NID_pkcs9_signingTime                     X509_PURPOSE_CRL_SIGN
   F_READ_N                        NID_pkcs9_unstructuredAddress             X509_PURPOSE_NS_SSL_SERVER
   F_REQUEST_CERTIFICATE           NID_pkcs9_unstructuredName                X509_PURPOSE_OCSP_HELPER
   F_SERVER_HELLO                  NID_private_key_usage_period              X509_PURPOSE_SMIME_ENCRYPT
   F_SSL_CERT_NEW                  NID_rc2_40_cbc                            X509_PURPOSE_SMIME_SIGN
   F_SSL_GET_NEW_SESSION           NID_rc2_64_cbc                            X509_PURPOSE_SSL_CLIENT
   F_SSL_NEW                       NID_rc2_cbc                               X509_PURPOSE_SSL_SERVER
   F_SSL_READ                      NID_rc2_cfb64                             X509_PURPOSE_TIMESTAMP_SIGN
   F_SSL_RSA_PRIVATE_DECRYPT       NID_rc2_ecb                               X509_TRUST_COMPAT
   F_SSL_RSA_PUBLIC_ENCRYPT        NID_rc2_ofb64                             X509_TRUST_EMAIL
   F_SSL_SESSION_NEW               NID_rc4                                   X509_TRUST_OBJECT_SIGN
   F_SSL_SESSION_PRINT_FP          NID_rc4_40                                X509_TRUST_OCSP_REQUEST
   F_SSL_SET_FD                    NID_rc5_cbc                               X509_TRUST_OCSP_SIGN
   F_SSL_SET_RFD                   NID_rc5_cfb64                             X509_TRUST_SSL_CLIENT
   F_SSL_SET_WFD                   NID_rc5_ecb                               X509_TRUST_SSL_SERVER
   F_SSL_USE_CERTIFICATE           NID_rc5_ofb64                             X509_TRUST_TSA
   F_SSL_USE_CERTIFICATE_ASN1      NID_ripemd160                             X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH
   F_SSL_USE_CERTIFICATE_FILE      NID_ripemd160WithRSA                      X509_V_ERR_AKID_SKID_MISMATCH
   F_SSL_USE_PRIVATEKEY            NID_rle_compression                       X509_V_ERR_APPLICATION_VERIFICATION
   F_SSL_USE_PRIVATEKEY_ASN1       NID_rsa                                   X509_V_ERR_CA_KEY_TOO_SMALL
   F_SSL_USE_PRIVATEKEY_FILE       NID_rsaEncryption                         X509_V_ERR_CA_MD_TOO_WEAK
   F_SSL_USE_RSAPRIVATEKEY         NID_rsadsi                                X509_V_ERR_CERT_CHAIN_TOO_LONG
   F_SSL_USE_RSAPRIVATEKEY_ASN1    NID_safeContentsBag                       X509_V_ERR_CERT_HAS_EXPIRED
   F_SSL_USE_RSAPRIVATEKEY_FILE    NID_sdsiCertificate                       X509_V_ERR_CERT_NOT_YET_VALID
   F_WRITE_PENDING                 NID_secretBag                             X509_V_ERR_CERT_REJECTED
   GEN_DIRNAME                     NID_serialNumber                          X509_V_ERR_CERT_REVOKED
   GEN_DNS                         NID_server_auth                           X509_V_ERR_CERT_SIGNATURE_FAILURE
   GEN_EDIPARTY                    NID_sha                                   X509_V_ERR_CERT_UNTRUSTED
   GEN_EMAIL                       NID_sha1                                  X509_V_ERR_CRL_HAS_EXPIRED
   GEN_IPADD                       NID_sha1WithRSA                           X509_V_ERR_CRL_NOT_YET_VALID
   GEN_OTHERNAME                   NID_sha1WithRSAEncryption                 X509_V_ERR_CRL_PATH_VALIDATION_ERROR
   GEN_RID                         NID_shaWithRSAEncryption                  X509_V_ERR_CRL_SIGNATURE_FAILURE
   GEN_URI                         NID_stateOrProvinceName                   X509_V_ERR_DANE_NO_MATCH
   GEN_X400                        NID_subject_alt_name                      X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT
   LIBRESSL_VERSION_NUMBER         NID_subject_key_identifier                X509_V_ERR_DIFFERENT_CRL_SCOPE
   MBSTRING_ASC                    NID_surname                               X509_V_ERR_EE_KEY_TOO_SMALL
   MBSTRING_BMP                    NID_sxnet                                 X509_V_ERR_EMAIL_MISMATCH
   MBSTRING_FLAG                   NID_time_stamp                            X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD
   MBSTRING_UNIV                   NID_title                                 X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD
   MBSTRING_UTF8                   NID_undef                                 X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD
   MIN_RSA_MODULUS_LENGTH_IN_BYTES NID_uniqueIdentifier                      X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD
   MODE_ACCEPT_MOVING_WRITE_BUFFER NID_x509Certificate                       X509_V_ERR_EXCLUDED_VIOLATION
   MODE_AUTO_RETRY                 NID_x509Crl                               X509_V_ERR_HOSTNAME_MISMATCH
   MODE_ENABLE_PARTIAL_WRITE       NID_zlib_compression                      X509_V_ERR_INVALID_CA
   MODE_RELEASE_BUFFERS            NOTHING                                   X509_V_ERR_INVALID_CALL
   NID_OCSP_sign                   OCSP_RESPONSE_STATUS_INTERNALERROR        X509_V_ERR_INVALID_EXTENSION
   NID_SMIMECapabilities           OCSP_RESPONSE_STATUS_MALFORMEDREQUEST     X509_V_ERR_INVALID_NON_CA
   NID_X500                        OCSP_RESPONSE_STATUS_SIGREQUIRED          X509_V_ERR_INVALID_POLICY_EXTENSION
   NID_X509                        OCSP_RESPONSE_STATUS_SUCCESSFUL           X509_V_ERR_INVALID_PURPOSE
   NID_ad_OCSP                     OCSP_RESPONSE_STATUS_TRYLATER             X509_V_ERR_IP_ADDRESS_MISMATCH
   NID_ad_ca_issuers               OCSP_RESPONSE_STATUS_UNAUTHORIZED         X509_V_ERR_KEYUSAGE_NO_CERTSIGN
   NID_algorithm                   OPENSSL_BUILT_ON                          X509_V_ERR_KEYUSAGE_NO_CRL_SIGN
   NID_authority_key_identifier    OPENSSL_CFLAGS                            X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE
   NID_basic_constraints           OPENSSL_DIR                               X509_V_ERR_NO_EXPLICIT_POLICY
   NID_bf_cbc                      OPENSSL_ENGINES_DIR                       X509_V_ERR_NO_VALID_SCTS
   NID_bf_cfb64                    OPENSSL_PLATFORM                          X509_V_ERR_OCSP_CERT_UNKNOWN
   NID_bf_ecb                      OPENSSL_VERSION                           X509_V_ERR_OCSP_VERIFY_FAILED
   NID_bf_ofb64                    OPENSSL_VERSION_NUMBER                    X509_V_ERR_OCSP_VERIFY_NEEDED
   NID_cast5_cbc                   OP_ALL                                    X509_V_ERR_OUT_OF_MEM
   NID_cast5_cfb64                 OP_ALLOW_NO_DHE_KEX                       X509_V_ERR_PATH_LENGTH_EXCEEDED
   NID_cast5_ecb                   OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION      X509_V_ERR_PATH_LOOP
   NID_cast5_ofb64                 OP_CIPHER_SERVER_PREFERENCE               X509_V_ERR_PERMITTED_VIOLATION
   NID_certBag                     OP_CISCO_ANYCONNECT                       X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED
   NID_certificate_policies        OP_COOKIE_EXCHANGE                        X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED
   NID_client_auth                 OP_CRYPTOPRO_TLSEXT_BUG                   X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION
   NID_code_sign                   OP_DONT_INSERT_EMPTY_FRAGMENTS            X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN
   NID_commonName                  OP_EPHEMERAL_RSA                          X509_V_ERR_STORE_LOOKUP
   NID_countryName                 OP_LEGACY_SERVER_CONNECT                  X509_V_ERR_SUBJECT_ISSUER_MISMATCH
   NID_crlBag                      OP_MICROSOFT_BIG_SSLV3_BUFFER             X509_V_ERR_SUBTREE_MINMAX
   NID_crl_distribution_points     OP_MICROSOFT_SESS_ID_BUG                  X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256
   NID_crl_number                  OP_MSIE_SSLV2_RSA_PADDING                 X509_V_ERR_SUITE_B_INVALID_ALGORITHM
   NID_crl_reason                  OP_NETSCAPE_CA_DN_BUG                     X509_V_ERR_SUITE_B_INVALID_CURVE
   NID_delta_crl                   OP_NETSCAPE_CHALLENGE_BUG                 X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM
   NID_des_cbc                     OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG        X509_V_ERR_SUITE_B_INVALID_VERSION
   NID_des_cfb64                   OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG       X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED
   NID_des_ecb                     OP_NON_EXPORT_FIRST                       X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY
   NID_des_ede                     OP_NO_CLIENT_RENEGOTIATION                X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE
   NID_des_ede3                    OP_NO_COMPRESSION                         X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE
   NID_des_ede3_cbc                OP_NO_ENCRYPT_THEN_MAC                    X509_V_ERR_UNABLE_TO_GET_CRL
   NID_des_ede3_cfb64              OP_NO_QUERY_MTU                           X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER
   NID_des_ede3_ofb64              OP_NO_RENEGOTIATION                       X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT
   NID_des_ede_cbc                 OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY
   NID_des_ede_cfb64               OP_NO_SSL_MASK                            X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE
   NID_des_ede_ofb64               OP_NO_SSLv2                               X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION
   NID_des_ofb64                   OP_NO_SSLv3                               X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION
   NID_description                 OP_NO_TICKET                              X509_V_ERR_UNNESTED_RESOURCE
   NID_desx_cbc                    OP_NO_TLSv1                               X509_V_ERR_UNSPECIFIED
   NID_dhKeyAgreement              OP_NO_TLSv1_1                             X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX
   NID_dnQualifier                 OP_NO_TLSv1_2                             X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE
   NID_dsa                         OP_NO_TLSv1_3                             X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE
   NID_dsaWithSHA                  OP_PKCS1_CHECK_1                          X509_V_ERR_UNSUPPORTED_NAME_SYNTAX
   NID_dsaWithSHA1                 OP_PKCS1_CHECK_2                          X509_V_FLAG_ALLOW_PROXY_CERTS
   NID_dsaWithSHA1_2               OP_PRIORITIZE_CHACHA                      X509_V_FLAG_CB_ISSUER_CHECK
   NID_dsa_2                       OP_SAFARI_ECDHE_ECDSA_BUG                 X509_V_FLAG_CHECK_SS_SIGNATURE
   NID_email_protect               OP_SINGLE_DH_USE                          X509_V_FLAG_CRL_CHECK
   NID_ext_key_usage               OP_SINGLE_ECDH_USE                        X509_V_FLAG_CRL_CHECK_ALL
   NID_ext_req                     OP_SSLEAY_080_CLIENT_DH_BUG               X509_V_FLAG_EXPLICIT_POLICY
   NID_friendlyName                OP_SSLREF2_REUSE_CERT_TYPE_BUG            X509_V_FLAG_EXTENDED_CRL_SUPPORT
   NID_givenName                   OP_TLSEXT_PADDING                         X509_V_FLAG_IGNORE_CRITICAL
   NID_hmacWithSHA1                OP_TLS_BLOCK_PADDING_BUG                  X509_V_FLAG_INHIBIT_ANY
   NID_id_ad                       OP_TLS_D5_BUG                             X509_V_FLAG_INHIBIT_MAP
   NID_id_ce                       OP_TLS_ROLLBACK_BUG                       X509_V_FLAG_NOTIFY_POLICY
   NID_id_kp                       READING                                   X509_V_FLAG_NO_ALT_CHAINS
   NID_id_pbkdf2                   RECEIVED_SHUTDOWN                         X509_V_FLAG_NO_CHECK_TIME
   NID_id_pe                       RSA_3                                     X509_V_FLAG_PARTIAL_CHAIN
   NID_id_pkix                     RSA_F4                                    X509_V_FLAG_POLICY_CHECK
   NID_id_qt_cps                   R_BAD_AUTHENTICATION_TYPE                 X509_V_FLAG_POLICY_MASK
   NID_id_qt_unotice               R_BAD_CHECKSUM                            X509_V_FLAG_SUITEB_128_LOS
   NID_idea_cbc                    R_BAD_MAC_DECODE                          X509_V_FLAG_SUITEB_128_LOS_ONLY
   NID_idea_cfb64                  R_BAD_RESPONSE_ARGUMENT                   X509_V_FLAG_SUITEB_192_LOS
   NID_idea_ecb                    R_BAD_SSL_FILETYPE                        X509_V_FLAG_TRUSTED_FIRST
   NID_idea_ofb64                  R_BAD_SSL_SESSION_ID_LENGTH               X509_V_FLAG_USE_CHECK_TIME
   NID_info_access                 R_BAD_STATE                               X509_V_FLAG_USE_DELTAS
   NID_initials                    R_BAD_WRITE_RETRY                         X509_V_FLAG_X509_STRICT
   NID_invalidity_date             R_CHALLENGE_IS_DIFFERENT                  X509_V_OK
   NID_issuer_alt_name             R_CIPHER_TABLE_SRC_ERROR                  XN_FLAG_COMPAT
   NID_keyBag                      R_INVALID_CHALLENGE_LENGTH                XN_FLAG_DN_REV
   NID_key_usage                   R_NO_CERTIFICATE_SET                      XN_FLAG_DUMP_UNKNOWN_FIELDS
   NID_localKeyID                  R_NO_CERTIFICATE_SPECIFIED                XN_FLAG_FN_ALIGN
   NID_localityName                R_NO_CIPHER_LIST                          XN_FLAG_FN_LN
   NID_md2                         R_NO_CIPHER_MATCH                         XN_FLAG_FN_MASK
   NID_md2WithRSAEncryption        R_NO_PRIVATEKEY                           XN_FLAG_FN_NONE
   NID_md5                         R_NO_PUBLICKEY                            XN_FLAG_FN_OID
   NID_md5WithRSA                  R_NULL_SSL_CTX                            XN_FLAG_FN_SN
   NID_md5WithRSAEncryption        R_PEER_DID_NOT_RETURN_A_CERTIFICATE       XN_FLAG_MULTILINE
   NID_md5_sha1                    R_PEER_ERROR                              XN_FLAG_ONELINE
   NID_mdc2                        R_PEER_ERROR_CERTIFICATE                  XN_FLAG_RFC2253
   NID_mdc2WithRSA                 R_PEER_ERROR_NO_CIPHER                    XN_FLAG_SEP_COMMA_PLUS
   NID_ms_code_com                 R_PEER_ERROR_UNSUPPORTED_CERTIFICATE_TYPE XN_FLAG_SEP_CPLUS_SPC
   NID_ms_code_ind                 R_PUBLIC_KEY_ENCRYPT_ERROR                XN_FLAG_SEP_MASK
   NID_ms_ctl_sign                 R_PUBLIC_KEY_IS_NOT_RSA                   XN_FLAG_SEP_MULTILINE
   NID_ms_efs                      R_READ_WRONG_PACKET_TYPE                  XN_FLAG_SEP_SPLUS_SPC
   NID_ms_ext_req                  R_SHORT_READ                              XN_FLAG_SPC_EQ
      BIO_eof
      BIO_f_ssl
      BIO_free
      BIO_new
      BIO_new_file
      BIO_pending
      BIO_read
      BIO_s_mem
      BIO_wpending
      BIO_write
      CTX_free
      CTX_get_cert_store
      CTX_new
      CTX_use_RSAPrivateKey_file
      CTX_use_certificate_file
      CTX_v23_new
      CTX_v2_new
      CTX_v3_new
      ERR_error_string
      ERR_get_error
      ERR_load_RAND_strings
      ERR_load_SSL_strings
      PEM_read_bio_X509_CRL
      RSA_free
      RSA_generate_key
      SESSION
      SESSION_free
      SESSION_get_master_key
      SESSION_new
      SESSION_print
      X509_NAME_get_text_by_NID
      X509_NAME_oneline
      X509_STORE_CTX_set_flags
      X509_STORE_add_cert
      X509_STORE_add_crl
      X509_check_email
      X509_check_host
      X509_check_ip
      X509_check_ip_asc
      X509_free
      X509_get_issuer_name
      X509_get_subject_name
      X509_load_cert_crl_file
      X509_load_cert_file
      X509_load_crl_file
      accept
      add_session
      clear
      clear_error
      connect
      copy_session_id
      d2i_SSL_SESSION
      die_if_ssl_error
      die_now
      do_https
      dump_peer_certificate
      err
      flush_sessions
      free
      get_cipher
      get_cipher_list
      get_client_random
      get_fd
      get_http
      get_http4
      get_https
      get_https3
      get_https4
      get_httpx
      get_httpx4
      get_peer_certificate
      get_peer_cert_chain
      get_rbio
      get_read_ahead
      get_server_random
      get_shared_ciphers
      get_time
      get_timeout
      get_wbio
      i2d_SSL_SESSION
      load_error_strings
      make_form
      make_headers
      new
      peek
      pending
      post_http
      post_http4
      post_https
      post_https3
      post_https4
      post_httpx
      post_httpx4
      print_errs
      read
      remove_session
      rstate_string
      rstate_string_long
      set_bio
      set_cert_and_key
      set_cipher_list
      set_fd
      set_read_ahead
      set_rfd
      set_server_cert_and_key
      set_session
      set_time
      set_timeout
      set_verify
      set_wfd
      ssl_read_CRLF
      ssl_read_all
      ssl_read_until
      ssl_write_CRLF
      ssl_write_all
      sslcat
      state_string
      state_string_long
      tcp_read_CRLF
      tcp_read_all
      tcp_read_until
      tcp_write_CRLF
      tcp_write_all
      tcpcat
      tcpxcat
      use_PrivateKey
      use_PrivateKey_ASN1
      use_PrivateKey_file
      use_RSAPrivateKey
      use_RSAPrivateKey_ASN1
      use_RSAPrivateKey_file
      use_certificate
      use_certificate_ASN1
      use_certificate_file
      write
      d2i_OCSP_RESPONSE
      i2d_OCSP_RESPONSE
      OCSP_RESPONSE_free
      d2i_OCSP_REQUEST
      i2d_OCSP_REQUEST
      OCSP_REQUEST_free
      OCSP_cert2ids
      OCSP_ids2req
      OCSP_response_status
      OCSP_response_status_str
      OCSP_response_verify
      OCSP_response_results
      OCSP_RESPONSE_STATUS_INTERNALERROR
      OCSP_RESPONSE_STATUS_MALFORMEDREQUEST
      OCSP_RESPONSE_STATUS_SIGREQUIRED
      OCSP_RESPONSE_STATUS_SUCCESSFUL
      OCSP_RESPONSE_STATUS_TRYLATER
      OCSP_RESPONSE_STATUS_UNAUTHORIZED
      TLSEXT_STATUSTYPE_ocsp
      V_OCSP_CERTSTATUS_GOOD
      V_OCSP_CERTSTATUS_REVOKED
      V_OCSP_CERTSTATUS_UNKNOWN
  );
  
  sub AUTOLOAD {
      # This AUTOLOAD is used to 'autoload' constants from the constant()
      # XS function.  If a constant is not found then control is passed
      # to the AUTOLOAD in AutoLoader.
  
      my $constname;
      ($constname = $AUTOLOAD) =~ s/.*:://;
      my $val = constant($constname);
      if ($! != 0) {
  	if ($! =~ /((Invalid)|(not valid))/i || $!{EINVAL}) {
  	    $AutoLoader::AUTOLOAD = $AUTOLOAD;
  	    goto &AutoLoader::AUTOLOAD;
  	}
  	else {
  	  croak "Your vendor has not defined SSLeay macro $constname";
  	}
      }
      eval "sub $AUTOLOAD { $val }";
      goto &$AUTOLOAD;
  }
  
  eval {
  	require XSLoader;
  	XSLoader::load('Net::SSLeay', $VERSION);
  	1;
  } or do {
  	require DynaLoader;
  	push @ISA, 'DynaLoader';
  	bootstrap Net::SSLeay $VERSION;
  };
  
  # Preloaded methods go here.
  
  $CRLF = "\x0d\x0a";  # because \r\n is not fully portable
  
  ### Print SSLeay error stack
  
  sub print_errs {
      my ($msg) = @_;
      my ($count, $err, $errs, $e) = (0,0,'');
      while ($err = ERR_get_error()) {
          $count ++;
  	$e = "$msg $$: $count - " . ERR_error_string($err) . "\n";
  	$errs .= $e;
  	warn $e if $Net::SSLeay::trace;
      }
      return $errs;
  }
  
  # Death is conditional to SSLeay errors existing, i.e. this function checks
  # for errors and only dies in affirmative.
  # usage: Net::SSLeay::write($ssl, "foo") or die_if_ssl_error("SSL write ($!)");
  
  sub die_if_ssl_error {
      my ($msg) = @_;
      die "$$: $msg\n" if print_errs($msg);
  }
  
  # Unconditional death. Used to print SSLeay errors before dying.
  # usage: Net::SSLeay::connect($ssl) or die_now("Failed SSL connect ($!)");
  
  sub die_now {
      my ($msg) = @_;
      print_errs($msg);
      die "$$: $msg\n";
  }
  
  # Perl 5.6.* unicode support causes that length() no longer reliably
  # reflects the byte length of a string. This eval is to fix that.
  # Thanks to Sean Burke for the snippet.
  
  BEGIN{
  eval 'use bytes; sub blength ($) { defined $_[0] ? length $_[0] : 0  }';
  $@ and eval '    sub blength ($) { defined $_[0] ? length $_[0] : 0 }' ;
  }
  
  # Autoload methods go after __END__, and are processed by the autosplit program.
  
  
  1;
  __END__
  
  ### Some methods that are macros in C
  
  sub want_nothing { want(shift) == 1 }
  sub want_read { want(shift) == 2 }
  sub want_write { want(shift) == 3 }
  sub want_X509_lookup { want(shift) == 4 }
  
  ###
  ### Open TCP stream to given host and port, looking up the details
  ### from system databases or DNS.
  ###
  
  sub open_tcp_connection {
      my ($dest_serv, $port) = @_;
      my ($errs);
  
      $port = getservbyname($port, 'tcp') unless $port =~ /^\d+$/;
      my $dest_serv_ip = gethostbyname($dest_serv);
      unless (defined($dest_serv_ip)) {
  	$errs = "$0 $$: open_tcp_connection: destination host not found:"
              . " `$dest_serv' (port $port) ($!)\n";
  	warn $errs if $trace;
          return wantarray ? (0, $errs) : 0;
      }
      my $sin = sockaddr_in($port, $dest_serv_ip);
  
      warn "Opening connection to $dest_serv:$port (" .
  	inet_ntoa($dest_serv_ip) . ")" if $trace>2;
  
      my $proto = &Socket::IPPROTO_TCP; # getprotobyname('tcp') not available on android
      if (socket (SSLCAT_S, &PF_INET(), &SOCK_STREAM(), $proto)) {
          warn "next connect" if $trace>3;
          if (CORE::connect (SSLCAT_S, $sin)) {
              my $old_out = select (SSLCAT_S); $| = 1; select ($old_out);
              warn "connected to $dest_serv, $port" if $trace>3;
              return wantarray ? (1, undef) : 1; # Success
          }
      }
      $errs = "$0 $$: open_tcp_connection: failed `$dest_serv', $port ($!)\n";
      warn $errs if $trace;
      close SSLCAT_S;
      return wantarray ? (0, $errs) : 0; # Fail
  }
  
  ### Open connection via standard web proxy, if one was defined
  ### using set_proxy().
  
  sub open_proxy_tcp_connection {
      my ($dest_serv, $port) = @_;
      return open_tcp_connection($dest_serv, $port) if !$proxyhost;
  
      warn "Connect via proxy: $proxyhost:$proxyport" if $trace>2;
      my ($ret, $errs) = open_tcp_connection($proxyhost, $proxyport);
      return wantarray ? (0, $errs) : 0 if !$ret;  # Connection fail
  
      warn "Asking proxy to connect to $dest_serv:$port" if $trace>2;
      #print SSLCAT_S "CONNECT $dest_serv:$port HTTP/1.0$proxyauth$CRLF$CRLF";
      #my $line = <SSLCAT_S>;   # *** bug? Mixing stdio with syscall read?
      ($ret, $errs) =
  	tcp_write_all("CONNECT $dest_serv:$port HTTP/1.0$proxyauth$CRLF$CRLF");
      return wantarray ? (0,$errs) : 0 if $errs;
      ($line, $errs) = tcp_read_until($CRLF . $CRLF, 1024);
      warn "Proxy response: $line" if $trace>2;
      return wantarray ? (0,$errs) : 0 if $errs;
      return wantarray ? (1,'') : 1;  # Success
  }
  
  ###
  ### read and write helpers that block
  ###
  
  sub debug_read {
      my ($replyr, $gotr) = @_;
      my $vm = $trace>2 && $linux_debug ?
  	(split ' ', `cat /proc/$$/stat`)[22] : 'vm_unknown';
      warn "  got " . blength($$gotr) . ':'
  	. blength($$replyr) . " bytes (VM=$vm).\n" if $trace == 3;
      warn "  got `$$gotr' (" . blength($$gotr) . ':'
  	. blength($$replyr) . " bytes, VM=$vm)\n" if $trace>3;
  }
  
  sub ssl_read_all {
      my ($ssl,$how_much) = @_;
      $how_much = 2000000000 unless $how_much;
      my ($got, $errs);
      my $reply = '';
  
      while ($how_much > 0) {
          $got = Net::SSLeay::read($ssl,
                  ($how_much > 32768) ? 32768 : $how_much
          );
          last if $errs = print_errs('SSL_read');
          $how_much -= blength($got);
          debug_read(\$reply, \$got) if $trace>1;
          last if $got eq '';  # EOF
          $reply .= $got;
      }
  
      return wantarray ? ($reply, $errs) : $reply;
  }
  
  sub tcp_read_all {
      my ($how_much) = @_;
      $how_much = 2000000000 unless $how_much;
      my ($n, $got, $errs);
      my $reply = '';
  
      my $bsize = 0x10000;
      while ($how_much > 0) {
  	$n = sysread(SSLCAT_S,$got, (($bsize < $how_much) ? $bsize : $how_much));
  	warn "Read error: $! ($n,$how_much)" unless defined $n;
  	last if !$n;  # EOF
  	$how_much -= $n;
  	debug_read(\$reply, \$got) if $trace>1;
  	$reply .= $got;
      }
      return wantarray ? ($reply, $errs) : $reply;
  }
  
  sub ssl_write_all {
      my $ssl = $_[0];
      my ($data_ref, $errs);
      if (ref $_[1]) {
  	$data_ref = $_[1];
      } else {
  	$data_ref = \$_[1];
      }
      my ($wrote, $written, $to_write) = (0,0, blength($$data_ref));
      my $vm = $trace>2 && $linux_debug ?
  	(split ' ', `cat /proc/$$/stat`)[22] : 'vm_unknown';
      warn "  write_all VM at entry=$vm\n" if $trace>2;
      while ($to_write) {
  	#sleep 1; # *** DEBUG
  	warn "partial `$$data_ref'\n" if $trace>3;
  	$wrote = write_partial($ssl, $written, $to_write, $$data_ref);
  	if (defined $wrote && ($wrote > 0)) {  # write_partial can return -1
  	    $written += $wrote;
  	    $to_write -= $wrote;
  	} else {
  	  if (defined $wrote) {
  	    # check error conditions via SSL_get_error per man page
  	    if ( my $sslerr = get_error($ssl, $wrote) ) {
  	      my $errstr = ERR_error_string($sslerr);
  	      my $errname = '';
  	      SWITCH: {
  		$sslerr == constant("ERROR_NONE") && do {
  		  # according to map page SSL_get_error(3ssl):
  		  #  The TLS/SSL I/O operation completed.
  		  #  This result code is returned if and only if ret > 0
                    # so if we received it here complain...
  		  warn "ERROR_NONE unexpected with invalid return value!"
  		    if $trace;
  		  $errname = "SSL_ERROR_NONE";
  		};
  		$sslerr == constant("ERROR_WANT_READ") && do {
  		  # operation did not complete, call again later, so do not
  		  # set errname and empty err_que since this is a known
  		  # error that is expected but, we should continue to try
  		  # writing the rest of our data with same io call and params.
  		  warn "ERROR_WANT_READ (TLS/SSL Handshake, will continue)\n"
  		    if $trace;
  		  print_errs('SSL_write(want read)');
  		  last SWITCH;
  		};
  		$sslerr == constant("ERROR_WANT_WRITE") && do {
  		  # operation did not complete, call again later, so do not
  		  # set errname and empty err_que since this is a known
  		  # error that is expected but, we should continue to try
  		  # writing the rest of our data with same io call and params.
  		  warn "ERROR_WANT_WRITE (TLS/SSL Handshake, will continue)\n"
  		    if $trace;
  		  print_errs('SSL_write(want write)');
  		  last SWITCH;
  		};
  		$sslerr == constant("ERROR_ZERO_RETURN") && do {
  		  # valid protocol closure from other side, no longer able to
  		  # write, since there is no longer a session...
  		  warn "ERROR_ZERO_RETURN($wrote): TLS/SSLv3 Closure alert\n"
  		    if $trace;
  		  $errname = "SSL_ERROR_ZERO_RETURN";
  		  last SWITCH;
  		};
  		$sslerr == constant("ERROR_SSL") && do {
  		  # library/protocol error
  		  warn "ERROR_SSL($wrote): Library/Protocol error occured\n"
  		    if $trace;
  		  $errname = "SSL_ERROR_SSL";
  		  last SWITCH;
  		};
  		$sslerr == constant("ERROR_WANT_CONNECT") && do {
  		  # according to man page, should never happen on call to
  		  # SSL_write, so complain, but handle as known error type
  		  warn "ERROR_WANT_CONNECT: Unexpected error for SSL_write\n"
  		    if $trace;
  		  $errname = "SSL_ERROR_WANT_CONNECT";
  		  last SWITCH;
  		};
  		$sslerr == constant("ERROR_WANT_ACCEPT") && do {
  		  # according to man page, should never happen on call to
  		  # SSL_write, so complain, but handle as known error type
  		  warn "ERROR_WANT_ACCEPT: Unexpected error for SSL_write\n"
  		    if $trace;
  		  $errname = "SSL_ERROR_WANT_ACCEPT";
  		  last SWITCH;
  		};
  		$sslerr == constant("ERROR_WANT_X509_LOOKUP") && do {
  		  # operation did not complete: waiting on call back,
  		  # call again later, so do not set errname and empty err_que
  		  # since this is a known error that is expected but, we should
  		  # continue to try writing the rest of our data with same io
  		  # call parameter.
  		  warn "ERROR_WANT_X509_LOOKUP: (Cert Callback asked for in ".
  		    "SSL_write will contine)\n" if $trace;
  		  print_errs('SSL_write(want x509');
  		  last SWITCH;
  		};
  		$sslerr == constant("ERROR_SYSCALL") && do {
  		  # some IO error occured. According to man page:
  		  # Check retval, ERR, fallback to errno
  		  if ($wrote==0) { # EOF
  		    warn "ERROR_SYSCALL($wrote): EOF violates protocol.\n"
  		      if $trace;
  		    $errname = "SSL_ERROR_SYSCALL(EOF)";
  		  } else { # -1 underlying BIO error reported.
  		    # check error que for details, don't set errname since we
  		    # are directly appending to errs
  		    my $chkerrs = print_errs('SSL_write (syscall)');
  		    if ($chkerrs) {
  		      warn "ERROR_SYSCALL($wrote): Have errors\n" if $trace;
  		      $errs .= "ssl_write_all $$: 1 - ERROR_SYSCALL($wrote,".
  			"$sslerr,$errstr,$!)\n$chkerrs";
  		    } else { # que was empty, use errno
  		      warn "ERROR_SYSCALL($wrote): errno($!)\n" if $trace;
  		      $errs .= "ssl_write_all $$: 1 - ERROR_SYSCALL($wrote,".
  			"$sslerr) : $!\n";
  		    }
  		  }
  		  last SWITCH;
  		};
  		warn "Unhandled val $sslerr from SSL_get_error(SSL,$wrote)\n"
  		  if $trace;
  		$errname = "SSL_ERROR_?($sslerr)";
  	      } # end of SWITCH block
  	      if ($errname) { # if we had an errname set add the error
  		$errs .= "ssl_write_all $$: 1 - $errname($wrote,$sslerr,".
  		  "$errstr,$!)\n";
  	      }
  	    } # endif on have SSL_get_error val
  	  } # endif on $wrote defined
  	} # endelse on $wrote > 0
  	$vm = $trace>2 && $linux_debug ?
  	    (split ' ', `cat /proc/$$/stat`)[22] : 'vm_unknown';
  	warn "  written so far $wrote:$written bytes (VM=$vm)\n" if $trace>2;
  	# append remaining errors in que and report if errs exist
  	$errs .= print_errs('SSL_write');
  	return (wantarray ? (undef, $errs) : undef) if $errs;
      }
      return wantarray ? ($written, $errs) : $written;
  }
  
  sub tcp_write_all {
      my ($data_ref, $errs);
      if (ref $_[0]) {
  	$data_ref = $_[0];
      } else {
  	$data_ref = \$_[0];
      }
      my ($wrote, $written, $to_write) = (0,0, blength($$data_ref));
      my $vm = $trace>2 && $linux_debug ?
  	(split ' ', `cat /proc/$$/stat`)[22] : 'vm_unknown';
      warn "  write_all VM at entry=$vm to_write=$to_write\n" if $trace>2;
      while ($to_write) {
  	warn "partial `$$data_ref'\n" if $trace>3;
  	$wrote = syswrite(SSLCAT_S, $$data_ref, $to_write, $written);
  	if (defined $wrote && ($wrote > 0)) {  # write_partial can return -1
  	    $written += $wrote;
  	    $to_write -= $wrote;
  	} elsif (!defined($wrote)) {
  	    warn "tcp_write_all: $!";
  	    return (wantarray ? (undef, "$!") : undef);
  	}
  	$vm = $trace>2 && $linux_debug ?
  	    (split ' ', `cat /proc/$$/stat`)[22] : 'vm_unknown';
  	warn "  written so far $wrote:$written bytes (VM=$vm)\n" if $trace>2;
      }
      return wantarray ? ($written, '') : $written;
  }
  
  ### from patch by Clinton Wong <clintdw@netcom.com>
  
  # ssl_read_until($ssl [, $delimit [, $max_length]])
  #  if $delimit missing, use $/ if it exists, otherwise use \n
  #  read until delimiter reached, up to $max_length chars if defined
  
  sub ssl_read_until ($;$$) {
      my ($ssl,$delim, $max_length) = @_;
  
      # guess the delim string if missing
      if ( ! defined $delim ) {
        if ( defined $/ && length $/  ) { $delim = $/ }
        else { $delim = "\n" }      # Note: \n,$/ value depends on the platform
      }
      my $len_delim = length $delim;
  
      my ($got);
      my $reply = '';
  
      # If we have OpenSSL 0.9.6a or later, we can use SSL_peek to
      # speed things up.
      # N.B. 0.9.6a has security problems, so the support for
      #      anything earlier than 0.9.6e will be dropped soon.
      if (&Net::SSLeay::OPENSSL_VERSION_NUMBER >= 0x0090601f) {
  	$max_length = 2000000000 unless (defined $max_length);
  	my ($pending, $peek_length, $found, $done);
  	while (blength($reply) < $max_length and !$done) {
  	    #Block if necessary until we get some data
  	    $got = Net::SSLeay::peek($ssl,1);
  	    last if print_errs('SSL_peek');
  
  	    $pending = Net::SSLeay::pending($ssl) + blength($reply);
  	    $peek_length = ($pending > $max_length) ? $max_length : $pending;
  	    $peek_length -= blength($reply);
  	    $got = Net::SSLeay::peek($ssl, $peek_length);
  	    last if print_errs('SSL_peek');
  	    $peek_length = blength($got);
  
  	    #$found = index($got, $delim);  # Old and broken
  
  	    # the delimiter may be split across two gets, so we prepend
  	    # a little from the last get onto this one before we check
  	    # for a match
  	    my $match;
  	    if(blength($reply) >= blength($delim) - 1) {
  		#if what we've read so far is greater or equal
  		#in length of what we need to prepatch
  		$match = substr $reply, blength($reply) - blength($delim) + 1;
  	    } else {
  		$match = $reply;
  	    }
  
  	    $match .= $got;
  	    $found = index($match, $delim);
  
  	    if ($found > -1) {
  		#$got = Net::SSLeay::read($ssl, $found+$len_delim);
  		#read up to the end of the delimiter
  		$got = Net::SSLeay::read($ssl,
  					 $found + $len_delim
  					 - ((blength($match)) - (blength($got))));
  		$done = 1;
  	    } else {
  		$got = Net::SSLeay::read($ssl, $peek_length);
  		$done = 1 if ($peek_length == $max_length - blength($reply));
  	    }
  
  	    last if print_errs('SSL_read');
  	    debug_read(\$reply, \$got) if $trace>1;
  	    last if $got eq '';
  	    $reply .= $got;
  	}
      } else {
  	while (!defined $max_length || length $reply < $max_length) {
  	    $got = Net::SSLeay::read($ssl,1);  # one by one
  	    last if print_errs('SSL_read');
  	    debug_read(\$reply, \$got) if $trace>1;
  	    last if $got eq '';
  	    $reply .= $got;
  	    last if $len_delim
  		&& substr($reply, blength($reply)-$len_delim) eq $delim;
  	}
      }
      return $reply;
  }
  
  sub tcp_read_until {
      my ($delim, $max_length) = @_;
  
      # guess the delim string if missing
      if ( ! defined $delim ) {
        if ( defined $/ && length $/  ) { $delim = $/ }
        else { $delim = "\n" }      # Note: \n,$/ value depends on the platform
      }
      my $len_delim = length $delim;
  
      my ($n,$got);
      my $reply = '';
  
      while (!defined $max_length || length $reply < $max_length) {
  	$n = sysread(SSLCAT_S, $got, 1);  # one by one
  	warn "tcp_read_until: $!" if !defined $n;
  	debug_read(\$reply, \$got) if $trace>1;
  	last if !$n;  # EOF
  	$reply .= $got;
  	last if $len_delim
  	    && substr($reply, blength($reply)-$len_delim) eq $delim;
      }
      return $reply;
  }
  
  # ssl_read_CRLF($ssl [, $max_length])
  sub ssl_read_CRLF ($;$) { ssl_read_until($_[0], $CRLF, $_[1]) }
  sub tcp_read_CRLF { tcp_read_until($CRLF, $_[0]) }
  
  # ssl_write_CRLF($ssl, $message) writes $message and appends CRLF
  sub ssl_write_CRLF ($$) {
    # the next line uses less memory but might use more network packets
    return ssl_write_all($_[0], $_[1]) + ssl_write_all($_[0], $CRLF);
  
    # the next few lines do the same thing at the expense of memory, with
    # the chance that it will use less packets, since CRLF is in the original
    # message and won't be sent separately.
  
    #my $data_ref;
    #if (ref $_[1]) { $data_ref = $_[1] }
    # else { $data_ref = \$_[1] }
    #my $message = $$data_ref . $CRLF;
    #return ssl_write_all($_[0], \$message);
  }
  
  sub tcp_write_CRLF {
    # the next line uses less memory but might use more network packets
    return tcp_write_all($_[0]) + tcp_write_all($CRLF);
  
    # the next few lines do the same thing at the expense of memory, with
    # the chance that it will use less packets, since CRLF is in the original
    # message and won't be sent separately.
  
    #my $data_ref;
    #if (ref $_[1]) { $data_ref = $_[1] }
    # else { $data_ref = \$_[1] }
    #my $message = $$data_ref . $CRLF;
    #return tcp_write_all($_[0], \$message);
  }
  
  ### Quickly print out with whom we're talking
  
  sub dump_peer_certificate ($) {
      my ($ssl) = @_;
      my $cert = get_peer_certificate($ssl);
      return if print_errs('get_peer_certificate');
      print "no cert defined\n" if !defined($cert);
      # Cipher=NONE with empty cert fix
      if (!defined($cert) || ($cert == 0)) {
  	warn "cert = `$cert'\n" if $trace;
  	return "Subject Name: undefined\nIssuer  Name: undefined\n";
      } else {
  	my $x = 'Subject Name: '
  	    . X509_NAME_oneline(X509_get_subject_name($cert)) . "\n"
  		. 'Issuer  Name: '
  		    . X509_NAME_oneline(X509_get_issuer_name($cert))  . "\n";
  	Net::SSLeay::X509_free($cert);
  	return $x;
      }
  }
  
  ### Arrange some randomness for eay PRNG
  
  sub randomize (;$$$) {
      my ($rn_seed_file, $seed, $egd_path) = @_;
      my $rnsf = defined($rn_seed_file) && -r $rn_seed_file;
  
  	$egd_path = '';
      $egd_path = $ENV{'EGD_PATH'} if $ENV{'EGD_PATH'};
  
      RAND_seed(rand() + $$);  # Stir it with time and pid
  
      unless ($rnsf || -r $Net::SSLeay::random_device || $seed || -S $egd_path) {
  	my $poll_retval = Net::SSLeay::RAND_poll();
  	warn "Random number generator not seeded!!!" if $trace && !$poll_retval;
      }
  
      RAND_load_file($rn_seed_file, -s _) if $rnsf;
      RAND_seed($seed) if $seed;
      RAND_seed($ENV{RND_SEED}) if $ENV{RND_SEED};
      RAND_load_file($Net::SSLeay::random_device, $Net::SSLeay::how_random/8)
  	if -r $Net::SSLeay::random_device;
  }
  
  sub new_x_ctx {
      if ($ssl_version == 2)  {
  	unless (exists &Net::SSLeay::CTX_v2_new) {
  	    warn "ssl_version has been set to 2, but this version of OpenSSL has been compiled without SSLv2 support";
  	    return undef;
  	}
  	$ctx = CTX_v2_new();
      }
      elsif ($ssl_version == 3)  { $ctx = CTX_v3_new(); }
      elsif ($ssl_version == 10) { $ctx = CTX_tlsv1_new(); }
      elsif ($ssl_version == 11) {
  	unless (exists &Net::SSLeay::CTX_tlsv1_1_new) {
  	    warn "ssl_version has been set to 11, but this version of OpenSSL has been compiled without TLSv1.1 support";
  	    return undef;
  	}
          $ctx = CTX_tlsv1_1_new;
      }
      elsif ($ssl_version == 12) {
  	unless (exists &Net::SSLeay::CTX_tlsv1_2_new) {
  	    warn "ssl_version has been set to 12, but this version of OpenSSL has been compiled without TLSv1.2 support";
  	    return undef;
  	}
          $ctx = CTX_tlsv1_2_new;
      }
      else                       { $ctx = CTX_new(); }
      return $ctx;
  }
  
  ###
  ### Standard initialisation. Initialise the ssl library in the usual way
  ###  at most once. Override this if you need differnet initialisation
  ###  SSLeay_add_ssl_algorithms is also protected against multiple runs in SSLeay.xs
  ###  and is also mutex protected in threading perls
  ###
  
  my $library_initialised;
  sub initialize
  {
      if (!$library_initialised)
      {
  	load_error_strings();         # Some bloat, but I'm after ease of use
  	SSLeay_add_ssl_algorithms();  # and debuggability.
  	randomize();
  	$library_initialised++;
      }
  }
  
  ###
  ### Basic request - response primitive (don't use for https)
  ###
  
  sub sslcat { # address, port, message, $crt, $key --> reply / (reply,errs,cert)
      my ($dest_serv, $port, $out_message, $crt_path, $key_path) = @_;
      my ($ctx, $ssl, $got, $errs, $written);
  
      ($got, $errs) = open_proxy_tcp_connection($dest_serv, $port);
      return (wantarray ? (undef, $errs) : undef) unless $got;
  
      ### Do SSL negotiation stuff
  
      warn "Creating SSL $ssl_version context...\n" if $trace>2;
      initialize(); # Will init at most once
  
      $ctx = new_x_ctx();
      goto cleanup2 if $errs = print_errs('CTX_new') or !$ctx;
  
      CTX_set_options($ctx, &OP_ALL);
      goto cleanup2 if $errs = print_errs('CTX_set_options');
  
      warn "Cert `$crt_path' given without key" if $crt_path && !$key_path;
      set_cert_and_key($ctx, $crt_path, $key_path) if $crt_path;
  
      warn "Creating SSL connection (context was '$ctx')...\n" if $trace>2;
      $ssl = new($ctx);
      goto cleanup if $errs = print_errs('SSL_new') or !$ssl;
  
      warn "Setting fd (ctx $ctx, con $ssl)...\n" if $trace>2;
      set_fd($ssl, fileno(SSLCAT_S));
      goto cleanup if $errs = print_errs('set_fd');
  
      warn "Entering SSL negotiation phase...\n" if $trace>2;
  
      if ($trace>2) {
  	my $i = 0;
  	my $p = '';
  	my $cipher_list = 'Cipher list: ';
  	$p=Net::SSLeay::get_cipher_list($ssl,$i);
  	$cipher_list .= $p if $p;
  	do {
  	    $i++;
  	    $cipher_list .= ', ' . $p if $p;
  	    $p=Net::SSLeay::get_cipher_list($ssl,$i);
  	} while $p;
  	$cipher_list .= '\n';
  	warn $cipher_list;
      }
  
      $got = Net::SSLeay::connect($ssl);
      warn "SSLeay connect returned $got\n" if $trace>2;
      goto cleanup if $errs = print_errs('SSL_connect');
  
      my $server_cert = get_peer_certificate($ssl);
      print_errs('get_peer_certificate');
      if ($trace>1) {
  	warn "Cipher `" . get_cipher($ssl) . "'\n";
  	print_errs('get_ciper');
  	warn dump_peer_certificate($ssl);
      }
  
      ### Connected. Exchange some data (doing repeated tries if necessary).
  
      warn "sslcat $$: sending " . blength($out_message) . " bytes...\n"
  	if $trace==3;
      warn "sslcat $$: sending `$out_message' (" . blength($out_message)
  	. " bytes)...\n" if $trace>3;
      ($written, $errs) = ssl_write_all($ssl, $out_message);
      goto cleanup unless $written;
  
      sleep $slowly if $slowly;  # Closing too soon can abort broken servers
      CORE::shutdown SSLCAT_S, 1;  # Half close --> No more output, send EOF to server
  
      warn "waiting for reply...\n" if $trace>2;
      ($got, $errs) = ssl_read_all($ssl);
      warn "Got " . blength($got) . " bytes.\n" if $trace==3;
      warn "Got `$got' (" . blength($got) . " bytes)\n" if $trace>3;
  
  cleanup:
      free ($ssl);
      $errs .= print_errs('SSL_free');
  cleanup2:
      CTX_free ($ctx);
      $errs .= print_errs('CTX_free');
      close SSLCAT_S;
      return wantarray ? ($got, $errs, $server_cert) : $got;
  }
  
  sub tcpcat { # address, port, message, $crt, $key --> reply / (reply,errs,cert)
      my ($dest_serv, $port, $out_message) = @_;
      my ($got, $errs, $written);
  
      ($got, $errs) = open_proxy_tcp_connection($dest_serv, $port);
      return (wantarray ? (undef, $errs) : undef) unless $got;
  
      ### Connected. Exchange some data (doing repeated tries if necessary).
  
      warn "tcpcat $$: sending " . blength($out_message) . " bytes...\n"
  	if $trace==3;
      warn "tcpcat $$: sending `$out_message' (" . blength($out_message)
  	. " bytes)...\n" if $trace>3;
      ($written, $errs) = tcp_write_all($out_message);
      goto cleanup unless $written;
  
      sleep $slowly if $slowly;  # Closing too soon can abort broken servers
      CORE::shutdown SSLCAT_S, 1;  # Half close --> No more output, send EOF to server
  
      warn "waiting for reply...\n" if $trace>2;
      ($got, $errs) = tcp_read_all();
      warn "Got " . blength($got) . " bytes.\n" if $trace==3;
      warn "Got `$got' (" . blength($got) . " bytes)\n" if $trace>3;
  
  cleanup:
      close SSLCAT_S;
      return wantarray ? ($got, $errs) : $got;
  }
  
  sub tcpxcat {
      my ($usessl, $site, $port, $req, $crt_path, $key_path) = @_;
      if ($usessl) {
  	return sslcat($site, $port, $req, $crt_path, $key_path);
      } else {
  	return tcpcat($site, $port, $req);
      }
  }
  
  ###
  ### Basic request - response primitive, this is different from sslcat
  ###                 because this does not shutdown the connection.
  ###
  
  sub https_cat { # address, port, message --> returns reply / (reply,errs,cert)
      my ($dest_serv, $port, $out_message, $crt_path, $key_path) = @_;
      my ($ctx, $ssl, $got, $errs, $written);
  
      ($got, $errs) = open_proxy_tcp_connection($dest_serv, $port);
      return (wantarray ? (undef, $errs) : undef) unless $got;
  
      ### Do SSL negotiation stuff
  
      warn "Creating SSL $ssl_version context...\n" if $trace>2;
      initialize();
  
      $ctx = new_x_ctx();
      goto cleanup2 if $errs = print_errs('CTX_new') or !$ctx;
  
      CTX_set_options($ctx, &OP_ALL);
      goto cleanup2 if $errs = print_errs('CTX_set_options');
  
      warn "Cert `$crt_path' given without key" if $crt_path && !$key_path;
      set_cert_and_key($ctx, $crt_path, $key_path) if $crt_path;
  
      warn "Creating SSL connection (context was '$ctx')...\n" if $trace>2;
      $ssl = new($ctx);
      goto cleanup if $errs = print_errs('SSL_new') or !$ssl;
  
      warn "Setting fd (ctx $ctx, con $ssl)...\n" if $trace>2;
      set_fd($ssl, fileno(SSLCAT_S));
      goto cleanup if $errs = print_errs('set_fd');
  
      warn "Entering SSL negotiation phase...\n" if $trace>2;
  
      if ($trace>2) {
  	my $i = 0;
  	my $p = '';
  	my $cipher_list = 'Cipher list: ';
  	$p=Net::SSLeay::get_cipher_list($ssl,$i);
  	$cipher_list .= $p if $p;
  	do {
  	    $i++;
  	    $cipher_list .= ', ' . $p if $p;
  	    $p=Net::SSLeay::get_cipher_list($ssl,$i);
  	} while $p;
  	$cipher_list .= '\n';
  	warn $cipher_list;
      }
  
      $got = Net::SSLeay::connect($ssl);
      warn "SSLeay connect failed" if $trace>2 && $got==0;
      goto cleanup if $errs = print_errs('SSL_connect');
  
      my $server_cert = get_peer_certificate($ssl);
      print_errs('get_peer_certificate');
      if ($trace>1) {
  	warn "Cipher `" . get_cipher($ssl) . "'\n";
  	print_errs('get_ciper');
  	warn dump_peer_certificate($ssl);
      }
  
      ### Connected. Exchange some data (doing repeated tries if necessary).
  
      warn "https_cat $$: sending " . blength($out_message) . " bytes...\n"
  	if $trace==3;
      warn "https_cat $$: sending `$out_message' (" . blength($out_message)
  	. " bytes)...\n" if $trace>3;
      ($written, $errs) = ssl_write_all($ssl, $out_message);
      goto cleanup unless $written;
  
      warn "waiting for reply...\n" if $trace>2;
      ($got, $errs) = ssl_read_all($ssl);
      warn "Got " . blength($got) . " bytes.\n" if $trace==3;
      warn "Got `$got' (" . blength($got) . " bytes)\n" if $trace>3;
  
  cleanup:
      free ($ssl);
      $errs .= print_errs('SSL_free');
  cleanup2:
      CTX_free ($ctx);
      $errs .= print_errs('CTX_free');
      close SSLCAT_S;
      return wantarray ? ($got, $errs, $server_cert) : $got;
  }
  
  sub http_cat { # address, port, message --> returns reply / (reply,errs,cert)
      my ($dest_serv, $port, $out_message) = @_;
      my ($got, $errs, $written);
  
      ($got, $errs) = open_proxy_tcp_connection($dest_serv, $port);
      return (wantarray ? (undef, $errs) : undef) unless $got;
  
      ### Connected. Exchange some data (doing repeated tries if necessary).
  
      warn "http_cat $$: sending " . blength($out_message) . " bytes...\n"
  	if $trace==3;
      warn "http_cat $$: sending `$out_message' (" . blength($out_message)
  	. " bytes)...\n" if $trace>3;
      ($written, $errs) = tcp_write_all($out_message);
      goto cleanup unless $written;
  
      warn "waiting for reply...\n" if $trace>2;
      ($got, $errs) = tcp_read_all();
      warn "Got " . blength($got) . " bytes.\n" if $trace==3;
      warn "Got `$got' (" . blength($got) . " bytes)\n" if $trace>3;
  
  cleanup:
      close SSLCAT_S;
      return wantarray ? ($got, $errs) : $got;
  }
  
  sub httpx_cat {
      my ($usessl, $site, $port, $req, $crt_path, $key_path) = @_;
      warn "httpx_cat: usessl=$usessl ($site:$port)" if $trace;
      if ($usessl) {
  	return https_cat($site, $port, $req, $crt_path, $key_path);
      } else {
  	return http_cat($site, $port, $req);
      }
  }
  
  ###
  ### Easy set up of private key and certificate
  ###
  
  sub set_cert_and_key ($$$) {
      my ($ctx, $cert_path, $key_path) = @_;
      my $errs = '';
      # Following will ask password unless private key is not encrypted
      CTX_use_PrivateKey_file ($ctx, $key_path, &FILETYPE_PEM);
      $errs .= print_errs("private key `$key_path' ($!)");
      CTX_use_certificate_file ($ctx, $cert_path, &FILETYPE_PEM);
      $errs .= print_errs("certificate `$cert_path' ($!)");
      return wantarray ? (undef, $errs) : ($errs eq '');
  }
  
  ### Old deprecated API
  
  sub set_server_cert_and_key ($$$) { &set_cert_and_key }
  
  ### Set up to use web proxy
  
  sub set_proxy ($$;**) {
      ($proxyhost, $proxyport, $proxyuser, $proxypass) = @_;
      require MIME::Base64 if $proxyuser;
      $proxyauth = $proxyuser
           ? $CRLF . 'Proxy-authorization: Basic '
  	 . MIME::Base64::encode("$proxyuser:$proxypass", '')
  	 : '';
  }
  
  ###
  ### Easy https manipulation routines
  ###
  
  sub make_form {
      my (@fields) = @_;
      my $form;
      while (@fields) {
  	my ($name, $data) = (shift(@fields), shift(@fields));
  	$data =~ s/([^\w\-.\@\$ ])/sprintf("%%%2.2x",ord($1))/gse;
      	$data =~ tr[ ][+];
  	$form .= "$name=$data&";
      }
      chop $form;
      return $form;
  }
  
  sub make_headers {
      my (@headers) = @_;
      my $headers;
      while (@headers) {
  	my $header = shift(@headers);
  	my $value = shift(@headers);
  	$header =~ s/:$//;
  	$value =~ s/\x0d?\x0a$//; # because we add it soon, see below
  	$headers .= "$header: $value$CRLF";
      }
      return $headers;
  }
  
  sub do_httpx3 {
      my ($method, $usessl, $site, $port, $path, $headers,
  	$content, $mime_type, $crt_path, $key_path) = @_;
      my ($response, $page, $h,$v);
  
      my $len = blength($content);
      if ($len) {
  	$mime_type = "application/x-www-form-urlencoded" unless $mime_type;
  	$content = "Content-Type: $mime_type$CRLF"
  	    . "Content-Length: $len$CRLF$CRLF$content";
      } else {
  	$content = "$CRLF$CRLF";
      }
      my $req = "$method $path HTTP/1.0$CRLF";
      unless (defined $headers && $headers =~ /^Host:/m) {
          $req .= "Host: $site";
          unless (($port == 80 && !$usessl) || ($port == 443 && $usessl)) {
              $req .= ":$port";
          }
          $req .= $CRLF;
  	}
      $req .= (defined $headers ? $headers : '') . "Accept: */*$CRLF$content";
  
      warn "do_httpx3($method,$usessl,$site:$port)" if $trace;
      my ($http, $errs, $server_cert)
  	= httpx_cat($usessl, $site, $port, $req, $crt_path, $key_path);
      return (undef, "HTTP/1.0 900 NET OR SSL ERROR$CRLF$CRLF$errs") if $errs;
  
      $http = '' if !defined $http;
      ($headers, $page) = split /\s?\n\s?\n/, $http, 2;
      warn "headers >$headers< page >>$page<< http >>>$http<<<" if $trace>1;
      ($response, $headers) = split /\s?\n/, $headers, 2;
      return ($page, $response, $headers, $server_cert);
  }
  
  sub do_https3 { splice(@_,1,0) = 1; do_httpx3; }  # Legacy undocumented
  
  ### do_https2() is a legacy version in the sense that it is unable
  ### to return all instances of duplicate headers.
  
  sub do_httpx2 {
      my ($page, $response, $headers, $server_cert) = &do_httpx3;
      X509_free($server_cert) if defined $server_cert;
      return ($page, $response, defined $headers ?
  	    map( { ($h,$v)=/^(\S+)\:\s*(.*)$/; (uc($h),$v); }
  		split(/\s?\n/, $headers)
  		) : ()
  	    );
  }
  
  sub do_https2 { splice(@_,1,0) = 1; do_httpx2; }  # Legacy undocumented
  
  ### Returns headers as a hash where multiple instances of same header
  ### are handled correctly.
  
  sub do_httpx4 {
      my ($page, $response, $headers, $server_cert) = &do_httpx3;
      my %hr = ();
      for my $hh (split /\s?\n/, $headers) {
  	my ($h,$v) = ($hh =~ /^(\S+)\:\s*(.*)$/);
  	push @{$hr{uc($h)}}, $v;
      }
      return ($page, $response, \%hr, $server_cert);
  }
  
  sub do_https4 { splice(@_,1,0) = 1; do_httpx4; }  # Legacy undocumented
  
  # https
  
  sub get_https  { do_httpx2(GET  => 1, @_) }
  sub post_https { do_httpx2(POST => 1, @_) }
  sub put_https  { do_httpx2(PUT  => 1, @_) }
  sub head_https { do_httpx2(HEAD => 1, @_) }
  
  sub get_https3  { do_httpx3(GET  => 1, @_) }
  sub post_https3 { do_httpx3(POST => 1, @_) }
  sub put_https3  { do_httpx3(PUT  => 1, @_) }
  sub head_https3 { do_httpx3(HEAD => 1, @_) }
  
  sub get_https4  { do_httpx4(GET  => 1, @_) }
  sub post_https4 { do_httpx4(POST => 1, @_) }
  sub put_https4  { do_httpx4(PUT  => 1, @_) }
  sub head_https4 { do_httpx4(HEAD => 1, @_) }
  
  # http
  
  sub get_http  { do_httpx2(GET  => 0, @_) }
  sub post_http { do_httpx2(POST => 0, @_) }
  sub put_http  { do_httpx2(PUT  => 0, @_) }
  sub head_http { do_httpx2(HEAD => 0, @_) }
  
  sub get_http3  { do_httpx3(GET  => 0, @_) }
  sub post_http3 { do_httpx3(POST => 0, @_) }
  sub put_http3  { do_httpx3(PUT  => 0, @_) }
  sub head_http3 { do_httpx3(HEAD => 0, @_) }
  
  sub get_http4  { do_httpx4(GET  => 0, @_) }
  sub post_http4 { do_httpx4(POST => 0, @_) }
  sub put_http4  { do_httpx4(PUT  => 0, @_) }
  sub head_http4 { do_httpx4(HEAD => 0, @_) }
  
  # Either https or http
  
  sub get_httpx  { do_httpx2(GET  => @_) }
  sub post_httpx { do_httpx2(POST => @_) }
  sub put_httpx  { do_httpx2(PUT  => @_) }
  sub head_httpx { do_httpx2(HEAD => @_) }
  
  sub get_httpx3  { do_httpx3(GET  => @_) }
  sub post_httpx3 { do_httpx3(POST => @_) }
  sub put_httpx3  { do_httpx3(PUT  => @_) }
  sub head_httpx3 { do_httpx3(HEAD => @_) }
  
  sub get_httpx4  { do_httpx4(GET  => @_) }
  sub post_httpx4 { do_httpx4(POST => @_) }
  sub put_httpx4  { do_httpx4(PUT  => @_) }
  sub head_httpx4 { do_httpx4(HEAD => @_) }
  
  ### Legacy, don't use
  # ($page, $respone_or_err, %headers) = do_https(...);
  
  sub do_https {
      my ($site, $port, $path, $method, $headers,
  	$content, $mime_type, $crt_path, $key_path) = @_;
  
      do_https2($method, $site, $port, $path, $headers,
  	     $content, $mime_type, $crt_path, $key_path);
  }
  
  1;
  __END__
  
DARWIN-2LEVEL_NET_SSLEAY

$fatpacked{"darwin-2level/Net/SSLeay/Handle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_NET_SSLEAY_HANDLE';
  package Net::SSLeay::Handle;
  
  require 5.005_03;
  use strict;
  
  use Socket;
  use Net::SSLeay;
  
  require Exporter;
  
  =head1 NAME
  
  Net::SSLeay::Handle - Perl module that lets SSL (HTTPS) sockets be
  handled as standard file handles.
  
  =head1 SYNOPSIS
  
    use Net::SSLeay::Handle qw/shutdown/;
    my ($host, $port) = ("localhost", 443);
  
    tie(*SSL, "Net::SSLeay::Handle", $host, $port);
  
    print SSL "GET / HTTP/1.0\r\n";
    shutdown(\*SSL, 1);
    print while (<SSL>);
    close SSL;                                                       
  
  =head1 DESCRIPTION
  
  Net::SSLeay::Handle allows you to request and receive HTTPS web pages
  using "old-fashion" file handles as in:
  
      print SSL "GET / HTTP/1.0\r\n";
  
  and
  
      print while (<SSL>);
  
  If you export the shutdown routine, then the only extra code that
  you need to add to your program is the tie function as in:
  
      my $socket;
      if ($scheme eq "https") {
          tie(*S2, "Net::SSLeay::Handle", $host, $port);
          $socket = \*S2;
      else {
          $socket = Net::SSLeay::Handle->make_socket($host, $port);
      }
      print $socket $request_headers;
      ... 
  
  =cut
  
  use vars qw(@ISA @EXPORT_OK $VERSION);
  @ISA = qw(Exporter);
  @EXPORT_OK = qw(shutdown);
  $VERSION = '0.61';
  
  my $Initialized;       #-- only _initialize() once
  my $Debug = 0;         #-- pretty hokey
  my %Glob_Ref;          #-- used to make unique \*S names for versions < 5.6
  
  #== Tie Handle Methods ========================================================
  #
  # see perldoc perltie for details.
  #
  #==============================================================================
  
  sub TIEHANDLE {
      my ($class, $socket, $port) = @_;
      $Debug > 10 and print "TIEHANDLE(@{[join ', ', @_]})\n";
  
      ref $socket eq "GLOB" or $socket = $class->make_socket($socket, $port);
  
      $class->_initialize();
  
      my $ctx = Net::SSLeay::CTX_new() or die_now("Failed to create SSL_CTX $!");
      my $ssl = Net::SSLeay::new($ctx) or die_now("Failed to create SSL $!");
  
      my $fileno = fileno($socket);
  
    Net::SSLeay::set_fd($ssl, $fileno);   # Must use fileno
  
      my $resp = Net::SSLeay::connect($ssl);
  
      $Debug and print "Cipher '" . Net::SSLeay::get_cipher($ssl) . "'\n";
  
  	my $self = bless {
          ssl    => $ssl, 
          ctx    => $ctx,
          socket => $socket,
          fileno => $fileno,
      }, $class;
  
      return $self;
  }
  
  sub PRINT {
      my $self = shift;
  
      my $ssl  = _get_ssl($self);
      my $resp = 0;
      for my $msg (@_) {
          defined $msg or last;
          $resp = Net::SSLeay::write($ssl, $msg) or last;
      }
      return $resp;
  }
  
  sub READLINE {
      my $self = shift;
      my $ssl  = _get_ssl($self);
  	if (wantarray) {
  		my @lines;
  		while (my $line = Net::SSLeay::ssl_read_until($ssl)) {
  			push @lines, $line;
  		}
  		return @lines;
  	} else {
  		my $line = Net::SSLeay::ssl_read_until($ssl); 
  		return $line ? $line : undef;
  	}
  }
  
  sub READ {
      my ($self, $buf, $len, $offset) = \ (@_);
      my $ssl = _get_ssl($$self);
      defined($$offset) or 
        return length($$buf = Net::SSLeay::ssl_read_all($ssl, $$len));
  
      defined(my $read = Net::SSLeay::ssl_read_all($ssl, $$len))
        or return undef;
  
      my $buf_len = length($$buf);
      $$offset > $buf_len and $$buf .= chr(0) x ($$offset - $buf_len);
      substr($$buf, $$offset) = $read;
      return length($read);
  }
  
  sub WRITE {
      my $self = shift;
      my ($buf, $len, $offset) = @_;
      $offset = 0 unless defined $offset;
  
      # Return number of characters written.
      my $ssl  = $self->_get_ssl();
      return $len if Net::SSLeay::write($ssl, substr($buf, $offset, $len));
      return undef;
  }
  
  sub CLOSE {
      my $self = shift;
      my $fileno = $self->{fileno};
      $Debug > 10 and print "close($fileno)\n";
      Net::SSLeay::free ($self->{ssl});
      Net::SSLeay::CTX_free ($self->{ctx});
      close $self->{socket};
  }
  
  sub FILENO  { $_[0]->{fileno} }
  
  
  =head1 FUNCTIONS
  
  =over
  
  =item shutdown
  
    shutdown(\*SOCKET, $mode)
  
  Calls to the main shutdown() don't work with tied sockets created with this
  module.  This shutdown should be able to distinquish between tied and untied
  sockets and do the right thing.
  
  =cut
  
  sub shutdown {
      my ($obj, @params) = @_;
  
  	my $socket = UNIVERSAL::isa($obj, 'Net::SSLeay::Handle') ?
  		$obj->{socket} : $obj;
      return shutdown($socket, @params);
  }
  
  =item debug
  
    my $debug = Net::SSLeay::Handle->debug()
    Net::SSLeay::Handle->debug(1)
  
  Get/set debugging mode. Always returns the debug value before the function call.
  if an additional argument is given the debug option will be set to this value.
  
  =cut
  
  sub debug {
      my ($class, $debug) = @_;
      my $old_debug = $Debug;
      @_ >1 and $Debug = $debug || 0;
      return $old_debug;
  }
  
  #=== Internal Methods =========================================================
  
  =item make_socket
  
    my $sock = Net::SSLeay::Handle->make_socket($host, $port);
  
  Creates a socket that is connected to $post using $port. It uses
  $Net::SSLeay::proxyhost and proxyport if set and authentificates itself against
  this proxy depending on $Net::SSLeay::proxyauth. It also turns autoflush on for
  the created socket.
  
  =cut
  
  sub make_socket {
      my ($class, $host, $port) = @_;
      $Debug > 10 and print "_make_socket(@{[join ', ', @_]})\n";
      $host ||= 'localhost';
      $port ||= 443;
  
      my $phost = $Net::SSLeay::proxyhost;
      my $pport = $Net::SSLeay::proxyhost ? $Net::SSLeay::proxyport : $port;
  
      my $dest_ip     = gethostbyname($phost || $host);
      my $host_params = sockaddr_in($pport, $dest_ip);
      my $socket = $^V ? undef : $class->_glob_ref("$host:$port");
      
      socket($socket, &PF_INET(), &SOCK_STREAM(), 0) or die "socket: $!";
      connect($socket, $host_params)                 or die "connect: $!";
  
      my $old_select = select($socket); $| = 1; select($old_select);
      $phost and do {
          my $auth = $Net::SSLeay::proxyauth;
          my $CRLF = $Net::SSLeay::CRLF;
          print $socket "CONNECT $host:$port HTTP/1.0$auth$CRLF$CRLF";
          my $line = <$socket>;
      };
      return $socket;
  }
  
  =back
  
  =cut
  
  #--- _glob_ref($strings) ------------------------------------------------------
  #
  # Create a unique namespace name and return a glob ref to it.  Would be great
  # to use the fileno but need this before we get back the fileno.
  # NEED TO LOCK THIS ROUTINE IF USING THREADS. (but it is only used for
  # versions < 5.6 :)
  #------------------------------------------------------------------------------
  
  sub _glob_ref {
      my $class = shift;
      my $preamb = join("", @_) || "_glob_ref";
      my $num = ++$Glob_Ref{$preamb};
      my $name = "$preamb:$num";
      no strict 'refs';
      my $glob_ref = \*$name;
      use strict 'refs';
  
      $Debug and do {
          print "GLOB_REF $preamb\n";
          while (my ($k, $v) = each %Glob_Ref) {print "$k = $v\n"} 
          print "\n";
      };
  
      return $glob_ref;
  }
  
  sub _initialize {
      $Initialized++ and return;
    Net::SSLeay::load_error_strings();
    Net::SSLeay::SSLeay_add_ssl_algorithms();
    Net::SSLeay::randomize();
  }
  
  sub __dummy {
      my $host = $Net::SSLeay::proxyhost;
      my $port = $Net::SSLeay::proxyport;
      my $auth = $Net::SSLeay::proxyauth;
  }
  
  #--- _get_self($socket) -------------------------------------------------------
  # Returns a hash containing attributes for $socket (= \*SOMETHING) based
  # on fileno($socket).  Will return undef if $socket was not created here.
  #------------------------------------------------------------------------------
  
  sub _get_self { return $_[0]; }
  
  #--- _get_ssl($socket) --------------------------------------------------------
  # Returns a the "ssl" attribute for $socket (= \*SOMETHING) based
  # on fileno($socket).  Will cause a warning and return undef if $socket was not
  # created here.
  #------------------------------------------------------------------------------
  
  sub _get_ssl {
      return $_[0]->{ssl};
  }
  
  1;
  
  __END__
  
  =head2 USING EXISTING SOCKETS
  
  One of the motivations for writing this module was to avoid
  duplicating socket creation code (which is mostly error handling).
  The calls to tie() above where it is passed a $host and $port is
  provided for convenience testing.  If you already have a socket
  connected to the right host and port, S1, then you can do something
  like:
  
      my $socket \*S1;
      if ($scheme eq "https") {
          tie(*S2, "Net::SSLeay::Handle", $socket);
          $socket = \*S2;
      }
      my $last_sel = select($socket); $| = 1; select($last_sel);
      print $socket $request_headers;
      ... 
  
  Note: As far as I know you must be careful with the globs in the tie()
  function.  The first parameter must be a glob (*SOMETHING) and the
  last parameter must be a reference to a glob (\*SOMETHING_ELSE) or a
  scaler that was assigned to a reference to a glob (as in the example
  above)
  
  Also, the two globs must be different.  When I tried to use the same
  glob, I got a core dump.
  
  =head2 EXPORT
  
  None by default.
  
  You can export the shutdown() function.
  
  It is suggested that you do export shutdown() or use the fully
  qualified Net::SSLeay::Handle::shutdown() function to shutdown SSL
  sockets.  It should be smart enough to distinguish between SSL and
  non-SSL sockets and do the right thing.
  
  =head1 EXAMPLES
  
    use Net::SSLeay::Handle qw/shutdown/;
    my ($host, $port) = ("localhost", 443);
  
    tie(*SSL, "Net::SSLeay::Handle", $host, $port);
  
    print SSL "GET / HTTP/1.0\r\n";
    shutdown(\*SSL, 1);
    print while (<SSL>);
    close SSL; 
  
  =head1 TODO
  
  Better error handling.  Callback routine?
  
  =head1 CAVEATS
  
  Tying to a file handle is a little tricky (for me at least).
  
  The first parameter to tie() must be a glob (*SOMETHING) and the last
  parameter must be a reference to a glob (\*SOMETHING_ELSE) or a scaler
  that was assigned to a reference to a glob ($s = \*SOMETHING_ELSE).
  Also, the two globs must be different.  When I tried to use the same
  glob, I got a core dump.
  
  I was able to associate attributes to globs created by this module
  (like *SSL above) by making a hash of hashes keyed by the file head1.
  
  Support for old perls may not be 100%. If in trouble try 5.6.0 or
  newer.
  
  =head1 CHANGES
  
  Please see Net-SSLeay-Handle-0.50/Changes file.
  
  =head1 KNOWN BUGS
  
  If you let this module construct sockets for you with Perl versions
  below v.5.6 then there is a slight memory leak.  Other upgrade your
  Perl, or create the sockets yourself.  The leak was created to let
  these older versions of Perl access more than one Handle at a time.
  
  =head1 AUTHOR
  
  Jim Bowlin jbowlin@linklint.org
  
  =head1 SEE ALSO
  
  Net::SSLeay, perl(1), http://openssl.org/
  
  =cut
DARWIN-2LEVEL_NET_SSLEAY_HANDLE

$fatpacked{"ojo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OJO';
  package ojo;
  use Mojo::Base -strict;
  
  use Benchmark qw(timeit timestr :hireswallclock);
  use Mojo::ByteStream 'b';
  use Mojo::Collection 'c';
  use Mojo::DOM;
  use Mojo::File 'path';
  use Mojo::JSON 'j';
  use Mojo::Util qw(dumper monkey_patch);
  
  # Silent one-liners
  $ENV{MOJO_LOG_LEVEL} ||= 'fatal';
  
  sub import {
  
    # Mojolicious::Lite
    my $caller = caller;
    eval "package $caller; use Mojolicious::Lite; 1" or die $@;
    Mojo::Base->import(-strict, $] < 5.020 ? () : (-signatures));
    my $ua = $caller->app->ua;
    $ua->server->app->hook(around_action => sub { local $_ = $_[1]; $_[0]() });
  
    $ua->max_redirects(10) unless defined $ENV{MOJO_MAX_REDIRECTS};
    $ua->proxy->detect unless defined $ENV{MOJO_PROXY};
  
    # The ojo DSL
    monkey_patch $caller,
      a => sub { $caller->can('any')->(@_) and return $ua->server->app },
      b => \&b,
      c => \&c,
      d => sub { $ua->delete(@_)->result },
      f => \&path,
      g => sub { $ua->get(@_)->result },
      h => sub { $ua->head(@_)->result },
      j => \&j,
      n => sub (&@) { say STDERR timestr timeit($_[1] // 1, $_[0]) },
      o => sub { $ua->options(@_)->result },
      p => sub { $ua->post(@_)->result },
      r => \&dumper,
      t => sub { $ua->patch(@_)->result },
      u => sub { $ua->put(@_)->result },
      x => sub { Mojo::DOM->new(@_) };
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  ojo - Fun one-liners with Mojo
  
  =head1 SYNOPSIS
  
    $ perl -Mojo -E 'say g("mojolicious.org")->dom->at("title")->text'
  
  =head1 DESCRIPTION
  
  A collection of automatically exported functions for fun Perl one-liners. Ten
  redirects will be followed by default, you can change this behavior with the
  C<MOJO_MAX_REDIRECTS> environment variable.
  
    $ MOJO_MAX_REDIRECTS=0 perl -Mojo -E 'say g("example.com")->code'
  
  Proxy detection is enabled by default, but you can disable it with the
  C<MOJO_PROXY> environment variable.
  
    $ MOJO_PROXY=0 perl -Mojo -E 'say g("example.com")->body'
  
  TLS certificate verification can be disabled with the C<MOJO_INSECURE>
  environment variable.
  
    $ MOJO_INSECURE=1 perl -Mojo -E 'say g("https://127.0.0.1:3000")->body'
  
  Every L<ojo> one-liner is also a L<Mojolicious::Lite> application.
  
    $ perl -Mojo -E 'get "/" => {inline => "%= time"}; app->start' get /
  
  On Perl 5.20+ L<subroutine signatures|perlsub/"Signatures"> will be enabled
  automatically.
  
    $ perl -Mojo -E 'a(sub ($c) { $c->render(text => 'Hello!') })->start' get /
  
  If it is not already defined, the C<MOJO_LOG_LEVEL> environment variable will
  be set to C<fatal>.
  
  =head1 FUNCTIONS
  
  L<ojo> implements the following functions, which are automatically exported.
  
  =head2 a
  
    my $app = a('/hello' => sub { $_->render(json => {hello => 'world'}) });
  
  Create a route with L<Mojolicious::Lite/"any"> and return the current
  L<Mojolicious::Lite> object. The current controller object is also available to
  actions as C<$_>. See also L<Mojolicious::Guides::Tutorial> for more argument
  variations.
  
    $ perl -Mojo -E 'a("/hello" => {text => "Hello Mojo!"})->start' daemon
  
  =head2 b
  
    my $stream = b('lalala');
  
  Turn string into a L<Mojo::ByteStream> object.
  
    $ perl -Mojo -E 'b(g("mojolicious.org")->body)->html_unescape->say'
  
  =head2 c
  
    my $collection = c(1, 2, 3);
  
  Turn list into a L<Mojo::Collection> object.
  
  =head2 d
  
    my $res = d('example.com');
    my $res = d('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = d('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = d('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<DELETE> request with L<Mojo::UserAgent/"delete"> and return resulting
  L<Mojo::Message::Response> object.
  
  =head2 f
  
    my $path = f('/home/sri/foo.txt');
  
  Turn string into a L<Mojo::File> object.
  
    $ perl -Mojo -E 'say r j f("hello.json")->slurp'
  
  =head2 g
  
    my $res = g('example.com');
    my $res = g('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = g('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = g('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<GET> request with L<Mojo::UserAgent/"get"> and return resulting
  L<Mojo::Message::Response> object.
  
    $ perl -Mojo -E 'say g("mojolicious.org")->dom("h1")->map("text")->join("\n")'
  
  =head2 h
  
    my $res = h('example.com');
    my $res = h('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = h('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = h('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<HEAD> request with L<Mojo::UserAgent/"head"> and return resulting
  L<Mojo::Message::Response> object.
  
  =head2 j
  
    my $bytes = j([1, 2, 3]);
    my $bytes = j({foo => 'bar'});
    my $value = j($bytes);
  
  Encode Perl data structure or decode JSON with L<Mojo::JSON/"j">.
  
    $ perl -Mojo -E 'f("hello.json")->spurt(j {hello => "world!"})'
  
  =head2 n
  
    n {...};
    n {...} 100;
  
  Benchmark block and print the results to C<STDERR>, with an optional number of
  iterations, which defaults to C<1>.
  
    $ perl -Mojo -E 'n { say g("mojolicious.org")->code }'
  
  =head2 o
  
    my $res = o('example.com');
    my $res = o('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = o('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = o('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<OPTIONS> request with L<Mojo::UserAgent/"options"> and return
  resulting L<Mojo::Message::Response> object.
  
  =head2 p
  
    my $res = p('example.com');
    my $res = p('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = p('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = p('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<POST> request with L<Mojo::UserAgent/"post"> and return resulting
  L<Mojo::Message::Response> object.
  
  =head2 r
  
    my $perl = r({data => 'structure'});
  
  Dump a Perl data structure with L<Mojo::Util/"dumper">.
  
    perl -Mojo -E 'say r g("example.com")->headers->to_hash'
  
  =head2 t
  
    my $res = t('example.com');
    my $res = t('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = t('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = t('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<PATCH> request with L<Mojo::UserAgent/"patch"> and return resulting
  L<Mojo::Message::Response> object.
  
  =head2 u
  
    my $res = u('example.com');
    my $res = u('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = u('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = u('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<PUT> request with L<Mojo::UserAgent/"put"> and return resulting
  L<Mojo::Message::Response> object.
  
  =head2 x
  
    my $dom = x('<div>Hello!</div>');
  
  Turn HTML/XML input into L<Mojo::DOM> object.
  
    $ perl -Mojo -E 'say x(f("test.html")->slurp)->at("title")->text'
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
OJO

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use Mojo::Base -strict;

use Mojo::Server::Morbo;
use Mojo::Util qw(extract_usage getopt);

getopt
  'b|backend=s' => \$ENV{MOJO_MORBO_BACKEND},
  'h|help'      => \my $help,
  'l|listen=s'  => \my @listen,
  'm|mode=s'    => \$ENV{MOJO_MODE},
  'v|verbose'   => \$ENV{MORBO_VERBOSE},
  'w|watch=s'   => \my @watch;

die extract_usage if $help || !(my $app = shift);
my $morbo = Mojo::Server::Morbo->new;
$morbo->daemon->listen(\@listen) if @listen;
$morbo->backend->watch(\@watch)  if @watch;
$morbo->run($app);

=encoding utf8

=head1 NAME

morbo - Morbo HTTP and WebSocket development server

=head1 SYNOPSIS

  Usage: morbo [OPTIONS] [APPLICATION]

    morbo ./script/my_app
    morbo ./myapp.pl
    morbo -m production -l https://*:443 -l http://[::]:3000 ./myapp.pl
    morbo -l 'https://*:443?cert=./server.crt&key=./server.key' ./myapp.pl
    morbo -w /usr/local/lib -w public -w myapp.conf ./myapp.pl

  Options:
    -b, --backend <name>           Morbo backend to use for reloading, defaults
                                   to "Poll"
    -h, --help                     Show this message
    -l, --listen <location>        One or more locations you want to listen on,
                                   defaults to the value of MOJO_LISTEN or
                                   "http://*:3000"
    -m, --mode <name>              Operating mode for your application,
                                   defaults to the value of
                                   MOJO_MODE/PLACK_ENV or "development"
    -v, --verbose                  Print details about what files changed to
                                   STDOUT
    -w, --watch <directory/file>   One or more directories and files to watch
                                   for changes, defaults to the application
                                   script as well as the "lib" and "templates"
                                   directories in the current working
                                   directory

=head1 DESCRIPTION

Start L<Mojolicious> and L<Mojolicious::Lite> applications with the
L<Mojo::Server::Morbo> web server.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
