#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"HTTP/Message/PSGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_MESSAGE_PSGI';
  package HTTP::Message::PSGI;
  use strict;
  use warnings;
  use parent qw(Exporter);
  our @EXPORT = qw( req_to_psgi res_from_psgi );
  
  use Carp ();
  use HTTP::Status qw(status_message);
  use URI::Escape ();
  use Plack::Util;
  use Try::Tiny;
  
  my $TRUE  = (1 == 1);
  my $FALSE = !$TRUE;
  
  sub req_to_psgi {
      my $req = shift;
  
      unless (try { $req->isa('HTTP::Request') }) {
          Carp::croak("Request is not HTTP::Request: $req");
      }
  
      # from HTTP::Request::AsCGI
      my $host = $req->header('Host');
      my $uri  = $req->uri->clone;
      $uri->scheme('http')    unless $uri->scheme;
      $uri->host('localhost') unless $uri->host;
      $uri->port(80)          unless $uri->port;
      $uri->host_port($host)  unless !$host || ( $host eq $uri->host_port );
  
      my $input;
      my $content = $req->content;
      if (ref $content eq 'CODE') {
          if (defined $req->content_length) {
              $input = HTTP::Message::PSGI::ChunkedInput->new($content);
          } else {
              $req->header("Transfer-Encoding" => "chunked");
              $input = HTTP::Message::PSGI::ChunkedInput->new($content, 1);
          }
      } else {
          open $input, "<", \$content;
          $req->content_length(length $content)
              unless defined $req->content_length;
      }
  
      my $env = {
          PATH_INFO         => URI::Escape::uri_unescape($uri->path || '/'),
          QUERY_STRING      => $uri->query || '',
          SCRIPT_NAME       => '',
          SERVER_NAME       => $uri->host,
          SERVER_PORT       => $uri->port,
          SERVER_PROTOCOL   => $req->protocol || 'HTTP/1.1',
          REMOTE_ADDR       => '127.0.0.1',
          REMOTE_HOST       => 'localhost',
          REMOTE_PORT       => int( rand(64000) + 1000 ),                   # not in RFC 3875
          REQUEST_URI       => $uri->path_query || '/',                     # not in RFC 3875
          REQUEST_METHOD    => $req->method,
          'psgi.version'      => [ 1, 1 ],
          'psgi.url_scheme'   => $uri->scheme eq 'https' ? 'https' : 'http',
          'psgi.input'        => $input,
          'psgi.errors'       => *STDERR,
          'psgi.multithread'  => $FALSE,
          'psgi.multiprocess' => $FALSE,
          'psgi.run_once'     => $TRUE,
          'psgi.streaming'    => $TRUE,
          'psgi.nonblocking'  => $FALSE,
          @_,
      };
  
      for my $field ( $req->headers->header_field_names ) {
          my $key = uc("HTTP_$field");
          $key =~ tr/-/_/;
          $key =~ s/^HTTP_// if $field =~ /^Content-(Length|Type)$/;
  
          unless ( exists $env->{$key} ) {
              $env->{$key} = $req->headers->header($field);
          }
      }
  
      if ($env->{SCRIPT_NAME}) {
          $env->{PATH_INFO} =~ s/^\Q$env->{SCRIPT_NAME}\E/\//;
          $env->{PATH_INFO} =~ s/^\/+/\//;
      }
  
      if (!defined($env->{HTTP_HOST}) && $req->uri->can('host')) {
          $env->{HTTP_HOST} = $req->uri->host;
          $env->{HTTP_HOST} .= ':' . $req->uri->port
              if $req->uri->port ne $req->uri->default_port;
      }
  
      return $env;
  }
  
  sub res_from_psgi {
      my ($psgi_res) = @_;
  
      require HTTP::Response;
  
      my $res;
      if (ref $psgi_res eq 'ARRAY') {
          _res_from_psgi($psgi_res, \$res);
      }
      elsif (ref $psgi_res eq 'CODE') {
          $psgi_res->(sub {
              _res_from_psgi($_[0], \$res);
          });
      }
  
      return $res;
  }
  
  sub _res_from_psgi {
      my ($status, $headers, $body) = @{+shift};
      my $res_ref = shift;
  
      my $convert_resp = sub {
          my $res = HTTP::Response->new($status);
          $res->message(status_message($status));
          $res->headers->header(@$headers) if @$headers;
  
          if (ref $body eq 'ARRAY') {
              $res->content(join '', grep defined, @$body);
          } else {
              local $/ = \4096;
              my $content = '';
              while (defined(my $buf = $body->getline)) {
                  $content .= $buf;
              }
              $body->close;
              $res->content($content);
          }
  
          ${ $res_ref } = $res;
  
          return;
      };
  
      if (!defined $body) {
          my $o = Plack::Util::inline_object
              write => sub { push @{ $body ||= [] }, @_ },
              close => $convert_resp;
  
          return $o;
      }
  
      $convert_resp->();
  }
  
  sub HTTP::Request::to_psgi {
      req_to_psgi(@_);
  }
  
  sub HTTP::Response::from_psgi {
      my $class = shift;
      res_from_psgi(@_);
  }
  
  package
      HTTP::Message::PSGI::ChunkedInput;
  
  sub new {
      my($class, $content, $chunked) = @_;
  
      my $content_cb;
      if ($chunked) {
          my $done;
          $content_cb = sub {
              my $chunk = $content->();
              return if $done;
              unless (defined $chunk) {
                  $done = 1;
                  return "0\015\012\015\012";
              }
              return '' unless length $chunk;
              return sprintf('%x', length $chunk) . "\015\012$chunk\015\012";
          };
      } else {
          $content_cb = $content;
      }
  
      bless { content => $content_cb }, $class;
  }
  
  sub read {
      my $self = shift;
  
      my $chunk = $self->{content}->();
      return 0 unless defined $chunk;
  
      $_[0] = '';
      substr($_[0], $_[2] || 0, length $chunk) = $chunk;
  
      return length $chunk;
  }
  
  sub close { }
  
  package HTTP::Message::PSGI;
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Message::PSGI - Converts HTTP::Request and HTTP::Response from/to PSGI env and response
  
  =head1 SYNOPSIS
  
    use HTTP::Message::PSGI;
  
    # $req is HTTP::Request, $res is HTTP::Response
    my $env = req_to_psgi($req);
    my $res = res_from_psgi([ $status, $headers, $body ]);
  
    # Adds methods to HTTP::Request/Response class as well
    my $env = $req->to_psgi;
    my $res = HTTP::Response->from_psgi([ $status, $headers, $body ]);
  
  =head1 DESCRIPTION
  
  HTTP::Message::PSGI gives you convenient methods to convert an L<HTTP::Request>
  object to a PSGI env hash and convert a PSGI response arrayref to
  a L<HTTP::Response> object.
  
  If you want the other way around, see L<Plack::Request> and
  L<Plack::Response>.
  
  =head1 METHODS
  
  =over 4
  
  =item req_to_psgi
  
    my $env = req_to_psgi($req [, $key => $val ... ]);
  
  Converts a L<HTTP::Request> object into a PSGI env hash reference.
  
  =item HTTP::Request::to_psgi
  
    my $env = $req->to_psgi;
  
  Same as C<req_to_psgi> but an instance method in L<HTTP::Request>.
  
  =item res_from_psgi
  
    my $res = res_from_psgi([ $status, $headers, $body ]);
  
  Creates a L<HTTP::Response> object from a PSGI response array ref.
  
  =item HTTP::Response->from_psgi
  
    my $res = HTTP::Response->from_psgi([ $status, $headers, $body ]);
  
  Same as C<res_from_psgi>, but is a class method in L<HTTP::Response>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<HTTP::Request::AsCGI> L<HTTP::Message> L<Plack::Test>
  
  =cut
  
HTTP_MESSAGE_PSGI

$fatpacked{"HTTP/Server/PSGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_SERVER_PSGI';
  package HTTP::Server::PSGI;
  use strict;
  use warnings;
  
  use Carp ();
  use Plack;
  use Plack::HTTPParser qw( parse_http_request );
  use IO::Socket::INET;
  use HTTP::Date;
  use HTTP::Status;
  use List::Util qw(max sum);
  use Plack::Util;
  use Stream::Buffered;
  use Plack::Middleware::ContentLength;
  use POSIX qw(EINTR);
  use Socket qw(IPPROTO_TCP TCP_NODELAY);
  
  use Try::Tiny;
  use Time::HiRes qw(time);
  
  my $alarm_interval;
  BEGIN {
      if ($^O eq 'MSWin32') {
          $alarm_interval = 1;
      } else {
          Time::HiRes->import('alarm');
          $alarm_interval = 0.1;
      }
  }
  
  use constant MAX_REQUEST_SIZE => 131072;
  use constant MSWin32          => $^O eq 'MSWin32';
  
  sub new {
      my($class, %args) = @_;
  
      my $self = bless {
          host               => $args{host} || 0,
          port               => $args{port} || 8080,
          timeout            => $args{timeout} || 300,
          server_software    => $args{server_software} || $class,
          server_ready       => $args{server_ready} || sub {},
          ssl                => $args{ssl},
          ipv6               => $args{ipv6},
          ssl_key_file       => $args{ssl_key_file},
          ssl_cert_file      => $args{ssl_cert_file},
      }, $class;
  
      $self;
  }
  
  sub run {
      my($self, $app) = @_;
      $self->setup_listener();
      $self->accept_loop($app);
  }
  
  sub prepare_socket_class {
      my($self, $args) = @_;
  
      if ($self->{ssl} && $self->{ipv6}) {
          Carp::croak("SSL and IPv6 are not supported at the same time (yet). Choose one.");
      }
  
      if ($self->{ssl}) {
          eval { require IO::Socket::SSL; 1 }
              or Carp::croak("SSL suport requires IO::Socket::SSL");
          $args->{SSL_key_file}  = $self->{ssl_key_file};
          $args->{SSL_cert_file} = $self->{ssl_cert_file};
          return "IO::Socket::SSL";
      } elsif ($self->{ipv6}) {
          eval { require IO::Socket::IP; 1 }
              or Carp::croak("IPv6 support requires IO::Socket::IP");
          $self->{host}      ||= '::';
          $args->{LocalAddr} ||= '::';
          return "IO::Socket::IP";
      }
  
      return "IO::Socket::INET";
  }
  
  sub setup_listener {
      my $self = shift;
  
      my %args = (
          Listen    => SOMAXCONN,
          LocalPort => $self->{port},
          LocalAddr => $self->{host},
          Proto     => 'tcp',
          ReuseAddr => 1,
      );
  
      my $class = $self->prepare_socket_class(\%args);
      $self->{listen_sock} ||= $class->new(%args)
          or die "failed to listen to port $self->{port}: $!";
  
      $self->{server_ready}->({ %$self, proto => $self->{ssl} ? 'https' : 'http' });
  }
  
  sub accept_loop {
      my($self, $app) = @_;
  
      $app = Plack::Middleware::ContentLength->wrap($app);
  
      while (1) {
          local $SIG{PIPE} = 'IGNORE';
          if (my $conn = $self->{listen_sock}->accept) {
              $conn->setsockopt(IPPROTO_TCP, TCP_NODELAY, 1)
                  or die "setsockopt(TCP_NODELAY) failed:$!";
              my $env = {
                  SERVER_PORT => $self->{port},
                  SERVER_NAME => $self->{host},
                  SCRIPT_NAME => '',
                  REMOTE_ADDR => $conn->peerhost,
                  REMOTE_PORT => $conn->peerport || 0,
                  'psgi.version' => [ 1, 1 ],
                  'psgi.errors'  => *STDERR,
                  'psgi.url_scheme' => $self->{ssl} ? 'https' : 'http',
                  'psgi.run_once'     => Plack::Util::FALSE,
                  'psgi.multithread'  => Plack::Util::FALSE,
                  'psgi.multiprocess' => Plack::Util::FALSE,
                  'psgi.streaming'    => Plack::Util::TRUE,
                  'psgi.nonblocking'  => Plack::Util::FALSE,
                  'psgix.harakiri'    => Plack::Util::TRUE,
                  'psgix.input.buffered' => Plack::Util::TRUE,
                  'psgix.io'          => $conn,
              };
  
              $self->handle_connection($env, $conn, $app);
              $conn->close;
              last if $env->{'psgix.harakiri.commit'};
          }
      }
  }
  
  sub handle_connection {
      my($self, $env, $conn, $app) = @_;
  
      my $buf = '';
      my $res = [ 400, [ 'Content-Type' => 'text/plain' ], [ 'Bad Request' ] ];
  
      while (1) {
          my $rlen = $self->read_timeout(
              $conn, \$buf, MAX_REQUEST_SIZE - length($buf), length($buf),
              $self->{timeout},
          ) or return;
          my $reqlen = parse_http_request($buf, $env);
          if ($reqlen >= 0) {
              $buf = substr $buf, $reqlen;
              if (my $cl = $env->{CONTENT_LENGTH}) {
                  my $buffer = Stream::Buffered->new($cl);
                  while ($cl > 0) {
                      my $chunk;
                      if (length $buf) {
                          $chunk = $buf;
                          $buf = '';
                      } else {
                          $self->read_timeout($conn, \$chunk, $cl, 0, $self->{timeout})
                              or return;
                      }
                      $buffer->print($chunk);
                      $cl -= length $chunk;
                  }
                  $env->{'psgi.input'} = $buffer->rewind;
              } else {
                  open my $input, "<", \$buf;
                  $env->{'psgi.input'} = $input;
              }
  
              $res = Plack::Util::run_app $app, $env;
              last;
          }
          if ($reqlen == -2) {
              # request is incomplete, do nothing
          } elsif ($reqlen == -1) {
              # error, close conn
              last;
          }
      }
  
      if (ref $res eq 'ARRAY') {
          $self->_handle_response($res, $conn);
      } elsif (ref $res eq 'CODE') {
          $res->(sub {
              $self->_handle_response($_[0], $conn);
          });
      } else {
          die "Bad response $res";
      }
  
      return;
  }
  
  sub _handle_response {
      my($self, $res, $conn) = @_;
  
      my @lines = (
          "Date: @{[HTTP::Date::time2str()]}\015\012",
          "Server: $self->{server_software}\015\012",
      );
  
      Plack::Util::header_iter($res->[1], sub {
          my ($k, $v) = @_;
          push @lines, "$k: $v\015\012";
      });
  
      unshift @lines, "HTTP/1.0 $res->[0] @{[ HTTP::Status::status_message($res->[0]) ]}\015\012";
      push @lines, "\015\012";
  
      $self->write_all($conn, join('', @lines), $self->{timeout})
          or return;
  
      if (defined $res->[2]) {
          my $err;
          my $done;
          {
              local $@;
              eval {
                  Plack::Util::foreach(
                      $res->[2],
                      sub {
                          $self->write_all($conn, $_[0], $self->{timeout})
                              or die "failed to send all data\n";
                      },
                  );
                  $done = 1;
              };
              $err = $@;
          };
          unless ($done) {
              if ($err =~ /^failed to send all data\n/) {
                  return;
              } else {
                  die $err;
              }
          }
      } else {
          return Plack::Util::inline_object
              write => sub { $self->write_all($conn, $_[0], $self->{timeout}) },
              close => sub { };
      }
  }
  
  # returns 1 if socket is ready, undef on timeout
  sub do_timeout {
      my ($self, $cb, $timeout) = @_;
      local $SIG{ALRM} = sub {};
      my $wait_until = time + $timeout;
      alarm($timeout);
      my $ret;
      while (1) {
          if ($ret = $cb->()) {
              last;
          } elsif (! (! defined($ret) && $! == EINTR)) {
              undef $ret;
              last;
          }
          # got EINTR
          my $left = $wait_until - time;
          last if $left <= 0;
          alarm($left + $alarm_interval);
      }
      alarm(0);
      $ret;
  }
  
  # returns (positive) number of bytes read, or undef if the socket is to be closed
  sub read_timeout {
      my ($self, $sock, $buf, $len, $off, $timeout) = @_;
      $self->do_timeout(sub { $sock->sysread($$buf, $len, $off) }, $timeout);
  }
  
  # returns (positive) number of bytes written, or undef if the socket is to be closed
  sub write_timeout {
      my ($self, $sock, $buf, $len, $off, $timeout) = @_;
      $self->do_timeout(sub { $sock->syswrite($buf, $len, $off) }, $timeout);
  }
  
  # writes all data in buf and returns number of bytes written or undef if failed
  sub write_all {
      my ($self, $sock, $buf, $timeout) = @_;
      return 0 unless defined $buf;
      _encode($buf);
      my $off = 0;
      while (my $len = length($buf) - $off) {
          my $ret = $self->write_timeout($sock, $buf, $len, $off, $timeout)
              or return;
          $off += $ret;
      }
      return length $buf;
  }
  
  # syswrite() will crash when given wide characters
  sub _encode {
      if ($_[0] =~ /[^\x00-\xff]/) {
          Carp::carp("Wide character outside byte range in response. Encoding data as UTF-8");
          utf8::encode($_[0]);
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Server::PSGI - Standalone PSGI compatible HTTP server
  
  =head1 SYNOPSIS
  
    use HTTP::Server::PSGI;
  
    my $server = HTTP::Server::PSGI->new(
        host => "127.0.0.1",
        port => 9091,
        timeout => 120,
    );
  
    $server->run($app);
  
  =head1 DESCRIPTION
  
  HTTP::Server::PSGI is a standalone, single-process and PSGI compatible
  HTTP server implementations.
  
  This server should be great for the development and testing, but might
  not be suitable for a production use.
  
  Some features in HTTP/1.1, notably chunked requests, responses and
  pipeline requests are B<NOT> supported, and it also does not support
  HTTP/0.9.
  
  See L<Starman> or uWSGI server if you want HTTP/1.1 and other features
  ready for a production use.
  
  =head1 PREFORKING
  
  L<HTTP::Server::PSGI> does B<NOT> support preforking. See L<Starman>
  or L<Starlet> if you want a multi-process prefork web servers.
  
  =head1 HARAKIRI SUPPORT
  
  This web server supports `psgix.harakiri` extension defined in the
  L<PSGI::Extensions>.
  
  This application is a non-forking single process web server
  (i.e. `psgi.multiprocess` is false), and if your application commits
  harakiri, the entire web server stops too. In case this behavior is
  not what you want, be sure to check `psgi.multiprocess` as well to
  enable harakiri only in the preforking servers such as L<Starman>.
  
  On the other hand, this behavior might be handy if you want to embed
  this module in your application and serve HTTP requests for only short
  period of time, then go back to your main program.
  
  =head1 AUTHOR
  
  Kazuho Oku
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Handler::Standalone> L<Starman> L<Starlet>
  
  =cut
HTTP_SERVER_PSGI

$fatpacked{"Plack.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK';
  package Plack;
  
  use strict;
  use warnings;
  use 5.008_001;
  our $VERSION = '1.0030';
  
  1;
  __END__
  
  =head1 NAME
  
  Plack - Perl Superglue for Web frameworks and Web Servers (PSGI toolkit)
  
  =head1 DESCRIPTION
  
  Plack is a set of tools for using the PSGI stack. It contains
  middleware components, a reference server and utilities for Web
  application frameworks. Plack is like Ruby's Rack or Python's Paste
  for WSGI.
  
  See L<PSGI> for the PSGI specification and L<PSGI::FAQ> to know what
  PSGI and Plack are and why we need them.
  
  =head1 MODULES AND UTILITIES
  
  =head2 Plack::Handler
  
  L<Plack::Handler> and its subclasses contains adapters for web
  servers. We have adapters for the built-in standalone web server
  L<HTTP::Server::PSGI>, L<CGI|Plack::Handler::CGI>,
  L<FCGI|Plack::Handler::FCGI>, L<Apache1|Plack::Handler::Apache1>,
  L<Apache2|Plack::Handler::Apache2> and
  L<HTTP::Server::Simple|Plack::Handler::HTTP::Server::Simple> included
  in the core Plack distribution.
  
  There are also many HTTP server implementations on CPAN that have Plack
  handlers.
  
  See L<Plack::Handler> when writing your own adapters.
  
  =head2 Plack::Loader
  
  L<Plack::Loader> is a loader to load one L<Plack::Handler> adapter
  and run a PSGI application code reference with it.
  
  =head2 Plack::Util
  
  L<Plack::Util> contains a lot of utility functions for server
  implementors as well as middleware authors.
  
  =head2 .psgi files
  
  A PSGI application is a code reference but it's not easy to pass code
  reference via the command line or configuration files, so Plack uses a
  convention that you need a file named C<app.psgi> or similar, which
  would be loaded (via perl's core function C<do>) to return the PSGI
  application code reference.
  
    # Hello.psgi
    my $app = sub {
        my $env = shift;
        # ...
        return [ $status, $headers, $body ];
    };
  
  If you use a web framework, chances are that they provide a helper
  utility to automatically generate these C<.psgi> files for you, such
  as:
  
    # MyApp.psgi
    use MyApp;
    my $app = sub { MyApp->run_psgi(@_) };
  
  It's important that the return value of C<.psgi> file is the code
  reference. See C<eg/dot-psgi> directory for more examples of C<.psgi>
  files.
  
  =head2 plackup, Plack::Runner
  
  L<plackup> is a command line launcher to run PSGI applications from
  command line using L<Plack::Loader> to load PSGI backends. It can be
  used to run standalone servers and FastCGI daemon processes. Other
  server backends like Apache2 needs a separate configuration but
  C<.psgi> application file can still be the same.
  
  If you want to write your own frontend that replaces, or adds
  functionalities to L<plackup>, take a look at the L<Plack::Runner> module.
  
  =head2 Plack::Middleware
  
  PSGI middleware is a PSGI application that wraps an existing PSGI
  application and plays both side of application and servers. From the
  servers the wrapped code reference still looks like and behaves
  exactly the same as PSGI applications.
  
  L<Plack::Middleware> gives you an easy way to wrap PSGI applications
  with a clean API, and compatibility with L<Plack::Builder> DSL.
  
  =head2 Plack::Builder
  
  L<Plack::Builder> gives you a DSL that you can enable Middleware in
  C<.psgi> files to wrap existent PSGI applications.
  
  =head2 Plack::Request, Plack::Response
  
  L<Plack::Request> gives you a nice wrapper API around PSGI C<$env>
  hash to get headers, cookies and query parameters much like
  L<Apache::Request> in mod_perl.
  
  L<Plack::Response> does the same to construct the response array
  reference.
  
  =head2 Plack::Test
  
  L<Plack::Test> is a unified interface to test your PSGI application
  using standard L<HTTP::Request> and L<HTTP::Response> pair with simple
  callbacks.
  
  =head2 Plack::Test::Suite
  
  L<Plack::Test::Suite> is a test suite to test a new PSGI server backend.
  
  =head1 CONTRIBUTING
  
  =head2 Patches and Bug Fixes
  
  Small patches and bug fixes can be either submitted via nopaste on IRC
  L<irc://irc.perl.org/#plack> or L<the github issue
  tracker|http://github.com/plack/Plack/issues>.  Forking on
  L<github|http://github.com/plack/Plack> is another good way if you
  intend to make larger fixes.
  
  See also L<http://contributing.appspot.com/plack> when you think this
  document is terribly outdated.
  
  =head2 Module Namespaces
  
  Modules added to the Plack:: sub-namespaces should be reasonably generic
  components which are useful as building blocks and not just simply using
  Plack.
  
  Middleware authors are free to use the Plack::Middleware:: namespace for
  their middleware components. Middleware must be written in the pipeline
  style such that they can chained together with other middleware components.
  The Plack::Middleware:: modules in the core distribution are good examples
  of such modules. It is recommended that you inherit from L<Plack::Middleware>
  for these types of modules.
  
  Not all middleware components are wrappers, but instead are more like
  endpoints in a middleware chain. These types of components should use the
  Plack::App:: namespace. Again, look in the core modules to see excellent
  examples of these (L<Plack::App::File>, L<Plack::App::Directory>, etc.).
  It is recommended that you inherit from L<Plack::Component> for these
  types of modules.
  
  B<DO NOT USE> Plack:: namespace to build a new web application or a
  framework. It's like naming your application under CGI:: namespace if
  it's supposed to run on CGI and that is a really bad choice and
  would confuse people badly.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 COPYRIGHT
  
  The following copyright notice applies to all the files provided in
  this distribution, including binary files, unless explicitly noted
  otherwise.
  
  Copyright 2009-2013 Tatsuhiko Miyagawa
  
  =head1 CORE DEVELOPERS
  
  Tatsuhiko Miyagawa (miyagawa)
  
  Tokuhiro Matsuno (tokuhirom)
  
  Jesse Luehrs (doy)
  
  Tomas Doran (bobtfish)
  
  Graham Knop (haarg)
  
  =head1 CONTRIBUTORS
  
  Yuval Kogman (nothingmuch)
  
  Kazuhiro Osawa (Yappo)
  
  Kazuho Oku
  
  Florian Ragwitz (rafl)
  
  Chia-liang Kao (clkao)
  
  Masahiro Honma (hiratara)
  
  Daisuke Murase (typester)
  
  John Beppu
  
  Matt S Trout (mst)
  
  Shawn M Moore (Sartak)
  
  Stevan Little
  
  Hans Dieter Pearcey (confound)
  
  mala
  
  Mark Stosberg
  
  Aaron Trevena
  
  =head1 SEE ALSO
  
  The L<PSGI> specification upon which Plack is based.
  
  L<http://plackperl.org/>
  
  The Plack wiki: L<https://github.com/plack/Plack/wiki>
  
  The Plack FAQ: L<https://github.com/plack/Plack/wiki/Faq>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK

$fatpacked{"Plack/App/CGIBin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_APP_CGIBIN';
  package Plack::App::CGIBin;
  use strict;
  use warnings;
  use parent qw/Plack::App::File/;
  use Plack::Util::Accessor qw( exec_cb );
  use Plack::App::WrapCGI;
  
  sub allow_path_info { 1 }
  
  my %exec_cache;
  
  sub would_exec {
      my($self, $file) = @_;
  
      return $exec_cache{$file} if exists $exec_cache{$file};
  
      my $exec_cb = $self->exec_cb || sub { $self->exec_cb_default(@_) };
  
      return $exec_cache{$file} = $exec_cb->($file);
  }
  
  sub exec_cb_default {
      my($self, $file) = @_;
  
      if ($file =~ /\.pl$/i) {
          return 0;
      } elsif ($self->shebang_for($file) =~ /^\#\!.*perl/) {
          return 0;
      } else {
          return 1;
      }
  }
  
  sub shebang_for {
      my($self, $file) = @_;
  
      open my $fh, "<", $file or return '';
      my $line = <$fh>;
      return $line;
  }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      local @{$env}{qw(SCRIPT_NAME PATH_INFO)} = @{$env}{qw( plack.file.SCRIPT_NAME plack.file.PATH_INFO )};
  
      my $app = $self->{_compiled}->{$file} ||= Plack::App::WrapCGI->new(
          script => $file, execute => $self->would_exec($file),
      )->to_app;
      $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::CGIBin - cgi-bin replacement for Plack servers
  
  =head1 SYNOPSIS
  
    use Plack::App::CGIBin;
    use Plack::Builder;
  
    my $app = Plack::App::CGIBin->new(root => "/path/to/cgi-bin")->to_app;
    builder {
        mount "/cgi-bin" => $app;
    };
  
    # Or from the command line
    plackup -MPlack::App::CGIBin -e 'Plack::App::CGIBin->new(root => "/path/to/cgi-bin")->to_app'
  
  =head1 DESCRIPTION
  
  Plack::App::CGIBin allows you to load CGI scripts from a directory and
  convert them into a PSGI application.
  
  This would give you the extreme easiness when you have bunch of old
  CGI scripts that is loaded using I<cgi-bin> of Apache web server.
  
  =head1 HOW IT WORKS
  
  This application checks if a given file path is a perl script and if
  so, uses L<CGI::Compile> to compile a CGI script into a sub (like
  L<ModPerl::Registry>) and then run it as a persistent application
  using L<CGI::Emulate::PSGI>.
  
  If the given file is not a perl script, it executes the script just
  like a normal CGI script with fork & exec. This is like a normal web
  server mode and no performance benefit is achieved.
  
  The default mechanism to determine if a given file is a Perl script is
  as follows:
  
  =over 4
  
  =item *
  
  Check if the filename ends with C<.pl>. If yes, it is a Perl script.
  
  =item *
  
  Open the file and see if the shebang (first line of the file) contains
  the word C<perl> (like C<#!/usr/bin/perl>). If yes, it is a Perl
  script.
  
  =back
  
  You can customize this behavior by passing C<exec_cb> callback, which
  takes a file path to its first argument.
  
  For example, if your perl-based CGI script uses lots of global
  variables and such and are not ready to run on a persistent
  environment, you can do:
  
    my $app = Plack::App::CGIBin->new(
        root => "/path/to/cgi-bin",
        exec_cb => sub { 1 },
    )->to_app;
  
  to always force the execute option for any files.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::File> L<CGI::Emulate::PSGI> L<CGI::Compile> L<Plack::App::WrapCGI>
  
  See also L<Plack::App::WrapCGI> if you compile one CGI script into a
  PSGI application without serving CGI scripts from a directory, to
  remove overhead of filesystem lookups, etc.
  
  =cut
PLACK_APP_CGIBIN

$fatpacked{"Plack/App/Cascade.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_APP_CASCADE';
  package Plack::App::Cascade;
  use strict;
  use base qw(Plack::Component);
  
  use Plack::Util;
  use Plack::Util::Accessor qw(apps catch codes);
  
  sub add {
      my $self = shift;
      $self->apps([]) unless $self->apps;
      push @{$self->apps}, @_;
  }
  
  sub prepare_app {
      my $self = shift;
      my %codes = map { $_ => 1 } @{ $self->catch || [ 404 ] };
      $self->codes(\%codes);
  }
  
  sub call {
      my($self, $env) = @_;
  
      return sub {
          my $respond = shift;
  
          my $done;
          my $respond_wrapper = sub {
              my $res = shift;
              if ($self->codes->{$res->[0]}) {
                  # suppress output by giving the app an
                  # output spool which drops everything on the floor
                  return Plack::Util::inline_object
                      write => sub { }, close => sub { };
              } else {
                  $done = 1;
                  return $respond->($res);
              }
          };
  
          my @try = @{$self->apps || []};
          my $tries_left = 0 + @try;
  
          if (not $tries_left) {
              return $respond->([ 404, [ 'Content-Type' => 'text/html' ], [ '404 Not Found' ] ])
          }
  
          for my $app (@try) {
              my $res = $app->($env);
              if ($tries_left-- == 1) {
                  $respond_wrapper = sub { $respond->(shift) };
              }
  
              if (ref $res eq 'CODE') {
                  $res->($respond_wrapper);
              } else {
                  $respond_wrapper->($res);
              }
              return if $done;
          }
      };
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::Cascade - Cascadable compound application
  
  =head1 SYNOPSIS
  
    use Plack::App::Cascade;
    use Plack::App::URLMap;
    use Plack::App::File;
  
    # Serve static files from multiple search paths
    my $cascade = Plack::App::Cascade->new;
    $cascade->add( Plack::App::File->new(root => "/www/example.com/foo")->to_app );
    $cascade->add( Plack::App::File->new(root => "/www/example.com/bar")->to_app );
  
    my $app = Plack::App::URLMap->new;
    $app->map("/static", $cascade);
    $app->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::Cascade is a Plack middleware component that compounds
  several apps and tries them to return the first response that is not
  404.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $app = Plack::App::Cascade->new(apps => [ $app1, $app2 ]);
  
  Creates a new Cascade application.
  
  =item add
  
    $app->add($app1);
    $app->add($app2, $app3);
  
  Appends a new application to the list of apps to try. You can pass the
  multiple apps to the one C<add> call.
  
  =item catch
  
    $app->catch([ 403, 404 ]);
  
  Sets which error codes to catch and process onwards. Defaults to C<404>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::URLMap> Rack::Cascade
  
  =cut
PLACK_APP_CASCADE

$fatpacked{"Plack/App/Directory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_APP_DIRECTORY';
  package Plack::App::Directory;
  use parent qw(Plack::App::File);
  use strict;
  use warnings;
  use Plack::Util;
  use HTTP::Date;
  use Plack::MIME;
  use DirHandle;
  use URI::Escape;
  use Plack::Request;
  
  # Stolen from rack/directory.rb
  my $dir_file = "<tr><td class='name'><a href='%s'>%s</a></td><td class='size'>%s</td><td class='type'>%s</td><td class='mtime'>%s</td></tr>";
  my $dir_page = <<PAGE;
  <html><head>
    <title>%s</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <style type='text/css'>
  table { width:100%%; }
  .name { text-align:left; }
  .size, .mtime { text-align:right; }
  .type { width:11em; }
  .mtime { width:15em; }
    </style>
  </head><body>
  <h1>%s</h1>
  <hr />
  <table>
    <tr>
      <th class='name'>Name</th>
      <th class='size'>Size</th>
      <th class='type'>Type</th>
      <th class='mtime'>Last Modified</th>
    </tr>
  %s
  </table>
  <hr />
  </body></html>
  PAGE
  
  sub should_handle {
      my($self, $file) = @_;
      return -d $file || -f $file;
  }
  
  sub return_dir_redirect {
      my ($self, $env) = @_;
      my $uri = Plack::Request->new($env)->uri;
      return [ 301,
          [
              'Location' => $uri . '/',
              'Content-Type' => 'text/plain',
              'Content-Length' => 8,
          ],
          [ 'Redirect' ],
      ];
  }
  
  sub serve_path {
      my($self, $env, $dir, $fullpath) = @_;
  
      if (-f $dir) {
          return $self->SUPER::serve_path($env, $dir, $fullpath);
      }
  
      my $dir_url = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
  
      if ($dir_url !~ m{/$}) {
          return $self->return_dir_redirect($env);
      }
  
      my @files = ([ "../", "Parent Directory", '', '', '' ]);
  
      my $dh = DirHandle->new($dir);
      my @children;
      while (defined(my $ent = $dh->read)) {
          next if $ent eq '.' or $ent eq '..';
          push @children, $ent;
      }
  
      for my $basename (sort { $a cmp $b } @children) {
          my $file = "$dir/$basename";
          my $url = $dir_url . $basename;
  
          my $is_dir = -d $file;
          my @stat = stat _;
  
          $url = join '/', map {uri_escape($_)} split m{/}, $url;
  
          if ($is_dir) {
              $basename .= "/";
              $url      .= "/";
          }
  
          my $mime_type = $is_dir ? 'directory' : ( Plack::MIME->mime_type($file) || 'text/plain' );
          push @files, [ $url, $basename, $stat[7], $mime_type, HTTP::Date::time2str($stat[9]) ];
      }
  
      my $path  = Plack::Util::encode_html("Index of $env->{PATH_INFO}");
      my $files = join "\n", map {
          my $f = $_;
          sprintf $dir_file, map Plack::Util::encode_html($_), @$f;
      } @files;
      my $page  = sprintf $dir_page, $path, $path, $files;
  
      return [ 200, ['Content-Type' => 'text/html; charset=utf-8'], [ $page ] ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::Directory - Serve static files from document root with directory index
  
  =head1 SYNOPSIS
  
    # app.psgi
    use Plack::App::Directory;
    my $app = Plack::App::Directory->new({ root => "/path/to/htdocs" })->to_app;
  
  =head1 DESCRIPTION
  
  This is a static file server PSGI application with directory index a la Apache's mod_autoindex.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item root
  
  Document root directory. Defaults to the current directory.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::File>
  
  =cut
PLACK_APP_DIRECTORY

$fatpacked{"Plack/App/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_APP_FILE';
  package Plack::App::File;
  use strict;
  use warnings;
  use parent qw/Plack::Component/;
  use File::Spec::Unix;
  use Cwd ();
  use Plack::Util;
  use Plack::MIME;
  use HTTP::Date;
  
  use Plack::Util::Accessor qw( root file content_type encoding );
  
  sub should_handle {
      my($self, $file) = @_;
      return -f $file;
  }
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my($file, $path_info) = $self->file || $self->locate_file($env);
      return $file if ref $file eq 'ARRAY';
  
      if ($path_info) {
          $env->{'plack.file.SCRIPT_NAME'} = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{'plack.file.SCRIPT_NAME'} =~ s/\Q$path_info\E$//;
          $env->{'plack.file.PATH_INFO'}   = $path_info;
      } else {
          $env->{'plack.file.SCRIPT_NAME'} = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{'plack.file.PATH_INFO'}   = '';
      }
  
      return $self->serve_path($env, $file);
  }
  
  sub locate_file {
      my($self, $env) = @_;
  
      my $path = $env->{PATH_INFO} || '';
  
      if ($path =~ /\0/) {
          return $self->return_400;
      }
  
      my $docroot = $self->root || ".";
      my @path = split /[\\\/]/, $path;
      if (@path) {
          shift @path if $path[0] eq '';
      } else {
          @path = ('.');
      }
  
      if (grep $_ eq '..', @path) {
          return $self->return_403;
      }
  
      my($file, @path_info);
      while (@path) {
          my $try = File::Spec::Unix->catfile($docroot, @path);
          if ($self->should_handle($try)) {
              $file = $try;
              last;
          } elsif (!$self->allow_path_info) {
              last;
          }
          unshift @path_info, pop @path;
      }
  
      if (!$file) {
          return $self->return_404;
      }
  
      if (!-r $file) {
          return $self->return_403;
      }
  
      return $file, join("/", "", @path_info);
  }
  
  sub allow_path_info { 0 }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      my $content_type = $self->content_type || Plack::MIME->mime_type($file)
                         || 'text/plain';
  
      if ("CODE" eq ref $content_type) {
  		$content_type = $content_type->($file);
      }
  
      if ($content_type =~ m!^text/!) {
          $content_type .= "; charset=" . ($self->encoding || "utf-8");
      }
  
      open my $fh, "<:raw", $file
          or return $self->return_403;
  
      my @stat = stat $file;
  
      Plack::Util::set_io_path($fh, Cwd::realpath($file));
  
      return [
          200,
          [
              'Content-Type'   => $content_type,
              'Content-Length' => $stat[7],
              'Last-Modified'  => HTTP::Date::time2str( $stat[9] )
          ],
          $fh,
      ];
  }
  
  sub return_403 {
      my $self = shift;
      return [403, ['Content-Type' => 'text/plain', 'Content-Length' => 9], ['forbidden']];
  }
  
  sub return_400 {
      my $self = shift;
      return [400, ['Content-Type' => 'text/plain', 'Content-Length' => 11], ['Bad Request']];
  }
  
  # Hint: subclasses can override this to return undef to pass through 404
  sub return_404 {
      my $self = shift;
      return [404, ['Content-Type' => 'text/plain', 'Content-Length' => 9], ['not found']];
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::App::File - Serve static files from root directory
  
  =head1 SYNOPSIS
  
    use Plack::App::File;
    my $app = Plack::App::File->new(root => "/path/to/htdocs")->to_app;
  
    # Or map the path to a specific file
    use Plack::Builder;
    builder {
        mount "/favicon.ico" => Plack::App::File->new(file => '/path/to/favicon.ico');
    };
  
  =head1 DESCRIPTION
  
  This is a static file server PSGI application, and internally used by
  L<Plack::Middleware::Static>. This application serves file from
  document root if the path matches with the local file. Use
  L<Plack::App::Directory> if you want to list files in the directory
  as well.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item root
  
  Document root directory. Defaults to C<.> (current directory)
  
  =item file
  
  The file path to create responses from. Optional.
  
  If it's set the application would B<ALWAYS> create a response out of
  the file and there will be no security check etc. (hence fast). If
  it's not set, the application uses C<root> to find the matching file.
  
  =item encoding
  
  Set the file encoding for text files. Defaults to C<utf-8>.
  
  =item content_type
  
  Set the file content type. If not set L<Plack::MIME> will try to detect it
  based on the file extension or fall back to C<text/plain>.
  Can be set to a callback which should work on $_[0] to check full path file 
  name.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::Static> L<Plack::App::Directory>
  
  =cut
  
  
PLACK_APP_FILE

$fatpacked{"Plack/App/PSGIBin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_APP_PSGIBIN';
  package Plack::App::PSGIBin;
  use strict;
  use warnings;
  use parent qw/Plack::App::File/;
  use Plack::Util;
  
  sub allow_path_info { 1 }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      local @{$env}{qw(SCRIPT_NAME PATH_INFO)} = @{$env}{qw( plack.file.SCRIPT_NAME plack.file.PATH_INFO )};
  
      my $app = $self->{_compiled}->{$file} ||= Plack::Util::load_psgi($file);
      $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::PSGIBin - Run .psgi files from a directory
  
  =head1 SYNOPSIS
  
    use Plack::App::PSGIBin;
    use Plack::Builder;
  
    my $app = Plack::App::PSGIBin->new(root => "/path/to/psgi/scripts")->to_app;
    builder {
        mount "/psgi" => $app;
    };
  
    # Or from the command line
    plackup -MPlack::App::PSGIBin -e 'Plack::App::PSGIBin->new(root => "/path/psgi/scripts")->to_app'
  
  =head1 DESCRIPTION
  
  This application loads I<.psgi> files (or actually whichever filename
  extensions) from the root directory and run it as a PSGI
  application. Suppose you have a directory containing C<foo.psgi> and
  C<bar.psgi>, map this application to C</app> with
  L<Plack::App::URLMap> and you can access them via the URL:
  
    http://example.com/app/foo.psgi
    http://example.com/app/bar.psgi
  
  to load them. You can rename the file to the one without C<.psgi>
  extension to make the URL look nicer, or use the URL rewriting tools
  like L<Plack::Middleware::Rewrite> to do the same thing.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::CGIBin>
PLACK_APP_PSGIBIN

$fatpacked{"Plack/App/URLMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_APP_URLMAP';
  package Plack::App::URLMap;
  use strict;
  use warnings;
  use parent qw(Plack::Component);
  use constant DEBUG => $ENV{PLACK_URLMAP_DEBUG};
  
  use Carp ();
  
  sub mount { shift->map(@_) }
  
  sub map {
      my $self = shift;
      my($location, $app) = @_;
  
      my $host;
      if ($location =~ m!^https?://(.*?)(/.*)!) {
          $host     = $1;
          $location = $2;
      }
  
      if ($location !~ m!^/!) {
          Carp::croak("Paths need to start with /");
      }
      $location =~ s!/$!!;
  
      push @{$self->{_mapping}}, [ $host, $location, qr/^\Q$location\E/, $app ];
  }
  
  sub prepare_app {
      my $self = shift;
      # sort by path length
      $self->{_sorted_mapping} = [
          map  { [ @{$_}[2..5] ] }
          sort { $b->[0] <=> $a->[0] || $b->[1] <=> $a->[1] }
          map  { [ ($_->[0] ? length $_->[0] : 0), length($_->[1]), @$_ ] } @{$self->{_mapping}},
      ];
  }
  
  sub call {
      my ($self, $env) = @_;
  
      my $path_info   = $env->{PATH_INFO};
      my $script_name = $env->{SCRIPT_NAME};
  
      my($http_host, $server_name) = @{$env}{qw( HTTP_HOST SERVER_NAME )};
  
      if ($http_host and my $port = $env->{SERVER_PORT}) {
          $http_host =~ s/:$port$//;
      }
  
      for my $map (@{ $self->{_sorted_mapping} }) {
          my($host, $location, $location_re, $app) = @$map;
          my $path = $path_info; # copy
          no warnings 'uninitialized';
          DEBUG && warn "Matching request (Host=$http_host Path=$path) and the map (Host=$host Path=$location)\n";
          next unless not defined $host     or
                      $http_host   eq $host or
                      $server_name eq $host;
          next unless $location eq '' or $path =~ s!$location_re!!;
          next unless $path eq '' or $path =~ m!^/!;
          DEBUG && warn "-> Matched!\n";
  
          my $orig_path_info   = $env->{PATH_INFO};
          my $orig_script_name = $env->{SCRIPT_NAME};
  
          $env->{PATH_INFO}  = $path;
          $env->{SCRIPT_NAME} = $script_name . $location;
          return $self->response_cb($app->($env), sub {
              $env->{PATH_INFO} = $orig_path_info;
              $env->{SCRIPT_NAME} = $orig_script_name;
          });
      }
  
      DEBUG && warn "All matching failed.\n";
  
      return [404, [ 'Content-Type' => 'text/plain' ], [ "Not Found" ]];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::URLMap - Map multiple apps in different paths
  
  =head1 SYNOPSIS
  
    use Plack::App::URLMap;
  
    my $app1 = sub { ... };
    my $app2 = sub { ... };
    my $app3 = sub { ... };
  
    my $urlmap = Plack::App::URLMap->new;
    $urlmap->map("/" => $app1);
    $urlmap->map("/foo" => $app2);
    $urlmap->map("http://bar.example.com/" => $app3);
  
    my $app = $urlmap->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::URLMap is a PSGI application that can dispatch multiple
  applications based on URL path and host names (a.k.a "virtual hosting")
  and takes care of rewriting C<SCRIPT_NAME> and C<PATH_INFO> (See
  L</"HOW THIS WORKS"> for details). This module is inspired by
  Ruby's Rack::URLMap.
  
  =head1 METHODS
  
  =over 4
  
  =item map
  
    $urlmap->map("/foo" => $app);
    $urlmap->map("http://bar.example.com/" => $another_app);
  
  Maps URL path or an absolute URL to a PSGI application. The match
  order is sorted by host name length and then path length (longest strings
  first).
  
  URL paths need to match from the beginning and should match completely
  until the path separator (or the end of the path). For example, if you
  register the path C</foo>, it I<will> match with the request C</foo>,
  C</foo/> or C</foo/bar> but it I<won't> match with C</foox>.
  
  Mapping URLs with host names is also possible, and in that case the URL
  mapping works like a virtual host.
  
  Mappings will nest.  If $app is already mapped to C</baz> it will
  match a request for C</foo/baz> but not C</foo>. See L</"HOW THIS
  WORKS"> for more details.
  
  =item mount
  
  Alias for C<map>.
  
  =item to_app
  
    my $handler = $urlmap->to_app;
  
  Returns the PSGI application code reference. Note that the
  Plack::App::URLMap object is callable (by overloading the code
  dereference), so returning the object itself as a PSGI application
  should also work.
  
  =back
  
  =head1 PERFORMANCE
  
  If you C<map> (or C<mount> with Plack::Builder) N applications,
  Plack::App::URLMap will need to at most iterate through N paths to
  match incoming requests.
  
  It is a good idea to use C<map> only for a known, limited amount of
  applications, since mounting hundreds of applications could affect
  runtime request performance.
  
  =head1 DEBUGGING
  
  You can set the environment variable C<PLACK_URLMAP_DEBUG> to see how
  this application matches with the incoming request host names and
  paths.
  
  =head1 HOW THIS WORKS
  
  This application works by I<fixing> C<SCRIPT_NAME> and C<PATH_INFO>
  before dispatching the incoming request to the relocated
  applications.
  
  Say you have a Wiki application that takes C</index> and C</page/*>
  and makes a PSGI application C<$wiki_app> out of it, using one of
  supported web frameworks, you can put the whole application under
  C</wiki> by:
  
    # MyWikiApp looks at PATH_INFO and handles /index and /page/*
    my $wiki_app = sub { MyWikiApp->run(@_) };
    
    use Plack::App::URLMap;
    my $app = Plack::App::URLMap->new;
    $app->mount("/wiki" => $wiki_app);
  
  When a request comes in with C<PATH_INFO> set to C</wiki/page/foo>,
  the URLMap application C<$app> strips the C</wiki> part from
  C<PATH_INFO> and B<appends> that to C<SCRIPT_NAME>.
  
  That way, if the C<$app> is mounted under the root
  (i.e. C<SCRIPT_NAME> is C<"">) with standalone web servers like
  L<Starman>, C<SCRIPT_NAME> is now locally set to C</wiki> and
  C<PATH_INFO> is changed to C</page/foo> when C<$wiki_app> gets called.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Builder>
  
  =cut
PLACK_APP_URLMAP

$fatpacked{"Plack/App/WrapCGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_APP_WRAPCGI';
  package Plack::App::WrapCGI;
  use strict;
  use warnings;
  use parent qw(Plack::Component);
  use Plack::Util::Accessor qw(script execute _app);
  use File::Spec;
  use CGI::Emulate::PSGI;
  use CGI::Compile;
  use Carp;
  use POSIX ":sys_wait_h";
  
  sub prepare_app {
      my $self = shift;
      my $script = $self->script
          or croak "'script' is not set";
  
      $script = File::Spec->rel2abs($script);
  
      if ($self->execute) {
          my $app = sub {
              my $env = shift;
  
              pipe( my $stdoutr, my $stdoutw );
              pipe( my $stdinr,  my $stdinw );
  
  
              my $pid = fork();
              Carp::croak("fork failed: $!") unless defined $pid;
  
  
              if ($pid == 0) { # child
                  local $SIG{__DIE__} = sub {
                      print STDERR @_;
                      exit(1);
                  };
  
                  close $stdoutr;
                  close $stdinw;
  
                  local %ENV = (%ENV, CGI::Emulate::PSGI->emulate_environment($env));
  
                  open( STDOUT, ">&=" . fileno($stdoutw) )
                    or Carp::croak "Cannot dup STDOUT: $!";
                  open( STDIN, "<&=" . fileno($stdinr) )
                    or Carp::croak "Cannot dup STDIN: $!";
  
                  chdir(File::Basename::dirname($script));
                  exec($script) or Carp::croak("cannot exec: $!");
  
                  exit(2);
              }
  
              close $stdoutw;
              close $stdinr;
  
              syswrite($stdinw, do {
                  local $/;
                  my $fh = $env->{'psgi.input'};
                  <$fh>;
              });
              # close STDIN so child will stop waiting
              close $stdinw;
  
              my $res = '';
              while (waitpid($pid, WNOHANG) <= 0) {
                  $res .= do { local $/; <$stdoutr> };
              }
              $res .= do { local $/; <$stdoutr> };
  
              if (POSIX::WIFEXITED($?)) {
                  return CGI::Parse::PSGI::parse_cgi_output(\$res);
              } else {
                  Carp::croak("Error at run_on_shell CGI: $!");
              }
          };
          $self->_app($app);
      } else {
          my $sub = CGI::Compile->compile($script);
          my $app = CGI::Emulate::PSGI->handler($sub);
  
          $self->_app($app);
      }
  }
  
  sub call {
      my($self, $env) = @_;
      $self->_app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::WrapCGI - Compiles a CGI script as PSGI application
  
  =head1 SYNOPSIS
  
    use Plack::App::WrapCGI;
  
    my $app = Plack::App::WrapCGI->new(script => "/path/to/script.pl")->to_app;
  
    # if you want to execute as a real CGI script
    my $app = Plack::App::WrapCGI->new(script => "/path/to/script.rb", execute => 1)->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::WrapCGI compiles a CGI script into a PSGI application
  using L<CGI::Compile> and L<CGI::Emulate::PSGI>, and runs it with any
  PSGI server as a PSGI application.
  
  See also L<Plack::App::CGIBin> if you have a directory that contains a
  lot of CGI scripts and serve them like Apache's mod_cgi.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    my $app = Plack::App::WrapCGI->new(%args);
  
  Creates a new PSGI application using the given script. I<%args> has two
  parameters:
  
  =over 8
  
  =item script
  
  The path to a CGI-style program. This is a required parameter.
  
  =item execute
  
  An optional parameter. When set to a true value, this app will run the script
  with a CGI-style C<fork>/C<exec> model. Note that you may run programs written
  in other languages with this approach.
  
  =back
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::CGIBin>
  
  =cut
PLACK_APP_WRAPCGI

$fatpacked{"Plack/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_BUILDER';
  package Plack::Builder;
  use strict;
  use parent qw( Exporter );
  our @EXPORT = qw( builder add enable enable_if mount );
  
  use Carp ();
  use Plack::App::URLMap;
  use Plack::Middleware::Conditional; # TODO delayed load?
  use Scalar::Util ();
  
  sub new {
      my $class = shift;
      bless { middlewares => [ ] }, $class;
  }
  
  sub add_middleware {
      my($self, $mw, @args) = @_;
  
      if (ref $mw ne 'CODE') {
          my $mw_class = Plack::Util::load_class($mw, 'Plack::Middleware');
          $mw = sub { $mw_class->wrap($_[0], @args) };
      }
  
      push @{$self->{middlewares}}, $mw;
  }
  
  sub add_middleware_if {
      my($self, $cond, $mw, @args) = @_;
  
      if (ref $mw ne 'CODE') {
          my $mw_class = Plack::Util::load_class($mw, 'Plack::Middleware');
          $mw = sub { $mw_class->wrap($_[0], @args) };
      }
  
      push @{$self->{middlewares}}, sub {
          Plack::Middleware::Conditional->wrap($_[0], condition => $cond, builder => $mw);
      };
  }
  
  # do you want remove_middleware() etc.?
  
  sub _mount {
      my ($self, $location, $app) = @_;
  
      if (!$self->{_urlmap}) {
          $self->{_urlmap} = Plack::App::URLMap->new;
      }
  
      $self->{_urlmap}->map($location => $app);
      $self->{_urlmap}; # for backward compat.
  }
  
  sub to_app {
      my($self, $app) = @_;
  
      if ($app) {
          $self->wrap($app);
      } elsif ($self->{_urlmap}) {
          $self->{_urlmap} = $self->{_urlmap}->to_app
              if Scalar::Util::blessed($self->{_urlmap});
          $self->wrap($self->{_urlmap});
      } else {
          Carp::croak("to_app() is called without mount(). No application to build.");
      }
  }
  
  sub wrap {
      my($self, $app) = @_;
  
      if ($self->{_urlmap} && $app ne $self->{_urlmap}) {
          Carp::carp("WARNING: wrap() and mount() can't be used altogether in Plack::Builder.\n" .
                     "WARNING: This causes all previous mount() mappings to be ignored.");
      }
  
      for my $mw (reverse @{$self->{middlewares}}) {
          $app = $mw->($app);
      }
  
      $app;
  }
  
  # DSL goes here
  our $_add = our $_add_if = our $_mount = sub {
      Carp::croak("enable/mount should be called inside builder {} block");
  };
  
  sub enable         { $_add->(@_) }
  sub enable_if(&$@) { $_add_if->(@_) }
  
  sub mount {
      my $self = shift;
      if (Scalar::Util::blessed($self)) {
          $self->_mount(@_);
      }else{
          $_mount->($self, @_);
      }
  }
  
  sub builder(&) {
      my $block = shift;
  
      my $self = __PACKAGE__->new;
  
      my $mount_is_called;
      my $urlmap = Plack::App::URLMap->new;
      local $_mount = sub {
          $mount_is_called++;
          $urlmap->map(@_);
          $urlmap;
      };
      local $_add = sub {
          $self->add_middleware(@_);
      };
      local $_add_if = sub {
          $self->add_middleware_if(@_);
      };
  
      my $app = $block->();
  
      if ($mount_is_called) {
          if ($app ne $urlmap) {
              Carp::carp("WARNING: You used mount() in a builder block, but the last line (app) isn't using mount().\n" .
                         "WARNING: This causes all mount() mappings to be ignored.\n");
          } else {
              $app = $app->to_app;
          }
      }
  
      $app = $app->to_app if $app and Scalar::Util::blessed($app) and $app->can('to_app');
  
      $self->to_app($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Builder - OO and DSL to enable Plack Middlewares
  
  =head1 SYNOPSIS
  
    # in .psgi
    use Plack::Builder;
  
    my $app = sub { ... };
  
    builder {
        enable "Deflater";
        enable "Session", store => "File";
        enable "Debug", panels => [ qw(DBITrace Memory Timer) ];
        enable "+My::Plack::Middleware";
        $app;
    };
  
    # use URLMap
  
    builder {
        mount "/foo" => builder {
            enable "Foo";
            $app;
        };
  
        mount "/bar" => $app2;
        mount "http://example.com/" => builder { $app3 };
    };
  
    # using OO interface
    my $builder = Plack::Builder->new;
    $builder->add_middleware('Foo', opt => 1);
    $builder->add_middleware('Bar');
    $builder->wrap($app);
  
  =head1 DESCRIPTION
  
  Plack::Builder gives you a quick domain specific language (DSL) to
  wrap your application with L<Plack::Middleware> subclasses. The
  middleware you're trying to use should use L<Plack::Middleware> as a
  base class to use this DSL, inspired by Rack::Builder.
  
  Whenever you call C<enable> on any middleware, the middleware app is
  pushed to the stack inside the builder, and then reversed when it
  actually creates a wrapped application handler. C<"Plack::Middleware::">
  is added as a prefix by default. So:
  
    builder {
        enable "Foo";
        enable "Bar", opt => "val";
        $app;
    };
  
  is syntactically equal to:
  
    $app = Plack::Middleware::Bar->wrap($app, opt => "val");
    $app = Plack::Middleware::Foo->wrap($app);
  
  In other words, you're supposed to C<enable> middleware from outer to inner.
  
  =head1 INLINE MIDDLEWARE
  
  Plack::Builder allows you to code middleware inline using a nested
  code reference.
  
  If the first argument to C<enable> is a code reference, it will be
  passed an C<$app> and should return another code reference
  which is a PSGI application that consumes C<$env> at runtime. So:
  
    builder {
        enable sub {
            my $app = shift;
            sub {
                my $env = shift;
                # do preprocessing
                my $res = $app->($env);
                # do postprocessing
                return $res;
            };
        };
        $app;
    };
  
  is equal to:
  
    my $mw = sub {
        my $app = shift;
        sub { my $env = shift; $app->($env) };
    };
  
    $app = $mw->($app);
  
  =head1 URLMap support
  
  Plack::Builder has a native support for L<Plack::App::URLMap> via the C<mount> method.
  
    use Plack::Builder;
    my $app = builder {
        mount "/foo" => $app1;
        mount "/bar" => builder {
            enable "Foo";
            $app2;
        };
    };
  
  See L<Plack::App::URLMap>'s C<map> method to see what they mean. With
  C<builder> you can't use C<map> as a DSL, for the obvious reason :)
  
  B<NOTE>: Once you use C<mount> in your builder code, you have to use
  C<mount> for all the paths, including the root path (C</>). You can't
  have the default app in the last line of C<builder> like:
  
    my $app = sub {
        my $env = shift;
        ...
    };
  
    builder {
        mount "/foo" => sub { ... };
        $app; # THIS DOESN'T WORK
    };
  
  You'll get warnings saying that your mount configuration will be
  ignored. Instead you should use C<< mount "/" => ... >> in the last
  line to set the default fallback app.
  
    builder {
        mount "/foo" => sub { ... };
        mount "/" => $app;
    }
  
  Note that the C<builder> DSL returns a whole new PSGI application, which means
  
  =over 4
  
  =item *
  
  C<builder { ... }> should normally the last statement of a C<.psgi>
  file, because the return value of C<builder> is the application that
  is actually executed.
  
  =item *
  
  You can nest your C<builder> blocks, mixed with C<mount> statements (see L</"URLMap support">
  above):
  
    builder {
        mount "/foo" => builder {
            mount "/bar" => $app;
        }
    }
  
  will locate the C<$app> under C</foo/bar>, since the inner C<builder>
  block puts it under C</bar> and it results in a new PSGI application
  which is located under C</foo> because of the outer C<builder> block.
  
  =back
  
  =head1 CONDITIONAL MIDDLEWARE SUPPORT
  
  You can use C<enable_if> to conditionally enable middleware based on
  the runtime environment.
  
    builder {
        enable_if { $_[0]->{REMOTE_ADDR} eq '127.0.0.1' } 'StackTrace', force => 1;
        $app;
    };
  
  See L<Plack::Middleware::Conditional> for details.
  
  =head1 OBJECT ORIENTED INTERFACE
  
  Object oriented interface supports the same functionality with the DSL
  version in a clearer interface, probably with more typing required.
  
    # With mount
    my $builder = Plack::Builder->new;
    $builder->add_middleware('Foo', opt => 1);
    $builder->mount('/foo' => $foo_app);
    $builder->mount('/' => $root_app);
    $builder->to_app;
  
    # Nested builders. Equivalent to:
    # builder {
    #     mount '/foo' => builder {
    #         enable 'Foo';
    #         $app;
    #     };
    #     mount '/' => $app2;
    # };
    my $builder_out = Plack::Builder->new;
    my $builder_in  = Plack::Builder->new;
    $builder_in->add_middleware('Foo');
    $builder_out->mount("/foo" => $builder_in->wrap($app));
    $builder_out->mount("/" => $app2);
    $builder_out->to_app;
  
    # conditional. You can also directly use Plack::Middleware::Conditional
    my $builder = Plack::Builder->new;
    $builder->add_middleware_if(sub { $_[0]->{REMOTE_ADDR} eq '127.0.0.1' }, 'StackTrace');
    $builder->wrap($app);
  
  =head1 SEE ALSO
  
  L<Plack::Middleware> L<Plack::App::URLMap> L<Plack::Middleware::Conditional>
  
  =cut
  
  
  
PLACK_BUILDER

$fatpacked{"Plack/Component.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_COMPONENT';
  package Plack::Component;
  use strict;
  use warnings;
  use Carp ();
  use Plack::Util;
  use overload '&{}' => \&to_app_auto, fallback => 1;
  
  sub new {
      my $proto = shift;
      my $class = ref $proto || $proto;
  
      my $self;
      if (@_ == 1 && ref $_[0] eq 'HASH') {
          $self = bless {%{$_[0]}}, $class;
      } else {
          $self = bless {@_}, $class;
      }
  
      $self;
  }
  
  sub to_app_auto {
      my $self = shift;
      if (($ENV{PLACK_ENV} || '') eq 'development') {
          my $class = ref($self);
          warn "WARNING: Automatically converting $class instance to a PSGI code reference. " .
            "If you see this warning for each request, you probably need to explicitly call " .
            "to_app() i.e. $class->new(...)->to_app in your PSGI file.\n";
      }
      $self->to_app(@_);
  }
  
  # NOTE:
  # this is for back-compat only,
  # future modules should use
  # Plack::Util::Accessor directly
  # or their own favorite accessor
  # generator.
  # - SL
  sub mk_accessors {
      my $self = shift;
      Plack::Util::Accessor::mk_accessors( ref( $self ) || $self, @_ )
  }
  
  sub prepare_app { return }
  
  sub to_app {
      my $self = shift;
      $self->prepare_app;
      return sub { $self->call(@_) };
  }
  
  
  sub response_cb {
      my($self, $res, $cb) = @_;
      Plack::Util::response_cb($res, $cb);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Component - Base class for PSGI endpoints
  
  =head1 SYNOPSIS
  
    package Plack::App::Foo;
    use parent qw( Plack::Component );
  
    sub call {
        my($self, $env) = @_;
        # Do something with $env
  
        my $res = ...; # create a response ...
  
        # return the response
        return $res;
    }
  
  =head1 DESCRIPTION
  
  Plack::Component is the base class shared between L<Plack::Middleware>
  and C<Plack::App::*> modules. If you are writing middleware, you should
  inherit from L<Plack::Middleware>, but if you are writing a
  Plack::App::* you should inherit from this directly.
  
  =head1 REQUIRED METHOD
  
  =over 4
  
  =item call ($env)
  
  You are expected to implement a C<call> method in your component. This
  is where all the work gets done. It receives the PSGI C<$env> hash-ref
  as an argument and is expected to return a proper PSGI response value.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item new (%opts | \%opts)
  
  The constructor accepts either a hash or a hashref and uses that to
  create the instance. It will call no other methods and simply return
  the instance that is created.
  
  =item prepare_app
  
  This method is called by C<to_app> and is meant as a hook to be used to
  prepare your component before it is packaged as a PSGI C<$app>.
  
  =item to_app
  
  This is the method used in several parts of the Plack infrastructure to
  convert your component into a PSGI C<$app>. You should not ever need to
  override this method; it is recommended to use C<prepare_app> and C<call>
  instead.
  
  =item response_cb
  
  This is a wrapper for C<response_cb> in L<Plack::Util>. See
  L<Plack::Middleware/RESPONSE CALLBACK> for details.
  
  =back
  
  =head1 OBJECT LIFECYCLE
  
  Objects for the derived classes (Plack::App::* or
  Plack::Middleware::*) are created at the PSGI application compile
  phase using C<new>, C<prepare_app> and C<to_app>, and the created
  object persists during the web server lifecycle, unless it is running
  on the non-persistent environment like CGI. C<call> is invoked against
  the same object whenever a new request comes in.
  
  You can check if it is running in a persistent environment by checking
  C<psgi.run_once> key in the C<$env> being true (non-persistent) or
  false (persistent), but it is best for you to write your middleware
  safely for a persistent environment. To accomplish that, you should
  avoid saving per-request data like C<$env> in your object.
  
  =head1 BACKWARDS COMPATIBILITY
  
  The L<Plack::Middleware> module used to inherit from L<Class::Accessor::Fast>,
  which has been removed in favor of the L<Plack::Util::Accessor> module. When
  developing new components it is recommended to use L<Plack::Util::Accessor>
  like so:
  
    use Plack::Util::Accessor qw( foo bar baz );
  
  However, in order to keep backwards compatibility this module provides a
  C<mk_accessors> method similar to L<Class::Accessor::Fast>. New code should
  not use this and use L<Plack::Util::Accessor> instead.
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Builder> L<Plack::Middleware>
  
  =cut
PLACK_COMPONENT

$fatpacked{"Plack/HTTPParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HTTPPARSER';
  package Plack::HTTPParser;
  use strict;
  use parent qw(Exporter);
  
  our @EXPORT = qw( parse_http_request );
  
  use Try::Tiny;
  
  {
      if (!$ENV{PLACK_HTTP_PARSER_PP} && try { require HTTP::Parser::XS; 1 }) {
          *parse_http_request = \&HTTP::Parser::XS::parse_http_request;
      } else {
          require Plack::HTTPParser::PP;
          *parse_http_request = \&Plack::HTTPParser::PP::parse_http_request;
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::HTTPParser - Parse HTTP headers
  
  =head1 SYNOPSIS
  
    use Plack::HTTPParser qw(parse_http_request);
  
    my $ret = parse_http_request($header_str, \%env);
    # see HTTP::Parser::XS docs
  
  =head1 DESCRIPTION
  
  Plack::HTTPParser is a wrapper class to dispatch C<parse_http_request>
  to Kazuho Oku's XS based HTTP::Parser::XS or pure perl fallback based
  on David Robins HTTP::Parser.
  
  If you want to force the use of the slower pure perl version even if the
  fast XS version is available, set the environment variable
  C<PLACK_HTTP_PARSER_PP> to 1.
  
  =head1 SEE ALSO
  
  L<HTTP::Parser::XS> L<HTTP::Parser>
  
  =cut
PLACK_HTTPPARSER

$fatpacked{"Plack/HTTPParser/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HTTPPARSER_PP';
  package Plack::HTTPParser::PP;
  use strict;
  use warnings;
  use URI::Escape;
  
  sub parse_http_request {
      my($chunk, $env) = @_;
      $env ||= {};
  
      # pre-header blank lines are allowed (RFC 2616 4.1)
      $chunk =~ s/^(\x0d?\x0a)+//;
      return -2 unless length $chunk;
  
      # double line break indicates end of header; parse it
      if ($chunk =~ /^(.*?\x0d?\x0a\x0d?\x0a)/s) {
          return _parse_header($chunk, length $1, $env);
      }
      return -2;  # still waiting for unknown amount of header lines
  }
  
  sub _parse_header {
      my($chunk, $eoh, $env) = @_;
  
      my $header = substr($chunk, 0, $eoh,'');
      $chunk =~ s/^\x0d?\x0a\x0d?\x0a//;
  
      # parse into lines
      my @header  = split /\x0d?\x0a/,$header;
      my $request = shift @header;
  
      # join folded lines
      my @out;
      for(@header) {
          if(/^[ \t]+/) {
              return -1 unless @out;
              $out[-1] .= $_;
          } else {
              push @out, $_;
          }
      }
  
      # parse request or response line
      my $obj;
      my ($major, $minor);
  
      my ($method,$uri,$http) = split / /,$request;
      return -1 unless $http and $http =~ /^HTTP\/(\d+)\.(\d+)$/i;
      ($major, $minor) = ($1, $2);
  
      $env->{REQUEST_METHOD}  = $method;
      $env->{SERVER_PROTOCOL} = "HTTP/$major.$minor";
      $env->{REQUEST_URI}     = $uri;
  
      my($path, $query) = ( $uri =~ /^([^?]*)(?:\?(.*))?$/s );
      for ($path, $query) { s/\#.*$// if defined && length } # dumb clients sending URI fragments
  
      $env->{PATH_INFO}    = URI::Escape::uri_unescape($path);
      $env->{QUERY_STRING} = $query || '';
      $env->{SCRIPT_NAME}  = '';
  
      # import headers
      my $token = qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;
      my $k;
      for my $header (@out) {
          if ( $header =~ s/^($token): ?// ) {
              $k = $1;
              $k =~ s/-/_/g;
              $k = uc $k;
  
              if ($k !~ /^(?:CONTENT_LENGTH|CONTENT_TYPE)$/) {
                  $k = "HTTP_$k";
              }
          } elsif ( $header =~ /^\s+/) {
              # multiline header
          } else {
              return -1;
          }
  
          if (exists $env->{$k}) {
              $env->{$k} .= ", $header";
          } else {
              $env->{$k} = $header;
          }
      }
  
      return $eoh;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::HTTPParser::PP - Pure perl fallback of HTTP::Parser::XS
  
  =head1 DESCRIPTION
  
  Do not use this module directly. Use L<Plack::HTTPParser> instead.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
  
PLACK_HTTPPARSER_PP

$fatpacked{"Plack/Handler.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER';
  package Plack::Handler;
  use strict;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler - Connects PSGI applications and Web servers
  
  =head1 SYNOPSIS
  
    package Plack::Handler::AwesomeWebServer;
    sub new {
        my($class, %opt) = @_;
        ...
        return $self;
    }
  
    sub run {
        my($self, $app) = @_;
        # launch the AwesomeWebServer and run $app in the loop
    }
  
    # then from command line
    plackup -s AwesomeWebServer -a app.psgi
  
  =head1 DESCRIPTION
  
  Plack::Handler defines an adapter (connector) interface to adapt
  L<plackup> and L<Plack::Runner> to various PSGI web servers, such as
  Apache2 for mod_perl and Standalone for L<HTTP::Server::PSGI>.
  
  It is an empty class, and as long as they implement the methods
  defined as an Server adapter interface, they do not need to inherit
  Plack::Handler.
  
  If you write a new handler for existing web servers, I recommend you
  to include the full name of the server module after I<Plack::Handler>
  prefix, like L<Plack::Handler::Net::Server::Coro> if you write a
  handler for L<Net::Server::Coro>. That way you'll be using plackup
  command line option like:
  
    plackup -s Net::Server::Coro
  
  that makes it easy to figure out which web server you're going to use.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $server = FooBarServer->new(%args);
  
  Creates a new adapter object. I<%args> can take arbitrary parameters
  to configure server environments but common parameters are:
  
  =over 8
  
  =item port
  
  Port number the server listens to.
  
  =item host
  
  Address the server listens to. Set to undef to listen any interface.
  
  =back
  
  =item run
  
    $server->run($app);
  
  Starts the server process and when a request comes in, run the PSGI
  application passed in C<$app> in the loop.
  
  =item register_service
  
    $server->register_service($app);
  
  Optional interface if your server should run in parallel with other
  event loop, particularly L<AnyEvent>. This is the same as C<run> but
  doesn't run the main loop.
  
  =back
  
  =head1 SEE ALSO
  
  rackup
  
  =cut
  
PLACK_HANDLER

$fatpacked{"Plack/Handler/Apache1.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER_APACHE1';
  package Plack::Handler::Apache1;
  use strict;
  use Apache::Request;
  use Apache::Constants qw(:common :response);
  
  use Plack::Util;
  use Scalar::Util;
  
  my %apps; # psgi file to $app mapping
  
  sub new { bless {}, shift }
  
  sub preload {
      my $class = shift;
      for my $app (@_) {
          $class->load_app($app);
      }
  }
  
  sub load_app {
      my($class, $app) = @_;
      return $apps{$app} ||= do {
          # Trick Catalyst, CGI.pm, CGI::Cookie and others that check
          # for $ENV{MOD_PERL}.
          #
          # Note that we delete it instead of just localizing
          # $ENV{MOD_PERL} because some users may check if the key
          # exists, and we do it this way because "delete local" is new
          # in 5.12:
          # http://perldoc.perl.org/5.12.0/perldelta.html#delete-local
          local $ENV{MOD_PERL};
          delete $ENV{MOD_PERL};
  
          Plack::Util::load_psgi $app;
      };
  }
  
  sub handler {
      my $class = __PACKAGE__;
      my $r     = shift;
      my $psgi  = $r->dir_config('psgi_app');
      $class->call_app($r, $class->load_app($psgi));
  }
  
  sub call_app {
      my ($class, $r, $app) = @_;
  
      $r->subprocess_env; # let Apache create %ENV for us :)
  
      my $env = {
          %ENV,
          'psgi.version'        => [ 1, 1 ],
          'psgi.url_scheme'     => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'          => $r,
          'psgi.errors'         => *STDERR,
          'psgi.multithread'    => Plack::Util::FALSE,
          'psgi.multiprocess'   => Plack::Util::TRUE,
          'psgi.run_once'       => Plack::Util::FALSE,
          'psgi.streaming'      => Plack::Util::TRUE,
          'psgi.nonblocking'    => Plack::Util::FALSE,
          'psgix.harakiri'      => Plack::Util::TRUE,
      };
  
      if (defined(my $HTTP_AUTHORIZATION = $r->headers_in->{Authorization})) {
          $env->{HTTP_AUTHORIZATION} = $HTTP_AUTHORIZATION;
      }
  
      my $vpath    = $env->{SCRIPT_NAME} . ($env->{PATH_INFO} || '');
  
      my $location = $r->location || "/";
         $location =~ s{/$}{};
      (my $path_info = $vpath) =~ s/^\Q$location\E//;
  
      $env->{SCRIPT_NAME} = $location;
      $env->{PATH_INFO}   = $path_info;
  
      my $res = $app->($env);
  
      if (ref $res eq 'ARRAY') {
          _handle_response($r, $res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              _handle_response($r, $_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  
      if ($env->{'psgix.harakiri.commit'}) {
          $r->child_terminate;
      }
  
      return OK;
  }
  
  sub _handle_response {
      my ($r, $res) = @_;
      my ($status, $headers, $body) = @{ $res };
  
      my $hdrs = ($status >= 200 && $status < 300)
          ? $r->headers_out : $r->err_headers_out;
  
      Plack::Util::header_iter($headers, sub {
          my($h, $v) = @_;
          if (lc $h eq 'content-type') {
              $r->content_type($v);
          } else {
              $hdrs->add($h => $v);
          }
      });
  
      $r->status($status);
      $r->send_http_header;
  
      if (defined $body) {
          if (Plack::Util::is_real_fh($body)) {
              $r->send_fd($body);
          } else {
              Plack::Util::foreach($body, sub { $r->print(@_) });
          }
      }
      else {
          return Plack::Util::inline_object
              write => sub { $r->print(@_) },
              close => sub { };
      }
  }
  
  1;
  
  __END__
  
  
  =head1 NAME
  
  Plack::Handler::Apache1 - Apache 1.3.x mod_perl handlers to run PSGI application
  
  =head1 SYNOPSIS
  
    <Location />
    SetHandler perl-script
    PerlHandler Plack::Handler::Apache1
    PerlSetVar psgi_app /path/to/app.psgi
    </Location>
  
    <Perl>
    use Plack::Handler::Apache1;
    Plack::Handler::Apache1->preload("/path/to/app.psgi");
    </Perl>
  
  =head1 DESCRIPTION
  
  This is a mod_perl handler module to run any PSGI application with mod_perl on Apache 1.3.x.
  
  If you want to run PSGI applications I<behind> Apache instead of using
  mod_perl, see L<Plack::Handler::FCGI> to run with FastCGI, or use
  standalone HTTP servers such as L<Starman> or L<Starlet> proxied with
  mod_proxy.
  
  =head1 AUTHOR
  
  Aaron Trevena
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_HANDLER_APACHE1

$fatpacked{"Plack/Handler/Apache2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER_APACHE2';
  package Plack::Handler::Apache2;
  use strict;
  use warnings;
  use Apache2::RequestRec;
  use Apache2::RequestIO;
  use Apache2::RequestUtil;
  use Apache2::Response;
  use Apache2::Const -compile => qw(OK);
  use Apache2::Log;
  use APR::Table;
  use IO::Handle;
  use Plack::Util;
  use Scalar::Util;
  use URI;
  use URI::Escape;
  
  my %apps; # psgi file to $app mapping
  
  sub new { bless {}, shift }
  
  sub preload {
      my $class = shift;
      for my $app (@_) {
          $class->load_app($app);
      }
  }
  
  sub load_app {
      my($class, $app) = @_;
      return $apps{$app} ||= do {
          # Trick Catalyst, CGI.pm, CGI::Cookie and others that check
          # for $ENV{MOD_PERL}.
          #
          # Note that we delete it instead of just localizing
          # $ENV{MOD_PERL} because some users may check if the key
          # exists, and we do it this way because "delete local" is new
          # in 5.12:
          # http://perldoc.perl.org/5.12.0/perldelta.html#delete-local
          local $ENV{MOD_PERL};
          delete $ENV{MOD_PERL};
  
          Plack::Util::load_psgi $app;
      };
  }
  
  sub call_app {
      my ($class, $r, $app) = @_;
  
      $r->subprocess_env; # let Apache create %ENV for us :)
  
      my $env = {
          %ENV,
          'psgi.version'           => [ 1, 1 ],
          'psgi.url_scheme'        => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'             => $r,
          'psgi.errors'            => *STDERR,
          'psgi.multithread'       => Plack::Util::FALSE,
          'psgi.multiprocess'      => Plack::Util::TRUE,
          'psgi.run_once'          => Plack::Util::FALSE,
          'psgi.streaming'         => Plack::Util::TRUE,
          'psgi.nonblocking'       => Plack::Util::FALSE,
          'psgix.harakiri'         => Plack::Util::TRUE,
          'psgix.cleanup'          => Plack::Util::TRUE,
          'psgix.cleanup.handlers' => [],
      };
  
      if (defined(my $HTTP_AUTHORIZATION = $r->headers_in->{Authorization})) {
          $env->{HTTP_AUTHORIZATION} = $HTTP_AUTHORIZATION;
      }
  
      # If you supply more than one Content-Length header Apache will
      # happily concat the values with ", ", e.g. "72, 72". This
      # violates the PSGI spec so fix this up and just take the first
      # one.
      if (exists $env->{CONTENT_LENGTH} && $env->{CONTENT_LENGTH} =~ /,/) {
          no warnings qw(numeric);
          $env->{CONTENT_LENGTH} = int $env->{CONTENT_LENGTH};
      }
  
      # Actually, we can not trust PATH_INFO from mod_perl because mod_perl squeezes multiple slashes into one slash.
      my $uri = URI->new("http://".$r->hostname.$r->unparsed_uri);
  
      $env->{PATH_INFO} = uri_unescape($uri->path);
  
      $class->fixup_path($r, $env);
  
      my $res = $app->($env);
  
      if (ref $res eq 'ARRAY') {
          _handle_response($r, $res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              _handle_response($r, $_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  
      if (@{ $env->{'psgix.cleanup.handlers'} }) {
          $r->push_handlers(
              PerlCleanupHandler => sub {
                  for my $cleanup_handler (@{ $env->{'psgix.cleanup.handlers'} }) {
                      $cleanup_handler->($env);
                  }
  
                  if ($env->{'psgix.harakiri.commit'}) {
                      $r->child_terminate;
                  }
              },
          );
      } else {
          if ($env->{'psgix.harakiri.commit'}) {
              $r->child_terminate;
          }
      }
  
      return Apache2::Const::OK;
  }
  
  sub handler {
      my $class = __PACKAGE__;
      my $r     = shift;
      my $psgi  = $r->dir_config('psgi_app');
      $class->call_app($r, $class->load_app($psgi));
  }
  
  # The method for PH::Apache2::Registry to override.
  sub fixup_path {
      my ($class, $r, $env) = @_;
  
      # $env->{PATH_INFO} is created from unparsed_uri so it is raw.
      my $path_info = $env->{PATH_INFO} || '';
  
      # Get argument of <Location> or <LocationMatch> directive
      # This may be string or regexp and we can't know either.
      my $location = $r->location;
  
      # Let's *guess* if we're in a LocationMatch directive
      if ($location eq '/') {
          # <Location /> could be handled as a 'root' case where we make
          # everything PATH_INFO and empty SCRIPT_NAME as in the PSGI spec
          $env->{SCRIPT_NAME} = '';
      } elsif ($path_info =~ s{^($location)/?}{/}) {
          $env->{SCRIPT_NAME} = $1 || '';
      } else {
          # Apache's <Location> is matched but here is not.
          # This is something wrong. We can only respect original.
          $r->server->log_error(
              "Your request path is '$path_info' and it doesn't match your Location(Match) '$location'. " .
              "This should be due to the configuration error. See perldoc Plack::Handler::Apache2 for details."
          );
      }
  
      $env->{PATH_INFO}   = $path_info;
  }
  
  sub _handle_response {
      my ($r, $res) = @_;
  
      my ($status, $headers, $body) = @{ $res };
  
      my $hdrs = ($status >= 200 && $status < 300)
          ? $r->headers_out : $r->err_headers_out;
  
      Plack::Util::header_iter($headers, sub {
          my($h, $v) = @_;
          if (lc $h eq 'content-type') {
              $r->content_type($v);
          } elsif (lc $h eq 'content-length') {
              $r->set_content_length($v);
          } else {
              $hdrs->add($h => $v);
          }
      });
  
      $r->status($status);
  
      if (Scalar::Util::blessed($body) and $body->can('path') and my $path = $body->path) {
          $r->sendfile($path);
      } elsif (defined $body) {
          Plack::Util::foreach($body, sub { $r->print(@_) });
          $r->rflush;
      }
      else {
          return Plack::Util::inline_object
              write => sub { $r->print(@_); $r->rflush },
              close => sub { $r->rflush };
      }
  
      return Apache2::Const::OK;
  }
  
  1;
  
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Plack::Handler::Apache2 - Apache 2.0 mod_perl handler to run PSGI application
  
  =head1 SYNOPSIS
  
    # in your httpd.conf
    <Location />
    SetHandler perl-script
    PerlResponseHandler Plack::Handler::Apache2
    PerlSetVar psgi_app /path/to/app.psgi
    </Location>
  
    # Optionally preload your apps in startup
    PerlPostConfigRequire /etc/httpd/startup.pl
  
  See L</STARTUP FILE> for more details on writing a C<startup.pl>.
  
  =head1 DESCRIPTION
  
  This is a mod_perl handler module to run any PSGI application with mod_perl on Apache 2.x.
  
  If you want to run PSGI applications I<behind> Apache instead of using
  mod_perl, see L<Plack::Handler::FCGI> to run with FastCGI, or use
  standalone HTTP servers such as L<Starman> or L<Starlet> proxied with
  mod_proxy.
  
  =head1 CREATING CUSTOM HANDLER
  
  If you want to create a custom handler that loads or creates PSGI
  applications using other means than loading from C<.psgi> files, you
  can create your own handler class and use C<call_app> class method to
  run your application.
  
    package My::ModPerl::Handler;
    use Plack::Handler::Apache2;
  
    sub get_app {
      # magic!
    }
  
    sub handler {
      my $r = shift;
      my $app = get_app();
      Plack::Handler::Apache2->call_app($r, $app);
    }
  
  =head1 STARTUP FILE
  
  Here is an example C<startup.pl> to preload PSGI applications:
  
      #!/usr/bin/env perl
  
      use strict;
      use warnings;
      use Apache2::ServerUtil ();
  
      BEGIN {
          return unless Apache2::ServerUtil::restart_count() > 1;
  
          require lib;
          lib->import('/path/to/my/perl/libs');
  
          require Plack::Handler::Apache2;
  
          my @psgis = ('/path/to/app1.psgi', '/path/to/app2.psgi');
          foreach my $psgi (@psgis) {
              Plack::Handler::Apache2->preload($psgi);
          }
      }
  
      1; # file must return true!
  
  See L<http://perl.apache.org/docs/2.0/user/handlers/server.html#Startup_File>
  for general information on the C<startup.pl> file for preloading perl modules
  and your apps.
  
  Some things to keep in mind when writing this file:
  
  =over 4
  
  =item * multiple init phases
  
  You have to check that L<Apache2::ServerUtil/restart_count> is C<< > 1 >>,
  otherwise your app will load twice and the env vars you set with
  L<PerlSetEnv|http://perl.apache.org/docs/2.0/user/config/config.html#C_PerlSetEnv_>
  will not be available when your app is loading the first time.
  
  Use the example above as a template.
  
  =item * C<@INC>
  
  The C<startup.pl> file is a good place to add entries to your C<@INC>.
  Use L<lib> to add entries, they can be in your app or C<.psgi> as well, but if
  your modules are in a L<local::lib> or some such, you will need to add the path
  for anything to load.
  
  Alternately, if you follow the example above, you can use:
  
      PerlSetEnv PERL5LIB /some/path
  
  or
  
      PerlSwitches -I/some/path
  
  in your C<httpd.conf>, which will also work.
  
  =item * loading errors
  
  Any exceptions thrown in your C<startup.pl> will stop Apache from starting at
  all.
  
  You probably don't want a stray syntax error to bring your whole server down in
  a shared or development environment, in which case it's a good idea to wrap the
  L</preload> call in an eval, using something like this:
  
      require Plack::Handler::Apache2;
  
      my @psgis = ('/path/to/app1.psgi', '/path/to/app2.psgi');
  
      foreach my $psgi (@psgis) {
          eval {
              Plack::Handler::Apache2->preload($psgi); 1;
          } or do {
              my $error = $@ || 'Unknown Error';
              # STDERR goes to the error_log
              print STDERR "Failed to load psgi '$psgi': $error\n";
          };
      }
  
  
  =item * dynamically loaded modules
  
  Some modules load their dependencies at runtime via e.g. L<Class::Load>. These
  modules will not get preloaded into your parent process by just including the
  app/module you are using.
  
  As an optimization, you can dump C<%INC> from a request to see if you are using
  any such modules and preload them in your C<startup.pl>.
  
  Another method is dumping the difference between the C<%INC> on
  process start and process exit. You can use something like this to
  accomplish this:
  
      my $start_inc = { %INC };
  
      END {
          my @m;
          foreach my $m (keys %INC) {
              push @m, $m unless exists $start_inc->{$m};
          }
  
          if (@m) {
              # STDERR goes to the error_log
              print STDERR "The following modules need to be preloaded:\n";
              print STDERR "$_\n" for @m;
          }
      }
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 CONTRIBUTORS
  
  Paul Driver
  
  Ævar Arnfjörð Bjarmason
  
  Rafael Kitover
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
PLACK_HANDLER_APACHE2

$fatpacked{"Plack/Handler/Apache2/Registry.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER_APACHE2_REGISTRY';
  package Plack::Handler::Apache2::Registry;
  use strict;
  use warnings;
  use Try::Tiny;
  use Apache2::Const;
  use Apache2::Log;
  use parent qw/Plack::Handler::Apache2/;
  
  sub handler {
      my $class = __PACKAGE__;
      my ($r) = @_;
  
      return try {
          my $app = $class->load_app( $r->filename );
          $class->call_app( $r, $app );
      }catch{
          if(/no such file/i){
              $r->log_error( $_ );
              return Apache2::Const::NOT_FOUND;
          }else{
              $r->log_error( $_ );
              return Apache2::Const::SERVER_ERROR;
          }
      };
  }
  
  # Overriding
  sub fixup_path {
      my ($class, $r, $env) = @_;
      $env->{PATH_INFO} =~ s{^$env->{SCRIPT_NAME}}{};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::Apache2::Registry - Runs .psgi files.
  
  =head1 SYNOPSIS
  
    PerlModule Plack::Handler::Apache2::Registry;
    <Location /psgi-bin>
    SetHandler modperl
    PerlHandler Plack::Handler::Apache2::Registry
    </Location>
  
  =head1 DESCRIPTION
  
  This is a handler module to run any *.psgi files with mod_perl2,
  just like ModPerl::Registry.
  
  =head1 AUTHOR
  
  Masahiro Honma E<lt>hiratara@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Plack::Handler::Apache2>
  
  =cut
  
PLACK_HANDLER_APACHE2_REGISTRY

$fatpacked{"Plack/Handler/CGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER_CGI';
  package Plack::Handler::CGI;
  use strict;
  use warnings;
  use IO::Handle;
  
  # copied from HTTP::Status
  my %StatusCode = (
      100 => 'Continue',
      101 => 'Switching Protocols',
      102 => 'Processing',                      # RFC 2518 (WebDAV)
      200 => 'OK',
      201 => 'Created',
      202 => 'Accepted',
      203 => 'Non-Authoritative Information',
      204 => 'No Content',
      205 => 'Reset Content',
      206 => 'Partial Content',
      207 => 'Multi-Status',                    # RFC 2518 (WebDAV)
      300 => 'Multiple Choices',
      301 => 'Moved Permanently',
      302 => 'Found',
      303 => 'See Other',
      304 => 'Not Modified',
      305 => 'Use Proxy',
      307 => 'Temporary Redirect',
      400 => 'Bad Request',
      401 => 'Unauthorized',
      402 => 'Payment Required',
      403 => 'Forbidden',
      404 => 'Not Found',
      405 => 'Method Not Allowed',
      406 => 'Not Acceptable',
      407 => 'Proxy Authentication Required',
      408 => 'Request Timeout',
      409 => 'Conflict',
      410 => 'Gone',
      411 => 'Length Required',
      412 => 'Precondition Failed',
      413 => 'Request Entity Too Large',
      414 => 'Request-URI Too Large',
      415 => 'Unsupported Media Type',
      416 => 'Request Range Not Satisfiable',
      417 => 'Expectation Failed',
      422 => 'Unprocessable Entity',            # RFC 2518 (WebDAV)
      423 => 'Locked',                          # RFC 2518 (WebDAV)
      424 => 'Failed Dependency',               # RFC 2518 (WebDAV)
      425 => 'No code',                         # WebDAV Advanced Collections
      426 => 'Upgrade Required',                # RFC 2817
      449 => 'Retry with',                      # unofficial Microsoft
      500 => 'Internal Server Error',
      501 => 'Not Implemented',
      502 => 'Bad Gateway',
      503 => 'Service Unavailable',
      504 => 'Gateway Timeout',
      505 => 'HTTP Version Not Supported',
      506 => 'Variant Also Negotiates',         # RFC 2295
      507 => 'Insufficient Storage',            # RFC 2518 (WebDAV)
      509 => 'Bandwidth Limit Exceeded',        # unofficial
      510 => 'Not Extended',                    # RFC 2774
  );
  
  sub new { bless {}, shift }
  
  sub run {
      my ($self, $app) = @_;
  
      my $env = $self->setup_env();
  
      my $res = $app->($env);
      if (ref $res eq 'ARRAY') {
          $self->_handle_response($res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              $self->_handle_response($_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  }
  
  sub setup_env {
      my ( $self, $override_env ) = @_;
  
      $override_env ||= {};
  
      binmode STDIN;
      binmode STDERR;
  
      my $env = {
          %ENV,
          'psgi.version'    => [ 1, 1 ],
          'psgi.url_scheme' => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'      => *STDIN,
          'psgi.errors'     => *STDERR,
          'psgi.multithread'  => 0,
          'psgi.multiprocess' => 1,
          'psgi.run_once'     => 1,
          'psgi.streaming'    => 1,
          'psgi.nonblocking'  => 1,
          %{ $override_env },
      };
  
      delete $env->{HTTP_CONTENT_TYPE};
      delete $env->{HTTP_CONTENT_LENGTH};
      $env->{'HTTP_COOKIE'} ||= $ENV{COOKIE}; # O'Reilly server bug
  
      if (!exists $env->{PATH_INFO}) {
          $env->{PATH_INFO} = '';
      }
  
      if ($env->{SCRIPT_NAME} eq '/') {
          $env->{SCRIPT_NAME} = '';
          $env->{PATH_INFO}   = '/' . $env->{PATH_INFO};
      }
  
      return $env;
  }
  
  
  
  sub _handle_response {
      my ($self, $res) = @_;
  
      *STDOUT->autoflush(1);
      binmode STDOUT;
  
      my $hdrs;
      my $message = $StatusCode{$res->[0]};
      $hdrs = "Status: $res->[0] $message\015\012";
  
      my $headers = $res->[1];
      while (my ($k, $v) = splice(@$headers, 0, 2)) {
          $hdrs .= "$k: $v\015\012";
      }
      $hdrs .= "\015\012";
  
      print STDOUT $hdrs;
  
      my $body = $res->[2];
      my $cb = sub { print STDOUT $_[0] };
  
      # inline Plack::Util::foreach here
      if (ref $body eq 'ARRAY') {
          for my $line (@$body) {
              $cb->($line) if length $line;
          }
      }
      elsif (defined $body) {
          local $/ = \65536 unless ref $/;
          while (defined(my $line = $body->getline)) {
              $cb->($line) if length $line;
          }
          $body->close;
      }
      else {
          return Plack::Handler::CGI::Writer->new;
      }
  }
  
  package Plack::Handler::CGI::Writer;
  sub new   { bless \do { my $x }, $_[0] }
  sub write { print STDOUT $_[1] }
  sub close { }
  
  package Plack::Handler::CGI;
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Handler::CGI - CGI handler for Plack
  
  =head1 SYNOPSIS
  
  Want to run PSGI application as a CGI script? Rename .psgi to .cgi and
  change the shebang line like:
  
    #!/usr/bin/env plackup
    # rest of the file can be the same as other .psgi file
  
  You can alternatively create a .cgi file that contains something like:
  
    #!/usr/bin/perl
    use Plack::Loader;
    my $app = Plack::Util::load_psgi("/path/to/app.psgi");
    Plack::Loader->auto->run($app);
  
  This will auto-recognize the CGI environment variable to load this class.
  
  If you really want to explicitly load the CGI handler, you can. For instance
  you might do this when you want to embed a PSGI application server built into
  CGI-compatible perl-based web server:
  
    use Plack::Handler::CGI;
    Plack::Handler::CGI->new->run($app);
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application as a CGI script.
  
  =head1 UTILITY METHODS
  
  =head2 setup_env()
  
    my $env = Plack::Handler::CGI->setup_env();
    my $env = Plack::Handler::CGI->setup_env(\%override_env);
  
  Sets up the PSGI environment hash for a CGI request from C<< %ENV >>> and returns it.
  You can provide a hashref of key/value pairs to override the defaults if you would like.
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
  
PLACK_HANDLER_CGI

$fatpacked{"Plack/Handler/FCGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER_FCGI';
  package Plack::Handler::FCGI;
  use strict;
  use warnings;
  use constant RUNNING_IN_HELL => $^O eq 'MSWin32';
  
  use Scalar::Util qw(blessed);
  use Plack::Util;
  use FCGI;
  use HTTP::Status qw(status_message);
  use URI;
  use URI::Escape;
  
  sub new {
      my $class = shift;
      my $self  = bless {@_}, $class;
  
      $self->{leave_umask} ||= 0;
      $self->{keep_stderr} ||= 0;
      $self->{nointr}      ||= 0;
      $self->{daemonize}   ||= $self->{detach}; # compatibility
      $self->{nproc}       ||= 1 unless blessed $self->{manager};
      $self->{pid}         ||= $self->{pidfile}; # compatibility
      $self->{listen}      ||= [ ":$self->{port}" ] if $self->{port}; # compatibility
      $self->{backlog}     ||= 100;
      $self->{manager}     = 'FCGI::ProcManager' unless exists $self->{manager};
  
      $self;
  }
  
  sub run {
      my ($self, $app) = @_;
  
      my $sock = 0;
      if (-S STDIN) {
          # running from web server. Do nothing
          # Note it should come before listen check because of plackup's default
      } elsif ($self->{listen}) {
          my $old_umask = umask;
          unless ($self->{leave_umask}) {
              umask(0);
          }
          $sock = FCGI::OpenSocket( $self->{listen}->[0], $self->{backlog} )
              or die "failed to open FastCGI socket: $!";
          unless ($self->{leave_umask}) {
              umask($old_umask);
          }
      } elsif (!RUNNING_IN_HELL) {
          die "STDIN is not a socket: specify a listen location";
      }
  
      @{$self}{qw(stdin stdout stderr)} 
        = (IO::Handle->new, IO::Handle->new, IO::Handle->new);
  
      my %env;
      my $request = FCGI::Request(
          $self->{stdin}, $self->{stdout}, $self->{stderr},
          \%env, $sock,
          ($self->{nointr} ? 0 : &FCGI::FAIL_ACCEPT_ON_INTR),
      );
  
      my $proc_manager;
  
      if ($self->{listen}) {
          $self->daemon_fork if $self->{daemonize};
  
          if ($self->{manager}) {
              if (blessed $self->{manager}) {
                  for (qw(nproc pid proc_title)) {
                      die "Don't use '$_' when passing in a 'manager' object"
                          if $self->{$_};
                  }
                  $proc_manager = $self->{manager};
              } else {
                  Plack::Util::load_class($self->{manager});
                  $proc_manager = $self->{manager}->new({
                      n_processes => $self->{nproc},
                      pid_fname   => $self->{pid},
                      (exists $self->{proc_title}
                           ? (pm_title => $self->{proc_title}) : ()),
                  });
              }
  
              # detach *before* the ProcManager inits
              $self->daemon_detach if $self->{daemonize};
  
              $proc_manager->pm_manage;
          }
          elsif ($self->{daemonize}) {
              $self->daemon_detach;
          }
      }
  
      while ($request->Accept >= 0) {
          $proc_manager && $proc_manager->pm_pre_dispatch;
  
          my $env = {
              %env,
              'psgi.version'      => [1,1],
              'psgi.url_scheme'   => ($env{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
              'psgi.input'        => $self->{stdin},
              'psgi.errors'       => 
                  ($self->{keep_stderr} ? \*STDERR : $self->{stderr}),
              'psgi.multithread'  => Plack::Util::FALSE,
              'psgi.multiprocess' => Plack::Util::TRUE,
              'psgi.run_once'     => Plack::Util::FALSE,
              'psgi.streaming'    => Plack::Util::TRUE,
              'psgi.nonblocking'  => Plack::Util::FALSE,
              'psgix.harakiri'    => defined $proc_manager,
          };
  
          delete $env->{HTTP_CONTENT_TYPE};
          delete $env->{HTTP_CONTENT_LENGTH};
  
          # lighttpd munges multiple slashes in PATH_INFO into one. Try recovering it
          my $uri = URI->new("http://localhost" .  $env->{REQUEST_URI});
          $env->{PATH_INFO} = uri_unescape($uri->path);
          $env->{PATH_INFO} =~ s/^\Q$env->{SCRIPT_NAME}\E//;
  
          # root access for mod_fastcgi
          if (!exists $env->{PATH_INFO}) {
              $env->{PATH_INFO} = '';
          }
  
          # typical fastcgi_param from nginx might get empty values
          for my $key (qw(CONTENT_TYPE CONTENT_LENGTH)) {
              no warnings;
              delete $env->{$key} if exists $env->{$key} && $env->{$key} eq '';
          }
  
          if (defined(my $HTTP_AUTHORIZATION = $env->{Authorization})) {
              $env->{HTTP_AUTHORIZATION} = $HTTP_AUTHORIZATION;
          }
  
          my $res = Plack::Util::run_app $app, $env;
  
          if (ref $res eq 'ARRAY') {
              $self->_handle_response($res);
          }
          elsif (ref $res eq 'CODE') {
              $res->(sub {
                  $self->_handle_response($_[0]);
              });
          }
          else {
              die "Bad response $res";
          }
  
          # give pm_post_dispatch the chance to do things after the client thinks
          # the request is done
          $request->Finish;
  
          $proc_manager && $proc_manager->pm_post_dispatch();
  
          if ($proc_manager && $env->{'psgix.harakiri.commit'}) {
              $proc_manager->pm_exit("safe exit with harakiri");
          }
      }
  }
  
  sub _handle_response {
      my ($self, $res) = @_;
  
      $self->{stdout}->autoflush(1);
      binmode $self->{stdout};
  
      my $hdrs;
      my $message = status_message($res->[0]);
      $hdrs = "Status: $res->[0] $message\015\012";
  
      my $headers = $res->[1];
      while (my ($k, $v) = splice @$headers, 0, 2) {
          $hdrs .= "$k: $v\015\012";
      }
      $hdrs .= "\015\012";
  
      print { $self->{stdout} } $hdrs;
  
      my $cb = sub { print { $self->{stdout} } $_[0] };
      my $body = $res->[2];
      if (defined $body) {
          Plack::Util::foreach($body, $cb);
      }
      else {
          return Plack::Util::inline_object
              write => $cb,
              close => sub { };
      }
  }
  
  sub daemon_fork {
      require POSIX;
      fork && exit;
  }
  
  sub daemon_detach {
      my $self = shift;
      print "FastCGI daemon started (pid $$)\n";
      open STDIN,  "+</dev/null" or die $!; ## no critic
      open STDOUT, ">&STDIN"     or die $!;
      open STDERR, ">&STDIN"     or die $!;
      POSIX::setsid();
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::FCGI - FastCGI handler for Plack
  
  =head1 SYNOPSIS
  
    # Run as a standalone daemon
    plackup -s FCGI --listen /tmp/fcgi.sock --daemonize --nproc 10
  
    # Run from your web server like mod_fastcgi
    #!/usr/bin/env plackup -s FCGI
    my $app = sub { ... };
  
    # Roll your own
    my $server = Plack::Handler::FCGI->new(
        nproc  => $num_proc,
        listen => [ $port_or_socket ],
        detach => 1,
    );
    $server->run($app);
  
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application as a standalone
  FastCGI daemon or a .fcgi script.
  
  =head2 OPTIONS
  
  =over 4
  
  =item listen
  
      listen => [ '/path/to/socket' ]
      listen => [ ':8080' ]
  
  Listen on a socket path, hostname:port, or :port.
  
  =item port
  
  listen via TCP on port on all interfaces (Same as C<< listen => ":$port" >>)
  
  =item leave-umask
  
  Set to 1 to disable setting umask to 0 for socket open
  
  =item nointr
  
  Do not allow the listener to be interrupted by Ctrl+C
  
  =item nproc
  
  Specify a number of processes for FCGI::ProcManager
  
  =item pid
  
  Specify a filename for the pid file
  
  =item manager
  
  Specify either a FCGI::ProcManager subclass, or an actual FCGI::ProcManager-compatible object.
  
    use FCGI::ProcManager::Dynamic;
    Plack::Handler::FCGI->new(
        manager => FCGI::ProcManager::Dynamic->new(...),
    );
  
  =item daemonize
  
  Daemonize the process.
  
  =item proc-title
  
  Specify process title
  
  =item keep-stderr
  
  Send psgi.errors to STDERR instead of to the FCGI error stream.
  
  =item backlog
  
  Maximum length of the queue of pending connections
  
  =back
  
  =head2 WEB SERVER CONFIGURATIONS
  
  In all cases, you will want to install L<FCGI> and L<FCGI::ProcManager>.
  You may find it most convenient to simply install L<Task::Plack> which
  includes both of these.
  
  =head3 nginx
  
  This is an example nginx configuration to run your FCGI daemon on a
  Unix domain socket and run it at the server's root URL (/).
  
    http {
      server {
        listen 3001;
        location / {
          set $script "";
          set $path_info $uri;
          fastcgi_pass unix:/tmp/fastcgi.sock;
          fastcgi_param  SCRIPT_NAME      $script;
          fastcgi_param  PATH_INFO        $path_info;
          fastcgi_param  QUERY_STRING     $query_string;
          fastcgi_param  REQUEST_METHOD   $request_method;
          fastcgi_param  CONTENT_TYPE     $content_type;
          fastcgi_param  CONTENT_LENGTH   $content_length;
          fastcgi_param  REQUEST_URI      $request_uri;
          fastcgi_param  SERVER_PROTOCOL  $server_protocol;
          fastcgi_param  REMOTE_ADDR      $remote_addr;
          fastcgi_param  REMOTE_PORT      $remote_port;
          fastcgi_param  SERVER_ADDR      $server_addr;
          fastcgi_param  SERVER_PORT      $server_port;
          fastcgi_param  SERVER_NAME      $server_name;
        }
      }
    }
  
  If you want to host your application in a non-root path, then you
  should mangle this configuration to set the path to C<SCRIPT_NAME> and
  the rest of the path in C<PATH_INFO>.
  
  See L<http://wiki.nginx.org/NginxFcgiExample> for more details.
  
  =head3 Apache mod_fastcgi
  
  After installing C<mod_fastcgi>, you should add the C<FastCgiExternalServer>
  directive to your Apache config:
  
    FastCgiExternalServer /tmp/myapp.fcgi -socket /tmp/fcgi.sock
  
    ## Then set up the location that you want to be handled by fastcgi:
  
    # EITHER from a given path
    Alias /myapp/ /tmp/myapp.fcgi/
  
    # OR at the root
    Alias / /tmp/myapp.fcgi/
  
  Now you can use plackup to listen to the socket that you've just configured in Apache.
  
    $  plackup -s FCGI --listen /tmp/myapp.sock psgi/myapp.psgi
  
  The above describes the "standalone" method, which is usually appropriate.
  There are other methods, described in more detail at 
  L<Catalyst::Engine::FastCGI/Standalone_server_mode> (with regards to Catalyst, but which may be set up similarly for Plack).
  
  See also L<http://www.fastcgi.com/mod_fastcgi/docs/mod_fastcgi.html#FastCgiExternalServer>
  for more details.
  
  =head3 lighttpd
  
  To host the app in the root path, you're recommended to use lighttpd
  1.4.23 or newer with C<fix-root-scriptname> flag like below.
  
    fastcgi.server = ( "/" =>
       ((
         "socket" => "/tmp/fcgi.sock",
         "check-local" => "disable",
         "fix-root-scriptname" => "enable",
       ))
  
  If you use lighttpd older than 1.4.22 where you don't have
  C<fix-root-scriptname>, mounting apps under the root causes wrong
  C<SCRIPT_NAME> and C<PATH_INFO> set. Also, mounting under the empty
  root (C<"">) or a path that has a trailing slash would still cause
  weird values set even with C<fix-root-scriptname>. In such cases you
  can use L<Plack::Middleware::LighttpdScriptNameFix> to fix it.
  
  To mount in the non-root path over TCP:
  
    fastcgi.server = ( "/foo" =>
       ((
         "host" = "127.0.0.1",
         "port" = "5000",
         "check-local" => "disable",
       ))
  
  It's recommended that your mount path does B<NOT> have the trailing
  slash. If you I<really> need to have one, you should consider using
  L<Plack::Middleware::LighttpdScriptNameFix> to fix the wrong
  B<PATH_INFO> values set by lighttpd.
  
  =cut
  
  =head2 Authorization
  
  Most fastcgi configuration does not pass C<Authorization> headers to
  C<HTTP_AUTHORIZATION> environment variable by default for security
  reasons. Authentication middleware such as L<Plack::Middleware::Auth::Basic> or
  L<Catalyst::Authentication::Credential::HTTP> requires the variable to
  be set up. Plack::Handler::FCGI supports extracting the C<Authorization> environment
  variable when it is configured that way.
  
  Apache2 with mod_fastcgi:
  
    --pass-header Authorization
  
  mod_fcgid:
  
    FcgiPassHeader Authorization
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_HANDLER_FCGI

$fatpacked{"Plack/Handler/HTTP/Server/PSGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER_HTTP_SERVER_PSGI';
  package Plack::Handler::HTTP::Server::PSGI;
  use strict;
  
  # for temporary backward compat
  use parent qw( HTTP::Server::PSGI );
  
  sub new {
      my($class, %args) = @_;
      bless { %args }, $class;
  }
  
  sub run {
      my($self, $app) = @_;
      $self->_server->run($app);
  }
  
  sub _server {
      my $self = shift;
      HTTP::Server::PSGI->new(%$self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::HTTP::Server::PSGI - adapter for HTTP::Server::PSGI
  
  =head1 SYNOPSIS
  
    % plackup -s HTTP::Server::PSGI \
        --host 127.0.0.1 --port 9091 --timeout 120
  
  =head1 BACKWARD COMPATIBLITY
  
  Since Plack 0.99_22 this handler doesn't support preforking
  configuration i.e. C<--max-workers>. Use L<Starman> or L<Starlet> if
  you need preforking PSGI web server.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item host
  
  Host the server binds to. Defaults to all interfaces.
  
  =item port
  
  Port number the server listens on. Defaults to 8080.
  
  =item timeout
  
  Number of seconds a request times out. Defaults to 300.
  
  =item max-reqs-per-child
  
  Number of requests per worker to process. Defaults to 100.
  
  =back
  
  =head1 AUTHOR
  
  Kazuho Oku
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack> L<HTTP::Server::PSGI>
  
  =cut
PLACK_HANDLER_HTTP_SERVER_PSGI

$fatpacked{"Plack/Handler/Standalone.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER_STANDALONE';
  package Plack::Handler::Standalone;
  use strict;
  use warnings;
  use parent qw( Plack::Handler::HTTP::Server::PSGI );
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::Standalone - adapter for HTTP::Server::PSGI
  
  =head1 SYNOPSIS
  
    % plackup -s Standalone \
        --host 127.0.0.1 --port 9091 --timeout 120
  
  =head1 DESCRIPTION
  
  Plack::Handler::Standalone is an adapter for default Plack server
  implementation L<HTTP::Server::PSGI>. This is just an alias for
  L<Plack::Handler::HTTP::Server::PSGI>.
  
  =head1 SEE ALSO
  
  L<Plack::Handler::HTTP::Server::PSGI>
  
  =cut
PLACK_HANDLER_STANDALONE

$fatpacked{"Plack/LWPish.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_LWPISH';
  package Plack::LWPish;
  use strict;
  use warnings;
  use HTTP::Tiny;
  use HTTP::Response;
  use Hash::MultiValue;
  
  sub new {
      my $class = shift;
      my $self  = bless {}, $class;
      $self->{http} = @_ == 1 ? $_[0] : HTTP::Tiny->new(@_);
      $self;
  }
  
  sub request {
      my($self, $req) = @_;
  
      my @headers;
      $req->headers->scan(sub { push @headers, @_ });
  
      my $options = {
          headers => Hash::MultiValue->new(@headers)->mixed,
      };
      $options->{content} = $req->content if defined $req->content && length($req->content);
  
      my $response = $self->{http}->request($req->method, $req->url, $options);
  
      my $res = HTTP::Response->new(
          $response->{status},
          $response->{reason},
          [ Hash::MultiValue->from_mixed($response->{headers})->flatten ],
          $response->{content},
      );
      $res->request($req);
  
      return $res;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::LWPish - HTTP::Request/Response compatible interface with HTTP::Tiny backend
  
  =head1 SYNOPSIS
  
    use Plack::LWPish;
  
    my $request = HTTP::Request->new(GET => 'http://perl.com/');
  
    my $ua = Plack::LWPish->new;
    my $res = $ua->request($request); # returns HTTP::Response
  
  =head1 DESCRIPTION
  
  This module is an adapter object that implements one method,
  C<request> that acts like L<LWP::UserAgent>'s request method
  i.e. takes HTTP::Request object and returns HTTP::Response object.
  
  This module is used solely inside L<Plack::Test::Suite> and
  L<Plack::Test::Server>, and you are recommended to take a look at
  L<HTTP::Thin> if you would like to use this outside Plack.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<HTTP::Thin> L<HTTP::Tiny> L<LWP::UserAgent>
  
  =cut
PLACK_LWPISH

$fatpacked{"Plack/Loader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_LOADER';
  package Plack::Loader;
  use strict;
  use Carp ();
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my $class = shift;
      bless {}, $class;
  }
  
  sub watch {
      # do nothing. Override in subclass
  }
  
  sub auto {
      my($class, @args) = @_;
  
      my $backend = $class->guess
          or Carp::croak("Couldn't auto-guess server server implementation. Set it with PLACK_SERVER");
  
      my $server = try {
          $class->load($backend, @args);
      } catch {
          if (($ENV{PLACK_ENV}||'') eq 'development' or !/^Can't locate /) {
              warn "Autoloading '$backend' backend failed. Falling back to the Standalone. ",
                  "(You might need to install Plack::Handler::$backend from CPAN.  Caught error was: $_)\n"
                      if $ENV{PLACK_ENV} && $ENV{PLACK_ENV} eq 'development';
          }
          $class->load('Standalone' => @args);
      };
  
      return $server;
  }
  
  sub load {
      my($class, $server, @args) = @_;
  
      my($server_class, $error);
      try {
          $server_class = Plack::Util::load_class($server, 'Plack::Handler');
      } catch {
          $error ||= $_;
      };
  
      if ($server_class) {
          $server_class->new(@args);
      } else {
          die $error;
      }
  }
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{app} = $builder->();
  }
  
  sub guess {
      my $class = shift;
  
      my $env = $class->env;
  
      return $env->{PLACK_SERVER} if $env->{PLACK_SERVER};
  
      if ($env->{PHP_FCGI_CHILDREN} || $env->{FCGI_ROLE} || $env->{FCGI_SOCKET_PATH}) {
          return "FCGI";
      } elsif ($env->{GATEWAY_INTERFACE}) {
          return "CGI";
      } elsif (exists $INC{"Coro.pm"}) {
          return "Corona";
      } elsif (exists $INC{"AnyEvent.pm"}) {
          return "Twiggy";
      } elsif (exists $INC{"POE.pm"}) {
          return "POE";
      } else {
          return "Standalone";
      }
  }
  
  sub env { \%ENV }
  
  sub run {
      my($self, $server, $builder) = @_;
      $server->run($self->{app});
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader - (auto)load Plack Servers
  
  =head1 SYNOPSIS
  
    # auto-select server backends based on env vars
    use Plack::Loader;
    Plack::Loader->auto(%args)->run($app);
  
    # specify the implementation with a name
    Plack::Loader->load('FCGI', %args)->run($app);
  
  =head1 DESCRIPTION
  
  Plack::Loader is a factory class to load one of Plack::Handler subclasses based on the environment.
  
  =head1 AUTOLOADING
  
  C<< Plack::Loader->auto(%args) >> will autoload the most correct
  server implementation by guessing from environment variables and Perl INC
  hashes.
  
  =over 4
  
  =item PLACK_SERVER
  
    env PLACK_SERVER=AnyEvent ...
  
  Plack users can specify the specific implementation they want to load
  using the C<PLACK_SERVER> environment variable.
  
  =item PHP_FCGI_CHILDREN, GATEWAY_INTERFACE
  
  If there's one of FastCGI or CGI specific environment variables set,
  use the corresponding server implementation.
  
  =item %INC
  
  If one of L<AnyEvent>, L<Coro> or L<POE> is loaded, the relevant
  server implementation such as L<Twiggy>, L<Corona> or
  L<POE::Component::Server::PSGI> will be loaded, if they're available.
  
  =back
  
  =cut
  
  
PLACK_LOADER

$fatpacked{"Plack/Loader/Delayed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_LOADER_DELAYED';
  package Plack::Loader::Delayed;
  use strict;
  use parent qw(Plack::Loader);
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = $builder;
  }
  
  sub run {
      my($self, $server) = @_;
  
      my $compiled;
      my $app = sub {
          $compiled ||= $self->{builder}->();
          $compiled->(@_);
      };
  
      $server->{psgi_app_builder} = $self->{builder};
      $server->run($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Delayed - Delay the loading of .psgi until the first run
  
  =head1 SYNOPSIS
  
    plackup -s Starlet -L Delayed myapp.psgi
  
  =head1 DESCRIPTION
  
  This loader delays the compilation of specified PSGI application until
  the first request time. This prevents bad things from happening with
  preforking web servers like L<Starlet>, when your application
  manipulates resources such as sockets or database connections in the
  master startup process and then shared by children.
  
  You can combine this loader with C<-M> command line option, like:
  
    plackup -s Starlet -MCatalyst -L Delayed myapp.psgi
  
  loads the module Catalyst in the master process for the better process
  management with copy-on-write, however the application C<myapp.psgi>
  is loaded per children.
  
  L<Starman> since version 0.2000 loads this loader by default unless
  you specify the command line option C<--preload-app> for the
  L<starman> executable.
  
  =head1 DEVELOPERS
  
  Web server developers can make use of C<psgi_app_builder> attribute
  callback set in Plack::Handler, to load the application earlier than
  the first request time.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
  
PLACK_LOADER_DELAYED

$fatpacked{"Plack/Loader/Restarter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_LOADER_RESTARTER';
  package Plack::Loader::Restarter;
  use strict;
  use warnings;
  use parent qw(Plack::Loader);
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my($class, $runner) = @_;
      bless { watch => [] }, $class;
  }
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = $builder;
  }
  
  sub watch {
      my($self, @dir) = @_;
      push @{$self->{watch}}, @dir;
  }
  
  sub _fork_and_start {
      my($self, $server) = @_;
  
      delete $self->{pid}; # re-init in case it's a restart
  
      my $pid = fork;
      die "Can't fork: $!" unless defined $pid;
  
      if ($pid == 0) { # child
          return $server->run($self->{builder}->());
      } else {
          $self->{pid} = $pid;
      }
  }
  
  sub _kill_child {
      my $self = shift;
  
      my $pid = $self->{pid} or return;
      warn "Killing the existing server (pid:$pid)\n";
      kill 'TERM' => $pid;
      waitpid($pid, 0);
  }
  
  sub valid_file {
      my($self, $file) = @_;
  
      # vim temporary file is  4913 to 5036
      # http://www.mail-archive.com/vim_dev@googlegroups.com/msg07518.html
      if ( $file->{path} =~ m{(\d+)$} && $1 >= 4913 && $1 <= 5036) {
          return 0;
      }
      $file->{path} !~ m!\.(?:git|svn)[/\\]|\.(?:bak|swp|swpx|swx)$|~$|_flymake\.p[lm]$|\.#!;
  }
  
  sub run {
      my($self, $server, $builder) = @_;
  
      $self->_fork_and_start($server, $builder);
      return unless $self->{pid};
  
      require Filesys::Notify::Simple;
      my $watcher = Filesys::Notify::Simple->new($self->{watch});
      warn "Watching @{$self->{watch}} for file updates.\n";
      local $SIG{TERM} = sub { $self->_kill_child; exit(0); };
  
      while (1) {
          my @restart;
  
          # this is blocking
          $watcher->wait(sub {
              my @events = @_;
              @events = grep $self->valid_file($_), @events;
              return unless @events;
  
              @restart = @events;
          });
  
          next unless @restart;
  
          for my $ev (@restart) {
              warn "-- $ev->{path} updated.\n";
          }
  
          $self->_kill_child;
          warn "Successfully killed! Restarting the new server process.\n";
          $self->_fork_and_start($server, $builder);
          return unless $self->{pid};
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Restarter - Restarting loader
  
  =head1 SYNOPSIS
  
    plackup -r -R paths
  
  =head1 DESCRIPTION
  
  Plack::Loader::Restarter is a loader backend that implements C<-r> and
  C<-R> option for the L<plackup> script. It forks the server as a child
  process and the parent watches the directories for file updates, and
  whenever it receives the notification, kills the child server and
  restart.
  
  =head1 SEE ALSO
  
  L<Plack::Runner>, L<Catalyst::Restarter>
  
  =cut
PLACK_LOADER_RESTARTER

$fatpacked{"Plack/Loader/Shotgun.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_LOADER_SHOTGUN';
  package Plack::Loader::Shotgun;
  use strict;
  use parent qw(Plack::Loader);
  use Storable;
  use Try::Tiny;
  use Plack::Middleware::BufferedStreaming;
  
  die <<DIE if $^O eq 'MSWin32' && !$ENV{PLACK_SHOTGUN_MEMORY_LEAK};
  
  Shotgun loader uses fork(2) system call to create a fresh Perl interpreter, that is known to not work
  properly in a fork-emulation layer on Windows and cause huge memory leaks.
  
  If you're aware of this and still want to run the loader, run it with the environment variable
  PLACK_SHOTGUN_MEMORY_LEAK on.
  
  DIE
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = sub { Plack::Middleware::BufferedStreaming->wrap($builder->()) };
  }
  
  sub run {
      my($self, $server) = @_;
  
      my $app = sub {
          my $env = shift;
  
          pipe my $read, my $write;
  
          my $pid = fork;
          if ($pid) {
              # parent
              close $write;
              my $res = Storable::thaw(join '', <$read>);
              close $read;
              waitpid($pid, 0);
  
              return $res;
          } else {
              # child
              close $read;
  
              my $res;
              try {
                  $env->{'psgi.streaming'} = 0;
                  $res = $self->{builder}->()->($env);
                  my @body;
                  Plack::Util::foreach($res->[2], sub { push @body, $_[0] });
                  $res->[2] = \@body;
              } catch {
                  $env->{'psgi.errors'}->print($_);
                  $res = [ 500, [ "Content-Type", "text/plain" ], [ "Internal Server Error" ] ];
              };
  
              print {$write} Storable::freeze($res);
              close $write;
              exit;
          }
      };
  
      $server->run($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Shotgun - forking implementation of plackup
  
  =head1 SYNOPSIS
  
    plackup -L Shotgun
  
  =head1 DESCRIPTION
  
  Shotgun loader delays the compilation and execution of your
  application until the runtime. When a new request comes in, this forks
  a new child, compiles your code and runs the application.
  
  This should be an ultimate alternative solution when reloading with
  L<Plack::Middleware::Refresh> doesn't work, or plackup's default C<-r>
  filesystem watcher causes problems. I can imagine this is useful for
  applications which expects their application is only evaluated once
  (like in-file templates) or on operating systems with broken fork
  implementation, etc.
  
  This is much like good old CGI's fork and run but you don't need a web
  server, and there's a benefit of preloading modules that are not
  likely to change. For instance if you develop a web application using
  Moose and DBIx::Class,
  
    plackup -MMoose -MDBIx::Class -L Shotgun yourapp.psgi
  
  would preload those modules and only re-evaluates your code in every
  request.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa with an inspiration from L<http://github.com/rtomayko/shotgun>
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
PLACK_LOADER_SHOTGUN

$fatpacked{"Plack/MIME.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIME';
  package Plack::MIME;
  use strict;
  
  # stolen from rack.mime.rb
  our $MIME_TYPES = {
      ".3gp"     => "video/3gpp",
      ".a"       => "application/octet-stream",
      ".ai"      => "application/postscript",
      ".aif"     => "audio/x-aiff",
      ".aiff"    => "audio/x-aiff",
      ".asc"     => "application/pgp-signature",
      ".asf"     => "video/x-ms-asf",
      ".asm"     => "text/x-asm",
      ".asx"     => "video/x-ms-asf",
      ".atom"    => "application/atom+xml",
      ".au"      => "audio/basic",
      ".avi"     => "video/x-msvideo",
      ".bat"     => "application/x-msdownload",
      ".bin"     => "application/octet-stream",
      ".bmp"     => "image/bmp",
      ".bz2"     => "application/x-bzip2",
      ".c"       => "text/x-c",
      ".cab"     => "application/vnd.ms-cab-compressed",
      ".cc"      => "text/x-c",
      ".chm"     => "application/vnd.ms-htmlhelp",
      ".class"   => "application/octet-stream",
      ".com"     => "application/x-msdownload",
      ".conf"    => "text/plain",
      ".cpp"     => "text/x-c",
      ".crt"     => "application/x-x509-ca-cert",
      ".css"     => "text/css",
      ".csv"     => "text/csv",
      ".cxx"     => "text/x-c",
      ".deb"     => "application/x-debian-package",
      ".der"     => "application/x-x509-ca-cert",
      ".diff"    => "text/x-diff",
      ".djv"     => "image/vnd.djvu",
      ".djvu"    => "image/vnd.djvu",
      ".dll"     => "application/x-msdownload",
      ".dmg"     => "application/octet-stream",
      ".doc"     => "application/msword",
      ".dot"     => "application/msword",
      ".dtd"     => "application/xml-dtd",
      ".dvi"     => "application/x-dvi",
      ".ear"     => "application/java-archive",
      ".eml"     => "message/rfc822",
      ".eps"     => "application/postscript",
      ".exe"     => "application/x-msdownload",
      ".f"       => "text/x-fortran",
      ".f77"     => "text/x-fortran",
      ".f90"     => "text/x-fortran",
      ".flv"     => "video/x-flv",
      ".for"     => "text/x-fortran",
      ".gem"     => "application/octet-stream",
      ".gemspec" => "text/x-script.ruby",
      ".gif"     => "image/gif",
      ".gz"      => "application/x-gzip",
      ".h"       => "text/x-c",
      ".hh"      => "text/x-c",
      ".htm"     => "text/html",
      ".html"    => "text/html",
      ".ico"     => "image/vnd.microsoft.icon",
      ".ics"     => "text/calendar",
      ".ifb"     => "text/calendar",
      ".iso"     => "application/octet-stream",
      ".jar"     => "application/java-archive",
      ".java"    => "text/x-java-source",
      ".jnlp"    => "application/x-java-jnlp-file",
      ".jpeg"    => "image/jpeg",
      ".jpg"     => "image/jpeg",
      ".js"      => "application/javascript",
      ".json"    => "application/json",
      ".log"     => "text/plain",
      ".m3u"     => "audio/x-mpegurl",
      ".m4v"     => "video/mp4",
      ".man"     => "text/troff",
      ".manifest"=> "text/cache-manifest",
      ".mathml"  => "application/mathml+xml",
      ".mbox"    => "application/mbox",
      ".mdoc"    => "text/troff",
      ".me"      => "text/troff",
      ".mid"     => "audio/midi",
      ".midi"    => "audio/midi",
      ".mime"    => "message/rfc822",
      ".mml"     => "application/mathml+xml",
      ".mng"     => "video/x-mng",
      ".mov"     => "video/quicktime",
      ".mp3"     => "audio/mpeg",
      ".mp4"     => "video/mp4",
      ".mp4v"    => "video/mp4",
      ".mpeg"    => "video/mpeg",
      ".mpg"     => "video/mpeg",
      ".ms"      => "text/troff",
      ".msi"     => "application/x-msdownload",
      ".odp"     => "application/vnd.oasis.opendocument.presentation",
      ".ods"     => "application/vnd.oasis.opendocument.spreadsheet",
      ".odt"     => "application/vnd.oasis.opendocument.text",
      ".ogg"     => "application/ogg",
      ".ogv"     => "video/ogg",
      ".p"       => "text/x-pascal",
      ".pas"     => "text/x-pascal",
      ".pbm"     => "image/x-portable-bitmap",
      ".pdf"     => "application/pdf",
      ".pem"     => "application/x-x509-ca-cert",
      ".pgm"     => "image/x-portable-graymap",
      ".pgp"     => "application/pgp-encrypted",
      ".pkg"     => "application/octet-stream",
      ".pl"      => "text/x-script.perl",
      ".pm"      => "text/x-script.perl-module",
      ".png"     => "image/png",
      ".pnm"     => "image/x-portable-anymap",
      ".ppm"     => "image/x-portable-pixmap",
      ".pps"     => "application/vnd.ms-powerpoint",
      ".ppt"     => "application/vnd.ms-powerpoint",
      ".ps"      => "application/postscript",
      ".psd"     => "image/vnd.adobe.photoshop",
      ".py"      => "text/x-script.python",
      ".qt"      => "video/quicktime",
      ".ra"      => "audio/x-pn-realaudio",
      ".rake"    => "text/x-script.ruby",
      ".ram"     => "audio/x-pn-realaudio",
      ".rar"     => "application/x-rar-compressed",
      ".rb"      => "text/x-script.ruby",
      ".rdf"     => "application/rdf+xml",
      ".roff"    => "text/troff",
      ".rpm"     => "application/x-redhat-package-manager",
      ".rss"     => "application/rss+xml",
      ".rtf"     => "application/rtf",
      ".ru"      => "text/x-script.ruby",
      ".s"       => "text/x-asm",
      ".sgm"     => "text/sgml",
      ".sgml"    => "text/sgml",
      ".sh"      => "application/x-sh",
      ".sig"     => "application/pgp-signature",
      ".snd"     => "audio/basic",
      ".so"      => "application/octet-stream",
      ".svg"     => "image/svg+xml",
      ".svgz"    => "image/svg+xml",
      ".swf"     => "application/x-shockwave-flash",
      ".t"       => "text/troff",
      ".tar"     => "application/x-tar",
      ".tbz"     => "application/x-bzip-compressed-tar",
      ".tcl"     => "application/x-tcl",
      ".tex"     => "application/x-tex",
      ".texi"    => "application/x-texinfo",
      ".texinfo" => "application/x-texinfo",
      ".text"    => "text/plain",
      ".tif"     => "image/tiff",
      ".tiff"    => "image/tiff",
      ".torrent" => "application/x-bittorrent",
      ".tr"      => "text/troff",
      ".txt"     => "text/plain",
      ".vcf"     => "text/x-vcard",
      ".vcs"     => "text/x-vcalendar",
      ".vrml"    => "model/vrml",
      ".war"     => "application/java-archive",
      ".wav"     => "audio/x-wav",
      ".wma"     => "audio/x-ms-wma",
      ".wmv"     => "video/x-ms-wmv",
      ".wmx"     => "video/x-ms-wmx",
      ".woff"    => "application/font-woff",
      ".wrl"     => "model/vrml",
      ".wsdl"    => "application/wsdl+xml",
      ".xbm"     => "image/x-xbitmap",
      ".xhtml"   => "application/xhtml+xml",
      ".xls"     => "application/vnd.ms-excel",
      ".xml"     => "application/xml",
      ".xpm"     => "image/x-xpixmap",
      ".xsl"     => "application/xml",
      ".xslt"    => "application/xslt+xml",
      ".yaml"    => "text/yaml",
      ".yml"     => "text/yaml",
      ".zip"     => "application/zip",
  };
  
  my $fallback = sub { };
  
  sub mime_type {
      my($class, $file) = @_;
      $file =~ /(\.[a-zA-Z0-9]+)$/ or return;
      $MIME_TYPES->{lc $1} || $fallback->(lc $1);
  }
  
  sub add_type {
      my $class = shift;
      while (my($ext, $type) = splice @_, 0, 2) {
          $MIME_TYPES->{lc $ext} = $type;
      }
  }
  
  sub set_fallback {
      my($class, $cb) = @_;
      $fallback = $cb;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::MIME - MIME type registry
  
  =head1 SYNOPSIS
  
    use Plack::MIME;
  
    my $mime = Plack::MIME->mime_type(".png"); # image/png
  
    # register new type(s)
    Plack::MIME->add_type(".foo" => "application/x-foo");
  
    # Use MIME::Types as a fallback
    use MIME::Types 'by_suffix';
    Plack::MIME->set_fallback(sub { (by_suffix $_[0])[0] });
  
  =head1 DESCRIPTION
  
  Plack::MIME is a simple MIME type registry for Plack applications. The
  selection of MIME types is based on Rack's Rack::Mime module.
  
  =head1 SEE ALSO
  
  Rack::Mime L<MIME::Types>
  
  =cut
  
  
PLACK_MIME

$fatpacked{"Plack/Middleware.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE';
  package Plack::Middleware;
  use strict;
  use warnings;
  use Carp ();
  use parent qw(Plack::Component);
  use Plack::Util;
  use Plack::Util::Accessor qw( app );
  
  sub wrap {
      my($self, $app, @args) = @_;
      if (ref $self) {
          $self->{app} = $app;
      } else {
          $self = $self->new({ app => $app, @args });
      }
      return $self->to_app;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware - Base class for easy-to-use PSGI middleware
  
  =head1 SYNOPSIS
  
    package Plack::Middleware::Foo;
    use parent qw( Plack::Middleware );
  
    sub call {
        my($self, $env) = @_;
        # Do something with $env
  
        # $self->app is the original app
        my $res = $self->app->($env);
  
        # Do something with $res
        return $res;
    }
  
    # then in app.psgi
    use Plack::Builder;
  
    my $app = sub { ... } # as usual
  
    builder {
        enable "Plack::Middleware::Foo";
        enable "Plack::Middleware::Bar", %options;
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware is a utility base class to write PSGI
  middleware. All you have to do is to inherit from Plack::Middleware
  and then implement the callback C<call> method (or the C<to_app> method
  that would return the PSGI code reference) to do the actual work. You
  can use C<< $self->app >> to call the original (wrapped) application.
  
  Your middleware object is created at the PSGI application compile time
  and is persistent during the web server life cycle (unless it is a
  non-persistent environment such as CGI), so you should never set or
  cache per-request data like C<$env> in your middleware object. See
  also L<Plack::Component/"OBJECT LIFECYCLE">.
  
  See L<Plack::Builder> how to actually enable middleware in your
  I<.psgi> application file using the DSL. If you do not like our
  builder DSL, you can also use the C<wrap> method to wrap your application
  with a middleware:
  
    use Plack::Middleware::Foo;
  
    my $app = sub { ... };
    $app = Plack::Middleware::Foo->wrap($app, %options);
    $app = Plack::Middleware::Bar->wrap($app, %options);
  
  =head1 RESPONSE CALLBACK
  
  The typical middleware is written like this:
  
    package Plack::Middleware::Something;
    use parent qw(Plack::Middleware);
  
    sub call {
        my($self, $env) = @_;
        # pre-processing $env
        my $res = $self->app->($env);
        # post-processing $res
        return $res;
    }
  
  The tricky thing about post-processing the response is that it could
  either be an immediate 3 element array ref, or a code reference that
  implements the delayed (streaming) interface.
  
  Dealing with these two types of response in each piece of middleware
  is pointless, so you're recommended to use the C<response_cb> wrapper
  function in L<Plack::Util> when implementing a post processing
  middleware.
  
    my $res = $app->($env);
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        # do something with $res;
    });
  
  The callback function gets a PSGI response as a 3 element array
  reference, and you can update the reference to implement the post-processing.
  
    package Plack::Middleware::Always500;
    use parent qw(Plack::Middleware);
    use Plack::Util;
  
    sub call {
        my($self, $env) = @_;
        my $res  = $self->app->($env);
        Plack::Util::response_cb($res, sub {
            my $res = shift;
            $res->[0] = 500;
            return;
        });
    }
  
  In this example, the callback gets the C<$res> and updates its first
  element (status code) to 500. Using C<response_cb> makes sure that
  this works with the delayed response too.
  
  You're not required (and not recommended either) to return a new array
  reference - they will be simply ignored. You're suggested to
  explicitly return, unless you fiddle with the content filter callback
  (see below).
  
  Similarly, note that you have to keep the C<$res> reference when you
  swap the entire response.
  
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        $res = [ $new_status, $new_headers, $new_body ]; # THIS DOES NOT WORK
        return;
    });
  
  This does not work, since assigning a new anonymous array to C<$res>
  doesn't update the original PSGI response value. You should instead
  do:
  
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        @$res = ($new_status, $new_headers, $new_body); # THIS WORKS
        return;
    });
  
  The third element of the PSGI response array ref is a body, and it could
  be either an arrayref or L<IO::Handle>-ish object. The application could
  also make use of the C<$writer> object if C<psgi.streaming> is in
  effect. Dealing with these variants is again really painful, and
  C<response_cb> can take care of that too, by allowing you to return a
  content filter as a code reference.
  
    # replace all "Foo" in content body with "Bar"
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        return sub {
            my $chunk = shift;
            return unless defined $chunk;
            $chunk =~ s/Foo/Bar/g;
            return $chunk;
        }
    });
  
  The callback takes one argument C<$chunk> and your callback is
  expected to return the updated chunk. If the given C<$chunk> is undef,
  it means the stream has reached the end, so your callback should also
  return undef, or return the final chunk and return undef when called
  next time.
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Builder> L<Plack::Component>
  
  =cut
PLACK_MIDDLEWARE

$fatpacked{"Plack/Middleware/AccessLog.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_ACCESSLOG';
  package Plack::Middleware::AccessLog;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  use Plack::Util::Accessor qw( logger format compiled_format);
  use Apache::LogFormat::Compiler;
  
  my %formats = (
      common => '%h %l %u %t "%r" %>s %b',
      combined => '%h %l %u %t "%r" %>s %b "%{Referer}i" "%{User-agent}i"',
  );
  
  sub prepare_app {
      my $self = shift;
      my $fmt = $self->format || "combined";
      $fmt = $formats{$fmt} if exists $formats{$fmt};
      $self->compiled_format(Apache::LogFormat::Compiler->new($fmt));
  }
  
  sub call {
      my $self = shift;
      my($env) = @_;
  
      my $res = $self->app->($env);
  
      if ( ref($res) && ref($res) eq 'ARRAY' ) {
          my $content_length = Plack::Util::content_length($res->[2]);
          my $log_line = $self->log_line($res->[0], $res->[1], $env, { content_length => $content_length });
          if ( my $logger = $self->logger ) {
              $logger->($log_line);
          }
          else {
              $env->{'psgi.errors'}->print($log_line);
          }  
          return $res;
      }
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my $content_length = Plack::Util::content_length($res->[2]);
          my $log_line = $self->log_line($res->[0], $res->[1], $env, { content_length => $content_length });
          if ( my $logger = $self->logger ) {
              $logger->($log_line);
          }
          else {
              $env->{'psgi.errors'}->print($log_line);
          }  
      });
  }
  
  sub log_line {
      my($self, $status, $headers, $env, $opts) = @_;
  
      $self->compiled_format->log_line(
          $env,
          [$status,$headers],
          $opts->{content_length},
          $opts->{time}
      );
  }
  
  1;
  
  __END__
  
  =for stopwords
  LogFormat
  
  =head1 NAME
  
  Plack::Middleware::AccessLog - Logs requests like Apache's log format
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::AccessLog", format => "combined";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::AccessLog forwards the request to the given app and
  logs request and response details to the logger callback. The format
  can be specified using Apache-like format strings (or C<combined> or
  C<common> for the default formats). If none is specified C<combined> is
  used.
  
  This middleware uses calculable Content-Length by checking body type,
  and cannot log the time taken to serve requests. It also logs the
  request B<before> the response is actually sent to the client. Use
  L<Plack::Middleware::AccessLog::Timed> if you want to log details
  B<after> the response is transmitted (more like a real web server) to
  the client.
  
  This middleware is enabled by default when you run L<plackup> as a
  default C<development> environment.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item format
  
    enable "Plack::Middleware::AccessLog",
        format => '%h %l %u %t "%r" %>s %b "%{Referer}i" "%{User-agent}i"';
  
  Takes a format string (or a preset template C<combined> or C<custom>)
  to specify the log format. This middleware uses L<Apache::LogFormat::Compiler> to
  generate access_log lines. See more details on perldoc L<Apache::LogFormat::Compiler>
  
     %%    a percent sign
     %h    REMOTE_ADDR from the PSGI environment, or -
     %l    remote logname not implemented (currently always -)
     %u    REMOTE_USER from the PSGI environment, or -
     %t    [local timestamp, in default format]
     %r    REQUEST_METHOD, REQUEST_URI and SERVER_PROTOCOL from the PSGI environment
     %s    the HTTP status code of the response
     %b    content length of the response
     %T    custom field for handling times in subclasses
     %D    custom field for handling sub-second times in subclasses
     %v    SERVER_NAME from the PSGI environment, or -
     %V    HTTP_HOST or SERVER_NAME from the PSGI environment, or -
     %p    SERVER_PORT from the PSGI environment
     %P    the worker's process id
     %m    REQUEST_METHOD from the PSGI environment
     %U    PATH_INFO from the PSGI environment
     %q    QUERY_STRING from the PSGI environment
     %H    SERVER_PROTOCOL from the PSGI environment
  
  Some of these format fields are only supported by middleware that subclasses C<AccessLog>.
  
  In addition, custom values can be referenced, using C<%{name}>,
  with one of the mandatory modifier flags C<i>, C<o> or C<t>:
  
     %{variable-name}i    HTTP_VARIABLE_NAME value from the PSGI environment
     %{header-name}o      header-name header in the response
     %{time-format]t      localtime in the specified strftime format
  
  =item logger
  
    my $logger = Log::Dispatch->new(...);
    enable "Plack::Middleware::AccessLog",
        logger => sub { $logger->log(level => 'debug', message => @_) };
  
  Sets a callback to print log message to. It prints to the C<psgi.errors>
  output stream by default.
  
  =back
  
  =head1 AUTHORS
  
  Tatsuhiko Miyagawa
  
  Masahiro Nagano
  
  =head1 SEE ALSO
  
  L<Apache::LogFormat::Compiler>, L<http://httpd.apache.org/docs/2.2/mod/mod_log_config.html> Rack::CustomLogger
  
  =cut
  
PLACK_MIDDLEWARE_ACCESSLOG

$fatpacked{"Plack/Middleware/AccessLog/Timed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_ACCESSLOG_TIMED';
  package Plack::Middleware::AccessLog::Timed;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware::AccessLog );
  
  use Time::HiRes;
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my($env) = @_;
  
      my $time = Time::HiRes::gettimeofday;
      my $length = 0;
      my $logger = $self->logger || sub { $env->{'psgi.errors'}->print(@_) };
  
      my $res = $self->app->($env);
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my($status, $header, $body) = @$res;
  
          if (!defined $body) {
              my $length;
  
              return sub {
                  my $line = shift;
                  
                  $length += length $line if defined $line;
  
                  unless( defined $line ) {
                      my $now = Time::HiRes::gettimeofday;
                      $logger->( $self->log_line($status, $header, $env, { time => $now - $time, content_length => $length }) );
                  }
  
                  return $line;
              };
          }
  
          my $getline = ref $body eq 'ARRAY' ? sub { shift @$body } : sub { $body->getline };
  
          my $timer_body = Plack::Util::inline_object(
              getline => sub {
                  my $line = $getline->();
                  $length += length $line if defined $line;
                  return $line;
              },
              close => sub {
                  $body->close if ref $body ne 'ARRAY';
  
                  my $now = Time::HiRes::gettimeofday;
                  $logger->( $self->log_line($status, $header, $env, { time => $now - $time, content_length => $length }) );
              },
          );
  
          @$res = ($status, $header, $timer_body);
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::AccessLog::Timed - Logs requests with time and accurate body size
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::AccessLog::Timed",
            format => "%v %h %l %u %t \"%r\" %>s %b %D";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::AccessLog::Timed is a subclass of
  L<Plack::Middleware::AccessLog> but uses a wrapped body handle to get the
  actual response body size C<%b> (even if it's not a chunk of array or
  a real filehandle) and the time taken to serve the request: C<%T> or
  C<%D>.
  
  This wraps the response body output stream to capture the time taken
  for the PSGI server to read the whole response body.
  
  This would mean, if the middleware is in use, it will prevent some
  server-side optimizations like sendfile(2) from working, as well as
  middleware like L<Plack::Middleware::ContentLength> can't guess the
  body size out of the file handle.
  
  If all you want is to capture the time taken in your PSGI application
  and do not want the wrapped body behavior described above, consider instead
  applying L<Plack::Middleware::Runtime> and using L<Plack::Middleware::AccessLog>
  to log the C<X-Runtime> header.
  
  =head1 CONFIGURATION
  
  Same as L<Plack::Middleware::AccessLog>.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::AccessLog>
  
  L<Plack::Middleware::Runtime>
  
  =cut
PLACK_MIDDLEWARE_ACCESSLOG_TIMED

$fatpacked{"Plack/Middleware/Auth/Basic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_AUTH_BASIC';
  package Plack::Middleware::Auth::Basic;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw( realm authenticator );
  use Scalar::Util;
  use MIME::Base64;
  
  sub prepare_app {
      my $self = shift;
  
      my $auth = $self->authenticator or die 'authenticator is not set';
      if (Scalar::Util::blessed($auth) && $auth->can('authenticate')) {
          $self->authenticator(sub { $auth->authenticate(@_[0,1]) }); # because Authen::Simple barfs on 3 params
      } elsif (ref $auth ne 'CODE') {
          die 'authenticator should be a code reference or an object that responds to authenticate()';
      }
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $auth = $env->{HTTP_AUTHORIZATION}
          or return $self->unauthorized;
  
      # note the 'i' on the regex, as, according to RFC2617 this is a 
      # "case-insensitive token to identify the authentication scheme"
      if ($auth =~ /^Basic (.*)$/i) {
          my($user, $pass) = split /:/, (MIME::Base64::decode($1) || ":"), 2;
          $pass = '' unless defined $pass;
          if ($self->authenticator->($user, $pass, $env)) {
              $env->{REMOTE_USER} = $user;
              return $self->app->($env);
          }
      }
  
      return $self->unauthorized;
  }
  
  sub unauthorized {
      my $self = shift;
      my $body = 'Authorization required';
      return [
          401,
          [ 'Content-Type' => 'text/plain',
            'Content-Length' => length $body,
            'WWW-Authenticate' => 'Basic realm="' . ($self->realm || "restricted area") . '"' ],
          [ $body ],
      ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Auth::Basic - Simple basic authentication middleware
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
    my $app = sub { ... };
  
    builder {
        enable "Auth::Basic", authenticator => \&authen_cb;
        $app;
    };
  
    sub authen_cb {
        my($username, $password, $env) = @_;
        return $username eq 'admin' && $password eq 's3cr3t';
    }
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Auth::Basic is a basic authentication handler for Plack.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item authenticator
  
  A callback function that takes username, password and PSGI environment
  supplied and returns whether the authentication succeeds. Required.
  
  Authenticator can also be an object that responds to C<authenticate>
  method that takes username and password and returns boolean, so
  backends for L<Authen::Simple> is perfect to use:
  
    use Authen::Simple::LDAP;
    enable "Auth::Basic", authenticator => Authen::Simple::LDAP->new(...);
  
  =item realm
  
  Realm name to display in the basic authentication dialog. Defaults to I<restricted area>.
  
  =back
  
  =head1 LIMITATIONS
  
  This middleware expects that the application has a full access to the
  headers sent by clients in PSGI environment. That is normally the case
  with standalone Perl PSGI web servers such as L<Starman> or
  L<HTTP::Server::Simple::PSGI>.
  
  However, in a web server configuration where you can't achieve this
  (i.e. using your application via Apache's mod_cgi), this middleware
  does not work since your application can't know the value of
  C<Authorization:> header.
  
  If you use Apache as a web server and CGI to run your PSGI
  application, you can either a) compile Apache with
  C<-DSECURITY_HOLE_PASS_AUTHORIZATION> option, or b) use mod_rewrite to
  pass the Authorization header to the application with the rewrite rule
  like following.
  
    RewriteEngine on
    RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization},L]
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
PLACK_MIDDLEWARE_AUTH_BASIC

$fatpacked{"Plack/Middleware/BufferedStreaming.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_BUFFEREDSTREAMING';
  package Plack::Middleware::BufferedStreaming;
  use strict;
  no warnings;
  use Carp;
  use Plack::Util;
  use Plack::Util::Accessor qw(force);
  use Scalar::Util qw(weaken);
  use parent qw(Plack::Middleware);
  
  sub call {
      my ( $self, $env ) = @_;
  
      my $caller_supports_streaming = $env->{'psgi.streaming'};
      $env->{'psgi.streaming'} = Plack::Util::TRUE;
  
      my $res = $self->app->($env);
      return $res if $caller_supports_streaming && !$self->force;
  
      if ( ref($res) eq 'CODE' ) {
          my $ret;
  
          $res->(sub {
              my $write = shift;
  
              if ( @$write == 2 ) {
                  my @body;
  
                  $ret = [ @$write, \@body ];
  
                  return Plack::Util::inline_object(
                      write => sub { push @body, $_[0] },
                      close => sub { },
                  );
              } else {
                  $ret = $write;
                  return;
              }
          });
  
          return $ret;
      } else {
          return $res;
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::BufferedStreaming - Enable buffering for non-streaming aware servers
  
  =head1 SYNOPSIS
  
    enable "BufferedStreaming";
  
  =head1 DESCRIPTION
  
  Plack::Middleware::BufferedStreaming is a PSGI middleware component
  that wraps the application that uses C<psgi.streaming> interface to
  run on the servers that do not support the interface, by buffering the
  writer output to a temporary buffer.
  
  This middleware doesn't do anything and bypass the application if the
  server supports C<psgi.streaming> interface, unless you set C<force>
  option (see below).
  
  =head1 OPTIONS
  
  =over 4
  
  =item force
  
  Force enable this middleware only if the container supports C<psgi.streaming>.
  
  =back
  
  =head1 AUTHOR
  
  Yuval Kogman
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_BUFFEREDSTREAMING

$fatpacked{"Plack/Middleware/Chunked.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_CHUNKED';
  package Plack::Middleware::Chunked;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Plack::Util;
  
  sub call {
      my($self, $env) = @_;
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          if ($env->{'SERVER_PROTOCOL'} ne 'HTTP/1.0' and
              ! Plack::Util::status_with_no_entity_body($res->[0]) and
              ! $h->exists('Content-Length') and
              ! $h->exists('Transfer-Encoding')
          ) {
              $h->set('Transfer-Encoding' => 'chunked');
              my $done;
              return sub {
                  my $chunk = shift;
                  return if $done;
                  unless (defined $chunk) {
                      $done = 1;
                      return "0\015\012\015\012";
                  }
                  return '' unless length $chunk;
                  return sprintf('%x', length $chunk) . "\015\012$chunk\015\012";
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Chunked - Applies chunked encoding to the response body
  
  =head1 SYNOPSIS
  
    # Mostly from server implemenations
    $app = Plack::Middeware::Chunked->wrap($app);
  
  =head1 DESCRIPTION
  
  Plack::Middeware::Chunked is a middleware, or rather a library for
  PSGI server to automatically add chunked encoding to the response body
  when Content-Length is not set in the response header.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::Chunked
  
  =cut
PLACK_MIDDLEWARE_CHUNKED

$fatpacked{"Plack/Middleware/Conditional.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_CONDITIONAL';
  package Plack::Middleware::Conditional;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Plack::Util::Accessor qw( condition middleware builder );
  
  sub prepare_app {
      my $self = shift;
      $self->middleware( $self->builder->($self->app) );
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $app = $self->condition->($env) ? $self->middleware : $self->app;
      return $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Conditional - Conditional wrapper for Plack middleware
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    builder {
        enable_if { $_[0]->{REMOTE_ADDR} eq '127.0.0.1' } 'StackTrace', force => 1;
        $app;
    };
  
    # or using the OO interface:
    $app = Plack::Middleware::Conditional->wrap(
        $app,
        condition  => sub { $_[0]->{REMOTE_ADDR} eq '127.0.0.1' },
        builder => sub { Plack::Middleware::StackTrace->wrap($_[0], force => 1) },
    );
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Conditional is a piece of meta-middleware, to run a
  specific middleware component under runtime conditions. The goal of
  this middleware is to avoid baking runtime configuration options in
  individual middleware components, and rather share them as another
  middleware component.
  
  =head1 EXAMPLES
  
  Note that some of the middleware component names are just made up for
  the explanation and might not exist.
  
    # Minify JavaScript if the browser is Firefox
    enable_if { $_[0]->{HTTP_USER_AGENT} =~ /Firefox/ } 'JavaScriptMinifier';
  
    # Enable Stacktrace when being accessed from the local network
    enable_if { $_[0]->{REMOTE_ADDR} =~ /^10\.0\.1\.*/ } 'StackTrace';
  
    # Work with other conditional setter middleware:
    # Transcode Jpeg on the fly for mobile clients
    builder {
        enable 'MobileDetector';
        enable_if { $_[0]->{'plack.mobile_detected'} }
          'TranscodeJpeg', max_size => 30_000;
        $app;
    };
  
  Note that in the last example I<MobileDetector> should come first
  because the conditional check runs in I<pre-run> conditions, which is
  from outer to inner: that is, from the top to the bottom in the
  Builder DSL code.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Steve Cook
  
  =head1 SEE ALSO
  
  L<Plack::Builder>
  
  =cut
PLACK_MIDDLEWARE_CONDITIONAL

$fatpacked{"Plack/Middleware/ConditionalGET.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_CONDITIONALGET';
  package Plack::Middleware::ConditionalGET;
  use strict;
  use parent qw( Plack::Middleware );
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->app->($env);
      return $res unless $env->{REQUEST_METHOD} =~ /^(GET|HEAD)$/;
  
      $self->response_cb($res, sub {
          my $res = shift;
  
          my $h = Plack::Util::headers($res->[1]);
          if ( $self->etag_matches($h, $env) || $self->not_modified_since($h, $env) ) {
              $res->[0] = 304;
              $h->remove($_) for qw( Content-Type Content-Length Content-Disposition );
              if ($res->[2]) {
                  $res->[2] = [];
              } else {
                  return sub {
                      return defined $_[0] ? '' : undef;
                  };
              }
          }
      });
  }
  
  no warnings 'uninitialized';
  
  # RFC 2616 14.25 says it's OK and expected to use 'eq' :)
  # > Note: When handling an If-Modified-Since header field, some
  # > servers will use an exact date comparison function, rather than a
  # > less-than function, for deciding whether to send a 304 ...
  
  sub etag_matches {
      my($self, $h, $env) = @_;
      $h->exists('ETag') && $h->get('ETag') eq _value($env->{HTTP_IF_NONE_MATCH});
  }
  
  sub not_modified_since {
      my($self, $h, $env) = @_;
      $h->exists('Last-Modified') && $h->get('Last-Modified') eq _value($env->{HTTP_IF_MODIFIED_SINCE});
  }
  
  sub _value {
      my $str = shift;
      # IE sends wrong formatted value(i.e. "Thu, 03 Dec 2009 01:46:32 GMT; length=17936")
      $str =~ s/;.*$//;
      return $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ConditionalGET - Middleware to enable conditional GET
  
  =head1 SYNOPSIS
  
    builder {
        enable "ConditionalGET";
        ....
    };
  
  =head1 DESCRIPTION
  
  This middleware enables conditional GET and HEAD using
  C<If-None-Match> and C<If-Modified-Since> header. The application
  should set either or both of C<Last-Modified> or C<ETag> response
  headers per RFC 2616. When either of the conditions is met, the
  response body is set to be zero length and the status is set to 304
  Not Modified.
  
  =head1 SEE ALSO
  
  Rack::ConditionalGet
  
  =cut
PLACK_MIDDLEWARE_CONDITIONALGET

$fatpacked{"Plack/Middleware/ContentLength.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_CONTENTLENGTH';
  package Plack::Middleware::ContentLength;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my $res  = $self->app->(@_);
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          if (!Plack::Util::status_with_no_entity_body($res->[0]) &&
              !$h->exists('Content-Length') &&
              !$h->exists('Transfer-Encoding') &&
              defined(my $content_length = Plack::Util::content_length($res->[2]))) {
              $h->push('Content-Length' => $content_length);
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ContentLength - Adds Content-Length header automatically
  
  =head1 SYNOPSIS
  
    # in app.psgi
  
    builder {
        enable "Plack::Middleware::ContentLength";
        $app;
    }
  
    # Or in Plack::Handler::*
    $app = Plack::Middleware::ContentLength->wrap($app);
  
  =head1 DESCRIPTION
  
  Plack::Middleware::ContentLength is a middleware that automatically
  adds C<Content-Length> header when it's appropriate i.e. the response
  has a content body with calculable size (array of chunks or a real
  filehandle).
  
  This middleware can also be used as a library from PSGI server
  implementations to automatically set C<Content-Length> rather than in
  the end user level.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::ContentLength
  
  =cut
  
PLACK_MIDDLEWARE_CONTENTLENGTH

$fatpacked{"Plack/Middleware/ContentMD5.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_CONTENTMD5';
  package Plack::Middleware::ContentMD5;
  
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  use Digest::MD5 qw/md5_hex/;
  
  sub call {
      my $self = shift;
      my $res  = $self->app->(@_);
      
      $self->response_cb($res, sub {
          my $res = shift;
  
          return unless defined $res->[2];
          return if (Plack::Util::status_with_no_entity_body($res->[0]));
          
          my $h = Plack::Util::headers($res->[1]);
          return if ( $h->exists('Content-MD5') );
          
          my $body = $res->[2];
          if (ref $body eq 'ARRAY') {
              $h->set('Content-MD5', md5_hex(@$body));
          }
          # Do we need support $fh?
  
          return;
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ContentMD5 - Automatically sets the Content-MD5 header on all String bodies
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [ 'Content-Type' => 'text/plain' ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::ContentMD5";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Automatically sets the Content-MD5 header on all String bodies
  
  =head1 AUTHOR
  
  Fayland Lam
  
  =cut
PLACK_MIDDLEWARE_CONTENTMD5

$fatpacked{"Plack/Middleware/ErrorDocument.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_ERRORDOCUMENT';
  package Plack::Middleware::ErrorDocument;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  use Plack::MIME;
  use Plack::Util;
  use Plack::Util::Accessor qw( subrequest );
  
  use HTTP::Status qw(is_error);
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $r = $self->app->($env);
  
      $self->response_cb($r, sub {
          my $r = shift;
          unless (is_error($r->[0]) && exists $self->{$r->[0]}) {
              return;
          }
  
          my $path = $self->{$r->[0]};
          if ($self->subrequest) {
              for my $key (keys %$env) {
                  unless ($key =~ /^psgi/) {
                      $env->{'psgix.errordocument.' . $key} = $env->{$key};
                  }
              }
  
              # TODO: What if SCRIPT_NAME is not empty?
              $env->{REQUEST_METHOD} = 'GET';
              $env->{REQUEST_URI}    = $path;
              $env->{PATH_INFO}      = $path;
              $env->{QUERY_STRING}   = '';
              delete $env->{CONTENT_LENGTH};
  
              my $sub_r = $self->app->($env);
              if ($sub_r->[0] == 200) {
                  $r->[1] = $sub_r->[1];
                  if (@$r == 3) {
                      $r->[2] = $sub_r->[2];
                  }
                  else {
                      my $full_sub_response = '';
                      Plack::Util::foreach($sub_r->[2], sub {
                          $full_sub_response .= $_[0];
                      });
  
                      my $returned;
                      return sub {
                          if ($returned) {
                              return defined($_[0]) ? '' : undef;
                          }
                          $returned = 1;
                          return $full_sub_response;
                      }
                  }
              }
              # TODO: allow 302 here?
          } else {
              my $h = Plack::Util::headers($r->[1]);
              $h->remove('Content-Length');
              $h->remove('Content-Encoding');
              $h->remove('Transfer-Encoding');
              $h->set('Content-Type', Plack::MIME->mime_type($path));
  
              open my $fh, "<", $path or die "$path: $!";
              if ($r->[2]) {
                  $r->[2] = $fh;
              } else {
                  my $done;
                  return sub {
                      unless ($done) {
                          return join '', <$fh>;
                      }
                      $done = 1;
                      return defined $_[0] ? '' : undef;
                  };
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ErrorDocument - Set Error Document based on HTTP status code
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::ErrorDocument",
            500 => '/uri/errors/500.html', 404 => '/uri/errors/404.html',
            subrequest => 1;
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::ErrorDocument allows you to customize error screen
  by setting paths (file system path or URI path) of error pages per
  status code.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item subrequest
  
  A boolean flag to serve error pages using a new GET sub request.
  Defaults to false, which means it serves error pages using file
  system path.
  
    builder {
        enable "Plack::Middleware::ErrorDocument",
            502 => '/home/www/htdocs/errors/maint.html';
        enable "Plack::Middleware::ErrorDocument",
            404 => '/static/404.html', 403 => '/static/403.html', subrequest => 1;
        $app;
    };
  
  This configuration serves 502 error pages from file system directly
  assuming that's when you probably maintain database etc. but serves
  404 and 403 pages using a sub request so your application can do some
  logic there like logging or doing suggestions.
  
  When using a subrequest, the subrequest should return a regular '200' response.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  =cut
PLACK_MIDDLEWARE_ERRORDOCUMENT

$fatpacked{"Plack/Middleware/HTTPExceptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_HTTPEXCEPTIONS';
  package Plack::Middleware::HTTPExceptions;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(rethrow);
  
  use Carp ();
  use Try::Tiny;
  use Scalar::Util 'blessed';
  use HTTP::Status ();
  
  sub prepare_app {
      my $self = shift;
      $self->rethrow(1) if ($ENV{PLACK_ENV} || '') eq 'development';
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $res = try {
          $self->app->($env);
      } catch {
          $self->transform_error($_, $env);
      };
  
      return $res if ref $res eq 'ARRAY';
  
      return sub {
          my $respond = shift;
  
          my $writer;
          try {
              $res->(sub { return $writer = $respond->(@_) });
          } catch {
              if ($writer) {
                  Carp::cluck $_;
                  $writer->close;
              } else {
                  my $res = $self->transform_error($_, $env);
                  $respond->($res);
              }
          };
      };
  }
  
  sub transform_error {
      my($self, $e, $env) = @_;
  
      my($code, $message);
      if (blessed $e && $e->can('as_psgi')) {
          return $e->as_psgi;
      }
      if (blessed $e && $e->can('code')) {
          $code = $e->code;
          $message =
              $e->can('as_string')       ? $e->as_string :
              overload::Method($e, '""') ? "$e"          : undef;
      } else {
          if ($self->rethrow) {
              die $e;
          }
          else {
              $code = 500;
              $env->{'psgi.errors'}->print($e);
          }
      }
  
      if ($code !~ /^[3-5]\d\d$/) {
          die $e; # rethrow
      }
  
      $message ||= HTTP::Status::status_message($code);
  
      my @headers = (
           'Content-Type'   => 'text/plain',
           'Content-Length' => length($message),
      );
  
      if ($code =~ /^3/ && (my $loc = eval { $e->location })) {
          push(@headers, Location => $loc);
      }
  
      return [ $code, \@headers, [ $message ] ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::HTTPExceptions - Catch HTTP exceptions
  
  =head1 SYNOPSIS
  
    use HTTP::Exception;
  
    my $app = sub {
        # ...
        HTTP::Exception::500->throw;
    };
  
    builder {
        enable "HTTPExceptions", rethrow => 1;
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::HTTPExceptions is a PSGI middleware component to
  catch exceptions from applications that can be translated into HTTP
  status codes.
  
  Your application is supposed to throw an object that implements a
  C<code> method which returns the HTTP status code, such as 501 or
  404. This middleware catches them and creates a valid response out of
  the code. If the C<code> method returns a code that is not an HTTP
  redirect or error code (3xx, 4xx, or 5xx), the exception will be
  rethrown.
  
  The exception object may also implement C<as_string> or overload
  stringification to represent the text of the error. The text defaults to
  the status message of the error code, such as I<Service Unavailable> for
  C<503>.
  
  Finally, the exception object may implement C<as_psgi>, and the result
  of this will be returned directly as the PSGI response.
  
  If the code is in the 3xx range and the exception implements the 'location'
  method (HTTP::Exception::3xx does), the Location header will be set in the
  response, so you can do redirects this way.
  
  There are CPAN modules L<HTTP::Exception> and L<HTTP::Throwable>, and
  they are perfect to throw from your application to let this middleware
  catch and display, but you can also implement your own exception class
  to throw.
  
  If the thrown exception is not an object that implements either a
  C<code> or an C<as_psgi> method, a 500 error will be returned, and the
  exception is printed to the psgi.errors stream.
  Alternatively, you can pass a true value for the C<rethrow> parameter
  for this middleware, and the exception will instead be rethrown. This is
  enabled by default when C<PLACK_ENV> is set to C<development>, so that
  the L<StackTrace|Plack::Middleware::StackTrace> middleware can catch it
  instead.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  paste.httpexceptions L<HTTP::Exception> L<HTTP::Throwable>
  
  =cut
PLACK_MIDDLEWARE_HTTPEXCEPTIONS

$fatpacked{"Plack/Middleware/Head.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_HEAD';
  package Plack::Middleware::Head;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  
  sub call {
      my($self, $env) = @_;
  
      return $self->app->($env)
          unless $env->{REQUEST_METHOD} eq 'HEAD';
  
      $self->response_cb($self->app->($env), sub {
          my $res = shift;
          if ($res->[2]) {
              $res->[2] = [];
          } else {
              return sub {
                  return defined $_[0] ? '': undef;
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Head - auto delete response body in HEAD requests
  
  =head1 SYNOPSIS
  
    enable "Head";
  
  =head1 DESCRIPTION
  
  This middleware deletes response body in HEAD requests.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::Head
  
  =cut
  
PLACK_MIDDLEWARE_HEAD

$fatpacked{"Plack/Middleware/IIS6ScriptNameFix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_IIS6SCRIPTNAMEFIX';
  package Plack::Middleware::IIS6ScriptNameFix;
  
  use strict;
  use parent 'Plack::Middleware';
  
  sub call {
      my($self, $env) = @_;
  
      if ($env->{SERVER_SOFTWARE} && $env->{SERVER_SOFTWARE} =~ /IIS\/[6-9]\.[0-9]/) {
          my @script_name = split(m!/!, $env->{PATH_INFO});
          my @path_translated = split(m!/|\\\\?!, $env->{PATH_TRANSLATED});
          my @path_info;
  
          while ($script_name[$#script_name] eq $path_translated[$#path_translated]) {
              pop(@path_translated);
              unshift(@path_info, pop(@script_name));
          }
  
          unshift(@path_info, '', '');
  
          $env->{PATH_INFO} = join('/', @path_info);
          $env->{SCRIPT_NAME} = join('/', @script_name);
      }
  
      return $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::IIS6ScriptNameFix - fixes wrong SCRIPT_NAME and PATH_INFO that IIS6 sets
  
  =head1 SYNOPSIS
  
    # in your app.psgi
    use Plack::Builder;
  
    builder {
      enable "IIS6ScriptNameFix";
      $app;
    };
  
    # Or from the command line
    plackup -s FCGI -e 'enable "IIS6ScriptNameFix"' /path/to/app.psgi
  
  =head1 DESCRIPTION
  
  This middleware fixes wrong C<SCRIPT_NAME> and C<PATH_INFO> set by IIS6.
  
  =head1 AUTHORS
  
  Florian Ragwitz
  
  =cut
PLACK_MIDDLEWARE_IIS6SCRIPTNAMEFIX

$fatpacked{"Plack/Middleware/IIS7KeepAliveFix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_IIS7KEEPALIVEFIX';
  package Plack::Middleware::IIS7KeepAliveFix;
  
  use strict;
  use parent 'Plack::Middleware';
  use Plack::Util;
  
  sub call {
      my($self, $env) = @_;
          # Fixes buffer being cut off on redirect when keep-alive is active
          my $res  = $self->app->($env);
  
          Plack::Util::response_cb($res, sub {
              my $res = shift;
              if ($res->[0] =~ m!^30[123]$! ) {
                  Plack::Util::header_remove($res->[1], 'Content-Length');
                  Plack::Util::header_remove($res->[1], 'Content-Type');
                 return sub{ my $chunk; return unless defined $chunk; return ''; };
              }
  
              return;
          });
  
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Middleware::IIS7KeepAliveFix - fixes buffer being cut off on redirect when keep-alive is active on IIS.
  
  =head1 SYNOPSIS
  
    # in your app.psgi
    use Plack::Builder;
  
    builder {
      enable "IIS7KeepAliveFix";
      $app;
    };
  
    # Or from the command line
    plackup -s FCGI -e 'enable "IIS7KeepAliveFix"' /path/to/app.psgi
  
  =head1 DESCRIPTION
  
  This middleware fixes buffer being cut off on redirect when keep-alive is active on IIS7.
  
  =head1 AUTHORS
  
  KnowZeroX
  
  =cut
  
PLACK_MIDDLEWARE_IIS7KEEPALIVEFIX

$fatpacked{"Plack/Middleware/JSONP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_JSONP';
  package Plack::Middleware::JSONP;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util;
  use URI::Escape ();
  
  use Plack::Util::Accessor qw/callback_key/;
  
  sub prepare_app {
      my $self = shift;
      unless (defined $self->callback_key) {
          $self->callback_key('callback');
      }
  }
  
  sub call {
      my($self, $env) = @_;
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          if (defined $res->[2]) {
              my $h = Plack::Util::headers($res->[1]);
              my $callback_key = $self->callback_key;
              if ($h->get('Content-Type') =~ m!/(?:json|javascript)! &&
                  $env->{QUERY_STRING} =~ /(?:^|&)$callback_key=([^&]+)/) {
                  my $cb = URI::Escape::uri_unescape($1);
                  if ($cb =~ /^[\w\.\[\]]+$/) {
                      my $body;
                      Plack::Util::foreach($res->[2], sub { $body .= $_[0] });
                      my $jsonp = "$cb($body)";
                      $res->[2] = [ $jsonp ];
                      $h->set('Content-Length', length $jsonp);
                      $h->set('Content-Type', 'text/javascript');
                  }
              }
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::JSONP - Wraps JSON response in JSONP if callback parameter is specified
  
  =head1 SYNOPSIS
  
      enable "JSONP", callback_key => 'jsonp';
  
  =head1 DESCRIPTION
  
  Plack::Middleware::JSONP wraps JSON response, which has Content-Type
  value either C<text/javascript> or C<application/json> as a JSONP
  response which is specified with the C<callback> query parameter. The
  name of the parameter can be set while enabling the middleware.
  
  This middleware only works with a non-streaming response, and doesn't
  touch the response otherwise.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_MIDDLEWARE_JSONP

$fatpacked{"Plack/Middleware/LighttpdScriptNameFix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_LIGHTTPDSCRIPTNAMEFIX';
  package Plack::Middleware::LighttpdScriptNameFix;
  use strict;
  use parent qw/Plack::Middleware/;
  use Plack::Util::Accessor qw(script_name);
  
  sub prepare_app {
      my $self = shift;
  
      my $script_name = $self->script_name;
      $script_name = '' unless defined($script_name);
      $script_name =~ s!/$!!;
      $self->script_name($script_name);
  }
  
  sub call {
      my($self, $env) = @_;
  
      if ($env->{SERVER_SOFTWARE} && $env->{SERVER_SOFTWARE} =~ /lighttpd/) {
          $env->{PATH_INFO}   = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{SCRIPT_NAME} = $self->script_name;
          $env->{PATH_INFO}  =~ s/^\Q$env->{SCRIPT_NAME}\E//;
      }
  
      return $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::LighttpdScriptNameFix - fixes wrong SCRIPT_NAME and PATH_INFO that lighttpd sets
  
  =head1 SYNOPSIS
  
    # in your app.psgi
    use Plack::Builder;
  
    builder {
      enable "LighttpdScriptNameFix";
      $app;
    };
  
    # Or from the command line
    plackup -s FCGI -e 'enable "LighttpdScriptNameFix"' /path/to/app.psgi
  
  =head1 DESCRIPTION
  
  This middleware fixes wrong C<SCRIPT_NAME> and C<PATH_INFO> set by
  lighttpd when you mount your app under the root path ("/"). If you use
  lighttpd 1.4.23 or later you can instead enable C<fix-root-scriptname>
  flag inside C<fastcgi.server> instead of using this middleware.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item script_name
  
  Even with C<fix-root-scriptname>, lighttpd I<still> sets weird
  C<SCRIPT_NAME> and C<PATH_INFO> if you mount your application at C<"">
  or something that ends with C</>. Setting C<script_name> option tells
  the middleware how to reconstruct the new correct C<SCRIPT_NAME> and
  C<PATH_INFO>.
  
  If you mount the app under C</something/>, you should set:
  
    enable "LighttpdScriptNameFix", script_name => "/something";
  
  and when a request for C</something/a/b?param=1> comes, C<SCRIPT_NAME>
  becomes C</something> and C<PATH_INFO> becomes C</a/b>.
  
  C<script_name> option is set to empty by default, which means all the
  request path is set to C<PATH_INFO> and it behaves like your fastcgi
  application is mounted in the root path.
  
  =back
  
  =head1 AUTHORS
  
  Yury Zavarin
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Handler::FCGI>
  L<http://github.com/plack/Plack/issues#issue/68>
  L<https://redmine.lighttpd.net/issues/729>
  
  =cut
  
PLACK_MIDDLEWARE_LIGHTTPDSCRIPTNAMEFIX

$fatpacked{"Plack/Middleware/Lint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_LINT';
  package Plack::Middleware::Lint;
  use strict;
  no warnings;
  use Carp ();
  use parent qw(Plack::Middleware);
  use Scalar::Util qw(blessed);
  use Plack::Util;
  
  sub wrap {
      my($self, $app) = @_;
  
      unless (ref $app eq 'CODE' or overload::Method($app, '&{}')) {
          die("PSGI app should be a code reference: ", (defined $app ? $app : "undef"));
      }
  
      $self->SUPER::wrap($app);
  }
  
  sub call {
      my $self = shift;
      my $env = shift;
  
      $self->validate_env($env);
      my $res = $self->app->($env);
      return $self->validate_res($res);
  }
  
  sub validate_env {
      my ($self, $env) = @_;
      unless ($env->{REQUEST_METHOD}) {
          die('Missing env param: REQUEST_METHOD');
      }
      unless ($env->{REQUEST_METHOD} =~ /^[A-Z]+$/) {
          die("Invalid env param: REQUEST_METHOD($env->{REQUEST_METHOD})");
      }
      unless (defined($env->{SCRIPT_NAME})) { # allows empty string
          die('Missing mandatory env param: SCRIPT_NAME');
      }
      if ($env->{SCRIPT_NAME} eq '/') {
          die('SCRIPT_NAME must not be /');
      }
      unless (defined($env->{PATH_INFO})) { # allows empty string
          die('Missing mandatory env param: PATH_INFO');
      }
      if ($env->{PATH_INFO} ne '' && $env->{PATH_INFO} !~ m!^/!) {
          die('PATH_INFO must begin with / ($env->{PATH_INFO})');
      }
      unless (defined($env->{SERVER_NAME})) {
          die('Missing mandatory env param: SERVER_NAME');
      }
      if ($env->{SERVER_NAME} eq '') {
          die('SERVER_NAME must not be empty string');
      }
      unless (defined($env->{SERVER_PORT})) {
          die('Missing mandatory env param: SERVER_PORT');
      }
      if ($env->{SERVER_PORT} eq '') {
          die('SERVER_PORT must not be empty string');
      }
      if (defined($env->{SERVER_PROTOCOL}) and $env->{SERVER_PROTOCOL} !~ m{^HTTP/1.\d$}) {
          die("Invalid SERVER_PROTOCOL: $env->{SEREVR_PROTOCOL}");
      }
      for my $param (qw/version url_scheme input errors multithread multiprocess/) {
          unless (exists $env->{"psgi.$param"}) {
              die("Missing psgi.$param");
          }
      }
      unless (ref($env->{'psgi.version'}) eq 'ARRAY') {
          die("psgi.version should be ArrayRef: $env->{'psgi.version'}");
      }
      unless (scalar(@{$env->{'psgi.version'}}) == 2) {
          die('psgi.version should contain 2 elements, not ', scalar(@{$env->{'psgi.version'}}));
      }
      unless ($env->{'psgi.url_scheme'} =~ /^https?$/) {
          die("psgi.url_scheme should be 'http' or 'https': ", $env->{'psgi.url_scheme'});
      }
      if ($env->{"psgi.version"}->[1] == 1) { # 1.1
          for my $param (qw(streaming nonblocking run_once)) {
              unless (exists $env->{"psgi.$param"}) {
                  die("Missing psgi.$param");
              }
          }
      }
      if ($env->{HTTP_CONTENT_TYPE}) {
          die('HTTP_CONTENT_TYPE should not exist');
      }
      if ($env->{HTTP_CONTENT_LENGTH}) {
          die('HTTP_CONTENT_LENGTH should not exist');
      }
  }
  
  sub is_possibly_fh {
      my $fh = shift;
  
      ref $fh eq 'GLOB' &&
      *{$fh}{IO} &&
      *{$fh}{IO}->can('getline');
  }
  
  sub validate_res {
      my ($self, $res, $streaming) = @_;
  
      unless (ref($res) eq 'ARRAY' or ref($res) eq 'CODE') {
          die("Response should be array ref or code ref: $res");
      }
  
      if (ref $res eq 'CODE') {
          return $self->response_cb($res, sub { $self->validate_res(@_, 1) });
      }
  
      unless (@$res == 3 || ($streaming && @$res == 2)) {
          die('Response needs to be 3 element array, or 2 element in streaming');
      }
  
      unless ($res->[0] =~ /^\d+$/ && $res->[0] >= 100) {
          die("Status code needs to be an integer greater than or equal to 100: $res->[0]");
      }
  
      unless (ref $res->[1] eq 'ARRAY') {
          die("Headers needs to be an array ref: $res->[1]");
      }
  
      my @copy = @{$res->[1]};
      unless (@copy % 2 == 0) {
          die('The number of response headers needs to be even, not odd(', scalar(@copy), ')');
      }
  
      while(my($key, $val) = splice(@copy, 0, 2)) {
          if (lc $key eq 'status') {
              die('Response headers MUST NOT contain a key named Status');
          }
          if ($key =~ /[:\r\n]|[-_]$/) {
              die("Response headers MUST NOT contain a key with : or newlines, or that end in - or _: $key");
          }
          unless ($key =~ /^[a-zA-Z][0-9a-zA-Z\-_]*$/) {
              die("Response headers MUST consist only of letters, digits, _ or - and MUST start with a letter: $key");
          }
          if ($val =~ /[\000-\037]/) {
              die("Response headers MUST NOT contain characters below octal \037: $val");
          }
          if (!defined $val) {
              die("Response headers MUST be a defined string");
          }
      }
  
      # @$res == 2 is only right in psgi.streaming, and it's already checked.
      unless (@$res == 2 ||
              ref $res->[2] eq 'ARRAY' ||
              Plack::Util::is_real_fh($res->[2]) ||
              is_possibly_fh($res->[2]) ||
              (blessed($res->[2]) && $res->[2]->can('getline'))) {
          die("Body should be an array ref or filehandle: $res->[2]");
      }
  
      if (ref $res->[2] eq 'ARRAY' && grep _has_wide_char($_), @{$res->[2]}) {
          die("Body must be bytes and should not contain wide characters (UTF-8 strings)");
      }
  
      return $res;
  }
  
  # NOTE: Some modules like HTML:: or XML:: could possibly generate
  # ASCII/Latin-1 strings with utf8 flags on. They're actually safe to
  # print, so there's no need to give warnings about it.
  sub _has_wide_char {
      my $str = shift;
      utf8::is_utf8($str) && $str =~ /[^\x00-\xff]/;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Lint - Validate request and response
  
  =head1 SYNOPSIS
  
    use Plack::Middleware::Lint;
  
    my $app = sub { ... }; # your app or middleware
    $app = Plack::Middleware::Lint->wrap($app);
  
    # Or from plackup
    plackup -e 'enable "Lint"' myapp.psgi
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Lint is a middleware component to validate request
  and response environment formats. You are strongly suggested to use
  this middleware when you develop a new framework adapter or a new PSGI
  web server that implements the PSGI interface.
  
  This middleware is enabled by default when you run plackup or other
  launcher tools with the default environment I<development> value.
  
  =head1 DEBUGGING
  
  Because of how this middleware works, it may not be easy to debug Lint
  errors when you encounter one, unless you're writing a PSGI web server
  or a framework.
  
  For example, when you're an application developer (user of some
  framework) and see errors like:
  
    Body should be an array ref or filehandle at lib/Plack/Middleware/Lint.pm line XXXX
  
  there's no clue about which line of I<your application> produces that
  error.
  
  We're aware of the issue, and have a plan to spit out more helpful
  errors to diagnose the issue. But until then, currently there are some
  workarounds to make this easier. For now, the easiest one would be to
  enable L<Plack::Middleware::REPL> outside of the Lint middleware,
  like:
  
    plackup -e 'enable "REPL"; enable "Lint"' app.psgi
  
  so that the Lint errors are caught by the REPL shell, where you can
  inspect all the variables in the response.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_MIDDLEWARE_LINT

$fatpacked{"Plack/Middleware/Log4perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_LOG4PERL';
  package Plack::Middleware::Log4perl;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(category logger conf);
  use Carp ();
  
  sub prepare_app {
      my $self = shift;
  
      if ($self->conf) {
          require Log::Log4perl;
          Log::Log4perl::init($self->conf);
      }
  
      $self->logger( Log::Log4perl->get_logger($self->category || '') );
  }
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
          my $level = $args->{level};
          local $Log::Log4perl::caller_depth
              = $Log::Log4perl::caller_depth + 1;
          $self->logger->$level($args->{message});
      };
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Log4perl - Uses Log::Log4perl to configure logger
  
  =head1 SYNOPSIS
  
    use Log::Log4perl;
  
    Log::Log4perl::init('/path/to/log4perl.conf');
  
    builder {
        enable "Log4perl", category => "plack";
        $app;
    }
  
    # in log4perl.conf
    log4perl.logger.plack = INFO, Logfile
    log4perl.appender.Logfile = Log::Log4perl::Appender::File
    log4perl.appender.Logfile.filename = /path/to/logfile.log
    log4perl.appender.Logfile.layout   = Log::Log4perl::Layout::SimpleLayout
  
    # Or let middleware to configure log4perl
    enable "Log4perl", category => "plack", conf => '/path/to/log.conf';
  
  =head1 DESCRIPTION
  
  Log4perl is a L<Plack::Middleware> component that allows you to use
  L<Log::Log4perl> to configure the logging object, C<psgix.logger>.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item category
  
  The C<log4perl> category to send logs to. Defaults to C<''> which means
  it send to the root logger.
  
  =item conf
  
  The configuration file path (or a scalar ref containing the config
  string) for L<Log::Log4perl> to automatically configure.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Log::Log4perl>
  
  L<Plack::Middleware::LogDispatch>
  
  =cut
  
PLACK_MIDDLEWARE_LOG4PERL

$fatpacked{"Plack/Middleware/LogDispatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_LOGDISPATCH';
  package Plack::Middleware::LogDispatch;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(logger);
  use Carp ();
  
  sub prepare_app {
      my $self = shift;
      unless ($self->logger) {
          Carp::croak "logger is not defined";
      }
  }
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
          $args->{level} = 'critical' if $args->{level} eq 'fatal';
  
          if ( ref $args->{message} && ref $args->{message} ne 'CODE' ) {
              $args->{message} .= q{};
          }
  
          $self->logger->log(%$args);
      };
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::LogDispatch - Uses Log::Dispatch to configure logger
  
  =head1 SYNOPSIS
  
    use Log::Dispatch;
  
    my $logger = Log::Dispatch->new;
    $logger->add( Log::Dispatch::File->new(...) );
    $logger->add( Log::Dispatch::DesktopNotification->new(...) );
  
    builder {
        enable "LogDispatch", logger => $logger;
        $app;
    }
  
    # use with Log::Dispatch::Config
    use Log::Dispatch::Config;
    Log::Dispatch::Config->configure('/path/to/log.conf');
  
    builder {
        enable "LogDispatch", logger => Log::Dispatch::Config->instance;
        ...
    }
  
  =head1 DESCRIPTION
  
  LogDispatch is a L<Plack::Middleware> component that allows you to use
  L<Log::Dispatch> to configure the logging object, C<psgix.logger>.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item logger
  
  L<Log::Dispatch> object to send logs to. Required.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Log::Dispatch>
  
  L<Plack::Middleware::Log4perl>
  
  =cut
  
PLACK_MIDDLEWARE_LOGDISPATCH

$fatpacked{"Plack/Middleware/NullLogger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_NULLLOGGER';
  package Plack::Middleware::NullLogger;
  use strict;
  use parent qw/Plack::Middleware/;
  
  sub call {
      my($self, $env) = @_;
      $env->{'psgix.logger'} = sub { };
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::NullLogger - Send logs to /dev/null
  
  =head1 SYNOPSIS
  
    enable "NullLogger";
  
  =head1 DESCRIPTION
  
  NullLogger is a middleware component that receives logs and does
  nothing but discarding them. Might be useful to shut up all the logs
  from frameworks in one shot.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_NULLLOGGER

$fatpacked{"Plack/Middleware/RearrangeHeaders.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_REARRANGEHEADERS';
  package Plack::Middleware::RearrangeHeaders;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use HTTP::Headers;
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->(@_);
      $self->response_cb($res, sub {
          my $res = shift;
  
          my $h = HTTP::Headers->new(@{$res->[1]});
          my @new_headers;
          $h->scan(sub { push @new_headers, @_ });
  
          $res->[1] = \@new_headers;
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::RearrangeHeaders - Reorder HTTP headers for buggy clients
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [
            'Last-Modified' => 'Wed, 23 Sep 2009 13:36:33 GMT',
            'Content-Type' => 'text/plain',
            'ETag' => 'foo bar',
        ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::RearrangeHeaders";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::RearrangeHeaders sorts HTTP headers based on "Good Practice" i.e.:
  
    # "Good Practice" order of HTTP message headers:
    #    - Response-Headers
    #    - Entity-Headers
  
  to work around buggy clients like very old MSIE or broken HTTP proxy
  servers. Most clients today don't (and shouldn't) care about HTTP
  header order but if you're too pedantic or have some environments
  where you need to deal with buggy clients like above, this might be
  useful.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>
  
  =cut
PLACK_MIDDLEWARE_REARRANGEHEADERS

$fatpacked{"Plack/Middleware/Recursive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_RECURSIVE';
  package Plack::Middleware::Recursive;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Try::Tiny;
  use Scalar::Util qw(blessed);
  
  open my $null_io, "<", \"";
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'plack.recursive.include'} = $self->recurse_callback($env, 1);
  
      my $res = try {
          $self->app->($env);
      } catch {
          if (blessed $_ && $_->isa('Plack::Recursive::ForwardRequest')) {
              return $self->recurse_callback($env)->($_->path);
          } else {
              die $_; # rethrow
          }
      };
  
      return $res if ref $res eq 'ARRAY';
  
      return sub {
          my $respond = shift;
  
          my $writer;
          try {
              $res->(sub { return $writer = $respond->(@_) });
          } catch {
              if (!$writer && blessed $_ && $_->isa('Plack::Recursive::ForwardRequest')) {
                  $res = $self->recurse_callback($env)->($_->path);
                  return ref $res eq 'CODE' ? $res->($respond) : $respond->($res);
              } else {
                  die $_;
              }
          };
      };
  }
  
  sub recurse_callback {
      my($self, $env, $include) = @_;
  
      my $old_path_info = $env->{PATH_INFO};
  
      return sub {
          my $new_path_info = shift;
          my($path, $query) = split /\?/, $new_path_info, 2;
  
          Scalar::Util::weaken($env);
  
          $env->{PATH_INFO}      = $path;
          $env->{QUERY_STRING}   = $query;
          $env->{REQUEST_METHOD} = 'GET';
          $env->{CONTENT_LENGTH} = 0;
          $env->{CONTENT_TYPE}   = '';
          $env->{'psgi.input'}   = $null_io;
          push @{$env->{'plack.recursive.old_path_info'}}, $old_path_info;
  
          $include ? $self->app->($env) : $self->call($env);
      };
  }
  
  package Plack::Recursive::ForwardRequest;
  use overload q("") => \&as_string, fallback => 1;
  
  sub new {
      my($class, $path) = @_;
      bless { path => $path }, $class;
  }
  
  sub path { $_[0]->{path} }
  
  sub throw {
      my($class, @args) = @_;
      die $class->new(@args);
  }
  
  sub as_string {
      my $self = shift;
      return "Forwarding to $self->{path}: Your application should be wrapped with Plack::Middleware::Recursive.";
  }
  
  package Plack::Middleware::Recursive;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Recursive - Allows PSGI apps to include or forward requests recursively
  
  =head1 SYNOPSIS
  
    # with Builder
    enable "Recursive";
  
    # in apps
    my $res = $env->{'plack.recursive.include'}->("/new_path");
  
    # Or, use exceptions
    my $app = sub {
        # ...
        Plack::Recursive::ForwardRequest->throw("/new_path");
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Recursive allows PSGI applications to recursively
  include or forward requests to other paths. Applications can make use
  of callbacks stored in C<< $env->{'plack.recursive.include'} >> to
  I<include> another path to get the response (whether it's an array ref
  or a code ref depending on your application), or throw an exception
  Plack::Recursive::ForwardRequest anywhere in the code to I<forward>
  the current request (i.e. abort the current and redo the request).
  
  =head1 EXCEPTIONS
  
  This middleware passes through unknown exceptions to the outside
  middleware stack, so if you use this middleware with other exception
  handlers such as L<Plack::Middleware::StackTrace> or
  L<Plack::Middleware::HTTPExceptions>, be sure to wrap this so
  L<Plack::Middleware::Recursive> gets as inner as possible.
  
  =head1 AUTHORS
  
  Tatsuhiko Miyagawa
  
  Masahiro Honma
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Middleware::HTTPExceptions>
  
  The idea, code and interface are stolen from Rack::Recursive and paste.recursive.
  
  =cut
  
  
PLACK_MIDDLEWARE_RECURSIVE

$fatpacked{"Plack/Middleware/Refresh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_REFRESH';
  package Plack::Middleware::Refresh;
  use strict;
  use parent qw(Plack::Middleware);
  use Module::Refresh;
  use Plack::Util::Accessor qw(last cooldown);
  
  sub prepare_app {
      my $self = shift;
      $self->cooldown(10) unless defined $self->cooldown;
  
      Module::Refresh->new;
      $self->last(time - $self->cooldown);
  }
  
  sub call {
      my($self, $env) = @_;
  
      if (time > $self->last + $self->cooldown) {
          Module::Refresh->refresh;
          $self->last(time);
      }
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Refresh - Refresh all modules in %INC
  
  =head1 SYNOPSIS
  
    enable "Refresh", cooldown => 3;
    $app;
  
  =head1 DESCRIPTION
  
  This is I<yet another> approach to refresh modules in C<%INC> during
  the development cycle, without the need to have a forking process to
  watch for filesystem updates. This middleware, in a request time,
  compares the last refresh time and the current time and if the
  difference is bigger than I<cooldown> seconds which defaults to 10,
  call L<Module::Refresh> to reload all Perl modules in C<%INC> if the
  files have been modified.
  
  Note that this only reloads modules and not other files such as
  templates.
  
  This middleware is quite similar to what Rack::Reoader does. If you
  have issues with this reloading technique, for instance when you have
  in-file templates that needs to be recompiled, or Moose classes that
  has C<make_immutable>, take a look at L<plackup>'s default -r option
  or L<Plack::Loader::Shotgun> instead.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Module::Refresh> Rack::Reloader
  
  =cut
  
PLACK_MIDDLEWARE_REFRESH

$fatpacked{"Plack/Middleware/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_RUNTIME';
  package Plack::Middleware::Runtime;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util;
  use Plack::Util::Accessor qw(header_name);
  use Time::HiRes;
  
  sub call {
      my($self, $env) = @_;
  
      my $start = [ Time::HiRes::gettimeofday ];
      my $res = $self->app->($env);
  
      $self->response_cb($res, sub {
          my $res = shift;
          my $req_time = sprintf '%.6f', Time::HiRes::tv_interval($start);
          Plack::Util::header_set($res->[1], 'X-Runtime', $req_time);
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Runtime - Sets an X-Runtime response header
  
  =head1 SYNOPSIS
  
    enable "Runtime";
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Runtime is a Plack middleware component that sets
  the application's response time (in seconds) in the I<X-Runtime> HTTP response
  header.
  
  =head1 OPTIONS
  
  =over 4
  
  =item header_name
  
  Name of the header. Defaults to I<X-Runtime>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Time::HiRes> Rack::Runtime
  
  =cut
PLACK_MIDDLEWARE_RUNTIME

$fatpacked{"Plack/Middleware/SimpleContentFilter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_SIMPLECONTENTFILTER';
  package Plack::Middleware::SimpleContentFilter;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  use Plack::Util::Accessor qw( filter );
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->(@_);
      $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          return unless $h->get('Content-Type');
          if ($h->get('Content-Type') =~ m!^text/!) {
              return sub {
                  my $chunk = shift;
                  return unless defined $chunk;
                  local $_ = $chunk;
                  $self->filter->();
                  return $_;
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::SimpleContentFilter - Filters response content
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [ 'Content-Type' => 'text/plain' ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::SimpleContentFilter",
            filter => sub { s/Foo/Bar/g; };
        $app;
    };
  
  =head1 DESCRIPTION
  
  B<This middleware should be considered as a demo. Running this against
  your application might break your HTML unless you code the filter
  callback carefully>.
  
  Plack::Middleware::SimpleContentFilter is a simple content text filter
  to run against response body. This middleware is only enabled against
  responses with C<text/*> Content-Type.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_SIMPLECONTENTFILTER

$fatpacked{"Plack/Middleware/SimpleLogger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_SIMPLELOGGER';
  package Plack::Middleware::SimpleLogger;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(level);
  use POSIX ();
  use Scalar::Util ();
  
  # Should this be in Plack::Util?
  my $i = 0;
  my %level_numbers = map { $_ => $i++ } qw(debug info warn error fatal);
  
  sub call {
      my($self, $env) = @_;
  
      my $min = $level_numbers{ $self->level || "debug" };
  
      my $env_ref = $env;
      Scalar::Util::weaken($env_ref);
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
  
          if ($level_numbers{$args->{level}} >= $min) {
              $env_ref->{'psgi.errors'}->print($self->format_message($args->{level}, $args->{message}));
          }
      };
  
      $self->app->($env);
  }
  
  sub format_time {
      my $old_locale = POSIX::setlocale(&POSIX::LC_ALL);
      POSIX::setlocale(&POSIX::LC_ALL, 'C');
      my $out = POSIX::strftime(@_);
      POSIX::setlocale(&POSIX::LC_ALL, $old_locale);
      return $out;
  }
  
  sub format_message {
      my($self, $level, $message) = @_;
  
      my $time = format_time("%Y-%m-%dT%H:%M:%S", localtime);
      sprintf "%s [%s #%d] %s: %s\n", uc substr($level, 0, 1), $time, $$, uc $level, $message;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::SimpleLogger - Simple logger that prints to psgi.errors
  
  =head1 SYNOPSIS
  
    enable "SimpleLogger", level => "warn";
  
  =head1 DESCRIPTION
  
  SimpleLogger is a middleware component that formats the log message
  with information such as the time and PID and prints them to
  I<psgi.errors> stream, which is mostly STDERR or server log output.
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::LogErrors>, essentially the opposite of this module
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_SIMPLELOGGER

$fatpacked{"Plack/Middleware/StackTrace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_STACKTRACE';
  package Plack::Middleware::StackTrace;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  use Devel::StackTrace;
  use Devel::StackTrace::AsHTML;
  use Try::Tiny;
  use Plack::Util::Accessor qw( force no_print_errors );
  
  our $StackTraceClass = "Devel::StackTrace";
  
  # Optional since it needs PadWalker
  if (try { require Devel::StackTrace::WithLexicals; Devel::StackTrace::WithLexicals->VERSION(0.08); 1 }) {
      $StackTraceClass = "Devel::StackTrace::WithLexicals";
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $trace;
      local $SIG{__DIE__} = sub {
          $trace = $StackTraceClass->new(
              indent => 1, message => munge_error($_[0], [ caller ]),
              ignore_package => __PACKAGE__,
          );
          die @_;
      };
  
      my $caught;
      my $res = try {
          $self->app->($env);
      } catch {
          $caught = $_;
          [ 500, [ "Content-Type", "text/plain; charset=utf-8" ], [ no_trace_error(utf8_safe($caught)) ] ];
      };
  
      if ($trace && ($caught || ($self->force && ref $res eq 'ARRAY' && $res->[0] == 500)) ) {
          my $text = $trace->as_string;
          my $html = $trace->as_html;
          $env->{'plack.stacktrace.text'} = $text;
          $env->{'plack.stacktrace.html'} = $html;
          $env->{'psgi.errors'}->print($text) unless $self->no_print_errors;
          if (($env->{HTTP_ACCEPT} || '*/*') =~ /html/) {
              $res = [500, ['Content-Type' => 'text/html; charset=utf-8'], [ utf8_safe($html) ]];
          } else {
              $res = [500, ['Content-Type' => 'text/plain; charset=utf-8'], [ utf8_safe($text) ]];
          }
      }
  
      # break $trace here since $SIG{__DIE__} holds the ref to it, and
      # $trace has refs to Standalone.pm's args ($conn etc.) and
      # prevents garbage collection to be happening.
      undef $trace;
  
      return $res;
  }
  
  sub no_trace_error {
      my $msg = shift;
      chomp($msg);
  
      return <<EOF;
  The application raised the following error:
  
    $msg
  
  and the StackTrace middleware couldn't catch its stack trace, possibly because your application overrides \$SIG{__DIE__} by itself, preventing the middleware from working correctly. Remove the offending code or module that does it: known examples are CGI::Carp and Carp::Always.
  EOF
  }
  
  sub munge_error {
      my($err, $caller) = @_;
      return $err if ref $err;
  
      # Ugly hack to remove " at ... line ..." automatically appended by perl
      # If there's a proper way to do this, please let me know.
      $err =~ s/ at \Q$caller->[1]\E line $caller->[2]\.\n$//;
  
      return $err;
  }
  
  sub utf8_safe {
      my $str = shift;
  
      # NOTE: I know messing with utf8:: in the code is WRONG, but
      # because we're running someone else's code that we can't
      # guarantee which encoding an exception is encoded, there's no
      # better way than doing this. The latest Devel::StackTrace::AsHTML
      # (0.08 or later) encodes high-bit chars as HTML entities, so this
      # path won't be executed.
      if (utf8::is_utf8($str)) {
          utf8::encode($str);
      }
  
      $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::StackTrace - Displays stack trace when your app dies
  
  =head1 SYNOPSIS
  
    enable "StackTrace";
  
  =head1 DESCRIPTION
  
  This middleware catches exceptions (run-time errors) happening in your
  application and displays nice stack trace screen. The stack trace is
  also stored in the environment as a plaintext and HTML under the key
  C<plack.stacktrace.text> and C<plack.stacktrace.html> respectively, so
  that middleware further up the stack can reference it.
  
  This middleware is enabled by default when you run L<plackup> in the
  default I<development> mode.
  
  You're recommended to use this middleware during the development and
  use L<Plack::Middleware::HTTPExceptions> in the deployment mode as a
  replacement, so that all the exceptions thrown from your application
  still get caught and rendered as a 500 error response, rather than
  crashing the web server.
  
  Catching errors in streaming response is not supported.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item force
  
    enable "StackTrace", force => 1;
  
  Force display the stack trace when an error occurs within your
  application and the response code from your application is
  500. Defaults to off.
  
  The use case of this option is that when your framework catches all
  the exceptions in the main handler and returns all failures in your
  code as a normal 500 PSGI error response. In such cases, this
  middleware would never have a chance to display errors because it
  can't tell if it's an application error or just random C<eval> in your
  code. This option enforces the middleware to display stack trace even
  if it's not the direct error thrown by the application.
  
  =item no_print_errors
  
    enable "StackTrace", no_print_errors => 1;
  
  Skips printing the text stacktrace to console
  (C<psgi.errors>). Defaults to 0, which means the text version of the
  stack trace error is printed to the errors handle, which usually is a
  standard error.
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Devel::StackTrace::AsHTML> L<Plack::Middleware> L<Plack::Middleware::HTTPExceptions>
  
  =cut
  
PLACK_MIDDLEWARE_STACKTRACE

$fatpacked{"Plack/Middleware/Static.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_STATIC';
  package Plack::Middleware::Static;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  use Plack::App::File;
  
  use Plack::Util::Accessor qw( path root encoding pass_through content_type );
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->_handle_static($env);
      if ($res && not ($self->pass_through and $res->[0] == 404)) {
          return $res;
      }
  
      return $self->app->($env);
  }
  
  sub _handle_static {
      my($self, $env) = @_;
  
      my $path_match = $self->path or return;
      my $path = $env->{PATH_INFO};
  
      for ($path) {
          my $matched = 'CODE' eq ref $path_match ? $path_match->($_, $env) : $_ =~ $path_match;
          return unless $matched;
      }
  
      $self->{file} ||= Plack::App::File->new({ root => $self->root || '.', encoding => $self->encoding, content_type => $self->content_type });
      local $env->{PATH_INFO} = $path; # rewrite PATH
      return $self->{file}->call($env);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Static - serve static files with Plack
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::Static",
            path => qr{^/(images|js|css)/}, root => './htdocs/';
        $app;
    };
  
  =head1 DESCRIPTION
  
  This middleware allows your Plack-based application to serve static files.
  
  Note that if you are building an app using L<Plack::App::URLMap>, you should
  consider using L<Plack::App::File> to serve static files instead. This makes
  the overall routing of your application simpler to understand.
  
  With this middleware, if a static file exists for the requested path, it will
  be served. If it does not exist, by default this middleware returns a 404, but
  you can set the C<pass_through> option to change this behavior.
  
  If the requested document is not within the C<root> or the file is there but
  not readable, this middleware will return a 403 Forbidden response.
  
  The content type returned will be determined from the file extension by using
  L<Plack::MIME> or using C<content_type>.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item path, root
  
    enable "Plack::Middleware::Static",
        path => qr{^/static/}, root => 'htdocs/';
  
  The C<path> option specifies the URL pattern (regular expression) or a
  callback to match against requests. If the <path> option matches, the
  middleware looks in C<root> to find the static files to serve. The default
  value of C<root> is the current directory.
  
  This example configuration serves C</static/foo.jpg> from
  C<htdocs/static/foo.jpg>. Note that the matched portion of the path,
  C</static/>, still appears in the locally mapped path under C<root>. If you
  don't want this to happen, you can use a callback to munge the path as you
  match it:
  
    enable "Plack::Middleware::Static",
        path => sub { s!^/static/!! }, root => 'static-files/';
  
  The callback should operate on C<$_> and return a true or false value. Any
  changes it makes to C<$_> are used when looking for the static file in the
  C<root>.
  
  The configuration above serves C</static/foo.png> from
  C<static-files/foo.png>, not C<static-files/static/foo.png>. The callback
  specified in the C<path> option matches against C<$_> munges this value using
  C<s///>. The substitution operator returns the number of matches it made, so it
  will return true when the path matches C<^/static>.
  
  For more complex static handling in the C<path> callback, in addition
  to C<$_> being set the callback receives two arguments, C<PATH_INFO>
  (same as C<$_>) and C<$env>.
  
  If you want to map multiple static directories from different roots, simply
  add this middleware multiple times with different configuration options.
  
  =item pass_through
  
  When this option is set to a true value, then this middleware will never
  return a 404 if it cannot find a matching file. Instead, it will simply pass
  the request on to the application it is wrapping.
  
  =item content_type
  
  The C<content_type> option can be used to provide access to a different MIME 
  database than L<Plack::MIME>.
  L<Plack::MIME> works fast and good for a list of well known file endings, 
  but if you need a more accurate content based checking you can use modules
  like L<File::MimeInfo> or L<File::MMagic> for example.
  The callback should work on $_[0] which is the filename of the file.
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno, Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware> L<Plack::Builder>
  
  =cut
  
  
PLACK_MIDDLEWARE_STATIC

$fatpacked{"Plack/Middleware/XFramework.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_XFRAMEWORK';
  package Plack::Middleware::XFramework;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  
  use Plack::Util;
  use Plack::Util::Accessor qw( framework );
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->( @_ );
      $self->response_cb($res, sub {
          my $res = shift;
          if ($self->framework) {
              Plack::Util::header_set $res->[1], 'X-Framework' => $self->framework;
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::XFramework - Sample middleware to add X-Framework
  
  =head1 SYNOPSIS
  
    enable "Plack::Middleware::XFramework", framework => "Catalyst";
  
  =head1 DESCRIPTION
  
  This middleware adds C<X-Framework> header to the HTTP response.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item framework
  
  Sets the string value of C<X-Framework> header. If not set, the header is not set to the response.
  
  =back
  
  =head1 SEE ALSO
  
  L<Plack::Middleware>
  
  =cut
  
PLACK_MIDDLEWARE_XFRAMEWORK

$fatpacked{"Plack/Middleware/XSendfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_XSENDFILE';
  package Plack::Middleware::XSendfile;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  
  use Plack::Util;
  use Scalar::Util;
  use Plack::Util::Accessor qw( variation );
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          my($status, $headers, $body) = @$res;
          return unless defined $body;
  
          if (Scalar::Util::blessed($body) && $body->can('path')) {
              my $type = $self->_variation($env) || '';
              my $h = Plack::Util::headers($headers);
              if ($type && !$h->exists($type)) {
                  if ($type eq 'X-Accel-Redirect') {
                      my $path = $body->path;
                      my $url = $self->map_accel_path($env, $path);
                      $h->set($type => $url) if $url;
                      $body = [];
                  } elsif ($type eq 'X-Sendfile' or $type eq 'X-Lighttpd-Send-File') {
                      my $path = $body->path;
                      $h->set($type => $path) if defined $path;
                      $body = [];
                  } else {
                      $env->{'psgi.errors'}->print("Unknown x-sendfile variation: $type");
                  }
              }
          }
  
          @$res = ( $status, $headers, $body );
      });
  }
  
  sub map_accel_path {
      my($self, $env, $path) = @_;
  
      if (my $mapping = $env->{HTTP_X_ACCEL_MAPPING}) {
          my($internal, $external) = split /=/, $mapping, 2;
          $path =~ s!^\Q$internal\E!$external!i;
      }
  
      return $path;
  }
  
  sub _variation {
      my($self, $env) = @_;
      $self->variation || $env->{'plack.xsendfile.type'} || $env->{HTTP_X_SENDFILE_TYPE};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::XSendfile - Sets X-Sendfile (or a like) header for frontends
  
  =head1 SYNOPSIS
  
    enable "Plack::Middleware::XSendfile";
  
  =head1 DESCRIPTION
  
  You should use L<IO::File::WithPath> or L<Plack::Util>'s
  C<set_io_path> to add C<path> method to an IO object in the body.
  
  See L<http://github.com/rack/rack-contrib/blob/master/lib/rack/contrib/sendfile.rb>
  for the frontend configuration.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_XSENDFILE

$fatpacked{"Plack/Request.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_REQUEST';
  package Plack::Request;
  use strict;
  use warnings;
  use 5.008_001;
  our $VERSION = '1.0030';
  
  use HTTP::Headers;
  use Carp ();
  use Hash::MultiValue;
  use HTTP::Body;
  
  use Plack::Request::Upload;
  use Stream::Buffered;
  use URI;
  use URI::Escape ();
  
  sub new {
      my($class, $env) = @_;
      Carp::croak(q{$env is required})
          unless defined $env && ref($env) eq 'HASH';
  
      bless { env => $env }, $class;
  }
  
  sub env { $_[0]->{env} }
  
  sub address     { $_[0]->env->{REMOTE_ADDR} }
  sub remote_host { $_[0]->env->{REMOTE_HOST} }
  sub protocol    { $_[0]->env->{SERVER_PROTOCOL} }
  sub method      { $_[0]->env->{REQUEST_METHOD} }
  sub port        { $_[0]->env->{SERVER_PORT} }
  sub user        { $_[0]->env->{REMOTE_USER} }
  sub request_uri { $_[0]->env->{REQUEST_URI} }
  sub path_info   { $_[0]->env->{PATH_INFO} }
  sub path        { $_[0]->env->{PATH_INFO} || '/' }
  sub script_name { $_[0]->env->{SCRIPT_NAME} }
  sub scheme      { $_[0]->env->{'psgi.url_scheme'} }
  sub secure      { $_[0]->scheme eq 'https' }
  sub body        { $_[0]->env->{'psgi.input'} }
  sub input       { $_[0]->env->{'psgi.input'} }
  
  sub content_length   { $_[0]->env->{CONTENT_LENGTH} }
  sub content_type     { $_[0]->env->{CONTENT_TYPE} }
  
  sub session         { $_[0]->env->{'psgix.session'} }
  sub session_options { $_[0]->env->{'psgix.session.options'} }
  sub logger          { $_[0]->env->{'psgix.logger'} }
  
  sub cookies {
      my $self = shift;
  
      return {} unless $self->env->{HTTP_COOKIE};
  
      # HTTP_COOKIE hasn't changed: reuse the parsed cookie
      if (   $self->env->{'plack.cookie.parsed'}
          && $self->env->{'plack.cookie.string'} eq $self->env->{HTTP_COOKIE}) {
          return $self->env->{'plack.cookie.parsed'};
      }
  
      $self->env->{'plack.cookie.string'} = $self->env->{HTTP_COOKIE};
  
      my %results;
      my @pairs = grep m/=/, split "[;,] ?", $self->env->{'plack.cookie.string'};
      for my $pair ( @pairs ) {
          # trim leading trailing whitespace
          $pair =~ s/^\s+//; $pair =~ s/\s+$//;
  
          my ($key, $value) = map URI::Escape::uri_unescape($_), split( "=", $pair, 2 );
  
          # Take the first one like CGI.pm or rack do
          $results{$key} = $value unless exists $results{$key};
      }
  
      $self->env->{'plack.cookie.parsed'} = \%results;
  }
  
  sub query_parameters {
      my $self = shift;
      $self->env->{'plack.request.query'} ||= $self->_parse_query;
  }
  
  sub _parse_query {
      my $self = shift;
  
      my @query;
      my $query_string = $self->env->{QUERY_STRING};
      if (defined $query_string) {
          if ($query_string =~ /=/) {
              # Handle  ?foo=bar&bar=foo type of query
              @query =
                  map { s/\+/ /g; URI::Escape::uri_unescape($_) }
                  map { /=/ ? split(/=/, $_, 2) : ($_ => '')}
                  split(/[&;]/, $query_string);
          } else {
              # Handle ...?dog+bones type of query
              @query =
                  map { (URI::Escape::uri_unescape($_), '') }
                  split(/\+/, $query_string, -1);
          }
      }
  
      Hash::MultiValue->new(@query);
  }
  
  sub content {
      my $self = shift;
  
      unless ($self->env->{'psgix.input.buffered'}) {
          $self->_parse_request_body;
      }
  
      my $fh = $self->input                 or return '';
      my $cl = $self->env->{CONTENT_LENGTH} or return '';
  
      $fh->seek(0, 0); # just in case middleware/apps read it without seeking back
      $fh->read(my($content), $cl, 0);
      $fh->seek(0, 0);
  
      return $content;
  }
  
  sub raw_body { $_[0]->content }
  
  # XXX you can mutate headers with ->headers but it's not written through to the env
  
  sub headers {
      my $self = shift;
      if (!defined $self->{headers}) {
          my $env = $self->env;
          $self->{headers} = HTTP::Headers->new(
              map {
                  (my $field = $_) =~ s/^HTTPS?_//;
                  ( $field => $env->{$_} );
              }
                  grep { /^(?:HTTP|CONTENT)/i } keys %$env
              );
      }
      $self->{headers};
  }
  
  sub content_encoding { shift->headers->content_encoding(@_) }
  sub header           { shift->headers->header(@_) }
  sub referer          { shift->headers->referer(@_) }
  sub user_agent       { shift->headers->user_agent(@_) }
  
  sub body_parameters {
      my $self = shift;
  
      unless ($self->env->{'plack.request.body'}) {
          $self->_parse_request_body;
      }
  
      return $self->env->{'plack.request.body'};
  }
  
  # contains body + query
  sub parameters {
      my $self = shift;
  
      $self->env->{'plack.request.merged'} ||= do {
          my $query = $self->query_parameters;
          my $body  = $self->body_parameters;
          Hash::MultiValue->new($query->flatten, $body->flatten);
      };
  }
  
  sub uploads {
      my $self = shift;
  
      if ($self->env->{'plack.request.upload'}) {
          return $self->env->{'plack.request.upload'};
      }
  
      $self->_parse_request_body;
      return $self->env->{'plack.request.upload'};
  }
  
  sub param {
      my $self = shift;
  
      return keys %{ $self->parameters } if @_ == 0;
  
      my $key = shift;
      return $self->parameters->{$key} unless wantarray;
      return $self->parameters->get_all($key);
  }
  
  sub upload {
      my $self = shift;
  
      return keys %{ $self->uploads } if @_ == 0;
  
      my $key = shift;
      return $self->uploads->{$key} unless wantarray;
      return $self->uploads->get_all($key);
  }
  
  sub uri {
      my $self = shift;
  
      my $base = $self->_uri_base;
  
      # We have to escape back PATH_INFO in case they include stuff like
      # ? or # so that the URI parser won't be tricked. However we should
      # preserve '/' since encoding them into %2f doesn't make sense.
      # This means when a request like /foo%2fbar comes in, we recognize
      # it as /foo/bar which is not ideal, but that's how the PSGI PATH_INFO
      # spec goes and we can't do anything about it. See PSGI::FAQ for details.
  
      # See RFC 3986 before modifying.
      my $path_escape_class = q{^/;:@&=A-Za-z0-9\$_.+!*'(),-};
  
      my $path = URI::Escape::uri_escape($self->env->{PATH_INFO} || '', $path_escape_class);
      $path .= '?' . $self->env->{QUERY_STRING}
          if defined $self->env->{QUERY_STRING} && $self->env->{QUERY_STRING} ne '';
  
      $base =~ s!/$!! if $path =~ m!^/!;
  
      return URI->new($base . $path)->canonical;
  }
  
  sub base {
      my $self = shift;
      URI->new($self->_uri_base)->canonical;
  }
  
  sub _uri_base {
      my $self = shift;
  
      my $env = $self->env;
  
      my $uri = ($env->{'psgi.url_scheme'} || "http") .
          "://" .
          ($env->{HTTP_HOST} || (($env->{SERVER_NAME} || "") . ":" . ($env->{SERVER_PORT} || 80))) .
          ($env->{SCRIPT_NAME} || '/');
  
      return $uri;
  }
  
  sub new_response {
      my $self = shift;
      require Plack::Response;
      Plack::Response->new(@_);
  }
  
  sub _parse_request_body {
      my $self = shift;
  
      my $ct = $self->env->{CONTENT_TYPE};
      my $cl = $self->env->{CONTENT_LENGTH};
      if (!$ct && !$cl) {
          # No Content-Type nor Content-Length -> GET/HEAD
          $self->env->{'plack.request.body'}   = Hash::MultiValue->new;
          $self->env->{'plack.request.upload'} = Hash::MultiValue->new;
          return;
      }
  
      my $body = HTTP::Body->new($ct, $cl);
  
      # HTTP::Body will create temporary files in case there was an
      # upload.  Those temporary files can be cleaned up by telling
      # HTTP::Body to do so. It will run the cleanup when the request
      # env is destroyed. That the object will not go out of scope by
      # the end of this sub we will store a reference here.
      $self->env->{'plack.request.http.body'} = $body;
      $body->cleanup(1);
  
      my $input = $self->input;
  
      my $buffer;
      if ($self->env->{'psgix.input.buffered'}) {
          # Just in case if input is read by middleware/apps beforehand
          $input->seek(0, 0);
      } else {
          $buffer = Stream::Buffered->new($cl);
      }
  
      my $spin = 0;
      while ($cl) {
          $input->read(my $chunk, $cl < 8192 ? $cl : 8192);
          my $read = length $chunk;
          $cl -= $read;
          $body->add($chunk);
          $buffer->print($chunk) if $buffer;
  
          if ($read == 0 && $spin++ > 2000) {
              Carp::croak "Bad Content-Length: maybe client disconnect? ($cl bytes remaining)";
          }
      }
  
      if ($buffer) {
          $self->env->{'psgix.input.buffered'} = 1;
          $self->env->{'psgi.input'} = $buffer->rewind;
      } else {
          $input->seek(0, 0);
      }
  
      $self->env->{'plack.request.body'}   = Hash::MultiValue->from_mixed($body->param);
  
      my @uploads = Hash::MultiValue->from_mixed($body->upload)->flatten;
      my @obj;
      while (my($k, $v) = splice @uploads, 0, 2) {
          push @obj, $k, $self->_make_upload($v);
      }
  
      $self->env->{'plack.request.upload'} = Hash::MultiValue->new(@obj);
  
      1;
  }
  
  sub _make_upload {
      my($self, $upload) = @_;
      my %copy = %$upload;
      $copy{headers} = HTTP::Headers->new(%{$upload->{headers}});
      Plack::Request::Upload->new(%copy);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Request - Portable HTTP request object from PSGI env hash
  
  =head1 SYNOPSIS
  
    use Plack::Request;
  
    my $app_or_middleware = sub {
        my $env = shift; # PSGI env
  
        my $req = Plack::Request->new($env);
  
        my $path_info = $req->path_info;
        my $query     = $req->param('query');
  
        my $res = $req->new_response(200); # new Plack::Response
        $res->finalize;
    };
  
  =head1 DESCRIPTION
  
  L<Plack::Request> provides a consistent API for request objects across
  web server environments.
  
  =head1 CAVEAT
  
  Note that this module is intended to be used by Plack middleware
  developers and web application framework developers rather than
  application developers (end users).
  
  Writing your web application directly using Plack::Request is
  certainly possible but not recommended: it's like doing so with
  mod_perl's Apache::Request: yet too low level.
  
  If you're writing a web application, not a framework, then you're
  encouraged to use one of the web application frameworks that support PSGI (L<http://plackperl.org/#frameworks>),
  or see modules like L<HTTP::Engine> to provide higher level
  Request and Response API on top of PSGI.
  
  =head1 METHODS
  
  Some of the methods defined in the earlier versions are deprecated in
  version 0.99. Take a look at L</"INCOMPATIBILITIES">.
  
  Unless otherwise noted, all methods and attributes are B<read-only>,
  and passing values to the method like an accessor doesn't work like
  you expect it to.
  
  =head2 new
  
      Plack::Request->new( $env );
  
  Creates a new request object.
  
  =head1 ATTRIBUTES
  
  =over 4
  
  =item env
  
  Returns the shared PSGI environment hash reference. This is a
  reference, so writing to this environment passes through during the
  whole PSGI request/response cycle.
  
  =item address
  
  Returns the IP address of the client (C<REMOTE_ADDR>).
  
  =item remote_host
  
  Returns the remote host (C<REMOTE_HOST>) of the client. It may be
  empty, in which case you have to get the IP address using C<address>
  method and resolve on your own.
  
  =item method
  
  Contains the request method (C<GET>, C<POST>, C<HEAD>, etc).
  
  =item protocol
  
  Returns the protocol (HTTP/1.0 or HTTP/1.1) used for the current request.
  
  =item request_uri
  
  Returns the raw, undecoded request URI path. You probably do B<NOT>
  want to use this to dispatch requests.
  
  =item path_info
  
  Returns B<PATH_INFO> in the environment. Use this to get the local
  path for the requests.
  
  =item path
  
  Similar to C<path_info> but returns C</> in case it is empty. In other
  words, it returns the virtual path of the request URI after C<<
  $req->base >>. See L</"DISPATCHING"> for details.
  
  =item script_name
  
  Returns B<SCRIPT_NAME> in the environment. This is the absolute path
  where your application is hosted.
  
  =item scheme
  
  Returns the scheme (C<http> or C<https>) of the request.
  
  =item secure
  
  Returns true or false, indicating whether the connection is secure (https).
  
  =item body, input
  
  Returns C<psgi.input> handle.
  
  =item session
  
  Returns (optional) C<psgix.session> hash. When it exists, you can
  retrieve and store per-session data from and to this hash.
  
  =item session_options
  
  Returns (optional) C<psgix.session.options> hash.
  
  =item logger
  
  Returns (optional) C<psgix.logger> code reference. When it exists,
  your application is supposed to send the log message to this logger,
  using:
  
    $req->logger->({ level => 'debug', message => "This is a debug message" });
  
  =item cookies
  
  Returns a reference to a hash containing the cookies. Values are
  strings that are sent by clients and are URI decoded.
  
  If there are multiple cookies with the same name in the request, this
  method will ignore the duplicates and return only the first value. If
  that causes issues for you, you may have to use modules like
  CGI::Simple::Cookie to parse C<$request->header('Cookies')> by
  yourself.
  
  =item query_parameters
  
  Returns a reference to a hash containing query string (GET)
  parameters. This hash reference is L<Hash::MultiValue> object.
  
  =item body_parameters
  
  Returns a reference to a hash containing posted parameters in the
  request body (POST). As with C<query_parameters>, the hash
  reference is a L<Hash::MultiValue> object.
  
  =item parameters
  
  Returns a L<Hash::MultiValue> hash reference containing (merged) GET
  and POST parameters.
  
  =item content, raw_body
  
  Returns the request content in an undecoded byte string for POST requests.
  
  =item uri
  
  Returns an URI object for the current request. The URI is constructed
  using various environment values such as C<SCRIPT_NAME>, C<PATH_INFO>,
  C<QUERY_STRING>, C<HTTP_HOST>, C<SERVER_NAME> and C<SERVER_PORT>.
  
  Every time this method is called it returns a new, cloned URI object.
  
  =item base
  
  Returns an URI object for the base path of current request. This is
  like C<uri> but only contains up to C<SCRIPT_NAME> where your
  application is hosted at.
  
  Every time this method is called it returns a new, cloned URI object.
  
  =item user
  
  Returns C<REMOTE_USER> if it's set.
  
  =item headers
  
  Returns an L<HTTP::Headers> object containing the headers for the current request.
  
  =item uploads
  
  Returns a reference to a hash containing uploads. The hash reference
  is a L<Hash::MultiValue> object and values are L<Plack::Request::Upload>
  objects.
  
  =item content_encoding
  
  Shortcut to $req->headers->content_encoding.
  
  =item content_length
  
  Shortcut to $req->headers->content_length.
  
  =item content_type
  
  Shortcut to $req->headers->content_type.
  
  =item header
  
  Shortcut to $req->headers->header.
  
  =item referer
  
  Shortcut to $req->headers->referer.
  
  =item user_agent
  
  Shortcut to $req->headers->user_agent.
  
  =item param
  
  Returns GET and POST parameters with a CGI.pm-compatible param
  method. This is an alternative method for accessing parameters in
  $req->parameters. Unlike CGI.pm, it does I<not> allow
  setting or modifying query parameters.
  
      $value  = $req->param( 'foo' );
      @values = $req->param( 'foo' );
      @params = $req->param;
  
  =item upload
  
  A convenient method to access $req->uploads.
  
      $upload  = $req->upload('field');
      @uploads = $req->upload('field');
      @fields  = $req->upload;
  
      for my $upload ( $req->upload('field') ) {
          print $upload->filename;
      }
  
  =item new_response
  
    my $res = $req->new_response;
  
  Creates a new L<Plack::Response> object. Handy to remove dependency on
  L<Plack::Response> in your code for easy subclassing and duck typing
  in web application frameworks, as well as overriding Response
  generation in middlewares.
  
  =back
  
  =head2 Hash::MultiValue parameters
  
  Parameters that can take one or multiple values (i.e. C<parameters>,
  C<query_parameters>, C<body_parameters> and C<uploads>) store the
  hash reference as a L<Hash::MultiValue> object. This means you can use
  the hash reference as a plain hash where values are B<always> scalars
  (B<NOT> array references), so you don't need to code ugly and unsafe
  C<< ref ... eq 'ARRAY' >> anymore.
  
  And if you explicitly want to get multiple values of the same key, you
  can call the C<get_all> method on it, such as:
  
    my @foo = $req->query_parameters->get_all('foo');
  
  You can also call C<get_one> to always get one parameter independent
  of the context (unlike C<param>), and even call C<mixed> (with
  Hash::MultiValue 0.05 or later) to get the I<traditional> hash
  reference,
  
    my $params = $req->parameters->mixed;
  
  where values are either a scalar or an array reference depending on
  input, so it might be useful if you already have the code to deal with
  that ugliness.
  
  =head2 PARSING POST BODY and MULTIPLE OBJECTS
  
  The methods to parse request body (C<content>, C<body_parameters> and
  C<uploads>) are carefully coded to save the parsed body in the
  environment hash as well as in the temporary buffer, so you can call
  them multiple times and create Plack::Request objects multiple times
  in a request and they should work safely, and won't parse request body
  more than twice for the efficiency.
  
  =head1 DISPATCHING
  
  If your application or framework wants to dispatch (or route) actions
  based on request paths, be sure to use C<< $req->path_info >> not C<<
  $req->uri->path >>.
  
  This is because C<path_info> gives you the virtual path of the request,
  regardless of how your application is mounted. If your application is
  hosted with mod_perl or CGI scripts, or even multiplexed with tools
  like L<Plack::App::URLMap>, request's C<path_info> always gives you
  the action path.
  
  Note that C<path_info> might give you an empty string, in which case
  you should assume that the path is C</>.
  
  You will also want to use C<< $req->base >> as a base prefix when
  building URLs in your templates or in redirections. It's a good idea
  for you to subclass Plack::Request and define methods such as:
  
    sub uri_for {
        my($self, $path, $args) = @_;
        my $uri = $self->base;
        $uri->path($uri->path . $path);
        $uri->query_form(@$args) if $args;
        $uri;
    }
  
  So you can say:
  
    my $link = $req->uri_for('/logout', [ signoff => 1 ]);
  
  and if C<< $req->base >> is C</app> you'll get the full URI for
  C</app/logout?signoff=1>.
  
  =head1 INCOMPATIBILITIES
  
  In version 0.99, many utility methods are removed or deprecated, and
  most methods are made read-only. These methods were deleted in version
  1.0001.
  
  All parameter-related methods such as C<parameters>,
  C<body_parameters>, C<query_parameters> and C<uploads> now contains
  L<Hash::MultiValue> objects, rather than I<scalar or an array
  reference depending on the user input> which is insecure. See
  L<Hash::MultiValue> for more about this change.
  
  C<< $req->path >> method had a bug, where the code and the document
  was mismatching. The document was suggesting it returns the sub
  request path after C<< $req->base >> but the code was always returning
  the absolute URI path. The code is now updated to be an alias of C<<
  $req->path_info >> but returns C</> in case it's empty. If you need
  the older behavior, just call C<< $req->uri->path >> instead.
  
  Cookie handling is simplified, and doesn't use L<CGI::Simple::Cookie>
  anymore, which means you B<CAN NOT> set array reference or hash
  reference as a cookie value and expect it be serialized. You're always
  required to set string value, and encoding or decoding them is totally
  up to your application or framework. Also, C<cookies> hash reference
  now returns I<strings> for the cookies rather than CGI::Simple::Cookie
  objects, which means you no longer have to write a wacky code such as:
  
    $v = $req->cookie->{foo} ? $req->cookie->{foo}->value : undef;
  
  and instead, simply do:
  
    $v = $req->cookie->{foo};
  
  =head1 AUTHORS
  
  Tatsuhiko Miyagawa
  
  Kazuhiro Osawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack::Response> L<HTTP::Request>, L<Catalyst::Request>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK_REQUEST

$fatpacked{"Plack/Request/Upload.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_REQUEST_UPLOAD';
  package Plack::Request::Upload;
  use strict;
  use warnings;
  use Carp ();
  
  sub new {
      my($class, %args) = @_;
  
      bless {
          headers  => $args{headers},
          tempname => $args{tempname},
          size     => $args{size},
          filename => $args{filename},
      }, $class;
  }
  
  sub filename { $_[0]->{filename} }
  sub headers  { $_[0]->{headers} }
  sub size     { $_[0]->{size} }
  sub tempname { $_[0]->{tempname} }
  sub path     { $_[0]->{tempname} }
  
  sub content_type {
      my $self = shift;
      $self->{headers}->content_type(@_);
  }
  
  sub type { shift->content_type(@_) }
  
  sub basename {
      my $self = shift;
      unless (defined $self->{basename}) {
          require File::Spec::Unix;
          my $basename = $self->{filename};
          $basename =~ s|\\|/|g;
          $basename = ( File::Spec::Unix->splitpath($basename) )[2];
          $basename =~ s|[^\w\.-]+|_|g;
          $self->{basename} = $basename;
      }
      $self->{basename};
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Request::Upload - handles file upload requests
  
  =head1 SYNOPSIS
  
    # $req is Plack::Request
    my $upload = $req->uploads->{field};
  
    $upload->size;
    $upload->path;
    $upload->content_type;
    $upload->basename;
  
  =head1 METHODS
  
  =over 4
  
  =item size
  
  Returns the size of Uploaded file.
  
  =item path
  
  Returns the path to the temporary file where uploaded file is saved.
  
  =item content_type
  
  Returns the content type of the uploaded file.
  
  =item filename
  
  Returns the original filename in the client.
  
  =item basename
  
  Returns basename for "filename".
  
  =back
  
  =head1 AUTHORS
  
  Kazuhiro Osawa
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Request>, L<Catalyst::Request::Upload>
  
  =cut
PLACK_REQUEST_UPLOAD

$fatpacked{"Plack/Response.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_RESPONSE';
  package Plack::Response;
  use strict;
  use warnings;
  our $VERSION = '1.0030';
  
  use Plack::Util::Accessor qw(body status);
  use Carp ();
  use Scalar::Util ();
  use HTTP::Headers;
  use URI::Escape ();
  
  sub code    { shift->status(@_) }
  sub content { shift->body(@_)   }
  
  sub new {
      my($class, $rc, $headers, $content) = @_;
  
      my $self = bless {}, $class;
      $self->status($rc)       if defined $rc;
      $self->headers($headers) if defined $headers;
      $self->body($content)    if defined $content;
  
      $self;
  }
  
  sub headers {
      my $self = shift;
  
      if (@_) {
          my $headers = shift;
          if (ref $headers eq 'ARRAY') {
              Carp::carp("Odd number of headers") if @$headers % 2 != 0;
              $headers = HTTP::Headers->new(@$headers);
          } elsif (ref $headers eq 'HASH') {
              $headers = HTTP::Headers->new(%$headers);
          }
          return $self->{headers} = $headers;
      } else {
          return $self->{headers} ||= HTTP::Headers->new();
      }
  }
  
  sub cookies {
      my $self = shift;
      if (@_) {
          $self->{cookies} = shift;
      } else {
          return $self->{cookies} ||= +{ };
      }
  }
  
  sub header { shift->headers->header(@_) } # shortcut
  
  sub content_length {
      shift->headers->content_length(@_);
  }
  
  sub content_type {
      shift->headers->content_type(@_);
  }
  
  sub content_encoding {
      shift->headers->content_encoding(@_);
  }
  
  sub location {
      my $self = shift;
      return $self->headers->header('Location' => @_);
  }
  
  sub redirect {
      my $self = shift;
  
      if (@_) {
          my $url = shift;
          my $status = shift || 302;
          $self->location($url);
          $self->status($status);
      }
  
      return $self->location;
  }
  
  sub finalize {
      my $self = shift;
      Carp::croak "missing status" unless $self->status();
  
      my $headers = $self->headers;
      my @headers;
      $headers->scan(sub{
          my ($k,$v) = @_;
          $v =~ s/\015\012[\040|\011]+/chr(32)/ge; # replace LWS with a single SP
          $v =~ s/\015|\012//g; # remove CR and LF since the char is invalid here
          push @headers, $k, $v;
      });
  
      $self->_finalize_cookies(\@headers);
  
      return [
          $self->status,
          \@headers,
          $self->_body,
      ];
  }
  
  sub to_app {
      my $self = shift;
      return sub { $self->finalize };
  }
  
  
  sub _body {
      my $self = shift;
      my $body = $self->body;
         $body = [] unless defined $body;
      if (!ref $body or Scalar::Util::blessed($body) && overload::Method($body, q("")) && !$body->can('getline')) {
          return [ $body ];
      } else {
          return $body;
      }
  }
  
  sub _finalize_cookies {
      my($self, $headers) = @_;
  
      while (my($name, $val) = each %{$self->cookies}) {
          my $cookie = $self->_bake_cookie($name, $val);
          push @$headers, 'Set-Cookie' => $cookie;
      }
  }
  
  sub _bake_cookie {
      my($self, $name, $val) = @_;
  
      return '' unless defined $val;
      $val = { value => $val } unless ref $val eq 'HASH';
  
      my @cookie = ( URI::Escape::uri_escape($name) . "=" . URI::Escape::uri_escape($val->{value}) );
      push @cookie, "domain=" . $val->{domain}   if $val->{domain};
      push @cookie, "path=" . $val->{path}       if $val->{path};
      push @cookie, "expires=" . $self->_date($val->{expires}) if $val->{expires};
      push @cookie, "max-age=" . $val->{"max-age"} if $val->{"max-age"};
      push @cookie, "secure"                     if $val->{secure};
      push @cookie, "HttpOnly"                   if $val->{httponly};
  
      return join "; ", @cookie;
  }
  
  my @MON  = qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec );
  my @WDAY = qw( Sun Mon Tue Wed Thu Fri Sat );
  
  sub _date {
      my($self, $expires) = @_;
  
      if ($expires =~ /^\d+$/) {
          # all numbers -> epoch date
          # (cookies use '-' as date separator, HTTP uses ' ')
          my($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($expires);
          $year += 1900;
  
          return sprintf("%s, %02d-%s-%04d %02d:%02d:%02d GMT",
                         $WDAY[$wday], $mday, $MON[$mon], $year, $hour, $min, $sec);
  
      }
  
      return $expires;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Response - Portable HTTP Response object for PSGI response
  
  =head1 SYNOPSIS
  
    use Plack::Response;
  
    sub psgi_handler {
        my $env = shift;
  
        my $res = Plack::Response->new(200);
        $res->content_type('text/html');
        $res->body("Hello World");
  
        return $res->finalize;
    }
  
  =head1 DESCRIPTION
  
  Plack::Response allows you a way to create PSGI response array ref through a simple API.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $res = Plack::Response->new;
    $res = Plack::Response->new($status);
    $res = Plack::Response->new($status, $headers);
    $res = Plack::Response->new($status, $headers, $body);
  
  Creates a new Plack::Response object.
  
  =item status
  
    $res->status(200);
    $status = $res->status;
  
  Sets and gets HTTP status code. C<code> is an alias.
  
  =item headers
  
    $headers = $res->headers;
    $res->headers([ 'Content-Type' => 'text/html' ]);
    $res->headers({ 'Content-Type' => 'text/html' });
    $res->headers( HTTP::Headers->new );
  
  Sets and gets HTTP headers of the response. Setter can take either an
  array ref, a hash ref or L<HTTP::Headers> object containing a list of
  headers.
  
  =item body
  
    $res->body($body_str);
    $res->body([ "Hello", "World" ]);
    $res->body($io);
  
  Gets and sets HTTP response body. Setter can take either a string, an
  array ref, or an IO::Handle-like object. C<content> is an alias.
  
  Note that this method doesn't automatically set I<Content-Length> for
  the response. You have to set it manually if you want, with the
  C<content_length> method (see below).
  
  =item header
  
    $res->header('X-Foo' => 'bar');
    my $val = $res->header('X-Foo');
  
  Shortcut for C<< $res->headers->header >>.
  
  =item content_type, content_length, content_encoding
  
    $res->content_type('text/plain');
    $res->content_length(123);
    $res->content_encoding('gzip');
  
  Shortcut for the equivalent get/set methods in C<< $res->headers >>.
  
  =item redirect
  
    $res->redirect($url);
    $res->redirect($url, 301);
  
  Sets redirect URL with an optional status code, which defaults to 302.
  
  Note that this method doesn't normalize the given URI string. Users of
  this module have to be responsible about properly encoding URI paths
  and parameters.
  
  =item location
  
  Gets and sets C<Location> header.
  
  Note that this method doesn't normalize the given URI string in the
  setter. See above in C<redirect> for details.
  
  =item cookies
  
    $res->cookies->{foo} = 123;
    $res->cookies->{foo} = { value => '123' };
  
  Returns a hash reference containing cookies to be set in the
  response. The keys of the hash are the cookies' names, and their
  corresponding values are a plain string (for C<value> with everything
  else defaults) or a hash reference that can contain keys such as
  C<value>, C<domain>, C<expires>, C<path>, C<httponly>, C<secure>,
  C<max-age>.
  
  C<expires> can take a string or an integer (as an epoch time) and
  B<does not> convert string formats such as C<+3M>.
  
    $res->cookies->{foo} = {
        value => 'test',
        path  => "/",
        domain => '.example.com',
        expires => time + 24 * 60 * 60,
    };
  
  =item finalize
  
    $res->finalize;
  
  Returns the status code, headers, and body of this response as a PSGI
  response array reference.
  
  =item to_app
  
    $app = $res->to_app;
  
  A helper shortcut for C<< sub { $res->finalize } >>.
  
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Request>
  
  =cut
PLACK_RESPONSE

$fatpacked{"Plack/Runner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_RUNNER';
  package Plack::Runner;
  use strict;
  use warnings;
  use Carp ();
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my $class = shift;
      bless {
          env      => $ENV{PLACK_ENV},
          loader   => 'Plack::Loader',
          includes => [],
          modules  => [],
          default_middleware => 1,
          @_,
      }, $class;
  }
  
  # delay the build process for reloader
  sub build(&;$) {
      my $block = shift;
      my $app   = shift || sub { };
      return sub { $block->($app->()) };
  }
  
  sub parse_options {
      my $self = shift;
  
      local @ARGV = @_;
  
      # From 'prove': Allow cuddling the paths with -I, -M and -e
      @ARGV = map { /^(-[IMe])(.+)/ ? ($1,$2) : $_ } @ARGV;
  
      my($host, $port, $socket, @listen);
  
      require Getopt::Long;
      my $parser = Getopt::Long::Parser->new(
          config => [ "no_auto_abbrev", "no_ignore_case", "pass_through" ],
      );
  
      $parser->getoptions(
          "a|app=s"      => \$self->{app},
          "o|host=s"     => \$host,
          "p|port=i"     => \$port,
          "s|server=s"   => \$self->{server},
          "S|socket=s"   => \$socket,
          'l|listen=s@'  => \@listen,
          'D|daemonize'  => \$self->{daemonize},
          "E|env=s"      => \$self->{env},
          "e=s"          => \$self->{eval},
          'I=s@'         => $self->{includes},
          'M=s@'         => $self->{modules},
          'r|reload'     => sub { $self->{loader} = "Restarter" },
          'R|Reload=s'   => sub { $self->{loader} = "Restarter"; $self->loader->watch(split ",", $_[1]) },
          'L|loader=s'   => \$self->{loader},
          "access-log=s" => \$self->{access_log},
          "path=s"       => \$self->{path},
          "h|help"       => \$self->{help},
          "v|version"    => \$self->{version},
          "default-middleware!" => \$self->{default_middleware},
      );
  
      my(@options, @argv);
      while (defined(my $arg = shift @ARGV)) {
          if ($arg =~ s/^--?//) {
              my @v = split '=', $arg, 2;
              $v[0] =~ tr/-/_/;
              if (@v == 2) {
                  push @options, @v;
              } elsif ($v[0] =~ s/^(disable|enable)_//) {
                  push @options, $v[0], $1 eq 'enable';
              } else {
                  push @options, $v[0], shift @ARGV;
              }
          } else {
              push @argv, $arg;
          }
      }
  
      push @options, $self->mangle_host_port_socket($host, $port, $socket, @listen);
      push @options, daemonize => 1 if $self->{daemonize};
  
      $self->{options} = \@options;
      $self->{argv}    = \@argv;
  }
  
  sub set_options {
      my $self = shift;
      push @{$self->{options}}, @_;
  }
  
  sub mangle_host_port_socket {
      my($self, $host, $port, $socket, @listen) = @_;
  
      for my $listen (reverse @listen) {
          if ($listen =~ /:\d+$/) {
              ($host, $port) = split /:/, $listen, 2;
              $host = undef if $host eq '';
          } else {
              $socket ||= $listen;
          }
      }
  
      unless (@listen) {
          if ($socket) {
              @listen = ($socket);
          } else {
              $port ||= 5000;
              @listen = ($host ? "$host:$port" : ":$port");
          }
      }
  
      return host => $host, port => $port, listen => \@listen, socket => $socket;
  }
  
  sub version_cb {
      my $self = shift;
      $self->{version_cb} || sub {
          require Plack;
          print "Plack $Plack::VERSION\n";
      };
  }
  
  sub setup {
      my $self = shift;
  
      if ($self->{help}) {
          require Pod::Usage;
          Pod::Usage::pod2usage(0);
      }
  
      if ($self->{version}) {
          $self->version_cb->();
          exit;
      }
  
      if (@{$self->{includes}}) {
          require lib;
          lib->import(@{$self->{includes}});
      }
  
      if ($self->{eval}) {
          push @{$self->{modules}}, 'Plack::Builder';
      }
  
      for (@{$self->{modules}}) {
          my($module, @import) = split /[=,]/;
          eval "require $module" or die $@;
          $module->import(@import);
      }
  }
  
  sub locate_app {
      my($self, @args) = @_;
  
      my $psgi = $self->{app} || $args[0];
  
      if (ref $psgi eq 'CODE') {
          return sub { $psgi };
      }
  
      if ($self->{eval}) {
          $self->loader->watch("lib");
          return build {
              no strict;
              no warnings;
              my $eval = "builder { $self->{eval};";
              $eval .= "Plack::Util::load_psgi(\$psgi);" if $psgi;
              $eval .= "}";
              eval $eval or die $@;
          };
      }
  
      $psgi ||= "app.psgi";
  
      require File::Basename;
      $self->loader->watch( File::Basename::dirname($psgi) . "/lib", $psgi );
      build { Plack::Util::load_psgi $psgi };
  }
  
  sub watch {
      my($self, @dir) = @_;
  
      push @{$self->{watch}}, @dir
          if $self->{loader} eq 'Restarter';
  }
  
  sub apply_middleware {
      my($self, $app, $class, @args) = @_;
  
      my $mw_class = Plack::Util::load_class($class, 'Plack::Middleware');
      build { $mw_class->wrap($_[0], @args) } $app;
  }
  
  sub prepare_devel {
      my($self, $app) = @_;
  
      if ($self->{default_middleware}) {
          $app = $self->apply_middleware($app, 'Lint');
          $app = $self->apply_middleware($app, 'StackTrace');
          if (!$ENV{GATEWAY_INTERFACE} and !$self->{access_log}) {
              $app = $self->apply_middleware($app, 'AccessLog');
          }
      }
  
      push @{$self->{options}}, server_ready => sub {
          my($args) = @_;
          my $name  = $args->{server_software} || ref($args); # $args is $server
          my $host  = $args->{host} || 0;
          my $proto = $args->{proto} || 'http';
          print STDERR "$name: Accepting connections at $proto://$host:$args->{port}/\n";
      };
  
      $app;
  }
  
  sub loader {
      my $self = shift;
      $self->{_loader} ||= Plack::Util::load_class($self->{loader}, 'Plack::Loader')->new;
  }
  
  sub load_server {
      my($self, $loader) = @_;
  
      if ($self->{server}) {
          return $loader->load($self->{server}, @{$self->{options}});
      } else {
          return $loader->auto(@{$self->{options}});
      }
  }
  
  sub run {
      my $self = shift;
  
      unless (ref $self) {
          $self = $self->new;
          $self->parse_options(@_);
          return $self->run;
      }
  
      unless ($self->{options}) {
          $self->parse_options();
      }
  
      my @args = @_ ? @_ : @{$self->{argv}};
  
      $self->setup;
  
      my $app = $self->locate_app(@args);
  
      if ($self->{path}) {
          require Plack::App::URLMap;
          $app = build {
              my $urlmap = Plack::App::URLMap->new;
              $urlmap->mount($self->{path} => $_[0]);
              $urlmap->to_app;
          } $app;
      }
  
      $ENV{PLACK_ENV} ||= $self->{env} || 'development';
      if ($ENV{PLACK_ENV} eq 'development') {
          $app = $self->prepare_devel($app);
      }
  
      if ($self->{access_log}) {
          open my $logfh, ">>", $self->{access_log}
              or die "open($self->{access_log}): $!";
          $logfh->autoflush(1);
          $app = $self->apply_middleware($app, 'AccessLog', logger => sub { $logfh->print( @_ ) });
      }
  
      my $loader = $self->loader;
      $loader->preload_app($app);
  
      my $server = $self->load_server($loader);
      $loader->run($server);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Runner - plackup core
  
  =head1 SYNOPSIS
  
    # Your bootstrap script
    use Plack::Runner;
    my $app = sub { ... };
  
    my $runner = Plack::Runner->new;
    $runner->parse_options(@ARGV);
    $runner->run($app);
  
  =head1 DESCRIPTION
  
  Plack::Runner is the core of L<plackup> runner script. You can create
  your own frontend to run your application or framework, munge command
  line options and pass that to C<run> method of this class.
  
  C<run> method does exactly the same thing as the L<plackup> script
  does, but one notable addition is that you can pass a PSGI application
  code reference directly to the method, rather than via C<.psgi>
  file path or with C<-e> switch. This would be useful if you want to
  make an installable PSGI application.
  
  Also, when C<-h> or C<--help> switch is passed, the usage text is
  automatically extracted from your own script using L<Pod::Usage>.
  
  =head1 NOTES
  
  Do not directly call this module from your C<.psgi>, since that makes
  your PSGI application unnecessarily depend on L<plackup> and won't run
  other backends like L<Plack::Handler::Apache2> or mod_psgi.
  
  If you I<really> want to make your C<.psgi> runnable as a standalone
  script, you can do this:
  
    my $app = sub { ... };
  
    unless (caller) {
        require Plack::Runner;
        my $runner = Plack::Runner->new;
        $runner->parse_options(@ARGV);
        return $runner->run($app);
    }
  
    return $app;
  
  B<WARNING>: this section used to recommend C<if (__FILE__ eq $0)> but
  it's known to be broken since Plack 0.9971, since C<$0> is now
  I<always> set to the .psgi file path even when you run it from
  plackup.
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
  
  
PLACK_RUNNER

$fatpacked{"Plack/TempBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_TEMPBUFFER';
  package Plack::TempBuffer;
  use strict;
  use warnings;
  
  use parent 'Stream::Buffered';
  
  sub new {
      my $class = shift;
  
      if (defined $Plack::TempBuffer::MaxMemoryBufferSize) {
          warn "Setting \$Plack::TempBuffer::MaxMemoryBufferSize is deprecated. "
             . "You should set \$Stream::Buffered::MaxMemoryBufferSize instead.";
          $Stream::Buffered::MaxMemoryBufferSize = $Plack::TempBuffer::MaxMemoryBufferSize;
      }
  
      return $class->SUPER::new(@_);
  }
  
  1;
PLACK_TEMPBUFFER

$fatpacked{"Plack/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_TEST';
  package Plack::Test;
  use strict;
  use warnings;
  use Carp;
  use parent qw(Exporter);
  our @EXPORT = qw(test_psgi);
  
  our $Impl;
  $Impl ||= $ENV{PLACK_TEST_IMPL} || "MockHTTP";
  
  sub create {
      my($class, $app, @args) = @_;
  
      my $subclass = "Plack::Test::$Impl";
      eval "require $subclass";
      die $@ if $@;
  
      no strict 'refs';
      if (defined &{"Plack::Test::$Impl\::test_psgi"}) {
          return \&{"Plack::Test::$Impl\::test_psgi"};
      }
  
      $subclass->new($app, @args);
  }
  
  sub test_psgi {
      if (ref $_[0] && @_ == 2) {
          @_ = (app => $_[0], client => $_[1]);
      }
      my %args = @_;
  
      my $app    = delete $args{app}; # Backward compat: some implementations don't need app
      my $client = delete $args{client} or Carp::croak "client test code needed";
  
      my $tester = Plack::Test->create($app, %args);
      return $tester->(@_) if ref $tester eq 'CODE'; # compatibility
  
      $client->(sub { $tester->request(@_) });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test - Test PSGI applications with various backends
  
  =head1 SYNOPSIS
  
    use Plack::Test;
    use HTTP::Request::Common;
  
    # Simple OO interface
    my $app = sub { return [ 200, [], [ "Hello "] ] };
    my $test = Plack::Test->create($app);
  
    my $res = $test->request(GET "/");
    is $res->content, "Hello";
  
    # traditional - named params
    test_psgi
        app => sub {
            my $env = shift;
            return [ 200, [ 'Content-Type' => 'text/plain' ], [ "Hello World" ] ],
        },
        client => sub {
            my $cb  = shift;
            my $req = HTTP::Request->new(GET => "http://localhost/hello");
            my $res = $cb->($req);
            like $res->content, qr/Hello World/;
        };
  
    # positional params (app, client)
    my $app = sub { return [ 200, [], [ "Hello "] ] };
    test_psgi $app, sub {
        my $cb  = shift;
        my $res = $cb->(GET "/");
        is $res->content, "Hello";
    };
  
  =head1 DESCRIPTION
  
  Plack::Test is a unified interface to test PSGI applications using
  L<HTTP::Request> and L<HTTP::Response> objects. It also allows you to run PSGI
  applications in various ways. The default backend is C<Plack::Test::MockHTTP>,
  but you may also use any L<Plack::Handler> implementation to run live HTTP
  requests against a web server.
  
  =head1 METHODS
  
  =over 4
  
  =item create
  
    $test = Plack::Test->create($app, %options);
  
  creates an instance of Plack::Test implementation class. C<$app> has
  to be a valid PSGI application code reference.
  
  =item request
  
    $res = $test->request($request);
  
  takes an HTTP::Request object, runs it through the PSGI application to
  test and returns an HTTP::Response object.
  
  =back
  
  =head1 FUNCTIONS
  
  Plack::Test also provides a functional interface that takes two
  callbacks, each of which represents PSGI application and HTTP client
  code that tests the application.
  
  =over 4
  
  =item test_psgi
  
    test_psgi $app, $client;
    test_psgi app => $app, client => $client;
  
  Runs the client test code C<$client> against a PSGI application
  C<$app>. The client callback gets one argument C<$cb>, a
  callback that accepts an C<HTTP::Request> object and returns an
  C<HTTP::Response> object.
  
  Use L<HTTP::Request::Common> to import shortcuts for creating requests for
  C<GET>, C<POST>, C<DELETE>, and C<PUT> operations.
  
  For your convenience, the C<HTTP::Request> given to the callback automatically
  uses the HTTP protocol and the localhost (I<127.0.0.1> by default), so the
  following code just works:
  
    use HTTP::Request::Common;
    test_psgi $app, sub {
        my $cb  = shift;
        my $res = $cb->(GET "/hello");
    };
  
  Note that however, it is not a good idea to pass an arbitrary
  (i.e. user-input) string to C<GET> or even C<<
  HTTP::Request->new >> by assuming that it always represents a path,
  because:
  
    my $req = GET "//foo/bar";
  
  would represent a request for a URL that has no scheme, has a hostname
  I<foo> and a path I</bar>, instead of a path I<//foo/bar> which you
  might actually want.
  
  =back
  
  =head1 OPTIONS
  
  Specify the L<Plack::Test> backend using the environment
  variable C<PLACK_TEST_IMPL> or C<$Plack::Test::Impl> package variable.
  
  The available values for the backend are:
  
  =over 4
  
  =item MockHTTP
  
  (Default) Creates a PSGI env hash out of HTTP::Request object, runs
  the PSGI application in-process and returns HTTP::Response.
  
  =item Server
  
  Runs one of Plack::Handler backends (C<Standalone> by default) and
  sends live HTTP requests to test.
  
  =item ExternalServer
  
  Runs tests against an external server specified in the
  C<PLACK_TEST_EXTERNALSERVER_URI> environment variable instead of spawning the
  application in a server locally.
  
  =back
  
  For instance, test your application with the C<HTTP::Server::ServerSimple>
  server backend with:
  
    > env PLACK_TEST_IMPL=Server PLACK_SERVER=HTTP::Server::ServerSimple \
      prove -l t/test.t
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_TEST

$fatpacked{"Plack/Test/MockHTTP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_TEST_MOCKHTTP';
  package Plack::Test::MockHTTP;
  use strict;
  use warnings;
  
  use Carp;
  use HTTP::Request;
  use HTTP::Response;
  use HTTP::Message::PSGI;
  use Try::Tiny;
  
  sub new {
      my($class, $app) = @_;
      bless { app => $app }, $class;
  }
  
  sub request {
      my($self, $req) = @_;
  
      $req->uri->scheme('http')    unless defined $req->uri->scheme;
      $req->uri->host('localhost') unless defined $req->uri->host;
      my $env = $req->to_psgi;
  
      my $res = try {
          HTTP::Response->from_psgi($self->{app}->($env));
      } catch {
          HTTP::Response->from_psgi([ 500, [ 'Content-Type' => 'text/plain' ], [ $_ ] ]);
      };
  
      $res->request($req);
      return $res;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test::MockHTTP - Run mocked HTTP tests through PSGI applications
  
  =head1 DESCRIPTION
  
  Plack::Test::MockHTTP is a utility to run PSGI application given
  HTTP::Request objects and return HTTP::Response object out of PSGI
  application response. See L<Plack::Test> how to use this module.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Test>
  
  =cut
  
  
PLACK_TEST_MOCKHTTP

$fatpacked{"Plack/Test/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_TEST_SERVER';
  package Plack::Test::Server;
  use strict;
  use warnings;
  use Carp;
  use HTTP::Request;
  use HTTP::Response;
  use Test::TCP;
  use Plack::Loader;
  use Plack::LWPish;
  
  sub new {
      my($class, $app, %args) = @_;
  
      my $server = Test::TCP->new(
          code => sub {
              my $port = shift;
              my $server = Plack::Loader->auto(port => $port, host => ($args{host} || '127.0.0.1'));
              $server->run($app);
              exit;
          },
      );
  
      bless { server => $server, %args }, $class;
  }
  
  sub port {
      my $self = shift;
      $self->{server}->port;
  }
  
  sub request {
      my($self, $req) = @_;
  
      my $ua = $self->{ua} || Plack::LWPish->new( no_proxy => [qw/127.0.0.1/] );
  
      $req->uri->scheme('http');
      $req->uri->host($self->{host} || '127.0.0.1');
      $req->uri->port($self->port);
  
      return $ua->request($req);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test::Server - Run HTTP tests through live Plack servers
  
  =head1 DESCRIPTION
  
  Plack::Test::Server is a utility to run PSGI application with Plack
  server implementations, and run the live HTTP tests with the server
  using a callback. See L<Plack::Test> how to use this module.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack::Loader> L<Test::TCP> L<Plack::Test>
  
  =cut
  
PLACK_TEST_SERVER

$fatpacked{"Plack/Test/Suite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_TEST_SUITE';
  package Plack::Test::Suite;
  use strict;
  use warnings;
  use Digest::MD5;
  use File::ShareDir;
  use HTTP::Request;
  use HTTP::Request::Common;
  use Test::More;
  use Test::TCP;
  use Plack::Loader;
  use Plack::Middleware::Lint;
  use Plack::Util;
  use Plack::Request;
  use Try::Tiny;
  use Plack::LWPish;
  
  my $share_dir = try { File::ShareDir::dist_dir('Plack') } || 'share';
  
  $ENV{PLACK_TEST_SCRIPT_NAME} = '';
  
  # 0: test name
  # 1: request generator coderef.
  # 2: request handler
  # 3: test case for response
  our @TEST = (
      [
          'SCRIPT_NAME',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->content, "script_name=$ENV{PLACK_TEST_SCRIPT_NAME}";
          },
          sub {
              my $env = shift;
              return [ 200, ["Content-Type", "text/plain"], [ "script_name=$env->{SCRIPT_NAME}" ] ];
          },
      ],
      [
          'GET',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ 'Hello, ' . $env->{QUERY_STRING} ],
              ];
          },
      ],
      [
          'POST',
          sub {
              my $cb = shift;
              my $res = $cb->(POST "http://127.0.0.1/", [name => 'tatsuhiko']);
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('Client-Content-Length'), 14;
              is $res->header('Client-Content-Type'), 'application/x-www-form-urlencoded';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=tatsuhiko';
          },
          sub {
              my $env = shift;
              my $body;
              $env->{'psgi.input'}->read($body, $env->{CONTENT_LENGTH});
              return [
                  200,
                  [ 'Content-Type' => 'text/plain',
                    'Client-Content-Length' => $env->{CONTENT_LENGTH},
                    'Client-Content-Type' => $env->{CONTENT_TYPE},
                ],
                  [ 'Hello, ' . $body ],
              ];
          },
      ],
      [
          'big POST',
          sub {
              my $cb = shift;
              my $chunk = "abcdefgh" x 12000;
              my $req = HTTP::Request->new(POST => "http://127.0.0.1/");
              $req->content_length(length $chunk);
              $req->content_type('application/octet-stream');
              $req->content($chunk);
  
              my $res = $cb->($req);
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('Client-Content-Length'), length $chunk;
              is length $res->content, length $chunk;
              is Digest::MD5::md5_hex($res->content), Digest::MD5::md5_hex($chunk);
          },
          sub {
              my $env = shift;
              my $len = $env->{CONTENT_LENGTH};
              my $body = '';
              my $spin;
              while ($len > 0) {
                  my $rc = $env->{'psgi.input'}->read($body, $env->{CONTENT_LENGTH}, length $body);
                  $len -= $rc;
                  last if $spin++ > 2000;
              }
              return [
                  200,
                  [ 'Content-Type' => 'text/plain',
                    'Client-Content-Length' => $env->{CONTENT_LENGTH},
                    'Client-Content-Type' => $env->{CONTENT_TYPE},
                ],
                  [ $body ],
              ];
          },
      ],
      [
          'psgi.url_scheme',
          sub {
              my $cb = shift;
              my $res = $cb->(POST "http://127.0.0.1/");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'http';
          },
          sub {
              my $env = $_[0];
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{'psgi.url_scheme'} ],
              ];
          },
      ],
      [
          'return glob',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              like $res->content, qr/^package /;
              like $res->content, qr/END_MARK_FOR_TESTING$/;
          },
          sub {
              my $env = shift;
              open my $fh, '<', __FILE__ or die $!;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  $fh,
              ];
          },
      ],
      [
          'filehandle',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo.jpg");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 4745;
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/face.jpg";
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'bigger file',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/baybridge.jpg");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 79838;
              is Digest::MD5::md5_hex($res->content), '983726ae0e4ce5081bef5fb2b7216950';
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/baybridge.jpg";
              binmode $fh;
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'handle HTTP-Header',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan", Foo => "Bar");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Bar';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{HTTP_FOO}],
              ];
          },
      ],
      [
          'handle HTTP-Cookie',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan", Cookie => "foo");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'foo';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{HTTP_COOKIE}],
              ];
          },
      ],
      [
          'validate env',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, join("\n",
                  'REQUEST_METHOD:GET',
                  "SCRIPT_NAME:$ENV{PLACK_TEST_SCRIPT_NAME}",
                  'PATH_INFO:/foo/',
                  'QUERY_STRING:dankogai=kogaidan',
                  'SERVER_NAME:127.0.0.1',
                  "SERVER_PORT:" . $res->request->uri->port,
              )."\n";
          },
          sub {
              my $env = shift;
              my $body;
              $body .= $_ . ':' . $env->{$_} . "\n" for qw/REQUEST_METHOD SCRIPT_NAME PATH_INFO QUERY_STRING SERVER_NAME SERVER_PORT/;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$body],
              ];
          },
      ],
      [
          '% encoding in PATH_INFO',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%2cbaz");
              is $res->content, "/foo/bar,baz", "PATH_INFO should be decoded per RFC 3875";
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
      [
          '% double encoding in PATH_INFO',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%252cbaz");
              is $res->content, "/foo/bar%2cbaz", "PATH_INFO should be decoded only once, per RFC 3875";
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
      [
          '% encoding in PATH_INFO (outside of URI characters)',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo%E3%81%82");
              is $res->content, "/foo\x{e3}\x{81}\x{82}";
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
      [
          'SERVER_PROTOCOL is required',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              like $res->content, qr{^HTTP/1\.[01]$};
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{SERVER_PROTOCOL}],
              ];
          },
      ],
      [
          'SCRIPT_NAME should not be undef',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->content, 1;
          },
          sub {
              my $env = shift;
              my $cont = defined $env->{'SCRIPT_NAME'};
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$cont],
              ];
          },
      ],
      [
          'call close after read IO::Handle-like',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/call_close");
              is($res->content, '1234');
          },
          sub {
              my $env = shift;
              {
                  our $closed = -1;
                  sub CalledClose::new { $closed = 0; my $i=0; bless \$i, 'CalledClose' }
                  sub CalledClose::getline {
                      my $self = shift;
                      return $$self++ < 4 ? $$self : undef;
                  }
                  sub CalledClose::close { ::ok(1, 'closed') if defined &::ok }
              }
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  CalledClose->new(),
              ];
          },
      ],
      [
          'has errors',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/has_errors");
              is $res->content, 1;
          },
          sub {
              my $env = shift;
              my $err = $env->{'psgi.errors'};
              my $has_errors = defined $err;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$has_errors]
              ];
          },
      ],
      [
          'status line',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is($res->status_line, '200 OK');
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [1]
              ];
          },
      ],
      [
          'Do not crash when the app dies',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 500;
              is $res->message, 'Internal Server Error';
          },
          sub {
              my $env = shift;
              open my $io, '>', \my $error;
              $env->{'psgi.errors'} = $io;
              die "Throwing an exception from app handler. Server shouldn't crash.";
          },
      ],
      [
          'multi headers (request)',
          sub {
              my $cb  = shift;
              my $req = HTTP::Request->new(
                  GET => "http://127.0.0.1/",
              );
              $req->push_header(Foo => "bar");
              $req->push_header(Foo => "baz");
              my $res = $cb->($req);
              like($res->content, qr/^bar,\s*baz$/);
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{HTTP_FOO} ]
              ];
          },
      ],
      [
          'multi headers (response)',
          sub {
              my $cb  = shift;
              my $res = $cb->(HTTP::Request->new(GET => "http://127.0.0.1/"));
              my $foo = $res->header('X-Foo');
              like $foo, qr/foo,\s*bar,\s*baz/;
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', 'X-Foo', 'foo', 'X-Foo', 'bar, baz' ],
                  [ 'hi' ]
              ];
          },
      ],
      [
          'Do not set $env->{COOKIE}',
          sub {
              my $cb  = shift;
              my $req = HTTP::Request->new(
                  GET => "http://127.0.0.1/",
              );
              $req->push_header(Cookie => "foo=bar");
              my $res = $cb->($req);
              is($res->header('X-Cookie'), 0);
              is $res->content, 'foo=bar';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', 'X-Cookie' => $env->{COOKIE} ? 1 : 0 ],
                  [ $env->{HTTP_COOKIE} ]
              ];
          },
      ],
      [
          'no entity headers on 304',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 304;
              is $res->message, 'Not Modified';
              is $res->content, '';
              ok ! defined $res->header('content_type'), "No Content-Type";
              ok ! defined $res->header('content_length'), "No Content-Length";
              ok ! defined $res->header('transfer_encoding'), "No Transfer-Encoding";
          },
          sub {
              my $env = shift;
              return [ 304, [], [] ];
          },
      ],
      [
          'REQUEST_URI is set',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%20baz%73?x=a");
              is $res->content, $ENV{PLACK_TEST_SCRIPT_NAME} . "/foo/bar%20baz%73?x=a";
          },
          sub {
              my $env = shift;
              return [ 200, [ 'Content-Type' => 'text/plain' ], [ $env->{REQUEST_URI} ] ];
          },
      ],
      [
          'filehandle with path()',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo.jpg");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 4745;
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/face.jpg";
              Plack::Util::set_io_path($fh, "$share_dir/face.jpg");
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'a big header value > 128 bytes',
          sub {
              my $cb  = shift;
              my $req = GET "http://127.0.0.1/";
              my $v = ("abcdefgh" x 16);
              $req->header('X-Foo' => $v);
              my $res = $cb->($req);
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->content, $v;
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain' ],
                  [ $env->{HTTP_X_FOO} ],
              ];
          },
      ],
      [
          'coderef res',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              return if $res->code == 501;
  
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              $env->{'psgi.streaming'} or return [ 501, ['Content-Type','text/plain'], [] ];
              return sub {
                  my $respond = shift;
                  $respond->([
                      200,
                      [ 'Content-Type' => 'text/plain', ],
                      [ 'Hello, ' . $env->{QUERY_STRING} ],
                  ]);
              }
          },
      ],
      [
          'coderef streaming',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              return if $res->code == 501;
  
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              $env->{'psgi.streaming'} or return [ 501, ['Content-Type','text/plain'], [] ];
  
              return sub {
                  my $respond = shift;
  
                  my $writer = $respond->([
                      200,
                      [ 'Content-Type' => 'text/plain', ],
                  ]);
  
                  $writer->write("Hello, ");
                  $writer->write($env->{QUERY_STRING});
                  $writer->close();
              }
          },
      ],
      [
          'CRLF output and FCGI parse bug',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
  
              is $res->header("Foo"), undef;
              is $res->content, "Foo: Bar\r\n\r\nHello World";
          },
          sub {
              return [ 200, [ "Content-Type", "text/plain" ], [ "Foo: Bar\r\n\r\nHello World" ] ];
          },
      ],
      [
          'newlines',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is length($res->content), 7;
          },
          sub {
              return [ 200, [ "Content-Type", "text/plain" ], [ "Bar\nBaz" ] ];
          },
      ],
      [
          'test 404',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 404;
              is $res->message, 'Not Found';
              is $res->content, 'Not Found';
          },
          sub {
              return [ 404, [ "Content-Type", "text/plain" ], [ "Not Found" ] ];
          },
      ],
      [
          'request->input seekable',
          sub {
              my $cb = shift;
              my $req = HTTP::Request->new(POST => "http://127.0.0.1/");
              $req->content("body");
              $req->content_type('text/plain');
              $req->content_length(4);
              my $res = $cb->($req);
              is $res->content, 'body';
          },
          sub {
              my $req = Plack::Request->new(shift);
              return [ 200, [ "Content-Type", "text/plain" ], [ $req->content ] ];
          },
      ],
      [
          'request->content on GET',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              ok $res->is_success;
          },
          sub {
              my $req = Plack::Request->new(shift);
              $req->content;
              return [ 200, [ "Content-Type", "text/plain" ], [ "OK" ] ];
          },
      ],
      [
          'handle Authorization header',
          sub {
              my $cb  = shift;
              SKIP: {
                  skip "Authorization header is unsupported under CGI", 4 if ($ENV{PLACK_TEST_HANDLER} || "") eq "CGI";
  
                  {
                      my $req = HTTP::Request->new(
                          GET => "http://127.0.0.1/",
                      );
                      $req->push_header(Authorization => 'Basic XXXX');
                      my $res = $cb->($req);
                      is $res->header('X-AUTHORIZATION'), 1;
                      is $res->content, 'Basic XXXX';
                  };
  
                  {
                      my $req = HTTP::Request->new(
                          GET => "http://127.0.0.1/",
                      );
                      my $res = $cb->($req);
                      is $res->header('X-AUTHORIZATION'), 0;
                      is $res->content, 'no_auth';
                  };
              };
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', 'X-AUTHORIZATION' => exists($env->{HTTP_AUTHORIZATION}) ? 1 : 0 ],
                  [ $env->{HTTP_AUTHORIZATION} || 'no_auth' ],
              ];
          },
      ],
      [
          'repeated slashes',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1//foo///bar/baz");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, '//foo///bar/baz';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
  );
  
  sub runtests {
      my($class, $runner) = @_;
      for my $test (@TEST) {
          $runner->(@$test);
      }
  }
  
  sub run_server_tests {
      my($class, $server, $server_port, $http_port, %args) = @_;
  
      if (ref $server ne 'CODE') {
          my $server_class = $server;
          $server = sub {
              my($port, $app) = @_;
              my $server = Plack::Loader->load($server_class, port => $port, host => "127.0.0.1", %args);
              $app = Plack::Middleware::Lint->wrap($app);
              $server->run($app);
          }
      }
  
      test_tcp(
          client => sub {
              my $port = shift;
              my $ua = Plack::LWPish->new( no_proxy => [qw/127.0.0.1/] );
              for my $i (0..$#TEST) {
                  my $test = $TEST[$i];
                  note $test->[0];
                  my $cb = sub {
                      my $req = shift;
                      $req->uri->port($http_port || $port);
                      $req->uri->path(($ENV{PLACK_TEST_SCRIPT_NAME}||"") . $req->uri->path);
                      $req->header('X-Plack-Test' => $i);
                      return $ua->request($req);
                  };
  
                  $test->[1]->($cb);
              }
          },
          server => sub {
              my $port = shift;
              my $app  = $class->test_app_handler;
              $server->($port, $app);
              exit(0); # for Test::TCP
          },
          port => $server_port,
      );
  }
  
  sub test_app_handler {
      return sub {
          my $env = shift;
          $TEST[$env->{HTTP_X_PLACK_TEST}][2]->($env);
      };
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Test::Suite - Test suite for Plack handlers
  
  =head1 SYNOPSIS
  
    use Test::More;
    use Plack::Test::Suite;
    Plack::Test::Suite->run_server_tests('Your::Handler');
    done_testing;
  
  =head1 DESCRIPTION
  
  Plack::Test::Suite is a test suite to test a new PSGI server
  implementation. It automatically loads a new handler environment and
  uses LWP to send HTTP requests to the local server to make sure your
  handler implements the PSGI specification correctly.
  
  Note that the handler name doesn't include the C<Plack::Handler::>
  prefix, i.e. if you have a new Plack handler Plack::Handler::Foo, your
  test script would look like:
  
    Plack::Test::Suite->run_server_tests('Foo');
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  Kazuho Oku
  
  =cut
  
  END_MARK_FOR_TESTING
PLACK_TEST_SUITE

$fatpacked{"Plack/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_UTIL';
  package Plack::Util;
  use strict;
  use Carp ();
  use Scalar::Util;
  use IO::Handle;
  use overload ();
  use File::Spec ();
  
  sub TRUE()  { 1==1 }
  sub FALSE() { !TRUE }
  
  sub load_class {
      my($class, $prefix) = @_;
  
      if ($prefix) {
          unless ($class =~ s/^\+// || $class =~ /^$prefix/) {
              $class = "$prefix\::$class";
          }
      }
  
      my $file = $class;
      $file =~ s!::!/!g;
      require "$file.pm"; ## no critic
  
      return $class;
  }
  
  sub is_real_fh ($) {
      my $fh = shift;
  
      {
          no warnings 'uninitialized';
          return FALSE if -p $fh or -c _ or -b _;
      }
  
      my $reftype = Scalar::Util::reftype($fh) or return;
      if (   $reftype eq 'IO'
          or $reftype eq 'GLOB' && *{$fh}{IO}
      ) {
          # if it's a blessed glob make sure to not break encapsulation with
          # fileno($fh) (e.g. if you are filtering output then file descriptor
          # based operations might no longer be valid).
          # then ensure that the fileno *opcode* agrees too, that there is a
          # valid IO object inside $fh either directly or indirectly and that it
          # corresponds to a real file descriptor.
          my $m_fileno = $fh->fileno;
          return FALSE unless defined $m_fileno;
          return FALSE unless $m_fileno >= 0;
  
          my $f_fileno = fileno($fh);
          return FALSE unless defined $f_fileno;
          return FALSE unless $f_fileno >= 0;
          return TRUE;
      } else {
          # anything else, including GLOBS without IO (even if they are blessed)
          # and non GLOB objects that look like filehandle objects cannot have a
          # valid file descriptor in fileno($fh) context so may break.
          return FALSE;
      }
  }
  
  sub set_io_path {
      my($fh, $path) = @_;
      bless $fh, 'Plack::Util::IOWithPath';
      $fh->path($path);
  }
  
  sub content_length {
      my $body = shift;
  
      return unless defined $body;
  
      if (ref $body eq 'ARRAY') {
          my $cl = 0;
          for my $chunk (@$body) {
              $cl += length $chunk;
          }
          return $cl;
      } elsif ( is_real_fh($body) ) {
          return (-s $body) - tell($body);
      }
  
      return;
  }
  
  sub foreach {
      my($body, $cb) = @_;
  
      if (ref $body eq 'ARRAY') {
          for my $line (@$body) {
              $cb->($line) if length $line;
          }
      } else {
          local $/ = \65536 unless ref $/;
          while (defined(my $line = $body->getline)) {
              $cb->($line) if length $line;
          }
          $body->close;
      }
  }
  
  sub class_to_file {
      my $class = shift;
      $class =~ s!::!/!g;
      $class . ".pm";
  }
  
  sub _load_sandbox {
      my $_file = shift;
  
      my $_package = $_file;
      $_package =~ s/([^A-Za-z0-9_])/sprintf("_%2x", unpack("C", $1))/eg;
  
      local $0 = $_file; # so FindBin etc. works
      local @ARGV = ();  # Some frameworks might try to parse @ARGV
  
      return eval sprintf <<'END_EVAL', $_package;
  package Plack::Sandbox::%s;
  {
      my $app = do $_file;
      if ( !$app && ( my $error = $@ || $! )) { die $error; }
      $app;
  }
  END_EVAL
  }
  
  sub load_psgi {
      my $stuff = shift;
  
      local $ENV{PLACK_ENV} = $ENV{PLACK_ENV} || 'development';
  
      my $file = $stuff =~ /^[a-zA-Z0-9\_\:]+$/ ? class_to_file($stuff) : File::Spec->rel2abs($stuff);
      my $app = _load_sandbox($file);
      die "Error while loading $file: $@" if $@;
  
      return $app;
  }
  
  sub run_app($$) {
      my($app, $env) = @_;
  
      return eval { $app->($env) } || do {
          my $body = "Internal Server Error";
          $env->{'psgi.errors'}->print($@);
          [ 500, [ 'Content-Type' => 'text/plain', 'Content-Length' => length($body) ], [ $body ] ];
      };
  }
  
  sub headers {
      my $headers = shift;
      inline_object(
          iter   => sub { header_iter($headers, @_) },
          get    => sub { header_get($headers, @_) },
          set    => sub { header_set($headers, @_) },
          push   => sub { header_push($headers, @_) },
          exists => sub { header_exists($headers, @_) },
          remove => sub { header_remove($headers, @_) },
          headers => sub { $headers },
      );
  }
  
  sub header_iter {
      my($headers, $code) = @_;
  
      my @headers = @$headers; # copy
      while (my($key, $val) = splice @headers, 0, 2) {
          $code->($key, $val);
      }
  }
  
  sub header_get {
      my($headers, $key) = (shift, lc shift);
  
      my @val;
      header_iter $headers, sub {
          push @val, $_[1] if lc $_[0] eq $key;
      };
  
      return wantarray ? @val : $val[0];
  }
  
  sub header_set {
      my($headers, $key, $val) = @_;
  
      my($set, @new_headers);
      header_iter $headers, sub {
          if (lc $key eq lc $_[0]) {
              return if $set;
              $_[1] = $val;
              $set++;
          }
          push @new_headers, $_[0], $_[1];
      };
  
      push @new_headers, $key, $val unless $set;
      @$headers = @new_headers;
  }
  
  sub header_push {
      my($headers, $key, $val) = @_;
      push @$headers, $key, $val;
  }
  
  sub header_exists {
      my($headers, $key) = (shift, lc shift);
  
      my $exists;
      header_iter $headers, sub {
          $exists = 1 if lc $_[0] eq $key;
      };
  
      return $exists;
  }
  
  sub header_remove {
      my($headers, $key) = (shift, lc shift);
  
      my @new_headers;
      header_iter $headers, sub {
          push @new_headers, $_[0], $_[1]
              unless lc $_[0] eq $key;
      };
  
      @$headers = @new_headers;
  }
  
  sub status_with_no_entity_body {
      my $status = shift;
      return $status < 200 || $status == 204 || $status == 304;
  }
  
  sub encode_html {
      my $str = shift;
      $str =~ s/&/&amp;/g;
      $str =~ s/>/&gt;/g;
      $str =~ s/</&lt;/g;
      $str =~ s/"/&quot;/g;
      $str =~ s/'/&#39;/g;
      return $str;
  }
  
  sub inline_object {
      my %args = @_;
      bless \%args, 'Plack::Util::Prototype';
  }
  
  sub response_cb {
      my($res, $cb) = @_;
  
      my $body_filter = sub {
          my($cb, $res) = @_;
          my $filter_cb = $cb->($res);
          # If response_cb returns a callback, treat it as a $body filter
          if (defined $filter_cb && ref $filter_cb eq 'CODE') {
              Plack::Util::header_remove($res->[1], 'Content-Length');
              if (defined $res->[2]) {
                  if (ref $res->[2] eq 'ARRAY') {
                      for my $line (@{$res->[2]}) {
                          $line = $filter_cb->($line);
                      }
                      # Send EOF.
                      my $eof = $filter_cb->( undef );
                      push @{ $res->[2] }, $eof if defined $eof;
                  } else {
                      my $body    = $res->[2];
                      my $getline = sub { $body->getline };
                      $res->[2] = Plack::Util::inline_object
                          getline => sub { $filter_cb->($getline->()) },
                          close => sub { $body->close };
                  }
              } else {
                  return $filter_cb;
              }
          }
      };
  
      if (ref $res eq 'ARRAY') {
          $body_filter->($cb, $res);
          return $res;
      } elsif (ref $res eq 'CODE') {
          return sub {
              my $respond = shift;
              my $cb = $cb;  # To avoid the nested closure leak for 5.8.x
              $res->(sub {
                  my $res = shift;
                  my $filter_cb = $body_filter->($cb, $res);
                  if ($filter_cb) {
                      my $writer = $respond->($res);
                      if ($writer) {
                          return Plack::Util::inline_object
                              write => sub { $writer->write($filter_cb->(@_)) },
                              close => sub {
                                  my $chunk = $filter_cb->(undef);
                                  $writer->write($chunk) if defined $chunk;
                                  $writer->close;
                              };
                      }
                  } else {
                      return $respond->($res);
                  }
              });
          };
      }
  
      return $res;
  }
  
  package Plack::Util::Prototype;
  
  our $AUTOLOAD;
  sub can {
      $_[0]->{$_[1]};
  }
  
  sub AUTOLOAD {
      my $self = shift;
      my $attr = $AUTOLOAD;
      $attr =~ s/.*://;
      if (ref($self->{$attr}) eq 'CODE') {
          $self->{$attr}->(@_);
      } else {
          Carp::croak(qq/Can't locate object method "$attr" via package "Plack::Util::Prototype"/);
      }
  }
  
  sub DESTROY { }
  
  package Plack::Util::IOWithPath;
  use parent qw(IO::Handle);
  
  sub path {
      my $self = shift;
      if (@_) {
          ${*$self}{+__PACKAGE__} = shift;
      }
      ${*$self}{+__PACKAGE__};
  }
  
  package Plack::Util;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Util - Utility subroutines for Plack server and framework developers
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item TRUE, FALSE
  
    my $true  = Plack::Util::TRUE;
    my $false = Plack::Util::FALSE;
  
  Utility constants to include when you specify boolean variables in C<$env> hash (e.g. C<psgi.multithread>).
  
  =item load_class
  
    my $class = Plack::Util::load_class($class [, $prefix ]);
  
  Constructs a class name and C<require> the class. Throws an exception
  if the .pm file for the class is not found, just with the built-in
  C<require>.
  
  If C<$prefix> is set, the class name is prepended to the C<$class>
  unless C<$class> begins with C<+> sign, which means the class name is
  already fully qualified.
  
    my $class = Plack::Util::load_class("Foo");                   # Foo
    my $class = Plack::Util::load_class("Baz", "Foo::Bar");       # Foo::Bar::Baz
    my $class = Plack::Util::load_class("+XYZ::ZZZ", "Foo::Bar"); # XYZ::ZZZ
  
  Note that this function doesn't validate (or "sanitize") the passed
  string, hence if you pass a user input to this function (which is an
  insecure thing to do in the first place) it might lead to unexpected
  behavior of loading files outside your C<@INC> path. If you want a
  generic module loading function, you should check out CPAN modules
  such as L<Module::Runtime>.
  
  =item is_real_fh
  
    if ( Plack::Util::is_real_fh($fh) ) { }
  
  returns true if a given C<$fh> is a real file handle that has a file
  descriptor. It returns false if C<$fh> is PerlIO handle that is not
  really related to the underlying file etc.
  
  =item content_length
  
    my $cl = Plack::Util::content_length($body);
  
  Returns the length of content from body if it can be calculated. If
  C<$body> is an array ref it's a sum of length of each chunk, if
  C<$body> is a real filehandle it's a remaining size of the filehandle,
  otherwise returns undef.
  
  =item set_io_path
  
    Plack::Util::set_io_path($fh, "/path/to/foobar.txt");
  
  Sets the (absolute) file path to C<$fh> filehandle object, so you can
  call C<< $fh->path >> on it. As a side effect C<$fh> is blessed to an
  internal package but it can still be treated as a normal file
  handle.
  
  This module doesn't normalize or absolutize the given path, and is
  intended to be used from Server or Middleware implementations. See
  also L<IO::File::WithPath>.
  
  =item foreach
  
    Plack::Util::foreach($body, $cb);
  
  Iterate through I<$body> which is an array reference or
  IO::Handle-like object and pass each line (which is NOT really
  guaranteed to be a I<line>) to the callback function.
  
  It internally sets the buffer length C<$/> to 65536 in case it reads
  the binary file, unless otherwise set in the caller's code.
  
  =item load_psgi
  
    my $app = Plack::Util::load_psgi $psgi_file_or_class;
  
  Load C<app.psgi> file or a class name (like C<MyApp::PSGI>) and
  require the file to get PSGI application handler. If the file can't be
  loaded (e.g. file doesn't exist or has a perl syntax error), it will
  throw an exception.
  
  Since version 1.0006, this function would not load PSGI files from
  include paths (C<@INC>) unless it looks like a class name that only
  consists of C<[A-Za-z0-9_:]>. For example:
  
    Plack::Util::load_psgi("app.psgi");          # ./app.psgi
    Plack::Util::load_psgi("/path/to/app.psgi"); # /path/to/app.psgi
    Plack::Util::load_psgi("MyApp::PSGI");       # MyApp/PSGI.pm from @INC
  
  B<Security>: If you give this function a class name or module name
  that is loadable from your system, it will load the module. This could
  lead to a security hole:
  
    my $psgi = ...; # user-input: consider "Moose"
    $app = Plack::Util::load_psgi($psgi); # this would lead to 'require "Moose.pm"'!
  
  Generally speaking, passing an external input to this function is
  considered very insecure. If you really want to do that, validate that
  a given file name contains dots (like C<foo.psgi>) and also turn it
  into a full path in your caller's code.
  
  =item run_app
  
    my $res = Plack::Util::run_app $app, $env;
  
  Runs the I<$app> by wrapping errors with I<eval> and if an error is
  found, logs it to C<< $env->{'psgi.errors'} >> and returns the
  template 500 Error response.
  
  =item header_get, header_exists, header_set, header_push, header_remove
  
    my $hdrs = [ 'Content-Type' => 'text/plain' ];
  
    my $v = Plack::Util::header_get($hdrs, $key); # First found only
    my @v = Plack::Util::header_get($hdrs, $key);
    my $bool = Plack::Util::header_exists($hdrs, $key);
    Plack::Util::header_set($hdrs, $key, $val);   # overwrites existent header
    Plack::Util::header_push($hdrs, $key, $val);
    Plack::Util::header_remove($hdrs, $key);
  
  Utility functions to manipulate PSGI response headers array
  reference. The methods that read existent header value handles header
  name as case insensitive.
  
    my $hdrs = [ 'Content-Type' => 'text/plain' ];
    my $v = Plack::Util::header_get($hdrs, 'content-type'); # 'text/plain'
  
  =item headers
  
    my $headers = [ 'Content-Type' => 'text/plain' ];
  
    my $h = Plack::Util::headers($headers);
    $h->get($key);
    if ($h->exists($key)) { ... }
    $h->set($key => $val);
    $h->push($key => $val);
    $h->remove($key);
    $h->headers; # same reference as $headers
  
  Given a header array reference, returns a convenient object that has
  an instance methods to access C<header_*> functions with an OO
  interface. The object holds a reference to the original given
  C<$headers> argument and updates the reference accordingly when called
  write methods like C<set>, C<push> or C<remove>. It also has C<headers>
  method that would return the same reference.
  
  =item status_with_no_entity_body
  
    if (status_with_no_entity_body($res->[0])) { }
  
  Returns true if the given status code doesn't have any Entity body in
  HTTP response, i.e. it's 100, 101, 204 or 304.
  
  =item inline_object
  
    my $o = Plack::Util::inline_object(
        write => sub { $h->push_write(@_) },
        close => sub { $h->push_shutdown },
    );
    $o->write(@stuff);
    $o->close;
  
  Creates an instant object that can react to methods passed in the
  constructor. Handy to create when you need to create an IO stream
  object for input or errors.
  
  =item encode_html
  
    my $encoded_string = Plack::Util::encode( $string );
  
  Entity encodes C<<>, C<< > >>, C<&>, C<"> and C<'> in the input string
  and returns it.
  
  =item response_cb
  
  See L<Plack::Middleware/RESPONSE CALLBACK> for details.
  
  =back
  
  =cut
  
  
  
PLACK_UTIL

$fatpacked{"Plack/Util/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_UTIL_ACCESSOR';
  package Plack::Util::Accessor;
  use strict;
  use warnings;
  
  sub import {
      shift;
      return unless @_;
      my $package = caller();
      mk_accessors( $package, @_ );
  }
  
  sub mk_accessors {
      my $package = shift;
      no strict 'refs';
      foreach my $field ( @_ ) {
          *{ $package . '::' . $field } = sub {
              return $_[0]->{ $field } if scalar( @_ ) == 1;
              return $_[0]->{ $field }  = scalar( @_ ) == 2 ? $_[1] : [ @_[1..$#_] ];
          };
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Util::Accessor - Accessor generation utility for Plack
  
  =head1 DESCRIPTION
  
  This module is just a simple accessor generator for Plack to replace
  the Class::Accessor::Fast usage and so our classes don't have to inherit
  from their accessor generator.
  
  =head1 SEE ALSO
  
  L<PSGI> L<http://plackperl.org/>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK_UTIL_ACCESSOR

$fatpacked{"URI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI';
  package URI;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  our ($ABS_REMOTE_LEADING_DOTS, $ABS_ALLOW_RELATIVE_SCHEME, $DEFAULT_QUERY_FORM_DELIMITER);
  
  my %implements;  # mapping from scheme to implementor class
  
  # Some "official" character classes
  
  our $reserved   = q(;/?:@&=+$,[]);
  our $mark       = q(-_.!~*'());                                    #'; emacs
  our $unreserved = "A-Za-z0-9\Q$mark\E";
  our $uric       = quotemeta($reserved) . $unreserved . "%";
  
  our $scheme_re  = '[a-zA-Z][a-zA-Z0-9.+\-]*';
  
  use Carp ();
  use URI::Escape ();
  
  use overload ('""'     => sub { ${$_[0]} },
                '=='     => sub { _obj_eq(@_) },
                '!='     => sub { !_obj_eq(@_) },
                fallback => 1,
               );
  
  # Check if two objects are the same object
  sub _obj_eq {
      return overload::StrVal($_[0]) eq overload::StrVal($_[1]);
  }
  
  sub new
  {
      my($class, $uri, $scheme) = @_;
  
      $uri = defined ($uri) ? "$uri" : "";   # stringify
      # Get rid of potential wrapping
      $uri =~ s/^<(?:URL:)?(.*)>$/$1/;  # 
      $uri =~ s/^"(.*)"$/$1/;
      $uri =~ s/^\s+//;
      $uri =~ s/\s+$//;
  
      my $impclass;
      if ($uri =~ m/^($scheme_re):/so) {
  	$scheme = $1;
      }
      else {
  	if (($impclass = ref($scheme))) {
  	    $scheme = $scheme->scheme;
  	}
  	elsif ($scheme && $scheme =~ m/^($scheme_re)(?::|$)/o) {
  	    $scheme = $1;
          }
      }
      $impclass ||= implementor($scheme) ||
  	do {
  	    require URI::_foreign;
  	    $impclass = 'URI::_foreign';
  	};
  
      return $impclass->_init($uri, $scheme);
  }
  
  
  sub new_abs
  {
      my($class, $uri, $base) = @_;
      $uri = $class->new($uri, $base);
      $uri->abs($base);
  }
  
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      # find all funny characters and encode the bytes.
      $str = $class->_uric_escape($str);
      $str = "$scheme:$str" unless $str =~ /^$scheme_re:/o ||
                                   $class->_no_scheme_ok;
      my $self = bless \$str, $class;
      $self;
  }
  
  
  sub _uric_escape
  {
      my($class, $str) = @_;
      $str =~ s*([^$uric\#])* URI::Escape::escape_char($1) *ego;
      utf8::downgrade($str);
      return $str;
  }
  
  my %require_attempted;
  
  sub implementor
  {
      my($scheme, $impclass) = @_;
      if (!$scheme || $scheme !~ /\A$scheme_re\z/o) {
  	require URI::_generic;
  	return "URI::_generic";
      }
  
      $scheme = lc($scheme);
  
      if ($impclass) {
  	# Set the implementor class for a given scheme
          my $old = $implements{$scheme};
          $impclass->_init_implementor($scheme);
          $implements{$scheme} = $impclass;
          return $old;
      }
  
      my $ic = $implements{$scheme};
      return $ic if $ic;
  
      # scheme not yet known, look for internal or
      # preloaded (with 'use') implementation
      $ic = "URI::$scheme";  # default location
  
      # turn scheme into a valid perl identifier by a simple transformation...
      $ic =~ s/\+/_P/g;
      $ic =~ s/\./_O/g;
      $ic =~ s/\-/_/g;
  
      no strict 'refs';
      # check we actually have one for the scheme:
      unless (@{"${ic}::ISA"}) {
          if (not exists $require_attempted{$ic}) {
              # Try to load it
              my $_old_error = $@;
              eval "require $ic";
              die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
              $@ = $_old_error;
          }
          return undef unless @{"${ic}::ISA"};
      }
  
      $ic->_init_implementor($scheme);
      $implements{$scheme} = $ic;
      $ic;
  }
  
  
  sub _init_implementor
  {
      my($class, $scheme) = @_;
      # Remember that one implementor class may actually
      # serve to implement several URI schemes.
  }
  
  
  sub clone
  {
      my $self = shift;
      my $other = $$self;
      bless \$other, ref $self;
  }
  
  sub TO_JSON { ${$_[0]} }
  
  sub _no_scheme_ok { 0 }
  
  sub _scheme
  {
      my $self = shift;
  
      unless (@_) {
  	return undef unless $$self =~ /^($scheme_re):/o;
  	return $1;
      }
  
      my $old;
      my $new = shift;
      if (defined($new) && length($new)) {
  	Carp::croak("Bad scheme '$new'") unless $new =~ /^$scheme_re$/o;
  	$old = $1 if $$self =~ s/^($scheme_re)://o;
  	my $newself = URI->new("$new:$$self");
  	$$self = $$newself; 
  	bless $self, ref($newself);
      }
      else {
  	if ($self->_no_scheme_ok) {
  	    $old = $1 if $$self =~ s/^($scheme_re)://o;
  	    Carp::carp("Oops, opaque part now look like scheme")
  		if $^W && $$self =~ m/^$scheme_re:/o
  	}
  	else {
  	    $old = $1 if $$self =~ m/^($scheme_re):/o;
  	}
      }
  
      return $old;
  }
  
  sub scheme
  {
      my $scheme = shift->_scheme(@_);
      return undef unless defined $scheme;
      lc($scheme);
  }
  
  sub has_recognized_scheme {
      my $self = shift;
      return ref($self) !~ /^URI::_(?:foreign|generic)\z/;
  }
  
  sub opaque
  {
      my $self = shift;
  
      unless (@_) {
  	$$self =~ /^(?:$scheme_re:)?([^\#]*)/o or die;
  	return $1;
      }
  
      $$self =~ /^($scheme_re:)?    # optional scheme
  	        ([^\#]*)          # opaque
                  (\#.*)?           # optional fragment
                $/sx or die;
  
      my $old_scheme = $1;
      my $old_opaque = $2;
      my $old_frag   = $3;
  
      my $new_opaque = shift;
      $new_opaque = "" unless defined $new_opaque;
      $new_opaque =~ s/([^$uric])/ URI::Escape::escape_char($1)/ego;
      utf8::downgrade($new_opaque);
  
      $$self = defined($old_scheme) ? $old_scheme : "";
      $$self .= $new_opaque;
      $$self .= $old_frag if defined $old_frag;
  
      $old_opaque;
  }
  
  sub path { goto &opaque }  # alias
  
  
  sub fragment
  {
      my $self = shift;
      unless (@_) {
  	return undef unless $$self =~ /\#(.*)/s;
  	return $1;
      }
  
      my $old;
      $old = $1 if $$self =~ s/\#(.*)//s;
  
      my $new_frag = shift;
      if (defined $new_frag) {
  	$new_frag =~ s/([^$uric])/ URI::Escape::escape_char($1) /ego;
  	utf8::downgrade($new_frag);
  	$$self .= "#$new_frag";
      }
      $old;
  }
  
  
  sub as_string
  {
      my $self = shift;
      $$self;
  }
  
  
  sub as_iri
  {
      my $self = shift;
      my $str = $$self;
      if ($str =~ s/%([89a-fA-F][0-9a-fA-F])/chr(hex($1))/eg) {
  	# All this crap because the more obvious:
  	#
  	#   Encode::decode("UTF-8", $str, sub { sprintf "%%%02X", shift })
  	#
  	# doesn't work before Encode 2.39.  Wait for a standard release
  	# to bundle that version.
  
  	require Encode;
  	my $enc = Encode::find_encoding("UTF-8");
  	my $u = "";
  	while (length $str) {
  	    $u .= $enc->decode($str, Encode::FB_QUIET());
  	    if (length $str) {
  		# escape next char
  		$u .= URI::Escape::escape_char(substr($str, 0, 1, ""));
  	    }
  	}
  	$str = $u;
      }
      return $str;
  }
  
  
  sub canonical
  {
      # Make sure scheme is lowercased, that we don't escape unreserved chars,
      # and that we use upcase escape sequences.
  
      my $self = shift;
      my $scheme = $self->_scheme || "";
      my $uc_scheme = $scheme =~ /[A-Z]/;
      my $esc = $$self =~ /%[a-fA-F0-9]{2}/;
      return $self unless $uc_scheme || $esc;
  
      my $other = $self->clone;
      if ($uc_scheme) {
  	$other->_scheme(lc $scheme);
      }
      if ($esc) {
  	$$other =~ s{%([0-9a-fA-F]{2})}
  	            { my $a = chr(hex($1));
                        $a =~ /^[$unreserved]\z/o ? $a : "%\U$1"
                      }ge;
      }
      return $other;
  }
  
  # Compare two URIs, subclasses will provide a more correct implementation
  sub eq {
      my($self, $other) = @_;
      $self  = URI->new($self, $other) unless ref $self;
      $other = URI->new($other, $self) unless ref $other;
      ref($self) eq ref($other) &&                # same class
  	$self->canonical->as_string eq $other->canonical->as_string;
  }
  
  # generic-URI transformation methods
  sub abs { $_[0]; }
  sub rel { $_[0]; }
  
  sub secure { 0 }
  
  # help out Storable
  sub STORABLE_freeze {
         my($self, $cloning) = @_;
         return $$self;
  }
  
  sub STORABLE_thaw {
         my($self, $cloning, $str) = @_;
         $$self = $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI - Uniform Resource Identifiers (absolute and relative)
  
  =head1 SYNOPSIS
  
   use URI;
  
   $u1 = URI->new("http://www.perl.com");
   $u2 = URI->new("foo", "http");
   $u3 = $u2->abs($u1);
   $u4 = $u3->clone;
   $u5 = URI->new("HTTP://WWW.perl.com:80")->canonical;
  
   $str = $u->as_string;
   $str = "$u";
  
   $scheme = $u->scheme;
   $opaque = $u->opaque;
   $path   = $u->path;
   $frag   = $u->fragment;
  
   $u->scheme("ftp");
   $u->host("ftp.perl.com");
   $u->path("cpan/");
  
  =head1 DESCRIPTION
  
  This module implements the C<URI> class.  Objects of this class
  represent "Uniform Resource Identifier references" as specified in RFC
  2396 (and updated by RFC 2732).
  
  A Uniform Resource Identifier is a compact string of characters that
  identifies an abstract or physical resource.  A Uniform Resource
  Identifier can be further classified as either a Uniform Resource Locator
  (URL) or a Uniform Resource Name (URN).  The distinction between URL
  and URN does not matter to the C<URI> class interface. A
  "URI-reference" is a URI that may have additional information attached
  in the form of a fragment identifier.
  
  An absolute URI reference consists of three parts:  a I<scheme>, a
  I<scheme-specific part> and a I<fragment> identifier.  A subset of URI
  references share a common syntax for hierarchical namespaces.  For
  these, the scheme-specific part is further broken down into
  I<authority>, I<path> and I<query> components.  These URIs can also
  take the form of relative URI references, where the scheme (and
  usually also the authority) component is missing, but implied by the
  context of the URI reference.  The three forms of URI reference
  syntax are summarized as follows:
  
    <scheme>:<scheme-specific-part>#<fragment>
    <scheme>://<authority><path>?<query>#<fragment>
    <path>?<query>#<fragment>
  
  The components into which a URI reference can be divided depend on the
  I<scheme>.  The C<URI> class provides methods to get and set the
  individual components.  The methods available for a specific
  C<URI> object depend on the scheme.
  
  =head1 CONSTRUCTORS
  
  The following methods construct new C<URI> objects:
  
  =over 4
  
  =item $uri = URI->new( $str )
  
  =item $uri = URI->new( $str, $scheme )
  
  Constructs a new URI object.  The string
  representation of a URI is given as argument, together with an optional
  scheme specification.  Common URI wrappers like "" and <>, as well as
  leading and trailing white space, are automatically removed from
  the $str argument before it is processed further.
  
  The constructor determines the scheme, maps this to an appropriate
  URI subclass, constructs a new object of that class and returns it.
  
  If the scheme isn't one of those that URI recognizes, you still get
  an URI object back that you can access the generic methods on.  The
  C<< $uri->has_recognized_scheme >> method can be used to test for
  this.
  
  The $scheme argument is only used when $str is a
  relative URI.  It can be either a simple string that
  denotes the scheme, a string containing an absolute URI reference, or
  an absolute C<URI> object.  If no $scheme is specified for a relative
  URI $str, then $str is simply treated as a generic URI (no scheme-specific
  methods available).
  
  The set of characters available for building URI references is
  restricted (see L<URI::Escape>).  Characters outside this set are
  automatically escaped by the URI constructor.
  
  =item $uri = URI->new_abs( $str, $base_uri )
  
  Constructs a new absolute URI object.  The $str argument can
  denote a relative or absolute URI.  If relative, then it is
  absolutized using $base_uri as base. The $base_uri must be an absolute
  URI.
  
  =item $uri = URI::file->new( $filename )
  
  =item $uri = URI::file->new( $filename, $os )
  
  Constructs a new I<file> URI from a file name.  See L<URI::file>.
  
  =item $uri = URI::file->new_abs( $filename )
  
  =item $uri = URI::file->new_abs( $filename, $os )
  
  Constructs a new absolute I<file> URI from a file name.  See
  L<URI::file>.
  
  =item $uri = URI::file->cwd
  
  Returns the current working directory as a I<file> URI.  See
  L<URI::file>.
  
  =item $uri->clone
  
  Returns a copy of the $uri.
  
  =back
  
  =head1 COMMON METHODS
  
  The methods described in this section are available for all C<URI>
  objects.
  
  Methods that give access to components of a URI always return the
  old value of the component.  The value returned is C<undef> if the
  component was not present.  There is generally a difference between a
  component that is empty (represented as C<"">) and a component that is
  missing (represented as C<undef>).  If an accessor method is given an
  argument, it updates the corresponding component in addition to
  returning the old value of the component.  Passing an undefined
  argument removes the component (if possible).  The description of
  each accessor method indicates whether the component is passed as
  an escaped (percent-encoded) or an unescaped string.  A component that can be further
  divided into sub-parts are usually passed escaped, as unescaping might
  change its semantics.
  
  The common methods available for all URI are:
  
  =over 4
  
  =item $uri->scheme
  
  =item $uri->scheme( $new_scheme )
  
  Sets and returns the scheme part of the $uri.  If the $uri is
  relative, then $uri->scheme returns C<undef>.  If called with an
  argument, it updates the scheme of $uri, possibly changing the
  class of $uri, and returns the old scheme value.  The method croaks
  if the new scheme name is illegal; a scheme name must begin with a
  letter and must consist of only US-ASCII letters, numbers, and a few
  special marks: ".", "+", "-".  This restriction effectively means
  that the scheme must be passed unescaped.  Passing an undefined
  argument to the scheme method makes the URI relative (if possible).
  
  Letter case does not matter for scheme names.  The string
  returned by $uri->scheme is always lowercase.  If you want the scheme
  just as it was written in the URI in its original case,
  you can use the $uri->_scheme method instead.
  
  =item $uri->has_recognized_scheme
  
  Returns TRUE if the URI scheme is one that URI recognizes.
  
  It will also be TRUE for relative URLs where a recognized
  scheme was provided to the constructor, even if C<< $uri->scheme >>
  returns C<undef> for these.
  
  =item $uri->opaque
  
  =item $uri->opaque( $new_opaque )
  
  Sets and returns the scheme-specific part of the $uri
  (everything between the scheme and the fragment)
  as an escaped string.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the same value as $uri->opaque unless the URI
  supports the generic syntax for hierarchical namespaces.
  In that case the generic method is overridden to set and return
  the part of the URI between the I<host name> and the I<fragment>.
  
  =item $uri->fragment
  
  =item $uri->fragment( $new_frag )
  
  Returns the fragment identifier of a URI reference
  as an escaped string.
  
  =item $uri->as_string
  
  Returns a URI object to a plain ASCII string.  URI objects are
  also converted to plain strings automatically by overloading.  This
  means that $uri objects can be used as plain strings in most Perl
  constructs.
  
  =item $uri->as_iri
  
  Returns a Unicode string representing the URI.  Escaped UTF-8 sequences
  representing non-ASCII characters are turned into their corresponding Unicode
  code point.
  
  =item $uri->canonical
  
  Returns a normalized version of the URI.  The rules
  for normalization are scheme-dependent.  They usually involve
  lowercasing the scheme and Internet host name components,
  removing the explicit port specification if it matches the default port,
  uppercasing all escape sequences, and unescaping octets that can be
  better represented as plain characters.
  
  For efficiency reasons, if the $uri is already in normalized form,
  then a reference to it is returned instead of a copy.
  
  =item $uri->eq( $other_uri )
  
  =item URI::eq( $first_uri, $other_uri )
  
  Tests whether two URI references are equal.  URI references
  that normalize to the same string are considered equal.  The method
  can also be used as a plain function which can also test two string
  arguments.
  
  If you need to test whether two C<URI> object references denote the
  same object, use the '==' operator.
  
  =item $uri->abs( $base_uri )
  
  Returns an absolute URI reference.  If $uri is already
  absolute, then a reference to it is simply returned.  If the $uri
  is relative, then a new absolute URI is constructed by combining the
  $uri and the $base_uri, and returned.
  
  =item $uri->rel( $base_uri )
  
  Returns a relative URI reference if it is possible to
  make one that denotes the same resource relative to $base_uri.
  If not, then $uri is simply returned.
  
  =item $uri->secure
  
  Returns a TRUE value if the URI is considered to point to a resource on
  a secure channel, such as an SSL or TLS encrypted one.
  
  =back
  
  =head1 GENERIC METHODS
  
  The following methods are available to schemes that use the
  common/generic syntax for hierarchical namespaces.  The descriptions of
  schemes below indicate which these are.  Unrecognized schemes are
  assumed to support the generic syntax, and therefore the following
  methods:
  
  =over 4
  
  =item $uri->authority
  
  =item $uri->authority( $new_authority )
  
  Sets and returns the escaped authority component
  of the $uri.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the escaped path component of
  the $uri (the part between the host name and the query or fragment).
  The path can never be undefined, but it can be the empty string.
  
  =item $uri->path_query
  
  =item $uri->path_query( $new_path_query )
  
  Sets and returns the escaped path and query
  components as a single entity.  The path and the query are
  separated by a "?" character, but the query can itself contain "?".
  
  =item $uri->path_segments
  
  =item $uri->path_segments( $segment, ... )
  
  Sets and returns the path.  In a scalar context, it returns
  the same value as $uri->path.  In a list context, it returns the
  unescaped path segments that make up the path.  Path segments that
  have parameters are returned as an anonymous array.  The first element
  is the unescaped path segment proper;  subsequent elements are escaped
  parameter strings.  Such an anonymous array uses overloading so it can
  be treated as a string too, but this string does not include the
  parameters.
  
  Note that absolute paths have the empty string as their first
  I<path_segment>, i.e. the I<path> C</foo/bar> have 3
  I<path_segments>; "", "foo" and "bar".
  
  =item $uri->query
  
  =item $uri->query( $new_query )
  
  Sets and returns the escaped query component of
  the $uri.
  
  =item $uri->query_form
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ... )
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ..., $delim )
  
  =item $uri->query_form( \@key_value_pairs )
  
  =item $uri->query_form( \@key_value_pairs, $delim )
  
  =item $uri->query_form( \%hash )
  
  =item $uri->query_form( \%hash, $delim )
  
  Sets and returns query components that use the
  I<application/x-www-form-urlencoded> format.  Key/value pairs are
  separated by "&", and the key is separated from the value by a "="
  character.
  
  The form can be set either by passing separate key/value pairs, or via
  an array or hash reference.  Passing an empty array or an empty hash
  removes the query component, whereas passing no arguments at all leaves
  the component unchanged.  The order of keys is undefined if a hash
  reference is passed.  The old value is always returned as a list of
  separate key/value pairs.  Assigning this list to a hash is unwise as
  the keys returned might repeat.
  
  The values passed when setting the form can be plain strings or
  references to arrays of strings.  Passing an array of values has the
  same effect as passing the key repeatedly with one value at a time.
  All the following statements have the same effect:
  
      $uri->query_form(foo => 1, foo => 2);
      $uri->query_form(foo => [1, 2]);
      $uri->query_form([ foo => 1, foo => 2 ]);
      $uri->query_form([ foo => [1, 2] ]);
      $uri->query_form({ foo => [1, 2] });
  
  The $delim parameter can be passed as ";" to force the key/value pairs
  to be delimited by ";" instead of "&" in the query string.  This
  practice is often recommended for URLs embedded in HTML or XML
  documents as this avoids the trouble of escaping the "&" character.
  You might also set the $URI::DEFAULT_QUERY_FORM_DELIMITER variable to
  ";" for the same global effect.
  
  The C<URI::QueryParam> module can be loaded to add further methods to
  manipulate the form of a URI.  See L<URI::QueryParam> for details.
  
  =item $uri->query_keywords
  
  =item $uri->query_keywords( $keywords, ... )
  
  =item $uri->query_keywords( \@keywords )
  
  Sets and returns query components that use the
  keywords separated by "+" format.
  
  The keywords can be set either by passing separate keywords directly
  or by passing a reference to an array of keywords.  Passing an empty
  array removes the query component, whereas passing no arguments at
  all leaves the component unchanged.  The old value is always returned
  as a list of separate words.
  
  =back
  
  =head1 SERVER METHODS
  
  For schemes where the I<authority> component denotes an Internet host,
  the following methods are available in addition to the generic
  methods.
  
  =over 4
  
  =item $uri->userinfo
  
  =item $uri->userinfo( $new_userinfo )
  
  Sets and returns the escaped userinfo part of the
  authority component.
  
  For some schemes this is a user name and a password separated by
  a colon.  This practice is not recommended. Embedding passwords in
  clear text (such as URI) has proven to be a security risk in almost
  every case where it has been used.
  
  =item $uri->host
  
  =item $uri->host( $new_host )
  
  Sets and returns the unescaped hostname.
  
  If the $new_host string ends with a colon and a number, then this
  number also sets the port.
  
  For IPv6 addresses the brackets around the raw address is removed in the return
  value from $uri->host.  When setting the host attribute to an IPv6 address you
  can use a raw address or one enclosed in brackets.  The address needs to be
  enclosed in brackets if you want to pass in a new port value as well.
  
  =item $uri->ihost
  
  Returns the host in Unicode form.  Any IDNA A-labels are turned into U-labels.
  
  =item $uri->port
  
  =item $uri->port( $new_port )
  
  Sets and returns the port.  The port is a simple integer
  that should be greater than 0.
  
  If a port is not specified explicitly in the URI, then the URI scheme's default port
  is returned. If you don't want the default port
  substituted, then you can use the $uri->_port method instead.
  
  =item $uri->host_port
  
  =item $uri->host_port( $new_host_port )
  
  Sets and returns the host and port as a single
  unit.  The returned value includes a port, even if it matches the
  default port.  The host part and the port part are separated by a
  colon: ":".
  
  For IPv6 addresses the bracketing is preserved; thus
  URI->new("http://[::1]/")->host_port returns "[::1]:80".  Contrast this with
  $uri->host which will remove the brackets.
  
  =item $uri->default_port
  
  Returns the default port of the URI scheme to which $uri
  belongs.  For I<http> this is the number 80, for I<ftp> this
  is the number 21, etc.  The default port for a scheme can not be
  changed.
  
  =back
  
  =head1 SCHEME-SPECIFIC SUPPORT
  
  Scheme-specific support is provided for the following URI schemes.  For C<URI>
  objects that do not belong to one of these, you can only use the common and
  generic methods.
  
  =over 4
  
  =item B<data>:
  
  The I<data> URI scheme is specified in RFC 2397.  It allows inclusion
  of small data items as "immediate" data, as if it had been included
  externally.
  
  C<URI> objects belonging to the data scheme support the common methods
  and two new methods to access their scheme-specific components:
  $uri->media_type and $uri->data.  See L<URI::data> for details.
  
  =item B<file>:
  
  An old specification of the I<file> URI scheme is found in RFC 1738.
  A new RFC 2396 based specification in not available yet, but file URI
  references are in common use.
  
  C<URI> objects belonging to the file scheme support the common and
  generic methods.  In addition, they provide two methods for mapping file URIs
  back to local file names; $uri->file and $uri->dir.  See L<URI::file>
  for details.
  
  =item B<ftp>:
  
  An old specification of the I<ftp> URI scheme is found in RFC 1738.  A
  new RFC 2396 based specification in not available yet, but ftp URI
  references are in common use.
  
  C<URI> objects belonging to the ftp scheme support the common,
  generic and server methods.  In addition, they provide two methods for
  accessing the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<gopher>:
  
  The I<gopher> URI scheme is specified in
  <draft-murali-url-gopher-1996-12-04> and will hopefully be available
  as a RFC 2396 based specification.
  
  C<URI> objects belonging to the gopher scheme support the common,
  generic and server methods. In addition, they support some methods for
  accessing gopher-specific path components: $uri->gopher_type,
  $uri->selector, $uri->search, $uri->string.
  
  =item B<http>:
  
  The I<http> URI scheme is specified in RFC 2616.
  The scheme is used to reference resources hosted by HTTP servers.
  
  C<URI> objects belonging to the http scheme support the common,
  generic and server methods.
  
  =item B<https>:
  
  The I<https> URI scheme is a Netscape invention which is commonly
  implemented.  The scheme is used to reference HTTP servers through SSL
  connections.  Its syntax is the same as http, but the default
  port is different.
  
  =item B<ldap>:
  
  The I<ldap> URI scheme is specified in RFC 2255.  LDAP is the
  Lightweight Directory Access Protocol.  An ldap URI describes an LDAP
  search operation to perform to retrieve information from an LDAP
  directory.
  
  C<URI> objects belonging to the ldap scheme support the common,
  generic and server methods as well as ldap-specific methods: $uri->dn,
  $uri->attributes, $uri->scope, $uri->filter, $uri->extensions.  See
  L<URI::ldap> for details.
  
  =item B<ldapi>:
  
  Like the I<ldap> URI scheme, but uses a UNIX domain socket.  The
  server methods are not supported, and the local socket path is
  available as $uri->un_path.  The I<ldapi> scheme is used by the
  OpenLDAP package.  There is no real specification for it, but it is
  mentioned in various OpenLDAP manual pages.
  
  =item B<ldaps>:
  
  Like the I<ldap> URI scheme, but uses an SSL connection.  This
  scheme is deprecated, as the preferred way is to use the I<start_tls>
  mechanism.
  
  =item B<mailto>:
  
  The I<mailto> URI scheme is specified in RFC 2368.  The scheme was
  originally used to designate the Internet mailing address of an
  individual or service.  It has (in RFC 2368) been extended to allow
  setting of other mail header fields and the message body.
  
  C<URI> objects belonging to the mailto scheme support the common
  methods and the generic query methods.  In addition, they support the
  following mailto-specific methods: $uri->to, $uri->headers.
  
  Note that the "foo@example.com" part of a mailto is I<not> the
  C<userinfo> and C<host> but instead the C<path>.  This allows a
  mailto URI to contain multiple comma separated email addresses.
  
  =item B<mms>:
  
  The I<mms> URL specification can be found at L<http://sdp.ppona.com/>.
  C<URI> objects belonging to the mms scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<news>:
  
  The I<news>, I<nntp> and I<snews> URI schemes are specified in
  <draft-gilman-news-url-01> and will hopefully be available as an RFC
  2396 based specification soon.
  
  C<URI> objects belonging to the news scheme support the common,
  generic and server methods.  In addition, they provide some methods to
  access the path: $uri->group and $uri->message.
  
  =item B<nntp>:
  
  See I<news> scheme.
  
  =item B<pop>:
  
  The I<pop> URI scheme is specified in RFC 2384. The scheme is used to
  reference a POP3 mailbox.
  
  C<URI> objects belonging to the pop scheme support the common, generic
  and server methods.  In addition, they provide two methods to access the
  userinfo components: $uri->user and $uri->auth
  
  =item B<rlogin>:
  
  An old specification of the I<rlogin> URI scheme is found in RFC
  1738. C<URI> objects belonging to the rlogin scheme support the
  common, generic and server methods.
  
  =item B<rtsp>:
  
  The I<rtsp> URL specification can be found in section 3.2 of RFC 2326.
  C<URI> objects belonging to the rtsp scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<rtspu>:
  
  The I<rtspu> URI scheme is used to talk to RTSP servers over UDP
  instead of TCP.  The syntax is the same as rtsp.
  
  =item B<rsync>:
  
  Information about rsync is available from L<http://rsync.samba.org/>.
  C<URI> objects belonging to the rsync scheme support the common,
  generic and server methods.  In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<sip>:
  
  The I<sip> URI specification is described in sections 19.1 and 25
  of RFC 3261.  C<URI> objects belonging to the sip scheme support the
  common, generic, and server methods with the exception of path related
  sub-components.  In addition, they provide two methods to get and set
  I<sip> parameters: $uri->params_form and $uri->params.
  
  =item B<sips>:
  
  See I<sip> scheme.  Its syntax is the same as sip, but the default
  port is different.
  
  =item B<snews>:
  
  See I<news> scheme.  Its syntax is the same as news, but the default
  port is different.
  
  =item B<telnet>:
  
  An old specification of the I<telnet> URI scheme is found in RFC
  1738. C<URI> objects belonging to the telnet scheme support the
  common, generic and server methods.
  
  =item B<tn3270>:
  
  These URIs are used like I<telnet> URIs but for connections to IBM
  mainframes.  C<URI> objects belonging to the tn3270 scheme support the
  common, generic and server methods.
  
  =item B<ssh>:
  
  Information about ssh is available at L<http://www.openssh.com/>.
  C<URI> objects belonging to the ssh scheme support the common,
  generic and server methods. In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<sftp>:
  
  C<URI> objects belonging to the sftp scheme support the common,
  generic and server methods. In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<urn>:
  
  The syntax of Uniform Resource Names is specified in RFC 2141.  C<URI>
  objects belonging to the urn scheme provide the common methods, and also the
  methods $uri->nid and $uri->nss, which return the Namespace Identifier
  and the Namespace-Specific String respectively.
  
  The Namespace Identifier basically works like the Scheme identifier of
  URIs, and further divides the URN namespace.  Namespace Identifier
  assignments are maintained at
  L<http://www.iana.org/assignments/urn-namespaces>.
  
  Letter case is not significant for the Namespace Identifier.  It is
  always returned in lower case by the $uri->nid method.  The $uri->_nid
  method can be used if you want it in its original case.
  
  =item B<urn>:B<isbn>:
  
  The C<urn:isbn:> namespace contains International Standard Book
  Numbers (ISBNs) and is described in RFC 3187.  A C<URI> object belonging
  to this namespace has the following extra methods (if the
  Business::ISBN module is available): $uri->isbn,
  $uri->isbn_publisher_code, $uri->isbn_group_code (formerly isbn_country_code,
  which is still supported by issues a deprecation warning), $uri->isbn_as_ean.
  
  =item B<urn>:B<oid>:
  
  The C<urn:oid:> namespace contains Object Identifiers (OIDs) and is
  described in RFC 3061.  An object identifier consists of sequences of digits
  separated by dots.  A C<URI> object belonging to this namespace has an
  additional method called $uri->oid that can be used to get/set the oid
  value.  In a list context, oid numbers are returned as separate elements.
  
  =back
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over 4
  
  =item $URI::ABS_ALLOW_RELATIVE_SCHEME
  
  Some older parsers used to allow the scheme name to be present in the
  relative URL if it was the same as the base URL scheme.  RFC 2396 says
  that this should be avoided, but you can enable this old behaviour by
  setting the $URI::ABS_ALLOW_RELATIVE_SCHEME variable to a TRUE value.
  The difference is demonstrated by the following examples:
  
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:foo"
  
    local $URI::ABS_ALLOW_RELATIVE_SCHEME = 1;
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:/host/a/foo"
  
  
  =item $URI::ABS_REMOTE_LEADING_DOTS
  
  You can also have the abs() method ignore excess ".."
  segments in the relative URI by setting $URI::ABS_REMOTE_LEADING_DOTS
  to a TRUE value.  The difference is demonstrated by the following
  examples:
  
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/../../foo"
  
    local $URI::ABS_REMOTE_LEADING_DOTS = 1;
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/foo"
  
  =item $URI::DEFAULT_QUERY_FORM_DELIMITER
  
  This value can be set to ";" to have the query form C<key=value> pairs
  delimited by ";" instead of "&" which is the default.
  
  =back
  
  =head1 BUGS
  
  There are some things that are not quite right:
  
  =over
  
  =item *
  
  Using regexp variables like $1 directly as arguments to the URI accessor methods
  does not work too well with current perl implementations.  I would argue
  that this is actually a bug in perl.  The workaround is to quote
  them. Example:
  
     /(...)/ || die;
     $u->query("$1");
  
  
  =item *
  
  The escaping (percent encoding) of chars in the 128 .. 255 range passed to the
  URI constructor or when setting URI parts using the accessor methods depend on
  the state of the internal UTF8 flag (see utf8::is_utf8) of the string passed.
  If the UTF8 flag is set the UTF-8 encoded version of the character is percent
  encoded.  If the UTF8 flag isn't set the Latin-1 version (byte) of the
  character is percent encoded.  This basically exposes the internal encoding of
  Perl strings.
  
  =back
  
  =head1 PARSING URIs WITH REGEXP
  
  As an alternative to this module, the following (official) regular
  expression can be used to decode a URI:
  
    my($scheme, $authority, $path, $query, $fragment) =
    $uri =~ m|(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?|;
  
  The C<URI::Split> module provides the function uri_split() as a
  readable alternative.
  
  =head1 SEE ALSO
  
  L<URI::file>, L<URI::WithBase>, L<URI::QueryParam>, L<URI::Escape>,
  L<URI::Split>, L<URI::Heuristic>
  
  RFC 2396: "Uniform Resource Identifiers (URI): Generic Syntax",
  Berners-Lee, Fielding, Masinter, August 1998.
  
  L<http://www.iana.org/assignments/uri-schemes>
  
  L<http://www.iana.org/assignments/urn-namespaces>
  
  L<http://www.w3.org/Addressing/>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2009 Gisle Aas.
  
  Copyright 1995 Martijn Koster.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHORS / ACKNOWLEDGMENTS
  
  This module is based on the C<URI::URL> module, which in turn was
  (distantly) based on the C<wwwurl.pl> code in the libwww-perl for
  perl4 developed by Roy Fielding, as part of the Arcadia project at the
  University of California, Irvine, with contributions from Brooks
  Cutter.
  
  C<URI::URL> was developed by Gisle Aas, Tim Bunce, Roy Fielding and
  Martijn Koster with input from other people on the libwww-perl mailing
  list.
  
  C<URI> and related subclasses was developed by Gisle Aas.
  
  =cut
URI

$fatpacked{"URI/Escape.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_ESCAPE';
  package URI::Escape;
  
  use strict;
  use warnings;
  
  =head1 NAME
  
  URI::Escape - Percent-encode and percent-decode unsafe characters
  
  =head1 SYNOPSIS
  
   use URI::Escape;
   $safe = uri_escape("10% is enough\n");
   $verysafe = uri_escape("foo", "\0-\377");
   $str  = uri_unescape($safe);
  
  =head1 DESCRIPTION
  
  This module provides functions to percent-encode and percent-decode URI strings as
  defined by RFC 3986. Percent-encoding URI's is informally called "URI escaping".
  This is the terminology used by this module, which predates the formalization of the
  terms by the RFC by several years.
  
  A URI consists of a restricted set of characters.  The restricted set
  of characters consists of digits, letters, and a few graphic symbols
  chosen from those common to most of the character encodings and input
  facilities available to Internet users.  They are made up of the
  "unreserved" and "reserved" character sets as defined in RFC 3986.
  
     unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
     reserved      = ":" / "/" / "?" / "#" / "[" / "]" / "@"
                     "!" / "$" / "&" / "'" / "(" / ")"
                   / "*" / "+" / "," / ";" / "="
  
  In addition, any byte (octet) can be represented in a URI by an escape
  sequence: a triplet consisting of the character "%" followed by two
  hexadecimal digits.  A byte can also be represented directly by a
  character, using the US-ASCII character for that octet.
  
  Some of the characters are I<reserved> for use as delimiters or as
  part of certain URI components.  These must be escaped if they are to
  be treated as ordinary data.  Read RFC 3986 for further details.
  
  The functions provided (and exported by default) from this module are:
  
  =over 4
  
  =item uri_escape( $string )
  
  =item uri_escape( $string, $unsafe )
  
  Replaces each unsafe character in the $string with the corresponding
  escape sequence and returns the result.  The $string argument should
  be a string of bytes.  The uri_escape() function will croak if given a
  characters with code above 255.  Use uri_escape_utf8() if you know you
  have such chars or/and want chars in the 128 .. 255 range treated as
  UTF-8.
  
  The uri_escape() function takes an optional second argument that
  overrides the set of characters that are to be escaped.  The set is
  specified as a string that can be used in a regular expression
  character class (between [ ]).  E.g.:
  
    "\x00-\x1f\x7f-\xff"          # all control and hi-bit characters
    "a-z"                         # all lower case characters
    "^A-Za-z"                     # everything not a letter
  
  The default set of characters to be escaped is all those which are
  I<not> part of the C<unreserved> character class shown above as well
  as the reserved characters.  I.e. the default is:
  
      "^A-Za-z0-9\-\._~"
  
  =item uri_escape_utf8( $string )
  
  =item uri_escape_utf8( $string, $unsafe )
  
  Works like uri_escape(), but will encode chars as UTF-8 before
  escaping them.  This makes this function able to deal with characters
  with code above 255 in $string.  Note that chars in the 128 .. 255
  range will be escaped differently by this function compared to what
  uri_escape() would.  For chars in the 0 .. 127 range there is no
  difference.
  
  Equivalent to:
  
      utf8::encode($string);
      my $uri = uri_escape($string);
  
  Note: JavaScript has a function called escape() that produces the
  sequence "%uXXXX" for chars in the 256 .. 65535 range.  This function
  has really nothing to do with URI escaping but some folks got confused
  since it "does the right thing" in the 0 .. 255 range.  Because of
  this you sometimes see "URIs" with these kind of escapes.  The
  JavaScript encodeURIComponent() function is similar to uri_escape_utf8().
  
  =item uri_unescape($string,...)
  
  Returns a string with each %XX sequence replaced with the actual byte
  (octet).
  
  This does the same as:
  
     $string =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
  
  but does not modify the string in-place as this RE would.  Using the
  uri_unescape() function instead of the RE might make the code look
  cleaner and is a few characters less to type.
  
  In a simple benchmark test I did,
  calling the function (instead of the inline RE above) if a few chars
  were unescaped was something like 40% slower, and something like 700% slower if none were.  If
  you are going to unescape a lot of times it might be a good idea to
  inline the RE.
  
  If the uri_unescape() function is passed multiple strings, then each
  one is returned unescaped.
  
  =back
  
  The module can also export the C<%escapes> hash, which contains the
  mapping from all 256 bytes to the corresponding escape codes.  Lookup
  in this hash is faster than evaluating C<sprintf("%%%02X", ord($byte))>
  each time.
  
  =head1 SEE ALSO
  
  L<URI>
  
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  use Exporter 5.57 'import';
  our %escapes;
  our @EXPORT = qw(uri_escape uri_unescape uri_escape_utf8);
  our @EXPORT_OK = qw(%escapes);
  our $VERSION = "3.31";
  
  use Carp ();
  
  # Build a char->hex map
  for (0..255) {
      $escapes{chr($_)} = sprintf("%%%02X", $_);
  }
  
  my %subst;  # compiled patterns
  
  my %Unsafe = (
      RFC2732 => qr/[^A-Za-z0-9\-_.!~*'()]/,
      RFC3986 => qr/[^A-Za-z0-9\-\._~]/,
  );
  
  sub uri_escape {
      my($text, $patn) = @_;
      return undef unless defined $text;
      if (defined $patn){
          unless (exists  $subst{$patn}) {
              # Because we can't compile the regex we fake it with a cached sub
              (my $tmp = $patn) =~ s,/,\\/,g;
              eval "\$subst{\$patn} = sub {\$_[0] =~ s/([$tmp])/\$escapes{\$1} || _fail_hi(\$1)/ge; }";
              Carp::croak("uri_escape: $@") if $@;
          }
          &{$subst{$patn}}($text);
      } else {
          $text =~ s/($Unsafe{RFC3986})/$escapes{$1} || _fail_hi($1)/ge;
      }
      $text;
  }
  
  sub _fail_hi {
      my $chr = shift;
      Carp::croak(sprintf "Can't escape \\x{%04X}, try uri_escape_utf8() instead", ord($chr));
  }
  
  sub uri_escape_utf8 {
      my $text = shift;
      return undef unless defined $text;
      utf8::encode($text);
      return uri_escape($text, @_);
  }
  
  sub uri_unescape {
      # Note from RFC1630:  "Sequences which start with a percent sign
      # but are not followed by two hexadecimal characters are reserved
      # for future extension"
      my $str = shift;
      if (@_ && wantarray) {
          # not executed for the common case of a single argument
          my @str = ($str, @_);  # need to copy
          for (@str) {
              s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
          }
          return @str;
      }
      $str =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg if defined $str;
      $str;
  }
  
  # XXX FIXME escape_char is buggy as it assigns meaning to the string's storage format.
  sub escape_char {
      # Old versions of utf8::is_utf8() didn't properly handle magical vars (e.g. $1).
      # The following forces a fetch to occur beforehand.
      my $dummy = substr($_[0], 0, 0);
  
      if (utf8::is_utf8($_[0])) {
          my $s = shift;
          utf8::encode($s);
          unshift(@_, $s);
      }
  
      return join '', @URI::Escape::escapes{split //, $_[0]};
  }
  
  1;
URI_ESCAPE

$fatpacked{"URI/Heuristic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HEURISTIC';
  package URI::Heuristic;
  
  =head1 NAME
  
  URI::Heuristic - Expand URI using heuristics
  
  =head1 SYNOPSIS
  
   use URI::Heuristic qw(uf_uristr);
   $u = uf_uristr("perl");             # http://www.perl.com
   $u = uf_uristr("www.sol.no/sol");   # http://www.sol.no/sol
   $u = uf_uristr("aas");              # http://www.aas.no
   $u = uf_uristr("ftp.funet.fi");     # ftp://ftp.funet.fi
   $u = uf_uristr("/etc/passwd");      # file:/etc/passwd
  
  =head1 DESCRIPTION
  
  This module provides functions that expand strings into real absolute
  URIs using some built-in heuristics.  Strings that already represent
  absolute URIs (i.e. that start with a C<scheme:> part) are never modified
  and are returned unchanged.  The main use of these functions is to
  allow abbreviated URIs similar to what many web browsers allow for URIs
  typed in by the user.
  
  The following functions are provided:
  
  =over 4
  
  =item uf_uristr($str)
  
  Tries to make the argument string
  into a proper absolute URI string.  The "uf_" prefix stands for "User 
  Friendly".  Under MacOS, it assumes that any string with a common URL 
  scheme (http, ftp, etc.) is a URL rather than a local path.  So don't name 
  your volumes after common URL schemes and expect uf_uristr() to construct 
  valid file: URL's on those volumes for you, because it won't.
  
  =item uf_uri($str)
  
  Works the same way as uf_uristr() but
  returns a C<URI> object.
  
  =back
  
  =head1 ENVIRONMENT
  
  If the hostname portion of a URI does not contain any dots, then
  certain qualified guesses are made.  These guesses are governed by
  the following environment variables:
  
  =over 10
  
  =item COUNTRY
  
  The two-letter country code (ISO 3166) for your location.  If
  the domain name of your host ends with two letters, then it is taken
  to be the default country. See also L<Locale::Country>.
  
  =item HTTP_ACCEPT_LANGUAGE, LC_ALL, LANG
  
  If COUNTRY is not set, these standard environment variables are
  examined and country (not language) information possibly found in them
  is used as the default country.
  
  =item URL_GUESS_PATTERN
  
  Contains a space-separated list of URL patterns to try.  The string
  "ACME" is for some reason used as a placeholder for the host name in
  the URL provided.  Example:
  
   URL_GUESS_PATTERN="www.ACME.no www.ACME.se www.ACME.com"
   export URL_GUESS_PATTERN
  
  Specifying URL_GUESS_PATTERN disables any guessing rules based on
  country.  An empty URL_GUESS_PATTERN disables any guessing that
  involves host name lookups.
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 1997-1998, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT_OK = qw(uf_uri uf_uristr uf_url uf_urlstr);
  our $VERSION = "4.20";
  
  our ($MY_COUNTRY, $DEBUG);
  
  sub MY_COUNTRY() {
      for ($MY_COUNTRY) {
  	return $_ if defined;
  
  	# First try the environment.
  	$_ = $ENV{COUNTRY};
  	return $_ if defined;
  
  	# Try the country part of LC_ALL and LANG from environment
  	my @srcs = ($ENV{LC_ALL}, $ENV{LANG});
  	# ...and HTTP_ACCEPT_LANGUAGE before those if present
  	if (my $httplang = $ENV{HTTP_ACCEPT_LANGUAGE}) {
  	    # TODO: q-value processing/ordering
  	    for $httplang (split(/\s*,\s*/, $httplang)) {
  		if ($httplang =~ /^\s*([a-zA-Z]+)[_-]([a-zA-Z]{2})\s*$/) {
  		    unshift(@srcs, "${1}_${2}");
  		    last;
  		}
  	    }
  	}
  	for (@srcs) {
  	    next unless defined;
  	    return lc($1) if /^[a-zA-Z]+_([a-zA-Z]{2})(?:[.@]|$)/;
  	}
  
  	# Last bit of domain name.  This may access the network.
  	require Net::Domain;
  	my $fqdn = Net::Domain::hostfqdn();
  	$_ = lc($1) if $fqdn =~ /\.([a-zA-Z]{2})$/;
  	return $_ if defined;
  
  	# Give up.  Defined but false.
  	return ($_ = 0);
      }
  }
  
  our %LOCAL_GUESSING =
  (
   'us' => [qw(www.ACME.gov www.ACME.mil)],
   'gb' => [qw(www.ACME.co.uk www.ACME.org.uk www.ACME.ac.uk)],
   'au' => [qw(www.ACME.com.au www.ACME.org.au www.ACME.edu.au)],
   'il' => [qw(www.ACME.co.il www.ACME.org.il www.ACME.net.il)],
   # send corrections and new entries to <gisle@aas.no>
  );
  # Backwards compatibility; uk != United Kingdom in ISO 3166
  $LOCAL_GUESSING{uk} = $LOCAL_GUESSING{gb};
  
  
  sub uf_uristr ($)
  {
      local($_) = @_;
      print STDERR "uf_uristr: resolving $_\n" if $DEBUG;
      return unless defined;
  
      s/^\s+//;
      s/\s+$//;
  
      if (/^(www|web|home)[a-z0-9-]*(?:\.|$)/i) {
  	$_ = "http://$_";
  
      } elsif (/^(ftp|gopher|news|wais|https|http)[a-z0-9-]*(?:\.|$)/i) {
  	$_ = lc($1) . "://$_";
  
      } elsif ($^O ne "MacOS" && 
  	    (m,^/,      ||          # absolute file name
  	     m,^\.\.?/, ||          # relative file name
  	     m,^[a-zA-Z]:[/\\],)    # dosish file name
  	    )
      {
  	$_ = "file:$_";
  
      } elsif ($^O eq "MacOS" && m/:/) {
          # potential MacOS file name
  	unless (m/^(ftp|gopher|news|wais|http|https|mailto):/) {
  	    require URI::file;
  	    my $a = URI::file->new($_)->as_string;
  	    $_ = ($a =~ m/^file:/) ? $a : "file:$a";
  	}
      } elsif (/^\w+([\.\-]\w+)*\@(\w+\.)+\w{2,3}$/) {
  	$_ = "mailto:$_";
  
      } elsif (!/^[a-zA-Z][a-zA-Z0-9.+\-]*:/) {      # no scheme specified
  	if (s/^([-\w]+(?:\.[-\w]+)*)([\/:\?\#]|$)/$2/) {
  	    my $host = $1;
  
  	    my $scheme = "http";
  	    if (/^:(\d+)\b/) {
  		# Some more or less well known ports
  		if ($1 =~ /^[56789]?443$/) {
  		    $scheme = "https";
  		} elsif ($1 eq "21") {
  		    $scheme = "ftp";
  		}
  	    }
  
  	    if ($host !~ /\./ && $host ne "localhost") {
  		my @guess;
  		if (exists $ENV{URL_GUESS_PATTERN}) {
  		    @guess = map { s/\bACME\b/$host/; $_ }
  		             split(' ', $ENV{URL_GUESS_PATTERN});
  		} else {
  		    if (MY_COUNTRY()) {
  			my $special = $LOCAL_GUESSING{MY_COUNTRY()};
  			if ($special) {
  			    my @special = @$special;
  			    push(@guess, map { s/\bACME\b/$host/; $_ }
                                                 @special);
  			} else {
  			    push(@guess, "www.$host." . MY_COUNTRY());
  			}
  		    }
  		    push(@guess, map "www.$host.$_",
  			             "com", "org", "net", "edu", "int");
  		}
  
  
  		my $guess;
  		for $guess (@guess) {
  		    print STDERR "uf_uristr: gethostbyname('$guess.')..."
  		      if $DEBUG;
  		    if (gethostbyname("$guess.")) {
  			print STDERR "yes\n" if $DEBUG;
  			$host = $guess;
  			last;
  		    }
  		    print STDERR "no\n" if $DEBUG;
  		}
  	    }
  	    $_ = "$scheme://$host$_";
  
  	} else {
  	    # pure junk, just return it unchanged...
  
  	}
      }
      print STDERR "uf_uristr: ==> $_\n" if $DEBUG;
  
      $_;
  }
  
  sub uf_uri ($)
  {
      require URI;
      URI->new(uf_uristr($_[0]));
  }
  
  # legacy
  *uf_urlstr = \*uf_uristr;
  
  sub uf_url ($)
  {
      require URI::URL;
      URI::URL->new(uf_uristr($_[0]));
  }
  
  1;
URI_HEURISTIC

$fatpacked{"URI/IRI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_IRI';
  package URI::IRI;
  
  # Experimental
  
  use strict;
  use warnings;
  use URI ();
  
  use overload '""' => sub { shift->as_string };
  
  our $VERSION = '1.74';
  
  sub new {
      my($class, $uri, $scheme) = @_;
      utf8::upgrade($uri);
      return bless {
  	uri => URI->new($uri, $scheme),
      }, $class;
  }
  
  sub clone {
      my $self = shift;
      return bless {
  	uri => $self->{uri}->clone,
      }, ref($self);
  }
  
  sub as_string {
      my $self = shift;
      return $self->{uri}->as_iri;
  }
  
  our $AUTOLOAD;
  sub AUTOLOAD
  {
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
  
      # We create the function here so that it will not need to be
      # autoloaded the next time.
      no strict 'refs';
      *$method = sub { shift->{uri}->$method(@_) };
      goto &$method;
  }
  
  sub DESTROY {}   # avoid AUTOLOADing it
  
  1;
URI_IRI

$fatpacked{"URI/QueryParam.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_QUERYPARAM';
  package URI::QueryParam;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  sub URI::_query::query_param {
      my $self = shift;
      my @old = $self->query_form;
  
      if (@_ == 0) {
  	# get keys
  	my (%seen, $i);
  	return grep !($i++ % 2 || $seen{$_}++), @old;
      }
  
      my $key = shift;
      my @i = grep $_ % 2 == 0 && $old[$_] eq $key, 0 .. $#old;
  
      if (@_) {
  	my @new = @old;
  	my @new_i = @i;
  	my @vals = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
  
  	while (@new_i > @vals) {
  	    splice @new, pop @new_i, 2;
  	}
  	if (@vals > @new_i) {
  	    my $i = @new_i ? $new_i[-1] + 2 : @new;
  	    my @splice = splice @vals, @new_i, @vals - @new_i;
  
  	    splice @new, $i, 0, map { $key => $_ } @splice;
  	}
  	if (@vals) {
  	    #print "SET $new_i[0]\n";
  	    @new[ map $_ + 1, @new_i ] = @vals;
  	}
  
  	$self->query_form(\@new);
      }
  
      return wantarray ? @old[map $_+1, @i] : @i ? $old[$i[0]+1] : undef;
  }
  
  sub URI::_query::query_param_append {
      my $self = shift;
      my $key = shift;
      my @vals = map { ref $_ eq 'ARRAY' ? @$_ : $_ } @_;
      $self->query_form($self->query_form, $key => \@vals);  # XXX
      return;
  }
  
  sub URI::_query::query_param_delete {
      my $self = shift;
      my $key = shift;
      my @old = $self->query_form;
      my @vals;
  
      for (my $i = @old - 2; $i >= 0; $i -= 2) {
  	next if $old[$i] ne $key;
  	push(@vals, (splice(@old, $i, 2))[1]);
      }
      $self->query_form(\@old) if @vals;
      return wantarray ? reverse @vals : $vals[-1];
  }
  
  sub URI::_query::query_form_hash {
      my $self = shift;
      my @old = $self->query_form;
      if (@_) {
  	$self->query_form(@_ == 1 ? %{shift(@_)} : @_);
      }
      my %hash;
      while (my($k, $v) = splice(@old, 0, 2)) {
  	if (exists $hash{$k}) {
  	    for ($hash{$k}) {
  		$_ = [$_] unless ref($_) eq "ARRAY";
  		push(@$_, $v);
  	    }
  	}
  	else {
  	    $hash{$k} = $v;
  	}
      }
      return \%hash;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::QueryParam - Additional query methods for URIs
  
  =head1 SYNOPSIS
  
    use URI;
    use URI::QueryParam;
  
    $u = URI->new("", "http");
    $u->query_param(foo => 1, 2, 3);
    print $u->query;    # prints foo=1&foo=2&foo=3
  
    for my $key ($u->query_param) {
        print "$key: ", join(", ", $u->query_param($key)), "\n";
    }
  
  =head1 DESCRIPTION
  
  Loading the C<URI::QueryParam> module adds some extra methods to
  URIs that support query methods.  These methods provide an alternative
  interface to the $u->query_form data.
  
  The query_param_* methods have deliberately been made identical to the
  interface of the corresponding C<CGI.pm> methods.
  
  The following additional methods are made available:
  
  =over
  
  =item @keys = $u->query_param
  
  =item @values = $u->query_param( $key )
  
  =item $first_value = $u->query_param( $key )
  
  =item $u->query_param( $key, $value,... )
  
  If $u->query_param is called with no arguments, it returns all the
  distinct parameter keys of the URI.  In a scalar context it returns the
  number of distinct keys.
  
  When a $key argument is given, the method returns the parameter values with the
  given key.  In a scalar context, only the first parameter value is
  returned.
  
  If additional arguments are given, they are used to update successive
  parameters with the given key.  If any of the values provided are
  array references, then the array is dereferenced to get the actual
  values.
  
  Please note that you can supply multiple values to this method, but you cannot
  supply multiple keys.
  
  Do this:
  
      $uri->query_param( widget_id => 1, 5, 9 );
  
  Do NOT do this:
  
      $uri->query_param( widget_id => 1, frobnicator_id => 99 );
  
  =item $u->query_param_append($key, $value,...)
  
  Adds new parameters with the given
  key without touching any old parameters with the same key.  It
  can be explained as a more efficient version of:
  
     $u->query_param($key,
                     $u->query_param($key),
                     $value,...);
  
  One difference is that this expression would return the old values
  of $key, whereas the query_param_append() method does not.
  
  =item @values = $u->query_param_delete($key)
  
  =item $first_value = $u->query_param_delete($key)
  
  Deletes all key/value pairs with the given key.
  The old values are returned.  In a scalar context, only the first value
  is returned.
  
  Using the query_param_delete() method is slightly more efficient than
  the equivalent:
  
     $u->query_param($key, []);
  
  =item $hashref = $u->query_form_hash
  
  =item $u->query_form_hash( \%new_form )
  
  Returns a reference to a hash that represents the
  query form's key/value pairs.  If a key occurs multiple times, then the hash
  value becomes an array reference.
  
  Note that sequence information is lost.  This means that:
  
     $u->query_form_hash($u->query_form_hash);
  
  is not necessarily a no-op, as it may reorder the key/value pairs.
  The values returned by the query_param() method should stay the same
  though.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<CGI>
  
  =head1 COPYRIGHT
  
  Copyright 2002 Gisle Aas.
  
  =cut
URI_QUERYPARAM

$fatpacked{"URI/Split.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SPLIT';
  package URI::Split;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use Exporter 5.57 'import';
  our @EXPORT_OK = qw(uri_split uri_join);
  
  use URI::Escape ();
  
  sub uri_split {
       return $_[0] =~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,;
  }
  
  sub uri_join {
      my($scheme, $auth, $path, $query, $frag) = @_;
      my $uri = defined($scheme) ? "$scheme:" : "";
      $path = "" unless defined $path;
      if (defined $auth) {
  	$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;
  	$uri .= "//$auth";
  	$path = "/$path" if length($path) && $path !~ m,^/,;
      }
      elsif ($path =~ m,^//,) {
  	$uri .= "//";  # XXX force empty auth
      }
      unless (length $uri) {
  	$path =~ s,(:), URI::Escape::escape_char($1),e while $path =~ m,^[^:/?\#]+:,;
      }
      $path =~ s,([?\#]), URI::Escape::escape_char($1),eg;
      $uri .= $path;
      if (defined $query) {
  	$query =~ s,(\#), URI::Escape::escape_char($1),eg;
  	$uri .= "?$query";
      }
      $uri .= "#$frag" if defined $frag;
      $uri;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::Split - Parse and compose URI strings
  
  =head1 SYNOPSIS
  
   use URI::Split qw(uri_split uri_join);
   ($scheme, $auth, $path, $query, $frag) = uri_split($uri);
   $uri = uri_join($scheme, $auth, $path, $query, $frag);
  
  =head1 DESCRIPTION
  
  Provides functions to parse and compose URI
  strings.  The following functions are provided:
  
  =over
  
  =item ($scheme, $auth, $path, $query, $frag) = uri_split($uri)
  
  Breaks up a URI string into its component
  parts.  An C<undef> value is returned for those parts that are not
  present.  The $path part is always present (but can be the empty
  string) and is thus never returned as C<undef>.
  
  No sensible value is returned if this function is called in a scalar
  context.
  
  =item $uri = uri_join($scheme, $auth, $path, $query, $frag)
  
  Puts together a URI string from its parts.
  Missing parts are signaled by passing C<undef> for the corresponding
  argument.
  
  Minimal escaping is applied to parts that contain reserved chars
  that would confuse a parser.  For instance, any occurrence of '?' or '#'
  in $path is always escaped, as it would otherwise be parsed back
  as a query or fragment.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::Escape>
  
  =head1 COPYRIGHT
  
  Copyright 2003, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_SPLIT

$fatpacked{"URI/URL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URL';
  package URI::URL;
  
  use strict;
  use warnings;
  
  use parent 'URI::WithBase';
  
  our $VERSION = "5.04";
  
  # Provide as much as possible of the old URI::URL interface for backwards
  # compatibility...
  
  use Exporter 5.57 'import';
  our @EXPORT = qw(url);
  
  # Easy to use constructor
  sub url ($;$) { URI::URL->new(@_); }
  
  use URI::Escape qw(uri_unescape);
  
  sub new
  {
      my $class = shift;
      my $self = $class->SUPER::new(@_);
      $self->[0] = $self->[0]->canonical;
      $self;
  }
  
  sub newlocal
  {
      my $class = shift;
      require URI::file;
      bless [URI::file->new_abs(shift)], $class;
  }
  
  {package URI::_foreign;
      sub _init  # hope it is not defined
      {
  	my $class = shift;
  	die "Unknown URI::URL scheme $_[1]:" if $URI::URL::STRICT;
  	$class->SUPER::_init(@_);
      }
  }
  
  sub strict
  {
      my $old = $URI::URL::STRICT;
      $URI::URL::STRICT = shift if @_;
      $old;
  }
  
  sub print_on
  {
      my $self = shift;
      require Data::Dumper;
      print STDERR Data::Dumper::Dumper($self);
  }
  
  sub _try
  {
      my $self = shift;
      my $method = shift;
      scalar(eval { $self->$method(@_) });
  }
  
  sub crack
  {
      # should be overridden by subclasses
      my $self = shift;
      (scalar($self->scheme),
       $self->_try("user"),
       $self->_try("password"),
       $self->_try("host"),
       $self->_try("port"),
       $self->_try("path"),
       $self->_try("params"),
       $self->_try("query"),
       scalar($self->fragment),
      )
  }
  
  sub full_path
  {
      my $self = shift;
      my $path = $self->path_query;
      $path = "/" unless length $path;
      $path;
  }
  
  sub netloc
  {
      shift->authority(@_);
  }
  
  sub epath
  {
      my $path = shift->SUPER::path(@_);
      $path =~ s/;.*//;
      $path;
  }
  
  sub eparams
  {
      my $self = shift;
      my @p = $self->path_segments;
      return undef unless ref($p[-1]);
      @p = @{$p[-1]};
      shift @p;
      join(";", @p);
  }
  
  sub params { shift->eparams(@_); }
  
  sub path {
      my $self = shift;
      my $old = $self->epath(@_);
      return unless defined wantarray;
      return '/' if !defined($old) || !length($old);
      Carp::croak("Path components contain '/' (you must call epath)")
  	if $old =~ /%2[fF]/ and !@_;
      $old = "/$old" if $old !~ m|^/| && defined $self->netloc;
      return uri_unescape($old);
  }
  
  sub path_components {
      shift->path_segments(@_);
  }
  
  sub query {
      my $self = shift;
      my $old = $self->equery(@_);
      if (defined(wantarray) && defined($old)) {
  	if ($old =~ /%(?:26|2[bB]|3[dD])/) {  # contains escaped '=' '&' or '+'
  	    my $mess;
  	    for ($old) {
  		$mess = "Query contains both '+' and '%2B'"
  		  if /\+/ && /%2[bB]/;
  		$mess = "Form query contains escaped '=' or '&'"
  		  if /=/  && /%(?:3[dD]|26)/;
  	    }
  	    if ($mess) {
  		Carp::croak("$mess (you must call equery)");
  	    }
  	}
  	# Now it should be safe to unescape the string without losing
  	# information
  	return uri_unescape($old);
      }
      undef;
  
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift;
      my $allow_scheme = shift;
      $allow_scheme = $URI::URL::ABS_ALLOW_RELATIVE_SCHEME
  	unless defined $allow_scheme;
      local $URI::ABS_ALLOW_RELATIVE_SCHEME = $allow_scheme;
      local $URI::ABS_REMOTE_LEADING_DOTS = $URI::URL::ABS_REMOTE_LEADING_DOTS;
      $self->SUPER::abs($base);
  }
  
  sub frag { shift->fragment(@_); }
  sub keywords { shift->query_keywords(@_); }
  
  # file:
  sub local_path { shift->file; }
  sub unix_path  { shift->file("unix"); }
  sub dos_path   { shift->file("dos");  }
  sub mac_path   { shift->file("mac");  }
  sub vms_path   { shift->file("vms");  }
  
  # mailto:
  sub address { shift->to(@_); }
  sub encoded822addr { shift->to(@_); }
  sub URI::mailto::authority { shift->to(@_); }  # make 'netloc' method work
  
  # news:
  sub groupart { shift->_group(@_); }
  sub article  { shift->message(@_); }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::URL - Uniform Resource Locators
  
  =head1 SYNOPSIS
  
   $u1 = URI::URL->new($str, $base);
   $u2 = $u1->abs;
  
  =head1 DESCRIPTION
  
  This module is provided for backwards compatibility with modules that
  depend on the interface provided by the C<URI::URL> class that used to
  be distributed with the libwww-perl library.
  
  The following differences exist compared to the C<URI> class interface:
  
  =over 3
  
  =item *
  
  The URI::URL module exports the url() function as an alternate
  constructor interface.
  
  =item *
  
  The constructor takes an optional $base argument.  The C<URI::URL>
  class is a subclass of C<URI::WithBase>.
  
  =item *
  
  The URI::URL->newlocal class method is the same as URI::file->new_abs.
  
  =item *
  
  URI::URL::strict(1)
  
  =item *
  
  $url->print_on method
  
  =item *
  
  $url->crack method
  
  =item *
  
  $url->full_path: same as ($uri->abs_path || "/")
  
  =item *
  
  $url->netloc: same as $uri->authority
  
  =item *
  
  $url->epath, $url->equery: same as $uri->path, $uri->query
  
  =item *
  
  $url->path and $url->query pass unescaped strings.
  
  =item *
  
  $url->path_components: same as $uri->path_segments (if you don't
  consider path segment parameters)
  
  =item *
  
  $url->params and $url->eparams methods
  
  =item *
  
  $url->base method.  See L<URI::WithBase>.
  
  =item *
  
  $url->abs and $url->rel have an optional $base argument.  See
  L<URI::WithBase>.
  
  =item *
  
  $url->frag: same as $uri->fragment
  
  =item *
  
  $url->keywords: same as $uri->query_keywords
  
  =item *
  
  $url->localpath and friends map to $uri->file.
  
  =item *
  
  $url->address and $url->encoded822addr: same as $uri->to for mailto URI
  
  =item *
  
  $url->groupart method for news URI
  
  =item *
  
  $url->article: same as $uri->message
  
  =back
  
  
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::WithBase>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2000 Gisle Aas.
  
  =cut
URI_URL

$fatpacked{"URI/WithBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_WITHBASE';
  package URI::WithBase;
  
  use strict;
  use warnings;
  
  use URI;
  use Scalar::Util 'blessed';
  
  our $VERSION = "2.20";
  
  use overload '""' => "as_string", fallback => 1;
  
  sub as_string;  # help overload find it
  
  sub new
  {
      my($class, $uri, $base) = @_;
      my $ibase = $base;
      if ($base && blessed($base) && $base->isa(__PACKAGE__)) {
  	$base = $base->abs;
  	$ibase = $base->[0];
      }
      bless [URI->new($uri, $ibase), $base], $class;
  }
  
  sub new_abs
  {
      my $class = shift;
      my $self = $class->new(@_);
      $self->abs;
  }
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      bless [URI->new($str, $scheme), undef], $class;
  }
  
  sub eq
  {
      my($self, $other) = @_;
      $other = $other->[0] if blessed($other) and $other->isa(__PACKAGE__);
      $self->[0]->eq($other);
  }
  
  our $AUTOLOAD;
  sub AUTOLOAD
  {
      my $self = shift;
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
      return if $method eq "DESTROY";
      $self->[0]->$method(@_);
  }
  
  sub can {                                  # override UNIVERSAL::can
      my $self = shift;
      $self->SUPER::can(@_) || (
        ref($self)
        ? $self->[0]->can(@_)
        : undef
      )
  }
  
  sub base {
      my $self = shift;
      my $base  = $self->[1];
  
      if (@_) { # set
  	my $new_base = shift;
  	# ensure absoluteness
  	$new_base = $new_base->abs if ref($new_base) && $new_base->isa(__PACKAGE__);
  	$self->[1] = $new_base;
      }
      return unless defined wantarray;
  
      # The base attribute supports 'lazy' conversion from URL strings
      # to URL objects. Strings may be stored but when a string is
      # fetched it will automatically be converted to a URL object.
      # The main benefit is to make it much cheaper to say:
      #   URI::WithBase->new($random_url_string, 'http:')
      if (defined($base) && !ref($base)) {
  	$base = ref($self)->new($base);
  	$self->[1] = $base unless @_;
      }
      $base;
  }
  
  sub clone
  {
      my $self = shift;
      my $base = $self->[1];
      $base = $base->clone if ref($base);
      bless [$self->[0]->clone, $base], ref($self);
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->abs($base, @_), $base], ref($self);
  }
  
  sub rel
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->rel($base, @_), $base], ref($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::WithBase - URIs which remember their base
  
  =head1 SYNOPSIS
  
   $u1 = URI::WithBase->new($str, $base);
   $u2 = $u1->abs;
  
   $base = $u1->base;
   $u1->base( $new_base )
  
  =head1 DESCRIPTION
  
  This module provides the C<URI::WithBase> class.  Objects of this class
  are like C<URI> objects, but can keep their base too.  The base
  represents the context where this URI was found and can be used to
  absolutize or relativize the URI.  All the methods described in L<URI>
  are supported for C<URI::WithBase> objects.
  
  The methods provided in addition to or modified from those of C<URI> are:
  
  =over 4
  
  =item $uri = URI::WithBase->new($str, [$base])
  
  The constructor takes an optional base URI as the second argument.
  If provided, this argument initializes the base attribute.
  
  =item $uri->base( [$new_base] )
  
  Can be used to get or set the value of the base attribute.
  The return value, which is the old value, is a URI object or C<undef>.
  
  =item $uri->abs( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is returned even if $uri is already
  absolute (while plain URI objects simply return themselves in
  that case).
  
  =item $uri->rel( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is always returned.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2002 Gisle Aas.
  
  =cut
URI_WITHBASE

$fatpacked{"URI/_foreign.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__FOREIGN';
  package URI::_foreign;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  
  our $VERSION = '1.74';
  
  1;
URI__FOREIGN

$fatpacked{"URI/_generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__GENERIC';
  package URI::_generic;
  
  use strict;
  use warnings;
  
  use parent qw(URI URI::_query);
  
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  our $VERSION = '1.74';
  
  my $ACHAR = $URI::uric;  $ACHAR =~ s,\\[/?],,g;
  my $PCHAR = $URI::uric;  $PCHAR =~ s,\\[?],,g;
  
  sub _no_scheme_ok { 1 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?://([^/?\#]*))?(.*)$,os or die;
  
      if (@_) {
  	my $auth = shift;
  	$$self = $1;
  	my $rest = $3;
  	if (defined $auth) {
  	    $auth =~ s/([^$ACHAR])/ URI::Escape::escape_char($1)/ego;
  	    utf8::downgrade($auth);
  	    $$self .= "//$auth";
  	}
  	_check_path($rest, $$self);
  	$$self .= $rest;
      }
      $2;
  }
  
  sub path
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^?\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$PCHAR])/ URI::Escape::escape_char($1)/ego;
  	utf8::downgrade($new_path);
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub path_query
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
  	utf8::downgrade($new_path);
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub _check_path
  {
      my($path, $pre) = @_;
      my $prefix;
      if ($pre =~ m,/,) {  # authority present
  	$prefix = "/" if length($path) && $path !~ m,^[/?\#],;
      }
      else {
  	if ($path =~ m,^//,) {
  	    Carp::carp("Path starting with double slash is confusing")
  		if $^W;
  	}
  	elsif (!length($pre) && $path =~ m,^[^:/?\#]+:,) {
  	    Carp::carp("Path might look like scheme, './' prepended")
  		if $^W;
  	    $prefix = "./";
  	}
      }
      substr($_[0], 0, 0) = $prefix if defined $prefix;
  }
  
  sub path_segments
  {
      my $self = shift;
      my $path = $self->path;
      if (@_) {
  	my @arg = @_;  # make a copy
  	for (@arg) {
  	    if (ref($_)) {
  		my @seg = @$_;
  		$seg[0] =~ s/%/%25/g;
  		for (@seg) { s/;/%3B/g; }
  		$_ = join(";", @seg);
  	    }
  	    else {
  		 s/%/%25/g; s/;/%3B/g;
  	    }
  	    s,/,%2F,g;
  	}
  	$self->path(join("/", @arg));
      }
      return $path unless wantarray;
      map {/;/ ? $self->_split_segment($_)
               : uri_unescape($_) }
          split('/', $path, -1);
  }
  
  
  sub _split_segment
  {
      my $self = shift;
      require URI::_segment;
      URI::_segment->new(@_);
  }
  
  
  sub abs
  {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
  
      if (my $scheme = $self->scheme) {
  	return $self unless $URI::ABS_ALLOW_RELATIVE_SCHEME;
  	$base = URI->new($base) unless ref $base;
  	return $self unless $scheme eq $base->scheme;
      }
  
      $base = URI->new($base) unless ref $base;
      my $abs = $self->clone;
      $abs->scheme($base->scheme);
      return $abs if $$self =~ m,^(?:$URI::scheme_re:)?//,o;
      $abs->authority($base->authority);
  
      my $path = $self->path;
      return $abs if $path =~ m,^/,;
  
      if (!length($path)) {
  	my $abs = $base->clone;
  	my $query = $self->query;
  	$abs->query($query) if defined $query;
  	my $fragment = $self->fragment;
  	$abs->fragment($fragment) if defined $fragment;
  	return $abs;
      }
  
      my $p = $base->path;
      $p =~ s,[^/]+$,,;
      $p .= $path;
      my @p = split('/', $p, -1);
      shift(@p) if @p && !length($p[0]);
      my $i = 1;
      while ($i < @p) {
  	#print "$i ", join("/", @p), " ($p[$i])\n";
  	if ($p[$i-1] eq ".") {
  	    splice(@p, $i-1, 1);
  	    $i-- if $i > 1;
  	}
  	elsif ($p[$i] eq ".." && $p[$i-1] ne "..") {
  	    splice(@p, $i-1, 2);
  	    if ($i > 1) {
  		$i--;
  		push(@p, "") if $i == @p;
  	    }
  	}
  	else {
  	    $i++;
  	}
      }
      $p[-1] = "" if @p && $p[-1] eq ".";  # trailing "/."
      if ($URI::ABS_REMOTE_LEADING_DOTS) {
          shift @p while @p && $p[0] =~ /^\.\.?$/;
      }
      $abs->path("/" . join("/", @p));
      $abs;
  }
  
  # The opposite of $url->abs.  Return a URI which is as relative as possible
  sub rel {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
      my $rel = $self->clone;
      $base = URI->new($base) unless ref $base;
  
      #my($scheme, $auth, $path) = @{$rel}{qw(scheme authority path)};
      my $scheme = $rel->scheme;
      my $auth   = $rel->canonical->authority;
      my $path   = $rel->path;
  
      if (!defined($scheme) && !defined($auth)) {
  	# it is already relative
  	return $rel;
      }
  
      #my($bscheme, $bauth, $bpath) = @{$base}{qw(scheme authority path)};
      my $bscheme = $base->scheme;
      my $bauth   = $base->canonical->authority;
      my $bpath   = $base->path;
  
      for ($bscheme, $bauth, $auth) {
  	$_ = '' unless defined
      }
  
      unless ($scheme eq $bscheme && $auth eq $bauth) {
  	# different location, can't make it relative
  	return $rel;
      }
  
      for ($path, $bpath) {  $_ = "/$_" unless m,^/,; }
  
      # Make it relative by eliminating scheme and authority
      $rel->scheme(undef);
      $rel->authority(undef);
  
      # This loop is based on code from Nicolai Langfeldt <janl@ifi.uio.no>.
      # First we calculate common initial path components length ($li).
      my $li = 1;
      while (1) {
  	my $i = index($path, '/', $li);
  	last if $i < 0 ||
                  $i != index($bpath, '/', $li) ||
  	        substr($path,$li,$i-$li) ne substr($bpath,$li,$i-$li);
  	$li=$i+1;
      }
      # then we nuke it from both paths
      substr($path, 0,$li) = '';
      substr($bpath,0,$li) = '';
  
      if ($path eq $bpath &&
          defined($rel->fragment) &&
          !defined($rel->query)) {
          $rel->path("");
      }
      else {
          # Add one "../" for each path component left in the base path
          $path = ('../' x $bpath =~ tr|/|/|) . $path;
  	$path = "./" if $path eq "";
          $rel->path($path);
      }
  
      $rel;
  }
  
  1;
URI__GENERIC

$fatpacked{"URI/_idna.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__IDNA';
  package URI::_idna;
  
  # This module implements the RFCs 3490 (IDNA) and 3491 (Nameprep)
  # based on Python-2.6.4/Lib/encodings/idna.py
  
  use strict;
  use warnings;
  
  use URI::_punycode qw(encode_punycode decode_punycode);
  use Carp qw(croak);
  
  our $VERSION = '1.74';
  
  BEGIN {
    *URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS = "$]" < 5.008_003
      ? sub () { 1 }
      : sub () { 0 }
    ;
  }
  
  my $ASCII = qr/^[\x00-\x7F]*\z/;
  
  sub encode {
      my $idomain = shift;
      my @labels = split(/\./, $idomain, -1);
      my @last_empty;
      push(@last_empty, pop @labels) if @labels > 1 && $labels[-1] eq "";
      for (@labels) {
  	$_ = ToASCII($_);
      }
  
      return eval 'join(".", @labels, @last_empty)' if URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS;
      return join(".", @labels, @last_empty);
  }
  
  sub decode {
      my $domain = shift;
      return join(".", map ToUnicode($_), split(/\./, $domain, -1))
  }
  
  sub nameprep { # XXX real implementation missing
      my $label = shift;
      $label = lc($label);
      return $label;
  }
  
  sub check_size {
      my $label = shift;
      croak "Label empty" if $label eq "";
      croak "Label too long" if length($label) > 63;
      return $label;
  }
  
  sub ToASCII {
      my $label = shift;
      return check_size($label) if $label =~ $ASCII;
  
      # Step 2: nameprep
      $label = nameprep($label);
      # Step 3: UseSTD3ASCIIRules is false
      # Step 4: try ASCII again
      return check_size($label) if $label =~ $ASCII;
  
      # Step 5: Check ACE prefix
      if ($label =~ /^xn--/) {
          croak "Label starts with ACE prefix";
      }
  
      # Step 6: Encode with PUNYCODE
      $label = encode_punycode($label);
  
      # Step 7: Prepend ACE prefix
      $label = "xn--$label";
  
      # Step 8: Check size
      return check_size($label);
  }
  
  sub ToUnicode {
      my $label = shift;
      $label = nameprep($label) unless $label =~ $ASCII;
      return $label unless $label =~ /^xn--/;
      my $result = decode_punycode(substr($label, 4));
      my $label2 = ToASCII($result);
      if (lc($label) ne $label2) {
  	croak "IDNA does not round-trip: '\L$label\E' vs '$label2'";
      }
      return $result;
  }
  
  1;
URI__IDNA

$fatpacked{"URI/_ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::_ldap;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use URI::Escape qw(uri_unescape);
  
  sub _ldap_elem {
    my $self  = shift;
    my $elem  = shift;
    my $query = $self->query;
    my @bits  = (split(/\?/,defined($query) ? $query : ""),("")x4);
    my $old   = $bits[$elem];
  
    if (@_) {
      my $new = shift;
      $new =~ s/\?/%3F/g;
      $bits[$elem] = $new;
      $query = join("?",@bits);
      $query =~ s/\?+$//;
      $query = undef unless length($query);
      $self->query($query);
    }
  
    $old;
  }
  
  sub dn {
    my $old = shift->path(@_);
    $old =~ s:^/::;
    uri_unescape($old);
  }
  
  sub attributes {
    my $self = shift;
    my $old = _ldap_elem($self,0, @_ ? join(",", map { my $tmp = $_; $tmp =~ s/,/%2C/g; $tmp } @_) : ());
    return $old unless wantarray;
    map { uri_unescape($_) } split(/,/,$old);
  }
  
  sub _scope {
    my $self = shift;
    my $old = _ldap_elem($self,1, @_);
    return undef unless defined wantarray && defined $old;
    uri_unescape($old);
  }
  
  sub scope {
    my $old = &_scope;
    $old = "base" unless length $old;
    $old;
  }
  
  sub _filter {
    my $self = shift;
    my $old = _ldap_elem($self,2, @_);
    return undef unless defined wantarray && defined $old;
    uri_unescape($old); # || "(objectClass=*)";
  }
  
  sub filter {
    my $old = &_filter;
    $old = "(objectClass=*)" unless length $old;
    $old;
  }
  
  sub extensions {
    my $self = shift;
    my @ext;
    while (@_) {
      my $key = shift;
      my $value = shift;
      push(@ext, join("=", map { $_="" unless defined; s/,/%2C/g; $_ } $key, $value));
    }
    @ext = join(",", @ext) if @ext;
    my $old = _ldap_elem($self,3, @ext);
    return $old unless wantarray;
    map { uri_unescape($_) } map { /^([^=]+)=(.*)$/ } split(/,/,$old);
  }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->_nonldap_canonical;
  
      # The stuff below is not as efficient as one might hope...
  
      $other = $other->clone if $other == $self;
  
      $other->dn(_normalize_dn($other->dn));
  
      # Should really know about mixed case "postalAddress", etc...
      $other->attributes(map lc, $other->attributes);
  
      # Lowercase scope, remove default
      my $old_scope = $other->scope;
      my $new_scope = lc($old_scope);
      $new_scope = "" if $new_scope eq "base";
      $other->scope($new_scope) if $new_scope ne $old_scope;
  
      # Remove filter if default
      my $old_filter = $other->filter;
      $other->filter("") if lc($old_filter) eq "(objectclass=*)" ||
  	                  lc($old_filter) eq "objectclass=*";
  
      # Lowercase extensions types and deal with known extension values
      my @ext = $other->extensions;
      for (my $i = 0; $i < @ext; $i += 2) {
  	my $etype = $ext[$i] = lc($ext[$i]);
  	if ($etype =~ /^!?bindname$/) {
  	    $ext[$i+1] = _normalize_dn($ext[$i+1]);
  	}
      }
      $other->extensions(@ext) if @ext;
      
      $other;
  }
  
  sub _normalize_dn  # RFC 2253
  {
      my $dn = shift;
  
      return $dn;
      # The code below will fail if the "+" or "," is embedding in a quoted
      # string or simply escaped...
  
      my @dn = split(/([+,])/, $dn);
      for (@dn) {
  	s/^([a-zA-Z]+=)/lc($1)/e;
      }
      join("", @dn);
  }
  
  1;
URI__LDAP

$fatpacked{"URI/_login.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LOGIN';
  package URI::_login;
  
  use strict;
  use warnings;
  
  use parent qw(URI::_server URI::_userpass);
  
  our $VERSION = '1.74';
  
  # Generic terminal logins.  This is used as a base class for 'telnet',
  # 'tn3270', and 'rlogin' URL schemes.
  
  1;
URI__LOGIN

$fatpacked{"URI/_punycode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__PUNYCODE';
  package URI::_punycode;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use Exporter 'import';
  our @EXPORT = qw(encode_punycode decode_punycode);
  
  use integer;
  
  our $DEBUG = 0;
  
  use constant BASE => 36;
  use constant TMIN => 1;
  use constant TMAX => 26;
  use constant SKEW => 38;
  use constant DAMP => 700;
  use constant INITIAL_BIAS => 72;
  use constant INITIAL_N => 128;
  
  my $Delimiter = chr 0x2D;
  my $BasicRE   = qr/[\x00-\x7f]/;
  
  sub _croak { require Carp; Carp::croak(@_); }
  
  sub digit_value {
      my $code = shift;
      return ord($code) - ord("A") if $code =~ /[A-Z]/;
      return ord($code) - ord("a") if $code =~ /[a-z]/;
      return ord($code) - ord("0") + 26 if $code =~ /[0-9]/;
      return;
  }
  
  sub code_point {
      my $digit = shift;
      return $digit + ord('a') if 0 <= $digit && $digit <= 25;
      return $digit + ord('0') - 26 if 26 <= $digit && $digit <= 36;
      die 'NOT COME HERE';
  }
  
  sub adapt {
      my($delta, $numpoints, $firsttime) = @_;
      $delta = $firsttime ? $delta / DAMP : $delta / 2;
      $delta += $delta / $numpoints;
      my $k = 0;
      while ($delta > ((BASE - TMIN) * TMAX) / 2) {
  	$delta /= BASE - TMIN;
  	$k += BASE;
      }
      return $k + (((BASE - TMIN + 1) * $delta) / ($delta + SKEW));
  }
  
  sub decode_punycode {
      my $code = shift;
  
      my $n      = INITIAL_N;
      my $i      = 0;
      my $bias   = INITIAL_BIAS;
      my @output;
  
      if ($code =~ s/(.*)$Delimiter//o) {
  	push @output, map ord, split //, $1;
  	return _croak('non-basic code point') unless $1 =~ /^$BasicRE*$/o;
      }
  
      while ($code) {
  	my $oldi = $i;
  	my $w    = 1;
      LOOP:
  	for (my $k = BASE; 1; $k += BASE) {
  	    my $cp = substr($code, 0, 1, '');
  	    my $digit = digit_value($cp);
  	    defined $digit or return _croak("invalid punycode input");
  	    $i += $digit * $w;
  	    my $t = ($k <= $bias) ? TMIN
  		: ($k >= $bias + TMAX) ? TMAX : $k - $bias;
  	    last LOOP if $digit < $t;
  	    $w *= (BASE - $t);
  	}
  	$bias = adapt($i - $oldi, @output + 1, $oldi == 0);
  	warn "bias becomes $bias" if $DEBUG;
  	$n += $i / (@output + 1);
  	$i = $i % (@output + 1);
  	splice(@output, $i, 0, $n);
  	warn join " ", map sprintf('%04x', $_), @output if $DEBUG;
  	$i++;
      }
      return join '', map chr, @output;
  }
  
  sub encode_punycode {
      my $input = shift;
      my @input = split //, $input;
  
      my $n     = INITIAL_N;
      my $delta = 0;
      my $bias  = INITIAL_BIAS;
  
      my @output;
      my @basic = grep /$BasicRE/, @input;
      my $h = my $b = @basic;
      push @output, @basic;
      push @output, $Delimiter if $b && $h < @input;
      warn "basic codepoints: (@output)" if $DEBUG;
  
      while ($h < @input) {
  	my $m = min(grep { $_ >= $n } map ord, @input);
  	warn sprintf "next code point to insert is %04x", $m if $DEBUG;
  	$delta += ($m - $n) * ($h + 1);
  	$n = $m;
  	for my $i (@input) {
  	    my $c = ord($i);
  	    $delta++ if $c < $n;
  	    if ($c == $n) {
  		my $q = $delta;
  	    LOOP:
  		for (my $k = BASE; 1; $k += BASE) {
  		    my $t = ($k <= $bias) ? TMIN :
  			($k >= $bias + TMAX) ? TMAX : $k - $bias;
  		    last LOOP if $q < $t;
  		    my $cp = code_point($t + (($q - $t) % (BASE - $t)));
  		    push @output, chr($cp);
  		    $q = ($q - $t) / (BASE - $t);
  		}
  		push @output, chr(code_point($q));
  		$bias = adapt($delta, $h + 1, $h == $b);
  		warn "bias becomes $bias" if $DEBUG;
  		$delta = 0;
  		$h++;
  	    }
  	}
  	$delta++;
  	$n++;
      }
      return join '', @output;
  }
  
  sub min {
      my $min = shift;
      for (@_) { $min = $_ if $_ <= $min }
      return $min;
  }
  
  1;
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  URI::_punycode - encodes Unicode string in Punycode
  
  =head1 SYNOPSIS
  
    use strict;
    use warnings;
    use utf8;
  
    use URI::_punycode qw(encode_punycode decode_punycode);
  
    # encode a unicode string
    my $punycode = encode_punycode('http://☃.net'); # http://.net-xc8g
    $punycode = encode_punycode('bücher'); # bcher-kva
    $punycode = encode_punycode('他们为什么不说中文'); # ihqwcrb4cv8a8dqg056pqjye
  
    # decode a punycode string back into a unicode string
    my $unicode = decode_punycode('http://.net-xc8g'); # http://☃.net
    $unicode = decode_punycode('bcher-kva'); # bücher
    $unicode = decode_punycode('ihqwcrb4cv8a8dqg056pqjye'); # 他们为什么不说中文
  
  =head1 DESCRIPTION
  
  L<URI::_punycode> is a module to encode / decode Unicode strings into
  L<Punycode|https://tools.ietf.org/html/rfc3492>, an efficient
  encoding of Unicode for use with L<IDNA|https://tools.ietf.org/html/rfc5890>.
  
  =head1 FUNCTIONS
  
  All functions throw exceptions on failure. You can C<catch> them with
  L<Syntax::Keyword::Try> or L<Try::Tiny>. The following functions are exported
  by default.
  
  =head2 encode_punycode
  
    my $punycode = encode_punycode('http://☃.net');  # http://.net-xc8g
    $punycode = encode_punycode('bücher'); # bcher-kva
    $punycode = encode_punycode('他们为什么不说中文') # ihqwcrb4cv8a8dqg056pqjye
  
  Takes a Unicode string (UTF8-flagged variable) and returns a Punycode
  encoding for it.
  
  =head2 decode_punycode
  
    my $unicode = decode_punycode('http://.net-xc8g'); # http://☃.net
    $unicode = decode_punycode('bcher-kva'); # bücher
    $unicode = decode_punycode('ihqwcrb4cv8a8dqg056pqjye'); # 他们为什么不说中文
  
  Takes a Punycode encoding and returns original Unicode string.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa <F<miyagawa@bulknews.net>> is the author of
  L<IDNA::Punycode> which was the basis for this module.
  
  =head1 SEE ALSO
  
  L<IDNA::Punycode>, L<RFC 3492|https://tools.ietf.org/html/rfc3492>,
  L<RFC 5891|https://tools.ietf.org/html/rfc5891>
  
  =head1 COPYRIGHT AND LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
URI__PUNYCODE

$fatpacked{"URI/_query.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__QUERY';
  package URI::_query;
  
  use strict;
  use warnings;
  
  use URI ();
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub query
  {
      my $self = shift;
      $$self =~ m,^([^?\#]*)(?:\?([^\#]*))?(.*)$,s or die;
  
      if (@_) {
  	my $q = shift;
  	$$self = $1;
  	if (defined $q) {
  	    $q =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
  	    utf8::downgrade($q);
  	    $$self .= "?$q";
  	}
  	$$self .= $3;
      }
      $2;
  }
  
  # Handle ...?foo=bar&bar=foo type of query
  sub query_form {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
          my $delim;
          my $r = $_[0];
          if (ref($r) eq "ARRAY") {
              $delim = $_[1];
              @_ = @$r;
          }
          elsif (ref($r) eq "HASH") {
              $delim = $_[1];
              @_ = map { $_ => $r->{$_} } sort keys %$r;
          }
          $delim = pop if @_ % 2;
  
          my @query;
          while (my($key,$vals) = splice(@_, 0, 2)) {
              $key = '' unless defined $key;
  	    $key =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;
  	    $key =~ s/ /+/g;
  	    $vals = [ref($vals) eq "ARRAY" ? @$vals : $vals];
              for my $val (@$vals) {
                  $val = '' unless defined $val;
  		$val =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;
                  $val =~ s/ /+/g;
                  push(@query, "$key=$val");
              }
          }
          if (@query) {
              unless ($delim) {
                  $delim = $1 if $old && $old =~ /([&;])/;
                  $delim ||= $URI::DEFAULT_QUERY_FORM_DELIMITER || "&";
              }
              $self->query(join($delim, @query));
          }
          else {
              $self->query(undef);
          }
      }
      return if !defined($old) || !length($old) || !defined(wantarray);
      return unless $old =~ /=/; # not a form
      map { s/\+/ /g; uri_unescape($_) }
           map { /=/ ? split(/=/, $_, 2) : ($_ => '')} split(/[&;]/, $old);
  }
  
  # Handle ...?dog+bones type of query
  sub query_keywords
  {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
  	my @copy = @_;
  	@copy = @{$copy[0]} if @copy == 1 && ref($copy[0]) eq "ARRAY";
  	for (@copy) { s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg; }
  	$self->query(@copy ? join('+', @copy) : undef);
      }
      return if !defined($old) || !defined(wantarray);
      return if $old =~ /=/;  # not keywords, but a form
      map { uri_unescape($_) } split(/\+/, $old, -1);
  }
  
  # Some URI::URL compatibility stuff
  sub equery { goto &query }
  
  1;
URI__QUERY

$fatpacked{"URI/_segment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SEGMENT';
  package URI::_segment;
  
  # Represents a generic path_segment so that it can be treated as
  # a string too.
  
  use strict;
  use warnings;
  
  use URI::Escape qw(uri_unescape);
  
  use overload '""' => sub { $_[0]->[0] },
               fallback => 1;
  
  our $VERSION = '1.74';
  
  sub new
  {
      my $class = shift;
      my @segment = split(';', shift, -1);
      $segment[0] = uri_unescape($segment[0]);
      bless \@segment, $class;
  }
  
  1;
URI__SEGMENT

$fatpacked{"URI/_server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SERVER';
  package URI::_server;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub _uric_escape {
      my($class, $str) = @_;
      if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os) {
  	my($scheme, $host, $rest) = ($1, $2, $3);
  	my $ui = $host =~ s/(.*@)// ? $1 : "";
  	my $port = $host =~ s/(:\d+)\z// ? $1 : "";
  	if (_host_escape($host)) {
  	    $str = "$scheme//$ui$host$port$rest";
  	}
      }
      return $class->SUPER::_uric_escape($str);
  }
  
  sub _host_escape {
      return unless $_[0] =~ /[^$URI::uric]/;
      eval {
  	require URI::_idna;
  	$_[0] = URI::_idna::encode($_[0]);
      };
      return 0 if $@;
      return 1;
  }
  
  sub as_iri {
      my $self = shift;
      my $str = $self->SUPER::as_iri;
      if ($str =~ /\bxn--/) {
  	if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os) {
  	    my($scheme, $host, $rest) = ($1, $2, $3);
  	    my $ui = $host =~ s/(.*@)// ? $1 : "";
  	    my $port = $host =~ s/(:\d+)\z// ? $1 : "";
  	    require URI::_idna;
  	    $host = URI::_idna::decode($host);
  	    $str = "$scheme//$ui$host$port$rest";
  	}
      }
      return $str;
  }
  
  sub userinfo
  {
      my $self = shift;
      my $old = $self->authority;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/.*@//;  # remove old stuff
  	my $ui = shift;
  	if (defined $ui) {
  	    $ui =~ s/@/%40/g;   # protect @
  	    $new = "$ui\@$new";
  	}
  	$self->authority($new);
      }
      return undef if !defined($old) || $old !~ /(.*)@/;
      return $1;
  }
  
  sub host
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $tmp = $old;
  	$tmp = "" unless defined $tmp;
  	my $ui = ($tmp =~ /(.*@)/) ? $1 : "";
  	my $port = ($tmp =~ /(:\d+)$/) ? $1 : "";
  	my $new = shift;
  	$new = "" unless defined $new;
  	if (length $new) {
  	    $new =~ s/[@]/%40/g;   # protect @
  	    if ($new =~ /^[^:]*:\d*\z/ || $new =~ /]:\d*\z/) {
  		$new =~ s/(:\d*)\z// || die "Assert";
  		$port = $1;
  	    }
  	    $new = "[$new]" if $new =~ /:/ && $new !~ /^\[/; # IPv6 address
  	    _host_escape($new);
  	}
  	$self->authority("$ui$new$port");
      }
      return undef unless defined $old;
      $old =~ s/.*@//;
      $old =~ s/:\d+$//;          # remove the port
      $old =~ s{^\[(.*)\]$}{$1};  # remove brackets around IPv6 (RFC 3986 3.2.2)
      return uri_unescape($old);
  }
  
  sub ihost
  {
      my $self = shift;
      my $old = $self->host(@_);
      if ($old =~ /(^|\.)xn--/) {
  	require URI::_idna;
  	$old = URI::_idna::decode($old);
      }
      return $old;
  }
  
  sub _port
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $new = $old;
  	$new =~ s/:\d*$//;
  	my $port = shift;
  	$new .= ":$port" if defined $port;
  	$self->authority($new);
      }
      return $1 if defined($old) && $old =~ /:(\d*)$/;
      return;
  }
  
  sub port
  {
      my $self = shift;
      my $port = $self->_port(@_);
      $port = $self->default_port if !defined($port) || $port eq "";
      $port;
  }
  
  sub host_port
  {
      my $self = shift;
      my $old = $self->authority;
      $self->host(shift) if @_;
      return undef unless defined $old;
      $old =~ s/.*@//;        # zap userinfo
      $old =~ s/:$//;         # empty port should be treated the same a no port
      $old .= ":" . $self->port unless $old =~ /:\d+$/;
      $old;
  }
  
  
  sub default_port { undef }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
      my $host = $other->host || "";
      my $port = $other->_port;
      my $uc_host = $host =~ /[A-Z]/;
      my $def_port = defined($port) && ($port eq "" ||
                                        $port == $self->default_port);
      if ($uc_host || $def_port) {
  	$other = $other->clone if $other == $self;
  	$other->host(lc $host) if $uc_host;
  	$other->port(undef)    if $def_port;
      }
      $other;
  }
  
  1;
URI__SERVER

$fatpacked{"URI/_userpass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__USERPASS';
  package URI::_userpass;
  
  use strict;
  use warnings;
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub user
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $pass = defined($info) ? $info : "";
  	$pass =~ s/^[^:]*//;
  
  	if (!defined($new) && !length($pass)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $new =~ s/:/%3A/g;
  	    $self->userinfo("$new$pass");
  	}
      }
      return undef unless defined $info;
      $info =~ s/:.*//;
      uri_unescape($info);
  }
  
  sub password
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $user = defined($info) ? $info : "";
  	$user =~ s/:.*//;
  
  	if (!defined($new) && !length($user)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $self->userinfo("$user:$new");
  	}
      }
      return undef unless defined $info;
      return undef unless $info =~ s/^[^:]*://;
      uri_unescape($info);
  }
  
  1;
URI__USERPASS

$fatpacked{"URI/data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_DATA';
  package URI::data;  # RFC 2397
  
  use strict;
  use warnings;
  
  use parent 'URI';
  
  our $VERSION = '1.74';
  
  use MIME::Base64 qw(encode_base64 decode_base64);
  use URI::Escape  qw(uri_unescape);
  
  sub media_type
  {
      my $self = shift;
      my $opaque = $self->opaque;
      $opaque =~ /^([^,]*),?/ or die;
      my $old = $1;
      my $base64;
      $base64 = $1 if $old =~ s/(;base64)$//i;
      if (@_) {
  	my $new = shift;
  	$new = "" unless defined $new;
  	$new =~ s/%/%25/g;
  	$new =~ s/,/%2C/g;
  	$base64 = "" unless defined $base64;
  	$opaque =~ s/^[^,]*,?/$new$base64,/;
  	$self->opaque($opaque);
      }
      return uri_unescape($old) if $old;  # media_type can't really be "0"
      "text/plain;charset=US-ASCII";      # default type
  }
  
  sub data
  {
      my $self = shift;
      my($enc, $data) = split(",", $self->opaque, 2);
      unless (defined $data) {
  	$data = "";
  	$enc  = "" unless defined $enc;
      }
      my $base64 = ($enc =~ /;base64$/i);
      if (@_) {
  	$enc =~ s/;base64$//i if $base64;
  	my $new = shift;
  	$new = "" unless defined $new;
  	my $uric_count = _uric_count($new);
  	my $urienc_len = $uric_count + (length($new) - $uric_count) * 3;
  	my $base64_len = int((length($new)+2) / 3) * 4;
  	$base64_len += 7;  # because of ";base64" marker
  	if ($base64_len < $urienc_len || $_[0]) {
  	    $enc .= ";base64";
  	    $new = encode_base64($new, "");
  	} else {
  	    $new =~ s/%/%25/g;
  	}
  	$self->opaque("$enc,$new");
      }
      return unless defined wantarray;
      $data = uri_unescape($data);
      return $base64 ? decode_base64($data) : $data;
  }
  
  # I could not find a better way to interpolate the tr/// chars from
  # a variable.
  my $ENC = $URI::uric;
  $ENC =~ s/%//;
  
  eval <<EOT; die $@ if $@;
  sub _uric_count
  {
      \$_[0] =~ tr/$ENC//;
  }
  EOT
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::data - URI that contains immediate data
  
  =head1 SYNOPSIS
  
   use URI;
  
   $u = URI->new("data:");
   $u->media_type("image/gif");
   $u->data(scalar(`cat camel.gif`));
   print "$u\n";
   open(XV, "|xv -") and print XV $u->data;
  
  =head1 DESCRIPTION
  
  The C<URI::data> class supports C<URI> objects belonging to the I<data>
  URI scheme.  The I<data> URI scheme is specified in RFC 2397.  It
  allows inclusion of small data items as "immediate" data, as if it had
  been included externally.  Examples:
  
    data:,Perl%20is%20good
  
    data:image/gif;base64,R0lGODdhIAAgAIAAAAAAAPj8+CwAAAAAI
      AAgAAAClYyPqcu9AJyCjtIKc5w5xP14xgeO2tlY3nWcajmZZdeJcG
      Kxrmimms1KMTa1Wg8UROx4MNUq1HrycMjHT9b6xKxaFLM6VRKzI+p
      KS9XtXpcbdun6uWVxJXA8pNPkdkkxhxc21LZHFOgD2KMoQXa2KMWI
      JtnE2KizVUkYJVZZ1nczBxXlFopZBtoJ2diXGdNUymmJdFMAADs=
  
  
  
  C<URI> objects belonging to the data scheme support the common methods
  (described in L<URI>) and the following two scheme-specific methods:
  
  =over 4
  
  =item $uri->media_type( [$new_media_type] )
  
  Can be used to get or set the media type specified in the
  URI.  If no media type is specified, then the default
  C<"text/plain;charset=US-ASCII"> is returned.
  
  =item $uri->data( [$new_data] )
  
  Can be used to get or set the data contained in the URI.
  The data is passed unescaped (in binary form).  The decision about
  whether to base64 encode the data in the URI is taken automatically,
  based on the encoding that produces the shorter URI string.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_DATA

$fatpacked{"URI/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE';
  package URI::file;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  our $VERSION = "4.21";
  
  use URI::Escape qw(uri_unescape);
  
  our $DEFAULT_AUTHORITY = "";
  
  # Map from $^O values to implementation classes.  The Unix
  # class is the default.
  our %OS_CLASS = (
       os2     => "OS2",
       mac     => "Mac",
       MacOS   => "Mac",
       MSWin32 => "Win32",
       win32   => "Win32",
       msdos   => "FAT",
       dos     => "FAT",
       qnx     => "QNX",
  );
  
  sub os_class
  {
      my($OS) = shift || $^O;
  
      my $class = "URI::file::" . ($OS_CLASS{$OS} || "Unix");
      no strict 'refs';
      unless (%{"$class\::"}) {
  	eval "require $class";
  	die $@ if $@;
      }
      $class;
  }
  
  sub host { uri_unescape(shift->authority(@_)) }
  
  sub new
  {
      my($class, $path, $os) = @_;
      os_class($os)->new($path);
  }
  
  sub new_abs
  {
      my $class = shift;
      my $file = $class->new(@_);
      return $file->abs($class->cwd) unless $$file =~ /^file:/;
      $file;
  }
  
  sub cwd
  {
      my $class = shift;
      require Cwd;
      my $cwd = Cwd::cwd();
      $cwd = VMS::Filespec::unixpath($cwd) if $^O eq 'VMS';
      $cwd = $class->new($cwd);
      $cwd .= "/" unless substr($cwd, -1, 1) eq "/";
      $cwd;
  }
  
  sub canonical {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $scheme = $other->scheme;
      my $auth = $other->authority;
      return $other if !defined($scheme) && !defined($auth);  # relative
  
      if (!defined($auth) ||
  	$auth eq "" ||
  	lc($auth) eq "localhost" ||
  	(defined($DEFAULT_AUTHORITY) && lc($auth) eq lc($DEFAULT_AUTHORITY))
         )
      {
  	# avoid cloning if $auth already match
  	if ((defined($auth) || defined($DEFAULT_AUTHORITY)) &&
  	    (!defined($auth) || !defined($DEFAULT_AUTHORITY) || $auth ne $DEFAULT_AUTHORITY)
  	   )
  	{
  	    $other = $other->clone if $self == $other;
  	    $other->authority($DEFAULT_AUTHORITY);
          }
      }
  
      $other;
  }
  
  sub file
  {
      my($self, $os) = @_;
      os_class($os)->file($self);
  }
  
  sub dir
  {
      my($self, $os) = @_;
      os_class($os)->dir($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::file - URI that maps to local file names
  
  =head1 SYNOPSIS
  
   use URI::file;
   
   $u1 = URI->new("file:/foo/bar");
   $u2 = URI->new("foo/bar", "file");
   
   $u3 = URI::file->new($path);
   $u4 = URI::file->new("c:\\windows\\", "win32");
   
   $u1->file;
   $u1->file("mac");
  
  =head1 DESCRIPTION
  
  The C<URI::file> class supports C<URI> objects belonging to the I<file>
  URI scheme.  This scheme allows us to map the conventional file names
  found on various computer systems to the URI name space.  An old
  specification of the I<file> URI scheme is found in RFC 1738.  Some
  older background information is also in RFC 1630. There are no newer
  specifications as far as I know.
  
  If you simply want to construct I<file> URI objects from URI strings,
  use the normal C<URI> constructor.  If you want to construct I<file>
  URI objects from the actual file names used by various systems, then
  use one of the following C<URI::file> constructors:
  
  =over 4
  
  =item $u = URI::file->new( $filename, [$os] )
  
  Maps a file name to the I<file:> URI name space, creates a URI object
  and returns it.  The $filename is interpreted as belonging to the
  indicated operating system ($os), which defaults to the value of the
  $^O variable.  The $filename can be either absolute or relative, and
  the corresponding type of URI object for $os is returned.
  
  =item $u = URI::file->new_abs( $filename, [$os] )
  
  Same as URI::file->new, but makes sure that the URI returned
  represents an absolute file name.  If the $filename argument is
  relative, then the name is resolved relative to the current directory,
  i.e. this constructor is really the same as:
  
    URI::file->new($filename)->abs(URI::file->cwd);
  
  =item $u = URI::file->cwd
  
  Returns a I<file> URI that represents the current working directory.
  See L<Cwd>.
  
  =back
  
  The following methods are supported for I<file> URI (in addition to
  the common and generic methods described in L<URI>):
  
  =over 4
  
  =item $u->file( [$os] )
  
  Returns a file name.  It maps from the URI name space
  to the file name space of the indicated operating system.
  
  It might return C<undef> if the name can not be represented in the
  indicated file system.
  
  =item $u->dir( [$os] )
  
  Some systems use a different form for names of directories than for plain
  files.  Use this method if you know you want to use the name for
  a directory.
  
  =back
  
  The C<URI::file> module can be used to map generic file names to names
  suitable for the current system.  As such, it can work as a nice
  replacement for the C<File::Spec> module.  For instance, the following
  code translates the UNIX-style file name F<Foo/Bar.pm> to a name
  suitable for the local system:
  
    $file = URI::file->new("Foo/Bar.pm", "unix")->file;
    die "Can't map filename Foo/Bar.pm for $^O" unless defined $file;
    open(FILE, $file) || die "Can't open '$file': $!";
    # do something with FILE
  
  =head1 MAPPING NOTES
  
  Most computer systems today have hierarchically organized file systems.
  Mapping the names used in these systems to the generic URI syntax
  allows us to work with relative file URIs that behave as they should
  when resolved using the generic algorithm for URIs (specified in RFC
  2396).  Mapping a file name to the generic URI syntax involves mapping
  the path separator character to "/" and encoding any reserved
  characters that appear in the path segments of the file name.  If
  path segments consisting of the strings "." or ".." have a
  different meaning than what is specified for generic URIs, then these
  must be encoded as well.
  
  If the file system has device, volume or drive specifications as
  the root of the name space, then it makes sense to map them to the
  authority field of the generic URI syntax.  This makes sure that
  relative URIs can not be resolved "above" them, i.e. generally how
  relative file names work in those systems.
  
  Another common use of the authority field is to encode the host on which
  this file name is valid.  The host name "localhost" is special and
  generally has the same meaning as a missing or empty authority
  field.  This use is in conflict with using it as a device
  specification, but can often be resolved for device specifications
  having characters not legal in plain host names.
  
  File name to URI mapping in normally not one-to-one.  There are
  usually many URIs that map to any given file name.  For instance, an
  authority of "localhost" maps the same as a URI with a missing or empty
  authority.
  
  Example 1: The Mac classic (Mac OS 9 and earlier) used ":" as path separator,
  but not in the same way as a generic URI. ":foo" was a relative name.  "foo:bar"
  was an absolute name.  Also, path segments could contain the "/" character as well
  as the literal "." or "..".  So the mapping looks like this:
  
    Mac classic           URI
    ----------            -------------------
    :foo:bar     <==>     foo/bar
    :            <==>     ./
    ::foo:bar    <==>     ../foo/bar
    :::          <==>     ../../
    foo:bar      <==>     file:/foo/bar
    foo:bar:     <==>     file:/foo/bar/
    ..           <==>     %2E%2E
    <undef>      <==      /
    foo/         <==      file:/foo%2F
    ./foo.txt    <==      file:/.%2Ffoo.txt
  
  Note that if you want a relative URL, you *must* begin the path with a :.  Any
  path that begins with [^:] is treated as absolute.
  
  Example 2: The UNIX file system is easy to map, as it uses the same path
  separator as URIs, has a single root, and segments of "." and ".."
  have the same meaning.  URIs that have the character "\0" or "/" as
  part of any path segment can not be turned into valid UNIX file names.
  
    UNIX                  URI
    ----------            ------------------
    foo/bar      <==>     foo/bar
    /foo/bar     <==>     file:/foo/bar
    /foo/bar     <==      file://localhost/foo/bar
    file:         ==>     ./file:
    <undef>      <==      file:/fo%00/bar
    /            <==>     file:/
  
  =cut
  
  
  RFC 1630
  
     [...]
  
     There is clearly a danger of confusion that a link made to a local
     file should be followed by someone on a different system, with
     unexpected and possibly harmful results.  Therefore, the convention
     is that even a "file" URL is provided with a host part.  This allows
     a client on another system to know that it cannot access the file
     system, or perhaps to use some other local mechanism to access the
     file.
  
     The special value "localhost" is used in the host field to indicate
     that the filename should really be used on whatever host one is.
     This for example allows links to be made to files which are
     distributed on many machines, or to "your unix local password file"
     subject of course to consistency across the users of the data.
  
     A void host field is equivalent to "localhost".
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over
  
  =item %URI::file::OS_CLASS
  
  This hash maps OS identifiers to implementation classes.  You might
  want to add or modify this if you want to plug in your own file
  handler class.  Normally the keys should match the $^O values in use.
  
  If there is no mapping then the "Unix" implementation is used.
  
  =item $URI::file::DEFAULT_AUTHORITY
  
  This determine what "authority" string to include in absolute file
  URIs.  It defaults to "".  If you prefer verbose URIs you might set it
  to be "localhost".
  
  Setting this value to C<undef> force behaviour compatible to URI v1.31
  and earlier.  In this mode host names in UNC paths and drive letters
  are mapped to the authority component on Windows, while we produce
  authority-less URIs on Unix.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>, L<File::Spec>, L<perlport>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998,2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_FILE

$fatpacked{"URI/file/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_BASE';
  package URI::file::Base;
  
  use strict;
  use warnings;
  
  use URI::Escape qw();
  
  our $VERSION = '1.74';
  
  sub new
  {
      my $class = shift;
      my $path  = shift;
      $path = "" unless defined $path;
  
      my($auth, $escaped_auth, $escaped_path);
  
      ($auth, $escaped_auth) = $class->_file_extract_authority($path);
      ($path, $escaped_path) = $class->_file_extract_path($path);
  
      if (defined $auth) {
  	$auth =~ s,%,%25,g unless $escaped_auth;
  	$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;
  	$auth = "//$auth";
  	if (defined $path) {
  	    $path = "/$path" unless substr($path, 0, 1) eq "/";
  	} else {
  	    $path = "";
  	}
      } else {
  	return undef unless defined $path;
  	$auth = "";
      }
  
      $path =~ s,([%;?]), URI::Escape::escape_char($1),eg unless $escaped_path;
      $path =~ s/\#/%23/g;
  
      my $uri = $auth . $path;
      $uri = "file:$uri" if substr($uri, 0, 1) eq "/";
  
      URI->new($uri, "file");
  }
  
  sub _file_extract_authority
  {
      my($class, $path) = @_;
      return undef unless $class->_file_is_absolute($path);
      return $URI::file::DEFAULT_AUTHORITY;
  }
  
  sub _file_extract_path
  {
      return undef;
  }
  
  sub _file_is_absolute
  {
      return 0;
  }
  
  sub _file_is_localhost
  {
      shift; # class
      my $host = lc(shift);
      return 1 if $host eq "localhost";
      eval {
  	require Net::Domain;
  	lc(Net::Domain::hostfqdn() || '') eq $host ||
  	lc(Net::Domain::hostname() || '') eq $host;
      };
  }
  
  sub file
  {
      undef;
  }
  
  sub dir
  {
      my $self = shift;
      $self->file(@_);
  }
  
  1;
URI_FILE_BASE

$fatpacked{"URI/file/FAT.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_FAT';
  package URI::file::FAT;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Win32';
  
  our $VERSION = '1.74';
  
  sub fix_path
  {
      shift; # class
      for (@_) {
  	# turn it into 8.3 names
  	my @p = map uc, split(/\./, $_, -1);
  	return if @p > 2;     # more than 1 dot is not allowed
  	@p = ("") unless @p;  # split bug? (returns nothing when splitting "")
  	$_ = substr($p[0], 0, 8);
          if (@p > 1) {
  	    my $ext = substr($p[1], 0, 3);
  	    $_ .= ".$ext" if length $ext;
  	}
      }
      1;  # ok
  }
  
  1;
URI_FILE_FAT

$fatpacked{"URI/file/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_MAC';
  package URI::file::Mac;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub _file_extract_path
  {
      my $class = shift;
      my $path = shift;
  
      my @pre;
      if ($path =~ s/^(:+)//) {
  	if (length($1) == 1) {
  	    @pre = (".") unless length($path);
  	} else {
  	    @pre = ("..") x (length($1) - 1);
  	}
      } else { #absolute
  	$pre[0] = "";
      }
  
      my $isdir = ($path =~ s/:$//);
      $path =~ s,([%/;]), URI::Escape::escape_char($1),eg;
  
      my @path = split(/:/, $path, -1);
      for (@path) {
  	if ($_ eq "." || $_ eq "..") {
  	    $_ = "%2E" x length($_);
  	}
  	$_ = ".." unless length($_);
      }
      push (@path,"") if $isdir;
      (join("/", @pre, @path), 1);
  }
  
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined $auth) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    my $u_auth = uri_unescape($auth);
  	    if (!$class->_file_is_localhost($u_auth)) {
  		# some other host (use it as volume name)
  		@path = ("", $auth);
  		# XXX or just return to make it illegal;
  	    }
  	}
      }
      my @ps = split("/", $uri->path, -1);
      shift @ps if @path;
      push(@path, @ps);
  
      my $pre = "";
      if (!@path) {
  	return;  # empty path; XXX return ":" instead?
      } elsif ($path[0] eq "") {
  	# absolute
  	shift(@path);
  	if (@path == 1) {
  	    return if $path[0] eq "";  # not root directory
  	    push(@path, "");           # volume only, effectively append ":"
  	}
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      } else {
  	$pre = ":";
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      }
      return unless $pre || @path;
      for (@path) {
  	s/;.*//;  # get rid of parameters
  	#return unless length; # XXX
  	$_ = uri_unescape($_);
  	return if /\0/;
  	return if /:/;  # Should we?
      }
      $pre . join(":", @path);
  }
  
  sub dir
  {
      my $class = shift;
      my $path = $class->file(@_);
      return unless defined $path;
      $path .= ":" unless $path =~ /:$/;
      $path;
  }
  
  1;
URI_FILE_MAC

$fatpacked{"URI/file/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_OS2';
  package URI::file::OS2;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Win32';
  
  our $VERSION = '1.74';
  
  # The Win32 version translates k:/foo to file://k:/foo  (?!)
  # We add an empty host
  
  sub _file_extract_authority
  {
      my $class = shift;
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ m#^[a-zA-Z]{1,2}:#) {	      # allow for ab: drives
  	return "";
      }
      return;
  }
  
  sub file {
    my $p = &URI::file::Win32::file;
    return unless defined $p;
    $p =~ s,\\,/,g;
    $p;
  }
  
  1;
URI_FILE_OS2

$fatpacked{"URI/file/QNX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_QNX';
  package URI::file::QNX;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Unix';
  
  our $VERSION = '1.74';
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      # tidy path
      $path =~ s,(.)//+,$1/,g; # ^// is correct
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
      $path;
  }
  
  1;
URI_FILE_QNX

$fatpacked{"URI/file/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_UNIX';
  package URI::file::Unix;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
  
      # tidy path
      $path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^/,;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined($auth)) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    $auth = uri_unescape($auth);
  	    unless ($class->_file_is_localhost($auth)) {
  		push(@path, "", "", $auth);
  	    }
  	}
      }
  
      my @ps = $uri->path_segments;
      shift @ps if @path;
      push(@path, @ps);
  
      for (@path) {
  	# Unix file/directory names are not allowed to contain '\0' or '/'
  	return undef if /\0/;
  	return undef if /\//;  # should we really?
      }
  
      return join("/", @path);
  }
  
  1;
URI_FILE_UNIX

$fatpacked{"URI/file/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_WIN32';
  package URI::file::Win32;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub _file_extract_authority
  {
      my $class = shift;
  
      return $class->SUPER::_file_extract_authority($_[0])
  	if defined $URI::file::DEFAULT_AUTHORITY;
  
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ s,^([a-zA-Z]:),,) {
  	my $auth = $1;
  	$auth .= "relative" if $_[0] !~ m,^[\\/],;
  	return $auth;
      }
      return undef;
  }
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      $path =~ s,\\,/,g;
      #$path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
  
      if (defined $URI::file::DEFAULT_AUTHORITY) {
  	$path =~ s,^([a-zA-Z]:),/$1,;
      }
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^[a-zA-Z]:, || $path =~ m,^[/\\],;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my $auth = $uri->authority;
      my $rel; # is filename relative to drive specified in authority
      if (defined $auth) {
          $auth = uri_unescape($auth);
  	if ($auth =~ /^([a-zA-Z])[:|](relative)?/) {
  	    $auth = uc($1) . ":";
  	    $rel++ if $2;
  	} elsif (lc($auth) eq "localhost") {
  	    $auth = "";
  	} elsif (length $auth) {
  	    $auth = "\\\\" . $auth;  # UNC
  	}
      } else {
  	$auth = "";
      }
  
      my @path = $uri->path_segments;
      for (@path) {
  	return undef if /\0/;
  	return undef if /\//;
  	#return undef if /\\/;        # URLs with "\" is not uncommon
      }
      return undef unless $class->fix_path(@path);
  
      my $path = join("\\", @path);
      $path =~ s/^\\// if $rel;
      $path = $auth . $path;
      $path =~ s,^\\([a-zA-Z])[:|],\u$1:,;
  
      return $path;
  }
  
  sub fix_path { 1; }
  
  1;
URI_FILE_WIN32

$fatpacked{"URI/ftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FTP';
  package URI::ftp;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent qw(URI::_server URI::_userpass);
  
  sub default_port { 21 }
  
  sub path { shift->path_query(@_) }  # XXX
  
  sub _user     { shift->SUPER::user(@_);     }
  sub _password { shift->SUPER::password(@_); }
  
  sub user
  {
      my $self = shift;
      my $user = $self->_user(@_);
      $user = "anonymous" unless defined $user;
      $user;
  }
  
  sub password
  {
      my $self = shift;
      my $pass = $self->_password(@_);
      unless (defined $pass) {
  	my $user = $self->user;
  	if ($user eq 'anonymous' || $user eq 'ftp') {
  	    # anonymous ftp login password
              # If there is no ftp anonymous password specified
              # then we'll just use 'anonymous@'
              # We don't try to send the read e-mail address because:
              # - We want to remain anonymous
              # - We want to stop SPAM
              # - We don't want to let ftp sites to discriminate by the user,
              #   host, country or ftp client being used.
  	    $pass = 'anonymous@';
  	}
      }
      $pass;
  }
  
  1;
URI_FTP

$fatpacked{"URI/gopher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_GOPHER';
  package URI::gopher;  # <draft-murali-url-gopher>, Dec 4, 1996
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  
  #  A Gopher URL follows the common internet scheme syntax as defined in 
  #  section 4.3 of [RFC-URL-SYNTAX]:
  #
  #        gopher://<host>[:<port>]/<gopher-path>
  #
  #  where
  #
  #        <gopher-path> :=  <gopher-type><selector> | 
  #                          <gopher-type><selector>%09<search> |
  #                          <gopher-type><selector>%09<search>%09<gopher+_string>
  #
  #        <gopher-type> := '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'
  #                         '8' | '9' | '+' | 'I' | 'g' | 'T'
  #
  #        <selector>    := *pchar     Refer to RFC 1808 [4]
  #        <search>      := *pchar
  #        <gopher+_string> := *uchar  Refer to RFC 1738 [3]
  #        
  #  If the optional port is omitted, the port defaults to 70. 
  
  sub default_port { 70 }
  
  sub _gopher_type
  {
      my $self = shift;
      my $path = $self->path_query;
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s/^(.)//s;
      if (@_) {
  	my $new_type = shift;
  	if (defined($new_type)) {
  	    Carp::croak("Bad gopher type '$new_type'")
                 unless length($new_type) == 1;
  	    substr($path, 0, 0) = $new_type;
  	    $self->path_query($path);
  	} else {
  	    Carp::croak("Can't delete gopher type when selector is present")
  		if length($path);
  	    $self->path_query(undef);
  	}
      }
      return $gtype;
  }
  
  sub gopher_type
  {
      my $self = shift;
      my $gtype = $self->_gopher_type(@_);
      $gtype = "1" unless defined $gtype;
      $gtype;
  }
  
  sub gtype { goto &gopher_type }  # URI::URL compatibility
  
  sub selector { shift->_gfield(0, @_) }
  sub search   { shift->_gfield(1, @_) }
  sub string   { shift->_gfield(2, @_) }
  
  sub _gfield
  {
      my $self = shift;
      my $fno  = shift;
      my $path = $self->path_query;
  
      # not according to spec., but many popular browsers accept
      # gopher URLs with a '?' before the search string.
      $path =~ s/\?/\t/;
      $path = uri_unescape($path);
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s,^(.),,s;
      my @path = split(/\t/, $path, 3);
      if (@_) {
  	# modify
  	my $new = shift;
  	$path[$fno] = $new;
  	pop(@path) while @path && !defined($path[-1]);
  	for (@path) { $_="" unless defined }
  	$path = $gtype;
  	$path = "1" unless defined $path;
  	$path .= join("\t", @path);
  	$self->path_query($path);
      }
      $path[$fno];
  }
  
  1;
URI_GOPHER

$fatpacked{"URI/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTP';
  package URI::http;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_server';
  
  sub default_port { 80 }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $slash_path = defined($other->authority) &&
          !length($other->path) && !defined($other->query);
  
      if ($slash_path) {
  	$other = $other->clone if $other == $self;
  	$other->path("/");
      }
      $other;
  }
  
  1;
URI_HTTP

$fatpacked{"URI/https.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTPS';
  package URI::https;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::http';
  
  sub default_port { 443 }
  
  sub secure { 1 }
  
  1;
URI_HTTPS

$fatpacked{"URI/ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::ldap;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent qw(URI::_ldap URI::_server);
  
  sub default_port { 389 }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_server::canonical(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::ldap - LDAP Uniform Resource Locators
  
  =head1 SYNOPSIS
  
    use URI;
  
    $uri = URI->new("ldap:$uri_string");
    $dn     = $uri->dn;
    $filter = $uri->filter;
    @attr   = $uri->attributes;
    $scope  = $uri->scope;
    %extn   = $uri->extensions;
    
    $uri = URI->new("ldap:");  # start empty
    $uri->host("ldap.itd.umich.edu");
    $uri->dn("o=University of Michigan,c=US");
    $uri->attributes(qw(postalAddress));
    $uri->scope('sub');
    $uri->filter('(cn=Babs Jensen)');
    print $uri->as_string,"\n";
  
  =head1 DESCRIPTION
  
  C<URI::ldap> provides an interface to parse an LDAP URI into its
  constituent parts and also to build a URI as described in
  RFC 2255.
  
  =head1 METHODS
  
  C<URI::ldap> supports all the generic and server methods defined by
  L<URI>, plus the following.
  
  Each of the following methods can be used to set or get the value in
  the URI. The values are passed in unescaped form.  None of these
  return undefined values, but elements without a default can be empty.
  If arguments are given, then a new value is set for the given part
  of the URI.
  
  =over 4
  
  =item $uri->dn( [$new_dn] )
  
  Sets or gets the I<Distinguished Name> part of the URI.  The DN
  identifies the base object of the LDAP search.
  
  =item $uri->attributes( [@new_attrs] )
  
  Sets or gets the list of attribute names which are
  returned by the search.
  
  =item $uri->scope( [$new_scope] )
  
  Sets or gets the scope to be used by the search. The value can be one of
  C<"base">, C<"one"> or C<"sub">. If none is given in the URI then the
  return value defaults to C<"base">.
  
  =item $uri->_scope( [$new_scope] )
  
  Same as scope(), but does not default to anything.
  
  =item $uri->filter( [$new_filter] )
  
  Sets or gets the filter to be used by the search. If none is given in
  the URI then the return value defaults to C<"(objectClass=*)">.
  
  =item $uri->_filter( [$new_filter] )
  
  Same as filter(), but does not default to anything.
  
  =item $uri->extensions( [$etype => $evalue,...] )
  
  Sets or gets the extensions used for the search. The list passed should
  be in the form etype1 => evalue1, etype2 => evalue2,... This is also
  the form of list that is returned.
  
  =back
  
  =head1 SEE ALSO
  
  L<http://tools.ietf.org/html/rfc2255>
  
  =head1 AUTHOR
  
  Graham Barr E<lt>F<gbarr@pobox.com>E<gt>
  
  Slightly modified by Gisle Aas to fit into the URI distribution.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1998 Graham Barr. All rights reserved. This program is
  free software; you can redistribute it and/or modify it under the same
  terms as Perl itself.
  
  =cut
URI_LDAP

$fatpacked{"URI/ldapi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPI';
  package URI::ldapi;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent qw(URI::_ldap URI::_generic);
  
  require URI::Escape;
  
  sub un_path {
      my $self = shift;
      my $old = URI::Escape::uri_unescape($self->authority);
      if (@_) {
  	my $p = shift;
  	$p =~ s/:/%3A/g;
  	$p =~ s/\@/%40/g;
  	$self->authority($p);
      }
      return $old;
  }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_generic::canonical(@_);
  }
  
  1;
URI_LDAPI

$fatpacked{"URI/ldaps.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPS';
  package URI::ldaps;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::ldap';
  
  sub default_port { 636 }
  
  sub secure { 1 }
  
  1;
URI_LDAPS

$fatpacked{"URI/mailto.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MAILTO';
  package URI::mailto;  # RFC 2368
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent qw(URI URI::_query);
  
  sub to
  {
      my $self = shift;
      my @old = $self->headers;
      if (@_) {
  	my @new = @old;
  	# get rid of any other to: fields
  	for (my $i = 0; $i < @new; $i += 2) {
  	    if (lc($new[$i] || '') eq "to") {
  		splice(@new, $i, 2);
  		redo;
  	    }
  	}
  
  	my $to = shift;
  	$to = "" unless defined $to;
  	unshift(@new, "to" => $to);
  	$self->headers(@new);
      }
      return unless defined wantarray;
  
      my @to;
      while (@old) {
  	my $h = shift @old;
  	my $v = shift @old;
  	push(@to, $v) if lc($h) eq "to";
      }
      join(",", @to);
  }
  
  
  sub headers
  {
      my $self = shift;
  
      # The trick is to just treat everything as the query string...
      my $opaque = "to=" . $self->opaque;
      $opaque =~ s/\?/&/;
  
      if (@_) {
  	my @new = @_;
  
  	# strip out any "to" fields
  	my @to;
  	for (my $i=0; $i < @new; $i += 2) {
  	    if (lc($new[$i] || '') eq "to") {
  		push(@to, (splice(@new, $i, 2))[1]);  # remove header
  		redo;
  	    }
  	}
  
  	my $new = join(",",@to);
  	$new =~ s/%/%25/g;
  	$new =~ s/\?/%3F/g;
  	$self->opaque($new);
  	$self->query_form(@new) if @new;
      }
      return unless defined wantarray;
  
      # I am lazy today...
      URI->new("mailto:?$opaque")->query_form;
  }
  
  1;
URI_MAILTO

$fatpacked{"URI/mms.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MMS';
  package URI::mms;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::http';
  
  sub default_port { 1755 }
  
  1;
URI_MMS

$fatpacked{"URI/news.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NEWS';
  package URI::news;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  sub default_port { 119 }
  
  #   newsURL      =  scheme ":" [ news-server ] [ refbygroup | message ]
  #   scheme       =  "news" | "snews" | "nntp"
  #   news-server  =  "//" server "/"
  #   refbygroup   = group [ "/" messageno [ "-" messageno ] ]
  #   message      = local-part "@" domain
  
  sub _group
  {
      my $self = shift;
      my $old = $self->path;
      if (@_) {
  	my($group,$from,$to) = @_;
  	if ($group =~ /\@/) {
              $group =~ s/^<(.*)>$/$1/;  # "<" and ">" should not be part of it
  	}
  	$group =~ s,%,%25,g;
  	$group =~ s,/,%2F,g;
  	my $path = $group;
  	if (defined $from) {
  	    $path .= "/$from";
  	    $path .= "-$to" if defined $to;
  	}
  	$self->path($path);
      }
  
      $old =~ s,^/,,;
      if ($old !~ /\@/ && $old =~ s,/(.*),, && wantarray) {
  	my $extra = $1;
  	return (uri_unescape($old), split(/-/, $extra));
      }
      uri_unescape($old);
  }
  
  
  sub group
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Group name can't contain '\@'") if $_[0] =~ /\@/;
      }
      my @old = $self->_group(@_);
      return if $old[0] =~ /\@/;
      wantarray ? @old : $old[0];
  }
  
  sub message
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Message must contain '\@'") unless $_[0] =~ /\@/;
      }
      my $old = $self->_group(@_);
      return undef unless $old =~ /\@/;
      return $old;
  }
  
  1;
URI_NEWS

$fatpacked{"URI/nntp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NNTP';
  package URI::nntp;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::news';
  
  1;
URI_NNTP

$fatpacked{"URI/pop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_POP';
  package URI::pop;   # RFC 2384
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  
  sub default_port { 110 }
  
  #pop://<user>;auth=<auth>@<host>:<port>
  
  sub user
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new_info = $old;
  	$new_info = "" unless defined $new_info;
  	$new_info =~ s/^[^;]*//;
  
  	my $new = shift;
  	if (!defined($new) && !length($new_info)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined $new;
  	    $new =~ s/%/%25/g;
  	    $new =~ s/;/%3B/g;
  	    $self->userinfo("$new$new_info");
  	}
      }
  
      return undef unless defined $old;
      $old =~ s/;.*//;
      return uri_unescape($old);
  }
  
  sub auth
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/(^[^;]*)//;
  	my $user = $1;
  	$new =~ s/;auth=[^;]*//i;
  
  	
  	my $auth = shift;
  	if (defined $auth) {
  	    $auth =~ s/%/%25/g;
  	    $auth =~ s/;/%3B/g;
  	    $new = ";AUTH=$auth$new";
  	}
  	$self->userinfo("$user$new");
  	
      }
  
      return undef unless defined $old;
      $old =~ s/^[^;]*//;
      return uri_unescape($1) if $old =~ /;auth=(.*)/i;
      return;
  }
  
  1;
URI_POP

$fatpacked{"URI/rlogin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RLOGIN';
  package URI::rlogin;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_login';
  
  sub default_port { 513 }
  
  1;
URI_RLOGIN

$fatpacked{"URI/rsync.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RSYNC';
  package URI::rsync;  # http://rsync.samba.org/
  
  # rsync://[USER@]HOST[:PORT]/SRC
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent qw(URI::_server URI::_userpass);
  
  sub default_port { 873 }
  
  1;
URI_RSYNC

$fatpacked{"URI/rtsp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSP';
  package URI::rtsp;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::http';
  
  sub default_port { 554 }
  
  1;
URI_RTSP

$fatpacked{"URI/rtspu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSPU';
  package URI::rtspu;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::rtsp';
  
  sub default_port { 554 }
  
  1;
URI_RTSPU

$fatpacked{"URI/sftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SFTP';
  package URI::sftp;
  
  use strict;
  use warnings;
  
  use parent 'URI::ssh';
  
  our $VERSION = '1.74';
  
  1;
URI_SFTP

$fatpacked{"URI/sip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIP';
  #
  # Written by Ryan Kereliuk <ryker@ryker.org>.  This file may be
  # distributed under the same terms as Perl itself.
  #
  # The RFC 3261 sip URI is <scheme>:<authority>;<params>?<query>.
  #
  
  package URI::sip;
  
  use strict;
  use warnings;
  
  use parent qw(URI::_server URI::_userpass);
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = '1.74';
  
  sub default_port { 5060 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^($URI::scheme_re:)?([^;?]*)(.*)$,os or die;
      my $old = $2;
  
      if (@_) {
          my $auth = shift;
          $$self = defined($1) ? $1 : "";
          my $rest = $3;
          if (defined $auth) {
              $auth =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
              $$self .= "$auth";
          }
          $$self .= $rest;
      }
      $old;
  }
  
  sub params_form
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my @args = @_; 
          $$self = $1 . $2;
          my $rest = $4;
  	my @new;
  	for (my $i=0; $i < @args; $i += 2) {
  	    push(@new, "$args[$i]=$args[$i+1]");
  	}
  	$paramstr = join(";", @new);
  	$$self .= ";" . $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return split(/[;=]/, $paramstr);
  }
  
  sub params
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my $new = shift; 
          $$self = $1 . $2;
          my $rest = $4;
  	$$self .= $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return $paramstr;
  }
  
  # Inherited methods that make no sense for a SIP URI.
  sub path {}
  sub path_query {}
  sub path_segments {}
  sub abs { shift }
  sub rel { shift }
  sub query_keywords {}
  
  1;
URI_SIP

$fatpacked{"URI/sips.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIPS';
  package URI::sips;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::sip';
  
  sub default_port { 5061 }
  
  sub secure { 1 }
  
  1;
URI_SIPS

$fatpacked{"URI/snews.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SNEWS';
  package URI::snews;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::news';
  
  sub default_port { 563 }
  
  sub secure { 1 }
  
  1;
URI_SNEWS

$fatpacked{"URI/ssh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SSH';
  package URI::ssh;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_login';
  
  # ssh://[USER@]HOST[:PORT]/SRC
  
  sub default_port { 22 }
  
  sub secure { 1 }
  
  1;
URI_SSH

$fatpacked{"URI/telnet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TELNET';
  package URI::telnet;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_login';
  
  sub default_port { 23 }
  
  1;
URI_TELNET

$fatpacked{"URI/tn3270.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TN3270';
  package URI::tn3270;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::_login';
  
  sub default_port { 23 }
  
  1;
URI_TN3270

$fatpacked{"URI/urn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN';
  package URI::urn;  # RFC 2141
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI';
  
  use Carp qw(carp);
  
  my %implementor;
  my %require_attempted;
  
  sub _init {
      my $class = shift;
      my $self = $class->SUPER::_init(@_);
      my $nid = $self->nid;
  
      my $impclass = $implementor{$nid};
      return $impclass->_urn_init($self, $nid) if $impclass;
  
      $impclass = "URI::urn";
      if ($nid =~ /^[A-Za-z\d][A-Za-z\d\-]*\z/) {
  	my $id = $nid;
  	# make it a legal perl identifier
  	$id =~ s/-/_/g;
  	$id = "_$id" if $id =~ /^\d/;
  
  	$impclass = "URI::urn::$id";
  	no strict 'refs';
  	unless (@{"${impclass}::ISA"}) {
              if (not exists $require_attempted{$impclass}) {
                  # Try to load it
                  my $_old_error = $@;
                  eval "require $impclass";
                  die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
                  $@ = $_old_error;
              }
  	    $impclass = "URI::urn" unless @{"${impclass}::ISA"};
  	}
      }
      else {
  	carp("Illegal namespace identifier '$nid' for URN '$self'") if $^W;
      }
      $implementor{$nid} = $impclass;
  
      return $impclass->_urn_init($self, $nid);
  }
  
  sub _urn_init {
      my($class, $self, $nid) = @_;
      bless $self, $class;
  }
  
  sub _nid {
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	$v =~ s/[^:]*/$new/;
  	$self->opaque($v);
  	# XXX possible rebless
      }
      $opaque =~ s/:.*//s;
      return $opaque;
  }
  
  sub nid {  # namespace identifier
      my $self = shift;
      my $nid = $self->_nid(@_);
      $nid = lc($nid) if defined($nid);
      return $nid;
  }
  
  sub nss {  # namespace specific string
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	if (defined $new) {
  	    $v =~ s/(:|\z).*/:$new/;
  	}
  	else {
  	    $v =~ s/:.*//s;
  	}
  	$self->opaque($v);
      }
      return undef unless $opaque =~ s/^[^:]*://;
      return $opaque;
  }
  
  sub canonical {
      my $self = shift;
      my $nid = $self->_nid;
      my $new = $self->SUPER::canonical;
      return $new if $nid !~ /[A-Z]/ || $nid =~ /%/;
      $new = $new->clone if $new == $self;
      $new->nid(lc($nid));
      return $new;
  }
  
  1;
URI_URN

$fatpacked{"URI/urn/isbn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_ISBN';
  package URI::urn::isbn;  # RFC 3187
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::urn';
  
  use Carp qw(carp);
  
  BEGIN {
      require Business::ISBN;
      
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      warn "Using Business::ISBN version " . Business::ISBN->VERSION . 
          " which is deprecated.\nUpgrade to Business::ISBN version 2\n"
          if Business::ISBN->VERSION < 2;
      }
      
  sub _isbn {
      my $nss = shift;
      $nss = $nss->nss if ref($nss);
      my $isbn = Business::ISBN->new($nss);
      $isbn = undef if $isbn && !$isbn->is_valid;
      return $isbn;
  }
  
  sub _nss_isbn {
      my $self = shift;
      my $nss = $self->nss(@_);
      my $isbn = _isbn($nss);
      $isbn = $isbn->as_string if $isbn;
      return($nss, $isbn);
  }
  
  sub isbn {
      my $self = shift;
      my $isbn;
      (undef, $isbn) = $self->_nss_isbn(@_);
      return $isbn;
  }
  
  sub isbn_publisher_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->publisher_code;
  }
  
  BEGIN {
  my $group_method = do {
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      Business::ISBN->VERSION >= 2 ? 'group_code' : 'country_code';
      };
  
  sub isbn_group_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->$group_method;
  }
  }
  
  sub isbn_country_code {
      my $name = (caller(0))[3]; $name =~ s/.*:://;
      carp "$name is DEPRECATED. Use isbn_group_code instead";
      
      no strict 'refs';
      &isbn_group_code;
  }
  
  BEGIN {
  my $isbn13_method = do {
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      Business::ISBN->VERSION >= 2 ? 'as_isbn13' : 'as_ean';
      };
  
  sub isbn13 {
      my $isbn = shift->_isbn || return undef;
      
      # Business::ISBN 1.x didn't put hyphens in the EAN, and it was just a string
      # Business::ISBN 2.0 doesn't do EAN, but it does ISBN-13 objects
      #   and it uses the hyphens, so call as_string with an empty anon array
      # or, adjust the test and features to say that it comes out with hyphens.
      my $thingy = $isbn->$isbn13_method;
      return eval { $thingy->can( 'as_string' ) } ? $thingy->as_string([]) : $thingy;
  }
  }
  
  sub isbn_as_ean {
      my $name = (caller(0))[3]; $name =~ s/.*:://;
      carp "$name is DEPRECATED. Use isbn13 instead";
  
      no strict 'refs';
      &isbn13;
  }
  
  sub canonical {
      my $self = shift;
      my($nss, $isbn) = $self->_nss_isbn;
      my $new = $self->SUPER::canonical;
      return $new unless $nss && $isbn && $nss ne $isbn;
      $new = $new->clone if $new == $self;
      $new->nss($isbn);
      return $new;
  }
  
  1;
URI_URN_ISBN

$fatpacked{"URI/urn/oid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_OID';
  package URI::urn::oid;  # RFC 2061
  
  use strict;
  use warnings;
  
  our $VERSION = '1.74';
  
  use parent 'URI::urn';
  
  sub oid {
      my $self = shift;
      my $old = $self->nss;
      if (@_) {
  	$self->nss(join(".", @_));
      }
      return split(/\./, $old) if wantarray;
      return $old;
  }
  
  1;
URI_URN_OID

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/home/gugod/perl5/perlbrew/perls/v18/bin/perl

eval 'exec /home/gugod/perl5/perlbrew/perls/v18/bin/perl  -S $0 ${1+"$@"}'
    if 0; # not running under some shell
use strict;
use warnings;
use App::Wallflower;

App::Wallflower->new_with_options( \@ARGV )->run;

__END__

=head1 NAME

wallflower - Sorry I can't dance, I'm hanging on to my friend's purse

=head1 VERSION

version 1.008

=head1 SYNOPSIS

 wallflower [options] [arguments]

=head1 OPTIONS AND ARGUMENTS

In typical L<Getopt::Long> fashion, all options can be abbreviated
as long as the shorter version is unambiguous.

=head2 Required options

 --application <app>        Pathname of the .psgi Plack application file

=head2 Other options

 --destination <path>       Directory for saving generated files
 --directory   <path>       (default: current dir), must exist

 --environment <name>       Plack environment for running the application,
                            usually development, deployment, or test
                            (default: deployment)

 --index       <filename>   Name of index file for URLs ending in /
                            (default: index.html)

 --follow                   Do/don't follow links in (X)HTML and CSS pages
 --no-follow                (default = follow)

 --filter                   Arguments are files containing lists of URLs
 --files
 -F

 --url         <url>        URL of the production site. If the URL has
                            a path component, the application will be
                            "mounted" there.

 --host        <hostname> * Process URLs with one of these hostnames in
                            addition to hostame-less ones and ones using
                            localhost (default is only hostame-less and
                            localhost ones), can include * as a wildcard,
                            like *.example.com. The hostname used in the
                            --url option is automatically added to the list,

 --errors                   Show URLs that returned a non-200 status code
 --verbose                  Show URLs that returned a 200 status code
 --quiet                    Disable both --errors and --verbose
                            (which are enabled by default)

 --include     <path>     * Library paths to add to @INC, delimited with your
 --INC         <path>     * OS' path separator ($Config::Config{path_sep})

 --help                     Print a short help summary and exit
 --manual                   Print the full manual page and exit
 --tutorial                 Print the tutorial and exit

Options marked with * can be repeated as necessary.

=head2 Arguments

Arguments are either URLs or (if I<--filter> is specified) files containing
URLs (one per line) or lines containing only spaces or where the first
non-space is a #. If no arguments are present, / (or standard input if
I<--filter> is specified) is used instead.

=head1 DESCRIPTION

B<wallflower> turns your L<Plack> application into a static (read-only)
web site.

While this isn't suitable for all applications, it makes sense for many
uses. Most web sites are largely static. With no
way for the site's users to update its content (via forms, comments, etc)
the only changes to the web site come from sources that you control
(including the database) and that are accessible in your development
environment.

Using a web framework like L<Dancer> (or any other) for a static web
site is very useful, because it lets you use all the features of the
framework on that site. Think of it as I<extreme caching>.

A possible dataflow would be processing forms on your development server
(maybe to update a local database), then I<publish> as static pages
a I<subset> of all the URLs the application supports.

Turning that application into a real static site (a set of pages
to upload to a static web server) is just a matter of generating all
possible URLs for the static site and saving the corresponding pages to files.

B<wallflower> does just that. It reads a list of URLs, strips off
any query strings, issues HTTP C<GET> requests for each in turn and
saves the response body to a file with a name derived from the request
pathinfo, under the directory specified by the B<--destination> option.

Note that B<wallflower> is not meant for use as an offline browsing tool:
among other things, it doesn't rewrite link URLs to match the pathnames of
the saved pages.

=head1 EXAMPLE

The web site created by C<dancer -a mywebapp> is the perfect example.

The complete list of URLs needed to view the site is:

    /
    /404.html
    /500.html
    /css/error.css
    /css/style.css
    /favicon.ico
    /images/perldancer-bg.jpg
    /images/perldancer.jpg
    /javascripts/jquery.js

Passing this list to B<wallflower> gives the following result:

    $ wallflower -a bin/app.pl -d /tmp -F urls.txt
    200 / => /tmp/output/index.html [5367]
    200 /404.html => /tmp/output/404.html [499]
    200 /500.html => /tmp/output/500.html [510]
    200 /css/error.css => /tmp/output/css/error.css [1210]
    200 /css/style.css => /tmp/output/css/style.css [2850]
    404 /favicon.ico
    404 /images/perldancer-bg.jpg
    404 /images/perldancer.jpg
    200 /javascripts/jquery.js => /tmp/output/javascripts/jquery.js [248235]

Note that URLs with a path ending in a C</> are considered directories
and have the default I<index> filename appended, and that wallflower will
behave unpredictably if the site contains pages accessible through URLs
ending both in F<foo> and F<foo/>. This is arguably a bug, but it's
unclear where to fix it, or if it can be fixed at all. See
L<Wallflower::Tutorial/URI SEMANTICS COMPARED TO DIRECTORY SEMANTICS> for
background on this.

Any URL returning a status other than C<200> will be logged,
but not saved. URLs returning a C<301> status (moved) are followed.

Only the path component is used to fetch the response, so URLs
pointing to other sites will likely return a C<404> (or fetch the
I<local> page if it exists in the application).

=head1 ACKNOWLEDGEMENTS

L<wallflower> started as a neat idea in a discussion between Marc
Chantreux, Alexis Sukrieh, Franck Cuny and myself in the hallway of
OSDC.fr (L<http://osdc.fr/>) 2010, after Alexis' talk about L<Dancer>.

Because a good pun should never be wasted, a first version of the
program has been included in L<Dancer> since version 1.3000_01.
Since it wasn't maintained, it has been removed in version 1.3110,
after the first release of L<App::Wallflower>.

The idea for L<App::Wallflower> owes a lot to Vincent Pit who, while
I was talking about L<wallflower> and L<Dancer> with Marc on IRC in
January 2011, noted that this file generation scheme had
nothing to do with L<Dancer> and much more with L<Plack>.

L<wallflower> treats all L<Plack> applications equally, even if the
first version of the program was targetting L<Dancer> only.

=head1 SEE ALSO

L<Wallflower::Tutorial>

=head1 AUTHOR

Philippe Bruhat (BooK) <book@cpan.org>

=head1 COPYRIGHT AND LICENSE

Copyright 2010-2018 by Philippe Bruhat (BooK).

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut
