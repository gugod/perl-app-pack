#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Data/OptList.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_OPTLIST';
  use strict;
  use warnings;
  package Data::OptList;
  # ABSTRACT: parse and validate simple name/value option pairs
  $Data::OptList::VERSION = '0.110';
  use List::Util ();
  use Params::Util ();
  use Sub::Install 0.921 ();
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   use Data::OptList;
  #pod
  #pod   my $options = Data::OptList::mkopt([
  #pod     qw(key1 key2 key3 key4),
  #pod     key5 => { ... },
  #pod     key6 => [ ... ],
  #pod     key7 => sub { ... },
  #pod     key8 => { ... },
  #pod     key8 => [ ... ],
  #pod   ]);
  #pod
  #pod ...is the same thing, more or less, as:
  #pod
  #pod   my $options = [
  #pod     [ key1 => undef,        ],
  #pod     [ key2 => undef,        ],
  #pod     [ key3 => undef,        ],
  #pod     [ key4 => undef,        ],
  #pod     [ key5 => { ... },      ],
  #pod     [ key6 => [ ... ],      ],
  #pod     [ key7 => sub { ... },  ],
  #pod     [ key8 => { ... },      ],
  #pod     [ key8 => [ ... ],      ],
  #pod   ]);
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod Hashes are great for storing named data, but if you want more than one entry
  #pod for a name, you have to use a list of pairs.  Even then, this is really boring
  #pod to write:
  #pod
  #pod   $values = [
  #pod     foo => undef,
  #pod     bar => undef,
  #pod     baz => undef,
  #pod     xyz => { ... },
  #pod   ];
  #pod
  #pod Just look at all those undefs!  Don't worry, we can get rid of those:
  #pod
  #pod   $values = [
  #pod     map { $_ => undef } qw(foo bar baz),
  #pod     xyz => { ... },
  #pod   ];
  #pod
  #pod Aaaauuugh!  We've saved a little typing, but now it requires thought to read,
  #pod and thinking is even worse than typing... and it's got a bug!  It looked right,
  #pod didn't it?  Well, the C<< xyz => { ... } >> gets consumed by the map, and we
  #pod don't get the data we wanted.
  #pod
  #pod With Data::OptList, you can do this instead:
  #pod
  #pod   $values = Data::OptList::mkopt([
  #pod     qw(foo bar baz),
  #pod     xyz => { ... },
  #pod   ]);
  #pod
  #pod This works by assuming that any defined scalar is a name and any reference
  #pod following a name is its value.
  #pod
  #pod =func mkopt
  #pod
  #pod   my $opt_list = Data::OptList::mkopt($input, \%arg);
  #pod
  #pod Valid arguments are:
  #pod
  #pod   moniker        - a word used in errors to describe the opt list; encouraged
  #pod   require_unique - if true, no name may appear more than once
  #pod   must_be        - types to which opt list values are limited (described below)
  #pod   name_test      - a coderef used to test whether a value can be a name
  #pod                    (described below, but you probably don't want this)
  #pod
  #pod This produces an array of arrays; the inner arrays are name/value pairs.
  #pod Values will be either "undef" or a reference.
  #pod
  #pod Positional parameters may be used for compatibility with the old C<mkopt>
  #pod interface:
  #pod
  #pod   my $opt_list = Data::OptList::mkopt($input, $moniker, $req_uni, $must_be);
  #pod
  #pod Valid values for C<$input>:
  #pod
  #pod  undef    -> []
  #pod  hashref  -> [ [ key1 => value1 ] ... ] # non-ref values become undef
  #pod  arrayref -> every name followed by a non-name becomes a pair: [ name => ref ]
  #pod              every name followed by undef becomes a pair: [ name => undef ]
  #pod              otherwise, it becomes [ name => undef ] like so:
  #pod              [ "a", "b", [ 1, 2 ] ] -> [ [ a => undef ], [ b => [ 1, 2 ] ] ]
  #pod
  #pod By default, a I<name> is any defined non-reference.  The C<name_test> parameter
  #pod can be a code ref that tests whether the argument passed it is a name or not.
  #pod This should be used rarely.  Interactions between C<require_unique> and
  #pod C<name_test> are not yet particularly elegant, as C<require_unique> just tests
  #pod string equality.  B<This may change.>
  #pod
  #pod The C<must_be> parameter is either a scalar or array of scalars; it defines
  #pod what kind(s) of refs may be values.  If an invalid value is found, an exception
  #pod is thrown.  If no value is passed for this argument, any reference is valid.
  #pod If C<must_be> specifies that values must be CODE, HASH, ARRAY, or SCALAR, then
  #pod Params::Util is used to check whether the given value can provide that
  #pod interface.  Otherwise, it checks that the given value is an object of the kind.
  #pod
  #pod In other words:
  #pod
  #pod   [ qw(SCALAR HASH Object::Known) ]
  #pod
  #pod Means:
  #pod
  #pod   _SCALAR0($value) or _HASH($value) or _INSTANCE($value, 'Object::Known')
  #pod
  #pod =cut
  
  my %test_for;
  BEGIN {
    %test_for = (
      CODE   => \&Params::Util::_CODELIKE,  ## no critic
      HASH   => \&Params::Util::_HASHLIKE,  ## no critic
      ARRAY  => \&Params::Util::_ARRAYLIKE, ## no critic
      SCALAR => \&Params::Util::_SCALAR0,   ## no critic
    );
  }
  
  sub mkopt {
    my ($opt_list) = shift;
  
    my ($moniker, $require_unique, $must_be); # the old positional args
    my ($name_test, $is_a);
  
    if (@_) {
      if (@_ == 1 and Params::Util::_HASHLIKE($_[0])) {
        ($moniker, $require_unique, $must_be, $name_test)
          = @{$_[0]}{ qw(moniker require_unique must_be name_test) };
      } else {
        ($moniker, $require_unique, $must_be) = @_;
      }
  
      # Transform the $must_be specification into a closure $is_a
      # that will check if a value matches the spec
  
      if (defined $must_be) {
        $must_be = [ $must_be ] unless ref $must_be;
        my @checks = map {
            my $class = $_;
            $test_for{$_}
            || sub { $_[1] = $class; goto \&Params::Util::_INSTANCE }
        } @$must_be;
  
        $is_a = (@checks == 1)
              ? $checks[0]
              : sub {
                  my $value = $_[0];
                  List::Util::first { defined($_->($value)) } @checks
                };
  
        $moniker = 'unnamed' unless defined $moniker;
      }
    }
  
    return [] unless $opt_list;
  
    $name_test ||= sub { ! ref $_[0] };
  
    $opt_list = [
      map { $_ => (ref $opt_list->{$_} ? $opt_list->{$_} : ()) } keys %$opt_list
    ] if ref $opt_list eq 'HASH';
  
    my @return;
    my %seen;
  
    for (my $i = 0; $i < @$opt_list; $i++) { ## no critic
      my $name = $opt_list->[$i];
  
      if ($require_unique) {
        Carp::croak "multiple definitions provided for $name" if $seen{$name}++;
      }
  
      my $value;
  
      if ($i < $#$opt_list) {
        if (not defined $opt_list->[$i+1]) {
          $i++
        } elsif (! $name_test->($opt_list->[$i+1])) {
          $value = $opt_list->[++$i];
          if ($is_a && !$is_a->($value)) {
            my $ref = ref $value;
            Carp::croak "$ref-ref values are not valid in $moniker opt list";
          }
        }
      }
  
      push @return, [ $name => $value ];
    }
  
    return \@return;
  }
  
  #pod =func mkopt_hash
  #pod
  #pod   my $opt_hash = Data::OptList::mkopt_hash($input, $moniker, $must_be);
  #pod
  #pod Given valid C<L</mkopt>> input, this routine returns a reference to a hash.  It
  #pod will throw an exception if any name has more than one value.
  #pod
  #pod =cut
  
  sub mkopt_hash {
    my ($opt_list, $moniker, $must_be) = @_;
    return {} unless $opt_list;
  
    $opt_list = mkopt($opt_list, $moniker, 1, $must_be);
    my %hash = map { $_->[0] => $_->[1] } @$opt_list;
    return \%hash;
  }
  
  #pod =head1 EXPORTS
  #pod
  #pod Both C<mkopt> and C<mkopt_hash> may be exported on request.
  #pod
  #pod =cut
  
  BEGIN {
    *import = Sub::Install::exporter {
      exports => [qw(mkopt mkopt_hash)],
    };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Data::OptList - parse and validate simple name/value option pairs
  
  =head1 VERSION
  
  version 0.110
  
  =head1 SYNOPSIS
  
    use Data::OptList;
  
    my $options = Data::OptList::mkopt([
      qw(key1 key2 key3 key4),
      key5 => { ... },
      key6 => [ ... ],
      key7 => sub { ... },
      key8 => { ... },
      key8 => [ ... ],
    ]);
  
  ...is the same thing, more or less, as:
  
    my $options = [
      [ key1 => undef,        ],
      [ key2 => undef,        ],
      [ key3 => undef,        ],
      [ key4 => undef,        ],
      [ key5 => { ... },      ],
      [ key6 => [ ... ],      ],
      [ key7 => sub { ... },  ],
      [ key8 => { ... },      ],
      [ key8 => [ ... ],      ],
    ]);
  
  =head1 DESCRIPTION
  
  Hashes are great for storing named data, but if you want more than one entry
  for a name, you have to use a list of pairs.  Even then, this is really boring
  to write:
  
    $values = [
      foo => undef,
      bar => undef,
      baz => undef,
      xyz => { ... },
    ];
  
  Just look at all those undefs!  Don't worry, we can get rid of those:
  
    $values = [
      map { $_ => undef } qw(foo bar baz),
      xyz => { ... },
    ];
  
  Aaaauuugh!  We've saved a little typing, but now it requires thought to read,
  and thinking is even worse than typing... and it's got a bug!  It looked right,
  didn't it?  Well, the C<< xyz => { ... } >> gets consumed by the map, and we
  don't get the data we wanted.
  
  With Data::OptList, you can do this instead:
  
    $values = Data::OptList::mkopt([
      qw(foo bar baz),
      xyz => { ... },
    ]);
  
  This works by assuming that any defined scalar is a name and any reference
  following a name is its value.
  
  =head1 FUNCTIONS
  
  =head2 mkopt
  
    my $opt_list = Data::OptList::mkopt($input, \%arg);
  
  Valid arguments are:
  
    moniker        - a word used in errors to describe the opt list; encouraged
    require_unique - if true, no name may appear more than once
    must_be        - types to which opt list values are limited (described below)
    name_test      - a coderef used to test whether a value can be a name
                     (described below, but you probably don't want this)
  
  This produces an array of arrays; the inner arrays are name/value pairs.
  Values will be either "undef" or a reference.
  
  Positional parameters may be used for compatibility with the old C<mkopt>
  interface:
  
    my $opt_list = Data::OptList::mkopt($input, $moniker, $req_uni, $must_be);
  
  Valid values for C<$input>:
  
   undef    -> []
   hashref  -> [ [ key1 => value1 ] ... ] # non-ref values become undef
   arrayref -> every name followed by a non-name becomes a pair: [ name => ref ]
               every name followed by undef becomes a pair: [ name => undef ]
               otherwise, it becomes [ name => undef ] like so:
               [ "a", "b", [ 1, 2 ] ] -> [ [ a => undef ], [ b => [ 1, 2 ] ] ]
  
  By default, a I<name> is any defined non-reference.  The C<name_test> parameter
  can be a code ref that tests whether the argument passed it is a name or not.
  This should be used rarely.  Interactions between C<require_unique> and
  C<name_test> are not yet particularly elegant, as C<require_unique> just tests
  string equality.  B<This may change.>
  
  The C<must_be> parameter is either a scalar or array of scalars; it defines
  what kind(s) of refs may be values.  If an invalid value is found, an exception
  is thrown.  If no value is passed for this argument, any reference is valid.
  If C<must_be> specifies that values must be CODE, HASH, ARRAY, or SCALAR, then
  Params::Util is used to check whether the given value can provide that
  interface.  Otherwise, it checks that the given value is an object of the kind.
  
  In other words:
  
    [ qw(SCALAR HASH Object::Known) ]
  
  Means:
  
    _SCALAR0($value) or _HASH($value) or _INSTANCE($value, 'Object::Known')
  
  =head2 mkopt_hash
  
    my $opt_hash = Data::OptList::mkopt_hash($input, $moniker, $must_be);
  
  Given valid C<L</mkopt>> input, this routine returns a reference to a hash.  It
  will throw an exception if any name has more than one value.
  
  =head1 EXPORTS
  
  Both C<mkopt> and C<mkopt_hash> may be exported on request.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Olivier Mengué Ricardo SIGNES
  
  =over 4
  
  =item *
  
  Olivier Mengué <dolmen@cpan.org>
  
  =item *
  
  Ricardo SIGNES <rjbs@codesimply.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DATA_OPTLIST

$fatpacked{"Sub/Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER';
  use 5.006;
  use strict;
  use warnings;
  package Sub::Exporter;
  {
    $Sub::Exporter::VERSION = '0.987';
  }
  # ABSTRACT: a sophisticated exporter for custom-built routines
  
  use Carp ();
  use Data::OptList 0.100 ();
  use Params::Util 0.14 (); # _CODELIKE
  use Sub::Install 0.92 ();
  
  
  # Given a potential import name, this returns the group name -- if it's got a
  # group prefix.
  sub _group_name {
    my ($name) = @_;
  
    return if (index q{-:}, (substr $name, 0, 1)) == -1;
    return substr $name, 1;
  }
  
  # \@groups is a canonicalized opt list of exports and groups this returns
  # another canonicalized opt list with groups replaced with relevant exports.
  # \%seen is groups we've already expanded and can ignore.
  # \%merge is merged options from the group we're descending through.
  sub _expand_groups {
    my ($class, $config, $groups, $collection, $seen, $merge) = @_;
    $seen  ||= {};
    $merge ||= {};
    my @groups = @$groups;
  
    for my $i (reverse 0 .. $#groups) {
      if (my $group_name = _group_name($groups[$i][0])) {
        my $seen = { %$seen }; # faux-dynamic scoping
  
        splice @groups, $i, 1,
          _expand_group($class, $config, $groups[$i], $collection, $seen, $merge);
      } else {
        # there's nothing to munge in this export's args
        next unless my %merge = %$merge;
  
        # we have things to merge in; do so
        my $prefix = (delete $merge{-prefix}) || '';
        my $suffix = (delete $merge{-suffix}) || '';
  
        if (
          Params::Util::_CODELIKE($groups[$i][1]) ## no critic Private
          or
          Params::Util::_SCALAR0($groups[$i][1]) ## no critic Private
        ) {
          # this entry was build by a group generator
          $groups[$i][0] = $prefix . $groups[$i][0] . $suffix;
        } else {
          my $as
            = ref $groups[$i][1]{-as} ? $groups[$i][1]{-as}
            :     $groups[$i][1]{-as} ? $prefix . $groups[$i][1]{-as} . $suffix
            :                           $prefix . $groups[$i][0]      . $suffix;
  
          $groups[$i][1] = { %{ $groups[$i][1] }, %merge, -as => $as };
        }
      }
    }
  
    return \@groups;
  }
  
  # \@group is a name/value pair from an opt list.
  sub _expand_group {
    my ($class, $config, $group, $collection, $seen, $merge) = @_;
    $merge ||= {};
  
    my ($group_name, $group_arg) = @$group;
    $group_name = _group_name($group_name);
  
    Carp::croak qq(group "$group_name" is not exported by the $class module)
      unless exists $config->{groups}{$group_name};
  
    return if $seen->{$group_name}++;
  
    if (ref $group_arg) {
      my $prefix = (delete $merge->{-prefix}||'') . ($group_arg->{-prefix}||'');
      my $suffix = ($group_arg->{-suffix}||'') . (delete $merge->{-suffix}||'');
      $merge = {
        %$merge,
        %$group_arg,
        ($prefix ? (-prefix => $prefix) : ()),
        ($suffix ? (-suffix => $suffix) : ()),
      };
    }
  
    my $exports = $config->{groups}{$group_name};
  
    if (
      Params::Util::_CODELIKE($exports) ## no critic Private
      or
      Params::Util::_SCALAR0($exports) ## no critic Private
    ) {
      # I'm not very happy with this code for hiding -prefix and -suffix, but
      # it's needed, and I'm not sure, offhand, how to make it better.
      # -- rjbs, 2006-12-05
      my $group_arg = $merge ? { %$merge } : {};
      delete $group_arg->{-prefix};
      delete $group_arg->{-suffix};
  
      my $group = Params::Util::_CODELIKE($exports) ## no critic Private
                ? $exports->($class, $group_name, $group_arg, $collection)
                : $class->$$exports($group_name, $group_arg, $collection);
  
      Carp::croak qq(group generator "$group_name" did not return a hashref)
        if ref $group ne 'HASH';
  
      my $stuff = [ map { [ $_ => $group->{$_} ] } keys %$group ];
      return @{
        _expand_groups($class, $config, $stuff, $collection, $seen, $merge)
      };
    } else {
      $exports
        = Data::OptList::mkopt($exports, "$group_name exports");
  
      return @{
        _expand_groups($class, $config, $exports, $collection, $seen, $merge)
      };
    }
  }
  
  sub _mk_collection_builder {
    my ($col, $etc) = @_;
    my ($config, $import_args, $class, $into) = @$etc;
  
    my %seen;
    sub {
      my ($collection) = @_;
      my ($name, $value) = @$collection;
  
      Carp::croak "collection $name provided multiple times in import"
        if $seen{ $name }++;
  
      if (ref(my $hook = $config->{collectors}{$name})) {
        my $arg = {
          name        => $name,
          config      => $config,
          import_args => $import_args,
          class       => $class,
          into        => $into,
        };
  
        my $error_msg = "collection $name failed validation";
        if (Params::Util::_SCALAR0($hook)) { ## no critic Private
          Carp::croak $error_msg unless $class->$$hook($value, $arg);
        } else {
          Carp::croak $error_msg unless $hook->($value, $arg);
        }
      }
  
      $col->{ $name } = $value;
    }
  }
  
  # Given a config and pre-canonicalized importer args, remove collections from
  # the args and return them.
  sub _collect_collections {
    my ($config, $import_args, $class, $into) = @_;
  
    my @collections
      = map  { splice @$import_args, $_, 1 }
        grep { exists $config->{collectors}{ $import_args->[$_][0] } }
        reverse 0 .. $#$import_args;
  
    unshift @collections, [ INIT => {} ] if $config->{collectors}{INIT};
  
    my $col = {};
    my $builder = _mk_collection_builder($col, \@_);
    for my $collection (@collections) {
      $builder->($collection)
    }
  
    return $col;
  }
  
  
  sub setup_exporter {
    my ($config)  = @_;
  
    Carp::croak 'into and into_level may not both be supplied to exporter'
      if exists $config->{into} and exists $config->{into_level};
  
    my $as   = delete $config->{as}   || 'import';
    my $into
      = exists $config->{into}       ? delete $config->{into}
      : exists $config->{into_level} ? caller(delete $config->{into_level})
      :                                caller(0);
  
    my $import = build_exporter($config);
  
    Sub::Install::reinstall_sub({
      code => $import,
      into => $into,
      as   => $as,
    });
  }
  
  
  sub _key_intersection {
    my ($x, $y) = @_;
    my %seen = map { $_ => 1 } keys %$x;
    my @names = grep { $seen{$_} } keys %$y;
  }
  
  # Given the config passed to setup_exporter, which contains sugary opt list
  # data, rewrite the opt lists into hashes, catch a few kinds of invalid
  # configurations, and set up defaults.  Since the config is a reference, it's
  # rewritten in place.
  my %valid_config_key;
  BEGIN {
    %valid_config_key =
      map { $_ => 1 }
      qw(as collectors installer generator exports groups into into_level),
      qw(exporter), # deprecated
  }
  
  sub _assert_collector_names_ok {
    my ($collectors) = @_;
  
    for my $reserved_name (grep { /\A[_A-Z]+\z/ } keys %$collectors) {
      Carp::croak "unknown reserved collector name: $reserved_name"
        if $reserved_name ne 'INIT';
    }
  }
  
  sub _rewrite_build_config {
    my ($config) = @_;
  
    if (my @keys = grep { not exists $valid_config_key{$_} } keys %$config) {
      Carp::croak "unknown options (@keys) passed to Sub::Exporter";
    }
  
    Carp::croak q(into and into_level may not both be supplied to exporter)
      if exists $config->{into} and exists $config->{into_level};
  
    # XXX: Remove after deprecation period.
    if ($config->{exporter}) {
      Carp::cluck "'exporter' argument to build_exporter is deprecated. Use 'installer' instead; the semantics are identical.";
      $config->{installer} = delete $config->{exporter};
    }
  
    Carp::croak q(into and into_level may not both be supplied to exporter)
      if exists $config->{into} and exists $config->{into_level};
  
    for (qw(exports collectors)) {
      $config->{$_} = Data::OptList::mkopt_hash(
        $config->{$_},
        $_,
        [ 'CODE', 'SCALAR' ],
      );
    }
  
    _assert_collector_names_ok($config->{collectors});
  
    if (my @names = _key_intersection(@$config{qw(exports collectors)})) {
      Carp::croak "names (@names) used in both collections and exports";
    }
  
    $config->{groups} = Data::OptList::mkopt_hash(
        $config->{groups},
        'groups',
        [
          'HASH',   # standard opt list
          'ARRAY',  # standard opt list
          'CODE',   # group generator
          'SCALAR', # name of group generation method
        ]
      );
  
    # by default, export nothing
    $config->{groups}{default} ||= [];
  
    # by default, build an all-inclusive 'all' group
    $config->{groups}{all} ||= [ keys %{ $config->{exports} } ];
  
    $config->{generator} ||= \&default_generator;
    $config->{installer} ||= \&default_installer;
  }
  
  sub build_exporter {
    my ($config) = @_;
  
    _rewrite_build_config($config);
  
    my $import = sub {
      my ($class) = shift;
  
      # XXX: clean this up -- rjbs, 2006-03-16
      my $special = (ref $_[0]) ? shift(@_) : {};
      Carp::croak q(into and into_level may not both be supplied to exporter)
        if exists $special->{into} and exists $special->{into_level};
  
      if ($special->{exporter}) {
        Carp::cluck "'exporter' special import argument is deprecated. Use 'installer' instead; the semantics are identical.";
        $special->{installer} = delete $special->{exporter};
      }
  
      my $into
        = defined $special->{into}       ? delete $special->{into}
        : defined $special->{into_level} ? caller(delete $special->{into_level})
        : defined $config->{into}        ? $config->{into}
        : defined $config->{into_level}  ? caller($config->{into_level})
        :                                  caller(0);
  
      my $generator = delete $special->{generator} || $config->{generator};
      my $installer = delete $special->{installer} || $config->{installer};
  
      # this builds a AOA, where the inner arrays are [ name => value_ref ]
      my $import_args = Data::OptList::mkopt([ @_ ]);
  
      # is this right?  defaults first or collectors first? -- rjbs, 2006-06-24
      $import_args = [ [ -default => undef ] ] unless @$import_args;
  
      my $collection = _collect_collections($config, $import_args, $class, $into);
  
      my $to_import = _expand_groups($class, $config, $import_args, $collection);
  
      # now, finally $import_arg is really the "to do" list
      _do_import(
        {
          class     => $class,
          col       => $collection,
          config    => $config,
          into      => $into,
          generator => $generator,
          installer => $installer,
        },
        $to_import,
      );
    };
  
    return $import;
  }
  
  sub _do_import {
    my ($arg, $to_import) = @_;
  
    my @todo;
  
    for my $pair (@$to_import) {
      my ($name, $import_arg) = @$pair;
  
      my ($generator, $as);
  
      if ($import_arg and Params::Util::_CODELIKE($import_arg)) { ## no critic
        # This is the case when a group generator has inserted name/code pairs.
        $generator = sub { $import_arg };
        $as = $name;
      } else {
        $import_arg = { $import_arg ? %$import_arg : () };
  
        Carp::croak qq("$name" is not exported by the $arg->{class} module)
          unless exists $arg->{config}{exports}{$name};
  
        $generator = $arg->{config}{exports}{$name};
  
        $as = exists $import_arg->{-as} ? (delete $import_arg->{-as}) : $name;
      }
  
      my $code = $arg->{generator}->(
        { 
          class     => $arg->{class},
          name      => $name,
          arg       => $import_arg,
          col       => $arg->{col},
          generator => $generator,
        }
      );
  
      push @todo, $as, $code;
    }
  
    $arg->{installer}->(
      {
        class => $arg->{class},
        into  => $arg->{into},
        col   => $arg->{col},
      },
      \@todo,
    );
  }
  
  ## Cute idea, possibly for future use: also supply an "unimport" for:
  ## no Module::Whatever qw(arg arg arg);
  # sub _unexport {
  #   my (undef, undef, undef, undef, undef, $as, $into) = @_;
  # 
  #   if (ref $as eq 'SCALAR') {
  #     undef $$as;
  #   } elsif (ref $as) {
  #     Carp::croak "invalid reference type for $as: " . ref $as;
  #   } else {
  #     no strict 'refs';
  #     delete &{$into . '::' . $as};
  #   }
  # }
  
  
  sub default_generator {
    my ($arg) = @_;
    my ($class, $name, $generator) = @$arg{qw(class name generator)};
  
    if (not defined $generator) {
      my $code = $class->can($name)
        or Carp::croak "can't locate exported subroutine $name via $class";
      return $code;
    }
  
    # I considered making this "$class->$generator(" but it seems that
    # overloading precedence would turn an overloaded-as-code generator object
    # into a string before code. -- rjbs, 2006-06-11
    return $generator->($class, $name, $arg->{arg}, $arg->{col})
      if Params::Util::_CODELIKE($generator); ## no critic Private
  
    # This "must" be a scalar reference, to a generator method name.
    # -- rjbs, 2006-12-05
    return $class->$$generator($name, $arg->{arg}, $arg->{col});
  }
  
  
  sub default_installer {
    my ($arg, $to_export) = @_;
  
    for (my $i = 0; $i < @$to_export; $i += 2) {
      my ($as, $code) = @$to_export[ $i, $i+1 ];
  
      # Allow as isa ARRAY to push onto an array?
      # Allow into isa HASH to install name=>code into hash?
  
      if (ref $as eq 'SCALAR') {
        $$as = $code;
      } elsif (ref $as) {
        Carp::croak "invalid reference type for $as: " . ref $as;
      } else {
        Sub::Install::reinstall_sub({
          code => $code,
          into => $arg->{into},
          as   => $as
        });
      }
    }
  }
  
  sub default_exporter {
    Carp::cluck "default_exporter is deprecated; call default_installer instead; the semantics are identical";
    goto &default_installer;
  }
  
  
  setup_exporter({
    exports => [
      qw(setup_exporter build_exporter),
      _import => sub { build_exporter($_[2]) },
    ],
    groups  => {
      all   => [ qw(setup_exporter build_export) ],
    },
    collectors => { -setup => \&_setup },
  });
  
  sub _setup {
    my ($value, $arg) = @_;
  
    if (ref $value eq 'HASH') {
      push @{ $arg->{import_args} }, [ _import => { -as => 'import', %$value } ];
      return 1;
    } elsif (ref $value eq 'ARRAY') {
      push @{ $arg->{import_args} },
        [ _import => { -as => 'import', exports => $value } ];
      return 1;
    }
    return;
  }
  
  
  
  "jn8:32"; # <-- magic true value
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Sub::Exporter - a sophisticated exporter for custom-built routines
  
  =head1 VERSION
  
  version 0.987
  
  =head1 SYNOPSIS
  
  Sub::Exporter must be used in two places.  First, in an exporting module:
  
    # in the exporting module:
    package Text::Tweaker;
    use Sub::Exporter -setup => {
      exports => [
        qw(squish titlecase), # always works the same way
        reformat => \&build_reformatter, # generator to build exported function
        trim     => \&build_trimmer,
        indent   => \&build_indenter,
      ],
      collectors => [ 'defaults' ],
    };
  
  Then, in an importing module:
  
    # in the importing module:
    use Text::Tweaker
      'squish',
      indent   => { margin => 5 },
      reformat => { width => 79, justify => 'full', -as => 'prettify_text' },
      defaults => { eol => 'CRLF' };
  
  With this setup, the importing module ends up with three routines: C<squish>,
  C<indent>, and C<prettify_text>.  The latter two have been built to the
  specifications of the importer -- they are not just copies of the code in the
  exporting package.
  
  =head1 DESCRIPTION
  
  B<ACHTUNG!>  If you're not familiar with Exporter or exporting, read
  L<Sub::Exporter::Tutorial> first!
  
  =head2 Why Generators?
  
  The biggest benefit of Sub::Exporter over existing exporters (including the
  ubiquitous Exporter.pm) is its ability to build new coderefs for export, rather
  than to simply export code identical to that found in the exporting package.
  
  If your module's consumers get a routine that works like this:
  
    use Data::Analyze qw(analyze);
    my $value = analyze($data, $tolerance, $passes);
  
  and they constantly pass only one or two different set of values for the
  non-C<$data> arguments, your code can benefit from Sub::Exporter.  By writing a
  simple generator, you can let them do this, instead:
  
    use Data::Analyze
      analyze => { tolerance => 0.10, passes => 10, -as => analyze10 },
      analyze => { tolerance => 0.15, passes => 50, -as => analyze50 };
  
    my $value = analyze10($data);
  
  The package with the generator for that would look something like this:
  
    package Data::Analyze;
    use Sub::Exporter -setup => {
      exports => [
        analyze => \&build_analyzer,
      ],
    };
  
    sub build_analyzer {
      my ($class, $name, $arg) = @_;
  
      return sub {
        my $data      = shift;
        my $tolerance = shift || $arg->{tolerance}; 
        my $passes    = shift || $arg->{passes}; 
  
        analyze($data, $tolerance, $passes);
      }
    }
  
  Your module's user now has to do less work to benefit from it -- and remember,
  you're often your own user!  Investing in customized subroutines is an
  investment in future laziness.
  
  This also avoids a common form of ugliness seen in many modules: package-level
  configuration.  That is, you might have seen something like the above
  implemented like so:
  
    use Data::Analyze qw(analyze);
    $Data::Analyze::default_tolerance = 0.10;
    $Data::Analyze::default_passes    = 10;
  
  This might save time, until you have multiple modules using Data::Analyze.
  Because there is only one global configuration, they step on each other's toes
  and your code begins to have mysterious errors.
  
  Generators can also allow you to export class methods to be called as
  subroutines:
  
    package Data::Methodical;
    use Sub::Exporter -setup => { exports => { some_method => \&_curry_class } };
  
    sub _curry_class {
      my ($class, $name) = @_;
      sub { $class->$name(@_); };
    }
  
  Because of the way that exporters and Sub::Exporter work, any package that
  inherits from Data::Methodical can inherit its exporter and override its
  C<some_method>.  If a user imports C<some_method> from that package, he'll
  receive a subroutine that calls the method on the subclass, rather than on
  Data::Methodical itself.
  
  =head2 Other Customizations
  
  Building custom routines with generators isn't the only way that Sub::Exporters
  allows the importing code to refine its use of the exported routines.  They may
  also be renamed to avoid naming collisions.
  
  Consider the following code:
  
    # this program determines to which circle of Hell you will be condemned
    use Morality qw(sin virtue); # for calculating viciousness
    use Math::Trig qw(:all);     # for dealing with circles
  
  The programmer has inadvertently imported two C<sin> routines.  The solution,
  in Exporter.pm-based modules, would be to import only one and then call the
  other by its fully-qualified name.  Alternately, the importer could write a
  routine that did so, or could mess about with typeglobs.
  
  How much easier to write:
  
    # this program determines to which circle of Hell you will be condemned
    use Morality qw(virtue), sin => { -as => 'offense' };
    use Math::Trig -all => { -prefix => 'trig_' };
  
  and to have at one's disposal C<offense> and C<trig_sin> -- not to mention
  C<trig_cos> and C<trig_tan>.
  
  =head1 EXPORTER CONFIGURATION
  
  You can configure an exporter for your package by using Sub::Exporter like so:
  
    package Tools;
    use Sub::Exporter
      -setup => { exports => [ qw(function1 function2 function3) ] };
  
  This is the simplest way to use the exporter, and is basically equivalent to
  this:
  
    package Tools;
    use base qw(Exporter);
    our @EXPORT_OK = qw(function1 function2 function3);
  
  Any basic use of Sub::Exporter will look like this:
  
    package Tools;
    use Sub::Exporter -setup => \%config;
  
  The following keys are valid in C<%config>:
  
    exports - a list of routines to provide for exporting; each routine may be
              followed by generator
    groups  - a list of groups to provide for exporting; each must be followed by
              either (a) a list of exports, possibly with arguments for each
              export, or (b) a generator
  
    collectors - a list of names into which values are collected for use in
                 routine generation; each name may be followed by a validator
  
  In addition to the basic options above, a few more advanced options may be
  passed:
  
    into_level - how far up the caller stack to look for a target (default 0)
    into       - an explicit target (package) into which to export routines
  
  In other words: Sub::Exporter installs a C<import> routine which, when called,
  exports routines to the calling namespace.  The C<into> and C<into_level>
  options change where those exported routines are installed.
  
    generator  - a callback used to produce the code that will be installed
                 default: Sub::Exporter::default_generator
  
    installer  - a callback used to install the code produced by the generator
                 default: Sub::Exporter::default_installer
  
  For information on how these callbacks are used, see the documentation for
  C<L</default_generator>> and C<L</default_installer>>.
  
  =head2 Export Configuration
  
  The C<exports> list may be provided as an array reference or a hash reference.
  The list is processed in such a way that the following are equivalent:
  
    { exports => [ qw(foo bar baz), quux => \&quux_generator ] }
  
    { exports =>
      { foo => undef, bar => undef, baz => undef, quux => \&quux_generator } }
  
  Generators are code that return coderefs.  They are called with four
  parameters:
  
    $class - the class whose exporter has been called (the exporting class)
    $name  - the name of the export for which the routine is being build
   \%arg   - the arguments passed for this export
   \%col   - the collections for this import
  
  Given the configuration in the L</SYNOPSIS>, the following C<use> statement:
  
    use Text::Tweaker
      reformat => { -as => 'make_narrow', width => 33 },
      defaults => { eol => 'CR' };
  
  would result in the following call to C<&build_reformatter>:
  
    my $code = build_reformatter(
      'Text::Tweaker',
      'reformat',
      { width => 33 }, # note that -as is not passed in
      { defaults => { eol => 'CR' } },
    );
  
  The returned coderef (C<$code>) would then be installed as C<make_narrow> in the
  calling package.
  
  Instead of providing a coderef in the configuration, a reference to a method
  name may be provided.  This method will then be called on the invocant of the
  C<import> method.  (In this case, we do not pass the C<$class> parameter, as it
  would be redundant.)
  
  =head2 Group Configuration
  
  The C<groups> list can be passed in the same forms as C<exports>.  Groups must
  have values to be meaningful, which may either list exports that make up the
  group (optionally with arguments) or may provide a way to build the group.
  
  The simpler case is the first: a group definition is a list of exports.  Here's
  the example that could go in exporter in the L</SYNOPSIS>.
  
    groups  => {
      default    => [ qw(reformat) ],
      shorteners => [ qw(squish trim) ],
      email_safe => [
        'indent',
        reformat => { -as => 'email_format', width => 72 }
      ],
    },
  
  Groups are imported by specifying their name prefixed be either a dash or a
  colon.  This line of code would import the C<shorteners> group:
  
    use Text::Tweaker qw(-shorteners);
  
  Arguments passed to a group when importing are merged into the groups options
  and passed to any relevant generators.  Groups can contain other groups, but
  looping group structures are ignored.
  
  The other possible value for a group definition, a coderef, allows one
  generator to build several exportable routines simultaneously.  This is useful
  when many routines must share enclosed lexical variables.  The coderef must
  return a hash reference.  The keys will be used as export names and the values
  are the subs that will be exported.
  
  This example shows a simple use of the group generator.
  
    package Data::Crypto;
    use Sub::Exporter -setup => { groups => { cipher => \&build_cipher_group } };
  
    sub build_cipher_group {
      my ($class, $group, $arg) = @_;
      my ($encode, $decode) = build_codec($arg->{secret});
      return { cipher => $encode, decipher => $decode };
    }
  
  The C<cipher> and C<decipher> routines are built in a group because they are
  built together by code which encloses their secret in their environment.
  
  =head3 Default Groups
  
  If a module that uses Sub::Exporter is C<use>d with no arguments, it will try
  to export the group named C<default>.  If that group has not been specifically
  configured, it will be empty, and nothing will happen.
  
  Another group is also created if not defined: C<all>.  The C<all> group
  contains all the exports from the exports list.
  
  =head2 Collector Configuration
  
  The C<collectors> entry in the exporter configuration gives names which, when
  found in the import call, have their values collected and passed to every
  generator.
  
  For example, the C<build_analyzer> generator that we saw above could be
  rewritten as:
  
   sub build_analyzer {
     my ($class, $name, $arg, $col) = @_;
  
     return sub {
       my $data      = shift;
       my $tolerance = shift || $arg->{tolerance} || $col->{defaults}{tolerance}; 
       my $passes    = shift || $arg->{passes}    || $col->{defaults}{passes}; 
  
       analyze($data, $tolerance, $passes);
     }
   }
  
  That would allow the importer to specify global defaults for his imports:
  
    use Data::Analyze
      'analyze',
      analyze  => { tolerance => 0.10, -as => analyze10 },
      analyze  => { tolerance => 0.15, passes => 50, -as => analyze50 },
      defaults => { passes => 10 };
  
    my $A = analyze10($data);     # equivalent to analyze($data, 0.10, 10);
    my $C = analyze50($data);     # equivalent to analyze($data, 0.15, 50);
    my $B = analyze($data, 0.20); # equivalent to analyze($data, 0.20, 10);
  
  If values are provided in the C<collectors> list during exporter setup, they
  must be code references, and are used to validate the importer's values.  The
  validator is called when the collection is found, and if it returns false, an
  exception is thrown.  We could ensure that no one tries to set a global data
  default easily:
  
    collectors => { defaults => sub { return (exists $_[0]->{data}) ? 0 : 1 } }
  
  Collector coderefs can also be used as hooks to perform arbitrary actions
  before anything is exported.
  
  When the coderef is called, it is passed the value of the collection and a
  hashref containing the following entries:
  
    name        - the name of the collector
    config      - the exporter configuration (hashref)
    import_args - the arguments passed to the exporter, sans collections (aref)
    class       - the package on which the importer was called
    into        - the package into which exports will be exported
  
  Collectors with all-caps names (that is, made up of underscore or capital A
  through Z) are reserved for special use.  The only currently implemented
  special collector is C<INIT>, whose hook (if present in the exporter
  configuration) is always run before any other hook.
  
  =head1 CALLING THE EXPORTER
  
  Arguments to the exporter (that is, the arguments after the module name in a
  C<use> statement) are parsed as follows:
  
  First, the collectors gather any collections found in the arguments.  Any
  reference type may be given as the value for a collector.  For each collection
  given in the arguments, its validator (if any) is called.  
  
  Next, groups are expanded.  If the group is implemented by a group generator,
  the generator is called.  There are two special arguments which, if given to a
  group, have special meaning:
  
    -prefix - a string to prepend to any export imported from this group
    -suffix - a string to append to any export imported from this group
  
  Finally, individual export generators are called and all subs, generated or
  otherwise, are installed in the calling package.  There is only one special
  argument for export generators:
  
    -as     - where to install the exported sub
  
  Normally, C<-as> will contain an alternate name for the routine.  It may,
  however, contain a reference to a scalar.  If that is the case, a reference the
  generated routine will be placed in the scalar referenced by C<-as>.  It will
  not be installed into the calling package.
  
  =head2 Special Exporter Arguments
  
  The generated exporter accept some special options, which may be passed as the
  first argument, in a hashref.
  
  These options are:
  
    into_level
    into
    generator
    installer
  
  These override the same-named configuration options described in L</EXPORTER
  CONFIGURATION>.
  
  =head1 SUBROUTINES
  
  =head2 setup_exporter
  
  This routine builds and installs an C<import> routine.  It is called with one
  argument, a hashref containing the exporter configuration.  Using this, it
  builds an exporter and installs it into the calling package with the name
  "import."  In addition to the normal exporter configuration, a few named
  arguments may be passed in the hashref:
  
    into       - into what package should the exporter be installed
    into_level - into what level up the stack should the exporter be installed
    as         - what name should the installed exporter be given
  
  By default the exporter is installed with the name C<import> into the immediate
  caller of C<setup_exporter>.  In other words, if your package calls
  C<setup_exporter> without providing any of the three above arguments, it will
  have an C<import> routine installed.
  
  Providing both C<into> and C<into_level> will cause an exception to be thrown.
  
  The exporter is built by C<L</build_exporter>>.
  
  =head2 build_exporter
  
  Given a standard exporter configuration, this routine builds and returns an
  exporter -- that is, a subroutine that can be installed as a class method to
  perform exporting on request.
  
  Usually, this method is called by C<L</setup_exporter>>, which then installs
  the exporter as a package's import routine.
  
  =head2 default_generator
  
  This is Sub::Exporter's default generator.  It takes bits of configuration that
  have been gathered during the import and turns them into a coderef that can be
  installed.
  
    my $code = default_generator(\%arg);
  
  Passed arguments are:
  
    class - the class on which the import method was called
    name  - the name of the export being generated
    arg   - the arguments to the generator
    col   - the collections
  
    generator - the generator to be used to build the export (code or scalar ref)
  
  =head2 default_installer
  
  This is Sub::Exporter's default installer.  It does what Sub::Exporter
  promises: it installs code into the target package.
  
    default_installer(\%arg, \@to_export);
  
  Passed arguments are:
  
    into - the package into which exports should be delivered
  
  C<@to_export> is a list of name/value pairs.  The default exporter assigns code
  (the values) to named slots (the names) in the given package.  If the name is a
  scalar reference, the scalar reference is made to point to the code reference
  instead.
  
  =head1 EXPORTS
  
  Sub::Exporter also offers its own exports: the C<setup_exporter> and
  C<build_exporter> routines described above.  It also provides a special "setup"
  collector, which will set up an exporter using the parameters passed to it.
  
  Note that the "setup" collector (seen in examples like the L</SYNOPSIS> above)
  uses C<build_exporter>, not C<setup_exporter>.  This means that the special
  arguments like "into" and "as" for C<setup_exporter> are not accepted here.
  Instead, you may write something like:
  
    use Sub::Exporter
      { into => 'Target::Package' },
      -setup => {
        -as     => 'do_import',
        exports => [ ... ],
      }
    ;
  
  Finding a good reason for wanting to do this is left as an exercise for the
  reader.
  
  =head1 COMPARISONS
  
  There are a whole mess of exporters on the CPAN.  The features included in
  Sub::Exporter set it apart from any existing Exporter.  Here's a summary of
  some other exporters and how they compare.
  
  =over
  
  =item * L<Exporter> and co.
  
  This is the standard Perl exporter.  Its interface is a little clunky, but it's
  fast and ubiquitous.  It can do some things that Sub::Exporter can't:  it can
  export things other than routines, it can import "everything in this group
  except this symbol," and some other more esoteric things.  These features seem
  to go nearly entirely unused.
  
  It always exports things exactly as they appear in the exporting module; it
  can't rename or customize routines.  Its groups ("tags") can't be nested.
  
  L<Exporter::Lite> is a whole lot like Exporter, but it does significantly less:
  it supports exporting symbols, but not groups, pattern matching, or negation.
  
  The fact that Sub::Exporter can't export symbols other than subroutines is
  a good idea, not a missing feature.
  
  For simple uses, setting up Sub::Exporter is about as easy as Exporter.  For
  complex uses, Sub::Exporter makes hard things possible, which would not be
  possible with Exporter. 
  
  When using a module that uses Sub::Exporter, users familiar with Exporter will
  probably see no difference in the basics.  These two lines do about the same
  thing in whether the exporting module uses Exporter or Sub::Exporter.
  
    use Some::Module qw(foo bar baz);
    use Some::Module qw(foo :bar baz);
  
  The definition for exporting in Exporter.pm might look like this:
  
    package Some::Module;
    use base qw(Exporter);
    our @EXPORT_OK   = qw(foo bar baz quux);
    our %EXPORT_TAGS = (bar => [ qw(bar baz) ]);
  
  Using Sub::Exporter, it would look like this:
  
    package Some::Module;
    use Sub::Exporter -setup => {
      exports => [ qw(foo bar baz quux) ],
      groups  => { bar => [ qw(bar baz) ]}
    };
  
  Sub::Exporter respects inheritance, so that a package may export inherited
  routines, and will export the most inherited version.  Exporting methods
  without currying away the invocant is a bad idea, but Sub::Exporter allows you
  to do just that -- and anyway, there are other uses for this feature, like
  packages of exported subroutines which use inheritance specifically to allow
  more specialized, but similar, packages.
  
  L<Exporter::Easy> provides a wrapper around the standard Exporter.  It makes it
  simpler to build groups, but doesn't provide any more functionality.  Because
  it is a front-end to Exporter, it will store your exporter's configuration in
  global package variables.
  
  =item * Attribute-Based Exporters
  
  Some exporters use attributes to mark variables to export.  L<Exporter::Simple>
  supports exporting any kind of symbol, and supports groups.  Using a module
  like Exporter or Sub::Exporter, it's easy to look at one place and see what is
  exported, but it's impossible to look at a variable definition and see whether
  it is exported by that alone.  Exporter::Simple makes this trade in reverse:
  each variable's declaration includes its export definition, but there is no one
  place to look to find a manifest of exports.
  
  More importantly, Exporter::Simple does not add any new features to those of
  Exporter.  In fact, like Exporter::Easy, it is just a front-end to Exporter, so
  it ends up storing its configuration in global package variables.  (This means
  that there is one place to look for your exporter's manifest, actually.  You
  can inspect the C<@EXPORT> package variables, and other related package
  variables, at runtime.)
  
  L<Perl6::Export> isn't actually attribute based, but looks similar.  Its syntax
  is borrowed from Perl 6, and implemented by a source filter.  It is a prototype
  of an interface that is still being designed.  It should probably be avoided
  for production work.  On the other hand, L<Perl6::Export::Attrs> implements
  Perl 6-like exporting, but translates it into Perl 5 by providing attributes.
  
  =item * Other Exporters
  
  L<Exporter::Renaming> wraps the standard Exporter to allow it to export symbols
  with changed names.
  
  L<Class::Exporter> performs a special kind of routine generation, giving each
  importing package an instance of your class, and then exporting the instance's
  methods as normal routines.  (Sub::Exporter, of course, can easily emulate this
  behavior, as shown above.)
  
  L<Exporter::Tidy> implements a form of renaming (using its C<_map> argument)
  and of prefixing, and implements groups.  It also avoids using package
  variables for its configuration.
  
  =back
  
  =head1 TODO
  
  =over
  
  =item * write a set of longer, more demonstrative examples
  
  =item * solidify the "custom exporter" interface (see C<&default_exporter>)
  
  =item * add an "always" group
  
  =back
  
  =head1 THANKS
  
  Hans Dieter Pearcey provided helpful advice while I was writing Sub::Exporter.
  Ian Langworth and Shawn Sorichetti asked some good questions and helped me
  improve my documentation quite a bit.  Yuval Kogman helped me find a bunch of
  little problems.
  
  Thanks, guys! 
  
  =head1 BUGS
  
  Please report any bugs or feature requests through the web interface at
  L<http://rt.cpan.org>. I will be notified, and then you'll automatically be
  notified of progress on your bug as I make changes.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2007 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_EXPORTER

$fatpacked{"Sub/Exporter/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_UTIL';
  use strict;
  use warnings;
  package Sub::Exporter::Util;
  {
    $Sub::Exporter::Util::VERSION = '0.987';
  }
  # ABSTRACT: utilities to make Sub::Exporter easier
  
  use Data::OptList ();
  use Params::Util ();
  
  
  sub curry_method {
    my $override_name = shift;
    sub {
      my ($class, $name) = @_;
      $name = $override_name if defined $override_name;
      sub { $class->$name(@_); };
    }
  }
  
  BEGIN { *curry_class = \&curry_method; }
  
  
  sub curry_chain {
    # In the future, we can make \%arg an optional prepend, like the "special"
    # args to the default Sub::Exporter-generated import routine.
    my (@opt_list) = @_;
  
    my $pairs = Data::OptList::mkopt(\@opt_list, 'args', 'ARRAY');
  
    sub {
      my ($class) = @_;
  
      sub {
        my $next = $class;
  
        for my $i (0 .. $#$pairs) {
          my $pair = $pairs->[ $i ];
          
          unless (Params::Util::_INVOCANT($next)) { ## no critic Private
            my $str = defined $next ? "'$next'" : 'undef';
            Carp::croak("can't call $pair->[0] on non-invocant $str")
          }
  
          my ($method, $args) = @$pair;
  
          if ($i == $#$pairs) {
            return $next->$method($args ? @$args : ());
          } else {
            $next = $next->$method($args ? @$args : ());
          }
        }
      };
    }
  }
  
  # =head2 name_map
  # 
  # This utility returns an list to be used in specify export generators.  For
  # example, the following:
  # 
  #   exports => {
  #     name_map(
  #       '_?_gen'  => [ qw(fee fie) ],
  #       '_make_?' => [ qw(foo bar) ],
  #     ),
  #   }
  # 
  # is equivalent to:
  # 
  #   exports => {
  #     name_map(
  #       fee => \'_fee_gen',
  #       fie => \'_fie_gen',
  #       foo => \'_make_foo',
  #       bar => \'_make_bar',
  #     ),
  #   }
  # 
  # This can save a lot of typing, when providing many exports with similarly-named
  # generators.
  # 
  # =cut
  # 
  # sub name_map {
  #   my (%groups) = @_;
  # 
  #   my %map;
  # 
  #   while (my ($template, $names) = each %groups) {
  #     for my $name (@$names) {
  #       (my $export = $template) =~ s/\?/$name/
  #         or Carp::croak 'no ? found in name_map template';
  # 
  #       $map{ $name } = \$export;
  #     }
  #   }
  # 
  #   return %map;
  # }
  
  
  sub merge_col {
    my (%groups) = @_;
  
    my %merged;
  
    while (my ($default_name, $group) = each %groups) {
      while (my ($export_name, $gen) = each %$group) {
        $merged{$export_name} = sub {
          my ($class, $name, $arg, $col) = @_;
  
          my $merged_arg = exists $col->{$default_name}
                         ? { %{ $col->{$default_name} }, %$arg }
                         : $arg;
  
          if (Params::Util::_CODELIKE($gen)) { ## no critic Private
            $gen->($class, $name, $merged_arg, $col);
          } else {
            $class->$$gen($name, $merged_arg, $col);
          }
        }
      }
    }
  
    return %merged;
  }
  
  
  sub __mixin_class_for {
    my ($class, $mix_into) = @_;
    require Package::Generator;
    my $mixin_class = Package::Generator->new_package({
      base => "$class\:\:__mixin__",
    });
  
    ## no critic (ProhibitNoStrict)
    no strict 'refs';
    if (ref $mix_into) {
      unshift @{"$mixin_class" . "::ISA"}, ref $mix_into;
    } else {
      unshift @{"$mix_into" . "::ISA"}, $mixin_class;
    }
    return $mixin_class;
  }
  
  sub mixin_installer {
    sub {
      my ($arg, $to_export) = @_;
  
      my $mixin_class = __mixin_class_for($arg->{class}, $arg->{into});
      bless $arg->{into} => $mixin_class if ref $arg->{into};
  
      Sub::Exporter::default_installer(
        { %$arg, into => $mixin_class },
        $to_export,
      );
    };
  }
  
  sub mixin_exporter {
    Carp::cluck "mixin_exporter is deprecated; use mixin_installer instead; it behaves identically";
    return mixin_installer;
  }
  
  
  sub like {
    sub {
      my ($value, $arg) = @_;
      Carp::croak "no regex supplied to regex group generator" unless $value;
  
      # Oh, qr//, how you bother me!  See the p5p thread from around now about
      # fixing this problem... too bad it won't help me. -- rjbs, 2006-04-25
      my @values = eval { $value->isa('Regexp') } ? ($value, undef)
                 :                                  @$value;
  
      while (my ($re, $opt) = splice @values, 0, 2) {
        Carp::croak "given pattern for regex group generater is not a Regexp"
          unless eval { $re->isa('Regexp') };
        my @exports  = keys %{ $arg->{config}->{exports} };
        my @matching = grep { $_ =~ $re } @exports;
  
        my %merge = $opt ? %$opt : ();
        my $prefix = (delete $merge{-prefix}) || '';
        my $suffix = (delete $merge{-suffix}) || '';
  
        for my $name (@matching) {
          my $as = $prefix . $name . $suffix;
          push @{ $arg->{import_args} }, [ $name => { %merge, -as => $as } ];
        }
      }
  
      1;
    }
  }
  
  use Sub::Exporter -setup => {
    exports => [ qw(
      like
      name_map
      merge_col
      curry_method curry_class
      curry_chain
      mixin_installer mixin_exporter
    ) ]
  };
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Sub::Exporter::Util - utilities to make Sub::Exporter easier
  
  =head1 VERSION
  
  version 0.987
  
  =head1 DESCRIPTION
  
  This module provides a number of utility functions for performing common or
  useful operations when setting up a Sub::Exporter configuration.  All of the
  utilities may be exported, but none are by default.
  
  =head1 THE UTILITIES
  
  =head2 curry_method
  
    exports => {
      some_method => curry_method,
    }
  
  This utility returns a generator which will produce an invocant-curried version
  of a method.  In other words, it will export a method call with the exporting
  class built in as the invocant.
  
  A module importing the code some the above example might do this:
  
    use Some::Module qw(some_method);
  
    my $x = some_method;
  
  This would be equivalent to:
  
    use Some::Module;
  
    my $x = Some::Module->some_method;
  
  If Some::Module is subclassed and the subclass's import method is called to
  import C<some_method>, the subclass will be curried in as the invocant.
  
  If an argument is provided for C<curry_method> it is used as the name of the
  curried method to export.  This means you could export a Widget constructor
  like this:
  
    exports => { widget => curry_method('new') }
  
  This utility may also be called as C<curry_class>, for backwards compatibility.
  
  =head2 curry_chain
  
  C<curry_chain> behaves like C<L</curry_method>>, but is meant for generating
  exports that will call several methods in succession.
  
    exports => {
      reticulate => curry_chain(
        new => gather_data => analyze => [ detail => 100 ] => 'results'
      ),
    }
  
  If imported from Spliner, calling the C<reticulate> routine will be equivalent
  to:
  
    Spliner->new->gather_data->analyze(detail => 100)->results;
  
  If any method returns something on which methods may not be called, the routine
  croaks.
  
  The arguments to C<curry_chain> form an optlist.  The names are methods to be
  called and the arguments, if given, are arrayrefs to be dereferenced and passed
  as arguments to those methods.  C<curry_chain> returns a generator like those
  expected by Sub::Exporter.
  
  B<Achtung!> at present, there is no way to pass arguments from the generated
  routine to the method calls.  This will probably be solved in future revisions
  by allowing the opt list's values to be subroutines that will be called with
  the generated routine's stack.
  
  =head2 merge_col
  
    exports => {
      merge_col(defaults => {
        twiddle => \'_twiddle_gen',
        tweak   => \&_tweak_gen,
      }),
    }
  
  This utility wraps the given generator in one that will merge the named
  collection into its args before calling it.  This means that you can support a
  "default" collector in multiple exports without writing the code each time.
  
  You can specify as many pairs of collection names and generators as you like.
  
  =head2 mixin_installer
  
    use Sub::Exporter -setup => {
      installer => Sub::Exporter::Util::mixin_installer,
      exports   => [ qw(foo bar baz) ],
    };
  
  This utility returns an installer that will install into a superclass and
  adjust the ISA importing class to include the newly generated superclass.
  
  If the target of importing is an object, the hierarchy is reversed: the new
  class will be ISA the object's class, and the object will be reblessed.
  
  B<Prerequisites>: This utility requires that Package::Generator be installed.
  
  =head2 like
  
  It's a collector that adds imports for anything like given regex.
  
  If you provide this configuration:
  
    exports    => [ qw(igrep imap islurp exhausted) ],
    collectors => { -like => Sub::Exporter::Util::like },
  
  A user may import from your module like this:
  
    use Your::Iterator -like => qr/^i/; # imports igre, imap, islurp
  
  or
  
    use Your::Iterator -like => [ qr/^i/ => { -prefix => 'your_' } ];
  
  The group-like prefix and suffix arguments are respected; other arguments are
  passed on to the generators for matching exports.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2007 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_EXPORTER_UTIL

$fatpacked{"Sub/Install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_INSTALL';
  use strict;
  use warnings;
  package Sub::Install;
  # ABSTRACT: install subroutines into packages easily
  $Sub::Install::VERSION = '0.928';
  use Carp;
  use Scalar::Util ();
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   use Sub::Install;
  #pod
  #pod   Sub::Install::install_sub({
  #pod     code => sub { ... },
  #pod     into => $package,
  #pod     as   => $subname
  #pod   });
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This module makes it easy to install subroutines into packages without the
  #pod unsightly mess of C<no strict> or typeglobs lying about where just anyone can
  #pod see them.
  #pod
  #pod =func install_sub
  #pod
  #pod   Sub::Install::install_sub({
  #pod    code => \&subroutine,
  #pod    into => "Finance::Shady",
  #pod    as   => 'launder',
  #pod   });
  #pod
  #pod This routine installs a given code reference into a package as a normal
  #pod subroutine.  The above is equivalent to:
  #pod
  #pod   no strict 'refs';
  #pod   *{"Finance::Shady" . '::' . "launder"} = \&subroutine;
  #pod
  #pod If C<into> is not given, the sub is installed into the calling package.
  #pod
  #pod If C<code> is not a code reference, it is looked for as an existing sub in the
  #pod package named in the C<from> parameter.  If C<from> is not given, it will look
  #pod in the calling package.
  #pod
  #pod If C<as> is not given, and if C<code> is a name, C<as> will default to C<code>.
  #pod If C<as> is not given, but if C<code> is a code ref, Sub::Install will try to
  #pod find the name of the given code ref and use that as C<as>.
  #pod
  #pod That means that this code:
  #pod
  #pod   Sub::Install::install_sub({
  #pod     code => 'twitch',
  #pod     from => 'Person::InPain',
  #pod     into => 'Person::Teenager',
  #pod     as   => 'dance',
  #pod   });
  #pod
  #pod is the same as:
  #pod
  #pod   package Person::Teenager;
  #pod
  #pod   Sub::Install::install_sub({
  #pod     code => Person::InPain->can('twitch'),
  #pod     as   => 'dance',
  #pod   });
  #pod
  #pod =func reinstall_sub
  #pod
  #pod This routine behaves exactly like C<L</install_sub>>, but does not emit a
  #pod warning if warnings are on and the destination is already defined.
  #pod
  #pod =cut
  
  sub _name_of_code {
    my ($code) = @_;
    require B;
    my $name = B::svref_2object($code)->GV->NAME;
    return $name unless $name =~ /\A__ANON__/;
    return;
  }
  
  # See also Params::Util, to which this code was donated.
  sub _CODELIKE {
    (Scalar::Util::reftype($_[0])||'') eq 'CODE'
    || Scalar::Util::blessed($_[0])
    && (overload::Method($_[0],'&{}') ? $_[0] : undef);
  }
  
  # do the heavy lifting
  sub _build_public_installer {
    my ($installer) = @_;
  
    sub {
      my ($arg) = @_;
      my ($calling_pkg) = caller(0);
  
      # I'd rather use ||= but I'm whoring for Devel::Cover.
      for (qw(into from)) { $arg->{$_} = $calling_pkg unless $arg->{$_} }
  
      # This is the only absolutely required argument, in many cases.
      Carp::croak "named argument 'code' is not optional" unless $arg->{code};
  
      if (_CODELIKE($arg->{code})) {
        $arg->{as} ||= _name_of_code($arg->{code});
      } else {
        Carp::croak
          "couldn't find subroutine named $arg->{code} in package $arg->{from}"
          unless my $code = $arg->{from}->can($arg->{code});
  
        $arg->{as}   = $arg->{code} unless $arg->{as};
        $arg->{code} = $code;
      }
  
      Carp::croak "couldn't determine name under which to install subroutine"
        unless $arg->{as};
  
      $installer->(@$arg{qw(into as code) });
    }
  }
  
  # do the ugly work
  
  my $_misc_warn_re;
  my $_redef_warn_re;
  BEGIN {
    $_misc_warn_re = qr/
      Prototype\ mismatch:\ sub\ .+?  |
      Constant subroutine .+? redefined
    /x;
    $_redef_warn_re = qr/Subroutine\ .+?\ redefined/x;
  }
  
  my $eow_re;
  BEGIN { $eow_re = qr/ at .+? line \d+\.\Z/ };
  
  sub _do_with_warn {
    my ($arg) = @_;
    my $code = delete $arg->{code};
    my $wants_code = sub {
      my $code = shift;
      sub {
        my $warn = $SIG{__WARN__} ? $SIG{__WARN__} : sub { warn @_ }; ## no critic
        local $SIG{__WARN__} = sub {
          my ($error) = @_;
          for (@{ $arg->{suppress} }) {
              return if $error =~ $_;
          }
          for (@{ $arg->{croak} }) {
            if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
              Carp::croak $base_error;
            }
          }
          for (@{ $arg->{carp} }) {
            if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
              return $warn->(Carp::shortmess $base_error);
            }
          }
          ($arg->{default} || $warn)->($error);
        };
        $code->(@_);
      };
    };
    return $wants_code->($code) if $code;
    return $wants_code;
  }
  
  sub _installer {
    sub {
      my ($pkg, $name, $code) = @_;
      no strict 'refs'; ## no critic ProhibitNoStrict
      *{"$pkg\::$name"} = $code;
      return $code;
    }
  }
  
  BEGIN {
    *_ignore_warnings = _do_with_warn({
      carp => [ $_misc_warn_re, $_redef_warn_re ]
    });
  
    *install_sub = _build_public_installer(_ignore_warnings(_installer));
  
    *_carp_warnings =  _do_with_warn({
      carp     => [ $_misc_warn_re ],
      suppress => [ $_redef_warn_re ],
    });
  
    *reinstall_sub = _build_public_installer(_carp_warnings(_installer));
  
    *_install_fatal = _do_with_warn({
      code     => _installer,
      croak    => [ $_redef_warn_re ],
    });
  }
  
  #pod =func install_installers
  #pod
  #pod This routine is provided to allow Sub::Install compatibility with
  #pod Sub::Installer.  It installs C<install_sub> and C<reinstall_sub> methods into
  #pod the package named by its argument.
  #pod
  #pod  Sub::Install::install_installers('Code::Builder'); # just for us, please
  #pod  Code::Builder->install_sub({ name => $code_ref });
  #pod
  #pod  Sub::Install::install_installers('UNIVERSAL'); # feeling lucky, punk?
  #pod  Anything::At::All->install_sub({ name => $code_ref });
  #pod
  #pod The installed installers are similar, but not identical, to those provided by
  #pod Sub::Installer.  They accept a single hash as an argument.  The key/value pairs
  #pod are used as the C<as> and C<code> parameters to the C<install_sub> routine
  #pod detailed above.  The package name on which the method is called is used as the
  #pod C<into> parameter.
  #pod
  #pod Unlike Sub::Installer's C<install_sub> will not eval strings into code, but
  #pod will look for named code in the calling package.
  #pod
  #pod =cut
  
  sub install_installers {
    my ($into) = @_;
  
    for my $method (qw(install_sub reinstall_sub)) {
      my $code = sub {
        my ($package, $subs) = @_;
        my ($caller) = caller(0);
        my $return;
        for (my ($name, $sub) = %$subs) {
          $return = Sub::Install->can($method)->({
            code => $sub,
            from => $caller,
            into => $package,
            as   => $name
          });
        }
        return $return;
      };
      install_sub({ code => $code, into => $into, as => $method });
    }
  }
  
  #pod =head1 EXPORTS
  #pod
  #pod Sub::Install exports C<install_sub> and C<reinstall_sub> only if they are
  #pod requested.
  #pod
  #pod =head2 exporter
  #pod
  #pod Sub::Install has a never-exported subroutine called C<exporter>, which is used
  #pod to implement its C<import> routine.  It takes a hashref of named arguments,
  #pod only one of which is currently recognize: C<exports>.  This must be an arrayref
  #pod of subroutines to offer for export.
  #pod
  #pod This routine is mainly for Sub::Install's own consumption.  Instead, consider
  #pod L<Sub::Exporter>.
  #pod
  #pod =cut
  
  sub exporter {
    my ($arg) = @_;
  
    my %is_exported = map { $_ => undef } @{ $arg->{exports} };
  
    sub {
      my $class = shift;
      my $target = caller;
      for (@_) {
        Carp::croak "'$_' is not exported by $class" if !exists $is_exported{$_};
        install_sub({ code => $_, from => $class, into => $target });
      }
    }
  }
  
  BEGIN { *import = exporter({ exports => [ qw(install_sub reinstall_sub) ] }); }
  
  #pod =head1 SEE ALSO
  #pod
  #pod =over
  #pod
  #pod =item L<Sub::Installer>
  #pod
  #pod This module is (obviously) a reaction to Damian Conway's Sub::Installer, which
  #pod does the same thing, but does it by getting its greasy fingers all over
  #pod UNIVERSAL.  I was really happy about the idea of making the installation of
  #pod coderefs less ugly, but I couldn't bring myself to replace the ugliness of
  #pod typeglobs and loosened strictures with the ugliness of UNIVERSAL methods.
  #pod
  #pod =item L<Sub::Exporter>
  #pod
  #pod This is a complete Exporter.pm replacement, built atop Sub::Install.
  #pod
  #pod =back
  #pod
  #pod =head1 EXTRA CREDITS
  #pod
  #pod Several of the tests are adapted from tests that shipped with Damian Conway's
  #pod Sub-Installer distribution.
  #pod
  #pod =cut
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Sub::Install - install subroutines into packages easily
  
  =head1 VERSION
  
  version 0.928
  
  =head1 SYNOPSIS
  
    use Sub::Install;
  
    Sub::Install::install_sub({
      code => sub { ... },
      into => $package,
      as   => $subname
    });
  
  =head1 DESCRIPTION
  
  This module makes it easy to install subroutines into packages without the
  unsightly mess of C<no strict> or typeglobs lying about where just anyone can
  see them.
  
  =head1 FUNCTIONS
  
  =head2 install_sub
  
    Sub::Install::install_sub({
     code => \&subroutine,
     into => "Finance::Shady",
     as   => 'launder',
    });
  
  This routine installs a given code reference into a package as a normal
  subroutine.  The above is equivalent to:
  
    no strict 'refs';
    *{"Finance::Shady" . '::' . "launder"} = \&subroutine;
  
  If C<into> is not given, the sub is installed into the calling package.
  
  If C<code> is not a code reference, it is looked for as an existing sub in the
  package named in the C<from> parameter.  If C<from> is not given, it will look
  in the calling package.
  
  If C<as> is not given, and if C<code> is a name, C<as> will default to C<code>.
  If C<as> is not given, but if C<code> is a code ref, Sub::Install will try to
  find the name of the given code ref and use that as C<as>.
  
  That means that this code:
  
    Sub::Install::install_sub({
      code => 'twitch',
      from => 'Person::InPain',
      into => 'Person::Teenager',
      as   => 'dance',
    });
  
  is the same as:
  
    package Person::Teenager;
  
    Sub::Install::install_sub({
      code => Person::InPain->can('twitch'),
      as   => 'dance',
    });
  
  =head2 reinstall_sub
  
  This routine behaves exactly like C<L</install_sub>>, but does not emit a
  warning if warnings are on and the destination is already defined.
  
  =head2 install_installers
  
  This routine is provided to allow Sub::Install compatibility with
  Sub::Installer.  It installs C<install_sub> and C<reinstall_sub> methods into
  the package named by its argument.
  
   Sub::Install::install_installers('Code::Builder'); # just for us, please
   Code::Builder->install_sub({ name => $code_ref });
  
   Sub::Install::install_installers('UNIVERSAL'); # feeling lucky, punk?
   Anything::At::All->install_sub({ name => $code_ref });
  
  The installed installers are similar, but not identical, to those provided by
  Sub::Installer.  They accept a single hash as an argument.  The key/value pairs
  are used as the C<as> and C<code> parameters to the C<install_sub> routine
  detailed above.  The package name on which the method is called is used as the
  C<into> parameter.
  
  Unlike Sub::Installer's C<install_sub> will not eval strings into code, but
  will look for named code in the calling package.
  
  =head1 EXPORTS
  
  Sub::Install exports C<install_sub> and C<reinstall_sub> only if they are
  requested.
  
  =head2 exporter
  
  Sub::Install has a never-exported subroutine called C<exporter>, which is used
  to implement its C<import> routine.  It takes a hashref of named arguments,
  only one of which is currently recognize: C<exports>.  This must be an arrayref
  of subroutines to offer for export.
  
  This routine is mainly for Sub::Install's own consumption.  Instead, consider
  L<Sub::Exporter>.
  
  =head1 SEE ALSO
  
  =over
  
  =item L<Sub::Installer>
  
  This module is (obviously) a reaction to Damian Conway's Sub::Installer, which
  does the same thing, but does it by getting its greasy fingers all over
  UNIVERSAL.  I was really happy about the idea of making the installation of
  coderefs less ugly, but I couldn't bring myself to replace the ugliness of
  typeglobs and loosened strictures with the ugliness of UNIVERSAL methods.
  
  =item L<Sub::Exporter>
  
  This is a complete Exporter.pm replacement, built atop Sub::Install.
  
  =back
  
  =head1 EXTRA CREDITS
  
  Several of the tests are adapted from tests that shipped with Damian Conway's
  Sub-Installer distribution.
  
  =head1 AUTHOR
  
  Ricardo SIGNES <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2005 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_INSTALL

$fatpacked{"Term/Spark.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_SPARK';
  package Term::Spark;
  
  use strict;
  use warnings;
  use utf8;
  
  use Sub::Exporter -setup => {
      'exports' => [ 'show_bar', 'show_graph' ],
  };
  
  our @ISA = qw();
  
  our $VERSION = '0.25'; # VERSION
  
  sub show_bar {
      my $num = shift;
      my $max = shift;
  
      my @graph  = qw{ ▁ ▂ ▃ ▄ ▅ ▆ ▇ █ };
  
      my $index = ( $num * ( scalar( @graph ) - 1 )  ) / $max;
  
      return $graph[ int $index ];
  }
  
  sub show_graph {
      my %args = @_;
  
      my $max    = $args{'max'}    || 0;
      my $values = $args{'values'} || [];
      my $result = q{};
  
      for my $value ( @{ $values } ) {
          $result .= show_bar( $value, $max );
      }
  
      return $result;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Term::Spark
  
  =head1 SYNOPSIS
  
  Displays beautiful graphs to use in the terminal
  
  =head1 DESCRIPTION
  
  =head2 METHODS
  
  Returns a string with a single utf8 bar according to the value
  
      Term::Spark::show_bar($value_for_this_bar, $max_value);
  
  Returns a string with a bunch of utf8 bars according to the values
  
      Term::Spark::show_graph('max' => $max_value, 'values' => \@values);
  
  Example:
  
      A script to capture args or STDIN and print a graph:
  
      use Term::Spark;
  
      chomp( @ARGV = <STDIN> ) unless @ARGV;
  
      my @list = sort { $a <=> $b } @ARGV;
  
      print Term::Spark::show_graph(
          'max'     => $list[-1],
          'values'  => \@ARGV,
      );
  
  =head1 NAME
  
  Term::Spark - Perl extension for dispaying bars in the terminal
  
  =head1 SEE ALSO
  
  Original idea: https://github.com/holman/spark
  
  =head1 AUTHOR
  
  Gil Gonçalves <lurst@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Gil Gonçalves.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
TERM_SPARK

$fatpacked{"darwin-2level/Params/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_PARAMS_UTIL';
  package Params::Util;
  
  =pod
  
  =head1 NAME
  
  Params::Util - Simple, compact and correct param-checking functions
  
  =head1 SYNOPSIS
  
    # Import some functions
    use Params::Util qw{_SCALAR _HASH _INSTANCE};
    
    # If you are lazy, or need a lot of them...
    use Params::Util ':ALL';
    
    sub foo {
        my $object  = _INSTANCE(shift, 'Foo') or return undef;
        my $image   = _SCALAR(shift)          or return undef;
        my $options = _HASH(shift)            or return undef;
        # etc...
    }
  
  =head1 DESCRIPTION
  
  C<Params::Util> provides a basic set of importable functions that makes
  checking parameters a hell of a lot easier
  
  While they can be (and are) used in other contexts, the main point
  behind this module is that the functions B<both> Do What You Mean,
  and Do The Right Thing, so they are most useful when you are getting
  params passed into your code from someone and/or somewhere else
  and you can't really trust the quality.
  
  Thus, C<Params::Util> is of most use at the edges of your API, where
  params and data are coming in from outside your code.
  
  The functions provided by C<Params::Util> check in the most strictly
  correct manner known, are documented as thoroughly as possible so their
  exact behaviour is clear, and heavily tested so make sure they are not
  fooled by weird data and Really Bad Things.
  
  To use, simply load the module providing the functions you want to use
  as arguments (as shown in the SYNOPSIS).
  
  To aid in maintainability, C<Params::Util> will B<never> export by
  default.
  
  You must explicitly name the functions you want to export, or use the
  C<:ALL> param to just have it export everything (although this is not
  recommended if you have any _FOO functions yourself with which future
  additions to C<Params::Util> may clash)
  
  =head1 FUNCTIONS
  
  =cut
  
  use 5.00503;
  use strict;
  require overload;
  require Exporter;
  require Scalar::Util;
  require DynaLoader;
  
  use vars qw{$VERSION @ISA @EXPORT_OK %EXPORT_TAGS};
  
  $VERSION   = '1.07';
  @ISA       = qw{
  	Exporter
  	DynaLoader
  };
  @EXPORT_OK = qw{
  	_STRING     _IDENTIFIER
  	_CLASS      _CLASSISA   _SUBCLASS  _DRIVER  _CLASSDOES
  	_NUMBER     _POSINT     _NONNEGINT
  	_SCALAR     _SCALAR0
  	_ARRAY      _ARRAY0     _ARRAYLIKE
  	_HASH       _HASH0      _HASHLIKE
  	_CODE       _CODELIKE
  	_INVOCANT   _REGEX      _INSTANCE  _INSTANCEDOES
  	_SET        _SET0
  	_HANDLE
  };
  %EXPORT_TAGS = ( ALL => \@EXPORT_OK );
  
  eval {
  	local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
  	bootstrap Params::Util $VERSION;
  	1;
  } unless $ENV{PERL_PARAMS_UTIL_PP};
  
  # Use a private pure-perl copy of looks_like_number if the version of
  # Scalar::Util is old (for whatever reason).
  my $SU = eval "$Scalar::Util::VERSION" || 0;
  if ( $SU >= 1.18 ) { 
  	Scalar::Util->import('looks_like_number');
  } else {
  	eval <<'END_PERL';
  sub looks_like_number {
  	local $_ = shift;
  
  	# checks from perlfaq4
  	return 0 if !defined($_);
  	if (ref($_)) {
  		return overload::Overloaded($_) ? defined(0 + $_) : 0;
  	}
  	return 1 if (/^[+-]?[0-9]+$/); # is a +/- integer
  	return 1 if (/^([+-]?)(?=[0-9]|\.[0-9])[0-9]*(\.[0-9]*)?([Ee]([+-]?[0-9]+))?$/); # a C float
  	return 1 if ($] >= 5.008 and /^(Inf(inity)?|NaN)$/i) or ($] >= 5.006001 and /^Inf$/i);
  
  	0;
  }
  END_PERL
  }
  
  
  
  
  
  #####################################################################
  # Param Checking Functions
  
  =pod
  
  =head2 _STRING $string
  
  The C<_STRING> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a normal non-false string of non-zero length.
  
  Note that this will NOT do anything magic to deal with the special
  C<'0'> false negative case, but will return it.
  
    # '0' not considered valid data
    my $name = _STRING(shift) or die "Bad name";
    
    # '0' is considered valid data
    my $string = _STRING($_[0]) ? shift : die "Bad string";
  
  Please also note that this function expects a normal string. It does
  not support overloading or other magic techniques to get a string.
  
  Returns the string as a conveince if it is a valid string, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_STRING;
  sub _STRING ($) {
  	(defined $_[0] and ! ref $_[0] and length($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _IDENTIFIER $string
  
  The C<_IDENTIFIER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl identifier.
  
  Returns the string as a convenience if it is a valid identifier, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_IDENTIFIER;
  sub _IDENTIFIER ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASS $string
  
  The C<_CLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl class.
  
  This function only checks that the format is valid, not that the
  class is actually loaded. It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASS;
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASSISA $string, $class
  
  The C<_CLASSISA> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a particularly class, or a subclass of it.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSISA;
  sub _CLASSISA ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =head2 _CLASSDOES $string, $role
  
  This routine behaves exactly like C<L</_CLASSISA>>, but checks with C<< ->DOES
  >> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
  5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
  implemented.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSDOES;
  sub _CLASSDOES ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SUBCLASS $string, $class
  
  The C<_SUBCLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a subclass of a specified class.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SUBCLASS;
  sub _SUBCLASS ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0] ne $_[1] and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NUMBER $scalar
  
  The C<_NUMBER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a number. That is, it is defined and perl thinks it's a number.
  
  This function is basically a Params::Util-style wrapper around the
  L<Scalar::Util> C<looks_like_number> function.
  
  Returns the value as a convience, or C<undef> if the value is not a
  number.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NUMBER;
  sub _NUMBER ($) {
  	( defined $_[0] and ! ref $_[0] and looks_like_number($_[0]) )
  	? $_[0]
  	: undef;
  }
  END_PERL
  
  =pod
  
  =head2 _POSINT $integer
  
  The C<_POSINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a positive integer (of any length).
  
  Returns the value as a convience, or C<undef> if the value is not a
  positive integer.
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_POSINT;
  sub _POSINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[1-9]\d*$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NONNEGINT $integer
  
  The C<_NONNEGINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a non-negative integer (of any length). That is, a positive integer,
  or zero.
  
  Returns the value as a convience, or C<undef> if the value is not a
  non-negative integer.
  
  As with other tests that may return false values, care should be taken
  to test via "defined" in boolean validy contexts.
  
    unless ( defined _NONNEGINT($value) ) {
       die "Invalid value";
    }
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NONNEGINT;
  sub _NONNEGINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^(?:0|[1-9]\d*)$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR \$scalar
  
  The C<_SCALAR> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR> reference, with content of non-zero length.
  
  For a version that allows zero length C<SCALAR> references, see
  the C<_SCALAR0> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR;
  sub _SCALAR ($) {
  	(ref $_[0] eq 'SCALAR' and defined ${$_[0]} and ${$_[0]} ne '') ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR0 \$scalar
  
  The C<_SCALAR0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR0> reference, allowing content of zero-length.
  
  For a simpler "give me some content" version that requires non-zero
  length, C<_SCALAR> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR0;
  sub _SCALAR0 ($) {
  	ref $_[0] eq 'SCALAR' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY $value
  
  The C<_ARRAY> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference containing B<at least> one element of any kind.
  
  For a more basic form that allows zero length ARRAY references, see
  the C<_ARRAY0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY;
  sub _ARRAY ($) {
  	(ref $_[0] eq 'ARRAY' and @{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY0 $value
  
  The C<_ARRAY0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference, allowing C<ARRAY> references that contain no
  elements.
  
  For a more basic "An array of something" form that also requires at
  least one element, see the C<_ARRAY> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY0;
  sub _ARRAY0 ($) {
  	ref $_[0] eq 'ARRAY' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAYLIKE $value
  
  The C<_ARRAYLIKE> function tests whether a given scalar value can respond to
  array dereferencing.  If it can, the value is returned.  If it cannot,
  C<_ARRAYLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAYLIKE;
  sub _ARRAYLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'ARRAY')
  		or
  		overload::Method($_[0], '@{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH $value
  
  The C<_HASH> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference with at least one entry.
  
  For a version of this function that allows the C<HASH> to be empty,
  see the C<_HASH0> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH;
  sub _HASH ($) {
  	(ref $_[0] eq 'HASH' and scalar %{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH0 $value
  
  The C<_HASH0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference, regardless of the C<HASH> content.
  
  For a simpler "A hash of something" version that requires at least one
  element, see the C<_HASH> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH0;
  sub _HASH0 ($) {
  	ref $_[0] eq 'HASH' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASHLIKE $value
  
  The C<_HASHLIKE> function tests whether a given scalar value can respond to
  hash dereferencing.  If it can, the value is returned.  If it cannot,
  C<_HASHLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASHLIKE;
  sub _HASHLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'HASH')
  		or
  		overload::Method($_[0], '%{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODE $value
  
  The C<_CODE> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<CODE> reference.
  
  Returns the C<CODE> reference itself as a convenience, or C<undef>
  if the value provided is not an C<CODE> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODE;
  sub _CODE ($) {
  	ref $_[0] eq 'CODE' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODELIKE $value
  
  The C<_CODELIKE> is the more generic version of C<_CODE>. Unlike C<_CODE>,
  which checks for an explicit C<CODE> reference, the C<_CODELIKE> function
  also includes things that act like them, such as blessed objects that
  overload C<'&{}'>.
  
  Please note that in the case of objects overloaded with '&{}', you will
  almost always end up also testing it in 'bool' context at some stage.
  
  For example:
  
    sub foo {
        my $code1 = _CODELIKE(shift) or die "No code param provided";
        my $code2 = _CODELIKE(shift);
        if ( $code2 ) {
             print "Got optional second code param";
        }
    }
  
  As such, you will most likely always want to make sure your class has
  at least the following to allow it to evaluate to true in boolean
  context.
  
    # Always evaluate to true in boolean context
    use overload 'bool' => sub () { 1 };
  
  Returns the callable value as a convenience, or C<undef> if the
  value provided is not callable.
  
  Note - This function was formerly known as _CALLABLE but has been renamed
  for greater symmetry with the other _XXXXLIKE functions.
  
  The use of _CALLABLE has been deprecated. It will continue to work, but
  with a warning, until end-2006, then will be removed.
  
  I apologise for any inconvenience caused.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODELIKE;
  sub _CODELIKE($) {
  	(
  		(Scalar::Util::reftype($_[0])||'') eq 'CODE'
  		or
  		Scalar::Util::blessed($_[0]) and overload::Method($_[0],'&{}')
  	)
  	? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INVOCANT $value
  
  This routine tests whether the given value is a valid method invocant.
  This can be either an instance of an object, or a class name.
  
  If so, the value itself is returned.  Otherwise, C<_INVOCANT>
  returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INVOCANT;
  sub _INVOCANT($) {
  	(defined $_[0] and
  		(defined Scalar::Util::blessed($_[0])
  		or      
  		# We used to check for stash definedness, but any class-like name is a
  		# valid invocant for UNIVERSAL methods, so we stopped. -- rjbs, 2006-07-02
  		Params::Util::_CLASS($_[0]))
  	) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INSTANCE $object, $class
  
  The C<_INSTANCE> function is intended to be imported into your package,
  and provides a convenient way to test for an object of a particular class
  in a strictly correct manner.
  
  Returns the object itself as a convenience, or C<undef> if the value
  provided is not an object of that type.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCE;
  sub _INSTANCE ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =head2 _INSTANCEDOES $object, $role
  
  This routine behaves exactly like C<L</_INSTANCE>>, but checks with C<< ->DOES
  >> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
  5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
  implemented.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCEDOES;
  sub _INSTANCEDOES ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _REGEX $value
  
  The C<_REGEX> function is intended to be imported into your package,
  and provides a convenient way to test for a regular expression.
  
  Returns the value itself as a convenience, or C<undef> if the value
  provided is not a regular expression.
  
  =cut
  
  eval <<'END_PERL' unless defined &_REGEX;
  sub _REGEX ($) {
  	(defined $_[0] and 'Regexp' eq ref($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SET \@array, $class
  
  The C<_SET> function is intended to be imported into your package,
  and provides a convenient way to test for set of at least one object of
  a particular class in a strictly correct manner.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that allows zero-length sets, see the
  C<_SET0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET;
  sub _SET ($$) {
  	my $set = shift;
  	_ARRAY($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _SET0 \@array, $class
  
  The C<_SET0> function is intended to be imported into your package,
  and provides a convenient way to test for a set of objects of a
  particular class in a strictly correct manner, allowing for zero objects.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that requires at least one object, see the
  C<_SET> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET0;
  sub _SET0 ($$) {
  	my $set = shift;
  	_ARRAY0($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _HANDLE
  
  The C<_HANDLE> function is intended to be imported into your package,
  and provides a convenient way to test whether or not a single scalar
  value is a file handle.
  
  Unfortunately, in Perl the definition of a file handle can be a little
  bit fuzzy, so this function is likely to be somewhat imperfect (at first
  anyway).
  
  That said, it is implement as well or better than the other file handle
  detectors in existance (and we stole from the best of them).
  
  =cut
  
  # We're doing this longhand for now. Once everything is perfect,
  # we'll compress this into something that compiles more efficiently.
  # Further, testing file handles is not something that is generally
  # done millions of times, so doing it slowly is not a big speed hit.
  eval <<'END_PERL' unless defined &_HANDLE;
  sub _HANDLE {
  	my $it = shift;
  
  	# It has to be defined, of course
  	unless ( defined $it ) {
  		return undef;
  	}
  
  	# Normal globs are considered to be file handles
  	if ( ref $it eq 'GLOB' ) {
  		return $it;
  	}
  
  	# Check for a normal tied filehandle
  	# Side Note: 5.5.4's tied() and can() doesn't like getting undef
  	if ( tied($it) and tied($it)->can('TIEHANDLE') ) {
  		return $it;
  	}
  
  	# There are no other non-object handles that we support
  	unless ( Scalar::Util::blessed($it) ) {
  		return undef;
  	}
  
  	# Check for a common base classes for conventional IO::Handle object
  	if ( $it->isa('IO::Handle') ) {
  		return $it;
  	}
  
  
  	# Check for tied file handles using Tie::Handle
  	if ( $it->isa('Tie::Handle') ) {
  		return $it;
  	}
  
  	# IO::Scalar is not a proper seekable, but it is valid is a
  	# regular file handle
  	if ( $it->isa('IO::Scalar') ) {
  		return $it;
  	}
  
  	# Yet another special case for IO::String, which refuses (for now
  	# anyway) to become a subclass of IO::Handle.
  	if ( $it->isa('IO::String') ) {
  		return $it;
  	}
  
  	# This is not any sort of object we know about
  	return undef;
  }
  END_PERL
  
  =pod
  
  =head2 _DRIVER $string
  
    sub foo {
      my $class = _DRIVER(shift, 'My::Driver::Base') or die "Bad driver";
      ...
    }
  
  The C<_DRIVER> function is intended to be imported into your
  package, and provides a convenient way to load and validate
  a driver class.
  
  The most common pattern when taking a driver class as a parameter
  is to check that the name is a class (i.e. check against _CLASS)
  and then to load the class (if it exists) and then ensure that
  the class returns true for the isa method on some base driver name.
  
  Return the value as a convenience, or C<undef> if the value is not
  a class name, the module does not exist, the module does not load,
  or the class fails the isa test.
  
  =cut
  
  eval <<'END_PERL' unless defined &_DRIVER;
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  END_PERL
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Add _CAN to help resolve the UNIVERSAL::can debacle
  
  - Would be even nicer if someone would demonstrate how the hell to
  build a Module::Install dist of the ::Util dual Perl/XS type. :/
  
  - Implement an assertion-like version of this module, that dies on
  error.
  
  - Implement a Test:: version of this module, for use in testing
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params-Util>
  
  For other issues, contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Params::Validate>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2012 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
DARWIN-2LEVEL_PARAMS_UTIL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use Term::Spark qw{ show_graph };

use strict;
use warnings;

our $VERSION = '0.25'; # VERSION
# PODNAME: show_graph

binmode STDOUT, ':encoding(UTF-8)';

chomp( @ARGV = <STDIN> ) unless @ARGV;

my @list = sort { $a <=> $b } @ARGV;

print show_graph(
    'max'     => $list[-1],
    'values'  => \@ARGV,
), "\n";

__END__

=pod

=encoding utf-8

=head1 NAME

show_graph

=head1 AUTHOR

Gil Gonçalves <lurst@cpan.org>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2013 by Gil Gonçalves.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut
