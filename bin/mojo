#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Getopt/Long.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG';
  #! perl
  
  # Getopt::Long.pm -- Universal options parsing
  # Author          : Johan Vromans
  # Created On      : Tue Sep 11 15:00:12 1990
  # Last Modified By: Johan Vromans
  # Last Modified On: Sat May 27 12:11:39 2017
  # Update Count    : 1715
  # Status          : Released
  
  ################ Module Preamble ################
  
  use 5.004;
  
  use strict;
  use warnings;
  
  package Getopt::Long;
  
  use vars qw($VERSION);
  $VERSION        =  2.50;
  # For testing versions only.
  use vars qw($VERSION_STRING);
  $VERSION_STRING = "2.50";
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  # Exported subroutines.
  sub GetOptions(@);		# always
  sub GetOptionsFromArray(@);	# on demand
  sub GetOptionsFromString(@);	# on demand
  sub Configure(@);		# on demand
  sub HelpMessage(@);		# on demand
  sub VersionMessage(@);		# in demand
  
  BEGIN {
      # Init immediately so their contents can be used in the 'use vars' below.
      @EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
      @EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
  		    &GetOptionsFromArray &GetOptionsFromString);
  }
  
  # User visible variables.
  use vars @EXPORT, @EXPORT_OK;
  use vars qw($error $debug $major_version $minor_version);
  # Deprecated visible variables.
  use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
  	    $passthrough);
  # Official invisible variables.
  use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
  
  # Really invisible variables.
  my $bundling_values;
  
  # Public subroutines.
  sub config(@);			# deprecated name
  
  # Private subroutines.
  sub ConfigDefaults();
  sub ParseOptionSpec($$);
  sub OptCtl($);
  sub FindOption($$$$$);
  sub ValidValue ($$$$$);
  
  ################ Local Variables ################
  
  # $requested_version holds the version that was mentioned in the 'use'
  # or 'require', if any. It can be used to enable or disable specific
  # features.
  my $requested_version = 0;
  
  ################ Resident subroutines ################
  
  sub ConfigDefaults() {
      # Handle POSIX compliancy.
      if ( defined $ENV{"POSIXLY_CORRECT"} ) {
  	$genprefix = "(--|-)";
  	$autoabbrev = 0;		# no automatic abbrev of options
  	$bundling = 0;			# no bundling of single letter switches
  	$getopt_compat = 0;		# disallow '+' to start options
  	$order = $REQUIRE_ORDER;
      }
      else {
  	$genprefix = "(--|-|\\+)";
  	$autoabbrev = 1;		# automatic abbrev of options
  	$bundling = 0;			# bundling off by default
  	$getopt_compat = 1;		# allow '+' to start options
  	$order = $PERMUTE;
      }
      # Other configurable settings.
      $debug = 0;			# for debugging
      $error = 0;			# error tally
      $ignorecase = 1;		# ignore case when matching options
      $passthrough = 0;		# leave unrecognized options alone
      $gnu_compat = 0;		# require --opt=val if value is optional
      $longprefix = "(--)";       # what does a long prefix look like
      $bundling_values = 0;	# no bundling of values
  }
  
  # Override import.
  sub import {
      my $pkg = shift;		# package
      my @syms = ();		# symbols to import
      my @config = ();		# configuration
      my $dest = \@syms;		# symbols first
      for ( @_ ) {
  	if ( $_ eq ':config' ) {
  	    $dest = \@config;	# config next
  	    next;
  	}
  	push(@$dest, $_);	# push
      }
      # Hide one level and call super.
      local $Exporter::ExportLevel = 1;
      push(@syms, qw(&GetOptions)) if @syms; # always export GetOptions
      $requested_version = 0;
      $pkg->SUPER::import(@syms);
      # And configure.
      Configure(@config) if @config;
  }
  
  ################ Initialization ################
  
  # Values for $order. See GNU getopt.c for details.
  ($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
  # Version major/minor numbers.
  ($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;
  
  ConfigDefaults();
  
  ################ OO Interface ################
  
  package Getopt::Long::Parser;
  
  # Store a copy of the default configuration. Since ConfigDefaults has
  # just been called, what we get from Configure is the default.
  my $default_config = do {
      Getopt::Long::Configure ()
  };
  
  sub new {
      my $that = shift;
      my $class = ref($that) || $that;
      my %atts = @_;
  
      # Register the callers package.
      my $self = { caller_pkg => (caller)[0] };
  
      bless ($self, $class);
  
      # Process config attributes.
      if ( defined $atts{config} ) {
  	my $save = Getopt::Long::Configure ($default_config, @{$atts{config}});
  	$self->{settings} = Getopt::Long::Configure ($save);
  	delete ($atts{config});
      }
      # Else use default config.
      else {
  	$self->{settings} = $default_config;
      }
  
      if ( %atts ) {		# Oops
  	die(__PACKAGE__.": unhandled attributes: ".
  	    join(" ", sort(keys(%atts)))."\n");
      }
  
      $self;
  }
  
  sub configure {
      my ($self) = shift;
  
      # Restore settings, merge new settings in.
      my $save = Getopt::Long::Configure ($self->{settings}, @_);
  
      # Restore orig config and save the new config.
      $self->{settings} = Getopt::Long::Configure ($save);
  }
  
  sub getoptions {
      my ($self) = shift;
  
      return $self->getoptionsfromarray(\@ARGV, @_);
  }
  
  sub getoptionsfromarray {
      my ($self) = shift;
  
      # Restore config settings.
      my $save = Getopt::Long::Configure ($self->{settings});
  
      # Call main routine.
      my $ret = 0;
      $Getopt::Long::caller = $self->{caller_pkg};
  
      eval {
  	# Locally set exception handler to default, otherwise it will
  	# be called implicitly here, and again explicitly when we try
  	# to deliver the messages.
  	local ($SIG{__DIE__}) = 'DEFAULT';
  	$ret = Getopt::Long::GetOptionsFromArray (@_);
      };
  
      # Restore saved settings.
      Getopt::Long::Configure ($save);
  
      # Handle errors and return value.
      die ($@) if $@;
      return $ret;
  }
  
  package Getopt::Long;
  
  ################ Back to Normal ################
  
  # Indices in option control info.
  # Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
  use constant CTL_TYPE    => 0;
  #use constant   CTL_TYPE_FLAG   => '';
  #use constant   CTL_TYPE_NEG    => '!';
  #use constant   CTL_TYPE_INCR   => '+';
  #use constant   CTL_TYPE_INT    => 'i';
  #use constant   CTL_TYPE_INTINC => 'I';
  #use constant   CTL_TYPE_XINT   => 'o';
  #use constant   CTL_TYPE_FLOAT  => 'f';
  #use constant   CTL_TYPE_STRING => 's';
  
  use constant CTL_CNAME   => 1;
  
  use constant CTL_DEFAULT => 2;
  
  use constant CTL_DEST    => 3;
   use constant   CTL_DEST_SCALAR => 0;
   use constant   CTL_DEST_ARRAY  => 1;
   use constant   CTL_DEST_HASH   => 2;
   use constant   CTL_DEST_CODE   => 3;
  
  use constant CTL_AMIN    => 4;
  use constant CTL_AMAX    => 5;
  
  # FFU.
  #use constant CTL_RANGE   => ;
  #use constant CTL_REPEAT  => ;
  
  # Rather liberal patterns to match numbers.
  use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
  use constant PAT_XINT  =>
    "(?:".
  	  "[-+]?_*[1-9][0-9_]*".
    "|".
  	  "0x_*[0-9a-f][0-9a-f_]*".
    "|".
  	  "0b_*[01][01_]*".
    "|".
  	  "0[0-7_]*".
    ")";
  use constant PAT_FLOAT =>
    "[-+]?".			# optional sign
    "(?=[0-9.])".			# must start with digit or dec.point
    "[0-9_]*".			# digits before the dec.point
    "(\.[0-9_]+)?".		# optional fraction
    "([eE][-+]?[0-9_]+)?";	# optional exponent
  
  sub GetOptions(@) {
      # Shift in default array.
      unshift(@_, \@ARGV);
      # Try to keep caller() and Carp consistent.
      goto &GetOptionsFromArray;
  }
  
  sub GetOptionsFromString(@) {
      my ($string) = shift;
      require Text::ParseWords;
      my $args = [ Text::ParseWords::shellwords($string) ];
      $caller ||= (caller)[0];	# current context
      my $ret = GetOptionsFromArray($args, @_);
      return ( $ret, $args ) if wantarray;
      if ( @$args ) {
  	$ret = 0;
  	warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n");
      }
      $ret;
  }
  
  sub GetOptionsFromArray(@) {
  
      my ($argv, @optionlist) = @_;	# local copy of the option descriptions
      my $argend = '--';		# option list terminator
      my %opctl = ();		# table of option specs
      my $pkg = $caller || (caller)[0];	# current context
  				# Needed if linkage is omitted.
      my @ret = ();		# accum for non-options
      my %linkage;		# linkage
      my $userlinkage;		# user supplied HASH
      my $opt;			# current option
      my $prefix = $genprefix;	# current prefix
  
      $error = '';
  
      if ( $debug ) {
  	# Avoid some warnings if debugging.
  	local ($^W) = 0;
  	print STDERR
  	  ("Getopt::Long $Getopt::Long::VERSION ",
  	   "called from package \"$pkg\".",
  	   "\n  ",
  	   "argv: ",
  	   defined($argv)
  	   ? UNIVERSAL::isa( $argv, 'ARRAY' ) ? "(@$argv)" : $argv
  	   : "<undef>",
  	   "\n  ",
  	   "autoabbrev=$autoabbrev,".
  	   "bundling=$bundling,",
  	   "bundling_values=$bundling_values,",
  	   "getopt_compat=$getopt_compat,",
  	   "gnu_compat=$gnu_compat,",
  	   "order=$order,",
  	   "\n  ",
  	   "ignorecase=$ignorecase,",
  	   "requested_version=$requested_version,",
  	   "passthrough=$passthrough,",
  	   "genprefix=\"$genprefix\",",
  	   "longprefix=\"$longprefix\".",
  	   "\n");
      }
  
      # Check for ref HASH as first argument.
      # First argument may be an object. It's OK to use this as long
      # as it is really a hash underneath.
      $userlinkage = undef;
      if ( @optionlist && ref($optionlist[0]) and
  	 UNIVERSAL::isa($optionlist[0],'HASH') ) {
  	$userlinkage = shift (@optionlist);
  	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
      }
  
      # See if the first element of the optionlist contains option
      # starter characters.
      # Be careful not to interpret '<>' as option starters.
      if ( @optionlist && $optionlist[0] =~ /^\W+$/
  	 && !($optionlist[0] eq '<>'
  	      && @optionlist > 0
  	      && ref($optionlist[1])) ) {
  	$prefix = shift (@optionlist);
  	# Turn into regexp. Needs to be parenthesized!
  	$prefix =~ s/(\W)/\\$1/g;
  	$prefix = "([" . $prefix . "])";
  	print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
      }
  
      # Verify correctness of optionlist.
      %opctl = ();
      while ( @optionlist ) {
  	my $opt = shift (@optionlist);
  
  	unless ( defined($opt) ) {
  	    $error .= "Undefined argument in option spec\n";
  	    next;
  	}
  
  	# Strip leading prefix so people can specify "--foo=i" if they like.
  	$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  
  	if ( $opt eq '<>' ) {
  	    if ( (defined $userlinkage)
  		&& !(@optionlist > 0 && ref($optionlist[0]))
  		&& (exists $userlinkage->{$opt})
  		&& ref($userlinkage->{$opt}) ) {
  		unshift (@optionlist, $userlinkage->{$opt});
  	    }
  	    unless ( @optionlist > 0
  		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
  		$error .= "Option spec <> requires a reference to a subroutine\n";
  		# Kill the linkage (to avoid another error).
  		shift (@optionlist)
  		  if @optionlist && ref($optionlist[0]);
  		next;
  	    }
  	    $linkage{'<>'} = shift (@optionlist);
  	    next;
  	}
  
  	# Parse option spec.
  	my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  	unless ( defined $name ) {
  	    # Failed. $orig contains the error message. Sorry for the abuse.
  	    $error .= $orig;
  	    # Kill the linkage (to avoid another error).
  	    shift (@optionlist)
  	      if @optionlist && ref($optionlist[0]);
  	    next;
  	}
  
  	# If no linkage is supplied in the @optionlist, copy it from
  	# the userlinkage if available.
  	if ( defined $userlinkage ) {
  	    unless ( @optionlist > 0 && ref($optionlist[0]) ) {
  		if ( exists $userlinkage->{$orig} &&
  		     ref($userlinkage->{$orig}) ) {
  		    print STDERR ("=> found userlinkage for \"$orig\": ",
  				  "$userlinkage->{$orig}\n")
  			if $debug;
  		    unshift (@optionlist, $userlinkage->{$orig});
  		}
  		else {
  		    # Do nothing. Being undefined will be handled later.
  		    next;
  		}
  	    }
  	}
  
  	# Copy the linkage. If omitted, link to global variable.
  	if ( @optionlist > 0 && ref($optionlist[0]) ) {
  	    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  		if $debug;
  	    my $rl = ref($linkage{$orig} = shift (@optionlist));
  
  	    if ( $rl eq "ARRAY" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  	    }
  	    elsif ( $rl eq "HASH" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
  	    }
  	    elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
  #		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  #		    my $t = $linkage{$orig};
  #		    $$t = $linkage{$orig} = [];
  #		}
  #		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  #		}
  #		else {
  		    # Ok.
  #		}
  	    }
  	    elsif ( $rl eq "CODE" ) {
  		# Ok.
  	    }
  	    else {
  		$error .= "Invalid option linkage for \"$opt\"\n";
  	    }
  	}
  	else {
  	    # Link to global $opt_XXX variable.
  	    # Make sure a valid perl identifier results.
  	    my $ov = $orig;
  	    $ov =~ s/\W/_/g;
  	    if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  		print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;");
  	    }
  	    elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  		print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
  	    }
  	    else {
  		print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
  	    }
  	}
  
  	if ( $opctl{$name}[CTL_TYPE] eq 'I'
  	     && ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY
  		  || $opctl{$name}[CTL_DEST] == CTL_DEST_HASH )
  	   ) {
  	    $error .= "Invalid option linkage for \"$opt\"\n";
  	}
  
      }
  
      $error .= "GetOptionsFromArray: 1st parameter is not an array reference\n"
        unless $argv && UNIVERSAL::isa( $argv, 'ARRAY' );
  
      # Bail out if errors found.
      die ($error) if $error;
      $error = 0;
  
      # Supply --version and --help support, if needed and allowed.
      if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{version}) ) {
  	    $opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
  	    $linkage{version} = \&VersionMessage;
  	}
  	$auto_version = 1;
      }
      if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
  	    $opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
  	    $linkage{help} = \&HelpMessage;
  	}
  	$auto_help = 1;
      }
  
      # Show the options tables if debugging.
      if ( $debug ) {
  	my ($arrow, $k, $v);
  	$arrow = "=> ";
  	while ( ($k,$v) = each(%opctl) ) {
  	    print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
  	    $arrow = "   ";
  	}
      }
  
      # Process argument list
      my $goon = 1;
      while ( $goon && @$argv > 0 ) {
  
  	# Get next argument.
  	$opt = shift (@$argv);
  	print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  
  	# Double dash is option list terminator.
  	if ( defined($opt) && $opt eq $argend ) {
  	  push (@ret, $argend) if $passthrough;
  	  last;
  	}
  
  	# Look it up.
  	my $tryopt = $opt;
  	my $found;		# success status
  	my $key;		# key (if hash type)
  	my $arg;		# option argument
  	my $ctl;		# the opctl entry
  
  	($found, $opt, $ctl, $arg, $key) =
  	  FindOption ($argv, $prefix, $argend, $opt, \%opctl);
  
  	if ( $found ) {
  
  	    # FindOption undefines $opt in case of errors.
  	    next unless defined $opt;
  
  	    my $argcnt = 0;
  	    while ( defined $arg ) {
  
  		# Get the canonical name.
  		print STDERR ("=> cname for \"$opt\" is ") if $debug;
  		$opt = $ctl->[CTL_CNAME];
  		print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  
  		if ( defined $linkage{$opt} ) {
  		    print STDERR ("=> ref(\$L{$opt}) -> ",
  				  ref($linkage{$opt}), "\n") if $debug;
  
  		    if ( ref($linkage{$opt}) eq 'SCALAR'
  			 || ref($linkage{$opt}) eq 'REF' ) {
  			if ( $ctl->[CTL_TYPE] eq '+' ) {
  			    print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
  			      if $debug;
  			    if ( defined ${$linkage{$opt}} ) {
  			        ${$linkage{$opt}} += $arg;
  			    }
  		            else {
  			        ${$linkage{$opt}} = $arg;
  			    }
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to ARRAY\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = [];
  			    print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			      if $debug;
  			    push (@{$linkage{$opt}}, $arg);
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to HASH\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = {};
  			    print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			      if $debug;
  			    $linkage{$opt}->{$key} = $arg;
  			}
  			else {
  			    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  			      if $debug;
  			    ${$linkage{$opt}} = $arg;
  		        }
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
  			print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			    if $debug;
  			push (@{$linkage{$opt}}, $arg);
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
  			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$linkage{$opt}->{$key} = $arg;
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
  			print STDERR ("=> &L{$opt}(\"$opt\"",
  				      $ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
  				      ", \"$arg\")\n")
  			    if $debug;
  			my $eval_error = do {
  			    local $@;
  			    local $SIG{__DIE__}  = 'DEFAULT';
  			    eval {
  				&{$linkage{$opt}}
  				  (Getopt::Long::CallBack->new
  				   (name    => $opt,
  				    ctl     => $ctl,
  				    opctl   => \%opctl,
  				    linkage => \%linkage,
  				    prefix  => $prefix,
  				   ),
  				   $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
  				   $arg);
  			    };
  			    $@;
  			};
  			print STDERR ("=> die($eval_error)\n")
  			  if $debug && $eval_error ne '';
  			if ( $eval_error =~ /^!/ ) {
  			    if ( $eval_error =~ /^!FINISH\b/ ) {
  				$goon = 0;
  			    }
  			}
  			elsif ( $eval_error ne '' ) {
  			    warn ($eval_error);
  			    $error++;
  			}
  		    }
  		    else {
  			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
  				      "\" in linkage\n");
  			die("Getopt::Long -- internal error!\n");
  		    }
  		}
  		# No entry in linkage means entry in userlinkage.
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")
  			    if $debug;
  			push (@{$userlinkage->{$opt}}, $arg);
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
  			    if $debug;
  			$userlinkage->{$opt} = [$arg];
  		    }
  		}
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$userlinkage->{$opt}->{$key} = $arg;
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
  			    if $debug;
  			$userlinkage->{$opt} = {$key => $arg};
  		    }
  		}
  		else {
  		    if ( $ctl->[CTL_TYPE] eq '+' ) {
  			print STDERR ("=> \$L{$opt} += \"$arg\"\n")
  			  if $debug;
  			if ( defined $userlinkage->{$opt} ) {
  			    $userlinkage->{$opt} += $arg;
  			}
  			else {
  			    $userlinkage->{$opt} = $arg;
  			}
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
  			$userlinkage->{$opt} = $arg;
  		    }
  		}
  
  		$argcnt++;
  		last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  		undef($arg);
  
  		# Need more args?
  		if ( $argcnt < $ctl->[CTL_AMIN] ) {
  		    if ( @$argv ) {
  			if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
  			    $arg = shift(@$argv);
  			    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  				$arg =~ tr/_//d;
  				$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  				  ? oct($arg)
  				  : 0+$arg
  			    }
  			    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  			      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  			    next;
  			}
  			warn("Value \"$$argv[0]\" invalid for option $opt\n");
  			$error++;
  		    }
  		    else {
  			warn("Insufficient arguments for option $opt\n");
  			$error++;
  		    }
  		}
  
  		# Any more args?
  		if ( @$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
  		    $arg = shift(@$argv);
  		    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  			$arg =~ tr/_//d;
  			$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  			  ? oct($arg)
  			  : 0+$arg
  		    }
  		    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  		      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  		    next;
  		}
  	    }
  	}
  
  	# Not an option. Save it if we $PERMUTE and don't have a <>.
  	elsif ( $order == $PERMUTE ) {
  	    # Try non-options call-back.
  	    my $cb;
  	    if ( defined ($cb = $linkage{'<>'}) ) {
  		print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
  		  if $debug;
  		my $eval_error = do {
  		    local $@;
  		    local $SIG{__DIE__}  = 'DEFAULT';
  		    eval {
  			# The arg to <> cannot be the CallBack object
  			# since it may be passed to other modules that
  			# get confused (e.g., Archive::Tar). Well,
  			# it's not relevant for this callback anyway.
  			&$cb($tryopt);
  		    };
  		    $@;
  		};
  		print STDERR ("=> die($eval_error)\n")
  		  if $debug && $eval_error ne '';
  		if ( $eval_error =~ /^!/ ) {
  		    if ( $eval_error =~ /^!FINISH\b/ ) {
  			$goon = 0;
  		    }
  		}
  		elsif ( $eval_error ne '' ) {
  		    warn ($eval_error);
  		    $error++;
  		}
  	    }
  	    else {
  		print STDERR ("=> saving \"$tryopt\" ",
  			      "(not an option, may permute)\n") if $debug;
  		push (@ret, $tryopt);
  	    }
  	    next;
  	}
  
  	# ...otherwise, terminate.
  	else {
  	    # Push this one back and exit.
  	    unshift (@$argv, $tryopt);
  	    return ($error == 0);
  	}
  
      }
  
      # Finish.
      if ( @ret && $order == $PERMUTE ) {
  	#  Push back accumulated arguments
  	print STDERR ("=> restoring \"", join('" "', @ret), "\"\n")
  	    if $debug;
  	unshift (@$argv, @ret);
      }
  
      return ($error == 0);
  }
  
  # A readable representation of what's in an optbl.
  sub OptCtl ($) {
      my ($v) = @_;
      my @v = map { defined($_) ? ($_) : ("<undef>") } @$v;
      "[".
        join(",",
  	   "\"$v[CTL_TYPE]\"",
  	   "\"$v[CTL_CNAME]\"",
  	   "\"$v[CTL_DEFAULT]\"",
  	   ("\$","\@","\%","\&")[$v[CTL_DEST] || 0],
  	   $v[CTL_AMIN] || '',
  	   $v[CTL_AMAX] || '',
  #	   $v[CTL_RANGE] || '',
  #	   $v[CTL_REPEAT] || '',
  	  ). "]";
  }
  
  # Parse an option specification and fill the tables.
  sub ParseOptionSpec ($$) {
      my ($opt, $opctl) = @_;
  
      # Match option spec.
      if ( $opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Alias names, or "?"
  		     (?: \| (?: \? | \w[-\w]* ) )*
  		     # Aliases
  		     (?: \| (?: [^-|!+=:][^|!+=:]* )? )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x ) {
  	return (undef, "Error in option spec: \"$opt\"\n");
      }
  
      my ($names, $spec) = ($1, $2);
      $spec = '' unless defined $spec;
  
      # $orig keeps track of the primary name the user specified.
      # This name will be used for the internal or external linkage.
      # In other words, if the user specifies "FoO|BaR", it will
      # match any case combinations of 'foo' and 'bar', but if a global
      # variable needs to be set, it will be $opt_FoO in the exact case
      # as specified.
      my $orig;
  
      my @names;
      if ( defined $names ) {
  	@names =  split (/\|/, $names);
  	$orig = $names[0];
      }
      else {
  	@names = ('');
  	$orig = '';
      }
  
      # Construct the opctl entries.
      my $entry;
      if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
  	# Fields are hard-wired here.
  	$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
      }
      elsif ( $spec =~ /^:(-?\d+|\+)([@%])?$/ ) {
  	my $def = $1;
  	my $dest = $2;
  	my $type = $def eq '+' ? 'I' : 'i';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,$def eq '+' ? undef : $def,
  		  $dest,0,1];
      }
      else {
  	my ($mand, $type, $dest) =
  	  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
  	return (undef, "Cannot repeat while bundling: \"$opt\"\n")
  	  if $bundling && defined($4);
  	my ($mi, $cm, $ma) = ($5, $6, $7);
  	return (undef, "{0} is useless in option spec: \"$opt\"\n")
  	  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
  
  	$type = 'i' if $type eq 'n';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Default minargs to 1/0 depending on mand status.
  	$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
  	# Adjust mand status according to minargs.
  	$mand = $mi ? '=' : ':';
  	# Adjust maxargs.
  	$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
  	return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
  	  if defined($ma) && !$ma;
  	return (undef, "Max less than min in option spec: \"$opt\"\n")
  	  if defined($ma) && $ma < $mi;
  
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
      }
  
      # Process all names. First is canonical, the rest are aliases.
      my $dups = '';
      foreach ( @names ) {
  
  	$_ = lc ($_)
  	  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
  
  	if ( exists $opctl->{$_} ) {
  	    $dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
  	}
  
  	if ( $spec eq '!' ) {
  	    $opctl->{"no$_"} = $entry;
  	    $opctl->{"no-$_"} = $entry;
  	    $opctl->{$_} = [@$entry];
  	    $opctl->{$_}->[CTL_TYPE] = '';
  	}
  	else {
  	    $opctl->{$_} = $entry;
  	}
      }
  
      if ( $dups && $^W ) {
  	foreach ( split(/\n+/, $dups) ) {
  	    warn($_."\n");
  	}
      }
      ($names[0], $orig);
  }
  
  # Option lookup.
  sub FindOption ($$$$$) {
  
      # returns (1, $opt, $ctl, $arg, $key) if okay,
      # returns (1, undef) if option in error,
      # returns (0) otherwise.
  
      my ($argv, $prefix, $argend, $opt, $opctl) = @_;
  
      print STDERR ("=> find \"$opt\"\n") if $debug;
  
      return (0) unless defined($opt);
      return (0) unless $opt =~ /^($prefix)(.*)$/s;
      return (0) if $opt eq "-" && !defined $opctl->{''};
  
      $opt = substr( $opt, length($1) ); # retain taintedness
      my $starter = $1;
  
      print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
  
      my $optarg;			# value supplied with --opt=value
      my $rest;			# remainder from unbundling
  
      # If it is a long option, it may include the value.
      # With getopt_compat, only if not bundling.
      if ( ($starter=~/^$longprefix$/
  	  || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
  	 && (my $oppos = index($opt, '=', 1)) > 0) {
  	my $optorg = $opt;
  	$opt = substr($optorg, 0, $oppos);
  	$optarg = substr($optorg, $oppos + 1); # retain tainedness
  	print STDERR ("=> option \"", $opt,
  		      "\", optarg = \"$optarg\"\n") if $debug;
      }
  
      #### Look it up ###
  
      my $tryopt = $opt;		# option to try
  
      if ( ( $bundling || $bundling_values ) && $starter eq '-' ) {
  
  	# To try overrides, obey case ignore.
  	$tryopt = $ignorecase ? lc($opt) : $opt;
  
  	# If bundling == 2, long options can override bundles.
  	if ( $bundling == 2 && length($tryopt) > 1
  	     && defined ($opctl->{$tryopt}) ) {
  	    print STDERR ("=> $starter$tryopt overrides unbundling\n")
  	      if $debug;
  	}
  
  	# If bundling_values, option may be followed by the value.
  	elsif ( $bundling_values ) {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    # Whatever remains may not be considered an option.
  	    $optarg = $rest eq '' ? undef : $rest;
  	    $rest = undef;
  	}
  
  	# Split off a single letter and leave the rest for
  	# further processing.
  	else {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    $rest = undef unless $rest ne '';
  	}
      }
  
      # Try auto-abbreviation.
      elsif ( $autoabbrev && $opt ne "" ) {
  	# Sort the possible long option names.
  	my @names = sort(keys (%$opctl));
  	# Downcase if allowed.
  	$opt = lc ($opt) if $ignorecase;
  	$tryopt = $opt;
  	# Turn option name into pattern.
  	my $pat = quotemeta ($opt);
  	# Look up in option names.
  	my @hits = grep (/^$pat/, @names);
  	print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
  		      "out of ", scalar(@names), "\n") if $debug;
  
  	# Check for ambiguous results.
  	unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
  	    # See if all matches are for the same option.
  	    my %hit;
  	    foreach ( @hits ) {
  		my $hit = $opctl->{$_}->[CTL_CNAME]
  		  if defined $opctl->{$_}->[CTL_CNAME];
  		$hit = "no" . $hit if $opctl->{$_}->[CTL_TYPE] eq '!';
  		$hit{$hit} = 1;
  	    }
  	    # Remove auto-supplied options (version, help).
  	    if ( keys(%hit) == 2 ) {
  		if ( $auto_version && exists($hit{version}) ) {
  		    delete $hit{version};
  		}
  		elsif ( $auto_help && exists($hit{help}) ) {
  		    delete $hit{help};
  		}
  	    }
  	    # Now see if it really is ambiguous.
  	    unless ( keys(%hit) == 1 ) {
  		return (0) if $passthrough;
  		warn ("Option ", $opt, " is ambiguous (",
  		      join(", ", @hits), ")\n");
  		$error++;
  		return (1, undef);
  	    }
  	    @hits = keys(%hit);
  	}
  
  	# Complete the option name, if appropriate.
  	if ( @hits == 1 && $hits[0] ne $opt ) {
  	    $tryopt = $hits[0];
  	    $tryopt = lc ($tryopt)
  	      if $ignorecase > (($bundling && length($tryopt) == 1) ? 1 : 0);
  	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
  		if $debug;
  	}
      }
  
      # Map to all lowercase if ignoring case.
      elsif ( $ignorecase ) {
  	$tryopt = lc ($opt);
      }
  
      # Check validity by fetching the info.
      my $ctl = $opctl->{$tryopt};
      unless  ( defined $ctl ) {
  	return (0) if $passthrough;
  	# Pretend one char when bundling.
  	if ( $bundling == 1 && length($starter) == 1 ) {
  	    $opt = substr($opt,0,1);
              unshift (@$argv, $starter.$rest) if defined $rest;
  	}
  	if ( $opt eq "" ) {
  	    warn ("Missing option after ", $starter, "\n");
  	}
  	else {
  	    warn ("Unknown option: ", $opt, "\n");
  	}
  	$error++;
  	return (1, undef);
      }
      # Apparently valid.
      $opt = $tryopt;
      print STDERR ("=> found ", OptCtl($ctl),
  		  " for \"", $opt, "\"\n") if $debug;
  
      #### Determine argument status ####
  
      # If it is an option w/o argument, we're almost finished with it.
      my $type = $ctl->[CTL_TYPE];
      my $arg;
  
      if ( $type eq '' || $type eq '!' || $type eq '+' ) {
  	if ( defined $optarg ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " does not take an argument\n");
  	    $error++;
  	    undef $opt;
  	    undef $optarg if $bundling_values;
  	}
  	elsif ( $type eq '' || $type eq '+' ) {
  	    # Supply explicit value.
  	    $arg = 1;
  	}
  	else {
  	    $opt =~ s/^no-?//i;	# strip NO prefix
  	    $arg = 0;		# supply explicit value
  	}
  	unshift (@$argv, $starter.$rest) if defined $rest;
  	return (1, $opt, $ctl, $arg);
      }
  
      # Get mandatory status and type info.
      my $mand = $ctl->[CTL_AMIN];
  
      # Check if there is an option argument available.
      if ( $gnu_compat ) {
  	my $optargtype = 0; # none, 1 = empty, 2 = nonempty, 3 = aux
  	if ( defined($optarg) ) {
  	    $optargtype = (length($optarg) == 0) ? 1 : 2;
  	}
  	elsif ( defined $rest || @$argv > 0 ) {
  	    # GNU getopt_long() does not accept the (optional)
  	    # argument to be passed to the option without = sign.
  	    # We do, since not doing so breaks existing scripts.
  	    $optargtype = 3;
  	}
  	if(($optargtype == 0) && !$mand) {
  	    my $val
  	      = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT]
  	      : $type eq 's'                 ? ''
  	      :                                0;
  	    return (1, $opt, $ctl, $val);
  	}
  	return (1, $opt, $ctl, $type eq 's' ? '' : 0)
  	  if $optargtype == 1;  # --foo=  -> return nothing
      }
  
      # Check if there is an option argument available.
      if ( defined $optarg
  	 ? ($optarg eq '')
  	 : !(defined $rest || @$argv > 0) ) {
  	# Complain if this option needs an argument.
  #	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
  	if ( $mand ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " requires an argument\n");
  	    $error++;
  	    return (1, undef);
  	}
  	if ( $type eq 'I' ) {
  	    # Fake incremental type.
  	    my @c = @$ctl;
  	    $c[CTL_TYPE] = '+';
  	    return (1, $opt, \@c, 1);
  	}
  	return (1, $opt, $ctl,
  		defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  		$type eq 's' ? '' : 0);
      }
  
      # Get (possibly optional) argument.
      $arg = (defined $rest ? $rest
  	    : (defined $optarg ? $optarg : shift (@$argv)));
  
      # Get key if this is a "name=value" pair for a hash option.
      my $key;
      if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
  	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
  	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  	     ($mand ? undef : ($type eq 's' ? "" : 1)));
  	if (! defined $arg) {
  	    warn ("Option $opt, key \"$key\", requires a value\n");
  	    $error++;
  	    # Push back.
  	    unshift (@$argv, $starter.$rest) if defined $rest;
  	    return (1, undef);
  	}
      }
  
      #### Check if the argument is valid for this option ####
  
      my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1, $opt, $ctl, $arg, $key) if $mand;
  
  	# Same for optional string as a hash value
  	return (1, $opt, $ctl, $arg, $key)
  	  if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  
  	# An optional string takes almost anything.
  	return (1, $opt, $ctl, $arg, $key)
  	  if defined $optarg || defined $rest;
  	return (1, $opt, $ctl, $arg, $key) if $arg eq "-"; # ??
  
  	# Check for option or option list terminator.
  	if ($arg eq $argend ||
  	    $arg =~ /^$prefix.+/) {
  	    # Push back.
  	    unshift (@$argv, $arg);
  	    # Supply empty value.
  	    $arg = '';
  	}
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  
  	if ( $bundling && defined $rest
  	     && $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/si ) {
  	    $arg =~ tr/_//d;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (",
  		      $type eq 'o' ? "extended " : '',
  		      "number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		if ( $type eq 'I' ) {
  		    # Fake incremental type.
  		    my @c = @$ctl;
  		    $c[CTL_TYPE] = '+';
  		    return (1, $opt, \@c, 1);
  		}
  		# Supply default value.
  		$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
  	    }
  	}
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	if ( $bundling && defined $rest &&
  	     $rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
  	    $arg =~ tr/_//d;
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/ ) {
  	    $arg =~ tr/_//d;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (real number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		# Supply default value.
  		$arg = 0.0;
  	    }
  	}
      }
      else {
  	die("Getopt::Long internal error (Can't happen)\n");
      }
      return (1, $opt, $ctl, $arg, $key);
  }
  
  sub ValidValue ($$$$$) {
      my ($ctl, $arg, $mand, $argend, $prefix) = @_;
  
      if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  	return 0 unless $arg =~ /[^=]+=(.*)/;
  	$arg = $1;
      }
  
      my $type = $ctl->[CTL_TYPE];
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1) if $mand;
  
  	return (1) if $arg eq "-";
  
  	# Check for option or option list terminator.
  	return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
  	return 1;
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  	return $arg =~ /^$o_valid$/si;
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	return $arg =~ /^$o_valid$/;
      }
      die("ValidValue: Cannot happen\n");
  }
  
  # Getopt::Long Configuration.
  sub Configure (@) {
      my (@options) = @_;
  
      my $prevconfig =
        [ $error, $debug, $major_version, $minor_version, $caller,
  	$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	$longprefix, $bundling_values ];
  
      if ( ref($options[0]) eq 'ARRAY' ) {
  	( $error, $debug, $major_version, $minor_version, $caller,
  	  $autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	  $longprefix, $bundling_values ) = @{shift(@options)};
      }
  
      my $opt;
      foreach $opt ( @options ) {
  	my $try = lc ($opt);
  	my $action = 1;
  	if ( $try =~ /^no_?(.*)$/s ) {
  	    $action = 0;
  	    $try = $+;
  	}
  	if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
  	    ConfigDefaults ();
  	}
  	elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
  	    local $ENV{POSIXLY_CORRECT};
  	    $ENV{POSIXLY_CORRECT} = 1 if $action;
  	    ConfigDefaults ();
  	}
  	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
  	    $autoabbrev = $action;
  	}
  	elsif ( $try eq 'getopt_compat' ) {
  	    $getopt_compat = $action;
              $genprefix = $action ? "(--|-|\\+)" : "(--|-)";
  	}
  	elsif ( $try eq 'gnu_getopt' ) {
  	    if ( $action ) {
  		$gnu_compat = 1;
  		$bundling = 1;
  		$getopt_compat = 0;
                  $genprefix = "(--|-)";
  		$order = $PERMUTE;
  		$bundling_values = 0;
  	    }
  	}
  	elsif ( $try eq 'gnu_compat' ) {
  	    $gnu_compat = $action;
  	    $bundling = 0;
  	    $bundling_values = 1;
  	}
  	elsif ( $try =~ /^(auto_?)?version$/ ) {
  	    $auto_version = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?help$/ ) {
  	    $auto_help = $action;
  	}
  	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
  	    $ignorecase = $action;
  	}
  	elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
  	    $ignorecase = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'bundling' ) {
  	    $bundling = $action;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_override' ) {
  	    $bundling = $action ? 2 : 0;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_values' ) {
  	    $bundling_values = $action;
  	    $bundling = 0 if $action;
  	}
  	elsif ( $try eq 'require_order' ) {
  	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
  	}
  	elsif ( $try eq 'permute' ) {
  	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
  	}
  	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
  	    $passthrough = $action;
  	}
  	elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Turn into regexp. Needs to be parenthesized!
  	    $genprefix = "(" . quotemeta($genprefix) . ")";
  	    eval { '' =~ /$genprefix/; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Parenthesize if needed.
  	    $genprefix = "(" . $genprefix . ")"
  	      unless $genprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$genprefix"; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
  	    $longprefix = $1;
  	    # Parenthesize if needed.
  	    $longprefix = "(" . $longprefix . ")"
  	      unless $longprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$longprefix"; };
  	    die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n") if $@;
  	}
  	elsif ( $try eq 'debug' ) {
  	    $debug = $action;
  	}
  	else {
  	    die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")
  	}
      }
      $prevconfig;
  }
  
  # Deprecated name.
  sub config (@) {
      Configure (@_);
  }
  
  # Issue a standard message for --version.
  #
  # The arguments are mostly the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub VersionMessage(@) {
      # Massage args.
      my $pa = setup_pa_args("version", @_);
  
      my $v = $main::VERSION;
      my $fh = $pa->{-output} ||
        ( ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR );
  
      print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
  	       $0, defined $v ? " version $v" : (),
  	       "\n",
  	       "(", __PACKAGE__, "::", "GetOptions",
  	       " version ",
  	       defined($Getopt::Long::VERSION_STRING)
  	         ? $Getopt::Long::VERSION_STRING : $VERSION, ";",
  	       " Perl version ",
  	       $] >= 5.006 ? sprintf("%vd", $^V) : $],
  	       ")\n");
      exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
  }
  
  # Issue a standard message for --help.
  #
  # The arguments are the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub HelpMessage(@) {
      eval {
  	require Pod::Usage;
  	import Pod::Usage;
  	1;
      } || die("Cannot provide help: cannot load Pod::Usage\n");
  
      # Note that pod2usage will issue a warning if -exitval => NOEXIT.
      pod2usage(setup_pa_args("help", @_));
  
  }
  
  # Helper routine to set up a normalized hash ref to be used as
  # argument to pod2usage.
  sub setup_pa_args($@) {
      my $tag = shift;		# who's calling
  
      # If called by direct binding to an option, it will get the option
      # name and value as arguments. Remove these, if so.
      @_ = () if @_ == 2 && $_[0] eq $tag;
  
      my $pa;
      if ( @_ > 1 ) {
  	$pa = { @_ };
      }
      else {
  	$pa = shift || {};
      }
  
      # At this point, $pa can be a number (exit value), string
      # (message) or hash with options.
  
      if ( UNIVERSAL::isa($pa, 'HASH') ) {
  	# Get rid of -msg vs. -message ambiguity.
  	$pa->{-message} = $pa->{-msg};
  	delete($pa->{-msg});
      }
      elsif ( $pa =~ /^-?\d+$/ ) {
  	$pa = { -exitval => $pa };
      }
      else {
  	$pa = { -message => $pa };
      }
  
      # These are _our_ defaults.
      $pa->{-verbose} = 0 unless exists($pa->{-verbose});
      $pa->{-exitval} = 0 unless exists($pa->{-exitval});
      $pa;
  }
  
  # Sneak way to know what version the user requested.
  sub VERSION {
      $requested_version = $_[1];
      shift->SUPER::VERSION(@_);
  }
  
  package Getopt::Long::CallBack;
  
  sub new {
      my ($pkg, %atts) = @_;
      bless { %atts }, $pkg;
  }
  
  sub name {
      my $self = shift;
      ''.$self->{name};
  }
  
  use overload
    # Treat this object as an ordinary string for legacy API.
    '""'	   => \&name,
    fallback => 1;
  
  1;
  
  ################ Documentation ################
  
  =head1 NAME
  
  Getopt::Long - Extended processing of command line options
  
  =head1 SYNOPSIS
  
    use Getopt::Long;
    my $data   = "file.dat";
    my $length = 24;
    my $verbose;
    GetOptions ("length=i" => \$length,    # numeric
                "file=s"   => \$data,      # string
                "verbose"  => \$verbose)   # flag
    or die("Error in command line arguments\n");
  
  =head1 DESCRIPTION
  
  The Getopt::Long module implements an extended getopt function called
  GetOptions(). It parses the command line from C<@ARGV>, recognizing
  and removing specified options and their possible values.
  
  This function adheres to the POSIX syntax for command
  line options, with GNU extensions. In general, this means that options
  have long names instead of single letters, and are introduced with a
  double dash "--". Support for bundling of command line options, as was
  the case with the more traditional single-letter approach, is provided
  but not enabled by default.
  
  =head1 Command Line Options, an Introduction
  
  Command line operated programs traditionally take their arguments from
  the command line, for example filenames or other information that the
  program needs to know. Besides arguments, these programs often take
  command line I<options> as well. Options are not necessary for the
  program to work, hence the name 'option', but are used to modify its
  default behaviour. For example, a program could do its job quietly,
  but with a suitable option it could provide verbose information about
  what it did.
  
  Command line options come in several flavours. Historically, they are
  preceded by a single dash C<->, and consist of a single letter.
  
      -l -a -c
  
  Usually, these single-character options can be bundled:
  
      -lac
  
  Options can have values, the value is placed after the option
  character. Sometimes with whitespace in between, sometimes not:
  
      -s 24 -s24
  
  Due to the very cryptic nature of these options, another style was
  developed that used long names. So instead of a cryptic C<-l> one
  could use the more descriptive C<--long>. To distinguish between a
  bundle of single-character options and a long one, two dashes are used
  to precede the option name. Early implementations of long options used
  a plus C<+> instead. Also, option values could be specified either
  like
  
      --size=24
  
  or
  
      --size 24
  
  The C<+> form is now obsolete and strongly deprecated.
  
  =head1 Getting Started with Getopt::Long
  
  Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was the
  first Perl module that provided support for handling the new style of
  command line options, in particular long option names, hence the Perl5
  name Getopt::Long. This module also supports single-character options
  and bundling.
  
  To use Getopt::Long from a Perl program, you must include the
  following line in your Perl program:
  
      use Getopt::Long;
  
  This will load the core of the Getopt::Long module and prepare your
  program for using it. Most of the actual Getopt::Long code is not
  loaded until you really call one of its functions.
  
  In the default configuration, options names may be abbreviated to
  uniqueness, case does not matter, and a single dash is sufficient,
  even for long option names. Also, options may be placed between
  non-option arguments. See L<Configuring Getopt::Long> for more
  details on how to configure Getopt::Long.
  
  =head2 Simple options
  
  The most simple options are the ones that take no values. Their mere
  presence on the command line enables the option. Popular examples are:
  
      --all --verbose --quiet --debug
  
  Handling simple options is straightforward:
  
      my $verbose = '';	# option variable with default value (false)
      my $all = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose, 'all' => \$all);
  
  The call to GetOptions() parses the command line arguments that are
  present in C<@ARGV> and sets the option variable to the value C<1> if
  the option did occur on the command line. Otherwise, the option
  variable is not touched. Setting the option value to true is often
  called I<enabling> the option.
  
  The option name as specified to the GetOptions() function is called
  the option I<specification>. Later we'll see that this specification
  can contain more than just the option name. The reference to the
  variable is called the option I<destination>.
  
  GetOptions() will return a true value if the command line could be
  processed successfully. Otherwise, it will write error messages using
  die() and warn(), and return a false result.
  
  =head2 A little bit less simple options
  
  Getopt::Long supports two useful variants of simple options:
  I<negatable> options and I<incremental> options.
  
  A negatable option is specified with an exclamation mark C<!> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose!' => \$verbose);
  
  Now, using C<--verbose> on the command line will enable C<$verbose>,
  as expected. But it is also allowed to use C<--noverbose>, which will
  disable C<$verbose> by setting its value to C<0>. Using a suitable
  default value, the program can find out whether C<$verbose> is false
  by default, or disabled by using C<--noverbose>.
  
  An incremental option is specified with a plus C<+> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose+' => \$verbose);
  
  Using C<--verbose> on the command line will increment the value of
  C<$verbose>. This way the program can keep track of how many times the
  option occurred on the command line. For example, each occurrence of
  C<--verbose> could increase the verbosity level of the program.
  
  =head2 Mixing command line option with other arguments
  
  Usually programs take command line options as well as other arguments,
  for example, file names. It is good practice to always specify the
  options first, and the other arguments last. Getopt::Long will,
  however, allow the options and arguments to be mixed and 'filter out'
  all the options before passing the rest of the arguments to the
  program. To stop Getopt::Long from processing further arguments,
  insert a double dash C<--> on the command line:
  
      --size 24 -- --all
  
  In this example, C<--all> will I<not> be treated as an option, but
  passed to the program unharmed, in C<@ARGV>.
  
  =head2 Options with values
  
  For options that take values it must be specified whether the option
  value is required or not, and what kind of value the option expects.
  
  Three kinds of values are supported: integer numbers, floating point
  numbers, and strings.
  
  If the option value is required, Getopt::Long will take the
  command line argument that follows the option and assign this to the
  option variable. If, however, the option value is specified as
  optional, this will only be done if that value does not look like a
  valid command line option itself.
  
      my $tag = '';	# option variable with default value
      GetOptions ('tag=s' => \$tag);
  
  In the option specification, the option name is followed by an equals
  sign C<=> and the letter C<s>. The equals sign indicates that this
  option requires a value. The letter C<s> indicates that this value is
  an arbitrary string. Other possible value types are C<i> for integer
  values, and C<f> for floating point values. Using a colon C<:> instead
  of the equals sign indicates that the option value is optional. In
  this case, if no suitable value is supplied, string valued options get
  an empty string C<''> assigned, while numeric options are set to C<0>.
  
  =head2 Options with multiple values
  
  Options sometimes take several values. For example, a program could
  use multiple directories to search for library files:
  
      --library lib/stdlib --library lib/extlib
  
  To accomplish this behaviour, simply specify an array reference as the
  destination for the option:
  
      GetOptions ("library=s" => \@libfiles);
  
  Alternatively, you can specify that the option can have multiple
  values by adding a "@", and pass a reference to a scalar as the
  destination:
  
      GetOptions ("library=s@" => \$libfiles);
  
  Used with the example above, C<@libfiles> c.q. C<@$libfiles> would
  contain two strings upon completion: C<"lib/stdlib"> and
  C<"lib/extlib">, in that order. It is also possible to specify that
  only integer or floating point numbers are acceptable values.
  
  Often it is useful to allow comma-separated lists of values as well as
  multiple occurrences of the options. This is easy using Perl's split()
  and join() operators:
  
      GetOptions ("library=s" => \@libfiles);
      @libfiles = split(/,/,join(',',@libfiles));
  
  Of course, it is important to choose the right separator string for
  each purpose.
  
  Warning: What follows is an experimental feature.
  
  Options can take multiple values at once, for example
  
      --coordinates 52.2 16.4 --rgbcolor 255 255 149
  
  This can be accomplished by adding a repeat specifier to the option
  specification. Repeat specifiers are very similar to the C<{...}>
  repeat specifiers that can be used with regular expression patterns.
  For example, the above command line would be handled as follows:
  
      GetOptions('coordinates=f{2}' => \@coor, 'rgbcolor=i{3}' => \@color);
  
  The destination for the option must be an array or array reference.
  
  It is also possible to specify the minimal and maximal number of
  arguments an option takes. C<foo=s{2,4}> indicates an option that
  takes at least two and at most 4 arguments. C<foo=s{1,}> indicates one
  or more values; C<foo:s{,}> indicates zero or more option values.
  
  =head2 Options with hash values
  
  If the option destination is a reference to a hash, the option will
  take, as value, strings of the form I<key>C<=>I<value>. The value will
  be stored with the specified key in the hash.
  
      GetOptions ("define=s" => \%defines);
  
  Alternatively you can use:
  
      GetOptions ("define=s%" => \$defines);
  
  When used with command line options:
  
      --define os=linux --define vendor=redhat
  
  the hash C<%defines> (or C<%$defines>) will contain two keys, C<"os">
  with value C<"linux"> and C<"vendor"> with value C<"redhat">. It is
  also possible to specify that only integer or floating point numbers
  are acceptable values. The keys are always taken to be strings.
  
  =head2 User-defined subroutines to handle options
  
  Ultimate control over what should be done when (actually: each time)
  an option is encountered on the command line can be achieved by
  designating a reference to a subroutine (or an anonymous subroutine)
  as the option destination. When GetOptions() encounters the option, it
  will call the subroutine with two or three arguments. The first
  argument is the name of the option. (Actually, it is an object that
  stringifies to the name of the option.) For a scalar or array destination,
  the second argument is the value to be stored. For a hash destination,
  the second argument is the key to the hash, and the third argument
  the value to be stored. It is up to the subroutine to store the value,
  or do whatever it thinks is appropriate.
  
  A trivial application of this mechanism is to implement options that
  are related to each other. For example:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose,
  	        'quiet'   => sub { $verbose = 0 });
  
  Here C<--verbose> and C<--quiet> control the same variable
  C<$verbose>, but with opposite values.
  
  If the subroutine needs to signal an error, it should call die() with
  the desired error message as its argument. GetOptions() will catch the
  die(), issue the error message, and record that an error result must
  be returned upon completion.
  
  If the text of the error message starts with an exclamation mark C<!>
  it is interpreted specially by GetOptions(). There is currently one
  special command implemented: C<die("!FINISH")> will cause GetOptions()
  to stop processing options, as if it encountered a double dash C<-->.
  
  In version 2.37 the first argument to the callback function was
  changed from string to object. This was done to make room for
  extensions and more detailed control. The object stringifies to the
  option name so this change should not introduce compatibility
  problems.
  
  Here is an example of how to access the option name and value from within
  a subroutine:
  
      GetOptions ('opt=i' => \&handler);
      sub handler {
          my ($opt_name, $opt_value) = @_;
          print("Option name is $opt_name and value is $opt_value\n");
      }
  
  =head2 Options with multiple names
  
  Often it is user friendly to supply alternate mnemonic names for
  options. For example C<--height> could be an alternate name for
  C<--length>. Alternate names can be included in the option
  specification, separated by vertical bar C<|> characters. To implement
  the above example:
  
      GetOptions ('length|height=f' => \$length);
  
  The first name is called the I<primary> name, the other names are
  called I<aliases>. When using a hash to store options, the key will
  always be the primary name.
  
  Multiple alternate names are possible.
  
  =head2 Case and abbreviations
  
  Without additional configuration, GetOptions() will ignore the case of
  option names, and allow the options to be abbreviated to uniqueness.
  
      GetOptions ('length|height=f' => \$length, "head" => \$head);
  
  This call will allow C<--l> and C<--L> for the length option, but
  requires a least C<--hea> and C<--hei> for the head and height options.
  
  =head2 Summary of Option Specifications
  
  Each option specifier consists of two parts: the name specification
  and the argument specification.
  
  The name specification contains the name of the option, optionally
  followed by a list of alternative names separated by vertical bar
  characters.
  
      length	      option name is "length"
      length|size|l     name is "length", aliases are "size" and "l"
  
  The argument specification is optional. If omitted, the option is
  considered boolean, a value of 1 will be assigned when the option is
  used on the command line.
  
  The argument specification can be
  
  =over 4
  
  =item !
  
  The option does not take an argument and may be negated by prefixing
  it with "no" or "no-". E.g. C<"foo!"> will allow C<--foo> (a value of
  1 will be assigned) as well as C<--nofoo> and C<--no-foo> (a value of
  0 will be assigned). If the option has aliases, this applies to the
  aliases as well.
  
  Using negation on a single letter option when bundling is in effect is
  pointless and will result in a warning.
  
  =item +
  
  The option does not take an argument and will be incremented by 1
  every time it appears on the command line. E.g. C<"more+">, when used
  with C<--more --more --more>, will increment the value three times,
  resulting in a value of 3 (provided it was 0 or undefined at first).
  
  The C<+> specifier is ignored if the option destination is not a scalar.
  
  =item = I<type> [ I<desttype> ] [ I<repeat> ]
  
  The option requires an argument of the given type. Supported types
  are:
  
  =over 4
  
  =item s
  
  String. An arbitrary sequence of characters. It is valid for the
  argument to start with C<-> or C<-->.
  
  =item i
  
  Integer. An optional leading plus or minus sign, followed by a
  sequence of digits.
  
  =item o
  
  Extended integer, Perl style. This can be either an optional leading
  plus or minus sign, followed by a sequence of digits, or an octal
  string (a zero, optionally followed by '0', '1', .. '7'), or a
  hexadecimal string (C<0x> followed by '0' .. '9', 'a' .. 'f', case
  insensitive), or a binary string (C<0b> followed by a series of '0'
  and '1').
  
  =item f
  
  Real number. For example C<3.14>, C<-6.23E24> and so on.
  
  =back
  
  The I<desttype> can be C<@> or C<%> to specify that the option is
  list or a hash valued. This is only needed when the destination for
  the option value is not otherwise specified. It should be omitted when
  not needed.
  
  The I<repeat> specifies the number of values this option takes per
  occurrence on the command line. It has the format C<{> [ I<min> ] [ C<,> [ I<max> ] ] C<}>.
  
  I<min> denotes the minimal number of arguments. It defaults to 1 for
  options with C<=> and to 0 for options with C<:>, see below. Note that
  I<min> overrules the C<=> / C<:> semantics.
  
  I<max> denotes the maximum number of arguments. It must be at least
  I<min>. If I<max> is omitted, I<but the comma is not>, there is no
  upper bound to the number of argument values taken.
  
  =item : I<type> [ I<desttype> ]
  
  Like C<=>, but designates the argument as optional.
  If omitted, an empty string will be assigned to string values options,
  and the value zero to numeric options.
  
  Note that if a string argument starts with C<-> or C<-->, it will be
  considered an option on itself.
  
  =item : I<number> [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the I<number> will be assigned.
  
  =item : + [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the current value for the
  option will be incremented.
  
  =back
  
  =head1 Advanced Possibilities
  
  =head2 Object oriented interface
  
  Getopt::Long can be used in an object oriented way as well:
  
      use Getopt::Long;
      $p = Getopt::Long::Parser->new;
      $p->configure(...configuration options...);
      if ($p->getoptions(...options descriptions...)) ...
      if ($p->getoptionsfromarray( \@array, ...options descriptions...)) ...
  
  Configuration options can be passed to the constructor:
  
      $p = new Getopt::Long::Parser
               config => [...configuration options...];
  
  =head2 Thread Safety
  
  Getopt::Long is thread safe when using ithreads as of Perl 5.8.  It is
  I<not> thread safe when using the older (experimental and now
  obsolete) threads implementation that was added to Perl 5.005.
  
  =head2 Documentation and help texts
  
  Getopt::Long encourages the use of Pod::Usage to produce help
  messages. For example:
  
      use Getopt::Long;
      use Pod::Usage;
  
      my $man = 0;
      my $help = 0;
  
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-exitval => 0, -verbose => 2) if $man;
  
      __END__
  
      =head1 NAME
  
      sample - Using Getopt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 8
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  See L<Pod::Usage> for details.
  
  =head2 Parsing options from an arbitrary array
  
  By default, GetOptions parses the options that are present in the
  global array C<@ARGV>. A special entry C<GetOptionsFromArray> can be
  used to parse options from an arbitrary array.
  
      use Getopt::Long qw(GetOptionsFromArray);
      $ret = GetOptionsFromArray(\@myopts, ...);
  
  When used like this, options and their possible values are removed
  from C<@myopts>, the global C<@ARGV> is not touched at all.
  
  The following two calls behave identically:
  
      $ret = GetOptions( ... );
      $ret = GetOptionsFromArray(\@ARGV, ... );
  
  This also means that a first argument hash reference now becomes the
  second argument:
  
      $ret = GetOptions(\%opts, ... );
      $ret = GetOptionsFromArray(\@ARGV, \%opts, ... );
  
  =head2 Parsing options from an arbitrary string
  
  A special entry C<GetOptionsFromString> can be used to parse options
  from an arbitrary string.
  
      use Getopt::Long qw(GetOptionsFromString);
      $ret = GetOptionsFromString($string, ...);
  
  The contents of the string are split into arguments using a call to
  C<Text::ParseWords::shellwords>. As with C<GetOptionsFromArray>, the
  global C<@ARGV> is not touched.
  
  It is possible that, upon completion, not all arguments in the string
  have been processed. C<GetOptionsFromString> will, when called in list
  context, return both the return status and an array reference to any
  remaining arguments:
  
      ($ret, $args) = GetOptionsFromString($string, ... );
  
  If any arguments remain, and C<GetOptionsFromString> was not called in
  list context, a message will be given and C<GetOptionsFromString> will
  return failure.
  
  As with GetOptionsFromArray, a first argument hash reference now
  becomes the second argument.
  
  =head2 Storing options values in a hash
  
  Sometimes, for example when there are a lot of options, having a
  separate variable for each of them can be cumbersome. GetOptions()
  supports, as an alternative mechanism, storing options values in a
  hash.
  
  To obtain this, a reference to a hash must be passed I<as the first
  argument> to GetOptions(). For each option that is specified on the
  command line, the option value will be stored in the hash with the
  option name as key. Options that are not actually used on the command
  line will not be put in the hash, on other words,
  C<exists($h{option})> (or defined()) can be used to test if an option
  was used. The drawback is that warnings will be issued if the program
  runs under C<use strict> and uses C<$h{option}> without testing with
  exists() or defined() first.
  
      my %h = ();
      GetOptions (\%h, 'length=i');	# will store in $h{length}
  
  For options that take list or hash values, it is necessary to indicate
  this by appending an C<@> or C<%> sign after the type:
  
      GetOptions (\%h, 'colours=s@');	# will push to @{$h{colours}}
  
  To make things more complicated, the hash may contain references to
  the actual destinations, for example:
  
      my $len = 0;
      my %h = ('length' => \$len);
      GetOptions (\%h, 'length=i');	# will store in $len
  
  This example is fully equivalent with:
  
      my $len = 0;
      GetOptions ('length=i' => \$len);	# will store in $len
  
  Any mixture is possible. For example, the most frequently used options
  could be stored in variables while all other options get stored in the
  hash:
  
      my $verbose = 0;			# frequently referred
      my $debug = 0;			# frequently referred
      my %h = ('verbose' => \$verbose, 'debug' => \$debug);
      GetOptions (\%h, 'verbose', 'debug', 'filter', 'size=i');
      if ( $verbose ) { ... }
      if ( exists $h{filter} ) { ... option 'filter' was specified ... }
  
  =head2 Bundling
  
  With bundling it is possible to set several single-character options
  at once. For example if C<a>, C<v> and C<x> are all valid options,
  
      -vax
  
  will set all three.
  
  Getopt::Long supports three styles of bundling. To enable bundling, a
  call to Getopt::Long::Configure is required.
  
  The simplest style of bundling can be enabled with:
  
      Getopt::Long::Configure ("bundling");
  
  Configured this way, single-character options can be bundled but long
  options B<must> always start with a double dash C<--> to avoid
  ambiguity. For example, when C<vax>, C<a>, C<v> and C<x> are all valid
  options,
  
      -vax
  
  will set C<a>, C<v> and C<x>, but
  
      --vax
  
  will set C<vax>.
  
  The second style of bundling lifts this restriction. It can be enabled
  with:
  
      Getopt::Long::Configure ("bundling_override");
  
  Now, C<-vax> will set the option C<vax>.
  
  In all of the above cases, option values may be inserted in the
  bundle. For example:
  
      -h24w80
  
  is equivalent to
  
      -h 24 -w 80
  
  A third style of bundling allows only values to be bundled with
  options. It can be enabled with:
  
      Getopt::Long::Configure ("bundling_values");
  
  Now, C<-h24> will set the option C<h> to C<24>, but option bundles
  like C<-vxa> and C<-h24w80> are flagged as errors.
  
  Enabling C<bundling_values> will disable the other two styles of
  bundling.
  
  When configured for bundling, single-character options are matched
  case sensitive while long options are matched case insensitive. To
  have the single-character options matched case insensitive as well,
  use:
  
      Getopt::Long::Configure ("bundling", "ignorecase_always");
  
  It goes without saying that bundling can be quite confusing.
  
  =head2 The lonesome dash
  
  Normally, a lone dash C<-> on the command line will not be considered
  an option. Option processing will terminate (unless "permute" is
  configured) and the dash will be left in C<@ARGV>.
  
  It is possible to get special treatment for a lone dash. This can be
  achieved by adding an option specification with an empty name, for
  example:
  
      GetOptions ('' => \$stdio);
  
  A lone dash on the command line will now be a legal option, and using
  it will set variable C<$stdio>.
  
  =head2 Argument callback
  
  A special option 'name' C<< <> >> can be used to designate a subroutine
  to handle non-option arguments. When GetOptions() encounters an
  argument that does not look like an option, it will immediately call this
  subroutine and passes it one parameter: the argument name. Well, actually
  it is an object that stringifies to the argument name.
  
  For example:
  
      my $width = 80;
      sub process { ... }
      GetOptions ('width=i' => \$width, '<>' => \&process);
  
  When applied to the following command line:
  
      arg1 --width=72 arg2 --width=60 arg3
  
  This will call
  C<process("arg1")> while C<$width> is C<80>,
  C<process("arg2")> while C<$width> is C<72>, and
  C<process("arg3")> while C<$width> is C<60>.
  
  This feature requires configuration option B<permute>, see section
  L<Configuring Getopt::Long>.
  
  =head1 Configuring Getopt::Long
  
  Getopt::Long can be configured by calling subroutine
  Getopt::Long::Configure(). This subroutine takes a list of quoted
  strings, each specifying a configuration option to be enabled, e.g.
  C<ignore_case>, or disabled, e.g. C<no_ignore_case>. Case does not
  matter. Multiple calls to Configure() are possible.
  
  Alternatively, as of version 2.24, the configuration options may be
  passed together with the C<use> statement:
  
      use Getopt::Long qw(:config no_ignore_case bundling);
  
  The following options are available:
  
  =over 12
  
  =item default
  
  This option causes all configuration options to be reset to their
  default values.
  
  =item posix_default
  
  This option causes all configuration options to be reset to their
  default values as if the environment variable POSIXLY_CORRECT had
  been set.
  
  =item auto_abbrev
  
  Allow option names to be abbreviated to uniqueness.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is disabled.
  
  =item getopt_compat
  
  Allow C<+> to start options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<getopt_compat> is disabled.
  
  =item gnu_compat
  
  C<gnu_compat> controls whether C<--opt=> is allowed, and what it should
  do. Without C<gnu_compat>, C<--opt=> gives an error. With C<gnu_compat>,
  C<--opt=> will give option C<opt> and empty value.
  This is the way GNU getopt_long() does it.
  
  Note that C<--opt value> is still accepted, even though GNU
  getopt_long() doesn't.
  
  =item gnu_getopt
  
  This is a short way of setting C<gnu_compat> C<bundling> C<permute>
  C<no_getopt_compat>. With C<gnu_getopt>, command line handling should be
  reasonably compatible with GNU getopt_long().
  
  =item require_order
  
  Whether command line arguments are allowed to be mixed with options.
  Default is disabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<require_order> is enabled.
  
  See also C<permute>, which is the opposite of C<require_order>.
  
  =item permute
  
  Whether command line arguments are allowed to be mixed with options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<permute> is disabled.
  Note that C<permute> is the opposite of C<require_order>.
  
  If C<permute> is enabled, this means that
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo --bar arg1 arg2 arg3
  
  If an argument callback routine is specified, C<@ARGV> will always be
  empty upon successful return of GetOptions() since all options have been
  processed. The only exception is when C<--> is used:
  
      --foo arg1 --bar arg2 -- arg3
  
  This will call the callback routine for arg1 and arg2, and then
  terminate GetOptions() leaving C<"arg3"> in C<@ARGV>.
  
  If C<require_order> is enabled, options processing
  terminates when the first non-option is encountered.
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo -- arg1 --bar arg2 arg3
  
  If C<pass_through> is also enabled, options processing will terminate
  at the first unrecognized option, or non-option, whichever comes
  first.
  
  =item bundling (default: disabled)
  
  Enabling this option will allow single-character options to be
  bundled. To distinguish bundles from long option names, long options
  I<must> be introduced with C<--> and bundles with C<->.
  
  Note that, if you have options C<a>, C<l> and C<all>, and
  auto_abbrev enabled, possible arguments and option settings are:
  
      using argument               sets option(s)
      ------------------------------------------
      -a, --a                      a
      -l, --l                      l
      -al, -la, -ala, -all,...     a, l
      --al, --all                  all
  
  The surprising part is that C<--a> sets option C<a> (due to auto
  completion), not C<all>.
  
  Note: disabling C<bundling> also disables C<bundling_override>.
  
  =item bundling_override (default: disabled)
  
  If C<bundling_override> is enabled, bundling is enabled as with
  C<bundling> but now long option names override option bundles.
  
  Note: disabling C<bundling_override> also disables C<bundling>.
  
  B<Note:> Using option bundling can easily lead to unexpected results,
  especially when mixing long options and bundles. Caveat emptor.
  
  =item ignore_case  (default: enabled)
  
  If enabled, case is ignored when matching option names. If, however,
  bundling is enabled as well, single character options will be treated
  case-sensitive.
  
  With C<ignore_case>, option specifications for options that only
  differ in case, e.g., C<"foo"> and C<"Foo">, will be flagged as
  duplicates.
  
  Note: disabling C<ignore_case> also disables C<ignore_case_always>.
  
  =item ignore_case_always (default: disabled)
  
  When bundling is in effect, case is ignored on single-character
  options also.
  
  Note: disabling C<ignore_case_always> also disables C<ignore_case>.
  
  =item auto_version (default:disabled)
  
  Automatically provide support for the B<--version> option if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a standard version message that includes the
  program name, its version (if $main::VERSION is defined), and the
  versions of Getopt::Long and Perl. The message will be written to
  standard output and processing will terminate.
  
  C<auto_version> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item auto_help (default:disabled)
  
  Automatically provide support for the B<--help> and B<-?> options if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a help message using module L<Pod::Usage>. The
  message, derived from the SYNOPSIS POD section, will be written to
  standard output and processing will terminate.
  
  C<auto_help> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item pass_through (default: disabled)
  
  With C<pass_through> anything that is unknown, ambiguous or supplied with
  an invalid option will not be flagged as an error. Instead the unknown
  option(s) will be passed to the catchall C<< <> >> if present, otherwise
  through to C<@ARGV>. This makes it possible to write wrapper scripts that
  process only part of the user supplied command line arguments, and pass the
  remaining options to some other program.
  
  If C<require_order> is enabled, options processing will terminate at the
  first unrecognized option, or non-option, whichever comes first and all
  remaining arguments are passed to C<@ARGV> instead of the catchall
  C<< <> >> if present.  However, if C<permute> is enabled instead, results
  can become confusing.
  
  Note that the options terminator (default C<-->), if present, will
  also be passed through in C<@ARGV>.
  
  =item prefix
  
  The string that starts options. If a constant string is not
  sufficient, see C<prefix_pattern>.
  
  =item prefix_pattern
  
  A Perl pattern that identifies the strings that introduce options.
  Default is C<--|-|\+> unless environment variable
  POSIXLY_CORRECT has been set, in which case it is C<--|->.
  
  =item long_prefix_pattern
  
  A Perl pattern that allows the disambiguation of long and short
  prefixes. Default is C<-->.
  
  Typically you only need to set this if you are using nonstandard
  prefixes and want some or all of them to have the same semantics as
  '--' does under normal circumstances.
  
  For example, setting prefix_pattern to C<--|-|\+|\/> and
  long_prefix_pattern to C<--|\/> would add Win32 style argument
  handling.
  
  =item debug (default: disabled)
  
  Enable debugging output.
  
  =back
  
  =head1 Exportable Methods
  
  =over
  
  =item VersionMessage
  
  This subroutine provides a standard version message. Its argument can be:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the standard message.
  
  =item *
  
  A numeric value corresponding to the desired exit status.
  
  =item *
  
  A reference to a hash.
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message>
  
  =item C<-msg>
  
  The text of a message to print immediately prior to printing the
  program's usage message.
  
  =item C<-exitval>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string "NOEXIT" to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-output>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =back
  
  You cannot tie this routine directly to an option, e.g.:
  
      GetOptions("version" => \&VersionMessage);
  
  Use this instead:
  
      GetOptions("version" => sub { VersionMessage() });
  
  =item HelpMessage
  
  This subroutine produces a standard help message, derived from the
  program's POD section SYNOPSIS using L<Pod::Usage>. It takes the same
  arguments as VersionMessage(). In particular, you cannot tie it
  directly to an option, e.g.:
  
      GetOptions("help" => \&HelpMessage);
  
  Use this instead:
  
      GetOptions("help" => sub { HelpMessage() });
  
  =back
  
  =head1 Return values and Errors
  
  Configuration errors and errors in the option definitions are
  signalled using die() and will terminate the calling program unless
  the call to Getopt::Long::GetOptions() was embedded in C<eval { ...
  }>, or die() was trapped using C<$SIG{__DIE__}>.
  
  GetOptions returns true to indicate success.
  It returns false when the function detected one or more errors during
  option parsing. These errors are signalled using warn() and can be
  trapped with C<$SIG{__WARN__}>.
  
  =head1 Legacy
  
  The earliest development of C<newgetopt.pl> started in 1990, with Perl
  version 4. As a result, its development, and the development of
  Getopt::Long, has gone through several stages. Since backward
  compatibility has always been extremely important, the current version
  of Getopt::Long still supports a lot of constructs that nowadays are
  no longer necessary or otherwise unwanted. This section describes
  briefly some of these 'features'.
  
  =head2 Default destinations
  
  When no destination is specified for an option, GetOptions will store
  the resultant value in a global variable named C<opt_>I<XXX>, where
  I<XXX> is the primary name of this option. When a program executes
  under C<use strict> (recommended), these variables must be
  pre-declared with our() or C<use vars>.
  
      our $opt_length = 0;
      GetOptions ('length=i');	# will store in $opt_length
  
  To yield a usable Perl variable, characters that are not part of the
  syntax for variables are translated to underscores. For example,
  C<--fpp-struct-return> will set the variable
  C<$opt_fpp_struct_return>. Note that this variable resides in the
  namespace of the calling program, not necessarily C<main>. For
  example:
  
      GetOptions ("size=i", "sizes=i@");
  
  with command line "-size 10 -sizes 24 -sizes 48" will perform the
  equivalent of the assignments
  
      $opt_size = 10;
      @opt_sizes = (24, 48);
  
  =head2 Alternative option starters
  
  A string of alternative option starter characters may be passed as the
  first argument (or the first argument after a leading hash reference
  argument).
  
      my $len = 0;
      GetOptions ('/', 'length=i' => $len);
  
  Now the command line may look like:
  
      /length 24 -- arg
  
  Note that to terminate options processing still requires a double dash
  C<-->.
  
  GetOptions() will not interpret a leading C<< "<>" >> as option starters
  if the next argument is a reference. To force C<< "<" >> and C<< ">" >> as
  option starters, use C<< "><" >>. Confusing? Well, B<using a starter
  argument is strongly deprecated> anyway.
  
  =head2 Configuration variables
  
  Previous versions of Getopt::Long used variables for the purpose of
  configuring. Although manipulating these variables still work, it is
  strongly encouraged to use the C<Configure> routine that was introduced
  in version 2.17. Besides, it is much easier.
  
  =head1 Tips and Techniques
  
  =head2 Pushing multiple values in a hash option
  
  Sometimes you want to combine the best of hashes and arrays. For
  example, the command line:
  
    --list add=first --list add=second --list add=third
  
  where each successive 'list add' option will push the value of add
  into array ref $list->{'add'}. The result would be like
  
    $list->{add} = [qw(first second third)];
  
  This can be accomplished with a destination routine:
  
    GetOptions('list=s%' =>
                 sub { push(@{$list{$_[1]}}, $_[2]) });
  
  =head1 Troubleshooting
  
  =head2 GetOptions does not return a false result when an option is not supplied
  
  That's why they're called 'options'.
  
  =head2 GetOptions does not split the command line correctly
  
  The command line is not split by GetOptions, but by the command line
  interpreter (CLI). On Unix, this is the shell. On Windows, it is
  COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.
  
  It is important to know that these CLIs may behave different when the
  command line contains special characters, in particular quotes or
  backslashes. For example, with Unix shells you can use single quotes
  (C<'>) and double quotes (C<">) to group words together. The following
  alternatives are equivalent on Unix:
  
      "two words"
      'two words'
      two\ words
  
  In case of doubt, insert the following statement in front of your Perl
  program:
  
      print STDERR (join("|",@ARGV),"\n");
  
  to verify how your CLI passes the arguments to the program.
  
  =head2 Undefined subroutine &main::GetOptions called
  
  Are you running Windows, and did you write
  
      use GetOpt::Long;
  
  (note the capital 'O')?
  
  =head2 How do I put a "-?" option into a Getopt::Long?
  
  You can only obtain this using an alias, and Getopt::Long of at least
  version 2.13.
  
      use Getopt::Long;
      GetOptions ("help|?");    # -help and -? will both set $opt_help
  
  Other characters that can't appear in Perl identifiers are also supported
  as aliases with Getopt::Long of at least version 2.39.
  
  As of version 2.32 Getopt::Long provides auto-help, a quick and easy way
  to add the options --help and -? to your program, and handle them.
  
  See C<auto_help> in section L<Configuring Getopt::Long>.
  
  =head1 AUTHOR
  
  Johan Vromans <jvromans@squirrel.nl>
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  This program is Copyright 1990,2015 by Johan Vromans.
  This program is free software; you can redistribute it and/or
  modify it under the terms of the Perl Artistic License or the
  GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any
  later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  If you do not have a copy of the GNU General Public License write to
  the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
  MA 02139, USA.
  
  =cut
  
GETOPT_LONG

$fatpacked{"Mojo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO';
  package Mojo;
  use Mojo::Base -strict;
  
  # "Professor: These old Doomsday devices are dangerously unstable. I'll rest
  #             easier not knowing where they are."
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo - Web development toolkit
  
  =head1 SYNOPSIS
  
    # HTTP/WebSocket user agent
    use Mojo::UserAgent;
    my $ua = Mojo::UserAgent->new;
    say $ua->get('www.mojolicious.org')->result->headers->server;
  
    # HTML/XML DOM parser with CSS selectors
    use Mojo::DOM;
    my $dom = Mojo::DOM->new('<div><b>Hello Mojo!</b></div>');
    say $dom->at('div > b')->text;
  
    # Perl-ish templates
    use Mojo::Template;
    my $mt = Mojo::Template->new(vars => 1);
    say $mt->render('Hello <%= $what %>!', {what => 'Mojo'});
  
    # HTTP/WebSocket server
    use Mojo::Server::Daemon;
    my $daemon = Mojo::Server::Daemon->new(listen => ['http://*:8080']);
    $daemon->unsubscribe('request')->on(request => sub {
      my ($daemon, $tx) = @_;
      $tx->res->code(200);
      $tx->res->body('Hello Mojo!');
      $tx->resume;
    });
    $daemon->run;
  
    # Event loop
    use Mojo::IOLoop;
    for my $seconds (1 .. 5) {
      Mojo::IOLoop->timer($seconds => sub { say $seconds });
    }
    Mojo::IOLoop->start;
  
  =head1 DESCRIPTION
  
  A powerful web development toolkit, with all the basic tools and helpers needed
  to write simple web applications and higher level web frameworks, such as
  L<Mojolicious>. Some of the most commonly used tools are L<Mojo::UserAgent>,
  L<Mojo::DOM>, L<Mojo::JSON>, L<Mojo::Server::Daemon>, L<Mojo::Server::Prefork>,
  L<Mojo::IOLoop> and L<Mojo::Template>.
  
  See L<Mojolicious::Guides> for more!
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO

$fatpacked{"Mojo/Asset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_ASSET';
  package Mojo::Asset;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  
  has 'end_range';
  has start_range => 0;
  
  sub add_chunk { croak 'Method "add_chunk" not implemented by subclass' }
  sub contains  { croak 'Method "contains" not implemented by subclass' }
  sub get_chunk { croak 'Method "get_chunk" not implemented by subclass' }
  
  sub is_file {undef}
  
  sub is_range { !!($_[0]->end_range || $_[0]->start_range) }
  
  sub move_to { croak 'Method "move_to" not implemented by subclass' }
  sub mtime   { croak 'Method "mtime" not implemented by subclass' }
  sub size    { croak 'Method "size" not implemented by subclass' }
  sub slurp   { croak 'Method "slurp" not implemented by subclass' }
  sub to_file { croak 'Method "to_file" not implemented by subclass' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Asset - HTTP content storage base class
  
  =head1 SYNOPSIS
  
    package Mojo::Asset::MyAsset;
    use Mojo::Base 'Mojo::Asset';
  
    sub add_chunk {...}
    sub contains  {...}
    sub get_chunk {...}
    sub move_to   {...}
    sub mtime     {...}
    sub size      {...}
    sub slurp     {...}
    sub to_file   {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Asset> is an abstract base class for HTTP content storage backends,
  like L<Mojo::Asset::File> and L<Mojo::Asset::Memory>.
  
  =head1 EVENTS
  
  L<Mojo::Asset> inherits all events from L<Mojo::EventEmitter>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Asset> implements the following attributes.
  
  =head2 end_range
  
    my $end = $asset->end_range;
    $asset  = $asset->end_range(8);
  
  Pretend file ends earlier.
  
  =head2 start_range
  
    my $start = $asset->start_range;
    $asset    = $asset->start_range(3);
  
  Pretend file starts later.
  
  =head1 METHODS
  
  L<Mojo::Asset> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 add_chunk
  
    $asset = $asset->add_chunk('foo bar baz');
  
  Add chunk of data to asset. Meant to be overloaded in a subclass.
  
  =head2 contains
  
    my $position = $asset->contains('bar');
  
  Check if asset contains a specific string. Meant to be overloaded in a
  subclass.
  
  =head2 get_chunk
  
    my $bytes = $asset->get_chunk($offset);
    my $bytes = $asset->get_chunk($offset, $max);
  
  Get chunk of data starting from a specific position, defaults to a maximum
  chunk size of C<131072> bytes (128KiB). Meant to be overloaded in a subclass.
  
  =head2 is_file
  
    my $bool = $asset->is_file;
  
  False, this is not a L<Mojo::Asset::File> object.
  
  =head2 is_range
  
    my $bool = $asset->is_range;
  
  Check if asset has a L</"start_range"> or L</"end_range">.
  
  =head2 move_to
  
    $asset = $asset->move_to('/home/sri/foo.txt');
  
  Move asset data into a specific file. Meant to be overloaded in a subclass.
  
  =head2 mtime
  
    my $mtime = $asset->mtime;
  
  Modification time of asset. Meant to be overloaded in a subclass.
  
  =head2 size
  
    my $size = $asset->size;
  
  Size of asset data in bytes. Meant to be overloaded in a subclass.
  
  =head2 slurp
  
    my $bytes = $asset->slurp;
  
  Read all asset data at once. Meant to be overloaded in a subclass.
  
  =head2 to_file
  
    my $file = $asset->to_file;
  
  Convert asset to L<Mojo::Asset::File> object. Meant to be overloaded in a
  subclass.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_ASSET

$fatpacked{"Mojo/Asset/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_ASSET_FILE';
  package Mojo::Asset::File;
  use Mojo::Base 'Mojo::Asset';
  
  use Carp 'croak';
  use Fcntl 'SEEK_SET';
  use File::Spec::Functions ();
  use Mojo::File 'tempfile';
  
  has [qw(cleanup path)];
  has handle => sub {
    my $self = shift;
  
    # Open existing file
    my $path = $self->path;
    return Mojo::File->new($path)->open('<') if defined $path && -e $path;
  
    $self->cleanup(1) unless defined $self->cleanup;
  
    # Create a specific file
    return Mojo::File->new($path)->open('+>>') if defined $path;
  
    # Create a temporary file
    my $template = 'mojo.tmp.XXXXXXXXXXXXXXXX';
    my $file = tempfile DIR => $self->tmpdir, TEMPLATE => $template, UNLINK => 0;
    $self->path($file->to_string);
    return $file->open('+>>');
  };
  has tmpdir => sub { $ENV{MOJO_TMPDIR} || File::Spec::Functions::tmpdir };
  
  sub DESTROY {
    my $self = shift;
  
    return unless $self->cleanup && defined(my $path = $self->path);
    if (my $handle = $self->handle) { close $handle }
  
    # Only the process that created the file is allowed to remove it
    unlink $path if -w $path && ($self->{pid} // $$) == $$;
  }
  
  sub add_chunk {
    my ($self, $chunk) = @_;
    ($self->handle->syswrite($chunk) // -1) == length $chunk
      or croak "Can't write to asset: $!";
    return $self;
  }
  
  sub contains {
    my ($self, $str) = @_;
  
    my $handle = $self->handle;
    $handle->sysseek($self->start_range, SEEK_SET);
  
    # Calculate window size
    my $end  = $self->end_range // $self->size;
    my $len  = length $str;
    my $size = $len > 131072 ? $len : 131072;
    $size = $end - $self->start_range if $size > $end - $self->start_range;
  
    # Sliding window search
    my $offset = 0;
    my $start = $handle->sysread(my $window, $len);
    while ($offset < $end) {
  
      # Read as much as possible
      my $diff = $end - ($start + $offset);
      my $read = $handle->sysread(my $buffer, $diff < $size ? $diff : $size);
      $window .= $buffer;
  
      # Search window
      my $pos = index $window, $str;
      return $offset + $pos if $pos >= 0;
      return -1 if $read == 0 || ($offset += $read) == $end;
  
      # Resize window
      substr $window, 0, $read, '';
    }
  
    return -1;
  }
  
  sub get_chunk {
    my ($self, $offset, $max) = @_;
    $max //= 131072;
  
    $offset += $self->start_range;
    my $handle = $self->handle;
    $handle->sysseek($offset, SEEK_SET);
  
    my $buffer;
    if (defined(my $end = $self->end_range)) {
      return '' if (my $chunk = $end + 1 - $offset) <= 0;
      $handle->sysread($buffer, $chunk > $max ? $max : $chunk);
    }
    else { $handle->sysread($buffer, $max) }
  
    return $buffer;
  }
  
  sub is_file {1}
  
  sub move_to {
    my ($self, $to) = @_;
  
    # Windows requires that the handle is closed
    close $self->handle;
    delete $self->{handle};
  
    # Move file and prevent clean up
    Mojo::File->new($self->path)->move_to($to);
    return $self->path($to)->cleanup(0);
  }
  
  sub mtime { (stat shift->handle)[9] }
  
  sub new {
    my $file = shift->SUPER::new(@_);
    $file->{pid} = $$;
    return $file;
  }
  
  sub size { -s shift->handle }
  
  sub slurp {
    my $handle = shift->handle;
    $handle->sysseek(0, SEEK_SET);
    my $ret = my $content = '';
    while ($ret = $handle->sysread(my $buffer, 131072, 0)) { $content .= $buffer }
    return defined $ret ? $content : croak "Can't read from asset: $!";
  }
  
  sub to_file {shift}
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Asset::File - File storage for HTTP content
  
  =head1 SYNOPSIS
  
    use Mojo::Asset::File;
  
    # Temporary file
    my $file = Mojo::Asset::File->new;
    $file->add_chunk('foo bar baz');
    say 'File contains "bar"' if $file->contains('bar') >= 0;
    say $file->slurp;
  
    # Existing file
    my $file = Mojo::Asset::File->new(path => '/home/sri/foo.txt');
    $file->move_to('/yada.txt');
    say $file->slurp;
  
  =head1 DESCRIPTION
  
  L<Mojo::Asset::File> is a file storage backend for HTTP content.
  
  =head1 EVENTS
  
  L<Mojo::Asset::File> inherits all events from L<Mojo::Asset>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Asset::File> inherits all attributes from L<Mojo::Asset> and implements
  the following new ones.
  
  =head2 cleanup
  
    my $bool = $file->cleanup;
    $file    = $file->cleanup($bool);
  
  Delete L</"path"> automatically once the file is not used anymore.
  
  =head2 handle
  
    my $handle = $file->handle;
    $file      = $file->handle(IO::File->new);
  
  Filehandle, created on demand for L</"path">, which can be generated
  automatically and safely based on L</"tmpdir">.
  
  =head2 path
  
    my $path = $file->path;
    $file    = $file->path('/home/sri/foo.txt');
  
  File path used to create L</"handle">.
  
  =head2 tmpdir
  
    my $tmpdir = $file->tmpdir;
    $file      = $file->tmpdir('/tmp');
  
  Temporary directory used to generate L</"path">, defaults to the value of the
  C<MOJO_TMPDIR> environment variable or auto-detection.
  
  =head1 METHODS
  
  L<Mojo::Asset::File> inherits all methods from L<Mojo::Asset> and implements
  the following new ones.
  
  =head2 add_chunk
  
    $file = $file->add_chunk('foo bar baz');
  
  Add chunk of data.
  
  =head2 contains
  
    my $position = $file->contains('bar');
  
  Check if asset contains a specific string.
  
  =head2 get_chunk
  
    my $bytes = $file->get_chunk($offset);
    my $bytes = $file->get_chunk($offset, $max);
  
  Get chunk of data starting from a specific position, defaults to a maximum
  chunk size of C<131072> bytes (128KiB).
  
  =head2 is_file
  
    my $bool = $file->is_file;
  
  True, this is a L<Mojo::Asset::File> object.
  
  =head2 move_to
  
    $file = $file->move_to('/home/sri/bar.txt');
  
  Move asset data into a specific file and disable L</"cleanup">.
  
  =head2 mtime
  
    my $mtime = $file->mtime;
  
  Modification time of asset.
  
  =head2 new
  
    my $file = Mojo::Asset::File->new;
    my $file = Mojo::Asset::File->new(path => '/home/sri/test.txt');
    my $file = Mojo::Asset::File->new({path => '/home/sri/test.txt'});
  
  Construct a new L<Mojo::Asset::File> object.
  
  =head2 size
  
    my $size = $file->size;
  
  Size of asset data in bytes.
  
  =head2 slurp
  
    my $bytes = $file->slurp;
  
  Read all asset data at once.
  
  =head2 to_file
  
    $file = $file->to_file;
  
  Does nothing but return the invocant, since we already have a
  L<Mojo::Asset::File> object.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_ASSET_FILE

$fatpacked{"Mojo/Asset/Memory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_ASSET_MEMORY';
  package Mojo::Asset::Memory;
  use Mojo::Base 'Mojo::Asset';
  
  use Mojo::Asset::File;
  use Mojo::File 'path';
  
  has 'auto_upgrade';
  has max_memory_size => sub { $ENV{MOJO_MAX_MEMORY_SIZE} || 262144 };
  has mtime => sub {$^T};
  
  sub add_chunk {
    my ($self, $chunk) = @_;
  
    # Upgrade if necessary
    $self->{content} .= $chunk;
    return $self if !$self->auto_upgrade || $self->size <= $self->max_memory_size;
    $self->emit(upgrade => my $file = $self->to_file);
    return $file;
  }
  
  sub contains {
    my ($self, $str) = @_;
  
    my $start = $self->start_range;
    my $pos = index $self->{content} // '', $str, $start;
    $pos -= $start if $start && $pos >= 0;
    my $end = $self->end_range;
  
    return $end && ($pos + length $str) >= $end ? -1 : $pos;
  }
  
  sub get_chunk {
    my ($self, $offset, $max) = @_;
    $max //= 131072;
  
    $offset += $self->start_range;
    if (my $end = $self->end_range) {
      $max = $end + 1 - $offset if ($offset + $max) > $end;
    }
  
    return substr shift->{content} // '', $offset, $max;
  }
  
  sub move_to { path($_[1])->spurt($_[0]{content} // '') and return $_[0] }
  
  sub size { length(shift->{content} // '') }
  
  sub slurp { shift->{content} // '' }
  
  sub to_file { Mojo::Asset::File->new->add_chunk(shift->slurp) }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Asset::Memory - In-memory storage for HTTP content
  
  =head1 SYNOPSIS
  
    use Mojo::Asset::Memory;
  
    my $mem = Mojo::Asset::Memory->new;
    $mem->add_chunk('foo bar baz');
    say $mem->slurp;
  
  =head1 DESCRIPTION
  
  L<Mojo::Asset::Memory> is an in-memory storage backend for HTTP content.
  
  =head1 EVENTS
  
  L<Mojo::Asset::Memory> inherits all events from L<Mojo::Asset> and can emit the
  following new ones.
  
  =head2 upgrade
  
    $mem->on(upgrade => sub {
      my ($mem, $file) = @_;
      ...
    });
  
  Emitted when asset gets upgraded to a L<Mojo::Asset::File> object.
  
    $mem->on(upgrade => sub {
      my ($mem, $file) = @_;
      $file->tmpdir('/tmp');
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Asset::Memory> inherits all attributes from L<Mojo::Asset> and
  implements the following new ones.
  
  =head2 auto_upgrade
  
    my $bool = $mem->auto_upgrade;
    $mem     = $mem->auto_upgrade($bool);
  
  Try to detect if content size exceeds L</"max_memory_size"> limit and
  automatically upgrade to a L<Mojo::Asset::File> object.
  
  =head2 max_memory_size
  
    my $size = $mem->max_memory_size;
    $mem     = $mem->max_memory_size(1024);
  
  Maximum size in bytes of data to keep in memory before automatically upgrading
  to a L<Mojo::Asset::File> object, defaults to the value of the
  C<MOJO_MAX_MEMORY_SIZE> environment variable or C<262144> (256KiB).
  
  =head2 mtime
  
    my $mtime = $mem->mtime;
    $mem      = $mem->mtime(1408567500);
  
  Modification time of asset, defaults to the value of C<$^T>.
  
  =head1 METHODS
  
  L<Mojo::Asset::Memory> inherits all methods from L<Mojo::Asset> and implements
  the following new ones.
  
  =head2 add_chunk
  
    $mem     = $mem->add_chunk('foo bar baz');
    my $file = $mem->add_chunk('abc' x 262144);
  
  Add chunk of data and upgrade to L<Mojo::Asset::File> object if necessary.
  
  =head2 contains
  
    my $position = $mem->contains('bar');
  
  Check if asset contains a specific string.
  
  =head2 get_chunk
  
    my $bytes = $mem->get_chunk($offset);
    my $bytes = $mem->get_chunk($offset, $max);
  
  Get chunk of data starting from a specific position, defaults to a maximum
  chunk size of C<131072> bytes (128KiB).
  
  =head2 move_to
  
    $mem = $mem->move_to('/home/sri/foo.txt');
  
  Move asset data into a specific file.
  
  =head2 size
  
    my $size = $mem->size;
  
  Size of asset data in bytes.
  
  =head2 slurp
  
    my $bytes = mem->slurp;
  
  Read all asset data at once.
  
  =head2 to_file
  
    my $file = $mem->to_file;
  
  Convert asset to L<Mojo::Asset::File> object.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_ASSET_MEMORY

$fatpacked{"Mojo/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_BASE';
  package Mojo::Base;
  
  use strict;
  use warnings;
  use utf8;
  use feature ();
  
  # No imports because we get subclassed, a lot!
  use Carp         ();
  use Scalar::Util ();
  
  # Defer to runtime so Mojo::Util can use "-strict"
  require Mojo::Util;
  
  # Only Perl 5.14+ requires it on demand
  use IO::Handle ();
  
  # Role support requires Role::Tiny 2.000001+
  use constant ROLES =>
    !!(eval { require Role::Tiny; Role::Tiny->VERSION('2.000001'); 1 });
  
  # Protect subclasses using AUTOLOAD
  sub DESTROY { }
  
  sub attr {
    my ($self, $attrs, $value) = @_;
    return unless (my $class = ref $self || $self) && $attrs;
  
    Carp::croak 'Default has to be a code reference or constant value'
      if ref $value && ref $value ne 'CODE';
  
    for my $attr (@{ref $attrs eq 'ARRAY' ? $attrs : [$attrs]}) {
      Carp::croak qq{Attribute "$attr" invalid} unless $attr =~ /^[a-zA-Z_]\w*$/;
  
      # Very performance-sensitive code with lots of micro-optimizations
      if (ref $value) {
        my $sub = sub {
          return
            exists $_[0]{$attr} ? $_[0]{$attr} : ($_[0]{$attr} = $value->($_[0]))
            if @_ == 1;
          $_[0]{$attr} = $_[1];
          $_[0];
        };
        Mojo::Util::monkey_patch($class, $attr, $sub);
      }
      elsif (defined $value) {
        my $sub = sub {
          return exists $_[0]{$attr} ? $_[0]{$attr} : ($_[0]{$attr} = $value)
            if @_ == 1;
          $_[0]{$attr} = $_[1];
          $_[0];
        };
        Mojo::Util::monkey_patch($class, $attr, $sub);
      }
      else {
        Mojo::Util::monkey_patch($class, $attr,
          sub { return $_[0]{$attr} if @_ == 1; $_[0]{$attr} = $_[1]; $_[0] });
      }
    }
  }
  
  sub import {
    my ($class, $caller) = (shift, caller);
    return unless my @flags = @_;
  
    # Base
    if ($flags[0] eq '-base') { $flags[0] = $class }
  
    # Role
    if ($flags[0] eq '-role') {
      Carp::croak 'Role::Tiny 2.000001+ is required for roles' unless ROLES;
      Mojo::Util::monkey_patch($caller, 'has', sub { attr($caller, @_) });
      eval "package $caller; use Role::Tiny; 1" or die $@;
    }
  
    # Module and not -strict
    elsif ($flags[0] !~ /^-/) {
      no strict 'refs';
      require(Mojo::Util::class_to_path($flags[0])) unless $flags[0]->can('new');
      push @{"${caller}::ISA"}, $flags[0];
      Mojo::Util::monkey_patch($caller, 'has', sub { attr($caller, @_) });
    }
  
    # Mojo modules are strict!
    $_->import for qw(strict warnings utf8);
    feature->import(':5.10');
  
    # Signatures (Perl 5.20+)
    if (($flags[1] || '') eq '-signatures') {
      Carp::croak 'Subroutine signatures require Perl 5.20+' if $] < 5.020;
      require experimental;
      experimental->import('signatures');
    }
  }
  
  sub new {
    my $class = shift;
    bless @_ ? @_ > 1 ? {@_} : {%{$_[0]}} : {}, ref $class || $class;
  }
  
  sub tap {
    my ($self, $cb) = (shift, shift);
    $_->$cb(@_) for $self;
    return $self;
  }
  
  sub with_roles {
    Carp::croak 'Role::Tiny 2.000001+ is required for roles' unless ROLES;
    my ($self, @roles) = @_;
  
    return Role::Tiny->create_class_with_roles($self,
      map { /^\+(.+)$/ ? "${self}::Role::$1" : $_ } @roles)
      unless my $class = Scalar::Util::blessed $self;
  
    return Role::Tiny->apply_roles_to_object($self,
      map { /^\+(.+)$/ ? "${class}::Role::$1" : $_ } @roles);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Base - Minimal base class for Mojo projects
  
  =head1 SYNOPSIS
  
    package Cat;
    use Mojo::Base -base;
  
    has name => 'Nyan';
    has ['age', 'weight'] => 4;
  
    package Tiger;
    use Mojo::Base 'Cat';
  
    has friend  => sub { Cat->new };
    has stripes => 42;
  
    package main;
    use Mojo::Base -strict;
  
    my $mew = Cat->new(name => 'Longcat');
    say $mew->age;
    say $mew->age(3)->weight(5)->age;
  
    my $rawr = Tiger->new(stripes => 38, weight => 250);
    say $rawr->tap(sub { $_->friend->name('Tacgnol') })->weight;
  
  =head1 DESCRIPTION
  
  L<Mojo::Base> is a simple base class for L<Mojo> projects with fluent
  interfaces.
  
    # Automatically enables "strict", "warnings", "utf8" and Perl 5.10 features
    use Mojo::Base -strict;
    use Mojo::Base -base;
    use Mojo::Base 'SomeBaseClass';
    use Mojo::Base -role;
  
  All four forms save a lot of typing. Note that role support depends on
  L<Role::Tiny> (2.000001+).
  
    # use Mojo::Base -strict;
    use strict;
    use warnings;
    use utf8;
    use feature ':5.10';
    use IO::Handle ();
  
    # use Mojo::Base -base;
    use strict;
    use warnings;
    use utf8;
    use feature ':5.10';
    use IO::Handle ();
    push @ISA, 'Mojo::Base';
    sub has { Mojo::Base::attr(__PACKAGE__, @_) }
  
    # use Mojo::Base 'SomeBaseClass';
    use strict;
    use warnings;
    use utf8;
    use feature ':5.10';
    use IO::Handle ();
    require SomeBaseClass;
    push @ISA, 'SomeBaseClass';
    sub has { Mojo::Base::attr(__PACKAGE__, @_) }
  
    # use Mojo::Base -role;
    use strict;
    use warnings;
    use utf8;
    use feature ':5.10';
    use IO::Handle ();
    use Role::Tiny;
    sub has { Mojo::Base::attr(__PACKAGE__, @_) }
  
  On Perl 5.20+ you can also append a C<-signatures> flag to all three forms and
  enable support for L<subroutine signatures|perlsub/"Signatures">.
  
    # Also enable signatures
    use Mojo::Base -strict, -signatures;
    use Mojo::Base -base, -signatures;
    use Mojo::Base 'SomeBaseClass', -signatures;
    use Mojo::Base -role, -signatures;
  
  This will also disable experimental warnings on versions of Perl where this
  feature was still experimental.
  
  =head1 FLUENT INTERFACES
  
  Fluent interfaces are a way to design object-oriented APIs around method
  chaining to create domain-specific languages, with the goal of making the
  readablity of the source code close to written prose.
  
    package Duck;
    use Mojo::Base -base;
  
    has 'name';
  
    sub quack {
      my $self = shift;
      my $name = $self->name;
      say "$name: Quack!"
    }
  
  L<Mojo::Base> will help you with this by having all attribute accessors created
  with L</"has"> (or L</"attr">) return their invocant (C<$self>) whenever they
  are used to assign a new attribute value.
  
    Duck->new->name('Donald')->quack;
  
  In this case the C<name> attribute accessor is called on the object created by
  C<Duck-E<gt>new>. It assigns a new attribute value and then returns the C<Duck>
  object, so the C<quack> method can be called on it afterwards. These method
  chains can continue until one of the methods called does not return the C<Duck>
  object.
  
  =head1 FUNCTIONS
  
  L<Mojo::Base> implements the following functions, which can be imported with
  the C<-base> flag or by setting a base class.
  
  =head2 has
  
    has 'name';
    has ['name1', 'name2', 'name3'];
    has name => 'foo';
    has name => sub {...};
    has ['name1', 'name2', 'name3'] => 'foo';
    has ['name1', 'name2', 'name3'] => sub {...};
  
  Create attributes for hash-based objects, just like the L</"attr"> method.
  
  =head1 METHODS
  
  L<Mojo::Base> implements the following methods.
  
  =head2 attr
  
    $object->attr('name');
    SubClass->attr('name');
    SubClass->attr(['name1', 'name2', 'name3']);
    SubClass->attr(name => 'foo');
    SubClass->attr(name => sub {...});
    SubClass->attr(['name1', 'name2', 'name3'] => 'foo');
    SubClass->attr(['name1', 'name2', 'name3'] => sub {...});
  
  Create attribute accessors for hash-based objects, an array reference can be
  used to create more than one at a time. Pass an optional second argument to set
  a default value, it should be a constant or a callback. The callback will be
  executed at accessor read time if there's no set value, and gets passed the
  current instance of the object as first argument. Accessors can be chained, that
  means they return their invocant when they are called with an argument.
  
  =head2 new
  
    my $object = SubClass->new;
    my $object = SubClass->new(name => 'value');
    my $object = SubClass->new({name => 'value'});
  
  This base class provides a basic constructor for hash-based objects. You can
  pass it either a hash or a hash reference with attribute values.
  
  =head2 tap
  
    $object = $object->tap(sub {...});
    $object = $object->tap('some_method');
    $object = $object->tap('some_method', @args);
  
  Tap into a method chain to perform operations on an object within the chain
  (also known as a K combinator or Kestrel). The object will be the first argument
  passed to the callback, and is also available as C<$_>. The callback's return
  value will be ignored; instead, the object (the callback's first argument) will
  be the return value. In this way, arbitrary code can be used within (i.e.,
  spliced or tapped into) a chained set of object method calls.
  
    # Longer version
    $object = $object->tap(sub { $_->some_method(@args) });
  
    # Inject side effects into a method chain
    $object->foo('A')->tap(sub { say $_->foo })->foo('B');
  
  =head2 with_roles
  
    my $new_class = SubClass->with_roles('SubClass::Role::One');
    my $new_class = SubClass->with_roles('+One', '+Two');
    $object       = $object->with_roles('+One', '+Two');
  
  Create a new class with one or more L<Role::Tiny> roles. If called on a class
  returns the new class, or if called on an object reblesses the object into the
  new class. For roles following the naming scheme C<MyClass::Role::RoleName> you
  can use the shorthand C<+RoleName>. Note that role support depends on
  L<Role::Tiny> (2.000001+).
  
    # Create a new class with the role "SubClass::Role::Foo" and instantiate it
    my $new_class = SubClass->with_roles('+Foo');
    my $object    = $new_class->new;
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_BASE

$fatpacked{"Mojo/ByteStream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_BYTESTREAM';
  package Mojo::ByteStream;
  use Mojo::Base -strict;
  use overload bool => sub {1}, '""' => sub { ${$_[0]} }, fallback => 1;
  
  use Exporter 'import';
  use Mojo::Collection;
  use Mojo::Util;
  
  our @EXPORT_OK = ('b');
  
  # Turn most functions from Mojo::Util into methods
  my @UTILS = (
    qw(b64_decode b64_encode camelize decamelize hmac_sha1_sum html_unescape),
    qw(md5_bytes md5_sum punycode_decode punycode_encode quote sha1_bytes),
    qw(sha1_sum slugify term_escape trim unindent unquote url_escape),
    qw(url_unescape xml_escape xor_encode)
  );
  for my $name (@UTILS) {
    my $sub = Mojo::Util->can($name);
    Mojo::Util::monkey_patch __PACKAGE__, $name, sub {
      my $self = shift;
      $$self = $sub->($$self, @_);
      return $self;
    };
  }
  
  sub b { __PACKAGE__->new(@_) }
  
  sub clone { $_[0]->new(${$_[0]}) }
  
  sub decode { shift->_delegate(\&Mojo::Util::decode, @_) }
  sub encode { shift->_delegate(\&Mojo::Util::encode, @_) }
  
  sub new {
    my $class = shift;
    return bless \(my $dummy = join '', @_), ref $class || $class;
  }
  
  sub say {
    my ($self, $handle) = @_;
    $handle ||= \*STDOUT;
    say $handle $$self;
    return $self;
  }
  
  sub secure_compare { Mojo::Util::secure_compare ${shift()}, shift }
  
  sub size { length ${$_[0]} }
  
  sub split {
    my ($self, $pattern) = @_;
    return Mojo::Collection->new(map { $self->new($_) } split $pattern, $$self);
  }
  
  sub tap { shift->Mojo::Base::tap(@_) }
  
  sub to_string { ${$_[0]} }
  
  sub with_roles { shift->Mojo::Base::with_roles(@_) }
  
  sub _delegate {
    my ($self, $sub) = (shift, shift);
    $$self = $sub->(shift || 'UTF-8', $$self);
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::ByteStream - ByteStream
  
  =head1 SYNOPSIS
  
    use Mojo::ByteStream;
  
    # Manipulate bytestream
    my $stream = Mojo::ByteStream->new('foo_bar_baz');
    say $stream->camelize;
  
    # Chain methods
    my $stream = Mojo::ByteStream->new('foo bar baz')->quote;
    $stream = $stream->unquote->encode('UTF-8')->b64_encode('');
    say "$stream";
  
    # Use the alternative constructor
    use Mojo::ByteStream 'b';
    my $stream = b('foobarbaz')->b64_encode('')->say;
  
  =head1 DESCRIPTION
  
  L<Mojo::ByteStream> is a scalar-based container for bytestreams that provides a
  more friendly API for many of the functions in L<Mojo::Util>.
  
    # Access scalar directly to manipulate bytestream
    my $stream = Mojo::ByteStream->new('foo');
    $$stream .= 'bar';
  
  =head1 FUNCTIONS
  
  L<Mojo::ByteStream> implements the following functions, which can be imported
  individually.
  
  =head2 b
  
    my $stream = b('test123');
  
  Construct a new scalar-based L<Mojo::ByteStream> object.
  
  =head1 METHODS
  
  L<Mojo::ByteStream> implements the following methods.
  
  =head2 b64_decode
  
    $stream = $stream->b64_decode;
  
  Base64 decode bytestream with L<Mojo::Util/"b64_decode">.
  
  =head2 b64_encode
  
    $stream = $stream->b64_encode;
    $stream = $stream->b64_encode("\n");
  
  Base64 encode bytestream with L<Mojo::Util/"b64_encode">.
  
    # "Zm9vIGJhciBiYXo="
    b('foo bar baz')->b64_encode('');
  
  =head2 camelize
  
    $stream = $stream->camelize;
  
  Camelize bytestream with L<Mojo::Util/"camelize">.
  
  =head2 clone
  
    my $stream2 = $stream->clone;
  
  Return a new L<Mojo::ByteStream> object cloned from this bytestream.
  
  =head2 decamelize
  
    $stream = $stream->decamelize;
  
  Decamelize bytestream with L<Mojo::Util/"decamelize">.
  
  =head2 decode
  
    $stream = $stream->decode;
    $stream = $stream->decode('iso-8859-1');
  
  Decode bytestream with L<Mojo::Util/"decode">, defaults to using C<UTF-8>.
  
    # ""
    b('%E2%99%A5')->url_unescape->decode;
  
  =head2 encode
  
    $stream = $stream->encode;
    $stream = $stream->encode('iso-8859-1');
  
  Encode bytestream with L<Mojo::Util/"encode">, defaults to using C<UTF-8>.
  
    # "%E2%99%A5"
    b('')->encode->url_escape;
  
  =head2 hmac_sha1_sum
  
    $stream = $stream->hmac_sha1_sum('passw0rd');
  
  Generate HMAC-SHA1 checksum for bytestream with L<Mojo::Util/"hmac_sha1_sum">.
  
    # "7fbdc89263974a89210ea71f171c77d3f8c21471"
    b('foo bar baz')->hmac_sha1_sum('secr3t');
  
  =head2 html_unescape
  
    $stream = $stream->html_unescape;
  
  Unescape all HTML entities in bytestream with L<Mojo::Util/"html_unescape">.
  
    # "%3Chtml%3E"
    b('&lt;html&gt;')->html_unescape->url_escape;
  
  =head2 md5_bytes
  
    $stream = $stream->md5_bytes;
  
  Generate binary MD5 checksum for bytestream with L<Mojo::Util/"md5_bytes">.
  
  =head2 md5_sum
  
    $stream = $stream->md5_sum;
  
  Generate MD5 checksum for bytestream with L<Mojo::Util/"md5_sum">.
  
  =head2 new
  
    my $stream = Mojo::ByteStream->new('test123');
  
  Construct a new scalar-based L<Mojo::ByteStream> object.
  
  =head2 punycode_decode
  
    $stream = $stream->punycode_decode;
  
  Punycode decode bytestream with L<Mojo::Util/"punycode_decode">.
  
  =head2 punycode_encode
  
    $stream = $stream->punycode_encode;
  
  Punycode encode bytestream with L<Mojo::Util/"punycode_encode">.
  
  =head2 quote
  
    $stream = $stream->quote;
  
  Quote bytestream with L<Mojo::Util/"quote">.
  
  =head2 say
  
    $stream = $stream->say;
    $stream = $stream->say(*STDERR);
  
  Print bytestream to handle and append a newline, defaults to using C<STDOUT>.
  
  =head2 secure_compare
  
    my $bool = $stream->secure_compare($str);
  
  Compare bytestream with L<Mojo::Util/"secure_compare">.
  
  =head2 sha1_bytes
  
    $stream = $stream->sha1_bytes;
  
  Generate binary SHA1 checksum for bytestream with L<Mojo::Util/"sha1_bytes">.
  
  =head2 sha1_sum
  
    $stream = $stream->sha1_sum;
  
  Generate SHA1 checksum for bytestream with L<Mojo::Util/"sha1_sum">.
  
  =head2 size
  
    my $size = $stream->size;
  
  Size of bytestream.
  
  =head2 slugify
  
    $stream = $stream->slugify;
    $stream = $stream->slugify($bool);
  
  Generate URL slug for bytestream with L<Mojo::Util/"slugify">.
  
  =head2 split
  
    my $collection = $stream->split(',');
  
  Turn bytestream into L<Mojo::Collection> object containing L<Mojo::ByteStream>
  objects.
  
    # "One,Two,Three"
    b("one,two,three")->split(',')->map('camelize')->join(',');
  
  =head2 tap
  
    $stream = $stream->tap(sub {...});
  
  Alias for L<Mojo::Base/"tap">.
  
  =head2 term_escape
  
    $stream = $stream->term_escape;
  
  Escape POSIX control characters in bytestream with L<Mojo::Util/"term_escape">.
  
    # Print binary checksum to terminal
    b('foo')->sha1_bytes->term_escape->say;
  
  =head2 to_string
  
    my $str = $stream->to_string;
  
  Stringify bytestream.
  
  =head2 trim
  
    $stream = $stream->trim;
  
  Trim whitespace characters from both ends of bytestream with
  L<Mojo::Util/"trim">.
  
  =head2 unindent
  
    $stream = $stream->unindent;
  
  Unindent bytestream with L<Mojo::Util/"unindent">.
  
  =head2 unquote
  
    $stream = $stream->unquote;
  
  Unquote bytestream with L<Mojo::Util/"unquote">.
  
  =head2 url_escape
  
    $stream = $stream->url_escape;
    $stream = $stream->url_escape('^A-Za-z0-9\-._~');
  
  Percent encode all unsafe characters in bytestream with
  L<Mojo::Util/"url_escape">.
  
    # "%E2%98%83"
    b('')->encode->url_escape;
  
  =head2 url_unescape
  
    $stream = $stream->url_unescape;
  
  Decode percent encoded characters in bytestream with
  L<Mojo::Util/"url_unescape">.
  
    # "&lt;html&gt;"
    b('%3Chtml%3E')->url_unescape->xml_escape;
  
  =head2 with_roles
  
    my $new_class = Mojo::ByteStream->with_roles('Mojo::ByteStream::Role::One');
    my $new_class = Mojo::ByteStream->with_roles('+One', '+Two');
    $stream       = $stream->with_roles('+One', '+Two');
  
  Alias for L<Mojo::Base/"with_roles">.
  
  =head2 xml_escape
  
    $stream = $stream->xml_escape;
  
  Escape only the characters C<&>, C<E<lt>>, C<E<gt>>, C<"> and C<'> in
  bytestream with L<Mojo::Util/"xml_escape">.
  
  =head2 xor_encode
  
    $stream = $stream->xor_encode($key);
  
  XOR encode bytestream with L<Mojo::Util/"xor_encode">.
  
    # "%04%0E%15B%03%1B%10"
    b('foo bar')->xor_encode('baz')->url_escape;
  
  =head1 OPERATORS
  
  L<Mojo::ByteStream> overloads the following operators.
  
  =head2 bool
  
    my $bool = !!$bytestream;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$bytestream";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_BYTESTREAM

$fatpacked{"Mojo/Cache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_CACHE';
  package Mojo::Cache;
  use Mojo::Base -base;
  
  has 'max_keys' => 100;
  
  sub get { (shift->{cache} || {})->{shift()} }
  
  sub set {
    my ($self, $key, $value) = @_;
  
    return $self unless (my $max = $self->max_keys) > 0;
  
    my $cache = $self->{cache} ||= {};
    my $queue = $self->{queue} ||= [];
    delete $cache->{shift @$queue} while @$queue >= $max;
    push @$queue, $key unless exists $cache->{$key};
    $cache->{$key} = $value;
  
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Cache - Naive in-memory cache
  
  =head1 SYNOPSIS
  
    use Mojo::Cache;
  
    my $cache = Mojo::Cache->new(max_keys => 50);
    $cache->set(foo => 'bar');
    my $foo = $cache->get('foo');
  
  =head1 DESCRIPTION
  
  L<Mojo::Cache> is a naive in-memory cache with size limits.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Cache> implements the following attributes.
  
  =head2 max_keys
  
    my $max = $cache->max_keys;
    $cache  = $cache->max_keys(50);
  
  Maximum number of cache keys, defaults to C<100>. Setting the value to C<0>
  will disable caching.
  
  =head1 METHODS
  
  L<Mojo::Cache> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 get
  
    my $value = $cache->get('foo');
  
  Get cached value.
  
  =head2 set
  
    $cache = $cache->set(foo => 'bar');
  
  Set cached value.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_CACHE

$fatpacked{"Mojo/Collection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_COLLECTION';
  package Mojo::Collection;
  use Mojo::Base -strict;
  
  use Carp 'croak';
  use Exporter 'import';
  use List::Util;
  use Mojo::ByteStream;
  use Scalar::Util 'blessed';
  
  our @EXPORT_OK = ('c');
  
  sub TO_JSON { [@{shift()}] }
  
  sub c { __PACKAGE__->new(@_) }
  
  sub compact {
    my $self = shift;
    return $self->new(grep { defined && (ref || length) } @$self);
  }
  
  sub each {
    my ($self, $cb) = @_;
    return @$self unless $cb;
    my $i = 1;
    $_->$cb($i++) for @$self;
    return $self;
  }
  
  sub first {
    my ($self, $cb) = (shift, shift);
    return $self->[0] unless $cb;
    return List::Util::first { $_ =~ $cb } @$self if ref $cb eq 'Regexp';
    return List::Util::first { $_->$cb(@_) } @$self;
  }
  
  sub flatten { $_[0]->new(_flatten(@{$_[0]})) }
  
  sub grep {
    my ($self, $cb) = (shift, shift);
    return $self->new(grep { $_ =~ $cb } @$self) if ref $cb eq 'Regexp';
    return $self->new(grep { $_->$cb(@_) } @$self);
  }
  
  sub join {
    Mojo::ByteStream->new(join $_[1] // '', map {"$_"} @{$_[0]});
  }
  
  sub last { shift->[-1] }
  
  sub map {
    my ($self, $cb) = (shift, shift);
    return $self->new(map { $_->$cb(@_) } @$self);
  }
  
  sub new {
    my $class = shift;
    return bless [@_], ref $class || $class;
  }
  
  sub reduce {
    my $self = shift;
    @_ = (@_, @$self);
    goto &List::Util::reduce;
  }
  
  sub reverse { $_[0]->new(reverse @{$_[0]}) }
  
  sub shuffle { $_[0]->new(List::Util::shuffle @{$_[0]}) }
  
  sub size { scalar @{$_[0]} }
  
  sub slice {
    my $self = shift;
    return $self->new(@$self[@_]);
  }
  
  sub sort {
    my ($self, $cb) = @_;
  
    return $self->new(sort @$self) unless $cb;
  
    my $caller = caller;
    no strict 'refs';
    my @sorted = sort {
      local (*{"${caller}::a"}, *{"${caller}::b"}) = (\$a, \$b);
      $a->$cb($b);
    } @$self;
    return $self->new(@sorted);
  }
  
  sub tap { shift->Mojo::Base::tap(@_) }
  
  sub to_array { [@{shift()}] }
  
  sub uniq {
    my ($self, $cb) = (shift, shift);
    my %seen;
    return $self->new(grep { !$seen{$_->$cb(@_) // ''}++ } @$self) if $cb;
    return $self->new(grep { !$seen{$_ // ''}++ } @$self);
  }
  
  sub with_roles { shift->Mojo::Base::with_roles(@_) }
  
  sub _flatten {
    map { _ref($_) ? _flatten(@$_) : $_ } @_;
  }
  
  sub _ref { ref $_[0] eq 'ARRAY' || blessed $_[0] && $_[0]->isa(__PACKAGE__) }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Collection - Collection
  
  =head1 SYNOPSIS
  
    use Mojo::Collection;
  
    # Manipulate collection
    my $collection = Mojo::Collection->new(qw(just works));
    unshift @$collection, 'it';
    say $collection->join("\n");
  
    # Chain methods
    $collection->map(sub { ucfirst })->shuffle->each(sub {
      my ($word, $num) = @_;
      say "$num: $word";
    });
  
    # Use the alternative constructor
    use Mojo::Collection 'c';
    c(qw(a b c))->join('/')->url_escape->say;
  
  =head1 DESCRIPTION
  
  L<Mojo::Collection> is an array-based container for collections.
  
    # Access array directly to manipulate collection
    my $collection = Mojo::Collection->new(1 .. 25);
    $collection->[23] += 100;
    say for @$collection;
  
  =head1 FUNCTIONS
  
  L<Mojo::Collection> implements the following functions, which can be imported
  individually.
  
  =head2 c
  
    my $collection = c(1, 2, 3);
  
  Construct a new array-based L<Mojo::Collection> object.
  
  =head1 METHODS
  
  L<Mojo::Collection> implements the following methods.
  
  =head2 TO_JSON
  
    my $array = $collection->TO_JSON;
  
  Alias for L</"to_array">.
  
  =head2 compact
  
    my $new = $collection->compact;
  
  Create a new collection with all elements that are defined and not an empty
  string.
  
    # "0, 1, 2, 3"
    c(0, 1, undef, 2, '', 3)->compact->join(', ');
  
  =head2 each
  
    my @elements = $collection->each;
    $collection  = $collection->each(sub {...});
  
  Evaluate callback for each element in collection, or return all elements as a
  list if none has been provided. The element will be the first argument passed
  to the callback, and is also available as C<$_>.
  
    # Make a numbered list
    $collection->each(sub {
      my ($e, $num) = @_;
      say "$num: $e";
    });
  
  =head2 first
  
    my $first = $collection->first;
    my $first = $collection->first(qr/foo/);
    my $first = $collection->first(sub {...});
    my $first = $collection->first('some_method');
    my $first = $collection->first('some_method', @args);
  
  Evaluate regular expression/callback for, or call method on, each element in
  collection and return the first one that matched the regular expression, or for
  which the callback/method returned true. The element will be the first argument
  passed to the callback, and is also available as C<$_>.
  
    # Longer version
    my $first = $collection->first(sub { $_->some_method(@args) });
  
    # Find first value that contains the word "mojo"
    my $interesting = $collection->first(qr/mojo/i);
  
    # Find first value that is greater than 5
    my $greater = $collection->first(sub { $_ > 5 });
  
  =head2 flatten
  
    my $new = $collection->flatten;
  
  Flatten nested collections/arrays recursively and create a new collection with
  all elements.
  
    # "1, 2, 3, 4, 5, 6, 7"
    c(1, [2, [3, 4], 5, [6]], 7)->flatten->join(', ');
  
  =head2 grep
  
    my $new = $collection->grep(qr/foo/);
    my $new = $collection->grep(sub {...});
    my $new = $collection->grep('some_method');
    my $new = $collection->grep('some_method', @args);
  
  Evaluate regular expression/callback for, or call method on, each element in
  collection and create a new collection with all elements that matched the
  regular expression, or for which the callback/method returned true. The element
  will be the first argument passed to the callback, and is also available as
  C<$_>.
  
    # Longer version
    my $new = $collection->grep(sub { $_->some_method(@args) });
  
    # Find all values that contain the word "mojo"
    my $interesting = $collection->grep(qr/mojo/i);
  
    # Find all values that are greater than 5
    my $greater = $collection->grep(sub { $_ > 5 });
  
  =head2 join
  
    my $stream = $collection->join;
    my $stream = $collection->join("\n");
  
  Turn collection into L<Mojo::ByteStream>.
  
    # Join all values with commas
    $collection->join(', ')->say;
  
  =head2 last
  
    my $last = $collection->last;
  
  Return the last element in collection.
  
  =head2 map
  
    my $new = $collection->map(sub {...});
    my $new = $collection->map('some_method');
    my $new = $collection->map('some_method', @args);
  
  Evaluate callback for, or call method on, each element in collection and create
  a new collection from the results. The element will be the first argument
  passed to the callback, and is also available as C<$_>.
  
    # Longer version
    my $new = $collection->map(sub { $_->some_method(@args) });
  
    # Append the word "mojo" to all values
    my $mojoified = $collection->map(sub { $_ . 'mojo' });
  
  =head2 new
  
    my $collection = Mojo::Collection->new(1, 2, 3);
  
  Construct a new array-based L<Mojo::Collection> object.
  
  =head2 reduce
  
    my $result = $collection->reduce(sub {...});
    my $result = $collection->reduce(sub {...}, $initial);
  
  Reduce elements in collection with a callback and return its final result,
  setting C<$a> and C<$b> each time the callback is executed. The first time C<$a>
  will be set to an optional initial value or the first element in the collection.
  And from then on C<$a> will be set to the return value of the callback, while
  C<$b> will always be set to the next element in the collection.
  
    # Calculate the sum of all values
    my $sum = $collection->reduce(sub { $a + $b });
  
    # Count how often each value occurs in collection
    my $hash = $collection->reduce(sub { $a->{$b}++; $a }, {});
  
  =head2 reverse
  
    my $new = $collection->reverse;
  
  Create a new collection with all elements in reverse order.
  
  =head2 slice
  
    my $new = $collection->slice(4 .. 7);
  
  Create a new collection with all selected elements.
  
    # "B C E"
    c('A', 'B', 'C', 'D', 'E')->slice(1, 2, 4)->join(' ');
  
  =head2 shuffle
  
    my $new = $collection->shuffle;
  
  Create a new collection with all elements in random order.
  
  =head2 size
  
    my $size = $collection->size;
  
  Number of elements in collection.
  
  =head2 sort
  
    my $new = $collection->sort;
    my $new = $collection->sort(sub {...});
  
  Sort elements based on return value of a callback and create a new collection
  from the results, setting C<$a> and C<$b> to the elements being compared, each
  time the callback is executed.
  
    # Sort values case-insensitive
    my $case_insensitive = $collection->sort(sub { uc($a) cmp uc($b) });
  
  =head2 tap
  
    $collection = $collection->tap(sub {...});
  
  Alias for L<Mojo::Base/"tap">.
  
  =head2 to_array
  
    my $array = $collection->to_array;
  
  Turn collection into array reference.
  
  =head2 uniq
  
    my $new = $collection->uniq;
    my $new = $collection->uniq(sub {...});
    my $new = $collection->uniq('some_method');
    my $new = $collection->uniq('some_method', @args);
  
  Create a new collection without duplicate elements, using the string
  representation of either the elements or the return value of the
  callback/method to decide uniqueness. Note that C<undef> and empty string are
  treated the same.
  
    # Longer version
    my $new = $collection->uniq(sub { $_->some_method(@args) });
  
    # "foo bar baz"
    c('foo', 'bar', 'bar', 'baz')->uniq->join(' ');
  
    # "[[1, 2], [2, 1]]"
    c([1, 2], [2, 1], [3, 2])->uniq(sub{ $_->[1] })->to_array;
  
  =head2 with_roles
  
    my $new_class = Mojo::Collection->with_roles('Mojo::Collection::Role::One');
    my $new_class = Mojo::Collection->with_roles('+One', '+Two');
    $collection   = $collection->with_roles('+One', '+Two');
  
  Alias for L<Mojo::Base/"with_roles">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_COLLECTION

$fatpacked{"Mojo/Content.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_CONTENT';
  package Mojo::Content;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Compress::Raw::Zlib qw(WANT_GZIP Z_STREAM_END);
  use Mojo::Headers;
  use Scalar::Util 'looks_like_number';
  
  has [qw(auto_decompress auto_relax expect_close relaxed skip_body)];
  has headers           => sub { Mojo::Headers->new };
  has max_buffer_size   => sub { $ENV{MOJO_MAX_BUFFER_SIZE} || 262144 };
  has max_leftover_size => sub { $ENV{MOJO_MAX_LEFTOVER_SIZE} || 262144 };
  
  my $BOUNDARY_RE
    = qr!multipart.*boundary\s*=\s*(?:"([^"]+)"|([\w'(),.:?\-+/]+))!i;
  
  sub body_contains {
    croak 'Method "body_contains" not implemented by subclass';
  }
  
  sub body_size { croak 'Method "body_size" not implemented by subclass' }
  
  sub boundary {
    (shift->headers->content_type // '') =~ $BOUNDARY_RE ? $1 // $2 : undef;
  }
  
  sub charset {
    my $type = shift->headers->content_type // '';
    return $type =~ /charset\s*=\s*"?([^"\s;]+)"?/i ? $1 : undef;
  }
  
  sub clone {
    my $self = shift;
    return undef if $self->is_dynamic;
    return $self->new(headers => $self->headers->clone);
  }
  
  sub generate_body_chunk {
    my ($self, $offset) = @_;
  
    $self->emit(drain => $offset) unless length($self->{body_buffer} //= '');
    my $len = $self->headers->content_length;
    return '' if looks_like_number $len && $len == $offset;
    my $chunk = delete $self->{body_buffer};
    return $self->{eof} ? '' : undef unless length $chunk;
  
    return $chunk;
  }
  
  sub get_body_chunk {
    croak 'Method "get_body_chunk" not implemented by subclass';
  }
  
  sub get_header_chunk { substr shift->_headers->{header_buffer}, shift, 131072 }
  
  sub header_size { length shift->_headers->{header_buffer} }
  
  sub headers_contain { index(shift->_headers->{header_buffer}, shift) >= 0 }
  
  sub is_chunked { !!shift->headers->transfer_encoding }
  
  sub is_compressed { lc(shift->headers->content_encoding // '') eq 'gzip' }
  
  sub is_dynamic { !!$_[0]{dynamic} }
  
  sub is_finished { (shift->{state} // '') eq 'finished' }
  
  sub is_limit_exceeded { !!shift->{limit} }
  
  sub is_multipart {undef}
  
  sub is_parsing_body { (shift->{state} // '') eq 'body' }
  
  sub leftovers { shift->{buffer} }
  
  sub parse {
    my $self = shift;
  
    # Headers
    $self->_parse_until_body(@_);
    return $self if $self->{state} eq 'headers';
  
    # Chunked content
    $self->{real_size} //= 0;
    if ($self->is_chunked && $self->{state} ne 'headers') {
      $self->_parse_chunked;
      $self->{state} = 'finished' if ($self->{chunk_state} // '') eq 'finished';
    }
  
    # Not chunked, pass through to second buffer
    else {
      $self->{real_size} += length $self->{pre_buffer};
      my $limit = $self->is_finished
        && length($self->{buffer}) > $self->max_leftover_size;
      $self->{buffer} .= $self->{pre_buffer} unless $limit;
      $self->{pre_buffer} = '';
    }
  
    # No content
    if ($self->skip_body) {
      $self->{state} = 'finished';
      return $self;
    }
  
    # Relaxed parsing
    my $headers = $self->headers;
    my $len     = $headers->content_length // '';
    if ($self->auto_relax && !length $len) {
      my $connection = lc($headers->connection // '');
      $self->relaxed(1)
        if $connection eq 'close' || (!$connection && $self->expect_close);
    }
  
    # Chunked or relaxed content
    if ($self->is_chunked || $self->relaxed) {
      $self->_decompress($self->{buffer} //= '');
      $self->{size} += length $self->{buffer};
      $self->{buffer} = '';
      return $self;
    }
  
    # Normal content
    $len = 0 unless looks_like_number $len;
    if ((my $need = $len - ($self->{size} ||= 0)) > 0) {
      my $len = length $self->{buffer};
      my $chunk = substr $self->{buffer}, 0, $need > $len ? $len : $need, '';
      $self->_decompress($chunk);
      $self->{size} += length $chunk;
    }
    $self->{state} = 'finished' if $len <= $self->progress;
  
    return $self;
  }
  
  sub parse_body {
    my $self = shift;
    $self->{state} = 'body';
    return $self->parse(@_);
  }
  
  sub progress {
    my $self = shift;
    return 0 unless my $state = $self->{state};
    return 0 unless $state eq 'body' || $state eq 'finished';
    return $self->{raw_size} - ($self->{header_size} || 0);
  }
  
  sub write {
    my ($self, $chunk, $cb) = @_;
  
    $self->{dynamic} = 1;
    $self->{body_buffer} .= $chunk if defined $chunk;
    $self->once(drain => $cb) if $cb;
    $self->{eof} = 1 if defined $chunk && !length $chunk;
  
    return $self;
  }
  
  sub write_chunk {
    my ($self, $chunk, $cb) = @_;
    $self->headers->transfer_encoding('chunked') unless $self->is_chunked;
    $self->write(defined $chunk ? $self->_build_chunk($chunk) : $chunk, $cb);
    $self->{eof} = 1 if defined $chunk && !length $chunk;
    return $self;
  }
  
  sub _build_chunk {
    my ($self, $chunk) = @_;
  
    # End
    return "\x0d\x0a0\x0d\x0a\x0d\x0a" unless length $chunk;
  
    # First chunk has no leading CRLF
    my $crlf = $self->{chunks}++ ? "\x0d\x0a" : '';
    return $crlf . sprintf('%x', length $chunk) . "\x0d\x0a$chunk";
  }
  
  sub _decompress {
    my ($self, $chunk) = @_;
  
    # No compression
    return $self->emit(read => $chunk)
      unless $self->auto_decompress && $self->is_compressed;
  
    # Decompress
    $self->{post_buffer} .= $chunk;
    my $gz = $self->{gz}
      //= Compress::Raw::Zlib::Inflate->new(WindowBits => WANT_GZIP);
    my $status = $gz->inflate(\$self->{post_buffer}, my $out);
    $self->emit(read => $out) if defined $out;
  
    # Replace Content-Encoding with Content-Length
    $self->headers->content_length($gz->total_out)->remove('Content-Encoding')
      if $status == Z_STREAM_END;
  
    # Check buffer size
    @$self{qw(state limit)} = ('finished', 1)
      if length($self->{post_buffer} // '') > $self->max_buffer_size;
  }
  
  sub _headers {
    my $self = shift;
    return $self if defined $self->{header_buffer};
    my $headers = $self->headers->to_string;
    $self->{header_buffer} = $headers ? "$headers\x0d\x0a\x0d\x0a" : "\x0d\x0a";
    return $self;
  }
  
  sub _parse_chunked {
    my $self = shift;
  
    # Trailing headers
    return $self->_parse_chunked_trailing_headers
      if ($self->{chunk_state} // '') eq 'trailing_headers';
  
    while (my $len = length $self->{pre_buffer}) {
  
      # Start new chunk (ignore the chunk extension)
      unless ($self->{chunk_len}) {
        last
          unless $self->{pre_buffer} =~ s/^(?:\x0d?\x0a)?([0-9a-fA-F]+).*\x0a//;
        next if $self->{chunk_len} = hex $1;
  
        # Last chunk
        $self->{chunk_state} = 'trailing_headers';
        last;
      }
  
      # Remove as much as possible from payload
      $len = $self->{chunk_len} if $self->{chunk_len} < $len;
      $self->{buffer} .= substr $self->{pre_buffer}, 0, $len, '';
      $self->{real_size} += $len;
      $self->{chunk_len} -= $len;
    }
  
    # Trailing headers
    $self->_parse_chunked_trailing_headers
      if ($self->{chunk_state} // '') eq 'trailing_headers';
  
    # Check buffer size
    @$self{qw(state limit)} = ('finished', 1)
      if length($self->{pre_buffer} // '') > $self->max_buffer_size;
  }
  
  sub _parse_chunked_trailing_headers {
    my $self = shift;
  
    my $headers = $self->headers->parse(delete $self->{pre_buffer});
    return unless $headers->is_finished;
    $self->{chunk_state} = 'finished';
  
    # Take care of leftover and replace Transfer-Encoding with Content-Length
    $self->{buffer} .= $headers->leftovers;
    $headers->remove('Transfer-Encoding');
    $headers->content_length($self->{real_size}) unless $headers->content_length;
  }
  
  sub _parse_headers {
    my $self = shift;
  
    my $headers = $self->headers->parse(delete $self->{pre_buffer});
    return unless $headers->is_finished;
    $self->{state} = 'body';
  
    # Take care of leftovers
    my $leftovers = $self->{pre_buffer} = $headers->leftovers;
    $self->{header_size} = $self->{raw_size} - length $leftovers;
  }
  
  sub _parse_until_body {
    my ($self, $chunk) = @_;
  
    $self->{raw_size} += length($chunk //= '');
    $self->{pre_buffer} .= $chunk;
    $self->_parse_headers if ($self->{state} ||= 'headers') eq 'headers';
    $self->emit('body') if $self->{state} ne 'headers' && !$self->{body}++;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Content - HTTP content base class
  
  =head1 SYNOPSIS
  
    package Mojo::Content::MyContent;
    use Mojo::Base 'Mojo::Content';
  
    sub body_contains  {...}
    sub body_size      {...}
    sub get_body_chunk {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Content> is an abstract base class for HTTP content containers, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230> and
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>, like
  L<Mojo::Content::MultiPart> and L<Mojo::Content::Single>.
  
  =head1 EVENTS
  
  L<Mojo::Content> inherits all events from L<Mojo::EventEmitter> and can emit
  the following new ones.
  
  =head2 body
  
    $content->on(body => sub {
      my $content = shift;
      ...
    });
  
  Emitted once all headers have been parsed and the body starts.
  
    $content->on(body => sub {
      my $content = shift;
      $content->auto_upgrade(0) if $content->headers->header('X-No-MultiPart');
    });
  
  =head2 drain
  
    $content->on(drain => sub {
      my ($content, $offset) = @_;
      ...
    });
  
  Emitted once all data has been written.
  
    $content->on(drain => sub {
      my $content = shift;
      $content->write_chunk(time);
    });
  
  =head2 read
  
    $content->on(read => sub {
      my ($content, $bytes) = @_;
      ...
    });
  
  Emitted when a new chunk of content arrives.
  
    $content->on(read => sub {
      my ($content, $bytes) = @_;
      say "Streaming: $bytes";
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Content> implements the following attributes.
  
  =head2 auto_decompress
  
    my $bool = $content->auto_decompress;
    $content = $content->auto_decompress($bool);
  
  Decompress content automatically if L</"is_compressed"> is true.
  
  =head2 auto_relax
  
    my $bool = $content->auto_relax;
    $content = $content->auto_relax($bool);
  
  Try to detect when relaxed parsing is necessary.
  
  =head2 expect_close
  
    my $bool = $content->expect_close;
    $content = $content->expect_close($bool);
  
  Expect a response that is terminated with a connection close.
  
  =head2 headers
  
    my $headers = $content->headers;
    $content    = $content->headers(Mojo::Headers->new);
  
  Content headers, defaults to a L<Mojo::Headers> object.
  
  =head2 max_buffer_size
  
    my $size = $content->max_buffer_size;
    $content = $content->max_buffer_size(1024);
  
  Maximum size in bytes of buffer for content parser, defaults to the value of
  the C<MOJO_MAX_BUFFER_SIZE> environment variable or C<262144> (256KiB).
  
  =head2 max_leftover_size
  
    my $size = $content->max_leftover_size;
    $content = $content->max_leftover_size(1024);
  
  Maximum size in bytes of buffer for pipelined HTTP requests, defaults to the
  value of the C<MOJO_MAX_LEFTOVER_SIZE> environment variable or C<262144>
  (256KiB).
  
  =head2 relaxed
  
    my $bool = $content->relaxed;
    $content = $content->relaxed($bool);
  
  Activate relaxed parsing for responses that are terminated with a connection
  close.
  
  =head2 skip_body
  
    my $bool = $content->skip_body;
    $content = $content->skip_body($bool);
  
  Skip body parsing and finish after headers.
  
  =head1 METHODS
  
  L<Mojo::Content> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 body_contains
  
    my $bool = $content->body_contains('foo bar baz');
  
  Check if content contains a specific string. Meant to be overloaded in a
  subclass.
  
  =head2 body_size
  
    my $size = $content->body_size;
  
  Content size in bytes. Meant to be overloaded in a subclass.
  
  =head2 boundary
  
    my $boundary = $content->boundary;
  
  Extract multipart boundary from C<Content-Type> header.
  
  =head2 charset
  
    my $charset = $content->charset;
  
  Extract charset from C<Content-Type> header.
  
  =head2 clone
  
    my $clone = $content->clone;
  
  Return a new L<Mojo::Content> object cloned from this content if possible,
  otherwise return C<undef>.
  
  =head2 generate_body_chunk
  
    my $bytes = $content->generate_body_chunk(0);
  
  Generate dynamic content.
  
  =head2 get_body_chunk
  
    my $bytes = $content->get_body_chunk(0);
  
  Get a chunk of content starting from a specific position. Meant to be
  overloaded in a subclass.
  
  =head2 get_header_chunk
  
    my $bytes = $content->get_header_chunk(13);
  
  Get a chunk of the headers starting from a specific position. Note that this
  method finalizes the content.
  
  =head2 header_size
  
    my $size = $content->header_size;
  
  Size of headers in bytes. Note that this method finalizes the content.
  
  =head2 headers_contain
  
    my $bool = $content->headers_contain('foo bar baz');
  
  Check if headers contain a specific string. Note that this method finalizes the
  content.
  
  =head2 is_chunked
  
    my $bool = $content->is_chunked;
  
  Check if C<Transfer-Encoding> header indicates chunked transfer encoding.
  
  =head2 is_compressed
  
    my $bool = $content->is_compressed;
  
  Check C<Content-Encoding> header for C<gzip> value.
  
  =head2 is_dynamic
  
    my $bool = $content->is_dynamic;
  
  Check if content will be dynamically generated, which prevents L</"clone"> from
  working.
  
  =head2 is_finished
  
    my $bool = $content->is_finished;
  
  Check if parser is finished.
  
  =head2 is_limit_exceeded
  
    my $bool = $content->is_limit_exceeded;
  
  Check if buffer has exceeded L</"max_buffer_size">.
  
  =head2 is_multipart
  
    my $bool = $content->is_multipart;
  
  False, this is not a L<Mojo::Content::MultiPart> object.
  
  =head2 is_parsing_body
  
    my $bool = $content->is_parsing_body;
  
  Check if body parsing started yet.
  
  =head2 leftovers
  
    my $bytes = $content->leftovers;
  
  Get leftover data from content parser.
  
  =head2 parse
  
    $content
      = $content->parse("Content-Length: 12\x0d\x0a\x0d\x0aHello World!");
  
  Parse content chunk.
  
  =head2 parse_body
  
    $content = $content->parse_body('Hi!');
  
  Parse body chunk and skip headers.
  
  =head2 progress
  
    my $size = $content->progress;
  
  Size of content already received from message in bytes.
  
  =head2 write
  
    $content = $content->write;
    $content = $content->write('');
    $content = $content->write($bytes);
    $content = $content->write($bytes => sub {...});
  
  Write dynamic content non-blocking, the optional drain callback will be executed
  once all data has been written. Calling this method without a chunk of data
  will finalize the L</"headers"> and allow for dynamic content to be written
  later. You can write an empty chunk of data at any time to end the stream.
  
    # Make sure previous chunk of data has been written before continuing
    $content->write('He' => sub {
      my $content = shift;
      $content->write('llo!' => sub {
        my $content = shift;
        $content->write('');
      });
    });
  
  =head2 write_chunk
  
    $content = $content->write_chunk;
    $content = $content->write_chunk('');
    $content = $content->write_chunk($bytes);
    $content = $content->write_chunk($bytes => sub {...});
  
  Write dynamic content non-blocking with chunked transfer encoding, the optional
  drain callback will be executed once all data has been written. Calling this
  method without a chunk of data will finalize the L</"headers"> and allow for
  dynamic content to be written later. You can write an empty chunk of data at any
  time to end the stream.
  
    # Make sure previous chunk of data has been written before continuing
    $content->write_chunk('He' => sub {
      my $content = shift;
      $content->write_chunk('llo!' => sub {
        my $content = shift;
        $content->write_chunk('');
      });
    });
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_CONTENT

$fatpacked{"Mojo/Content/MultiPart.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_CONTENT_MULTIPART';
  package Mojo::Content::MultiPart;
  use Mojo::Base 'Mojo::Content';
  
  use Mojo::Util 'b64_encode';
  
  has parts => sub { [] };
  
  sub body_contains {
    my ($self, $chunk) = @_;
    ($_->headers_contain($chunk) or $_->body_contains($chunk)) and return 1
      for @{$self->parts};
    return undef;
  }
  
  sub body_size {
    my $self = shift;
  
    # Check for existing Content-Lenght header
    if (my $len = $self->headers->content_length) { return $len }
  
    # Calculate length of whole body
    my $len = my $boundary_len = length($self->build_boundary) + 6;
    $len += $_->header_size + $_->body_size + $boundary_len for @{$self->parts};
  
    return $len;
  }
  
  sub build_boundary {
    my $self = shift;
  
    # Check for existing boundary
    my $boundary;
    return $boundary if defined($boundary = $self->boundary);
  
    # Generate and check boundary
    my $size = 1;
    do {
      $boundary = b64_encode join('', map chr(rand 256), 1 .. $size++ * 3);
      $boundary =~ s/\W/X/g;
    } while $self->body_contains($boundary);
  
    # Add boundary to Content-Type header
    my $headers = $self->headers;
    ($headers->content_type // '') =~ m!^(.*multipart/[^;]+)(.*)$!;
    my $before = $1 || 'multipart/mixed';
    my $after  = $2 || '';
    $headers->content_type("$before; boundary=$boundary$after");
  
    return $boundary;
  }
  
  sub clone {
    my $self = shift;
    return undef unless my $clone = $self->SUPER::clone();
    return $clone->parts($self->parts);
  }
  
  sub get_body_chunk {
    my ($self, $offset) = @_;
  
    # Body generator
    return $self->generate_body_chunk($offset) if $self->is_dynamic;
  
    # First boundary
    my $boundary     = $self->{boundary} //= $self->build_boundary;
    my $boundary_len = length($boundary) + 6;
    my $len          = $boundary_len - 2;
    return substr "--$boundary\x0d\x0a", $offset if $len > $offset;
  
    # Skip parts that have already been processed
    my $start = 0;
    ($len, $start) = ($self->{last_len}, $self->{last_part} + 1)
      if $self->{offset} && $offset > $self->{offset};
  
    # Prepare content part by part
    my $parts = $self->parts;
    for (my $i = $start; $i < @$parts; $i++) {
      my $part = $parts->[$i];
  
      # Headers
      my $header_len = $part->header_size;
      return $part->get_header_chunk($offset - $len)
        if ($len + $header_len) > $offset;
      $len += $header_len;
  
      # Content
      my $content_len = $part->body_size;
      return $part->get_body_chunk($offset - $len)
        if ($len + $content_len) > $offset;
      $len += $content_len;
  
      # Boundary
      if ($#$parts == $i) {
        $boundary .= '--';
        $boundary_len += 2;
      }
      return substr "\x0d\x0a--$boundary\x0d\x0a", $offset - $len
        if ($len + $boundary_len) > $offset;
      $len += $boundary_len;
  
      @{$self}{qw(last_len last_part offset)} = ($len, $i, $offset);
    }
  }
  
  sub is_multipart {1}
  
  sub new {
    my $self = shift->SUPER::new(@_);
    $self->on(read => \&_read);
    return $self;
  }
  
  sub _parse_multipart_body {
    my ($self, $boundary) = @_;
  
    # Whole part in buffer
    my $pos = index $self->{multipart}, "\x0d\x0a--$boundary";
    if ($pos < 0) {
      my $len = length($self->{multipart}) - (length($boundary) + 8);
      return undef unless $len > 0;
  
      # Store chunk
      my $chunk = substr $self->{multipart}, 0, $len, '';
      $self->parts->[-1] = $self->parts->[-1]->parse($chunk);
      return undef;
    }
  
    # Store chunk
    my $chunk = substr $self->{multipart}, 0, $pos, '';
    $self->parts->[-1] = $self->parts->[-1]->parse($chunk);
    return !!($self->{multi_state} = 'multipart_boundary');
  }
  
  sub _parse_multipart_boundary {
    my ($self, $boundary) = @_;
  
    # Boundary begins
    if ((index $self->{multipart}, "\x0d\x0a--$boundary\x0d\x0a") == 0) {
      substr $self->{multipart}, 0, length($boundary) + 6, '';
  
      # New part
      my $part = Mojo::Content::Single->new(relaxed => 1);
      $self->emit(part => $part);
      push @{$self->parts}, $part;
      return !!($self->{multi_state} = 'multipart_body');
    }
  
    # Boundary ends
    my $end = "\x0d\x0a--$boundary--";
    if ((index $self->{multipart}, $end) == 0) {
      substr $self->{multipart}, 0, length $end, '';
      $self->{multi_state} = 'finished';
    }
  
    return undef;
  }
  
  sub _parse_multipart_preamble {
    my ($self, $boundary) = @_;
  
    # No boundary yet
    return undef if (my $pos = index $self->{multipart}, "--$boundary") < 0;
  
    # Replace preamble with carriage return and line feed
    substr $self->{multipart}, 0, $pos, "\x0d\x0a";
  
    # Parse boundary
    return !!($self->{multi_state} = 'multipart_boundary');
  }
  
  sub _read {
    my ($self, $chunk) = @_;
  
    $self->{multipart} .= $chunk;
    my $boundary = $self->boundary;
    until (($self->{multi_state} //= 'multipart_preamble') eq 'finished') {
  
      # Preamble
      if ($self->{multi_state} eq 'multipart_preamble') {
        last unless $self->_parse_multipart_preamble($boundary);
      }
  
      # Boundary
      elsif ($self->{multi_state} eq 'multipart_boundary') {
        last unless $self->_parse_multipart_boundary($boundary);
      }
  
      # Body
      elsif ($self->{multi_state} eq 'multipart_body') {
        last unless $self->_parse_multipart_body($boundary);
      }
    }
  
    # Check buffer size
    @$self{qw(state limit)} = ('finished', 1)
      if length($self->{multipart} // '') > $self->max_buffer_size;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Content::MultiPart - HTTP multipart content
  
  =head1 SYNOPSIS
  
    use Mojo::Content::MultiPart;
  
    my $multi = Mojo::Content::MultiPart->new;
    $multi->parse('Content-Type: multipart/mixed; boundary=---foobar');
    my $single = $multi->parts->[4];
  
  =head1 DESCRIPTION
  
  L<Mojo::Content::MultiPart> is a container for HTTP multipart content, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230>,
  L<RFC 7231|http://tools.ietf.org/html/rfc7231> and
  L<RFC 2388|http://tools.ietf.org/html/rfc2388>.
  
  =head1 EVENTS
  
  L<Mojo::Content::Multipart> inherits all events from L<Mojo::Content> and can
  emit the following new ones.
  
  =head2 part
  
    $multi->on(part => sub {
      my ($multi, $single) = @_;
      ...
    });
  
  Emitted when a new L<Mojo::Content::Single> part starts.
  
    $multi->on(part => sub {
      my ($multi, $single) = @_;
      return unless $single->headers->content_disposition =~ /name="([^"]+)"/;
      say "Field: $1";
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Content::MultiPart> inherits all attributes from L<Mojo::Content> and
  implements the following new ones.
  
  =head2 parts
  
    my $parts = $multi->parts;
    $multi    = $multi->parts([Mojo::Content::Single->new]);
  
  Content parts embedded in this multipart content, usually
  L<Mojo::Content::Single> objects.
  
  =head1 METHODS
  
  L<Mojo::Content::MultiPart> inherits all methods from L<Mojo::Content> and
  implements the following new ones.
  
  =head2 body_contains
  
    my $bool = $multi->body_contains('foobarbaz');
  
  Check if content parts contain a specific string.
  
  =head2 body_size
  
    my $size = $multi->body_size;
  
  Content size in bytes.
  
  =head2 build_boundary
  
    my $boundary = $multi->build_boundary;
  
  Generate a suitable boundary for content and add it to C<Content-Type> header.
  
  =head2 clone
  
    my $clone = $multi->clone;
  
  Return a new L<Mojo::Content::MultiPart> object cloned from this content if
  possible, otherwise return C<undef>.
  
  =head2 get_body_chunk
  
    my $bytes = $multi->get_body_chunk(0);
  
  Get a chunk of content starting from a specific position. Note that it might
  not be possible to get the same chunk twice if content was generated
  dynamically.
  
  =head2 is_multipart
  
    my $bool = $multi->is_multipart;
  
  True, this is a L<Mojo::Content::MultiPart> object.
  
  =head2 new
  
    my $multi = Mojo::Content::MultiPart->new;
    my $multi
      = Mojo::Content::MultiPart->new(parts => [Mojo::Content::Single->new]);
    my $multi
      = Mojo::Content::MultiPart->new({parts => [Mojo::Content::Single->new]});
  
  Construct a new L<Mojo::Content::MultiPart> object and subscribe to L</"read">
  event with default content parser.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_CONTENT_MULTIPART

$fatpacked{"Mojo/Content/Single.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_CONTENT_SINGLE';
  package Mojo::Content::Single;
  use Mojo::Base 'Mojo::Content';
  
  use Mojo::Asset::Memory;
  use Mojo::Content::MultiPart;
  
  has asset => sub { Mojo::Asset::Memory->new(auto_upgrade => 1) };
  has auto_upgrade => 1;
  
  sub body_contains { shift->asset->contains(shift) >= 0 }
  
  sub body_size {
    my $self = shift;
    return ($self->headers->content_length || 0) if $self->is_dynamic;
    return $self->{body_size} //= $self->asset->size;
  }
  
  sub clone {
    my $self = shift;
    return undef unless my $clone = $self->SUPER::clone();
    return $clone->asset($self->asset);
  }
  
  sub get_body_chunk {
    my ($self, $offset) = @_;
    return $self->generate_body_chunk($offset) if $self->is_dynamic;
    return $self->asset->get_chunk($offset);
  }
  
  sub new {
    my $self = shift->SUPER::new(@_);
    $self->{read}
      = $self->on(read => sub { $_[0]->asset($_[0]->asset->add_chunk($_[1])) });
    return $self;
  }
  
  sub parse {
    my $self = shift;
  
    # Parse headers
    $self->_parse_until_body(@_);
  
    # Parse body
    return $self->SUPER::parse
      unless $self->auto_upgrade && defined $self->boundary;
  
    # Content needs to be upgraded to multipart
    $self->unsubscribe(read => $self->{read});
    my $multi = Mojo::Content::MultiPart->new(%$self);
    $self->emit(upgrade => $multi);
    return $multi->parse;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Content::Single - HTTP content
  
  =head1 SYNOPSIS
  
    use Mojo::Content::Single;
  
    my $single = Mojo::Content::Single->new;
    $single->parse("Content-Length: 12\x0d\x0a\x0d\x0aHello World!");
    say $single->headers->content_length;
  
  =head1 DESCRIPTION
  
  L<Mojo::Content::Single> is a container for HTTP content, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230> and
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>.
  
  =head1 EVENTS
  
  L<Mojo::Content::Single> inherits all events from L<Mojo::Content> and can emit
  the following new ones.
  
  =head2 upgrade
  
    $single->on(upgrade => sub {
      my ($single, $multi) = @_;
      ...
    });
  
  Emitted when content gets upgraded to a L<Mojo::Content::MultiPart> object.
  
    $single->on(upgrade => sub {
      my ($single, $multi) = @_;
      return unless $multi->headers->content_type =~ /multipart\/([^;]+)/i;
      say "Multipart: $1";
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Content::Single> inherits all attributes from L<Mojo::Content> and
  implements the following new ones.
  
  =head2 asset
  
    my $asset = $single->asset;
    $single   = $single->asset(Mojo::Asset::Memory->new);
  
  The actual content, defaults to a L<Mojo::Asset::Memory> object with
  L<Mojo::Asset::Memory/"auto_upgrade"> enabled.
  
  =head2 auto_upgrade
  
    my $bool = $single->auto_upgrade;
    $single  = $single->auto_upgrade($bool);
  
  Try to detect multipart content and automatically upgrade to a
  L<Mojo::Content::MultiPart> object, defaults to a true value.
  
  =head1 METHODS
  
  L<Mojo::Content::Single> inherits all methods from L<Mojo::Content> and
  implements the following new ones.
  
  =head2 body_contains
  
    my $bool = $single->body_contains('1234567');
  
  Check if content contains a specific string.
  
  =head2 body_size
  
    my $size = $single->body_size;
  
  Content size in bytes.
  
  =head2 clone
  
    my $clone = $single->clone;
  
  Return a new L<Mojo::Content::Single> object cloned from this content if
  possible, otherwise return C<undef>.
  
  =head2 get_body_chunk
  
    my $bytes = $single->get_body_chunk(0);
  
  Get a chunk of content starting from a specific position. Note that it might
  not be possible to get the same chunk twice if content was generated
  dynamically.
  
  =head2 new
  
    my $single = Mojo::Content::Single->new;
    my $single = Mojo::Content::Single->new(asset => Mojo::Asset::File->new);
    my $single = Mojo::Content::Single->new({asset => Mojo::Asset::File->new});
  
  Construct a new L<Mojo::Content::Single> object and subscribe to L</"read">
  event with default content parser.
  
  =head2 parse
  
    $single = $single->parse("Content-Length: 12\x0d\x0a\x0d\x0aHello World!");
    my $multi
      = $single->parse("Content-Type: multipart/form-data\x0d\x0a\x0d\x0a");
  
  Parse content chunk and upgrade to L<Mojo::Content::MultiPart> object if
  necessary.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_CONTENT_SINGLE

$fatpacked{"Mojo/Cookie.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_COOKIE';
  package Mojo::Cookie;
  use Mojo::Base -base;
  use overload bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;
  
  use Carp 'croak';
  
  has [qw(name value)];
  
  sub parse     { croak 'Method "parse" not implemented by subclass' }
  sub to_string { croak 'Method "to_string" not implemented by subclass' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Cookie - HTTP cookie base class
  
  =head1 SYNOPSIS
  
    package Mojo::Cookie::MyCookie;
    use Mojo::Base 'Mojo::Cookie';
  
    sub parse     {...}
    sub to_string {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Cookie> is an abstract base class for HTTP cookie containers, based on
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>, like L<Mojo::Cookie::Request>
  and L<Mojo::Cookie::Response>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Cookie> implements the following attributes.
  
  =head2 name
  
    my $name = $cookie->name;
    $cookie  = $cookie->name('foo');
  
  Cookie name.
  
  =head2 value
  
    my $value = $cookie->value;
    $cookie   = $cookie->value('/test');
  
  Cookie value.
  
  =head1 METHODS
  
  L<Mojo::Cookie> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 parse
  
    my $cookies = $cookie->parse($str);
  
  Parse cookies. Meant to be overloaded in a subclass.
  
  =head2 to_string
  
    my $str = $cookie->to_string;
  
  Render cookie. Meant to be overloaded in a subclass.
  
  =head1 OPERATORS
  
  L<Mojo::Cookie> overloads the following operators.
  
  =head2 bool
  
    my $bool = !!$cookie;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$cookie";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_COOKIE

$fatpacked{"Mojo/Cookie/Request.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_COOKIE_REQUEST';
  package Mojo::Cookie::Request;
  use Mojo::Base 'Mojo::Cookie';
  
  use Mojo::Util qw(quote split_header);
  
  sub parse {
    my ($self, $str) = @_;
  
    my @cookies;
    my @pairs = map {@$_} @{split_header $str // ''};
    while (my ($name, $value) = splice @pairs, 0, 2) {
      next if $name =~ /^\$/;
      push @cookies, $self->new(name => $name, value => $value // '');
    }
  
    return \@cookies;
  }
  
  sub to_string {
    my $self = shift;
    return '' unless length(my $name = $self->name // '');
    my $value = $self->value // '';
    return join '=', $name, $value =~ /[,;" ]/ ? quote $value : $value;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Cookie::Request - HTTP request cookie
  
  =head1 SYNOPSIS
  
    use Mojo::Cookie::Request;
  
    my $cookie = Mojo::Cookie::Request->new;
    $cookie->name('foo');
    $cookie->value('bar');
    say "$cookie";
  
  =head1 DESCRIPTION
  
  L<Mojo::Cookie::Request> is a container for HTTP request cookies, based on
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Cookie::Request> inherits all attributes from L<Mojo::Cookie>.
  
  =head1 METHODS
  
  L<Mojo::Cookie::Request> inherits all methods from L<Mojo::Cookie> and
  implements the following new ones.
  
  =head2 parse
  
    my $cookies = Mojo::Cookie::Request->parse('f=b; g=a');
  
  Parse cookies.
  
  =head2 to_string
  
    my $str = $cookie->to_string;
  
  Render cookie.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_COOKIE_REQUEST

$fatpacked{"Mojo/Cookie/Response.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_COOKIE_RESPONSE';
  package Mojo::Cookie::Response;
  use Mojo::Base 'Mojo::Cookie';
  
  use Mojo::Date;
  use Mojo::Util qw(quote split_cookie_header);
  
  has [qw(domain expires host_only httponly max_age path secure)];
  
  my %ATTRS = map { $_ => 1 } qw(domain expires httponly max-age path secure);
  
  sub parse {
    my ($self, $str) = @_;
  
    my @cookies;
    my $tree = split_cookie_header $str // '';
    while (my $pairs = shift @$tree) {
      my ($name, $value) = splice @$pairs, 0, 2;
      push @cookies, $self->new(name => $name, value => $value // '');
  
      while (my ($name, $value) = splice @$pairs, 0, 2) {
        next unless $ATTRS{my $attr = lc $name};
        $value =~ s/^\.// if $attr eq 'domain' && defined $value;
        $value = Mojo::Date->new($value // '')->epoch if $attr eq 'expires';
        $value = 1 if $attr eq 'secure' || $attr eq 'httponly';
        $cookies[-1]{$attr eq 'max-age' ? 'max_age' : $attr} = $value;
      }
    }
  
    return \@cookies;
  }
  
  sub to_string {
    my $self = shift;
  
    # Name and value
    return '' unless length(my $name = $self->name // '');
    my $value = $self->value // '';
    my $cookie = join '=', $name, $value =~ /[,;" ]/ ? quote $value : $value;
  
    # "expires"
    my $expires = $self->expires;
    $cookie .= '; expires=' . Mojo::Date->new($expires) if defined $expires;
  
    # "domain"
    if (my $domain = $self->domain) { $cookie .= "; domain=$domain" }
  
    # "path"
    if (my $path = $self->path) { $cookie .= "; path=$path" }
  
    # "secure"
    $cookie .= "; secure" if $self->secure;
  
    # "HttpOnly"
    $cookie .= "; HttpOnly" if $self->httponly;
  
    # "Max-Age"
    if (defined(my $max = $self->max_age)) { $cookie .= "; Max-Age=$max" }
  
    return $cookie;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Cookie::Response - HTTP response cookie
  
  =head1 SYNOPSIS
  
    use Mojo::Cookie::Response;
  
    my $cookie = Mojo::Cookie::Response->new;
    $cookie->name('foo');
    $cookie->value('bar');
    say "$cookie";
  
  =head1 DESCRIPTION
  
  L<Mojo::Cookie::Response> is a container for HTTP response cookies, based on
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Cookie::Response> inherits all attributes from L<Mojo::Cookie> and
  implements the following new ones.
  
  =head2 domain
  
    my $domain = $cookie->domain;
    $cookie    = $cookie->domain('localhost');
  
  Cookie domain.
  
  =head2 expires
  
    my $expires = $cookie->expires;
    $cookie     = $cookie->expires(time + 60);
  
  Expiration for cookie.
  
  =head2 host_only
  
    my $bool = $cookie->host_only;
    $cookie  = $cookie->host_only($bool);
  
  Host-only flag, indicating that the canonicalized request-host is identical to
  the cookie's L</"domain">.
  
  =head2 httponly
  
    my $bool = $cookie->httponly;
    $cookie  = $cookie->httponly($bool);
  
  HttpOnly flag, which can prevent client-side scripts from accessing this
  cookie.
  
  =head2 max_age
  
    my $max_age = $cookie->max_age;
    $cookie     = $cookie->max_age(60);
  
  Max age for cookie.
  
  =head2 path
  
    my $path = $cookie->path;
    $cookie  = $cookie->path('/test');
  
  Cookie path.
  
  =head2 secure
  
    my $bool = $cookie->secure;
    $cookie  = $cookie->secure($bool);
  
  Secure flag, which instructs browsers to only send this cookie over HTTPS
  connections.
  
  =head1 METHODS
  
  L<Mojo::Cookie::Response> inherits all methods from L<Mojo::Cookie> and
  implements the following new ones.
  
  =head2 parse
  
    my $cookies = Mojo::Cookie::Response->parse('f=b; path=/');
  
  Parse cookies.
  
  =head2 to_string
  
    my $str = $cookie->to_string;
  
  Render cookie.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_COOKIE_RESPONSE

$fatpacked{"Mojo/DOM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_DOM';
  package Mojo::DOM;
  use Mojo::Base -strict;
  use overload
    '@{}'    => sub { shift->child_nodes },
    '%{}'    => sub { shift->attr },
    bool     => sub {1},
    '""'     => sub { shift->to_string },
    fallback => 1;
  
  # "Fry: This snow is beautiful. I'm glad global warming never happened.
  #  Leela: Actually, it did. But thank God nuclear winter canceled it out."
  use Mojo::Collection;
  use Mojo::DOM::CSS;
  use Mojo::DOM::HTML;
  use Scalar::Util qw(blessed weaken);
  use Storable 'dclone';
  
  sub all_text { _text(_nodes(shift->tree), 1) }
  
  sub ancestors { _select($_[0]->_collect([_ancestors($_[0]->tree)]), $_[1]) }
  
  sub append { shift->_add(1, @_) }
  sub append_content { shift->_content(1, 0, @_) }
  
  sub at {
    my $self = shift;
    return undef unless my $result = $self->_css->select_one(@_);
    return $self->_build($result, $self->xml);
  }
  
  sub attr {
    my $self = shift;
  
    # Hash
    my $tree = $self->tree;
    my $attrs = $tree->[0] ne 'tag' ? {} : $tree->[2];
    return $attrs unless @_;
  
    # Get
    return $attrs->{$_[0]} unless @_ > 1 || ref $_[0];
  
    # Set
    my $values = ref $_[0] ? $_[0] : {@_};
    @$attrs{keys %$values} = values %$values;
  
    return $self;
  }
  
  sub child_nodes { $_[0]->_collect(_nodes($_[0]->tree)) }
  
  sub children { _select($_[0]->_collect(_nodes($_[0]->tree, 1)), $_[1]) }
  
  sub content {
    my $self = shift;
  
    my $type = $self->type;
    if ($type eq 'root' || $type eq 'tag') {
      return $self->_content(0, 1, @_) if @_;
      my $html = Mojo::DOM::HTML->new(xml => $self->xml);
      return join '', map { $html->tree($_)->render } @{_nodes($self->tree)};
    }
  
    return $self->tree->[1] unless @_;
    $self->tree->[1] = shift;
    return $self;
  }
  
  sub descendant_nodes { $_[0]->_collect(_all(_nodes($_[0]->tree))) }
  
  sub find {
    my $self = shift;
    return $self->_collect($self->_css->select(@_));
  }
  
  sub following { _select($_[0]->_collect(_siblings($_[0]->tree, 1, 1)), $_[1]) }
  sub following_nodes { $_[0]->_collect(_siblings($_[0]->tree, 0, 1)) }
  
  sub matches { shift->_css->matches(@_) }
  
  sub namespace {
    my $self = shift;
  
    return undef if (my $tree = $self->tree)->[0] ne 'tag';
  
    # Extract namespace prefix and search parents
    my $ns = $tree->[1] =~ /^(.*?):/ ? "xmlns:$1" : undef;
    for my $node ($tree, _ancestors($tree)) {
  
      # Namespace for prefix
      my $attrs = $node->[2];
      if ($ns) { $_ eq $ns and return $attrs->{$_} for keys %$attrs }
  
      # Namespace attribute
      elsif (defined $attrs->{xmlns}) { return $attrs->{xmlns} }
    }
  
    return undef;
  }
  
  sub new {
    my $class = shift;
    my $self = bless \Mojo::DOM::HTML->new, ref $class || $class;
    return @_ ? $self->parse(@_) : $self;
  }
  
  sub new_tag {
    my $self = shift;
    my $new  = $self->new;
    $$new->tag(@_);
    $$new->xml($$self->xml) if ref $self;
    return $new;
  }
  
  sub next      { $_[0]->_maybe(_siblings($_[0]->tree, 1, 1, 0)) }
  sub next_node { $_[0]->_maybe(_siblings($_[0]->tree, 0, 1, 0)) }
  
  sub parent {
    my $self = shift;
    return undef if (my $tree = $self->tree)->[0] eq 'root';
    return $self->_build(_parent($tree), $self->xml);
  }
  
  sub parse { ${$_[0]}->parse($_[1]) and return $_[0] }
  
  sub preceding { _select($_[0]->_collect(_siblings($_[0]->tree, 1, 0)), $_[1]) }
  sub preceding_nodes { $_[0]->_collect(_siblings($_[0]->tree, 0)) }
  
  sub prepend { shift->_add(0, @_) }
  sub prepend_content { shift->_content(0, 0, @_) }
  
  sub previous      { $_[0]->_maybe(_siblings($_[0]->tree, 1, 0, -1)) }
  sub previous_node { $_[0]->_maybe(_siblings($_[0]->tree, 0, 0, -1)) }
  
  sub remove { shift->replace('') }
  
  sub replace {
    my ($self, $new) = @_;
    return $self->parse($new) if (my $tree = $self->tree)->[0] eq 'root';
    return $self->_replace(_parent($tree), $tree, _nodes($self->_parse($new)));
  }
  
  sub root {
    my $self = shift;
    return $self unless my $tree = _ancestors($self->tree, 1);
    return $self->_build($tree, $self->xml);
  }
  
  sub selector {
    return undef unless (my $tree = shift->tree)->[0] eq 'tag';
    return join ' > ',
      reverse map { $_->[1] . ':nth-child(' . (@{_siblings($_, 1)} + 1) . ')' }
      $tree, _ancestors($tree);
  }
  
  sub strip {
    my $self = shift;
    return $self if (my $tree = $self->tree)->[0] ne 'tag';
    return $self->_replace($tree->[3], $tree, _nodes($tree));
  }
  
  sub tag {
    my ($self, $tag) = @_;
    return undef if (my $tree = $self->tree)->[0] ne 'tag';
    return $tree->[1] unless $tag;
    $tree->[1] = $tag;
    return $self;
  }
  
  sub tap { shift->Mojo::Base::tap(@_) }
  
  sub text { _text(_nodes(shift->tree), 0) }
  
  sub to_string { ${shift()}->render }
  
  sub tree { @_ > 1 ? (${$_[0]}->tree($_[1]) and return $_[0]) : ${$_[0]}->tree }
  
  sub type { shift->tree->[0] }
  
  sub val {
    my $self = shift;
  
    # "option"
    return $self->{value} // $self->text if (my $tag = $self->tag) eq 'option';
  
    # "input" ("type=checkbox" and "type=radio")
    my $type = $self->{type} // '';
    return $self->{value} // 'on'
      if $tag eq 'input' && ($type eq 'radio' || $type eq 'checkbox');
  
    # "textarea", "input" or "button"
    return $tag eq 'textarea' ? $self->text : $self->{value} if $tag ne 'select';
  
    # "select"
    my $v = $self->find('option:checked:not([disabled])')
      ->grep(sub { !$_->ancestors('optgroup[disabled]')->size })->map('val');
    return exists $self->{multiple} ? $v->size ? $v->to_array : undef : $v->last;
  }
  
  sub with_roles { shift->Mojo::Base::with_roles(@_) }
  
  sub wrap         { shift->_wrap(0, @_) }
  sub wrap_content { shift->_wrap(1, @_) }
  
  sub xml { @_ > 1 ? (${$_[0]}->xml($_[1]) and return $_[0]) : ${$_[0]}->xml }
  
  sub _add {
    my ($self, $offset, $new) = @_;
  
    return $self if (my $tree = $self->tree)->[0] eq 'root';
  
    my $parent = _parent($tree);
    splice @$parent, _offset($parent, $tree) + $offset, 0,
      @{_link($parent, _nodes($self->_parse($new)))};
  
    return $self;
  }
  
  sub _all {
    my $nodes = shift;
    @$nodes = map { $_->[0] eq 'tag' ? ($_, @{_all(_nodes($_))}) : ($_) } @$nodes;
    return $nodes;
  }
  
  sub _ancestors {
    my ($tree, $root) = @_;
  
    return () unless $tree = _parent($tree);
    my @ancestors;
    do { push @ancestors, $tree }
      while ($tree->[0] eq 'tag') && ($tree = $tree->[3]);
    return $root ? $ancestors[-1] : @ancestors[0 .. $#ancestors - 1];
  }
  
  sub _build { shift->new->tree(shift)->xml(shift) }
  
  sub _collect {
    my ($self, $nodes) = (shift, shift // []);
    my $xml = $self->xml;
    return Mojo::Collection->new(map { $self->_build($_, $xml) } @$nodes);
  }
  
  sub _content {
    my ($self, $start, $offset, $new) = @_;
  
    my $tree = $self->tree;
    unless ($tree->[0] eq 'root' || $tree->[0] eq 'tag') {
      my $old = $self->content;
      return $self->content($start ? $old . $new : $new . $old);
    }
  
    $start  = $start  ? ($#$tree + 1) : _start($tree);
    $offset = $offset ? $#$tree       : 0;
    splice @$tree, $start, $offset, @{_link($tree, _nodes($self->_parse($new)))};
  
    return $self;
  }
  
  sub _css { Mojo::DOM::CSS->new(tree => shift->tree) }
  
  sub _fragment { _link(my $r = ['root', @_], [@_]); $r }
  
  sub _link {
    my ($parent, $children) = @_;
  
    # Link parent to children
    for my $node (@$children) {
      my $offset = $node->[0] eq 'tag' ? 3 : 2;
      $node->[$offset] = $parent;
      weaken $node->[$offset];
    }
  
    return $children;
  }
  
  sub _maybe { $_[1] ? $_[0]->_build($_[1], $_[0]->xml) : undef }
  
  sub _nodes {
    return () unless my $tree = shift;
    my @nodes = @$tree[_start($tree) .. $#$tree];
    return shift() ? [grep { $_->[0] eq 'tag' } @nodes] : \@nodes;
  }
  
  sub _offset {
    my ($parent, $child) = @_;
    my $i = _start($parent);
    $_ eq $child ? last : $i++ for @$parent[$i .. $#$parent];
    return $i;
  }
  
  sub _parent { $_[0]->[$_[0][0] eq 'tag' ? 3 : 2] }
  
  sub _parse {
    my ($self, $input) = @_;
    return Mojo::DOM::HTML->new(xml => $self->xml)->parse($input)->tree
      unless blessed $input && $input->isa('Mojo::DOM');
    my $tree = dclone $input->tree;
    return $tree->[0] eq 'root' ? $tree : _fragment($tree);
  }
  
  sub _replace {
    my ($self, $parent, $child, $nodes) = @_;
    splice @$parent, _offset($parent, $child), 1, @{_link($parent, $nodes)};
    return $self->parent;
  }
  
  sub _select { $_[1] ? $_[0]->grep(matches => $_[1]) : $_[0] }
  
  sub _siblings {
    my ($tree, $tags, $tail, $i) = @_;
  
    return defined $i ? undef : [] if $tree->[0] eq 'root';
  
    my $nodes = _nodes(_parent($tree));
    my $match = -1;
    defined($match++) and $_ eq $tree and last for @$nodes;
  
    if ($tail) { splice @$nodes, 0, $match + 1 }
    else       { splice @$nodes, $match, ($#$nodes + 1) - $match }
  
    @$nodes = grep { $_->[0] eq 'tag' } @$nodes if $tags;
  
    return defined $i ? $i == -1 && !@$nodes ? undef : $nodes->[$i] : $nodes;
  }
  
  sub _start { $_[0][0] eq 'root' ? 1 : 4 }
  
  sub _text {
    my ($nodes, $all) = @_;
  
    my $text = '';
    while (my $node = shift @$nodes) {
      my $type = $node->[0];
  
      # Text
      if ($type eq 'text' || $type eq 'cdata' || $type eq 'raw') {
        $text .= $node->[1];
      }
  
      # Nested tag
      elsif ($type eq 'tag' && $all) { unshift @$nodes, @{_nodes($node)} }
    }
  
    return $text;
  }
  
  sub _wrap {
    my ($self, $content, $new) = @_;
  
    return $self if (my $tree = $self->tree)->[0] eq 'root' && !$content;
    return $self if $tree->[0] ne 'root' && $tree->[0] ne 'tag' && $content;
  
    # Find innermost tag
    my $current;
    my $first = $new = $self->_parse($new);
    $current = $first while $first = _nodes($first, 1)->[0];
    return $self unless $current;
  
    # Wrap content
    if ($content) {
      push @$current, @{_link($current, _nodes($tree))};
      splice @$tree, _start($tree), $#$tree, @{_link($tree, _nodes($new))};
      return $self;
    }
  
    # Wrap element
    $self->_replace(_parent($tree), $tree, _nodes($new));
    push @$current, @{_link($current, [$tree])};
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::DOM - Minimalistic HTML/XML DOM parser with CSS selectors
  
  =head1 SYNOPSIS
  
    use Mojo::DOM;
  
    # Parse
    my $dom = Mojo::DOM->new('<div><p id="a">Test</p><p id="b">123</p></div>');
  
    # Find
    say $dom->at('#b')->text;
    say $dom->find('p')->map('text')->join("\n");
    say $dom->find('[id]')->map(attr => 'id')->join("\n");
  
    # Iterate
    $dom->find('p[id]')->reverse->each(sub { say $_->{id} });
  
    # Loop
    for my $e ($dom->find('p[id]')->each) {
      say $e->{id}, ':', $e->text;
    }
  
    # Modify
    $dom->find('div p')->last->append('<p id="c">456</p>');
    $dom->at('#c')->prepend($dom->new_tag('p', id => 'd', '789'));
    $dom->find(':not(p)')->map('strip');
  
    # Render
    say "$dom";
  
  =head1 DESCRIPTION
  
  L<Mojo::DOM> is a minimalistic and relaxed HTML/XML DOM parser with CSS
  selector support. It will even try to interpret broken HTML and XML, so you
  should not use it for validation.
  
  =head1 NODES AND ELEMENTS
  
  When we parse an HTML/XML fragment, it gets turned into a tree of nodes.
  
    <!DOCTYPE html>
    <html>
      <head><title>Hello</title></head>
      <body>World!</body>
    </html>
  
  There are currently eight different kinds of nodes, C<cdata>, C<comment>,
  C<doctype>, C<pi>, C<raw>, C<root>, C<tag> and C<text>. Elements are nodes of
  the type C<tag>.
  
    root
    |- doctype (html)
    +- tag (html)
       |- tag (head)
       |  +- tag (title)
       |     +- raw (Hello)
       +- tag (body)
          +- text (World!)
  
  While all node types are represented as L<Mojo::DOM> objects, some methods like
  L</"attr"> and L</"namespace"> only apply to elements.
  
  =head1 CASE-SENSITIVITY
  
  L<Mojo::DOM> defaults to HTML semantics, that means all tags and attribute
  names are lowercased and selectors need to be lowercase as well.
  
    # HTML semantics
    my $dom = Mojo::DOM->new('<P ID="greeting">Hi!</P>');
    say $dom->at('p[id]')->text;
  
  If an XML declaration is found, the parser will automatically switch into XML
  mode and everything becomes case-sensitive.
  
    # XML semantics
    my $dom = Mojo::DOM->new('<?xml version="1.0"?><P ID="greeting">Hi!</P>');
    say $dom->at('P[ID]')->text;
  
  HTML or XML semantics can also be forced with the L</"xml"> method.
  
    # Force HTML semantics
    my $dom = Mojo::DOM->new->xml(0)->parse('<P ID="greeting">Hi!</P>');
    say $dom->at('p[id]')->text;
  
    # Force XML semantics
    my $dom = Mojo::DOM->new->xml(1)->parse('<P ID="greeting">Hi!</P>');
    say $dom->at('P[ID]')->text;
  
  =head1 METHODS
  
  L<Mojo::DOM> implements the following methods.
  
  =head2 all_text
  
    my $text = $dom->all_text;
  
  Extract text content from all descendant nodes of this element.
  
    # "foo\nbarbaz\n"
    $dom->parse("<div>foo\n<p>bar</p>baz\n</div>")->at('div')->all_text;
  
  =head2 ancestors
  
    my $collection = $dom->ancestors;
    my $collection = $dom->ancestors('div ~ p');
  
  Find all ancestor elements of this node matching the CSS selector and return a
  L<Mojo::Collection> object containing these elements as L<Mojo::DOM> objects.
  All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # List tag names of ancestor elements
    say $dom->ancestors->map('tag')->join("\n");
  
  =head2 append
  
    $dom = $dom->append('<p>I  Mojolicious!</p>');
    $dom = $dom->append(Mojo::DOM->new);
  
  Append HTML/XML fragment to this node (for all node types other than C<root>).
  
    # "<div><h1>Test</h1><h2>123</h2></div>"
    $dom->parse('<div><h1>Test</h1></div>')
      ->at('h1')->append('<h2>123</h2>')->root;
  
    # "<p>Test 123</p>"
    $dom->parse('<p>Test</p>')->at('p')
      ->child_nodes->first->append(' 123')->root;
  
  =head2 append_content
  
    $dom = $dom->append_content('<p>I  Mojolicious!</p>');
    $dom = $dom->append_content(Mojo::DOM->new);
  
  Append HTML/XML fragment (for C<root> and C<tag> nodes) or raw content to this
  node's content.
  
    # "<div><h1>Test123</h1></div>"
    $dom->parse('<div><h1>Test</h1></div>')
      ->at('h1')->append_content('123')->root;
  
    # "<!-- Test 123 --><br>"
    $dom->parse('<!-- Test --><br>')
      ->child_nodes->first->append_content('123 ')->root;
  
    # "<p>Test<i>123</i></p>"
    $dom->parse('<p>Test</p>')->at('p')->append_content('<i>123</i>')->root;
  
  =head2 at
  
    my $result = $dom->at('div ~ p');
    my $result = $dom->at('svg|line', svg => 'http://www.w3.org/2000/svg');
  
  Find first descendant element of this element matching the CSS selector and
  return it as a L<Mojo::DOM> object, or C<undef> if none could be found. All
  selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # Find first element with "svg" namespace definition
    my $namespace = $dom->at('[xmlns\:svg]')->{'xmlns:svg'};
  
  Trailing key/value pairs can be used to declare xml namespace aliases.
  
    # "<rect />"
    $dom->parse('<svg xmlns="http://www.w3.org/2000/svg"><rect /></svg>')
      ->at('svg|rect', svg => 'http://www.w3.org/2000/svg');
  
  =head2 attr
  
    my $hash = $dom->attr;
    my $foo  = $dom->attr('foo');
    $dom     = $dom->attr({foo => 'bar'});
    $dom     = $dom->attr(foo => 'bar');
  
  This element's attributes.
  
    # Remove an attribute
    delete $dom->attr->{id};
  
    # Attribute without value
    $dom->attr(selected => undef);
  
    # List id attributes
    say $dom->find('*')->map(attr => 'id')->compact->join("\n");
  
  =head2 child_nodes
  
    my $collection = $dom->child_nodes;
  
  Return a L<Mojo::Collection> object containing all child nodes of this element
  as L<Mojo::DOM> objects.
  
    # "<p><b>123</b></p>"
    $dom->parse('<p>Test<b>123</b></p>')->at('p')->child_nodes->first->remove;
  
    # "<!DOCTYPE html>"
    $dom->parse('<!DOCTYPE html><b>123</b>')->child_nodes->first;
  
    # " Test "
    $dom->parse('<b>123</b><!-- Test -->')->child_nodes->last->content;
  
  =head2 children
  
    my $collection = $dom->children;
    my $collection = $dom->children('div ~ p');
  
  Find all child elements of this element matching the CSS selector and return a
  L<Mojo::Collection> object containing these elements as L<Mojo::DOM> objects.
  All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # Show tag name of random child element
    say $dom->children->shuffle->first->tag;
  
  =head2 content
  
    my $str = $dom->content;
    $dom    = $dom->content('<p>I  Mojolicious!</p>');
    $dom    = $dom->content(Mojo::DOM->new);
  
  Return this node's content or replace it with HTML/XML fragment (for C<root>
  and C<tag> nodes) or raw content.
  
    # "<b>Test</b>"
    $dom->parse('<div><b>Test</b></div>')->at('div')->content;
  
    # "<div><h1>123</h1></div>"
    $dom->parse('<div><h1>Test</h1></div>')->at('h1')->content('123')->root;
  
    # "<p><i>123</i></p>"
    $dom->parse('<p>Test</p>')->at('p')->content('<i>123</i>')->root;
  
    # "<div><h1></h1></div>"
    $dom->parse('<div><h1>Test</h1></div>')->at('h1')->content('')->root;
  
    # " Test "
    $dom->parse('<!-- Test --><br>')->child_nodes->first->content;
  
    # "<div><!-- 123 -->456</div>"
    $dom->parse('<div><!-- Test -->456</div>')
      ->at('div')->child_nodes->first->content(' 123 ')->root;
  
  =head2 descendant_nodes
  
    my $collection = $dom->descendant_nodes;
  
  Return a L<Mojo::Collection> object containing all descendant nodes of this
  element as L<Mojo::DOM> objects.
  
    # "<p><b>123</b></p>"
    $dom->parse('<p><!-- Test --><b>123<!-- 456 --></b></p>')
      ->descendant_nodes->grep(sub { $_->type eq 'comment' })
      ->map('remove')->first;
  
    # "<p><b>test</b>test</p>"
    $dom->parse('<p><b>123</b>456</p>')
      ->at('p')->descendant_nodes->grep(sub { $_->type eq 'text' })
      ->map(content => 'test')->first->root;
  
  =head2 find
  
    my $collection = $dom->find('div ~ p');
    my $collection = $dom->find('svg|line', svg => 'http://www.w3.org/2000/svg');
  
  Find all descendant elements of this element matching the CSS selector and
  return a L<Mojo::Collection> object containing these elements as L<Mojo::DOM>
  objects. All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # Find a specific element and extract information
    my $id = $dom->find('div')->[23]{id};
  
    # Extract information from multiple elements
    my @headers = $dom->find('h1, h2, h3')->map('text')->each;
  
    # Count all the different tags
    my $hash = $dom->find('*')->reduce(sub { $a->{$b->tag}++; $a }, {});
  
    # Find elements with a class that contains dots
    my @divs = $dom->find('div.foo\.bar')->each;
  
  Trailing key/value pairs can be used to declare xml namespace aliases.
  
    # "<rect />"
    $dom->parse('<svg xmlns="http://www.w3.org/2000/svg"><rect /></svg>')
      ->find('svg|rect', svg => 'http://www.w3.org/2000/svg')->first;
  
  =head2 following
  
    my $collection = $dom->following;
    my $collection = $dom->following('div ~ p');
  
  Find all sibling elements after this node matching the CSS selector and return
  a L<Mojo::Collection> object containing these elements as L<Mojo::DOM> objects.
  All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # List tags of sibling elements after this node
    say $dom->following->map('tag')->join("\n");
  
  =head2 following_nodes
  
    my $collection = $dom->following_nodes;
  
  Return a L<Mojo::Collection> object containing all sibling nodes after this
  node as L<Mojo::DOM> objects.
  
    # "C"
    $dom->parse('<p>A</p><!-- B -->C')->at('p')->following_nodes->last->content;
  
  =head2 matches
  
    my $bool = $dom->matches('div ~ p');
    my $bool = $dom->matches('svg|line', svg => 'http://www.w3.org/2000/svg');
  
  Check if this element matches the CSS selector. All selectors from
  L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # True
    $dom->parse('<p class="a">A</p>')->at('p')->matches('.a');
    $dom->parse('<p class="a">A</p>')->at('p')->matches('p[class]');
  
    # False
    $dom->parse('<p class="a">A</p>')->at('p')->matches('.b');
    $dom->parse('<p class="a">A</p>')->at('p')->matches('p[id]');
  
  Trailing key/value pairs can be used to declare xml namespace aliases.
  
    # True
    $dom->parse('<svg xmlns="http://www.w3.org/2000/svg"><rect /></svg>')
      ->matches('svg|rect', svg => 'http://www.w3.org/2000/svg');
  
  =head2 namespace
  
    my $namespace = $dom->namespace;
  
  Find this element's namespace, or return C<undef> if none could be found.
  
    # Find namespace for an element with namespace prefix
    my $namespace = $dom->at('svg > svg\:circle')->namespace;
  
    # Find namespace for an element that may or may not have a namespace prefix
    my $namespace = $dom->at('svg > circle')->namespace;
  
  =head2 new
  
    my $dom = Mojo::DOM->new;
    my $dom = Mojo::DOM->new('<foo bar="baz">I  Mojolicious!</foo>');
  
  Construct a new scalar-based L<Mojo::DOM> object and L</"parse"> HTML/XML
  fragment if necessary.
  
  =head2 new_tag
  
    my $tag = Mojo::DOM->new_tag('div');
    my $tag = $dom->new_tag('div');
    my $tag = $dom->new_tag('div', id => 'foo', hidden => undef);
    my $tag = $dom->new_tag('div', 'safe content');
    my $tag = $dom->new_tag('div', id => 'foo', 'safe content');
    my $tag = $dom->new_tag('div', data => {mojo => 'rocks'}, 'safe content');
    my $tag = $dom->new_tag('div', id => 'foo', sub { 'unsafe content' });
  
  Construct a new L<Mojo::DOM> object for an HTML/XML tag with or without
  attributes and content. The C<data> attribute may contain a hash reference with
  key/value pairs to generate attributes from.
  
    # "<br>"
    $dom->new_tag('br');
  
    # "<div></div>"
    $dom->new_tag('div');
  
    # "<div id="foo" hidden></div>"
    $dom->new_tag('div', id => 'foo', hidden => undef);
  
    # "<div>test &amp; 123</div>"
    $dom->new_tag('div', 'test & 123');
  
    # "<div id="foo">test &amp; 123</div>"
    $dom->new_tag('div', id => 'foo', 'test & 123');
  
    # "<div data-foo="1" data-bar="test">test &amp; 123</div>""
    $dom->new_tag('div', data => {foo => 1, Bar => 'test'}, 'test & 123');
  
    # "<div id="foo">test & 123</div>"
    $dom->new_tag('div', id => 'foo', sub { 'test & 123' });
  
    # "<div>Hello<b>Mojo!</b></div>"
    $dom->parse('<div>Hello</div>')->at('div')
      ->append_content($dom->new_tag('b', 'Mojo!'))->root;
  
  =head2 next
  
    my $sibling = $dom->next;
  
  Return L<Mojo::DOM> object for next sibling element, or C<undef> if there are no
  more siblings.
  
    # "<h2>123</h2>"
    $dom->parse('<div><h1>Test</h1><h2>123</h2></div>')->at('h1')->next;
  
  =head2 next_node
  
    my $sibling = $dom->next_node;
  
  Return L<Mojo::DOM> object for next sibling node, or C<undef> if there are no
  more siblings.
  
    # "456"
    $dom->parse('<p><b>123</b><!-- Test -->456</p>')
      ->at('b')->next_node->next_node;
  
    # " Test "
    $dom->parse('<p><b>123</b><!-- Test -->456</p>')
      ->at('b')->next_node->content;
  
  =head2 parent
  
    my $parent = $dom->parent;
  
  Return L<Mojo::DOM> object for parent of this node, or C<undef> if this node has
  no parent.
  
    # "<b><i>Test</i></b>"
    $dom->parse('<p><b><i>Test</i></b></p>')->at('i')->parent;
  
  =head2 parse
  
    $dom = $dom->parse('<foo bar="baz">I  Mojolicious!</foo>');
  
  Parse HTML/XML fragment with L<Mojo::DOM::HTML>.
  
    # Parse XML
    my $dom = Mojo::DOM->new->xml(1)->parse('<foo>I  Mojolicious!</foo>');
  
  =head2 preceding
  
    my $collection = $dom->preceding;
    my $collection = $dom->preceding('div ~ p');
  
  Find all sibling elements before this node matching the CSS selector and return
  a L<Mojo::Collection> object containing these elements as L<Mojo::DOM> objects.
  All selectors from L<Mojo::DOM::CSS/"SELECTORS"> are supported.
  
    # List tags of sibling elements before this node
    say $dom->preceding->map('tag')->join("\n");
  
  =head2 preceding_nodes
  
    my $collection = $dom->preceding_nodes;
  
  Return a L<Mojo::Collection> object containing all sibling nodes before this
  node as L<Mojo::DOM> objects.
  
    # "A"
    $dom->parse('A<!-- B --><p>C</p>')->at('p')->preceding_nodes->first->content;
  
  =head2 prepend
  
    $dom = $dom->prepend('<p>I  Mojolicious!</p>');
    $dom = $dom->prepend(Mojo::DOM->new);
  
  Prepend HTML/XML fragment to this node (for all node types other than C<root>).
  
    # "<div><h1>Test</h1><h2>123</h2></div>"
    $dom->parse('<div><h2>123</h2></div>')
      ->at('h2')->prepend('<h1>Test</h1>')->root;
  
    # "<p>Test 123</p>"
    $dom->parse('<p>123</p>')
      ->at('p')->child_nodes->first->prepend('Test ')->root;
  
  =head2 prepend_content
  
    $dom = $dom->prepend_content('<p>I  Mojolicious!</p>');
    $dom = $dom->prepend_content(Mojo::DOM->new);
  
  Prepend HTML/XML fragment (for C<root> and C<tag> nodes) or raw content to this
  node's content.
  
    # "<div><h2>Test123</h2></div>"
    $dom->parse('<div><h2>123</h2></div>')
      ->at('h2')->prepend_content('Test')->root;
  
    # "<!-- Test 123 --><br>"
    $dom->parse('<!-- 123 --><br>')
      ->child_nodes->first->prepend_content(' Test')->root;
  
    # "<p><i>123</i>Test</p>"
    $dom->parse('<p>Test</p>')->at('p')->prepend_content('<i>123</i>')->root;
  
  =head2 previous
  
    my $sibling = $dom->previous;
  
  Return L<Mojo::DOM> object for previous sibling element, or C<undef> if there
  are no more siblings.
  
    # "<h1>Test</h1>"
    $dom->parse('<div><h1>Test</h1><h2>123</h2></div>')->at('h2')->previous;
  
  =head2 previous_node
  
    my $sibling = $dom->previous_node;
  
  Return L<Mojo::DOM> object for previous sibling node, or C<undef> if there are
  no more siblings.
  
    # "123"
    $dom->parse('<p>123<!-- Test --><b>456</b></p>')
      ->at('b')->previous_node->previous_node;
  
    # " Test "
    $dom->parse('<p>123<!-- Test --><b>456</b></p>')
      ->at('b')->previous_node->content;
  
  =head2 remove
  
    my $parent = $dom->remove;
  
  Remove this node and return L</"root"> (for C<root> nodes) or L</"parent">.
  
    # "<div></div>"
    $dom->parse('<div><h1>Test</h1></div>')->at('h1')->remove;
  
    # "<p><b>456</b></p>"
    $dom->parse('<p>123<b>456</b></p>')
      ->at('p')->child_nodes->first->remove->root;
  
  =head2 replace
  
    my $parent = $dom->replace('<div>I  Mojolicious!</div>');
    my $parent = $dom->replace(Mojo::DOM->new);
  
  Replace this node with HTML/XML fragment and return L</"root"> (for C<root>
  nodes) or L</"parent">.
  
    # "<div><h2>123</h2></div>"
    $dom->parse('<div><h1>Test</h1></div>')->at('h1')->replace('<h2>123</h2>');
  
    # "<p><b>123</b></p>"
    $dom->parse('<p>Test</p>')
      ->at('p')->child_nodes->[0]->replace('<b>123</b>')->root;
  
  =head2 root
  
    my $root = $dom->root;
  
  Return L<Mojo::DOM> object for C<root> node.
  
  =head2 selector
  
    my $selector = $dom->selector;
  
  Get a unique CSS selector for this element.
  
    # "ul:nth-child(1) > li:nth-child(2)"
    $dom->parse('<ul><li>Test</li><li>123</li></ul>')->find('li')->last->selector;
  
    # "p:nth-child(1) > b:nth-child(1) > i:nth-child(1)"
    $dom->parse('<p><b><i>Test</i></b></p>')->at('i')->selector;
  
  =head2 strip
  
    my $parent = $dom->strip;
  
  Remove this element while preserving its content and return L</"parent">.
  
    # "<div>Test</div>"
    $dom->parse('<div><h1>Test</h1></div>')->at('h1')->strip;
  
  =head2 tag
  
    my $tag = $dom->tag;
    $dom    = $dom->tag('div');
  
  This element's tag name.
  
    # List tag names of child elements
    say $dom->children->map('tag')->join("\n");
  
  =head2 tap
  
    $dom = $dom->tap(sub {...});
  
  Alias for L<Mojo::Base/"tap">.
  
  =head2 text
  
    my $text = $dom->text;
  
  Extract text content from this element only (not including child elements).
  
    # "bar"
    $dom->parse("<div>foo<p>bar</p>baz</div>")->at('p')->text;
  
    # "foo\nbaz\n"
    $dom->parse("<div>foo\n<p>bar</p>baz\n</div>")->at('div')->text;
  
  =head2 to_string
  
    my $str = $dom->to_string;
  
  Render this node and its content to HTML/XML.
  
    # "<b>Test</b>"
    $dom->parse('<div><b>Test</b></div>')->at('div b')->to_string;
  
  =head2 tree
  
    my $tree = $dom->tree;
    $dom     = $dom->tree(['root']);
  
  Document Object Model. Note that this structure should only be used very
  carefully since it is very dynamic.
  
  =head2 type
  
    my $type = $dom->type;
  
  This node's type, usually C<cdata>, C<comment>, C<doctype>, C<pi>, C<raw>,
  C<root>, C<tag> or C<text>.
  
    # "cdata"
    $dom->parse('<![CDATA[Test]]>')->child_nodes->first->type;
  
    # "comment"
    $dom->parse('<!-- Test -->')->child_nodes->first->type;
  
    # "doctype"
    $dom->parse('<!DOCTYPE html>')->child_nodes->first->type;
  
    # "pi"
    $dom->parse('<?xml version="1.0"?>')->child_nodes->first->type;
  
    # "raw"
    $dom->parse('<title>Test</title>')->at('title')->child_nodes->first->type;
  
    # "root"
    $dom->parse('<p>Test</p>')->type;
  
    # "tag"
    $dom->parse('<p>Test</p>')->at('p')->type;
  
    # "text"
    $dom->parse('<p>Test</p>')->at('p')->child_nodes->first->type;
  
  =head2 val
  
    my $value = $dom->val;
  
  Extract value from form element (such as C<button>, C<input>, C<option>,
  C<select> and C<textarea>), or return C<undef> if this element has no value. In
  the case of C<select> with C<multiple> attribute, find C<option> elements with
  C<selected> attribute and return an array reference with all values, or C<undef>
  if none could be found.
  
    # "a"
    $dom->parse('<input name=test value=a>')->at('input')->val;
  
    # "b"
    $dom->parse('<textarea>b</textarea>')->at('textarea')->val;
  
    # "c"
    $dom->parse('<option value="c">Test</option>')->at('option')->val;
  
    # "d"
    $dom->parse('<select><option selected>d</option></select>')
      ->at('select')->val;
  
    # "e"
    $dom->parse('<select multiple><option selected>e</option></select>')
      ->at('select')->val->[0];
  
    # "on"
    $dom->parse('<input name=test type=checkbox>')->at('input')->val;
  
  =head2 with_roles
  
    my $new_class = Mojo::DOM->with_roles('Mojo::DOM::Role::One');
    my $new_class = Mojo::DOM->with_roles('+One', '+Two');
    $dom          = $dom->with_roles('+One', '+Two');
  
  Alias for L<Mojo::Base/"with_roles">.
  
  =head2 wrap
  
    $dom = $dom->wrap('<div></div>');
    $dom = $dom->wrap(Mojo::DOM->new);
  
  Wrap HTML/XML fragment around this node (for all node types other than C<root>),
  placing it as the last child of the first innermost element.
  
    # "<p>123<b>Test</b></p>"
    $dom->parse('<b>Test</b>')->at('b')->wrap('<p>123</p>')->root;
  
    # "<div><p><b>Test</b></p>123</div>"
    $dom->parse('<b>Test</b>')->at('b')->wrap('<div><p></p>123</div>')->root;
  
    # "<p><b>Test</b></p><p>123</p>"
    $dom->parse('<b>Test</b>')->at('b')->wrap('<p></p><p>123</p>')->root;
  
    # "<p><b>Test</b></p>"
    $dom->parse('<p>Test</p>')->at('p')->child_nodes->first->wrap('<b>')->root;
  
  =head2 wrap_content
  
    $dom = $dom->wrap_content('<div></div>');
    $dom = $dom->wrap_content(Mojo::DOM->new);
  
  Wrap HTML/XML fragment around this node's content (for C<root> and C<tag>
  nodes), placing it as the last children of the first innermost element.
  
    # "<p><b>123Test</b></p>"
    $dom->parse('<p>Test<p>')->at('p')->wrap_content('<b>123</b>')->root;
  
    # "<p><b>Test</b></p><p>123</p>"
    $dom->parse('<b>Test</b>')->wrap_content('<p></p><p>123</p>');
  
  =head2 xml
  
    my $bool = $dom->xml;
    $dom     = $dom->xml($bool);
  
  Disable HTML semantics in parser and activate case-sensitivity, defaults to
  auto-detection based on XML declarations.
  
  =head1 OPERATORS
  
  L<Mojo::DOM> overloads the following operators.
  
  =head2 array
  
    my @nodes = @$dom;
  
  Alias for L</"child_nodes">.
  
    # "<!-- Test -->"
    $dom->parse('<!-- Test --><b>123</b>')->[0];
  
  =head2 bool
  
    my $bool = !!$dom;
  
  Always true.
  
  =head2 hash
  
    my %attrs = %$dom;
  
  Alias for L</"attr">.
  
    # "test"
    $dom->parse('<div id="test">Test</div>')->at('div')->{id};
  
  =head2 stringify
  
    my $str = "$dom";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_DOM

$fatpacked{"Mojo/DOM/CSS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_DOM_CSS';
  package Mojo::DOM::CSS;
  use Mojo::Base -base;
  
  use Mojo::Util 'trim';
  
  has 'tree';
  
  my $ESCAPE_RE = qr/\\[^0-9a-fA-F]|\\[0-9a-fA-F]{1,6}/;
  my $ATTR_RE   = qr/
    \[
    ((?:$ESCAPE_RE|[\w\-])+)                              # Key
    (?:
      (\W)?=                                              # Operator
      (?:"((?:\\"|[^"])*)"|'((?:\\'|[^'])*)'|([^\]]+?))   # Value
      (?:\s+(i))?                                         # Case-sensitivity
    )?
    \]
  /x;
  
  sub matches {
    my $tree = shift->tree;
    return $tree->[0] ne 'tag' ? undef : _match(_compile(@_), $tree, $tree);
  }
  
  sub select     { _select(0, shift->tree, _compile(@_)) }
  sub select_one { _select(1, shift->tree, _compile(@_)) }
  
  sub _ancestor {
    my ($selectors, $current, $tree, $one, $pos) = @_;
  
    while ($current = $current->[3]) {
      return undef if $current->[0] eq 'root' || $current eq $tree;
      return 1 if _combinator($selectors, $current, $tree, $pos);
      last if $one;
    }
  
    return undef;
  }
  
  sub _attr {
    my ($name_re, $value_re, $current) = @_;
  
    my $attrs = $current->[2];
    for my $name (keys %$attrs) {
      my $value = $attrs->{$name};
      next if $name !~ $name_re || (!defined $value && defined $value_re);
      return 1 if !(defined $value && defined $value_re) || $value =~ $value_re;
    }
  
    return undef;
  }
  
  sub _combinator {
    my ($selectors, $current, $tree, $pos) = @_;
  
    # Selector
    return undef unless my $c = $selectors->[$pos];
    if (ref $c) {
      return undef unless _selector($c, $current);
      return 1 unless $c = $selectors->[++$pos];
    }
  
    # ">" (parent only)
    return _ancestor($selectors, $current, $tree, 1, ++$pos) if $c eq '>';
  
    # "~" (preceding siblings)
    return _sibling($selectors, $current, $tree, 0, ++$pos) if $c eq '~';
  
    # "+" (immediately preceding siblings)
    return _sibling($selectors, $current, $tree, 1, ++$pos) if $c eq '+';
  
    # " " (ancestor)
    return _ancestor($selectors, $current, $tree, 0, ++$pos);
  }
  
  sub _compile {
    my ($css, %ns) = (trim('' . shift), @_);
  
    my $group = [[]];
    while (my $selectors = $group->[-1]) {
      push @$selectors, [] unless @$selectors && ref $selectors->[-1];
      my $last = $selectors->[-1];
  
      # Separator
      if ($css =~ /\G\s*,\s*/gc) { push @$group, [] }
  
      # Combinator
      elsif ($css =~ /\G\s*([ >+~])\s*/gc) { push @$selectors, $1 }
  
      # Class or ID
      elsif ($css =~ /\G([.#])((?:$ESCAPE_RE\s|\\.|[^,.#:[ >~+])+)/gco) {
        my ($name, $op) = $1 eq '.' ? ('class', '~') : ('id', '');
        push @$last, ['attr', _name($name), _value($op, $2)];
      }
  
      # Attributes
      elsif ($css =~ /\G$ATTR_RE/gco) {
        push @$last, ['attr', _name($1), _value($2 // '', $3 // $4 // $5, $6)];
      }
  
      # Pseudo-class
      elsif ($css =~ /\G:([\w\-]+)(?:\(((?:\([^)]+\)|[^)])+)\))?/gcs) {
        my ($name, $args) = (lc $1, $2);
  
        # ":matches" and ":not" (contains more selectors)
        $args = _compile($args, %ns) if $name eq 'matches' || $name eq 'not';
  
        # ":nth-*" (with An+B notation)
        $args = _equation($args) if $name =~ /^nth-/;
  
        # ":first-*" (rewrite to ":nth-*")
        ($name, $args) = ("nth-$1", [0, 1]) if $name =~ /^first-(.+)$/;
  
        # ":last-*" (rewrite to ":nth-*")
        ($name, $args) = ("nth-$name", [-1, 1]) if $name =~ /^last-/;
  
        push @$last, ['pc', $name, $args];
      }
  
      # Tag
      elsif ($css =~ /\G((?:$ESCAPE_RE\s|\\.|[^,.#:[ >~+])+)/gco) {
        my $alias = (my $name = $1) =~ s/^([^|]*)\|// && $1 ne '*' ? $1 : undef;
        my $ns = length $alias ? $ns{$alias} // return [['invalid']] : $alias;
        push @$last, ['tag', $name eq '*' ? undef : _name($name), _unescape($ns)];
      }
  
      else {last}
    }
  
    return $group;
  }
  
  sub _empty { $_[0][0] eq 'comment' || $_[0][0] eq 'pi' }
  
  sub _equation {
    return [0, 0] unless my $equation = shift;
  
    # "even"
    return [2, 2] if $equation =~ /^\s*even\s*$/i;
  
    # "odd"
    return [2, 1] if $equation =~ /^\s*odd\s*$/i;
  
    # "4", "+4" or "-4"
    return [0, $1] if $equation =~ /^\s*((?:\+|-)?\d+)\s*$/;
  
    # "n", "4n", "+4n", "-4n", "n+1", "4n-1", "+4n-1" (and other variations)
    return [0, 0]
      unless $equation =~ /^\s*((?:\+|-)?(?:\d+)?)?n\s*((?:\+|-)\s*\d+)?\s*$/i;
    return [$1 eq '-' ? -1 : !length $1 ? 1 : $1, join('', split(' ', $2 // 0))];
  }
  
  sub _match {
    my ($group, $current, $tree) = @_;
    _combinator([reverse @$_], $current, $tree, 0) and return 1 for @$group;
    return undef;
  }
  
  sub _name {qr/(?:^|:)\Q@{[_unescape(shift)]}\E$/}
  
  sub _namespace {
    my ($ns, $current) = @_;
  
    my $attr = $current->[1] =~ /^([^:]+):/ ? "xmlns:$1" : 'xmlns';
    while ($current) {
      last if $current->[0] eq 'root';
      return $current->[2]{$attr} eq $ns if exists $current->[2]{$attr};
  
      $current = $current->[3];
    }
  
    # Failing to match yields true if searching for no namespace, false otherwise
    return !length $ns;
  }
  
  sub _pc {
    my ($class, $args, $current) = @_;
  
    # ":checked"
    return exists $current->[2]{checked} || exists $current->[2]{selected}
      if $class eq 'checked';
  
    # ":not"
    return !_match($args, $current, $current) if $class eq 'not';
  
    # ":matches"
    return !!_match($args, $current, $current) if $class eq 'matches';
  
    # ":empty"
    return !grep { !_empty($_) } @$current[4 .. $#$current] if $class eq 'empty';
  
    # ":root"
    return $current->[3] && $current->[3][0] eq 'root' if $class eq 'root';
  
    # ":link" and ":visited"
    if ($class eq 'link' || $class eq 'visited') {
      return undef unless $current->[0] eq 'tag' && exists $current->[2]{href};
      return !!grep { $current->[1] eq $_ } qw(a area link);
    }
  
    # ":only-child" or ":only-of-type"
    if ($class eq 'only-child' || $class eq 'only-of-type') {
      my $type = $class eq 'only-of-type' ? $current->[1] : undef;
      $_ ne $current and return undef for @{_siblings($current, $type)};
      return 1;
    }
  
    # ":nth-child", ":nth-last-child", ":nth-of-type" or ":nth-last-of-type"
    if (ref $args) {
      my $type = $class eq 'nth-of-type'
        || $class eq 'nth-last-of-type' ? $current->[1] : undef;
      my @siblings = @{_siblings($current, $type)};
      @siblings = reverse @siblings
        if $class eq 'nth-last-child' || $class eq 'nth-last-of-type';
  
      for my $i (0 .. $#siblings) {
        next if (my $result = $args->[0] * $i + $args->[1]) < 1;
        return undef unless my $sibling = $siblings[$result - 1];
        return 1 if $sibling eq $current;
      }
    }
  
    # Everything else
    return undef;
  }
  
  sub _select {
    my ($one, $tree, $group) = @_;
  
    my @results;
    my @queue = @$tree[($tree->[0] eq 'root' ? 1 : 4) .. $#$tree];
    while (my $current = shift @queue) {
      next unless $current->[0] eq 'tag';
  
      unshift @queue, @$current[4 .. $#$current];
      next unless _match($group, $current, $tree);
      $one ? return $current : push @results, $current;
    }
  
    return $one ? undef : \@results;
  }
  
  sub _selector {
    my ($selector, $current) = @_;
  
    for my $s (@$selector) {
      my $type = $s->[0];
  
      # Tag
      if ($type eq 'tag') {
        return undef if defined $s->[1] && $current->[1] !~ $s->[1];
        return undef if defined $s->[2] && !_namespace($s->[2], $current);
      }
  
      # Attribute
      elsif ($type eq 'attr') { return undef unless _attr(@$s[1, 2], $current) }
  
      # Pseudo-class
      elsif ($type eq 'pc') { return undef unless _pc(@$s[1, 2], $current) }
  
      # Invalid selector
      else { return undef }
    }
  
    return 1;
  }
  
  sub _sibling {
    my ($selectors, $current, $tree, $immediate, $pos) = @_;
  
    my $found;
    for my $sibling (@{_siblings($current)}) {
      return $found if $sibling eq $current;
  
      # "+" (immediately preceding sibling)
      if ($immediate) { $found = _combinator($selectors, $sibling, $tree, $pos) }
  
      # "~" (preceding sibling)
      else { return 1 if _combinator($selectors, $sibling, $tree, $pos) }
    }
  
    return undef;
  }
  
  sub _siblings {
    my ($current, $type) = @_;
  
    my $parent = $current->[3];
    my @siblings = grep { $_->[0] eq 'tag' }
      @$parent[($parent->[0] eq 'root' ? 1 : 4) .. $#$parent];
    @siblings = grep { $type eq $_->[1] } @siblings if defined $type;
  
    return \@siblings;
  }
  
  sub _unescape {
    return undef unless defined(my $value = shift);
  
    # Remove escaped newlines
    $value =~ s/\\\n//g;
  
    # Unescape Unicode characters
    $value =~ s/\\([0-9a-fA-F]{1,6})\s?/pack 'U', hex $1/ge;
  
    # Remove backslash
    $value =~ s/\\//g;
  
    return $value;
  }
  
  sub _value {
    my ($op, $value, $insensitive) = @_;
    return undef unless defined $value;
    $value = ($insensitive ? '(?i)' : '') . quotemeta _unescape($value);
  
    # "~=" (word)
    return qr/(?:^|\s+)$value(?:\s+|$)/ if $op eq '~';
  
    # "|=" (hyphen-separated)
    return qr/^$value(?:-|$)/ if $op eq '|';
  
    # "*=" (contains)
    return qr/$value/ if $op eq '*';
  
    # "^=" (begins with)
    return qr/^$value/ if $op eq '^';
  
    # "$=" (ends with)
    return qr/$value$/ if $op eq '$';
  
    # Everything else
    return qr/^$value$/;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::DOM::CSS - CSS selector engine
  
  =head1 SYNOPSIS
  
    use Mojo::DOM::CSS;
  
    # Select elements from DOM tree
    my $css = Mojo::DOM::CSS->new(tree => $tree);
    my $elements = $css->select('h1, h2, h3');
  
  =head1 DESCRIPTION
  
  L<Mojo::DOM::CSS> is the CSS selector engine used by L<Mojo::DOM>, based on the
  L<HTML Living Standard|https://html.spec.whatwg.org> and
  L<Selectors Level 3|http://www.w3.org/TR/css3-selectors/>.
  
  =head1 SELECTORS
  
  All CSS selectors that make sense for a standalone parser are supported.
  
  =head2 *
  
  Any element.
  
    my $all = $css->select('*');
  
  =head2 E
  
  An element of type C<E>.
  
    my $title = $css->select('title');
  
  =head2 E[foo]
  
  An C<E> element with a C<foo> attribute.
  
    my $links = $css->select('a[href]');
  
  =head2 E[foo="bar"]
  
  An C<E> element whose C<foo> attribute value is exactly equal to C<bar>.
  
    my $case_sensitive = $css->select('input[type="hidden"]');
    my $case_sensitive = $css->select('input[type=hidden]');
  
  =head2 E[foo="bar" i]
  
  An C<E> element whose C<foo> attribute value is exactly equal to any
  (ASCII-range) case-permutation of C<bar>. Note that this selector is
  EXPERIMENTAL and might change without warning!
  
    my $case_insensitive = $css->select('input[type="hidden" i]');
    my $case_insensitive = $css->select('input[type=hidden i]');
    my $case_insensitive = $css->select('input[class~="foo" i]');
  
  This selector is part of
  L<Selectors Level 4|http://dev.w3.org/csswg/selectors-4>, which is still a work
  in progress.
  
  =head2 E[foo~="bar"]
  
  An C<E> element whose C<foo> attribute value is a list of whitespace-separated
  values, one of which is exactly equal to C<bar>.
  
    my $foo = $css->select('input[class~="foo"]');
    my $foo = $css->select('input[class~=foo]');
  
  =head2 E[foo^="bar"]
  
  An C<E> element whose C<foo> attribute value begins exactly with the string
  C<bar>.
  
    my $begins_with = $css->select('input[name^="f"]');
    my $begins_with = $css->select('input[name^=f]');
  
  =head2 E[foo$="bar"]
  
  An C<E> element whose C<foo> attribute value ends exactly with the string
  C<bar>.
  
    my $ends_with = $css->select('input[name$="o"]');
    my $ends_with = $css->select('input[name$=o]');
  
  =head2 E[foo*="bar"]
  
  An C<E> element whose C<foo> attribute value contains the substring C<bar>.
  
    my $contains = $css->select('input[name*="fo"]');
    my $contains = $css->select('input[name*=fo]');
  
  =head2 E[foo|="en"]
  
  An C<E> element whose C<foo> attribute has a hyphen-separated list of values
  beginning (from the left) with C<en>.
  
    my $english = $css->select('link[hreflang|=en]');
  
  =head2 E:root
  
  An C<E> element, root of the document.
  
    my $root = $css->select(':root');
  
  =head2 E:nth-child(n)
  
  An C<E> element, the C<n-th> child of its parent.
  
    my $third = $css->select('div:nth-child(3)');
    my $odd   = $css->select('div:nth-child(odd)');
    my $even  = $css->select('div:nth-child(even)');
    my $top3  = $css->select('div:nth-child(-n+3)');
  
  =head2 E:nth-last-child(n)
  
  An C<E> element, the C<n-th> child of its parent, counting from the last one.
  
    my $third    = $css->select('div:nth-last-child(3)');
    my $odd      = $css->select('div:nth-last-child(odd)');
    my $even     = $css->select('div:nth-last-child(even)');
    my $bottom3  = $css->select('div:nth-last-child(-n+3)');
  
  =head2 E:nth-of-type(n)
  
  An C<E> element, the C<n-th> sibling of its type.
  
    my $third = $css->select('div:nth-of-type(3)');
    my $odd   = $css->select('div:nth-of-type(odd)');
    my $even  = $css->select('div:nth-of-type(even)');
    my $top3  = $css->select('div:nth-of-type(-n+3)');
  
  =head2 E:nth-last-of-type(n)
  
  An C<E> element, the C<n-th> sibling of its type, counting from the last one.
  
    my $third    = $css->select('div:nth-last-of-type(3)');
    my $odd      = $css->select('div:nth-last-of-type(odd)');
    my $even     = $css->select('div:nth-last-of-type(even)');
    my $bottom3  = $css->select('div:nth-last-of-type(-n+3)');
  
  =head2 E:first-child
  
  An C<E> element, first child of its parent.
  
    my $first = $css->select('div p:first-child');
  
  =head2 E:last-child
  
  An C<E> element, last child of its parent.
  
    my $last = $css->select('div p:last-child');
  
  =head2 E:first-of-type
  
  An C<E> element, first sibling of its type.
  
    my $first = $css->select('div p:first-of-type');
  
  =head2 E:last-of-type
  
  An C<E> element, last sibling of its type.
  
    my $last = $css->select('div p:last-of-type');
  
  =head2 E:only-child
  
  An C<E> element, only child of its parent.
  
    my $lonely = $css->select('div p:only-child');
  
  =head2 E:only-of-type
  
  An C<E> element, only sibling of its type.
  
    my $lonely = $css->select('div p:only-of-type');
  
  =head2 E:empty
  
  An C<E> element that has no children (including text nodes).
  
    my $empty = $css->select(':empty');
  
  =head2 E:link
  
  An C<E> element being the source anchor of a hyperlink of which the target is
  not yet visited (C<:link>) or already visited (C<:visited>). Note that
  L<Mojo::DOM::CSS> is not stateful, therefore C<:link> and C<:visited> yield
  exactly the same results.
  
    my $links = $css->select(':link');
    my $links = $css->select(':visited');
  
  =head2 E:visited
  
  Alias for L</"E:link">.
  
  =head2 E:checked
  
  A user interface element C<E> which is checked (for instance a radio-button or
  checkbox).
  
    my $input = $css->select(':checked');
  
  =head2 E.warning
  
  An C<E> element whose class is "warning".
  
    my $warning = $css->select('div.warning');
  
  =head2 E#myid
  
  An C<E> element with C<ID> equal to "myid".
  
    my $foo = $css->select('div#foo');
  
  =head2 E:not(s1, s2)
  
  An C<E> element that does not match either compound selector C<s1> or compound
  selector C<s2>. Note that support for compound selectors is EXPERIMENTAL and
  might change without warning!
  
    my $others = $css->select('div p:not(:first-child, :last-child)');
  
  Support for compound selectors was added as part of
  L<Selectors Level 4|http://dev.w3.org/csswg/selectors-4>, which is still a work
  in progress.
  
  =head2 E:matches(s1, s2)
  
  An C<E> element that matches compound selector C<s1> and/or compound selector
  C<s2>. Note that this selector is EXPERIMENTAL and might change without warning!
  
    my $headers = $css->select(':matches(section, article, aside, nav) h1');
  
  This selector is part of
  L<Selectors Level 4|http://dev.w3.org/csswg/selectors-4>, which is still a work
  in progress.
  
  =head2 A|E
  
  An C<E> element that belongs to the namespace alias C<A> from
  L<CSS Namespaces Module Level 3|https://www.w3.org/TR/css-namespaces-3/>.
  Key/value pairs passed to selector methods are used to declare namespace
  aliases.
  
    my $elem = $css->select('lq|elem', lq => 'http://example.com/q-markup');
  
  Using an empty alias searches for an element that belongs to no namespace.
  
    my $div = $c->select('|div');
  
  =head2 E F
  
  An C<F> element descendant of an C<E> element.
  
    my $headlines = $css->select('div h1');
  
  =head2 E E<gt> F
  
  An C<F> element child of an C<E> element.
  
    my $headlines = $css->select('html > body > div > h1');
  
  =head2 E + F
  
  An C<F> element immediately preceded by an C<E> element.
  
    my $second = $css->select('h1 + h2');
  
  =head2 E ~ F
  
  An C<F> element preceded by an C<E> element.
  
    my $second = $css->select('h1 ~ h2');
  
  =head2 E, F, G
  
  Elements of type C<E>, C<F> and C<G>.
  
    my $headlines = $css->select('h1, h2, h3');
  
  =head2 E[foo=bar][bar=baz]
  
  An C<E> element whose attributes match all following attribute selectors.
  
    my $links = $css->select('a[foo^=b][foo$=ar]');
  
  =head1 ATTRIBUTES
  
  L<Mojo::DOM::CSS> implements the following attributes.
  
  =head2 tree
  
    my $tree = $css->tree;
    $css     = $css->tree(['root']);
  
  Document Object Model. Note that this structure should only be used very
  carefully since it is very dynamic.
  
  =head1 METHODS
  
  L<Mojo::DOM::CSS> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 matches
  
    my $bool = $css->matches('head > title');
    my $bool = $css->matches('svg|line', svg => 'http://www.w3.org/2000/svg');
  
  Check if first node in L</"tree"> matches the CSS selector. Trailing key/value
  pairs can be used to declare xml namespace aliases.
  
  =head2 select
  
    my $results = $css->select('head > title');
    my $results = $css->select('svg|line', svg => 'http://www.w3.org/2000/svg');
  
  Run CSS selector against L</"tree">. Trailing key/value pairs can be used to
  declare xml namespace aliases.
  
  =head2 select_one
  
    my $result = $css->select_one('head > title');
    my $result =
      $css->select_one('svg|line', svg => 'http://www.w3.org/2000/svg');
  
  Run CSS selector against L</"tree"> and stop as soon as the first node matched.
  Trailing key/value pairs can be used to declare xml namespace aliases.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_DOM_CSS

$fatpacked{"Mojo/DOM/HTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_DOM_HTML';
  package Mojo::DOM::HTML;
  use Mojo::Base -base;
  
  use Exporter 'import';
  use Mojo::Util qw(html_attr_unescape html_unescape xml_escape);
  use Scalar::Util 'weaken';
  
  our @EXPORT_OK = ('tag_to_html');
  
  has tree => sub { ['root'] };
  has 'xml';
  
  my $ATTR_RE = qr/
    ([^<>=\s\/]+|\/)                     # Key
    (?:
      \s*=\s*
      (?s:(["'])(.*?)\g{-2}|([^>\s]*))   # Value
    )?
    \s*
  /x;
  my $TOKEN_RE = qr/
    ([^<]+)?                                            # Text
    (?:
      <(?:
        !(?:
          DOCTYPE(
          \s+\w+                                        # Doctype
          (?:(?:\s+\w+)?(?:\s+(?:"[^"]*"|'[^']*'))+)?   # External ID
          (?:\s+\[.+?\])?                               # Int Subset
          \s*)
        |
          --(.*?)--\s*                                  # Comment
        |
          \[CDATA\[(.*?)\]\]                            # CDATA
        )
      |
        \?(.*?)\?                                       # Processing Instruction
      |
        \s*([^<>\s]+\s*(?:(?:$ATTR_RE){0,32766})*+)     # Tag
      )>
    |
      (<)                                               # Runaway "<"
    )??
  /xis;
  
  # HTML elements that only contain raw text
  my %RAW = map { $_ => 1 } qw(script style);
  
  # HTML elements that only contain raw text and entities
  my %RCDATA = map { $_ => 1 } qw(title textarea);
  
  # HTML elements with optional end tags
  my %END = (body => 'head', optgroup => 'optgroup', option => 'option');
  
  # HTML elements that break paragraphs
  map { $END{$_} = 'p' } (
    qw(address article aside blockquote details div dl fieldset figcaption),
    qw(figure footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p),
    qw(pre section table ul)
  );
  
  # HTML table elements with optional end tags
  my %TABLE = map { $_ => 1 } qw(colgroup tbody td tfoot th thead tr);
  
  # HTML elements with optional end tags and scoping rules
  my %CLOSE
    = (li => [{li => 1}, {ul => 1, ol => 1}], tr => [{tr => 1}, {table => 1}]);
  $CLOSE{$_} = [\%TABLE, {table => 1}] for qw(colgroup tbody tfoot thead);
  $CLOSE{$_} = [{dd => 1, dt => 1}, {dl    => 1}] for qw(dd dt);
  $CLOSE{$_} = [{rp => 1, rt => 1}, {ruby  => 1}] for qw(rp rt);
  $CLOSE{$_} = [{th => 1, td => 1}, {table => 1}] for qw(td th);
  
  # HTML elements without end tags
  my %EMPTY = map { $_ => 1 } (
    qw(area base br col embed hr img input keygen link menuitem meta param),
    qw(source track wbr)
  );
  
  # HTML elements categorized as phrasing content (and obsolete inline elements)
  my @PHRASING = (
    qw(a abbr area audio b bdi bdo br button canvas cite code data datalist),
    qw(del dfn em embed i iframe img input ins kbd keygen label link map mark),
    qw(math meta meter noscript object output picture progress q ruby s samp),
    qw(script select slot small span strong sub sup svg template textarea time u),
    qw(var video wbr)
  );
  my @OBSOLETE = qw(acronym applet basefont big font strike tt);
  my %PHRASING = map { $_ => 1 } @OBSOLETE, @PHRASING;
  
  # HTML elements that don't get their self-closing flag acknowledged
  my %BLOCK = map { $_ => 1 } (
    qw(a address applet article aside b big blockquote body button caption),
    qw(center code col colgroup dd details dialog dir div dl dt em fieldset),
    qw(figcaption figure font footer form frameset h1 h2 h3 h4 h5 h6 head),
    qw(header hgroup html i iframe li listing main marquee menu nav nobr),
    qw(noembed noframes noscript object ol optgroup option p plaintext pre rp),
    qw(rt s script section select small strike strong style summary table),
    qw(tbody td template textarea tfoot th thead title tr tt u ul xmp)
  );
  
  sub parse {
    my ($self, $html) = (shift, "$_[0]");
  
    my $xml = $self->xml;
    my $current = my $tree = ['root'];
    while ($html =~ /\G$TOKEN_RE/gcso) {
      my ($text, $doctype, $comment, $cdata, $pi, $tag, $runaway)
        = ($1, $2, $3, $4, $5, $6, $11);
  
      # Text (and runaway "<")
      $text .= '<' if defined $runaway;
      _node($current, 'text', html_unescape $text) if defined $text;
  
      # Tag
      if (defined $tag) {
  
        # End
        if ($tag =~ /^\/\s*(\S+)/) { _end($xml ? $1 : lc $1, $xml, \$current) }
  
        # Start
        elsif ($tag =~ m!^([^\s/]+)([\s\S]*)!) {
          my ($start, $attr) = ($xml ? $1 : lc $1, $2);
  
          # Attributes
          my (%attrs, $closing);
          while ($attr =~ /$ATTR_RE/go) {
            my ($key, $value) = ($xml ? $1 : lc $1, $3 // $4);
  
            # Empty tag
            ++$closing and next if $key eq '/';
  
            $attrs{$key} = defined $value ? html_attr_unescape $value : $value;
          }
  
          # "image" is an alias for "img"
          $start = 'img' if !$xml && $start eq 'image';
          _start($start, \%attrs, $xml, \$current);
  
          # Element without end tag (self-closing)
          _end($start, $xml, \$current)
            if !$xml && $EMPTY{$start} || ($xml || !$BLOCK{$start}) && $closing;
  
          # Raw text elements
          next if $xml || !$RAW{$start} && !$RCDATA{$start};
          next unless $html =~ m!\G(.*?)<\s*/\s*\Q$start\E\s*>!gcsi;
          _node($current, 'raw', $RCDATA{$start} ? html_unescape $1 : $1);
          _end($start, 0, \$current);
        }
      }
  
      # DOCTYPE
      elsif (defined $doctype) { _node($current, 'doctype', $doctype) }
  
      # Comment
      elsif (defined $comment) { _node($current, 'comment', $comment) }
  
      # CDATA
      elsif (defined $cdata) { _node($current, 'cdata', $cdata) }
  
      # Processing instruction (try to detect XML)
      elsif (defined $pi) {
        $self->xml($xml = 1) if !exists $self->{xml} && $pi =~ /xml/i;
        _node($current, 'pi', $pi);
      }
    }
  
    return $self->tree($tree);
  }
  
  sub render { _render($_[0]->tree, $_[0]->xml) }
  
  sub tag { shift->tree(['root', _tag(@_)]) }
  
  sub tag_to_html { _render(_tag(@_), undef) }
  
  sub _end {
    my ($end, $xml, $current) = @_;
  
    # Search stack for start tag
    my $next = $$current;
    do {
  
      # Ignore useless end tag
      return if $next->[0] eq 'root';
  
      # Right tag
      return $$current = $next->[3] if $next->[1] eq $end;
  
      # Phrasing content can only cross phrasing content
      return if !$xml && $PHRASING{$end} && !$PHRASING{$next->[1]};
  
    } while $next = $next->[3];
  }
  
  sub _node {
    my ($current, $type, $content) = @_;
    push @$current, my $new = [$type, $content, $current];
    weaken $new->[2];
  }
  
  sub _render {
    my ($tree, $xml) = @_;
  
    # Tag
    my $type = $tree->[0];
    if ($type eq 'tag') {
  
      # Start tag
      my $tag    = $tree->[1];
      my $result = "<$tag";
  
      # Attributes
      for my $key (sort keys %{$tree->[2]}) {
        my $value = $tree->[2]{$key};
        $result .= $xml ? qq{ $key="$key"} : " $key" and next
          unless defined $value;
        $result .= qq{ $key="} . xml_escape($value) . '"';
      }
  
      # No children
      return $xml ? "$result />" : $EMPTY{$tag} ? "$result>" : "$result></$tag>"
        unless $tree->[4];
  
      # Children
      no warnings 'recursion';
      $result .= '>' . join '', map { _render($_, $xml) } @$tree[4 .. $#$tree];
  
      # End tag
      return "$result</$tag>";
    }
  
    # Text (escaped)
    return xml_escape $tree->[1] if $type eq 'text';
  
    # Raw text
    return $tree->[1] if $type eq 'raw';
  
    # Root
    return join '', map { _render($_, $xml) } @$tree[1 .. $#$tree]
      if $type eq 'root';
  
    # DOCTYPE
    return '<!DOCTYPE' . $tree->[1] . '>' if $type eq 'doctype';
  
    # Comment
    return '<!--' . $tree->[1] . '-->' if $type eq 'comment';
  
    # CDATA
    return '<![CDATA[' . $tree->[1] . ']]>' if $type eq 'cdata';
  
    # Processing instruction
    return '<?' . $tree->[1] . '?>' if $type eq 'pi';
  
    # Everything else
    return '';
  }
  
  sub _start {
    my ($start, $attrs, $xml, $current) = @_;
  
    # Autoclose optional HTML elements
    if (!$xml && $$current->[0] ne 'root') {
      if (my $end = $END{$start}) { _end($end, 0, $current) }
  
      elsif (my $close = $CLOSE{$start}) {
        my ($allowed, $scope) = @$close;
  
        # Close allowed parent elements in scope
        my $parent = $$current;
        while ($parent->[0] ne 'root' && !$scope->{$parent->[1]}) {
          _end($parent->[1], 0, $current) if $allowed->{$parent->[1]};
          $parent = $parent->[3];
        }
      }
    }
  
    # New tag
    push @$$current, my $new = ['tag', $start, $attrs, $$current];
    weaken $new->[3];
    $$current = $new;
  }
  
  sub _tag {
    my $tree = ['tag', shift, undef, undef];
  
    # Content
    push @$tree, ref $_[-1] eq 'CODE' ? ['raw', pop->()] : ['text', pop]
      if @_ % 2;
  
    # Attributes
    my $attrs = $tree->[2] = {@_};
    return $tree unless exists $attrs->{data} && ref $attrs->{data} eq 'HASH';
    my $data = delete $attrs->{data};
    @$attrs{map { y/_/-/; lc "data-$_" } keys %$data} = values %$data;
    return $tree;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::DOM::HTML - HTML/XML engine
  
  =head1 SYNOPSIS
  
    use Mojo::DOM::HTML;
  
    # Turn HTML into DOM tree
    my $html = Mojo::DOM::HTML->new;
    $html->parse('<div><p id="a">Test</p><p id="b">123</p></div>');
    my $tree = $html->tree;
  
  =head1 DESCRIPTION
  
  L<Mojo::DOM::HTML> is the HTML/XML engine used by L<Mojo::DOM>, based on the
  L<HTML Living Standard|https://html.spec.whatwg.org> and the
  L<Extensible Markup Language (XML) 1.0|http://www.w3.org/TR/xml/>.
  
  =head1 FUNCTIONS
  
  L<Mojo::DOM::HTML> implements the following functions, which can be imported
  individually.
  
  =head2 tag_to_html
  
    my $str = tag_to_html 'div', id => 'foo', 'safe content';
  
  Generate HTML/XML tag and render it right away. This is a significantly faster
  alternative to L</"tag"> for template systems that have to generate a lot of
  tags. Note that this function is EXPERIMENTAL and might change without warning!
  
  =head1 ATTRIBUTES
  
  L<Mojo::DOM::HTML> implements the following attributes.
  
  =head2 tree
  
    my $tree = $html->tree;
    $html    = $html->tree(['root']);
  
  Document Object Model. Note that this structure should only be used very
  carefully since it is very dynamic.
  
  =head2 xml
  
    my $bool = $html->xml;
    $html    = $html->xml($bool);
  
  Disable HTML semantics in parser and activate case-sensitivity, defaults to
  auto-detection based on XML declarations.
  
  =head1 METHODS
  
  L<Mojo::DOM::HTML> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 parse
  
    $html = $html->parse('<foo bar="baz">I  Mojolicious!</foo>');
  
  Parse HTML/XML fragment.
  
  =head2 render
  
    my $str = $html->render;
  
  Render DOM to HTML/XML.
  
  =head2 tag
  
    $html = $html->tag('div', id => 'foo', 'safe content');
  
  Generate HTML/XML tag. Note that this method is EXPERIMENTAL and might change
  without warning!
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_DOM_HTML

$fatpacked{"Mojo/Date.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_DATE';
  package Mojo::Date;
  use Mojo::Base -base;
  use overload bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;
  
  use Time::Local 'timegm';
  
  has epoch => sub {time};
  
  my $RFC3339_RE = qr/
    ^(\d+)-(\d+)-(\d+)\D+(\d+):(\d+):(\d+(?:\.\d+)?)   # Date and time
    (?:Z|([+-])(\d+):(\d+))?$                          # Offset
  /xi;
  
  my @DAYS   = qw(Sun Mon Tue Wed Thu Fri Sat);
  my @MONTHS = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
  my %MONTHS;
  @MONTHS{@MONTHS} = (0 .. 11);
  
  sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }
  
  sub parse {
    my ($self, $date) = @_;
  
    # epoch (784111777)
    return $self->epoch($date) if $date =~ /^\d+$|^\d+\.\d+$/;
  
    # RFC 822/1123 (Sun, 06 Nov 1994 08:49:37 GMT)
    # RFC 850/1036 (Sunday, 06-Nov-94 08:49:37 GMT)
    my $offset = 0;
    my ($day, $month, $year, $h, $m, $s);
    if ($date =~ /^\w+\W+(\d+)\W+(\w+)\W+(\d+)\W+(\d+):(\d+):(\d+)\W*\w+$/) {
      ($day, $month, $year, $h, $m, $s) = ($1, $MONTHS{$2}, $3, $4, $5, $6);
    }
  
    # RFC 3339 (1994-11-06T08:49:37Z)
    elsif ($date =~ $RFC3339_RE) {
      ($year, $month, $day, $h, $m, $s) = ($1, $2 - 1, $3, $4, $5, $6);
      $offset = (($8 * 3600) + ($9 * 60)) * ($7 eq '+' ? -1 : 1) if $7;
    }
  
    # ANSI C asctime() (Sun Nov  6 08:49:37 1994)
    elsif ($date =~ /^\w+\s+(\w+)\s+(\d+)\s+(\d+):(\d+):(\d+)\s+(\d+)$/) {
      ($month, $day, $h, $m, $s, $year) = ($MONTHS{$1}, $2, $3, $4, $5, $6);
    }
  
    # Invalid
    else { return $self->epoch(undef) }
  
    my $epoch = eval { timegm $s, $m, $h, $day, $month, $year };
    return $self->epoch(
      (defined $epoch && ($epoch += $offset) >= 0) ? $epoch : undef);
  }
  
  sub to_datetime {
  
    # RFC 3339 (1994-11-06T08:49:37Z)
    my ($s, $m, $h, $day, $month, $year) = gmtime(my $epoch = shift->epoch);
    my $str = sprintf '%04d-%02d-%02dT%02d:%02d:%02d', $year + 1900, $month + 1,
      $day, $h, $m, $s;
    return $str . ($epoch =~ /(\.\d+)$/ ? $1 : '') . 'Z';
  }
  
  sub to_string {
  
    # RFC 7231 (Sun, 06 Nov 1994 08:49:37 GMT)
    my ($s, $m, $h, $mday, $month, $year, $wday) = gmtime shift->epoch;
    return sprintf '%s, %02d %s %04d %02d:%02d:%02d GMT', $DAYS[$wday], $mday,
      $MONTHS[$month], $year + 1900, $h, $m, $s;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Date - HTTP date
  
  =head1 SYNOPSIS
  
    use Mojo::Date;
  
    # Parse
    my $date = Mojo::Date->new('Sun, 06 Nov 1994 08:49:37 GMT');
    say $date->epoch;
  
    # Build
    my $date = Mojo::Date->new(time + 60);
    say "$date";
  
  =head1 DESCRIPTION
  
  L<Mojo::Date> implements HTTP date and time functions, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230>,
  L<RFC 7231|http://tools.ietf.org/html/rfc7231> and
  L<RFC 3339|http://tools.ietf.org/html/rfc3339>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Date> implements the following attributes.
  
  =head2 epoch
  
    my $epoch = $date->epoch;
    $date     = $date->epoch(784111777);
  
  Epoch seconds, defaults to the current time.
  
  =head1 METHODS
  
  L<Mojo::Date> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 new
  
    my $date = Mojo::Date->new;
    my $date = Mojo::Date->new('Sun Nov  6 08:49:37 1994');
  
  Construct a new L<Mojo::Date> object and L</"parse"> date if necessary.
  
  =head2 parse
  
    $date = $date->parse('Sun Nov  6 08:49:37 1994');
  
  Parse date.
  
    # Epoch
    say Mojo::Date->new('784111777')->epoch;
    say Mojo::Date->new('784111777.21')->epoch;
  
    # RFC 822/1123
    say Mojo::Date->new('Sun, 06 Nov 1994 08:49:37 GMT')->epoch;
  
    # RFC 850/1036
    say Mojo::Date->new('Sunday, 06-Nov-94 08:49:37 GMT')->epoch;
  
    # Ansi C asctime()
    say Mojo::Date->new('Sun Nov  6 08:49:37 1994')->epoch;
  
    # RFC 3339
    say Mojo::Date->new('1994-11-06T08:49:37Z')->epoch;
    say Mojo::Date->new('1994-11-06T08:49:37')->epoch;
    say Mojo::Date->new('1994-11-06T08:49:37.21Z')->epoch;
    say Mojo::Date->new('1994-11-06T08:49:37+01:00')->epoch;
    say Mojo::Date->new('1994-11-06T08:49:37-01:00')->epoch;
  
  =head2 to_datetime
  
    my $str = $date->to_datetime;
  
  Render L<RFC 3339|http://tools.ietf.org/html/rfc3339> date and time.
  
    # "1994-11-06T08:49:37Z"
    Mojo::Date->new(784111777)->to_datetime;
  
    # "1994-11-06T08:49:37.21Z"
    Mojo::Date->new(784111777.21)->to_datetime;
  
  =head2 to_string
  
    my $str = $date->to_string;
  
  Render date suitable for HTTP messages.
  
    # "Sun, 06 Nov 1994 08:49:37 GMT"
    Mojo::Date->new(784111777)->to_string;
  
  =head1 OPERATORS
  
  L<Mojo::Date> overloads the following operators.
  
  =head2 bool
  
    my $bool = !!$date;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$date";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_DATE

$fatpacked{"Mojo/EventEmitter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_EVENTEMITTER';
  package Mojo::EventEmitter;
  use Mojo::Base -base;
  
  use Scalar::Util qw(blessed weaken);
  
  use constant DEBUG => $ENV{MOJO_EVENTEMITTER_DEBUG} || 0;
  
  sub catch { $_[0]->on(error => $_[1]) and return $_[0] }
  
  sub emit {
    my ($self, $name) = (shift, shift);
  
    if (my $s = $self->{events}{$name}) {
      warn "-- Emit $name in @{[blessed $self]} (@{[scalar @$s]})\n" if DEBUG;
      for my $cb (@$s) { $self->$cb(@_) }
    }
    else {
      warn "-- Emit $name in @{[blessed $self]} (0)\n" if DEBUG;
      die "@{[blessed $self]}: $_[0]" if $name eq 'error';
    }
  
    return $self;
  }
  
  sub has_subscribers { !!shift->{events}{shift()} }
  
  sub on { push @{$_[0]{events}{$_[1]}}, $_[2] and return $_[2] }
  
  sub once {
    my ($self, $name, $cb) = @_;
  
    weaken $self;
    my $wrapper;
    $wrapper = sub {
      $self->unsubscribe($name => $wrapper);
      $cb->(@_);
    };
    $self->on($name => $wrapper);
    weaken $wrapper;
  
    return $wrapper;
  }
  
  sub subscribers { shift->{events}{shift()} ||= [] }
  
  sub unsubscribe {
    my ($self, $name, $cb) = @_;
  
    # One
    if ($cb) {
      $self->{events}{$name} = [grep { $cb ne $_ } @{$self->{events}{$name}}];
      delete $self->{events}{$name} unless @{$self->{events}{$name}};
    }
  
    # All
    else { delete $self->{events}{$name} }
  
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::EventEmitter - Event emitter base class
  
  =head1 SYNOPSIS
  
    package Cat;
    use Mojo::Base 'Mojo::EventEmitter';
  
    # Emit events
    sub poke {
      my $self = shift;
      $self->emit(roar => 3);
    }
  
    package main;
  
    # Subscribe to events
    my $tiger = Cat->new;
    $tiger->on(roar => sub {
      my ($tiger, $times) = @_;
      say 'RAWR!' for 1 .. $times;
    });
    $tiger->poke;
  
  =head1 DESCRIPTION
  
  L<Mojo::EventEmitter> is a simple base class for event emitting objects.
  
  =head1 EVENTS
  
  L<Mojo::EventEmitter> can emit the following events.
  
  =head2 error
  
    $e->on(error => sub {
      my ($e, $err) = @_;
      ...
    });
  
  This is a special event for errors, it will not be emitted directly by this
  class, but is fatal if unhandled. Subclasses may choose to emit it, but are not
  required to do so.
  
    $e->on(error => sub {
      my ($e, $err) = @_;
      say "This looks bad: $err";
    });
  
  =head1 METHODS
  
  L<Mojo::EventEmitter> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 catch
  
    $e = $e->catch(sub {...});
  
  Subscribe to L</"error"> event.
  
    # Longer version
    $e->on(error => sub {...});
  
  =head2 emit
  
    $e = $e->emit('foo');
    $e = $e->emit('foo', 123);
  
  Emit event.
  
  =head2 has_subscribers
  
    my $bool = $e->has_subscribers('foo');
  
  Check if event has subscribers.
  
  =head2 on
  
    my $cb = $e->on(foo => sub {...});
  
  Subscribe to event.
  
    $e->on(foo => sub {
      my ($e, @args) = @_;
      ...
    });
  
  =head2 once
  
    my $cb = $e->once(foo => sub {...});
  
  Subscribe to event and unsubscribe again after it has been emitted once.
  
    $e->once(foo => sub {
      my ($e, @args) = @_;
      ...
    });
  
  =head2 subscribers
  
    my $subscribers = $e->subscribers('foo');
  
  All subscribers for event.
  
    # Unsubscribe last subscriber
    $e->unsubscribe(foo => $e->subscribers('foo')->[-1]);
  
    # Change order of subscribers
    @{$e->subscribers('foo')} = reverse @{$e->subscribers('foo')};
  
  =head2 unsubscribe
  
    $e = $e->unsubscribe('foo');
    $e = $e->unsubscribe(foo => $cb);
  
  Unsubscribe from event.
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_EVENTEMITTER_DEBUG> environment variable to get some
  advanced diagnostics information printed to C<STDERR>.
  
    MOJO_EVENTEMITTER_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_EVENTEMITTER

$fatpacked{"Mojo/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_EXCEPTION';
  package Mojo::Exception;
  use Mojo::Base -base;
  use overload bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;
  
  use Mojo::Util 'decode';
  
  has [qw(frames line lines_after lines_before)] => sub { [] };
  has message => 'Exception!';
  has 'verbose';
  
  sub inspect {
    my ($self, @sources) = @_;
  
    # Extract file and line from message
    my @files;
    my $msg = $self->lines_before([])->line([])->lines_after([])->message;
    while ($msg =~ /at\s+(.+?)\s+line\s+(\d+)/g) { unshift @files, [$1, $2] }
  
    # Extract file and line from stack trace
    if (my $zero = $self->frames->[0]) { push @files, [$zero->[1], $zero->[2]] }
  
    # Search for context in files
    for my $file (@files) {
      next unless -r $file->[0] && open my $handle, '<', $file->[0];
      $self->_context($file->[1], [[<$handle>]]);
      return $self;
    }
  
    # Search for context in sources
    $self->_context($files[-1][1], [map { [split "\n"] } @sources]) if @sources;
  
    return $self;
  }
  
  sub new { @_ > 1 ? shift->SUPER::new(message => shift) : shift->SUPER::new }
  
  sub to_string {
    my $self = shift;
  
    my $str = $self->message;
    return $str unless $self->verbose;
  
    $str .= "\n" unless $str =~ /\n$/;
    $str .= $_->[0] . ': ' . $_->[1] . "\n" for @{$self->lines_before};
    $str .= $self->line->[0] . ': ' . $self->line->[1] . "\n" if $self->line->[0];
    $str .= $_->[0] . ': ' . $_->[1] . "\n" for @{$self->lines_after};
  
    return $str;
  }
  
  sub throw { CORE::die shift->new(shift)->trace(2)->inspect }
  
  sub trace {
    my ($self, $start) = (shift, shift // 1);
    my @frames;
    while (my @trace = caller($start++)) { push @frames, \@trace }
    return $self->frames(\@frames);
  }
  
  sub _append {
    my ($stack, $line) = @_;
    $line = decode('UTF-8', $line) // $line;
    chomp $line;
    push @$stack, $line;
  }
  
  sub _context {
    my ($self, $num, $sources) = @_;
  
    # Line
    return unless defined $sources->[0][$num - 1];
    $self->line([$num]);
    _append($self->line, $_->[$num - 1]) for @$sources;
  
    # Before
    for my $i (2 .. 6) {
      last if ((my $previous = $num - $i) < 0);
      unshift @{$self->lines_before}, [$previous + 1];
      _append($self->lines_before->[0], $_->[$previous]) for @$sources;
    }
  
    # After
    for my $i (0 .. 4) {
      next if ((my $next = $num + $i) < 0);
      next unless defined $sources->[0][$next];
      push @{$self->lines_after}, [$next + 1];
      _append($self->lines_after->[-1], $_->[$next]) for @$sources;
    }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Exception - Exceptions with context
  
  =head1 SYNOPSIS
  
    use Mojo::Exception;
  
    # Throw exception and show stack trace
    eval { Mojo::Exception->throw('Something went wrong!') };
    say "$_->[1]:$_->[2]" for @{$@->frames};
  
    # Customize exception
    eval {
      my $e = Mojo::Exception->new('Died at test.pl line 3.');
      die $e->trace(2)->inspect->verbose(1);
    };
    say $@;
  
  =head1 DESCRIPTION
  
  L<Mojo::Exception> is a container for exceptions with context information.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Exception> implements the following attributes.
  
  =head2 frames
  
    my $frames = $e->frames;
    $e         = $e->frames([$frame1, $frame2]);
  
  Stack trace if available.
  
    # Extract information from the last frame
    my ($package, $filename, $line, $subroutine, $hasargs, $wantarray, $evaltext,
        $is_require, $hints, $bitmask, $hinthash) = @{$e->frames->[-1]};
  
  =head2 line
  
    my $line = $e->line;
    $e       = $e->line([3, 'die;']);
  
  The line where the exception occurred if available.
  
  =head2 lines_after
  
    my $lines = $e->lines_after;
    $e        = $e->lines_after([[4, 'say $foo;'], [5, 'say $bar;']]);
  
  Lines after the line where the exception occurred if available.
  
  =head2 lines_before
  
    my $lines = $e->lines_before;
    $e        = $e->lines_before([[1, 'my $foo = 23;'], [2, 'my $bar = 24;']]);
  
  Lines before the line where the exception occurred if available.
  
  =head2 message
  
    my $msg = $e->message;
    $e      = $e->message('Died at test.pl line 3.');
  
  Exception message, defaults to C<Exception!>.
  
  =head2 verbose
  
    my $bool = $e->verbose;
    $e       = $e->verbose($bool);
  
  Enable context information for L</"to_string">.
  
  =head1 METHODS
  
  L<Mojo::Exception> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 inspect
  
    $e = $e->inspect;
    $e = $e->inspect($source1, $source2);
  
  Inspect L</"message">, L</"frames"> and optional additional sources to fill
  L</"lines_before">, L</"line"> and L</"lines_after"> with context information.
  
  =head2 new
  
    my $e = Mojo::Exception->new;
    my $e = Mojo::Exception->new('Died at test.pl line 3.');
  
  Construct a new L<Mojo::Exception> object and assign L</"message"> if necessary.
  
  =head2 to_string
  
    my $str = $e->to_string;
  
  Render exception.
  
    # Render exception with context
    say $e->verbose(1)->to_string;
  
  =head2 throw
  
    Mojo::Exception->throw('Something went wrong!');
  
  Throw exception from the current execution context.
  
    # Longer version
    die Mojo::Exception->new('Something went wrong!')->trace->inspect;
  
  =head2 trace
  
    $e = $e->trace;
    $e = $e->trace($skip);
  
  Generate stack trace and store all L</"frames">, defaults to skipping C<1> call
  frame.
  
    # Skip 3 call frames
    $e->trace(3);
  
    # Skip no call frames
    $e->trace(0);
  
  =head1 OPERATORS
  
  L<Mojo::Exception> overloads the following operators.
  
  =head2 bool
  
    my $bool = !!$e;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$e";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_EXCEPTION

$fatpacked{"Mojo/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_FILE';
  package Mojo::File;
  use Mojo::Base -strict;
  use overload
    '@{}'    => sub { shift->to_array },
    bool     => sub {1},
    '""'     => sub { ${$_[0]} },
    fallback => 1;
  
  use Carp 'croak';
  use Cwd 'getcwd';
  use Exporter 'import';
  use File::Basename ();
  use File::Copy qw(copy move);
  use File::Find 'find';
  use File::Path ();
  use File::Spec::Functions
    qw(abs2rel canonpath catfile file_name_is_absolute rel2abs splitdir);
  use File::Temp ();
  use IO::File   ();
  use Mojo::Collection;
  
  our @EXPORT_OK = ('path', 'tempdir', 'tempfile');
  
  sub basename { File::Basename::basename ${shift()}, @_ }
  
  sub child { $_[0]->new(@_) }
  
  sub copy_to {
    my ($self, $to) = @_;
    copy($$self, $to) or croak qq{Can't copy file "$$self" to "$to": $!};
    return $self->new(-d $to ? ($to, File::Basename::basename $self) : $to);
  }
  
  sub dirname { $_[0]->new(scalar File::Basename::dirname ${$_[0]}) }
  
  sub is_abs { file_name_is_absolute ${shift()} }
  
  sub list {
    my ($self, $options) = (shift, shift // {});
  
    return Mojo::Collection->new unless -d $$self;
    opendir(my $dir, $$self) or croak qq{Can't open directory "$$self": $!};
    my @files = grep { $_ ne '.' && $_ ne '..' } readdir $dir;
    @files = grep { !/^\./ } @files unless $options->{hidden};
    @files = map { catfile $$self, $_ } @files;
    @files = grep { !-d } @files unless $options->{dir};
  
    return Mojo::Collection->new(map { $self->new($_) } sort @files);
  }
  
  sub list_tree {
    my ($self, $options) = (shift, shift // {});
  
    # This may break in the future, but is worth it for performance
    local $File::Find::skip_pattern = qr/^\./ unless $options->{hidden};
  
    # The File::Find documentation lies, this is needed for CIFS
    local $File::Find::dont_use_nlink = 1 if $options->{dont_use_nlink};
  
    my %all;
    my $wanted = {wanted => sub { $all{$File::Find::name}++ }, no_chdir => 1};
    $wanted->{postprocess} = sub { delete $all{$File::Find::dir} }
      unless $options->{dir};
    find $wanted, $$self if -d $$self;
    delete $all{$$self};
  
    return Mojo::Collection->new(map { $self->new(canonpath $_) } sort keys %all);
  }
  
  sub make_path {
    my $self = shift;
    File::Path::make_path $$self, @_;
    return $self;
  }
  
  sub move_to {
    my ($self, $to) = @_;
    move($$self, $to) or croak qq{Can't move file "$$self" to "$to": $!};
    return $self->new(-d $to ? ($to, File::Basename::basename $self) : $to);
  }
  
  sub new {
    my $class = shift;
    my $value = @_ == 1 ? $_[0] : @_ > 1 ? catfile @_ : canonpath getcwd;
    return bless \$value, ref $class || $class;
  }
  
  sub open {
    my $self   = shift;
    my $handle = IO::File->new;
    $handle->open($$self, @_) or croak qq{Can't open file "$$self": $!};
    return $handle;
  }
  
  sub path { __PACKAGE__->new(@_) }
  
  sub realpath { $_[0]->new(Cwd::realpath ${$_[0]}) }
  
  sub remove_tree {
    my $self = shift;
    File::Path::remove_tree $$self, @_;
    return $self;
  }
  
  sub sibling {
    my $self = shift;
    return $self->new(scalar File::Basename::dirname($self), @_);
  }
  
  sub slurp {
    my $self = shift;
  
    CORE::open my $file, '<', $$self or croak qq{Can't open file "$$self": $!};
    my $ret = my $content = '';
    while ($ret = $file->sysread(my $buffer, 131072, 0)) { $content .= $buffer }
    croak qq{Can't read from file "$$self": $!} unless defined $ret;
  
    return $content;
  }
  
  sub spurt {
    my ($self, $content) = (shift, join '', @_);
    CORE::open my $file, '>', $$self or croak qq{Can't open file "$$self": $!};
    ($file->syswrite($content) // -1) == length $content
      or croak qq{Can't write to file "$$self": $!};
    return $self;
  }
  
  sub tap { shift->Mojo::Base::tap(@_) }
  
  sub tempdir { __PACKAGE__->new(File::Temp->newdir(@_)) }
  
  sub tempfile { __PACKAGE__->new(File::Temp->new(@_)) }
  
  sub to_abs { $_[0]->new(rel2abs ${$_[0]}) }
  
  sub to_array { [splitdir ${shift()}] }
  
  sub to_rel { $_[0]->new(abs2rel(${$_[0]}, $_[1])) }
  
  sub to_string {"${$_[0]}"}
  
  sub with_roles { shift->Mojo::Base::with_roles(@_) }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::File - File system paths
  
  =head1 SYNOPSIS
  
    use Mojo::File;
  
    # Portably deal with file system paths
    my $path = Mojo::File->new('/home/sri/.vimrc');
    say $path->slurp;
    say $path->dirname;
    say $path->basename;
    say $path->sibling('.bashrc');
  
    # Use the alternative constructor
    use Mojo::File 'path';
    my $path = path('/tmp/foo/bar')->make_path;
    $path->child('test.txt')->spurt('Hello Mojo!');
  
  =head1 DESCRIPTION
  
  L<Mojo::File> is a scalar-based container for file system paths that provides a
  friendly API for dealing with different operating systems.
  
    # Access scalar directly to manipulate path
    my $path = Mojo::File->new('/home/sri/test');
    $$path .= '.txt';
  
  =head1 FUNCTIONS
  
  L<Mojo::File> implements the following functions, which can be imported
  individually.
  
  =head2 path
  
    my $path = path;
    my $path = path('/home/sri/.vimrc');
    my $path = path('/home', 'sri', '.vimrc');
    my $path = path(File::Temp->newdir);
  
  Construct a new scalar-based L<Mojo::File> object, defaults to using the current
  working directory.
  
    # "foo/bar/baz.txt" (on UNIX)
    path('foo', 'bar', 'baz.txt');
  
  =head2 tempdir
  
    my $path = tempdir;
    my $path = tempdir('tempXXXXX');
  
  Construct a new scalar-based L<Mojo::File> object for a temporary directory with
  L<File::Temp>.
  
    # Longer version
    my $path = path(File::Temp->newdir('tempXXXXX'));
  
  =head2 tempfile
  
    my $path = tempfile;
    my $path = tempfile(DIR => '/tmp');
  
  Construct a new scalar-based L<Mojo::File> object for a temporary file with
  L<File::Temp>.
  
    # Longer version
    my $path = path(File::Temp->new(DIR => '/tmp'));
  
  =head1 METHODS
  
  L<Mojo::File> implements the following methods.
  
  =head2 basename
  
    my $name = $path->basename;
    my $name = $path->basename('.txt');
  
  Return the last level of the path with L<File::Basename>.
  
    # ".vimrc" (on UNIX)
    path('/home/sri/.vimrc')->basename;
  
    # "test" (on UNIX)
    path('/home/sri/test.txt')->basename('.txt');
  
  =head2 child
  
    my $child = $path->child('.vimrc');
  
  Return a new L<Mojo::File> object relative to the path.
  
    # "/home/sri/.vimrc" (on UNIX)
    path('/home')->child('sri', '.vimrc');
  
  =head2 copy_to
  
    my $destination = $path->copy_to('/home/sri');
    my $destination = $path->copy_to('/home/sri/.vimrc.backup');
  
  Copy file with L<File::Copy> and return the destination as a L<Mojo::File>
  object.
  
  =head2 dirname
  
    my $name = $path->dirname;
  
  Return all but the last level of the path with L<File::Basename> as a
  L<Mojo::File> object.
  
    # "/home/sri" (on UNIX)
    path('/home/sri/.vimrc')->dirname;
  
  =head2 is_abs
  
    my $bool = $path->is_abs;
  
  Check if the path is absolute.
  
    # True (on UNIX)
    path('/home/sri/.vimrc')->is_abs;
  
    # False (on UNIX)
    path('.vimrc')->is_abs;
  
  =head2 list
  
    my $collection = $path->list;
    my $collection = $path->list({hidden => 1});
  
  List all files in the directory and return a L<Mojo::Collection> object
  containing the results as L<Mojo::File> objects. The list does not include C<.>
  and C<..>.
  
    # List files
    say for path('/home/sri/myapp')->list->each;
  
  These options are currently available:
  
  =over 2
  
  =item dir
  
    dir => 1
  
  Include directories.
  
  =item hidden
  
    hidden => 1
  
  Include hidden files.
  
  =back
  
  =head2 list_tree
  
    my $collection = $path->list_tree;
    my $collection = $path->list_tree({hidden => 1});
  
  List all files recursively in the directory and return a L<Mojo::Collection>
  object containing the results as L<Mojo::File> objects. The list does not
  include C<.> and C<..>.
  
    # List all templates
    say for path('/home/sri/myapp/templates')->list_tree->each;
  
  These options are currently available:
  
  =over 2
  
  =item dir
  
    dir => 1
  
  Include directories.
  
  =item dont_use_nlink
  
    dont_use_nlink => 1
  
  Force L<File::Find> to always stat directories.
  
  =item hidden
  
    hidden => 1
  
  Include hidden files and directories.
  
  =back
  
  =head2 make_path
  
    $path = $path->make_path;
    $path = $path->make_path({mode => 0711});
  
  Create the directories if they don't already exist, any additional arguments are
  passed through to L<File::Path>.
  
  =head2 move_to
  
    my $destination = $path->move_to('/home/sri');
    my $destination = $path->move_to('/home/sri/.vimrc.backup');
  
  Move file with L<File::Copy> and return the destination as a L<Mojo::File>
  object.
  
  =head2 new
  
    my $path = Mojo::File->new;
    my $path = Mojo::File->new('/home/sri/.vimrc');
    my $path = Mojo::File->new('/home', 'sri', '.vimrc');
    my $path = Mojo::File->new(File::Temp->new);
    my $path = Mojo::File->new(File::Temp->newdir);
  
  Construct a new L<Mojo::File> object, defaults to using the current working
  directory.
  
    # "foo/bar/baz.txt" (on UNIX)
    Mojo::File->new('foo', 'bar', 'baz.txt');
  
  =head2 open
  
    my $handle = $path->open('+<');
    my $handle = $path->open('r+');
    my $handle = $path->open(O_RDWR);
    my $handle = $path->open('<:encoding(UTF-8)');
  
  Open file with L<IO::File>.
  
    # Combine "fcntl.h" constants
    use Fcntl qw(O_CREAT O_EXCL O_RDWR);
    my $handle = path('/home/sri/test.pl')->open(O_RDWR | O_CREAT | O_EXCL);
  
  =head2 realpath
  
    my $realpath = $path->realpath;
  
  Resolve the path with L<Cwd> and return the result as a L<Mojo::File> object.
  
  =head2 remove_tree
  
    $path = $path->remove_tree;
    $path = $path->remove_tree({keep_root => 1});
  
  Delete this directory and any files and subdirectories it may contain, any
  additional arguments are passed through to L<File::Path>.
  
  =head2 sibling
  
    my $sibling = $path->sibling('.vimrc');
  
  Return a new L<Mojo::File> object relative to the directory part of the path.
  
    # "/home/sri/.vimrc" (on UNIX)
    path('/home/sri/.bashrc')->sibling('.vimrc');
  
    # "/home/sri/.ssh/known_hosts" (on UNIX)
    path('/home/sri/.bashrc')->sibling('.ssh', 'known_hosts');
  
  =head2 slurp
  
    my $bytes = $path->slurp;
  
  Read all data at once from the file.
  
  =head2 spurt
  
    $path = $path->spurt($bytes);
    $path = $path->spurt(@chunks_of_bytes);
  
  Write all data at once to the file.
  
  =head2 tap
  
    $path = $path->tap(sub {...});
  
  Alias for L<Mojo::Base/"tap">.
  
  =head2 to_abs
  
    my $absolute = $path->to_abs;
  
  Return absolute path as a L<Mojo::File> object, the path does not need to exist
  on the file system.
  
  =head2 to_array
  
    my $parts = $path->to_array;
  
  Split the path on directory separators.
  
    # "home:sri:.vimrc" (on UNIX)
    join ':', @{path('/home/sri/.vimrc')->to_array};
  
  =head2 to_rel
  
    my $relative = $path->to_rel('/some/base/path');
  
  Return a relative path from the original path to the destination path as a
  L<Mojo::File> object.
  
    # "sri/.vimrc" (on UNIX)
    path('/home/sri/.vimrc')->to_rel('/home');
  
  =head2 to_string
  
    my $str = $path->to_string;
  
  Stringify the path.
  
  =head2 with_roles
  
    my $new_class = Mojo::File->with_roles('Mojo::File::Role::One');
    my $new_class = Mojo::File->with_roles('+One', '+Two');
    $path         = $path->with_roles('+One', '+Two');
  
  Alias for L<Mojo::Base/"with_roles">.
  
  =head1 OPERATORS
  
  L<Mojo::File> overloads the following operators.
  
  =head2 array
  
    my @parts = @$path;
  
  Alias for L</"to_array">.
  
  =head2 bool
  
    my $bool = !!$path;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$path";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_FILE

$fatpacked{"Mojo/Headers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_HEADERS';
  package Mojo::Headers;
  use Mojo::Base -base;
  
  use Mojo::Util 'monkey_patch';
  
  has max_line_size => sub { $ENV{MOJO_MAX_LINE_SIZE} || 8192 };
  has max_lines     => sub { $ENV{MOJO_MAX_LINES}     || 100 };
  
  # Common headers
  my %NAMES = map { lc() => $_ } (
    qw(Accept Accept-Charset Accept-Encoding Accept-Language Accept-Ranges),
    qw(Access-Control-Allow-Origin Allow Authorization Cache-Control Connection),
    qw(Content-Disposition Content-Encoding Content-Language Content-Length),
    qw(Content-Location Content-Range Content-Security-Policy Content-Type),
    qw(Cookie DNT Date ETag Expect Expires Host If-Modified-Since If-None-Match),
    qw(Last-Modified Link Location Origin Proxy-Authenticate),
    qw(Proxy-Authorization Range Sec-WebSocket-Accept Sec-WebSocket-Extensions),
    qw(Sec-WebSocket-Key Sec-WebSocket-Protocol Sec-WebSocket-Version Server),
    qw(Server-Timing Set-Cookie Status Strict-Transport-Security TE Trailer),
    qw(Transfer-Encoding Upgrade User-Agent Vary WWW-Authenticate)
  );
  for my $header (keys %NAMES) {
    my $name = $header;
    $name =~ y/-/_/;
    monkey_patch __PACKAGE__, $name, sub {
      my $self = shift;
      $self->{headers}{$header} = [@_] and return $self if @_;
      return undef unless my $headers = $self->{headers}{$header};
      return join ', ', @$headers;
    };
  }
  
  sub add {
    my ($self, $name) = (shift, shift);
  
    # Make sure we have a normal case entry for name
    my $key = lc $name;
    $self->{names}{$key} //= $name unless $NAMES{$key};
    push @{$self->{headers}{$key}}, @_;
  
    return $self;
  }
  
  sub append {
    my ($self, $name, $value) = @_;
    my $old = $self->header($name);
    return $self->header($name => defined $old ? "$old, $value" : $value);
  }
  
  sub clone { $_[0]->new->from_hash($_[0]->to_hash(1)) }
  
  sub every_header { shift->{headers}{lc shift} || [] }
  
  sub from_hash {
    my ($self, $hash) = @_;
  
    # Empty hash deletes all headers
    delete $self->{headers} if keys %{$hash} == 0;
  
    # Merge
    for my $header (keys %$hash) {
      my $value = $hash->{$header};
      $self->add($header => ref $value eq 'ARRAY' ? @$value : $value);
    }
  
    return $self;
  }
  
  sub header {
    my ($self, $name) = (shift, shift);
  
    # Replace
    return $self->remove($name)->add($name, @_) if @_;
  
    return undef unless my $headers = $self->{headers}{lc $name};
    return join ', ', @$headers;
  }
  
  sub is_finished { (shift->{state} // '') eq 'finished' }
  
  sub is_limit_exceeded { !!shift->{limit} }
  
  sub leftovers { delete shift->{buffer} }
  
  sub names {
    my $self = shift;
    return [map { $NAMES{$_} || $self->{names}{$_} } keys %{$self->{headers}}];
  }
  
  sub parse {
    my ($self, $chunk) = @_;
  
    $self->{state} = 'headers';
    $self->{buffer} .= $chunk;
    my $headers = $self->{cache} ||= [];
    my $size    = $self->max_line_size;
    my $lines   = $self->max_lines;
    while ($self->{buffer} =~ s/^(.*?)\x0d?\x0a//) {
      my $line = $1;
  
      # Check line size limit
      if ($+[0] > $size || @$headers >= $lines) {
        @$self{qw(state limit)} = ('finished', 1);
        return $self;
      }
  
      # New header
      if ($line =~ /^(\S[^:]*)\s*:\s*(.*)$/) { push @$headers, [$1, $2] }
  
      # Multi-line
      elsif ($line =~ s/^\s+// && @$headers) { $headers->[-1][1] .= " $line" }
  
      # Empty line
      else {
        $self->add(@$_) for @$headers;
        @$self{qw(state cache)} = ('finished', []);
        return $self;
      }
    }
  
    # Check line size limit
    @$self{qw(state limit)} = ('finished', 1) if length $self->{buffer} > $size;
  
    return $self;
  }
  
  sub referrer { shift->header(Referer => @_) }
  
  sub remove {
    my ($self, $name) = @_;
    delete $self->{headers}{lc $name};
    return $self;
  }
  
  sub to_hash {
    my ($self, $multi) = @_;
    return {map { $_ => $self->{headers}{lc $_} } @{$self->names}} if $multi;
    return {map { $_ => $self->header($_) } @{$self->names}};
  }
  
  sub to_string {
    my $self = shift;
  
    # Make sure multi-line values are formatted correctly
    my @headers;
    for my $name (@{$self->names}) {
      push @headers, "$name: $_" for @{$self->{headers}{lc $name}};
    }
  
    return join "\x0d\x0a", @headers;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Headers - HTTP headers
  
  =head1 SYNOPSIS
  
    use Mojo::Headers;
  
    # Parse
    my $headers = Mojo::Headers->new;
    $headers->parse("Content-Length: 42\x0d\x0a");
    $headers->parse("Content-Type: text/html\x0d\x0a\x0d\x0a");
    say $headers->content_length;
    say $headers->content_type;
  
    # Build
    my $headers = Mojo::Headers->new;
    $headers->content_length(42);
    $headers->content_type('text/plain');
    say $headers->to_string;
  
  =head1 DESCRIPTION
  
  L<Mojo::Headers> is a container for HTTP headers, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230> and
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Headers> implements the following attributes.
  
  =head2 max_line_size
  
    my $size = $headers->max_line_size;
    $headers = $headers->max_line_size(1024);
  
  Maximum header line size in bytes, defaults to the value of the
  C<MOJO_MAX_LINE_SIZE> environment variable or C<8192> (8KiB).
  
  =head2 max_lines
  
    my $num  = $headers->max_lines;
    $headers = $headers->max_lines(200);
  
  Maximum number of header lines, defaults to the value of the C<MOJO_MAX_LINES>
  environment variable or C<100>.
  
  =head1 METHODS
  
  L<Mojo::Headers> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 accept
  
    my $accept = $headers->accept;
    $headers   = $headers->accept('application/json');
  
  Get or replace current header value, shortcut for the C<Accept> header.
  
  =head2 accept_charset
  
    my $charset = $headers->accept_charset;
    $headers    = $headers->accept_charset('UTF-8');
  
  Get or replace current header value, shortcut for the C<Accept-Charset> header.
  
  =head2 accept_encoding
  
    my $encoding = $headers->accept_encoding;
    $headers     = $headers->accept_encoding('gzip');
  
  Get or replace current header value, shortcut for the C<Accept-Encoding> header.
  
  =head2 accept_language
  
    my $language = $headers->accept_language;
    $headers     = $headers->accept_language('de, en');
  
  Get or replace current header value, shortcut for the C<Accept-Language> header.
  
  =head2 accept_ranges
  
    my $ranges = $headers->accept_ranges;
    $headers   = $headers->accept_ranges('bytes');
  
  Get or replace current header value, shortcut for the C<Accept-Ranges> header.
  
  =head2 access_control_allow_origin
  
    my $origin = $headers->access_control_allow_origin;
    $headers   = $headers->access_control_allow_origin('*');
  
  Get or replace current header value, shortcut for the
  C<Access-Control-Allow-Origin> header from
  L<Cross-Origin Resource Sharing|http://www.w3.org/TR/cors/>.
  
  =head2 add
  
    $headers = $headers->add(Foo => 'one value');
    $headers = $headers->add(Foo => 'first value', 'second value');
  
  Add header with one or more lines.
  
    # "Vary: Accept
    #  Vary: Accept-Encoding"
    $headers->add(Vary => 'Accept')->add(Vary => 'Accept-Encoding')->to_string;
  
  =head2 allow
  
    my $allow = $headers->allow;
    $headers  = $headers->allow('GET, POST');
  
  Get or replace current header value, shortcut for the C<Allow> header.
  
  =head2 append
  
    $headers = $headers->append(Vary => 'Accept-Encoding');
  
  Append value to header and flatten it if necessary.
  
    # "Vary: Accept"
    $headers->append(Vary => 'Accept')->to_string;
  
    # "Vary: Accept, Accept-Encoding"
    $headers->vary('Accept')->append(Vary => 'Accept-Encoding')->to_string;
  
  =head2 authorization
  
    my $authorization = $headers->authorization;
    $headers          = $headers->authorization('Basic Zm9vOmJhcg==');
  
  Get or replace current header value, shortcut for the C<Authorization> header.
  
  =head2 cache_control
  
    my $cache_control = $headers->cache_control;
    $headers          = $headers->cache_control('max-age=1, no-cache');
  
  Get or replace current header value, shortcut for the C<Cache-Control> header.
  
  =head2 clone
  
    my $clone = $headers->clone;
  
  Return a new L<Mojo::Headers> object cloned from these headers.
  
  =head2 connection
  
    my $connection = $headers->connection;
    $headers       = $headers->connection('close');
  
  Get or replace current header value, shortcut for the C<Connection> header.
  
  =head2 content_disposition
  
    my $disposition = $headers->content_disposition;
    $headers        = $headers->content_disposition('foo');
  
  Get or replace current header value, shortcut for the C<Content-Disposition>
  header.
  
  =head2 content_encoding
  
    my $encoding = $headers->content_encoding;
    $headers     = $headers->content_encoding('gzip');
  
  Get or replace current header value, shortcut for the C<Content-Encoding>
  header.
  
  =head2 content_language
  
    my $language = $headers->content_language;
    $headers     = $headers->content_language('en');
  
  Get or replace current header value, shortcut for the C<Content-Language>
  header.
  
  =head2 content_length
  
    my $len  = $headers->content_length;
    $headers = $headers->content_length(4000);
  
  Get or replace current header value, shortcut for the C<Content-Length> header.
  
  =head2 content_location
  
    my $location = $headers->content_location;
    $headers     = $headers->content_location('http://127.0.0.1/foo');
  
  Get or replace current header value, shortcut for the C<Content-Location>
  header.
  
  =head2 content_range
  
    my $range = $headers->content_range;
    $headers  = $headers->content_range('bytes 2-8/100');
  
  Get or replace current header value, shortcut for the C<Content-Range> header.
  
  =head2 content_security_policy
  
    my $policy = $headers->content_security_policy;
    $headers   = $headers->content_security_policy('default-src https:');
  
  Get or replace current header value, shortcut for the C<Content-Security-Policy>
  header from L<Content Security Policy 1.0|http://www.w3.org/TR/CSP/>.
  
  =head2 content_type
  
    my $type = $headers->content_type;
    $headers = $headers->content_type('text/plain');
  
  Get or replace current header value, shortcut for the C<Content-Type> header.
  
  =head2 cookie
  
    my $cookie = $headers->cookie;
    $headers   = $headers->cookie('f=b');
  
  Get or replace current header value, shortcut for the C<Cookie> header from
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head2 date
  
    my $date = $headers->date;
    $headers = $headers->date('Sun, 17 Aug 2008 16:27:35 GMT');
  
  Get or replace current header value, shortcut for the C<Date> header.
  
  =head2 dnt
  
    my $dnt  = $headers->dnt;
    $headers = $headers->dnt(1);
  
  Get or replace current header value, shortcut for the C<DNT> (Do Not Track)
  header, which has no specification yet, but is very commonly used.
  
  =head2 etag
  
    my $etag = $headers->etag;
    $headers = $headers->etag('"abc321"');
  
  Get or replace current header value, shortcut for the C<ETag> header.
  
  =head2 every_header
  
    my $all = $headers->every_header('Location');
  
  Similar to L</"header">, but returns all headers sharing the same name as an
  array reference.
  
    # Get first header value
    say $headers->every_header('Location')->[0];
  
  =head2 expect
  
    my $expect = $headers->expect;
    $headers   = $headers->expect('100-continue');
  
  Get or replace current header value, shortcut for the C<Expect> header.
  
  =head2 expires
  
    my $expires = $headers->expires;
    $headers    = $headers->expires('Thu, 01 Dec 1994 16:00:00 GMT');
  
  Get or replace current header value, shortcut for the C<Expires> header.
  
  =head2 from_hash
  
    $headers = $headers->from_hash({'Cookie' => 'a=b'});
    $headers = $headers->from_hash({'Cookie' => ['a=b', 'c=d']});
    $headers = $headers->from_hash({});
  
  Parse headers from a hash reference, an empty hash removes all headers.
  
  =head2 header
  
    my $value = $headers->header('Foo');
    $headers  = $headers->header(Foo => 'one value');
    $headers  = $headers->header(Foo => 'first value', 'second value');
  
  Get or replace the current header values.
  
  =head2 host
  
    my $host = $headers->host;
    $headers = $headers->host('127.0.0.1');
  
  Get or replace current header value, shortcut for the C<Host> header.
  
  =head2 if_modified_since
  
    my $date = $headers->if_modified_since;
    $headers = $headers->if_modified_since('Sun, 17 Aug 2008 16:27:35 GMT');
  
  Get or replace current header value, shortcut for the C<If-Modified-Since>
  header.
  
  =head2 if_none_match
  
    my $etag = $headers->if_none_match;
    $headers = $headers->if_none_match('"abc321"');
  
  Get or replace current header value, shortcut for the C<If-None-Match> header.
  
  =head2 is_finished
  
    my $bool = $headers->is_finished;
  
  Check if header parser is finished.
  
  =head2 is_limit_exceeded
  
    my $bool = $headers->is_limit_exceeded;
  
  Check if headers have exceeded L</"max_line_size"> or L</"max_lines">.
  
  =head2 last_modified
  
    my $date = $headers->last_modified;
    $headers = $headers->last_modified('Sun, 17 Aug 2008 16:27:35 GMT');
  
  Get or replace current header value, shortcut for the C<Last-Modified> header.
  
  =head2 leftovers
  
    my $bytes = $headers->leftovers;
  
  Get and remove leftover data from header parser.
  
  =head2 link
  
    my $link = $headers->link;
    $headers = $headers->link('<http://127.0.0.1/foo/3>; rel="next"');
  
  Get or replace current header value, shortcut for the C<Link> header from
  L<RFC 5988|http://tools.ietf.org/html/rfc5988>.
  
  =head2 location
  
    my $location = $headers->location;
    $headers     = $headers->location('http://127.0.0.1/foo');
  
  Get or replace current header value, shortcut for the C<Location> header.
  
  =head2 names
  
    my $names = $headers->names;
  
  Return an array reference with all currently defined headers.
  
    # Names of all headers
    say for @{$headers->names};
  
  =head2 origin
  
    my $origin = $headers->origin;
    $headers   = $headers->origin('http://example.com');
  
  Get or replace current header value, shortcut for the C<Origin> header from
  L<RFC 6454|http://tools.ietf.org/html/rfc6454>.
  
  =head2 parse
  
    $headers = $headers->parse("Content-Type: text/plain\x0d\x0a\x0d\x0a");
  
  Parse formatted headers.
  
  =head2 proxy_authenticate
  
    my $authenticate = $headers->proxy_authenticate;
    $headers         = $headers->proxy_authenticate('Basic "realm"');
  
  Get or replace current header value, shortcut for the C<Proxy-Authenticate>
  header.
  
  =head2 proxy_authorization
  
    my $authorization = $headers->proxy_authorization;
    $headers          = $headers->proxy_authorization('Basic Zm9vOmJhcg==');
  
  Get or replace current header value, shortcut for the C<Proxy-Authorization>
  header.
  
  =head2 range
  
    my $range = $headers->range;
    $headers  = $headers->range('bytes=2-8');
  
  Get or replace current header value, shortcut for the C<Range> header.
  
  =head2 referrer
  
    my $referrer = $headers->referrer;
    $headers     = $headers->referrer('http://example.com');
  
  Get or replace current header value, shortcut for the C<Referer> header, there
  was a typo in L<RFC 2068|http://tools.ietf.org/html/rfc2068> which resulted in
  C<Referer> becoming an official header.
  
  =head2 remove
  
    $headers = $headers->remove('Foo');
  
  Remove a header.
  
  =head2 sec_websocket_accept
  
    my $accept = $headers->sec_websocket_accept;
    $headers   = $headers->sec_websocket_accept('s3pPLMBiTxaQ9kYGzzhZRbK+xOo=');
  
  Get or replace current header value, shortcut for the C<Sec-WebSocket-Accept>
  header from L<RFC 6455|http://tools.ietf.org/html/rfc6455>.
  
  =head2 sec_websocket_extensions
  
    my $extensions = $headers->sec_websocket_extensions;
    $headers       = $headers->sec_websocket_extensions('foo');
  
  Get or replace current header value, shortcut for the
  C<Sec-WebSocket-Extensions> header from
  L<RFC 6455|http://tools.ietf.org/html/rfc6455>.
  
  =head2 sec_websocket_key
  
    my $key  = $headers->sec_websocket_key;
    $headers = $headers->sec_websocket_key('dGhlIHNhbXBsZSBub25jZQ==');
  
  Get or replace current header value, shortcut for the C<Sec-WebSocket-Key>
  header from L<RFC 6455|http://tools.ietf.org/html/rfc6455>.
  
  =head2 sec_websocket_protocol
  
    my $proto = $headers->sec_websocket_protocol;
    $headers  = $headers->sec_websocket_protocol('sample');
  
  Get or replace current header value, shortcut for the C<Sec-WebSocket-Protocol>
  header from L<RFC 6455|http://tools.ietf.org/html/rfc6455>.
  
  =head2 sec_websocket_version
  
    my $version = $headers->sec_websocket_version;
    $headers    = $headers->sec_websocket_version(13);
  
  Get or replace current header value, shortcut for the C<Sec-WebSocket-Version>
  header from L<RFC 6455|http://tools.ietf.org/html/rfc6455>.
  
  =head2 server
  
    my $server = $headers->server;
    $headers   = $headers->server('Mojo');
  
  Get or replace current header value, shortcut for the C<Server> header.
  
  =head2 server_timing
  
    my $timing = $headers->server_timing;
    $headers   = $headers->server_timing('app;desc=Mojolicious;dur=0.0001');
  
  Get or replace current header value, shortcut for the C<Server-Timing> header
  from L<Server Timing|https://www.w3.org/TR/server-timing/>.
  Note that this method is EXPERIMENTAL and might change without warning!
  
  =head2 set_cookie
  
    my $cookie = $headers->set_cookie;
    $headers   = $headers->set_cookie('f=b; path=/');
  
  Get or replace current header value, shortcut for the C<Set-Cookie> header from
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head2 status
  
    my $status = $headers->status;
    $headers   = $headers->status('200 OK');
  
  Get or replace current header value, shortcut for the C<Status> header from
  L<RFC 3875|http://tools.ietf.org/html/rfc3875>.
  
  =head2 strict_transport_security
  
    my $policy = $headers->strict_transport_security;
    $headers   = $headers->strict_transport_security('max-age=31536000');
  
  Get or replace current header value, shortcut for the
  C<Strict-Transport-Security> header from
  L<RFC 6797|http://tools.ietf.org/html/rfc6797>.
  
  =head2 te
  
    my $te   = $headers->te;
    $headers = $headers->te('chunked');
  
  Get or replace current header value, shortcut for the C<TE> header.
  
  =head2 to_hash
  
    my $single = $headers->to_hash;
    my $multi  = $headers->to_hash(1);
  
  Turn headers into hash reference, array references to represent multiple
  headers with the same name are disabled by default.
  
    say $headers->to_hash->{DNT};
  
  =head2 to_string
  
    my $str = $headers->to_string;
  
  Turn headers into a string, suitable for HTTP messages.
  
  =head2 trailer
  
    my $trailer = $headers->trailer;
    $headers    = $headers->trailer('X-Foo');
  
  Get or replace current header value, shortcut for the C<Trailer> header.
  
  =head2 transfer_encoding
  
    my $encoding = $headers->transfer_encoding;
    $headers     = $headers->transfer_encoding('chunked');
  
  Get or replace current header value, shortcut for the C<Transfer-Encoding>
  header.
  
  =head2 upgrade
  
    my $upgrade = $headers->upgrade;
    $headers    = $headers->upgrade('websocket');
  
  Get or replace current header value, shortcut for the C<Upgrade> header.
  
  =head2 user_agent
  
    my $agent = $headers->user_agent;
    $headers  = $headers->user_agent('Mojo/1.0');
  
  Get or replace current header value, shortcut for the C<User-Agent> header.
  
  =head2 vary
  
    my $vary = $headers->vary;
    $headers = $headers->vary('*');
  
  Get or replace current header value, shortcut for the C<Vary> header.
  
  =head2 www_authenticate
  
    my $authenticate = $headers->www_authenticate;
    $headers         = $headers->www_authenticate('Basic realm="realm"');
  
  Get or replace current header value, shortcut for the C<WWW-Authenticate>
  header.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_HEADERS

$fatpacked{"Mojo/HelloWorld.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_HELLOWORLD';
  package Mojo::HelloWorld;
  use Mojo::Base 'Mojolicious';
  
  sub startup {
    my $self = shift;
    $self->log->level('error')->path(undef);
    $self->routes->any(
      '/*whatever' => {whatever => '', text => 'Your Mojo is working!'});
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::HelloWorld - Hello World!
  
  =head1 SYNOPSIS
  
    use Mojo::HelloWorld;
  
    my $hello = Mojo::HelloWorld->new;
    $hello->start;
  
  =head1 DESCRIPTION
  
  L<Mojo::HelloWorld> is the default L<Mojolicious> application, used mostly for
  testing.
  
  =head1 ATTRIBUTES
  
  L<Mojo::HelloWorld> inherits all attributes from L<Mojolicious>.
  
  =head1 METHODS
  
  L<Mojo::HelloWorld> inherits all methods from L<Mojolicious> and implements the
  following new ones.
  
  =head2 startup
  
    $hello->startup;
  
  Creates a catch-all route that renders a text message.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_HELLOWORLD

$fatpacked{"Mojo/Home.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_HOME';
  package Mojo::Home;
  use Mojo::Base 'Mojo::File';
  
  use Mojo::Util 'class_to_path';
  
  sub detect {
    my ($self, $class) = @_;
  
    # Environment variable
    my $home;
    if ($ENV{MOJO_HOME}) { $home = Mojo::File->new($ENV{MOJO_HOME})->to_array }
  
    # Location of the application class (Windows mixes backslash and slash)
    elsif ($class && (my $path = $INC{my $file = class_to_path $class})) {
      $home = Mojo::File->new($path)->to_array;
      splice @$home, (my @dummy = split('/', $file)) * -1;
      @$home && $home->[-1] eq $_ && pop @$home for qw(lib blib);
    }
  
    $$self = Mojo::File->new(@$home)->to_abs->to_string if $home;
    return $self;
  }
  
  sub mojo_lib_dir { shift->new(__FILE__)->sibling('..') }
  
  sub rel_file { shift->child(split('/', shift)) }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Home - Home sweet home
  
  =head1 SYNOPSIS
  
    use Mojo::Home;
  
    # Find and manage the project root directory
    my $home = Mojo::Home->new;
    $home->detect;
    say $home->child('templates', 'layouts', 'default.html.ep');
    say "$home";
  
  =head1 DESCRIPTION
  
  L<Mojo::Home> is a container for home directories based on L<Mojo::File>.
  
  =head1 METHODS
  
  L<Mojo::Home> inherits all methods from L<Mojo::File> and implements the
  following new ones.
  
  =head2 detect
  
    $home = $home->detect;
    $home = $home->detect('My::App');
  
  Detect home directory from the value of the C<MOJO_HOME> environment variable or
  the location of the application class.
  
  =head2 mojo_lib_dir
  
    my $path = $home->mojo_lib_dir;
  
  Path to C<lib> directory in which L<Mojolicious> is installed as a L<Mojo::Home>
  object.
  
  =head2 rel_file
  
    my $path = $home->rel_file('foo/bar.html');
  
  Return a new L<Mojo::Home> object relative to the home directory.
  
  =head1 OPERATORS
  
  L<Mojo::Home> inherits all overloaded operators from L<Mojo::File>.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_HOME

$fatpacked{"Mojo/IOLoop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP';
  package Mojo::IOLoop;
  use Mojo::Base 'Mojo::EventEmitter';
  
  # "Professor: Amy, technology isn't intrinsically good or evil. It's how it's
  #             used. Like the death ray."
  use Carp 'croak';
  use Mojo::IOLoop::Client;
  use Mojo::IOLoop::Delay;
  use Mojo::IOLoop::Server;
  use Mojo::IOLoop::Stream;
  use Mojo::IOLoop::Subprocess;
  use Mojo::Reactor::Poll;
  use Mojo::Util qw(md5_sum steady_time);
  use Scalar::Util qw(blessed weaken);
  
  use constant DEBUG => $ENV{MOJO_IOLOOP_DEBUG} || 0;
  
  has max_accepts     => 0;
  has max_connections => 1000;
  has reactor         => sub {
    my $class = Mojo::Reactor::Poll->detect;
    warn "-- Reactor initialized ($class)\n" if DEBUG;
    return $class->new->catch(sub { warn "@{[blessed $_[0]]}: $_[1]" });
  };
  
  # Ignore PIPE signal
  $SIG{PIPE} = 'IGNORE';
  
  # Initialize singleton reactor early
  __PACKAGE__->singleton->reactor;
  
  sub acceptor {
    my ($self, $acceptor) = (_instance(shift), @_);
  
    # Find acceptor for id
    return $self->{acceptors}{$acceptor} unless ref $acceptor;
  
    # Connect acceptor with reactor
    $self->{acceptors}{my $id = $self->_id} = $acceptor;
    weaken $acceptor->reactor($self->reactor)->{reactor};
  
    # Allow new acceptor to get picked up
    $self->_not_accepting->_maybe_accepting;
  
    return $id;
  }
  
  sub client {
    my ($self, $cb) = (_instance(shift), pop);
    my $args = ref $_[0] ? $_[0] : {@_};
  
    my $id = $self->_id;
    my $client = $self->{out}{$id}{client} = Mojo::IOLoop::Client->new;
    weaken $client->reactor($self->reactor)->{reactor};
    my $class = delete $args->{stream_class} || 'Mojo::IOLoop::Stream';
  
    weaken $self;
    $client->on(
      connect => sub {
        delete $self->{out}{$id}{client};
        my $stream = $class->new(pop);
        $self->_stream($stream => $id);
        $self->$cb(undef, $stream);
      }
    );
    $client->on(error => sub { $self->_remove($id); $self->$cb(pop, undef) });
    $client->connect($args);
  
    return $id;
  }
  
  sub delay {
    my $delay = Mojo::IOLoop::Delay->new;
    weaken $delay->ioloop(_instance(shift))->{ioloop};
    return @_ ? $delay->steps(@_) : $delay;
  }
  
  sub is_running { _instance(shift)->reactor->is_running }
  
  sub next_tick {
    my ($self, $cb) = (_instance(shift), @_);
    weaken $self;
    return $self->reactor->next_tick(sub { $self->$cb });
  }
  
  sub one_tick {
    my $self = _instance(shift);
    croak 'Mojo::IOLoop already running' if $self->is_running;
    $self->reactor->one_tick;
  }
  
  sub recurring { shift->_timer(recurring => @_) }
  
  sub remove {
    my ($self, $id) = (_instance(shift), @_);
    my $c = $self->{in}{$id} || $self->{out}{$id};
    if ($c && (my $stream = $c->{stream})) { return $stream->close_gracefully }
    $self->_remove($id);
  }
  
  sub reset {
    my $self = _instance(shift);
    delete @$self{qw(accepting acceptors events in out stop)};
    $self->reactor->reset;
    $self->stop;
  }
  
  sub server {
    my ($self, $cb) = (_instance(shift), pop);
    my $args = ref $_[0] ? $_[0] : {@_};
  
    my $server = Mojo::IOLoop::Server->new;
    my $class = delete $args->{stream_class} || 'Mojo::IOLoop::Stream';
    weaken $self;
    $server->on(
      accept => sub {
        my $stream = $class->new(pop);
        $self->$cb($stream, $self->_stream($stream, $self->_id, 1));
  
        # Enforce connection limit (randomize to improve load balancing)
        if (my $max = $self->max_accepts) {
          $self->{accepts} //= $max - int rand $max / 2;
          $self->stop_gracefully if ($self->{accepts} -= 1) <= 0;
        }
  
        # Stop accepting if connection limit has been reached
        $self->_not_accepting if $self->_limit;
      }
    );
    $server->listen($args);
  
    return $self->acceptor($server);
  }
  
  sub singleton { state $loop = shift->SUPER::new }
  
  sub start {
    my $self = _instance(shift);
    croak 'Mojo::IOLoop already running' if $self->is_running;
    $self->reactor->start;
  }
  
  sub stop { _instance(shift)->reactor->stop }
  
  sub stop_gracefully {
    my $self = _instance(shift)->_not_accepting;
    ++$self->{stop} and !$self->emit('finish')->_in and $self->stop;
  }
  
  sub stream {
    my ($self, $stream) = (_instance(shift), @_);
    return $self->_stream($stream => $self->_id) if ref $stream;
    my $c = $self->{in}{$stream} || $self->{out}{$stream} || {};
    return $c->{stream};
  }
  
  sub subprocess {
    my $subprocess = Mojo::IOLoop::Subprocess->new;
    weaken $subprocess->ioloop(_instance(shift))->{ioloop};
    return @_ ? $subprocess->run(@_) : $subprocess;
  }
  
  sub timer { shift->_timer(timer => @_) }
  
  sub transition {
    my ($self, $id, $class) = (_instance(shift), @_);
    my $new = $class->new($self->stream($id)->steal_handle);
    $self->_stream($new, $id, !!$self->{in}{$id});
    return $new;
  }
  
  sub _id {
    my $self = shift;
    my $id;
    do { $id = md5_sum 'c' . steady_time . rand }
      while $self->{in}{$id} || $self->{out}{$id} || $self->{acceptors}{$id};
    return $id;
  }
  
  sub _in { scalar keys %{shift->{in} || {}} }
  
  sub _instance { ref $_[0] ? $_[0] : $_[0]->singleton }
  
  sub _limit { $_[0]{stop} ? 1 : $_[0]->_in >= $_[0]->max_connections }
  
  sub _maybe_accepting {
    my $self = shift;
    return if $self->{accepting} || $self->_limit;
    $_->start for values %{$self->{acceptors} || {}};
    $self->{accepting} = 1;
  }
  
  sub _not_accepting {
    my $self = shift;
    return $self unless delete $self->{accepting};
    $_->stop for values %{$self->{acceptors} || {}};
    return $self;
  }
  
  sub _out { scalar keys %{shift->{out} || {}} }
  
  sub _remove {
    my ($self, $id) = @_;
  
    # Timer
    return unless my $reactor = $self->reactor;
    return if $reactor->remove($id);
  
    # Acceptor
    return $self->_not_accepting->_maybe_accepting
      if delete $self->{acceptors}{$id};
  
    # Connection
    return unless delete $self->{in}{$id} || delete $self->{out}{$id};
    return $self->stop if $self->{stop} && !$self->_in;
    $self->_maybe_accepting;
    warn "-- $id <<< $$ (@{[$self->_in]}:@{[$self->_out]})\n" if DEBUG;
  }
  
  sub _stream {
    my ($self, $stream, $id, $server) = @_;
  
    # Connect stream with reactor
    $self->{$server ? 'in' : 'out'}{$id}{stream} = $stream;
    warn "-- $id >>> $$ (@{[$self->_in]}:@{[$self->_out]})\n" if DEBUG;
    weaken $stream->reactor($self->reactor)->{reactor};
    weaken $self;
    $stream->on(close => sub { $self && $self->_remove($id) });
    $stream->start;
  
    return $id;
  }
  
  sub _timer {
    my ($self, $method, $after, $cb) = (_instance(shift), @_);
    weaken $self;
    return $self->reactor->$method($after => sub { $self->$cb });
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop - Minimalistic event loop
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop;
  
    # Listen on port 3000
    Mojo::IOLoop->server({port => 3000} => sub {
      my ($loop, $stream) = @_;
  
      $stream->on(read => sub {
        my ($stream, $bytes) = @_;
  
        # Process input chunk
        say $bytes;
  
        # Write response
        $stream->write('HTTP/1.1 200 OK');
      });
    });
  
    # Connect to port 3000
    my $id = Mojo::IOLoop->client({port => 3000} => sub {
      my ($loop, $err, $stream) = @_;
  
      $stream->on(read => sub {
        my ($stream, $bytes) = @_;
  
        # Process input
        say "Input: $bytes";
      });
  
      # Write request
      $stream->write("GET / HTTP/1.1\x0d\x0a\x0d\x0a");
    });
  
    # Add a timer
    Mojo::IOLoop->timer(5 => sub {
      my $loop = shift;
      $loop->remove($id);
    });
  
    # Start event loop if necessary
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop> is a very minimalistic event loop based on L<Mojo::Reactor>, it
  has been reduced to the absolute minimal feature set required to build solid
  and scalable non-blocking clients and servers.
  
  Depending on operating system, the default per-process and system-wide file
  descriptor limits are often very low and need to be tuned for better
  scalability. The C<LIBEV_FLAGS> environment variable should also be used to
  select the best possible L<EV> backend, which usually defaults to the not very
  scalable C<select>.
  
    LIBEV_FLAGS=1   # select
    LIBEV_FLAGS=2   # poll
    LIBEV_FLAGS=4   # epoll (Linux)
    LIBEV_FLAGS=8   # kqueue (*BSD, OS X)
  
  The event loop will be resilient to time jumps if a monotonic clock is
  available through L<Time::HiRes>. A TLS certificate and key are also built
  right in, to make writing test servers as easy as possible. Also note that for
  convenience the C<PIPE> signal will be set to C<IGNORE> when L<Mojo::IOLoop> is
  loaded.
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (2.009+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NNR>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"REAL-TIME WEB"> for more.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop> inherits all events from L<Mojo::EventEmitter> and can emit the
  following new ones.
  
  =head2 finish
  
    $loop->on(finish => sub {
      my $loop = shift;
      ...
    });
  
  Emitted when the event loop wants to shut down gracefully and is just waiting
  for all existing connections to be closed.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop> implements the following attributes.
  
  =head2 max_accepts
  
    my $max = $loop->max_accepts;
    $loop   = $loop->max_accepts(1000);
  
  The maximum number of connections this event loop is allowed to accept, before
  shutting down gracefully without interrupting existing connections, defaults to
  C<0>. Setting the value to C<0> will allow this event loop to accept new
  connections indefinitely. Note that up to half of this value can be subtracted
  randomly to improve load balancing between multiple server processes, and to
  make sure that not all of them restart at the same time.
  
  =head2 max_connections
  
    my $max = $loop->max_connections;
    $loop   = $loop->max_connections(100);
  
  The maximum number of accepted connections this event loop is allowed to handle
  concurrently, before stopping to accept new incoming connections, defaults to
  C<1000>.
  
  =head2 reactor
  
    my $reactor = $loop->reactor;
    $loop       = $loop->reactor(Mojo::Reactor->new);
  
  Low-level event reactor, usually a L<Mojo::Reactor::Poll> or
  L<Mojo::Reactor::EV> object with a default subscriber to the event
  L<Mojo::Reactor/"error">.
  
    # Watch if handle becomes readable or writable
    Mojo::IOLoop->singleton->reactor->io($handle => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Handle is writable' : 'Handle is readable';
    });
  
    # Change to watching only if handle becomes writable
    Mojo::IOLoop->singleton->reactor->watch($handle, 0, 1);
  
    # Remove handle again
    Mojo::IOLoop->singleton->reactor->remove($handle);
  
  =head1 METHODS
  
  L<Mojo::IOLoop> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 acceptor
  
    my $server = Mojo::IOLoop->acceptor($id);
    my $server = $loop->acceptor($id);
    my $id     = $loop->acceptor(Mojo::IOLoop::Server->new);
  
  Get L<Mojo::IOLoop::Server> object for id or turn object into an acceptor.
  
  =head2 client
  
    my $id
      = Mojo::IOLoop->client(address => '127.0.0.1', port => 3000, sub {...});
    my $id = $loop->client(address => '127.0.0.1', port => 3000, sub {...});
    my $id = $loop->client({address => '127.0.0.1', port => 3000} => sub {...});
  
  Open a TCP/IP or UNIX domain socket connection with L<Mojo::IOLoop::Client> and
  create a stream object (usually L<Mojo::IOLoop::Stream>), takes the same
  arguments as L<Mojo::IOLoop::Client/"connect"> in addition to C<stream_class>.
  
    # Connect to 127.0.0.1 on port 3000 with a custom stream class
    my $class = 'Mojo::IOLoop::Stream::HTTPClient';
    Mojo::IOLoop->client({port => 3000, stream_class => $class} => sub {
      my ($loop, $err, $stream) = @_;
      ...
    });
  
  =head2 delay
  
    my $delay = Mojo::IOLoop->delay;
    my $delay = $loop->delay;
    my $delay = $loop->delay(sub {...});
    my $delay = $loop->delay(sub {...}, sub {...});
  
  Build L<Mojo::IOLoop::Delay> object to use as a promise and/or for flow-control.
  Callbacks will be passed along to L<Mojo::IOLoop::Delay/"steps">.
  
    # Wrap continuation-passing style APIs with promises
    my $ua = Mojo::UserAgent->new;
    sub get {
      my $promise = Mojo::IOLoop->delay;
      $ua->get(@_ => sub {
        my ($ua, $tx) = @_;
        my $err = $tx->error;
        $promise->resolve($tx) if !$err || $err->{code};
        $promise->reject($err->{message});
      });
      return $promise;
    }
    my $mojo = get('https://mojolicious.org');
    my $cpan = get('https://metacpan.org');
    Mojo::Promise->race($mojo, $cpan)->then(sub { say shift->req->url })->wait;
  
    # Synchronize multiple non-blocking operations
    my $delay = Mojo::IOLoop->delay(sub { say 'BOOM!' });
    for my $i (1 .. 10) {
      my $end = $delay->begin;
      Mojo::IOLoop->timer($i => sub {
        say 10 - $i;
        $end->();
      });
    }
    $delay->wait;
  
    # Sequentialize multiple non-blocking operations
    Mojo::IOLoop->delay(
  
      # First step (simple timer)
      sub {
        my $delay = shift;
        Mojo::IOLoop->timer(2 => $delay->begin);
        say 'Second step in 2 seconds.';
      },
  
      # Second step (concurrent timers)
      sub {
        my $delay = shift;
        Mojo::IOLoop->timer(1 => $delay->begin);
        Mojo::IOLoop->timer(3 => $delay->begin);
        say 'Third step in 3 seconds.';
      },
  
      # Third step (the end)
      sub { say 'And done after 5 seconds total.' }
    )->wait;
  
  =head2 is_running
  
    my $bool = Mojo::IOLoop->is_running;
    my $bool = $loop->is_running;
  
  Check if event loop is running.
  
    exit unless Mojo::IOLoop->is_running;
  
  =head2 next_tick
  
    my $undef = Mojo::IOLoop->next_tick(sub {...});
    my $undef = $loop->next_tick(sub {...});
  
  Execute callback as soon as possible, but not before returning or other
  callbacks that have been registered with this method, always returns C<undef>.
  
    # Perform operation on next reactor tick
    Mojo::IOLoop->next_tick(sub {
      my $loop = shift;
      ...
    });
  
  =head2 one_tick
  
    Mojo::IOLoop->one_tick;
    $loop->one_tick;
  
  Run event loop until an event occurs.
  
    # Don't block longer than 0.5 seconds
    my $id = Mojo::IOLoop->timer(0.5 => sub {});
    Mojo::IOLoop->one_tick;
    Mojo::IOLoop->remove($id);
  
  =head2 recurring
  
    my $id = Mojo::IOLoop->recurring(3 => sub {...});
    my $id = $loop->recurring(0 => sub {...});
    my $id = $loop->recurring(0.25 => sub {...});
  
  Create a new recurring timer, invoking the callback repeatedly after a given
  amount of time in seconds.
  
    # Perform operation every 5 seconds
    Mojo::IOLoop->recurring(5 => sub {
      my $loop = shift;
      ...
    });
  
  =head2 remove
  
    Mojo::IOLoop->remove($id);
    $loop->remove($id);
  
  Remove anything with an id, connections will be dropped gracefully by allowing
  them to finish writing all data in their write buffers.
  
  =head2 reset
  
    Mojo::IOLoop->reset;
    $loop->reset;
  
  Remove everything and stop the event loop.
  
  =head2 server
  
    my $id = Mojo::IOLoop->server(port => 3000, sub {...});
    my $id = $loop->server(port => 3000, sub {...});
    my $id = $loop->server({port => 3000} => sub {...});
  
  Accept TCP/IP and UNIX domain socket connections with L<Mojo::IOLoop::Server>
  and create stream objects (usually L<Mojo::IOLoop::Stream>, takes the same
  arguments as L<Mojo::IOLoop::Server/"listen"> in addition to C<stream_class>.
  
    # Listen on port 3000 with a custom stream class
    my $class = 'Mojo::IOLoop::Stream::HTTPServer';
    Mojo::IOLoop->server({port => 3000, stream_class => $class} => sub {
      my ($loop, $stream, $id) = @_;
      ...
    });
  
    # Listen on random port
    my $id = Mojo::IOLoop->server({address => '127.0.0.1'} => sub {
      my ($loop, $stream, $id) = @_;
      ...
    });
    my $port = Mojo::IOLoop->acceptor($id)->port;
  
  =head2 singleton
  
    my $loop = Mojo::IOLoop->singleton;
  
  The global L<Mojo::IOLoop> singleton, used to access a single shared event loop
  object from everywhere inside the process.
  
    # Many methods also allow you to take shortcuts
    Mojo::IOLoop->timer(2 => sub { Mojo::IOLoop->stop });
    Mojo::IOLoop->start;
  
    # Restart active timer
    my $id = Mojo::IOLoop->timer(3 => sub { say 'Timeout!' });
    Mojo::IOLoop->singleton->reactor->again($id);
  
    # Turn file descriptor into handle and watch if it becomes readable
    my $handle = IO::Handle->new_from_fd($fd, 'r');
    Mojo::IOLoop->singleton->reactor->io($handle => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Handle is writable' : 'Handle is readable';
    })->watch($handle, 1, 0);
  
  =head2 start
  
    Mojo::IOLoop->start;
    $loop->start;
  
  Start the event loop, this will block until L</"stop"> is called. Note that
  some reactors stop automatically if there are no events being watched anymore.
  
    # Start event loop only if it is not running already
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 stop
  
    Mojo::IOLoop->stop;
    $loop->stop;
  
  Stop the event loop, this will not interrupt any existing connections and the
  event loop can be restarted by running L</"start"> again.
  
  =head2 stop_gracefully
  
    Mojo::IOLoop->stop_gracefully;
    $loop->stop_gracefully;
  
  Stop accepting new connections and wait for already accepted connections to be
  closed, before stopping the event loop.
  
  =head2 stream
  
    my $stream = Mojo::IOLoop->stream($id);
    my $stream = $loop->stream($id);
    my $id     = $loop->stream(Mojo::IOLoop::Stream->new);
  
  Get L<Mojo::IOLoop::Stream> object for id or turn object into a connection.
  
    # Increase inactivity timeout for connection to 300 seconds
    Mojo::IOLoop->stream($id)->timeout(300);
  
  =head2 subprocess
  
    my $subprocess = Mojo::IOLoop->subprocess(sub {...}, sub {...});
    my $subprocess = $loop->subprocess;
    my $subprocess = $loop->subprocess(sub {...}, sub {...});
  
  Build L<Mojo::IOLoop::Subprocess> object to perform computationally expensive
  operations in subprocesses, without blocking the event loop. Callbacks will be
  passed along to L<Mojo::IOLoop::Subprocess/"run">.
  
    # Operation that would block the event loop for 5 seconds
    Mojo::IOLoop->subprocess(
      sub {
        my $subprocess = shift;
        sleep 5;
        return '', 'Mojolicious';
      },
      sub {
        my ($subprocess, $err, @results) = @_;
        say "Subprocess error: $err" and return if $err;
        say "I $results[0] $results[1]!";
      }
    );
  
  =head2 timer
  
    my $id = Mojo::IOLoop->timer(3 => sub {...});
    my $id = $loop->timer(0 => sub {...});
    my $id = $loop->timer(0.25 => sub {...});
  
  Create a new timer, invoking the callback after a given amount of time in
  seconds.
  
    # Perform operation in 5 seconds
    Mojo::IOLoop->timer(5 => sub {
      my $loop = shift;
      ...
    });
  
  =head2 transition
  
    my $stream =
      Mojo::IOLoop->transition($id => 'Mojo::IOLoop::Stream::HTTPClient');
    my $stream = $loop->transition($id => 'Mojo::IOLoop::Stream::HTTPClient');
  
  Transition stream to a different class.
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_IOLOOP_DEBUG> environment variable to get some advanced
  diagnostics information printed to C<STDERR>.
  
    MOJO_IOLOOP_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_IOLOOP

$fatpacked{"Mojo/IOLoop/Client.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_CLIENT';
  package Mojo::IOLoop::Client;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Errno 'EINPROGRESS';
  use IO::Socket::IP;
  use IO::Socket::UNIX;
  use Mojo::IOLoop;
  use Mojo::IOLoop::TLS;
  use Scalar::Util 'weaken';
  use Socket qw(IPPROTO_TCP SOCK_STREAM TCP_NODELAY);
  
  # Non-blocking name resolution requires Net::DNS::Native
  use constant NNR => $ENV{MOJO_NO_NNR}
    ? 0
    : eval { require Net::DNS::Native; Net::DNS::Native->VERSION('0.15'); 1 };
  my $NDN;
  
  # SOCKS support requires IO::Socket::Socks
  use constant SOCKS => $ENV{MOJO_NO_SOCKS}
    ? 0
    : eval { require IO::Socket::Socks; IO::Socket::Socks->VERSION('0.64'); 1 };
  use constant READ  => SOCKS ? IO::Socket::Socks::SOCKS_WANT_READ()  : 0;
  use constant WRITE => SOCKS ? IO::Socket::Socks::SOCKS_WANT_WRITE() : 0;
  
  has reactor => sub { Mojo::IOLoop->singleton->reactor };
  
  sub DESTROY { shift->_cleanup }
  
  sub can_nnr   {NNR}
  sub can_socks {SOCKS}
  
  sub connect {
    my ($self, $args) = (shift, ref $_[0] ? $_[0] : {@_});
  
    # Timeout
    weaken $self;
    my $reactor = $self->reactor;
    $self->{timer} = $reactor->timer($args->{timeout} || 10,
      sub { $self->emit(error => 'Connect timeout') });
  
    # Blocking name resolution
    $_ && s/[[\]]//g for @$args{qw(address socks_address)};
    my $address = $args->{socks_address} || ($args->{address} ||= '127.0.0.1');
    return $reactor->next_tick(sub { $self && $self->_connect($args) })
      if !NNR || $args->{handle} || $args->{path};
  
    # Non-blocking name resolution
    $NDN //= Net::DNS::Native->new(pool => 5, extra_thread => 1);
    my $handle = $self->{dns} = $NDN->getaddrinfo($address, _port($args),
      {protocol => IPPROTO_TCP, socktype => SOCK_STREAM});
    $reactor->io(
      $handle => sub {
        my $reactor = shift;
  
        $reactor->remove($self->{dns});
        my ($err, @res) = $NDN->get_result(delete $self->{dns});
        return $self->emit(error => "Can't resolve: $err") if $err;
  
        $args->{addr_info} = \@res;
        $self->_connect($args);
      }
    )->watch($handle, 1, 0);
  }
  
  sub _cleanup {
    my $self = shift;
    $NDN->timedout($self->{dns}) if $NDN && $self->{dns};
    return unless my $reactor = $self->reactor;
    $self->{$_} && $reactor->remove(delete $self->{$_}) for qw(dns timer handle);
    return $self;
  }
  
  sub _connect {
    my ($self, $args) = @_;
  
    my $path = $args->{path};
    my $handle = $self->{handle} = $args->{handle};
  
    unless ($handle) {
      my $class = $path ? 'IO::Socket::UNIX' : 'IO::Socket::IP';
      my %options = (Blocking => 0);
  
      # UNIX domain socket
      if ($path) { $options{Peer} = $path }
  
      # IP socket
      else {
        if (my $info = $args->{addr_info}) { $options{PeerAddrInfo} = $info }
        else {
          $options{PeerAddr} = $args->{socks_address} || $args->{address};
          $options{PeerPort} = _port($args);
        }
        $options{LocalAddr} = $args->{local_address} if $args->{local_address};
      }
  
      return $self->emit(error => "Can't connect: $@")
        unless $self->{handle} = $handle = $class->new(%options);
    }
    $handle->blocking(0);
  
    $path ? $self->_try_socks($args) : $self->_wait('_ready', $handle, $args);
  }
  
  sub _port { $_[0]{socks_port} || $_[0]{port} || ($_[0]{tls} ? 443 : 80) }
  
  sub _ready {
    my ($self, $args) = @_;
  
    # Socket changes in between attempts and needs to be re-added for epoll/kqueue
    my $handle = $self->{handle};
    unless ($handle->connect) {
      return $self->emit(error => $!) unless $! == EINPROGRESS;
      $self->reactor->remove($handle);
      return $self->_wait('_ready', $handle, $args);
    }
  
    return $self->emit(error => $! || 'Not connected') unless $handle->connected;
  
    # Disable Nagle's algorithm
    setsockopt $handle, IPPROTO_TCP, TCP_NODELAY, 1;
  
    $self->_try_socks($args);
  }
  
  sub _socks {
    my ($self, $args) = @_;
  
    # Connected
    my $handle = $self->{handle};
    return $self->_try_tls($args) if $handle->ready;
  
    # Switch between reading and writing
    my $err = $IO::Socket::Socks::SOCKS_ERROR;
    if    ($err == READ)  { $self->reactor->watch($handle, 1, 0) }
    elsif ($err == WRITE) { $self->reactor->watch($handle, 1, 1) }
    else                  { $self->emit(error => $err) }
  }
  
  sub _try_socks {
    my ($self, $args) = @_;
  
    my $handle = $self->{handle};
    return $self->_try_tls($args) unless $args->{socks_address};
    return $self->emit(
      error => 'IO::Socket::Socks 0.64+ required for SOCKS support')
      unless SOCKS;
  
    my %options = (ConnectAddr => $args->{address}, ConnectPort => $args->{port});
    @options{qw(AuthType Username Password)}
      = ('userpass', @$args{qw(socks_user socks_pass)})
      if $args->{socks_user};
    my $reactor = $self->reactor;
    $reactor->remove($handle);
    return $self->emit(error => 'SOCKS upgrade failed')
      unless IO::Socket::Socks->start_SOCKS($handle, %options);
  
    $self->_wait('_socks', $handle, $args);
  }
  
  sub _try_tls {
    my ($self, $args) = @_;
  
    my $handle = $self->{handle};
    return $self->_cleanup->emit(connect => $handle) unless $args->{tls};
    my $reactor = $self->reactor;
    $reactor->remove($handle);
  
    # Start TLS handshake
    weaken $self;
    my $tls = Mojo::IOLoop::TLS->new($handle)->reactor($self->reactor);
    $tls->on(upgrade => sub { $self->_cleanup->emit(connect => pop) });
    $tls->on(error => sub { $self->emit(error => pop) });
    $tls->negotiate(%$args);
  }
  
  sub _wait {
    my ($self, $next, $handle, $args) = @_;
    weaken $self;
    $self->reactor->io($handle => sub { $self->$next($args) })
      ->watch($handle, 0, 1);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Client - Non-blocking TCP/IP and UNIX domain socket client
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Client;
  
    # Create socket connection
    my $client = Mojo::IOLoop::Client->new;
    $client->on(connect => sub {
      my ($client, $handle) = @_;
      ...
    });
    $client->on(error => sub {
      my ($client, $err) = @_;
      ...
    });
    $client->connect(address => 'example.com', port => 80);
  
    # Start reactor if necessary
    $client->reactor->start unless $client->reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Client> opens TCP/IP and UNIX domain socket connections for
  L<Mojo::IOLoop>.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Client> inherits all events from L<Mojo::EventEmitter> and can
  emit the following new ones.
  
  =head2 connect
  
    $client->on(connect => sub {
      my ($client, $handle) = @_;
      ...
    });
  
  Emitted once the connection is established.
  
  =head2 error
  
    $client->on(error => sub {
      my ($client, $err) = @_;
      ...
    });
  
  Emitted if an error occurs on the connection, fatal if unhandled.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Client> implements the following attributes.
  
  =head2 reactor
  
    my $reactor = $client->reactor;
    $client     = $client->reactor(Mojo::Reactor::Poll->new);
  
  Low-level event reactor, defaults to the C<reactor> attribute value of the
  global L<Mojo::IOLoop> singleton.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Client> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 can_nnr
  
    my $bool = Mojo::IOLoop::Client->can_nnr;
  
  True if L<Net::DNS::Native> 0.15+ is installed and non-blocking name resolution
  support enabled.
  
  =head2 can_socks
  
    my $bool = Mojo::IOLoop::Client->can_socks;
  
  True if L<IO::Socket::SOCKS> 0.64+ is installed and SOCKS5 support enabled.
  
  =head2 connect
  
    $client->connect(address => '127.0.0.1', port => 3000);
    $client->connect({address => '127.0.0.1', port => 3000});
  
  Open a socket connection to a remote host. Note that non-blocking name
  resolution depends on L<Net::DNS::Native> (0.15+), SOCKS5 support on
  L<IO::Socket::Socks> (0.64), and TLS support on L<IO::Socket::SSL> (2.009+).
  
  These options are currently available:
  
  =over 2
  
  =item address
  
    address => 'mojolicious.org'
  
  Address or host name of the peer to connect to, defaults to C<127.0.0.1>.
  
  =item handle
  
    handle => $handle
  
  Use an already prepared L<IO::Socket::IP> object.
  
  =item local_address
  
    local_address => '127.0.0.1'
  
  Local address to bind to.
  
  =item path
  
    path => '/tmp/myapp.sock'
  
  Path of UNIX domain socket to connect to.
  
  =item port
  
    port => 80
  
  Port to connect to, defaults to C<80> or C<443> with C<tls> option.
  
  =item socks_address
  
    socks_address => '127.0.0.1'
  
  Address or host name of SOCKS5 proxy server to use for connection.
  
  =item socks_pass
  
    socks_pass => 'secr3t'
  
  Password to use for SOCKS5 authentication.
  
  =item socks_port
  
    socks_port => 9050
  
  Port of SOCKS5 proxy server to use for connection.
  
  =item socks_user
  
    socks_user => 'sri'
  
  Username to use for SOCKS5 authentication.
  
  =item timeout
  
    timeout => 15
  
  Maximum amount of time in seconds establishing connection may take before
  getting canceled, defaults to C<10>.
  
  =item tls
  
    tls => 1
  
  Enable TLS.
  
  =item tls_ca
  
    tls_ca => '/etc/tls/ca.crt'
  
  Path to TLS certificate authority file.
  
  =item tls_cert
  
    tls_cert => '/etc/tls/client.crt'
  
  Path to the TLS certificate file.
  
  =item tls_key
  
    tls_key => '/etc/tls/client.key'
  
  Path to the TLS key file.
  
  =item tls_protocols
  
    tls_protocols => ['foo', 'bar']
  
  ALPN protocols to negotiate.
  
  =item tls_verify
  
    tls_verify => 0x00
  
  TLS verification mode.
  
  =back
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_IOLOOP_CLIENT

$fatpacked{"Mojo/IOLoop/Delay.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_DELAY';
  package Mojo::IOLoop::Delay;
  use Mojo::Base 'Mojo::Promise';
  
  # DEPRECATED!
  use base 'Mojo::EventEmitter';
  
  sub begin {
    my ($self, $offset, $len) = @_;
    $self->{pending}++;
    my $id = $self->{counter}++;
    return sub { $self->_step($id, $offset // 1, $len, @_) };
  }
  
  sub pass { $_[0]->begin->(@_) }
  
  sub steps {
    my ($self, @steps) = @_;
    $self->{steps} = \@steps;
    $self->ioloop->next_tick($self->begin);
  
    # DEPRECATED!
    $self->{deprecated} ||= $self->on(error => sub { });
  
    return $self;
  }
  
  sub _step {
    my ($self, $id, $offset, $len) = (shift, shift, shift, shift);
  
    $self->{args}[$id]
      = [@_ ? defined $len ? splice @_, $offset, $len : splice @_, $offset : ()];
    return $self if $self->{fail} || --$self->{pending} || $self->{lock};
    local $self->{lock} = 1;
    my @args = map {@$_} @{delete $self->{args}};
  
    $self->{counter} = 0;
    if (my $cb = shift @{$self->{steps}}) {
      unless (eval { $self->$cb(@args); 1 }) {
        my $err = $@;
        @{$self}{qw(fail steps)} = (1, []);
        return $self->reject($err)->emit(error => $err);
      }
    }
  
    ($self->{steps} = []) and return $self->resolve(@args)->emit(finish => @args)
      unless $self->{counter};
    $self->ioloop->next_tick($self->begin) unless $self->{pending};
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Delay - Promises/A+ and flow-control helpers
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Delay;
  
    # Synchronize multiple non-blocking operations
    my $delay = Mojo::IOLoop::Delay->new;
    $delay->steps(sub { say 'BOOM!' });
    for my $i (1 .. 10) {
      my $end = $delay->begin;
      Mojo::IOLoop->timer($i => sub {
        say 10 - $i;
        $end->();
      });
    }
    $delay->wait;
  
    # Sequentialize multiple non-blocking operations
    Mojo::IOLoop::Delay->new->steps(
  
      # First step (simple timer)
      sub {
        my $delay = shift;
        Mojo::IOLoop->timer(2 => $delay->begin);
        say 'Second step in 2 seconds.';
      },
  
      # Second step (concurrent timers)
      sub {
        my ($delay, @args) = @_;
        Mojo::IOLoop->timer(1 => $delay->begin);
        Mojo::IOLoop->timer(3 => $delay->begin);
        say 'Third step in 3 seconds.';
      },
  
      # Third step (the end)
      sub {
        my ($delay, @args) = @_;
        say 'And done after 5 seconds total.';
      }
    )->wait;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Delay> adds flow-control helpers to L<Mojo::Promise>, which can
  help you avoid deep nested closures that often result from continuation-passing
  style.
  
    use Mojo::IOLoop;
  
    # These deep nested closures are often referred to as "Callback Hell"
    Mojo::IOLoop->timer(3 => sub {
      my loop = shift;
  
      say '3 seconds';
      Mojo::IOLoop->timer(3 => sub {
        my $loop = shift;
  
        say '6 seconds';
        Mojo::IOLoop->timer(3 => sub {
          my $loop = shift;
  
          say '9 seconds';
          Mojo::IOLoop->stop;
        });
      });
    });
  
    Mojo::IOLoop->start;
  
  The idea behind L<Mojo::IOLoop::Delay> is to turn the nested closures above into
  a flat series of closures. In the example below, the call to L</"begin"> creates
  a code reference that we can pass to L<Mojo::IOLoop/"timer"> as a callback, and
  that leads to the next closure in the series when executed.
  
    use Mojo::IOLoop;
  
    # Instead of nested closures we now have a simple chain of steps
    my $delay = Mojo::IOLoop->delay(
      sub {
        my $delay = shift;
        Mojo::IOLoop->timer(3 => $delay->begin);
      },
      sub {
        my $delay = shift;
        say '3 seconds';
        Mojo::IOLoop->timer(3 => $delay->begin);
      },
      sub {
        my $delay = shift;
        say '6 seconds';
        Mojo::IOLoop->timer(3 => $delay->begin);
      },
      sub {
        my $delay = shift;
        say '9 seconds';
      }
    );
    $delay->wait;
  
  Another positive side effect of this pattern is that we do not need to call
  L<Mojo::IOLoop/"start"> and L<Mojo::IOLoop/"stop"> manually, because we know
  exactly when our chain of L</"steps"> has reached the end. So
  L<Mojo::Promise/"wait"> can stop the event loop automatically if it had to be
  started at all in the first place.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Delay> inherits all attributes from L<Mojo::Promise>.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Delay> inherits all methods from L<Mojo::Promise> and implements
  the following new ones.
  
  =head2 begin
  
    my $cb = $delay->begin;
    my $cb = $delay->begin($offset);
    my $cb = $delay->begin($offset, $len);
  
  Indicate an active event by incrementing the event counter, the returned
  code reference can be used as a callback, and needs to be executed when the
  event has completed to decrement the event counter again. When all code
  references generated by this method have been executed and the event counter has
  reached zero, L</"steps"> will continue.
  
    # Capture all arguments except for the first one (invocant)
    my $delay = Mojo::IOLoop->delay(sub {
      my ($delay, $err, $stream) = @_;
      ...
    });
    Mojo::IOLoop->client({port => 3000} => $delay->begin);
    $delay->wait;
  
  Arguments passed to the returned code reference are spliced with the given
  offset and length, defaulting to an offset of C<1> with no default length. The
  arguments are then combined in the same order L</"begin"> was called, and passed
  together to the next step.
  
    # Capture all arguments
    my $delay = Mojo::IOLoop->delay(sub {
      my ($delay, $loop, $err, $stream) = @_;
      ...
    });
    Mojo::IOLoop->client({port => 3000} => $delay->begin(0));
    $delay->wait;
  
    # Capture only the second argument
    my $delay = Mojo::IOLoop->delay(sub {
      my ($delay, $err) = @_;
      ...
    });
    Mojo::IOLoop->client({port => 3000} => $delay->begin(1, 1));
    $delay->wait;
  
    # Capture and combine arguments
    my $delay = Mojo::IOLoop->delay(sub {
      my ($delay, $three_err, $three_stream, $four_err, $four_stream) = @_;
      ...
    });
    Mojo::IOLoop->client({port => 3000} => $delay->begin);
    Mojo::IOLoop->client({port => 4000} => $delay->begin);
    $delay->wait;
  
  =head2 pass
  
    $delay = $delay->pass;
    $delay = $delay->pass(@args);
  
  Shortcut for passing values between L</"steps">.
  
    # Longer version
    $delay->begin(0)->(@args);
  
  =head2 steps
  
    $delay = $delay->steps(sub {...}, sub {...});
  
  Sequentialize multiple events, every time the event counter reaches zero a
  callback will run, the first one automatically runs during the next reactor tick
  unless it is delayed by incrementing the event counter. This chain will continue
  until there are no remaining callbacks, a callback does not increment the event
  counter or an exception gets thrown in a callback. Finishing the chain will also
  result in the promise being fulfilled, or if an exception got thrown it will be
  rejected.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_IOLOOP_DELAY

$fatpacked{"Mojo/IOLoop/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_SERVER';
  package Mojo::IOLoop::Server;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use IO::Socket::IP;
  use IO::Socket::UNIX;
  use Mojo::IOLoop;
  use Mojo::IOLoop::TLS;
  use Scalar::Util 'weaken';
  use Socket qw(IPPROTO_TCP TCP_NODELAY);
  
  has reactor => sub { Mojo::IOLoop->singleton->reactor };
  
  sub DESTROY {
    my $self = shift;
    $ENV{MOJO_REUSE} =~ s/(?:^|\,)\Q$self->{reuse}\E// if $self->{reuse};
    $self->stop if $self->{handle} && $self->reactor;
  }
  
  sub generate_port {
    IO::Socket::IP->new(Listen => 5, LocalAddr => '127.0.0.1')->sockport;
  }
  
  sub handle { shift->{handle} }
  
  sub is_accepting { !!shift->{active} }
  
  sub listen {
    my ($self, $args) = (shift, ref $_[0] ? $_[0] : {@_});
  
    # Look for reusable file descriptor
    my $path    = $args->{path};
    my $address = $args->{address} || '0.0.0.0';
    my $port    = $args->{port};
    $ENV{MOJO_REUSE} ||= '';
    my $fd
      = ($path && $ENV{MOJO_REUSE} =~ /(?:^|\,)unix:\Q$path\E:(\d+)/)
      || ($port && $ENV{MOJO_REUSE} =~ /(?:^|\,)\Q$address:$port\E:(\d+)/)
      ? $1
      : undef;
  
    # Allow file descriptor inheritance
    local $^F = 1023;
  
    # Reuse file descriptor
    my $handle;
    my $class = $path ? 'IO::Socket::UNIX' : 'IO::Socket::IP';
    if (defined($fd //= $args->{fd})) {
      $handle = $class->new_from_fd($fd, 'r')
        or croak "Can't open file descriptor $fd: $!";
    }
  
    else {
      my %options
        = (Listen => $args->{backlog} // SOMAXCONN, Type => SOCK_STREAM);
  
      # UNIX domain socket
      my $reuse;
      if ($path) {
        unlink $path if -S $path;
        $options{Local} = $path;
        $handle = $class->new(%options) or croak "Can't create listen socket: $!";
        $reuse = $self->{reuse} = join ':', 'unix', $path, fileno $handle;
      }
  
      # IP socket
      else {
        $options{LocalAddr} = $address;
        $options{LocalAddr} =~ s/[\[\]]//g;
        $options{LocalPort} = $port if $port;
        $options{ReuseAddr} = 1;
        $options{ReusePort} = $args->{reuse};
        $handle = $class->new(%options) or croak "Can't create listen socket: $@";
        $fd     = fileno $handle;
        $reuse  = $self->{reuse} = join ':', $address, $handle->sockport, $fd;
      }
  
      $ENV{MOJO_REUSE} .= length $ENV{MOJO_REUSE} ? ",$reuse" : "$reuse";
    }
    $handle->blocking(0);
    @$self{qw(args handle)} = ($args, $handle);
  
    croak 'IO::Socket::SSL 2.009+ required for TLS support'
      if !Mojo::IOLoop::TLS->can_tls && $args->{tls};
  }
  
  sub port { shift->{handle}->sockport }
  
  sub start {
    my $self = shift;
    weaken $self;
    ++$self->{active}
      and $self->reactor->io($self->{handle} => sub { $self->_accept });
  }
  
  sub stop { delete($_[0]{active}) and $_[0]->reactor->remove($_[0]{handle}) }
  
  sub _accept {
    my $self = shift;
  
    # Greedy accept
    my $args     = $self->{args};
    my $accepted = 0;
    while ($self->{active} && !($args->{single_accept} && $accepted++)) {
      return unless my $handle = $self->{handle}->accept;
      $handle->blocking(0);
  
      # Disable Nagle's algorithm
      setsockopt $handle, IPPROTO_TCP, TCP_NODELAY, 1;
  
      $self->emit(accept => $handle) and next unless $args->{tls};
  
      # Start TLS handshake
      my $tls = Mojo::IOLoop::TLS->new($handle)->reactor($self->reactor);
      $tls->on(upgrade => sub { $self->emit(accept => pop) });
      $tls->on(error => sub { });
      $tls->negotiate(%$args, server => 1);
    }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Server - Non-blocking TCP and UNIX domain socket server
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Server;
  
    # Create listen socket
    my $server = Mojo::IOLoop::Server->new;
    $server->on(accept => sub {
      my ($server, $handle) = @_;
      ...
    });
    $server->listen(port => 3000);
  
    # Start and stop accepting connections
    $server->start;
    $server->stop;
  
    # Start reactor if necessary
    $server->reactor->start unless $server->reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Server> accepts TCP/IP and UNIX domain socket connections for
  L<Mojo::IOLoop>.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Server> inherits all events from L<Mojo::EventEmitter> and can
  emit the following new ones.
  
  =head2 accept
  
    $server->on(accept => sub {
      my ($server, $handle) = @_;
      ...
    });
  
  Emitted for each accepted connection.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Server> implements the following attributes.
  
  =head2 reactor
  
    my $reactor = $server->reactor;
    $server     = $server->reactor(Mojo::Reactor::Poll->new);
  
  Low-level event reactor, defaults to the C<reactor> attribute value of the
  global L<Mojo::IOLoop> singleton.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Server> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 generate_port
  
    my $port = Mojo::IOLoop::Server->generate_port;
  
  Find a free TCP port, primarily used for tests.
  
  =head2 handle
  
    my $handle = $server->handle;
  
  Get handle for server, usually an L<IO::Socket::IP> object.
  
  =head2 is_accepting
  
    my $bool = $server->is_accepting;
  
  Check if connections are currently being accepted.
  
  =head2 listen
  
    $server->listen(port => 3000);
    $server->listen({port => 3000});
  
  Create a new listen socket. Note that TLS support depends on L<IO::Socket::SSL>
  (2.009+).
  
  These options are currently available:
  
  =over 2
  
  =item address
  
    address => '127.0.0.1'
  
  Local address to listen on, defaults to C<0.0.0.0>.
  
  =item backlog
  
    backlog => 128
  
  Maximum backlog size, defaults to C<SOMAXCONN>.
  
  =item fd
  
    fd => 3
  
  File descriptor with an already prepared listen socket.
  
  =item path
  
    path => '/tmp/myapp.sock'
  
  Path for UNIX domain socket to listen on.
  
  =item port
  
    port => 80
  
  Port to listen on, defaults to a random port.
  
  =item reuse
  
    reuse => 1
  
  Allow multiple servers to use the same port with the C<SO_REUSEPORT> socket
  option.
  
  =item single_accept
  
    single_accept => 1
  
  Only accept one connection at a time.
  
  =item tls
  
    tls => 1
  
  Enable TLS.
  
  =item tls_ca
  
    tls_ca => '/etc/tls/ca.crt'
  
  Path to TLS certificate authority file.
  
  =item tls_cert
  
    tls_cert => '/etc/tls/server.crt'
    tls_cert => {'mojolicious.org' => '/etc/tls/mojo.crt'}
  
  Path to the TLS cert file, defaults to a built-in test certificate.
  
  =item tls_ciphers
  
    tls_ciphers => 'AES128-GCM-SHA256:RC4:HIGH:!MD5:!aNULL:!EDH'
  
  TLS cipher specification string. For more information about the format see
  L<https://www.openssl.org/docs/manmaster/apps/ciphers.html#CIPHER-STRINGS>.
  
  =item tls_key
  
    tls_key => '/etc/tls/server.key'
    tls_key => {'mojolicious.org' => '/etc/tls/mojo.key'}
  
  Path to the TLS key file, defaults to a built-in test key.
  
  =item tls_protocols
  
    tls_protocols => ['foo', 'bar']
  
  ALPN protocols to negotiate.
  
  =item tls_verify
  
    tls_verify => 0x00
  
  TLS verification mode.
  
  =item tls_version
  
    tls_version => 'TLSv1_2'
  
  TLS protocol version.
  
  =back
  
  =head2 port
  
    my $port = $server->port;
  
  Get port this server is listening on.
  
  =head2 start
  
    $server->start;
  
  Start or resume accepting connections.
  
  =head2 stop
  
    $server->stop;
  
  Stop accepting connections.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_IOLOOP_SERVER

$fatpacked{"Mojo/IOLoop/Stream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_STREAM';
  package Mojo::IOLoop::Stream;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Errno qw(EAGAIN ECONNRESET EINTR EWOULDBLOCK);
  use Mojo::IOLoop;
  use Mojo::Util;
  use Scalar::Util 'weaken';
  
  has reactor => sub { Mojo::IOLoop->singleton->reactor };
  
  sub DESTROY { Mojo::Util::_global_destruction() or shift->close }
  
  sub close {
    my $self = shift;
    return unless my $reactor = $self->reactor;
    return unless my $handle  = delete $self->timeout(0)->{handle};
    $reactor->remove($handle);
    $self->emit('close');
  }
  
  sub close_gracefully { $_[0]->is_writing ? $_[0]{graceful}++ : $_[0]->close }
  
  sub handle { shift->{handle} }
  
  sub is_readable {
    my $self = shift;
    $self->_again;
    return $self->{handle} && Mojo::Util::_readable(0, fileno $self->{handle});
  }
  
  sub is_writing {
    my $self = shift;
    return undef unless $self->{handle};
    return !!length($self->{buffer}) || $self->has_subscribers('drain');
  }
  
  sub new { shift->SUPER::new(handle => shift, buffer => '', timeout => 15) }
  
  sub start {
    my $self = shift;
  
    # Resume
    my $reactor = $self->reactor;
    return $reactor->watch($self->{handle}, 1, $self->is_writing)
      if delete $self->{paused};
  
    weaken $self;
    my $cb = sub { pop() ? $self->_write : $self->_read };
    $reactor->io($self->timeout($self->{timeout})->{handle} => $cb);
  }
  
  sub steal_handle {
    my $self = shift;
    $self->reactor->remove($self->{handle});
    return delete $self->{handle};
  }
  
  sub stop {
    my $self = shift;
    $self->reactor->watch($self->{handle}, 0, $self->is_writing)
      unless $self->{paused}++;
  }
  
  sub timeout {
    my $self = shift;
  
    return $self->{timeout} unless @_;
  
    my $reactor = $self->reactor;
    $reactor->remove(delete $self->{timer}) if $self->{timer};
    return $self unless my $timeout = $self->{timeout} = shift;
    weaken $self;
    $self->{timer}
      = $reactor->timer($timeout => sub { $self->emit('timeout')->close });
  
    return $self;
  }
  
  sub write {
    my ($self, $chunk, $cb) = @_;
  
    # IO::Socket::SSL will corrupt data with the wrong internal representation
    utf8::downgrade $chunk;
    $self->{buffer} .= $chunk;
    if ($cb) { $self->once(drain => $cb) }
    elsif (!length $self->{buffer}) { return $self }
    $self->reactor->watch($self->{handle}, !$self->{paused}, 1)
      if $self->{handle};
  
    return $self;
  }
  
  sub _again { $_[0]->reactor->again($_[0]{timer}) if $_[0]{timer} }
  
  sub _read {
    my $self = shift;
  
    my $read = $self->{handle}->sysread(my $buffer, 131072, 0);
    return $read == 0 ? $self->close : $self->emit(read => $buffer)->_again
      if defined $read;
  
    # Retry
    return if $! == EAGAIN || $! == EINTR || $! == EWOULDBLOCK;
  
    # Closed (maybe real error)
    $! == ECONNRESET ? $self->close : $self->emit(error => $!)->close;
  }
  
  sub _write {
    my $self = shift;
  
    # Handle errors only when reading (to avoid timing problems)
    my $handle = $self->{handle};
    if (length $self->{buffer}) {
      return unless defined(my $written = $handle->syswrite($self->{buffer}));
      $self->emit(write => substr($self->{buffer}, 0, $written, ''))->_again;
    }
  
    $self->emit('drain') unless length $self->{buffer};
    return if $self->is_writing;
    return $self->close if $self->{graceful};
    $self->reactor->watch($handle, !$self->{paused}, 0) if $self->{handle};
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Stream - Non-blocking I/O stream
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Stream;
  
    # Create stream
    my $stream = Mojo::IOLoop::Stream->new($handle);
    $stream->on(read => sub {
      my ($stream, $bytes) = @_;
      ...
    });
    $stream->on(close => sub {
      my $stream = shift;
      ...
    });
    $stream->on(error => sub {
      my ($stream, $err) = @_;
      ...
    });
  
    # Start and stop watching for new data
    $stream->start;
    $stream->stop;
  
    # Start reactor if necessary
    $stream->reactor->start unless $stream->reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Stream> is a container for I/O streams used by L<Mojo::IOLoop>.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Stream> inherits all events from L<Mojo::EventEmitter> and can
  emit the following new ones.
  
  =head2 close
  
    $stream->on(close => sub {
      my $stream = shift;
      ...
    });
  
  Emitted if the stream gets closed.
  
  =head2 drain
  
    $stream->on(drain => sub {
      my $stream = shift;
      ...
    });
  
  Emitted once all data has been written.
  
  =head2 error
  
    $stream->on(error => sub {
      my ($stream, $err) = @_;
      ...
    });
  
  Emitted if an error occurs on the stream, fatal if unhandled.
  
  =head2 read
  
    $stream->on(read => sub {
      my ($stream, $bytes) = @_;
      ...
    });
  
  Emitted if new data arrives on the stream.
  
  =head2 timeout
  
    $stream->on(timeout => sub {
      my $stream = shift;
      ...
    });
  
  Emitted if the stream has been inactive for too long and will get closed
  automatically.
  
  =head2 write
  
    $stream->on(write => sub {
      my ($stream, $bytes) = @_;
      ...
    });
  
  Emitted if new data has been written to the stream.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Stream> implements the following attributes.
  
  =head2 reactor
  
    my $reactor = $stream->reactor;
    $stream     = $stream->reactor(Mojo::Reactor::Poll->new);
  
  Low-level event reactor, defaults to the C<reactor> attribute value of the
  global L<Mojo::IOLoop> singleton.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Stream> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 close
  
    $stream->close;
  
  Close stream immediately.
  
  =head2 close_gracefully
  
    $stream->close_gracefully;
  
  Close stream gracefully.
  
  =head2 handle
  
    my $handle = $stream->handle;
  
  Get handle for stream, usually an L<IO::Socket::IP> or L<IO::Socket::SSL>
  object.
  
  =head2 is_readable
  
    my $bool = $stream->is_readable;
  
  Quick non-blocking check if stream is readable, useful for identifying tainted
  sockets.
  
  =head2 is_writing
  
    my $bool = $stream->is_writing;
  
  Check if stream is writing.
  
  =head2 new
  
    my $stream = Mojo::IOLoop::Stream->new($handle);
  
  Construct a new L<Mojo::IOLoop::Stream> object.
  
  =head2 start
  
    $stream->start;
  
  Start or resume watching for new data on the stream.
  
  =head2 steal_handle
  
    my $handle = $stream->steal_handle;
  
  Steal L</"handle"> and prevent it from getting closed automatically.
  
  =head2 stop
  
    $stream->stop;
  
  Stop watching for new data on the stream.
  
  =head2 timeout
  
    my $timeout = $stream->timeout;
    $stream     = $stream->timeout(45);
  
  Maximum amount of time in seconds stream can be inactive before getting closed
  automatically, defaults to C<15>. Setting the value to C<0> will allow this
  stream to be inactive indefinitely.
  
  =head2 write
  
    $stream = $stream->write($bytes);
    $stream = $stream->write($bytes => sub {...});
  
  Write data to stream, the optional drain callback will be executed once all data
  has been written.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_IOLOOP_STREAM

$fatpacked{"Mojo/IOLoop/Stream/HTTPClient.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_STREAM_HTTPCLIENT';
  package Mojo::IOLoop::Stream::HTTPClient;
  use Mojo::Base 'Mojo::IOLoop::Stream';
  
  use Mojo::Transaction::WebSocket;
  use Mojo::Util 'term_escape';
  use Mojo::WebSocket 'challenge';
  use Scalar::Util 'weaken';
  
  use constant DEBUG => $ENV{MOJO_CLIENT_DEBUG} || 0;
  
  has request_timeout => 0;
  
  sub new {
    my $self = shift->SUPER::new(@_);
    $self->on(read => sub { shift->_read_content(shift) });
    $self->on(close => sub { $_[0]->{closing}++ || $_[0]->_finish(1) });
    return $self;
  }
  
  sub process {
    my ($self, $tx) = @_;
  
    $self->{tx} = $tx;
    my $handle = $self->handle;
    unless ($handle->isa('IO::Socket::UNIX')) {
      $tx->local_address($handle->sockhost)->local_port($handle->sockport);
      $tx->remote_address($handle->peerhost)->remote_port($handle->peerport);
    }
  
    weaken $self;
    $tx->on(resume => sub { $self->_write_content });
    if (my $timeout = $self->request_timeout) {
      $self->{req_timeout} = $self->reactor->timer(
        $timeout => sub { $self->_error('Request timeout') });
    }
    $self->_write_content;
  }
  
  sub _error {
    my ($self, $err) = @_;
    $self->{tx}->res->error({message => $err}) if $self->{tx};
    $self->_finish(1);
  }
  
  sub _finish {
    my ($self, $close) = @_;
  
    # Remove request timeout and finish transaction
    $self->reactor->remove($self->{req_timeout}) if $self->{req_timeout};
    return ++$self->{closing} && $self->close unless my $tx = delete $self->{tx};
  
    # Premature connection close
    my $res = $tx->res->finish;
    if ($close && !$res->code && !$res->error) {
      $res->error({message => 'Premature connection close'});
    }
  
    # Upgrade connection to WebSocket
    if (my $ws = $self->_upgrade($tx)) {
      $self->emit(upgrade => $ws);
      return $ws->client_read($ws->handshake->res->content->leftovers);
    }
  
    ++$self->{closing} && $self->close_gracefully
      if $tx->error || !$tx->keep_alive;
    $res->error({message => $res->message, code => $res->code}) if $res->is_error;
    $tx->closed;
  }
  
  sub _read_content {
    my ($self, $chunk) = @_;
  
    # Corrupted connection
    return $self->close unless my $tx = $self->{tx};
  
    warn term_escape "-- Client <<< Server (@{[_url($tx)]})\n$chunk\n" if DEBUG;
    $tx->client_read($chunk);
    $self->_finish if $tx->is_finished;
  }
  
  sub _upgrade {
    my ($self, $tx) = @_;
    my $code = $tx->res->code // 0;
    return undef unless $tx->req->is_handshake && $code == 101;
    my $ws = Mojo::Transaction::WebSocket->new(handshake => $tx, masked => 1);
    return challenge($ws) ? $ws->established(1) : undef;
  }
  
  sub _url { shift->req->url->to_abs }
  
  sub _write_content {
    my $self = shift;
  
    # Protect from resume event recursion
    return if !(my $tx = $self->{tx}) || $self->{write_lock};
    local $self->{write_lock} = 1;
    my $chunk = $tx->client_write;
    warn term_escape "-- Client >>> Server (@{[_url($tx)]})\n$chunk\n" if DEBUG;
    return unless length $chunk;
    $self->write($chunk => sub { $_[0]->_write_content });
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Stream::HTTPClient - Non-blocking I/O HTTP client stream
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Client;
    use Mojo::IOLoop::Stream::HTTPClient;
    use Mojo::Transaction::HTTP;
    
    # Create transaction
    my $tx = Mojo::Transaction::HTTP->new;
    $tx->req->method('GET')
    $tx->url->parse('https://mojolicious.org');
    $tx->on(
      finish => sub {
        my $tx = shift;
        say $tx->res->code;
      }
    );
    
    # Create socket connection
    my $client = Mojo::IOLoop::Client->new;
    $client->on(
      connect => sub {
        my $stream = Mojo::IOLoop::Stream::HTTPClient->new(pop);
        $stream->start;
        $stream->process($tx);
      }
    );
    $client->connect(address => 'mojolicious.org', port => 80);
  
    # Start reactor if necessary
    $stream->reactor->start unless $stream->reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Stream::HTTPClient> is a container for I/O streams used by
  L<Mojo::IOLoop> to support the HTTP protocol client-side.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Stream::HTTPClient> inherits all events from
  L<Mojo::IOLoop::Stream> and can emit the following new ones.
  
  =head2 upgrade
  
    $stream->on(upgrade => sub {
      my ($stream, $ws) = @_;
      ...
    });
  
  Emitted when the connection should be upgraded to the WebSocket protocol.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Stream::HTTPClient> inherits all attributes from
  L<Mojo::IOLoop::Stream> and implements the following ones.
  
  =head2 request_timeout
  
    my $timeout = $stream->request_timeout;
    $stream     = $stream->request_timeout(5);
  
  Maximum amount of time in seconds sending the request and receiving a whole
  response may take before getting canceled, defaults to C<0>. Setting the value
  to C<0> will allow to wait indefinitely.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Stream::HTTPClient> inherits all methods from
  L<Mojo::IOLoop::Stream> and implements the following new ones.
  
  =head2 new
  
    my $stream = Mojo::IOLoop::Stream::HTTPClient->new($handle);
  
  Construct a new L<Mojo::IOLoop::Stream::HTTPClient> object.
  
  =head2 process
  
    $stream->process(Mojo::Transaction::HTTP->new);
  
  Process a L<Mojo::Transaction::HTTP> object with the current connection.
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_CLIENT_DEBUG> environment variable to get some advanced
  diagnostics information printed to C<STDERR>.
  
    MOJO_CLIENT_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
  
MOJO_IOLOOP_STREAM_HTTPCLIENT

$fatpacked{"Mojo/IOLoop/Stream/HTTPServer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_STREAM_HTTPSERVER';
  package Mojo::IOLoop::Stream::HTTPServer;
  use Mojo::Base 'Mojo::IOLoop::Stream';
  
  use Mojo::Server;
  use Mojo::Transaction::WebSocket;
  use Mojo::Util 'term_escape';
  use Mojo::WebSocket 'server_handshake';
  use Scalar::Util 'weaken';
  
  use constant DEBUG => $ENV{MOJO_SERVER_DEBUG} || 0;
  
  has app => sub { Mojo::Server->new->build_app('Mojo::HelloWorld') };
  has max_requests => 100;
  
  sub new {
    my $self = shift->SUPER::new(@_);
    $self->on(read  => sub { shift->_read_content(shift) });
    $self->on(close => sub { shift->_close });
    return $self;
  }
  
  sub _build_tx {
    my $self = shift;
  
    my $tx = $self->app->build_tx;
    $tx->res->headers->server('Mojolicious (Perl)');
    my $handle = $self->handle;
    unless ($handle->isa('IO::Socket::UNIX')) {
      $tx->local_address($handle->sockhost)->local_port($handle->sockport);
      $tx->remote_address($handle->peerhost)->remote_port($handle->peerport);
    }
    $tx->req->url->base->scheme('https') if $handle->isa('IO::Socket::SSL');
  
    weaken $self;
    $tx->on(
      request => sub {
        my $tx = shift;
  
        # WebSocket
        my $req = $tx->req;
        if ($req->is_handshake) {
          my $ws = $self->{next}
            = Mojo::Transaction::WebSocket->new(handshake => $tx);
          $self->emit(request => server_handshake $ws);
        }
  
        # HTTP
        else { $self->emit(request => $tx) }
  
        # Last keep-alive request or corrupted connection
        $tx->res->headers->connection('close')
          if ($self->{keep_alive} || 1) >= $self->max_requests || $req->error;
  
        $tx->on(resume => sub { $self->_write_content });
        $self->_write_content;
      }
    );
  
    $self->emit(start => $tx);
  
    # Kept alive if we have more than one request on the connection
    return ++$self->{keep_alive} > 1 ? $tx->kept_alive(1) : $tx;
  }
  
  sub _close { delete($_[0]->{tx})->closed if $_[0]->{tx} }
  
  sub _finish {
    my $self = shift;
  
    # Always remove connection for WebSockets
    return unless my $tx = $self->{tx};
  
    # Finish transaction
    delete($self->{tx})->closed;
  
    # Upgrade connection to WebSocket
    if (my $ws = delete $self->{next}) {
  
      # Successful upgrade
      if ($ws->handshake->res->code == 101) {
        $self->emit(upgrade => $ws->established(1));
      }
  
      # Failed upgrade
      else { $ws->closed }
    }
  
    # Close connection if necessary
    return $self->close_gracefully if $tx->error || !$tx->keep_alive;
  
    # Build new transaction for leftovers
    return unless length(my $leftovers = $tx->req->content->leftovers);
    $self->{tx} = $tx = $self->_build_tx;
    $tx->server_read($leftovers);
  }
  
  sub _read_content {
    my ($self, $chunk) = @_;
    my $tx = $self->{tx} ||= $self->_build_tx;
    warn term_escape "-- Server <<< Client (@{[_url($tx)]})\n$chunk\n" if DEBUG;
    $tx->server_read($chunk);
  }
  
  sub _url { shift->req->url->to_abs }
  
  sub _write_content {
    my $self = shift;
  
    # Protect from resume event recursion
    return if !(my $tx = $self->{tx}) || $self->{write_lock};
    local $self->{write_lock} = 1;
    my $chunk = $tx->server_write;
    warn term_escape "-- Server >>> Client (@{[_url($tx)]})\n$chunk\n" if DEBUG;
    my $next
      = $tx->is_finished ? '_finish' : length $chunk ? '_write_content' : undef;
    return $self->write($chunk) unless $next;
    $self->write($chunk => sub { shift->$next() });
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Stream::HTTPServer - Non-blocking I/O HTTP server stream
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Server;
    use Mojo::IOLoop::Stream::HTTPServer;
    
    # Create listen socket
    my $server = Mojo::IOLoop::Server->new;
    $server->on(
      accept => sub {
        my $stream = Mojo::IOLoop::Stream::HTTPServer->new(pop);
    
        $stream->on(
          request => sub {
            my ($stream, $tx) = @_;
            $tx->res->code(200);
            $tx->res->headers->content_type('text/plain');
            $tx->res->body('Hello World!');
            $tx->resume;
          }
        );
        $stream->start;
      }
    );
    $server->listen(port => 3000);
    
    # Start reactor if necessary
    $stream->reactor->start unless $stream->reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Stream::HTTPServer> is a container for I/O streams used by
  L<Mojo::IOLoop> to support the HTTP protocol server-side.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Stream::HTTPServer> inherits all events from
  L<Mojo::IOLoop::Stream> and can emit the following new ones.
  
  =head2 request
  
    $stream->on(request => sub {
      my ($sream, $tx) = @_;
      ...
    });
  
  Emitted when a request is ready and needs to be handled.
  
    $stream->on(request => sub {
      my ($stream, $tx) = @_;
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body('Hello World!');
      $tx->resume;
    });
  
  =head2 start
  
    $stream->on(start => sub {
      my ($stream, $tx) = @_;
      ...
    });
  
  Emitted whenever a transaction for a new request is about to start.
  
  =head2 upgrade
  
    $stream->on(upgrade => sub {
      my ($stream, $ws) = @_;
      ...
    });
  
  Emitted when the connection should be upgraded to the WebSocket protocol.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Stream::HTTPServer> inherits all attributes from
  L<Mojo::IOLoop::Stream> and implements the following ones.
  
  =head2 app
  
    my $app = $stream->app;
    $stream = $stream->app(Mojolicious->new);
  
  Application responsible for building transactions, defaults to a
  L<Mojo::HelloWorld> object.
  
  =head2 max_requests
  
    my $max = $stream->max_requests;
    $stream = $stream->max_requests(250);
  
  Maximum number of keep-alive requests per connection, defaults to C<100>.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Stream::HTTPServer> inherits all methods from
  L<Mojo::IOLoop::Stream> and implements the following new ones.
  
  =head2 new
  
    my $stream = Mojo::IOLoop::Stream::HTTPServer->new($handle);
  
  Construct a new L<Mojo::IOLoop::Stream::HTTPServer> object.
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_SERVER_DEBUG> environment variable to get some advanced
  diagnostics information printed to C<STDERR>.
  
    MOJO_SERVER_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
  
MOJO_IOLOOP_STREAM_HTTPSERVER

$fatpacked{"Mojo/IOLoop/Stream/WebSocketClient.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_STREAM_WEBSOCKETCLIENT';
  package Mojo::IOLoop::Stream::WebSocketClient;
  use Mojo::Base 'Mojo::IOLoop::Stream::HTTPClient';
  
  use Scalar::Util 'weaken';
  
  sub process {
    my ($self, $tx) = @_;
    $self->{tx} = $tx;
    weaken $self;
    $tx->on(resume => sub { $self->_write_content });
    $self->_write_content;
  }
  
  sub _finish {
    my $self = shift;
    return ++$self->{closing} && $self->close unless $self->{tx};
    delete($self->{tx})->closed;
    ++$self->{closing} && $self->close_gracefully;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Stream::WebSocketClient - Non-blocking I/O WebSocket client stream
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Stream::WebSocketClient;
    use Mojo::Transaction::WebSocket;
    
    # Create transaction
    my $ws = Mojo::Transaction::WebSocket->new;
    $ws->on(message => sub {
      my ($ws, $msg) = @_;
      say "Message: $msg";
    });
    
    # Create stream and process transaction with it
    my $stream = Mojo::IOLoop::Stream::WebSocketClient->new($handle);
    $stream->process($ws);
  
    # Start reactor if necessary
    $stream->reactor->start unless $stream->reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Stream::WebSocketClient> is a container for I/O streams used by
  L<Mojo::IOLoop> to support the WebSocket protocol client-side.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Stream::WebSocketClient> inherits all events from
  L<Mojo::IOLoop::Stream::HTTPClient>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Stream::WebSocketClient> inherits all attributes from
  L<Mojo::IOLoop::Stream::HTTPClient>.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Stream::WebSocketClient> inherits all methods from
  L<Mojo::IOLoop::Stream::HTTPClient> and implements the following new ones.
  
  =head2 process
  
    $stream->process(Mojo::Transaction::WebSocket->new);
  
  Process a L<Mojo::Transaction::WebSocket> object.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
  
MOJO_IOLOOP_STREAM_WEBSOCKETCLIENT

$fatpacked{"Mojo/IOLoop/Stream/WebSocketServer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_STREAM_WEBSOCKETSERVER';
  package Mojo::IOLoop::Stream::WebSocketServer;
  use Mojo::Base 'Mojo::IOLoop::Stream::HTTPServer';
  
  use Scalar::Util 'weaken';
  
  sub process {
    my ($self, $tx) = @_;
    $self->{tx} = $tx;
    weaken $self;
    $tx->on(resume => sub { $self->_write_content });
    $self->_write_content;
  }
  
  sub _close { delete($_[0]->{tx})->closed if $_[0]->{tx} }
  
  sub _finish { shift->close_gracefully }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Stream::WebSocketServer - Non-blocking I/O WebSocket server stream
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Stream::WebSocketServer;
    use Mojo::Transaction::WebSocket;
    
    # Create transaction
    my $ws = Mojo::Transaction::WebSocket->new;
    $ws->on(message => sub {
      my ($ws, $msg) = @_;
      say "Message: $msg";
    });
  
    # Create stream and process transaction with it
    my $stream = Mojo::IOLoop::Stream::WebSocketServer->new($handle);
    $stream->process($ws);
  
    # Start reactor if necessary
    $stream->reactor->start unless $stream->reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Stream::WebSocketServer> is a container for I/O streams used by
  L<Mojo::IOLoop> to support the WebSocket protocol server-side.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Stream::WEBSocketServer> inherits all events from
  L<Mojo::IOLoop::Stream::HTTPServer>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Stream::WebSocketServer> inherits all attributes from
  L<Mojo::IOLoop::Stream::HTTPServer>.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Stream::WebSocketServer> inherits all methods from
  L<Mojo::IOLoop::Stream::HTTPServer> and implements the following new ones.
  
  =head2 process
  
    $stream->process(Mojo::Transaction::WebSocket->new);
  
  Process a L<Mojo::Transaction::WebSocket> object.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  =cut
  
MOJO_IOLOOP_STREAM_WEBSOCKETSERVER

$fatpacked{"Mojo/IOLoop/Subprocess.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_SUBPROCESS';
  package Mojo::IOLoop::Subprocess;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Config;
  use Mojo::IOLoop;
  use Mojo::IOLoop::Stream;
  use POSIX ();
  use Storable;
  
  has deserialize => sub { \&Storable::thaw };
  has ioloop      => sub { Mojo::IOLoop->singleton };
  has serialize   => sub { \&Storable::freeze };
  
  sub pid { shift->{pid} }
  
  sub run {
    my ($self, @args) = @_;
    $self->ioloop->next_tick(sub { $self->_start(@args) });
    return $self;
  }
  
  sub _start {
    my ($self, $child, $parent) = @_;
  
    # No fork emulation support
    return $self->$parent('Subprocesses do not support fork emulation')
      if $Config{d_pseudofork};
  
    # Pipe for subprocess communication
    return $self->$parent("Can't create pipe: $!")
      unless pipe(my $reader, my $writer);
    $writer->autoflush(1);
  
    # Child
    return $self->$parent("Can't fork: $!")
      unless defined(my $pid = $self->{pid} = fork);
    unless ($pid) {
      $self->ioloop->reset;
      my $results = eval { [$self->$child] } || [];
      print $writer $self->serialize->([$@, @$results]);
      POSIX::_exit(0);
    }
  
    # Parent
    my $me     = $$;
    my $stream = Mojo::IOLoop::Stream->new($reader)->timeout(0);
    $self->emit('spawn')->ioloop->stream($stream);
    my $buffer = '';
    $stream->on(read => sub { $buffer .= pop });
    $stream->on(
      close => sub {
        return unless $$ == $me;
        waitpid $pid, 0;
        my $results = eval { $self->deserialize->($buffer) } || [];
        $self->$parent(shift(@$results) // $@, @$results);
      }
    );
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::Subprocess - Subprocesses
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::Subprocess;
  
    # Operation that would block the event loop for 5 seconds
    my $subprocess = Mojo::IOLoop::Subprocess->new;
    $subprocess->run(
      sub {
        my $subprocess = shift;
        sleep 5;
        return '', 'Mojolicious';
      },
      sub {
        my ($subprocess, $err, @results) = @_;
        say "Subprocess error: $err" and return if $err;
        say "I $results[0] $results[1]!";
      }
    );
  
    # Start event loop if necessary
    $subprocess->ioloop->start unless $subprocess->ioloop->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::Subprocess> allows L<Mojo::IOLoop> to perform computationally
  expensive operations in subprocesses, without blocking the event loop.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::Subprocess> inherits all events from L<Mojo::EventEmitter> and
  can emit the following new ones.
  
  =head2 spawn
  
    $subprocess->on(spawn => sub {
      my $subprocess = shift;
      ...
    });
  
  Emitted in the parent process when the subprocess has been spawned.
  
    $subprocess->on(spawn => sub {
      my $subprocess = shift;
      my $pid = $subprocess->pid;
      say "Performing work in process $pid";
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::Subprocess> implements the following attributes.
  
  =head2 deserialize
  
    my $cb      = $subprocess->deserialize;
    $subprocess = $subprocess->deserialize(sub {...});
  
  A callback used to deserialize subprocess return values, defaults to using
  L<Storable>.
  
    $subprocess->deserialize(sub {
      my $bytes = shift;
      return [];
    });
  
  =head2 ioloop
  
    my $loop    = $subprocess->ioloop;
    $subprocess = $subprocess->ioloop(Mojo::IOLoop->new);
  
  Event loop object to control, defaults to the global L<Mojo::IOLoop> singleton.
  
  =head2 serialize
  
    my $cb      = $subprocess->serialize;
    $subprocess = $subprocess->serialize(sub {...});
  
  A callback used to serialize subprocess return values, defaults to using
  L<Storable>.
  
    $subprocess->serialize(sub {
      my $array = shift;
      return '';
    });
  
  =head1 METHODS
  
  L<Mojo::IOLoop::Subprocess> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 pid
  
    my $pid = $subprocess->pid;
  
  Process id of the spawned subprocess if available.
  
  =head2 run
  
    $subprocess = $subprocess->run(sub {...}, sub {...});
  
  Execute the first callback in a child process and wait for it to return one or
  more values, without blocking L</"ioloop"> in the parent process. Then execute
  the second callback in the parent process with the results. The return values of
  the first callback and exceptions thrown by it, will be serialized with
  L<Storable>, so they can be shared between processes.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_IOLOOP_SUBPROCESS

$fatpacked{"Mojo/IOLoop/TLS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_TLS';
  package Mojo::IOLoop::TLS;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Mojo::File 'path';
  use Mojo::IOLoop;
  use Scalar::Util 'weaken';
  
  # TLS support requires IO::Socket::SSL
  use constant TLS => $ENV{MOJO_NO_TLS}
    ? 0
    : eval { require IO::Socket::SSL; IO::Socket::SSL->VERSION('2.009'); 1 };
  use constant READ  => TLS ? IO::Socket::SSL::SSL_WANT_READ()  : 0;
  use constant WRITE => TLS ? IO::Socket::SSL::SSL_WANT_WRITE() : 0;
  
  has reactor => sub { Mojo::IOLoop->singleton->reactor };
  
  # To regenerate the certificate run this command (18.04.2012)
  # openssl req -new -x509 -keyout server.key -out server.crt -nodes -days 7300
  my $CERT = path(__FILE__)->sibling('resources', 'server.crt')->to_string;
  my $KEY  = path(__FILE__)->sibling('resources', 'server.key')->to_string;
  
  sub DESTROY { shift->_cleanup }
  
  sub can_tls {TLS}
  
  sub negotiate {
    my ($self, $args) = (shift, ref $_[0] ? $_[0] : {@_});
  
    return $self->emit(error => 'IO::Socket::SSL 2.009+ required for TLS support')
      unless TLS;
  
    my $handle = $self->{handle};
    return $self->emit(error => $IO::Socket::SSL::SSL_ERROR)
      unless IO::Socket::SSL->start_SSL($handle, %{$self->_expand($args)});
    $self->reactor->io($handle
        = $handle => sub { $self->_tls($handle, $args->{server}) });
  }
  
  sub new { shift->SUPER::new(handle => shift) }
  
  sub _cleanup {
    my $self = shift;
    return unless my $reactor = $self->reactor;
    $reactor->remove($self->{handle}) if $self->{handle};
    return $self;
  }
  
  sub _expand {
    my ($self, $args) = @_;
  
    weaken $self;
    my $tls = {
      SSL_error_trap     => sub { $self->_cleanup->emit(error => $_[1]) },
      SSL_startHandshake => 0
    };
    $tls->{SSL_alpn_protocols} = $args->{tls_protocols} if $args->{tls_protocols};
    $tls->{SSL_ca_file} = $args->{tls_ca}
      if $args->{tls_ca} && -T $args->{tls_ca};
    $tls->{SSL_cert_file}   = $args->{tls_cert}    if $args->{tls_cert};
    $tls->{SSL_cipher_list} = $args->{tls_ciphers} if $args->{tls_ciphers};
    $tls->{SSL_key_file}    = $args->{tls_key}     if $args->{tls_key};
    $tls->{SSL_server}      = $args->{server}      if $args->{server};
    $tls->{SSL_verify_mode} = $args->{tls_verify}  if defined $args->{tls_verify};
    $tls->{SSL_version}     = $args->{tls_version} if $args->{tls_version};
  
    if ($args->{server}) {
      $tls->{SSL_cert_file} ||= $CERT;
      $tls->{SSL_key_file}  ||= $KEY;
    }
    else {
      $tls->{SSL_hostname}
        = IO::Socket::SSL->can_client_sni ? $args->{address} : '';
      $tls->{SSL_verifycn_name} = $args->{address};
    }
  
    return $tls;
  }
  
  sub _tls {
    my ($self, $handle, $server) = @_;
  
    return $self->_cleanup->emit(upgrade => delete $self->{handle})
      if $server ? $handle->accept_SSL : $handle->connect_SSL;
  
    # Switch between reading and writing
    my $err = $IO::Socket::SSL::SSL_ERROR;
    if    ($err == READ)  { $self->reactor->watch($handle, 1, 0) }
    elsif ($err == WRITE) { $self->reactor->watch($handle, 1, 1) }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::IOLoop::TLS - Non-blocking TLS handshake
  
  =head1 SYNOPSIS
  
    use Mojo::IOLoop::TLS;
  
    # Negotiate TLS
    my $tls = Mojo::IOLoop::TLS->new($old_handle);
    $tls->on(upgrade => sub {
      my ($tls, $new_handle) = @_;
      ...
    });
    $tls->on(error => sub {
      my ($tls, $err) = @_;
      ...
    });
    $tls->negotiate(server => 1, tls_version => 'TLSv1_2');
  
    # Start reactor if necessary
    $tls->reactor->start unless $tls->reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::IOLoop::TLS> negotiates TLS for L<Mojo::IOLoop>.
  
  =head1 EVENTS
  
  L<Mojo::IOLoop::TLS> inherits all events from L<Mojo::EventEmitter> and can
  emit the following new ones.
  
  =head2 upgrade
  
    $tls->on(upgrade => sub {
      my ($tls, $handle) = @_;
      ...
    });
  
  Emitted once TLS has been negotiated.
  
  =head2 error
  
    $tls->on(error => sub {
      my ($tls, $err) = @_;
      ...
    });
  
  Emitted if an error occurs during negotiation, fatal if unhandled.
  
  =head1 ATTRIBUTES
  
  L<Mojo::IOLoop::TLS> implements the following attributes.
  
  =head2 reactor
  
    my $reactor = $tls->reactor;
    $tls        = $tls->reactor(Mojo::Reactor::Poll->new);
  
  Low-level event reactor, defaults to the C<reactor> attribute value of the
  global L<Mojo::IOLoop> singleton.
  
  =head1 METHODS
  
  L<Mojo::IOLoop::TLS> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 can_tls
  
    my $bool = Mojo::IOLoop::TLS->can_tls;
  
  True if L<IO::Socket::SSL> 2.009+ is installed and TLS support enabled.
  
  =head2 negotiate
  
    $tls->negotiate(server => 1, tls_version => 'TLSv1_2');
    $tls->negotiate({server => 1, tls_version => 'TLSv1_2'});
  
  Negotiate TLS.
  
  These options are currently available:
  
  =over 2
  
  =item server
  
    server => 1
  
  Negotiate TLS from the server-side, defaults to the client-side.
  
  =item tls_ca
  
    tls_ca => '/etc/tls/ca.crt'
  
  Path to TLS certificate authority file.
  
  =item tls_cert
  
    tls_cert => '/etc/tls/server.crt'
    tls_cert => {'mojolicious.org' => '/etc/tls/mojo.crt'}
  
  Path to the TLS cert file, defaults to a built-in test certificate on the
  server-side.
  
  =item tls_ciphers
  
    tls_ciphers => 'AES128-GCM-SHA256:RC4:HIGH:!MD5:!aNULL:!EDH'
  
  TLS cipher specification string. For more information about the format see
  L<https://www.openssl.org/docs/manmaster/apps/ciphers.html#CIPHER-STRINGS>.
  
  =item tls_key
  
    tls_key => '/etc/tls/server.key'
    tls_key => {'mojolicious.org' => '/etc/tls/mojo.key'}
  
  Path to the TLS key file, defaults to a built-in test key on the server-side.
  
  =item tls_protocols
  
    tls_protocols => ['foo', 'bar']
  
  ALPN protocols to negotiate.
  
  =item tls_verify
  
    tls_verify => 0x00
  
  TLS verification mode.
  
  =item tls_version
  
    tls_version => 'TLSv1_2'
  
  TLS protocol version.
  
  =back
  
  =head2 new
  
    my $tls = Mojo::IOLoop::TLS->new($handle);
  
  Construct a new L<Mojo::IOLoop::Stream> object.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_IOLOOP_TLS

$fatpacked{"Mojo/JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_JSON';
  package Mojo::JSON;
  use Mojo::Base -strict;
  
  use Carp 'croak';
  use Exporter 'import';
  use JSON::PP ();
  use Mojo::Util qw(decode encode monkey_patch);
  use Scalar::Util 'blessed';
  
  # For better performance Cpanel::JSON::XS is required
  use constant JSON_XS => $ENV{MOJO_NO_JSON_XS}
    ? 0
    : eval { require Cpanel::JSON::XS; Cpanel::JSON::XS->VERSION('4.04'); 1 };
  
  our @EXPORT_OK = qw(decode_json encode_json false from_json j to_json true);
  
  # Escaped special character map
  my %ESCAPE = (
    '"'  => '"',
    '\\' => '\\',
    '/'  => '/',
    'b'  => "\x08",
    'f'  => "\x0c",
    'n'  => "\x0a",
    'r'  => "\x0d",
    't'  => "\x09"
  );
  my %REVERSE = map { $ESCAPE{$_} => "\\$_" } keys %ESCAPE;
  for (0x00 .. 0x1f) { $REVERSE{pack 'C', $_} //= sprintf '\u%.4X', $_ }
  
  # Replace pure-Perl fallbacks if Cpanel::JSON::XS is available
  if (JSON_XS) {
    my $BINARY = Cpanel::JSON::XS->new->utf8;
    my $TEXT   = Cpanel::JSON::XS->new;
    $_->canonical->allow_nonref->allow_unknown->allow_blessed->convert_blessed
      ->stringify_infnan->escape_slash
      for $BINARY, $TEXT;
    monkey_patch __PACKAGE__, 'encode_json', sub { $BINARY->encode($_[0]) };
    monkey_patch __PACKAGE__, 'decode_json', sub { $BINARY->decode($_[0]) };
    monkey_patch __PACKAGE__, 'to_json',     sub { $TEXT->encode($_[0]) };
    monkey_patch __PACKAGE__, 'from_json',   sub { $TEXT->decode($_[0]) };
  }
  
  sub decode_json {
    my $err = _decode(\my $value, shift);
    return defined $err ? croak $err : $value;
  }
  
  sub encode_json { encode('UTF-8', _encode_value(shift)) }
  
  sub false () {JSON::PP::false}
  
  sub from_json {
    my $err = _decode(\my $value, shift, 1);
    return defined $err ? croak $err : $value;
  }
  
  sub j {
    return encode_json($_[0]) if ref $_[0] eq 'ARRAY' || ref $_[0] eq 'HASH';
    return eval { decode_json($_[0]) };
  }
  
  sub to_json { _encode_value(shift) }
  
  sub true () {JSON::PP::true}
  
  sub _decode {
    my $valueref = shift;
  
    eval {
  
      # Missing input
      die "Missing or empty input\n" unless length(local $_ = shift);
  
      # UTF-8
      $_ = decode('UTF-8', $_) unless shift;
      die "Input is not UTF-8 encoded\n" unless defined;
  
      # Value
      $$valueref = _decode_value();
  
      # Leftover data
      /\G[\x20\x09\x0a\x0d]*\z/gc or _throw('Unexpected data');
    } ? return undef : chomp $@;
  
    return $@;
  }
  
  sub _decode_array {
    my @array;
    until (m/\G[\x20\x09\x0a\x0d]*\]/gc) {
  
      # Value
      push @array, _decode_value();
  
      # Separator
      redo if /\G[\x20\x09\x0a\x0d]*,/gc;
  
      # End
      last if /\G[\x20\x09\x0a\x0d]*\]/gc;
  
      # Invalid character
      _throw('Expected comma or right square bracket while parsing array');
    }
  
    return \@array;
  }
  
  sub _decode_object {
    my %hash;
    until (m/\G[\x20\x09\x0a\x0d]*\}/gc) {
  
      # Quote
      /\G[\x20\x09\x0a\x0d]*"/gc
        or _throw('Expected string while parsing object');
  
      # Key
      my $key = _decode_string();
  
      # Colon
      /\G[\x20\x09\x0a\x0d]*:/gc or _throw('Expected colon while parsing object');
  
      # Value
      $hash{$key} = _decode_value();
  
      # Separator
      redo if /\G[\x20\x09\x0a\x0d]*,/gc;
  
      # End
      last if /\G[\x20\x09\x0a\x0d]*\}/gc;
  
      # Invalid character
      _throw('Expected comma or right curly bracket while parsing object');
    }
  
    return \%hash;
  }
  
  sub _decode_string {
    my $pos = pos;
  
    # Extract string with escaped characters
    m!\G((?:(?:[^\x00-\x1f\\"]|\\(?:["\\/bfnrt]|u[0-9a-fA-F]{4})){0,32766})*)!gc;
    my $str = $1;
  
    # Invalid character
    unless (m/\G"/gc) {
      _throw('Unexpected character or invalid escape while parsing string')
        if /\G[\x00-\x1f\\]/;
      _throw('Unterminated string');
    }
  
    # Unescape popular characters
    if (index($str, '\\u') < 0) {
      $str =~ s!\\(["\\/bfnrt])!$ESCAPE{$1}!gs;
      return $str;
    }
  
    # Unescape everything else
    my $buffer = '';
    while ($str =~ /\G([^\\]*)\\(?:([^u])|u(.{4}))/gc) {
      $buffer .= $1;
  
      # Popular character
      if ($2) { $buffer .= $ESCAPE{$2} }
  
      # Escaped
      else {
        my $ord = hex $3;
  
        # Surrogate pair
        if (($ord & 0xf800) == 0xd800) {
  
          # High surrogate
          ($ord & 0xfc00) == 0xd800
            or pos = $pos + pos($str), _throw('Missing high-surrogate');
  
          # Low surrogate
          $str =~ /\G\\u([Dd][C-Fc-f]..)/gc
            or pos = $pos + pos($str), _throw('Missing low-surrogate');
  
          $ord = 0x10000 + ($ord - 0xd800) * 0x400 + (hex($1) - 0xdc00);
        }
  
        # Character
        $buffer .= pack 'U', $ord;
      }
    }
  
    # The rest
    return $buffer . substr $str, pos($str), length($str);
  }
  
  sub _decode_value {
  
    # Leading whitespace
    /\G[\x20\x09\x0a\x0d]*/gc;
  
    # String
    return _decode_string() if /\G"/gc;
  
    # Object
    return _decode_object() if /\G\{/gc;
  
    # Array
    return _decode_array() if /\G\[/gc;
  
    # Number
    return 0 + $1
      if /\G([-]?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?)/gc;
  
    # True
    return true() if /\Gtrue/gc;
  
    # False
    return false() if /\Gfalse/gc;
  
    # Null
    return undef if /\Gnull/gc;
  
    # Invalid character
    _throw('Expected string, array, object, number, boolean or null');
  }
  
  sub _encode_array {
    '[' . join(',', map { _encode_value($_) } @{$_[0]}) . ']';
  }
  
  sub _encode_object {
    my $object = shift;
    my @pairs = map { _encode_string($_) . ':' . _encode_value($object->{$_}) }
      sort keys %$object;
    return '{' . join(',', @pairs) . '}';
  }
  
  sub _encode_string {
    my $str = shift;
    $str =~ s!([\x00-\x1f\\"/])!$REVERSE{$1}!gs;
    return "\"$str\"";
  }
  
  sub _encode_value {
    my $value = shift;
  
    # Reference
    if (my $ref = ref $value) {
  
      # Object
      return _encode_object($value) if $ref eq 'HASH';
  
      # Array
      return _encode_array($value) if $ref eq 'ARRAY';
  
      # True or false
      return $$value ? 'true' : 'false' if $ref eq 'SCALAR';
      return $value  ? 'true' : 'false' if $ref eq 'JSON::PP::Boolean';
  
      # Everything else
      return 'null' unless blessed $value;
      return _encode_string($value) unless my $sub = $value->can('TO_JSON');
      return _encode_value($value->$sub);
    }
  
    # Null
    return 'null' unless defined $value;
  
    # Number
    no warnings 'numeric';
    return $value
      if !utf8::is_utf8($value)
      && length((my $dummy = '') & $value)
      && 0 + $value eq $value
      && $value * 0 == 0;
  
    # String
    return _encode_string($value);
  }
  
  sub _throw {
  
    # Leading whitespace
    /\G[\x20\x09\x0a\x0d]*/gc;
  
    # Context
    my $context = 'Malformed JSON: ' . shift;
    if (m/\G\z/gc) { $context .= ' before end of data' }
    else {
      my @lines = split "\n", substr($_, 0, pos);
      $context .= ' at line ' . @lines . ', offset ' . length(pop @lines || '');
    }
  
    die "$context\n";
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::JSON - Minimalistic JSON
  
  =head1 SYNOPSIS
  
    use Mojo::JSON qw(decode_json encode_json);
  
    my $bytes = encode_json {foo => [1, 2], bar => 'hello!', baz => \1};
    my $hash  = decode_json $bytes;
  
  =head1 DESCRIPTION
  
  L<Mojo::JSON> is a minimalistic and possibly the fastest pure-Perl
  implementation of L<RFC 8259|http://tools.ietf.org/html/rfc8259>.
  
  It supports normal Perl data types like scalar, array reference, hash reference
  and will try to call the C<TO_JSON> method on blessed references, or stringify
  them if it doesn't exist. Differentiating between strings and numbers in Perl
  is hard, depending on how it has been used, a scalar can be both at the same
  time. The string value has a higher precedence unless both representations are
  equivalent.
  
    [1, -2, 3]     -> [1, -2, 3]
    {"foo": "bar"} -> {foo => 'bar'}
  
  Literal names will be translated to and from L<Mojo::JSON> constants or a
  similar native Perl value.
  
    true  -> Mojo::JSON->true
    false -> Mojo::JSON->false
    null  -> undef
  
  In addition scalar references will be used to generate booleans, based on if
  their values are true or false.
  
    \1 -> true
    \0 -> false
  
  The character C</> will always be escaped to prevent XSS attacks.
  
    "</script>" -> "<\/script>"
  
  For better performance the optional module L<Cpanel::JSON::XS> (4.04+) will be
  used automatically if possible. This can also be disabled with the
  C<MOJO_NO_JSON_XS> environment variable.
  
  =head1 FUNCTIONS
  
  L<Mojo::JSON> implements the following functions, which can be imported
  individually.
  
  =head2 decode_json
  
    my $value = decode_json $bytes;
  
  Decode JSON to Perl value and die if decoding fails.
  
  =head2 encode_json
  
    my $bytes = encode_json {i => ' mojolicious'};
  
  Encode Perl value to JSON.
  
  =head2 false
  
    my $false = false;
  
  False value, used because Perl has no native equivalent.
  
  =head2 from_json
  
    my $value = from_json $chars;
  
  Decode JSON text that is not C<UTF-8> encoded to Perl value and die if decoding
  fails.
  
  =head2 j
  
    my $bytes = j [1, 2, 3];
    my $bytes = j {i => ' mojolicious'};
    my $value = j $bytes;
  
  Encode Perl data structure (which may only be an array reference or hash
  reference) or decode JSON, an C<undef> return value indicates a bare C<null> or
  that decoding failed.
  
  =head2 to_json
  
    my $chars = to_json {i => ' mojolicious'};
  
  Encode Perl value to JSON text without C<UTF-8> encoding it.
  
  =head2 true
  
    my $true = true;
  
  True value, used because Perl has no native equivalent.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_JSON

$fatpacked{"Mojo/JSON/Pointer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_JSON_POINTER';
  package Mojo::JSON::Pointer;
  use Mojo::Base -base;
  
  has 'data';
  
  sub contains { shift->_pointer(1, @_) }
  sub get      { shift->_pointer(0, @_) }
  
  sub new { @_ > 1 ? shift->SUPER::new(data => shift) : shift->SUPER::new }
  
  sub _pointer {
    my ($self, $contains, $pointer) = @_;
  
    my $data = $self->data;
    return $contains ? 1 : $data unless $pointer =~ s!^/!!;
    for my $p (length $pointer ? (split '/', $pointer, -1) : ($pointer)) {
      $p =~ s!~1!/!g;
      $p =~ s/~0/~/g;
  
      # Hash
      if (ref $data eq 'HASH' && exists $data->{$p}) { $data = $data->{$p} }
  
      # Array
      elsif (ref $data eq 'ARRAY' && $p =~ /^\d+$/ && @$data > $p) {
        $data = $data->[$p];
      }
  
      # Nothing
      else { return undef }
    }
  
    return $contains ? 1 : $data;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::JSON::Pointer - JSON Pointers
  
  =head1 SYNOPSIS
  
    use Mojo::JSON::Pointer;
  
    my $pointer = Mojo::JSON::Pointer->new({foo => [23, 'bar']});
    say $pointer->get('/foo/1');
    say 'Contains "/foo".' if $pointer->contains('/foo');
  
  =head1 DESCRIPTION
  
  L<Mojo::JSON::Pointer> is an implementation of
  L<RFC 6901|http://tools.ietf.org/html/rfc6901>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::JSON::Pointer> implements the following attributes.
  
  =head2 data
  
    my $data = $pointer->data;
    $pointer = $pointer->data({foo => 'bar'});
  
  Data structure to be processed.
  
  =head1 METHODS
  
  L<Mojo::JSON::Pointer> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 contains
  
    my $bool = $pointer->contains('/foo/1');
  
  Check if L</"data"> contains a value that can be identified with the given JSON
  Pointer.
  
    # True
    Mojo::JSON::Pointer->new('just a string')->contains('');
    Mojo::JSON::Pointer->new({'' => 'mojolicious'})->contains('/');
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5]})->contains('/foo');
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5]})->contains('/baz/1');
  
    # False
    Mojo::JSON::Pointer->new({'' => 'mojolicious'})->contains('/');
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5]})->contains('/bar');
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5]})->contains('/baz/9');
  
  =head2 get
  
    my $value = $pointer->get('/foo/bar');
  
  Extract value from L</"data"> identified by the given JSON Pointer.
  
    # "just a string"
    Mojo::JSON::Pointer->new('just a string')->get('');
  
    # "mojolicious"
    Mojo::JSON::Pointer->new({'' => 'mojolicious'})->get('/');
  
    # "bar"
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5, 6]})->get('/foo');
  
    # "4"
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5, 6]})->get('/baz/0');
  
    # "6"
    Mojo::JSON::Pointer->new({foo => 'bar', baz => [4, 5, 6]})->get('/baz/2');
  
  =head2 new
  
    my $pointer = Mojo::JSON::Pointer->new;
    my $pointer = Mojo::JSON::Pointer->new({foo => 'bar'});
  
  Build new L<Mojo::JSON::Pointer> object.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_JSON_POINTER

$fatpacked{"Mojo/Loader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_LOADER';
  package Mojo::Loader;
  use Mojo::Base -strict;
  
  use Exporter 'import';
  use Mojo::Exception;
  use Mojo::File 'path';
  use Mojo::Util qw(b64_decode class_to_path);
  
  our @EXPORT_OK
    = qw(data_section file_is_binary find_modules find_packages load_class);
  
  my (%BIN, %CACHE);
  
  sub data_section { $_[0] ? $_[1] ? _all($_[0])->{$_[1]} : _all($_[0]) : undef }
  
  sub file_is_binary { keys %{_all($_[0])} ? !!$BIN{$_[0]}{$_[1]} : undef }
  
  sub find_modules {
    my $ns = shift;
  
    my %modules;
    for my $directory (@INC) {
      next unless -d (my $path = path($directory, split(/::|'/, $ns)));
      $modules{"${ns}::$_"}++
        for $path->list->grep(qr/\.pm$/)->map('basename', '.pm')->each;
    }
  
    return sort keys %modules;
  }
  
  sub find_packages {
    my $ns = shift;
    no strict 'refs';
    return sort map { /^(.+)::$/ ? "${ns}::$1" : () } keys %{"${ns}::"};
  }
  
  sub load_class {
    my $class = shift;
  
    # Invalid class name
    return 1 if ($class || '') !~ /^\w(?:[\w:']*\w)?$/;
  
    # Load if not already loaded
    return undef if $class->can('new') || eval "require $class; 1";
  
    # Does not exist
    return 1 if $@ =~ /^Can't locate \Q@{[class_to_path $class]}\E in \@INC/;
  
    # Real error
    return Mojo::Exception->new($@)->inspect;
  }
  
  sub _all {
    my $class = shift;
  
    return $CACHE{$class} if $CACHE{$class};
    local $.;
    my $handle = do { no strict 'refs'; \*{"${class}::DATA"} };
    return {} unless fileno $handle;
    seek $handle, 0, 0;
    my $data = join '', <$handle>;
  
    # Ignore everything before __DATA__ (some versions seek to start of file)
    $data =~ s/^.*\n__DATA__\r?\n/\n/s;
  
    # Ignore everything after __END__
    $data =~ s/\n__END__\r?\n.*$/\n/s;
  
    # Split files
    (undef, my @files) = split /^@@\s*(.+?)\s*\r?\n/m, $data;
  
    # Find data
    my $all = $CACHE{$class} = {};
    while (@files) {
      my ($name, $data) = splice @files, 0, 2;
      $all->{$name} = $name =~ s/\s*\(\s*base64\s*\)$//
        && ++$BIN{$class}{$name} ? b64_decode $data : $data;
    }
  
    return $all;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Loader - Load all kinds of things
  
  =head1 SYNOPSIS
  
    use Mojo::Loader qw(data_section find_modules load_class);
  
    # Find modules in a namespace
    for my $module (find_modules 'Some::Namespace') {
  
      # Load them safely
      my $e = load_class $module;
      warn qq{Loading "$module" failed: $e} and next if ref $e;
  
      # And extract files from the DATA section
      say data_section($module, 'some_file.txt');
    }
  
  =head1 DESCRIPTION
  
  L<Mojo::Loader> is a class loader and plugin framework. Aside from finding
  modules and loading classes, it allows multiple files to be stored in the
  C<DATA> section of a class, which can then be accessed individually.
  
    package Foo;
  
    1;
    __DATA__
  
    @@ test.txt
    This is the first file.
  
    @@ test2.html (base64)
    VGhpcyBpcyB0aGUgc2Vjb25kIGZpbGUu
  
    @@ test
    This is the
    third file.
  
  Each file has a header starting with C<@@>, followed by the file name and
  optional instructions for decoding its content. Currently only the Base64
  encoding is supported, which can be quite convenient for the storage of binary
  data.
  
  =head1 FUNCTIONS
  
  L<Mojo::Loader> implements the following functions, which can be imported
  individually.
  
  =head2 data_section
  
    my $all   = data_section 'Foo::Bar';
    my $index = data_section 'Foo::Bar', 'index.html';
  
  Extract embedded file from the C<DATA> section of a class, all files will be
  cached once they have been accessed for the first time.
  
    # List embedded files
    say for keys %{data_section 'Foo::Bar'};
  
  =head2 file_is_binary
  
    my $bool = file_is_binary 'Foo::Bar', 'test.png';
  
  Check if embedded file from the C<DATA> section of a class was Base64 encoded.
  
  =head2 find_packages
  
    my @pkgs = find_packages 'MyApp::Namespace';
  
  Search for packages in a namespace non-recursively.
  
  =head2 find_modules
  
    my @modules = find_modules 'MyApp::Namespace';
  
  Search for modules in a namespace non-recursively.
  
  =head2 load_class
  
    my $e = load_class 'Foo::Bar';
  
  Load a class and catch exceptions, returns a false value if loading was
  successful, a true value if the class was not found, or a L<Mojo::Exception>
  object if loading failed. Note that classes are checked for a C<new> method to
  see if they are already loaded, so trying to load the same class multiple times
  may yield different results.
  
    # Handle exceptions
    if (my $e = load_class 'Foo::Bar') {
      die ref $e ? "Exception: $e" : 'Not found!';
    }
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_LOADER

$fatpacked{"Mojo/Log.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_LOG';
  package Mojo::Log;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Fcntl ':flock';
  use Mojo::File;
  use Mojo::Util 'encode';
  
  has format => sub { shift->short ? \&_short : \&_default };
  has handle => sub {
  
    # STDERR
    return \*STDERR unless my $path = shift->path;
  
    # File
    return Mojo::File->new($path)->open('>>');
  };
  has history          => sub { [] };
  has level            => 'debug';
  has max_history_size => 10;
  has 'path';
  has short => sub { $ENV{MOJO_LOG_SHORT} };
  
  # Supported log levels
  my %LEVEL = (debug => 1, info => 2, warn => 3, error => 4, fatal => 5);
  
  # Systemd magic numbers
  my %MAGIC = (debug => 7, info => 6, warn => 4, error => 3, fatal => 2);
  
  sub append {
    my ($self, $msg) = @_;
  
    return unless my $handle = $self->handle;
    flock $handle, LOCK_EX;
    $handle->print(encode('UTF-8', $msg)) or croak "Can't write to log: $!";
    flock $handle, LOCK_UN;
  }
  
  sub debug { shift->_log(debug => @_) }
  sub error { shift->_log(error => @_) }
  sub fatal { shift->_log(fatal => @_) }
  sub info  { shift->_log(info  => @_) }
  
  sub is_level { $LEVEL{pop()} >= $LEVEL{$ENV{MOJO_LOG_LEVEL} || shift->level} }
  
  sub new {
    my $self = shift->SUPER::new(@_);
    $self->on(message => \&_message);
    return $self;
  }
  
  sub warn { shift->_log(warn => @_) }
  
  sub _default {
    '[' . localtime(shift) . '] [' . shift() . '] ' . join "\n", @_, '';
  }
  
  sub _log { shift->emit('message', shift, @_) }
  
  sub _message {
    my ($self, $level) = (shift, shift);
  
    return unless $self->is_level($level);
  
    my $max     = $self->max_history_size;
    my $history = $self->history;
    push @$history, my $msg = [time, $level, @_];
    shift @$history while @$history > $max;
  
    $self->append($self->format->(@$msg));
  }
  
  sub _short {
    my ($time, $level) = (shift, shift);
    my ($magic, $short) = ("<$MAGIC{$level}>", substr($level, 0, 1));
    return "${magic}[$short] " . join("\n$magic", @_) . "\n";
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Log - Simple logger
  
  =head1 SYNOPSIS
  
    use Mojo::Log;
  
    # Log to STDERR
    my $log = Mojo::Log->new;
  
    # Customize log file location and minimum log level
    my $log = Mojo::Log->new(path => '/var/log/mojo.log', level => 'warn');
  
    # Log messages
    $log->debug('Not sure what is happening here');
    $log->info('FYI: it happened again');
    $log->warn('This might be a problem');
    $log->error('Garden variety error');
    $log->fatal('Boom');
  
  =head1 DESCRIPTION
  
  L<Mojo::Log> is a simple logger for L<Mojo> projects.
  
  =head1 EVENTS
  
  L<Mojo::Log> inherits all events from L<Mojo::EventEmitter> and can emit the
  following new ones.
  
  =head2 message
  
    $log->on(message => sub {
      my ($log, $level, @lines) = @_;
      ...
    });
  
  Emitted when a new message gets logged.
  
    $log->on(message => sub {
      my ($log, $level, @lines) = @_;
      say "$level: ", @lines;
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Log> implements the following attributes.
  
  =head2 format
  
    my $cb = $log->format;
    $log   = $log->format(sub {...});
  
  A callback for formatting log messages.
  
    $log->format(sub {
      my ($time, $level, @lines) = @_;
      return "[Thu May 15 17:47:04 2014] [info] I  Mojolicious\n";
    });
  
  =head2 handle
  
    my $handle = $log->handle;
    $log       = $log->handle(IO::Handle->new);
  
  Log filehandle used by default L</"message"> event, defaults to opening
  L</"path"> or C<STDERR>.
  
  =head2 history
  
    my $history = $log->history;
    $log        = $log->history([[time, 'debug', 'That went wrong']]);
  
  The last few logged messages.
  
  =head2 level
  
    my $level = $log->level;
    $log      = $log->level('debug');
  
  Active log level, defaults to C<debug>. Available log levels are C<debug>,
  C<info>, C<warn>, C<error> and C<fatal>, in that order. Note that the
  C<MOJO_LOG_LEVEL> environment variable can override this value.
  
  =head2 max_history_size
  
    my $size = $log->max_history_size;
    $log     = $log->max_history_size(5);
  
  Maximum number of logged messages to store in L</"history">, defaults to C<10>.
  
  =head2 path
  
    my $path = $log->path
    $log     = $log->path('/var/log/mojo.log');
  
  Log file path used by L</"handle">.
  
  =head2 short
  
    my $bool = $log->short;
    $log     = $log->short($bool);
  
  Generate short log messages without a timestamp, suitable for systemd, defaults
  to the value of the C<MOJO_LOG_SHORT> environment variables.
  
  =head1 METHODS
  
  L<Mojo::Log> inherits all methods from L<Mojo::EventEmitter> and implements the
  following new ones.
  
  =head2 append
  
    $log->append("[Thu May 15 17:47:04 2014] [info] I  Mojolicious\n");
  
  Append message to L</"handle">.
  
  =head2 debug
  
    $log = $log->debug('You screwed up, but that is ok');
    $log = $log->debug('All', 'cool');
  
  Emit L</"message"> event and log C<debug> message.
  
  =head2 error
  
    $log = $log->error('You really screwed up this time');
    $log = $log->error('Wow', 'seriously');
  
  Emit L</"message"> event and log C<error> message.
  
  =head2 fatal
  
    $log = $log->fatal('Its over...');
    $log = $log->fatal('Bye', 'bye');
  
  Emit L</"message"> event and log C<fatal> message.
  
  =head2 info
  
    $log = $log->info('You are bad, but you prolly know already');
    $log = $log->info('Ok', 'then');
  
  Emit L</"message"> event and log C<info> message.
  
  =head2 is_level
  
    my $bool = $log->is_level('debug');
  
  Check active log L</"level">.
  
    # True
    $log->level('debug')->is_level('debug');
    $log->level('debug')->is_level('info');
  
    # False
    $log->level('info')->is_level('debug');
    $log->level('fatal')->is_level('warn');
  
  =head2 new
  
    my $log = Mojo::Log->new;
    my $log = Mojo::Log->new(level => 'warn');
    my $log = Mojo::Log->new({level => 'warn'});
  
  Construct a new L<Mojo::Log> object and subscribe to L</"message"> event with
  default logger.
  
  =head2 warn
  
    $log = $log->warn('Dont do that Dave...');
    $log = $log->warn('No', 'really');
  
  Emit L</"message"> event and log C<warn> message.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_LOG

$fatpacked{"Mojo/Message.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_MESSAGE';
  package Mojo::Message;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Mojo::Asset::Memory;
  use Mojo::Content::Single;
  use Mojo::DOM;
  use Mojo::JSON 'j';
  use Mojo::JSON::Pointer;
  use Mojo::Parameters;
  use Mojo::Upload;
  use Mojo::Util 'decode';
  
  has content          => sub { Mojo::Content::Single->new };
  has default_charset  => 'UTF-8';
  has max_line_size    => sub { $ENV{MOJO_MAX_LINE_SIZE} || 8192 };
  has max_message_size => sub { $ENV{MOJO_MAX_MESSAGE_SIZE} // 16777216 };
  has version          => '1.1';
  
  sub body {
    my $self = shift;
  
    # Get
    my $content = $self->content;
    return $content->is_multipart ? '' : $content->asset->slurp unless @_;
  
    # Set (multipart content needs to be downgraded)
    $content = $self->content(Mojo::Content::Single->new)->content
      if $content->is_multipart;
    $content->asset(Mojo::Asset::Memory->new->add_chunk(@_));
  
    return $self;
  }
  
  sub body_params {
    my $self = shift;
  
    return $self->{body_params} if $self->{body_params};
    my $params = $self->{body_params} = Mojo::Parameters->new;
    $params->charset($self->content->charset || $self->default_charset);
  
    # "application/x-www-form-urlencoded"
    my $type = $self->headers->content_type // '';
    if ($type =~ m!application/x-www-form-urlencoded!i) {
      $params->parse($self->content->asset->slurp);
    }
  
    # "multipart/form-data"
    elsif ($type =~ m!multipart/form-data!i) {
      $params->append(@$_[0, 1]) for @{$self->_parse_formdata};
    }
  
    return $params;
  }
  
  sub body_size { shift->content->body_size }
  
  sub build_body       { shift->_build('get_body_chunk') }
  sub build_headers    { shift->_build('get_header_chunk') }
  sub build_start_line { shift->_build('get_start_line_chunk') }
  
  sub cookie { shift->_cache('cookies', 0, @_) }
  
  sub cookies { croak 'Method "cookies" not implemented by subclass' }
  
  sub dom {
    my $self = shift;
    return undef if $self->content->is_multipart;
    my $dom = $self->{dom} ||= Mojo::DOM->new($self->text);
    return @_ ? $dom->find(@_) : $dom;
  }
  
  sub error {
    my $self = shift;
    return $self->{error} unless @_;
    $self->{error} = shift;
    return $self->finish;
  }
  
  sub every_cookie { shift->_cache('cookies', 1, @_) }
  sub every_upload { shift->_cache('uploads', 1, @_) }
  
  sub extract_start_line {
    croak 'Method "extract_start_line" not implemented by subclass';
  }
  
  sub finish {
    my $self = shift;
    $self->{state} = 'finished';
    return $self->{finished}++ ? $self : $self->emit('finish');
  }
  
  sub fix_headers {
    my $self = shift;
    return $self if $self->{fix}++;
  
    # Content-Length or Connection (unless chunked transfer encoding is used)
    my $content = $self->content;
    my $headers = $content->headers;
    if ($content->is_multipart) { $headers->remove('Content-Length') }
    elsif ($content->is_chunked || $headers->content_length) { return $self }
    if   ($content->is_dynamic) { $headers->connection('close') }
    else                        { $headers->content_length($self->body_size) }
  
    return $self;
  }
  
  sub get_body_chunk {
    my ($self, $offset) = @_;
  
    $self->emit('progress', 'body', $offset);
    my $chunk = $self->content->get_body_chunk($offset);
    return $chunk if !defined $chunk || length $chunk;
    $self->finish;
  
    return $chunk;
  }
  
  sub get_header_chunk {
    my ($self, $offset) = @_;
    $self->emit('progress', 'headers', $offset);
    return $self->fix_headers->content->get_header_chunk($offset);
  }
  
  sub get_start_line_chunk {
    croak 'Method "get_start_line_chunk" not implemented by subclass';
  }
  
  sub header_size { shift->fix_headers->content->header_size }
  
  sub headers { shift->content->headers }
  
  sub is_finished { (shift->{state} // '') eq 'finished' }
  
  sub is_limit_exceeded { !!shift->{limit} }
  
  sub json {
    my ($self, $pointer) = @_;
    return undef if $self->content->is_multipart;
    my $data = $self->{json} //= j($self->body);
    return $pointer ? Mojo::JSON::Pointer->new($data)->get($pointer) : $data;
  }
  
  sub parse {
    my ($self, $chunk) = @_;
  
    return $self if $self->{error};
    $self->{raw_size} += length $chunk;
    $self->{buffer} .= $chunk;
  
    # Start-line
    unless ($self->{state}) {
  
      # Check start-line size
      my $len = index $self->{buffer}, "\x0a";
      $len = length $self->{buffer} if $len < 0;
      return $self->_limit('Maximum start-line size exceeded')
        if $len > $self->max_line_size;
  
      $self->{state} = 'content' if $self->extract_start_line(\$self->{buffer});
    }
  
    # Content
    my $state = $self->{state} // '';
    $self->content($self->content->parse(delete $self->{buffer}))
      if $state eq 'content' || $state eq 'finished';
  
    # Check message size
    my $max = $self->max_message_size;
    return $self->_limit('Maximum message size exceeded')
      if $max && $max < $self->{raw_size};
  
    # Check header size
    return $self->_limit('Maximum header size exceeded')
      if $self->headers->is_limit_exceeded;
  
    # Check buffer size
    return $self->_limit('Maximum buffer size exceeded')
      if $self->content->is_limit_exceeded;
  
    return $self->emit('progress')->content->is_finished ? $self->finish : $self;
  }
  
  sub start_line_size {
    croak 'Method "start_line_size" not implemented by subclass';
  }
  
  sub text {
    my $self    = shift;
    my $body    = $self->body;
    my $charset = $self->content->charset || $self->default_charset;
    return $charset ? decode($charset, $body) // $body : $body;
  }
  
  sub to_string {
    my $self = shift;
    return $self->build_start_line . $self->build_headers . $self->build_body;
  }
  
  sub upload { shift->_cache('uploads', 0, @_) }
  
  sub uploads {
    my $self = shift;
  
    my @uploads;
    for my $data (@{$self->_parse_formdata(1)}) {
      my $upload = Mojo::Upload->new(
        name     => $data->[0],
        filename => $data->[2],
        asset    => $data->[1]->asset,
        headers  => $data->[1]->headers
      );
      push @uploads, $upload;
    }
  
    return \@uploads;
  }
  
  sub _build {
    my ($self, $method) = @_;
  
    my ($buffer, $offset) = ('', 0);
    while (1) {
  
      # No chunk yet, try again
      next unless defined(my $chunk = $self->$method($offset));
  
      # End of part
      last unless my $len = length $chunk;
  
      $offset += $len;
      $buffer .= $chunk;
    }
  
    return $buffer;
  }
  
  sub _cache {
    my ($self, $method, $all, $name) = @_;
  
    # Cache objects by name
    unless ($self->{$method}) {
      $self->{$method} = {};
      push @{$self->{$method}{$_->name}}, $_ for @{$self->$method};
    }
  
    my $objects = $self->{$method}{$name} || [];
    return $all ? $objects : $objects->[-1];
  }
  
  sub _limit { ++$_[0]{limit} and return $_[0]->error({message => $_[1]}) }
  
  sub _parse_formdata {
    my ($self, $upload) = @_;
  
    my @formdata;
    my $content = $self->content;
    return \@formdata unless $content->is_multipart;
    my $charset = $content->charset || $self->default_charset;
  
    # Check all parts recursively
    my @parts = ($content);
    while (my $part = shift @parts) {
  
      if ($part->is_multipart) {
        unshift @parts, @{$part->parts};
        next;
      }
  
      next unless my $disposition = $part->headers->content_disposition;
      my ($filename) = $disposition =~ /[; ]filename="((?:\\"|[^"])*)"/;
      next if $upload && !defined $filename || !$upload && defined $filename;
      my ($name) = $disposition =~ /[; ]name="((?:\\"|[^;"])*)"/;
      $part = $part->asset->slurp unless $upload;
  
      if ($charset) {
        $name     = decode($charset, $name) // $name         if $name;
        $filename = decode($charset, $filename) // $filename if $filename;
        $part = decode($charset, $part) // $part unless $upload;
      }
  
      push @formdata, [$name, $part, $filename];
    }
  
    return \@formdata;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Message - HTTP message base class
  
  =head1 SYNOPSIS
  
    package Mojo::Message::MyMessage;
    use Mojo::Base 'Mojo::Message';
  
    sub cookies              {...}
    sub extract_start_line   {...}
    sub get_start_line_chunk {...}
    sub start_line_size      {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Message> is an abstract base class for HTTP message containers, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230>,
  L<RFC 7231|http://tools.ietf.org/html/rfc7231> and
  L<RFC 2388|http://tools.ietf.org/html/rfc2388>, like L<Mojo::Message::Request>
  and L<Mojo::Message::Response>.
  
  =head1 EVENTS
  
  L<Mojo::Message> inherits all events from L<Mojo::EventEmitter> and can emit
  the following new ones.
  
  =head2 finish
  
    $msg->on(finish => sub {
      my $msg = shift;
      ...
    });
  
  Emitted after message building or parsing is finished.
  
    my $before = time;
    $msg->on(finish => sub {
      my $msg = shift;
      $msg->headers->header('X-Parser-Time' => time - $before);
    });
  
  =head2 progress
  
    $msg->on(progress => sub {
      my $msg = shift;
      ...
    });
  
  Emitted when message building or parsing makes progress.
  
    # Building
    $msg->on(progress => sub {
      my ($msg, $state, $offset) = @_;
      say qq{Building "$state" at offset $offset};
    });
  
    # Parsing
    $msg->on(progress => sub {
      my $msg = shift;
      return unless my $len = $msg->headers->content_length;
      my $size = $msg->content->progress;
      say 'Progress: ', $size == $len ? 100 : int($size / ($len / 100)), '%';
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Message> implements the following attributes.
  
  =head2 content
  
    my $msg = $msg->content;
    $msg    = $msg->content(Mojo::Content::Single->new);
  
  Message content, defaults to a L<Mojo::Content::Single> object.
  
  =head2 default_charset
  
    my $charset = $msg->default_charset;
    $msg        = $msg->default_charset('UTF-8');
  
  Default charset used by L</"text"> and to extract data from
  C<application/x-www-form-urlencoded> or C<multipart/form-data> message body,
  defaults to C<UTF-8>.
  
  =head2 max_line_size
  
    my $size = $msg->max_line_size;
    $msg     = $msg->max_line_size(1024);
  
  Maximum start-line size in bytes, defaults to the value of the
  C<MOJO_MAX_LINE_SIZE> environment variable or C<8192> (8KiB).
  
  =head2 max_message_size
  
    my $size = $msg->max_message_size;
    $msg     = $msg->max_message_size(1024);
  
  Maximum message size in bytes, defaults to the value of the
  C<MOJO_MAX_MESSAGE_SIZE> environment variable or C<16777216> (16MiB). Setting
  the value to C<0> will allow messages of indefinite size.
  
  =head2 version
  
    my $version = $msg->version;
    $msg        = $msg->version('1.1');
  
  HTTP version of message, defaults to C<1.1>.
  
  =head1 METHODS
  
  L<Mojo::Message> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 body
  
    my $bytes = $msg->body;
    $msg      = $msg->body('Hello!');
  
  Slurp or replace L</"content">.
  
  =head2 body_params
  
    my $params = $msg->body_params;
  
  C<POST> parameters extracted from C<application/x-www-form-urlencoded> or
  C<multipart/form-data> message body, usually a L<Mojo::Parameters> object. Note
  that this method caches all data, so it should not be called before the entire
  message body has been received. Parts of the message body need to be loaded
  into memory to parse C<POST> parameters, so you have to make sure it is not
  excessively large. There's a 16MiB limit for requests and a 2GiB limit for
  responses by default.
  
    # Get POST parameter names and values
    my $hash = $msg->body_params->to_hash;
  
  =head2 body_size
  
    my $size = $msg->body_size;
  
  Content size in bytes.
  
  =head2 build_body
  
    my $bytes = $msg->build_body;
  
  Render whole body with L</"get_body_chunk">.
  
  =head2 build_headers
  
    my $bytes = $msg->build_headers;
  
  Render all headers with L</"get_header_chunk">.
  
  =head2 build_start_line
  
    my $bytes = $msg->build_start_line;
  
  Render start-line with L</"get_start_line_chunk">.
  
  =head2 cookie
  
    my $cookie = $msg->cookie('foo');
  
  Access message cookies, usually L<Mojo::Cookie::Request> or
  L<Mojo::Cookie::Response> objects. If there are multiple cookies sharing the
  same name, and you want to access more than just the last one, you can use
  L</"every_cookie">. Note that this method caches all data, so it should not be
  called before all headers have been received.
  
    # Get cookie value
    say $msg->cookie('foo')->value;
  
  =head2 cookies
  
    my $cookies = $msg->cookies;
  
  Access message cookies. Meant to be overloaded in a subclass.
  
  =head2 dom
  
    my $dom        = $msg->dom;
    my $collection = $msg->dom('a[href]');
  
  Retrieve message body from L</"text"> and turn it into a L<Mojo::DOM> object,
  an optional selector can be used to call the method L<Mojo::DOM/"find"> on it
  right away, which then returns a L<Mojo::Collection> object. Note that this
  method caches all data, so it should not be called before the entire message
  body has been received. The whole message body needs to be loaded into memory
  to parse it, so you have to make sure it is not excessively large. There's a
  16MiB limit for requests and a 2GiB limit for responses by default.
  
    # Perform "find" right away
    say $msg->dom('h1, h2, h3')->map('text')->join("\n");
  
    # Use everything else Mojo::DOM has to offer
    say $msg->dom->at('title')->text;
    say $msg->dom->at('body')->children->map('tag')->uniq->join("\n");
  
  =head2 error
  
    my $err = $msg->error;
    $msg    = $msg->error({message => 'Parser error'});
  
  Get or set message error, an C<undef> return value indicates that there is no
  error.
  
    # Connection or parser error
    $msg->error({message => 'Connection refused'});
  
    # 4xx/5xx response
    $msg->error({message => 'Internal Server Error', code => 500});
  
  =head2 every_cookie
  
    my $cookies = $msg->every_cookie('foo');
  
  Similar to L</"cookie">, but returns all message cookies sharing the same name
  as an array reference.
  
    # Get first cookie value
    say $msg->every_cookie('foo')->[0]->value;
  
  =head2 every_upload
  
    my $uploads = $msg->every_upload('foo');
  
  Similar to L</"upload">, but returns all file uploads sharing the same name as
  an array reference.
  
    # Get content of first uploaded file
    say $msg->every_upload('foo')->[0]->asset->slurp;
  
  =head2 extract_start_line
  
    my $bool = $msg->extract_start_line(\$str);
  
  Extract start-line from string. Meant to be overloaded in a subclass.
  
  =head2 finish
  
    $msg = $msg->finish;
  
  Finish message parser/generator.
  
  =head2 fix_headers
  
    $msg = $msg->fix_headers;
  
  Make sure message has all required headers.
  
  =head2 get_body_chunk
  
    my $bytes = $msg->get_body_chunk($offset);
  
  Get a chunk of body data starting from a specific position. Note that it might
  not be possible to get the same chunk twice if content was generated
  dynamically.
  
  =head2 get_header_chunk
  
    my $bytes = $msg->get_header_chunk($offset);
  
  Get a chunk of header data, starting from a specific position. Note that this
  method finalizes the message.
  
  =head2 get_start_line_chunk
  
    my $bytes = $msg->get_start_line_chunk($offset);
  
  Get a chunk of start-line data starting from a specific position. Meant to be
  overloaded in a subclass.
  
  =head2 header_size
  
    my $size = $msg->header_size;
  
  Size of headers in bytes. Note that this method finalizes the message.
  
  =head2 headers
  
    my $headers = $msg->headers;
  
  Message headers, usually a L<Mojo::Headers> object.
  
    # Longer version
    my $headers = $msg->content->headers;
  
  =head2 is_finished
  
    my $bool = $msg->is_finished;
  
  Check if message parser/generator is finished.
  
  =head2 is_limit_exceeded
  
    my $bool = $msg->is_limit_exceeded;
  
  Check if message has exceeded L</"max_line_size">, L</"max_message_size">,
  L<Mojo::Content/"max_buffer_size"> or L<Mojo::Headers/"max_line_size">.
  
  =head2 json
  
    my $value = $msg->json;
    my $value = $msg->json('/foo/bar');
  
  Decode JSON message body directly using L<Mojo::JSON> if possible, an C<undef>
  return value indicates a bare C<null> or that decoding failed. An optional JSON
  Pointer can be used to extract a specific value with L<Mojo::JSON::Pointer>.
  Note that this method caches all data, so it should not be called before the
  entire message body has been received. The whole message body needs to be
  loaded into memory to parse it, so you have to make sure it is not excessively
  large. There's a 16MiB limit for requests and a 2GiB limit for responses by
  default.
  
    # Extract JSON values
    say $msg->json->{foo}{bar}[23];
    say $msg->json('/foo/bar/23');
  
  =head2 parse
  
    $msg = $msg->parse('HTTP/1.1 200 OK...');
  
  Parse message chunk.
  
  =head2 start_line_size
  
    my $size = $msg->start_line_size;
  
  Size of the start-line in bytes. Meant to be overloaded in a subclass.
  
  =head2 text
  
    my $str = $msg->text;
  
  Retrieve L</"body"> and try to decode it with L<Mojo::Content/"charset"> or
  L</"default_charset">.
  
  =head2 to_string
  
    my $str = $msg->to_string;
  
  Render whole message. Note that this method finalizes the message, and that it
  might not be possible to render the same message twice if content was generated
  dynamically.
  
  =head2 upload
  
    my $upload = $msg->upload('foo');
  
  Access C<multipart/form-data> file uploads, usually L<Mojo::Upload> objects. If
  there are multiple uploads sharing the same name, and you want to access more
  than just the last one, you can use L</"every_upload">. Note that this method
  caches all data, so it should not be called before the entire message body has
  been received.
  
    # Get content of uploaded file
    say $msg->upload('foo')->asset->slurp;
  
  =head2 uploads
  
    my $uploads = $msg->uploads;
  
  All C<multipart/form-data> file uploads, usually L<Mojo::Upload> objects.
  
    # Names of all uploads
    say $_->name for @{$msg->uploads};
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_MESSAGE

$fatpacked{"Mojo/Message/Request.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_MESSAGE_REQUEST';
  package Mojo::Message::Request;
  use Mojo::Base 'Mojo::Message';
  
  use Mojo::Cookie::Request;
  use Mojo::Util qw(b64_encode b64_decode sha1_sum);
  use Mojo::URL;
  
  my ($SEED, $COUNTER) = (rand, int rand 0xffffff);
  
  has env => sub { {} };
  has method => 'GET';
  has [qw(proxy reverse_proxy)];
  has request_id => sub {
    substr sha1_sum($SEED . $$ . ($COUNTER = ($COUNTER + 1) % 0xffffff)), 0, 8;
  };
  has url => sub { Mojo::URL->new };
  has via_proxy => 1;
  
  sub clone {
    my $self = shift;
  
    # Dynamic requests cannot be cloned
    return undef unless my $content = $self->content->clone;
    my $clone = $self->new(
      content => $content,
      method  => $self->method,
      url     => $self->url->clone,
      version => $self->version
    );
    $clone->{proxy} = $self->{proxy}->clone if $self->{proxy};
  
    return $clone;
  }
  
  sub cookies {
    my $self = shift;
  
    # Parse cookies
    my $headers = $self->headers;
    return [map { @{Mojo::Cookie::Request->parse($_)} } $headers->cookie]
      unless @_;
  
    # Add cookies
    my @cookies = map { ref $_ eq 'HASH' ? Mojo::Cookie::Request->new($_) : $_ }
      $headers->cookie || (), @_;
    $headers->cookie(join '; ', @cookies);
  
    return $self;
  }
  
  sub every_param { shift->params->every_param(@_) }
  
  sub extract_start_line {
    my ($self, $bufref) = @_;
  
    # Ignore any leading empty lines
    return undef unless $$bufref =~ s/^\s*(.*?)\x0d?\x0a//;
  
    # We have a (hopefully) full request-line
    return !$self->error({message => 'Bad request start-line'})
      unless $1 =~ /^(\S+)\s+(\S+)\s+HTTP\/(\d\.\d)$/;
    my $url    = $self->method($1)->version($3)->url;
    my $target = $2;
    return !!$url->host_port($target) if $1 eq 'CONNECT';
    return !!$url->parse($target)->fragment(undef) if $target =~ /^[^:\/?#]+:/;
    return !!$url->path_query($target);
  }
  
  sub fix_headers {
    my $self = shift;
    $self->{fix} ? return $self : $self->SUPER::fix_headers(@_);
  
    # Host
    my $url     = $self->url;
    my $headers = $self->headers;
    $headers->host($url->host_port) unless $headers->host;
  
    # Basic authentication
    if ((my $info = $url->userinfo) && !$headers->authorization) {
      $headers->authorization('Basic ' . b64_encode($info, ''));
    }
  
    # Basic proxy authentication
    return $self unless (my $proxy = $self->proxy) && $self->via_proxy;
    return $self unless my $info = $proxy->userinfo;
    $headers->proxy_authorization('Basic ' . b64_encode($info, ''))
      unless $headers->proxy_authorization;
    return $self;
  }
  
  sub get_start_line_chunk {
    my ($self, $offset) = @_;
    $self->_start_line->emit(progress => 'start_line', $offset);
    return substr $self->{start_buffer}, $offset, 131072;
  }
  
  sub is_handshake { lc($_[0]->headers->upgrade // '') eq 'websocket' }
  
  sub is_secure {
    my $url = shift->url;
    return ($url->protocol || $url->base->protocol) eq 'https';
  }
  
  sub is_xhr {
    (shift->headers->header('X-Requested-With') // '') =~ /XMLHttpRequest/i;
  }
  
  sub param { shift->params->param(@_) }
  
  sub params {
    my $self = shift;
    return $self->{params}
      ||= $self->body_params->clone->append($self->query_params);
  }
  
  sub parse {
    my $self = shift;
    my ($env, $chunk) = ref $_[0] ? (shift, '') : (undef, shift);
  
    # Parse CGI environment
    $self->env($env)->_parse_env($env) if $env;
  
    # Parse normal message
    if (($self->{state} // '') ne 'cgi') { $self->SUPER::parse($chunk) }
  
    # Parse CGI content
    else { $self->content($self->content->parse_body($chunk))->SUPER::parse('') }
  
    # Check if we can fix things that require all headers
    return $self unless $self->is_finished;
  
    # Base URL
    my $base = $self->url->base;
    $base->scheme('http') unless $base->scheme;
    my $headers = $self->headers;
    if (!$base->host && (my $host = $headers->host)) { $base->host_port($host) }
  
    # Basic authentication
    if (my $basic = _basic($headers->authorization)) { $base->userinfo($basic) }
  
    # Basic proxy authentication
    my $basic = _basic($headers->proxy_authorization);
    $self->proxy(Mojo::URL->new->userinfo($basic)) if $basic;
  
    # "X-Forwarded-Proto"
    $base->scheme('https')
      if $self->reverse_proxy
      && ($headers->header('X-Forwarded-Proto') // '') eq 'https';
  
    return $self;
  }
  
  sub query_params { shift->url->query }
  
  sub start_line_size { length shift->_start_line->{start_buffer} }
  
  sub _basic { $_[0] && $_[0] =~ /Basic (.+)$/ ? b64_decode $1 : undef }
  
  sub _parse_env {
    my ($self, $env) = @_;
  
    # Bypass normal message parser
    $self->{state} = 'cgi';
  
    # Extract headers
    my $headers = $self->headers;
    my $url     = $self->url;
    my $base    = $url->base;
    for my $name (keys %$env) {
      my $value = $env->{$name};
      next unless $name =~ s/^HTTP_//i;
      $name =~ y/_/-/;
      $headers->header($name => $value);
  
      # Host/Port
      $value =~ s/:(\d+)$// ? $base->host($value)->port($1) : $base->host($value)
        if $name eq 'HOST';
    }
  
    # Content-Type is a special case on some servers
    $headers->content_type($env->{CONTENT_TYPE}) if $env->{CONTENT_TYPE};
  
    # Content-Length is a special case on some servers
    $headers->content_length($env->{CONTENT_LENGTH}) if $env->{CONTENT_LENGTH};
  
    # Query
    $url->query->parse($env->{QUERY_STRING}) if $env->{QUERY_STRING};
  
    # Method
    $self->method($env->{REQUEST_METHOD}) if $env->{REQUEST_METHOD};
  
    # Scheme/Version
    $base->scheme($1) and $self->version($2)
      if ($env->{SERVER_PROTOCOL} // '') =~ m!^([^/]+)/([^/]+)$!;
  
    # HTTPS
    $base->scheme('https') if uc($env->{HTTPS} // '') eq 'ON';
  
    # Path
    my $path = $url->path->parse($env->{PATH_INFO} ? $env->{PATH_INFO} : '');
  
    # Base path
    if (my $value = $env->{SCRIPT_NAME}) {
  
      # Make sure there is a trailing slash (important for merging)
      $base->path->parse($value =~ m!/$! ? $value : "$value/");
  
      # Remove SCRIPT_NAME prefix if necessary
      my $buffer = $path->to_string;
      $value =~ s!^/|/$!!g;
      $buffer =~ s!^/?\Q$value\E/?!!;
      $buffer =~ s!^/!!;
      $path->parse($buffer);
    }
  }
  
  sub _start_line {
    my $self = shift;
  
    return $self if defined $self->{start_buffer};
  
    # Path
    my $url  = $self->url;
    my $path = $url->path_query;
    $path = "/$path" unless $path =~ m!^/!;
  
    # CONNECT
    my $method = uc $self->method;
    if ($method eq 'CONNECT') {
      my $port = $url->port // ($url->protocol eq 'https' ? '443' : '80');
      $path = $url->ihost . ":$port";
    }
  
    # Proxy
    elsif ($self->proxy && $self->via_proxy && $url->protocol ne 'https') {
      $path = $url->clone->userinfo(undef) unless $self->is_handshake;
    }
  
    $self->{start_buffer} = "$method $path HTTP/@{[$self->version]}\x0d\x0a";
  
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Message::Request - HTTP request
  
  =head1 SYNOPSIS
  
    use Mojo::Message::Request;
  
    # Parse
    my $req = Mojo::Message::Request->new;
    $req->parse("GET /foo HTTP/1.0\x0d\x0a");
    $req->parse("Content-Length: 12\x0d\x0a");
    $req->parse("Content-Type: text/plain\x0d\x0a\x0d\x0a");
    $req->parse('Hello World!');
    say $req->method;
    say $req->headers->content_type;
    say $req->body;
  
    # Build
    my $req = Mojo::Message::Request->new;
    $req->url->parse('http://127.0.0.1/foo/bar');
    $req->method('GET');
    say $req->to_string;
  
  =head1 DESCRIPTION
  
  L<Mojo::Message::Request> is a container for HTTP requests, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230>,
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>,
  L<RFC 7235|http://tools.ietf.org/html/rfc7235> and
  L<RFC 2817|http://tools.ietf.org/html/rfc2817>.
  
  =head1 EVENTS
  
  L<Mojo::Message::Request> inherits all events from L<Mojo::Message>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Message::Request> inherits all attributes from L<Mojo::Message> and
  implements the following new ones.
  
  =head2 env
  
    my $env = $req->env;
    $req    = $req->env({PATH_INFO => '/'});
  
  Direct access to the C<CGI> or C<PSGI> environment hash if available.
  
    # Check CGI version
    my $version = $req->env->{GATEWAY_INTERFACE};
  
    # Check PSGI version
    my $version = $req->env->{'psgi.version'};
  
  =head2 method
  
    my $method = $req->method;
    $req       = $req->method('POST');
  
  HTTP request method, defaults to C<GET>.
  
  =head2 proxy
  
    my $url = $req->proxy;
    $req    = $req->proxy(Mojo::URL->new('http://127.0.0.1:3000'));
  
  Proxy URL for request.
  
  =head2 reverse_proxy
  
    my $bool = $req->reverse_proxy;
    $req     = $req->reverse_proxy($bool);
  
  Request has been performed through a reverse proxy.
  
  =head2 request_id
  
    my $id = $req->request_id;
    $req   = $req->request_id('aee7d5d8');
  
  Request ID, defaults to a reasonably unique value.
  
  =head2 url
  
    my $url = $req->url;
    $req    = $req->url(Mojo::URL->new);
  
  HTTP request URL, defaults to a L<Mojo::URL> object.
  
    # Get request information
    my $info = $req->url->to_abs->userinfo;
    my $host = $req->url->to_abs->host;
    my $path = $req->url->to_abs->path;
  
  =head2 via_proxy
  
    my $bool = $req->via_proxy;
    $req     = $req->via_proxy($bool);
  
  Request can be performed through a proxy server.
  
  =head1 METHODS
  
  L<Mojo::Message::Request> inherits all methods from L<Mojo::Message> and
  implements the following new ones.
  
  =head2 clone
  
    my $clone = $req->clone;
  
  Return a new L<Mojo::Message::Request> object cloned from this request if
  possible, otherwise return C<undef>.
  
  =head2 cookies
  
    my $cookies = $req->cookies;
    $req        = $req->cookies(Mojo::Cookie::Request->new);
    $req        = $req->cookies({name => 'foo', value => 'bar'});
  
  Access request cookies, usually L<Mojo::Cookie::Request> objects.
  
    # Names of all cookies
    say $_->name for @{$req->cookies};
  
  =head2 every_param
  
    my $values = $req->every_param('foo');
  
  Similar to L</"param">, but returns all values sharing the same name as an
  array reference.
  
    # Get first value
    say $req->every_param('foo')->[0];
  
  =head2 extract_start_line
  
    my $bool = $req->extract_start_line(\$str);
  
  Extract request-line from string.
  
  =head2 fix_headers
  
    $req = $req->fix_headers;
  
  Make sure request has all required headers.
  
  =head2 get_start_line_chunk
  
    my $bytes = $req->get_start_line_chunk($offset);
  
  Get a chunk of request-line data starting from a specific position. Note that
  this method finalizes the request.
  
  =head2 is_handshake
  
    my $bool = $req->is_handshake;
  
  Check C<Upgrade> header for C<websocket> value.
  
  =head2 is_secure
  
    my $bool = $req->is_secure;
  
  Check if connection is secure.
  
  =head2 is_xhr
  
    my $bool = $req->is_xhr;
  
  Check C<X-Requested-With> header for C<XMLHttpRequest> value.
  
  =head2 param
  
    my $value = $req->param('foo');
  
  Access C<GET> and C<POST> parameters extracted from the query string and
  C<application/x-www-form-urlencoded> or C<multipart/form-data> message body. If
  there are multiple values sharing the same name, and you want to access more
  than just the last one, you can use L</"every_param">. Note that this method
  caches all data, so it should not be called before the entire request body has
  been received. Parts of the request body need to be loaded into memory to parse
  C<POST> parameters, so you have to make sure it is not excessively large.
  There's a 16MiB limit for requests by default.
  
  =head2 params
  
    my $params = $req->params;
  
  All C<GET> and C<POST> parameters extracted from the query string and
  C<application/x-www-form-urlencoded> or C<multipart/form-data> message body,
  usually a L<Mojo::Parameters> object. Note that this method caches all data, so
  it should not be called before the entire request body has been received. Parts
  of the request body need to be loaded into memory to parse C<POST> parameters,
  so you have to make sure it is not excessively large. There's a 16MiB limit for
  requests by default.
  
    # Get parameter names and values
    my $hash = $req->params->to_hash;
  
  =head2 parse
  
    $req = $req->parse('GET /foo/bar HTTP/1.1');
    $req = $req->parse({PATH_INFO => '/'});
  
  Parse HTTP request chunks or environment hash.
  
  =head2 query_params
  
    my $params = $req->query_params;
  
  All C<GET> parameters, usually a L<Mojo::Parameters> object.
  
    # Turn GET parameters to hash and extract value
    say $req->query_params->to_hash->{foo};
  
  =head2 start_line_size
  
    my $size = $req->start_line_size;
  
  Size of the request-line in bytes. Note that this method finalizes the request.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_MESSAGE_REQUEST

$fatpacked{"Mojo/Message/Response.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_MESSAGE_RESPONSE';
  package Mojo::Message::Response;
  use Mojo::Base 'Mojo::Message';
  
  use Mojo::Cookie::Response;
  use Mojo::Date;
  
  has [qw(code message)];
  has max_message_size => sub { $ENV{MOJO_MAX_MESSAGE_SIZE} // 2147483648 };
  
  # Umarked codes are from RFC 7231
  my %MESSAGES = (
    100 => 'Continue',
    101 => 'Switching Protocols',
    102 => 'Processing',                         # RFC 2518 (WebDAV)
    103 => 'Early Hints',                        # RFC 8297
    200 => 'OK',
    201 => 'Created',
    202 => 'Accepted',
    203 => 'Non-Authoritative Information',
    204 => 'No Content',
    205 => 'Reset Content',
    206 => 'Partial Content',
    207 => 'Multi-Status',                       # RFC 2518 (WebDAV)
    208 => 'Already Reported',                   # RFC 5842
    226 => 'IM Used',                            # RFC 3229
    300 => 'Multiple Choices',
    301 => 'Moved Permanently',
    302 => 'Found',
    303 => 'See Other',
    304 => 'Not Modified',
    305 => 'Use Proxy',
    307 => 'Temporary Redirect',
    308 => 'Permanent Redirect',                 # RFC 7538
    400 => 'Bad Request',
    401 => 'Unauthorized',
    402 => 'Payment Required',
    403 => 'Forbidden',
    404 => 'Not Found',
    405 => 'Method Not Allowed',
    406 => 'Not Acceptable',
    407 => 'Proxy Authentication Required',
    408 => 'Request Timeout',
    409 => 'Conflict',
    410 => 'Gone',
    411 => 'Length Required',
    412 => 'Precondition Failed',
    413 => 'Request Entity Too Large',
    414 => 'Request-URI Too Long',
    415 => 'Unsupported Media Type',
    416 => 'Request Range Not Satisfiable',
    417 => 'Expectation Failed',
    418 => "I'm a teapot",                       # RFC 2324 :)
    421 => 'Misdirected Request',                # RFC 7540
    422 => 'Unprocessable Entity',               # RFC 2518 (WebDAV)
    423 => 'Locked',                             # RFC 2518 (WebDAV)
    424 => 'Failed Dependency',                  # RFC 2518 (WebDAV)
    425 => 'Unordered Colection',                # RFC 3648 (WebDAV)
    426 => 'Upgrade Required',                   # RFC 2817
    428 => 'Precondition Required',              # RFC 6585
    429 => 'Too Many Requests',                  # RFC 6585
    431 => 'Request Header Fields Too Large',    # RFC 6585
    451 => 'Unavailable For Legal Reasons',      # RFC 7725
    500 => 'Internal Server Error',
    501 => 'Not Implemented',
    502 => 'Bad Gateway',
    503 => 'Service Unavailable',
    504 => 'Gateway Timeout',
    505 => 'HTTP Version Not Supported',
    506 => 'Variant Also Negotiates',            # RFC 2295
    507 => 'Insufficient Storage',               # RFC 2518 (WebDAV)
    508 => 'Loop Detected',                      # RFC 5842
    509 => 'Bandwidth Limit Exceeded',           # Unofficial
    510 => 'Not Extended',                       # RFC 2774
    511 => 'Network Authentication Required'     # RFC 6585
  );
  
  sub cookies {
    my $self = shift;
  
    # Parse cookies
    my $headers = $self->headers;
    return [@{Mojo::Cookie::Response->parse($headers->set_cookie)}] unless @_;
  
    # Add cookies
    $headers->add('Set-Cookie' => "$_")
      for map { ref $_ eq 'HASH' ? Mojo::Cookie::Response->new($_) : $_ } @_;
  
    return $self;
  }
  
  sub default_message { $MESSAGES{$_[1] || $_[0]->code // 404} || '' }
  
  sub extract_start_line {
    my ($self, $bufref) = @_;
  
    # We have a full response line
    return undef unless $$bufref =~ s/^(.*?)\x0d?\x0a//;
    return !$self->error({message => 'Bad response start-line'})
      unless $1 =~ m!^\s*HTTP/(\d\.\d)\s+(\d\d\d)\s*(.+)?$!;
  
    my $content = $self->content;
    $content->skip_body(1) if $self->code($2)->is_empty;
    defined $content->$_ or $content->$_(1) for qw(auto_decompress auto_relax);
    $content->expect_close(1) if $1 eq '1.0';
    return !!$self->version($1)->message($3);
  }
  
  sub fix_headers {
    my $self = shift;
    $self->{fix} ? return $self : $self->SUPER::fix_headers(@_);
  
    # Date
    my $headers = $self->headers;
    $headers->date(Mojo::Date->new->to_string) unless $headers->date;
  
    # RFC 7230 3.3.2
    $headers->remove('Content-Length') if $self->is_empty;
  
    return $self;
  }
  
  sub get_start_line_chunk {
    my ($self, $offset) = @_;
    $self->_start_line->emit(progress => 'start_line', $offset);
    return substr $self->{start_buffer}, $offset, 131072;
  }
  
  sub is_client_error { shift->_status_class(400) }
  
  sub is_empty {
    my $self = shift;
    return undef unless my $code = $self->code;
    return $self->is_info || $code == 204 || $code == 304;
  }
  
  sub is_error { shift->_status_class(400, 500) }
  sub is_info { shift->_status_class(100) }
  sub is_redirect     { shift->_status_class(300) }
  sub is_server_error { shift->_status_class(500) }
  
  sub is_success { shift->_status_class(200) }
  
  sub start_line_size { length shift->_start_line->{start_buffer} }
  
  sub _start_line {
    my $self = shift;
  
    return $self if defined $self->{start_buffer};
    my $code = $self->code    || 404;
    my $msg  = $self->message || $self->default_message;
    $self->{start_buffer} = "HTTP/@{[$self->version]} $code $msg\x0d\x0a";
  
    return $self;
  }
  
  sub _status_class {
    my ($self, @classes) = @_;
    return undef unless my $code = $self->code;
    return !!grep { $code >= $_ && $code < ($_ + 100) } @classes;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Message::Response - HTTP response
  
  =head1 SYNOPSIS
  
    use Mojo::Message::Response;
  
    # Parse
    my $res = Mojo::Message::Response->new;
    $res->parse("HTTP/1.0 200 OK\x0d\x0a");
    $res->parse("Content-Length: 12\x0d\x0a");
    $res->parse("Content-Type: text/plain\x0d\x0a\x0d\x0a");
    $res->parse('Hello World!');
    say $res->code;
    say $res->headers->content_type;
    say $res->body;
  
    # Build
    my $res = Mojo::Message::Response->new;
    $res->code(200);
    $res->headers->content_type('text/plain');
    $res->body('Hello World!');
    say $res->to_string;
  
  =head1 DESCRIPTION
  
  L<Mojo::Message::Response> is a container for HTTP responses, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230> and
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>.
  
  =head1 EVENTS
  
  L<Mojo::Message::Response> inherits all events from L<Mojo::Message>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Message::Response> inherits all attributes from L<Mojo::Message> and
  implements the following new ones.
  
  =head2 code
  
    my $code = $res->code;
    $res     = $res->code(200);
  
  HTTP response status code.
  
  =head2 max_message_size
  
    my $size = $res->max_message_size;
    $res     = $res->max_message_size(1024);
  
  Maximum message size in bytes, defaults to the value of the
  C<MOJO_MAX_MESSAGE_SIZE> environment variable or C<2147483648> (2GiB). Setting
  the value to C<0> will allow messages of indefinite size.
  
  =head2 message
  
    my $msg = $res->message;
    $res    = $res->message('OK');
  
  HTTP response status message.
  
  =head1 METHODS
  
  L<Mojo::Message::Response> inherits all methods from L<Mojo::Message> and
  implements the following new ones.
  
  =head2 cookies
  
    my $cookies = $res->cookies;
    $res        = $res->cookies(Mojo::Cookie::Response->new);
    $res        = $res->cookies({name => 'foo', value => 'bar'});
  
  Access response cookies, usually L<Mojo::Cookie::Response> objects.
  
    # Names of all cookies
    say $_->name for @{$res->cookies};
  
  =head2 default_message
  
    my $msg = $res->default_message;
    my $msg = $res->default_message(418);
  
  Generate default response message for status code, defaults to using
  L</"code">.
  
  =head2 extract_start_line
  
    my $bool = $res->extract_start_line(\$str);
  
  Extract status-line from string.
  
  =head2 fix_headers
  
    $res = $res->fix_headers;
  
  Make sure response has all required headers.
  
  =head2 get_start_line_chunk
  
    my $bytes = $res->get_start_line_chunk($offset);
  
  Get a chunk of status-line data starting from a specific position. Note that
  this method finalizes the response.
  
  =head2 is_client_error
  
    my $bool = $res->is_client_error;
  
  Check if this response has a C<4xx> status L</"code">.
  
  =head2 is_empty
  
    my $bool = $res->is_empty;
  
  Check if this response has a C<1xx>, C<204> or C<304> status L</"code">.
  
  =head2 is_error
  
    my $bool = $res->is_error;
  
  Check if this response has a C<4xx> or C<5xx> status L</"code">.
  
  =head2 is_info
  
    my $bool = $res->is_info;
  
  Check if this response has a C<1xx> status L</"code">.
  
  =head2 is_redirect
  
    my $bool = $res->is_redirect;
  
  Check if this response has a C<3xx> status L</"code">.
  
  =head2 is_server_error
  
    my $bool = $res->is_server_error;
  
  Check if this response has a C<5xx> status L</"code">.
  
  =head2 is_success
  
    my $bool = $res->is_success;
  
  Check if this response has a C<2xx> status L</"code">.
  
  =head2 start_line_size
  
    my $size = $req->start_line_size;
  
  Size of the status-line in bytes. Note that this method finalizes the response.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_MESSAGE_RESPONSE

$fatpacked{"Mojo/Parameters.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_PARAMETERS';
  package Mojo::Parameters;
  use Mojo::Base -base;
  use overload
    '@{}'    => sub { shift->pairs },
    bool     => sub {1},
    '""'     => sub { shift->to_string },
    fallback => 1;
  
  use Mojo::Util qw(decode encode url_escape url_unescape);
  
  has charset => 'UTF-8';
  
  sub append {
    my $self = shift;
  
    my $old = $self->pairs;
    my @new = @_ == 1 ? @{shift->pairs} : @_;
    while (my ($name, $value) = splice @new, 0, 2) {
  
      # Multiple values
      if (ref $value eq 'ARRAY') { push @$old, $name => $_ // '' for @$value }
  
      # Single value
      elsif (defined $value) { push @$old, $name => $value }
    }
  
    return $self;
  }
  
  sub clone {
    my $self = shift;
  
    my $clone = $self->new;
    if   (exists $self->{charset}) { $clone->{charset} = $self->{charset} }
    if   (defined $self->{string}) { $clone->{string}  = $self->{string} }
    else                           { $clone->{pairs}   = [@{$self->pairs}] }
  
    return $clone;
  }
  
  sub every_param {
    my ($self, $name) = @_;
  
    my @values;
    my $pairs = $self->pairs;
    for (my $i = 0; $i < @$pairs; $i += 2) {
      push @values, $pairs->[$i + 1] if $pairs->[$i] eq $name;
    }
  
    return \@values;
  }
  
  sub merge {
    my $self = shift;
  
    my @pairs = @_ == 1 ? @{shift->pairs} : @_;
    while (my ($name, $value) = splice @pairs, 0, 2) {
      defined $value ? $self->param($name => $value) : $self->remove($name);
    }
  
    return $self;
  }
  
  sub names { [sort keys %{shift->to_hash}] }
  
  sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }
  
  sub pairs {
    my $self = shift;
  
    # Replace parameters
    if (@_) {
      $self->{pairs} = shift;
      delete $self->{string};
      return $self;
    }
  
    # Parse string
    if (defined(my $str = delete $self->{string})) {
      my $pairs = $self->{pairs} = [];
      return $pairs unless length $str;
  
      my $charset = $self->charset;
      for my $pair (split '&', $str) {
        next unless $pair =~ /^([^=]+)(?:=(.*))?$/;
        my ($name, $value) = ($1, $2 // '');
  
        # Replace "+" with whitespace, unescape and decode
        s/\+/ /g for $name, $value;
        $name  = url_unescape $name;
        $name  = decode($charset, $name) // $name if $charset;
        $value = url_unescape $value;
        $value = decode($charset, $value) // $value if $charset;
  
        push @$pairs, $name, $value;
      }
    }
  
    return $self->{pairs} ||= [];
  }
  
  sub param {
    my ($self, $name) = (shift, shift);
    return $self->every_param($name)->[-1] unless @_;
    $self->remove($name);
    return $self->append($name => ref $_[0] eq 'ARRAY' ? $_[0] : [@_]);
  }
  
  sub parse {
    my $self = shift;
  
    # Pairs
    return $self->append(@_) if @_ > 1;
  
    # String
    $self->{string} = shift;
    return $self;
  }
  
  sub remove {
    my ($self, $name) = @_;
    my $pairs = $self->pairs;
    my $i     = 0;
    $pairs->[$i] eq $name ? splice @$pairs, $i, 2 : ($i += 2) while $i < @$pairs;
    return $self;
  }
  
  sub to_hash {
    my $self = shift;
  
    my %hash;
    my $pairs = $self->pairs;
    for (my $i = 0; $i < @$pairs; $i += 2) {
      my ($name, $value) = @{$pairs}[$i, $i + 1];
  
      # Array
      if (exists $hash{$name}) {
        $hash{$name} = [$hash{$name}] if ref $hash{$name} ne 'ARRAY';
        push @{$hash{$name}}, $value;
      }
  
      # String
      else { $hash{$name} = $value }
    }
  
    return \%hash;
  }
  
  sub to_string {
    my $self = shift;
  
    # String (RFC 3986)
    my $charset = $self->charset;
    if (defined(my $str = $self->{string})) {
      $str = encode $charset, $str if $charset;
      return url_escape $str, '^A-Za-z0-9\-._~%!$&\'()*+,;=:@/?';
    }
  
    # Build pairs (HTML Living Standard)
    my $pairs = $self->pairs;
    return '' unless @$pairs;
    my @pairs;
    for (my $i = 0; $i < @$pairs; $i += 2) {
      my ($name, $value) = @{$pairs}[$i, $i + 1];
  
      # Escape and replace whitespace with "+"
      $name  = encode $charset,   $name if $charset;
      $name  = url_escape $name,  '^*\-.0-9A-Z_a-z';
      $value = encode $charset,   $value if $charset;
      $value = url_escape $value, '^*\-.0-9A-Z_a-z';
      s/\%20/\+/g for $name, $value;
  
      push @pairs, "$name=$value";
    }
  
    return join '&', @pairs;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Parameters - Parameters
  
  =head1 SYNOPSIS
  
    use Mojo::Parameters;
  
    # Parse
    my $params = Mojo::Parameters->new('foo=bar&baz=23');
    say $params->param('baz');
  
    # Build
    my $params = Mojo::Parameters->new(foo => 'bar', baz => 23);
    push @$params, i => ' mojolicious';
    say "$params";
  
  =head1 DESCRIPTION
  
  L<Mojo::Parameters> is a container for form parameters used by L<Mojo::URL>,
  based on L<RFC 3986|http://tools.ietf.org/html/rfc3986> and the
  L<HTML Living Standard|https://html.spec.whatwg.org>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Parameters> implements the following attributes.
  
  =head2 charset
  
    my $charset = $params->charset;
    $params     = $params->charset('UTF-8');
  
  Charset used for encoding and decoding parameters, defaults to C<UTF-8>.
  
    # Disable encoding and decoding
    $params->charset(undef);
  
  =head1 METHODS
  
  L<Mojo::Parameters> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 append
  
    $params = $params->append(foo => 'ba&r');
    $params = $params->append(foo => ['ba&r', 'baz']);
    $params = $params->append(foo => ['bar', 'baz'], bar => 23);
    $params = $params->append(Mojo::Parameters->new);
  
  Append parameters. Note that this method will normalize the parameters.
  
    # "foo=bar&foo=baz"
    Mojo::Parameters->new('foo=bar')->append(Mojo::Parameters->new('foo=baz'));
  
    # "foo=bar&foo=baz"
    Mojo::Parameters->new('foo=bar')->append(foo => 'baz');
  
    # "foo=bar&foo=baz&foo=yada"
    Mojo::Parameters->new('foo=bar')->append(foo => ['baz', 'yada']);
  
    # "foo=bar&foo=baz&foo=yada&bar=23"
    Mojo::Parameters->new('foo=bar')->append(foo => ['baz', 'yada'], bar => 23);
  
  =head2 clone
  
    my $params2 = $params->clone;
  
  Return a new L<Mojo::Parameters> object cloned from these parameters.
  
  =head2 every_param
  
    my $values = $params->every_param('foo');
  
  Similar to L</"param">, but returns all values sharing the same name as an
  array reference. Note that this method will normalize the parameters.
  
    # Get first value
    say $params->every_param('foo')->[0];
  
  =head2 merge
  
    $params = $params->merge(foo => 'ba&r');
    $params = $params->merge(foo => ['ba&r', 'baz']);
    $params = $params->merge(foo => ['bar', 'baz'], bar => 23);
    $params = $params->merge(Mojo::Parameters->new);
  
  Merge parameters. Note that this method will normalize the parameters.
  
    # "foo=baz"
    Mojo::Parameters->new('foo=bar')->merge(Mojo::Parameters->new('foo=baz'));
  
    # "yada=yada&foo=baz"
    Mojo::Parameters->new('foo=bar&yada=yada')->merge(foo => 'baz');
  
    # "yada=yada"
    Mojo::Parameters->new('foo=bar&yada=yada')->merge(foo => undef);
  
  =head2 names
  
    my $names = $params->names;
  
  Return an array reference with all parameter names.
  
    # Names of all parameters
    say for @{$params->names};
  
  =head2 new
  
    my $params = Mojo::Parameters->new;
    my $params = Mojo::Parameters->new('foo=b%3Bar&baz=23');
    my $params = Mojo::Parameters->new(foo => 'b&ar');
    my $params = Mojo::Parameters->new(foo => ['ba&r', 'baz']);
    my $params = Mojo::Parameters->new(foo => ['bar', 'baz'], bar => 23);
  
  Construct a new L<Mojo::Parameters> object and L</"parse"> parameters if
  necessary.
  
  =head2 pairs
  
    my $array = $params->pairs;
    $params   = $params->pairs([foo => 'b&ar', baz => 23]);
  
  Parsed parameter pairs. Note that this method will normalize the parameters.
  
    # Remove all parameters
    $params->pairs([]);
  
  =head2 param
  
    my $value = $params->param('foo');
    $params   = $params->param(foo => 'ba&r');
    $params   = $params->param(foo => qw(ba&r baz));
    $params   = $params->param(foo => ['ba;r', 'baz']);
  
  Access parameter values. If there are multiple values sharing the same name,
  and you want to access more than just the last one, you can use
  L</"every_param">. Note that this method will normalize the parameters.
  
  =head2 parse
  
    $params = $params->parse('foo=b%3Bar&baz=23');
  
  Parse parameters.
  
  =head2 remove
  
    $params = $params->remove('foo');
  
  Remove parameters. Note that this method will normalize the parameters.
  
    # "bar=yada"
    Mojo::Parameters->new('foo=bar&foo=baz&bar=yada')->remove('foo');
  
  =head2 to_hash
  
    my $hash = $params->to_hash;
  
  Turn parameters into a hash reference. Note that this method will normalize the
  parameters.
  
    # "baz"
    Mojo::Parameters->new('foo=bar&foo=baz')->to_hash->{foo}[1];
  
  =head2 to_string
  
    my $str = $params->to_string;
  
  Turn parameters into a string.
  
    # "foo=bar&baz=23"
    Mojo::Parameters->new->pairs([foo => 'bar', baz => 23])->to_string;
  
  =head1 OPERATORS
  
  L<Mojo::Parameters> overloads the following operators.
  
  =head2 array
  
    my @pairs = @$params;
  
  Alias for L</"pairs">. Note that this will normalize the parameters.
  
    say $params->[0];
    say for @$params;
  
  =head2 bool
  
    my $bool = !!$params;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$params";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_PARAMETERS

$fatpacked{"Mojo/Path.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_PATH';
  package Mojo::Path;
  use Mojo::Base -base;
  use overload
    '@{}'    => sub { shift->parts },
    bool     => sub {1},
    '""'     => sub { shift->to_string },
    fallback => 1;
  
  use Mojo::Util qw(decode encode url_escape url_unescape);
  
  has charset => 'UTF-8';
  
  sub canonicalize {
    my $self = shift;
  
    my $parts = $self->parts;
    for (my $i = 0; $i <= $#$parts;) {
      if (!length $parts->[$i] || $parts->[$i] eq '.' || $parts->[$i] eq '...') {
        splice @$parts, $i, 1;
      }
      elsif ($i < 1 || $parts->[$i] ne '..' || $parts->[$i - 1] eq '..') { $i++ }
      else { splice @$parts, --$i, 2 }
    }
  
    return @$parts ? $self : $self->trailing_slash(undef);
  }
  
  sub clone {
    my $self = shift;
  
    my $clone = $self->new;
    if (exists $self->{charset}) { $clone->{charset} = $self->{charset} }
    if (my $parts = $self->{parts}) {
      $clone->{$_} = $self->{$_} for qw(leading_slash trailing_slash);
      $clone->{parts} = [@$parts];
    }
    else { $clone->{path} = $self->{path} }
  
    return $clone;
  }
  
  sub contains { $_[1] eq '/' || $_[0]->to_route =~ m!^\Q$_[1]\E(?:/|$)! }
  
  sub leading_slash { shift->_parse(leading_slash => @_) }
  
  sub merge {
    my ($self, $path) = @_;
  
    # Replace
    return $self->parse($path) if $path =~ m!^/!;
  
    # Merge
    pop @{$self->parts} unless $self->trailing_slash;
    $path = $self->new($path);
    push @{$self->parts}, @{$path->parts};
    return $self->trailing_slash($path->trailing_slash);
  }
  
  sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }
  
  sub parse {
    my $self = shift;
    $self->{path} = shift;
    delete @$self{qw(leading_slash parts trailing_slash)};
    return $self;
  }
  
  sub parts { shift->_parse(parts => @_) }
  
  sub to_abs_string {
    my $path = shift->to_string;
    return $path =~ m!^/! ? $path : "/$path";
  }
  
  sub to_dir {
    my $clone = shift->clone;
    pop @{$clone->parts} unless $clone->trailing_slash;
    return $clone->trailing_slash(!!@{$clone->parts});
  }
  
  sub to_route {
    my $clone = shift->clone;
    return '/' . join '/', @{$clone->parts}, $clone->trailing_slash ? '' : ();
  }
  
  sub to_string {
    my $self = shift;
  
    # Path
    my $charset = $self->charset;
    if (defined(my $path = $self->{path})) {
      $path = encode $charset, $path if $charset;
      return url_escape $path, '^A-Za-z0-9\-._~!$&\'()*+,;=%:@/';
    }
  
    # Build path
    my @parts = @{$self->parts};
    @parts = map { encode $charset, $_ } @parts if $charset;
    my $path = join '/',
      map { url_escape $_, '^A-Za-z0-9\-._~!$&\'()*+,;=:@' } @parts;
    $path = "/$path" if $self->leading_slash;
    $path = "$path/" if $self->trailing_slash;
    return $path;
  }
  
  sub trailing_slash { shift->_parse(trailing_slash => @_) }
  
  sub _parse {
    my ($self, $name) = (shift, shift);
  
    unless ($self->{parts}) {
      my $path    = url_unescape delete($self->{path}) // '';
      my $charset = $self->charset;
      $path = decode($charset, $path) // $path if $charset;
      $self->{leading_slash}  = $path =~ s!^/!!;
      $self->{trailing_slash} = $path =~ s!/$!!;
      $self->{parts}          = [split '/', $path, -1];
    }
  
    return $self->{$name} unless @_;
    $self->{$name} = shift;
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Path - Path
  
  =head1 SYNOPSIS
  
    use Mojo::Path;
  
    # Parse
    my $path = Mojo::Path->new('/foo%2Fbar%3B/baz.html');
    say $path->[0];
  
    # Build
    my $path = Mojo::Path->new('/i/');
    push @$path, 'mojolicious';
    say "$path";
  
  =head1 DESCRIPTION
  
  L<Mojo::Path> is a container for paths used by L<Mojo::URL>, based on
  L<RFC 3986|http://tools.ietf.org/html/rfc3986>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Path> implements the following attributes.
  
  =head2 charset
  
    my $charset = $path->charset;
    $path       = $path->charset('UTF-8');
  
  Charset used for encoding and decoding, defaults to C<UTF-8>.
  
    # Disable encoding and decoding
    $path->charset(undef);
  
  =head1 METHODS
  
  L<Mojo::Path> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 canonicalize
  
    $path = $path->canonicalize;
  
  Canonicalize path by resolving C<.> and C<..>, in addition C<...> will be
  treated as C<.> to protect from path traversal attacks.
  
    # "/foo/baz"
    Mojo::Path->new('/foo/./bar/../baz')->canonicalize;
  
    # "/../baz"
    Mojo::Path->new('/foo/../bar/../../baz')->canonicalize;
  
    # "/foo/bar"
    Mojo::Path->new('/foo/.../bar')->canonicalize;
  
  =head2 clone
  
    my $clone = $path->clone;
  
  Return a new L<Mojo::Path> object cloned from this path.
  
  =head2 contains
  
    my $bool = $path->contains('/i//mojolicious');
  
  Check if path contains given prefix.
  
    # True
    Mojo::Path->new('/foo/bar')->contains('/');
    Mojo::Path->new('/foo/bar')->contains('/foo');
    Mojo::Path->new('/foo/bar')->contains('/foo/bar');
  
    # False
    Mojo::Path->new('/foo/bar')->contains('/f');
    Mojo::Path->new('/foo/bar')->contains('/bar');
    Mojo::Path->new('/foo/bar')->contains('/whatever');
  
  =head2 leading_slash
  
    my $bool = $path->leading_slash;
    $path    = $path->leading_slash($bool);
  
  Path has a leading slash. Note that this method will normalize the path and
  that C<%2F> will be treated as C</> for security reasons.
  
    # "/foo/bar"
    Mojo::Path->new('foo/bar')->leading_slash(1);
  
    # "foo/bar"
    Mojo::Path->new('/foo/bar')->leading_slash(0);
  
  =head2 merge
  
    $path = $path->merge('/foo/bar');
    $path = $path->merge('foo/bar');
    $path = $path->merge(Mojo::Path->new);
  
  Merge paths. Note that this method will normalize both paths if necessary and
  that C<%2F> will be treated as C</> for security reasons.
  
    # "/baz/yada"
    Mojo::Path->new('/foo/bar')->merge('/baz/yada');
  
    # "/foo/baz/yada"
    Mojo::Path->new('/foo/bar')->merge('baz/yada');
  
    # "/foo/bar/baz/yada"
    Mojo::Path->new('/foo/bar/')->merge('baz/yada');
  
  =head2 new
  
    my $path = Mojo::Path->new;
    my $path = Mojo::Path->new('/foo%2Fbar%3B/baz.html');
  
  Construct a new L<Mojo::Path> object and L</"parse"> path if necessary.
  
  =head2 parse
  
    $path = $path->parse('/foo%2Fbar%3B/baz.html');
  
  Parse path.
  
  =head2 to_abs_string
  
    my $str = $path->to_abs_string;
  
  Turn path into an absolute string.
  
    # "/i/%E2%99%A5/mojolicious"
    Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_abs_string;
    Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_abs_string;
  
  =head2 parts
  
    my $parts = $path->parts;
    $path     = $path->parts([qw(foo bar baz)]);
  
  The path parts. Note that this method will normalize the path and that C<%2F>
  will be treated as C</> for security reasons.
  
    # Part with slash
    push @{$path->parts}, 'foo/bar';
  
  =head2 to_dir
  
    my $dir = $route->to_dir;
  
  Clone path and remove everything after the right-most slash.
  
    # "/i/%E2%99%A5/"
    Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_dir->to_abs_string;
  
    # "i/%E2%99%A5/"
    Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_dir->to_abs_string;
  
  =head2 to_route
  
    my $route = $path->to_route;
  
  Turn path into a route.
  
    # "/i//mojolicious"
    Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_route;
    Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_route;
  
  =head2 to_string
  
    my $str = $path->to_string;
  
  Turn path into a string.
  
    # "/i/%E2%99%A5/mojolicious"
    Mojo::Path->new('/i/%E2%99%A5/mojolicious')->to_string;
  
    # "i/%E2%99%A5/mojolicious"
    Mojo::Path->new('i/%E2%99%A5/mojolicious')->to_string;
  
  =head2 trailing_slash
  
    my $bool = $path->trailing_slash;
    $path    = $path->trailing_slash($bool);
  
  Path has a trailing slash. Note that this method will normalize the path and
  that C<%2F> will be treated as C</> for security reasons.
  
    # "/foo/bar/"
    Mojo::Path->new('/foo/bar')->trailing_slash(1);
  
    # "/foo/bar"
    Mojo::Path->new('/foo/bar/')->trailing_slash(0);
  
  =head1 OPERATORS
  
  L<Mojo::Path> overloads the following operators.
  
  =head2 array
  
    my @parts = @$path;
  
  Alias for L</"parts">. Note that this will normalize the path and that C<%2F>
  will be treated as C</> for security reasons.
  
    say $path->[0];
    say for @$path;
  
  =head2 bool
  
    my $bool = !!$path;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$path";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_PATH

$fatpacked{"Mojo/Promise.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_PROMISE';
  package Mojo::Promise;
  use Mojo::Base -base;
  
  use Mojo::IOLoop;
  use Scalar::Util qw(blessed weaken);
  
  has ioloop => sub { Mojo::IOLoop->singleton };
  
  sub all {
    my ($class, @promises) = @_;
  
    my $all       = $class->new;
    my $results   = [];
    my $remaining = scalar @promises;
    for my $i (0 .. $#promises) {
      $promises[$i]->then(
        sub {
          $results->[$i] = [@_];
          $all->resolve(@$results) if --$remaining <= 0;
        },
        sub { $all->reject(@_) }
      );
    }
  
    return @promises ? $all : $all->resolve;
  }
  
  sub catch { shift->then(undef, shift) }
  
  sub finally {
    my ($self, $finally) = @_;
  
    my $new = $self->_clone;
    push @{$self->{resolve}}, sub { _finally($new, $finally, 'resolve', @_) };
    push @{$self->{reject}},  sub { _finally($new, $finally, 'reject',  @_) };
  
    $self->_defer if $self->{result};
  
    return $new;
  }
  
  sub race {
    my ($class, @promises) = @_;
    my $new = $class->new;
    $_->then(sub { $new->resolve(@_) }, sub { $new->reject(@_) }) for @promises;
    return $new;
  }
  
  sub reject  { shift->_settle('reject',  @_) }
  sub resolve { shift->_settle('resolve', @_) }
  
  sub then {
    my ($self, $resolve, $reject) = @_;
  
    my $new = $self->_clone;
    push @{$self->{resolve}}, sub { _then($new, $resolve, 'resolve', @_) };
    push @{$self->{reject}},  sub { _then($new, $reject,  'reject',  @_) };
  
    $self->_defer if $self->{result};
  
    return $new;
  }
  
  sub wait {
    my $self = shift;
    return if (my $loop = $self->ioloop)->is_running;
    $self->finally(sub { $loop->stop });
    $loop->start;
  }
  
  sub _clone {
    my $self  = shift;
    my $clone = $self->new;
    weaken $clone->ioloop($self->ioloop)->{ioloop};
    return $clone;
  }
  
  sub _defer {
    my $self = shift;
  
    return unless my $result = $self->{result};
    my $cbs = $self->{status} eq 'resolve' ? $self->{resolve} : $self->{reject};
    @{$self}{qw(resolve reject)} = ([], []);
  
    $self->ioloop->next_tick(sub { $_->(@$result) for @$cbs });
  }
  
  sub _finally {
    my ($new, $finally, $method, @result) = @_;
    my ($res) = eval { $finally->(@result) };
    return $new->$method(@result)
      unless $res && blessed $res && $res->can('then');
    $res->then(sub { $new->$method(@result) }, sub { $new->$method(@result) });
  }
  
  sub _settle {
    my ($self, $status) = (shift, shift);
  
    $_[0]->then(sub { $self->resolve(@_); () }, sub { $self->reject(@_); () })
      and return $self
      if blessed $_[0] && $_[0]->can('then');
  
    return $self if $self->{result};
  
    @{$self}{qw(result status)} = ([@_], $status);
    $self->_defer;
    return $self;
  }
  
  sub _then {
    my ($new, $cb, $method, @result) = @_;
  
    return $new->$method(@result) unless defined $cb;
  
    my @res;
    return $new->reject($@) unless eval { @res = $cb->(@result); 1 };
    return $new->resolve(@res);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Promise - Promises/A+
  
  =head1 SYNOPSIS
  
    use Mojo::Promise;
    use Mojo::UserAgent;
  
    # Wrap continuation-passing style APIs with promises
    my $ua = Mojo::UserAgent->new;
    sub get {
      my $promise = Mojo::Promise->new;
      $ua->get(@_ => sub {
        my ($ua, $tx) = @_;
        my $err = $tx->error;
        $promise->resolve($tx) if !$err || $err->{code};
        $promise->reject($err->{message});
      });
      return $promise;
    }
  
    # Perform non-blocking operations sequentially
    get('https://mojolicious.org')->then(sub {
      my $mojo = shift;
      say $mojo->res->code;
      return get('https://metacpan.org');
    })->then(sub {
      my $cpan = shift;
      say $cpan->res->code;
    })->catch(sub {
      my $err = shift;
      warn "Something went wrong: $err";
    })->wait;
  
    # Synchronize non-blocking operations (all)
    my $mojo = get('https://mojolicious.org');
    my $cpan = get('https://metacpan.org');
    Mojo::Promise->all($mojo, $cpan)->then(sub {
      my ($mojo, $cpan) = @_;
      say $mojo->[0]->res->code;
      say $cpan->[0]->res->code;
    })->catch(sub {
      my $err = shift;
      warn "Something went wrong: $err";
    })->wait;
  
    # Synchronize non-blocking operations (race)
    my $mojo = get('https://mojolicious.org');
    my $cpan = get('https://metacpan.org');
    Mojo::Promise->race($mojo, $cpan)->then(sub {
      my $tx = shift;
      say $tx->req->url, ' won!';
    })->catch(sub {
      my $err = shift;
      warn "Something went wrong: $err";
    })->wait;
  
  =head1 DESCRIPTION
  
  L<Mojo::Promise> is a Perl-ish implementation of
  L<Promises/A+|https://promisesaplus.com>.
  
  =head1 STATES
  
  A promise is an object representing the eventual completion or failure of a
  non-blocking operation. It allows non-blocking functions to return values, like
  blocking functions. But instead of immediately returning the final value, the
  non-blocking function returns a promise to supply the value at some point in the
  future.
  
  A promise can be in one of three states:
  
  =over 2
  
  =item pending
  
  Initial state, neither fulfilled nor rejected.
  
  =item fulfilled
  
  Meaning that the operation completed successfully.
  
  =item rejected
  
  Meaning that the operation failed.
  
  =back
  
  A pending promise can either be fulfilled with a value or rejected with a
  reason. When either happens, the associated handlers queued up by a promise's
  L</"then"> method are called.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Promise> implements the following attributes.
  
  =head2 ioloop
  
    my $loop = $promise->ioloop;
    $promise = $promise->ioloop(Mojo::IOLoop->new);
  
  Event loop object to control, defaults to the global L<Mojo::IOLoop> singleton.
  
  =head1 METHODS
  
  L<Mojo::Promise> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 all
  
    my $new = Mojo::Promise->all(@promises);
  
  Returns a new L<Mojo::Promise> object that either fulfills when all of the
  passed L<Mojo::Promise> objects have fulfilled or rejects as soon as one of them
  rejects. If the returned promise fulfills, it is fulfilled with the values from
  the fulfilled promises in the same order as the passed promises. This method can
  be useful for aggregating results of multiple promises.
  
  =head2 catch
  
    my $new = $promise->catch(sub {...});
  
  Appends a rejection handler callback to the promise, and returns a new
  L<Mojo::Promise> object resolving to the return value of the callback if it is
  called, or to its original fulfillment value if the promise is instead
  fulfilled.
  
    # Longer version
    my $new = $promise->then(undef, sub {...});
  
    # Pass along the rejection reason
    $promise->catch(sub {
      my @reason = @_;
      warn "Something went wrong: $reason[0]";
      return @reason;
    });
  
    # Change the rejection reason
    $promise->catch(sub {
      my @reason = @_;
      return "This is bad: $reason[0]";
    });
  
  =head2 finally
  
    my $new = $promise->finally(sub {...});
  
  Appends a fulfillment and rejection handler to the promise, and returns a new
  L<Mojo::Promise> object resolving to the original fulfillment value or rejection
  reason.
  
    # Do something on fulfillment and rejection
    $promise->finally(sub {
      my @value_or_reason = @_;
      say "We are done!";
    });
  
  =head2 race
  
    my $new = Mojo::Promise->race(@promises);
  
  Returns a new L<Mojo::Promise> object that fulfills or rejects as soon as one of
  the passed L<Mojo::Promise> objects fulfills or rejects, with the value or
  reason from that promise.
  
  =head2 reject
  
    $promise = $promise->reject(@reason);
  
  Reject the promise with one or more rejection reasons.
  
    # Generate rejected promise
    my $promise = Mojo::Promise->new->reject('Something went wrong: Oops');
  
  =head2 resolve
  
    $promise = $promise->resolve(@value);
  
  Resolve the promise with one or more fulfillment values.
  
    # Generate fulfilled promise
    my $promise = Mojo::Promise->new->resolve('The result is: 24');
  
  =head2 then
  
    my $new = $promise->then(sub {...});
    my $new = $promise->then(sub {...}, sub {...});
    my $new = $promise->then(undef, sub {...});
  
  Appends fulfillment and rejection handlers to the promise, and returns a new
  L<Mojo::Promise> object resolving to the return value of the called handler.
  
    # Pass along the fulfillment value or rejection reason
    $promise->then(
      sub {
        my @value = @_;
        say "The result is $value[0]";
        return @value;
      },
      sub {
        my @reason = @_;
        warn "Something went wrong: $reason[0]";
        return @reason;
      }
    );
  
    # Change the fulfillment value or rejection reason
    $promise->then(
      sub {
        my @value = @_;
        return "This is good: $value[0]";
      },
      sub {
        my @reason = @_;
        return "This is bad: $reason[0]";
      }
    );
  
  =head2 wait
  
    $promise->wait;
  
  Start L</"ioloop"> and stop it again once the promise has been fulfilled or
  rejected, does nothing when L</"ioloop"> is already running.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_PROMISE

$fatpacked{"Mojo/Reactor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_REACTOR';
  package Mojo::Reactor;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Config;
  use Mojo::Loader 'load_class';
  
  my %DETECTED;
  
  sub again { croak 'Method "again" not implemented by subclass' }
  
  sub detect {
    my $default = 'Mojo::Reactor::' . ($Config{d_pseudofork} ? 'Poll' : 'EV');
    my $try = $ENV{MOJO_REACTOR} || $default;
    return $DETECTED{$try} ||= load_class($try) ? 'Mojo::Reactor::Poll' : $try;
  }
  
  sub io         { croak 'Method "io" not implemented by subclass' }
  sub is_running { croak 'Method "is_running" not implemented by subclass' }
  sub next_tick  { croak 'Method "next_tick" not implemented by subclass' }
  sub one_tick   { croak 'Method "one_tick" not implemented by subclass' }
  sub recurring  { croak 'Method "recurring" not implemented by subclass' }
  sub remove     { croak 'Method "remove" not implemented by subclass' }
  sub reset      { croak 'Method "reset" not implemented by subclass' }
  sub start      { croak 'Method "start" not implemented by subclass' }
  sub stop       { croak 'Method "stop" not implemented by subclass' }
  sub timer      { croak 'Method "timer" not implemented by subclass' }
  sub watch      { croak 'Method "watch" not implemented by subclass' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Reactor - Low-level event reactor base class
  
  =head1 SYNOPSIS
  
    package Mojo::Reactor::MyEventLoop;
    use Mojo::Base 'Mojo::Reactor';
  
    sub again      {...}
    sub io         {...}
    sub is_running {...}
    sub next_tick  {...}
    sub one_tick   {...}
    sub recurring  {...}
    sub remove     {...}
    sub reset      {...}
    sub start      {...}
    sub stop       {...}
    sub timer      {...}
    sub watch      {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Reactor> is an abstract base class for low-level event reactors, like
  L<Mojo::Reactor::EV> and L<Mojo::Reactor::Poll>.
  
  =head1 EVENTS
  
  L<Mojo::Reactor> inherits all events from L<Mojo::EventEmitter> and can emit
  the following new ones.
  
  =head2 error
  
    $reactor->on(error => sub {
      my ($reactor, $err) = @_;
      ...
    });
  
  Emitted for exceptions caught in callbacks, fatal if unhandled. Note that if
  this event is unhandled or fails it might kill your program, so you need to be
  careful.
  
    $reactor->on(error => sub {
      my ($reactor, $err) = @_;
      say "Something very bad happened: $err";
    });
  
  =head1 METHODS
  
  L<Mojo::Reactor> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 again
  
    $reactor->again($id);
  
  Restart timer. Meant to be overloaded in a subclass. Note that this method
  requires an active timer.
  
  =head2 detect
  
    my $class = Mojo::Reactor->detect;
  
  Detect and load the best reactor implementation available, will try the value
  of the C<MOJO_REACTOR> environment variable, L<Mojo::Reactor::EV> or
  L<Mojo::Reactor::Poll>.
  
    # Instantiate best reactor implementation available
    my $reactor = Mojo::Reactor->detect->new;
  
  =head2 io
  
    $reactor = $reactor->io($handle => sub {...});
  
  Watch handle for I/O events, invoking the callback whenever handle becomes
  readable or writable. Meant to be overloaded in a subclass.
  
    # Callback will be executed twice if handle becomes readable and writable
    $reactor->io($handle => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Handle is writable' : 'Handle is readable';
    });
  
  =head2 is_running
  
    my $bool = $reactor->is_running;
  
  Check if reactor is running. Meant to be overloaded in a subclass.
  
  =head2 next_tick
  
    my $undef = $reactor->next_tick(sub {...});
  
  Execute callback as soon as possible, but not before returning or other
  callbacks that have been registered with this method, always returns C<undef>.
  Meant to be overloaded in a subclass.
  
  =head2 one_tick
  
    $reactor->one_tick;
  
  Run reactor until an event occurs. Note that this method can recurse back into
  the reactor, so you need to be careful. Meant to be overloaded in a subclass.
  
    # Don't block longer than 0.5 seconds
    my $id = $reactor->timer(0.5 => sub {});
    $reactor->one_tick;
    $reactor->remove($id);
  
  =head2 recurring
  
    my $id = $reactor->recurring(0.25 => sub {...});
  
  Create a new recurring timer, invoking the callback repeatedly after a given
  amount of time in seconds. Meant to be overloaded in a subclass.
  
  =head2 remove
  
    my $bool = $reactor->remove($handle);
    my $bool = $reactor->remove($id);
  
  Remove handle or timer. Meant to be overloaded in a subclass.
  
  =head2 reset
  
    $reactor->reset;
  
  Remove all handles and timers. Meant to be overloaded in a subclass.
  
  =head2 start
  
    $reactor->start;
  
  Start watching for I/O and timer events, this will block until L</"stop"> is
  called. Note that some reactors stop automatically if there are no events being
  watched anymore. Meant to be overloaded in a subclass.
  
    # Start reactor only if it is not running already
    $reactor->start unless $reactor->is_running;
  
  =head2 stop
  
    $reactor->stop;
  
  Stop watching for I/O and timer events. Meant to be overloaded in a subclass.
  
  =head2 timer
  
    my $id = $reactor->timer(0.5 => sub {...});
  
  Create a new timer, invoking the callback after a given amount of time in
  seconds. Meant to be overloaded in a subclass.
  
  =head2 watch
  
    $reactor = $reactor->watch($handle, $readable, $writable);
  
  Change I/O events to watch handle for with true and false values. Meant to be
  overloaded in a subclass. Note that this method requires an active I/O watcher.
  
    # Watch only for readable events
    $reactor->watch($handle, 1, 0);
  
    # Watch only for writable events
    $reactor->watch($handle, 0, 1);
  
    # Watch for readable and writable events
    $reactor->watch($handle, 1, 1);
  
    # Pause watching for events
    $reactor->watch($handle, 0, 0);
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_REACTOR

$fatpacked{"Mojo/Reactor/EV.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_REACTOR_EV';
  package Mojo::Reactor::EV;
  use Mojo::Base 'Mojo::Reactor::Poll';
  
  use Carp 'croak';
  use EV 4.0;
  
  my $EV;
  
  sub DESTROY { undef $EV }
  
  sub again {
    croak 'Timer not active' unless my $timer = shift->{timers}{shift()};
    $timer->{watcher}->again;
  }
  
  sub is_running { !!EV::depth }
  
  # We have to fall back to Mojo::Reactor::Poll, since EV is unique
  sub new { $EV++ ? Mojo::Reactor::Poll->new : shift->SUPER::new }
  
  sub one_tick { EV::run(EV::RUN_ONCE) }
  
  sub recurring { shift->_timer(1, @_) }
  
  sub start {EV::run}
  
  sub stop { EV::break(EV::BREAK_ALL) }
  
  sub timer { shift->_timer(0, @_) }
  
  sub watch {
    my ($self, $handle, $read, $write) = @_;
  
    my $fd = fileno $handle;
    croak 'I/O watcher not active' unless my $io = $self->{io}{$fd};
  
    my $mode = 0;
    $mode |= EV::READ  if $read;
    $mode |= EV::WRITE if $write;
  
    if ($mode == 0) { delete $io->{watcher} }
    elsif (my $w = $io->{watcher}) { $w->events($mode) }
    else {
      my $cb = sub {
        my ($w, $revents) = @_;
        $self->_try('I/O watcher', $self->{io}{$fd}{cb}, 0)
          if EV::READ & $revents;
        $self->_try('I/O watcher', $self->{io}{$fd}{cb}, 1)
          if EV::WRITE & $revents && $self->{io}{$fd};
      };
      $io->{watcher} = EV::io($fd, $mode, $cb);
    }
  
    return $self;
  }
  
  sub _timer {
    my ($self, $recurring, $after, $cb) = @_;
    $after ||= 0.0001 if $recurring;
  
    my $id      = $self->_id;
    my $wrapper = sub {
      delete $self->{timers}{$id} unless $recurring;
      $self->_try('Timer', $cb);
    };
    EV::now_update() if $after > 0;
    $self->{timers}{$id}{watcher} = EV::timer($after, $after, $wrapper);
  
    return $id;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Reactor::EV - Low-level event reactor with libev support
  
  =head1 SYNOPSIS
  
    use Mojo::Reactor::EV;
  
    # Watch if handle becomes readable or writable
    my $reactor = Mojo::Reactor::EV->new;
    $reactor->io($first => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'First handle is writable' : 'First handle is readable';
    });
  
    # Change to watching only if handle becomes writable
    $reactor->watch($first, 0, 1);
  
    # Turn file descriptor into handle and watch if it becomes readable
    my $second = IO::Handle->new_from_fd($fd, 'r');
    $reactor->io($second => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Second handle is writable' : 'Second handle is readable';
    })->watch($second, 1, 0);
  
    # Add a timer
    $reactor->timer(15 => sub {
      my $reactor = shift;
      $reactor->remove($first);
      $reactor->remove($second);
      say 'Timeout!';
    });
  
    # Start reactor if necessary
    $reactor->start unless $reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::Reactor::EV> is a low-level event reactor based on L<EV> (4.0+).
  
  =head1 EVENTS
  
  L<Mojo::Reactor::EV> inherits all events from L<Mojo::Reactor::Poll>.
  
  =head1 METHODS
  
  L<Mojo::Reactor::EV> inherits all methods from L<Mojo::Reactor::Poll> and
  implements the following new ones.
  
  =head2 again
  
    $reactor->again($id);
  
  Restart timer. Note that this method requires an active timer.
  
  =head2 is_running
  
    my $bool = $reactor->is_running;
  
  Check if reactor is running.
  
  =head2 new
  
    my $reactor = Mojo::Reactor::EV->new;
  
  Construct a new L<Mojo::Reactor::EV> object.
  
  =head2 one_tick
  
    $reactor->one_tick;
  
  Run reactor until an event occurs or no events are being watched anymore.
  
    # Don't block longer than 0.5 seconds
    my $id = $reactor->timer(0.5 => sub {});
    $reactor->one_tick;
    $reactor->remove($id);
  
  =head2 recurring
  
    my $id = $reactor->recurring(0.25 => sub {...});
  
  Create a new recurring timer, invoking the callback repeatedly after a given
  amount of time in seconds.
  
  =head2 start
  
    $reactor->start;
  
  Start watching for I/O and timer events, this will block until L</"stop"> is
  called or no events are being watched anymore.
  
    # Start reactor only if it is not running already
    $reactor->start unless $reactor->is_running;
  
  =head2 stop
  
    $reactor->stop;
  
  Stop watching for I/O and timer events.
  
  =head2 timer
  
    my $id = $reactor->timer(0.5 => sub {...});
  
  Create a new timer, invoking the callback after a given amount of time in
  seconds.
  
  =head2 watch
  
    $reactor = $reactor->watch($handle, $readable, $writable);
  
  Change I/O events to watch handle for with true and false values. Note that
  this method requires an active I/O watcher.
  
    # Watch only for readable events
    $reactor->watch($handle, 1, 0);
  
    # Watch only for writable events
    $reactor->watch($handle, 0, 1);
  
    # Watch for readable and writable events
    $reactor->watch($handle, 1, 1);
  
    # Pause watching for events
    $reactor->watch($handle, 0, 0);
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_REACTOR_EV

$fatpacked{"Mojo/Reactor/Poll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_REACTOR_POLL';
  package Mojo::Reactor::Poll;
  use Mojo::Base 'Mojo::Reactor';
  
  use Carp 'croak';
  use IO::Poll qw(POLLERR POLLHUP POLLIN POLLNVAL POLLOUT POLLPRI);
  use List::Util 'min';
  use Mojo::Util qw(md5_sum steady_time);
  use Time::HiRes 'usleep';
  
  sub again {
    croak 'Timer not active' unless my $timer = shift->{timers}{shift()};
    $timer->{time} = steady_time + $timer->{after};
  }
  
  sub io {
    my ($self, $handle, $cb) = @_;
    $self->{io}{fileno($handle) // croak 'Handle is closed'} = {cb => $cb};
    return $self->watch($handle, 1, 1);
  }
  
  sub is_running { !!shift->{running} }
  
  sub next_tick {
    my ($self, $cb) = @_;
    push @{$self->{next_tick}}, $cb;
    $self->{next_timer} //= $self->timer(0 => \&_next);
    return undef;
  }
  
  sub one_tick {
    my $self = shift;
  
    # Just one tick
    local $self->{running} = 1 unless $self->{running};
  
    # Wait for one event
    my $i;
    until ($i || !$self->{running}) {
  
      # Stop automatically if there is nothing to watch
      return $self->stop unless keys %{$self->{timers}} || keys %{$self->{io}};
  
      # Calculate ideal timeout based on timers and round up to next millisecond
      my $min = min map { $_->{time} } values %{$self->{timers}};
      my $timeout = defined $min ? $min - steady_time : 0.5;
      $timeout = $timeout <= 0 ? 0 : int($timeout * 1000) + 1;
  
      # I/O
      if (keys %{$self->{io}}) {
        my @poll = map { $_ => $self->{io}{$_}{mode} } keys %{$self->{io}};
  
        # This may break in the future, but is worth it for performance
        if (IO::Poll::_poll($timeout, @poll) > 0) {
          while (my ($fd, $mode) = splice @poll, 0, 2) {
  
            if ($mode & (POLLIN | POLLPRI | POLLNVAL | POLLHUP | POLLERR)) {
              next unless my $io = $self->{io}{$fd};
              ++$i and $self->_try('I/O watcher', $io->{cb}, 0);
            }
            next unless $mode & POLLOUT && (my $io = $self->{io}{$fd});
            ++$i and $self->_try('I/O watcher', $io->{cb}, 1);
          }
        }
      }
  
      # Wait for timeout if poll can't be used
      elsif ($timeout) { usleep($timeout * 1000) }
  
      # Timers (time should not change in between timers)
      my $now = steady_time;
      for my $id (keys %{$self->{timers}}) {
        next unless my $t = $self->{timers}{$id};
        next unless $t->{time} <= $now;
  
        # Recurring timer
        if (exists $t->{recurring}) { $t->{time} = $now + $t->{recurring} }
  
        # Normal timer
        else { $self->remove($id) }
  
        ++$i and $self->_try('Timer', $t->{cb}) if $t->{cb};
      }
    }
  }
  
  sub recurring { shift->_timer(1, @_) }
  
  sub remove {
    my ($self, $remove) = @_;
    return !!delete $self->{timers}{$remove} unless ref $remove;
    return !!delete $self->{io}{fileno($remove) // croak 'Handle is closed'};
  }
  
  sub reset { delete @{shift()}{qw(events io next_tick next_timer timers)} }
  
  sub start {
    my $self = shift;
    local $self->{running} = ($self->{running} || 0) + 1;
    $self->one_tick while $self->{running};
  }
  
  sub stop { delete shift->{running} }
  
  sub timer { shift->_timer(0, @_) }
  
  sub watch {
    my ($self, $handle, $read, $write) = @_;
  
    croak 'I/O watcher not active' unless my $io = $self->{io}{fileno $handle};
    $io->{mode} = 0;
    $io->{mode} |= POLLIN | POLLPRI if $read;
    $io->{mode} |= POLLOUT if $write;
  
    return $self;
  }
  
  sub _id {
    my $self = shift;
    my $id;
    do { $id = md5_sum 't' . steady_time . rand } while $self->{timers}{$id};
    return $id;
  }
  
  sub _next {
    my $self = shift;
    delete $self->{next_timer};
    while (my $cb = shift @{$self->{next_tick}}) { $self->$cb }
  }
  
  sub _timer {
    my ($self, $recurring, $after, $cb) = @_;
  
    my $id    = $self->_id;
    my $timer = $self->{timers}{$id}
      = {cb => $cb, after => $after, time => steady_time + $after};
    $timer->{recurring} = $after if $recurring;
  
    return $id;
  }
  
  sub _try {
    my ($self, $what, $cb) = (shift, shift, shift);
    eval { $self->$cb(@_); 1 } or $self->emit(error => "$what failed: $@");
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Reactor::Poll - Low-level event reactor with poll support
  
  =head1 SYNOPSIS
  
    use Mojo::Reactor::Poll;
  
    # Watch if handle becomes readable or writable
    my $reactor = Mojo::Reactor::Poll->new;
    $reactor->io($first => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'First handle is writable' : 'First handle is readable';
    });
  
    # Change to watching only if handle becomes writable
    $reactor->watch($first, 0, 1);
  
    # Turn file descriptor into handle and watch if it becomes readable
    my $second = IO::Handle->new_from_fd($fd, 'r');
    $reactor->io($second => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Second handle is writable' : 'Second handle is readable';
    })->watch($second, 1, 0);
  
    # Add a timer
    $reactor->timer(15 => sub {
      my $reactor = shift;
      $reactor->remove($first);
      $reactor->remove($second);
      say 'Timeout!';
    });
  
    # Start reactor if necessary
    $reactor->start unless $reactor->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::Reactor::Poll> is a low-level event reactor based on L<IO::Poll>.
  
  =head1 EVENTS
  
  L<Mojo::Reactor::Poll> inherits all events from L<Mojo::Reactor>.
  
  =head1 METHODS
  
  L<Mojo::Reactor::Poll> inherits all methods from L<Mojo::Reactor> and
  implements the following new ones.
  
  =head2 again
  
    $reactor->again($id);
  
  Restart timer. Note that this method requires an active timer.
  
  =head2 io
  
    $reactor = $reactor->io($handle => sub {...});
  
  Watch handle for I/O events, invoking the callback whenever handle becomes
  readable or writable.
  
    # Callback will be executed twice if handle becomes readable and writable
    $reactor->io($handle => sub {
      my ($reactor, $writable) = @_;
      say $writable ? 'Handle is writable' : 'Handle is readable';
    });
  
  =head2 is_running
  
    my $bool = $reactor->is_running;
  
  Check if reactor is running.
  
  =head2 next_tick
  
    my $undef = $reactor->next_tick(sub {...});
  
  Execute callback as soon as possible, but not before returning or other
  callbacks that have been registered with this method, always returns C<undef>.
  
  =head2 one_tick
  
    $reactor->one_tick;
  
  Run reactor until an event occurs or no events are being watched anymore.
  
    # Don't block longer than 0.5 seconds
    my $id = $reactor->timer(0.5 => sub {});
    $reactor->one_tick;
    $reactor->remove($id);
  
  =head2 recurring
  
    my $id = $reactor->recurring(0.25 => sub {...});
  
  Create a new recurring timer, invoking the callback repeatedly after a given
  amount of time in seconds.
  
  =head2 remove
  
    my $bool = $reactor->remove($handle);
    my $bool = $reactor->remove($id);
  
  Remove handle or timer.
  
  =head2 reset
  
    $reactor->reset;
  
  Remove all handles and timers.
  
  =head2 start
  
    $reactor->start;
  
  Start watching for I/O and timer events, this will block until L</"stop"> is
  called or no events are being watched anymore.
  
    # Start reactor only if it is not running already
    $reactor->start unless $reactor->is_running;
  
  =head2 stop
  
    $reactor->stop;
  
  Stop watching for I/O and timer events.
  
  =head2 timer
  
    my $id = $reactor->timer(0.5 => sub {...});
  
  Create a new timer, invoking the callback after a given amount of time in
  seconds.
  
  =head2 watch
  
    $reactor = $reactor->watch($handle, $readable, $writable);
  
  Change I/O events to watch handle for with true and false values. Note that
  this method requires an active I/O watcher.
  
    # Watch only for readable events
    $reactor->watch($handle, 1, 0);
  
    # Watch only for writable events
    $reactor->watch($handle, 0, 1);
  
    # Watch for readable and writable events
    $reactor->watch($handle, 1, 1);
  
    # Pause watching for events
    $reactor->watch($handle, 0, 0);
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_REACTOR_POLL

$fatpacked{"Mojo/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER';
  package Mojo::Server;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Mojo::File 'path';
  use Mojo::Loader 'load_class';
  use Mojo::Util 'md5_sum';
  use POSIX ();
  use Scalar::Util 'blessed';
  
  has app           => sub { shift->build_app('Mojo::HelloWorld') };
  has reverse_proxy => sub { $ENV{MOJO_REVERSE_PROXY} };
  
  sub build_app {
    my ($self, $app) = (shift, shift);
    local $ENV{MOJO_EXE};
    return $self->app($app->new(@_))->app unless my $e = load_class $app;
    die ref $e ? $e : qq{Can't find application class "$app" in \@INC. (@INC)\n};
  }
  
  sub build_tx {
    my $self = shift;
    my $tx   = $self->app->build_tx;
    $tx->req->reverse_proxy(1) if $self->reverse_proxy;
    return $tx;
  }
  
  sub daemonize {
  
    # Fork and kill parent
    die "Can't fork: $!" unless defined(my $pid = fork);
    exit 0 if $pid;
    POSIX::setsid or die "Can't start a new session: $!";
  
    # Close filehandles
    open STDIN,  '</dev/null';
    open STDOUT, '>/dev/null';
    open STDERR, '>&STDOUT';
  }
  
  sub load_app {
    my ($self, $path) = @_;
  
    # Clean environment (reset FindBin defensively)
    {
      local $0 = $path = path($path)->to_abs->to_string;
      require FindBin;
      FindBin->again;
      local $ENV{MOJO_APP_LOADER} = 1;
      local $ENV{MOJO_EXE};
  
      # Try to load application from script into sandbox
      delete $INC{$path};
      my $app = eval
        "package Mojo::Server::Sandbox::@{[md5_sum $path]}; require \$path";
      die qq{Can't load application from file "$path": $@} if $@;
      die qq{File "$path" did not return an application object.\n}
        unless blessed $app && $app->can('handler');
      $self->app($app);
    };
    FindBin->again;
  
    return $self->app;
  }
  
  sub new {
    my $self = shift->SUPER::new(@_);
    $self->on(request => sub { shift->app->handler(shift) });
    return $self;
  }
  
  sub run { croak 'Method "run" not implemented by subclass' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server - HTTP/WebSocket server base class
  
  =head1 SYNOPSIS
  
    package Mojo::Server::MyServer;
    use Mojo::Base 'Mojo::Server';
  
    sub run {
      my $self = shift;
  
      # Get a transaction
      my $tx = $self->build_tx;
  
      # Emit "request" event
      $self->emit(request => $tx);
    }
  
  =head1 DESCRIPTION
  
  L<Mojo::Server> is an abstract base class for HTTP/WebSocket servers and server
  interfaces, like L<Mojo::Server::CGI>, L<Mojo::Server::Daemon>,
  L<Mojo::Server::Hypnotoad>, L<Mojo::Server::Morbo>, L<Mojo::Server::Prefork>
  and L<Mojo::Server::PSGI>.
  
  =head1 EVENTS
  
  L<Mojo::Server> inherits all events from L<Mojo::EventEmitter> and can emit the
  following new ones.
  
  =head2 request
  
    $server->on(request => sub {
      my ($server, $tx) = @_;
      ...
    });
  
  Emitted when a request is ready and needs to be handled.
  
    $server->on(request => sub {
      my ($server, $tx) = @_;
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body('Hello World!');
      $tx->resume;
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server> implements the following attributes.
  
  =head2 app
  
    my $app = $server->app;
    $server = $server->app(MojoSubclass->new);
  
  Application this server handles, defaults to a L<Mojo::HelloWorld> object.
  
  =head2 reverse_proxy
  
    my $bool = $server->reverse_proxy;
    $server  = $server->reverse_proxy($bool);
  
  This server operates behind a reverse proxy, defaults to the value of the
  C<MOJO_REVERSE_PROXY> environment variable.
  
  =head1 METHODS
  
  L<Mojo::Server> inherits all methods from L<Mojo::EventEmitter> and implements
  the following new ones.
  
  =head2 build_app
  
    my $app = $server->build_app('MyApp');
    my $app = $server->build_app('MyApp', log => Mojo::Log->new);
    my $app = $server->build_app('MyApp', {log => Mojo::Log->new});
  
  Build application from class and assign it to L</"app">.
  
  =head2 build_tx
  
    my $tx = $server->build_tx;
  
  Let application build a transaction.
  
  =head2 daemonize
  
    $server->daemonize;
  
  Daemonize server process.
  
  =head2 load_app
  
    my $app = $server->load_app('/home/sri/myapp.pl');
  
  Load application from script and assign it to L</"app">.
  
    say Mojo::Server->new->load_app('./myapp.pl')->home;
  
  =head2 new
  
    my $server = Mojo::Server->new;
    my $server = Mojo::Server->new(reverse_proxy => 1);
    my $server = Mojo::Server->new({reverse_proxy => 1});
  
  Construct a new L<Mojo::Server> object and subscribe to L</"request"> event
  with default request handling.
  
  =head2 run
  
    $server->run;
  
  Run server. Meant to be overloaded in a subclass.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_SERVER

$fatpacked{"Mojo/Server/CGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_CGI';
  package Mojo::Server::CGI;
  use Mojo::Base 'Mojo::Server';
  
  has 'nph';
  
  sub run {
    my $self = shift;
  
    my $tx  = $self->build_tx;
    my $req = $tx->req->parse(\%ENV);
    $tx->local_port($ENV{SERVER_PORT})->remote_address($ENV{REMOTE_ADDR});
  
    # Request body (may block if we try to read too much)
    binmode STDIN;
    my $len = $req->headers->content_length;
    until ($req->is_finished) {
      my $chunk = ($len && $len < 131072) ? $len : 131072;
      last unless my $read = STDIN->read(my $buffer, $chunk, 0);
      $req->parse($buffer);
      last if ($len -= $read) <= 0;
    }
  
    $self->emit(request => $tx);
  
    # Response start-line
    STDOUT->autoflush(1);
    binmode STDOUT;
    my $res = $tx->res->fix_headers;
    return undef if $self->nph && !_write($res, 'get_start_line_chunk');
  
    # Response headers
    my $code = $res->code    || 404;
    my $msg  = $res->message || $res->default_message;
    $res->headers->status("$code $msg") unless $self->nph;
    return undef unless _write($res, 'get_header_chunk');
  
    # Response body
    return undef unless $tx->is_empty || _write($res, 'get_body_chunk');
  
    # Finish transaction
    $tx->closed;
  
    return $res->code;
  }
  
  sub _write {
    my ($res, $method) = @_;
  
    my $offset = 0;
    while (1) {
  
      # No chunk yet, try again
      sleep 1 and next unless defined(my $chunk = $res->$method($offset));
  
      # End of part
      last unless my $len = length $chunk;
  
      # Make sure we can still write
      $offset += $len;
      return undef unless STDOUT->opened;
      print STDOUT $chunk;
    }
  
    return 1;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::CGI - CGI server
  
  =head1 SYNOPSIS
  
    use Mojo::Server::CGI;
  
    my $cgi = Mojo::Server::CGI->new;
    $cgi->unsubscribe('request')->on(request => sub {
      my ($cgi, $tx) = @_;
  
      # Request
      my $method = $tx->req->method;
      my $path   = $tx->req->url->path;
  
      # Response
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body("$method request for $path!");
  
      # Resume transaction
      $tx->resume;
    });
    $cgi->run;
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::CGI> is a simple and portable implementation of
  L<RFC 3875|http://tools.ietf.org/html/rfc3875>.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 EVENTS
  
  L<Mojo::Server::CGI> inherits all events from L<Mojo::Server>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::CGI> inherits all attributes from L<Mojo::Server> and
  implements the following new ones.
  
  =head2 nph
  
    my $bool = $cgi->nph;
    $cgi     = $cgi->nph($bool);
  
  Activate non-parsed header mode.
  
  =head1 METHODS
  
  L<Mojo::Server::CGI> inherits all methods from L<Mojo::Server> and implements
  the following new ones.
  
  =head2 run
  
    my $status = $cgi->run;
  
  Run CGI.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_SERVER_CGI

$fatpacked{"Mojo/Server/Daemon.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_DAEMON';
  package Mojo::Server::Daemon;
  use Mojo::Base 'Mojo::Server';
  
  use Carp 'croak';
  use Mojo::IOLoop;
  use Mojo::IOLoop::Stream::HTTPServer;
  use Mojo::IOLoop::Stream::WebSocketServer;
  use Mojo::URL;
  use Scalar::Util 'weaken';
  
  use constant DEBUG => $ENV{MOJO_SERVER_DEBUG} || 0;
  
  has acceptors => sub { [] };
  has [qw(backlog max_clients silent)];
  has inactivity_timeout => sub { $ENV{MOJO_INACTIVITY_TIMEOUT} // 15 };
  has ioloop             => sub { Mojo::IOLoop->singleton };
  has listen => sub { [split ',', $ENV{MOJO_LISTEN} || 'http://*:3000'] };
  has max_requests => 100;
  
  sub DESTROY {
    return if Mojo::Util::_global_destruction();
    my $self = shift;
    my $loop = $self->ioloop;
    $loop->remove($_) for keys %{$self->{connections} || {}}, @{$self->acceptors};
  }
  
  sub close_connections {
    my $self = shift;
    my $loop = $self->ioloop;
    $_->max_requests(1)
      for map { $loop->stream($_) || () } keys %{$self->{connections} || {}};
  }
  
  sub ports { [map { $_[0]->ioloop->acceptor($_)->port } @{$_[0]->acceptors}] }
  
  sub run {
    my $self = shift;
  
    # Make sure the event loop can be stopped in regular intervals
    my $loop = $self->ioloop;
    my $int = $loop->recurring(1 => sub { });
    local $SIG{INT} = local $SIG{TERM} = sub { $loop->stop };
    $self->start->ioloop->start;
    $loop->remove($int);
  }
  
  sub start {
    my $self = shift;
  
    my $loop = $self->ioloop;
    if (my $max = $self->max_clients) { $loop->max_connections($max) }
  
    # Resume accepting connections
    if (my $servers = $self->{servers}) {
      push @{$self->acceptors}, $loop->acceptor(delete $servers->{$_})
        for keys %$servers;
    }
  
    # Start listening
    elsif (!@{$self->acceptors}) {
      $self->app->server($self);
      $self->_listen($_) for @{$self->listen};
    }
  
    return $self;
  }
  
  sub stop {
    my $self = shift;
  
    # Suspend accepting connections but keep listen sockets open
    my $loop = $self->ioloop;
    while (my $id = shift @{$self->acceptors}) {
      my $server = $self->{servers}{$id} = $loop->acceptor($id);
      $loop->remove($id);
      $server->stop;
    }
  
    return $self;
  }
  
  sub _debug { $_[0]->app->log->debug($_[2]) if $_[0]{connections}{$_[1]}{tx} }
  
  sub _listen {
    my ($self, $listen) = @_;
  
    my $url   = Mojo::URL->new($listen);
    my $proto = $url->protocol;
    croak qq{Invalid listen location "$listen"}
      unless $proto eq 'http' || $proto eq 'https' || $proto eq 'http+unix';
  
    my $query   = $url->query;
    my $options = {
      backlog      => $self->backlog,
      stream_class => 'Mojo::IOLoop::Stream::HTTPServer'
    };
    $options->{$_} = $query->param($_) for qw(fd single_accept reuse);
    if ($proto eq 'http+unix') { $options->{path} = $url->host }
    else {
      if ((my $host = $url->host) ne '*') { $options->{address} = $host }
      if (my $port = $url->port) { $options->{port} = $port }
    }
    $options->{"tls_$_"} = $query->param($_) for qw(ca ciphers version);
    /^(.*)_(cert|key)$/ and $options->{"tls_$2"}{$1} = $query->param($_)
      for @{$query->names};
    if (my $cert = $query->param('cert')) { $options->{'tls_cert'}{''} = $cert }
    if (my $key  = $query->param('key'))  { $options->{'tls_key'}{''}  = $key }
    my $verify = $query->param('verify');
    $options->{tls_verify} = hex $verify if defined $verify;
    $options->{tls} = $proto eq 'https';
  
    weaken $self;
    push @{$self->acceptors}, $self->ioloop->server(
      $options => sub {
        my ($loop, $stream, $id) = @_;
  
        my $c = $self->{connections}{$id} = {};
        warn "-- Accept $id (@{[$stream->handle->peerhost]})\n" if DEBUG;
        $stream->timeout($self->inactivity_timeout);
        $stream->max_requests($self->max_requests);
        weaken $stream->app($self)->{app};
  
        $stream->on(close => sub { $self && $self->_remove($id) });
        $stream->on(error =>
            sub { $self && $self->app->log->error(pop) && $self->_remove($id) });
        $stream->on(request => sub { $self->_request($id, pop) });
        $stream->on(start => sub { $c->{tx} = pop->connection($id) });
        $stream->on(timeout => sub { $self->_debug($id, 'Inactivity timeout') });
        $stream->on(upgrade => sub { $self->_upgrade($id, pop) });
      }
    );
  
    return if $self->silent;
    $self->app->log->info(qq{Listening at "$url"});
    $query->pairs([]);
    $url->host('127.0.0.1') if $url->host eq '*';
    say 'Server available at ', $options->{path} // $url;
  }
  
  sub _remove {
    my ($self, $id) = @_;
    $self->ioloop->remove($id);
    delete $self->{connections}{$id};
  }
  
  sub _request {
    my ($self, $id, $tx) = @_;
    if (my $error = $tx->error) { $self->_debug($id, $error->{message}) }
  
    weaken $self;
    $tx->on(finish => sub { delete $self->{connections}{$id}{tx} });
    $self->emit(request => $tx);
  }
  
  sub _upgrade {
    my ($self, $id, $ws) = @_;
  
    my $loop    = $self->ioloop;
    my $timeout = $loop->stream($id)->timeout;
    my $stream  = $loop->transition($id, 'Mojo::IOLoop::Stream::WebSocketServer');
    $stream->timeout($timeout);
  
    weaken $self;
    $stream->on(timeout => sub { $self->_debug($id, 'Inactivity timeout') });
    $stream->on(close => sub { $self && $self->_remove($id) });
    $stream->on(
      error => sub { $self && $self->app->log->error(pop) && $self->_remove($id) }
    );
  
    $self->{connections}{$id} = {tx => $ws};
    $stream->process($ws);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::Daemon - Non-blocking I/O HTTP and WebSocket server
  
  =head1 SYNOPSIS
  
    use Mojo::Server::Daemon;
  
    my $daemon = Mojo::Server::Daemon->new(listen => ['http://*:8080']);
    $daemon->unsubscribe('request')->on(request => sub {
      my ($daemon, $tx) = @_;
  
      # Request
      my $method = $tx->req->method;
      my $path   = $tx->req->url->path;
  
      # Response
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body("$method request for $path!");
  
      # Resume transaction
      $tx->resume;
    });
    $daemon->run;
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::Daemon> is a full featured, highly portable non-blocking I/O
  HTTP and WebSocket server, with IPv6, TLS, SNI, Comet (long polling), keep-alive
  and multiple event loop support.
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (2.009+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NNR>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 SIGNALS
  
  The L<Mojo::Server::Daemon> process can be controlled at runtime with the
  following signals.
  
  =head2 INT, TERM
  
  Shut down server immediately.
  
  =head1 EVENTS
  
  L<Mojo::Server::Daemon> inherits all events from L<Mojo::Server>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::Daemon> inherits all attributes from L<Mojo::Server> and
  implements the following new ones.
  
  =head2 acceptors
  
    my $acceptors = $daemon->acceptors;
    $daemon       = $daemon->acceptors(['6be0c140ef00a389c5d039536b56d139']);
  
  Active acceptor ids.
  
    # Check port
    mu $port = $daemon->ioloop->acceptor($daemon->acceptors->[0])->port;
  
  =head2 backlog
  
    my $backlog = $daemon->backlog;
    $daemon     = $daemon->backlog(128);
  
  Listen backlog size, defaults to C<SOMAXCONN>.
  
  =head2 inactivity_timeout
  
    my $timeout = $daemon->inactivity_timeout;
    $daemon     = $daemon->inactivity_timeout(5);
  
  Maximum amount of time in seconds a connection can be inactive before getting
  closed, defaults to the value of the C<MOJO_INACTIVITY_TIMEOUT> environment
  variable or C<15>. Setting the value to C<0> will allow connections to be
  inactive indefinitely.
  
  =head2 ioloop
  
    my $loop = $daemon->ioloop;
    $daemon  = $daemon->ioloop(Mojo::IOLoop->new);
  
  Event loop object to use for I/O operations, defaults to the global
  L<Mojo::IOLoop> singleton.
  
  =head2 listen
  
    my $listen = $daemon->listen;
    $daemon    = $daemon->listen(['https://127.0.0.1:8080']);
  
  Array reference with one or more locations to listen on, defaults to the value
  of the C<MOJO_LISTEN> environment variable or C<http://*:3000> (shortcut for
  C<http://0.0.0.0:3000>).
  
    # Listen on all IPv4 interfaces
    $daemon->listen(['http://*:3000']);
  
    # Listen on all IPv4 and IPv6 interfaces
    $daemon->listen(['http://[::]:3000']);
  
    # Listen on IPv6 interface
    $daemon->listen(['http://[::1]:4000']);
  
    # Listen on IPv4 and IPv6 interfaces
    $daemon->listen(['http://127.0.0.1:3000', 'http://[::1]:3000']);
  
    # Listen on UNIX domain socket "/tmp/myapp.sock" (percent encoded slash)
    $daemon->listen(['http+unix://%2Ftmp%2Fmyapp.sock']);
  
    # File descriptor, as used by systemd
    $daemon->listen(['http://127.0.0.1?fd=3']);
  
    # Allow multiple servers to use the same port (SO_REUSEPORT)
    $daemon->listen(['http://*:8080?reuse=1']);
  
    # Listen on two ports with HTTP and HTTPS at the same time
    $daemon->listen(['http://*:3000', 'https://*:4000']);
  
    # Use a custom certificate and key
    $daemon->listen(['https://*:3000?cert=/x/server.crt&key=/y/server.key']);
  
    # Domain specific certificates and keys (SNI)
    $daemon->listen(
      ['https://*:3000?example.com_cert=/x/my.crt&example.com_key=/y/my.key']);
  
    # Or even a custom certificate authority
    $daemon->listen(
      ['https://*:3000?cert=/x/server.crt&key=/y/server.key&ca=/z/ca.crt']);
  
  These parameters are currently available:
  
  =over 2
  
  =item ca
  
    ca=/etc/tls/ca.crt
  
  Path to TLS certificate authority file used to verify the peer certificate.
  
  =item cert
  
    cert=/etc/tls/server.crt
    mojolicious.org_cert=/etc/tls/mojo.crt
  
  Path to the TLS cert file, defaults to a built-in test certificate.
  
  =item ciphers
  
    ciphers=AES128-GCM-SHA256:RC4:HIGH:!MD5:!aNULL:!EDH
  
  TLS cipher specification string. For more information about the format see
  L<https://www.openssl.org/docs/manmaster/apps/ciphers.html#CIPHER-STRINGS>.
  
  =item fd
  
    fd=3
  
  File descriptor with an already prepared listen socket.
  
  =item key
  
    key=/etc/tls/server.key
    mojolicious.org_key=/etc/tls/mojo.key
  
  Path to the TLS key file, defaults to a built-in test key.
  
  =item reuse
  
    reuse=1
  
  Allow multiple servers to use the same port with the C<SO_REUSEPORT> socket
  option.
  
  =item single_accept
  
    single_accept=1
  
  Only accept one connection at a time.
  
  =item verify
  
    verify=0x00
  
  TLS verification mode.
  
  =item version
  
    version=TLSv1_2
  
  TLS protocol version.
  
  =back
  
  =head2 max_clients
  
    my $max = $daemon->max_clients;
    $daemon = $daemon->max_clients(100);
  
  Maximum number of accepted connections this server is allowed to handle
  concurrently, before stopping to accept new incoming connections, passed along
  to L<Mojo::IOLoop/"max_connections">.
  
  =head2 max_requests
  
    my $max = $daemon->max_requests;
    $daemon = $daemon->max_requests(250);
  
  Maximum number of keep-alive requests per connection, defaults to C<100>.
  
  =head2 silent
  
    my $bool = $daemon->silent;
    $daemon  = $daemon->silent($bool);
  
  Disable console messages.
  
  =head1 METHODS
  
  L<Mojo::Server::Daemon> inherits all methods from L<Mojo::Server> and
  implements the following new ones.
  
  =head2 close_connections
  
    $daemon->close_connections;
  
  Stop accepting new requests and close all connections after finising those
  currently being processed.
  
  =head2 ports
  
    my $ports = $daemon->ports;
  
  Get all ports this server is currently listening on.
  
    # All ports
    say for @{$daemon->ports};
  
  =head2 run
  
    $daemon->run;
  
  Run server and wait for L</"SIGNALS">.
  
  =head2 start
  
    $daemon = $daemon->start;
  
  Start or resume accepting connections through L</"ioloop">.
  
    # Listen on random port
    my $port = $daemon->listen(['http://127.0.0.1'])->start->ports->[0];
  
    # Run multiple web servers concurrently
    my $daemon1 = Mojo::Server::Daemon->new(listen => ['http://*:3000'])->start;
    my $daemon2 = Mojo::Server::Daemon->new(listen => ['http://*:4000'])->start;
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 stop
  
    $daemon = $daemon->stop;
  
  Stop accepting connections through L</"ioloop">.
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_SERVER_DEBUG> environment variable to get some advanced
  diagnostics information printed to C<STDERR>.
  
    MOJO_SERVER_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_SERVER_DAEMON

$fatpacked{"Mojo/Server/Hypnotoad.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_HYPNOTOAD';
  package Mojo::Server::Hypnotoad;
  use Mojo::Base -base;
  
  # "Bender: I was God once.
  #  God: Yes, I saw. You were doing well, until everyone died."
  use Config;
  use Mojo::File 'path';
  use Mojo::Server::Prefork;
  use Mojo::Util 'steady_time';
  use Scalar::Util 'weaken';
  
  has prefork => sub { Mojo::Server::Prefork->new(listen => ['http://*:8080']) };
  has upgrade_timeout => 180;
  
  sub configure {
    my ($self, $name) = @_;
  
    # Hypnotoad settings
    my $prefork = $self->prefork;
    my $c = $prefork->app->config($name) || {};
    $self->upgrade_timeout($c->{upgrade_timeout}) if $c->{upgrade_timeout};
  
    # Pre-fork settings
    $prefork->reverse_proxy($c->{proxy})   if defined $c->{proxy};
    $prefork->max_clients($c->{clients})   if $c->{clients};
    $prefork->max_requests($c->{requests}) if $c->{requests};
    defined $c->{$_} and $prefork->$_($c->{$_})
      for qw(accepts backlog graceful_timeout heartbeat_interval),
      qw(heartbeat_timeout inactivity_timeout listen pid_file spare workers);
  }
  
  sub run {
    my ($self, $app) = @_;
  
    # No fork emulation support
    _exit('Hypnotoad does not support fork emulation.') if $Config{d_pseudofork};
  
    # Remember executable and application for later
    $ENV{HYPNOTOAD_EXE} ||= $0;
    $0 = $ENV{HYPNOTOAD_APP} ||= path($app)->to_abs->to_string;
  
    # This is a production server
    $ENV{MOJO_MODE} ||= 'production';
  
    # Clean start (to make sure everything works)
    die "Can't exec: $!"
      if !$ENV{HYPNOTOAD_REV}++ && !exec $^X, $ENV{HYPNOTOAD_EXE};
  
    # Preload application and configure server
    my $prefork = $self->prefork->cleanup(0);
    $prefork->load_app($app)->config->{hypnotoad}{pid_file}
      //= path($ENV{HYPNOTOAD_APP})->sibling('hypnotoad.pid')->to_string;
    $self->configure('hypnotoad');
    weaken $self;
    $prefork->on(wait   => sub { $self->_manage });
    $prefork->on(reap   => sub { $self->_cleanup(pop) });
    $prefork->on(finish => sub { $self->_finish });
  
    # Testing
    _exit('Everything looks good!') if $ENV{HYPNOTOAD_TEST};
  
    # Stop running server
    $self->_stop if $ENV{HYPNOTOAD_STOP};
  
    # Initiate hot deployment
    $self->_hot_deploy unless $ENV{HYPNOTOAD_PID};
  
    # Daemonize as early as possible (but not for restarts)
    local $SIG{USR2} = sub { $self->{upgrade} ||= steady_time };
    $prefork->start;
    $prefork->daemonize if !$ENV{HYPNOTOAD_FOREGROUND} && $ENV{HYPNOTOAD_REV} < 3;
  
    # Start accepting connections
    $prefork->cleanup(1)->run;
  }
  
  sub _cleanup {
    my ($self, $pid) = @_;
  
    # Clean up failed upgrade
    return unless ($self->{new} || '') eq $pid;
    $self->prefork->app->log->error('Zero downtime software upgrade failed');
    delete @$self{qw(new upgrade)};
  }
  
  sub _exit { say shift and exit 0 }
  
  sub _finish {
    my $self = shift;
  
    $self->{finish} = 1;
    return unless my $new = $self->{new};
  
    my $prefork = $self->prefork->cleanup(0);
    unlink $prefork->pid_file;
    $prefork->ensure_pid_file($new);
  }
  
  sub _hot_deploy {
  
    # Make sure server is running
    return unless my $pid = shift->prefork->check_pid;
  
    # Start hot deployment
    kill 'USR2', $pid;
    _exit("Starting hot deployment for Hypnotoad server $pid.");
  }
  
  sub _manage {
    my $self = shift;
  
    # Upgraded (wait for all workers to send a heartbeat)
    my $prefork = $self->prefork;
    my $log     = $prefork->app->log;
    if ($ENV{HYPNOTOAD_PID} && $ENV{HYPNOTOAD_PID} ne $$) {
      return unless $prefork->healthy == $prefork->workers;
      $log->info("Upgrade successful, stopping $ENV{HYPNOTOAD_PID}");
      kill 'QUIT', $ENV{HYPNOTOAD_PID};
    }
    $ENV{HYPNOTOAD_PID} = $$ unless ($ENV{HYPNOTOAD_PID} // '') eq $$;
  
    # Upgrade
    if ($self->{upgrade} && !$self->{finished}) {
  
      # Fresh start
      my $ut = $self->upgrade_timeout;
      unless ($self->{new}) {
        $log->info("Starting zero downtime software upgrade ($ut seconds)");
        die "Can't fork: $!" unless defined(my $pid = $self->{new} = fork);
        exec $^X, $ENV{HYPNOTOAD_EXE} or die "Can't exec: $!" unless $pid;
      }
  
      # Timeout
      kill 'KILL', $self->{new} if $self->{upgrade} + $ut <= steady_time;
    }
  }
  
  sub _stop {
    _exit('Hypnotoad server not running.')
      unless my $pid = shift->prefork->check_pid;
    kill 'QUIT', $pid;
    _exit("Stopping Hypnotoad server $pid gracefully.");
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::Hypnotoad - A production web serv...ALL GLORY TO THE HYPNOTOAD!
  
  =head1 SYNOPSIS
  
    use Mojo::Server::Hypnotoad;
  
    my $hypnotoad = Mojo::Server::Hypnotoad->new;
    $hypnotoad->run('/home/sri/myapp.pl');
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::Hypnotoad> is a full featured, UNIX optimized, pre-forking
  non-blocking I/O HTTP and WebSocket server, built around the very well tested
  and reliable L<Mojo::Server::Prefork>, with IPv6, TLS, SNI, UNIX domain socket,
  Comet (long polling), keep-alive, multiple event loop and hot deployment support
  that just works. Note that the server uses signals for process management, so
  you should avoid modifying signal handlers in your applications.
  
  To start applications with it you can use the L<hypnotoad> script, which
  listens on port C<8080>, automatically daemonizes the server process and
  defaults to C<production> mode for L<Mojolicious> and L<Mojolicious::Lite>
  applications.
  
    $ hypnotoad ./myapp.pl
  
  You can run the same command again for automatic hot deployment.
  
    $ hypnotoad ./myapp.pl
    Starting hot deployment for Hypnotoad server 31841.
  
  This second invocation will load the application again, detect the process id
  file with it, and send a L</"USR2"> signal to the already running server.
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (2.009+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NNR>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 MANAGER SIGNALS
  
  The L<Mojo::Server::Hypnotoad> manager process can be controlled at runtime
  with the following signals.
  
  =head2 INT, TERM
  
  Shut down server immediately.
  
  =head2 QUIT
  
  Shut down server gracefully.
  
  =head2 TTIN
  
  Increase worker pool by one.
  
  =head2 TTOU
  
  Decrease worker pool by one.
  
  =head2 USR2
  
  Attempt zero downtime software upgrade (hot deployment) without losing any
  incoming connections.
  
    Manager (old)
    |- Worker [1]
    |- Worker [2]
    |- Worker [3]
    |- Worker [4]
    +- Manager (new)
       |- Worker [1]
       |- Worker [2]
       |- Worker [3]
       +- Worker [4]
  
  The new manager will automatically send a L</"QUIT"> signal to the old manager
  and take over serving requests after starting up successfully.
  
  =head1 WORKER SIGNALS
  
  L<Mojo::Server::Hypnotoad> worker processes can be controlled at runtime with
  the following signals.
  
  =head2 QUIT
  
  Stop worker gracefully.
  
  =head1 SETTINGS
  
  L<Mojo::Server::Hypnotoad> can be configured with the following settings, see
  L<Mojolicious::Guides::Cookbook/"Hypnotoad"> for examples.
  
  =head2 accepts
  
    accepts => 100
  
  Maximum number of connections a worker is allowed to accept, before stopping
  gracefully and then getting replaced with a newly started worker, defaults to
  the value of L<Mojo::Server::Prefork/"accepts">. Setting the value to C<0> will
  allow workers to accept new connections indefinitely. Note that up to half of
  this value can be subtracted randomly to improve load balancing, and to make
  sure that not all workers restart at the same time.
  
  =head2 backlog
  
    backlog => 128
  
  Listen backlog size, defaults to the value of
  L<Mojo::Server::Daemon/"backlog">.
  
  =head2 clients
  
    clients => 100
  
  Maximum number of accepted connections each worker process is allowed to handle
  concurrently, before stopping to accept new incoming connections, defaults to
  the value of L<Mojo::IOLoop/"max_connections">. Note that high concurrency works
  best with applications that perform mostly non-blocking operations, to optimize
  for blocking operations you can decrease this value and increase L</"workers">
  instead for better performance.
  
  =head2 graceful_timeout
  
    graceful_timeout => 15
  
  Maximum amount of time in seconds stopping a worker gracefully may take before
  being forced, defaults to the value of
  L<Mojo::Server::Prefork/"graceful_timeout">. Note that this value should usually
  be a little larger than the maximum amount of time you expect any one request to
  take.
  
  =head2 heartbeat_interval
  
    heartbeat_interval => 3
  
  Heartbeat interval in seconds, defaults to the value of
  L<Mojo::Server::Prefork/"heartbeat_interval">.
  
  =head2 heartbeat_timeout
  
    heartbeat_timeout => 2
  
  Maximum amount of time in seconds before a worker without a heartbeat will be
  stopped gracefully, defaults to the value of
  L<Mojo::Server::Prefork/"heartbeat_timeout">. Note that this value should
  usually be a little larger than the maximum amount of time you expect any one
  operation to block the event loop.
  
  =head2 inactivity_timeout
  
    inactivity_timeout => 10
  
  Maximum amount of time in seconds a connection can be inactive before getting
  closed, defaults to the value of L<Mojo::Server::Daemon/"inactivity_timeout">.
  Setting the value to C<0> will allow connections to be inactive indefinitely.
  
  =head2 listen
  
    listen => ['http://*:80']
  
  Array reference with one or more locations to listen on, defaults to
  C<http://*:8080>. See also L<Mojo::Server::Daemon/"listen"> for more examples.
  
  =head2 pid_file
  
    pid_file => '/var/run/hypnotoad.pid'
  
  Full path to process id file, defaults to C<hypnotoad.pid> in the same
  directory as the application. Note that this value can only be changed after
  the server has been stopped.
  
  =head2 proxy
  
    proxy => 1
  
  Activate reverse proxy support, which allows for the C<X-Forwarded-For> and
  C<X-Forwarded-Proto> headers to be picked up automatically, defaults to the
  value of L<Mojo::Server/"reverse_proxy">.
  
  =head2 requests
  
    requests => 50
  
  Number of keep-alive requests per connection, defaults to the value of
  L<Mojo::Server::Daemon/"max_requests">.
  
  =head2 spare
  
    spare => 4
  
  Temporarily spawn up to this number of additional workers if there is a need,
  defaults to the value of L<Mojo::Server::Prefork/"spare">. This allows for new
  workers to be started while old ones are still shutting down gracefully,
  drastically reducing the performance cost of worker restarts.
  
  =head2 upgrade_timeout
  
    upgrade_timeout => 45
  
  Maximum amount of time in seconds a zero downtime software upgrade may take
  before getting canceled, defaults to C<180>.
  
  =head2 workers
  
    workers => 10
  
  Number of worker processes, defaults to the value of
  L<Mojo::Server::Prefork/"workers">. A good rule of thumb is two worker
  processes per CPU core for applications that perform mostly non-blocking
  operations, blocking operations often require more and benefit from decreasing
  concurrency with L</"clients"> (often as low as C<1>). Note that during zero
  downtime software upgrades there will be twice as many workers active for a
  short amount of time.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::Hypnotoad> implements the following attributes.
  
  =head2 prefork
  
    my $prefork = $hypnotoad->prefork;
    $hypnotoad  = $hypnotoad->prefork(Mojo::Server::Prefork->new);
  
  L<Mojo::Server::Prefork> object this server manages.
  
  =head2 upgrade_timeout
  
    my $timeout = $hypnotoad->upgrade_timeout;
    $hypnotoad  = $hypnotoad->upgrade_timeout(15);
  
  Maximum amount of time in seconds a zero downtime software upgrade may take
  before getting canceled, defaults to C<180>.
  
  =head1 METHODS
  
  L<Mojo::Server::Hypnotoad> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 configure
  
    $hypnotoad->configure('hypnotoad');
  
  Configure server from application settings.
  
  =head2 run
  
    $hypnotoad->run('script/my_app');
  
  Run server for application and wait for L</"MANAGER SIGNALS">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_SERVER_HYPNOTOAD

$fatpacked{"Mojo/Server/Morbo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_MORBO';
  package Mojo::Server::Morbo;
  use Mojo::Base -base;
  
  # "Linda: With Haley's Comet out of ice, Earth is experiencing the devastating
  #         effects of sudden, intense global warming.
  #  Morbo: Morbo is pleased but sticky."
  use Mojo::Loader 'load_class';
  use Mojo::Server::Daemon;
  use POSIX 'WNOHANG';
  
  has backend => sub {
    my $backend = $ENV{MOJO_MORBO_BACKEND} || 'Poll';
    $backend = "Mojo::Server::Morbo::Backend::$backend";
    return $backend->new unless my $e = load_class $backend;
    die $e if ref $e;
    die qq{Can't find Morbo backend class "$backend" in \@INC. (@INC)\n};
  };
  has daemon => sub { Mojo::Server::Daemon->new };
  
  sub run {
    my ($self, $app) = @_;
  
    # Clean manager environment
    local $SIG{INT} = local $SIG{TERM} = sub {
      $self->{finished} = 1;
      kill 'TERM', $self->{worker} if $self->{worker};
    };
    unshift @{$self->backend->watch}, $0 = $app;
    $self->{modified} = 1;
  
    # Prepare and cache listen sockets for smooth restarting
    $self->daemon->start->stop;
  
    $self->_manage until $self->{finished} && !$self->{worker};
    exit 0;
  }
  
  sub _manage {
    my $self = shift;
  
    if (my @files = @{$self->backend->modified_files}) {
      say @files == 1
        ? qq{File "@{[$files[0]]}" changed, restarting.}
        : qq{@{[scalar @files]} files changed, restarting.}
        if $ENV{MORBO_VERBOSE};
      kill 'TERM', $self->{worker} if $self->{worker};
      $self->{modified} = 1;
    }
  
    if (my $pid = $self->{worker}) {
      delete $self->{worker} if waitpid($pid, WNOHANG) == $pid;
    }
  
    $self->_spawn if !$self->{worker} && delete $self->{modified};
  }
  
  sub _spawn {
    my $self = shift;
  
    # Manager
    my $manager = $$;
    die "Can't fork: $!" unless defined(my $pid = $self->{worker} = fork);
    return if $pid;
  
    # Worker
    my $daemon = $self->daemon;
    $daemon->load_app($self->backend->watch->[0]);
    $daemon->ioloop->recurring(1 => sub { shift->stop unless kill 0, $manager });
    $daemon->run;
    exit 0;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::Morbo - Tonight at 11...DOOOOOOOOOOOOOOOM!
  
  =head1 SYNOPSIS
  
    use Mojo::Server::Morbo;
  
    my $morbo = Mojo::Server::Morbo->new;
    $morbo->run('/home/sri/myapp.pl');
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::Morbo> is a full featured, self-restart capable non-blocking
  I/O HTTP and WebSocket server, built around the very well tested and reliable
  L<Mojo::Server::Daemon>, with IPv6, TLS, SNI, UNIX domain socket, Comet (long
  polling), keep-alive and multiple event loop support. Note that the server uses
  signals for process management, so you should avoid modifying signal handlers in
  your applications.
  
  To start applications with it you can use the L<morbo> script.
  
    $ morbo ./myapp.pl
    Server available at http://127.0.0.1:3000
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (2.009+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NNR>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 SIGNALS
  
  The L<Mojo::Server::Morbo> process can be controlled at runtime with the
  following signals.
  
  =head2 INT, TERM
  
  Shut down server immediately.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::Morbo> implements the following attributes.
  
  =head2 backend
  
    my $backend = $morbo->backend;
    $morbo      = $morbo->backend(Mojo::Server::Morbo::Backend::Poll->new);
  
  Backend, usually a L<Mojo::Server::Morbo::Backend::Poll> object.
  
  =head2 daemon
  
    my $daemon = $morbo->daemon;
    $morbo     = $morbo->daemon(Mojo::Server::Daemon->new);
  
  L<Mojo::Server::Daemon> object this server manages.
  
  =head1 METHODS
  
  L<Mojo::Server::Morbo> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 run
  
    $morbo->run('script/my_app');
  
  Run server for application and wait for L</"SIGNALS">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_SERVER_MORBO

$fatpacked{"Mojo/Server/Morbo/Backend.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_MORBO_BACKEND';
  package Mojo::Server::Morbo::Backend;
  use Mojo::Base -base;
  
  use Carp 'croak';
  
  has watch => sub { [qw(lib templates)] };
  has watch_timeout => sub { $ENV{MOJO_MORBO_TIMEOUT} || 1 };
  
  sub modified_files {
    croak 'Method "modified_files" not implemented by subclass';
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::Morbo::Backend - Morbo backend base class
  
  =head1 SYNOPSIS
  
    package Mojo::Server::Morbo::Backend::Inotify:
    use Mojo::Base 'Mojo::Server::Morbo::Backend';
  
    sub modified_files {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::Morbo::Backend> is an abstract base class for Morbo backends,
  like L<Mojo::Server::Morbo::Backend::Poll>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::Morbo::Backend> implements the following attributes.
  
  =head2 watch
  
    my $watch = $backend->watch;
    $backend  = $backend->watch(['/home/sri/my_app']);
  
  Files and directories to watch for changes, defaults to the application script
  as well as the C<lib> and C<templates> directories in the current working
  directory.
  
  =head2 watch_timeout
  
    my $timeout = $backend->watch_timeout;
    $backend    = $backend->watch_timeout(10);
  
  Maximum amount of time in seconds a backend may block when waiting for files to
  change, defaults to the value of the C<MOJO_MORBO_TIMEOUT> environment variable
  or C<1>.
  
  =head1 METHODS
  
  L<Mojo::Server::Morbo::Backend> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 modified_files
  
    my $files = $backend->modified_files;
  
  Check if files from L</"watch"> have been modified since the last check and
  return an array reference with the results. Meant to be overloaded in a
  subclass.
  
    # All files that have been modified
    say for @{$backend->modified_files};
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_SERVER_MORBO_BACKEND

$fatpacked{"Mojo/Server/Morbo/Backend/Poll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_MORBO_BACKEND_POLL';
  package Mojo::Server::Morbo::Backend::Poll;
  use Mojo::Base 'Mojo::Server::Morbo::Backend';
  
  use Mojo::File 'path';
  
  sub modified_files {
    my $self = shift;
  
    my $cache = $self->{cache} ||= {};
    my @files;
    for my $file (map { -f $_ && -r _ ? $_ : _list($_) } @{$self->watch}) {
      my ($size, $mtime) = (stat $file)[7, 9];
      next unless defined $size and defined $mtime;
      my $stats = $cache->{$file} ||= [$^T, $size];
      next if $mtime <= $stats->[0] && $size == $stats->[1];
      @$stats = ($mtime, $size);
      push @files, $file;
    }
    sleep $self->watch_timeout unless @files;
  
    return \@files;
  }
  
  sub _list { path(shift)->list_tree->map('to_string')->each }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::Morbo::Backend::Poll - Morbo default backend
  
  =head1 SYNOPSIS
  
    use Mojo::Server::Morbo::Backend::Poll;
  
    my $backend = Mojo::Server::Morbo::Backend::Poll->new;
    if (my $files = $backend->modified_files) {
      ...
    }
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::Morbo::Backend:Poll> is the default backend for
  L<Mojo::Server::Morbo>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::Morbo::Backend::Poll> inherits all attributes from
  L<Mojo::Server::Morbo::Backend>.
  
  =head1 METHODS
  
  L<Mojo::Server::Morbo::Backend::Poll> inherits all methods from
  L<Mojo::Server::Morbo::Backend> and implements the following new ones.
  
  =head2 modified_files
  
    my $files = $backend->modified_files;
  
  Check file size and mtime to determine which files have changed, this is not
  particularly efficient, but very portable.
  
    # All files that have been modified
    say for @{$backend->modified_files};
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_SERVER_MORBO_BACKEND_POLL

$fatpacked{"Mojo/Server/PSGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_PSGI';
  package Mojo::Server::PSGI;
  use Mojo::Base 'Mojo::Server';
  
  sub run {
    my ($self, $env) = @_;
  
    my $tx  = $self->build_tx;
    my $req = $tx->req->parse($env);
    $tx->local_port($env->{SERVER_PORT})->remote_address($env->{REMOTE_ADDR});
  
    # Request body (may block if we try to read too much)
    my $len = $env->{CONTENT_LENGTH};
    until ($req->is_finished) {
      my $chunk = ($len && $len < 131072) ? $len : 131072;
      last unless my $read = $env->{'psgi.input'}->read(my $buffer, $chunk, 0);
      $req->parse($buffer);
      last if ($len -= $read) <= 0;
    }
  
    $self->emit(request => $tx);
  
    # Response headers
    my $res  = $tx->res->fix_headers;
    my $hash = $res->headers->to_hash(1);
    my @headers;
    for my $name (keys %$hash) { push @headers, $name, $_ for @{$hash->{$name}} }
  
    # PSGI response
    my $io = Mojo::Server::PSGI::_IO->new(tx => $tx, empty => $tx->is_empty);
    return [$res->code // 404, \@headers, $io];
  }
  
  sub to_psgi_app {
    my $self = shift;
  
    # Preload application and wrap it
    $self->app->server($self);
    return sub { $self->run(@_) }
  }
  
  package Mojo::Server::PSGI::_IO;
  use Mojo::Base -base;
  
  # Finish transaction
  sub close { shift->{tx}->closed }
  
  sub getline {
    my $self = shift;
  
    # Empty
    return undef if $self->{empty};
  
    # No content yet, try again later
    my $chunk = $self->{tx}->res->get_body_chunk($self->{offset} //= 0);
    return '' unless defined $chunk;
  
    # End of content
    return undef unless length $chunk;
  
    $self->{offset} += length $chunk;
    return $chunk;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::PSGI - PSGI server
  
  =head1 SYNOPSIS
  
    use Mojo::Server::PSGI;
  
    my $psgi = Mojo::Server::PSGI->new;
    $psgi->unsubscribe('request')->on(request => sub {
      my ($psgi, $tx) = @_;
  
      # Request
      my $method = $tx->req->method;
      my $path   = $tx->req->url->path;
  
      # Response
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body("$method request for $path!");
  
      # Resume transaction
      $tx->resume;
    });
    my $app = $psgi->to_psgi_app;
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::PSGI> allows L<Mojolicious> applications to run on all L<PSGI>
  compatible servers.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 EVENTS
  
  L<Mojo::Server::PSGI> inherits all events from L<Mojo::Server>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::PSGI> inherits all attributes from L<Mojo::Server>.
  
  =head1 METHODS
  
  L<Mojo::Server::PSGI> inherits all methods from L<Mojo::Server> and implements
  the following new ones.
  
  =head2 run
  
    my $res = $psgi->run($env);
  
  Run L<PSGI>.
  
  =head2 to_psgi_app
  
    my $app = $psgi->to_psgi_app;
  
  Turn L<Mojolicious> application into L<PSGI> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_SERVER_PSGI

$fatpacked{"Mojo/Server/Prefork.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_PREFORK';
  package Mojo::Server::Prefork;
  use Mojo::Base 'Mojo::Server::Daemon';
  
  use Config;
  use File::Spec::Functions 'tmpdir';
  use Mojo::File 'path';
  use Mojo::Util 'steady_time';
  use POSIX 'WNOHANG';
  use Scalar::Util 'weaken';
  
  has accepts            => 10000;
  has cleanup            => 1;
  has graceful_timeout   => 120;
  has heartbeat_timeout  => 30;
  has heartbeat_interval => 5;
  has pid_file           => sub { path(tmpdir, 'prefork.pid')->to_string };
  has spare              => 2;
  has workers            => 4;
  
  sub DESTROY { unlink $_[0]->pid_file if $_[0]->cleanup }
  
  sub check_pid {
    my $file = shift->pid_file;
    return undef unless open my $handle, '<', $file;
    my $pid = <$handle>;
    chomp $pid;
  
    # Running
    return $pid if $pid && kill 0, $pid;
  
    # Not running
    unlink $file;
    return undef;
  }
  
  sub ensure_pid_file {
    my ($self, $pid) = @_;
  
    # Check if PID file already exists
    return if -e (my $file = $self->pid_file);
  
    # Create PID file
    $self->app->log->error(qq{Can't create process id file "$file": $!})
      and die qq{Can't create process id file "$file": $!}
      unless open my $handle, '>', $file;
    $self->app->log->info(qq{Creating process id file "$file"});
    chmod 0644, $handle;
    print $handle "$pid\n";
  }
  
  sub healthy {
    scalar grep { $_->{healthy} } values %{shift->{pool}};
  }
  
  sub run {
    my $self = shift;
  
    # No fork emulation support
    say 'Pre-forking does not support fork emulation.' and exit 0
      if $Config{d_pseudofork};
  
    # Pipe for worker communication
    pipe($self->{reader}, $self->{writer}) or die "Can't create pipe: $!";
  
    # Clean manager environment
    local $SIG{CHLD} = sub {
      while ((my $pid = waitpid -1, WNOHANG) > 0) {
        $self->emit(reap => $pid)->_stopped($pid);
      }
    };
    local $SIG{INT} = local $SIG{TERM} = sub { $self->_term };
    local $SIG{QUIT} = sub { $self->_term(1) };
    local $SIG{TTIN} = sub { $self->workers($self->workers + 1) };
    local $SIG{TTOU} = sub {
      $self->workers > 0 ? $self->workers($self->workers - 1) : return;
      for my $w (values %{$self->{pool}}) {
        ($w->{graceful} = steady_time) and last unless $w->{graceful};
      }
    };
  
    # Preload application before starting workers
    $self->start->app->log->info("Manager $$ started");
    $self->ioloop->max_accepts($self->accepts);
    $self->{running} = 1;
    $self->_manage while $self->{running};
    $self->app->log->info("Manager $$ stopped");
  }
  
  sub _heartbeat { shift->{writer}->syswrite("$$:$_[0]\n") or exit 0 }
  
  sub _manage {
    my $self = shift;
  
    # Spawn more workers if necessary and check PID file
    if (!$self->{finished}) {
      my $graceful = grep { $_->{graceful} } values %{$self->{pool}};
      my $spare = $self->spare;
      $spare = $graceful ? $graceful > $spare ? $spare : $graceful : 0;
      my $need = ($self->workers - keys %{$self->{pool}}) + $spare;
      $self->_spawn while $need-- > 0;
      $self->ensure_pid_file($$);
    }
  
    # Shutdown
    elsif (!keys %{$self->{pool}}) { return delete $self->{running} }
  
    # Wait for heartbeats
    $self->_wait;
  
    my $interval = $self->heartbeat_interval;
    my $ht       = $self->heartbeat_timeout;
    my $gt       = $self->graceful_timeout;
    my $log      = $self->app->log;
    my $time     = steady_time;
  
    for my $pid (keys %{$self->{pool}}) {
      next unless my $w = $self->{pool}{$pid};
  
      # No heartbeat (graceful stop)
      $log->error("Worker $pid has no heartbeat ($ht seconds), restarting")
        and $w->{graceful} = $time
        if !$w->{graceful} && ($w->{time} + $interval + $ht <= $time);
  
      # Graceful stop with timeout
      my $graceful = $w->{graceful} ||= $self->{graceful} ? $time : undef;
      $log->info("Stopping worker $pid gracefully ($gt seconds)")
        and (kill 'QUIT', $pid or $self->_stopped($pid))
        if $graceful && !$w->{quit}++;
      $w->{force} = 1 if $graceful && $graceful + $gt <= $time;
  
      # Normal stop
      $log->warn("Stopping worker $pid immediately")
        and (kill 'KILL', $pid or $self->_stopped($pid))
        if $w->{force} || ($self->{finished} && !$graceful);
    }
  }
  
  sub _spawn {
    my $self = shift;
  
    # Manager
    die "Can't fork: $!" unless defined(my $pid = fork);
    return $self->emit(spawn => $pid)->{pool}{$pid} = {time => steady_time}
      if $pid;
  
    # Heartbeat messages
    my $loop     = $self->cleanup(0)->ioloop;
    my $finished = 0;
    $loop->on(finish => sub { $finished = 1 });
    weaken $self;
    my $cb = sub { $self->_heartbeat($finished) };
    $loop->next_tick($cb);
    $loop->recurring($self->heartbeat_interval => $cb);
  
    # Clean worker environment
    $SIG{$_} = 'DEFAULT' for qw(CHLD INT TERM TTIN TTOU);
    $SIG{QUIT} = sub { $loop->stop_gracefully };
    $loop->on(finish => sub { $self->max_requests(1)->close_connections });
    delete $self->{reader};
    srand;
  
    $self->app->log->info("Worker $$ started");
    $loop->start;
    exit 0;
  }
  
  sub _stopped {
    my ($self, $pid) = @_;
  
    return unless my $w = delete $self->{pool}{$pid};
  
    my $log = $self->app->log;
    $log->info("Worker $pid stopped");
    $log->error("Worker $pid stopped too early, shutting down") and $self->_term
      unless $w->{healthy};
  }
  
  sub _term {
    my ($self, $graceful) = @_;
    @{$self->emit(finish => $graceful)}{qw(finished graceful)} = (1, $graceful);
  }
  
  sub _wait {
    my $self = shift;
  
    # Poll for heartbeats
    my $reader = $self->emit('wait')->{reader};
    return unless Mojo::Util::_readable(1000, fileno($reader));
    return unless $reader->sysread(my $chunk, 4194304);
  
    # Update heartbeats (and stop gracefully if necessary)
    my $time = steady_time;
    while ($chunk =~ /(\d+):(\d)\n/g) {
      next unless my $w = $self->{pool}{$1};
      @$w{qw(healthy time)} = (1, $time) and $self->emit(heartbeat => $1);
      $w->{graceful} ||= $time if $2;
    }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Server::Prefork - Pre-forking non-blocking I/O HTTP and WebSocket server
  
  =head1 SYNOPSIS
  
    use Mojo::Server::Prefork;
  
    my $prefork = Mojo::Server::Prefork->new(listen => ['http://*:8080']);
    $prefork->unsubscribe('request')->on(request => sub {
      my ($prefork, $tx) = @_;
  
      # Request
      my $method = $tx->req->method;
      my $path   = $tx->req->url->path;
  
      # Response
      $tx->res->code(200);
      $tx->res->headers->content_type('text/plain');
      $tx->res->body("$method request for $path!");
  
      # Resume transaction
      $tx->resume;
    });
    $prefork->run;
  
  =head1 DESCRIPTION
  
  L<Mojo::Server::Prefork> is a full featured, UNIX optimized, pre-forking
  non-blocking I/O HTTP and WebSocket server, built around the very well tested
  and reliable L<Mojo::Server::Daemon>, with IPv6, TLS, SNI, UNIX domain socket,
  Comet (long polling), keep-alive and multiple event loop support. Note that the
  server uses signals for process management, so you should avoid modifying signal
  handlers in your applications.
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (1.84+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NNR>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"DEPLOYMENT"> for more.
  
  =head1 MANAGER SIGNALS
  
  The L<Mojo::Server::Prefork> manager process can be controlled at runtime with
  the following signals.
  
  =head2 INT, TERM
  
  Shut down server immediately.
  
  =head2 QUIT
  
  Shut down server gracefully.
  
  =head2 TTIN
  
  Increase worker pool by one.
  
  =head2 TTOU
  
  Decrease worker pool by one.
  
  =head1 WORKER SIGNALS
  
  L<Mojo::Server::Prefork> worker processes can be controlled at runtime with the
  following signals.
  
  =head2 QUIT
  
  Stop worker gracefully.
  
  =head1 EVENTS
  
  L<Mojo::Server::Prefork> inherits all events from L<Mojo::Server::Daemon> and
  can emit the following new ones.
  
  =head2 finish
  
    $prefork->on(finish => sub {
      my ($prefork, $graceful) = @_;
      ...
    });
  
  Emitted when the server shuts down.
  
    $prefork->on(finish => sub {
      my ($prefork, $graceful) = @_;
      say $graceful ? 'Graceful server shutdown' : 'Server shutdown';
    });
  
  =head2 heartbeat
  
    $prefork->on(heartbeat => sub {
      my ($prefork, $pid) = @_;
      ...
    });
  
  Emitted when a heartbeat message has been received from a worker.
  
    $prefork->on(heartbeat => sub {
      my ($prefork, $pid) = @_;
      say "Worker $pid has a heartbeat";
    });
  
  =head2 reap
  
    $prefork->on(reap => sub {
      my ($prefork, $pid) = @_;
      ...
    });
  
  Emitted when a child process exited.
  
    $prefork->on(reap => sub {
      my ($prefork, $pid) = @_;
      say "Worker $pid stopped";
    });
  
  =head2 spawn
  
    $prefork->on(spawn => sub {
      my ($prefork, $pid) = @_;
      ...
    });
  
  Emitted when a worker process is spawned.
  
    $prefork->on(spawn => sub {
      my ($prefork, $pid) = @_;
      say "Worker $pid started";
    });
  
  =head2 wait
  
    $prefork->on(wait => sub {
      my $prefork = shift;
      ...
    });
  
  Emitted when the manager starts waiting for new heartbeat messages.
  
    $prefork->on(wait => sub {
      my $prefork = shift;
      my $workers = $prefork->workers;
      say "Waiting for heartbeat messages from $workers workers";
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Server::Prefork> inherits all attributes from L<Mojo::Server::Daemon>
  and implements the following new ones.
  
  =head2 accepts
  
    my $accepts = $prefork->accepts;
    $prefork    = $prefork->accepts(100);
  
  Maximum number of connections a worker is allowed to accept, before stopping
  gracefully and then getting replaced with a newly started worker, passed along
  to L<Mojo::IOLoop/"max_accepts">, defaults to C<10000>. Setting the value to
  C<0> will allow workers to accept new connections indefinitely. Note that up to
  half of this value can be subtracted randomly to improve load balancing, and to
  make sure that not all workers restart at the same time.
  
  =head2 cleanup
  
    my $bool = $prefork->cleanup;
    $prefork = $prefork->cleanup($bool);
  
  Delete L</"pid_file"> automatically once it is not needed anymore, defaults to
  a true value.
  
  =head2 graceful_timeout
  
    my $timeout = $prefork->graceful_timeout;
    $prefork    = $prefork->graceful_timeout(15);
  
  Maximum amount of time in seconds stopping a worker gracefully may take before
  being forced, defaults to C<120>. Note that this value should usually be a
  little larger than the maximum amount of time you expect any one request to
  take.
  
  =head2 heartbeat_interval
  
    my $interval = $prefork->heartbeat_interval;
    $prefork     = $prefork->heartbeat_interval(3);
  
  Heartbeat interval in seconds, defaults to C<5>.
  
  =head2 heartbeat_timeout
  
    my $timeout = $prefork->heartbeat_timeout;
    $prefork    = $prefork->heartbeat_timeout(2);
  
  Maximum amount of time in seconds before a worker without a heartbeat will be
  stopped gracefully, defaults to C<30>. Note that this value should usually be a
  little larger than the maximum amount of time you expect any one operation to
  block the event loop.
  
  =head2 pid_file
  
    my $file = $prefork->pid_file;
    $prefork = $prefork->pid_file('/tmp/prefork.pid');
  
  Full path of process id file, defaults to C<prefork.pid> in a temporary
  directory.
  
  =head2 spare
  
    my $spare = $prefork->spare;
    $prefork  = $prefork->spare(4);
  
  Temporarily spawn up to this number of additional workers if there is a need,
  defaults to C<2>. This allows for new workers to be started while old ones are
  still shutting down gracefully, drastically reducing the performance cost of
  worker restarts.
  
  =head2 workers
  
    my $workers = $prefork->workers;
    $prefork    = $prefork->workers(10);
  
  Number of worker processes, defaults to C<4>. A good rule of thumb is two
  worker processes per CPU core for applications that perform mostly non-blocking
  operations, blocking operations often require more and benefit from decreasing
  concurrency with L<Mojo::Server::Daemon/"clients"> (often as low as C<1>).
  
  =head1 METHODS
  
  L<Mojo::Server::Prefork> inherits all methods from L<Mojo::Server::Daemon> and
  implements the following new ones.
  
  =head2 check_pid
  
    my $pid = $prefork->check_pid;
  
  Get process id for running server from L</"pid_file"> or delete it if server is
  not running.
  
    say 'Server is not running' unless $prefork->check_pid;
  
  =head2 ensure_pid_file
  
    $prefork->ensure_pid_file($pid);
  
  Ensure L</"pid_file"> exists.
  
  =head2 healthy
  
    my $healthy = $prefork->healthy;
  
  Number of currently active worker processes with a heartbeat.
  
  =head2 run
  
    $prefork->run;
  
  Run server and wait for L</"MANAGER SIGNALS">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_SERVER_PREFORK

$fatpacked{"Mojo/Template.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_TEMPLATE';
  package Mojo::Template;
  use Mojo::Base -base;
  
  use Carp 'croak';
  use Mojo::ByteStream;
  use Mojo::Exception;
  use Mojo::File 'path';
  use Mojo::Util qw(decode encode monkey_patch);
  
  use constant DEBUG => $ENV{MOJO_TEMPLATE_DEBUG} || 0;
  
  has [qw(append code prepend unparsed)] => '';
  has [qw(auto_escape compiled vars)];
  has capture_end   => 'end';
  has capture_start => 'begin';
  has comment_mark  => '#';
  has encoding      => 'UTF-8';
  has escape        => sub { \&Mojo::Util::xml_escape };
  has [qw(escape_mark expression_mark trim_mark)] => '=';
  has [qw(line_start replace_mark)] => '%';
  has name      => 'template';
  has namespace => 'Mojo::Template::SandBox';
  has tag_start => '<%';
  has tag_end   => '%>';
  has tree      => sub { [] };
  
  sub parse {
    my ($self, $template) = @_;
  
    # Clean start
    $self->unparsed($template)->tree(\my @tree)->compiled(undef);
  
    my $tag     = $self->tag_start;
    my $replace = $self->replace_mark;
    my $expr    = $self->expression_mark;
    my $escp    = $self->escape_mark;
    my $cpen    = $self->capture_end;
    my $cmnt    = $self->comment_mark;
    my $cpst    = $self->capture_start;
    my $trim    = $self->trim_mark;
    my $end     = $self->tag_end;
    my $start   = $self->line_start;
  
    my $line_re
      = qr/^(\s*)\Q$start\E(?:(\Q$replace\E)|(\Q$cmnt\E)|(\Q$expr\E))?(.*)$/;
    my $token_re = qr/
      (
        \Q$tag\E(?:\Q$replace\E|\Q$cmnt\E)                   # Replace
      |
        \Q$tag$expr\E(?:\Q$escp\E)?(?:\s*\Q$cpen\E(?!\w))?   # Expression
      |
        \Q$tag\E(?:\s*\Q$cpen\E(?!\w))?                      # Code
      |
        (?:(?<!\w)\Q$cpst\E\s*)?(?:\Q$trim\E)?\Q$end\E       # End
      )
    /x;
    my $cpen_re = qr/^\Q$tag\E(?:\Q$expr\E)?(?:\Q$escp\E)?\s*\Q$cpen\E(.*)$/;
    my $end_re  = qr/^(?:(\Q$cpst\E)\s*)?(\Q$trim\E)?\Q$end\E$/;
  
    # Split lines
    my $op = 'text';
    my ($trimming, $capture);
    for my $line (split "\n", $template) {
  
      # Turn Perl line into mixed line
      if ($op eq 'text' && $line =~ $line_re) {
  
        # Escaped start
        if ($2) { $line = "$1$start$5" }
  
        # Comment
        elsif ($3) { $line = "$tag$3 $trim$end" }
  
        # Expression or code
        else { $line = $4 ? "$1$tag$4$5 $end" : "$tag$5 $trim$end" }
      }
  
      # Escaped line ending
      $line .= "\n" if $line !~ s/\\\\$/\\\n/ && $line !~ s/\\$//;
  
      # Mixed line
      for my $token (split $token_re, $line) {
  
        # Capture end
        ($token, $capture) = ("$tag$1", 1) if $token =~ $cpen_re;
  
        # End
        if ($op ne 'text' && $token =~ $end_re) {
  
          # Capture start
          splice @tree, -1, 0, ['cpst'] if $1;
  
          # Trim left side
          _trim(\@tree) if ($trimming = $2) && @tree > 1;
  
          # Hint at end
          push @tree, [$op = 'text', ''];
        }
  
        # Code
        elsif ($token eq $tag) { $op = 'code' }
  
        # Expression
        elsif ($token eq "$tag$expr") { $op = 'expr' }
  
        # Expression that needs to be escaped
        elsif ($token eq "$tag$expr$escp") { $op = 'escp' }
  
        # Comment
        elsif ($token eq "$tag$cmnt") { $op = 'cmnt' }
  
        # Text (comments are just ignored)
        elsif ($op ne 'cmnt') {
  
          # Replace
          $token = $tag if $token eq "$tag$replace";
  
          # Trim right side (convert whitespace to line noise)
          if ($trimming && $token =~ s/^(\s+)//) {
            push @tree, ['code', $1];
            $trimming = 0;
          }
  
          # Token (with optional capture end)
          push @tree, $capture ? ['cpen'] : (), [$op, $token];
          $capture = 0;
        }
      }
  
      # Optimize successive text lines separated by a newline
      push @tree, ['line'] and next
        if $tree[-4] && $tree[-4][0] ne 'line'
        || (!$tree[-3] || $tree[-3][0] ne 'text' || $tree[-3][1] !~ /\n$/)
        || ($tree[-2][0] ne 'line' || $tree[-1][0] ne 'text');
      $tree[-3][1] .= pop(@tree)->[1];
    }
  
    return $self;
  }
  
  sub process {
    my $self = shift;
  
    # Use a local stack trace for compile exceptions
    my $compiled = $self->compiled;
    unless ($compiled) {
      my $code = $self->_compile->code;
      monkey_patch $self->namespace, '_escape', $self->escape;
      return Mojo::Exception->new($@)->inspect($self->unparsed, $code)
        ->trace->verbose(1)
        unless $compiled = eval $self->_wrap($code, @_);
      $self->compiled($compiled);
    }
  
    # Use a real stack trace for normal exceptions
    local $SIG{__DIE__} = sub {
      CORE::die $_[0] if ref $_[0];
      CORE::die Mojo::Exception->new(shift)
        ->trace->inspect($self->unparsed, $self->code)->verbose(1);
    };
  
    my $output;
    return eval { $output = $compiled->(@_); 1 } ? $output : $@;
  }
  
  sub render { shift->parse(shift)->process(@_) }
  
  sub render_file {
    my ($self, $path) = (shift, shift);
  
    $self->name($path) unless defined $self->{name};
    my $template = path($path)->slurp;
    my $encoding = $self->encoding;
    croak qq{Template "$path" has invalid encoding}
      if $encoding && !defined($template = decode $encoding, $template);
  
    return $self->render($template, @_);
  }
  
  sub _compile {
    my $self = shift;
  
    my $tree   = $self->tree;
    my $escape = $self->auto_escape;
  
    my @blocks = ('');
    my ($i, $capture, $multi);
    while (++$i <= @$tree && (my $next = $tree->[$i])) {
      my ($op, $value) = @{$tree->[$i - 1]};
      push @blocks, '' and next if $op eq 'line';
      my $newline = chomp($value //= '');
  
      # Text (quote and fix line ending)
      if ($op eq 'text') {
        $value = join "\n", map { quotemeta $_ } split("\n", $value, -1);
        $value .= '\n' if $newline;
        $blocks[-1] .= "\$_O .= \"" . $value . "\";" if length $value;
      }
  
      # Code or multi-line expression
      elsif ($op eq 'code' || $multi) { $blocks[-1] .= $value }
  
      # Capture end
      elsif ($op eq 'cpen') {
        $blocks[-1] .= 'return Mojo::ByteStream->new($_O) }';
  
        # No following code
        $blocks[-1] .= ';' if ($next->[1] // '') =~ /^\s*$/;
      }
  
      # Expression
      if ($op eq 'expr' || $op eq 'escp') {
  
        # Escaped
        if (!$multi && ($op eq 'escp' && !$escape || $op eq 'expr' && $escape)) {
          $blocks[-1] .= "\$_O .= _escape scalar + $value";
        }
  
        # Raw
        elsif (!$multi) { $blocks[-1] .= "\$_O .= scalar + $value" }
  
        # Multi-line
        $multi = !$next || $next->[0] ne 'text';
  
        # Append semicolon
        $blocks[-1] .= ';' unless $multi || $capture;
      }
  
      # Capture start
      if ($op eq 'cpst') { $capture = 1 }
      elsif ($capture) {
        $blocks[-1] .= "sub { my \$_O = ''; ";
        $capture = 0;
      }
    }
  
    return $self->code(join "\n", @blocks)->tree([]);
  }
  
  sub _line {
    my $name = shift->name;
    $name =~ y/"//d;
    return qq{#line @{[shift]} "$name"};
  }
  
  sub _trim {
    my $tree = shift;
  
    # Skip captures
    my $i = $tree->[-2][0] eq 'cpst' || $tree->[-2][0] eq 'cpen' ? -3 : -2;
  
    # Only trim text
    return unless $tree->[$i][0] eq 'text';
  
    # Convert whitespace text to line noise
    splice @$tree, $i, 0, ['code', $1] if $tree->[$i][1] =~ s/(\s+)$//;
  }
  
  sub _wrap {
    my ($self, $body, $vars) = @_;
  
    # Variables
    my $args = '';
    if ($self->vars && (my @vars = grep {/^\w+$/} keys %$vars)) {
      $args = 'my (' . join(',', map {"\$$_"} @vars) . ')';
      $args .= '= @{shift()}{qw(' . join(' ', @vars) . ')};';
    }
  
    # Wrap lines
    my $num = () = $body =~ /\n/g;
    my $code = $self->_line(1) . "\npackage @{[$self->namespace]};";
    $code .= "use Mojo::Base -strict; no warnings 'ambiguous';";
    $code .= "sub { my \$_O = ''; @{[$self->prepend]};{ $args { $body\n";
    $code .= $self->_line($num + 1) . "\n;}@{[$self->append]}; } \$_O };";
  
    warn "-- Code for @{[$self->name]}\n@{[encode 'UTF-8', $code]}\n\n" if DEBUG;
    return $code;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Template - Perl-ish templates
  
  =head1 SYNOPSIS
  
    use Mojo::Template;
  
    # Use Perl modules
    my $mt = Mojo::Template->new;
    say $mt->render(<<'EOF');
    % use Time::Piece;
    <div>
      % my $now = localtime;
      Time: <%= $now->hms %>
    </div>
    EOF
  
    # Render with arguments
    say $mt->render(<<'EOF', [1 .. 13], 'Hello World!');
    % my ($numbers, $title) = @_;
    <div>
      <h1><%= $title %></h1>
      % for my $i (@$numbers) {
        Test <%= $i %>
      % }
    </div>
    EOF
  
    # Render with named variables
    say $mt->vars(1)->render(<<'EOF', {title => 'Hello World!'});
    <div>
      <h1><%= $title %></h1>
      %= 5 + 5
    </div>
    EOF
  
  =head1 DESCRIPTION
  
  L<Mojo::Template> is a minimalistic, fast, and very Perl-ish template engine,
  designed specifically for all those small tasks that come up during big
  projects. Like preprocessing a configuration file, generating text from heredocs
  and stuff like that.
  
  See L<Mojolicious::Guides::Rendering> for information on how to generate
  content with the L<Mojolicious> renderer.
  
  =head1 SYNTAX
  
  For all templates L<strict>, L<warnings>, L<utf8> and Perl 5.10
  L<features|feature> are automatically enabled.
  
    <% Perl code %>
    <%= Perl expression, replaced with result %>
    <%== Perl expression, replaced with XML escaped result %>
    <%# Comment, useful for debugging %>
    <%% Replaced with "<%", useful for generating templates %>
    % Perl code line, treated as "<% line =%>" (explained later)
    %= Perl expression line, treated as "<%= line %>"
    %== Perl expression line, treated as "<%== line %>"
    %# Comment line, useful for debugging
    %% Replaced with "%", useful for generating templates
  
  Escaping behavior can be reversed with the L</"auto_escape"> attribute, this is
  the default in L<Mojolicious> C<.ep> templates, for example.
  
    <%= Perl expression, replaced with XML escaped result %>
    <%== Perl expression, replaced with result %>
  
  L<Mojo::ByteStream> objects are always excluded from automatic escaping.
  
    % use Mojo::ByteStream 'b';
    <%= b('<div>excluded!</div>') %>
  
  Whitespace characters around tags can be trimmed by adding an additional equal
  sign to the end of a tag.
  
    <% for (1 .. 3) { %>
      <%= 'Trim all whitespace characters around this expression' =%>
    <% } %>
  
  Newline characters can be escaped with a backslash.
  
    This is <%= 1 + 1 %> a\
    single line
  
  And a backslash in front of a newline character can be escaped with another
  backslash.
  
    This will <%= 1 + 1 %> result\\
    in multiple\\
    lines
  
  A newline character gets appended automatically to every template, unless the
  last character is a backslash. And empty lines at the end of a template are
  ignored.
  
    There is <%= 1 + 1 %> no newline at the end here\
  
  You can capture whole template blocks for reuse later with the C<begin> and
  C<end> keywords. Just be aware that both keywords are part of the surrounding
  tag and not actual Perl code, so there can only be whitespace after C<begin>
  and before C<end>.
  
    <% my $block = begin %>
      <% my $name = shift; =%>
      Hello <%= $name %>.
    <% end %>
    <%= $block->('Baerbel') %>
    <%= $block->('Wolfgang') %>
  
  Perl lines can also be indented freely.
  
    % my $block = begin
      % my $name = shift;
      Hello <%= $name %>.
    % end
    %= $block->('Baerbel')
    %= $block->('Wolfgang')
  
  L<Mojo::Template> templates get compiled to a Perl subroutine, that means you
  can access arguments simply via C<@_>.
  
    % my ($foo, $bar) = @_;
    % my $x = shift;
    test 123 <%= $foo %>
  
  The compilation of templates to Perl code can make debugging a bit tricky, but
  L<Mojo::Template> will return L<Mojo::Exception> objects that stringify to
  error messages with context.
  
    Bareword "xx" not allowed while "strict subs" in use at template line 4.
    2: </head>
    3: <body>
    4: % my $i = 2; xx
    5: %= $i * 2
    6: </body>
  
  =head1 ATTRIBUTES
  
  L<Mojo::Template> implements the following attributes.
  
  =head2 auto_escape
  
    my $bool = $mt->auto_escape;
    $mt      = $mt->auto_escape($bool);
  
  Activate automatic escaping.
  
    # "&lt;html&gt;"
    Mojo::Template->new(auto_escape => 1)->render("<%= '<html>' %>");
  
  =head2 append
  
    my $code = $mt->append;
    $mt      = $mt->append('warn "Processed template"');
  
  Append Perl code to compiled template. Note that this code should not contain
  newline characters, or line numbers in error messages might end up being wrong.
  
  =head2 capture_end
  
    my $end = $mt->capture_end;
    $mt     = $mt->capture_end('end');
  
  Keyword indicating the end of a capture block, defaults to C<end>.
  
    <% my $block = begin %>
      Some data!
    <% end %>
  
  =head2 capture_start
  
    my $start = $mt->capture_start;
    $mt       = $mt->capture_start('begin');
  
  Keyword indicating the start of a capture block, defaults to C<begin>.
  
    <% my $block = begin %>
      Some data!
    <% end %>
  
  =head2 code
  
    my $code = $mt->code;
    $mt      = $mt->code($code);
  
  Perl code for template if available.
  
  =head2 comment_mark
  
    my $mark = $mt->comment_mark;
    $mt      = $mt->comment_mark('#');
  
  Character indicating the start of a comment, defaults to C<#>.
  
    <%# This is a comment %>
  
  =head2 compiled
  
    my $compiled = $mt->compiled;
    $mt          = $mt->compiled($compiled);
  
  Compiled template code if available.
  
  =head2 encoding
  
    my $encoding = $mt->encoding;
    $mt          = $mt->encoding('UTF-8');
  
  Encoding used for template files, defaults to C<UTF-8>.
  
  =head2 escape
  
    my $cb = $mt->escape;
    $mt    = $mt->escape(sub {...});
  
  A callback used to escape the results of escaped expressions, defaults to
  L<Mojo::Util/"xml_escape">.
  
    $mt->escape(sub {
      my $str = shift;
      return reverse $str;
    });
  
  =head2 escape_mark
  
    my $mark = $mt->escape_mark;
    $mt      = $mt->escape_mark('=');
  
  Character indicating the start of an escaped expression, defaults to C<=>.
  
    <%== $foo %>
  
  =head2 expression_mark
  
    my $mark = $mt->expression_mark;
    $mt      = $mt->expression_mark('=');
  
  Character indicating the start of an expression, defaults to C<=>.
  
    <%= $foo %>
  
  =head2 line_start
  
    my $start = $mt->line_start;
    $mt       = $mt->line_start('%');
  
  Character indicating the start of a code line, defaults to C<%>.
  
    % $foo = 23;
  
  =head2 name
  
    my $name = $mt->name;
    $mt      = $mt->name('foo.mt');
  
  Name of template currently being processed, defaults to C<template>. Note that
  this value should not contain quotes or newline characters, or error messages
  might end up being wrong.
  
  =head2 namespace
  
    my $namespace = $mt->namespace;
    $mt           = $mt->namespace('main');
  
  Namespace used to compile templates, defaults to C<Mojo::Template::SandBox>.
  Note that namespaces should only be shared very carefully between templates,
  since functions and global variables will not be cleared automatically.
  
  =head2 prepend
  
    my $code = $mt->prepend;
    $mt      = $mt->prepend('my $self = shift;');
  
  Prepend Perl code to compiled template. Note that this code should not contain
  newline characters, or line numbers in error messages might end up being wrong.
  
  =head2 replace_mark
  
    my $mark = $mt->replace_mark;
    $mt      = $mt->replace_mark('%');
  
  Character used for escaping the start of a tag or line, defaults to C<%>.
  
    <%% my $foo = 23; %>
  
  =head2 tag_start
  
    my $start = $mt->tag_start;
    $mt       = $mt->tag_start('<%');
  
  Characters indicating the start of a tag, defaults to C<E<lt>%>.
  
    <% $foo = 23; %>
  
  =head2 tag_end
  
    my $end = $mt->tag_end;
    $mt     = $mt->tag_end('%>');
  
  Characters indicating the end of a tag, defaults to C<%E<gt>>.
  
    <%= $foo %>
  
  =head2 tree
  
    my $tree = $mt->tree;
    $mt      = $mt->tree([['text', 'foo'], ['line']]);
  
  Template in parsed form if available. Note that this structure should only be
  used very carefully since it is very dynamic.
  
  =head2 trim_mark
  
    my $mark = $mt->trim_mark;
    $mt      = $mt->trim_mark('-');
  
  Character activating automatic whitespace trimming, defaults to C<=>.
  
    <%= $foo =%>
  
  =head2 unparsed
  
    my $unparsed = $mt->unparsed;
    $mt          = $mt->unparsed('<%= 1 + 1 %>');
  
  Raw unparsed template if available.
  
  =head2 vars
  
    my $bool = $mt->vars;
    $mt      = $mt->vars($bool);
  
  Instead of a list of values, use a hash reference with named variables to pass
  data to templates.
  
    # "works!"
    Mojo::Template->new(vars => 1)->render('<%= $test %>!', {test => 'works'});
  
  =head1 METHODS
  
  L<Mojo::Template> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 parse
  
    $mt = $mt->parse('<%= 1 + 1 %>');
  
  Parse template into L</"tree">.
  
  =head2 process
  
    my $output = $mt->process;
    my $output = $mt->process(@args);
    my $output = $mt->process({foo => 'bar'});
  
  Process previously parsed template and return the result, or a
  L<Mojo::Exception> object if rendering failed.
  
    # Parse and process
    say Mojo::Template->new->parse('Hello <%= $_[0] %>')->process('Bender');
  
    # Reuse template (for much better performance)
    my $mt = Mojo::Template->new;
    say $mt->render('Hello <%= $_[0] %>!', 'Bender');
    say $mt->process('Fry');
    say $mt->process('Leela');
  
  =head2 render
  
    my $output = $mt->render('<%= 1 + 1 %>');
    my $output = $mt->render('<%= shift() + shift() %>', @args);
    my $output = $mt->render('<%= $foo %>', {foo => 'bar'});
  
  Render template and return the result, or a L<Mojo::Exception> object if
  rendering failed.
  
    # Longer version
    my $output = $mt->parse('<%= 1 + 1 %>')->process;
  
    # Render with arguments
    say Mojo::Template->new->render('<%= $_[0] %>', 'bar');
  
    # Render with named variables
    say Mojo::Template->new(vars => 1)->render('<%= $foo %>', {foo => 'bar'});
  
  =head2 render_file
  
    my $output = $mt->render_file('/tmp/foo.mt');
    my $output = $mt->render_file('/tmp/foo.mt', @args);
    my $output = $mt->render_file('/tmp/bar.mt', {foo => 'bar'});
  
  Same as L</"render">, but renders a template file.
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_TEMPLATE_DEBUG> environment variable to get some
  advanced diagnostics information printed to C<STDERR>.
  
    MOJO_TEMPLATE_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_TEMPLATE

$fatpacked{"Mojo/Transaction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_TRANSACTION';
  package Mojo::Transaction;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Carp 'croak';
  use Mojo::Message::Request;
  use Mojo::Message::Response;
  
  has [
    qw(kept_alive local_address local_port original_remote_address remote_port)];
  has req => sub { Mojo::Message::Request->new };
  has res => sub { Mojo::Message::Response->new };
  
  sub client_read  { croak 'Method "client_read" not implemented by subclass' }
  sub client_write { croak 'Method "client_write" not implemented by subclass' }
  
  sub closed { shift->completed->emit('finish') }
  
  sub completed { ++$_[0]{completed} and return $_[0] }
  
  sub connection {
    my $self = shift;
    return $self->emit(connection => $self->{connection} = shift) if @_;
    return $self->{connection};
  }
  
  sub error { $_[0]->req->error || $_[0]->res->error }
  
  sub is_finished { !!shift->{completed} }
  
  sub is_websocket {undef}
  
  sub remote_address {
    my $self = shift;
  
    return $self->original_remote_address(@_) if @_;
    return $self->original_remote_address unless $self->req->reverse_proxy;
  
    # Reverse proxy
    return ($self->req->headers->header('X-Forwarded-For') // '') =~ /([^,\s]+)$/
      ? $1
      : $self->original_remote_address;
  }
  
  sub result {
    my $self = shift;
    my $err  = $self->error;
    return !$err || $err->{code} ? $self->res : croak $err->{message};
  }
  
  sub server_read  { croak 'Method "server_read" not implemented by subclass' }
  sub server_write { croak 'Method "server_write" not implemented by subclass' }
  
  sub success { $_[0]->error ? undef : $_[0]->res }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Transaction - Transaction base class
  
  =head1 SYNOPSIS
  
    package Mojo::Transaction::MyTransaction;
    use Mojo::Base 'Mojo::Transaction';
  
    sub client_read  {...}
    sub client_write {...}
    sub server_read  {...}
    sub server_write {...}
  
  =head1 DESCRIPTION
  
  L<Mojo::Transaction> is an abstract base class for transactions, like
  L<Mojo::Transaction::HTTP> and L<Mojo::Transaction::WebSocket>.
  
  =head1 EVENTS
  
  L<Mojo::Transaction> inherits all events from L<Mojo::EventEmitter> and can
  emit the following new ones.
  
  =head2 connection
  
    $tx->on(connection => sub {
      my ($tx, $connection) = @_;
      ...
    });
  
  Emitted when a connection has been assigned to transaction.
  
  =head2 finish
  
    $tx->on(finish => sub {
      my $tx = shift;
      ...
    });
  
  Emitted when transaction is finished.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Transaction> implements the following attributes.
  
  =head2 kept_alive
  
    my $bool = $tx->kept_alive;
    $tx      = $tx->kept_alive($bool);
  
  Connection has been kept alive.
  
  =head2 local_address
  
    my $address = $tx->local_address;
    $tx         = $tx->local_address('127.0.0.1');
  
  Local interface address.
  
  =head2 local_port
  
    my $port = $tx->local_port;
    $tx      = $tx->local_port(8080);
  
  Local interface port.
  
  =head2 original_remote_address
  
    my $address = $tx->original_remote_address;
    $tx         = $tx->original_remote_address('127.0.0.1');
  
  Remote interface address.
  
  =head2 remote_port
  
    my $port = $tx->remote_port;
    $tx      = $tx->remote_port(8081);
  
  Remote interface port.
  
  =head2 req
  
    my $req = $tx->req;
    $tx     = $tx->req(Mojo::Message::Request->new);
  
  HTTP request, defaults to a L<Mojo::Message::Request> object.
  
    # Access request information
    my $method = $tx->req->method;
    my $url    = $tx->req->url->to_abs;
    my $info   = $tx->req->url->to_abs->userinfo;
    my $host   = $tx->req->url->to_abs->host;
    my $agent  = $tx->req->headers->user_agent;
    my $custom = $tx->req->headers->header('Custom-Header');
    my $bytes  = $tx->req->body;
    my $str    = $tx->req->text;
    my $hash   = $tx->req->params->to_hash;
    my $all    = $tx->req->uploads;
    my $value  = $tx->req->json;
    my $foo    = $tx->req->json('/23/foo');
    my $dom    = $tx->req->dom;
    my $bar    = $tx->req->dom('div.bar')->first->text;
  
  =head2 res
  
    my $res = $tx->res;
    $tx     = $tx->res(Mojo::Message::Response->new);
  
  HTTP response, defaults to a L<Mojo::Message::Response> object.
  
    # Access response information
    my $code    = $tx->res->code;
    my $message = $tx->res->message;
    my $server  = $tx->res->headers->server;
    my $custom  = $tx->res->headers->header('Custom-Header');
    my $bytes   = $tx->res->body;
    my $str     = $tx->res->text;
    my $value   = $tx->res->json;
    my $foo     = $tx->res->json('/23/foo');
    my $dom     = $tx->res->dom;
    my $bar     = $tx->res->dom('div.bar')->first->text;
  
  =head1 METHODS
  
  L<Mojo::Transaction> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 client_read
  
    $tx->client_read($bytes);
  
  Read data client-side, used to implement user agents such as L<Mojo::UserAgent>.
  Meant to be overloaded in a subclass.
  
  =head2 client_write
  
    my $bytes = $tx->client_write;
  
  Write data client-side, used to implement user agents such as
  L<Mojo::UserAgent>. Meant to be overloaded in a subclass.
  
  =head2 closed
  
    $tx = $tx->closed;
  
  Same as L</"completed">, but also indicates that all transaction data has been
  sent.
  
  =head2 completed
  
    $tx = $tx->completed;
  
  Low-level method to finalize transaction.
  
  =head2 connection
  
    my $id = $tx->connection;
    $tx    = $tx->connection($id);
  
  Connection identifier.
  
  =head2 error
  
    my $err = $tx->error;
  
  Get request or response error and return C<undef> if there is no error,
  commonly used together with L</"success">.
  
    # Longer version
    my $err = $tx->req->error || $tx->res->error;
  
    # Check for 4xx/5xx response and connection errors
    if (my $err = $tx->error) {
      die "$err->{code} response: $err->{message}" if $err->{code};
      die "Connection error: $err->{message}";
    }
  
  =head2 is_finished
  
    my $bool = $tx->is_finished;
  
  Check if transaction is finished.
  
  =head2 is_websocket
  
    my $bool = $tx->is_websocket;
  
  False, this is not a L<Mojo::Transaction::WebSocket> object.
  
  =head2 remote_address
  
    my $address = $tx->remote_address;
    $tx         = $tx->remote_address('127.0.0.1');
  
  Same as L</"original_remote_address"> or the last value of the
  C<X-Forwarded-For> header if L</"req"> has been performed through a reverse
  proxy.
  
  =head2 result
  
    my $res = $tx->result;
  
  Returns the L<Mojo::Message::Response> object from L</"res"> or dies if a
  connection error has occurred.
  
    # Fine grained response handling (dies on connection errors)
    my $res = $tx->result;
    if    ($res->is_success)  { say $res->body }
    elsif ($res->is_error)    { say $res->message }
    elsif ($res->code == 301) { say $res->headers->location }
    else                      { say 'Whatever...' }
  
  =head2 server_read
  
    $tx->server_read($bytes);
  
  Read data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>. Meant to be overloaded in a subclass.
  
  =head2 server_write
  
    my $bytes = $tx->server_write;
  
  Write data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>. Meant to be overloaded in a subclass.
  
  =head2 success
  
    my $res = $tx->success;
  
  Returns the L<Mojo::Message::Response> object from L</"res"> if transaction was
  successful or C<undef> otherwise. Connection and parser errors have only a
  message in L</"error">, C<400> and C<500> responses also a code.
  
    # Manual exception handling
    if (my $res = $tx->success) { say $res->body }
    else {
      my $err = $tx->error;
      die "$err->{code} response: $err->{message}" if $err->{code};
      die "Connection error: $err->{message}";
    }
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_TRANSACTION

$fatpacked{"Mojo/Transaction/HTTP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_TRANSACTION_HTTP';
  package Mojo::Transaction::HTTP;
  use Mojo::Base 'Mojo::Transaction';
  
  has 'previous';
  
  sub client_read {
    my ($self, $chunk) = @_;
  
    # Skip body for HEAD request
    my $res = $self->res;
    $res->content->skip_body(1) if uc $self->req->method eq 'HEAD';
    return unless $res->parse($chunk)->is_finished;
  
    # Unexpected 1xx response
    return $self->completed if !$res->is_info || $res->headers->upgrade;
    $self->res($res->new)->emit(unexpected => $res);
    return unless length(my $leftovers = $res->content->leftovers);
    $self->client_read($leftovers);
  }
  
  sub client_write { shift->_write(0) }
  
  sub is_empty { !!(uc $_[0]->req->method eq 'HEAD' || $_[0]->res->is_empty) }
  
  sub keep_alive {
    my $self = shift;
  
    # Close
    my $req      = $self->req;
    my $res      = $self->res;
    my $req_conn = lc($req->headers->connection // '');
    my $res_conn = lc($res->headers->connection // '');
    return undef if $req_conn eq 'close' || $res_conn eq 'close';
  
    # Keep-alive is optional for 1.0
    return $res_conn eq 'keep-alive' if $res->version eq '1.0';
    return $req_conn eq 'keep-alive' if $req->version eq '1.0';
  
    # Keep-alive is the default for 1.1
    return 1;
  }
  
  sub redirects {
    my $previous = shift;
    my @redirects;
    unshift @redirects, $previous while $previous = $previous->previous;
    return \@redirects;
  }
  
  sub resume { ++$_[0]{writing} and return $_[0]->emit('resume') }
  
  sub server_read {
    my ($self, $chunk) = @_;
  
    # Parse request
    my $req = $self->req;
    $req->parse($chunk) unless $req->error;
  
    # Generate response
    $self->emit('request') if $req->is_finished && !$self->{handled}++;
  }
  
  sub server_write { shift->_write(1) }
  
  sub _body {
    my ($self, $msg, $finish) = @_;
  
    # Prepare body chunk
    my $buffer = $msg->get_body_chunk($self->{offset});
    my $written = defined $buffer ? length $buffer : 0;
    $self->{write} = $msg->content->is_dynamic ? 1 : ($self->{write} - $written);
    $self->{offset} += $written;
  
    # Delayed
    $self->{writing} = 0 unless defined $buffer;
  
    # Finished
    $finish ? $self->completed : ($self->{writing} = 0)
      if $self->{write} <= 0 || defined $buffer && !length $buffer;
  
    return $buffer // '';
  }
  
  sub _headers {
    my ($self, $msg, $head) = @_;
  
    # Prepare header chunk
    my $buffer = $msg->get_header_chunk($self->{offset});
    my $written = defined $buffer ? length $buffer : 0;
    $self->{write} -= $written;
    $self->{offset} += $written;
  
    # Switch to body
    if ($self->{write} <= 0) {
      @$self{qw(http_state offset)} = ('body', 0);
  
      # Response without body
      if ($head && $self->is_empty) { $self->completed->{http_state} = 'empty' }
  
      # Body
      else { $self->{write} = $msg->content->is_dynamic ? 1 : $msg->body_size }
    }
  
    return $buffer;
  }
  
  sub _start_line {
    my ($self, $msg) = @_;
  
    # Prepare start-line chunk
    my $buffer = $msg->get_start_line_chunk($self->{offset});
    my $written = defined $buffer ? length $buffer : 0;
    $self->{write} -= $written;
    $self->{offset} += $written;
  
    # Switch to headers
    @$self{qw(http_state write offset)} = ('headers', $msg->header_size, 0)
      if $self->{write} <= 0;
  
    return $buffer;
  }
  
  sub _write {
    my ($self, $server) = @_;
  
    # Client starts writing right away
    return '' unless $server ? $self->{writing} : ($self->{writing} //= 1);
  
    # Nothing written yet
    $self->{$_} ||= 0 for qw(offset write);
    my $msg = $server ? $self->res : $self->req;
    @$self{qw(http_state write)} = ('start_line', $msg->start_line_size)
      unless $self->{http_state};
  
    # Start-line
    my $chunk = '';
    $chunk .= $self->_start_line($msg) if $self->{http_state} eq 'start_line';
  
    # Headers
    $chunk .= $self->_headers($msg, $server) if $self->{http_state} eq 'headers';
  
    # Body
    $chunk .= $self->_body($msg, $server) if $self->{http_state} eq 'body';
  
    return $chunk;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Transaction::HTTP - HTTP transaction
  
  =head1 SYNOPSIS
  
    use Mojo::Transaction::HTTP;
  
    # Client
    my $tx = Mojo::Transaction::HTTP->new;
    $tx->req->method('GET');
    $tx->req->url->parse('http://example.com');
    $tx->req->headers->accept('application/json');
    say $tx->res->code;
    say $tx->res->headers->content_type;
    say $tx->res->body;
    say $tx->remote_address;
  
    # Server
    my $tx = Mojo::Transaction::HTTP->new;
    say $tx->req->method;
    say $tx->req->url->to_abs;
    say $tx->req->headers->accept;
    say $tx->remote_address;
    $tx->res->code(200);
    $tx->res->headers->content_type('text/plain');
    $tx->res->body('Hello World!');
  
  =head1 DESCRIPTION
  
  L<Mojo::Transaction::HTTP> is a container for HTTP transactions, based on
  L<RFC 7230|http://tools.ietf.org/html/rfc7230> and
  L<RFC 7231|http://tools.ietf.org/html/rfc7231>.
  
  =head1 EVENTS
  
  L<Mojo::Transaction::HTTP> inherits all events from L<Mojo::Transaction> and
  can emit the following new ones.
  
  =head2 request
  
    $tx->on(request => sub {
      my $tx = shift;
      ...
    });
  
  Emitted when a request is ready and needs to be handled.
  
    $tx->on(request => sub {
      my $tx = shift;
      $tx->res->headers->header('X-Bender' => 'Bite my shiny metal ass!');
    });
  
  =head2 resume
  
    $tx->on(resume => sub {
      my $tx = shift;
      ...
    });
  
  Emitted when transaction is resumed.
  
  =head2 unexpected
  
    $tx->on(unexpected => sub {
      my ($tx, $res) = @_;
      ...
    });
  
  Emitted for unexpected C<1xx> responses that will be ignored.
  
    $tx->on(unexpected => sub {
      my $tx = shift;
      $tx->res->on(finish => sub { say 'Follow-up response is finished.' });
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Transaction::HTTP> inherits all attributes from L<Mojo::Transaction>
  and implements the following new ones.
  
  =head2 previous
  
    my $previous = $tx->previous;
    $tx          = $tx->previous(Mojo::Transaction::HTTP->new);
  
  Previous transaction that triggered this follow-up transaction, usually a
  L<Mojo::Transaction::HTTP> object.
  
    # Paths of previous requests
    say $tx->previous->previous->req->url->path;
    say $tx->previous->req->url->path;
  
  =head1 METHODS
  
  L<Mojo::Transaction::HTTP> inherits all methods from L<Mojo::Transaction> and
  implements the following new ones.
  
  =head2 client_read
  
    $tx->client_read($bytes);
  
  Read data client-side, used to implement user agents such as L<Mojo::UserAgent>.
  
  =head2 client_write
  
    my $bytes = $tx->client_write;
  
  Write data client-side, used to implement user agents such as
  L<Mojo::UserAgent>.
  
  =head2 is_empty
  
    my $bool = $tx->is_empty;
  
  Check transaction for C<HEAD> request and C<1xx>, C<204> or C<304> response.
  
  =head2 keep_alive
  
    my $bool = $tx->keep_alive;
  
  Check if connection can be kept alive.
  
  =head2 redirects
  
    my $redirects = $tx->redirects;
  
  Return an array reference with all previous transactions that preceded this
  follow-up transaction.
  
    # Paths of all previous requests
    say $_->req->url->path for @{$tx->redirects};
  
  =head2 resume
  
    $tx = $tx->resume;
  
  Resume transaction.
  
  =head2 server_read
  
    $tx->server_read($bytes);
  
  Read data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>.
  
  =head2 server_write
  
    my $bytes = $tx->server_write;
  
  Write data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_TRANSACTION_HTTP

$fatpacked{"Mojo/Transaction/WebSocket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_TRANSACTION_WEBSOCKET';
  package Mojo::Transaction::WebSocket;
  use Mojo::Base 'Mojo::Transaction';
  
  use Compress::Raw::Zlib 'Z_SYNC_FLUSH';
  use List::Util 'first';
  use Mojo::JSON qw(encode_json j);
  use Mojo::Util qw(decode encode trim);
  use Mojo::WebSocket
    qw(WS_BINARY WS_CLOSE WS_CONTINUATION WS_PING WS_PONG WS_TEXT);
  
  has [qw(compressed established handshake masked)];
  has max_websocket_size => sub { $ENV{MOJO_MAX_WEBSOCKET_SIZE} || 262144 };
  
  sub build_message {
    my ($self, $frame) = @_;
  
    # Text
    $frame = {text => encode('UTF-8', $frame)} if ref $frame ne 'HASH';
  
    # JSON
    $frame->{text} = encode_json($frame->{json}) if exists $frame->{json};
  
    # Raw text or binary
    if (exists $frame->{text}) { $frame = [1, 0, 0, 0, WS_TEXT, $frame->{text}] }
    else { $frame = [1, 0, 0, 0, WS_BINARY, $frame->{binary}] }
  
    # "permessage-deflate" extension
    return $frame unless $self->compressed;
    my $deflate = $self->{deflate} ||= Compress::Raw::Zlib::Deflate->new(
      AppendOutput => 1,
      MemLevel     => 8,
      WindowBits   => -15
    );
    $deflate->deflate($frame->[5], my $out);
    $deflate->flush($out, Z_SYNC_FLUSH);
    @$frame[1, 5] = (1, substr($out, 0, length($out) - 4));
  
    return $frame;
  }
  
  sub client_read  { shift->server_read(@_) }
  sub client_write { shift->server_write(@_) }
  
  sub closed {
    my $self = shift->completed;
    return $self->emit(finish => $self->{close} ? (@{$self->{close}}) : 1006);
  }
  
  sub connection { shift->handshake->connection }
  
  sub finish {
    my $self = shift;
  
    my $close = $self->{close} = [@_];
    my $payload = $close->[0] ? pack('n', $close->[0]) : '';
    $payload .= encode 'UTF-8', $close->[1] if defined $close->[1];
    $close->[0] //= 1005;
    $self->send([1, 0, 0, 0, WS_CLOSE, $payload])->{closing} = 1;
  
    return $self;
  }
  
  sub is_websocket {1}
  
  sub kept_alive    { shift->handshake->kept_alive }
  sub local_address { shift->handshake->local_address }
  sub local_port    { shift->handshake->local_port }
  
  sub parse_message {
    my ($self, $frame) = @_;
  
    $self->emit(frame => $frame);
  
    # Ping/Pong
    my $op = $frame->[4];
    return $self->send([1, 0, 0, 0, WS_PONG, $frame->[5]]) if $op == WS_PING;
    return if $op == WS_PONG;
  
    # Close
    if ($op == WS_CLOSE) {
      return $self->finish unless length $frame->[5] >= 2;
      return $self->finish(unpack('n', substr($frame->[5], 0, 2, '')),
        decode('UTF-8', $frame->[5]));
    }
  
    # Append chunk and check message size
    $self->{op} = $op unless exists $self->{op};
    $self->{message} .= $frame->[5];
    my $max = $self->max_websocket_size;
    return $self->finish(1009) if length $self->{message} > $max;
  
    # No FIN bit (Continuation)
    return unless $frame->[0];
  
    # "permessage-deflate" extension (handshake and RSV1)
    my $msg = delete $self->{message};
    if ($self->compressed && $frame->[1]) {
      my $inflate = $self->{inflate} ||= Compress::Raw::Zlib::Inflate->new(
        Bufsize     => $max,
        LimitOutput => 1,
        WindowBits  => -15
      );
      $inflate->inflate(($msg .= "\x00\x00\xff\xff"), my $out);
      return $self->finish(1009) if length $msg;
      $msg = $out;
    }
  
    $self->emit(json => j($msg)) if $self->has_subscribers('json');
    $op = delete $self->{op};
    $self->emit($op == WS_TEXT ? 'text' : 'binary' => $msg);
    $self->emit(message => $op == WS_TEXT ? decode 'UTF-8', $msg : $msg)
      if $self->has_subscribers('message');
  }
  
  sub protocol { shift->res->headers->sec_websocket_protocol }
  
  sub remote_address { shift->handshake->remote_address }
  sub remote_port    { shift->handshake->remote_port }
  sub req            { shift->handshake->req }
  sub res            { shift->handshake->res }
  
  sub resume { $_[0]->handshake->resume and return $_[0] }
  
  sub send {
    my ($self, $msg, $cb) = @_;
    $self->once(drain => $cb) if $cb;
    $msg = $self->build_message($msg) unless ref $msg eq 'ARRAY';
    $self->{write} .= Mojo::WebSocket::build_frame($self->masked, @$msg);
    return $self->emit('resume');
  }
  
  sub server_read {
    my ($self, $chunk) = @_;
  
    $self->{read} .= $chunk;
    my $max = $self->max_websocket_size;
    while (my $frame = Mojo::WebSocket::parse_frame(\$self->{read}, $max)) {
      $self->finish(1009) and last unless ref $frame;
      $self->parse_message($frame);
    }
  
    $self->emit('resume');
  }
  
  sub server_write {
    my $self = shift;
    $self->emit('drain') unless length($self->{write} //= '');
    $self->completed if !length $self->{write} && $self->{closing};
    return delete $self->{write};
  }
  
  sub with_compression {
    my $self = shift;
  
    # "permessage-deflate" extension
    $self->compressed(1)
      and $self->res->headers->sec_websocket_extensions('permessage-deflate')
      if ($self->req->headers->sec_websocket_extensions // '')
      =~ /permessage-deflate/;
  }
  
  sub with_protocols {
    my $self = shift;
  
    my %protos = map { trim($_) => 1 } split ',',
      $self->req->headers->sec_websocket_protocol // '';
    return undef unless defined(my $proto = first { $protos{$_} } @_);
  
    $self->res->headers->sec_websocket_protocol($proto);
    return $proto;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Transaction::WebSocket - WebSocket transaction
  
  =head1 SYNOPSIS
  
    use Mojo::Transaction::WebSocket;
  
    # Send and receive WebSocket messages
    my $ws = Mojo::Transaction::WebSocket->new;
    $ws->send('Hello World!');
    $ws->on(message => sub {
      my ($ws, $msg) = @_;
      say "Message: $msg";
    });
    $ws->on(finish => sub {
      my ($ws, $code, $reason) = @_;
      say "WebSocket closed with status $code.";
    });
  
  =head1 DESCRIPTION
  
  L<Mojo::Transaction::WebSocket> is a container for WebSocket transactions, based
  on L<RFC 6455|http://tools.ietf.org/html/rfc6455> and
  L<RFC 7692|http://tools.ietf.org/html/rfc7692>.
  
  =head1 EVENTS
  
  L<Mojo::Transaction::WebSocket> inherits all events from L<Mojo::Transaction>
  and can emit the following new ones.
  
  =head2 binary
  
    $ws->on(binary => sub {
      my ($ws, $bytes) = @_;
      ...
    });
  
  Emitted when a complete WebSocket binary message has been received.
  
    $ws->on(binary => sub {
      my ($ws, $bytes) = @_;
      say "Binary: $bytes";
    });
  
  =head2 drain
  
    $ws->on(drain => sub {
      my $ws = shift;
      ...
    });
  
  Emitted once all data has been sent.
  
    $ws->on(drain => sub {
      my $ws = shift;
      $ws->send(time);
    });
  
  =head2 finish
  
    $ws->on(finish => sub {
      my ($ws, $code, $reason) = @_;
      ...
    });
  
  Emitted when the WebSocket connection has been closed.
  
  =head2 frame
  
    $ws->on(frame => sub {
      my ($ws, $frame) = @_;
      ...
    });
  
  Emitted when a WebSocket frame has been received.
  
    $ws->on(frame => sub {
      my ($ws, $frame) = @_;
      say "FIN: $frame->[0]";
      say "RSV1: $frame->[1]";
      say "RSV2: $frame->[2]";
      say "RSV3: $frame->[3]";
      say "Opcode: $frame->[4]";
      say "Payload: $frame->[5]";
    });
  
  =head2 json
  
    $ws->on(json => sub {
      my ($ws, $json) = @_;
      ...
    });
  
  Emitted when a complete WebSocket message has been received, all text and
  binary messages will be automatically JSON decoded. Note that this event only
  gets emitted when it has at least one subscriber.
  
    $ws->on(json => sub {
      my ($ws, $hash) = @_;
      say "Message: $hash->{msg}";
    });
  
  =head2 message
  
    $ws->on(message => sub {
      my ($ws, $msg) = @_;
      ...
    });
  
  Emitted when a complete WebSocket message has been received, text messages will
  be automatically decoded. Note that this event only gets emitted when it has at
  least one subscriber.
  
    $ws->on(message => sub {
      my ($ws, $msg) = @_;
      say "Message: $msg";
    });
  
  =head2 resume
  
    $tx->on(resume => sub {
      my $tx = shift;
      ...
    });
  
  Emitted when transaction is resumed.
  
  =head2 text
  
    $ws->on(text => sub {
      my ($ws, $bytes) = @_;
      ...
    });
  
  Emitted when a complete WebSocket text message has been received.
  
    $ws->on(text => sub {
      my ($ws, $bytes) = @_;
      say "Text: $bytes";
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::Transaction::WebSocket> inherits all attributes from
  L<Mojo::Transaction> and implements the following new ones.
  
  =head2 compressed
  
    my $bool = $ws->compressed;
    $ws      = $ws->compressed($bool);
  
  Compress messages with C<permessage-deflate> extension.
  
  =head2 established
  
    my $bool = $ws->established;
    $ws      = $ws->established($bool);
  
  WebSocket connection established.
  
  =head2 handshake
  
    my $handshake = $ws->handshake;
    $ws           = $ws->handshake(Mojo::Transaction::HTTP->new);
  
  The original handshake transaction, usually a L<Mojo::Transaction::HTTP> object.
  
  =head2 masked
  
    my $bool = $ws->masked;
    $ws      = $ws->masked($bool);
  
  Mask outgoing frames with XOR cipher and a random 32-bit key.
  
  =head2 max_websocket_size
  
    my $size = $ws->max_websocket_size;
    $ws      = $ws->max_websocket_size(1024);
  
  Maximum WebSocket message size in bytes, defaults to the value of the
  C<MOJO_MAX_WEBSOCKET_SIZE> environment variable or C<262144> (256KiB).
  
  =head1 METHODS
  
  L<Mojo::Transaction::WebSocket> inherits all methods from L<Mojo::Transaction>
  and implements the following new ones.
  
  =head2 build_message
  
    my $frame = $ws->build_message({binary => $bytes});
    my $frame = $ws->build_message({text   => $bytes});
    my $frame = $ws->build_message({json   => {test => [1, 2, 3]}});
    my $frame = $ws->build_message($chars);
  
  Build WebSocket message.
  
  =head2 client_read
  
    $ws->client_read($data);
  
  Read data client-side, used to implement user agents such as L<Mojo::UserAgent>.
  
  =head2 client_write
  
    my $bytes = $ws->client_write;
  
  Write data client-side, used to implement user agents such as
  L<Mojo::UserAgent>.
  
  =head2 closed
  
    $tx = $tx->closed;
  
  Same as L<Mojo::Transaction/"completed">, but also indicates that all
  transaction data has been sent.
  
  =head2 connection
  
    my $id = $ws->connection;
  
  Connection identifier.
  
  =head2 finish
  
    $ws = $ws->finish;
    $ws = $ws->finish(1000);
    $ws = $ws->finish(1003 => 'Cannot accept data!');
  
  Close WebSocket connection gracefully.
  
  =head2 is_websocket
  
    my $bool = $ws->is_websocket;
  
  True, this is a L<Mojo::Transaction::WebSocket> object.
  
  =head2 kept_alive
  
    my $bool = $ws->kept_alive;
  
  Connection has been kept alive.
  
  =head2 local_address
  
    my $address = $ws->local_address;
  
  Local interface address.
  
  =head2 local_port
  
    my $port = $ws->local_port;
  
  Local interface port.
  
  =head2 parse_message
  
    $ws->parse_message([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);
  
  Parse WebSocket message.
  
  =head2 protocol
  
    my $proto = $ws->protocol;
  
  Return negotiated subprotocol or C<undef>.
  
  =head2 remote_address
  
    my $address = $ws->remote_address;
  
  Remote interface address.
  
  =head2 remote_port
  
    my $port = $ws->remote_port;
  
  Remote interface port.
  
  =head2 req
  
    my $req = $ws->req;
  
  Handshake request, usually a L<Mojo::Message::Request> object.
  
  =head2 res
  
    my $res = $ws->res;
  
  Handshake response, usually a L<Mojo::Message::Response> object.
  
  =head2 resume
  
    $ws = $ws->resume;
  
  Resume L</"handshake"> transaction.
  
  =head2 send
  
    $ws = $ws->send({binary => $bytes});
    $ws = $ws->send({text   => $bytes});
    $ws = $ws->send({json   => {test => [1, 2, 3]}});
    $ws = $ws->send([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);
    $ws = $ws->send($chars);
    $ws = $ws->send($chars => sub {...});
  
  Send message or frame non-blocking via WebSocket, the optional drain callback
  will be executed once all data has been written.
  
    # Send "Ping" frame
    use Mojo::WebSocket 'WS_PING';
    $ws->send([1, 0, 0, 0, WS_PING, 'Hello World!']);
  
  =head2 server_read
  
    $ws->server_read($data);
  
  Read data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>.
  
  =head2 server_write
  
    my $bytes = $ws->server_write;
  
  Write data server-side, used to implement web servers such as
  L<Mojo::Server::Daemon>.
  
  =head2 with_compression
  
    $ws->with_compression;
  
  Negotiate C<permessage-deflate> extension for this WebSocket connection.
  
  =head2 with_protocols
  
    my $proto = $ws->with_protocols('v2.proto', 'v1.proto');
  
  Negotiate subprotocol for this WebSocket connection.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_TRANSACTION_WEBSOCKET

$fatpacked{"Mojo/URL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_URL';
  package Mojo::URL;
  use Mojo::Base -base;
  use overload bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;
  
  use Mojo::Parameters;
  use Mojo::Path;
  use Mojo::Util
    qw(decode encode punycode_decode punycode_encode url_escape url_unescape);
  
  has base => sub { Mojo::URL->new };
  has [qw(fragment host port scheme userinfo)];
  
  sub clone {
    my $self  = shift;
    my $clone = $self->new;
    @$clone{keys %$self} = values %$self;
    $clone->{$_} && ($clone->{$_} = $clone->{$_}->clone) for qw(base path query);
    return $clone;
  }
  
  sub host_port {
    my ($self, $host_port) = @_;
  
    if (defined $host_port) {
      $self->port($1) if $host_port =~ s/:(\d+)$//;
      my $host = url_unescape $host_port;
      return $host =~ /[^\x00-\x7f]/ ? $self->ihost($host) : $self->host($host);
    }
  
    return undef unless defined(my $host = $self->ihost);
    return $host unless defined(my $port = $self->port);
    return "$host:$port";
  }
  
  sub ihost {
    my $self = shift;
  
    # Decode
    return $self->host(join '.',
      map { /^xn--(.+)$/ ? punycode_decode $1 : $_ } split(/\./, shift, -1))
      if @_;
  
    # Check if host needs to be encoded
    return undef unless defined(my $host = $self->host);
    return $host unless $host =~ /[^\x00-\x7f]/;
  
    # Encode
    return join '.',
      map { /[^\x00-\x7f]/ ? ('xn--' . punycode_encode $_) : $_ }
      split(/\./, $host, -1);
  }
  
  sub is_abs { !!shift->scheme }
  
  sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }
  
  sub parse {
    my ($self, $url) = @_;
  
    # Official regex from RFC 3986
    $url =~ m!^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?!;
    $self->scheme($2)                         if defined $2;
    $self->path($5)                           if defined $5;
    $self->query($7)                          if defined $7;
    $self->fragment(_decode(url_unescape $9)) if defined $9;
    if (defined(my $auth = $4)) {
      $self->userinfo(_decode(url_unescape $1)) if $auth =~ s/^([^\@]+)\@//;
      $self->host_port($auth);
    }
  
    return $self;
  }
  
  sub password { (shift->userinfo // '') =~ /:(.*)$/ ? $1 : undef }
  
  sub path {
    my $self = shift;
  
    # Old path
    $self->{path} ||= Mojo::Path->new;
    return $self->{path} unless @_;
  
    # New path
    $self->{path} = ref $_[0] ? $_[0] : $self->{path}->merge($_[0]);
  
    return $self;
  }
  
  sub path_query {
    my ($self, $pq) = @_;
  
    if (defined $pq) {
      return $self unless $pq =~ /^([^?#]*)(?:\?([^#]*))?/;
      return defined $2 ? $self->path($1)->query($2) : $self->path($1);
    }
  
    my $query = $self->query->to_string;
    return $self->path->to_string . (length $query ? "?$query" : '');
  }
  
  sub protocol { lc(shift->scheme // '') }
  
  sub query {
    my $self = shift;
  
    # Old parameters
    my $q = $self->{query} ||= Mojo::Parameters->new;
    return $q unless @_;
  
    # Replace with list
    if (@_ > 1) { $q->pairs([])->parse(@_) }
  
    # Merge with array
    elsif (ref $_[0] eq 'ARRAY') { $q->merge(@{$_[0]}) }
  
    # Append hash
    elsif (ref $_[0] eq 'HASH') { $q->append(%{$_[0]}) }
  
    # New parameters
    else { $self->{query} = ref $_[0] ? $_[0] : $q->parse($_[0]) }
  
    return $self;
  }
  
  sub to_abs {
    my $self = shift;
  
    my $abs = $self->clone;
    return $abs if $abs->is_abs;
  
    # Scheme
    my $base = shift || $abs->base;
    $abs->base($base)->scheme($base->scheme);
  
    # Authority
    return $abs if $abs->host;
    $abs->userinfo($base->userinfo)->host($base->host)->port($base->port);
  
    # Absolute path
    my $path = $abs->path;
    return $abs if $path->leading_slash;
  
    # Inherit path
    if (!@{$path->parts}) {
      $abs->path($base->path->clone->canonicalize);
  
      # Query
      $abs->query($base->query->clone) unless length $abs->query->to_string;
    }
  
    # Merge paths
    else { $abs->path($base->path->clone->merge($path)->canonicalize) }
  
    return $abs;
  }
  
  sub to_string        { shift->_string(0) }
  sub to_unsafe_string { shift->_string(1) }
  
  sub username { (shift->userinfo // '') =~ /^([^:]+)/ ? $1 : undef }
  
  sub _decode { decode('UTF-8', $_[0]) // $_[0] }
  
  sub _encode { url_escape encode('UTF-8', $_[0]), $_[1] }
  
  sub _string {
    my ($self, $unsafe) = @_;
  
    # Scheme
    my $url = '';
    if (my $proto = $self->protocol) { $url .= "$proto:" }
  
    # Authority
    my $auth = $self->host_port;
    $auth = _encode($auth, '^A-Za-z0-9\-._~!$&\'()*+,;=:\[\]') if defined $auth;
    if ($unsafe && defined(my $info = $self->userinfo)) {
      $auth = _encode($info, '^A-Za-z0-9\-._~!$&\'()*+,;=:') . '@' . $auth;
    }
    $url .= "//$auth" if defined $auth;
  
    # Path and query
    my $path = $self->path_query;
    $url .= !$auth || !length $path || $path =~ m!^[/?]! ? $path : "/$path";
  
    # Fragment
    return $url unless defined(my $fragment = $self->fragment);
    return $url . '#' . _encode($fragment, '^A-Za-z0-9\-._~!$&\'()*+,;=:@/?');
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::URL - Uniform Resource Locator
  
  =head1 SYNOPSIS
  
    use Mojo::URL;
  
    # Parse
    my $url = Mojo::URL->new('http://sri:foo@example.com:3000/foo?foo=bar#23');
    say $url->scheme;
    say $url->userinfo;
    say $url->host;
    say $url->port;
    say $url->path;
    say $url->query;
    say $url->fragment;
  
    # Build
    my $url = Mojo::URL->new;
    $url->scheme('http');
    $url->host('example.com');
    $url->port(3000);
    $url->path('/foo/bar');
    $url->query(foo => 'bar');
    $url->fragment(23);
    say "$url";
  
  =head1 DESCRIPTION
  
  L<Mojo::URL> implements a subset of
  L<RFC 3986|http://tools.ietf.org/html/rfc3986>,
  L<RFC 3987|http://tools.ietf.org/html/rfc3987> and the
  L<URL Living Standard|https://url.spec.whatwg.org> for Uniform Resource
  Locators with support for IDNA and IRIs.
  
  =head1 ATTRIBUTES
  
  L<Mojo::URL> implements the following attributes.
  
  =head2 base
  
    my $base = $url->base;
    $url     = $url->base(Mojo::URL->new);
  
  Base of this URL, defaults to a L<Mojo::URL> object.
  
    "http://example.com/a/b?c"
    Mojo::URL->new("/a/b?c")->base(Mojo::URL->new("http://example.com"))->to_abs;
  
  =head2 fragment
  
    my $fragment = $url->fragment;
    $url         = $url->fragment('mojolicious');
  
  Fragment part of this URL.
  
    # "yada"
    Mojo::URL->new('http://example.com/foo?bar=baz#yada')->fragment;
  
  =head2 host
  
    my $host = $url->host;
    $url     = $url->host('127.0.0.1');
  
  Host part of this URL.
  
    # "example.com"
    Mojo::URL->new('http://sri:t3st@example.com:8080/foo')->host;
  
  =head2 port
  
    my $port = $url->port;
    $url     = $url->port(8080);
  
  Port part of this URL.
  
    # "8080"
    Mojo::URL->new('http://sri:t3st@example.com:8080/foo')->port;
  
  =head2 scheme
  
    my $scheme = $url->scheme;
    $url       = $url->scheme('http');
  
  Scheme part of this URL.
  
    # "http"
    Mojo::URL->new('http://example.com/foo')->scheme;
  
  =head2 userinfo
  
    my $info = $url->userinfo;
    $url     = $url->userinfo('root:');
  
  Userinfo part of this URL.
  
    # "sri:t3st"
    Mojo::URL->new('https://sri:t3st@example.com/foo')->userinfo;
  
  =head1 METHODS
  
  L<Mojo::URL> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 clone
  
    my $url2 = $url->clone;
  
  Return a new L<Mojo::URL> object cloned from this URL.
  
  =head2 host_port
  
    my $host_port = $url->host_port;
    $url          = $url->host_port('example.com:8080');
  
  Normalized version of L</"host"> and L</"port">.
  
    # "xn--n3h.net:8080"
    Mojo::URL->new('http://.net:8080/test')->host_port;
  
    # "example.com"
    Mojo::URL->new('http://example.com/test')->host_port;
  
  =head2 ihost
  
    my $ihost = $url->ihost;
    $url      = $url->ihost('xn--bcher-kva.ch');
  
  Host part of this URL in punycode format.
  
    # "xn--n3h.net"
    Mojo::URL->new('http://.net')->ihost;
  
    # "example.com"
    Mojo::URL->new('http://example.com')->ihost;
  
  =head2 is_abs
  
    my $bool = $url->is_abs;
  
  Check if URL is absolute.
  
    # True
    Mojo::URL->new('http://example.com')->is_abs;
    Mojo::URL->new('http://example.com/test/index.html')->is_abs;
  
    # False
    Mojo::URL->new('test/index.html')->is_abs;
    Mojo::URL->new('/test/index.html')->is_abs;
    Mojo::URL->new('//example.com/test/index.html')->is_abs;
  
  =head2 new
  
    my $url = Mojo::URL->new;
    my $url = Mojo::URL->new('http://127.0.0.1:3000/foo?f=b&baz=2#foo');
  
  Construct a new L<Mojo::URL> object and L</"parse"> URL if necessary.
  
  =head2 parse
  
    $url = $url->parse('http://127.0.0.1:3000/foo/bar?fo=o&baz=23#foo');
  
  Parse relative or absolute URL.
  
    # "/test/123"
    $url->parse('/test/123?foo=bar')->path;
  
    # "example.com"
    $url->parse('http://example.com/test/123?foo=bar')->host;
  
    # "sri@example.com"
    $url->parse('mailto:sri@example.com')->path;
  
  =head2 password
  
    my $password = $url->password;
  
  Password part of L</"userinfo">.
  
    # "s3cret"
    Mojo::URL->new('http://isabel:s3cret@mojolicious.org')->password;
  
    # "s:3:c:r:e:t"
    Mojo::URL->new('http://isabel:s:3:c:r:e:t@mojolicious.org')->password;
  
  =head2 path
  
    my $path = $url->path;
    $url     = $url->path('foo/bar');
    $url     = $url->path('/foo/bar');
    $url     = $url->path(Mojo::Path->new);
  
  Path part of this URL, relative paths will be merged with
  L<Mojo::Path/"merge">, defaults to a L<Mojo::Path> object.
  
    # "perldoc"
    Mojo::URL->new('http://example.com/perldoc/Mojo')->path->parts->[0];
  
    # "/perldoc/DOM/HTML"
    Mojo::URL->new('http://example.com/perldoc/Mojo')->path->merge('DOM/HTML');
  
    # "http://example.com/DOM/HTML"
    Mojo::URL->new('http://example.com/perldoc/Mojo')->path('/DOM/HTML');
  
    # "http://example.com/perldoc/DOM/HTML"
    Mojo::URL->new('http://example.com/perldoc/Mojo')->path('DOM/HTML');
  
    # "http://example.com/perldoc/Mojo/DOM/HTML"
    Mojo::URL->new('http://example.com/perldoc/Mojo/')->path('DOM/HTML');
  
  =head2 path_query
  
    my $path_query = $url->path_query;
    $url           = $url->path_query('/foo/bar?a=1&b=2');
  
  Normalized version of L</"path"> and L</"query">.
  
    # "/test?a=1&b=2"
    Mojo::URL->new('http://example.com/test?a=1&b=2')->path_query;
  
    # "/"
    Mojo::URL->new('http://example.com/')->path_query;
  
  =head2 protocol
  
    my $proto = $url->protocol;
  
  Normalized version of L</"scheme">.
  
    # "http"
    Mojo::URL->new('HtTp://example.com')->protocol;
  
  =head2 query
  
    my $query = $url->query;
    $url      = $url->query([merge => 'with']);
    $url      = $url->query({append => 'to'});
    $url      = $url->query(replace => 'with');
    $url      = $url->query('a=1&b=2');
    $url      = $url->query(Mojo::Parameters->new);
  
  Query part of this URL, key/value pairs in an array reference will be merged
  with L<Mojo::Parameters/"merge">, and key/value pairs in a hash reference
  appended with L<Mojo::Parameters/"append">, defaults to a L<Mojo::Parameters>
  object.
  
    # "2"
    Mojo::URL->new('http://example.com?a=1&b=2')->query->param('b');
  
    # "a=2&b=2&c=3"
    Mojo::URL->new('http://example.com?a=1&b=2')->query->merge(a => 2, c => 3);
  
    # "http://example.com?a=2&c=3"
    Mojo::URL->new('http://example.com?a=1&b=2')->query(a => 2, c => 3);
  
    # "http://example.com?a=2&a=3"
    Mojo::URL->new('http://example.com?a=1&b=2')->query(a => [2, 3]);
  
    # "http://example.com?a=2&b=2&c=3"
    Mojo::URL->new('http://example.com?a=1&b=2')->query([a => 2, c => 3]);
  
    # "http://example.com?b=2"
    Mojo::URL->new('http://example.com?a=1&b=2')->query([a => undef]);
  
    # "http://example.com?a=1&b=2&a=2&c=3"
    Mojo::URL->new('http://example.com?a=1&b=2')->query({a => 2, c => 3});
  
  =head2 to_abs
  
    my $abs = $url->to_abs;
    my $abs = $url->to_abs(Mojo::URL->new('http://example.com/foo'));
  
  Return a new L<Mojo::URL> object cloned from this relative URL and turn it into
  an absolute one using L</"base"> or provided base URL.
  
    # "http://example.com/foo/baz.xml?test=123"
    Mojo::URL->new('baz.xml?test=123')
      ->to_abs(Mojo::URL->new('http://example.com/foo/bar.html'));
  
    # "http://example.com/baz.xml?test=123"
    Mojo::URL->new('/baz.xml?test=123')
      ->to_abs(Mojo::URL->new('http://example.com/foo/bar.html'));
  
    # "http://example.com/foo/baz.xml?test=123"
    Mojo::URL->new('//example.com/foo/baz.xml?test=123')
      ->to_abs(Mojo::URL->new('http://example.com/foo/bar.html'));
  
  =head2 to_string
  
    my $str = $url->to_string;
  
  Turn URL into a string. Note that L</"userinfo"> will not be included for
  security reasons.
  
    # "http://mojolicious.org"
    Mojo::URL->new->scheme('http')->host('mojolicious.org')->to_string;
  
    # "http://mojolicious.org"
    Mojo::URL->new('http://daniel:s3cret@mojolicious.org')->to_string;
  
  =head2 to_unsafe_string
  
    my $str = $url->to_unsafe_string;
  
  Same as L</"to_string">, but includes L</"userinfo">.
  
    # "http://daniel:s3cret@mojolicious.org"
    Mojo::URL->new('http://daniel:s3cret@mojolicious.org')->to_unsafe_string;
  
  =head2 username
  
    my $username = $url->username;
  
  Username part of L</"userinfo">.
  
    # "isabel"
    Mojo::URL->new('http://isabel:s3cret@mojolicious.org')->username;
  
  =head1 OPERATORS
  
  L<Mojo::URL> overloads the following operators.
  
  =head2 bool
  
    my $bool = !!$url;
  
  Always true.
  
  =head2 stringify
  
    my $str = "$url";
  
  Alias for L</"to_string">.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_URL

$fatpacked{"Mojo/Upload.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_UPLOAD';
  package Mojo::Upload;
  use Mojo::Base -base;
  
  has [qw(asset filename headers name)];
  
  sub move_to { $_[0]->asset->move_to($_[1]) and return $_[0] }
  
  sub size  { shift->asset->size }
  sub slurp { shift->asset->slurp }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Upload - Upload
  
  =head1 SYNOPSIS
  
    use Mojo::Upload;
  
    my $upload = Mojo::Upload->new;
    say $upload->filename;
    $upload->move_to('/home/sri/foo.txt');
  
  =head1 DESCRIPTION
  
  L<Mojo::Upload> is a container for uploaded files.
  
  =head1 ATTRIBUTES
  
  L<Mojo::Upload> implements the following attributes.
  
  =head2 asset
  
    my $asset = $upload->asset;
    $upload   = $upload->asset(Mojo::Asset::File->new);
  
  Asset containing the uploaded data, usually a L<Mojo::Asset::File> or
  L<Mojo::Asset::Memory> object.
  
  =head2 filename
  
    my $filename = $upload->filename;
    $upload      = $upload->filename('foo.txt');
  
  Name of the uploaded file.
  
  =head2 headers
  
    my $headers = $upload->headers;
    $upload     = $upload->headers(Mojo::Headers->new);
  
  Headers for upload, usually a L<Mojo::Headers> object.
  
  =head2 name
  
    my $name = $upload->name;
    $upload  = $upload->name('foo');
  
  Name of the upload.
  
  =head1 METHODS
  
  L<Mojo::Upload> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 move_to
  
    $upload = $upload->move_to('/home/sri/foo.txt');
  
  Move uploaded data into a specific file.
  
  =head2 size
  
    my $size = $upload->size;
  
  Size of uploaded data in bytes.
  
  =head2 slurp
  
    my $bytes = $upload->slurp;
  
  Read all uploaded data at once.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_UPLOAD

$fatpacked{"Mojo/UserAgent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT';
  package Mojo::UserAgent;
  use Mojo::Base 'Mojo::EventEmitter';
  
  # "Fry: Since when is the Internet about robbing people of their privacy?
  #  Bender: August 6, 1991."
  use Mojo::IOLoop;
  use Mojo::IOLoop::Stream::HTTPClient;
  use Mojo::IOLoop::Stream::WebSocketClient;
  use Mojo::Promise;
  use Mojo::Util 'monkey_patch';
  use Mojo::UserAgent::CookieJar;
  use Mojo::UserAgent::Proxy;
  use Mojo::UserAgent::Server;
  use Mojo::UserAgent::Transactor;
  use Scalar::Util 'weaken';
  
  use constant DEBUG => $ENV{MOJO_CLIENT_DEBUG} || 0;
  
  has ca                 => sub { $ENV{MOJO_CA_FILE} };
  has cert               => sub { $ENV{MOJO_CERT_FILE} };
  has connect_timeout    => sub { $ENV{MOJO_CONNECT_TIMEOUT} || 10 };
  has cookie_jar         => sub { Mojo::UserAgent::CookieJar->new };
  has inactivity_timeout => sub { $ENV{MOJO_INACTIVITY_TIMEOUT} // 20 };
  has insecure           => sub { $ENV{MOJO_INSECURE} };
  has [qw(local_address max_response_size)];
  has ioloop => sub { Mojo::IOLoop->new };
  has key    => sub { $ENV{MOJO_KEY_FILE} };
  has max_connections => 5;
  has max_redirects   => sub { $ENV{MOJO_MAX_REDIRECTS} || 0 };
  has proxy           => sub { Mojo::UserAgent::Proxy->new };
  has request_timeout => sub { $ENV{MOJO_REQUEST_TIMEOUT} // 0 };
  has server => sub { Mojo::UserAgent::Server->new(ioloop => shift->ioloop) };
  has transactor => sub { Mojo::UserAgent::Transactor->new };
  
  # Common HTTP methods
  for my $name (qw(DELETE GET HEAD OPTIONS PATCH POST PUT)) {
    monkey_patch __PACKAGE__, lc $name, sub {
      my ($self, $cb) = (shift, ref $_[-1] eq 'CODE' ? pop : undef);
      return $self->start($self->build_tx($name, @_), $cb);
    };
    monkey_patch __PACKAGE__, lc($name) . '_p', sub {
      my $self = shift;
      return $self->start_p($self->build_tx($name, @_));
    };
  }
  
  sub DESTROY { Mojo::Util::_global_destruction() or shift->_cleanup }
  
  sub build_tx           { shift->transactor->tx(@_) }
  sub build_websocket_tx { shift->transactor->websocket(@_) }
  
  sub start {
    my ($self, $tx, $cb) = @_;
  
    # Fork-safety
    $self->_cleanup->server->restart unless ($self->{pid} //= $$) eq $$;
  
    # Non-blocking
    if ($cb) {
      warn "-- Non-blocking request (@{[_url($tx)]})\n" if DEBUG;
      return $self->_start(Mojo::IOLoop->singleton, $tx, $cb);
    }
  
    # Blocking
    warn "-- Blocking request (@{[_url($tx)]})\n" if DEBUG;
    $self->_start($self->ioloop, $tx => sub { shift->ioloop->stop; $tx = shift });
    $self->ioloop->start;
  
    return $tx;
  }
  
  sub start_p {
    my ($self, $tx) = @_;
    my $promise = Mojo::Promise->new;
    $self->start($tx => sub { shift->transactor->promisify($promise, shift) });
    return $promise;
  }
  
  sub websocket {
    my ($self, $cb) = (shift, pop);
    $self->start($self->build_websocket_tx(@_), $cb);
  }
  
  sub websocket_p {
    my $self = shift;
    return $self->start_p($self->build_websocket_tx(@_));
  }
  
  sub _cleanup {
    my $self = shift;
    delete $self->{pid};
    $self->_error($_, 'Premature connection close')
      for keys %{$self->{connections} || {}};
    return $self;
  }
  
  sub _connect {
    my ($self, $loop, $tx, $handle) = @_;
  
    my $t = $self->transactor;
    my ($proto, $host, $port) = $handle ? $t->endpoint($tx) : $t->peer($tx);
  
    my %options = (
      timeout      => $self->connect_timeout,
      stream_class => 'Mojo::IOLoop::Stream::HTTPClient'
    );
    if ($proto eq 'http+unix') { $options{path} = $host }
    else                       { @options{qw(address port)} = ($host, $port) }
    if (my $local = $self->local_address) { $options{local_address} = $local }
    $options{handle} = $handle if $handle;
  
    # SOCKS
    if ($proto eq 'socks') {
      @options{qw(socks_address socks_port)} = @options{qw(address port)};
      ($proto, @options{qw(address port)}) = $t->endpoint($tx);
      my $userinfo = $tx->req->via_proxy(0)->proxy->userinfo;
      @options{qw(socks_user socks_pass)} = split ':', $userinfo if $userinfo;
    }
  
    # TLS
    if ($options{tls} = $proto eq 'https') {
      map { $options{"tls_$_"} = $self->$_ } qw(ca cert key);
      $options{tls_verify} = 0x00 if $self->insecure;
    }
  
    weaken $self;
    my $id;
    return $id = $loop->client(
      %options => sub {
        my ($loop, $err, $stream) = @_;
  
        # Connection error
        return unless $self;
        return $self->_error($id, $err) if $err;
  
        # Connection established
        $stream->on(timeout => sub { $self->_error($id, 'Inactivity timeout') });
        $stream->on(close => sub { $self && $self->_finish($id, 1) });
        $stream->on(error => sub { $self && $self->_error($id, pop) });
        $stream->on(upgrade => sub { $self->_upgrade($id, pop) });
        $self->_process($id);
      }
    );
  }
  
  sub _connect_proxy {
    my ($self, $loop, $old, $cb) = @_;
  
    # Start CONNECT request
    return undef unless my $new = $self->transactor->proxy_connect($old);
    my $id;
    return $id = $self->_start(
      ($loop, $new) => sub {
        my ($self, $tx) = @_;
  
        # Real transaction
        $old->previous($tx)->req->via_proxy(0);
        my $c = $self->{connections}{$id}
          = {cb => $cb, ioloop => $loop, tx => $old};
  
        # CONNECT failed
        return $self->_error($id, 'Proxy connection failed')
          if $tx->error || !$tx->res->is_success || !$tx->keep_alive;
  
        # Start real transaction without TLS upgrade
        return $self->_process($id) unless $tx->req->url->protocol eq 'https';
  
        # TLS upgrade before starting the real transaction
        my $handle = $loop->stream($id)->steal_handle;
        $self->_remove($id);
        $id = $self->_connect($loop, $old, $handle);
        $self->{connections}{$id} = $c;
      }
    );
  }
  
  sub _connection {
    my ($self, $loop, $tx, $cb) = @_;
  
    # Reuse connection
    my ($proto, $host, $port) = $self->transactor->endpoint($tx);
    my $id;
    if ($id = $self->_dequeue($loop, "$proto:$host:$port", 1)) {
      warn "-- Reusing connection $id ($proto://$host:$port)\n" if DEBUG;
      @{$self->{connections}{$id}}{qw(cb tx)} = ($cb, $tx);
      $tx->kept_alive(1) unless $tx->connection;
      $self->_process($id);
      return $id;
    }
  
    # CONNECT request to proxy required
    if (my $id = $self->_connect_proxy($loop, $tx, $cb)) { return $id }
  
    # New connection
    $tx->res->error({message => "Unsupported protocol: $proto"})
      and return $loop->next_tick(sub { $self->$cb($tx) })
      unless $proto eq 'http' || $proto eq 'https' || $proto eq 'http+unix';
    $id = $self->_connect($loop, $tx);
    warn "-- Connect $id ($proto://$host:$port)\n" if DEBUG;
    $self->{connections}{$id} = {cb => $cb, ioloop => $loop, tx => $tx};
  
    return $id;
  }
  
  sub _dequeue {
    my ($self, $loop, $name, $test) = @_;
  
    my $old = $self->{queue}{$loop} ||= [];
    my ($found, @new);
    for my $queued (@$old) {
      push @new, $queued and next if $found || !grep { $_ eq $name } @$queued;
  
      # Search for id/name and sort out corrupted connections if necessary
      next unless my $stream = $loop->stream($queued->[1]);
      $test && $stream->is_readable ? $stream->close : ($found = $queued->[1]);
    }
    @$old = @new;
  
    return $found;
  }
  
  sub _error {
    my ($self, $id, $err) = @_;
    my $tx = $self->{connections}{$id}{tx};
    $tx->closed->res->finish->error({message => $err}) if $tx;
    $self->_finish($id, 1);
  }
  
  sub _finish {
    my ($self, $id, $close) = @_;
  
    return unless my $c = $self->{connections}{$id};
    return $self->_reuse($id, $close) unless my $tx = $c->{tx};
  
    $self->cookie_jar->collect($tx);
    $self->_reuse($id, $close) unless uc $tx->req->method eq 'CONNECT';
    $c->{cb}($self, $tx) unless $self->_redirect($c, $tx);
  }
  
  sub _process {
    my ($self, $id) = @_;
  
    my $c      = $self->{connections}{$id};
    my $stream = $c->{ioloop}->stream($id)->timeout($self->inactivity_timeout)
      ->request_timeout($self->request_timeout);
    my $tx = $c->{tx}->connection($id);
  
    weaken $self;
    $tx->on(finish => sub { $self->_finish($id) });
    $stream->process($tx);
  }
  
  sub _redirect {
    my ($self, $c, $old) = @_;
    return undef unless my $new = $self->transactor->redirect($old);
    return undef unless @{$old->redirects} < $self->max_redirects;
    return $self->_start($c->{ioloop}, $new, delete $c->{cb});
  }
  
  sub _remove {
    my ($self, $id) = @_;
    my $c = delete $self->{connections}{$id};
    $self->_dequeue($c->{ioloop}, $id);
    $c->{ioloop}->remove($id);
  }
  
  sub _reuse {
    my ($self, $id, $close) = @_;
  
    # Connection close
    my $c   = $self->{connections}{$id};
    my $tx  = delete $c->{tx};
    my $max = $self->max_connections;
    return $self->_remove($id) if $close || !$tx || !$max;
  
    # Keep connection alive
    my $queue = $self->{queue}{$c->{ioloop}} ||= [];
    $self->_remove(shift(@$queue)->[1]) while @$queue && @$queue >= $max;
    push @$queue, [join(':', $self->transactor->endpoint($tx)), $id];
  }
  
  sub _start {
    my ($self, $loop, $tx, $cb) = @_;
  
    # Application server
    my $url = $tx->req->url;
    if (!$url->is_abs && (my $server = $self->server)) {
      my $base = $loop == $self->ioloop ? $server->url : $server->nb_url;
      $url->scheme($base->scheme)->host($base->host)->port($base->port);
    }
  
    $_->prepare($tx) for $self->proxy, $self->cookie_jar;
    my $max = $self->max_response_size;
    $tx->res->max_message_size($max) if defined $max;
    $self->emit(start => $tx);
    return $self->_connection($loop, $tx, $cb);
  }
  
  sub _upgrade {
    my ($self, $id, $ws) = @_;
  
    my $c       = $self->{connections}{$id};
    my $loop    = $c->{ioloop};
    my $timeout = $loop->stream($id)->timeout;
    my $stream  = $loop->transition($id, 'Mojo::IOLoop::Stream::WebSocketClient');
    $stream->timeout($timeout);
  
    weaken $self;
    $stream->on(timeout => sub { $self->_error($id, 'Inactivity timeout') });
    $stream->on(close => sub { $self && $self->_remove($id) });
  
    $self->cookie_jar->collect($ws);
    $c->{cb}($self, $c->{tx} = $ws);
    $stream->process($ws);
  }
  
  sub _url { shift->req->url->to_abs }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::UserAgent - Non-blocking I/O HTTP and WebSocket user agent
  
  =head1 SYNOPSIS
  
    use Mojo::UserAgent;
  
    # Fine grained response handling (dies on connection errors)
    my $ua  = Mojo::UserAgent->new;
    my $res = $ua->get('mojolicious.org/perldoc')->result;
    if    ($res->is_success)  { say $res->body }
    elsif ($res->is_error)    { say $res->message }
    elsif ($res->code == 301) { say $res->headers->location }
    else                      { say 'Whatever...' }
  
    # Say hello to the Unicode snowman and include an Accept header
    say $ua->get('www..net?hello=there' => {Accept => '*/*'})->result->body;
  
    # Extract data from HTML and XML resources with CSS selectors
    say $ua->get('www.perl.org')->result->dom->at('title')->text;
  
    # Scrape the latest headlines from a news site
    say $ua->get('blogs.perl.org')
      ->result->dom->find('h2 > a')->map('text')->join("\n");
  
    # IPv6 PUT request with Content-Type header and content
    my $tx = $ua->put('[::1]:3000' => {'Content-Type' => 'text/plain'} => 'Hi!');
  
    # Quick JSON API request with Basic authentication
    my $value = $ua->get('https://sri:t3st@example.com/test.json')->result->json;
  
    # JSON POST (application/json) with TLS certificate authentication
    my $tx = $ua->cert('tls.crt')->key('tls.key')
      ->post('https://example.com' => json => {top => 'secret'});
  
    # Search DuckDuckGo anonymously through Tor
    $ua->proxy->http('socks://127.0.0.1:9050');
    say $ua->get('api.3g2upl4pq6kufc4m.onion/?q=mojolicious&format=json')
      ->result->json('/Abstract');
  
    # GET request via UNIX domain socket "/tmp/myapp.sock" (percent encoded slash)
    say $ua->get('http+unix://%2Ftmp%2Fmyapp.sock/perldoc')->result->body;
  
    # Follow redirects to download Mojolicious from GitHub
    $ua->max_redirects(5)
      ->get('https://www.github.com/kraih/mojo/tarball/master')
      ->result->content->asset->move_to('/home/sri/mojo.tar.gz');
  
    # Form POST (application/x-www-form-urlencoded) with manual exception handling
    my $tx = $ua->post('https://metacpan.org/search' => form => {q => 'mojo'});
    if (my $res = $tx->success) { say $res->body }
    else {
      my $err = $tx->error;
      die "$err->{code} response: $err->{message}" if $err->{code};
      die "Connection error: $err->{message}";
    }
  
    # Non-blocking request
    $ua->get('mojolicious.org' => sub {
      my ($ua, $tx) = @_;
      say $tx->result->dom->at('title')->text;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
    # Concurrent non-blocking requests (synchronized with promises)
    my $mojo = $ua->get_p('mojolicious.org');
    my $cpan = $ua->get_p('cpan.org');
    Mojo::Promise->all($mojo, $cpan)->then(sub {
      my ($mojo, $cpan) = @_;
      say $mojo->[0]->result->dom->at('title')->text;
      say $cpan->[0]->result->dom->at('title')->text;
    })->wait;
  
    # WebSocket connection sending and receiving JSON via UNIX domain socket
    $ua->websocket('ws+unix://%2Ftmp%2Fmyapp.sock/echo.json' => sub {
      my ($ua, $tx) = @_;
      say 'WebSocket handshake failed!' and return unless $tx->is_websocket;
      $tx->on(json => sub {
        my ($tx, $hash) = @_;
        say "WebSocket message via JSON: $hash->{msg}";
        $tx->finish;
      });
      $tx->send({json => {msg => 'Hello World!'}});
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head1 DESCRIPTION
  
  L<Mojo::UserAgent> is a full featured non-blocking I/O HTTP and WebSocket user
  agent, with IPv6, TLS, SNI, IDNA, HTTP/SOCKS5 proxy, UNIX domain socket, Comet
  (long polling), Promises/A+, keep-alive, connection pooling, timeout, cookie,
  multipart, gzip compression and multiple event loop support.
  
  All connections will be reset automatically if a new process has been forked,
  this allows multiple processes to share the same L<Mojo::UserAgent> object
  safely.
  
  For better scalability (epoll, kqueue) and to provide non-blocking name
  resolution, SOCKS5 as well as TLS support, the optional modules L<EV> (4.0+),
  L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and
  L<IO::Socket::SSL> (2.009+) will be used automatically if possible. Individual
  features can also be disabled with the C<MOJO_NO_NNR>, C<MOJO_NO_SOCKS> and
  C<MOJO_NO_TLS> environment variables.
  
  See L<Mojolicious::Guides::Cookbook/"USER AGENT"> for more.
  
  =head1 EVENTS
  
  L<Mojo::UserAgent> inherits all events from L<Mojo::EventEmitter> and can emit
  the following new ones.
  
  =head2 start
  
    $ua->on(start => sub {
      my ($ua, $tx) = @_;
      ...
    });
  
  Emitted whenever a new transaction is about to start, this includes
  automatically prepared proxy C<CONNECT> requests and followed redirects.
  
    $ua->on(start => sub {
      my ($ua, $tx) = @_;
      $tx->req->headers->header('X-Bender' => 'Bite my shiny metal ass!');
    });
  
  =head1 ATTRIBUTES
  
  L<Mojo::UserAgent> implements the following attributes.
  
  =head2 ca
  
    my $ca = $ua->ca;
    $ua    = $ua->ca('/etc/tls/ca.crt');
  
  Path to TLS certificate authority file used to verify the peer certificate,
  defaults to the value of the C<MOJO_CA_FILE> environment variable.
  
    # Show certificate authorities for debugging
    IO::Socket::SSL::set_defaults(
      SSL_verify_callback => sub { say "Authority: $_[2]" and return $_[0] });
  
  =head2 cert
  
    my $cert = $ua->cert;
    $ua      = $ua->cert('/etc/tls/client.crt');
  
  Path to TLS certificate file, defaults to the value of the C<MOJO_CERT_FILE>
  environment variable.
  
  =head2 connect_timeout
  
    my $timeout = $ua->connect_timeout;
    $ua         = $ua->connect_timeout(5);
  
  Maximum amount of time in seconds establishing a connection may take before
  getting canceled, defaults to the value of the C<MOJO_CONNECT_TIMEOUT>
  environment variable or C<10>.
  
  =head2 cookie_jar
  
    my $cookie_jar = $ua->cookie_jar;
    $ua            = $ua->cookie_jar(Mojo::UserAgent::CookieJar->new);
  
  Cookie jar to use for requests performed by this user agent, defaults to a
  L<Mojo::UserAgent::CookieJar> object.
  
    # Ignore all cookies
    $ua->cookie_jar->ignore(sub { 1 });
  
    # Ignore cookies for public suffixes
    my $ps = IO::Socket::SSL::PublicSuffix->default;
    $ua->cookie_jar->ignore(sub {
      my $cookie = shift;
      return undef unless my $domain = $cookie->domain;
      return ($ps->public_suffix($domain))[0] eq '';
    });
  
    # Add custom cookie to the jar
    $ua->cookie_jar->add(
      Mojo::Cookie::Response->new(
        name   => 'foo',
        value  => 'bar',
        domain => 'mojolicious.org',
        path   => '/perldoc'
      )
    );
  
  =head2 inactivity_timeout
  
    my $timeout = $ua->inactivity_timeout;
    $ua         = $ua->inactivity_timeout(15);
  
  Maximum amount of time in seconds a connection can be inactive before getting
  closed, defaults to the value of the C<MOJO_INACTIVITY_TIMEOUT> environment
  variable or C<20>. Setting the value to C<0> will allow connections to be
  inactive indefinitely.
  
  =head2 insecure
  
    my $bool = $ua->insecure;
    $ua      = $ua->insecure($bool);
  
  Do not require a valid TLS certificate to access HTTPS/WSS sites, defaults to
  the value of the C<MOJO_INSECURE> environment variable.
  
    # Disable TLS certificate verification for testing
    say $ua->insecure(1)->get('https://127.0.0.1:3000')->result->code;
  
  =head2 ioloop
  
    my $loop = $ua->ioloop;
    $ua      = $ua->ioloop(Mojo::IOLoop->new);
  
  Event loop object to use for blocking I/O operations, defaults to a
  L<Mojo::IOLoop> object.
  
  =head2 key
  
    my $key = $ua->key;
    $ua     = $ua->key('/etc/tls/client.crt');
  
  Path to TLS key file, defaults to the value of the C<MOJO_KEY_FILE> environment
  variable.
  
  =head2 local_address
  
    my $address = $ua->local_address;
    $ua         = $ua->local_address('127.0.0.1');
  
  Local address to bind to.
  
  =head2 max_connections
  
    my $max = $ua->max_connections;
    $ua     = $ua->max_connections(5);
  
  Maximum number of keep-alive connections that the user agent will retain before
  it starts closing the oldest ones, defaults to C<5>. Setting the value to C<0>
  will prevent any connections from being kept alive.
  
  =head2 max_redirects
  
    my $max = $ua->max_redirects;
    $ua     = $ua->max_redirects(3);
  
  Maximum number of redirects the user agent will follow before it fails,
  defaults to the value of the C<MOJO_MAX_REDIRECTS> environment variable or
  C<0>.
  
  =head2 max_response_size
  
    my $max = $ua->max_response_size;
    $ua     = $ua->max_response_size(16777216);
  
  Maximum response size in bytes, defaults to the value of
  L<Mojo::Message::Response/"max_message_size">. Setting the value to C<0> will
  allow responses of indefinite size. Note that increasing this value can also
  drastically increase memory usage, should you for example attempt to parse an
  excessively large response body with the methods L<Mojo::Message/"dom"> or
  L<Mojo::Message/"json">.
  
  =head2 proxy
  
    my $proxy = $ua->proxy;
    $ua       = $ua->proxy(Mojo::UserAgent::Proxy->new);
  
  Proxy manager, defaults to a L<Mojo::UserAgent::Proxy> object.
  
    # Detect proxy servers from environment
    $ua->proxy->detect;
  
    # Manually configure HTTP proxy (using CONNECT for HTTPS/WebSockets)
    $ua->proxy->http('http://127.0.0.1:8080')->https('http://127.0.0.1:8080');
  
    # Manually configure Tor (SOCKS5)
    $ua->proxy->http('socks://127.0.0.1:9050')->https('socks://127.0.0.1:9050');
  
    # Manually configure UNIX domain socket (using CONNECT for HTTPS/WebSockets)
    $ua->proxy->http('http+unix://%2Ftmp%2Fproxy.sock')
      ->https('http+unix://%2Ftmp%2Fproxy.sock');
  
  =head2 request_timeout
  
    my $timeout = $ua->request_timeout;
    $ua         = $ua->request_timeout(5);
  
  Maximum amount of time in seconds sending the request and receiving a whole
  response may take before getting canceled, defaults to the value of the
  C<MOJO_REQUEST_TIMEOUT> environment variable or C<0>. This does not include
  L</"connect_timeout">. Setting the value to C<0> will allow the user agent to
  wait indefinitely. The timeout will reset for every followed redirect.
  
    # Allow 3 seconds to establish connection and 5 seconds to process request
    $ua->max_redirects(0)->connect_timeout(3)->request_timeout(5);
  
  =head2 server
  
    my $server = $ua->server;
    $ua        = $ua->server(Mojo::UserAgent::Server->new);
  
  Application server relative URLs will be processed with, defaults to a
  L<Mojo::UserAgent::Server> object.
  
    # Mock web service
    $ua->server->app(Mojolicious->new);
    $ua->server->app->routes->get('/time' => sub {
      my $c = shift;
      $c->render(json => {now => time});
    });
    my $time = $ua->get('/time')->result->json->{now};
  
    # Change log level
    $ua->server->app->log->level('fatal');
  
    # Port currently used for processing relative URLs blocking
    say $ua->server->url->port;
  
    # Port currently used for processing relative URLs non-blocking
    say $ua->server->nb_url->port;
  
  =head2 transactor
  
    my $t = $ua->transactor;
    $ua   = $ua->transactor(Mojo::UserAgent::Transactor->new);
  
  Transaction builder, defaults to a L<Mojo::UserAgent::Transactor> object.
  
    # Change name of user agent
    $ua->transactor->name('MyUA 1.0');
  
  =head1 METHODS
  
  L<Mojo::UserAgent> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 build_tx
  
    my $tx = $ua->build_tx(GET => 'example.com');
    my $tx = $ua->build_tx(
      PUT => 'http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->build_tx(
      PUT => 'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->build_tx(
      PUT => 'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Generate L<Mojo::Transaction::HTTP> object with
  L<Mojo::UserAgent::Transactor/"tx">.
  
    # Request with custom cookie
    my $tx = $ua->build_tx(GET => 'https://example.com/account');
    $tx->req->cookies({name => 'user', value => 'sri'});
    $tx = $ua->start($tx);
  
    # Deactivate gzip compression
    my $tx = $ua->build_tx(GET => 'example.com');
    $tx->req->headers->remove('Accept-Encoding');
    $tx = $ua->start($tx);
  
    # Interrupt response by raising an error
    my $tx = $ua->build_tx(GET => 'http://example.com');
    $tx->res->on(progress => sub {
      my $res = shift;
      return unless my $server = $res->headers->server;
      $res->error({message => 'Oh noes, it is IIS!'}) if $server =~ /IIS/;
    });
    $tx = $ua->start($tx);
  
  =head2 build_websocket_tx
  
    my $tx = $ua->build_websocket_tx('ws://example.com');
    my $tx = $ua->build_websocket_tx(
      'ws://example.com' => {DNT => 1} => ['v1.proto']);
  
  Generate L<Mojo::Transaction::HTTP> object with
  L<Mojo::UserAgent::Transactor/"websocket">.
  
    # Custom WebSocket handshake with cookie
    my $tx = $ua->build_websocket_tx('wss://example.com/echo');
    $tx->req->cookies({name => 'user', value => 'sri'});
    $ua->start($tx => sub {
      my ($ua, $tx) = @_;
      say 'WebSocket handshake failed!' and return unless $tx->is_websocket;
      $tx->on(message => sub {
        my ($tx, $msg) = @_;
        say "WebSocket message: $msg";
        $tx->finish;
      });
      $tx->send('Hi!');
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 delete
  
    my $tx = $ua->delete('example.com');
    my $tx = $ua->delete('http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->delete(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->delete(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<DELETE> request and return resulting
  L<Mojo::Transaction::HTTP> object, takes the same arguments as
  L<Mojo::UserAgent::Transactor/"tx"> (except for the C<DELETE> method, which is
  implied). You can also append a callback to perform requests non-blocking.
  
    $ua->delete('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 delete_p
  
    my $promise = $ua->delete_p('http://example.com');
  
  Same as L</"delete">, but performs all requests non-blocking and returns a
  L<Mojo::Promise> object instead of accepting a callback.
  
    $ua->delete_p('http://example.com' => json => {a => 'b'})->then(sub {
      my $tx = shift;
      say $tx->result->body;
    })->catch(sub {
      my $err = shift;
      warn "Connection error: $err";
    })->wait;
  
  =head2 get
  
    my $tx = $ua->get('example.com');
    my $tx = $ua->get('http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->get(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->get(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<GET> request and return resulting L<Mojo::Transaction::HTTP>
  object, takes the same arguments as L<Mojo::UserAgent::Transactor/"tx"> (except
  for the C<GET> method, which is implied). You can also append a callback to
  perform requests non-blocking.
  
    $ua->get('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 get_p
  
    my $promise = $ua->get_p('http://example.com');
  
  Same as L</"get">, but performs all requests non-blocking and returns a
  L<Mojo::Promise> object instead of accepting a callback.
  
    $ua->get_p('http://example.com' => json => {a => 'b'})->then(sub {
      my $tx = shift;
      say $tx->result->body;
    })->catch(sub {
      my $err = shift;
      warn "Connection error: $err";
    })->wait;
  
  =head2 head
  
    my $tx = $ua->head('example.com');
    my $tx = $ua->head('http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->head(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->head(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<HEAD> request and return resulting
  L<Mojo::Transaction::HTTP> object, takes the same arguments as
  L<Mojo::UserAgent::Transactor/"tx"> (except for the C<HEAD> method, which is
  implied). You can also append a callback to perform requests non-blocking.
  
    $ua->head('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 head_p
  
    my $promise = $ua->head_p('http://example.com');
  
  Same as L</"head">, but performs all requests non-blocking and returns a
  L<Mojo::Promise> object instead of accepting a callback.
  
    $ua->head_p('http://example.com' => json => {a => 'b'})->then(sub {
      my $tx = shift;
      say $tx->result->body;
    })->catch(sub {
      my $err = shift;
      warn "Connection error: $err";
    })->wait;
  
  =head2 options
  
    my $tx = $ua->options('example.com');
    my $tx = $ua->options('http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->options(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->options(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<OPTIONS> request and return resulting
  L<Mojo::Transaction::HTTP> object, takes the same arguments as
  L<Mojo::UserAgent::Transactor/"tx"> (except for the C<OPTIONS> method, which is
  implied). You can also append a callback to perform requests non-blocking.
  
    $ua->options('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 options_p
  
    my $promise = $ua->options_p('http://example.com');
  
  Same as L</"options">, but performs all requests non-blocking and returns a
  L<Mojo::Promise> object instead of accepting a callback.
  
    $ua->options_p('http://example.com' => json => {a => 'b'})->then(sub {
      my $tx = shift;
      say $tx->result->body;
    })->catch(sub {
      my $err = shift;
      warn "Connection error: $err";
    })->wait;
  
  =head2 patch
  
    my $tx = $ua->patch('example.com');
    my $tx = $ua->patch('http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->patch(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->patch(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<PATCH> request and return resulting
  L<Mojo::Transaction::HTTP> object, takes the same arguments as
  L<Mojo::UserAgent::Transactor/"tx"> (except for the C<PATCH> method, which is
  implied). You can also append a callback to perform requests non-blocking.
  
    $ua->patch('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 patch_p
  
    my $promise = $ua->patch_p('http://example.com');
  
  Same as L</"patch">, but performs all requests non-blocking and returns a
  L<Mojo::Promise> object instead of accepting a callback.
  
    $ua->patch_p('http://example.com' => json => {a => 'b'})->then(sub {
      my $tx = shift;
      say $tx->result->body;
    })->catch(sub {
      my $err = shift;
      warn "Connection error: $err";
    })->wait;
  
  =head2 post
  
    my $tx = $ua->post('example.com');
    my $tx = $ua->post('http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->post(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->post(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<POST> request and return resulting
  L<Mojo::Transaction::HTTP> object, takes the same arguments as
  L<Mojo::UserAgent::Transactor/"tx"> (except for the C<POST> method, which is
  implied). You can also append a callback to perform requests non-blocking.
  
    $ua->post('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 post_p
  
    my $promise = $ua->post_p('http://example.com');
  
  Same as L</"post">, but performs all requests non-blocking and returns a
  L<Mojo::Promise> object instead of accepting a callback.
  
    $ua->post_p('http://example.com' => json => {a => 'b'})->then(sub {
      my $tx = shift;
      say $tx->result->body;
    })->catch(sub {
      my $err = shift;
      warn "Connection error: $err";
    })->wait;
  
  =head2 put
  
    my $tx = $ua->put('example.com');
    my $tx = $ua->put('http://example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $ua->put(
      'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $ua->put(
      'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform blocking C<PUT> request and return resulting L<Mojo::Transaction::HTTP>
  object, takes the same arguments as L<Mojo::UserAgent::Transactor/"tx"> (except
  for the C<PUT> method, which is implied). You can also append a callback to
  perform requests non-blocking.
  
    $ua->put('http://example.com' => json => {a => 'b'} => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 put_p
  
    my $promise = $ua->put_p('http://example.com');
  
  Same as L</"put">, but performs all requests non-blocking and returns a
  L<Mojo::Promise> object instead of accepting a callback.
  
    $ua->put_p('http://example.com' => json => {a => 'b'})->then(sub {
      my $tx = shift;
      say $tx->result->body;
    })->catch(sub {
      my $err = shift;
      warn "Connection error: $err";
    })->wait;
  
  =head2 start
  
    my $tx = $ua->start(Mojo::Transaction::HTTP->new);
  
  Perform blocking request for a custom L<Mojo::Transaction::HTTP> object, which
  can be prepared manually or with L</"build_tx">. You can also append a callback
  to perform requests non-blocking.
  
    my $tx = $ua->build_tx(GET => 'http://example.com');
    $ua->start($tx => sub {
      my ($ua, $tx) = @_;
      say $tx->result->body;
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  =head2 start_p
  
    my $promise = $ua->start_p(Mojo::Transaction::HTTP->new);
  
  Same as L</"start">, but performs all requests non-blocking and returns a
  L<Mojo::Promise> object instead of accepting a callback.
  
    my $tx = $ua->build_tx(GET => 'http://example.com');
    $ua->start_p($tx)->then(sub {
      my $tx = shift;
      say $tx->result->body;
    })->catch(sub {
      my $err = shift;
      warn "Connection error: $err";
    })->wait;
  
  =head2 websocket
  
    $ua->websocket('ws://example.com' => sub {...});
    $ua->websocket(
      'ws://example.com' => {DNT => 1} => ['v1.proto'] => sub {...});
  
  Open a non-blocking WebSocket connection with transparent handshake, takes the
  same arguments as L<Mojo::UserAgent::Transactor/"websocket">. The callback will
  receive either a L<Mojo::Transaction::WebSocket> or L<Mojo::Transaction::HTTP>
  object, depending on if the handshake was successful.
  
    $ua->websocket('wss://example.com/echo' => ['v1.proto'] => sub {
      my ($ua, $tx) = @_;
      say 'WebSocket handshake failed!' and return unless $tx->is_websocket;
      say 'Subprotocol negotiation failed!' and return unless $tx->protocol;
      $tx->on(finish => sub {
        my ($tx, $code, $reason) = @_;
        say "WebSocket closed with status $code.";
      });
      $tx->on(message => sub {
        my ($tx, $msg) = @_;
        say "WebSocket message: $msg";
        $tx->finish;
      });
      $tx->send('Hi!');
    });
    Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
  
  You can activate C<permessage-deflate> compression by setting the
  C<Sec-WebSocket-Extensions> header, this can result in much better performance,
  but also increases memory usage by up to 300KiB per connection.
  
    $ua->websocket('ws://example.com/foo' => {
      'Sec-WebSocket-Extensions' => 'permessage-deflate'
    } => sub {...});
  
  =head2 websocket_p
  
    my $promise = $ua->websocket_p('ws://example.com');
  
  Same as L</"websocket">, but returns a L<Mojo::Promise> object instead of
  accepting a callback.
  
    $ua->websocket_p('wss://example.com/echo')->then(sub {
      my $tx = shift;
      my $promise = Mojo::Promise->new;
      $tx->on(finish => sub { $promise->resolve });
      $tx->on(message => sub {
        my ($tx, $msg) = @_;
        say "WebSocket message: $msg";
        $tx->finish;
      });
      $tx->send('Hi!');
      return $promise;
    })->catch(sub {
      my $err = shift;
      warn "WebSocket error: $err";
    })->wait;
  
  =head1 DEBUGGING
  
  You can set the C<MOJO_CLIENT_DEBUG> environment variable to get some advanced
  diagnostics information printed to C<STDERR>.
  
    MOJO_CLIENT_DEBUG=1
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_USERAGENT

$fatpacked{"Mojo/UserAgent/CookieJar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT_COOKIEJAR';
  package Mojo::UserAgent::CookieJar;
  use Mojo::Base -base;
  
  use Mojo::Cookie::Request;
  use Mojo::Path;
  use Scalar::Util 'looks_like_number';
  
  has 'ignore';
  has max_cookie_size => 4096;
  
  sub add {
    my ($self, @cookies) = @_;
  
    my $size = $self->max_cookie_size;
    for my $cookie (@cookies) {
  
      # Convert max age to expires
      my $age = $cookie->max_age;
      $cookie->expires($age <= 0 ? 0 : $age + time) if looks_like_number $age;
  
      # Check cookie size
      next if length($cookie->value // '') > $size;
  
      # Replace cookie
      next unless my $domain = lc($cookie->domain // '');
      next unless my $path   = $cookie->path;
      next unless length(my $name = $cookie->name // '');
      my $jar = $self->{jar}{$domain} ||= [];
      @$jar = (grep({ _compare($_, $path, $name, $domain) } @$jar), $cookie);
    }
  
    return $self;
  }
  
  sub all {
    my $jar = shift->{jar};
    return [map { @{$jar->{$_}} } sort keys %$jar];
  }
  
  sub collect {
    my ($self, $tx) = @_;
  
    my $url = $tx->req->url;
    for my $cookie (@{$tx->res->cookies}) {
  
      # Validate domain
      my $host = lc $url->ihost;
      $cookie->domain($host)->host_only(1) unless $cookie->domain;
      my $domain = lc $cookie->domain;
      if (my $cb = $self->ignore) { next if $cb->($cookie) }
      next if $host ne $domain && ($host !~ /\Q.$domain\E$/ || $host =~ /\.\d+$/);
  
      # Validate path
      my $path = $cookie->path // $url->path->to_dir->to_abs_string;
      $path = Mojo::Path->new($path)->trailing_slash(0)->to_abs_string;
      next unless _path($path, $url->path->to_abs_string);
      $self->add($cookie->path($path));
    }
  }
  
  sub empty { delete shift->{jar} }
  
  sub find {
    my ($self, $url) = @_;
  
    my @found;
    my $domain = my $host = lc $url->ihost;
    my $path = $url->path->to_abs_string;
    while ($domain) {
      next unless my $old = $self->{jar}{$domain};
  
      # Grab cookies
      my $new = $self->{jar}{$domain} = [];
      for my $cookie (@$old) {
        next if $cookie->host_only && $host ne $cookie->domain;
  
        # Check if cookie has expired
        if (defined(my $expires = $cookie->expires)) { next if time > $expires }
        push @$new, $cookie;
  
        # Taste cookie
        next if $cookie->secure && $url->protocol ne 'https';
        next unless _path($cookie->path, $path);
        my $name  = $cookie->name;
        my $value = $cookie->value;
        push @found, Mojo::Cookie::Request->new(name => $name, value => $value);
      }
    }
  
    # Remove another part
    continue { $domain =~ s/^[^.]*\.*// }
  
    return \@found;
  }
  
  sub prepare {
    my ($self, $tx) = @_;
    return unless keys %{$self->{jar}};
    my $req = $tx->req;
    $req->cookies(@{$self->find($req->url)});
  }
  
  sub _compare {
    my ($cookie, $path, $name, $domain) = @_;
    return
         $cookie->path ne $path
      || $cookie->name ne $name
      || $cookie->domain ne $domain;
  }
  
  sub _path { $_[0] eq '/' || $_[0] eq $_[1] || index($_[1], "$_[0]/") == 0 }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::UserAgent::CookieJar - Cookie jar for HTTP user agents
  
  =head1 SYNOPSIS
  
    use Mojo::UserAgent::CookieJar;
  
    # Add response cookies
    my $jar = Mojo::UserAgent::CookieJar->new;
    $jar->add(
      Mojo::Cookie::Response->new(
        name   => 'foo',
        value  => 'bar',
        domain => 'localhost',
        path   => '/test'
      )
    );
  
    # Find request cookies
    for my $cookie (@{$jar->find(Mojo::URL->new('http://localhost/test'))}) {
      say $cookie->name;
      say $cookie->value;
    }
  
  =head1 DESCRIPTION
  
  L<Mojo::UserAgent::CookieJar> is a minimalistic and relaxed cookie jar used by
  L<Mojo::UserAgent>, based on L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::UserAgent::CookieJar> implements the following attributes.
  
  =head2 ignore
  
    my $ignore = $jar->ignore;
    $jar       = $jar->ignore(sub {...});
  
  A callback used to decide if a cookie should be ignored by L</"collect">.
  
    # Ignore all cookies
    $jar->ignore(sub { 1 });
  
    # Ignore cookies for domains "com", "net" and "org"
    $jar->ignore(sub {
      my $cookie = shift;
      return undef unless my $domain = $cookie->domain;
      return $domain eq 'com' || $domain eq 'net' || $domain eq 'org';
    });
  
  =head2 max_cookie_size
  
    my $size = $jar->max_cookie_size;
    $jar     = $jar->max_cookie_size(4096);
  
  Maximum cookie size in bytes, defaults to C<4096> (4KiB).
  
  =head1 METHODS
  
  L<Mojo::UserAgent::CookieJar> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 add
  
    $jar = $jar->add(@cookies);
  
  Add multiple L<Mojo::Cookie::Response> objects to the jar.
  
  =head2 all
  
    my $cookies = $jar->all;
  
  Return all L<Mojo::Cookie::Response> objects that are currently stored in the
  jar.
  
    # Names of all cookies
    say $_->name for @{$jar->all};
  
  =head2 collect
  
    $jar->collect(Mojo::Transaction::HTTP->new);
  
  Collect response cookies from transaction.
  
  =head2 empty
  
    $jar->empty;
  
  Empty the jar.
  
  =head2 find
  
    my $cookies = $jar->find(Mojo::URL->new);
  
  Find L<Mojo::Cookie::Request> objects in the jar for L<Mojo::URL> object.
  
    # Names of all cookies found
    say $_->name for @{$jar->find(Mojo::URL->new('http://example.com/foo'))};
  
  =head2 prepare
  
    $jar->prepare(Mojo::Transaction::HTTP->new);
  
  Prepare request cookies for transaction.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_USERAGENT_COOKIEJAR

$fatpacked{"Mojo/UserAgent/Proxy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT_PROXY';
  package Mojo::UserAgent::Proxy;
  use Mojo::Base -base;
  
  use Mojo::URL;
  
  has [qw(http https not)];
  
  sub detect {
    my $self = shift;
    $self->http($ENV{HTTP_PROXY}   || $ENV{http_proxy});
    $self->https($ENV{HTTPS_PROXY} || $ENV{https_proxy});
    return $self->not([split ',', $ENV{NO_PROXY} || $ENV{no_proxy} || '']);
  }
  
  sub is_needed {
    !grep { $_[1] =~ /\Q$_\E$/ } @{$_[0]->not || []};
  }
  
  sub prepare {
    my ($self, $tx) = @_;
  
    $self->detect if $ENV{MOJO_PROXY};
    my $req = $tx->req;
    my $url = $req->url;
    return unless $self->is_needed($url->host);
  
    # HTTP proxy
    my $proto = $url->protocol;
    my $http  = $self->http;
    $req->proxy(Mojo::URL->new($http)) if $http && $proto eq 'http';
  
    # HTTPS proxy
    my $https = $self->https;
    $req->proxy(Mojo::URL->new($https)) if $https && $proto eq 'https';
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::UserAgent::Proxy - User agent proxy manager
  
  =head1 SYNOPSIS
  
    use Mojo::UserAgent::Proxy;
  
    my $proxy = Mojo::UserAgent::Proxy->new;
    $proxy->detect;
    say $proxy->http;
  
  =head1 DESCRIPTION
  
  L<Mojo::UserAgent::Proxy> manages proxy servers for L<Mojo::UserAgent>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::UserAgent::Proxy> implements the following attributes.
  
  =head2 http
  
    my $http = $proxy->http;
    $proxy   = $proxy->http('socks://sri:secret@127.0.0.1:8080');
  
  Proxy server to use for HTTP and WebSocket requests.
  
  =head2 https
  
    my $https = $proxy->https;
    $proxy    = $proxy->https('http://sri:secret@127.0.0.1:8080');
  
  Proxy server to use for HTTPS and WebSocket requests.
  
  =head2 not
  
    my $not = $proxy->not;
    $proxy  = $proxy->not(['localhost', 'intranet.mojolicious.org']);
  
  Domains that don't require a proxy server to be used.
  
  =head1 METHODS
  
  L<Mojo::UserAgent::Proxy> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 detect
  
    $proxy = $proxy->detect;
  
  Check environment variables C<HTTP_PROXY>, C<http_proxy>, C<HTTPS_PROXY>,
  C<https_proxy>, C<NO_PROXY> and C<no_proxy> for proxy information. Automatic
  proxy detection can be enabled with the C<MOJO_PROXY> environment variable.
  
  =head2 is_needed
  
    my $bool = $proxy->is_needed('intranet.example.com');
  
  Check if request for domain would use a proxy server.
  
  =head2 prepare
  
    $proxy->prepare(Mojo::Transaction::HTTP->new);
  
  Prepare proxy server information for transaction.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_USERAGENT_PROXY

$fatpacked{"Mojo/UserAgent/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT_SERVER';
  package Mojo::UserAgent::Server;
  use Mojo::Base -base;
  
  use Mojo::IOLoop;
  use Mojo::Server::Daemon;
  use Scalar::Util 'weaken';
  
  has ioloop => sub { Mojo::IOLoop->singleton };
  
  sub app {
    my ($self, $app) = @_;
  
    # Singleton application
    state $singleton;
    return $singleton = $app ? $app : $singleton unless ref $self;
  
    # Default to singleton application
    return $self->{app} || $singleton unless $app;
    $self->{app} = $app;
    return $self;
  }
  
  sub nb_url { shift->_url(1, @_) }
  
  sub restart { delete @{$_[0]}{qw(nb_port nb_server port server)} }
  
  sub url { shift->_url(0, @_) }
  
  sub _url {
    my ($self, $nb, $proto) = @_;
  
    if (!$self->{server} || $proto) {
      $proto = $self->{proto} = $proto || 'http';
  
      # Blocking
      my $server = $self->{server}
        = Mojo::Server::Daemon->new(ioloop => $self->ioloop, silent => 1);
      weaken $server->app($self->app)->{app};
      my $port = $self->{port} ? ":$self->{port}" : '';
      $self->{port}
        = $server->listen(["$proto://127.0.0.1$port"])->start->ports->[0];
  
      # Non-blocking
      $server = $self->{nb_server} = Mojo::Server::Daemon->new(silent => 1);
      weaken $server->app($self->app)->{app};
      $port = $self->{nb_port} ? ":$self->{nb_port}" : '';
      $self->{nb_port}
        = $server->listen(["$proto://127.0.0.1$port"])->start->ports->[0];
    }
  
    my $port = $nb ? $self->{nb_port} : $self->{port};
    return Mojo::URL->new("$self->{proto}://127.0.0.1:$port/");
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::UserAgent::Server - Application server
  
  =head1 SYNOPSIS
  
    use Mojo::UserAgent::Server;
  
    my $server = Mojo::UserAgent::Server->new;
    say $server->url;
  
  =head1 DESCRIPTION
  
  L<Mojo::UserAgent::Server> is an embedded web server based on
  L<Mojo::Server::Daemon> that processes requests for L<Mojo::UserAgent>.
  
  =head1 ATTRIBUTES
  
  L<Mojo::UserAgent::Server> implements the following attributes.
  
  =head2 ioloop
  
    my $loop = $server->ioloop;
    $server  = $server->ioloop(Mojo::IOLoop->new);
  
  Event loop object to use for I/O operations, defaults to the global
  L<Mojo::IOLoop> singleton.
  
  =head1 METHODS
  
  L<Mojo::UserAgent::Server> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 app
  
    my $app = Mojo::UserAgent::Server->app;
              Mojo::UserAgent::Server->app(Mojolicious->new);
    my $app = $server->app;
    $server = $server->app(Mojolicious->new);
  
  Application this server handles, instance specific applications override the
  global default.
  
    # Change application behavior
    $server->app->defaults(testing => 'oh yea!');
  
  =head2 nb_url
  
    my $url = $ua->nb_url;
    my $url = $ua->nb_url('http');
    my $url = $ua->nb_url('https');
  
  Get absolute L<Mojo::URL> object for server processing non-blocking requests
  with L</"app"> and switch protocol if necessary.
  
  =head2 restart
  
    $server->restart;
  
  Restart server with new port.
  
  =head2 url
  
    my $url = $ua->url;
    my $url = $ua->url('http');
    my $url = $ua->url('https');
  
  Get absolute L<Mojo::URL> object for server processing blocking requests with
  L</"app"> and switch protocol if necessary.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_USERAGENT_SERVER

$fatpacked{"Mojo/UserAgent/Transactor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT_TRANSACTOR';
  package Mojo::UserAgent::Transactor;
  use Mojo::Base -base;
  
  use Mojo::Asset::File;
  use Mojo::Asset::Memory;
  use Mojo::Content::MultiPart;
  use Mojo::Content::Single;
  use Mojo::File 'path';
  use Mojo::JSON 'encode_json';
  use Mojo::Parameters;
  use Mojo::Transaction::HTTP;
  use Mojo::Transaction::WebSocket;
  use Mojo::URL;
  use Mojo::Util qw(encode url_escape);
  use Mojo::WebSocket qw(challenge client_handshake);
  
  has generators =>
    sub { {form => \&_form, json => \&_json, multipart => \&_multipart} };
  has name => 'Mojolicious (Perl)';
  
  sub add_generator { $_[0]->generators->{$_[1]} = $_[2] and return $_[0] }
  
  sub endpoint {
    my ($self, $tx) = @_;
  
    # Basic endpoint
    my $req   = $tx->req;
    my $url   = $req->url;
    my $proto = $url->protocol || 'http';
    my $host  = $url->ihost;
    my $port  = $url->port // ($proto eq 'https' ? 443 : 80);
  
    # Proxy for normal HTTP requests
    my $socks;
    if (my $proxy = $req->proxy) { $socks = $proxy->protocol eq 'socks' }
    return _proxy($tx, $proto, $host, $port)
      if $proto eq 'http' && !$req->is_handshake && !$socks;
  
    return $proto, $host, $port;
  }
  
  sub peer { _proxy($_[1], $_[0]->endpoint($_[1])) }
  
  sub promisify {
    my ($self, $promise, $tx) = @_;
    my $err = $tx->error;
    return $promise->reject($err->{message}) if $err && !$err->{code};
    return $promise->reject('WebSocket handshake failed')
      if $tx->req->is_handshake && !$tx->is_websocket;
    $promise->resolve($tx);
  }
  
  sub proxy_connect {
    my ($self, $old) = @_;
  
    # Already a CONNECT request
    my $req = $old->req;
    return undef if uc $req->method eq 'CONNECT';
  
    # No proxy
    return undef unless (my $proxy = $req->proxy) && $req->via_proxy;
    return undef if $proxy->protocol eq 'socks';
  
    # WebSocket and/or HTTPS
    my $url = $req->url;
    return undef unless $req->is_handshake || $url->protocol eq 'https';
  
    # CONNECT request (expect a bad response)
    my $new = $self->tx(CONNECT => $url->clone->userinfo(undef));
    $new->req->proxy($proxy);
    $new->res->content->auto_relax(0)->headers->connection('keep-alive');
  
    return $new;
  }
  
  sub redirect {
    my ($self, $old) = @_;
  
    # Commonly used codes
    my $res  = $old->res;
    my $code = $res->code // 0;
    return undef unless grep { $_ == $code } 301, 302, 303, 307, 308;
  
    # CONNECT requests cannot be redirected
    my $req = $old->req;
    return undef if uc $req->method eq 'CONNECT';
  
    # Fix location without authority and/or scheme
    return undef
      unless my $location = $res->headers->every_header('Location')->[0];
    $location = Mojo::URL->new($location);
    $location = $location->base($req->url)->to_abs unless $location->is_abs;
    my $proto = $location->protocol;
    return undef if ($proto ne 'http' && $proto ne 'https') || !$location->host;
  
    # Clone request if necessary
    my $new = Mojo::Transaction::HTTP->new;
    if ($code == 307 || $code == 308) {
      return undef unless my $clone = $req->clone;
      $new->req($clone);
    }
    else {
      my $m = uc $req->method;
      my $headers = $new->req->method($code == 303 || $m eq 'POST' ? 'GET' : $m)
        ->content->headers($req->headers->clone)->headers;
      $headers->remove($_) for grep {/^content-/i} @{$headers->names};
    }
    my $headers = $new->req->url($location)->headers;
    $headers->remove($_) for qw(Authorization Cookie Host Referer);
    return $new->previous($old);
  }
  
  sub tx {
    my ($self, $method, $url) = (shift, shift, shift);
  
    # Method and URL
    my $tx  = Mojo::Transaction::HTTP->new;
    my $req = $tx->req->method($method);
    if   (ref $url) { $req->url($url) }
    else            { $req->url->parse($url =~ m!^/|://! ? $url : "http://$url") }
  
    # Headers (we identify ourselves and accept gzip compression)
    my $headers = $req->headers;
    $headers->from_hash(shift) if ref $_[0] eq 'HASH';
    $headers->user_agent($self->name) unless $headers->user_agent;
    $headers->accept_encoding('gzip') unless $headers->accept_encoding;
  
    # Generator
    if (@_ > 1) {
      my $cb = $self->generators->{shift()};
      $self->$cb($tx, @_);
    }
  
    # Body
    elsif (@_) { $req->body(shift) }
  
    return $tx;
  }
  
  sub upgrade {
    my ($self, $tx) = @_;
    my $code = $tx->res->code // 0;
    return undef unless $tx->req->is_handshake && $code == 101;
    my $ws = Mojo::Transaction::WebSocket->new(handshake => $tx, masked => 1);
    return challenge($ws) ? $ws->established(1) : undef;
  }
  
  sub websocket {
    my $self = shift;
  
    # New WebSocket transaction
    my $sub = ref $_[-1] eq 'ARRAY' ? pop : [];
    my $tx = $self->tx(GET => @_);
    my $req = $tx->req;
    $req->headers->sec_websocket_protocol(join ', ', @$sub) if @$sub;
  
    # Handshake protocol
    my $url   = $req->url;
    my $proto = $url->protocol // '';
    if    ($proto eq 'ws')      { $url->scheme('http') }
    elsif ($proto eq 'wss')     { $url->scheme('https') }
    elsif ($proto eq 'ws+unix') { $url->scheme('http+unix') }
  
    return client_handshake $tx;
  }
  
  sub _content { Mojo::Content::MultiPart->new(headers => $_[0], parts => $_[1]) }
  
  sub _form {
    my ($self, $tx, $form, %options) = @_;
    $options{charset} = 'UTF-8' unless exists $options{charset};
  
    # Check for uploads and force multipart if necessary
    my $req       = $tx->req;
    my $headers   = $req->headers;
    my $multipart = ($headers->content_type // '') =~ m!multipart/form-data!i;
    for my $value (map { ref $_ eq 'ARRAY' ? @$_ : $_ } values %$form) {
      ++$multipart and last if ref $value eq 'HASH';
    }
  
    # Multipart
    if ($multipart) {
      $req->content(_content($headers, _form_parts($options{charset}, $form)));
      _type($headers, 'multipart/form-data');
      return $tx;
    }
  
    # Query parameters or urlencoded
    my $method = uc $req->method;
    my @form = map { $_ => $form->{$_} } sort keys %$form;
    if ($method eq 'GET' || $method eq 'HEAD') { $req->url->query->merge(@form) }
    else {
      $req->body(
        Mojo::Parameters->new(@form)->charset($options{charset})->to_string);
      _type($headers, 'application/x-www-form-urlencoded');
    }
    return $tx;
  }
  
  sub _form_parts {
    my ($charset, $form) = @_;
  
    my @parts;
    for my $name (sort keys %$form) {
      next unless defined(my $values = $form->{$name});
      $values = [$values] unless ref $values eq 'ARRAY';
      push @parts, @{_parts($charset, $name, $values)};
    }
  
    return \@parts;
  }
  
  sub _json {
    my ($self, $tx, $data) = @_;
    _type($tx->req->body(encode_json $data)->headers, 'application/json');
    return $tx;
  }
  
  sub _multipart {
    my ($self, $tx, $parts) = @_;
    my $req = $tx->req;
    $req->content(_content($req->headers, _parts(undef, undef, $parts)));
    return $tx;
  }
  
  sub _parts {
    my ($charset, $name, $values) = @_;
  
    my @parts;
    for my $value (@$values) {
      push @parts, my $part = Mojo::Content::Single->new;
  
      my $filename;
      my $headers = $part->headers;
      if (ref $value eq 'HASH') {
  
        # File
        if (my $file = delete $value->{file}) {
          $file = Mojo::Asset::File->new(path => $file) unless ref $file;
          $part->asset($file);
          $value->{filename} //= path($file->path)->basename
            if $file->isa('Mojo::Asset::File');
        }
  
        # Memory
        elsif (defined(my $content = delete $value->{content})) {
          $part->asset(Mojo::Asset::Memory->new->add_chunk($content));
        }
  
        # Filename and headers
        $filename = delete $value->{filename};
        $headers->from_hash($value);
        next unless defined $name;
        $filename = url_escape $filename // $name, '"';
        $filename = encode $charset, $filename if $charset;
      }
  
      # Field
      else {
        $value = encode $charset, $value if $charset;
        $part->asset(Mojo::Asset::Memory->new->add_chunk($value));
      }
  
      # Content-Disposition
      next unless defined $name;
      $name = url_escape $name, '"';
      $name = encode $charset, $name if $charset;
      my $disposition = qq{form-data; name="$name"};
      $disposition .= qq{; filename="$filename"} if defined $filename;
      $headers->content_disposition($disposition);
    }
  
    return \@parts;
  }
  
  sub _proxy {
    my ($tx, $proto, $host, $port) = @_;
  
    my $req = $tx->req;
    if ($req->via_proxy && (my $proxy = $req->proxy)) {
      return $proxy->protocol, $proxy->ihost,
        $proxy->port // ($proto eq 'https' ? 443 : 80);
    }
  
    return $proto, $host, $port;
  }
  
  sub _type { $_[0]->content_type($_[1]) unless $_[0]->content_type }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::UserAgent::Transactor - User agent transactor
  
  =head1 SYNOPSIS
  
    use Mojo::UserAgent::Transactor;
  
    # GET request with Accept header
    my $t = Mojo::UserAgent::Transactor->new;
    say $t->tx(GET => 'http://example.com' => {Accept => '*/*'})->req->to_string;
  
    # POST request with form-data
    say $t->tx(POST => 'example.com' => form => {a => 'b'})->req->to_string;
  
    # PUT request with JSON data
    say $t->tx(PUT => 'example.com' => json => {a => 'b'})->req->to_string;
  
  =head1 DESCRIPTION
  
  L<Mojo::UserAgent::Transactor> is the transaction building and manipulation
  framework used by L<Mojo::UserAgent>.
  
  =head1 GENERATORS
  
  These content generators are available by default.
  
  =head2 form
  
    $t->tx(POST => 'http://example.com' => form => {a => 'b'});
  
  Generate query string, C<application/x-www-form-urlencoded> or
  C<multipart/form-data> content. See L</"tx"> for more.
  
  =head2 json
  
    $t->tx(PATCH => 'http://example.com' => json => {a => 'b'});
  
  Generate JSON content with L<Mojo::JSON>. See L</"tx"> for more.
  
  =head2 multipart
  
    $t->tx(PUT => 'http://example.com' => multipart => ['Hello', 'World!']);
  
  Generate multipart content. See L</"tx"> for more.
  
  =head1 ATTRIBUTES
  
  L<Mojo::UserAgent::Transactor> implements the following attributes.
  
  =head2 generators
  
    my $generators = $t->generators;
    $t             = $t->generators({foo => sub {...}});
  
  Registered content generators, by default only C<form>, C<json> and C<multipart>
  are already defined.
  
  =head2 name
  
    my $name = $t->name;
    $t       = $t->name('Mojolicious');
  
  Value for C<User-Agent> request header of generated transactions, defaults to
  C<Mojolicious (Perl)>.
  
  =head1 METHODS
  
  L<Mojo::UserAgent::Transactor> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 add_generator
  
    $t = $t->add_generator(foo => sub {...});
  
  Register a content generator.
  
    $t->add_generator(foo => sub {
      my ($t, $tx, @args) = @_;
      ...
    });
  
  =head2 endpoint
  
    my ($proto, $host, $port) = $t->endpoint(Mojo::Transaction::HTTP->new);
  
  Actual endpoint for transaction.
  
  =head2 peer
  
    my ($proto, $host, $port) = $t->peer(Mojo::Transaction::HTTP->new);
  
  Actual peer for transaction.
  
  =head2 promisify
  
    $t->promisify(Mojo::Promise->new, Mojo::Transaction::HTTP->new);
  
  Resolve or reject L<Mojo::Promise> object with L<Mojo::Transaction::HTTP>
  object.
  
  =head2 proxy_connect
  
    my $tx = $t->proxy_connect(Mojo::Transaction::HTTP->new);
  
  Build L<Mojo::Transaction::HTTP> proxy C<CONNECT> request for transaction if
  possible.
  
  =head2 redirect
  
    my $tx = $t->redirect(Mojo::Transaction::HTTP->new);
  
  Build L<Mojo::Transaction::HTTP> follow-up request for C<301>, C<302>, C<303>,
  C<307> or C<308> redirect response if possible.
  
  =head2 tx
  
    my $tx = $t->tx(GET  => 'example.com');
    my $tx = $t->tx(POST => 'http://example.com');
    my $tx = $t->tx(GET  => 'http://example.com' => {Accept => '*/*'});
    my $tx = $t->tx(PUT  => 'http://example.com' => 'Content!');
    my $tx = $t->tx(PUT  => 'http://example.com' => form => {a => 'b'});
    my $tx = $t->tx(PUT  => 'http://example.com' => json => {a => 'b'});
    my $tx = $t->tx(PUT  => 'https://example.com' => multipart => ['a', 'b']);
    my $tx = $t->tx(POST => 'example.com' => {Accept => '*/*'} => 'Content!');
    my $tx = $t->tx(
      PUT => 'example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $tx = $t->tx(
      PUT => 'example.com' => {Accept => '*/*'} => json => {a => 'b'});
    my $tx = $t->tx(
      PUT => 'example.com' => {Accept => '*/*'} => multipart => ['a', 'b']);
  
  Versatile general purpose L<Mojo::Transaction::HTTP> transaction builder for
  requests, with support for L</"GENERATORS">.
  
    # Generate and inspect custom GET request with DNT header and content
    say $t->tx(GET => 'example.com' => {DNT => 1} => 'Bye!')->req->to_string;
  
    # Stream response content to STDOUT
    my $tx = $t->tx(GET => 'http://example.com');
    $tx->res->content->unsubscribe('read')->on(read => sub { say $_[1] });
  
    # PUT request with content streamed from file
    my $tx = $t->tx(PUT => 'http://example.com');
    $tx->req->content->asset(Mojo::Asset::File->new(path => '/foo.txt'));
  
  The C<json> content generator uses L<Mojo::JSON> for encoding and sets the
  content type to C<application/json>.
  
    # POST request with "application/json" content
    my $tx = $t->tx(
      POST => 'http://example.com' => json => {a => 'b', c => [1, 2, 3]});
  
  The C<form> content generator will automatically use query parameters for
  C<GET> and C<HEAD> requests.
  
    # GET request with query parameters
    my $tx = $t->tx(GET => 'http://example.com' => form => {a => 'b'});
  
  For all other request methods the C<application/x-www-form-urlencoded> content
  type is used.
  
    # POST request with "application/x-www-form-urlencoded" content
    my $tx = $t->tx(
      POST => 'http://example.com' => form => {a => 'b', c => 'd'});
  
  Parameters may be encoded with the C<charset> option.
  
    # PUT request with Shift_JIS encoded form values
    my $tx = $t->tx(
      PUT => 'example.com' => form => {a => 'b'} => charset => 'Shift_JIS');
  
  An array reference can be used for multiple form values sharing the same name.
  
    # POST request with form values sharing the same name
    my $tx = $t->tx(
      POST => 'http://example.com' => form => {a => ['b', 'c', 'd']});
  
  A hash reference with a C<content> or C<file> value can be used to switch to
  the C<multipart/form-data> content type for file uploads.
  
    # POST request with "multipart/form-data" content
    my $tx = $t->tx(
      POST => 'http://example.com' => form => {mytext => {content => 'lala'}});
  
    # POST request with multiple files sharing the same name
    my $tx = $t->tx(POST => 'http://example.com' =>
      form => {mytext => [{content => 'first'}, {content => 'second'}]});
  
  The C<file> value should contain the path to the file you want to upload or an
  asset object, like L<Mojo::Asset::File> or L<Mojo::Asset::Memory>.
  
    # POST request with upload streamed from file
    my $tx = $t->tx(
      POST => 'http://example.com' => form => {mytext => {file => '/foo.txt'}});
  
    # POST request with upload streamed from asset
    my $asset = Mojo::Asset::Memory->new->add_chunk('lalala');
    my $tx    = $t->tx(
      POST => 'http://example.com' => form => {mytext => {file => $asset}});
  
  A C<filename> value will be generated automatically, but can also be set
  manually if necessary. All remaining values in the hash reference get merged
  into the C<multipart/form-data> content as headers.
  
    # POST request with form values and customized upload (filename and header)
    my $tx = $t->tx(POST => 'http://example.com' => form => {
      a      => 'b',
      c      => 'd',
      mytext => {
        content        => 'lalala',
        filename       => 'foo.txt',
        'Content-Type' => 'text/plain'
      }
    });
  
  The C<multipart/form-data> content type can also be enforced by setting the
  C<Content-Type> header manually.
  
    # Force "multipart/form-data"
    my $headers = {'Content-Type' => 'multipart/form-data'};
    my $tx = $t->tx(POST => 'example.com' => $headers => form => {a => 'b'});
  
  The C<multipart> content generator can be used to build custom multipart
  requests and does not set a content type.
  
    # POST request with multipart content ("foo" and "bar")
    my $tx = $t->tx(POST => 'http://example.com' => multipart => ['foo', 'bar']);
  
  Similar to the C<form> content generator you can also pass hash references with
  C<content> or C<file> values, as well as headers.
  
    # POST request with multipart content streamed from file
    my $tx = $t->tx(
      POST => 'http://example.com' => multipart => [{file => '/foo.txt'}]);
  
    # PUT request with multipart content streamed from asset
    my $headers = {'Content-Type' => 'multipart/custom'};
    my $asset   = Mojo::Asset::Memory->new->add_chunk('lalala');
    my $tx      = $t->tx(
      PUT => 'http://example.com' => $headers => multipart => [{file => $asset}]);
  
    # POST request with multipart content and custom headers
    my $tx = $t->tx(POST => 'http://example.com' => multipart => [
      {
        content            => 'Hello',
        'Content-Type'     => 'text/plain',
        'Content-Language' => 'en-US'
      },
      {
        content            => 'World!',
        'Content-Type'     => 'text/plain',
        'Content-Language' => 'en-US'
      }
    ]);
  
  =head2 upgrade
  
    my $tx = $t->upgrade(Mojo::Transaction::HTTP->new);
  
  Build L<Mojo::Transaction::WebSocket> follow-up transaction for WebSocket
  handshake if possible.
  
  =head2 websocket
  
    my $tx = $t->websocket('ws://example.com');
    my $tx = $t->websocket('ws://example.com' => {DNT => 1} => ['v1.proto']);
  
  Versatile L<Mojo::Transaction::HTTP> transaction builder for WebSocket
  handshake requests.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_USERAGENT_TRANSACTOR

$fatpacked{"Mojo/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_UTIL';
  package Mojo::Util;
  use Mojo::Base -strict;
  
  use Carp qw(carp croak);
  use Data::Dumper ();
  use Digest::MD5 qw(md5 md5_hex);
  use Digest::SHA qw(hmac_sha1_hex sha1 sha1_hex);
  use Encode 'find_encoding';
  use Exporter 'import';
  use Getopt::Long 'GetOptionsFromArray';
  use IO::Poll qw(POLLIN POLLPRI);
  use List::Util 'min';
  use MIME::Base64 qw(decode_base64 encode_base64);
  use Pod::Usage 'pod2usage';
  use Symbol 'delete_package';
  use Time::HiRes        ();
  use Unicode::Normalize ();
  
  # Check for monotonic clock support
  use constant MONOTONIC =>
    eval { !!Time::HiRes::clock_gettime(Time::HiRes::CLOCK_MONOTONIC()) };
  
  # Punycode bootstring parameters
  use constant {
    PC_BASE         => 36,
    PC_TMIN         => 1,
    PC_TMAX         => 26,
    PC_SKEW         => 38,
    PC_DAMP         => 700,
    PC_INITIAL_BIAS => 72,
    PC_INITIAL_N    => 128
  };
  
  # Supported on Perl 5.22+
  my $NAME
    = eval { require Sub::Util; Sub::Util->can('set_subname') } || sub { $_[1] };
  
  # To generate a new HTML entity table run this command
  # perl examples/entities.pl
  my %ENTITIES;
  for my $line (split "\n", join('', <DATA>)) {
    next unless $line =~ /^(\S+)\s+U\+(\S+)(?:\s+U\+(\S+))?/;
    $ENTITIES{$1} = defined $3 ? (chr(hex $2) . chr(hex $3)) : chr(hex $2);
  }
  close DATA;
  
  # Characters that should be escaped in XML
  my %XML = (
    '&'  => '&amp;',
    '<'  => '&lt;',
    '>'  => '&gt;',
    '"'  => '&quot;',
    '\'' => '&#39;'
  );
  
  # "Sun, 06 Nov 1994 08:49:37 GMT" and "Sunday, 06-Nov-94 08:49:37 GMT"
  my $EXPIRES_RE = qr/(\w+\W+\d+\W+\w+\W+\d+\W+\d+:\d+:\d+\W*\w+)/;
  
  # HTML entities
  my $ENTITY_RE = qr/&(?:\#((?:[0-9]{1,7}|x[0-9a-fA-F]{1,6}));|(\w+[;=]?))/;
  
  # Encoding and pattern cache
  my (%ENCODING, %PATTERN);
  
  our @EXPORT_OK = (
    qw(b64_decode b64_encode camelize class_to_file class_to_path decamelize),
    qw(decode deprecated dumper encode extract_usage getopt hmac_sha1_sum),
    qw(html_attr_unescape html_unescape md5_bytes md5_sum monkey_patch),
    qw(punycode_decode punycode_encode quote secure_compare sha1_bytes sha1_sum),
    qw(slugify split_cookie_header split_header steady_time tablify term_escape),
    qw(trim unindent unquote url_escape url_unescape xml_escape xor_encode)
  );
  
  # Aliases
  monkey_patch(__PACKAGE__, 'b64_decode',    \&decode_base64);
  monkey_patch(__PACKAGE__, 'b64_encode',    \&encode_base64);
  monkey_patch(__PACKAGE__, 'hmac_sha1_sum', \&hmac_sha1_hex);
  monkey_patch(__PACKAGE__, 'md5_bytes',     \&md5);
  monkey_patch(__PACKAGE__, 'md5_sum',       \&md5_hex);
  monkey_patch(__PACKAGE__, 'sha1_bytes',    \&sha1);
  monkey_patch(__PACKAGE__, 'sha1_sum',      \&sha1_hex);
  
  # Use a monotonic clock if possible
  monkey_patch(__PACKAGE__, 'steady_time',
    MONOTONIC
    ? sub () { Time::HiRes::clock_gettime(Time::HiRes::CLOCK_MONOTONIC()) }
    : \&Time::HiRes::time);
  
  sub camelize {
    my $str = shift;
    return $str if $str =~ /^[A-Z]/;
  
    # CamelCase words
    return join '::', map {
      join('', map { ucfirst lc } split '_')
    } split '-', $str;
  }
  
  sub class_to_file {
    my $class = shift;
    $class =~ s/::|'//g;
    $class =~ s/([A-Z])([A-Z]*)/$1 . lc $2/ge;
    return decamelize($class);
  }
  
  sub class_to_path { join '.', join('/', split(/::|'/, shift)), 'pm' }
  
  sub decamelize {
    my $str = shift;
    return $str if $str !~ /^[A-Z]/;
  
    # snake_case words
    return join '-', map {
      join('_', map {lc} grep {length} split /([A-Z]{1}[^A-Z]*)/)
    } split '::', $str;
  }
  
  sub decode {
    my ($encoding, $bytes) = @_;
    return undef
      unless eval { $bytes = _encoding($encoding)->decode("$bytes", 1); 1 };
    return $bytes;
  }
  
  sub deprecated {
    local $Carp::CarpLevel = 1;
    $ENV{MOJO_FATAL_DEPRECATIONS} ? croak @_ : carp @_;
  }
  
  sub dumper {
    Data::Dumper->new([@_])->Indent(1)->Sortkeys(1)->Terse(1)->Useqq(1)->Dump;
  }
  
  sub encode { _encoding($_[0])->encode("$_[1]", 0) }
  
  sub extract_usage {
    my $file = @_ ? "$_[0]" : (caller)[1];
  
    open my $handle, '>', \my $output;
    pod2usage -exitval => 'noexit', -input => $file, -output => $handle;
    $output =~ s/^.*\n|\n$//;
    $output =~ s/\n$//;
  
    return unindent($output);
  }
  
  sub getopt {
    my ($array, $opts) = map { ref $_[0] eq 'ARRAY' ? shift : $_ } \@ARGV, [];
    my $save = Getopt::Long::Configure(qw(default no_auto_abbrev no_ignore_case),
      @$opts);
    GetOptionsFromArray $array, @_;
    Getopt::Long::Configure($save);
  }
  
  sub html_attr_unescape { _html(shift, 1) }
  sub html_unescape      { _html(shift, 0) }
  
  sub monkey_patch {
    my ($class, %patch) = @_;
    no strict 'refs';
    no warnings 'redefine';
    *{"${class}::$_"} = $NAME->("${class}::$_", $patch{$_}) for keys %patch;
  }
  
  # Direct translation of RFC 3492
  sub punycode_decode {
    my $input = shift;
    use integer;
  
    my ($n, $i, $bias, @output) = (PC_INITIAL_N, 0, PC_INITIAL_BIAS);
  
    # Consume all code points before the last delimiter
    push @output, split('', $1) if $input =~ s/(.*)\x2d//s;
  
    while (length $input) {
      my ($oldi, $w) = ($i, 1);
  
      # Base to infinity in steps of base
      for (my $k = PC_BASE; 1; $k += PC_BASE) {
        my $digit = ord substr $input, 0, 1, '';
        $digit = $digit < 0x40 ? $digit + (26 - 0x30) : ($digit & 0x1f) - 1;
        $i += $digit * $w;
        my $t = $k - $bias;
        $t = $t < PC_TMIN ? PC_TMIN : $t > PC_TMAX ? PC_TMAX : $t;
        last if $digit < $t;
        $w *= PC_BASE - $t;
      }
  
      $bias = _adapt($i - $oldi, @output + 1, $oldi == 0);
      $n += $i / (@output + 1);
      $i = $i % (@output + 1);
      splice @output, $i++, 0, chr $n;
    }
  
    return join '', @output;
  }
  
  # Direct translation of RFC 3492
  sub punycode_encode {
    my $output = shift;
    use integer;
  
    my ($n, $delta, $bias) = (PC_INITIAL_N, 0, PC_INITIAL_BIAS);
  
    # Extract basic code points
    my @input = map {ord} split '', $output;
    $output =~ s/[^\x00-\x7f]+//gs;
    my $h = my $basic = length $output;
    $output .= "\x2d" if $basic > 0;
  
    for my $m (sort grep { $_ >= PC_INITIAL_N } @input) {
      next if $m < $n;
      $delta += ($m - $n) * ($h + 1);
      $n = $m;
  
      for my $c (@input) {
  
        if ($c < $n) { $delta++ }
        elsif ($c == $n) {
          my $q = $delta;
  
          # Base to infinity in steps of base
          for (my $k = PC_BASE; 1; $k += PC_BASE) {
            my $t = $k - $bias;
            $t = $t < PC_TMIN ? PC_TMIN : $t > PC_TMAX ? PC_TMAX : $t;
            last if $q < $t;
            my $o = $t + (($q - $t) % (PC_BASE - $t));
            $output .= chr $o + ($o < 26 ? 0x61 : 0x30 - 26);
            $q = ($q - $t) / (PC_BASE - $t);
          }
  
          $output .= chr $q + ($q < 26 ? 0x61 : 0x30 - 26);
          $bias = _adapt($delta, $h + 1, $h == $basic);
          $delta = 0;
          $h++;
        }
      }
  
      $delta++;
      $n++;
    }
  
    return $output;
  }
  
  sub quote {
    my $str = shift;
    $str =~ s/(["\\])/\\$1/g;
    return qq{"$str"};
  }
  
  sub secure_compare {
    my ($one, $two) = @_;
    return undef if length $one != length $two;
    my $r = 0;
    $r |= ord(substr $one, $_) ^ ord(substr $two, $_) for 0 .. length($one) - 1;
    return $r == 0;
  }
  
  sub slugify {
    my ($value, $allow_unicode) = @_;
  
    if ($allow_unicode) {
  
      # Force unicode semantics by upgrading string
      utf8::upgrade($value = Unicode::Normalize::NFKC($value));
      $value =~ s/[^\w\s-]+//g;
    }
    else {
      $value = Unicode::Normalize::NFKD($value);
      $value =~ s/[^a-zA-Z0-9_\p{PosixSpace}-]+//g;
    }
    (my $new = lc trim($value)) =~ s/[-\s]+/-/g;
  
    return $new;
  }
  
  sub split_cookie_header { _header(shift, 1) }
  sub split_header        { _header(shift, 0) }
  
  sub tablify {
    my $rows = shift;
  
    my @spec;
    for my $row (@$rows) {
      for my $i (0 .. $#$row) {
        ($row->[$i] //= '') =~ s/[\r\n]//g;
        my $len = length $row->[$i];
        $spec[$i] = $len if $len >= ($spec[$i] // 0);
      }
    }
  
    my @fm = (map({"\%-${_}s"} @spec[0 .. $#spec - 1]), '%s');
    return join '', map { sprintf join('  ', @fm[0 .. $#$_]) . "\n", @$_ } @$rows;
  }
  
  sub term_escape {
    my $str = shift;
    $str =~ s/([\x00-\x09\x0b-\x1f\x7f\x80-\x9f])/sprintf '\\x%02x', ord $1/ge;
    return $str;
  }
  
  sub trim {
    my $str = shift;
    $str =~ s/^\s+//;
    $str =~ s/\s+$//;
    return $str;
  }
  
  sub unindent {
    my $str = shift;
    my $min = min map { m/^([ \t]*)/; length $1 || () } split "\n", $str;
    $str =~ s/^[ \t]{0,$min}//gm if $min;
    return $str;
  }
  
  sub unquote {
    my $str = shift;
    return $str unless $str =~ s/^"(.*)"$/$1/g;
    $str =~ s/\\\\/\\/g;
    $str =~ s/\\"/"/g;
    return $str;
  }
  
  sub url_escape {
    my ($str, $pattern) = @_;
  
    if ($pattern) {
      unless (exists $PATTERN{$pattern}) {
        (my $quoted = $pattern) =~ s!([/\$\[])!\\$1!g;
        $PATTERN{$pattern}
          = eval "sub { \$_[0] =~ s/([$quoted])/sprintf '%%%02X', ord \$1/ge }"
          or croak $@;
      }
      $PATTERN{$pattern}->($str);
    }
    else { $str =~ s/([^A-Za-z0-9\-._~])/sprintf '%%%02X', ord $1/ge }
  
    return $str;
  }
  
  sub url_unescape {
    my $str = shift;
    $str =~ s/%([0-9a-fA-F]{2})/chr hex $1/ge;
    return $str;
  }
  
  sub xml_escape {
    return $_[0] if ref $_[0] && ref $_[0] eq 'Mojo::ByteStream';
    my $str = shift // '';
    $str =~ s/([&<>"'])/$XML{$1}/ge;
    return $str;
  }
  
  sub xor_encode {
    my ($input, $key) = @_;
  
    # Encode with variable key length
    my $len = length $key;
    my $buffer = my $output = '';
    $output .= $buffer ^ $key
      while length($buffer = substr($input, 0, $len, '')) == $len;
    return $output .= $buffer ^ substr($key, 0, length $buffer, '');
  }
  
  sub _adapt {
    my ($delta, $numpoints, $firsttime) = @_;
    use integer;
  
    $delta = $firsttime ? $delta / PC_DAMP : $delta / 2;
    $delta += $delta / $numpoints;
    my $k = 0;
    while ($delta > ((PC_BASE - PC_TMIN) * PC_TMAX) / 2) {
      $delta /= PC_BASE - PC_TMIN;
      $k += PC_BASE;
    }
  
    return $k + (((PC_BASE - PC_TMIN + 1) * $delta) / ($delta + PC_SKEW));
  }
  
  sub _encoding {
    $ENCODING{$_[0]} //= find_encoding($_[0]) // croak "Unknown encoding '$_[0]'";
  }
  
  sub _entity {
    my ($point, $name, $attr) = @_;
  
    # Code point
    return chr($point !~ /^x/ ? $point : hex $point) unless defined $name;
  
    # Named character reference
    my $rest = my $last = '';
    while (length $name) {
      return $ENTITIES{$name} . reverse $rest
        if exists $ENTITIES{$name}
        && (!$attr || $name =~ /;$/ || $last !~ /[A-Za-z0-9=]/);
      $rest .= $last = chop $name;
    }
    return '&' . reverse $rest;
  }
  
  # Supported on Perl 5.14+
  sub _global_destruction {
    defined ${^GLOBAL_PHASE} && ${^GLOBAL_PHASE} eq 'DESTRUCT';
  }
  
  sub _header {
    my ($str, $cookie) = @_;
  
    my (@tree, @part);
    while ($str =~ /\G[,;\s]*([^=;, ]+)\s*/gc) {
      push @part, $1, undef;
      my $expires = $cookie && @part > 2 && lc $1 eq 'expires';
  
      # Special "expires" value
      if ($expires && $str =~ /\G=\s*$EXPIRES_RE/gco) { $part[-1] = $1 }
  
      # Quoted value
      elsif ($str =~ /\G=\s*("(?:\\\\|\\"|[^"])*")/gc) { $part[-1] = unquote $1 }
  
      # Unquoted value
      elsif ($str =~ /\G=\s*([^;, ]*)/gc) { $part[-1] = $1 }
  
      # Separator
      next unless $str =~ /\G[;\s]*,\s*/gc;
      push @tree, [@part];
      @part = ();
    }
  
    # Take care of final part
    return [@part ? (@tree, \@part) : @tree];
  }
  
  sub _html {
    my ($str, $attr) = @_;
    $str =~ s/$ENTITY_RE/_entity($1, $2, $attr)/geo;
    return $str;
  }
  
  sub _options {
  
    # Hash or name (one)
    return ref $_[0] eq 'HASH' ? (undef, %{shift()}) : @_ if @_ == 1;
  
    # Name and values (odd)
    return shift, @_ if @_ % 2;
  
    # Name and hash or just values (even)
    return ref $_[1] eq 'HASH' ? (shift, %{shift()}) : (undef, @_);
  }
  
  # This may break in the future, but is worth it for performance
  sub _readable { !!(IO::Poll::_poll(@_[0, 1], my $m = POLLIN | POLLPRI) > 0) }
  
  sub _stash {
    my ($name, $object) = (shift, shift);
  
    # Hash
    return $object->{$name} ||= {} unless @_;
  
    # Get
    return $object->{$name}{$_[0]} unless @_ > 1 || ref $_[0];
  
    # Set
    my $values = ref $_[0] ? $_[0] : {@_};
    @{$object->{$name}}{keys %$values} = values %$values;
  
    return $object;
  }
  
  sub _teardown {
    return unless my $class = shift;
  
    # @ISA has to be cleared first because of circular references
    no strict 'refs';
    @{"${class}::ISA"} = ();
    delete_package $class;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::Util - Portable utility functions
  
  =head1 SYNOPSIS
  
    use Mojo::Util qw(b64_encode url_escape url_unescape);
  
    my $str = 'test=23';
    my $escaped = url_escape $str;
    say url_unescape $escaped;
    say b64_encode $escaped, '';
  
  =head1 DESCRIPTION
  
  L<Mojo::Util> provides portable utility functions for L<Mojo>.
  
  =head1 FUNCTIONS
  
  L<Mojo::Util> implements the following functions, which can be imported
  individually.
  
  =head2 b64_decode
  
    my $bytes = b64_decode $b64;
  
  Base64 decode bytes with L<MIME::Base64>.
  
  =head2 b64_encode
  
    my $b64 = b64_encode $bytes;
    my $b64 = b64_encode $bytes, "\n";
  
  Base64 encode bytes with L<MIME::Base64>, the line ending defaults to a newline.
  
  =head2 camelize
  
    my $camelcase = camelize $snakecase;
  
  Convert C<snake_case> string to C<CamelCase> and replace C<-> with C<::>.
  
    # "FooBar"
    camelize 'foo_bar';
  
    # "FooBar::Baz"
    camelize 'foo_bar-baz';
  
    # "FooBar::Baz"
    camelize 'FooBar::Baz';
  
  =head2 class_to_file
  
    my $file = class_to_file 'Foo::Bar';
  
  Convert a class name to a file.
  
    # "foo_bar"
    class_to_file 'Foo::Bar';
  
    # "foobar"
    class_to_file 'FOO::Bar';
  
    # "foo_bar"
    class_to_file 'FooBar';
  
    # "foobar"
    class_to_file 'FOOBar';
  
  =head2 class_to_path
  
    my $path = class_to_path 'Foo::Bar';
  
  Convert class name to path, as used by C<%INC>.
  
    # "Foo/Bar.pm"
    class_to_path 'Foo::Bar';
  
    # "FooBar.pm"
    class_to_path 'FooBar';
  
  =head2 decamelize
  
    my $snakecase = decamelize $camelcase;
  
  Convert C<CamelCase> string to C<snake_case> and replace C<::> with C<->.
  
    # "foo_bar"
    decamelize 'FooBar';
  
    # "foo_bar-baz"
    decamelize 'FooBar::Baz';
  
    # "foo_bar-baz"
    decamelize 'foo_bar-baz';
  
  =head2 decode
  
    my $chars = decode 'UTF-8', $bytes;
  
  Decode bytes to characters with L<Encode>, or return C<undef> if decoding
  failed.
  
  =head2 deprecated
  
    deprecated 'foo is DEPRECATED in favor of bar';
  
  Warn about deprecated feature from perspective of caller. You can also set the
  C<MOJO_FATAL_DEPRECATIONS> environment variable to make them die instead.
  
  =head2 dumper
  
    my $perl = dumper {some => 'data'};
  
  Dump a Perl data structure with L<Data::Dumper>.
  
  =head2 encode
  
    my $bytes = encode 'UTF-8', $chars;
  
  Encode characters to bytes with L<Encode>.
  
  =head2 extract_usage
  
    my $usage = extract_usage;
    my $usage = extract_usage '/home/sri/foo.pod';
  
  Extract usage message from the SYNOPSIS section of a file containing POD
  documentation, defaults to using the file this function was called from.
  
    # "Usage: APPLICATION test [OPTIONS]\n"
    extract_usage;
  
    =head1 SYNOPSIS
  
      Usage: APPLICATION test [OPTIONS]
  
    =cut
  
  =head2 getopt
  
    getopt
      'H|headers=s' => \my @headers,
      't|timeout=i' => \my $timeout,
      'v|verbose'   => \my $verbose;
    getopt $array,
      'H|headers=s' => \my @headers,
      't|timeout=i' => \my $timeout,
      'v|verbose'   => \my $verbose;
    getopt $array, ['pass_through'],
      'H|headers=s' => \my @headers,
      't|timeout=i' => \my $timeout,
      'v|verbose'   => \my $verbose;
  
  Extract options from an array reference with L<Getopt::Long>, but without
  changing its global configuration, defaults to using C<@ARGV>. The configuration
  options C<no_auto_abbrev> and C<no_ignore_case> are enabled by default.
  
    # Extract "charset" option
    getopt ['--charset', 'UTF-8'], 'charset=s' => \my $charset;
    say $charset;
  
  =head2 hmac_sha1_sum
  
    my $checksum = hmac_sha1_sum $bytes, 'passw0rd';
  
  Generate HMAC-SHA1 checksum for bytes with L<Digest::SHA>.
  
    # "11cedfd5ec11adc0ec234466d8a0f2a83736aa68"
    hmac_sha1_sum 'foo', 'passw0rd';
  
  =head2 html_attr_unescape
  
    my $str = html_attr_unescape $escaped;
  
  Same as L</"html_unescape">, but handles special rules from the
  L<HTML Living Standard|https://html.spec.whatwg.org> for HTML attributes.
  
    # "foo=bar&ltest=baz"
    html_attr_unescape 'foo=bar&ltest=baz';
  
    # "foo=bar<est=baz"
    html_attr_unescape 'foo=bar&lt;est=baz';
  
  =head2 html_unescape
  
    my $str = html_unescape $escaped;
  
  Unescape all HTML entities in string.
  
    # "<div>"
    html_unescape '&lt;div&gt;';
  
  =head2 md5_bytes
  
    my $checksum = md5_bytes $bytes;
  
  Generate binary MD5 checksum for bytes with L<Digest::MD5>.
  
  =head2 md5_sum
  
    my $checksum = md5_sum $bytes;
  
  Generate MD5 checksum for bytes with L<Digest::MD5>.
  
    # "acbd18db4cc2f85cedef654fccc4a4d8"
    md5_sum 'foo';
  
  =head2 monkey_patch
  
    monkey_patch $package, foo => sub {...};
    monkey_patch $package, foo => sub {...}, bar => sub {...};
  
  Monkey patch functions into package.
  
    monkey_patch 'MyApp',
      one   => sub { say 'One!' },
      two   => sub { say 'Two!' },
      three => sub { say 'Three!' };
  
  =head2 punycode_decode
  
    my $str = punycode_decode $punycode;
  
  Punycode decode string as described in
  L<RFC 3492|http://tools.ietf.org/html/rfc3492>.
  
    # "bcher"
    punycode_decode 'bcher-kva';
  
  =head2 punycode_encode
  
    my $punycode = punycode_encode $str;
  
  Punycode encode string as described in
  L<RFC 3492|http://tools.ietf.org/html/rfc3492>.
  
    # "bcher-kva"
    punycode_encode 'bcher';
  
  =head2 quote
  
    my $quoted = quote $str;
  
  Quote string.
  
  =head2 secure_compare
  
    my $bool = secure_compare $str1, $str2;
  
  Constant time comparison algorithm to prevent timing attacks.
  
  =head2 sha1_bytes
  
    my $checksum = sha1_bytes $bytes;
  
  Generate binary SHA1 checksum for bytes with L<Digest::SHA>.
  
  =head2 sha1_sum
  
    my $checksum = sha1_sum $bytes;
  
  Generate SHA1 checksum for bytes with L<Digest::SHA>.
  
    # "0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33"
    sha1_sum 'foo';
  
  =head2 slugify
  
    my $slug = slugify $string;
    my $slug = slugify $string, $bool;
  
  Returns a URL slug generated from the input string. Non-word characters are
  removed, the string is trimmed and lowercased, and whitespace characters are
  replaced by a dash. By default, non-ASCII characters are normalized to ASCII
  word characters or removed, but if a true value is passed as the second
  parameter, all word characters will be allowed in the result according to
  unicode semantics.
  
    # "joel-is-a-slug"
    slugify 'Joel is a slug';
  
    # "this-is-my-resume"
    slugify 'This is: my - rsum!  ';
  
    # "this-is-my-rsum"
    slugify 'This is: my - rsum!  ', 1;
  
  =head2 split_cookie_header
  
    my $tree = split_cookie_header 'a=b; expires=Thu, 07 Aug 2008 07:07:59 GMT';
  
  Same as L</"split_header">, but handles C<expires> values from
  L<RFC 6265|http://tools.ietf.org/html/rfc6265>.
  
  =head2 split_header
  
     my $tree = split_header 'foo="bar baz"; test=123, yada';
  
  Split HTTP header value into key/value pairs, each comma separated part gets
  its own array reference, and keys without a value get C<undef> assigned.
  
    # "one"
    split_header('one; two="three four", five=six')->[0][0];
  
    # "two"
    split_header('one; two="three four", five=six')->[0][2];
  
    # "three four"
    split_header('one; two="three four", five=six')->[0][3];
  
    # "five"
    split_header('one; two="three four", five=six')->[1][0];
  
    # "six"
    split_header('one; two="three four", five=six')->[1][1];
  
  =head2 steady_time
  
    my $time = steady_time;
  
  High resolution time elapsed from an arbitrary fixed point in the past,
  resilient to time jumps if a monotonic clock is available through
  L<Time::HiRes>.
  
  =head2 tablify
  
    my $table = tablify [['foo', 'bar'], ['baz', 'yada']];
  
  Row-oriented generator for text tables.
  
    # "foo   bar\nyada  yada\nbaz   yada\n"
    tablify [['foo', 'bar'], ['yada', 'yada'], ['baz', 'yada']];
  
  =head2 term_escape
  
    my $escaped = term_escape $str;
  
  Escape all POSIX control characters except for C<\n>.
  
    # "foo\\x09bar\\x0d\n"
    term_escape "foo\tbar\r\n";
  
  =head2 trim
  
    my $trimmed = trim $str;
  
  Trim whitespace characters from both ends of string.
  
    # "foo bar"
    trim '  foo bar  ';
  
  =head2 unindent
  
    my $unindented = unindent $str;
  
  Unindent multi-line string.
  
    # "foo\nbar\nbaz\n"
    unindent "  foo\n  bar\n  baz\n";
  
  =head2 unquote
  
    my $str = unquote $quoted;
  
  Unquote string.
  
  =head2 url_escape
  
    my $escaped = url_escape $str;
    my $escaped = url_escape $str, '^A-Za-z0-9\-._~';
  
  Percent encode unsafe characters in string as described in
  L<RFC 3986|http://tools.ietf.org/html/rfc3986>, the pattern used defaults to
  C<^A-Za-z0-9\-._~>.
  
    # "foo%3Bbar"
    url_escape 'foo;bar';
  
  =head2 url_unescape
  
    my $str = url_unescape $escaped;
  
  Decode percent encoded characters in string as described in
  L<RFC 3986|http://tools.ietf.org/html/rfc3986>.
  
    # "foo;bar"
    url_unescape 'foo%3Bbar';
  
  =head2 xml_escape
  
    my $escaped = xml_escape $str;
  
  Escape unsafe characters C<&>, C<E<lt>>, C<E<gt>>, C<"> and C<'> in string, but
  do not escape L<Mojo::ByteStream> objects.
  
    # "&lt;div&gt;"
    xml_escape '<div>';
  
    # "<div>"
    use Mojo::ByteStream 'b';
    xml_escape b('<div>');
  
  =head2 xor_encode
  
    my $encoded = xor_encode $str, $key;
  
  XOR encode string with variable length key.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
  
  __DATA__
  Aacute; U+000C1
  Aacute U+000C1
  aacute; U+000E1
  aacute U+000E1
  Abreve; U+00102
  abreve; U+00103
  ac; U+0223E
  acd; U+0223F
  acE; U+0223E U+00333
  Acirc; U+000C2
  Acirc U+000C2
  acirc; U+000E2
  acirc U+000E2
  acute; U+000B4
  acute U+000B4
  Acy; U+00410
  acy; U+00430
  AElig; U+000C6
  AElig U+000C6
  aelig; U+000E6
  aelig U+000E6
  af; U+02061
  Afr; U+1D504
  afr; U+1D51E
  Agrave; U+000C0
  Agrave U+000C0
  agrave; U+000E0
  agrave U+000E0
  alefsym; U+02135
  aleph; U+02135
  Alpha; U+00391
  alpha; U+003B1
  Amacr; U+00100
  amacr; U+00101
  amalg; U+02A3F
  AMP; U+00026
  AMP U+00026
  amp; U+00026
  amp U+00026
  And; U+02A53
  and; U+02227
  andand; U+02A55
  andd; U+02A5C
  andslope; U+02A58
  andv; U+02A5A
  ang; U+02220
  ange; U+029A4
  angle; U+02220
  angmsd; U+02221
  angmsdaa; U+029A8
  angmsdab; U+029A9
  angmsdac; U+029AA
  angmsdad; U+029AB
  angmsdae; U+029AC
  angmsdaf; U+029AD
  angmsdag; U+029AE
  angmsdah; U+029AF
  angrt; U+0221F
  angrtvb; U+022BE
  angrtvbd; U+0299D
  angsph; U+02222
  angst; U+000C5
  angzarr; U+0237C
  Aogon; U+00104
  aogon; U+00105
  Aopf; U+1D538
  aopf; U+1D552
  ap; U+02248
  apacir; U+02A6F
  apE; U+02A70
  ape; U+0224A
  apid; U+0224B
  apos; U+00027
  ApplyFunction; U+02061
  approx; U+02248
  approxeq; U+0224A
  Aring; U+000C5
  Aring U+000C5
  aring; U+000E5
  aring U+000E5
  Ascr; U+1D49C
  ascr; U+1D4B6
  Assign; U+02254
  ast; U+0002A
  asymp; U+02248
  asympeq; U+0224D
  Atilde; U+000C3
  Atilde U+000C3
  atilde; U+000E3
  atilde U+000E3
  Auml; U+000C4
  Auml U+000C4
  auml; U+000E4
  auml U+000E4
  awconint; U+02233
  awint; U+02A11
  backcong; U+0224C
  backepsilon; U+003F6
  backprime; U+02035
  backsim; U+0223D
  backsimeq; U+022CD
  Backslash; U+02216
  Barv; U+02AE7
  barvee; U+022BD
  Barwed; U+02306
  barwed; U+02305
  barwedge; U+02305
  bbrk; U+023B5
  bbrktbrk; U+023B6
  bcong; U+0224C
  Bcy; U+00411
  bcy; U+00431
  bdquo; U+0201E
  becaus; U+02235
  Because; U+02235
  because; U+02235
  bemptyv; U+029B0
  bepsi; U+003F6
  bernou; U+0212C
  Bernoullis; U+0212C
  Beta; U+00392
  beta; U+003B2
  beth; U+02136
  between; U+0226C
  Bfr; U+1D505
  bfr; U+1D51F
  bigcap; U+022C2
  bigcirc; U+025EF
  bigcup; U+022C3
  bigodot; U+02A00
  bigoplus; U+02A01
  bigotimes; U+02A02
  bigsqcup; U+02A06
  bigstar; U+02605
  bigtriangledown; U+025BD
  bigtriangleup; U+025B3
  biguplus; U+02A04
  bigvee; U+022C1
  bigwedge; U+022C0
  bkarow; U+0290D
  blacklozenge; U+029EB
  blacksquare; U+025AA
  blacktriangle; U+025B4
  blacktriangledown; U+025BE
  blacktriangleleft; U+025C2
  blacktriangleright; U+025B8
  blank; U+02423
  blk12; U+02592
  blk14; U+02591
  blk34; U+02593
  block; U+02588
  bne; U+0003D U+020E5
  bnequiv; U+02261 U+020E5
  bNot; U+02AED
  bnot; U+02310
  Bopf; U+1D539
  bopf; U+1D553
  bot; U+022A5
  bottom; U+022A5
  bowtie; U+022C8
  boxbox; U+029C9
  boxDL; U+02557
  boxDl; U+02556
  boxdL; U+02555
  boxdl; U+02510
  boxDR; U+02554
  boxDr; U+02553
  boxdR; U+02552
  boxdr; U+0250C
  boxH; U+02550
  boxh; U+02500
  boxHD; U+02566
  boxHd; U+02564
  boxhD; U+02565
  boxhd; U+0252C
  boxHU; U+02569
  boxHu; U+02567
  boxhU; U+02568
  boxhu; U+02534
  boxminus; U+0229F
  boxplus; U+0229E
  boxtimes; U+022A0
  boxUL; U+0255D
  boxUl; U+0255C
  boxuL; U+0255B
  boxul; U+02518
  boxUR; U+0255A
  boxUr; U+02559
  boxuR; U+02558
  boxur; U+02514
  boxV; U+02551
  boxv; U+02502
  boxVH; U+0256C
  boxVh; U+0256B
  boxvH; U+0256A
  boxvh; U+0253C
  boxVL; U+02563
  boxVl; U+02562
  boxvL; U+02561
  boxvl; U+02524
  boxVR; U+02560
  boxVr; U+0255F
  boxvR; U+0255E
  boxvr; U+0251C
  bprime; U+02035
  Breve; U+002D8
  breve; U+002D8
  brvbar; U+000A6
  brvbar U+000A6
  Bscr; U+0212C
  bscr; U+1D4B7
  bsemi; U+0204F
  bsim; U+0223D
  bsime; U+022CD
  bsol; U+0005C
  bsolb; U+029C5
  bsolhsub; U+027C8
  bull; U+02022
  bullet; U+02022
  bump; U+0224E
  bumpE; U+02AAE
  bumpe; U+0224F
  Bumpeq; U+0224E
  bumpeq; U+0224F
  Cacute; U+00106
  cacute; U+00107
  Cap; U+022D2
  cap; U+02229
  capand; U+02A44
  capbrcup; U+02A49
  capcap; U+02A4B
  capcup; U+02A47
  capdot; U+02A40
  CapitalDifferentialD; U+02145
  caps; U+02229 U+0FE00
  caret; U+02041
  caron; U+002C7
  Cayleys; U+0212D
  ccaps; U+02A4D
  Ccaron; U+0010C
  ccaron; U+0010D
  Ccedil; U+000C7
  Ccedil U+000C7
  ccedil; U+000E7
  ccedil U+000E7
  Ccirc; U+00108
  ccirc; U+00109
  Cconint; U+02230
  ccups; U+02A4C
  ccupssm; U+02A50
  Cdot; U+0010A
  cdot; U+0010B
  cedil; U+000B8
  cedil U+000B8
  Cedilla; U+000B8
  cemptyv; U+029B2
  cent; U+000A2
  cent U+000A2
  CenterDot; U+000B7
  centerdot; U+000B7
  Cfr; U+0212D
  cfr; U+1D520
  CHcy; U+00427
  chcy; U+00447
  check; U+02713
  checkmark; U+02713
  Chi; U+003A7
  chi; U+003C7
  cir; U+025CB
  circ; U+002C6
  circeq; U+02257
  circlearrowleft; U+021BA
  circlearrowright; U+021BB
  circledast; U+0229B
  circledcirc; U+0229A
  circleddash; U+0229D
  CircleDot; U+02299
  circledR; U+000AE
  circledS; U+024C8
  CircleMinus; U+02296
  CirclePlus; U+02295
  CircleTimes; U+02297
  cirE; U+029C3
  cire; U+02257
  cirfnint; U+02A10
  cirmid; U+02AEF
  cirscir; U+029C2
  ClockwiseContourIntegral; U+02232
  CloseCurlyDoubleQuote; U+0201D
  CloseCurlyQuote; U+02019
  clubs; U+02663
  clubsuit; U+02663
  Colon; U+02237
  colon; U+0003A
  Colone; U+02A74
  colone; U+02254
  coloneq; U+02254
  comma; U+0002C
  commat; U+00040
  comp; U+02201
  compfn; U+02218
  complement; U+02201
  complexes; U+02102
  cong; U+02245
  congdot; U+02A6D
  Congruent; U+02261
  Conint; U+0222F
  conint; U+0222E
  ContourIntegral; U+0222E
  Copf; U+02102
  copf; U+1D554
  coprod; U+02210
  Coproduct; U+02210
  COPY; U+000A9
  COPY U+000A9
  copy; U+000A9
  copy U+000A9
  copysr; U+02117
  CounterClockwiseContourIntegral; U+02233
  crarr; U+021B5
  Cross; U+02A2F
  cross; U+02717
  Cscr; U+1D49E
  cscr; U+1D4B8
  csub; U+02ACF
  csube; U+02AD1
  csup; U+02AD0
  csupe; U+02AD2
  ctdot; U+022EF
  cudarrl; U+02938
  cudarrr; U+02935
  cuepr; U+022DE
  cuesc; U+022DF
  cularr; U+021B6
  cularrp; U+0293D
  Cup; U+022D3
  cup; U+0222A
  cupbrcap; U+02A48
  CupCap; U+0224D
  cupcap; U+02A46
  cupcup; U+02A4A
  cupdot; U+0228D
  cupor; U+02A45
  cups; U+0222A U+0FE00
  curarr; U+021B7
  curarrm; U+0293C
  curlyeqprec; U+022DE
  curlyeqsucc; U+022DF
  curlyvee; U+022CE
  curlywedge; U+022CF
  curren; U+000A4
  curren U+000A4
  curvearrowleft; U+021B6
  curvearrowright; U+021B7
  cuvee; U+022CE
  cuwed; U+022CF
  cwconint; U+02232
  cwint; U+02231
  cylcty; U+0232D
  Dagger; U+02021
  dagger; U+02020
  daleth; U+02138
  Darr; U+021A1
  dArr; U+021D3
  darr; U+02193
  dash; U+02010
  Dashv; U+02AE4
  dashv; U+022A3
  dbkarow; U+0290F
  dblac; U+002DD
  Dcaron; U+0010E
  dcaron; U+0010F
  Dcy; U+00414
  dcy; U+00434
  DD; U+02145
  dd; U+02146
  ddagger; U+02021
  ddarr; U+021CA
  DDotrahd; U+02911
  ddotseq; U+02A77
  deg; U+000B0
  deg U+000B0
  Del; U+02207
  Delta; U+00394
  delta; U+003B4
  demptyv; U+029B1
  dfisht; U+0297F
  Dfr; U+1D507
  dfr; U+1D521
  dHar; U+02965
  dharl; U+021C3
  dharr; U+021C2
  DiacriticalAcute; U+000B4
  DiacriticalDot; U+002D9
  DiacriticalDoubleAcute; U+002DD
  DiacriticalGrave; U+00060
  DiacriticalTilde; U+002DC
  diam; U+022C4
  Diamond; U+022C4
  diamond; U+022C4
  diamondsuit; U+02666
  diams; U+02666
  die; U+000A8
  DifferentialD; U+02146
  digamma; U+003DD
  disin; U+022F2
  div; U+000F7
  divide; U+000F7
  divide U+000F7
  divideontimes; U+022C7
  divonx; U+022C7
  DJcy; U+00402
  djcy; U+00452
  dlcorn; U+0231E
  dlcrop; U+0230D
  dollar; U+00024
  Dopf; U+1D53B
  dopf; U+1D555
  Dot; U+000A8
  dot; U+002D9
  DotDot; U+020DC
  doteq; U+02250
  doteqdot; U+02251
  DotEqual; U+02250
  dotminus; U+02238
  dotplus; U+02214
  dotsquare; U+022A1
  doublebarwedge; U+02306
  DoubleContourIntegral; U+0222F
  DoubleDot; U+000A8
  DoubleDownArrow; U+021D3
  DoubleLeftArrow; U+021D0
  DoubleLeftRightArrow; U+021D4
  DoubleLeftTee; U+02AE4
  DoubleLongLeftArrow; U+027F8
  DoubleLongLeftRightArrow; U+027FA
  DoubleLongRightArrow; U+027F9
  DoubleRightArrow; U+021D2
  DoubleRightTee; U+022A8
  DoubleUpArrow; U+021D1
  DoubleUpDownArrow; U+021D5
  DoubleVerticalBar; U+02225
  DownArrow; U+02193
  Downarrow; U+021D3
  downarrow; U+02193
  DownArrowBar; U+02913
  DownArrowUpArrow; U+021F5
  DownBreve; U+00311
  downdownarrows; U+021CA
  downharpoonleft; U+021C3
  downharpoonright; U+021C2
  DownLeftRightVector; U+02950
  DownLeftTeeVector; U+0295E
  DownLeftVector; U+021BD
  DownLeftVectorBar; U+02956
  DownRightTeeVector; U+0295F
  DownRightVector; U+021C1
  DownRightVectorBar; U+02957
  DownTee; U+022A4
  DownTeeArrow; U+021A7
  drbkarow; U+02910
  drcorn; U+0231F
  drcrop; U+0230C
  Dscr; U+1D49F
  dscr; U+1D4B9
  DScy; U+00405
  dscy; U+00455
  dsol; U+029F6
  Dstrok; U+00110
  dstrok; U+00111
  dtdot; U+022F1
  dtri; U+025BF
  dtrif; U+025BE
  duarr; U+021F5
  duhar; U+0296F
  dwangle; U+029A6
  DZcy; U+0040F
  dzcy; U+0045F
  dzigrarr; U+027FF
  Eacute; U+000C9
  Eacute U+000C9
  eacute; U+000E9
  eacute U+000E9
  easter; U+02A6E
  Ecaron; U+0011A
  ecaron; U+0011B
  ecir; U+02256
  Ecirc; U+000CA
  Ecirc U+000CA
  ecirc; U+000EA
  ecirc U+000EA
  ecolon; U+02255
  Ecy; U+0042D
  ecy; U+0044D
  eDDot; U+02A77
  Edot; U+00116
  eDot; U+02251
  edot; U+00117
  ee; U+02147
  efDot; U+02252
  Efr; U+1D508
  efr; U+1D522
  eg; U+02A9A
  Egrave; U+000C8
  Egrave U+000C8
  egrave; U+000E8
  egrave U+000E8
  egs; U+02A96
  egsdot; U+02A98
  el; U+02A99
  Element; U+02208
  elinters; U+023E7
  ell; U+02113
  els; U+02A95
  elsdot; U+02A97
  Emacr; U+00112
  emacr; U+00113
  empty; U+02205
  emptyset; U+02205
  EmptySmallSquare; U+025FB
  emptyv; U+02205
  EmptyVerySmallSquare; U+025AB
  emsp; U+02003
  emsp13; U+02004
  emsp14; U+02005
  ENG; U+0014A
  eng; U+0014B
  ensp; U+02002
  Eogon; U+00118
  eogon; U+00119
  Eopf; U+1D53C
  eopf; U+1D556
  epar; U+022D5
  eparsl; U+029E3
  eplus; U+02A71
  epsi; U+003B5
  Epsilon; U+00395
  epsilon; U+003B5
  epsiv; U+003F5
  eqcirc; U+02256
  eqcolon; U+02255
  eqsim; U+02242
  eqslantgtr; U+02A96
  eqslantless; U+02A95
  Equal; U+02A75
  equals; U+0003D
  EqualTilde; U+02242
  equest; U+0225F
  Equilibrium; U+021CC
  equiv; U+02261
  equivDD; U+02A78
  eqvparsl; U+029E5
  erarr; U+02971
  erDot; U+02253
  Escr; U+02130
  escr; U+0212F
  esdot; U+02250
  Esim; U+02A73
  esim; U+02242
  Eta; U+00397
  eta; U+003B7
  ETH; U+000D0
  ETH U+000D0
  eth; U+000F0
  eth U+000F0
  Euml; U+000CB
  Euml U+000CB
  euml; U+000EB
  euml U+000EB
  euro; U+020AC
  excl; U+00021
  exist; U+02203
  Exists; U+02203
  expectation; U+02130
  ExponentialE; U+02147
  exponentiale; U+02147
  fallingdotseq; U+02252
  Fcy; U+00424
  fcy; U+00444
  female; U+02640
  ffilig; U+0FB03
  fflig; U+0FB00
  ffllig; U+0FB04
  Ffr; U+1D509
  ffr; U+1D523
  filig; U+0FB01
  FilledSmallSquare; U+025FC
  FilledVerySmallSquare; U+025AA
  fjlig; U+00066 U+0006A
  flat; U+0266D
  fllig; U+0FB02
  fltns; U+025B1
  fnof; U+00192
  Fopf; U+1D53D
  fopf; U+1D557
  ForAll; U+02200
  forall; U+02200
  fork; U+022D4
  forkv; U+02AD9
  Fouriertrf; U+02131
  fpartint; U+02A0D
  frac12; U+000BD
  frac12 U+000BD
  frac13; U+02153
  frac14; U+000BC
  frac14 U+000BC
  frac15; U+02155
  frac16; U+02159
  frac18; U+0215B
  frac23; U+02154
  frac25; U+02156
  frac34; U+000BE
  frac34 U+000BE
  frac35; U+02157
  frac38; U+0215C
  frac45; U+02158
  frac56; U+0215A
  frac58; U+0215D
  frac78; U+0215E
  frasl; U+02044
  frown; U+02322
  Fscr; U+02131
  fscr; U+1D4BB
  gacute; U+001F5
  Gamma; U+00393
  gamma; U+003B3
  Gammad; U+003DC
  gammad; U+003DD
  gap; U+02A86
  Gbreve; U+0011E
  gbreve; U+0011F
  Gcedil; U+00122
  Gcirc; U+0011C
  gcirc; U+0011D
  Gcy; U+00413
  gcy; U+00433
  Gdot; U+00120
  gdot; U+00121
  gE; U+02267
  ge; U+02265
  gEl; U+02A8C
  gel; U+022DB
  geq; U+02265
  geqq; U+02267
  geqslant; U+02A7E
  ges; U+02A7E
  gescc; U+02AA9
  gesdot; U+02A80
  gesdoto; U+02A82
  gesdotol; U+02A84
  gesl; U+022DB U+0FE00
  gesles; U+02A94
  Gfr; U+1D50A
  gfr; U+1D524
  Gg; U+022D9
  gg; U+0226B
  ggg; U+022D9
  gimel; U+02137
  GJcy; U+00403
  gjcy; U+00453
  gl; U+02277
  gla; U+02AA5
  glE; U+02A92
  glj; U+02AA4
  gnap; U+02A8A
  gnapprox; U+02A8A
  gnE; U+02269
  gne; U+02A88
  gneq; U+02A88
  gneqq; U+02269
  gnsim; U+022E7
  Gopf; U+1D53E
  gopf; U+1D558
  grave; U+00060
  GreaterEqual; U+02265
  GreaterEqualLess; U+022DB
  GreaterFullEqual; U+02267
  GreaterGreater; U+02AA2
  GreaterLess; U+02277
  GreaterSlantEqual; U+02A7E
  GreaterTilde; U+02273
  Gscr; U+1D4A2
  gscr; U+0210A
  gsim; U+02273
  gsime; U+02A8E
  gsiml; U+02A90
  GT; U+0003E
  GT U+0003E
  Gt; U+0226B
  gt; U+0003E
  gt U+0003E
  gtcc; U+02AA7
  gtcir; U+02A7A
  gtdot; U+022D7
  gtlPar; U+02995
  gtquest; U+02A7C
  gtrapprox; U+02A86
  gtrarr; U+02978
  gtrdot; U+022D7
  gtreqless; U+022DB
  gtreqqless; U+02A8C
  gtrless; U+02277
  gtrsim; U+02273
  gvertneqq; U+02269 U+0FE00
  gvnE; U+02269 U+0FE00
  Hacek; U+002C7
  hairsp; U+0200A
  half; U+000BD
  hamilt; U+0210B
  HARDcy; U+0042A
  hardcy; U+0044A
  hArr; U+021D4
  harr; U+02194
  harrcir; U+02948
  harrw; U+021AD
  Hat; U+0005E
  hbar; U+0210F
  Hcirc; U+00124
  hcirc; U+00125
  hearts; U+02665
  heartsuit; U+02665
  hellip; U+02026
  hercon; U+022B9
  Hfr; U+0210C
  hfr; U+1D525
  HilbertSpace; U+0210B
  hksearow; U+02925
  hkswarow; U+02926
  hoarr; U+021FF
  homtht; U+0223B
  hookleftarrow; U+021A9
  hookrightarrow; U+021AA
  Hopf; U+0210D
  hopf; U+1D559
  horbar; U+02015
  HorizontalLine; U+02500
  Hscr; U+0210B
  hscr; U+1D4BD
  hslash; U+0210F
  Hstrok; U+00126
  hstrok; U+00127
  HumpDownHump; U+0224E
  HumpEqual; U+0224F
  hybull; U+02043
  hyphen; U+02010
  Iacute; U+000CD
  Iacute U+000CD
  iacute; U+000ED
  iacute U+000ED
  ic; U+02063
  Icirc; U+000CE
  Icirc U+000CE
  icirc; U+000EE
  icirc U+000EE
  Icy; U+00418
  icy; U+00438
  Idot; U+00130
  IEcy; U+00415
  iecy; U+00435
  iexcl; U+000A1
  iexcl U+000A1
  iff; U+021D4
  Ifr; U+02111
  ifr; U+1D526
  Igrave; U+000CC
  Igrave U+000CC
  igrave; U+000EC
  igrave U+000EC
  ii; U+02148
  iiiint; U+02A0C
  iiint; U+0222D
  iinfin; U+029DC
  iiota; U+02129
  IJlig; U+00132
  ijlig; U+00133
  Im; U+02111
  Imacr; U+0012A
  imacr; U+0012B
  image; U+02111
  ImaginaryI; U+02148
  imagline; U+02110
  imagpart; U+02111
  imath; U+00131
  imof; U+022B7
  imped; U+001B5
  Implies; U+021D2
  in; U+02208
  incare; U+02105
  infin; U+0221E
  infintie; U+029DD
  inodot; U+00131
  Int; U+0222C
  int; U+0222B
  intcal; U+022BA
  integers; U+02124
  Integral; U+0222B
  intercal; U+022BA
  Intersection; U+022C2
  intlarhk; U+02A17
  intprod; U+02A3C
  InvisibleComma; U+02063
  InvisibleTimes; U+02062
  IOcy; U+00401
  iocy; U+00451
  Iogon; U+0012E
  iogon; U+0012F
  Iopf; U+1D540
  iopf; U+1D55A
  Iota; U+00399
  iota; U+003B9
  iprod; U+02A3C
  iquest; U+000BF
  iquest U+000BF
  Iscr; U+02110
  iscr; U+1D4BE
  isin; U+02208
  isindot; U+022F5
  isinE; U+022F9
  isins; U+022F4
  isinsv; U+022F3
  isinv; U+02208
  it; U+02062
  Itilde; U+00128
  itilde; U+00129
  Iukcy; U+00406
  iukcy; U+00456
  Iuml; U+000CF
  Iuml U+000CF
  iuml; U+000EF
  iuml U+000EF
  Jcirc; U+00134
  jcirc; U+00135
  Jcy; U+00419
  jcy; U+00439
  Jfr; U+1D50D
  jfr; U+1D527
  jmath; U+00237
  Jopf; U+1D541
  jopf; U+1D55B
  Jscr; U+1D4A5
  jscr; U+1D4BF
  Jsercy; U+00408
  jsercy; U+00458
  Jukcy; U+00404
  jukcy; U+00454
  Kappa; U+0039A
  kappa; U+003BA
  kappav; U+003F0
  Kcedil; U+00136
  kcedil; U+00137
  Kcy; U+0041A
  kcy; U+0043A
  Kfr; U+1D50E
  kfr; U+1D528
  kgreen; U+00138
  KHcy; U+00425
  khcy; U+00445
  KJcy; U+0040C
  kjcy; U+0045C
  Kopf; U+1D542
  kopf; U+1D55C
  Kscr; U+1D4A6
  kscr; U+1D4C0
  lAarr; U+021DA
  Lacute; U+00139
  lacute; U+0013A
  laemptyv; U+029B4
  lagran; U+02112
  Lambda; U+0039B
  lambda; U+003BB
  Lang; U+027EA
  lang; U+027E8
  langd; U+02991
  langle; U+027E8
  lap; U+02A85
  Laplacetrf; U+02112
  laquo; U+000AB
  laquo U+000AB
  Larr; U+0219E
  lArr; U+021D0
  larr; U+02190
  larrb; U+021E4
  larrbfs; U+0291F
  larrfs; U+0291D
  larrhk; U+021A9
  larrlp; U+021AB
  larrpl; U+02939
  larrsim; U+02973
  larrtl; U+021A2
  lat; U+02AAB
  lAtail; U+0291B
  latail; U+02919
  late; U+02AAD
  lates; U+02AAD U+0FE00
  lBarr; U+0290E
  lbarr; U+0290C
  lbbrk; U+02772
  lbrace; U+0007B
  lbrack; U+0005B
  lbrke; U+0298B
  lbrksld; U+0298F
  lbrkslu; U+0298D
  Lcaron; U+0013D
  lcaron; U+0013E
  Lcedil; U+0013B
  lcedil; U+0013C
  lceil; U+02308
  lcub; U+0007B
  Lcy; U+0041B
  lcy; U+0043B
  ldca; U+02936
  ldquo; U+0201C
  ldquor; U+0201E
  ldrdhar; U+02967
  ldrushar; U+0294B
  ldsh; U+021B2
  lE; U+02266
  le; U+02264
  LeftAngleBracket; U+027E8
  LeftArrow; U+02190
  Leftarrow; U+021D0
  leftarrow; U+02190
  LeftArrowBar; U+021E4
  LeftArrowRightArrow; U+021C6
  leftarrowtail; U+021A2
  LeftCeiling; U+02308
  LeftDoubleBracket; U+027E6
  LeftDownTeeVector; U+02961
  LeftDownVector; U+021C3
  LeftDownVectorBar; U+02959
  LeftFloor; U+0230A
  leftharpoondown; U+021BD
  leftharpoonup; U+021BC
  leftleftarrows; U+021C7
  LeftRightArrow; U+02194
  Leftrightarrow; U+021D4
  leftrightarrow; U+02194
  leftrightarrows; U+021C6
  leftrightharpoons; U+021CB
  leftrightsquigarrow; U+021AD
  LeftRightVector; U+0294E
  LeftTee; U+022A3
  LeftTeeArrow; U+021A4
  LeftTeeVector; U+0295A
  leftthreetimes; U+022CB
  LeftTriangle; U+022B2
  LeftTriangleBar; U+029CF
  LeftTriangleEqual; U+022B4
  LeftUpDownVector; U+02951
  LeftUpTeeVector; U+02960
  LeftUpVector; U+021BF
  LeftUpVectorBar; U+02958
  LeftVector; U+021BC
  LeftVectorBar; U+02952
  lEg; U+02A8B
  leg; U+022DA
  leq; U+02264
  leqq; U+02266
  leqslant; U+02A7D
  les; U+02A7D
  lescc; U+02AA8
  lesdot; U+02A7F
  lesdoto; U+02A81
  lesdotor; U+02A83
  lesg; U+022DA U+0FE00
  lesges; U+02A93
  lessapprox; U+02A85
  lessdot; U+022D6
  lesseqgtr; U+022DA
  lesseqqgtr; U+02A8B
  LessEqualGreater; U+022DA
  LessFullEqual; U+02266
  LessGreater; U+02276
  lessgtr; U+02276
  LessLess; U+02AA1
  lesssim; U+02272
  LessSlantEqual; U+02A7D
  LessTilde; U+02272
  lfisht; U+0297C
  lfloor; U+0230A
  Lfr; U+1D50F
  lfr; U+1D529
  lg; U+02276
  lgE; U+02A91
  lHar; U+02962
  lhard; U+021BD
  lharu; U+021BC
  lharul; U+0296A
  lhblk; U+02584
  LJcy; U+00409
  ljcy; U+00459
  Ll; U+022D8
  ll; U+0226A
  llarr; U+021C7
  llcorner; U+0231E
  Lleftarrow; U+021DA
  llhard; U+0296B
  lltri; U+025FA
  Lmidot; U+0013F
  lmidot; U+00140
  lmoust; U+023B0
  lmoustache; U+023B0
  lnap; U+02A89
  lnapprox; U+02A89
  lnE; U+02268
  lne; U+02A87
  lneq; U+02A87
  lneqq; U+02268
  lnsim; U+022E6
  loang; U+027EC
  loarr; U+021FD
  lobrk; U+027E6
  LongLeftArrow; U+027F5
  Longleftarrow; U+027F8
  longleftarrow; U+027F5
  LongLeftRightArrow; U+027F7
  Longleftrightarrow; U+027FA
  longleftrightarrow; U+027F7
  longmapsto; U+027FC
  LongRightArrow; U+027F6
  Longrightarrow; U+027F9
  longrightarrow; U+027F6
  looparrowleft; U+021AB
  looparrowright; U+021AC
  lopar; U+02985
  Lopf; U+1D543
  lopf; U+1D55D
  loplus; U+02A2D
  lotimes; U+02A34
  lowast; U+02217
  lowbar; U+0005F
  LowerLeftArrow; U+02199
  LowerRightArrow; U+02198
  loz; U+025CA
  lozenge; U+025CA
  lozf; U+029EB
  lpar; U+00028
  lparlt; U+02993
  lrarr; U+021C6
  lrcorner; U+0231F
  lrhar; U+021CB
  lrhard; U+0296D
  lrm; U+0200E
  lrtri; U+022BF
  lsaquo; U+02039
  Lscr; U+02112
  lscr; U+1D4C1
  Lsh; U+021B0
  lsh; U+021B0
  lsim; U+02272
  lsime; U+02A8D
  lsimg; U+02A8F
  lsqb; U+0005B
  lsquo; U+02018
  lsquor; U+0201A
  Lstrok; U+00141
  lstrok; U+00142
  LT; U+0003C
  LT U+0003C
  Lt; U+0226A
  lt; U+0003C
  lt U+0003C
  ltcc; U+02AA6
  ltcir; U+02A79
  ltdot; U+022D6
  lthree; U+022CB
  ltimes; U+022C9
  ltlarr; U+02976
  ltquest; U+02A7B
  ltri; U+025C3
  ltrie; U+022B4
  ltrif; U+025C2
  ltrPar; U+02996
  lurdshar; U+0294A
  luruhar; U+02966
  lvertneqq; U+02268 U+0FE00
  lvnE; U+02268 U+0FE00
  macr; U+000AF
  macr U+000AF
  male; U+02642
  malt; U+02720
  maltese; U+02720
  Map; U+02905
  map; U+021A6
  mapsto; U+021A6
  mapstodown; U+021A7
  mapstoleft; U+021A4
  mapstoup; U+021A5
  marker; U+025AE
  mcomma; U+02A29
  Mcy; U+0041C
  mcy; U+0043C
  mdash; U+02014
  mDDot; U+0223A
  measuredangle; U+02221
  MediumSpace; U+0205F
  Mellintrf; U+02133
  Mfr; U+1D510
  mfr; U+1D52A
  mho; U+02127
  micro; U+000B5
  micro U+000B5
  mid; U+02223
  midast; U+0002A
  midcir; U+02AF0
  middot; U+000B7
  middot U+000B7
  minus; U+02212
  minusb; U+0229F
  minusd; U+02238
  minusdu; U+02A2A
  MinusPlus; U+02213
  mlcp; U+02ADB
  mldr; U+02026
  mnplus; U+02213
  models; U+022A7
  Mopf; U+1D544
  mopf; U+1D55E
  mp; U+02213
  Mscr; U+02133
  mscr; U+1D4C2
  mstpos; U+0223E
  Mu; U+0039C
  mu; U+003BC
  multimap; U+022B8
  mumap; U+022B8
  nabla; U+02207
  Nacute; U+00143
  nacute; U+00144
  nang; U+02220 U+020D2
  nap; U+02249
  napE; U+02A70 U+00338
  napid; U+0224B U+00338
  napos; U+00149
  napprox; U+02249
  natur; U+0266E
  natural; U+0266E
  naturals; U+02115
  nbsp; U+000A0
  nbsp U+000A0
  nbump; U+0224E U+00338
  nbumpe; U+0224F U+00338
  ncap; U+02A43
  Ncaron; U+00147
  ncaron; U+00148
  Ncedil; U+00145
  ncedil; U+00146
  ncong; U+02247
  ncongdot; U+02A6D U+00338
  ncup; U+02A42
  Ncy; U+0041D
  ncy; U+0043D
  ndash; U+02013
  ne; U+02260
  nearhk; U+02924
  neArr; U+021D7
  nearr; U+02197
  nearrow; U+02197
  nedot; U+02250 U+00338
  NegativeMediumSpace; U+0200B
  NegativeThickSpace; U+0200B
  NegativeThinSpace; U+0200B
  NegativeVeryThinSpace; U+0200B
  nequiv; U+02262
  nesear; U+02928
  nesim; U+02242 U+00338
  NestedGreaterGreater; U+0226B
  NestedLessLess; U+0226A
  NewLine; U+0000A
  nexist; U+02204
  nexists; U+02204
  Nfr; U+1D511
  nfr; U+1D52B
  ngE; U+02267 U+00338
  nge; U+02271
  ngeq; U+02271
  ngeqq; U+02267 U+00338
  ngeqslant; U+02A7E U+00338
  nges; U+02A7E U+00338
  nGg; U+022D9 U+00338
  ngsim; U+02275
  nGt; U+0226B U+020D2
  ngt; U+0226F
  ngtr; U+0226F
  nGtv; U+0226B U+00338
  nhArr; U+021CE
  nharr; U+021AE
  nhpar; U+02AF2
  ni; U+0220B
  nis; U+022FC
  nisd; U+022FA
  niv; U+0220B
  NJcy; U+0040A
  njcy; U+0045A
  nlArr; U+021CD
  nlarr; U+0219A
  nldr; U+02025
  nlE; U+02266 U+00338
  nle; U+02270
  nLeftarrow; U+021CD
  nleftarrow; U+0219A
  nLeftrightarrow; U+021CE
  nleftrightarrow; U+021AE
  nleq; U+02270
  nleqq; U+02266 U+00338
  nleqslant; U+02A7D U+00338
  nles; U+02A7D U+00338
  nless; U+0226E
  nLl; U+022D8 U+00338
  nlsim; U+02274
  nLt; U+0226A U+020D2
  nlt; U+0226E
  nltri; U+022EA
  nltrie; U+022EC
  nLtv; U+0226A U+00338
  nmid; U+02224
  NoBreak; U+02060
  NonBreakingSpace; U+000A0
  Nopf; U+02115
  nopf; U+1D55F
  Not; U+02AEC
  not; U+000AC
  not U+000AC
  NotCongruent; U+02262
  NotCupCap; U+0226D
  NotDoubleVerticalBar; U+02226
  NotElement; U+02209
  NotEqual; U+02260
  NotEqualTilde; U+02242 U+00338
  NotExists; U+02204
  NotGreater; U+0226F
  NotGreaterEqual; U+02271
  NotGreaterFullEqual; U+02267 U+00338
  NotGreaterGreater; U+0226B U+00338
  NotGreaterLess; U+02279
  NotGreaterSlantEqual; U+02A7E U+00338
  NotGreaterTilde; U+02275
  NotHumpDownHump; U+0224E U+00338
  NotHumpEqual; U+0224F U+00338
  notin; U+02209
  notindot; U+022F5 U+00338
  notinE; U+022F9 U+00338
  notinva; U+02209
  notinvb; U+022F7
  notinvc; U+022F6
  NotLeftTriangle; U+022EA
  NotLeftTriangleBar; U+029CF U+00338
  NotLeftTriangleEqual; U+022EC
  NotLess; U+0226E
  NotLessEqual; U+02270
  NotLessGreater; U+02278
  NotLessLess; U+0226A U+00338
  NotLessSlantEqual; U+02A7D U+00338
  NotLessTilde; U+02274
  NotNestedGreaterGreater; U+02AA2 U+00338
  NotNestedLessLess; U+02AA1 U+00338
  notni; U+0220C
  notniva; U+0220C
  notnivb; U+022FE
  notnivc; U+022FD
  NotPrecedes; U+02280
  NotPrecedesEqual; U+02AAF U+00338
  NotPrecedesSlantEqual; U+022E0
  NotReverseElement; U+0220C
  NotRightTriangle; U+022EB
  NotRightTriangleBar; U+029D0 U+00338
  NotRightTriangleEqual; U+022ED
  NotSquareSubset; U+0228F U+00338
  NotSquareSubsetEqual; U+022E2
  NotSquareSuperset; U+02290 U+00338
  NotSquareSupersetEqual; U+022E3
  NotSubset; U+02282 U+020D2
  NotSubsetEqual; U+02288
  NotSucceeds; U+02281
  NotSucceedsEqual; U+02AB0 U+00338
  NotSucceedsSlantEqual; U+022E1
  NotSucceedsTilde; U+0227F U+00338
  NotSuperset; U+02283 U+020D2
  NotSupersetEqual; U+02289
  NotTilde; U+02241
  NotTildeEqual; U+02244
  NotTildeFullEqual; U+02247
  NotTildeTilde; U+02249
  NotVerticalBar; U+02224
  npar; U+02226
  nparallel; U+02226
  nparsl; U+02AFD U+020E5
  npart; U+02202 U+00338
  npolint; U+02A14
  npr; U+02280
  nprcue; U+022E0
  npre; U+02AAF U+00338
  nprec; U+02280
  npreceq; U+02AAF U+00338
  nrArr; U+021CF
  nrarr; U+0219B
  nrarrc; U+02933 U+00338
  nrarrw; U+0219D U+00338
  nRightarrow; U+021CF
  nrightarrow; U+0219B
  nrtri; U+022EB
  nrtrie; U+022ED
  nsc; U+02281
  nsccue; U+022E1
  nsce; U+02AB0 U+00338
  Nscr; U+1D4A9
  nscr; U+1D4C3
  nshortmid; U+02224
  nshortparallel; U+02226
  nsim; U+02241
  nsime; U+02244
  nsimeq; U+02244
  nsmid; U+02224
  nspar; U+02226
  nsqsube; U+022E2
  nsqsupe; U+022E3
  nsub; U+02284
  nsubE; U+02AC5 U+00338
  nsube; U+02288
  nsubset; U+02282 U+020D2
  nsubseteq; U+02288
  nsubseteqq; U+02AC5 U+00338
  nsucc; U+02281
  nsucceq; U+02AB0 U+00338
  nsup; U+02285
  nsupE; U+02AC6 U+00338
  nsupe; U+02289
  nsupset; U+02283 U+020D2
  nsupseteq; U+02289
  nsupseteqq; U+02AC6 U+00338
  ntgl; U+02279
  Ntilde; U+000D1
  Ntilde U+000D1
  ntilde; U+000F1
  ntilde U+000F1
  ntlg; U+02278
  ntriangleleft; U+022EA
  ntrianglelefteq; U+022EC
  ntriangleright; U+022EB
  ntrianglerighteq; U+022ED
  Nu; U+0039D
  nu; U+003BD
  num; U+00023
  numero; U+02116
  numsp; U+02007
  nvap; U+0224D U+020D2
  nVDash; U+022AF
  nVdash; U+022AE
  nvDash; U+022AD
  nvdash; U+022AC
  nvge; U+02265 U+020D2
  nvgt; U+0003E U+020D2
  nvHarr; U+02904
  nvinfin; U+029DE
  nvlArr; U+02902
  nvle; U+02264 U+020D2
  nvlt; U+0003C U+020D2
  nvltrie; U+022B4 U+020D2
  nvrArr; U+02903
  nvrtrie; U+022B5 U+020D2
  nvsim; U+0223C U+020D2
  nwarhk; U+02923
  nwArr; U+021D6
  nwarr; U+02196
  nwarrow; U+02196
  nwnear; U+02927
  Oacute; U+000D3
  Oacute U+000D3
  oacute; U+000F3
  oacute U+000F3
  oast; U+0229B
  ocir; U+0229A
  Ocirc; U+000D4
  Ocirc U+000D4
  ocirc; U+000F4
  ocirc U+000F4
  Ocy; U+0041E
  ocy; U+0043E
  odash; U+0229D
  Odblac; U+00150
  odblac; U+00151
  odiv; U+02A38
  odot; U+02299
  odsold; U+029BC
  OElig; U+00152
  oelig; U+00153
  ofcir; U+029BF
  Ofr; U+1D512
  ofr; U+1D52C
  ogon; U+002DB
  Ograve; U+000D2
  Ograve U+000D2
  ograve; U+000F2
  ograve U+000F2
  ogt; U+029C1
  ohbar; U+029B5
  ohm; U+003A9
  oint; U+0222E
  olarr; U+021BA
  olcir; U+029BE
  olcross; U+029BB
  oline; U+0203E
  olt; U+029C0
  Omacr; U+0014C
  omacr; U+0014D
  Omega; U+003A9
  omega; U+003C9
  Omicron; U+0039F
  omicron; U+003BF
  omid; U+029B6
  ominus; U+02296
  Oopf; U+1D546
  oopf; U+1D560
  opar; U+029B7
  OpenCurlyDoubleQuote; U+0201C
  OpenCurlyQuote; U+02018
  operp; U+029B9
  oplus; U+02295
  Or; U+02A54
  or; U+02228
  orarr; U+021BB
  ord; U+02A5D
  order; U+02134
  orderof; U+02134
  ordf; U+000AA
  ordf U+000AA
  ordm; U+000BA
  ordm U+000BA
  origof; U+022B6
  oror; U+02A56
  orslope; U+02A57
  orv; U+02A5B
  oS; U+024C8
  Oscr; U+1D4AA
  oscr; U+02134
  Oslash; U+000D8
  Oslash U+000D8
  oslash; U+000F8
  oslash U+000F8
  osol; U+02298
  Otilde; U+000D5
  Otilde U+000D5
  otilde; U+000F5
  otilde U+000F5
  Otimes; U+02A37
  otimes; U+02297
  otimesas; U+02A36
  Ouml; U+000D6
  Ouml U+000D6
  ouml; U+000F6
  ouml U+000F6
  ovbar; U+0233D
  OverBar; U+0203E
  OverBrace; U+023DE
  OverBracket; U+023B4
  OverParenthesis; U+023DC
  par; U+02225
  para; U+000B6
  para U+000B6
  parallel; U+02225
  parsim; U+02AF3
  parsl; U+02AFD
  part; U+02202
  PartialD; U+02202
  Pcy; U+0041F
  pcy; U+0043F
  percnt; U+00025
  period; U+0002E
  permil; U+02030
  perp; U+022A5
  pertenk; U+02031
  Pfr; U+1D513
  pfr; U+1D52D
  Phi; U+003A6
  phi; U+003C6
  phiv; U+003D5
  phmmat; U+02133
  phone; U+0260E
  Pi; U+003A0
  pi; U+003C0
  pitchfork; U+022D4
  piv; U+003D6
  planck; U+0210F
  planckh; U+0210E
  plankv; U+0210F
  plus; U+0002B
  plusacir; U+02A23
  plusb; U+0229E
  pluscir; U+02A22
  plusdo; U+02214
  plusdu; U+02A25
  pluse; U+02A72
  PlusMinus; U+000B1
  plusmn; U+000B1
  plusmn U+000B1
  plussim; U+02A26
  plustwo; U+02A27
  pm; U+000B1
  Poincareplane; U+0210C
  pointint; U+02A15
  Popf; U+02119
  popf; U+1D561
  pound; U+000A3
  pound U+000A3
  Pr; U+02ABB
  pr; U+0227A
  prap; U+02AB7
  prcue; U+0227C
  prE; U+02AB3
  pre; U+02AAF
  prec; U+0227A
  precapprox; U+02AB7
  preccurlyeq; U+0227C
  Precedes; U+0227A
  PrecedesEqual; U+02AAF
  PrecedesSlantEqual; U+0227C
  PrecedesTilde; U+0227E
  preceq; U+02AAF
  precnapprox; U+02AB9
  precneqq; U+02AB5
  precnsim; U+022E8
  precsim; U+0227E
  Prime; U+02033
  prime; U+02032
  primes; U+02119
  prnap; U+02AB9
  prnE; U+02AB5
  prnsim; U+022E8
  prod; U+0220F
  Product; U+0220F
  profalar; U+0232E
  profline; U+02312
  profsurf; U+02313
  prop; U+0221D
  Proportion; U+02237
  Proportional; U+0221D
  propto; U+0221D
  prsim; U+0227E
  prurel; U+022B0
  Pscr; U+1D4AB
  pscr; U+1D4C5
  Psi; U+003A8
  psi; U+003C8
  puncsp; U+02008
  Qfr; U+1D514
  qfr; U+1D52E
  qint; U+02A0C
  Qopf; U+0211A
  qopf; U+1D562
  qprime; U+02057
  Qscr; U+1D4AC
  qscr; U+1D4C6
  quaternions; U+0210D
  quatint; U+02A16
  quest; U+0003F
  questeq; U+0225F
  QUOT; U+00022
  QUOT U+00022
  quot; U+00022
  quot U+00022
  rAarr; U+021DB
  race; U+0223D U+00331
  Racute; U+00154
  racute; U+00155
  radic; U+0221A
  raemptyv; U+029B3
  Rang; U+027EB
  rang; U+027E9
  rangd; U+02992
  range; U+029A5
  rangle; U+027E9
  raquo; U+000BB
  raquo U+000BB
  Rarr; U+021A0
  rArr; U+021D2
  rarr; U+02192
  rarrap; U+02975
  rarrb; U+021E5
  rarrbfs; U+02920
  rarrc; U+02933
  rarrfs; U+0291E
  rarrhk; U+021AA
  rarrlp; U+021AC
  rarrpl; U+02945
  rarrsim; U+02974
  Rarrtl; U+02916
  rarrtl; U+021A3
  rarrw; U+0219D
  rAtail; U+0291C
  ratail; U+0291A
  ratio; U+02236
  rationals; U+0211A
  RBarr; U+02910
  rBarr; U+0290F
  rbarr; U+0290D
  rbbrk; U+02773
  rbrace; U+0007D
  rbrack; U+0005D
  rbrke; U+0298C
  rbrksld; U+0298E
  rbrkslu; U+02990
  Rcaron; U+00158
  rcaron; U+00159
  Rcedil; U+00156
  rcedil; U+00157
  rceil; U+02309
  rcub; U+0007D
  Rcy; U+00420
  rcy; U+00440
  rdca; U+02937
  rdldhar; U+02969
  rdquo; U+0201D
  rdquor; U+0201D
  rdsh; U+021B3
  Re; U+0211C
  real; U+0211C
  realine; U+0211B
  realpart; U+0211C
  reals; U+0211D
  rect; U+025AD
  REG; U+000AE
  REG U+000AE
  reg; U+000AE
  reg U+000AE
  ReverseElement; U+0220B
  ReverseEquilibrium; U+021CB
  ReverseUpEquilibrium; U+0296F
  rfisht; U+0297D
  rfloor; U+0230B
  Rfr; U+0211C
  rfr; U+1D52F
  rHar; U+02964
  rhard; U+021C1
  rharu; U+021C0
  rharul; U+0296C
  Rho; U+003A1
  rho; U+003C1
  rhov; U+003F1
  RightAngleBracket; U+027E9
  RightArrow; U+02192
  Rightarrow; U+021D2
  rightarrow; U+02192
  RightArrowBar; U+021E5
  RightArrowLeftArrow; U+021C4
  rightarrowtail; U+021A3
  RightCeiling; U+02309
  RightDoubleBracket; U+027E7
  RightDownTeeVector; U+0295D
  RightDownVector; U+021C2
  RightDownVectorBar; U+02955
  RightFloor; U+0230B
  rightharpoondown; U+021C1
  rightharpoonup; U+021C0
  rightleftarrows; U+021C4
  rightleftharpoons; U+021CC
  rightrightarrows; U+021C9
  rightsquigarrow; U+0219D
  RightTee; U+022A2
  RightTeeArrow; U+021A6
  RightTeeVector; U+0295B
  rightthreetimes; U+022CC
  RightTriangle; U+022B3
  RightTriangleBar; U+029D0
  RightTriangleEqual; U+022B5
  RightUpDownVector; U+0294F
  RightUpTeeVector; U+0295C
  RightUpVector; U+021BE
  RightUpVectorBar; U+02954
  RightVector; U+021C0
  RightVectorBar; U+02953
  ring; U+002DA
  risingdotseq; U+02253
  rlarr; U+021C4
  rlhar; U+021CC
  rlm; U+0200F
  rmoust; U+023B1
  rmoustache; U+023B1
  rnmid; U+02AEE
  roang; U+027ED
  roarr; U+021FE
  robrk; U+027E7
  ropar; U+02986
  Ropf; U+0211D
  ropf; U+1D563
  roplus; U+02A2E
  rotimes; U+02A35
  RoundImplies; U+02970
  rpar; U+00029
  rpargt; U+02994
  rppolint; U+02A12
  rrarr; U+021C9
  Rrightarrow; U+021DB
  rsaquo; U+0203A
  Rscr; U+0211B
  rscr; U+1D4C7
  Rsh; U+021B1
  rsh; U+021B1
  rsqb; U+0005D
  rsquo; U+02019
  rsquor; U+02019
  rthree; U+022CC
  rtimes; U+022CA
  rtri; U+025B9
  rtrie; U+022B5
  rtrif; U+025B8
  rtriltri; U+029CE
  RuleDelayed; U+029F4
  ruluhar; U+02968
  rx; U+0211E
  Sacute; U+0015A
  sacute; U+0015B
  sbquo; U+0201A
  Sc; U+02ABC
  sc; U+0227B
  scap; U+02AB8
  Scaron; U+00160
  scaron; U+00161
  sccue; U+0227D
  scE; U+02AB4
  sce; U+02AB0
  Scedil; U+0015E
  scedil; U+0015F
  Scirc; U+0015C
  scirc; U+0015D
  scnap; U+02ABA
  scnE; U+02AB6
  scnsim; U+022E9
  scpolint; U+02A13
  scsim; U+0227F
  Scy; U+00421
  scy; U+00441
  sdot; U+022C5
  sdotb; U+022A1
  sdote; U+02A66
  searhk; U+02925
  seArr; U+021D8
  searr; U+02198
  searrow; U+02198
  sect; U+000A7
  sect U+000A7
  semi; U+0003B
  seswar; U+02929
  setminus; U+02216
  setmn; U+02216
  sext; U+02736
  Sfr; U+1D516
  sfr; U+1D530
  sfrown; U+02322
  sharp; U+0266F
  SHCHcy; U+00429
  shchcy; U+00449
  SHcy; U+00428
  shcy; U+00448
  ShortDownArrow; U+02193
  ShortLeftArrow; U+02190
  shortmid; U+02223
  shortparallel; U+02225
  ShortRightArrow; U+02192
  ShortUpArrow; U+02191
  shy; U+000AD
  shy U+000AD
  Sigma; U+003A3
  sigma; U+003C3
  sigmaf; U+003C2
  sigmav; U+003C2
  sim; U+0223C
  simdot; U+02A6A
  sime; U+02243
  simeq; U+02243
  simg; U+02A9E
  simgE; U+02AA0
  siml; U+02A9D
  simlE; U+02A9F
  simne; U+02246
  simplus; U+02A24
  simrarr; U+02972
  slarr; U+02190
  SmallCircle; U+02218
  smallsetminus; U+02216
  smashp; U+02A33
  smeparsl; U+029E4
  smid; U+02223
  smile; U+02323
  smt; U+02AAA
  smte; U+02AAC
  smtes; U+02AAC U+0FE00
  SOFTcy; U+0042C
  softcy; U+0044C
  sol; U+0002F
  solb; U+029C4
  solbar; U+0233F
  Sopf; U+1D54A
  sopf; U+1D564
  spades; U+02660
  spadesuit; U+02660
  spar; U+02225
  sqcap; U+02293
  sqcaps; U+02293 U+0FE00
  sqcup; U+02294
  sqcups; U+02294 U+0FE00
  Sqrt; U+0221A
  sqsub; U+0228F
  sqsube; U+02291
  sqsubset; U+0228F
  sqsubseteq; U+02291
  sqsup; U+02290
  sqsupe; U+02292
  sqsupset; U+02290
  sqsupseteq; U+02292
  squ; U+025A1
  Square; U+025A1
  square; U+025A1
  SquareIntersection; U+02293
  SquareSubset; U+0228F
  SquareSubsetEqual; U+02291
  SquareSuperset; U+02290
  SquareSupersetEqual; U+02292
  SquareUnion; U+02294
  squarf; U+025AA
  squf; U+025AA
  srarr; U+02192
  Sscr; U+1D4AE
  sscr; U+1D4C8
  ssetmn; U+02216
  ssmile; U+02323
  sstarf; U+022C6
  Star; U+022C6
  star; U+02606
  starf; U+02605
  straightepsilon; U+003F5
  straightphi; U+003D5
  strns; U+000AF
  Sub; U+022D0
  sub; U+02282
  subdot; U+02ABD
  subE; U+02AC5
  sube; U+02286
  subedot; U+02AC3
  submult; U+02AC1
  subnE; U+02ACB
  subne; U+0228A
  subplus; U+02ABF
  subrarr; U+02979
  Subset; U+022D0
  subset; U+02282
  subseteq; U+02286
  subseteqq; U+02AC5
  SubsetEqual; U+02286
  subsetneq; U+0228A
  subsetneqq; U+02ACB
  subsim; U+02AC7
  subsub; U+02AD5
  subsup; U+02AD3
  succ; U+0227B
  succapprox; U+02AB8
  succcurlyeq; U+0227D
  Succeeds; U+0227B
  SucceedsEqual; U+02AB0
  SucceedsSlantEqual; U+0227D
  SucceedsTilde; U+0227F
  succeq; U+02AB0
  succnapprox; U+02ABA
  succneqq; U+02AB6
  succnsim; U+022E9
  succsim; U+0227F
  SuchThat; U+0220B
  Sum; U+02211
  sum; U+02211
  sung; U+0266A
  Sup; U+022D1
  sup; U+02283
  sup1; U+000B9
  sup1 U+000B9
  sup2; U+000B2
  sup2 U+000B2
  sup3; U+000B3
  sup3 U+000B3
  supdot; U+02ABE
  supdsub; U+02AD8
  supE; U+02AC6
  supe; U+02287
  supedot; U+02AC4
  Superset; U+02283
  SupersetEqual; U+02287
  suphsol; U+027C9
  suphsub; U+02AD7
  suplarr; U+0297B
  supmult; U+02AC2
  supnE; U+02ACC
  supne; U+0228B
  supplus; U+02AC0
  Supset; U+022D1
  supset; U+02283
  supseteq; U+02287
  supseteqq; U+02AC6
  supsetneq; U+0228B
  supsetneqq; U+02ACC
  supsim; U+02AC8
  supsub; U+02AD4
  supsup; U+02AD6
  swarhk; U+02926
  swArr; U+021D9
  swarr; U+02199
  swarrow; U+02199
  swnwar; U+0292A
  szlig; U+000DF
  szlig U+000DF
  Tab; U+00009
  target; U+02316
  Tau; U+003A4
  tau; U+003C4
  tbrk; U+023B4
  Tcaron; U+00164
  tcaron; U+00165
  Tcedil; U+00162
  tcedil; U+00163
  Tcy; U+00422
  tcy; U+00442
  tdot; U+020DB
  telrec; U+02315
  Tfr; U+1D517
  tfr; U+1D531
  there4; U+02234
  Therefore; U+02234
  therefore; U+02234
  Theta; U+00398
  theta; U+003B8
  thetasym; U+003D1
  thetav; U+003D1
  thickapprox; U+02248
  thicksim; U+0223C
  ThickSpace; U+0205F U+0200A
  thinsp; U+02009
  ThinSpace; U+02009
  thkap; U+02248
  thksim; U+0223C
  THORN; U+000DE
  THORN U+000DE
  thorn; U+000FE
  thorn U+000FE
  Tilde; U+0223C
  tilde; U+002DC
  TildeEqual; U+02243
  TildeFullEqual; U+02245
  TildeTilde; U+02248
  times; U+000D7
  times U+000D7
  timesb; U+022A0
  timesbar; U+02A31
  timesd; U+02A30
  tint; U+0222D
  toea; U+02928
  top; U+022A4
  topbot; U+02336
  topcir; U+02AF1
  Topf; U+1D54B
  topf; U+1D565
  topfork; U+02ADA
  tosa; U+02929
  tprime; U+02034
  TRADE; U+02122
  trade; U+02122
  triangle; U+025B5
  triangledown; U+025BF
  triangleleft; U+025C3
  trianglelefteq; U+022B4
  triangleq; U+0225C
  triangleright; U+025B9
  trianglerighteq; U+022B5
  tridot; U+025EC
  trie; U+0225C
  triminus; U+02A3A
  TripleDot; U+020DB
  triplus; U+02A39
  trisb; U+029CD
  tritime; U+02A3B
  trpezium; U+023E2
  Tscr; U+1D4AF
  tscr; U+1D4C9
  TScy; U+00426
  tscy; U+00446
  TSHcy; U+0040B
  tshcy; U+0045B
  Tstrok; U+00166
  tstrok; U+00167
  twixt; U+0226C
  twoheadleftarrow; U+0219E
  twoheadrightarrow; U+021A0
  Uacute; U+000DA
  Uacute U+000DA
  uacute; U+000FA
  uacute U+000FA
  Uarr; U+0219F
  uArr; U+021D1
  uarr; U+02191
  Uarrocir; U+02949
  Ubrcy; U+0040E
  ubrcy; U+0045E
  Ubreve; U+0016C
  ubreve; U+0016D
  Ucirc; U+000DB
  Ucirc U+000DB
  ucirc; U+000FB
  ucirc U+000FB
  Ucy; U+00423
  ucy; U+00443
  udarr; U+021C5
  Udblac; U+00170
  udblac; U+00171
  udhar; U+0296E
  ufisht; U+0297E
  Ufr; U+1D518
  ufr; U+1D532
  Ugrave; U+000D9
  Ugrave U+000D9
  ugrave; U+000F9
  ugrave U+000F9
  uHar; U+02963
  uharl; U+021BF
  uharr; U+021BE
  uhblk; U+02580
  ulcorn; U+0231C
  ulcorner; U+0231C
  ulcrop; U+0230F
  ultri; U+025F8
  Umacr; U+0016A
  umacr; U+0016B
  uml; U+000A8
  uml U+000A8
  UnderBar; U+0005F
  UnderBrace; U+023DF
  UnderBracket; U+023B5
  UnderParenthesis; U+023DD
  Union; U+022C3
  UnionPlus; U+0228E
  Uogon; U+00172
  uogon; U+00173
  Uopf; U+1D54C
  uopf; U+1D566
  UpArrow; U+02191
  Uparrow; U+021D1
  uparrow; U+02191
  UpArrowBar; U+02912
  UpArrowDownArrow; U+021C5
  UpDownArrow; U+02195
  Updownarrow; U+021D5
  updownarrow; U+02195
  UpEquilibrium; U+0296E
  upharpoonleft; U+021BF
  upharpoonright; U+021BE
  uplus; U+0228E
  UpperLeftArrow; U+02196
  UpperRightArrow; U+02197
  Upsi; U+003D2
  upsi; U+003C5
  upsih; U+003D2
  Upsilon; U+003A5
  upsilon; U+003C5
  UpTee; U+022A5
  UpTeeArrow; U+021A5
  upuparrows; U+021C8
  urcorn; U+0231D
  urcorner; U+0231D
  urcrop; U+0230E
  Uring; U+0016E
  uring; U+0016F
  urtri; U+025F9
  Uscr; U+1D4B0
  uscr; U+1D4CA
  utdot; U+022F0
  Utilde; U+00168
  utilde; U+00169
  utri; U+025B5
  utrif; U+025B4
  uuarr; U+021C8
  Uuml; U+000DC
  Uuml U+000DC
  uuml; U+000FC
  uuml U+000FC
  uwangle; U+029A7
  vangrt; U+0299C
  varepsilon; U+003F5
  varkappa; U+003F0
  varnothing; U+02205
  varphi; U+003D5
  varpi; U+003D6
  varpropto; U+0221D
  vArr; U+021D5
  varr; U+02195
  varrho; U+003F1
  varsigma; U+003C2
  varsubsetneq; U+0228A U+0FE00
  varsubsetneqq; U+02ACB U+0FE00
  varsupsetneq; U+0228B U+0FE00
  varsupsetneqq; U+02ACC U+0FE00
  vartheta; U+003D1
  vartriangleleft; U+022B2
  vartriangleright; U+022B3
  Vbar; U+02AEB
  vBar; U+02AE8
  vBarv; U+02AE9
  Vcy; U+00412
  vcy; U+00432
  VDash; U+022AB
  Vdash; U+022A9
  vDash; U+022A8
  vdash; U+022A2
  Vdashl; U+02AE6
  Vee; U+022C1
  vee; U+02228
  veebar; U+022BB
  veeeq; U+0225A
  vellip; U+022EE
  Verbar; U+02016
  verbar; U+0007C
  Vert; U+02016
  vert; U+0007C
  VerticalBar; U+02223
  VerticalLine; U+0007C
  VerticalSeparator; U+02758
  VerticalTilde; U+02240
  VeryThinSpace; U+0200A
  Vfr; U+1D519
  vfr; U+1D533
  vltri; U+022B2
  vnsub; U+02282 U+020D2
  vnsup; U+02283 U+020D2
  Vopf; U+1D54D
  vopf; U+1D567
  vprop; U+0221D
  vrtri; U+022B3
  Vscr; U+1D4B1
  vscr; U+1D4CB
  vsubnE; U+02ACB U+0FE00
  vsubne; U+0228A U+0FE00
  vsupnE; U+02ACC U+0FE00
  vsupne; U+0228B U+0FE00
  Vvdash; U+022AA
  vzigzag; U+0299A
  Wcirc; U+00174
  wcirc; U+00175
  wedbar; U+02A5F
  Wedge; U+022C0
  wedge; U+02227
  wedgeq; U+02259
  weierp; U+02118
  Wfr; U+1D51A
  wfr; U+1D534
  Wopf; U+1D54E
  wopf; U+1D568
  wp; U+02118
  wr; U+02240
  wreath; U+02240
  Wscr; U+1D4B2
  wscr; U+1D4CC
  xcap; U+022C2
  xcirc; U+025EF
  xcup; U+022C3
  xdtri; U+025BD
  Xfr; U+1D51B
  xfr; U+1D535
  xhArr; U+027FA
  xharr; U+027F7
  Xi; U+0039E
  xi; U+003BE
  xlArr; U+027F8
  xlarr; U+027F5
  xmap; U+027FC
  xnis; U+022FB
  xodot; U+02A00
  Xopf; U+1D54F
  xopf; U+1D569
  xoplus; U+02A01
  xotime; U+02A02
  xrArr; U+027F9
  xrarr; U+027F6
  Xscr; U+1D4B3
  xscr; U+1D4CD
  xsqcup; U+02A06
  xuplus; U+02A04
  xutri; U+025B3
  xvee; U+022C1
  xwedge; U+022C0
  Yacute; U+000DD
  Yacute U+000DD
  yacute; U+000FD
  yacute U+000FD
  YAcy; U+0042F
  yacy; U+0044F
  Ycirc; U+00176
  ycirc; U+00177
  Ycy; U+0042B
  ycy; U+0044B
  yen; U+000A5
  yen U+000A5
  Yfr; U+1D51C
  yfr; U+1D536
  YIcy; U+00407
  yicy; U+00457
  Yopf; U+1D550
  yopf; U+1D56A
  Yscr; U+1D4B4
  yscr; U+1D4CE
  YUcy; U+0042E
  yucy; U+0044E
  Yuml; U+00178
  yuml; U+000FF
  yuml U+000FF
  Zacute; U+00179
  zacute; U+0017A
  Zcaron; U+0017D
  zcaron; U+0017E
  Zcy; U+00417
  zcy; U+00437
  Zdot; U+0017B
  zdot; U+0017C
  zeetrf; U+02128
  ZeroWidthSpace; U+0200B
  Zeta; U+00396
  zeta; U+003B6
  Zfr; U+02128
  zfr; U+1D537
  ZHcy; U+00416
  zhcy; U+00436
  zigrarr; U+021DD
  Zopf; U+02124
  zopf; U+1D56B
  Zscr; U+1D4B5
  zscr; U+1D4CF
  zwj; U+0200D
  zwnj; U+0200C
MOJO_UTIL

$fatpacked{"Mojo/WebSocket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_WEBSOCKET';
  package Mojo::WebSocket;
  use Mojo::Base -strict;
  
  use Config;
  use Exporter 'import';
  use Mojo::Util qw(b64_encode dumper sha1_bytes xor_encode);
  
  use constant DEBUG => $ENV{MOJO_WEBSOCKET_DEBUG} || 0;
  
  # Unique value from RFC 6455
  use constant GUID => '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';
  
  # Perl with support for quads
  use constant MODERN =>
    (($Config{use64bitint} // '') eq 'define' || $Config{longsize} >= 8);
  
  # Opcodes
  use constant {
    WS_CONTINUATION => 0x0,
    WS_TEXT         => 0x1,
    WS_BINARY       => 0x2,
    WS_CLOSE        => 0x8,
    WS_PING         => 0x9,
    WS_PONG         => 0xa
  };
  
  our @EXPORT_OK = (
    qw(WS_BINARY WS_CLOSE WS_CONTINUATION WS_PING WS_PONG WS_TEXT),
    qw(build_frame challenge client_handshake parse_frame server_handshake)
  );
  
  sub build_frame {
    my ($masked, $fin, $rsv1, $rsv2, $rsv3, $op, $payload) = @_;
    warn "-- Building frame ($fin, $rsv1, $rsv2, $rsv3, $op)\n" if DEBUG;
  
    # Head
    my $head = $op + ($fin ? 128 : 0);
    $head |= 0b01000000 if $rsv1;
    $head |= 0b00100000 if $rsv2;
    $head |= 0b00010000 if $rsv3;
    my $frame = pack 'C', $head;
  
    # Small payload
    my $len = length $payload;
    if ($len < 126) {
      warn "-- Small payload ($len)\n@{[dumper $payload]}" if DEBUG;
      $frame .= pack 'C', $masked ? ($len | 128) : $len;
    }
  
    # Extended payload (16-bit)
    elsif ($len < 65536) {
      warn "-- Extended 16-bit payload ($len)\n@{[dumper $payload]}" if DEBUG;
      $frame .= pack 'Cn', $masked ? (126 | 128) : 126, $len;
    }
  
    # Extended payload (64-bit with 32-bit fallback)
    else {
      warn "-- Extended 64-bit payload ($len)\n@{[dumper $payload]}" if DEBUG;
      $frame .= pack 'C', $masked ? (127 | 128) : 127;
      $frame .= MODERN ? pack('Q>', $len) : pack('NN', 0, $len & 0xffffffff);
    }
  
    # Mask payload
    if ($masked) {
      my $mask = pack 'N', int(rand 9 x 7);
      $payload = $mask . xor_encode($payload, $mask x 128);
    }
  
    return $frame . $payload;
  }
  
  sub challenge {
    my $tx = shift;
  
    # "permessage-deflate" extension
    my $headers = $tx->res->headers;
    $tx->compressed(1)
      if ($headers->sec_websocket_extensions // '') =~ /permessage-deflate/;
  
    return _challenge($tx->req->headers->sec_websocket_key) eq
      $headers->sec_websocket_accept;
  }
  
  sub client_handshake {
    my $tx = shift;
  
    my $headers = $tx->req->headers;
    $headers->upgrade('websocket')      unless $headers->upgrade;
    $headers->connection('Upgrade')     unless $headers->connection;
    $headers->sec_websocket_version(13) unless $headers->sec_websocket_version;
  
    # Generate 16 byte WebSocket challenge
    my $challenge = b64_encode sprintf('%16u', int(rand 9 x 16)), '';
    $headers->sec_websocket_key($challenge) unless $headers->sec_websocket_key;
  
    return $tx;
  }
  
  sub parse_frame {
    my ($buffer, $max) = @_;
  
    # Head
    return undef unless length $$buffer >= 2;
    my ($first, $second) = unpack 'C2', $$buffer;
  
    # FIN
    my $fin = ($first & 0b10000000) == 0b10000000 ? 1 : 0;
  
    # RSV1-3
    my $rsv1 = ($first & 0b01000000) == 0b01000000 ? 1 : 0;
    my $rsv2 = ($first & 0b00100000) == 0b00100000 ? 1 : 0;
    my $rsv3 = ($first & 0b00010000) == 0b00010000 ? 1 : 0;
  
    # Opcode
    my $op = $first & 0b00001111;
    warn "-- Parsing frame ($fin, $rsv1, $rsv2, $rsv3, $op)\n" if DEBUG;
  
    # Small payload
    my ($hlen, $len) = (2, $second & 0b01111111);
    if ($len < 126) { warn "-- Small payload ($len)\n" if DEBUG }
  
    # Extended payload (16-bit)
    elsif ($len == 126) {
      return undef unless length $$buffer > 4;
      $hlen = 4;
      $len = unpack 'x2n', $$buffer;
      warn "-- Extended 16-bit payload ($len)\n" if DEBUG;
    }
  
    # Extended payload (64-bit with 32-bit fallback)
    elsif ($len == 127) {
      return undef unless length $$buffer > 10;
      $hlen = 10;
      $len = MODERN ? unpack('x2Q>', $$buffer) : unpack('x2x4N', $$buffer);
      warn "-- Extended 64-bit payload ($len)\n" if DEBUG;
    }
  
    # Check message size
    return 1 if $len > $max;
  
    # Check if whole packet has arrived
    $len += 4 if my $masked = $second & 0b10000000;
    return undef if length $$buffer < ($hlen + $len);
    substr $$buffer, 0, $hlen, '';
  
    # Payload
    my $payload = $len ? substr($$buffer, 0, $len, '') : '';
    $payload = xor_encode($payload, substr($payload, 0, 4, '') x 128) if $masked;
    warn dumper $payload if DEBUG;
  
    return [$fin, $rsv1, $rsv2, $rsv3, $op, $payload];
  }
  
  sub server_handshake {
    my $tx = shift;
  
    my $headers = $tx->res->headers;
    $headers->upgrade('websocket')->connection('Upgrade');
    $headers->sec_websocket_accept(
      _challenge($tx->req->headers->sec_websocket_key));
  
    return $tx;
  }
  
  sub _challenge { b64_encode(sha1_bytes(($_[0] || '') . GUID), '') }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojo::WebSocket - The WebSocket protocol
  
  =head1 SYNOPSIS
  
    use Mojo::WebSocket qw(WS_TEXT build_frame parse_frame);
  
    my $bytes = build_frame 0, 1, 0, 0, 0, WS_TEXT, 'Hello World!';
    my $frame = parse_frame \$bytes, 262144;
  
  =head1 DESCRIPTION
  
  L<Mojo::WebSocket> implements the WebSocket protocol as described in
  L<RFC 6455|http://tools.ietf.org/html/rfc6455>. Note that 64-bit frames require
  a Perl with support for quads or they are limited to 32-bit.
  
  =head1 FUNCTIONS
  
  L<Mojo::WebSocket> implements the following functions, which can be imported
  individually.
  
  =head2 build_frame
  
    my $bytes = build_frame $masked, $fin, $rsv1, $rsv2, $rsv3, $op, $payload;
  
  Build WebSocket frame.
  
    # Masked binary frame with FIN bit and payload
    say build_frame 1, 1, 0, 0, 0, WS_BINARY, 'Hello World!';
  
    # Text frame with payload but without FIN bit
    say build_frame 0, 0, 0, 0, 0, WS_TEXT, 'Hello ';
  
    # Continuation frame with FIN bit and payload
    say build_frame 0, 1, 0, 0, 0, WS_CONTINUATION, 'World!';
  
    # Close frame with FIN bit and without payload
    say build_frame 0, 1, 0, 0, 0, WS_CLOSE, '';
  
    # Ping frame with FIN bit and payload
    say build_frame 0, 1, 0, 0, 0, WS_PING, 'Test 123';
  
    # Pong frame with FIN bit and payload
    say build_frame 0, 1, 0, 0, 0, WS_PONG, 'Test 123';
  
  =head2 challenge
  
    my $bool = challenge Mojo::Transaction::WebSocket->new;
  
  Check WebSocket handshake challenge.
  
  =head2 client_handshake
  
    my $tx = client_handshake Mojo::Transaction::HTTP->new;
  
  Perform WebSocket handshake client-side.
  
  =head2 parse_frame
  
    my $frame = parse_frame \$bytes, $limit;
  
  Parse WebSocket frame.
  
    # Parse single frame and remove it from buffer
    my $frame = parse_frame \$buffer, 262144;
    say "FIN: $frame->[0]";
    say "RSV1: $frame->[1]";
    say "RSV2: $frame->[2]";
    say "RSV3: $frame->[3]";
    say "Opcode: $frame->[4]";
    say "Payload: $frame->[5]";
  
  =head2 server_handshake
  
    my $tx = server_handshake Mojo::Transaction::HTTP->new;
  
  Perform WebSocket handshake server-side.
  
  =head1 CONSTANTS
  
  L<Mojo::WebSocket> implements the following constants, which can be imported
  individually.
  
  =head2 WS_BINARY
  
  Opcode for C<Binary> frames.
  
  =head2 WS_CLOSE
  
  Opcode for C<Close> frames.
  
  =head2 WS_CONTINUATION
  
  Opcode for C<Continuation> frames.
  
  =head2 WS_PING
  
  Opcode for C<Ping> frames.
  
  =head2 WS_PONG
  
  Opcode for C<Pong> frames.
  
  =head2 WS_TEXT
  
  Opcode for C<Text> frames.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJO_WEBSOCKET

$fatpacked{"Mojolicious.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS';
  package Mojolicious;
  use Mojo::Base -base;
  
  # "Fry: Shut up and take my money!"
  use Carp ();
  use Mojo::Exception;
  use Mojo::Home;
  use Mojo::Log;
  use Mojo::Util;
  use Mojo::UserAgent;
  use Mojolicious::Commands;
  use Mojolicious::Controller;
  use Mojolicious::Plugins;
  use Mojolicious::Renderer;
  use Mojolicious::Routes;
  use Mojolicious::Sessions;
  use Mojolicious::Static;
  use Mojolicious::Types;
  use Mojolicious::Validator;
  use Scalar::Util ();
  
  has commands => sub {
    my $commands = Mojolicious::Commands->new(app => shift);
    Scalar::Util::weaken $commands->{app};
    return $commands;
  };
  has controller_class => 'Mojolicious::Controller';
  has home             => sub { Mojo::Home->new->detect(ref shift) };
  has log              => sub {
    my $self = shift;
  
    # Check if we have a log directory that is writable
    my $log  = Mojo::Log->new;
    my $home = $self->home;
    my $mode = $self->mode;
    $log->path($home->child('log', "$mode.log"))
      if -d $home->child('log') && -w _;
  
    # Reduced log output outside of development mode
    return $mode eq 'development' ? $log : $log->level('info');
  };
  has 'max_request_size';
  has mode     => sub { $ENV{MOJO_MODE} || $ENV{PLACK_ENV} || 'development' };
  has moniker  => sub { Mojo::Util::decamelize ref shift };
  has plugins  => sub { Mojolicious::Plugins->new };
  has renderer => sub { Mojolicious::Renderer->new };
  has routes   => sub { Mojolicious::Routes->new };
  has secrets  => sub {
    my $self = shift;
  
    # Warn developers about insecure default
    $self->log->debug('Your secret passphrase needs to be changed');
  
    # Default to moniker
    return [$self->moniker];
  };
  has sessions => sub { Mojolicious::Sessions->new };
  has static   => sub { Mojolicious::Static->new };
  has types    => sub { Mojolicious::Types->new };
  has ua       => sub {
    my $ua = Mojo::UserAgent->new;
    Scalar::Util::weaken $ua->server->app(shift)->{app};
    return $ua;
  };
  has validator => sub { Mojolicious::Validator->new };
  
  our $CODENAME = 'Doughnut';
  our $VERSION  = '7.87';
  
  sub AUTOLOAD {
    my $self = shift;
  
    my ($package, $method) = our $AUTOLOAD =~ /^(.+)::(.+)$/;
    Carp::croak "Undefined subroutine &${package}::$method called"
      unless Scalar::Util::blessed $self && $self->isa(__PACKAGE__);
  
    # Call helper with fresh controller
    Carp::croak qq{Can't locate object method "$method" via package "$package"}
      unless my $helper = $self->renderer->get_helper($method);
    return $self->build_controller->$helper(@_);
  }
  
  sub build_controller {
    my ($self, $tx) = @_;
    $tx ||= $self->build_tx;
  
    # Embedded application
    my $stash = {};
    if (my $sub = $tx->can('stash')) { ($stash, $tx) = ($tx->$sub, $tx->tx) }
  
    # Build default controller
    my $defaults = $self->defaults;
    @$stash{keys %$defaults} = values %$defaults;
    my $c
      = $self->controller_class->new(app => $self, stash => $stash, tx => $tx);
    Scalar::Util::weaken $c->{app};
  
    return $c;
  }
  
  sub build_tx {
    my $self = shift;
  
    my $tx  = Mojo::Transaction::HTTP->new;
    my $max = $self->max_request_size;
    $tx->req->max_message_size($max) if defined $max;
    $self->plugins->emit_hook(after_build_tx => $tx, $self);
  
    return $tx;
  }
  
  sub config   { Mojo::Util::_stash(config   => @_) }
  sub defaults { Mojo::Util::_stash(defaults => @_) }
  
  sub dispatch {
    my ($self, $c) = @_;
  
    my $plugins = $self->plugins->emit_hook(before_dispatch => $c);
  
    # Try to find a static file
    my $tx = $c->tx;
    $self->static->dispatch($c) and $plugins->emit_hook(after_static => $c)
      unless $tx->res->code;
  
    # Start timer (ignore static files)
    my $stash = $c->stash;
    unless ($stash->{'mojo.static'} || $stash->{'mojo.started'}) {
      my $req    = $c->req;
      my $method = $req->method;
      my $path   = $req->url->path->to_abs_string;
      my $id     = $req->request_id;
      $self->log->debug(qq{$method "$path" ($id)});
      $c->helpers->timing->begin('mojo.timer');
    }
  
    # Routes
    $plugins->emit_hook(before_routes => $c);
    $c->helpers->reply->not_found
      unless $tx->res->code || $self->routes->dispatch($c) || $tx->res->code;
  }
  
  sub handler {
    my $self = shift;
  
    # Dispatcher has to be last in the chain
    ++$self->{dispatch}
      and $self->hook(around_action   => sub { $_[2]($_[1]) })
      and $self->hook(around_dispatch => sub { $_[1]->app->dispatch($_[1]) })
      unless $self->{dispatch};
  
    # Process with chain
    my $c = $self->build_controller(@_);
    Scalar::Util::weaken $c->{tx};
    $self->plugins->emit_chain(around_dispatch => $c);
  
    # Delayed response
    $self->log->debug('Nothing has been rendered, expecting delayed response')
      unless $c->stash->{'mojo.rendered'};
  }
  
  sub helper { shift->renderer->add_helper(@_) }
  
  sub hook { shift->plugins->on(@_) }
  
  sub new {
    my $self = shift->SUPER::new(@_);
  
    my $home = $self->home;
    push @{$self->renderer->paths}, $home->child('templates')->to_string;
    push @{$self->static->paths},   $home->child('public')->to_string;
  
    # Default to controller and application namespace
    my $r = $self->routes->namespaces(["@{[ref $self]}::Controller", ref $self]);
  
    # Hide controller attributes/methods
    $r->hide(qw(app continue cookie every_cookie every_param));
    $r->hide(qw(every_signed_cookie finish flash helpers match on param));
    $r->hide(qw(redirect_to render render_later render_maybe render_to_string));
    $r->hide(qw(rendered req res respond_to send session signed_cookie stash));
    $r->hide(qw(tx url_for validation write write_chunk));
  
    $self->plugin($_)
      for qw(HeaderCondition DefaultHelpers TagHelpers EPLRenderer EPRenderer);
  
    # Exception handling should be first in chain
    $self->hook(around_dispatch => \&_exception);
  
    $self->startup;
  
    return $self;
  }
  
  sub plugin {
    my $self = shift;
    $self->plugins->register_plugin(shift, $self, @_);
  }
  
  sub server { $_[0]->plugins->emit_hook(before_server_start => @_[1, 0]) }
  
  sub start {
    my $self = shift;
    $_->warmup for $self->static, $self->renderer;
    return $self->commands->run(@_ ? @_ : @ARGV);
  }
  
  sub startup { }
  
  sub _exception {
    my ($next, $c) = @_;
    local $SIG{__DIE__}
      = sub { ref $_[0] ? CORE::die $_[0] : Mojo::Exception->throw(shift) };
    $c->helpers->reply->exception($@) unless eval { $next->(); 1 };
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious - Real-time web framework
  
  =head1 SYNOPSIS
  
    # Application
    package MyApp;
    use Mojo::Base 'Mojolicious';
  
    # Route
    sub startup {
      my $self = shift;
      $self->routes->get('/hello')->to('foo#hello');
    }
  
    # Controller
    package MyApp::Controller::Foo;
    use Mojo::Base 'Mojolicious::Controller';
  
    # Action
    sub hello {
      my $self = shift;
      $self->render(text => 'Hello World!');
    }
  
  =head1 DESCRIPTION
  
  An amazing real-time web framework built on top of the powerful L<Mojo> web
  development toolkit. With support for RESTful routes, plugins, commands,
  Perl-ish templates, content negotiation, session management, form validation,
  testing framework, static file server, C<CGI>/C<PSGI> detection, first class
  Unicode support and much more for you to discover.
  
  Take a look at our excellent documentation in L<Mojolicious::Guides>!
  
  =head1 HOOKS
  
  L<Mojolicious> will emit the following hooks in the listed order.
  
  =head2 before_server_start
  
  Emitted right before the application server is started, for web servers that
  support it, which includes all the built-in ones (except for
  L<Mojo::Server::CGI>). Note that this hook is EXPERIMENTAL and might change
  without warning!
  
    $app->hook(before_server_start => sub {
      my ($server, $app) = @_;
      ...
    });
  
  Useful for reconfiguring application servers dynamically or collecting server
  diagnostics information. (Passed the server and application objects)
  
  =head2 after_build_tx
  
  Emitted right after the transaction is built and before the HTTP request gets
  parsed.
  
    $app->hook(after_build_tx => sub {
      my ($tx, $app) = @_;
      ...
    });
  
  This is a very powerful hook and should not be used lightly, it makes some
  rather advanced features such as upload progress bars possible. Note that this
  hook will not work for embedded applications, because only the host application
  gets to build transactions. (Passed the transaction and application objects)
  
  =head2 around_dispatch
  
  Emitted right after a new request has been received and wraps around the whole
  dispatch process, so you have to manually forward to the next hook if you want
  to continue the chain. Default exception handling with
  L<Mojolicious::Plugin::DefaultHelpers/"reply-E<gt>exception"> is the first hook
  in the chain and a call to L</"dispatch"> the last, yours will be in between.
  
    $app->hook(around_dispatch => sub {
      my ($next, $c) = @_;
      ...
      $next->();
      ...
    });
  
  This is a very powerful hook and should not be used lightly, it allows you to,
  for example, customize application-wide exception handling, consider it the
  sledgehammer in your toolbox. (Passed a callback leading to the next hook and
  the default controller object)
  
  =head2 before_dispatch
  
  Emitted right before the static file server and router start their work.
  
    $app->hook(before_dispatch => sub {
      my $c = shift;
      ...
    });
  
  Very useful for rewriting incoming requests and other preprocessing tasks.
  (Passed the default controller object)
  
  =head2 after_static
  
  Emitted after a static file response has been generated by the static file
  server.
  
    $app->hook(after_static => sub {
      my $c = shift;
      ...
    });
  
  Mostly used for post-processing static file responses. (Passed the default
  controller object)
  
  =head2 before_routes
  
  Emitted after the static file server determined if a static file should be
  served and before the router starts its work.
  
    $app->hook(before_routes => sub {
      my $c = shift;
      ...
    });
  
  Mostly used for custom dispatchers and collecting metrics. (Passed the default
  controller object)
  
  =head2 around_action
  
  Emitted right before an action gets executed and wraps around it, so you have to
  manually forward to the next hook if you want to continue the chain. Default
  action dispatching is the last hook in the chain, yours will run before it.
  
    $app->hook(around_action => sub {
      my ($next, $c, $action, $last) = @_;
      ...
      return $next->();
    });
  
  This is a very powerful hook and should not be used lightly, it allows you for
  example to pass additional arguments to actions or handle return values
  differently. Note that this hook can trigger more than once for the same
  request if there are nested routes. (Passed a callback leading to the next hook,
  the current controller object, the action callback and a flag indicating if this
  action is an endpoint)
  
  =head2 before_render
  
  Emitted before content is generated by the renderer. Note that this hook can
  trigger out of order due to its dynamic nature, and with embedded applications
  will only work for the application that is rendering.
  
    $app->hook(before_render => sub {
      my ($c, $args) = @_;
      ...
    });
  
  Mostly used for pre-processing arguments passed to the renderer. (Passed the
  current controller object and the render arguments)
  
  =head2 after_render
  
  Emitted after content has been generated by the renderer that will be assigned
  to the response. Note that this hook can trigger out of order due to its
  dynamic nature, and with embedded applications will only work for the
  application that is rendering.
  
    $app->hook(after_render => sub {
      my ($c, $output, $format) = @_;
      ...
    });
  
  Mostly used for post-processing dynamically generated content. (Passed the
  current controller object, a reference to the content and the format)
  
  =head2 after_dispatch
  
  Emitted in reverse order after a response has been generated. Note that this
  hook can trigger out of order due to its dynamic nature, and with embedded
  applications will only work for the application that is generating the response.
  
    $app->hook(after_dispatch => sub {
      my $c = shift;
      ...
    });
  
  Useful for rewriting outgoing responses and other post-processing tasks.
  (Passed the current controller object)
  
  =head1 ATTRIBUTES
  
  L<Mojolicious> implements the following attributes.
  
  =head2 commands
  
    my $commands = $app->commands;
    $app         = $app->commands(Mojolicious::Commands->new);
  
  Command line interface for your application, defaults to a
  L<Mojolicious::Commands> object.
  
    # Add another namespace to load commands from
    push @{$app->commands->namespaces}, 'MyApp::Command';
  
  =head2 controller_class
  
    my $class = $app->controller_class;
    $app      = $app->controller_class('Mojolicious::Controller');
  
  Class to be used for the default controller, defaults to
  L<Mojolicious::Controller>. Note that this class needs to have already been
  loaded before the first request arrives.
  
  =head2 home
  
    my $home = $app->home;
    $app     = $app->home(Mojo::Home->new);
  
  The home directory of your application, defaults to a L<Mojo::Home> object
  which stringifies to the actual path.
  
    # Portably generate path relative to home directory
    my $path = $app->home->child('data', 'important.txt');
  
  =head2 log
  
    my $log = $app->log;
    $app    = $app->log(Mojo::Log->new);
  
  The logging layer of your application, defaults to a L<Mojo::Log> object. The
  level will default to C<debug> if the L</mode> is C<development>, or C<info>
  otherwise. All messages will be written to C<STDERR>, or a C<log/$mode.log> file
  if a C<log> directory exists.
  
    # Log debug message
    $app->log->debug('It works');
  
  =head2 max_request_size
  
    my $max = $app->max_request_size;
    $app    = $app->max_request_size(16777216);
  
  Maximum request size in bytes, defaults to the value of
  L<Mojo::Message/"max_message_size">. Setting the value to C<0> will allow
  requests of indefinite size. Note that increasing this value can also
  drastically increase memory usage, should you for example attempt to parse an
  excessively large request body with the methods L<Mojo::Message/"dom"> or
  L<Mojo::Message/"json">.
  
  =head2 mode
  
    my $mode = $app->mode;
    $app     = $app->mode('production');
  
  The operating mode for your application, defaults to a value from the
  C<MOJO_MODE> and C<PLACK_ENV> environment variables or C<development>.
  
  =head2 moniker
  
    my $moniker = $app->moniker;
    $app        = $app->moniker('foo_bar');
  
  Moniker of this application, often used as default filename for configuration
  files and the like, defaults to decamelizing the application class with
  L<Mojo::Util/"decamelize">.
  
  =head2 plugins
  
    my $plugins = $app->plugins;
    $app        = $app->plugins(Mojolicious::Plugins->new);
  
  The plugin manager, defaults to a L<Mojolicious::Plugins> object. See the
  L</"plugin"> method below if you want to load a plugin.
  
    # Add another namespace to load plugins from
    push @{$app->plugins->namespaces}, 'MyApp::Plugin';
  
  =head2 renderer
  
    my $renderer = $app->renderer;
    $app         = $app->renderer(Mojolicious::Renderer->new);
  
  Used to render content, defaults to a L<Mojolicious::Renderer> object. For more
  information about how to generate content see
  L<Mojolicious::Guides::Rendering>.
  
    # Add another "templates" directory
    push @{$app->renderer->paths}, '/home/sri/templates';
  
    # Add another "templates" directory with higher precedence
    unshift @{$app->renderer->paths}, '/home/sri/themes/blue/templates';
  
    # Add another class with templates in DATA section
    push @{$app->renderer->classes}, 'Mojolicious::Plugin::Fun';
  
  =head2 routes
  
    my $routes = $app->routes;
    $app       = $app->routes(Mojolicious::Routes->new);
  
  The router, defaults to a L<Mojolicious::Routes> object. You use this in your
  startup method to define the url endpoints for your application.
  
    # Add routes
    my $r = $app->routes;
    $r->get('/foo/bar')->to('test#foo', title => 'Hello Mojo!');
    $r->post('/baz')->to('test#baz');
  
    # Add another namespace to load controllers from
    push @{$app->routes->namespaces}, 'MyApp::MyController';
  
  =head2 secrets
  
    my $secrets = $app->secrets;
    $app        = $app->secrets([$bytes]);
  
  Secret passphrases used for signed cookies and the like, defaults to the
  L</"moniker"> of this application, which is not very secure, so you should
  change it!!! As long as you are using the insecure default there will be debug
  messages in the log file reminding you to change your passphrase. Only the
  first passphrase is used to create new signatures, but all of them for
  verification. So you can increase security without invalidating all your
  existing signed cookies by rotating passphrases, just add new ones to the front
  and remove old ones from the back.
  
    # Rotate passphrases
    $app->secrets(['new_passw0rd', 'old_passw0rd', 'very_old_passw0rd']);
  
  =head2 sessions
  
    my $sessions = $app->sessions;
    $app         = $app->sessions(Mojolicious::Sessions->new);
  
  Signed cookie based session manager, defaults to a L<Mojolicious::Sessions>
  object. You can usually leave this alone, see
  L<Mojolicious::Controller/"session"> for more information about working with
  session data.
  
    # Change name of cookie used for all sessions
    $app->sessions->cookie_name('mysession');
  
  =head2 static
  
    my $static = $app->static;
    $app       = $app->static(Mojolicious::Static->new);
  
  For serving static files from your C<public> directories, defaults to a
  L<Mojolicious::Static> object.
  
    # Add another "public" directory
    push @{$app->static->paths}, '/home/sri/public';
  
    # Add another "public" directory with higher precedence
    unshift @{$app->static->paths}, '/home/sri/themes/blue/public';
  
    # Add another class with static files in DATA section
    push @{$app->static->classes}, 'Mojolicious::Plugin::Fun';
  
    # Remove built-in favicon
    delete $app->static->extra->{'favicon.ico'};
  
  =head2 types
  
    my $types = $app->types;
    $app      = $app->types(Mojolicious::Types->new);
  
  Responsible for connecting file extensions with MIME types, defaults to a
  L<Mojolicious::Types> object.
  
    # Add custom MIME type
    $app->types->type(twt => 'text/tweet');
  
  =head2 ua
  
    my $ua = $app->ua;
    $app   = $app->ua(Mojo::UserAgent->new);
  
  A full featured HTTP user agent for use in your applications, defaults to a
  L<Mojo::UserAgent> object.
  
    # Perform blocking request
    say $app->ua->get('example.com')->result->body;
  
  =head2 validator
  
    my $validator = $app->validator;
    $app          = $app->validator(Mojolicious::Validator->new);
  
  Validate values, defaults to a L<Mojolicious::Validator> object.
  
    # Add validation check
    $app->validator->add_check(foo => sub {
      my ($v, $name, $value) = @_;
      return $value ne 'foo';
    });
  
    # Add validation filter
    $app->validator->add_filter(quotemeta => sub {
      my ($v, $name, $value) = @_;
      return quotemeta $value;
    });
  
  =head1 METHODS
  
  L<Mojolicious> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 build_controller
  
    my $c = $app->build_controller;
    my $c = $app->build_controller(Mojo::Transaction::HTTP->new);
    my $c = $app->build_controller(Mojolicious::Controller->new);
  
  Build default controller object with L</"controller_class">.
  
    # Render template from application
    my $foo = $app->build_controller->render_to_string(template => 'foo');
  
  =head2 build_tx
  
    my $tx = $app->build_tx;
  
  Build L<Mojo::Transaction::HTTP> object and emit L</"after_build_tx"> hook.
  
  =head2 config
  
    my $hash = $app->config;
    my $foo  = $app->config('foo');
    $app     = $app->config({foo => 'bar', baz => 23});
    $app     = $app->config(foo => 'bar', baz => 23);
  
  Application configuration.
  
    # Remove value
    my $foo = delete $app->config->{foo};
  
    # Assign multiple values at once
    $app->config(foo => 'test', bar => 23);
  
  =head2 defaults
  
    my $hash = $app->defaults;
    my $foo  = $app->defaults('foo');
    $app     = $app->defaults({foo => 'bar', baz => 23});
    $app     = $app->defaults(foo => 'bar', baz => 23);
  
  Default values for L<Mojolicious::Controller/"stash">, assigned for every new
  request.
  
    # Remove value
    my $foo = delete $app->defaults->{foo};
  
    # Assign multiple values at once
    $app->defaults(foo => 'test', bar => 23);
  
  =head2 dispatch
  
    $app->dispatch(Mojolicious::Controller->new);
  
  The heart of every L<Mojolicious> application, calls the L</"static"> and
  L</"routes"> dispatchers for every request and passes them a
  L<Mojolicious::Controller> object.
  
  =head2 handler
  
    $app->handler(Mojo::Transaction::HTTP->new);
    $app->handler(Mojolicious::Controller->new);
  
  Sets up the default controller and emits the L</"around_dispatch"> hook for
  every request.
  
  =head2 helper
  
    $app->helper(foo => sub {...});
  
  Add or replace a helper that will be available as a method of the controller
  object and the application object, as well as a function in C<ep> templates. For
  a full list of helpers that are available by default see
  L<Mojolicious::Plugin::DefaultHelpers> and L<Mojolicious::Plugin::TagHelpers>.
  
    # Helper
    $app->helper(cache => sub { state $cache = {} });
  
    # Application
    $app->cache->{foo} = 'bar';
    my $result = $app->cache->{foo};
  
    # Controller
    $c->cache->{foo} = 'bar';
    my $result = $c->cache->{foo};
  
    # Template
    % cache->{foo} = 'bar';
    %= cache->{foo}
  
  =head2 hook
  
    $app->hook(after_dispatch => sub {...});
  
  Extend L<Mojolicious> with hooks, which allow code to be shared with all
  requests indiscriminately, for a full list of available hooks see L</"HOOKS">.
  
    # Dispatchers will not run if there's already a response code defined
    $app->hook(before_dispatch => sub {
      my $c = shift;
      $c->render(text => 'Skipped static file server and router!')
        if $c->req->url->path->to_route =~ /do_not_dispatch/;
    });
  
  =head2 new
  
    my $app = Mojolicious->new;
    my $app = Mojolicious->new(moniker => 'foo_bar');
    my $app = Mojolicious->new({moniker => 'foo_bar'});
  
  Construct a new L<Mojolicious> application and call L</"startup">. Will
  automatically detect your home directory. Also sets up the renderer, static file
  server, a default set of plugins and an L</"around_dispatch"> hook with the
  default exception handling.
  
  =head2 plugin
  
    $app->plugin('some_thing');
    $app->plugin('some_thing', foo => 23);
    $app->plugin('some_thing', {foo => 23});
    $app->plugin('SomeThing');
    $app->plugin('SomeThing', foo => 23);
    $app->plugin('SomeThing', {foo => 23});
    $app->plugin('MyApp::Plugin::SomeThing');
    $app->plugin('MyApp::Plugin::SomeThing', foo => 23);
    $app->plugin('MyApp::Plugin::SomeThing', {foo => 23});
  
  Load a plugin, for a full list of example plugins included in the
  L<Mojolicious> distribution see L<Mojolicious::Plugins/"PLUGINS">.
  
  =head2 server
  
    $app->server(Mojo::Server->new);
  
  Emits the L</"before_server_start"> hook. Note that this method is EXPERIMENTAL
  and might change without warning!
  
  =head2 start
  
    $app->start;
    $app->start(@ARGV);
  
  Start the command line interface for your application. For a full list of
  commands that are available by default see L<Mojolicious::Commands/"COMMANDS">.
  Note that the options C<-h>/C<--help>, C<--home> and C<-m>/C<--mode>, which are
  shared by all commands, will be parsed from C<@ARGV> during compile time.
  
    # Always start daemon
    $app->start('daemon', '-l', 'http://*:8080');
  
  =head2 startup
  
    $app->startup;
  
  This is your main hook into the application, it will be called at application
  startup. Meant to be overloaded in a subclass.
  
    sub startup {
      my $self = shift;
      ...
    }
  
  =head1 AUTOLOAD
  
  In addition to the L</"ATTRIBUTES"> and L</"METHODS"> above you can also call
  helpers on L<Mojolicious> objects. This includes all helpers from
  L<Mojolicious::Plugin::DefaultHelpers> and L<Mojolicious::Plugin::TagHelpers>.
  Note that application helpers are always called with a new default controller
  object, so they can't depend on or change controller state, which includes
  request, response and stash.
  
    # Call helper
    say $app->dumper({foo => 'bar'});
  
    # Longer version
    say $app->build_controller->helpers->dumper({foo => 'bar'});
  
  =head1 BUNDLED FILES
  
  The L<Mojolicious> distribution includes a few files with different licenses
  that have been bundled for internal use.
  
  =head2 Mojolicious Artwork
  
    Copyright (C) 2010-2018, Sebastian Riedel.
  
  Licensed under the CC-SA License, Version 4.0
  L<http://creativecommons.org/licenses/by-sa/4.0>.
  
  =head2 jQuery
  
    Copyright (C) jQuery Foundation.
  
  Licensed under the MIT License, L<http://creativecommons.org/licenses/MIT>.
  
  =head2 prettify.js
  
    Copyright (C) 2006, 2013 Google Inc..
  
  Licensed under the Apache License, Version 2.0
  L<http://www.apache.org/licenses/LICENSE-2.0>.
  
  =head1 CODE NAMES
  
  Every major release of L<Mojolicious> has a code name, these are the ones that
  have been used in the past.
  
  7.0, C<Doughnut> (U+1F369)
  
  6.0, C<Clinking Beer Mugs> (U+1F37B)
  
  5.0, C<Tiger Face> (U+1F42F)
  
  4.0, C<Top Hat> (U+1F3A9)
  
  3.0, C<Rainbow> (U+1F308)
  
  2.0, C<Leaf Fluttering In Wind> (U+1F343)
  
  1.0, C<Snowflake> (U+2744)
  
  =head1 SPONSORS
  
  Some of the work on this distribution has been sponsored by
  L<The Perl Foundation|http://www.perlfoundation.org>, thank you!
  
  =head1 PROJECT FOUNDER
  
  Sebastian Riedel, C<kraih@mojolicious.org>
  
  =head1 CORE DEVELOPERS
  
  Current members of the core team in alphabetical order:
  
  =over 2
  
  Jan Henning Thorsen, C<batman@mojolicious.org>
  
  Joel Berger, C<jberger@mojolicious.org>
  
  Marcus Ramberg, C<marcus@mojolicious.org>
  
  =back
  
  The following members of the core team are currently on hiatus:
  
  =over 2
  
  Abhijit Menon-Sen, C<ams@cpan.org>
  
  Glen Hinkle, C<tempire@cpan.org>
  
  =back
  
  =head1 CREDITS
  
  In alphabetical order:
  
  =over 2
  
  Adam Kennedy
  
  Adriano Ferreira
  
  Al Newkirk
  
  Alex Efros
  
  Alex Salimon
  
  Alexey Likhatskiy
  
  Anatoly Sharifulin
  
  Andre Parker
  
  Andre Vieth
  
  Andreas Jaekel
  
  Andreas Koenig
  
  Andrew Fresh
  
  Andrew Nugged
  
  Andrey Khozov
  
  Andrey Kuzmin
  
  Andy Grundman
  
  Aristotle Pagaltzis
  
  Ashley Dev
  
  Ask Bjoern Hansen
  
  Audrey Tang
  
  Ben Tyler
  
  Ben van Staveren
  
  Benjamin Erhart
  
  Bernhard Graf
  
  Breno G. de Oliveira
  
  Brian Duggan
  
  Brian Medley
  
  Burak Gursoy
  
  Ch Lamprecht
  
  Charlie Brady
  
  Chas. J. Owens IV
  
  Chase Whitener
  
  Christian Hansen
  
  chromatic
  
  Curt Tilmes
  
  Dan Book
  
  Daniel Kimsey
  
  Daniel Mantovani
  
  Danijel Tasov
  
  Danny Thomas
  
  David Davis
  
  David Webb
  
  Diego Kuperman
  
  Dmitriy Shalashov
  
  Dmitry Konstantinov
  
  Dominik Jarmulowicz
  
  Dominique Dumont
  
  Dotan Dimet
  
  Douglas Christopher Wilson
  
  Ettore Di Giacinto
  
  Eugen Konkov
  
  Eugene Toropov
  
  Flavio Poletti
  
  Gisle Aas
  
  Graham Barr
  
  Graham Knop
  
  Henry Tang
  
  Hideki Yamamura
  
  Hiroki Toyokawa
  
  Ian Goodacre
  
  Ilya Chesnokov
  
  James Duncan
  
  Jan Jona Javorsek
  
  Jan Schmidt
  
  Jaroslav Muhin
  
  Jesse Vincent
  
  Johannes Plunien
  
  John Kingsley
  
  Jonathan Yu
  
  Josh Leder
  
  Kazuhiro Shibuya
  
  Kevin Old
  
  Kitamura Akatsuki
  
  Klaus S. Madsen
  
  Knut Arne Bjorndal
  
  Lars Balker Rasmussen
  
  Lee Johnson
  
  Leon Brocard
  
  Magnus Holm
  
  Maik Fischer
  
  Mark Fowler
  
  Mark Grimes
  
  Mark Stosberg
  
  Marty Tennison
  
  Matt S Trout
  
  Matthew Lineen
  
  Maksym Komar
  
  Maxim Vuets
  
  Michael Gregorowicz
  
  Michael Harris
  
  Mike Magowan
  
  Mirko Westermeier
  
  Mons Anderson
  
  Moritz Lenz
  
  Neil Watkiss
  
  Nic Sandfield
  
  Nils Diewald
  
  Oleg Zhelo
  
  Olivier Mengue
  
  Pascal Gaudette
  
  Paul Evans
  
  Paul Robins
  
  Paul Tomlin
  
  Pavel Shaydo
  
  Pedro Melo
  
  Peter Edwards
  
  Pierre-Yves Ritschard
  
  Piotr Roszatycki
  
  Quentin Carbonneaux
  
  Rafal Pocztarski
  
  Randal Schwartz
  
  Richard Elberger
  
  Rick Delaney
  
  Robert Hicks
  
  Robin Lee
  
  Roland Lammel
  
  Roy Storey
  
  Ryan Jendoubi
  
  Salvador Fandino
  
  Santiago Zarate
  
  Sascha Kiefer
  
  Scott Wiersdorf
  
  Sergey Zasenko
  
  Simon Bertrang
  
  Simone Tampieri
  
  Shu Cho
  
  Skye Shaw
  
  Stanis Trendelenburg
  
  Steffen Ullrich
  
  Stephan Kulow
  
  Stephane Este-Gracias
  
  Stevan Little
  
  Steve Atkins
  
  Tatsuhiko Miyagawa
  
  Terrence Brannon
  
  Tianon Gravi
  
  Tomas Znamenacek
  
  Tudor Constantin
  
  Ulrich Habel
  
  Ulrich Kautz
  
  Uwe Voelker
  
  Viacheslav Tykhanovskyi
  
  Victor Engmark
  
  Viliam Pucik
  
  Wes Cravens
  
  William Lindley
  
  Yaroslav Korshak
  
  Yuki Kimoto
  
  Zak B. Elep
  
  Zoffix Znet
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008-2018, Sebastian Riedel and others.
  
  This program is free software, you can redistribute it and/or modify it under
  the terms of the Artistic License version 2.0.
  
  =head1 SEE ALSO
  
  L<https://github.com/kraih/mojo>, L<Mojolicious::Guides>,
  L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS

$fatpacked{"Mojolicious/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND';
  package Mojolicious::Command;
  use Mojo::Base -base;
  
  use Carp 'croak';
  use Mojo::File 'path';
  use Mojo::Loader 'data_section';
  use Mojo::Server;
  use Mojo::Template;
  
  has app => sub { Mojo::Server->new->build_app('Mojo::HelloWorld') };
  has description => 'No description';
  has 'quiet';
  has template => sub { {} };
  has usage => "Usage: APPLICATION\n";
  
  sub chmod_file {
    my ($self, $path, $mod) = @_;
    chmod $mod, $path or croak qq{Can't chmod file "$path": $!};
    return $self->_loud("  [chmod] $path " . sprintf('%lo', $mod));
  }
  
  sub chmod_rel_file { $_[0]->chmod_file($_[0]->rel_file($_[1]), $_[2]) }
  
  sub create_dir {
    my ($self, $path) = @_;
    return $self->_loud("  [exist] $path") if -d $path;
    path($path)->make_path;
    return $self->_loud("  [mkdir] $path");
  }
  
  sub create_rel_dir { $_[0]->create_dir($_[0]->rel_file($_[1])) }
  
  sub extract_usage { Mojo::Util::extract_usage((caller)[1]) }
  
  sub help { print shift->usage }
  
  sub rel_file { path->child(split('/', pop)) }
  
  sub render_data {
    my ($self, $name) = (shift, shift);
    my $template = Mojo::Template->new($self->template)
      ->name("template $name from DATA section");
    my $output = $template->render(data_section(ref $self, $name), @_);
    return ref $output ? die $output : $output;
  }
  
  sub render_to_file {
    my ($self, $data, $path) = (shift, shift, shift);
    return $self->write_file($path, $self->render_data($data, @_));
  }
  
  sub render_to_rel_file {
    my $self = shift;
    $self->render_to_file(shift, $self->rel_file(shift), @_);
  }
  
  sub run { croak 'Method "run" not implemented by subclass' }
  
  sub write_file {
    my ($self, $path, $data) = @_;
    return $self->_loud("  [exist] $path") if -f $path;
    $self->create_dir(path($path)->dirname);
    path($path)->spurt($data);
    return $self->_loud("  [write] $path");
  }
  
  sub write_rel_file { $_[0]->write_file($_[0]->rel_file($_[1]), $_[2]) }
  
  sub _loud {
    my ($self, $msg) = @_;
    say $msg unless $self->quiet;
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command - Command base class
  
  =head1 SYNOPSIS
  
    # Lowercase command name
    package Mojolicious::Command::mycommand;
    use Mojo::Base 'Mojolicious::Command';
  
    # Short description
    has description => 'My first Mojo command';
  
    # Usage message from SYNOPSIS
    has usage => sub { shift->extract_usage };
  
    sub run {
      my ($self, @args) = @_;
  
      # Magic here! :)
    }
  
    1;
  
    =head1 SYNOPSIS
  
      Usage: APPLICATION mycommand [OPTIONS]
  
      Options:
        -s, --something   Does something
  
    =cut
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command> is an abstract base class for L<Mojolicious> commands.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command> implements the following attributes.
  
  =head2 app
  
    my $app  = $command->app;
    $command = $command->app(Mojolicious->new);
  
  Application for command, defaults to a L<Mojo::HelloWorld> object.
  
    # Introspect
    say "Template path: $_" for @{$command->app->renderer->paths};
  
  =head2 description
  
    my $description = $command->description;
    $command        = $command->description('Foo');
  
  Short description of command, used for the command list.
  
  =head2 quiet
  
    my $bool = $command->quiet;
    $command = $command->quiet($bool);
  
  Limited command output.
  
  =head2 template
  
    my $template = $command->template;
    $command     = $command->template({vars => 1});
  
  Attribute values passed to L<Mojo::Template> objects used to render templates
  with L</"render_data">.
  
  =head2 usage
  
    my $usage = $command->usage;
    $command  = $command->usage('Foo');
  
  Usage information for command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 chmod_file
  
    $command = $command->chmod_file('/home/sri/foo.txt', 0644);
  
  Change mode of a file.
  
  =head2 chmod_rel_file
  
    $command = $command->chmod_rel_file('foo/foo.txt', 0644);
  
  Portably change mode of a file relative to the current working directory.
  
  =head2 create_dir
  
    $command = $command->create_dir('/home/sri/foo/bar');
  
  Create a directory if it does not exist already.
  
  =head2 create_rel_dir
  
    $command = $command->create_rel_dir('foo/bar/baz');
  
  Portably create a directory relative to the current working directory if it does
  not exist already.
  
  =head2 extract_usage
  
    my $usage = $command->extract_usage;
  
  Extract usage message from the SYNOPSIS section of the file this method was
  called from with L<Mojo::Util/"extract_usage">.
  
  =head2 help
  
    $command->help;
  
  Print usage information for command.
  
  =head2 rel_file
  
    my $path = $command->rel_file('foo/bar.txt');
  
  Return a L<Mojo::File> object relative to the current working directory.
  
  =head2 render_data
  
    my $data = $command->render_data('foo_bar');
    my $data = $command->render_data('foo_bar', @args);
    my $data = $command->render_data('foo_bar', {foo => 'bar'});
  
  Render a template from the C<DATA> section of the command class with
  L<Mojo::Loader> and L<Mojo::Template>. The template can be configured with
  L</"template">.
  
  =head2 render_to_file
  
    $command = $command->render_to_file('foo_bar', '/home/sri/foo.txt');
    $command = $command->render_to_file('foo_bar', '/home/sri/foo.txt', @args);
    $command = $command->render_to_file(
      'foo_bar', '/home/sri/foo.txt', {foo => 'bar'});
  
  Render a template with L</"render_data"> to a file if it does not exist already,
  and create the directory if necessary.
  
  =head2 render_to_rel_file
  
    $command = $command->render_to_rel_file('foo_bar', 'foo/bar.txt');
    $command = $command->render_to_rel_file('foo_bar', 'foo/bar.txt', @args);
    $command = $command->render_to_rel_file(
      'foo_bar', 'foo/bar.txt', {foo => 'bar'});
  
  Portably render a template with L</"render_data"> to a file relative to the
  current working directory if it does not exist already, and create the directory
  if necessary.
  
  =head2 run
  
    $command->run;
    $command->run(@ARGV);
  
  Run command. Meant to be overloaded in a subclass.
  
  =head2 write_file
  
    $command = $command->write_file('/home/sri/foo.txt', 'Hello World!');
  
  Write text to a file if it does not exist already, and create the directory if
  necessary.
  
  =head2 write_rel_file
  
    $command = $command->write_rel_file('foo/bar.txt', 'Hello World!');
  
  Portably write text to a file relative to the current working directory if it
  does not exist already, and create the directory if necessary.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND

$fatpacked{"Mojolicious/Command/cgi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_CGI';
  package Mojolicious::Command::cgi;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Server::CGI;
  use Mojo::Util 'getopt';
  
  has description => 'Start application with CGI';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
    getopt \@args, nph => \(my $nph = 0);
    Mojo::Server::CGI->new(app => $self->app, nph => $nph)->run;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::cgi - CGI command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION cgi [OPTIONS]
  
      ./myapp.pl cgi
  
    Options:
      -h, --help          Show this summary of available options
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
          --nph           Enable non-parsed-header mode
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::cgi> starts applications with the L<Mojo::Server::CGI>
  backend.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::cgi> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $cgi->description;
    $cgi            = $cgi->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $cgi->usage;
    $cgi      = $cgi->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::cgi> inherits all methods from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 run
  
    $cgi->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_CGI

$fatpacked{"Mojolicious/Command/cpanify.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_CPANIFY';
  package Mojolicious::Command::cpanify;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::File 'path';
  use Mojo::Util 'getopt';
  
  has description => 'Upload distribution to CPAN';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    getopt \@args,
      'p|password=s' => \(my $password = ''),
      'u|user=s'     => \(my $user     = '');
    die $self->usage unless my $file = shift @args;
  
    my $tx = $self->app->ua->tap(sub { $_->proxy->detect })->post(
      "https://$user:$password\@pause.perl.org/pause/authenquery" => form => {
        HIDDENNAME                        => $user,
        CAN_MULTIPART                     => 1,
        pause99_add_uri_upload            => path($file)->basename,
        SUBMIT_pause99_add_uri_httpupload => ' Upload this file from my disk ',
        pause99_add_uri_uri               => '',
        pause99_add_uri_httpupload        => {file => $file},
      }
    );
  
    unless ($tx->success) {
      my $code = $tx->res->code // 0;
      my $msg  = $tx->error->{message};
      if    ($code == 401) { $msg = 'Wrong username or password.' }
      elsif ($code == 409) { $msg = 'File already exists on CPAN.' }
      die qq{Problem uploading file "$file": $msg\n};
    }
  
    say 'Upload successful!';
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::cpanify - CPAN-ify command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION cpanify [OPTIONS] [FILE]
  
      mojo cpanify -u sri -p secr3t Mojolicious-Plugin-MyPlugin-0.01.tar.gz
  
    Options:
      -h, --help                  Show this summary of available options
      -p, --password <password>   PAUSE password
      -u, --user <name>           PAUSE username
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::cpanify> uploads files to CPAN.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::cpanify> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $cpanify->description;
    $cpanify        = $cpanify->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $cpanify->usage;
    $cpanify  = $cpanify->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::cpanify> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $cpanify->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_CPANIFY

$fatpacked{"Mojolicious/Command/daemon.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_DAEMON';
  package Mojolicious::Command::daemon;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Server::Daemon;
  use Mojo::Util 'getopt';
  
  has description => 'Start application with HTTP and WebSocket server';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    my $daemon = Mojo::Server::Daemon->new(app => $self->app);
    getopt \@args,
      'b|backlog=i'            => sub { $daemon->backlog($_[1]) },
      'c|clients=i'            => sub { $daemon->max_clients($_[1]) },
      'i|inactivity-timeout=i' => sub { $daemon->inactivity_timeout($_[1]) },
      'l|listen=s'             => \my @listen,
      'p|proxy'                => sub { $daemon->reverse_proxy(1) },
      'r|requests=i'           => sub { $daemon->max_requests($_[1]) };
  
    $daemon->listen(\@listen) if @listen;
    $daemon->run;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::daemon - Daemon command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION daemon [OPTIONS]
  
      ./myapp.pl daemon
      ./myapp.pl daemon -m production -l http://*:8080
      ./myapp.pl daemon -l http://127.0.0.1:8080 -l https://[::]:8081
      ./myapp.pl daemon -l 'https://*:443?cert=./server.crt&key=./server.key'
      ./myapp.pl daemon -l http+unix://%2Ftmp%2Fmyapp.sock
  
    Options:
      -b, --backlog <size>                 Listen backlog size, defaults to
                                           SOMAXCONN
      -c, --clients <number>               Maximum number of concurrent
                                           connections, defaults to 1000
      -h, --help                           Show this summary of available options
          --home <path>                    Path to home directory of your
                                           application, defaults to the value of
                                           MOJO_HOME or auto-detection
      -i, --inactivity-timeout <seconds>   Inactivity timeout, defaults to the
                                           value of MOJO_INACTIVITY_TIMEOUT or 15
      -l, --listen <location>              One or more locations you want to
                                           listen on, defaults to the value of
                                           MOJO_LISTEN or "http://*:3000"
      -m, --mode <name>                    Operating mode for your application,
                                           defaults to the value of
                                           MOJO_MODE/PLACK_ENV or "development"
      -p, --proxy                          Activate reverse proxy support,
                                           defaults to the value of
                                           MOJO_REVERSE_PROXY
      -r, --requests <number>              Maximum number of requests per
                                           keep-alive connection, defaults to 100
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::daemon> starts applications with the
  L<Mojo::Server::Daemon> backend.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::daemon> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $daemon->description;
    $daemon         = $daemon->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $daemon->usage;
    $daemon   = $daemon->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::daemon> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $daemon->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_DAEMON

$fatpacked{"Mojolicious/Command/eval.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_EVAL';
  package Mojolicious::Command::eval;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Util 'getopt';
  
  has description => 'Run code against application';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    getopt \@args, 'v|verbose' => \my $v1, 'V' => \my $v2;
    my $code = shift @args || '';
  
    # Run code against application
    my $app = $self->app;
    no warnings;
    my $result = eval "package main; sub app; local *app = sub { \$app }; $code";
    return $@ ? die $@ : $result unless defined $result && ($v1 || $v2);
    $v2 ? print($app->dumper($result)) : say $result;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::eval - Eval command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION eval [OPTIONS] CODE
  
      ./myapp.pl eval 'say app->ua->get("/")->result->body'
      ./myapp.pl eval 'say for sort keys %{app->renderer->helpers}'
      ./myapp.pl eval -v 'app->home'
      ./myapp.pl eval -V 'app->renderer->paths'
  
    Options:
      -h, --help          Show this summary of available options
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
      -v, --verbose       Print return value to STDOUT
      -V                  Print returned data structure to STDOUT
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::eval> runs code against applications.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::eval> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $eval->description;
    $eval           = $eval->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $eval->usage;
    $eval     = $eval->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::eval> inherits all methods from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 run
  
    $eval->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_EVAL

$fatpacked{"Mojolicious/Command/generate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE';
  package Mojolicious::Command::generate;
  use Mojo::Base 'Mojolicious::Commands';
  
  has description => 'Generate files and directories from templates';
  has hint        => <<EOF;
  
  See 'APPLICATION generate help GENERATOR' for more information on a specific
  generator.
  EOF
  has message    => sub { shift->extract_usage . "\nGenerators:\n" };
  has namespaces => sub { ['Mojolicious::Command::generate'] };
  
  sub help { shift->run(@_) }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::generate - Generator command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION generate GENERATOR [OPTIONS]
  
      mojo generate app
      mojo generate lite_app
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::generate> lists available generators.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::generate> inherits all attributes from
  L<Mojolicious::Commands> and implements the following new ones.
  
  =head2 description
  
    my $description = $generator->description;
    $generator      = $generator->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 hint
  
    my $hint   = $generator->hint;
    $generator = $generator->hint('Foo');
  
  Short hint shown after listing available generator commands.
  
  =head2 message
  
    my $msg    = $generator->message;
    $generator = $generator->message('Bar');
  
  Short usage message shown before listing available generator commands.
  
  =head2 namespaces
  
    my $namespaces = $generator->namespaces;
    $generator     = $generator->namespaces(['MyApp::Command::generate']);
  
  Namespaces to search for available generator commands, defaults to
  L<Mojolicious::Command::generate>.
  
  =head1 METHODS
  
  L<Mojolicious::Command::generate> inherits all methods from
  L<Mojolicious::Commands> and implements the following new ones.
  
  =head2 help
  
    $generator->help('app');
  
  Print usage information for generator command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_GENERATE

$fatpacked{"Mojolicious/Command/generate/app.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE_APP';
  package Mojolicious::Command::generate::app;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Util qw(class_to_file class_to_path decamelize);
  
  has description => 'Generate Mojolicious application directory structure';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, $class) = (shift, shift || 'MyApp');
  
    # Prevent bad applications
    die <<EOF unless $class =~ /^[A-Z](?:\w|::)+$/;
  Your application name has to be a well formed (CamelCase) Perl module name
  like "MyApp".
  EOF
  
    # Script
    my $name = class_to_file $class;
    $self->template({vars => 1});
    $self->render_to_rel_file('mojo', "$name/script/$name", {class => $class});
    $self->chmod_rel_file("$name/script/$name", 0744);
  
    # Application class
    my $app = class_to_path $class;
    $self->render_to_rel_file('appclass', "$name/lib/$app", {class => $class});
  
    # Config file (using the default moniker)
    $self->render_to_rel_file('config', "$name/@{[decamelize $class]}.conf");
  
    # Controller
    my $controller = "${class}::Controller::Example";
    my $path       = class_to_path $controller;
    $self->render_to_rel_file('controller', "$name/lib/$path",
      {class => $controller});
  
    # Test
    $self->render_to_rel_file('test', "$name/t/basic.t", {class => $class});
  
    # Static file
    $self->render_to_rel_file('static', "$name/public/index.html");
  
    # Templates
    $self->render_to_rel_file('layout',
      "$name/templates/layouts/default.html.ep");
    $self->render_to_rel_file('welcome',
      "$name/templates/example/welcome.html.ep");
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::generate::app - App generator command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION generate app [OPTIONS] [NAME]
  
      mojo generate app
      mojo generate app TestApp
  
    Options:
      -h, --help   Show this summary of available options
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::generate::app> generates application directory
  structures for fully functional L<Mojolicious> applications.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::generate::app> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $app->description;
    $app            = $app->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $app->usage;
    $app      = $app->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::generate::app> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $app->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
  
  __DATA__
  
  @@ mojo
  #!/usr/bin/env perl
  
  use strict;
  use warnings;
  
  use FindBin;
  BEGIN { unshift @INC, "$FindBin::Bin/../lib" }
  use Mojolicious::Commands;
  
  # Start command line interface for application
  Mojolicious::Commands->start_app('<%= $class %>');
  
  @@ appclass
  package <%= $class %>;
  use Mojo::Base 'Mojolicious';
  
  # This method will run once at server start
  sub startup {
    my $self = shift;
  
    # Load configuration from hash returned by "my_app.conf"
    my $config = $self->plugin('Config');
  
    # Documentation browser under "/perldoc"
    $self->plugin('PODRenderer') if $config->{perldoc};
  
    # Router
    my $r = $self->routes;
  
    # Normal route to controller
    $r->get('/')->to('example#welcome');
  }
  
  1;
  
  @@ controller
  package <%= $class %>;
  use Mojo::Base 'Mojolicious::Controller';
  
  # This action will render a template
  sub welcome {
    my $self = shift;
  
    # Render template "example/welcome.html.ep" with message
    $self->render(msg => 'Welcome to the Mojolicious real-time web framework!');
  }
  
  1;
  
  @@ static
  <!DOCTYPE html>
  <html>
    <head>
      <title>Welcome to the Mojolicious real-time web framework!</title>
    </head>
    <body>
      <h2>Welcome to the Mojolicious real-time web framework!</h2>
      This is the static document "public/index.html",
      <a href="/">click here</a> to get back to the start.
    </body>
  </html>
  
  @@ test
  use Mojo::Base -strict;
  
  use Test::More;
  use Test::Mojo;
  
  my $t = Test::Mojo->new('<%= $class %>');
  $t->get_ok('/')->status_is(200)->content_like(qr/Mojolicious/i);
  
  done_testing();
  
  @@ layout
  <!DOCTYPE html>
  <html>
    <head><title><%%= title %></title></head>
    <body><%%= content %></body>
  </html>
  
  @@ welcome
  %% layout 'default';
  %% title 'Welcome';
  <h2><%%= $msg %></h2>
  <p>
    This page was generated from the template "templates/example/welcome.html.ep"
    and the layout "templates/layouts/default.html.ep",
    <%%= link_to 'click here' => url_for %> to reload the page or
    <%%= link_to 'here' => '/index.html' %> to move forward to a static page.
    %% if (config 'perldoc') {
      To learn more, you can also browse through the documentation
      <%%= link_to 'here' => '/perldoc' %>.
    %% }
  </p>
  
  @@ config
  % use Mojo::Util qw(sha1_sum steady_time);
  {
    perldoc => 1,
    secrets => ['<%= sha1_sum $$ . steady_time . rand  %>']
  }
MOJOLICIOUS_COMMAND_GENERATE_APP

$fatpacked{"Mojolicious/Command/generate/lite_app.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE_LITE_APP';
  package Mojolicious::Command::generate::lite_app;
  use Mojo::Base 'Mojolicious::Command';
  
  has description => 'Generate Mojolicious::Lite application';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, $name) = (shift, shift || 'myapp.pl');
    $self->render_to_rel_file('liteapp', $name);
    $self->chmod_rel_file($name, 0744);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::generate::lite_app - Lite app generator command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION generate lite_app [OPTIONS] [NAME]
  
      mojo generate lite_app
      mojo generate lite_app foo.pl
  
    Options:
      -h, --help   Show this summary of available options
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::generate::lite_app> generate fully functional
  L<Mojolicious::Lite> applications.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::generate::lite_app> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $app->description;
    $app            = $app->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $app->usage;
    $app      = $app->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::generate::lite_app> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $app->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
  
  __DATA__
  
  @@ liteapp
  #!/usr/bin/env perl
  use Mojolicious::Lite;
  
  # Documentation browser under "/perldoc"
  plugin 'PODRenderer';
  
  get '/' => sub {
    my $c = shift;
    $c->render(template => 'index');
  };
  
  app->start;
  <% %>__DATA__
  
  <% %>@@ index.html.ep
  %% layout 'default';
  %% title 'Welcome';
  <h1>Welcome to the Mojolicious real-time web framework!</h1>
  To learn more, you can browse through the documentation
  <%%= link_to 'here' => '/perldoc' %>.
  
  <% %>@@ layouts/default.html.ep
  <!DOCTYPE html>
  <html>
    <head><title><%%= title %></title></head>
    <body><%%= content %></body>
  </html>
MOJOLICIOUS_COMMAND_GENERATE_LITE_APP

$fatpacked{"Mojolicious/Command/generate/makefile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE_MAKEFILE';
  package Mojolicious::Command::generate::makefile;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojolicious;
  
  has description => 'Generate "Makefile.PL"';
  has usage => sub { shift->extract_usage };
  
  sub run { shift->render_to_rel_file('makefile', 'Makefile.PL') }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::generate::makefile - Makefile generator command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION generate makefile [OPTIONS]
  
      mojo generate makefile
  
    Options:
      -h, --help   Show this summary of available options
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::generate::makefile> generates C<Makefile.PL> files for
  applications.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::generate::makefile> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $makefile->description;
    $makefile       = $makefile->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $makefile->usage;
    $makefile = $makefile->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::generate::makefile> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $makefile->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
  
  __DATA__
  
  @@ makefile
  use strict;
  use warnings;
  
  use ExtUtils::MakeMaker;
  
  WriteMakefile(
    VERSION   => '0.01',
    PREREQ_PM => {'Mojolicious' => '<%= $Mojolicious::VERSION %>'},
    test      => {TESTS => 't/*.t'}
  );
MOJOLICIOUS_COMMAND_GENERATE_MAKEFILE

$fatpacked{"Mojolicious/Command/generate/plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE_PLUGIN';
  package Mojolicious::Command::generate::plugin;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Util qw(camelize class_to_path);
  use Mojolicious;
  
  has description => 'Generate Mojolicious plugin directory structure';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, $name) = (shift, shift || 'MyPlugin');
  
    # Class
    my $class = $name =~ /^[a-z]/ ? camelize $name : $name;
    $class = "Mojolicious::Plugin::$class";
    my $app = class_to_path $class;
    my $dir = join '-', split('::', $class);
    $self->template({vars => 1});
    $self->render_to_rel_file('class', "$dir/lib/$app",
      {class => $class, name => $name});
  
    # Test
    $self->render_to_rel_file('test', "$dir/t/basic.t", {name => $name});
  
    # Makefile
    $self->render_to_rel_file('makefile', "$dir/Makefile.PL",
      {class => $class, path => $app});
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::generate::plugin - Plugin generator command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION generate plugin [OPTIONS] [NAME]
  
      mojo generate plugin
      mojo generate plugin TestPlugin
  
    Options:
      -h, --help   Show this summary of available options
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::generate::plugin> generates directory structures for
  fully functional L<Mojolicious> plugins.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::generate::plugin> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $plugin->description;
    $plugin         = $plugin->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $plugin->usage;
    $plugin   = $plugin->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::generate::plugin> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $plugin->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
  
  __DATA__
  
  @@ class
  package <%= $class %>;
  use Mojo::Base 'Mojolicious::Plugin';
  
  our $VERSION = '0.01';
  
  sub register {
    my ($self, $app) = @_;
  }
  
  1;
  <% %>__END__
  
  <% %>=encoding utf8
  
  <% %>=head1 NAME
  
  <%= $class %> - Mojolicious Plugin
  
  <% %>=head1 SYNOPSIS
  
    # Mojolicious
    $self->plugin('<%= $name %>');
  
    # Mojolicious::Lite
    plugin '<%= $name %>';
  
  <% %>=head1 DESCRIPTION
  
  L<<%= $class %>> is a L<Mojolicious> plugin.
  
  <% %>=head1 METHODS
  
  L<<%= $class %>> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  <% %>=head2 register
  
    $plugin->register(Mojolicious->new);
  
  Register plugin in L<Mojolicious> application.
  
  <% %>=head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  <% %>=cut
  
  @@ test
  use Mojo::Base -strict;
  
  use Test::More;
  use Mojolicious::Lite;
  use Test::Mojo;
  
  plugin '<%= $name %>';
  
  get '/' => sub {
    my $c = shift;
    $c->render(text => 'Hello Mojo!');
  };
  
  my $t = Test::Mojo->new;
  $t->get_ok('/')->status_is(200)->content_is('Hello Mojo!');
  
  done_testing();
  
  @@ makefile
  use strict;
  use warnings;
  
  use ExtUtils::MakeMaker;
  
  WriteMakefile(
    NAME         => '<%= $class %>',
    VERSION_FROM => 'lib/<%= $path %>',
    AUTHOR       => 'A Good Programmer <nospam@cpan.org>',
    PREREQ_PM    => {'Mojolicious' => '<%= $Mojolicious::VERSION %>'},
    test         => {TESTS => 't/*.t'}
  );
MOJOLICIOUS_COMMAND_GENERATE_PLUGIN

$fatpacked{"Mojolicious/Command/get.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GET';
  package Mojolicious::Command::get;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::DOM;
  use Mojo::IOLoop;
  use Mojo::JSON qw(to_json j);
  use Mojo::JSON::Pointer;
  use Mojo::URL;
  use Mojo::UserAgent;
  use Mojo::Util qw(decode encode getopt);
  use Scalar::Util 'weaken';
  
  has description => 'Perform HTTP request';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    # Data from STDIN
    vec(my $r = '', fileno(STDIN), 1) = 1;
    my $in = !-t STDIN && select($r, undef, undef, 0) ? join '', <STDIN> : undef;
  
    my $ua = Mojo::UserAgent->new(ioloop => Mojo::IOLoop->singleton);
    my %form;
    getopt \@args,
      'C|charset=s' => \my $charset,
      'c|content=s' => \$in,
      'f|form=s'    => sub { _form(\%form) if $_[1] =~ /^(.+)=(\@?)(.+)$/ },
      'H|header=s'  => \my @headers,
      'i|inactivity-timeout=i' => sub { $ua->inactivity_timeout($_[1]) },
      'k|insecure'             => sub { $ua->insecure(1) },
      'M|method=s'             => \(my $method = 'GET'),
      'o|connect-timeout=i'    => sub { $ua->connect_timeout($_[1]) },
      'r|redirect'             => \my $redirect,
      'S|response-size=i'      => sub { $ua->max_response_size($_[1]) },
      'u|user=s'               => \my $user,
      'v|verbose'              => \my $verbose;
  
    @args = map { decode 'UTF-8', $_ } @args;
    die $self->usage unless my $url = shift @args;
    my $selector = shift @args;
  
    # Parse header pairs
    my %headers = map { /^\s*([^:]+)\s*:\s*(.*+)$/ ? ($1, $2) : () } @headers;
  
    # Detect proxy for absolute URLs
    $url !~ m!^/! ? $ua->proxy->detect : $ua->server->app($self->app);
    $url = Mojo::URL->new($url)->userinfo($user) if $user;
    $ua->max_redirects(10) if $redirect;
  
    my $buffer = '';
    $ua->on(
      start => sub {
        my ($ua, $tx) = @_;
  
        # Verbose
        weaken $tx;
        $tx->res->content->on(
          body => sub { warn _header($tx->req), _header($tx->res) })
          if $verbose;
  
        # Stream content (ignore redirects)
        $tx->res->content->unsubscribe('read')->on(
          read => sub {
            return if $redirect && $tx->res->is_redirect;
            defined $selector ? ($buffer .= pop) : print pop;
          }
        );
      }
    );
  
    # Switch to verbose for HEAD requests
    $verbose = 1 if $method eq 'HEAD';
    STDOUT->autoflush(1);
    my @content = %form ? (form => \%form) : defined $in ? ($in) : ();
    my $tx = $ua->start($ua->build_tx($method, $url, \%headers, @content));
    my $res = $tx->result;
  
    # JSON Pointer
    return unless defined $selector;
    return _json($buffer, $selector) if !length $selector || $selector =~ m!^/!;
  
    # Selector
    $charset //= $res->content->charset || $res->default_charset;
    _select($buffer, $selector, $charset, @args);
  }
  
  sub _form { push @{$_[0]{$1}}, $2 ? {file => $3} : $3 }
  
  sub _header { $_[0]->build_start_line, $_[0]->headers->to_string, "\n\n" }
  
  sub _json {
    return unless my $data = j(shift);
    return unless defined($data = Mojo::JSON::Pointer->new($data)->get(shift));
    _say(ref $data eq 'HASH' || ref $data eq 'ARRAY' ? to_json($data) : $data);
  }
  
  sub _say { length && say encode('UTF-8', $_) for @_ }
  
  sub _select {
    my ($buffer, $selector, $charset, @args) = @_;
  
    # Keep a strong reference to the root
    $buffer = decode($charset, $buffer) // $buffer if $charset;
    my $dom     = Mojo::DOM->new($buffer);
    my $results = $dom->find($selector);
  
    while (defined(my $command = shift @args)) {
  
      # Number
      ($results = $results->slice($command)) and next if $command =~ /^\d+$/;
  
      # Text
      return _say($results->map('text')->each) if $command eq 'text';
  
      # All text
      return _say($results->map('all_text')->each) if $command eq 'all';
  
      # Attribute
      return _say($results->map(attr => $args[0] // '')->each)
        if $command eq 'attr';
  
      # Unknown
      die qq{Unknown command "$command".\n};
    }
  
    _say($results->each);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::get - Get command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION get [OPTIONS] URL [SELECTOR|JSON-POINTER] [COMMANDS]
  
      ./myapp.pl get /
      ./myapp.pl get -H 'Accept: text/html' /hello.html 'head > title' text
      ./myapp.pl get //sri:secr3t@/secrets.json /1/content
      mojo get mojolicious.org
      mojo get -v -r -o 25 -i 50 google.com
      mojo get -v -H 'Host: mojolicious.org' -H 'Accept: */*' mojolicious.org
      mojo get -u 'sri:s3cret' https://mojolicious.org
      mojo get mojolicious.org > example.html
      mojo get -M PUT mojolicious.org < example.html
      mojo get -f 'q=Mojolicious' -f 'size=5' https://metacpan.org/search
      mojo get -M POST -f 'upload=@example.html' mojolicious.org
      mojo get mojolicious.org 'head > title' text
      mojo get mojolicious.org .footer all
      mojo get mojolicious.org a attr href
      mojo get mojolicious.org '*' attr id
      mojo get mojolicious.org 'h1, h2, h3' 3 text
      mojo get https://fastapi.metacpan.org/v1/author/SRI /name
      mojo get -H 'Host: example.com' http+unix://%2Ftmp%2Fmyapp.sock/index.html
  
    Options:
      -C, --charset <charset>              Charset of HTML/XML content, defaults
                                           to auto-detection
      -c, --content <content>              Content to send with request
      -f, --form <name=value>              One or more form values and file
                                           uploads
      -H, --header <name:value>            One or more additional HTTP headers
      -h, --help                           Show this summary of available options
          --home <path>                    Path to home directory of your
                                           application, defaults to the value of
                                           MOJO_HOME or auto-detection
      -i, --inactivity-timeout <seconds>   Inactivity timeout, defaults to the
                                           value of MOJO_INACTIVITY_TIMEOUT or 20
      -k, --insecure                       Do not require a valid TLS certificate
                                           to access HTTPS sites
      -M, --method <method>                HTTP method to use, defaults to "GET"
      -m, --mode <name>                    Operating mode for your application,
                                           defaults to the value of
                                           MOJO_MODE/PLACK_ENV or "development"
      -o, --connect-timeout <seconds>      Connect timeout, defaults to the value
                                           of MOJO_CONNECT_TIMEOUT or 10
      -r, --redirect                       Follow up to 10 redirects
      -S, --response-size <size>           Maximum response size in bytes,
                                           defaults to 2147483648 (2GiB)
      -u, --user <userinfo>                Alternate mechanism for specifying
                                           colon-separated username and password
      -v, --verbose                        Print request and response headers to
                                           STDERR
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::get> is a command line interface for
  L<Mojo::UserAgent>.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::get> performs requests to remote hosts or local
  applications.
  
  =head2 description
  
    my $description = $get->description;
    $get            = $get->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $get->usage;
    $get      = $get->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::get> inherits all methods from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 run
  
    $get->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_GET

$fatpacked{"Mojolicious/Command/inflate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_INFLATE';
  package Mojolicious::Command::inflate;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Loader qw(data_section file_is_binary);
  use Mojo::Util 'encode';
  
  has description => 'Inflate embedded files to real files';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my $self = shift;
  
    # Find all embedded files
    my %all;
    my $app = $self->app;
    for my $class (@{$app->renderer->classes}, @{$app->static->classes}) {
      for my $name (keys %{data_section $class}) {
        my $data = data_section $class, $name;
        $data = encode 'UTF-8', $data unless file_is_binary $class, $name;
        $all{$name} = $data;
      }
    }
  
    # Turn them into real files
    for my $name (grep {/\.\w+$/} keys %all) {
      my $prefix = $name =~ /\.\w+\.\w+$/ ? 'templates' : 'public';
      $self->write_file($self->rel_file("$prefix/$name"), $all{$name});
    }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::inflate - Inflate command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION inflate [OPTIONS]
  
      ./myapp.pl inflate
  
    Options:
      -h, --help          Show this summary of available options
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::inflate> turns templates and static files embedded in
  the C<DATA> sections of your application into real files.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::inflate> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $inflate->description;
    $inflate        = $inflate->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $inflate->usage;
    $inflate  = $inflate->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::inflate> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $inflate->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_INFLATE

$fatpacked{"Mojolicious/Command/prefork.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_PREFORK';
  package Mojolicious::Command::prefork;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Server::Prefork;
  use Mojo::Util 'getopt';
  
  has description =>
    'Start application with pre-forking HTTP and WebSocket server';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    my $prefork = Mojo::Server::Prefork->new(app => $self->app);
    getopt \@args,
      'a|accepts=i'            => sub { $prefork->accepts($_[1]) },
      'b|backlog=i'            => sub { $prefork->backlog($_[1]) },
      'c|clients=i'            => sub { $prefork->max_clients($_[1]) },
      'G|graceful-timeout=i'   => sub { $prefork->graceful_timeout($_[1]) },
      'I|heartbeat-interval=i' => sub { $prefork->heartbeat_interval($_[1]) },
      'H|heartbeat-timeout=i'  => sub { $prefork->heartbeat_timeout($_[1]) },
      'i|inactivity-timeout=i' => sub { $prefork->inactivity_timeout($_[1]) },
      'l|listen=s'             => \my @listen,
      'P|pid-file=s'           => sub { $prefork->pid_file($_[1]) },
      'p|proxy'                => sub { $prefork->reverse_proxy(1) },
      'r|requests=i'           => sub { $prefork->max_requests($_[1]) },
      's|spare=i'              => sub { $prefork->spare($_[1]) },
      'w|workers=i'            => sub { $prefork->workers($_[1]) };
  
    $prefork->listen(\@listen) if @listen;
    $prefork->run;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::prefork - Pre-fork command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION prefork [OPTIONS]
  
      ./myapp.pl prefork
      ./myapp.pl prefork -m production -l http://*:8080
      ./myapp.pl prefork -l http://127.0.0.1:8080 -l https://[::]:8081
      ./myapp.pl prefork -l 'https://*:443?cert=./server.crt&key=./server.key'
      ./myapp.pl prefork -l http+unix://%2Ftmp%2Fmyapp.sock -w 12
  
    Options:
      -a, --accepts <number>               Number of connections for workers to
                                           accept, defaults to 10000
      -b, --backlog <size>                 Listen backlog size, defaults to
                                           SOMAXCONN
      -c, --clients <number>               Maximum number of concurrent
                                           connections, defaults to 1000
      -G, --graceful-timeout <seconds>     Graceful timeout, defaults to 120.
      -I, --heartbeat-interval <seconds>   Heartbeat interval, defaults to 5
      -H, --heartbeat-timeout <seconds>    Heartbeat timeout, defaults to 30
      -h, --help                           Show this summary of available options
          --home <path>                    Path to home directory of your
                                           application, defaults to the value of
                                           MOJO_HOME or auto-detection
      -i, --inactivity-timeout <seconds>   Inactivity timeout, defaults to the
                                           value of MOJO_INACTIVITY_TIMEOUT or 15
      -l, --listen <location>              One or more locations you want to
                                           listen on, defaults to the value of
                                           MOJO_LISTEN or "http://*:3000"
      -m, --mode <name>                    Operating mode for your application,
                                           defaults to the value of
                                           MOJO_MODE/PLACK_ENV or "development"
      -P, --pid-file <path>                Path to process id file, defaults to
                                           "prefork.pid" in a temporary directory
      -p, --proxy                          Activate reverse proxy support,
                                           defaults to the value of
                                           MOJO_REVERSE_PROXY
      -r, --requests <number>              Maximum number of requests per
                                           keep-alive connection, defaults to 100
      -s, --spare <number>                 Temporarily spawn up to this number of
                                           additional workers, defaults to 2
      -w, --workers <number>               Number of workers, defaults to 4
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::prefork> starts applications with the
  L<Mojo::Server::Prefork> backend.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::prefork> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $prefork->description;
    $prefork        = $prefork->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $prefork->usage;
    $prefork  = $prefork->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::prefork> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $prefork->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_PREFORK

$fatpacked{"Mojolicious/Command/psgi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_PSGI';
  package Mojolicious::Command::psgi;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Server::PSGI;
  
  has description => 'Start application with PSGI';
  has usage => sub { shift->extract_usage };
  
  sub run { Mojo::Server::PSGI->new(app => shift->app)->to_psgi_app }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::psgi - PSGI command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION psgi [OPTIONS]
  
      ./myapp.pl psgi
  
    Options:
      -h, --help          Show this summary of available options
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::psgi> starts applications with the L<Mojo::Server::PSGI>
  backend.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::psgi> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $psgi->description;
    $psgi           = $psgi->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $psgi->usage;
    $psgi     = $psgi->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::psgi> inherits all methods from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 run
  
    my $app = $psgi->run;
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_PSGI

$fatpacked{"Mojolicious/Command/routes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_ROUTES';
  package Mojolicious::Command::routes;
  use Mojo::Base 'Mojolicious::Command';
  
  use re 'regexp_pattern';
  use Mojo::Util qw(encode getopt tablify);
  
  has description => 'Show available routes';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    getopt \@args, 'v|verbose' => \my $verbose;
  
    my $rows = [];
    _walk($_, 0, $rows, $verbose) for @{$self->app->routes->children};
    print encode('UTF-8', tablify($rows));
  }
  
  sub _walk {
    my ($route, $depth, $rows, $verbose) = @_;
  
    # Pattern
    my $prefix = '';
    if (my $i = $depth * 2) { $prefix .= ' ' x $i . '+' }
    push @$rows, my $row = [$prefix . ($route->pattern->unparsed || '/')];
  
    # Flags
    my @flags;
    push @flags, @{$route->over || []} ? 'C' : '.';
    push @flags, (my $partial = $route->partial) ? 'D' : '.';
    push @flags, $route->inline       ? 'U' : '.';
    push @flags, $route->is_websocket ? 'W' : '.';
    push @$row, join('', @flags) if $verbose;
  
    # Methods
    my $via = $route->via;
    push @$row, !$via ? '*' : uc join ',', @$via;
  
    # Name
    my $name = $route->name;
    push @$row, $route->has_custom_name ? qq{"$name"} : $name;
  
    # Regex (verbose)
    my $pattern = $route->pattern;
    $pattern->match('/', $route->is_endpoint && !$partial);
    push @$row, (regexp_pattern $pattern->regex)[0] if $verbose;
  
    $depth++;
    _walk($_, $depth, $rows, $verbose) for @{$route->children};
    $depth--;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::routes - Routes command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION routes [OPTIONS]
  
      ./myapp.pl routes
      ./myapp.pl routes -v
  
    Options:
      -h, --help          Show this summary of available options
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
      -v, --verbose       Print additional details about routes, flags indicate
                          C=Conditions, D=Detour, U=Under and W=WebSocket
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::routes> lists all your application routes.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::routes> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $routes->description;
    $routes         = $routes->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $routes->usage;
    $routes   = $routes->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::routes> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $routes->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_ROUTES

$fatpacked{"Mojolicious/Command/test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_TEST';
  package Mojolicious::Command::test;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Util 'getopt';
  
  has description => 'Run tests';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my ($self, @args) = @_;
  
    getopt \@args, 'v|verbose' => \$ENV{HARNESS_VERBOSE};
  
    if (!@args && (my $tests = $self->app->home->child('t'))) {
      die "Can't find test directory.\n" unless -d $tests;
      @args = $tests->list_tree->grep(qr/\.t$/)->map('to_string')->each;
      say qq{Running tests from "$tests".};
    }
  
    $ENV{HARNESS_OPTIONS} //= 'c';
    require Test::Harness;
    local $Test::Harness::switches = '';
    Test::Harness::runtests(sort @args);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::test - Test command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION test [OPTIONS] [TESTS]
  
      ./myapp.pl test
      ./myapp.pl test t/foo.t
      ./myapp.pl test -v t/foo/*.t
  
    Options:
      -h, --help      Show this summary of available options
      -v, --verbose   Print verbose debug information to STDERR
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::test> runs application tests from the C<t> directory.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::test> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $test->description;
    $test           = $test->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $test->usage;
    $test     = $test->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::test> inherits all methods from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 run
  
    $test->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_TEST

$fatpacked{"Mojolicious/Command/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_VERSION';
  package Mojolicious::Command::version;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::IOLoop::Client;
  use Mojo::IOLoop::TLS;
  use Mojo::JSON;
  use Mojolicious;
  
  has description => 'Show versions of available modules';
  has usage => sub { shift->extract_usage };
  
  sub run {
    my $self = shift;
  
    my $json = Mojo::JSON->JSON_XS ? $Cpanel::JSON::XS::VERSION : 'n/a';
    my $ev = eval { require Mojo::Reactor::EV; 1 } ? $EV::VERSION : 'n/a';
    my $socks
      = Mojo::IOLoop::Client->can_socks ? $IO::Socket::Socks::VERSION : 'n/a';
    my $tls = Mojo::IOLoop::TLS->can_tls    ? $IO::Socket::SSL::VERSION  : 'n/a';
    my $nnr = Mojo::IOLoop::Client->can_nnr ? $Net::DNS::Native::VERSION : 'n/a';
    my $roles = Mojo::Base->ROLES ? $Role::Tiny::VERSION : 'n/a';
  
    print <<EOF;
  CORE
    Perl        ($^V, $^O)
    Mojolicious ($Mojolicious::VERSION, $Mojolicious::CODENAME)
  
  OPTIONAL
    Cpanel::JSON::XS 4.04+  ($json)
    EV 4.0+                 ($ev)
    IO::Socket::Socks 0.64+ ($socks)
    IO::Socket::SSL 2.009+  ($tls)
    Net::DNS::Native 0.15+  ($nnr)
    Role::Tiny 2.000001+    ($roles)
  
  EOF
  
    # Check latest version on CPAN
    my $latest = eval {
      $self->app->ua->max_redirects(10)->tap(sub { $_->proxy->detect })
        ->get('fastapi.metacpan.org/v1/release/Mojolicious')
        ->result->json->{version};
    } or return;
  
    my $msg = 'This version is up to date, have fun!';
    $msg = 'Thanks for testing a development release, you are awesome!'
      if $latest < $Mojolicious::VERSION;
    $msg = "You might want to update your Mojolicious to $latest!"
      if $latest > $Mojolicious::VERSION;
    say $msg;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Command::version - Version command
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION version [OPTIONS]
  
      mojo version
  
    Options:
      -h, --help   Show this summary of available options
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Command::version> shows version information for available core
  and optional modules.
  
  This is a core command, that means it is always enabled and its code a good
  example for learning to build new commands, you're welcome to fork it.
  
  See L<Mojolicious::Commands/"COMMANDS"> for a list of commands that are
  available by default.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Command::version> inherits all attributes from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 description
  
    my $description = $v->description;
    $v              = $v->description('Foo');
  
  Short description of this command, used for the command list.
  
  =head2 usage
  
    my $usage = $v->usage;
    $v        = $v->usage('Foo');
  
  Usage information for this command, used for the help screen.
  
  =head1 METHODS
  
  L<Mojolicious::Command::version> inherits all methods from
  L<Mojolicious::Command> and implements the following new ones.
  
  =head2 run
  
    $v->run(@ARGV);
  
  Run this command.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMAND_VERSION

$fatpacked{"Mojolicious/Commands.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMANDS';
  package Mojolicious::Commands;
  use Mojo::Base 'Mojolicious::Command';
  
  use Mojo::Loader qw(find_modules find_packages load_class);
  use Mojo::Server;
  use Mojo::Util qw(getopt tablify);
  
  has hint => <<EOF;
  
  See 'APPLICATION help COMMAND' for more information on a specific command.
  EOF
  has message    => sub { shift->extract_usage . "\nCommands:\n" };
  has namespaces => sub { ['Mojolicious::Command'] };
  
  sub detect {
  
    # PSGI (Plack only for now)
    return 'psgi' if defined $ENV{PLACK_ENV};
  
    # CGI
    return 'cgi' if defined $ENV{PATH_INFO} || defined $ENV{GATEWAY_INTERFACE};
  
    # Nothing
    return undef;
  }
  
  sub run {
    my ($self, $name, @args) = @_;
  
    # Application loader
    return $self->app if defined $ENV{MOJO_APP_LOADER};
  
    # Try to detect environment
    if (!$ENV{MOJO_NO_DETECT} && (my $env = $self->detect)) { $name = $env }
  
    # Run command
    if ($name && $name =~ /^\w+$/ && ($name ne 'help' || $args[0])) {
  
      # Help
      $name = shift @args if my $help = $name eq 'help';
      $help = $ENV{MOJO_HELP} ||= $help;
  
      # Remove options shared by all commands before loading the command
      _args(\@args);
      my $module;
      $module = _command("${_}::$name", 1) and last for @{$self->namespaces};
  
      # Unknown command
      die qq{Unknown command "$name", maybe you need to install it?\n}
        unless $module;
  
      # Run command
      my $command = $module->new(app => $self->app);
      return $help ? $command->help(@args) : $command->run(@args);
    }
  
    # Hide list for tests
    return 1 if $ENV{HARNESS_ACTIVE};
  
    # Find all available commands
    my %all;
    for my $ns (@{$self->namespaces}) {
      $all{substr $_, length "${ns}::"} //= $_->new->description
        for grep { _command($_) } find_modules($ns), find_packages($ns);
    }
  
    my @rows = map { [" $_", $all{$_}] } sort keys %all;
    return print $self->message, tablify(\@rows), $self->hint;
  }
  
  sub start_app { shift; Mojo::Server->new->build_app(shift)->start(@_) }
  
  # Command line options for MOJO_HELP, MOJO_HOME and MOJO_MODE
  sub _args {
    getopt shift, ['pass_through'],
      'h|help'   => \$ENV{MOJO_HELP},
      'home=s'   => \$ENV{MOJO_HOME},
      'm|mode=s' => \$ENV{MOJO_MODE}
      unless __PACKAGE__->detect;
  }
  
  # Do not remove options from @ARGV
  BEGIN { _args([@ARGV]) }
  
  sub _command {
    my ($module, $fatal) = @_;
    return $module->isa('Mojolicious::Command') ? $module : undef
      unless my $e = load_class $module;
    $fatal && ref $e ? die $e : return undef;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Commands - Command line interface
  
  =head1 SYNOPSIS
  
    Usage: APPLICATION COMMAND [OPTIONS]
  
      mojo version
      mojo generate lite_app
      ./myapp.pl daemon -m production -l http://*:8080
      ./myapp.pl get /foo
      ./myapp.pl routes -v
  
    Tip: CGI and PSGI environments can be automatically detected very often and
         work without commands.
  
    Options (for all commands):
      -h, --help          Get more information on a specific command
          --home <path>   Path to home directory of your application, defaults to
                          the value of MOJO_HOME or auto-detection
      -m, --mode <name>   Operating mode for your application, defaults to the
                          value of MOJO_MODE/PLACK_ENV or "development"
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Commands> is the interactive command line interface for the
  L<Mojolicious> framework. It will automatically detect available commands in
  the C<Mojolicious::Command> namespace.
  
  =head1 COMMANDS
  
  These commands are available by default.
  
  =head2 cgi
  
    $ ./myapp.pl cgi
  
  Use L<Mojolicious::Command::cgi> to start application with CGI backend, usually
  auto detected.
  
  =head2 cpanify
  
    $ mojo cpanify -u sri -p secr3t Mojolicious-Plugin-Fun-0.1.tar.gz
  
  Use L<Mojolicious::Command::cpanify> for uploading files to CPAN.
  
  =head2 daemon
  
    $ ./myapp.pl daemon
  
  Use L<Mojolicious::Command::daemon> to start application with standalone HTTP
  and WebSocket server.
  
  =head2 eval
  
    $ ./myapp.pl eval 'say app->home'
  
  Use L<Mojolicious::Command::eval> to run code against application.
  
  =head2 generate
  
    $ mojo generate
    $ mojo generate help
    $ ./myapp.pl generate help
  
  List available generator commands with short descriptions.
  
    $ mojo generate help <generator>
    $ ./myapp.pl generate help <generator>
  
  List available options for generator command with short descriptions.
  
  =head2 generate app
  
    $ mojo generate app <AppName>
  
  Use L<Mojolicious::Command::generate::app> to generate application directory
  structure for a fully functional L<Mojolicious> application.
  
  =head2 generate lite_app
  
    $ mojo generate lite_app
  
  Use L<Mojolicious::Command::generate::lite_app> to generate a fully functional
  L<Mojolicious::Lite> application.
  
  =head2 generate makefile
  
    $ mojo generate makefile
    $ ./myapp.pl generate makefile
  
  Use L<Mojolicious::Command::generate::makefile> to generate C<Makefile.PL> file
  for application.
  
  =head2 generate plugin
  
    $ mojo generate plugin <PluginName>
  
  Use L<Mojolicious::Command::generate::plugin> to generate directory structure
  for a fully functional L<Mojolicious> plugin.
  
  =head2 get
  
    $ mojo get https://mojolicious.org
    $ ./myapp.pl get /foo
  
  Use L<Mojolicious::Command::get> to perform requests to remote host or local
  application.
  
  =head2 help
  
    $ mojo
    $ mojo help
    $ ./myapp.pl help
  
  List available commands with short descriptions.
  
    $ mojo help <command>
    $ ./myapp.pl help <command>
  
  List available options for the command with short descriptions.
  
  =head2 inflate
  
    $ ./myapp.pl inflate
  
  Use L<Mojolicious::Command::inflate> to turn templates and static files
  embedded in the C<DATA> sections of your application into real files.
  
  =head2 prefork
  
    $ ./myapp.pl prefork
  
  Use L<Mojolicious::Command::prefork> to start application with standalone
  pre-forking HTTP and WebSocket server.
  
  =head2 psgi
  
    $ ./myapp.pl psgi
  
  Use L<Mojolicious::Command::psgi> to start application with PSGI backend,
  usually auto detected.
  
  =head2 routes
  
    $ ./myapp.pl routes
  
  Use L<Mojolicious::Command::routes> to list application routes.
  
  =head2 test
  
    $ ./myapp.pl test
    $ ./myapp.pl test t/fun.t
  
  Use L<Mojolicious::Command::test> to run application tests from the C<t>
  directory.
  
  =head2 version
  
    $ mojo version
    $ ./myapp.pl version
  
  Use L<Mojolicious::Command::version> to show version information for available
  core and optional modules, very useful for debugging.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Commands> inherits all attributes from L<Mojolicious::Command>
  and implements the following new ones.
  
  =head2 hint
  
    my $hint  = $commands->hint;
    $commands = $commands->hint('Foo');
  
  Short hint shown after listing available commands.
  
  =head2 message
  
    my $msg   = $commands->message;
    $commands = $commands->message('Hello World!');
  
  Short usage message shown before listing available commands.
  
  =head2 namespaces
  
    my $namespaces = $commands->namespaces;
    $commands      = $commands->namespaces(['MyApp::Command']);
  
  Namespaces to load commands from, defaults to C<Mojolicious::Command>.
  
    # Add another namespace to load commands from
    push @{$commands->namespaces}, 'MyApp::Command';
  
  =head1 METHODS
  
  L<Mojolicious::Commands> inherits all methods from L<Mojolicious::Command> and
  implements the following new ones.
  
  =head2 detect
  
    my $env = $commands->detect;
  
  Try to detect environment, or return C<undef> if none could be detected.
  
  =head2 run
  
    $commands->run;
    $commands->run(@ARGV);
  
  Load and run commands. Automatic deployment environment detection can be
  disabled with the C<MOJO_NO_DETECT> environment variable.
  
  =head2 start_app
  
    Mojolicious::Commands->start_app('MyApp');
    Mojolicious::Commands->start_app(MyApp => @ARGV);
  
  Load application from class and start the command line interface for it. Note
  that the options C<-h>/C<--help>, C<--home> and C<-m>/C<--mode>, which are
  shared by all commands, will be parsed from C<@ARGV> during compile time.
  
    # Always start daemon for application
    Mojolicious::Commands->start_app('MyApp', 'daemon', '-l', 'http://*:8080');
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_COMMANDS

$fatpacked{"Mojolicious/Controller.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_CONTROLLER';
  package Mojolicious::Controller;
  use Mojo::Base -base;
  
  # No imports, for security reasons!
  use Carp ();
  use Mojo::ByteStream;
  use Mojo::URL;
  use Mojo::Util;
  use Mojolicious::Routes::Match;
  use Scalar::Util ();
  
  has [qw(app tx)];
  has match =>
    sub { Mojolicious::Routes::Match->new(root => shift->app->routes) };
  
  # Reserved stash values
  my %RESERVED = map { $_ => 1 } (
    qw(action app cb controller data extends format handler inline json layout),
    qw(namespace path status template text variant)
  );
  
  sub AUTOLOAD {
    my $self = shift;
  
    my ($package, $method) = our $AUTOLOAD =~ /^(.+)::(.+)$/;
    Carp::croak "Undefined subroutine &${package}::$method called"
      unless Scalar::Util::blessed $self && $self->isa(__PACKAGE__);
  
    # Call helper with current controller
    Carp::croak qq{Can't locate object method "$method" via package "$package"}
      unless my $helper = $self->app->renderer->get_helper($method);
    return $self->$helper(@_);
  }
  
  sub continue { $_[0]->app->routes->continue($_[0]) }
  
  sub cookie {
    my ($self, $name) = (shift, shift);
  
    # Response cookie
    if (@_) {
  
      # Cookie too big
      my $cookie = {name => $name, value => shift, %{shift || {}}};
      $self->app->log->error(qq{Cookie "$name" is bigger than 4096 bytes})
        if length $cookie->{value} > 4096;
  
      $self->res->cookies($cookie);
      return $self;
    }
  
    # Request cookies
    return undef unless my $cookie = $self->req->cookie($name);
    return $cookie->value;
  }
  
  sub every_cookie {
    [map { $_->value } @{shift->req->every_cookie(shift)}];
  }
  
  sub every_param {
    my ($self, $name) = @_;
  
    # Captured unreserved values
    my $captures = $self->stash->{'mojo.captures'} ||= {};
    if (!$RESERVED{$name} && exists $captures->{$name}) {
      my $value = $captures->{$name};
      return ref $value eq 'ARRAY' ? $value : [$value];
    }
  
    # Uploads or param values
    my $req     = $self->req;
    my $uploads = $req->every_upload($name);
    return @$uploads ? $uploads : $req->every_param($name);
  }
  
  sub every_signed_cookie {
    my ($self, $name) = @_;
  
    my $secrets = $self->app->secrets;
    my @results;
    for my $value (@{$self->every_cookie($name)}) {
  
      # Check signature with rotating secrets
      if ($value =~ s/--([^\-]+)$//) {
        my $signature = $1;
  
        my $valid;
        for my $secret (@$secrets) {
          my $check = Mojo::Util::hmac_sha1_sum($value, $secret);
          ++$valid and last if Mojo::Util::secure_compare($signature, $check);
        }
        if ($valid) { push @results, $value }
  
        else { $self->app->log->debug(qq{Cookie "$name" has a bad signature}) }
      }
  
      else { $self->app->log->debug(qq{Cookie "$name" is not signed}) }
    }
  
    return \@results;
  }
  
  sub finish {
    my $self = shift;
  
    # WebSocket
    my $tx = $self->tx || Carp::croak 'Connection already closed';
    $tx->finish(@_) and return $tx->established ? $self : $self->rendered(101)
      if $tx->is_websocket;
  
    # Chunked stream
    return @_ ? $self->write_chunk(@_)->write_chunk('') : $self->write_chunk('')
      if $tx->res->content->is_chunked;
  
    # Normal stream
    return @_ ? $self->write(@_)->write('') : $self->write('');
  }
  
  sub flash {
    my $self = shift;
  
    # Check old flash
    my $session = $self->session;
    return $session->{flash} ? $session->{flash}{$_[0]} : undef
      if @_ == 1 && !ref $_[0];
  
    # Initialize new flash and merge values
    my $values = ref $_[0] ? $_[0] : {@_};
    @{$session->{new_flash} ||= {}}{keys %$values} = values %$values;
  
    return $self;
  }
  
  sub helpers { $_[0]->app->renderer->get_helper('')->($_[0]) }
  
  sub on {
    my ($self, $name, $cb) = @_;
    my $tx = $self->tx || Carp::croak 'Connection already closed';
    $self->rendered(101) if $tx->is_websocket && !$tx->established;
    return $tx->on($name => sub { shift; $self->$cb(@_) });
  }
  
  sub param {
    my ($self, $name) = (shift, shift);
    return $self->every_param($name)->[-1] unless @_;
    $self->stash->{'mojo.captures'}{$name} = @_ > 1 ? [@_] : $_[0];
    return $self;
  }
  
  sub redirect_to {
    my $self = shift;
  
    # Don't override 3xx status
    my $res = $self->res;
    $res->headers->location($self->url_for(@_));
    return $self->rendered($res->is_redirect ? () : 302);
  }
  
  sub render {
    my $self = shift;
  
    # Template may be first argument
    my ($template, $args) = (@_ % 2 ? shift : undef, {@_});
    $args->{template} = $template if $template;
    my $app = $self->app;
    my $plugins = $app->plugins->emit_hook(before_render => $self, $args);
  
    # Localize "extends" and "layout" to allow argument overrides
    my ($maybe, $ts) = @{$args}{'mojo.maybe', 'mojo.string'};
    my $stash = $self->stash;
    local $stash->{layout}  = $stash->{layout}  if exists $stash->{layout};
    local $stash->{extends} = $stash->{extends} if exists $stash->{extends};
  
    # Rendering to string
    local @{$stash}{keys %$args} if $ts || $maybe;
    delete @{$stash}{qw(layout extends)} if $ts;
  
    # All other arguments just become part of the stash
    @$stash{keys %$args} = values %$args;
    my ($output, $format) = $app->renderer->render($self, $args);
  
    # Maybe no 404
    return defined $output ? Mojo::ByteStream->new($output) : undef if $ts;
    return $maybe ? undef : !$self->helpers->reply->not_found
      unless defined $output;
  
    $plugins->emit_hook(after_render => $self, \$output, $format);
    my $headers = $self->res->body($output)->headers;
    $headers->content_type($app->types->type($format) || 'text/plain')
      unless $headers->content_type;
    return !!$self->rendered($stash->{status});
  }
  
  sub render_later { shift->stash('mojo.rendered' => 1) }
  
  sub render_maybe { shift->render(@_, 'mojo.maybe' => 1) }
  
  sub render_to_string { shift->render(@_, 'mojo.string' => 1) }
  
  sub rendered {
    my ($self, $status) = @_;
  
    # Make sure we have a status
    my $res = $self->res;
    $res->code($status || 200) if $status || !$res->code;
  
    # Finish transaction
    my $stash = $self->stash;
    if (!$stash->{'mojo.finished'} && ++$stash->{'mojo.finished'}) {
  
      # Disable auto rendering and stop timer
      my $app    = $self->render_later->app;
      my $timing = $self->helpers->timing;
      if (defined(my $elapsed = $timing->elapsed('mojo.timer'))) {
        my $rps  = $timing->rps($elapsed) // '??';
        my $code = $res->code;
        my $msg  = $res->message || $res->default_message($code);
        $app->log->debug("$code $msg (${elapsed}s, $rps/s)");
      }
  
      $app->plugins->emit_hook_reverse(after_dispatch => $self);
      $app->sessions->store($self);
    }
    $self->tx->resume;
    return $self;
  }
  
  sub req { (shift->tx || Carp::croak 'Connection already closed')->req }
  sub res { (shift->tx || Carp::croak 'Connection already closed')->res }
  
  sub respond_to {
    my ($self, $args) = (shift, ref $_[0] ? $_[0] : {@_});
  
    # Find target
    my $target;
    my $renderer = $self->app->renderer;
    my @formats  = @{$renderer->accepts($self)};
    for my $format (@formats ? @formats : ($renderer->default_format)) {
      next unless $target = $args->{$format};
      $self->stash->{format} = $format;
      last;
    }
  
    # Fallback
    unless ($target) {
      return $self->rendered(204) unless $target = $args->{any};
      delete $self->stash->{format};
    }
  
    # Dispatch
    ref $target eq 'CODE' ? $target->($self) : $self->render(%$target);
  
    return $self;
  }
  
  sub send {
    my ($self, $msg, $cb) = @_;
    my $tx = $self->tx || Carp::croak 'Connection already closed';
    Carp::croak 'No WebSocket connection to send message to'
      unless $tx->is_websocket;
    $tx->send($msg, $cb ? sub { shift; $self->$cb(@_) } : ());
    return $tx->established ? $self : $self->rendered(101);
  }
  
  sub session {
    my $self = shift;
  
    my $stash = $self->stash;
    $self->app->sessions->load($self)
      unless exists $stash->{'mojo.active_session'};
  
    # Hash
    my $session = $stash->{'mojo.session'} ||= {};
    return $session unless @_;
  
    # Get
    return $session->{$_[0]} unless @_ > 1 || ref $_[0];
  
    # Set
    my $values = ref $_[0] ? $_[0] : {@_};
    @$session{keys %$values} = values %$values;
  
    return $self;
  }
  
  sub signed_cookie {
    my ($self, $name, $value, $options) = @_;
  
    # Request cookie
    return $self->every_signed_cookie($name)->[-1] unless defined $value;
  
    # Response cookie
    my $checksum = Mojo::Util::hmac_sha1_sum($value, $self->app->secrets->[0]);
    return $self->cookie($name, "$value--$checksum", $options);
  }
  
  sub stash { Mojo::Util::_stash(stash => @_) }
  
  sub url_for {
    my ($self, $target) = (shift, shift // '');
  
    # Absolute URL
    return $target if Scalar::Util::blessed $target && $target->isa('Mojo::URL');
    return Mojo::URL->new($target) if $target =~ m!^(?:[^:/?#]+:|//|#)!;
  
    # Base
    my $url  = Mojo::URL->new;
    my $req  = $self->req;
    my $base = $url->base($req->url->base->clone)->base->userinfo(undef);
  
    # Relative URL
    my $path = $url->path;
    if ($target =~ m!^/!) {
      if (defined(my $prefix = $self->stash->{path})) {
        my $real = $req->url->path->to_route;
        $real =~ s!/?\Q$prefix\E$!$target!;
        $target = $real;
      }
      $url->parse($target);
    }
  
    # Route
    else {
      my $generated = $self->match->path_for($target, @_);
      $path->parse($generated->{path}) if $generated->{path};
      $base->scheme($base->protocol eq 'https' ? 'wss' : 'ws')
        if $generated->{websocket};
    }
  
    # Make path absolute
    my $base_path = $base->path;
    unshift @{$path->parts}, @{$base_path->parts};
    $base_path->parts([])->trailing_slash(0);
  
    return $url;
  }
  
  sub validation {
    my $self = shift;
  
    my $stash = $self->stash;
    return $stash->{'mojo.validation'} if $stash->{'mojo.validation'};
  
    my $req    = $self->req;
    my $token  = $self->session->{csrf_token};
    my $header = $req->headers->header('X-CSRF-Token');
    my $hash   = $req->params->to_hash;
    $hash->{csrf_token} //= $header if $token && $header;
    $hash->{$_} = $req->every_upload($_) for map { $_->name } @{$req->uploads};
    my $v = $self->app->validator->validation->input($hash);
    return $stash->{'mojo.validation'} = $v->csrf_token($token);
  }
  
  sub write {
    my ($self, $chunk, $cb) = @_;
    $self->res->content->write($chunk, $cb ? sub { shift; $self->$cb(@_) } : ());
    return $self->rendered;
  }
  
  sub write_chunk {
    my ($self, $chunk, $cb) = @_;
    my $content = $self->res->content;
    $content->write_chunk($chunk, $cb ? sub { shift; $self->$cb(@_) } : ());
    return $self->rendered;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Controller - Controller base class
  
  =head1 SYNOPSIS
  
    # Controller
    package MyApp::Controller::Foo;
    use Mojo::Base 'Mojolicious::Controller';
  
    # Action
    sub bar {
      my $self = shift;
      my $name = $self->param('name');
      $self->res->headers->cache_control('max-age=1, no-cache');
      $self->render(json => {hello => $name});
    }
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Controller> is the base class for your L<Mojolicious>
  controllers. It is also the default controller class unless you set
  L<Mojolicious/"controller_class">.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Controller> inherits all attributes from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 app
  
    my $app = $c->app;
    $c      = $c->app(Mojolicious->new);
  
  A reference back to the application that dispatched to this controller, usually
  a L<Mojolicious> object.
  
    # Use application logger
    $c->app->log->debug('Hello Mojo');
  
    # Generate path
    my $path = $c->app->home->child('templates', 'foo', 'bar.html.ep');
  
  =head2 match
  
    my $m = $c->match;
    $c    = $c->match(Mojolicious::Routes::Match->new);
  
  Router results for the current request, defaults to a
  L<Mojolicious::Routes::Match> object.
  
    # Introspect
    my $name   = $c->match->endpoint->name;
    my $foo    = $c->match->endpoint->pattern->defaults->{foo};
    my $action = $c->match->stack->[-1]{action};
  
  =head2 tx
  
    my $tx = $c->tx;
    $c     = $c->tx(Mojo::Transaction::HTTP->new);
  
  The transaction that is currently being processed, usually a
  L<Mojo::Transaction::HTTP> or L<Mojo::Transaction::WebSocket> object. Note that
  this reference is usually weakened, so the object needs to be referenced
  elsewhere as well when you're performing non-blocking operations and the
  underlying connection might get closed early.
  
    # Check peer information
    my $address = $c->tx->remote_address;
    my $port    = $c->tx->remote_port;
  
    # Increase size limit for WebSocket messages to 16MiB
    $c->tx->max_websocket_size(16777216) if $c->tx->is_websocket;
  
    # Perform non-blocking operation without knowing the connection status
    my $tx = $c->tx;
    Mojo::IOLoop->timer(2 => sub {
      $c->app->log->debug($tx->is_finished ? 'Finished' : 'In progress');
    });
  
  =head1 METHODS
  
  L<Mojolicious::Controller> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 continue
  
    $c->continue;
  
  Continue dispatch chain from an intermediate destination with
  L<Mojolicious::Routes/"continue">.
  
  =head2 cookie
  
    my $value = $c->cookie('foo');
    $c        = $c->cookie(foo => 'bar');
    $c        = $c->cookie(foo => 'bar', {path => '/'});
  
  Access request cookie values and create new response cookies. If there are
  multiple values sharing the same name, and you want to access more than just
  the last one, you can use L</"every_cookie">.
  
    # Create response cookie with domain and expiration date
    $c->cookie(user => 'sri', {domain => 'example.com', expires => time + 60});
  
    # Create secure response cookie
    $c->cookie(secret => 'I <3 Mojolicious', {secure => 1, httponly => 1});
  
  =head2 every_cookie
  
    my $values = $c->every_cookie('foo');
  
  Similar to L</"cookie">, but returns all request cookie values sharing the same
  name as an array reference.
  
    $ Get first cookie value
    my $first = $c->every_cookie('foo')->[0];
  
  =head2 every_param
  
    my $values = $c->every_param('foo');
  
  Similar to L</"param">, but returns all values sharing the same name as an
  array reference.
  
    # Get first value
    my $first = $c->every_param('foo')->[0];
  
  =head2 every_signed_cookie
  
    my $values = $c->every_signed_cookie('foo');
  
  Similar to L</"signed_cookie">, but returns all signed request cookie values
  sharing the same name as an array reference.
  
    # Get first signed cookie value
    my $first = $c->every_signed_cookie('foo')->[0];
  
  =head2 finish
  
    $c = $c->finish;
    $c = $c->finish(1000);
    $c = $c->finish(1003 => 'Cannot accept data!');
    $c = $c->finish('Bye!');
  
  Close WebSocket connection or long poll stream gracefully. This method will
  automatically respond to WebSocket handshake requests with a C<101> response
  status, to establish the WebSocket connection.
  
  =head2 flash
  
    my $foo = $c->flash('foo');
    $c      = $c->flash({foo => 'bar'});
    $c      = $c->flash(foo => 'bar');
  
  Data storage persistent only for the next request, stored in the L</"session">.
  
    # Show message after redirect
    $c->flash(message => 'User created successfully!');
    $c->redirect_to('show_user', id => 23);
  
  =head2 helpers
  
    my $helpers = $c->helpers;
  
  Return a proxy object containing the current controller object and on which
  helpers provided by L</"app"> can be called. This includes all helpers from
  L<Mojolicious::Plugin::DefaultHelpers> and L<Mojolicious::Plugin::TagHelpers>.
  
    # Make sure to use the "title" helper and not the controller method
    $c->helpers->title('Welcome!');
  
    # Use a nested helper instead of the "reply" controller method
    $c->helpers->reply->not_found;
  
  =head2 on
  
    my $cb = $c->on(finish => sub {...});
  
  Subscribe to events of L</"tx">, which is usually a L<Mojo::Transaction::HTTP>
  or L<Mojo::Transaction::WebSocket> object. This method will automatically
  respond to WebSocket handshake requests with a C<101> response status, to
  establish the WebSocket connection.
  
    # Do something after the transaction has been finished
    $c->on(finish => sub {
      my $c = shift;
      $c->app->log->debug('All data has been sent');
    });
  
    # Receive WebSocket message
    $c->on(message => sub {
      my ($c, $msg) = @_;
      $c->app->log->debug("Message: $msg");
    });
  
    # Receive JSON object via WebSocket message
    $c->on(json => sub {
      my ($c, $hash) = @_;
      $c->app->log->debug("Test: $hash->{test}");
    });
  
    # Receive WebSocket "Binary" message
    $c->on(binary => sub {
      my ($c, $bytes) = @_;
      my $len = length $bytes;
      $c->app->log->debug("Received $len bytes");
    });
  
  =head2 param
  
    my $value = $c->param('foo');
    $c        = $c->param(foo => 'ba;r');
    $c        = $c->param(foo => 'ba;r', 'baz');
    $c        = $c->param(foo => ['ba;r', 'baz']);
  
  Access route placeholder values that are not reserved stash values, file
  uploads as well as C<GET> and C<POST> parameters extracted from the query
  string and C<application/x-www-form-urlencoded> or C<multipart/form-data>
  message body, in that order. If there are multiple values sharing the same
  name, and you want to access more than just the last one, you can use
  L</"every_param">. Parts of the request body need to be loaded into memory to
  parse C<POST> parameters, so you have to make sure it is not excessively large.
  There's a 16MiB limit for requests by default.
  
    # Get first value
    my $first = $c->every_param('foo')->[0];
  
  For more control you can also access request information directly.
  
    # Only GET parameters
    my $foo = $c->req->query_params->param('foo');
  
    # Only POST parameters
    my $foo = $c->req->body_params->param('foo');
  
    # Only GET and POST parameters
    my $foo = $c->req->param('foo');
  
    # Only file uploads
    my $foo = $c->req->upload('foo');
  
  =head2 redirect_to
  
    $c = $c->redirect_to('named', foo => 'bar');
    $c = $c->redirect_to('named', {foo => 'bar'});
    $c = $c->redirect_to('/index.html');
    $c = $c->redirect_to('http://example.com/index.html');
  
  Prepare a C<302> (if the status code is not already C<3xx>) redirect response
  with C<Location> header, takes the same arguments as L</"url_for">.
  
    # Moved Permanently
    $c->res->code(301);
    $c->redirect_to('some_route');
  
    # Temporary Redirect
    $c->res->code(307);
    $c->redirect_to('some_route');
  
  =head2 render
  
    my $bool = $c->render;
    my $bool = $c->render(foo => 'bar', baz => 23);
    my $bool = $c->render(template => 'foo/index');
    my $bool = $c->render(template => 'index', format => 'html');
    my $bool = $c->render(data => $bytes);
    my $bool = $c->render(text => 'Hello!');
    my $bool = $c->render(json => {foo => 'bar'});
    my $bool = $c->render(handler => 'something');
    my $bool = $c->render('foo/index');
  
  Render content with L<Mojolicious/"renderer"> and emit hooks
  L<Mojolicious/"before_render"> as well as L<Mojolicious/"after_render">, or
  call L<Mojolicious::Plugin::DefaultHelpers/"reply-E<gt>not_found"> if no
  response could be generated, all additional key/value pairs get merged into the
  L</"stash">.
  
    # Render characters
    $c->render(text => 'I  Mojolicious!');
  
    # Render characters (alternative)
    $c->stash(text => 'I  Mojolicious!')->render;
  
    # Render binary data
    use Mojo::JSON 'encode_json';
    $c->render(data => encode_json({test => 'I  Mojolicious!'}));
  
    # Render JSON
    $c->render(json => {test => 'I  Mojolicious!'});
  
    # Render inline template
    $c->render(inline => '<%= 1 + 1 %>');
  
    # Render template "foo/bar.html.ep"
    $c->render(template => 'foo/bar', format => 'html', handler => 'ep');
  
    # Render template "test.*.*" with arbitrary values "foo" and "bar"
    $c->render(template => 'test', foo => 'test', bar => 23);
  
    # Render template "test.xml.*"
    $c->render(template => 'test', format => 'xml');
  
    # Render template "test.xml.*" (alternative)
    $c->render('test', format => 'xml');
  
  =head2 render_later
  
    $c = $c->render_later;
  
  Disable automatic rendering to delay response generation, only necessary if
  automatic rendering would result in a response.
  
    # Delayed rendering
    $c->render_later;
    Mojo::IOLoop->timer(2 => sub {
      $c->render(text => 'Delayed by 2 seconds!');
    });
  
  =head2 render_maybe
  
    my $bool = $c->render_maybe;
    my $bool = $c->render_maybe(foo => 'bar', baz => 23);
    my $bool = $c->render_maybe('foo/index', format => 'html');
  
  Try to render content, but do not call
  L<Mojolicious::Plugin::DefaultHelpers/"reply-E<gt>not_found"> if no response
  could be generated, all arguments get localized automatically and are only
  available during this render operation, takes the same arguments as
  L</"render">.
  
    # Render template "index_local" only if it exists
    $c->render_maybe('index_local') or $c->render('index');
  
  =head2 render_to_string
  
    my $output = $c->render_to_string('foo/index', format => 'pdf');
  
  Try to render content and return it wrapped in a L<Mojo::ByteStream> object or
  return C<undef>, all arguments get localized automatically and are only
  available during this render operation, takes the same arguments as
  L</"render">.
  
    # Render inline template
    my $two = $c->render_to_string(inline => '<%= 1 + 1 %>');
  
  =head2 rendered
  
    $c = $c->rendered;
    $c = $c->rendered(302);
  
  Finalize response and emit hook L<Mojolicious/"after_dispatch">, defaults to
  using a C<200> response code.
  
    # Custom response
    $c->res->headers->content_type('text/plain');
    $c->res->body('Hello World!');
    $c->rendered(200);
  
  =head2 req
  
    my $req = $c->req;
  
  Get L<Mojo::Message::Request> object from L</"tx">.
  
    # Longer version
    my $req = $c->tx->req;
  
    # Extract request information
    my $method = $c->req->method;
    my $url    = $c->req->url->to_abs;
    my $info   = $c->req->url->to_abs->userinfo;
    my $host   = $c->req->url->to_abs->host;
    my $agent  = $c->req->headers->user_agent;
    my $custom = $c->req->headers->header('Custom-Header');
    my $bytes  = $c->req->body;
    my $str    = $c->req->text;
    my $hash   = $c->req->params->to_hash;
    my $all    = $c->req->uploads;
    my $value  = $c->req->json;
    my $foo    = $c->req->json('/23/foo');
    my $dom    = $c->req->dom;
    my $bar    = $c->req->dom('div.bar')->first->text;
  
  =head2 res
  
    my $res = $c->res;
  
  Get L<Mojo::Message::Response> object from L</"tx">.
  
    # Longer version
    my $res = $c->tx->res;
  
    # Force file download by setting a response header
    $c->res->headers->content_disposition('attachment; filename=foo.png;');
  
    # Use a custom response header
    $c->res->headers->header('Custom-Header' => 'whatever');
  
    # Make sure response is cached correctly
    $c->res->headers->cache_control('public, max-age=300');
    $c->res->headers->append(Vary => 'Accept-Encoding');
  
  =head2 respond_to
  
    $c = $c->respond_to(
      json => {json => {message => 'Welcome!'}},
      html => {template => 'welcome'},
      any  => sub {...}
    );
  
  Automatically select best possible representation for resource from C<format>
  C<GET>/C<POST> parameter, C<format> stash value or C<Accept> request header,
  defaults to L<Mojolicious::Renderer/"default_format"> or rendering an empty
  C<204> response. Each representation can be handled with a callback or a hash
  reference containing arguments to be passed to L</"render">.
  
    # Everything else than "json" and "xml" gets a 204 response
    $c->respond_to(
      json => sub { $c->render(json => {just => 'works'}) },
      xml  => {text => '<just>works</just>'},
      any  => {data => '', status => 204}
    );
  
  For more advanced negotiation logic you can also use the helper
  L<Mojolicious::Plugin::DefaultHelpers/"accepts">.
  
  =head2 send
  
    $c = $c->send({binary => $bytes});
    $c = $c->send({text   => $bytes});
    $c = $c->send({json   => {test => [1, 2, 3]}});
    $c = $c->send([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);
    $c = $c->send($chars);
    $c = $c->send($chars => sub {...});
  
  Send message or frame non-blocking via WebSocket, the optional drain callback
  will be executed once all data has been written. This method will automatically
  respond to WebSocket handshake requests with a C<101> response status, to
  establish the WebSocket connection.
  
    # Send "Text" message
    $c->send('I  Mojolicious!');
  
    # Send JSON object as "Text" message
    $c->send({json => {test => 'I  Mojolicious!'}});
  
    # Send JSON object as "Binary" message
    use Mojo::JSON 'encode_json';
    $c->send({binary => encode_json({test => 'I  Mojolicious!'})});
  
    # Send "Ping" frame
    use Mojo::WebSocket 'WS_PING';
    $c->send([1, 0, 0, 0, WS_PING, 'Hello World!']);
  
    # Make sure the first message has been written before continuing
    $c->send('First message!' => sub {
      my $c = shift;
      $c->send('Second message!');
    });
  
  For mostly idle WebSockets you might also want to increase the inactivity
  timeout with L<Mojolicious::Plugin::DefaultHelpers/"inactivity_timeout">, which
  usually defaults to C<15> seconds.
  
    # Increase inactivity timeout for connection to 300 seconds
    $c->inactivity_timeout(300);
  
  =head2 session
  
    my $session = $c->session;
    my $foo     = $c->session('foo');
    $c          = $c->session({foo => 'bar'});
    $c          = $c->session(foo => 'bar');
  
  Persistent data storage for the next few requests, all session data gets
  serialized with L<Mojo::JSON> and stored Base64 encoded in HMAC-SHA1 signed
  cookies, to prevent tampering. Note that cookies usually have a C<4096> byte
  (4KiB) limit, depending on browser.
  
    # Manipulate session
    $c->session->{foo} = 'bar';
    my $foo = $c->session->{foo};
    delete $c->session->{foo};
  
    # Expiration date in seconds from now (persists between requests)
    $c->session(expiration => 604800);
  
    # Expiration date as absolute epoch time (only valid for one request)
    $c->session(expires => time + 604800);
  
    # Delete whole session by setting an expiration date in the past
    $c->session(expires => 1);
  
  =head2 signed_cookie
  
    my $value = $c->signed_cookie('foo');
    $c        = $c->signed_cookie(foo => 'bar');
    $c        = $c->signed_cookie(foo => 'bar', {path => '/'});
  
  Access signed request cookie values and create new signed response cookies. If
  there are multiple values sharing the same name, and you want to access more
  than just the last one, you can use L</"every_signed_cookie">. Cookies are
  cryptographically signed with HMAC-SHA1, to prevent tampering, and the ones
  failing signature verification will be automatically discarded.
  
  =head2 stash
  
    my $hash = $c->stash;
    my $foo  = $c->stash('foo');
    $c       = $c->stash({foo => 'bar', baz => 23});
    $c       = $c->stash(foo => 'bar', baz => 23);
  
  Non-persistent data storage and exchange for the current request, application
  wide default values can be set with L<Mojolicious/"defaults">. Some stash
  values have a special meaning and are reserved, the full list is currently
  C<action>, C<app>, C<cb>, C<controller>, C<data>, C<extends>, C<format>,
  C<handler>, C<inline>, C<json>, C<layout>, C<namespace>, C<path>, C<status>,
  C<template>, C<text> and C<variant>. Note that all stash values with a
  C<mojo.*> prefix are reserved for internal use.
  
    # Remove value
    my $foo = delete $c->stash->{foo};
  
    # Assign multiple values at once
    $c->stash(foo => 'test', bar => 23);
  
  =head2 url_for
  
    my $url = $c->url_for;
    my $url = $c->url_for(name => 'sebastian');
    my $url = $c->url_for({name => 'sebastian'});
    my $url = $c->url_for('test', name => 'sebastian');
    my $url = $c->url_for('test', {name => 'sebastian'});
    my $url = $c->url_for('/index.html');
    my $url = $c->url_for('//example.com/index.html');
    my $url = $c->url_for('http://example.com/index.html');
    my $url = $c->url_for('mailto:sri@example.com');
    my $url = $c->url_for('#whatever');
  
  Generate a portable L<Mojo::URL> object with base for a path, URL or route.
  
    # Rebuild URL for the current route
    $c->url_for;
  
    # Rebuild URL for the current route, but replace the "name" placeholder value
    $c->url_for(name => 'sebastian');
  
    # Absolute URL for the current route
    $c->url_for->to_abs;
  
    # Build URL for route "test" with two placeholder values
    $c->url_for('test', name => 'sebastian', foo => 'bar');
  
    # "http://127.0.0.1:3000/index.html" if application was started with Morbo
    $c->url_for('/index.html')->to_abs;
  
    # "https://127.0.0.1:443/index.html" if application was started with Morbo
    $c->url_for('/index.html')->to_abs->scheme('https')->port(443);
  
    # "/index.html?foo=bar" if application is deployed under "/"
    $c->url_for('/index.html')->query(foo => 'bar');
  
    # "/myapp/index.html?foo=bar" if application is deployed under "/myapp"
    $c->url_for('/index.html')->query(foo => 'bar');
  
  You can also use the helper L<Mojolicious::Plugin::DefaultHelpers/"url_with">
  to inherit query parameters from the current request.
  
    # "/list?q=mojo&page=2" if current request was for "/list?q=mojo&page=1"
    $c->url_with->query([page => 2]);
  
  =head2 validation
  
    my $v = $c->validation;
  
  Get L<Mojolicious::Validator::Validation> object for current request to
  validate file uploads as well as C<GET> and C<POST> parameters extracted from
  the query string and C<application/x-www-form-urlencoded> or
  C<multipart/form-data> message body. Parts of the request body need to be loaded
  into memory to parse C<POST> parameters, so you have to make sure it is not
  excessively large. There's a 16MiB limit for requests by default.
  
    # Validate GET/POST parameter
    my $v = $c->validation;
    $v->required('title', 'trim')->size(3, 50);
    my $title = $v->param('title');
  
    # Validate file upload
    my $v = $c->validation;
    $v->required('tarball')->upload->size(1, 1048576);
    my $tarball = $v->param('tarball');
  
  =head2 write
  
    $c = $c->write;
    $c = $c->write('');
    $c = $c->write($bytes);
    $c = $c->write($bytes => sub {...});
  
  Write dynamic content non-blocking, the optional drain callback will be executed
  once all data has been written. Calling this method without a chunk of data
  will finalize the response headers and allow for dynamic content to be written
  later.
  
    # Keep connection alive (with Content-Length header)
    $c->res->headers->content_length(6);
    $c->write('Hel' => sub {
      my $c = shift;
      $c->write('lo!');
    });
  
    # Close connection when finished (without Content-Length header)
    $c->write('Hel' => sub {
      my $c = shift;
      $c->write('lo!' => sub {
        my $c = shift;
        $c->finish;
      });
    });
  
  You can call L</"finish"> or write an empty chunk of data at any time to end
  the stream.
  
    HTTP/1.1 200 OK
    Date: Sat, 13 Sep 2014 16:48:29 GMT
    Content-Length: 6
    Server: Mojolicious (Perl)
  
    Hello!
  
    HTTP/1.1 200 OK
    Connection: close
    Date: Sat, 13 Sep 2014 16:48:29 GMT
    Server: Mojolicious (Perl)
  
    Hello!
  
  For Comet (long polling) you might also want to increase the inactivity timeout
  with L<Mojolicious::Plugin::DefaultHelpers/"inactivity_timeout">, which usually
  defaults to C<15> seconds.
  
    # Increase inactivity timeout for connection to 300 seconds
    $c->inactivity_timeout(300);
  
  =head2 write_chunk
  
    $c = $c->write_chunk;
    $c = $c->write_chunk('');
    $c = $c->write_chunk($bytes);
    $c = $c->write_chunk($bytes => sub {...});
  
  Write dynamic content non-blocking with chunked transfer encoding, the optional
  drain callback will be executed once all data has been written. Calling this
  method without a chunk of data will finalize the response headers and allow for
  dynamic content to be written later.
  
    # Make sure previous chunk has been written before continuing
    $c->write_chunk('H' => sub {
      my $c = shift;
      $c->write_chunk('ell' => sub {
        my $c = shift;
        $c->finish('o!');
      });
    });
  
  You can call L</"finish"> or write an empty chunk of data at any time to end
  the stream.
  
    HTTP/1.1 200 OK
    Date: Sat, 13 Sep 2014 16:48:29 GMT
    Transfer-Encoding: chunked
    Server: Mojolicious (Perl)
  
    1
    H
    3
    ell
    2
    o!
    0
  
  =head1 AUTOLOAD
  
  In addition to the L</"ATTRIBUTES"> and L</"METHODS"> above you can also call
  helpers provided by L</"app"> on L<Mojolicious::Controller> objects. This
  includes all helpers from L<Mojolicious::Plugin::DefaultHelpers> and
  L<Mojolicious::Plugin::TagHelpers>.
  
    # Call helpers
    $c->layout('green');
    $c->title('Welcome!');
  
    # Longer version
    $c->helpers->layout('green');
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_CONTROLLER

$fatpacked{"Mojolicious/Lite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_LITE';
  package Mojolicious::Lite;
  use Mojo::Base 'Mojolicious';
  
  # "Bender: Bite my shiny metal ass!"
  use Mojo::File 'path';
  use Mojo::UserAgent::Server;
  use Mojo::Util 'monkey_patch';
  
  sub import {
  
    # Remember executable for later
    $ENV{MOJO_EXE} ||= (caller)[1];
  
    # Reuse home directory if possible
    local $ENV{MOJO_HOME} = path($ENV{MOJO_EXE})->dirname->to_string
      unless $ENV{MOJO_HOME};
  
    # Initialize application class
    my $caller = caller;
    no strict 'refs';
    push @{"${caller}::ISA"}, 'Mojolicious';
  
    # Generate moniker based on filename
    my $moniker = path($ENV{MOJO_EXE})->basename('.pl', '.pm', '.t');
    my $app = shift->new(moniker => $moniker);
  
    # Initialize routes without namespaces
    my $routes = $app->routes->namespaces([]);
    $app->static->classes->[0] = $app->renderer->classes->[0] = $caller;
  
    # The Mojolicious::Lite DSL
    my $root = $routes;
    for my $name (qw(any get options patch post put websocket)) {
      monkey_patch $caller, $name, sub { $routes->$name(@_) };
    }
    monkey_patch($caller, $_, sub {$app}) for qw(new app);
    monkey_patch $caller, del => sub { $routes->delete(@_) };
    monkey_patch $caller, group => sub (&) {
      (my $old, $root) = ($root, $routes);
      shift->();
      ($routes, $root) = ($root, $old);
    };
    monkey_patch $caller,
      helper => sub { $app->helper(@_) },
      hook   => sub { $app->hook(@_) },
      plugin => sub { $app->plugin(@_) },
      under  => sub { $routes = $root->under(@_) };
  
    # Make sure there's a default application for testing
    Mojo::UserAgent::Server->app($app) unless Mojo::UserAgent::Server->app;
  
    # Lite apps are strict!
    unshift @_, 'Mojo::Base', -strict;
    goto &Mojo::Base::import;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Lite - Micro real-time web framework
  
  =head1 SYNOPSIS
  
    # Automatically enables "strict", "warnings", "utf8" and Perl 5.10 features
    use Mojolicious::Lite;
  
    # Route with placeholder
    get '/:foo' => sub {
      my $c   = shift;
      my $foo = $c->param('foo');
      $c->render(text => "Hello from $foo.");
    };
  
    # Start the Mojolicious command system
    app->start;
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Lite> is a tiny domain specific language built around
  L<Mojolicious>, made up of only about a dozen Perl functions.
  
  On Perl 5.20+ you can also use a C<-signatures> flag to enable support for
  L<subroutine signatures|perlsub/"Signatures">.
  
    use Mojolicious::Lite -signatures;
  
    get '/:foo' => sub ($c) {
      my $foo = $c->param('foo');
      $c->render(text => "Hello from $foo.");
    };
  
    app->start;
  
  See L<Mojolicious::Guides::Tutorial> for more!
  
  =head1 GROWING
  
  While L<Mojolicious::Guides::Growing> will give you a detailed introduction to
  growing a L<Mojolicious::Lite> prototype into a well-structured L<Mojolicious>
  application, here we have collected a few snippets that illustrate very well
  just how similar both of them are.
  
  =head2 Routes
  
  The functions L</"get">, L</"post"> and friends all have equivalent methods.
  
    # Mojolicious::Lite
    get '/foo' => sub {
      my $c = shift;
      $c->render(text => 'Hello World!');
    };
  
    # Mojolicious
    sub startup {
      my $self = shift;
  
      my $routes = $self->routes;
      $routes->get('/foo' => sub {
        my $c = shift;
        $c->render(text => 'Hello World!');
      });
    }
  
  =head2 Application
  
  The application object you can access with the function L</"app"> is the first
  argument passed to the C<startup> method.
  
    # Mojolicious::Lite
    app->max_request_size(16777216);
  
    # Mojolicious
    sub startup {
      my $self = shift;
      $self->max_request_size(16777216);
    }
  
  =head2 Plugins
  
  Instead of the L</"plugin"> function you just use the method
  L<Mojolicious/"plugin">.
  
    # Mojolicious::Lite
    plugin 'Config';
  
    # Mojolicious
    sub startup {
      my $self = shift;
      $self->plugin('Config');
    }
  
  =head2 Helpers
  
  Similar to plugins, instead of the L</"helper"> function you just use the method
  L<Mojolicious/"helper">.
  
    # Mojolicious::Lite
    helper two => sub {
      my $c = shift;
      return 1 + 1;
    };
  
    # Mojolicious
    sub startup {
      my $self = shift;
      $self->helper(two => sub {
        my $c = shift;
        return 1 + 1;
      });
    }
  
  =head2 Under
  
  Instead of sequential function calls, we can use methods to build a tree with
  nested routes, that much better illustrates how routes work internally.
  
    # Mojolicious::Lite
    under '/foo';
    get '/bar' => sub {...};
  
    # Mojolicious
    sub startup {
      my $self = shift;
  
      my $routes = $self->routes;
      my $foo = $routes->under('/foo');
      $foo->get('/bar' => sub {...});
    }
  
  =head1 FUNCTIONS
  
  L<Mojolicious::Lite> implements the following functions, which are
  automatically exported.
  
  =head2 any
  
    my $route = any '/:foo' => sub {...};
    my $route = any '/:foo' => sub {...} => 'name';
    my $route = any '/:foo' => {foo => 'bar'} => sub {...};
    my $route = any '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = any ['GET', 'POST'] => '/:foo' => sub {...};
    my $route = any ['GET', 'POST'] => '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = any
      ['GET', 'POST'] => '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"any">, matching any of the
  listed HTTP request methods or all. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head2 app
  
    my $app = app;
  
  Returns the L<Mojolicious::Lite> application object, which is a subclass of
  L<Mojolicious>.
  
    # Use all the available attributes and methods
    app->log->level('error');
    app->defaults(foo => 'bar');
  
  =head2 del
  
    my $route = del '/:foo' => sub {...};
    my $route = del '/:foo' => sub {...} => 'name';
    my $route = del '/:foo' => {foo => 'bar'} => sub {...};
    my $route = del '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = del '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"delete">, matching only
  C<DELETE> requests. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head2 get
  
    my $route = get '/:foo' => sub {...};
    my $route = get '/:foo' => sub {...} => 'name';
    my $route = get '/:foo' => {foo => 'bar'} => sub {...};
    my $route = get '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = get '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"get">, matching only C<GET>
  requests. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head2 group
  
    group {...};
  
  Start a new route group.
  
  =head2 helper
  
    helper foo => sub {...};
  
  Add a new helper with L<Mojolicious/"helper">.
  
  =head2 hook
  
    hook after_dispatch => sub {...};
  
  Share code with L<Mojolicious/"hook">.
  
  =head2 options
  
    my $route = options '/:foo' => sub {...};
    my $route = options '/:foo' => sub {...} => 'name';
    my $route = options '/:foo' => {foo => 'bar'} => sub {...};
    my $route = options '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = options '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"options">, matching only
  C<OPTIONS> requests. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head2 patch
  
    my $route = patch '/:foo' => sub {...};
    my $route = patch '/:foo' => sub {...} => 'name';
    my $route = patch '/:foo' => {foo => 'bar'} => sub {...};
    my $route = patch '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = patch '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"patch">, matching only
  C<PATCH> requests. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head2 plugin
  
    plugin SomePlugin => {foo => 23};
  
  Load a plugin with L<Mojolicious/"plugin">.
  
  =head2 post
  
    my $route = post '/:foo' => sub {...};
    my $route = post '/:foo' => sub {...} => 'name';
    my $route = post '/:foo' => {foo => 'bar'} => sub {...};
    my $route = post '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = post '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"post">, matching only C<POST>
  requests. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head2 put
  
    my $route = put '/:foo' => sub {...};
    my $route = put '/:foo' => sub {...} => 'name';
    my $route = put '/:foo' => {foo => 'bar'} => sub {...};
    my $route = put '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = put '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"put">, matching only C<PUT>
  requests. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head2 under
  
    my $route = under sub {...};
    my $route = under '/:foo' => sub {...};
    my $route = under '/:foo' => {foo => 'bar'};
    my $route = under '/:foo' => [foo => qr/\w+/];
    my $route = under '/:foo' => (agent => qr/Firefox/);
    my $route = under [format => 0];
  
  Generate nested route with L<Mojolicious::Routes::Route/"under">, to which all
  following routes are automatically appended. See
  L<Mojolicious::Guides::Tutorial> and L<Mojolicious::Guides::Routing> for more
  information.
  
  =head2 websocket
  
    my $route = websocket '/:foo' => sub {...};
    my $route = websocket '/:foo' => sub {...} => 'name';
    my $route = websocket '/:foo' => {foo => 'bar'} => sub {...};
    my $route = websocket '/:foo' => [foo => qr/\w+/] => sub {...};
    my $route = websocket '/:foo' => (agent => qr/Firefox/) => sub {...};
  
  Generate route with L<Mojolicious::Routes::Route/"websocket">, matching only
  WebSocket handshakes. See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Lite> inherits all attributes from L<Mojolicious>.
  
  =head1 METHODS
  
  L<Mojolicious::Lite> inherits all methods from L<Mojolicious>.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_LITE

$fatpacked{"Mojolicious/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN';
  package Mojolicious::Plugin;
  use Mojo::Base -base;
  
  use Carp 'croak';
  
  sub register { croak 'Method "register" not implemented by subclass' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin - Plugin base class
  
  =head1 SYNOPSIS
  
    # CamelCase plugin name
    package Mojolicious::Plugin::MyPlugin;
    use Mojo::Base 'Mojolicious::Plugin';
  
    sub register {
      my ($self, $app, $conf) = @_;
  
      # Magic here! :)
    }
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin> is an abstract base class for L<Mojolicious> plugins.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
    $plugin->register(Mojolicious->new, {foo => 'bar'});
  
  This method will be called by L<Mojolicious::Plugins> at startup time. Meant to
  be overloaded in a subclass.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN

$fatpacked{"Mojolicious/Plugin/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_CONFIG';
  package Mojolicious::Plugin::Config;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use Mojo::File 'path';
  use Mojo::Util 'decode';
  
  sub load { $_[0]->parse(decode('UTF-8', path($_[1])->slurp), @_[1, 2, 3]) }
  
  sub parse {
    my ($self, $content, $file, $conf, $app) = @_;
  
    # Run Perl code in sandbox
    my $config = eval 'package Mojolicious::Plugin::Config::Sandbox; no warnings;'
      . "sub app; local *app = sub { \$app }; use Mojo::Base -strict; $content";
    die qq{Can't load configuration from file "$file": $@} if $@;
    die qq{Configuration file "$file" did not return a hash reference.\n}
      unless ref $config eq 'HASH';
  
    return $config;
  }
  
  sub register {
    my ($self, $app, $conf) = @_;
  
    # Override
    $app->defaults(config => $app->config);
    return $app->config if $app->config->{config_override};
  
    # Config file
    my $file = $conf->{file} || $ENV{MOJO_CONFIG};
    $file ||= $app->moniker . '.' . ($conf->{ext} || 'conf');
  
    # Mode specific config file
    my $mode = $file =~ /^(.*)\.([^.]+)$/ ? join('.', $1, $app->mode, $2) : '';
  
    my $home = $app->home;
    $file = $home->child($file) unless path($file)->is_abs;
    $mode = $home->child($mode) if $mode && !path($mode)->is_abs;
    $mode = undef unless $mode && -e $mode;
  
    # Read config file
    my $config = {};
    if (-e $file) { $config = $self->load($file, $conf, $app) }
  
    # Check for default and mode specific config file
    elsif (!$conf->{default} && !$mode) {
      die qq{Configuration file "$file" missing, maybe you need to create it?\n};
    }
  
    # Merge everything
    $config = {%$config, %{$self->load($mode, $conf, $app)}} if $mode;
    $config = {%{$conf->{default}}, %$config} if $conf->{default};
    return $app->config($config)->config;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::Config - Perl-ish configuration plugin
  
  =head1 SYNOPSIS
  
    # myapp.conf (it's just Perl returning a hash)
    {
      # Just a value
      foo => "bar",
  
      # Nested data structures are fine too
      baz => [''],
  
      # You have full access to the application
      music_dir => app->home->child('music')
    };
  
    # Mojolicious
    my $config = $app->plugin('Config');
    say $config->{foo};
  
    # Mojolicious::Lite
    my $config = plugin 'Config';
    say $config->{foo};
  
    # foo.html.ep
    %= $config->{foo}
  
    # The configuration is available application-wide
    my $config = app->config;
    say $config->{foo};
  
    # Everything can be customized with options
    my $config = plugin Config => {file => '/etc/myapp.stuff'};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::Config> is a Perl-ish configuration plugin.
  
  The application object can be accessed via C<$app> or the C<app> function,
  L<strict>, L<warnings>, L<utf8> and Perl 5.10 L<features|feature> are
  automatically enabled. A default configuration filename in the application home
  directory will be generated from the value of L<Mojolicious/"moniker">
  (C<$moniker.conf>). You can extend the normal configuration file
  C<$moniker.conf> with C<mode> specific ones like C<$moniker.$mode.conf>, which
  will be detected automatically.
  
  If the configuration value C<config_override> has been set in
  L<Mojolicious/"config"> when this plugin is loaded, it will not do anything.
  
  The code of this plugin is a good example for learning to build new plugins,
  you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 OPTIONS
  
  L<Mojolicious::Plugin::Config> supports the following options.
  
  =head2 default
  
    # Mojolicious::Lite
    plugin Config => {default => {foo => 'bar'}};
  
  Default configuration, making configuration files optional.
  
  =head2 ext
  
    # Mojolicious::Lite
    plugin Config => {ext => 'stuff'};
  
  File extension for generated configuration filenames, defaults to C<conf>.
  
  =head2 file
  
    # Mojolicious::Lite
    plugin Config => {file => 'myapp.conf'};
    plugin Config => {file => '/etc/foo.stuff'};
  
  Path to configuration file, absolute or relative to the application home
  directory, defaults to the value of the C<MOJO_CONFIG> environment variable or
  C<$moniker.conf> in the application home directory.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::Config> inherits all methods from L<Mojolicious::Plugin>
  and implements the following new ones.
  
  =head2 load
  
    $plugin->load($file, $conf, $app);
  
  Loads configuration file and passes the content to L</"parse">.
  
    sub load {
      my ($self, $file, $conf, $app) = @_;
      ...
      return $self->parse($content, $file, $conf, $app);
    }
  
  =head2 parse
  
    $plugin->parse($content, $file, $conf, $app);
  
  Parse configuration file.
  
    sub parse {
      my ($self, $content, $file, $conf, $app) = @_;
      ...
      return $hash;
    }
  
  =head2 register
  
    my $config = $plugin->register(Mojolicious->new);
    my $config = $plugin->register(Mojolicious->new, {file => '/etc/app.conf'});
  
  Register plugin in L<Mojolicious> application and merge configuration.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_CONFIG

$fatpacked{"Mojolicious/Plugin/DefaultHelpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_DEFAULTHELPERS';
  package Mojolicious::Plugin::DefaultHelpers;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use Mojo::Asset::File;
  use Mojo::ByteStream;
  use Mojo::Collection;
  use Mojo::Exception;
  use Mojo::IOLoop;
  use Mojo::Util qw(deprecated dumper hmac_sha1_sum steady_time);
  use Time::HiRes qw(gettimeofday tv_interval);
  use Scalar::Util 'blessed';
  
  sub register {
    my ($self, $app) = @_;
  
    # Controller alias helpers
    for my $name (qw(app flash param stash session url_for validation)) {
      $app->helper($name => sub { shift->$name(@_) });
    }
  
    # Stash key shortcuts (should not generate log messages)
    for my $name (qw(extends layout title)) {
      $app->helper($name => sub { shift->stash($name, @_) });
    }
  
    $app->helper(accepts => sub { $_[0]->app->renderer->accepts(@_) });
    $app->helper(b       => sub { shift; Mojo::ByteStream->new(@_) });
    $app->helper(c       => sub { shift; Mojo::Collection->new(@_) });
    $app->helper(config  => sub { shift->app->config(@_) });
  
    $app->helper(content      => sub { _content(0, 0, @_) });
    $app->helper(content_for  => sub { _content(1, 0, @_) });
    $app->helper(content_with => sub { _content(0, 1, @_) });
  
    # DEPRECATED!
    $app->helper(
      delay => sub {
        deprecated 'delay helper is DEPRECATED';
        my $c  = shift;
        my $tx = $c->render_later->tx;
        Mojo::IOLoop->delay(@_)
          ->catch(sub { $c->helpers->reply->exception(pop) and undef $tx })->wait;
      }
    );
  
    $app->helper($_ => $self->can("_$_"))
      for qw(csrf_token current_route inactivity_timeout is_fresh url_with);
  
    $app->helper(dumper => sub { shift; dumper @_ });
    $app->helper(include => sub { shift->render_to_string(@_) });
  
    $app->helper("reply.$_" => $self->can("_$_")) for qw(asset file static);
  
    $app->helper('reply.exception' => sub { _development('exception', @_) });
    $app->helper('reply.not_found' => sub { _development('not_found', @_) });
  
    $app->helper('timing.begin'         => \&_timing_begin);
    $app->helper('timing.elapsed'       => \&_timing_elapsed);
    $app->helper('timing.rps'           => \&_timing_rps);
    $app->helper('timing.server_timing' => \&_timing_server_timing);
  
    $app->helper(ua => sub { shift->app->ua });
  }
  
  sub _asset {
    my $c = shift;
    $c->app->static->serve_asset($c, @_);
    $c->rendered;
  }
  
  sub _block { ref $_[0] eq 'CODE' ? $_[0]() : $_[0] }
  
  sub _content {
    my ($append, $replace, $c, $name, $content) = @_;
    $name ||= 'content';
  
    my $hash = $c->stash->{'mojo.content'} ||= {};
    if (defined $content) {
      if ($append) { $hash->{$name} .= _block($content) }
      if ($replace) { $hash->{$name} = _block($content) }
      else          { $hash->{$name} //= _block($content) }
    }
  
    return Mojo::ByteStream->new($hash->{$name} // '');
  }
  
  sub _csrf_token {
    my $c = shift;
    return $c->session->{csrf_token}
      ||= hmac_sha1_sum($$ . steady_time . rand, $c->app->secrets->[0]);
  }
  
  sub _current_route {
    return '' unless my $route = shift->match->endpoint;
    return @_ ? $route->name eq shift : $route->name;
  }
  
  sub _development {
    my ($page, $c, $e) = @_;
  
    my $app = $c->app;
    $app->log->error($e = _exception($e) ? $e : Mojo::Exception->new($e)->inspect)
      if $page eq 'exception';
  
    # Filtered stash snapshot
    my $stash = $c->stash;
    %{$stash->{snapshot} = {}} = map { $_ => $stash->{$_} }
      grep { !/^mojo\./ and defined $stash->{$_} } keys %$stash;
    $stash->{exception} = $page eq 'exception' ? $e : undef;
  
    # Render with fallbacks
    my $mode    = $app->mode;
    my $options = {
      format   => $stash->{format} || $app->renderer->default_format,
      handler  => undef,
      status   => $page eq 'exception' ? 500 : 404,
      template => "$page.$mode"
    };
    my $bundled = 'mojo/' . ($mode eq 'development' ? 'debug' : $page);
    return $c if _fallbacks($c, $options, $page, $bundled);
    _fallbacks($c, {%$options, format => 'html'}, $page, $bundled);
    return $c;
  }
  
  sub _exception { blessed $_[0] && $_[0]->isa('Mojo::Exception') }
  
  sub _fallbacks {
    my ($c, $options, $template, $bundled) = @_;
  
    # Mode specific template
    return 1 if $c->render_maybe(%$options);
  
    # Normal template
    return 1 if $c->render_maybe(%$options, template => $template);
  
    # Inline template
    my $stash = $c->stash;
    return undef unless $options->{format} eq 'html';
    delete @$stash{qw(extends layout)};
    return $c->render_maybe($bundled, %$options, handler => 'ep');
  }
  
  sub _file { _asset(shift, Mojo::Asset::File->new(path => shift)) }
  
  sub _inactivity_timeout {
    my ($c, $timeout) = @_;
    my $stream = Mojo::IOLoop->stream($c->tx->connection // '');
    $stream->timeout($timeout) if $stream;
    return $c;
  }
  
  sub _is_fresh {
    my ($c, %options) = @_;
    return $c->app->static->is_fresh($c, \%options);
  }
  
  sub _static {
    my ($c, $file) = @_;
    return !!$c->rendered if $c->app->static->serve($c, $file);
    $c->app->log->debug(qq{Static file "$file" not found});
    return !$c->helpers->reply->not_found;
  }
  
  sub _timing_begin { shift->stash->{'mojo.timing'}{shift()} = [gettimeofday] }
  
  sub _timing_elapsed {
    my ($c, $name) = @_;
    return undef unless my $started = $c->stash->{'mojo.timing'}{$name};
    return tv_interval($started, [gettimeofday()]);
  }
  
  sub _timing_rps { $_[1] == 0 ? undef : sprintf '%.3f', 1 / $_[1] }
  
  sub _timing_server_timing {
    my ($c, $metric, $desc, $dur) = @_;
    my $value = $metric;
    $value .= qq{;desc="$desc"} if defined $desc;
    $value .= ";dur=$dur"       if defined $dur;
    $c->res->headers->append('Server-Timing' => $value);
  }
  
  sub _url_with {
    my $c = shift;
    return $c->url_for(@_)->query($c->req->url->query->clone);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::DefaultHelpers - Default helpers plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    $app->plugin('DefaultHelpers');
  
    # Mojolicious::Lite
    plugin 'DefaultHelpers';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::DefaultHelpers> is a collection of helpers for
  L<Mojolicious>.
  
  This is a core plugin, that means it is always enabled and its code a good
  example for learning to build new plugins, you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 HELPERS
  
  L<Mojolicious::Plugin::DefaultHelpers> implements the following helpers.
  
  =head2 accepts
  
    my $formats = $c->accepts;
    my $format  = $c->accepts('html', 'json', 'txt');
  
  Select best possible representation for resource from C<format> C<GET>/C<POST>
  parameter, C<format> stash value or C<Accept> request header with
  L<Mojolicious::Renderer/"accepts">, defaults to returning the first extension if
  no preference could be detected.
  
    # Check if JSON is acceptable
    $c->render(json => {hello => 'world'}) if $c->accepts('json');
  
    # Check if JSON was specifically requested
    $c->render(json => {hello => 'world'}) if $c->accepts('', 'json');
  
    # Unsupported representation
    $c->render(data => '', status => 204)
      unless my $format = $c->accepts('html', 'json');
  
    # Detected representations to select from
    my @formats = @{$c->accepts};
  
  =head2 app
  
    %= app->secrets->[0]
  
  Alias for L<Mojolicious::Controller/"app">.
  
  =head2 b
  
    %= b('Joel is a slug')->slugify
  
  Turn string into a L<Mojo::ByteStream> object.
  
  =head2 c
  
    %= c('a', 'b', 'c')->shuffle->join
  
  Turn list into a L<Mojo::Collection> object.
  
  =head2 config
  
    %= config 'something'
  
  Alias for L<Mojolicious/"config">.
  
  =head2 content
  
    %= content foo => begin
      test
    % end
    %= content bar => 'Hello World!'
    %= content 'foo'
    %= content 'bar'
    %= content
  
  Store partial rendered content in a named buffer and retrieve it later,
  defaults to retrieving the named buffer C<content>, which is used by the
  renderer for the C<layout> and C<extends> features. New content will be ignored
  if the named buffer is already in use.
  
  =head2 content_for
  
    % content_for foo => begin
      test
    % end
    %= content_for 'foo'
  
  Same as L</"content">, but appends content to named buffers if they are already
  in use.
  
    % content_for message => begin
      Hello
    % end
    % content_for message => begin
      world!
    % end
    %= content 'message'
  
  =head2 content_with
  
    % content_with foo => begin
      test
    % end
    %= content_with 'foo'
  
  Same as L</"content">, but replaces content of named buffers if they are
  already in use.
  
    % content message => begin
      world!
    % end
    % content_with message => begin
      Hello <%= content 'message' %>
    % end
    %= content 'message'
  
  =head2 csrf_token
  
    %= csrf_token
  
  Get CSRF token from L</"session">, and generate one if none exists.
  
  =head2 current_route
  
    % if (current_route 'login') {
      Welcome to Mojolicious!
    % }
    %= current_route
  
  Check or get name of current route.
  
  =head2 dumper
  
    %= dumper {some => 'data'}
  
  Dump a Perl data structure with L<Mojo::Util/"dumper">, very useful for
  debugging.
  
  =head2 extends
  
    % extends 'blue';
    % extends 'blue', title => 'Blue!';
  
  Set C<extends> stash value, all additional key/value pairs get merged into the
  L</"stash">.
  
  =head2 flash
  
    %= flash 'foo'
  
  Alias for L<Mojolicious::Controller/"flash">.
  
  =head2 inactivity_timeout
  
    $c = $c->inactivity_timeout(3600);
  
  Use L<Mojo::IOLoop/"stream"> to find the current connection and increase
  timeout if possible.
  
    # Longer version
    Mojo::IOLoop->stream($c->tx->connection)->timeout(3600);
  
  =head2 include
  
    %= include 'menubar'
    %= include 'menubar', format => 'txt'
  
  Alias for L<Mojolicious::Controller/"render_to_string">.
  
  =head2 is_fresh
  
    my $bool = $c->is_fresh;
    my $bool = $c->is_fresh(etag => 'abc');
    my $bool = $c->is_fresh(last_modified => $epoch);
  
  Check freshness of request by comparing the C<If-None-Match> and
  C<If-Modified-Since> request headers to the C<ETag> and C<Last-Modified>
  response headers with L<Mojolicious::Static/"is_fresh">.
  
    # Add ETag/Last-Modified headers and check freshness before rendering
    $c->is_fresh(etag => 'abc', last_modified => 1424985708)
      ? $c->rendered(304)
      : $c->render(text => 'I  Mojolicious!');
  
  =head2 layout
  
    % layout 'green';
    % layout 'green', title => 'Green!';
  
  Set C<layout> stash value, all additional key/value pairs get merged into the
  L</"stash">.
  
  =head2 param
  
    %= param 'foo'
  
  Alias for L<Mojolicious::Controller/"param">.
  
  =head2 reply->asset
  
    $c->reply->asset(Mojo::Asset::File->new);
  
  Reply with a L<Mojo::Asset::File> or L<Mojo::Asset::Memory> object using
  L<Mojolicious::Static/"serve_asset">, and perform content negotiation with
  C<Range>, C<If-Modified-Since> and C<If-None-Match> headers.
  
    # Serve asset with custom modification time
    my $asset = Mojo::Asset::Memory->new;
    $asset->add_chunk('Hello World!')->mtime(784111777);
    $c->res->headers->content_type('text/plain');
    $c->reply->asset($asset);
  
    # Serve static file if it exists
    if (my $asset = $c->app->static->file('images/logo.png')) {
      $c->res->headers->content_type('image/png');
      $c->reply->asset($asset);
    }
  
  =head2 reply->exception
  
    $c = $c->reply->exception('Oops!');
    $c = $c->reply->exception(Mojo::Exception->new);
  
  Render the exception template C<exception.$mode.$format.*> or
  C<exception.$format.*> and set the response status code to C<500>. Also sets
  the stash values C<exception> to a L<Mojo::Exception> object and C<snapshot> to
  a copy of the L</"stash"> for use in the templates.
  
  =head2 reply->file
  
    $c->reply->file('/etc/passwd');
  
  Reply with a static file from an absolute path anywhere on the file system using
  L<Mojolicious/"static">.
  
    # Longer version
    $c->reply->asset(Mojo::Asset::File->new(path => '/etc/passwd'));
  
    # Serve file from an absolute path with a custom content type
    $c->res->headers->content_type('application/myapp');
    $c->reply->file('/home/sri/foo.txt');
  
    # Serve file from a secret application directory
    $c->reply->file($c->app->home->child('secret', 'file.txt'));
  
  =head2 reply->not_found
  
    $c = $c->reply->not_found;
  
  Render the not found template C<not_found.$mode.$format.*> or
  C<not_found.$format.*> and set the response status code to C<404>. Also sets
  the stash value C<snapshot> to a copy of the L</"stash"> for use in the
  templates.
  
  =head2 reply->static
  
    my $bool = $c->reply->static('images/logo.png');
    my $bool = $c->reply->static('../lib/MyApp.pm');
  
  Reply with a static file using L<Mojolicious/"static">, usually from the
  C<public> directories or C<DATA> sections of your application. Note that this
  helper uses a relative path, but does not protect from traversing to parent
  directories.
  
    # Serve file from a relative path with a custom content type
    $c->res->headers->content_type('application/myapp');
    $c->reply->static('foo.txt');
  
  =head2 session
  
    %= session 'foo'
  
  Alias for L<Mojolicious::Controller/"session">.
  
  =head2 stash
  
    %= stash 'foo'
    % stash foo => 'bar';
  
  Alias for L<Mojolicious::Controller/"stash">.
  
    %= stash('name') // 'Somebody'
  
  =head2 timing->begin
  
    $c->timing->begin('foo');
  
  Create named timestamp for L<"timing-E<gt>elapsed">. Note that this helper is
  EXPERIMENTAL and might change without warning!
  
  =head2 timing->elapsed
  
    my $elapsed = $c->timing->elapsed('foo');
  
  Return fractional amount of time in seconds since named timstamp has been
  created with L</"timing-E<gt>begin"> or C<undef> if no such timestamp exists.
  Note that this helper is EXPERIMENTAL and might change without warning!
  
    # Log timing information
    $c->timing->begin('database_stuff');
    ...
    my $elapsed = $c->timing->elapsed('database_stuff');
    $c->app->log->debug("Database stuff took $elapsed seconds");
  
  =head2 timing->rps
  
    my $rps = $c->timing->rps('0.001');
  
  Return fractional number of requests that could be performed in one second if
  every singe one took the given amount of time in seconds or C<undef> if the
  number is too low. Note that this helper is EXPERIMENTAL and might change
  without warning!
  
    # Log more timing information
    $c->timing->begin('web_stuff');
    ...
    my $elapsed = $c->timing->elapsed('web_stuff');
    my $rps     = $c->timing->rps($elapsed);
    $c->app->log->debug("Web stuff took $elapsed seconds ($rps per second)");
  
  =head2 timing->server_timing
  
    $c->timing->server_timing('metric');
    $c->timing->server_timing('metric', 'Some Description');
    $c->timing->server_timing('metric', 'Some Description', '0.001');
  
  Create C<Server-Timing> header with optional description and duration. Note that
  this helper is EXPERIMENTAL and might change without warning!
  
    # "Server-Timing: miss"
    $c->timing->server_timing('miss');
  
    # "Server-Timing: dc;desc=atl"
    $c->timing->server_timing('dc', 'atl');
  
    # "Server-Timing: db;desc=Database;dur=0.0001"
    $c->timing->begin('database_stuff');
    ...
    my $elapsed = $c->timing->elapsed('database_stuff');
    $c->timing->server_timing('db', 'Database', $elapsed);
  
    # "Server-Timing: miss, dc;desc=atl"
    $c->timing->server_timing('miss');
    $c->timing->server_timing('dc', 'atl');
  
  =head2 title
  
    %= title
    % title 'Welcome!';
    % title 'Welcome!', foo => 'bar';
  
  Get or set C<title> stash value, all additional key/value pairs get merged into
  the L</"stash">.
  
  =head2 ua
  
    %= ua->get('mojolicious.org')->result->dom->at('title')->text
  
  Alias for L<Mojolicious/"ua">.
  
  =head2 url_for
  
    %= url_for 'named', controller => 'bar', action => 'baz'
  
  Alias for L<Mojolicious::Controller/"url_for">.
  
    %= url_for('/index.html')->query(foo => 'bar')
  
  =head2 url_with
  
    %= url_with 'named', controller => 'bar', action => 'baz'
  
  Does the same as L</"url_for">, but inherits query parameters from the current
  request.
  
    %= url_with->query([page => 2])
  
  =head2 validation
  
    %= validation->param('foo')
  
  Alias for L<Mojolicious::Controller/"validation">.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::DefaultHelpers> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
  
  Register helpers in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_DEFAULTHELPERS

$fatpacked{"Mojolicious/Plugin/EPLRenderer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_EPLRENDERER';
  package Mojolicious::Plugin::EPLRenderer;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use Mojo::Template;
  use Mojo::Util qw(encode md5_sum);
  
  sub register {
    my ($self, $app) = @_;
    $app->renderer->add_handler(
      epl => sub { _render(@_, Mojo::Template->new, $_[1]) });
  }
  
  sub _render {
    my ($renderer, $c, $output, $options, $mt, @args) = @_;
  
    # Cached
    if ($mt->compiled) {
      $c->app->log->debug("Rendering cached @{[$mt->name]}");
      $$output = $mt->process(@args);
    }
  
    # Not cached
    else {
      my $inline = $options->{inline};
      my $name = defined $inline ? md5_sum encode('UTF-8', $inline) : undef;
      return unless defined($name //= $renderer->template_name($options));
  
      # Inline
      if (defined $inline) {
        $c->app->log->debug(qq{Rendering inline template "$name"});
        $$output = $mt->name(qq{inline template "$name"})->render($inline, @args);
      }
  
      # File
      else {
        if (my $encoding = $renderer->encoding) { $mt->encoding($encoding) }
  
        # Try template
        if (defined(my $path = $renderer->template_path($options))) {
          $c->app->log->debug(qq{Rendering template "$name"});
          $$output = $mt->name(qq{template "$name"})->render_file($path, @args);
        }
  
        # Try DATA section
        elsif (defined(my $d = $renderer->get_data_template($options))) {
          $c->app->log->debug(qq{Rendering template "$name" from DATA section});
          $$output = $mt->name(qq{template "$name" from DATA section})
            ->render($d, @args);
        }
  
        # No template
        else { $c->app->log->debug(qq{Template "$name" not found}) }
      }
    }
  
    # Exception
    die $$output if ref $$output;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::EPLRenderer - Embedded Perl Lite renderer plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    $app->plugin('EPLRenderer');
  
    # Mojolicious::Lite
    plugin 'EPLRenderer';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::EPLRenderer> is a renderer for C<epl> templates, which
  are pretty much just raw L<Mojo::Template>.
  
  This is a core plugin, that means it is always enabled and its code a good
  example for learning to build new plugins, you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::EPLRenderer> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
  
  Register renderer in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_EPLRENDERER

$fatpacked{"Mojolicious/Plugin/EPRenderer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_EPRENDERER';
  package Mojolicious::Plugin::EPRenderer;
  use Mojo::Base 'Mojolicious::Plugin::EPLRenderer';
  
  use Mojo::Template;
  use Mojo::Util qw(encode md5_sum monkey_patch);
  
  sub DESTROY { Mojo::Util::_teardown(shift->{namespace}) }
  
  sub register {
    my ($self, $app, $conf) = @_;
  
    # Auto escape by default to prevent XSS attacks
    my $ep = {auto_escape => 1, %{$conf->{template} || {}}, vars => 1};
    my $ns = $self->{namespace} = $ep->{namespace}
      //= 'Mojo::Template::Sandbox::' . md5_sum "$self";
  
    # Make "$self" and "$c" available in templates
    $ep->{prepend} = 'my $self = my $c = _C;' . ($ep->{prepend} // '');
  
    # Add "ep" handler and make it the default
    $app->renderer->default_handler('ep')->add_handler(
      $conf->{name} || 'ep' => sub {
        my ($renderer, $c, $output, $options) = @_;
  
        my $name = $options->{inline} // $renderer->template_name($options);
        return unless defined $name;
        my $key = md5_sum encode 'UTF-8', $name;
  
        my $cache = $renderer->cache;
        my $mt    = $cache->get($key);
        $cache->set($key => $mt = Mojo::Template->new($ep)) unless $mt;
  
        # Export helpers only once
        ++$self->{helpers} and _helpers($ns, $renderer->helpers)
          unless $self->{helpers};
  
        # Make current controller available and render with "epl" handler
        no strict 'refs';
        no warnings 'redefine';
        local *{"${ns}::_C"} = sub {$c};
        Mojolicious::Plugin::EPLRenderer::_render($renderer, $c, $output,
          $options, $mt, $c->stash);
      }
    );
  }
  
  sub _helpers {
    my ($class, $helpers) = @_;
    for my $method (grep {/^\w+$/} keys %$helpers) {
      my $sub = $helpers->{$method};
      monkey_patch $class, $method, sub { $class->_C->$sub(@_) };
    }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::EPRenderer - Embedded Perl renderer plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    $app->plugin('EPRenderer');
    $app->plugin(EPRenderer => {name => 'foo'});
    $app->plugin(EPRenderer => {name => 'bar', template => {line_start => '.'}});
  
    # Mojolicious::Lite
    plugin 'EPRenderer';
    plugin EPRenderer => {name => 'foo'};
    plugin EPRenderer => {name => 'bar', template => {line_start => '.'}};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::EPRenderer> is a renderer for Embedded Perl templates.
  For more information see L<Mojolicious::Guides::Rendering/"Embedded Perl">.
  
  This is a core plugin, that means it is always enabled and its code a good
  example for learning to build new plugins, you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 OPTIONS
  
  L<Mojolicious::Plugin::EPRenderer> supports the following options.
  
  =head2 name
  
    # Mojolicious::Lite
    plugin EPRenderer => {name => 'foo'};
  
  Handler name, defaults to C<ep>.
  
  =head2 template
  
    # Mojolicious::Lite
    plugin EPRenderer => {template => {line_start => '.'}};
  
  Attribute values passed to L<Mojo::Template> objects used to render templates.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::EPRenderer> inherits all methods from
  L<Mojolicious::Plugin::EPLRenderer> and implements the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
    $plugin->register(Mojolicious->new, {name => 'foo'});
  
  Register renderer in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_EPRENDERER

$fatpacked{"Mojolicious/Plugin/HeaderCondition.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_HEADERCONDITION';
  package Mojolicious::Plugin::HeaderCondition;
  use Mojo::Base 'Mojolicious::Plugin';
  
  sub register {
    my ($self, $app) = @_;
  
    $app->routes->add_condition(headers => \&_headers);
    $app->routes->add_condition(
      agent => sub { _headers(@_[0 .. 2], {'User-Agent' => $_[3]}) });
    $app->routes->add_condition(
      host => sub { _check($_[1]->req->url->to_abs->host, $_[3]) });
  }
  
  sub _check {
    my ($value, $pattern) = @_;
    return 1
      if $value && $pattern && ref $pattern eq 'Regexp' && $value =~ $pattern;
    return $value && defined $pattern && $pattern eq $value;
  }
  
  sub _headers {
    my ($route, $c, $captures, $patterns) = @_;
    return undef unless $patterns && ref $patterns eq 'HASH' && keys %$patterns;
  
    # All headers need to match
    my $headers = $c->req->headers;
    _check($headers->header($_), $patterns->{$_}) || return undef
      for keys %$patterns;
    return 1;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::HeaderCondition - Header condition plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    $app->plugin('HeaderCondition');
    $app->routes->get('/:controller/:action')
      ->over(headers => {Referer => qr/example\.com/});
  
    # Mojolicious::Lite
    plugin 'HeaderCondition';
    get '/' => (headers => {Referer => qr/example\.com/}) => sub {...};
  
    # All headers need to match
    $app->routes->get('/:controller/:action')->over(headers => {
      'X-Secret-Header' => 'Foo',
      Referer => qr/example\.com/
    });
  
    # The "agent" condition is a shortcut for the "User-Agent" header
    get '/' => (agent => qr/Firefox/) => sub {...};
  
    # The "host" condition is a shortcut for the detected host
    get '/' => (host => qr/mojolicious\.org/) => sub {...};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::HeaderCondition> is a route condition for header-based
  routes.
  
  This is a core plugin, that means it is always enabled and its code a good
  example for learning to build new plugins, you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::HeaderCondition> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
  
  Register conditions in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_HEADERCONDITION

$fatpacked{"Mojolicious/Plugin/JSONConfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_JSONCONFIG';
  package Mojolicious::Plugin::JSONConfig;
  use Mojo::Base 'Mojolicious::Plugin::Config';
  
  use Mojo::JSON 'from_json';
  use Mojo::Template;
  
  sub parse {
    my ($self, $content, $file, $conf, $app) = @_;
  
    my $config = eval { from_json $self->render($content, $file, $conf, $app) };
    die qq{Can't parse config "$file": $@} if $@;
    die qq{Invalid config "$file"} unless ref $config eq 'HASH';
  
    return $config;
  }
  
  sub register { shift->SUPER::register(shift, {ext => 'json', %{shift()}}) }
  
  sub render {
    my ($self, $content, $file, $conf, $app) = @_;
  
    # Application instance and helper
    my $prepend = q[no strict 'refs'; no warnings 'redefine';];
    $prepend .= q[my $app = shift; sub app; local *app = sub { $app };];
    $prepend .= q[use Mojo::Base -strict; no warnings 'ambiguous';];
  
    my $mt = Mojo::Template->new($conf->{template} || {})->name($file);
    my $output = $mt->prepend($prepend . $mt->prepend)->render($content, $app);
    return ref $output ? die $output : $output;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::JSONConfig - JSON configuration plugin
  
  =head1 SYNOPSIS
  
    # myapp.json (it's just JSON with embedded Perl)
    {
      %# Just a value
      "foo": "bar",
  
      %# Nested data structures are fine too
      "baz": [""],
  
      %# You have full access to the application
      "music_dir": "<%= app->home->child('music') %>"
    }
  
    # Mojolicious
    my $config = $app->plugin('JSONConfig');
    say $config->{foo};
  
    # Mojolicious::Lite
    my $config = plugin 'JSONConfig';
    say $config->{foo};
  
    # foo.html.ep
    %= $config->{foo}
  
    # The configuration is available application-wide
    my $config = app->config;
    say $config->{foo};
  
    # Everything can be customized with options
    my $config = plugin JSONConfig => {file => '/etc/myapp.conf'};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::JSONConfig> is a JSON configuration plugin that
  preprocesses its input with L<Mojo::Template>.
  
  The application object can be accessed via C<$app> or the C<app> function. A
  default configuration filename in the application home directory will be
  generated from the value of L<Mojolicious/"moniker"> (C<$moniker.json>). You can
  extend the normal configuration file C<$moniker.json> with C<mode> specific ones
  like C<$moniker.$mode.json>, which will be detected automatically.
  
  If the configuration value C<config_override> has been set in
  L<Mojolicious/"config"> when this plugin is loaded, it will not do anything.
  
  The code of this plugin is a good example for learning to build new plugins,
  you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 OPTIONS
  
  L<Mojolicious::Plugin::JSONConfig> inherits all options from
  L<Mojolicious::Plugin::Config> and supports the following new ones.
  
  =head2 template
  
    # Mojolicious::Lite
    plugin JSONConfig => {template => {line_start => '.'}};
  
  Attribute values passed to L<Mojo::Template> object used to preprocess
  configuration files.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::JSONConfig> inherits all methods from
  L<Mojolicious::Plugin::Config> and implements the following new ones.
  
  =head2 parse
  
    $plugin->parse($content, $file, $conf, $app);
  
  Process content with L</"render"> and parse it with L<Mojo::JSON>.
  
    sub parse {
      my ($self, $content, $file, $conf, $app) = @_;
      ...
      $content = $self->render($content, $file, $conf, $app);
      ...
      return $hash;
    }
  
  =head2 register
  
    my $config = $plugin->register(Mojolicious->new);
    my $config = $plugin->register(Mojolicious->new, {file => '/etc/foo.conf'});
  
  Register plugin in L<Mojolicious> application and merge configuration.
  
  =head2 render
  
    $plugin->render($content, $file, $conf, $app);
  
  Process configuration file with L<Mojo::Template>.
  
    sub render {
      my ($self, $content, $file, $conf, $app) = @_;
      ...
      return $content;
    }
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_JSONCONFIG

$fatpacked{"Mojolicious/Plugin/Mount.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_MOUNT';
  package Mojolicious::Plugin::Mount;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use Mojo::Server;
  
  sub register {
    my ($self, $app, $conf) = @_;
  
    my $path  = (keys %$conf)[0];
    my $embed = Mojo::Server->new->load_app($conf->{$path});
    $embed->secrets($app->secrets);
  
    # Extract host
    my $host;
    ($host, $path) = ($1 ? qr/^(?:.*\.)?\Q$2\E$/i : qr/^\Q$2\E$/i, $3)
      if $path =~ m!^(\*\.)?([^/]+)(/.*)?$!;
  
    my $route = $app->routes->route($path)->detour(app => $embed);
    return $host ? $route->over(host => $host) : $route;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::Mount - Application mount plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    my $route = $app->plugin(Mount => {'/prefix' => '/home/sri/myapp.pl'});
  
    # Mojolicious::Lite
    my $route = plugin Mount => {'/prefix' => '/home/sri/myapp.pl'};
  
    # Adjust the generated route and mounted application
    my $example = plugin Mount => {'/example' => '/home/sri/example.pl'};
    $example->to(message => 'It works great!');
    my $app = $example->pattern->defaults->{app};
    $app->config(foo => 'bar');
    $app->log(app->log);
  
    # Mount application with host
    plugin Mount => {'example.com' => '/home/sri/myapp.pl'};
  
    # Host and path
    plugin Mount => {'example.com/myapp' => '/home/sri/myapp.pl'};
  
    # Or even hosts with wildcard subdomains
    plugin Mount => {'*.example.com/myapp' => '/home/sri/myapp.pl'};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::Mount> is a plugin that allows you to mount whole
  L<Mojolicious> applications.
  
  The code of this plugin is a good example for learning to build new plugins,
  you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::Mount> inherits all methods from L<Mojolicious::Plugin>
  and implements the following new ones.
  
  =head2 register
  
    my $route = $plugin->register(Mojolicious->new, {'/foo' => '/some/app.pl'});
  
  Mount L<Mojolicious> application and return the generated route, which is
  usually a L<Mojolicious::Routes::Route> object.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_MOUNT

$fatpacked{"Mojolicious/Plugin/PODRenderer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_PODRENDERER';
  package Mojolicious::Plugin::PODRenderer;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use Mojo::Asset::File;
  use Mojo::ByteStream;
  use Mojo::DOM;
  use Mojo::File 'path';
  use Mojo::URL;
  use Pod::Simple::XHTML;
  use Pod::Simple::Search;
  
  sub register {
    my ($self, $app, $conf) = @_;
  
    my $preprocess = $conf->{preprocess} || 'ep';
    $app->renderer->add_handler(
      $conf->{name} || 'pod' => sub {
        my ($renderer, $c, $output, $options) = @_;
        $renderer->handlers->{$preprocess}($renderer, $c, $output, $options);
        $$output = _pod_to_html($$output) if defined $$output;
      }
    );
  
    $app->helper(
      pod_to_html => sub { shift; Mojo::ByteStream->new(_pod_to_html(@_)) });
  
    # Perldoc browser
    return undef if $conf->{no_perldoc};
    my $defaults = {module => 'Mojolicious/Guides'};
    return $app->routes->any(
      '/perldoc/:module' => $defaults => [module => qr/[^.]+/] => \&_perldoc);
  }
  
  sub _indentation {
    (sort map {/^(\s+)/} @{shift()})[0];
  }
  
  sub _html {
    my ($c, $src) = @_;
  
    # Rewrite links
    my $dom     = Mojo::DOM->new(_pod_to_html($src));
    my $perldoc = $c->url_for('/perldoc/');
    $_->{href} =~ s!^https://metacpan\.org/pod/!$perldoc!
      and $_->{href} =~ s!::!/!gi
      for $dom->find('a[href]')->map('attr')->each;
  
    # Rewrite code blocks for syntax highlighting and correct indentation
    for my $e ($dom->find('pre > code')->each) {
      next if (my $str = $e->content) =~ /^\s*(?:\$|Usage:)\s+/m;
      next unless $str =~ /[\$\@\%]\w|-&gt;\w|^use\s+\w/m;
      my $attrs = $e->attr;
      my $class = $attrs->{class};
      $attrs->{class} = defined $class ? "$class prettyprint" : 'prettyprint';
    }
  
    # Rewrite headers
    my $toc = Mojo::URL->new->fragment('toc');
    my @parts;
    for my $e ($dom->find('h1, h2, h3, h4')->each) {
  
      push @parts, [] if $e->tag eq 'h1' || !@parts;
      my $link = Mojo::URL->new->fragment($e->{id});
      push @{$parts[-1]}, my $text = $e->all_text, $link;
      my $permalink = $c->link_to('#' => $link, class => 'permalink');
      $e->content($permalink . $c->link_to($text => $toc));
    }
  
    # Try to find a title
    my $title = 'Perldoc';
    $dom->find('h1 + p')->first(sub { $title = shift->text });
  
    # Combine everything to a proper response
    $c->content_for(perldoc => "$dom");
    $c->render('mojo/perldoc', title => $title, parts => \@parts);
  }
  
  sub _perldoc {
    my $c = shift;
  
    # Find module or redirect to CPAN
    my $module = join '::', split('/', $c->param('module'));
    $c->stash(cpan => "https://metacpan.org/pod/$module");
    my $path
      = Pod::Simple::Search->new->find($module, map { $_, "$_/pods" } @INC);
    return $c->redirect_to($c->stash('cpan')) unless $path && -r $path;
  
    my $src = path($path)->slurp;
    $c->respond_to(txt => {data => $src}, html => sub { _html($c, $src) });
  }
  
  sub _pod_to_html {
    return '' unless defined(my $pod = ref $_[0] eq 'CODE' ? shift->() : shift);
  
    my $parser = Pod::Simple::XHTML->new;
    $parser->perldoc_url_prefix('https://metacpan.org/pod/');
    $parser->$_('') for qw(html_header html_footer);
    $parser->strip_verbatim_indent(\&_indentation);
    $parser->output_string(\(my $output));
    return $@ unless eval { $parser->parse_string_document("$pod"); 1 };
  
    return $output;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::PODRenderer - POD renderer plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious (with documentation browser under "/perldoc")
    my $route = $app->plugin('PODRenderer');
    my $route = $app->plugin(PODRenderer => {name => 'foo'});
    my $route = $app->plugin(PODRenderer => {preprocess => 'epl'});
  
    # Mojolicious::Lite (with documentation browser under "/perldoc")
    my $route = plugin 'PODRenderer';
    my $route = plugin PODRenderer => {name => 'foo'};
    my $route = plugin PODRenderer => {preprocess => 'epl'};
  
    # Without documentation browser
    plugin PODRenderer => {no_perldoc => 1};
  
    # foo.html.ep
    %= pod_to_html "=head1 TEST\n\nC<123>"
  
    # foo.html.pod
    =head1 <%= uc 'test' %>
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::PODRenderer> is a renderer for true Perl hackers, rawr!
  
  The code of this plugin is a good example for learning to build new plugins,
  you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 OPTIONS
  
  L<Mojolicious::Plugin::PODRenderer> supports the following options.
  
  =head2 name
  
    # Mojolicious::Lite
    plugin PODRenderer => {name => 'foo'};
  
  Handler name, defaults to C<pod>.
  
  =head2 no_perldoc
  
    # Mojolicious::Lite
    plugin PODRenderer => {no_perldoc => 1};
  
  Disable L<Mojolicious::Guides> documentation browser that will otherwise be
  available under C</perldoc>.
  
  =head2 preprocess
  
    # Mojolicious::Lite
    plugin PODRenderer => {preprocess => 'epl'};
  
  Name of handler used to preprocess POD, defaults to C<ep>.
  
  =head1 HELPERS
  
  L<Mojolicious::Plugin::PODRenderer> implements the following helpers.
  
  =head2 pod_to_html
  
    %= pod_to_html '=head2 lalala'
    <%= pod_to_html begin %>=head2 lalala<% end %>
  
  Render POD to HTML without preprocessing.
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::PODRenderer> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  =head2 register
  
    my $route = $plugin->register(Mojolicious->new);
    my $route = $plugin->register(Mojolicious->new, {name => 'foo'});
  
  Register renderer and helper in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_PODRENDERER

$fatpacked{"Mojolicious/Plugin/TagHelpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_TAGHELPERS';
  package Mojolicious::Plugin::TagHelpers;
  use Mojo::Base 'Mojolicious::Plugin';
  
  use Mojo::ByteStream;
  use Mojo::DOM::HTML 'tag_to_html';
  use Scalar::Util 'blessed';
  
  sub register {
    my ($self, $app) = @_;
  
    # Text field variations
    my @time = qw(date month time week);
    for my $name (@time, qw(color email number range search tel text url)) {
      $app->helper("${name}_field" => sub { _input(@_, type => $name) });
    }
    $app->helper(datetime_field => sub { _input(@_, type => 'datetime-local') });
  
    my @helpers = (
      qw(csrf_field form_for hidden_field javascript label_for link_to),
      qw(select_field stylesheet submit_button tag_with_error text_area)
    );
    $app->helper($_ => __PACKAGE__->can("_$_")) for @helpers;
  
    $app->helper(button_to => sub { _button_to(0, @_) });
    $app->helper(check_box => sub { _input(@_, type => 'checkbox') });
    $app->helper(csrf_button_to => sub { _button_to(1, @_) });
    $app->helper(file_field => sub { _empty_field('file', @_) });
    $app->helper(image => sub { _tag('img', src => shift->url_for(shift), @_) });
    $app->helper(input_tag      => sub { _input(@_) });
    $app->helper(password_field => sub { _empty_field('password', @_) });
    $app->helper(radio_button   => sub { _input(@_, type => 'radio') });
  
    # "t" is just a shortcut for the "tag" helper
    $app->helper($_ => sub { shift; _tag(@_) }) for qw(t tag);
  }
  
  sub _button_to {
    my ($csrf, $c, $text) = (shift, shift, shift);
    my $prefix = $csrf ? _csrf_field($c) : '';
    return _form_for($c, @_, sub { $prefix . _submit_button($c, $text) });
  }
  
  sub _csrf_field {
    my $c = shift;
    return _hidden_field($c, csrf_token => $c->helpers->csrf_token, @_);
  }
  
  sub _empty_field {
    my ($type, $c, $name) = (shift, shift, shift);
    return _validation($c, $name, 'input', name => $name, @_, type => $type);
  }
  
  sub _form_for {
    my ($c, @url) = (shift, shift);
    push @url, shift if ref $_[0] eq 'HASH';
  
    # Method detection
    my $r      = $c->app->routes->lookup($url[0]);
    my $method = $r ? $r->suggested_method : 'GET';
    my @post   = $method ne 'GET' ? (method => 'POST') : ();
  
    my $url = $c->url_for(@url);
    $url->query({_method => $method}) if @post && $method ne 'POST';
    return _tag('form', action => $url, @post, @_);
  }
  
  sub _hidden_field {
    my ($c, $name, $value) = (shift, shift, shift);
    return _tag('input', name => $name, value => $value, @_, type => 'hidden');
  }
  
  sub _input {
    my ($c, $name) = (shift, shift);
    my %attrs = @_ % 2 ? (value => shift, @_) : @_;
  
    if (my @values = @{$c->every_param($name)}) {
  
      # Checkbox or radiobutton
      my $type = $attrs{type} || '';
      if ($type eq 'checkbox' || $type eq 'radio') {
        my $value = $attrs{value} // 'on';
        delete $attrs{checked};
        $attrs{checked} = undef if grep { $_ eq $value } @values;
      }
  
      # Others
      else { $attrs{value} = $values[-1] }
    }
  
    return _validation($c, $name, 'input', name => $name, %attrs);
  }
  
  sub _javascript {
    my $c = shift;
    my $content
      = ref $_[-1] eq 'CODE' ? "//<![CDATA[\n" . pop->() . "\n//]]>" : '';
    my @src = @_ % 2 ? (src => $c->url_for(shift)) : ();
    return _tag('script', @src, @_, sub {$content});
  }
  
  sub _label_for {
    my ($c, $name) = (shift, shift);
    my $content = ref $_[-1] eq 'CODE' ? pop : shift;
    return _validation($c, $name, 'label', for => $name, @_, $content);
  }
  
  sub _link_to {
    my ($c, $content) = (shift, shift);
    my @url = ($content);
  
    # Content
    unless (ref $_[-1] eq 'CODE') {
      @url = (shift);
      push @_, $content;
    }
  
    # Captures
    push @url, shift if ref $_[0] eq 'HASH';
  
    return _tag('a', href => $c->url_for(@url), @_);
  }
  
  sub _option {
    my ($values, $pair) = @_;
  
    $pair = [$pair => $pair] unless ref $pair eq 'ARRAY';
    my %attrs = (value => $pair->[1], @$pair[2 .. $#$pair]);
    delete $attrs{selected} if keys %$values;
    $attrs{selected} = undef if $values->{$pair->[1]};
  
    return _tag('option', %attrs, $pair->[0]);
  }
  
  sub _select_field {
    my ($c, $name, $options, %attrs) = (shift, shift, shift, @_);
  
    my %values = map { $_ => 1 } @{$c->every_param($name)};
  
    my $groups = '';
    for my $group (@$options) {
  
      # "optgroup" tag
      if (blessed $group && $group->isa('Mojo::Collection')) {
        my ($label, $values, %attrs) = @$group;
        my $content = join '', map { _option(\%values, $_) } @$values;
        $groups .= _tag('optgroup', label => $label, %attrs, sub {$content});
      }
  
      # "option" tag
      else { $groups .= _option(\%values, $group) }
    }
  
    return _validation($c, $name, 'select', name => $name, %attrs, sub {$groups});
  }
  
  sub _stylesheet {
    my $c = shift;
    my $content
      = ref $_[-1] eq 'CODE' ? "/*<![CDATA[*/\n" . pop->() . "\n/*]]>*/" : '';
    return _tag('style', @_, sub {$content}) unless @_ % 2;
    return _tag('link', rel => 'stylesheet', href => $c->url_for(shift), @_);
  }
  
  sub _submit_button {
    my ($c, $value) = (shift, shift // 'Ok');
    return _tag('input', value => $value, @_, type => 'submit');
  }
  
  sub _tag { Mojo::ByteStream->new(tag_to_html(@_)) }
  
  sub _tag_with_error {
    my ($c, $tag) = (shift, shift);
    my ($content, %attrs) = (@_ % 2 ? pop : undef, @_);
    $attrs{class} .= $attrs{class} ? ' field-with-error' : 'field-with-error';
    return _tag($tag, %attrs, defined $content ? $content : ());
  }
  
  sub _text_area {
    my ($c, $name) = (shift, shift);
  
    my $cb = ref $_[-1] eq 'CODE' ? pop : undef;
    my $content = @_ % 2 ? shift : undef;
    $content = $c->param($name) // $content // $cb // '';
  
    return _validation($c, $name, 'textarea', name => $name, @_, $content);
  }
  
  sub _validation {
    my ($c, $name) = (shift, shift);
    return _tag(@_) unless $c->validation->has_error($name);
    return $c->helpers->tag_with_error(@_);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugin::TagHelpers - Tag helpers plugin
  
  =head1 SYNOPSIS
  
    # Mojolicious
    $app->plugin('TagHelpers');
  
    # Mojolicious::Lite
    plugin 'TagHelpers';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugin::TagHelpers> is a collection of HTML tag helpers for
  L<Mojolicious>, based on the
  L<HTML Living Standard|https://html.spec.whatwg.org>.
  
  Most form helpers can automatically pick up previous input values and will show
  them as default. You can also use
  L<Mojolicious::Plugin::DefaultHelpers/"param"> to set them manually and let
  necessary attributes always be generated automatically.
  
    % param country => 'germany' unless param 'country';
    <%= radio_button country => 'germany' %> Germany
    <%= radio_button country => 'france'  %> France
    <%= radio_button country => 'uk'      %> UK
  
  For fields that failed validation with L<Mojolicious::Controller/"validation">
  the C<field-with-error> class will be automatically added through
  L</"tag_with_error">, to make styling with CSS easier.
  
    <input class="field-with-error" name="age" type="text" value="250">
  
  This is a core plugin, that means it is always enabled and its code a good
  example for learning how to build new plugins, you're welcome to fork it.
  
  See L<Mojolicious::Plugins/"PLUGINS"> for a list of plugins that are available
  by default.
  
  =head1 HELPERS
  
  L<Mojolicious::Plugin::TagHelpers> implements the following helpers.
  
  =head2 button_to
  
    %= button_to Test => 'some_get_route'
    %= button_to Test => some_get_route => {id => 23} => (class => 'menu')
    %= button_to Test => 'http://example.com/test' => (class => 'menu')
    %= button_to Remove => 'some_delete_route'
  
  Generate portable C<form> tag with L</"form_for">, containing a single button.
  
    <form action="/path/to/get/route">
      <input type="submit" value="Test">
    </form>
    <form action="/path/to/get/route/23" class="menu">
      <input type="submit" value="Test">
    </form>
    <form action="http://example.com/test" class="menu">
      <input type="submit" value="Test">
    </form>
    <form action="/path/to/delete/route?_method=DELETE" method="POST">
      <input type="submit" value="Remove">
    </form>
  
  =head2 check_box
  
    %= check_box 'employed'
    %= check_box employed => 1
    %= check_box employed => 1, checked => undef, id => 'foo'
  
  Generate C<input> tag of type C<checkbox>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="employed" type="checkbox">
    <input name="employed" type="checkbox" value="1">
    <input checked id="foo" name="employed" type="checkbox" value="1">
  
  =head2 color_field
  
    %= color_field 'background'
    %= color_field background => '#ffffff'
    %= color_field background => '#ffffff', id => 'foo'
  
  Generate C<input> tag of type C<color>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="background" type="color">
    <input name="background" type="color" value="#ffffff">
    <input id="foo" name="background" type="color" value="#ffffff">
  
  =head2 csrf_button_to
  
    %= csrf_button_to Remove => 'some_delete_route'
  
  Same as L</"button_to">, but also includes a L</"csrf_field">.
  
    <form action="/path/to/delete/route?_method=DELETE" method="POST">
      <input name="csrf_token" type="hidden" value="fa6a08...">
      <input type="submit" value="Remove">
    </form>
  
  =head2 csrf_field
  
    %= csrf_field
  
  Generate C<input> tag of type C<hidden> with
  L<Mojolicious::Plugin::DefaultHelpers/"csrf_token">.
  
    <input name="csrf_token" type="hidden" value="fa6a08...">
  
  =head2 date_field
  
    %= date_field 'end'
    %= date_field end => '2012-12-21'
    %= date_field end => '2012-12-21', id => 'foo'
  
  Generate C<input> tag of type C<date>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="end" type="date">
    <input name="end" type="date" value="2012-12-21">
    <input id="foo" name="end" type="date" value="2012-12-21">
  
  =head2 datetime_field
  
    %= datetime_field 'end'
    %= datetime_field end => '2012-12-21T23:59:59'
    %= datetime_field end => '2012-12-21T23:59:59', id => 'foo'
  
  Generate C<input> tag of type C<datetime-local>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="end" type="datetime-local">
    <input name="end" type="datetime-local" value="2012-12-21T23:59:59">
    <input id="foo" name="end" type="datetime-local" value="2012-12-21T23:59:59">
  
  =head2 email_field
  
    %= email_field 'notify'
    %= email_field notify => 'nospam@example.com'
    %= email_field notify => 'nospam@example.com', id => 'foo'
  
  Generate C<input> tag of type C<email>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="notify" type="email">
    <input name="notify" type="email" value="nospam@example.com">
    <input id="foo" name="notify" type="email" value="nospam@example.com">
  
  =head2 file_field
  
    %= file_field 'avatar'
    %= file_field 'avatar', id => 'foo'
  
  Generate C<input> tag of type C<file>.
  
    <input name="avatar" type="file">
    <input id="foo" name="avatar" type="file">
  
  =head2 form_for
  
    %= form_for login => begin
      %= text_field 'first_name'
      %= submit_button
    % end
    %= form_for login => {format => 'txt'} => (method => 'POST') => begin
      %= text_field 'first_name'
      %= submit_button
    % end
    %= form_for '/login' => (enctype => 'multipart/form-data') => begin
      %= text_field 'first_name', disabled => 'disabled'
      %= submit_button
    % end
    %= form_for 'http://example.com/login' => (method => 'POST') => begin
      %= text_field 'first_name'
      %= submit_button
    % end
    %= form_for some_delete_route => begin
      %= submit_button 'Remove'
    % end
  
  Generate portable C<form> tag with L<Mojolicious::Controller/"url_for">. For
  routes that do not allow C<GET>, a C<method> attribute with the value C<POST>
  will be automatically added. And for methods other than C<GET> or C<POST>, an
  C<_method> query parameter will be added as well.
  
    <form action="/path/to/login">
      <input name="first_name" type="text">
      <input type="submit" value="Ok">
    </form>
    <form action="/path/to/login.txt" method="POST">
      <input name="first_name" type="text">
      <input type="submit" value="Ok">
    </form>
    <form action="/path/to/login" enctype="multipart/form-data">
      <input disabled="disabled" name="first_name" type="text">
      <input type="submit" value="Ok">
    </form>
    <form action="http://example.com/login" method="POST">
      <input name="first_name" type="text">
      <input type="submit" value="Ok">
    </form>
    <form action="/path/to/delete/route?_method=DELETE" method="POST">
      <input type="submit" value="Remove">
    </form>
  
  =head2 hidden_field
  
    %= hidden_field foo => 'bar'
    %= hidden_field foo => 'bar', id => 'bar'
  
  Generate C<input> tag of type C<hidden>.
  
    <input name="foo" type="hidden" value="bar">
    <input id="bar" name="foo" type="hidden" value="bar">
  
  =head2 image
  
    %= image '/images/foo.png'
    %= image '/images/foo.png', alt => 'Foo'
  
  Generate portable C<img> tag.
  
    <img src="/path/to/images/foo.png">
    <img alt="Foo" src="/path/to/images/foo.png">
  
  =head2 input_tag
  
    %= input_tag 'first_name'
    %= input_tag first_name => 'Default'
    %= input_tag 'employed', type => 'checkbox'
  
  Generate C<input> tag. Previous input values will automatically get picked up
  and shown as default.
  
    <input name="first_name">
    <input name="first_name" value="Default">
    <input name="employed" type="checkbox">
  
  =head2 javascript
  
    %= javascript '/script.js'
    %= javascript '/script.js', defer => undef
    %= javascript begin
      var a = 'b';
    % end
  
  Generate portable C<script> tag for JavaScript asset.
  
    <script src="/path/to/script.js"></script>
    <script defer src="/path/to/script.js"></script>
    <script><![CDATA[
      var a = 'b';
    ]]></script>
  
  =head2 label_for
  
    %= label_for first_name => 'First name'
    %= label_for first_name => 'First name', class => 'user'
    %= label_for first_name => begin
      First name
    % end
    %= label_for first_name => (class => 'user') => begin
      First name
    % end
  
  Generate C<label> tag.
  
    <label for="first_name">First name</label>
    <label class="user" for="first_name">First name</label>
    <label for="first_name">
      First name
    </label>
    <label class="user" for="first_name">
      First name
    </label>
  
  =head2 link_to
  
    %= link_to Home => 'index'
    %= link_to Home => 'index' => {format => 'txt'} => (class => 'menu')
    %= link_to index => {format => 'txt'} => (class => 'menu') => begin
      Home
    % end
    %= link_to Contact => 'mailto:sri@example.com'
    <%= link_to index => begin %>Home<% end %>
    <%= link_to '/file.txt' => begin %>File<% end %>
    <%= link_to 'https://mojolicious.org' => begin %>Mojolicious<% end %>
    <%= link_to url_for->query(foo => 'bar')->to_abs => begin %>Retry<% end %>
  
  Generate portable C<a> tag with L<Mojolicious::Controller/"url_for">, defaults
  to using the capitalized link target as content.
  
    <a href="/path/to/index">Home</a>
    <a class="menu" href="/path/to/index.txt">Home</a>
    <a class="menu" href="/path/to/index.txt">
      Home
    </a>
    <a href="mailto:sri@example.com">Contact</a>
    <a href="/path/to/index">Home</a>
    <a href="/path/to/file.txt">File</a>
    <a href="https://mojolicious.org">Mojolicious</a>
    <a href="http://127.0.0.1:3000/current/path?foo=bar">Retry</a>
  
  =head2 month_field
  
    %= month_field 'vacation'
    %= month_field vacation => '2012-12'
    %= month_field vacation => '2012-12', id => 'foo'
  
  Generate C<input> tag of type C<month>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="vacation" type="month">
    <input name="vacation" type="month" value="2012-12">
    <input id="foo" name="vacation" type="month" value="2012-12">
  
  =head2 number_field
  
    %= number_field 'age'
    %= number_field age => 25
    %= number_field age => 25, id => 'foo', min => 0, max => 200
  
  Generate C<input> tag of type C<number>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="age" type="number">
    <input name="age" type="number" value="25">
    <input id="foo" max="200" min="0" name="age" type="number" value="25">
  
  =head2 password_field
  
    %= password_field 'pass'
    %= password_field 'pass', id => 'foo'
  
  Generate C<input> tag of type C<password>.
  
    <input name="pass" type="password">
    <input id="foo" name="pass" type="password">
  
  =head2 radio_button
  
    %= radio_button 'test'
    %= radio_button country => 'germany'
    %= radio_button country => 'germany', checked => undef, id => 'foo'
  
  Generate C<input> tag of type C<radio>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="test" type="radio">
    <input name="country" type="radio" value="germany">
    <input checked id="foo" name="country" type="radio" value="germany">
  
  =head2 range_field
  
    %= range_field 'age'
    %= range_field age => 25
    %= range_field age => 25, id => 'foo', min => 0, max => 200
  
  Generate C<input> tag of type C<range>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="age" type="range">
    <input name="age" type="range" value="25">
    <input id="foo" max="200" min="200" name="age" type="range" value="25">
  
  =head2 search_field
  
    %= search_field 'q'
    %= search_field q => 'perl'
    %= search_field q => 'perl', id => 'foo'
  
  Generate C<input> tag of type C<search>. Previous input values will
  automatically get picked up and shown as default.
  
    <input name="q" type="search">
    <input name="q" type="search" value="perl">
    <input id="foo" name="q" type="search" value="perl">
  
  =head2 select_field
  
    %= select_field country => ['de', 'en']
    %= select_field country => [[Germany => 'de'], 'en'], id => 'eu'
    %= select_field country => [[Germany => 'de', selected => 'selected'], 'en']
    %= select_field country => [c(EU => [[Germany => 'de'], 'en'], id => 'eu')]
    %= select_field country => [c(EU => ['de', 'en']), c(Asia => ['cn', 'jp'])]
  
  Generate C<select> and C<option> tags from array references and C<optgroup>
  tags from L<Mojo::Collection> objects. Previous input values will automatically
  get picked up and shown as default.
  
    <select name="country">
      <option value="de">de</option>
      <option value="en">en</option>
    </select>
    <select id="eu" name="country">
      <option value="de">Germany</option>
      <option value="en">en</option>
    </select>
    <select name="country">
      <option selected="selected" value="de">Germany</option>
      <option value="en">en</option>
    </select>
    <select name="country">
      <optgroup id="eu" label="EU">
        <option value="de">Germany</option>
        <option value="en">en</option>
      </optgroup>
    </select>
    <select name="country">
      <optgroup label="EU">
        <option value="de">de</option>
        <option value="en">en</option>
      </optgroup>
      <optgroup label="Asia">
        <option value="cn">cn</option>
        <option value="jp">jp</option>
      </optgroup>
    </select>
  
  =head2 stylesheet
  
    %= stylesheet '/foo.css'
    %= stylesheet '/foo.css', title => 'Foo style'
    %= stylesheet begin
      body {color: #000}
    % end
  
  Generate portable C<style> or C<link> tag for CSS asset.
  
    <link href="/path/to/foo.css" rel="stylesheet">
    <link href="/path/to/foo.css" rel="stylesheet" title="Foo style">
    <style><![CDATA[
      body {color: #000}
    ]]></style>
  
  =head2 submit_button
  
    %= submit_button
    %= submit_button 'Ok!', id => 'foo'
  
  Generate C<input> tag of type C<submit>.
  
    <input type="submit" value="Ok">
    <input id="foo" type="submit" value="Ok!">
  
  =head2 t
  
    %= t div => 'test & 123'
  
  Alias for L</"tag">.
  
    <div>test &amp; 123</div>
  
  =head2 tag
  
    %= tag 'br'
    %= tag 'div'
    %= tag 'div', id => 'foo', hidden => undef
    %= tag 'div', 'test & 123'
    %= tag 'div', id => 'foo', 'test & 123'
    %= tag 'div', data => {my_id => 1, Name => 'test'}, 'test & 123'
    %= tag div => begin
      test & 123
    % end
    <%= tag div => (id => 'foo') => begin %>test & 123<% end %>
  
  Alias for L<Mojo::DOM/"new_tag">.
  
    <br>
    <div></div>
    <div id="foo" hidden></div>
    <div>test &amp; 123</div>
    <div id="foo">test &amp; 123</div>
    <div data-my-id="1" data-name="test">test &amp; 123</div>
    <div>
      test & 123
    </div>
    <div id="foo">test & 123</div>
  
  Very useful for reuse in more specific tag helpers.
  
    my $output = $c->tag('meta');
    my $output = $c->tag('meta', charset => 'UTF-8');
    my $output = $c->tag('div', '<p>This will be escaped</p>');
    my $output = $c->tag('div', sub { '<p>This will not be escaped</p>' });
  
  Results are automatically wrapped in L<Mojo::ByteStream> objects to prevent
  accidental double escaping in C<ep> templates.
  
  =head2 tag_with_error
  
    %= tag_with_error 'input', class => 'foo'
  
  Same as L</"tag">, but adds the class C<field-with-error>.
  
    <input class="foo field-with-error">
  
  =head2 tel_field
  
    %= tel_field 'work'
    %= tel_field work => '123456789'
    %= tel_field work => '123456789', id => 'foo'
  
  Generate C<input> tag of type C<tel>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="work" type="tel">
    <input name="work" type="tel" value="123456789">
    <input id="foo" name="work" type="tel" value="123456789">
  
  =head2 text_area
  
    %= text_area 'story'
    %= text_area 'story', cols => 40
    %= text_area story => 'Default', cols => 40
    %= text_area story => (cols => 40) => begin
      Default
    % end
  
  Generate C<textarea> tag. Previous input values will automatically get picked
  up and shown as default.
  
    <textarea name="story"></textarea>
    <textarea cols="40" name="story"></textarea>
    <textarea cols="40" name="story">Default</textarea>
    <textarea cols="40" name="story">
      Default
    </textarea>
  
  =head2 text_field
  
    %= text_field 'first_name'
    %= text_field first_name => 'Default'
    %= text_field first_name => 'Default', class => 'user'
  
  Generate C<input> tag of type C<text>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="first_name" type="text">
    <input name="first_name" type="text" value="Default">
    <input class="user" name="first_name" type="text" value="Default">
  
  =head2 time_field
  
    %= time_field 'start'
    %= time_field start => '23:59:59'
    %= time_field start => '23:59:59', id => 'foo'
  
  Generate C<input> tag of type C<time>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="start" type="time">
    <input name="start" type="time" value="23:59:59">
    <input id="foo" name="start" type="time" value="23:59:59">
  
  =head2 url_field
  
    %= url_field 'address'
    %= url_field address => 'https://mojolicious.org'
    %= url_field address => 'https://mojolicious.org', id => 'foo'
  
  Generate C<input> tag of type C<url>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="address" type="url">
    <input name="address" type="url" value="https://mojolicious.org">
    <input id="foo" name="address" type="url" value="https://mojolicious.org">
  
  =head2 week_field
  
    %= week_field 'vacation'
    %= week_field vacation => '2012-W17'
    %= week_field vacation => '2012-W17', id => 'foo'
  
  Generate C<input> tag of type C<week>. Previous input values will automatically
  get picked up and shown as default.
  
    <input name="vacation" type="week">
    <input name="vacation" type="week" value="2012-W17">
    <input id="foo" name="vacation" type="week" value="2012-W17">
  
  =head1 METHODS
  
  L<Mojolicious::Plugin::TagHelpers> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  =head2 register
  
    $plugin->register(Mojolicious->new);
  
  Register helpers in L<Mojolicious> application.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGIN_TAGHELPERS

$fatpacked{"Mojolicious/Plugins.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGINS';
  package Mojolicious::Plugins;
  use Mojo::Base 'Mojo::EventEmitter';
  
  use Mojo::Loader 'load_class';
  use Mojo::Util 'camelize';
  
  has namespaces => sub { ['Mojolicious::Plugin'] };
  
  sub emit_chain {
    my ($self, $name, @args) = @_;
  
    my $wrapper;
    for my $cb (reverse @{$self->subscribers($name)}) {
      my $next = $wrapper;
      $wrapper = sub { $cb->($next, @args) };
    }
  
    !$wrapper ? return : return $wrapper->();
  }
  
  sub emit_hook {
    my $self = shift;
    for my $cb (@{$self->subscribers(shift)}) { $cb->(@_) }
    return $self;
  }
  
  sub emit_hook_reverse {
    my $self = shift;
    for my $cb (reverse @{$self->subscribers(shift)}) { $cb->(@_) }
    return $self;
  }
  
  sub load_plugin {
    my ($self, $name) = @_;
  
    # Try all namespaces and full module name
    my $suffix = $name =~ /^[a-z]/ ? camelize $name : $name;
    my @classes = map {"${_}::$suffix"} @{$self->namespaces};
    for my $class (@classes, $name) { return $class->new if _load($class) }
  
    # Not found
    die qq{Plugin "$name" missing, maybe you need to install it?\n};
  }
  
  sub register_plugin {
    shift->load_plugin(shift)->register(shift, ref $_[0] ? $_[0] : {@_});
  }
  
  sub _load {
    my $module = shift;
    return $module->isa('Mojolicious::Plugin') unless my $e = load_class $module;
    ref $e ? die $e : return undef;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Plugins - Plugin manager
  
  =head1 SYNOPSIS
  
    use Mojolicious::Plugins;
  
    my $plugins = Mojolicious::Plugins->new;
    push @{$plugins->namespaces}, 'MyApp::Plugin';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Plugins> is the plugin manager of L<Mojolicious>.
  
  =head1 PLUGINS
  
  The following plugins are included in the L<Mojolicious> distribution as
  examples.
  
  =over 2
  
  =item L<Mojolicious::Plugin::Config>
  
  Perl-ish configuration files.
  
  =item L<Mojolicious::Plugin::DefaultHelpers>
  
  General purpose helper collection, loaded automatically.
  
  =item L<Mojolicious::Plugin::EPLRenderer>
  
  Renderer for plain embedded Perl templates, loaded automatically.
  
  =item L<Mojolicious::Plugin::EPRenderer>
  
  Renderer for more sophisticated embedded Perl templates, loaded automatically.
  
  =item L<Mojolicious::Plugin::HeaderCondition>
  
  Route condition for all kinds of headers, loaded automatically.
  
  =item L<Mojolicious::Plugin::JSONConfig>
  
  JSON configuration files.
  
  =item L<Mojolicious::Plugin::Mount>
  
  Mount whole L<Mojolicious> applications.
  
  =item L<Mojolicious::Plugin::PODRenderer>
  
  Renderer for turning POD into HTML and documentation browser for
  L<Mojolicious::Guides>.
  
  =item L<Mojolicious::Plugin::TagHelpers>
  
  Template specific helper collection, loaded automatically.
  
  =back
  
  =head1 EVENTS
  
  L<Mojolicious::Plugins> inherits all events from L<Mojo::EventEmitter>.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Plugins> implements the following attributes.
  
  =head2 namespaces
  
    my $namespaces = $plugins->namespaces;
    $plugins       = $plugins->namespaces(['Mojolicious::Plugin']);
  
  Namespaces to load plugins from, defaults to L<Mojolicious::Plugin>.
  
    # Add another namespace to load plugins from
    push @{$plugins->namespaces}, 'MyApp::Plugin';
  
  =head1 METHODS
  
  L<Mojolicious::Plugins> inherits all methods from L<Mojo::EventEmitter> and
  implements the following new ones.
  
  =head2 emit_chain
  
    $plugins->emit_chain('foo');
    $plugins->emit_chain(foo => 123);
  
  Emit events as chained hooks.
  
  =head2 emit_hook
  
    $plugins = $plugins->emit_hook('foo');
    $plugins = $plugins->emit_hook(foo => 123);
  
  Emit events as hooks.
  
  =head2 emit_hook_reverse
  
    $plugins = $plugins->emit_hook_reverse('foo');
    $plugins = $plugins->emit_hook_reverse(foo => 123);
  
  Emit events as hooks in reverse order.
  
  =head2 load_plugin
  
    my $plugin = $plugins->load_plugin('some_thing');
    my $plugin = $plugins->load_plugin('SomeThing');
    my $plugin = $plugins->load_plugin('MyApp::Plugin::SomeThing');
  
  Load a plugin from the configured namespaces or by full module name.
  
  =head2 register_plugin
  
    $plugins->register_plugin('some_thing', Mojolicious->new);
    $plugins->register_plugin('some_thing', Mojolicious->new, foo => 23);
    $plugins->register_plugin('some_thing', Mojolicious->new, {foo => 23});
    $plugins->register_plugin('SomeThing', Mojolicious->new);
    $plugins->register_plugin('SomeThing', Mojolicious->new, foo => 23);
    $plugins->register_plugin('SomeThing', Mojolicious->new, {foo => 23});
    $plugins->register_plugin('MyApp::Plugin::SomeThing', Mojolicious->new);
    $plugins->register_plugin(
      'MyApp::Plugin::SomeThing', Mojolicious->new, foo => 23);
    $plugins->register_plugin(
      'MyApp::Plugin::SomeThing', Mojolicious->new, {foo => 23});
  
  Load a plugin from the configured namespaces or by full module name and run
  C<register>, optional arguments are passed through.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_PLUGINS

$fatpacked{"Mojolicious/Renderer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_RENDERER';
  package Mojolicious::Renderer;
  use Mojo::Base -base;
  
  use Mojo::Cache;
  use Mojo::File 'path';
  use Mojo::JSON 'encode_json';
  use Mojo::Home;
  use Mojo::Loader 'data_section';
  use Mojo::Util qw(decamelize encode md5_sum monkey_patch);
  
  has cache   => sub { Mojo::Cache->new };
  has classes => sub { ['main'] };
  has default_format => 'html';
  has 'default_handler';
  has encoding => 'UTF-8';
  has [qw(handlers helpers)] => sub { {} };
  has paths => sub { [] };
  
  # Bundled templates
  my $TEMPLATES = Mojo::Home->new->mojo_lib_dir->child('Mojolicious', 'resources',
    'templates');
  
  sub DESTROY { Mojo::Util::_teardown($_) for @{shift->{namespaces}} }
  
  sub accepts {
    my ($self, $c) = (shift, shift);
  
    # List representations
    my $req  = $c->req;
    my $fmt  = $req->param('format') || $c->stash->{format};
    my @exts = $fmt ? ($fmt) : ();
    push @exts, @{$c->app->types->detect($req->headers->accept)};
    return \@exts unless @_;
  
    # Find best representation
    for my $ext (@exts) { $ext eq $_ and return $ext for @_ }
    return @exts ? undef : shift;
  }
  
  sub add_handler { $_[0]->handlers->{$_[1]} = $_[2] and return $_[0] }
  
  sub add_helper {
    my ($self, $name, $cb) = @_;
    $self->helpers->{$name} = $cb;
    delete $self->{proxy};
    return $self;
  }
  
  sub get_data_template {
    my ($self, $options) = @_;
    return undef unless my $template = $self->template_name($options);
    return data_section $self->{index}{$template}, $template;
  }
  
  sub get_helper {
    my ($self, $name) = @_;
  
    if (my $h = $self->{proxy}{$name} || $self->helpers->{$name}) { return $h }
  
    my $found;
    my $class = 'Mojolicious::Renderer::Helpers::' . md5_sum "$name:$self";
    my $re = length $name ? qr/^(\Q$name\E\.([^.]+))/ : qr/^(([^.]+))/;
    for my $key (keys %{$self->helpers}) {
      $key =~ $re ? ($found, my $method) = (1, $2) : next;
      my $sub = $self->get_helper($1);
      monkey_patch $class, $method => sub { ${shift()}->$sub(@_) };
    }
  
    $found ? push @{$self->{namespaces}}, $class : return undef;
    return $self->{proxy}{$name} = sub { bless \(my $dummy = shift), $class };
  }
  
  sub render {
    my ($self, $c, $args) = @_;
  
    my $stash   = $c->stash;
    my $options = {
      encoding => $self->encoding,
      handler  => $stash->{handler},
      template => delete $stash->{template},
      variant  => $stash->{variant}
    };
    my $inline = $options->{inline} = delete $stash->{inline};
    $options->{handler} //= $self->default_handler if defined $inline;
    $options->{format} = $stash->{format} || $self->default_format;
  
    # Data
    return delete $stash->{data}, $options->{format} if defined $stash->{data};
  
    # Text
    return _maybe($options->{encoding}, delete $stash->{text}), $options->{format}
      if defined $stash->{text};
  
    # JSON
    return encode_json(delete $stash->{json}), 'json' if exists $stash->{json};
  
    # Template or templateless handler
    $options->{template} //= $self->template_for($c);
    return () unless $self->_render_template($c, \my $output, $options);
  
    # Inheritance
    my $content = $stash->{'mojo.content'} ||= {};
    local $content->{content} = $output =~ /\S/ ? $output : undef
      if $stash->{extends} || $stash->{layout};
    while ((my $next = _next($stash)) && !defined $inline) {
      @$options{qw(handler template)} = ($stash->{handler}, $next);
      $options->{format} = $stash->{format} || $self->default_format;
      if ($self->_render_template($c, \my $tmp, $options)) { $output = $tmp }
      $content->{content} //= $output if $output =~ /\S/;
    }
  
    return $output if $args->{'mojo.string'};
    return _maybe($options->{encoding}, $output), $options->{format};
  }
  
  sub template_for {
    my ($self, $c) = @_;
  
    # Normal default template
    my $stash = $c->stash;
    my ($controller, $action) = @$stash{qw(controller action)};
    return join '/', split('-', decamelize $controller), $action
      if $controller && $action;
  
    # Try the route name if we don't have controller and action
    return undef unless my $route = $c->match->endpoint;
    return $route->name;
  }
  
  sub template_handler {
    my ($self, $options) = @_;
    return undef unless my $file = $self->template_name($options);
    return $self->default_handler unless my $handlers = $self->{templates}{$file};
    return $handlers->[0];
  }
  
  sub template_name {
    my ($self, $options) = @_;
  
    return undef unless defined(my $template = $options->{template});
    return undef unless my $format = $options->{format};
    $template .= ".$format";
  
    $self->warmup unless $self->{templates};
  
    # Variants
    my $handler = $options->{handler};
    if (defined(my $variant = $options->{variant})) {
      $variant = "$template+$variant";
      my $handlers = $self->{templates}{$variant} // [];
      $template = $variant
        if @$handlers && !defined $handler || grep { $_ eq $handler } @$handlers;
    }
  
    return defined $handler ? "$template.$handler" : $template;
  }
  
  sub template_path {
    my ($self, $options) = @_;
    return undef unless my $name = $self->template_name($options);
    my @parts = split '/', $name;
    -r and return $_
      for map { path($_, @parts)->to_string } @{$self->paths}, $TEMPLATES;
    return undef;
  }
  
  sub warmup {
    my $self = shift;
  
    my ($index, $templates) = @$self{qw(index templates)} = ({}, {});
  
    # Handlers for templates
    for my $path (@{$self->paths}, $TEMPLATES) {
      s/\.(\w+)$// and push @{$templates->{$_}}, $1
        for path($path)->list_tree->map(sub { join '/', @{$_->to_rel($path)} })
        ->each;
    }
  
    # Handlers and classes for DATA templates
    for my $class (reverse @{$self->classes}) {
      $index->{$_} = $class for my @keys = sort keys %{data_section $class};
      s/\.(\w+)$// and unshift @{$templates->{$_}}, $1 for reverse @keys;
    }
  }
  
  sub _maybe { $_[0] ? encode @_ : $_[1] }
  
  sub _next {
    my $stash = shift;
    return delete $stash->{extends} if $stash->{extends};
    return undef unless my $layout = delete $stash->{layout};
    return join '/', 'layouts', $layout;
  }
  
  sub _render_template {
    my ($self, $c, $output, $options) = @_;
  
    my $handler = $options->{handler} ||= $self->template_handler($options);
    return undef unless $handler;
    $c->app->log->error(qq{No handler for "$handler" available}) and return undef
      unless my $renderer = $self->handlers->{$handler};
  
    $renderer->($self, $c, $output, $options);
    return 1 if defined $$output;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Renderer - Generate dynamic content
  
  =head1 SYNOPSIS
  
    use Mojolicious::Renderer;
  
    my $renderer = Mojolicious::Renderer->new;
    push @{$renderer->classes}, 'MyApp::Controller::Foo';
    push @{$renderer->paths}, '/home/sri/templates';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Renderer> is the standard L<Mojolicious> renderer.
  
  See L<Mojolicious::Guides::Rendering> for more.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Renderer> implements the following attributes.
  
  =head2 cache
  
    my $cache = $renderer->cache;
    $renderer = $renderer->cache(Mojo::Cache->new);
  
  Renderer cache, defaults to a L<Mojo::Cache> object.
  
  =head2 classes
  
    my $classes = $renderer->classes;
    $renderer   = $renderer->classes(['main']);
  
  Classes to use for finding templates in C<DATA> sections with L<Mojo::Loader>,
  first one has the highest precedence, defaults to C<main>. Only files with
  exactly two extensions will be used, like C<index.html.ep>. Note that for
  templates to be detected, these classes need to have already been loaded and
  added before L</"warmup"> is called, which usually happens automatically during
  application startup.
  
    # Add another class with templates in DATA section
    push @{$renderer->classes}, 'Mojolicious::Plugin::Fun';
  
    # Add another class with templates in DATA section and higher precedence
    unshift @{$renderer->classes}, 'Mojolicious::Plugin::MoreFun';
  
  =head2 default_format
  
    my $default = $renderer->default_format;
    $renderer   = $renderer->default_format('html');
  
  The default format to render if C<format> is not set in the stash, defaults to
  C<html>. Note that changing the default away from C<html> is not recommended, as
  it has the potential to break, for example, plugins with bundled templates.
  
  =head2 default_handler
  
    my $default = $renderer->default_handler;
    $renderer   = $renderer->default_handler('ep');
  
  The default template handler to use for rendering in cases where auto-detection
  doesn't work, like for C<inline> templates.
  
  =head2 encoding
  
    my $encoding = $renderer->encoding;
    $renderer    = $renderer->encoding('koi8-r');
  
  Will encode generated content if set, defaults to C<UTF-8>. Note that many
  renderers such as L<Mojolicious::Plugin::EPRenderer> also use this value to
  determine if template files should be decoded before processing.
  
  =head2 handlers
  
    my $handlers = $renderer->handlers;
    $renderer    = $renderer->handlers({epl => sub {...}});
  
  Registered handlers.
  
  =head2 helpers
  
    my $helpers = $renderer->helpers;
    $renderer   = $renderer->helpers({url_for => sub {...}});
  
  Registered helpers.
  
  =head2 paths
  
    my $paths = $renderer->paths;
    $renderer = $renderer->paths(['/home/sri/templates']);
  
  Directories to look for templates in, first one has the highest precedence.
  
    # Add another "templates" directory
    push @{$renderer->paths}, '/home/sri/templates';
  
    # Add another "templates" directory with higher precedence
    unshift @{$renderer->paths}, '/home/sri/themes/blue/templates';
  
  =head1 METHODS
  
  L<Mojolicious::Renderer> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 accepts
  
    my $all  = $renderer->accepts(Mojolicious::Controller->new);
    my $best = $renderer->accepts(Mojolicious::Controller->new, 'html', 'json');
  
  Select best possible representation for L<Mojolicious::Controller> object from
  C<format> C<GET>/C<POST> parameter, C<format> stash value, or C<Accept> request
  header, defaults to returning the first extension if no preference could be
  detected.
  
  =head2 add_handler
  
    $renderer = $renderer->add_handler(epl => sub {...});
  
  Register a handler.
  
    $renderer->add_handler(foo => sub {
      my ($renderer, $c, $output, $options) = @_;
      ...
      $$output = 'Hello World!';
    });
  
  =head2 add_helper
  
    $renderer = $renderer->add_helper(url_for => sub {...});
  
  Register a helper.
  
    $renderer->add_helper(foo => sub {
      my ($c, @args) = @_;
      ...
    });
  
  =head2 get_data_template
  
    my $template = $renderer->get_data_template({
      template       => 'foo/bar',
      format         => 'html',
      handler        => 'epl'
    });
  
  Return a C<DATA> section template from L</"classes"> for an options hash
  reference with C<template>, C<format>, C<variant> and C<handler> values, or
  C<undef> if no template could be found, usually used by handlers.
  
  =head2 get_helper
  
    my $helper = $renderer->get_helper('url_for');
  
  Get a helper by full name, generate a helper dynamically for a prefix, or return
  C<undef> if no helper or prefix could be found. Generated helpers return a
  proxy object containing the current controller object and on which nested
  helpers can be called.
  
  =head2 render
  
    my ($output, $format) = $renderer->render(Mojolicious::Controller->new, {
      template => 'foo/bar',
      foo      => 'bar'
    });
  
  Render output through one of the renderers. See
  L<Mojolicious::Controller/"render"> for a more user-friendly interface.
  
  =head2 template_for
  
    my $name = $renderer->template_for(Mojolicious::Controller->new);
  
  Return default template name for L<Mojolicious::Controller> object, or C<undef>
  if no name could be generated.
  
  =head2 template_handler
  
    my $handler = $renderer->template_handler({
      template => 'foo/bar',
      format   => 'html'
    });
  
  Return handler for an options hash reference with C<template>, C<format> and
  C<variant> values, or C<undef> if no handler could be found.
  
  =head2 template_name
  
    my $template = $renderer->template_name({
      template => 'foo/bar',
      format   => 'html',
      handler  => 'epl'
    });
  
  Return a template name for an options hash reference with C<template>,
  C<format>, C<variant> and C<handler> values, or C<undef> if no template could be
  found, usually used by handlers.
  
  =head2 template_path
  
    my $path = $renderer->template_path({
      template => 'foo/bar',
      format   => 'html',
      handler  => 'epl'
    });
  
  Return the full template path for an options hash reference with C<template>,
  C<format>, C<variant> and C<handler> values, or C<undef> if the file does not
  exist in L</"paths">, usually used by handlers.
  
  =head2 warmup
  
    $renderer->warmup;
  
  Prepare templates from L</"classes"> for future use.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_RENDERER

$fatpacked{"Mojolicious/Routes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_ROUTES';
  package Mojolicious::Routes;
  use Mojo::Base 'Mojolicious::Routes::Route';
  
  use List::Util 'first';
  use Mojo::Cache;
  use Mojo::Loader 'load_class';
  use Mojo::Util 'camelize';
  use Mojolicious::Routes::Match;
  use Scalar::Util 'weaken';
  
  has base_classes => sub { [qw(Mojolicious::Controller Mojolicious)] };
  has cache        => sub { Mojo::Cache->new };
  has [qw(conditions shortcuts)] => sub { {} };
  has types      => sub { {num => qr/[0-9]+/} };
  has hidden     => sub { [qw(attr has new tap)] };
  has namespaces => sub { [] };
  
  sub add_condition { $_[0]->conditions->{$_[1]} = $_[2] and return $_[0] }
  sub add_shortcut  { $_[0]->shortcuts->{$_[1]}  = $_[2] and return $_[0] }
  sub add_type      { $_[0]->types->{$_[1]}      = $_[2] and return $_[0] }
  
  sub continue {
    my ($self, $c) = @_;
  
    my $match    = $c->match;
    my $stack    = $match->stack;
    my $position = $match->position;
    return _render($c) unless my $field = $stack->[$position];
  
    # Merge captures into stash
    my $stash = $c->stash;
    @{$stash->{'mojo.captures'} //= {}}{keys %$field} = values %$field;
    @$stash{keys %$field} = values %$field;
  
    my $continue;
    my $last = !$stack->[++$position];
    if (my $cb = $field->{cb}) { $continue = $self->_callback($c, $cb, $last) }
    else { $continue = $self->_controller($c, $field, $last) }
    $match->position($position);
    $self->continue($c) if $last || $continue;
  }
  
  sub dispatch {
    my ($self, $c) = @_;
    $self->match($c);
    @{$c->match->stack} ? $self->continue($c) : return undef;
    return 1;
  }
  
  sub hide { push @{shift->hidden}, @_ }
  
  sub is_hidden {
    my ($self, $method) = @_;
    my $h = $self->{hiding} ||= {map { $_ => 1 } @{$self->hidden}};
    return !!($h->{$method} || $method =~ /^_/ || $method =~ /^[A-Z_]+$/);
  }
  
  sub lookup { ($_[0]{reverse} //= $_[0]->_index)->{$_[1]} }
  
  sub match {
    my ($self, $c) = @_;
  
    # Path (partial path gets priority)
    my $req  = $c->req;
    my $path = $c->stash->{path};
    if (defined $path) { $path = "/$path" if $path !~ m!^/! }
    else               { $path = $req->url->path->to_route }
  
    # Method (HEAD will be treated as GET)
    my $method = uc($req->url->query->clone->param('_method') || $req->method);
    $method = 'GET' if $method eq 'HEAD';
  
    # Check cache
    my $ws = $c->tx->is_websocket ? 1 : 0;
    my $match = Mojolicious::Routes::Match->new(root => $self);
    $c->match($match);
    my $cache = $self->cache;
    if (my $result = $cache->get("$method:$path:$ws")) {
      return $match->endpoint($result->{endpoint})->stack($result->{stack});
    }
  
    # Check routes
    $match->find($c => {method => $method, path => $path, websocket => $ws});
    return unless my $route = $match->endpoint;
    $cache->set(
      "$method:$path:$ws" => {endpoint => $route, stack => $match->stack});
  }
  
  sub _action { shift->plugins->emit_chain(around_action => @_) }
  
  sub _callback {
    my ($self, $c, $cb, $last) = @_;
    $c->stash->{'mojo.routed'} = 1 if $last;
    my $app = $c->app;
    $app->log->debug('Routing to a callback');
    return _action($app, $c, $cb, $last);
  }
  
  sub _class {
    my ($self, $c, $field) = @_;
  
    # Application instance
    return $field->{app} if ref $field->{app};
  
    # Application class
    my @classes;
    my $class = $field->{controller} ? camelize $field->{controller} : '';
    if ($field->{app}) { push @classes, $field->{app} }
  
    # Specific namespace
    elsif (defined(my $ns = $field->{namespace})) {
      if ($class) { push @classes, $ns ? "${ns}::$class" : $class }
      elsif ($ns) { push @classes, $ns }
    }
  
    # All namespaces
    elsif ($class) { push @classes, "${_}::$class" for @{$self->namespaces} }
  
    # Try to load all classes
    my $log = $c->app->log;
    for my $class (@classes) {
  
      # Failed
      next unless defined(my $found = $self->_load($class));
      return !$log->debug(qq{Class "$class" is not a controller}) unless $found;
  
      # Success
      my $new = $class->new(%$c);
      weaken $new->{$_} for qw(app tx);
      return $new;
    }
  
    # Nothing found
    $log->debug(qq{Controller "$classes[-1]" does not exist}) if @classes;
    return @classes ? undef : 0;
  }
  
  sub _controller {
    my ($self, $old, $field, $last) = @_;
  
    # Load and instantiate controller/application
    my $new;
    unless ($new = $self->_class($old, $field)) { return defined $new }
  
    # Application
    my $class = ref $new;
    my $app   = $old->app;
    my $log   = $app->log;
    if ($new->isa('Mojolicious')) {
      $log->debug(qq{Routing to application "$class"});
  
      # Try to connect routes
      if (my $sub = $new->can('routes')) {
        my $r = $new->$sub;
        weaken $r->parent($old->match->endpoint)->{parent} unless $r->parent;
      }
      $new->handler($old);
      $old->stash->{'mojo.routed'} = 1;
    }
  
    # Action
    elsif (my $method = $field->{action}) {
      if (!$self->is_hidden($method)) {
        $log->debug(qq{Routing to controller "$class" and action "$method"});
  
        if (my $sub = $new->can($method)) {
          $old->stash->{'mojo.routed'} = 1 if $last;
          return 1 if _action($app, $new, $sub, $last);
        }
  
        else { $log->debug('Action not found in controller') }
      }
      else { $log->debug(qq{Action "$method" is not allowed}) }
    }
  
    return undef;
  }
  
  sub _load {
    my ($self, $app) = @_;
  
    # Load unless already loaded
    return 1 if $self->{loaded}{$app};
    if (my $e = load_class $app) { ref $e ? die $e : return undef }
  
    # Check base classes
    return 0 unless first { $app->isa($_) } @{$self->base_classes};
    return $self->{loaded}{$app} = 1;
  }
  
  sub _render {
    my $c     = shift;
    my $stash = $c->stash;
    return if $stash->{'mojo.rendered'};
    $c->render_maybe or $stash->{'mojo.routed'} or $c->helpers->reply->not_found;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Routes - Always find your destination with routes
  
  =head1 SYNOPSIS
  
    use Mojolicious::Routes;
  
    # Simple route
    my $r = Mojolicious::Routes->new;
    $r->route('/')->to(controller => 'blog', action => 'welcome');
  
    # More advanced routes
    my $blog = $r->under('/blog');
    $blog->get('/list')->to('blog#list');
    $blog->get('/:id' => [id => qr/\d+/])->to('blog#show', id => 23);
    $blog->patch(sub { shift->render(text => 'Go away!', status => 405) });
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Routes> is the core of the L<Mojolicious> web framework.
  
  See L<Mojolicious::Guides::Routing> for more.
  
  =head1 TYPES
  
  These placeholder types are available by default.
  
  =head2 num
  
    $r->get('/article/<id:num>');
  
  Placeholder value needs to be a non-fractional number, similar to the regular
  expression C<([0-9]+)>.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Routes> inherits all attributes from
  L<Mojolicious::Routes::Route> and implements the following new ones.
  
  =head2 base_classes
  
    my $classes = $r->base_classes;
    $r          = $r->base_classes(['MyApp::Controller']);
  
  Base classes used to identify controllers, defaults to
  L<Mojolicious::Controller> and L<Mojolicious>.
  
  =head2 cache
  
    my $cache = $r->cache;
    $r        = $r->cache(Mojo::Cache->new);
  
  Routing cache, defaults to a L<Mojo::Cache> object.
  
  =head2 conditions
  
    my $conditions = $r->conditions;
    $r             = $r->conditions({foo => sub {...}});
  
  Contains all available conditions.
  
  =head2 hidden
  
    my $hidden = $r->hidden;
    $r         = $r->hidden(['attr', 'has', 'new']);
  
  Controller attributes and methods that are hidden from router, defaults to
  C<attr>, C<has>, C<new> and C<tap>.
  
  =head2 namespaces
  
    my $namespaces = $r->namespaces;
    $r             = $r->namespaces(['MyApp::Controller', 'MyApp']);
  
  Namespaces to load controllers from.
  
    # Add another namespace to load controllers from
    push @{$r->namespaces}, 'MyApp::MyController';
  
  =head2 shortcuts
  
    my $shortcuts = $r->shortcuts;
    $r            = $r->shortcuts({foo => sub {...}});
  
  Contains all available shortcuts.
  
  =head2 types
  
    my $types = $r->types;
    $r        = $r->types({lower => qr/[a-z]+/});
  
  Registered placeholder types, by default only L</"num"> is already defined.
  
  =head1 METHODS
  
  L<Mojolicious::Routes> inherits all methods from L<Mojolicious::Routes::Route>
  and implements the following new ones.
  
  =head2 add_condition
  
    $r = $r->add_condition(foo => sub {...});
  
  Register a condition.
  
    $r->add_condition(foo => sub {
      my ($route, $c, $captures, $arg) = @_;
      ...
      return 1;
    });
  
  =head2 add_shortcut
  
    $r = $r->add_shortcut(foo => sub {...});
  
  Register a shortcut.
  
    $r->add_shortcut(foo => sub {
      my ($route, @args) = @_;
      ...
    });
  
  =head2 add_type
  
    $r = $r->add_type(foo => qr/\w+/);
    $r = $r->add_type(foo => ['bar', 'baz']);
  
  Register a placeholder type.
  
    $r->add_type(lower => qr/[a-z]+/);
  
  =head2 continue
  
    $r->continue(Mojolicious::Controller->new);
  
  Continue dispatch chain and emit the hook L<Mojolicious/"around_action"> for
  every action.
  
  =head2 dispatch
  
    my $bool = $r->dispatch(Mojolicious::Controller->new);
  
  Match routes with L</"match"> and dispatch with L</"continue">.
  
  =head2 hide
  
    $r = $r->hide('foo', 'bar');
  
  Hide controller attributes and methods from router.
  
  =head2 is_hidden
  
    my $bool = $r->is_hidden('foo');
  
  Check if controller attribute or method is hidden from router.
  
  =head2 lookup
  
    my $route = $r->lookup('foo');
  
  Find route by name with L<Mojolicious::Routes::Route/"find"> and cache all
  results for future lookups.
  
  =head2 match
  
    $r->match(Mojolicious::Controller->new);
  
  Match routes with L<Mojolicious::Routes::Match>.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_ROUTES

$fatpacked{"Mojolicious/Routes/Match.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_ROUTES_MATCH';
  package Mojolicious::Routes::Match;
  use Mojo::Base -base;
  
  use Mojo::Util;
  
  has [qw(endpoint root)];
  has position => 0;
  has stack => sub { [] };
  
  sub find { $_[0]->_match($_[0]->root, $_[1], $_[2]) }
  
  sub path_for {
    my ($self, $name, %values) = (shift, Mojo::Util::_options(@_));
  
    # Current route
    my $route;
    if (!$name || $name eq 'current') {
      return {} unless $route = $self->endpoint;
    }
  
    # Find endpoint
    else { return {path => $name} unless $route = $self->root->lookup($name) }
  
    # Merge values (clear format)
    my $captures = $self->stack->[-1] || {};
    %values = (%$captures, format => undef, %values);
    my $pattern = $route->pattern;
    $values{format}
      //= defined $captures->{format}
      ? $captures->{format}
      : $pattern->defaults->{format}
      if $pattern->constraints->{format};
  
    my $path = $route->render(\%values);
    return {path => $path, websocket => $route->has_websocket};
  }
  
  sub _match {
    my ($self, $r, $c, $options) = @_;
  
    # Pattern
    my $path    = $options->{path};
    my $partial = $r->partial;
    my $detect  = (my $endpoint = $r->is_endpoint) && !$partial;
    return undef
      unless my $captures = $r->pattern->match_partial(\$path, $detect);
    local $options->{path} = $path;
    local @{$self->{captures} ||= {}}{keys %$captures} = values %$captures;
    $captures = $self->{captures};
  
    # Method
    my $methods = $r->via;
    return undef if $methods && !grep { $_ eq $options->{method} } @$methods;
  
    # Conditions
    if (my $over = $r->over) {
      my $conditions = $self->{conditions} ||= $self->root->conditions;
      for (my $i = 0; $i < @$over; $i += 2) {
        return undef unless my $condition = $conditions->{$over->[$i]};
        return undef if !$condition->($r, $c, $captures, $over->[$i + 1]);
      }
    }
  
    # WebSocket
    return undef if $r->is_websocket && !$options->{websocket};
  
    # Partial
    my $empty = !length $path || $path eq '/';
    if ($partial) {
      $captures->{path} = $path;
      $self->endpoint($r);
      $empty = 1;
    }
  
    # Endpoint (or intermediate destination)
    if (($endpoint && $empty) || $r->inline) {
      push @{$self->stack}, {%$captures};
      if ($endpoint && $empty) {
        my $format = $captures->{format};
        if ($format) { $_->{format} = $format for @{$self->stack} }
        return !!$self->endpoint($r);
      }
      delete @$captures{qw(app cb)};
    }
  
    # Match children
    my $snapshot = $r->parent ? [@{$self->stack}] : [];
    for my $child (@{$r->children}) {
      return 1 if $self->_match($child, $c, $options);
      $self->stack([@$snapshot]);
    }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Routes::Match - Find routes
  
  =head1 SYNOPSIS
  
    use Mojolicious::Controller;
    use Mojolicious::Routes;
    use Mojolicious::Routes::Match;
  
    # Routes
    my $r = Mojolicious::Routes->new;
    $r->get('/:controller/:action');
    $r->put('/:controller/:action');
  
    # Match
    my $c = Mojolicious::Controller->new;
    my $match = Mojolicious::Routes::Match->new(root => $r);
    $match->find($c => {method => 'PUT', path => '/foo/bar'});
    say $match->stack->[0]{controller};
    say $match->stack->[0]{action};
  
    # Render
    say $match->path_for->{path};
    say $match->path_for(action => 'baz')->{path};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Routes::Match> finds routes in L<Mojolicious::Routes>
  structures.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Routes::Match> implements the following attributes.
  
  =head2 endpoint
  
    my $route = $match->endpoint;
    $match    = $match->endpoint(Mojolicious::Routes::Route->new);
  
  The route endpoint that matched, usually a L<Mojolicious::Routes::Route>
  object.
  
  =head2 position
  
    my $position = $match->position;
    $match       = $match->position(2);
  
  Current position on the L</"stack">, defaults to C<0>.
  
  =head2 root
  
    my $root = $match->root;
    $match   = $match->root(Mojolicious::Routes->new);
  
  The root of the route structure, usually a L<Mojolicious::Routes> object.
  
  =head2 stack
  
    my $stack = $match->stack;
    $match    = $match->stack([{action => 'foo'}, {action => 'bar'}]);
  
  Captured parameters with nesting history.
  
  =head1 METHODS
  
  L<Mojolicious::Routes::Match> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 find
  
    $match->find(Mojolicious::Controller->new, {method => 'GET', path => '/'});
  
  Match controller and options against L</"root"> to find an appropriate
  L</"endpoint">.
  
  =head2 path_for
  
    my $info = $match->path_for;
    my $info = $match->path_for(foo => 'bar');
    my $info = $match->path_for({foo => 'bar'});
    my $info = $match->path_for('named');
    my $info = $match->path_for('named', foo => 'bar');
    my $info = $match->path_for('named', {foo => 'bar'});
  
  Render matching route with parameters into path.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_ROUTES_MATCH

$fatpacked{"Mojolicious/Routes/Pattern.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_ROUTES_PATTERN';
  package Mojolicious::Routes::Pattern;
  use Mojo::Base -base;
  
  use Carp 'croak';
  use Mojo::Util 'deprecated';
  
  has [qw(constraints defaults types)] => sub { {} };
  has [qw(placeholder_start type_start)] => ':';
  has [qw(placeholders tree)] => sub { [] };
  has quote_end   => '>';
  has quote_start => '<';
  has [qw(regex unparsed)];
  has relaxed_start  => '#';
  has wildcard_start => '*';
  
  sub match {
    my ($self, $path, $detect) = @_;
    my $captures = $self->match_partial(\$path, $detect);
    return !$path || $path eq '/' ? $captures : undef;
  }
  
  sub match_partial {
    my ($self, $pathref, $detect) = @_;
  
    # Compile on demand
    $self->_compile($detect) unless $self->{regex};
  
    return undef unless my @captures = $$pathref =~ $self->regex;
    $$pathref = ${^POSTMATCH};
    @captures = () if $#+ == 0;
    my $captures = {%{$self->defaults}};
    for my $placeholder (@{$self->placeholders}, 'format') {
      last unless @captures;
      my $capture = shift @captures;
      $captures->{$placeholder} = $capture if defined $capture;
    }
  
    return $captures;
  }
  
  sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }
  
  sub parse {
    my $self = shift;
  
    my $pattern = @_ % 2 ? (shift // '/') : '/';
    $pattern =~ s!^/*|/+!/!g;
    return $self->constraints({@_}) if $pattern eq '/';
  
    $pattern =~ s!/$!!;
    return $self->constraints({@_})->_tokenize($pattern);
  }
  
  sub render {
    my ($self, $values, $endpoint) = @_;
  
    my $start = $self->type_start;
  
    # Placeholders can only be optional without a format
    my $optional = !(my $format = $values->{format});
  
    my $str = '';
    for my $token (reverse @{$self->tree}) {
      my ($op, $value) = @$token;
      my $part = '';
  
      # Text
      if ($op eq 'text') { ($part, $optional) = ($value, 0) }
  
      # Slash
      elsif ($op eq 'slash') { $part = '/' unless $optional }
  
      # Placeholder
      else {
        my $name = (split $start, $value)[0] // '';
        my $default = $self->defaults->{$name};
        $part = $values->{$name} // $default // '';
        if (!defined $default || ($default ne $part)) { $optional = 0 }
        elsif ($optional) { $part = '' }
      }
  
      $str = $part . $str;
    }
  
    # Format can be optional
    return $endpoint && $format ? "$str.$format" : $str;
  }
  
  sub _compile {
    my ($self, $detect) = @_;
  
    my $placeholders = $self->placeholders;
    my $constraints  = $self->constraints;
    my $defaults     = $self->defaults;
    my $start        = $self->type_start;
    my $types        = $self->types;
  
    my $block = my $regex = '';
    my $optional = 1;
    for my $token (reverse @{$self->tree}) {
      my ($op, $value, $type) = @$token;
      my $part = '';
  
      # Text
      if ($op eq 'text') { ($part, $optional) = (quotemeta $value, 0) }
  
      # Slash
      elsif ($op eq 'slash') {
        $regex = ($optional ? "(?:/$block)?" : "/$block") . $regex;
        ($block, $optional) = ('', 1);
        next;
      }
  
      # Placeholder
      else {
        if ($value =~ /^(.+)\Q$start\E(.+)$/) {
          ($value, $part) = ($1, _compile_req($types->{$2} // '?!'));
        }
        else {
          $part = $type ? $type eq 'relaxed' ? '([^/]+)' : '(.+)' : '([^/.]+)';
        }
        unshift @$placeholders, $value;
  
        # Custom regex
        if (my $c = $constraints->{$value}) { $part = _compile_req($c) }
  
        # Optional placeholder
        exists $defaults->{$value} ? ($part .= '?') : ($optional = 0);
      }
  
      $block = $part . $block;
    }
  
    # Not rooted with a slash
    $regex = $block . $regex if $block;
  
    # Format
    $regex .= _compile_format($constraints->{format}, $defaults->{format})
      if $detect;
  
    $self->regex(qr/^$regex/ps);
  }
  
  sub _compile_format {
    my ($format, $default) = @_;
  
    # Default regex
    return '/?(?:\.([^/]+))?$' unless defined $format;
  
    # No regex
    return '' unless $format;
  
    # Compile custom regex
    my $regex = '\.' . _compile_req($format);
    return $default ? "/?(?:$regex)?\$" : "/?$regex\$";
  }
  
  sub _compile_req {
    my $req = shift;
    return "($req)" if ref $req ne 'ARRAY';
    return '(' . join('|', map {quotemeta} reverse sort @$req) . ')';
  }
  
  sub _tokenize {
    my ($self, $pattern) = @_;
  
    # DEPRECATED!
    deprecated 'Placeholder quoting with "(placeholder)" is DEPRECATED'
      . ' in favor of "<placeholder>"'
      if $pattern =~ tr/()/<>/;
  
    my $quote_end   = $self->quote_end;
    my $quote_start = $self->quote_start;
    my $start       = $self->placeholder_start;
    my $relaxed     = $self->relaxed_start;
    my $wildcard    = $self->wildcard_start;
  
    my (@tree, $spec, $more);
    for my $char (split '', $pattern) {
  
      # Quoted
      if ($char eq $quote_start) { push @tree, ['placeholder', ''] if ++$spec }
      elsif ($char eq $quote_end) { $spec = $more = 0 }
  
      # Placeholder
      elsif (!$more && $char eq $start) {
        push @tree, ['placeholder', ''] unless $spec++;
      }
  
      # Relaxed or wildcard (upgrade when quoted)
      elsif (!$more && ($char eq $relaxed || $char eq $wildcard)) {
        push @tree, ['placeholder', ''] unless $spec++;
        $tree[-1][2] = $char eq $relaxed ? 'relaxed' : 'wildcard';
      }
  
      # Slash
      elsif ($char eq '/') {
        push @tree, ['slash'];
        $spec = $more = 0;
      }
  
      # Placeholder
      elsif ($spec && ++$more) { $tree[-1][1] .= $char }
  
      # Text (optimize slash+text and *+text+slash+text)
      elsif ($tree[-1][0] eq 'text') { $tree[-1][-1] .= $char }
      elsif (!$tree[-2] && $tree[-1][0] eq 'slash') {
        @tree = (['text', "/$char"]);
      }
      elsif ($tree[-2] && $tree[-2][0] eq 'text' && $tree[-1][0] eq 'slash') {
        pop @tree && ($tree[-1][-1] .= "/$char");
      }
      else { push @tree, ['text', $char] }
    }
  
    return $self->unparsed($pattern)->tree(\@tree);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Routes::Pattern - Route pattern
  
  =head1 SYNOPSIS
  
    use Mojolicious::Routes::Pattern;
  
    # Create pattern
    my $pattern = Mojolicious::Routes::Pattern->new('/test/:name');
  
    # Match routes
    my $captures = $pattern->match('/test/sebastian');
    say $captures->{name};
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Routes::Pattern> is the core of L<Mojolicious::Routes>.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Routes::Pattern> implements the following attributes.
  
  =head2 constraints
  
    my $constraints = $pattern->constraints;
    $pattern        = $pattern->constraints({foo => qr/\w+/});
  
  Regular expression constraints.
  
  =head2 defaults
  
    my $defaults = $pattern->defaults;
    $pattern     = $pattern->defaults({foo => 'bar'});
  
  Default parameters.
  
  =head2 placeholder_start
  
    my $start = $pattern->placeholder_start;
    $pattern  = $pattern->placeholder_start(':');
  
  Character indicating a placeholder, defaults to C<:>.
  
  =head2 placeholders
  
    my $placeholders = $pattern->placeholders;
    $pattern         = $pattern->placeholders(['foo', 'bar']);
  
  Placeholder names.
  
  =head2 quote_end
  
    my $end  = $pattern->quote_end;
    $pattern = $pattern->quote_end('}');
  
  Character indicating the end of a quoted placeholder, defaults to C<E<gt>>.
  
  =head2 quote_start
  
    my $start = $pattern->quote_start;
    $pattern  = $pattern->quote_start('{');
  
  Character indicating the start of a quoted placeholder, defaults to C<E<lt>>.
  
  =head2 regex
  
    my $regex = $pattern->regex;
    $pattern  = $pattern->regex($regex);
  
  Pattern in compiled regular expression form.
  
  =head2 relaxed_start
  
    my $start = $pattern->relaxed_start;
    $pattern  = $pattern->relaxed_start('*');
  
  Character indicating a relaxed placeholder, defaults to C<#>.
  
  =head2 tree
  
    my $tree = $pattern->tree;
    $pattern = $pattern->tree([['text', '/foo']]);
  
  Pattern in parsed form. Note that this structure should only be used very
  carefully since it is very dynamic.
  
  =head2 type_start
  
    my $start = $pattern->type_start;
    $pattern  = $pattern->type_start('|');
  
  Character indicating the start of a placeholder type, defaults to C<:>.
  
  =head2 types
  
    my $types = $pattern->types;
    $pattern  = $pattern->types({int => qr/[0-9]+/});
  
  Placeholder types.
  
  =head2 unparsed
  
    my $unparsed = $pattern->unparsed;
    $pattern     = $pattern->unparsed('/:foo/:bar');
  
  Raw unparsed pattern.
  
  =head2 wildcard_start
  
    my $start = $pattern->wildcard_start;
    $pattern  = $pattern->wildcard_start('*');
  
  Character indicating the start of a wildcard placeholder, defaults to C<*>.
  
  =head1 METHODS
  
  L<Mojolicious::Routes::Pattern> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 match
  
    my $captures = $pattern->match('/foo/bar');
    my $captures = $pattern->match('/foo/bar', 1);
  
  Match pattern against entire path, format detection is disabled by default.
  
  =head2 match_partial
  
    my $captures = $pattern->match_partial(\$path);
    my $captures = $pattern->match_partial(\$path, 1);
  
  Match pattern against path and remove matching parts, format detection is
  disabled by default.
  
  =head2 new
  
    my $pattern = Mojolicious::Routes::Pattern->new;
    my $pattern = Mojolicious::Routes::Pattern->new('/:action');
    my $pattern
      = Mojolicious::Routes::Pattern->new('/:action', action => qr/\w+/);
    my $pattern = Mojolicious::Routes::Pattern->new(format => 0);
  
  Construct a new L<Mojolicious::Routes::Pattern> object and L</"parse"> pattern
  if necessary.
  
  =head2 parse
  
    $pattern = $pattern->parse('/:action');
    $pattern = $pattern->parse('/:action', action => qr/\w+/);
    $pattern = $pattern->parse(format => 0);
  
  Parse pattern.
  
  =head2 render
  
    my $path = $pattern->render({action => 'foo'});
    my $path = $pattern->render({action => 'foo'}, 1);
  
  Render pattern into a path with parameters, format rendering is disabled by
  default.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_ROUTES_PATTERN

$fatpacked{"Mojolicious/Routes/Route.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_ROUTES_ROUTE';
  package Mojolicious::Routes::Route;
  use Mojo::Base -base;
  
  use Carp ();
  use Mojo::Util;
  use Mojolicious::Routes::Pattern;
  use Scalar::Util ();
  
  has [qw(inline parent partial)];
  has 'children' => sub { [] };
  has pattern    => sub { Mojolicious::Routes::Pattern->new };
  
  sub AUTOLOAD {
    my $self = shift;
  
    my ($package, $method) = our $AUTOLOAD =~ /^(.+)::(.+)$/;
    Carp::croak "Undefined subroutine &${package}::$method called"
      unless Scalar::Util::blessed $self && $self->isa(__PACKAGE__);
  
    # Call shortcut with current route
    Carp::croak qq{Can't locate object method "$method" via package "$package"}
      unless my $shortcut = $self->root->shortcuts->{$method};
    return $self->$shortcut(@_);
  }
  
  sub add_child {
    my ($self, $route) = @_;
    Scalar::Util::weaken $route->remove->parent($self)->{parent};
    push @{$self->children}, $route;
    $route->pattern->types($self->root->types);
    return $self;
  }
  
  sub any { shift->_generate_route(ref $_[0] eq 'ARRAY' ? shift : [], @_) }
  
  sub delete { shift->_generate_route(DELETE => @_) }
  
  sub detour { shift->partial(1)->to(@_) }
  
  sub find { shift->_index->{shift()} }
  
  sub get { shift->_generate_route(GET => @_) }
  
  sub has_custom_name { !!shift->{custom} }
  
  sub has_websocket {
    my $self = shift;
    return $self->{has_websocket} if exists $self->{has_websocket};
    return $self->{has_websocket} = grep { $_->is_websocket } @{$self->_chain};
  }
  
  sub is_endpoint { $_[0]->inline ? undef : !@{$_[0]->children} }
  
  sub is_websocket { !!shift->{websocket} }
  
  sub name {
    my $self = shift;
    return $self->{name} unless @_;
    @$self{qw(name custom)} = (shift, 1);
    return $self;
  }
  
  sub options { shift->_generate_route(OPTIONS => @_) }
  
  sub over {
    my $self = shift;
  
    # Routes with conditions can't be cached
    return $self->{over} unless @_;
    my $conditions = ref $_[0] eq 'ARRAY' ? $_[0] : [@_];
    return $self unless @$conditions;
    $self->{over} = $conditions;
    $self->root->cache->max_keys(0);
  
    return $self;
  }
  
  sub parse {
    my $self = shift;
    $self->{name} = $self->pattern->parse(@_)->unparsed // '';
    $self->{name} =~ s/\W+//g;
    return $self;
  }
  
  sub patch { shift->_generate_route(PATCH => @_) }
  sub post  { shift->_generate_route(POST  => @_) }
  sub put   { shift->_generate_route(PUT   => @_) }
  
  sub remove {
    my $self = shift;
    return $self unless my $parent = $self->parent;
    @{$parent->children} = grep { $_ ne $self } @{$parent->children};
    return $self->parent(undef);
  }
  
  sub render {
    my ($self, $values) = @_;
    my $path = join '',
      map { $_->pattern->render($values, !@{$_->children} && !$_->partial) }
      @{$self->_chain};
    return $path || '/';
  }
  
  sub root { shift->_chain->[0] }
  
  sub route {
    my $self   = shift;
    my $route  = $self->add_child(__PACKAGE__->new->parse(@_))->children->[-1];
    my $format = $self->pattern->constraints->{format};
    $route->pattern->constraints->{format} //= 0 if defined $format && !$format;
    return $route;
  }
  
  sub suggested_method {
    my $self = shift;
  
    my %via;
    for my $route (@{$self->_chain}) {
      next unless my @via = @{$route->via || []};
      %via = map { $_ => 1 } keys %via ? grep { $via{$_} } @via : @via;
    }
  
    return 'POST' if $via{POST} && !$via{GET};
    return $via{GET} ? 'GET' : (sort keys %via)[0] || 'GET';
  }
  
  sub to {
    my $self = shift;
  
    my $pattern = $self->pattern;
    return $pattern->defaults unless @_;
    my ($shortcut, %defaults) = Mojo::Util::_options(@_);
  
    if ($shortcut) {
  
      # Application
      if (ref $shortcut || $shortcut =~ /^[\w:]+$/) {
        $defaults{app} = $shortcut;
      }
  
      # Controller and action
      elsif ($shortcut =~ /^([\w\-:]+)?\#(\w+)?$/) {
        $defaults{controller} = $1 if defined $1;
        $defaults{action}     = $2 if defined $2;
      }
    }
  
    @{$pattern->defaults}{keys %defaults} = values %defaults;
  
    return $self;
  }
  
  sub to_string {
    join '', map { $_->pattern->unparsed // '' } @{shift->_chain};
  }
  
  sub under { shift->_generate_route(under => @_) }
  
  sub via {
    my $self = shift;
    return $self->{via} unless @_;
    my $methods = [map uc($_), @{ref $_[0] ? $_[0] : [@_]}];
    $self->{via} = $methods if @$methods;
    return $self;
  }
  
  sub websocket {
    my $route = shift->get(@_);
    $route->{websocket} = 1;
    return $route;
  }
  
  sub _chain {
    my @chain = (my $parent = shift);
    unshift @chain, $parent while $parent = $parent->parent;
    return \@chain;
  }
  
  sub _generate_route {
    my ($self, $methods, @args) = @_;
  
    my (@conditions, @constraints, %defaults, $name, $pattern);
    while (defined(my $arg = shift @args)) {
  
      # First scalar is the pattern
      if (!ref $arg && !$pattern) { $pattern = $arg }
  
      # Scalar
      elsif (!ref $arg && @args) { push @conditions, $arg, shift @args }
  
      # Last scalar is the route name
      elsif (!ref $arg) { $name = $arg }
  
      # Callback
      elsif (ref $arg eq 'CODE') { $defaults{cb} = $arg }
  
      # Constraints
      elsif (ref $arg eq 'ARRAY') { push @constraints, @$arg }
  
      # Defaults
      elsif (ref $arg eq 'HASH') { %defaults = (%defaults, %$arg) }
    }
  
    my $route
      = $self->route($pattern, @constraints)->over(\@conditions)->to(\%defaults);
    $methods eq 'under' ? $route->inline(1) : $route->via($methods);
  
    return defined $name ? $route->name($name) : $route;
  }
  
  sub _index {
    my $self = shift;
  
    my (%auto, %custom);
    my @children = (@{$self->children});
    while (my $child = shift @children) {
      if   ($child->has_custom_name) { $custom{$child->name} ||= $child }
      else                           { $auto{$child->name}   ||= $child }
      push @children, @{$child->children};
    }
  
    return {%auto, %custom};
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Routes::Route - Route
  
  =head1 SYNOPSIS
  
    use Mojolicious::Routes::Route;
  
    my $r = Mojolicious::Routes::Route->new;
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Routes::Route> is the route container used by
  L<Mojolicious::Routes>.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Routes::Route> implements the following attributes.
  
  =head2 children
  
    my $children = $r->children;
    $r           = $r->children([Mojolicious::Routes::Route->new]);
  
  The children of this route, used for nesting routes.
  
  =head2 inline
  
    my $bool = $r->inline;
    $r       = $r->inline($bool);
  
  Allow L</"under"> semantics for this route.
  
  =head2 parent
  
    my $parent = $r->parent;
    $r         = $r->parent(Mojolicious::Routes::Route->new);
  
  The parent of this route, usually a L<Mojolicious::Routes::Route> object.
  
  =head2 partial
  
    my $bool = $r->partial;
    $r       = $r->partial($bool);
  
  Route has no specific end, remaining characters will be captured in C<path>.
  
  =head2 pattern
  
    my $pattern = $r->pattern;
    $r          = $r->pattern(Mojolicious::Routes::Pattern->new);
  
  Pattern for this route, defaults to a L<Mojolicious::Routes::Pattern> object.
  
  =head1 METHODS
  
  L<Mojolicious::Routes::Route> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 add_child
  
    $r = $r->add_child(Mojolicious::Routes::Route->new);
  
  Add a child to this route, it will be automatically removed from its current
  parent if necessary.
  
    # Reattach route
    $r->add_child($r->find('foo'));
  
  =head2 any
  
    my $route = $r->any;
    my $route = $r->any('/:foo');
    my $route = $r->any('/:foo' => sub {...});
    my $route = $r->any('/:foo' => sub {...} => 'name');
    my $route = $r->any('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->any('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->any('/:foo' => (agent => qr/Firefox/) => sub {...});
    my $route = $r->any(['GET', 'POST'] => '/:foo' => sub {...});
    my $route = $r->any(['GET', 'POST'] => '/:foo' => [foo => qr/\w+/]);
  
  Generate L<Mojolicious::Routes::Route> object matching any of the listed HTTP
  request methods or all.
  
    # Route with pattern and destination
    $r->any('/user')->to('user#whatever');
  
  All arguments are optional, but some have to appear in a certain order, like the
  two supported array reference values, which contain the HTTP methods to match
  and restrictive placeholders.
  
    # Route with HTTP methods, pattern, restrictive placeholders and destination
    $r->any(['DELETE', 'PUT'] => '/:foo' => [foo => qr/\w+/])->to('foo#bar');
  
  There are also two supported string values, containing the route pattern and the
  route name, defaulting to the pattern C</> and a name based on the pattern.
  
    # Route with pattern, name and destination
    $r->any('/:foo' => 'foo_route')->to('foo#bar');
  
  An arbitrary number of key/value pairs in between the route pattern and name can
  be used to specify route conditions.
  
    # Route with pattern, condition and destination
    $r->any('/' => (agent => qr/Firefox/))->to('foo#bar');
  
  A hash reference is used to specify optional placeholders and default values for
  the stash.
  
    # Route with pattern, optional placeholder and destination
    $r->any('/:foo' => {foo => 'bar'})->to('foo#bar');
  
  And a code reference can be used to specify a C<cb> value to be merged into the
  default values for the stash.
  
    # Route with pattern and a closure as destination
    $r->any('/:foo' => sub {
      my $c = shift;
      $c->render(text => 'Hello World!');
    });
  
  See L<Mojolicious::Guides::Tutorial> and L<Mojolicious::Guides::Routing> for
  more information.
  
  =head2 delete
  
    my $route = $r->delete;
    my $route = $r->delete('/:foo');
    my $route = $r->delete('/:foo' => sub {...});
    my $route = $r->delete('/:foo' => sub {...} => 'name');
    my $route = $r->delete('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->delete('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->delete('/:foo' => (agent => qr/Firefox/) => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<DELETE> requests,
  takes the same arguments as L</"any"> (except for the HTTP methods to match,
  which are implied). See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
    # Route with destination
    $r->delete('/user')->to('user#remove');
  
  =head2 detour
  
    $r = $r->detour(action => 'foo');
    $r = $r->detour('controller#action');
    $r = $r->detour(Mojolicious->new, foo => 'bar');
    $r = $r->detour('MyApp', {foo => 'bar'});
  
  Set default parameters for this route and allow partial matching to simplify
  application embedding, takes the same arguments as L</"to">.
  
  =head2 find
  
    my $route = $r->find('foo');
  
  Find child route by name, custom names have precedence over automatically
  generated ones.
  
    # Change default parameters of a named route
    $r->find('show_user')->to(foo => 'bar');
  
  =head2 get
  
    my $route = $r->get;
    my $route = $r->get('/:foo');
    my $route = $r->get('/:foo' => sub {...});
    my $route = $r->get('/:foo' => sub {...} => 'name');
    my $route = $r->get('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->get('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->get('/:foo' => (agent => qr/Firefox/) => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<GET> requests,
  takes the same arguments as L</"any"> (except for the HTTP methods to match,
  which are implied). See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
    # Route with destination
    $r->get('/user')->to('user#show');
  
  =head2 has_custom_name
  
    my $bool = $r->has_custom_name;
  
  Check if this route has a custom name.
  
  =head2 has_websocket
  
    my $bool = $r->has_websocket;
  
  Check if this route has a WebSocket ancestor and cache the result for future
  checks.
  
  =head2 is_endpoint
  
    my $bool = $r->is_endpoint;
  
  Check if this route qualifies as an endpoint.
  
  =head2 is_websocket
  
    my $bool = $r->is_websocket;
  
  Check if this route is a WebSocket.
  
  =head2 name
  
    my $name = $r->name;
    $r       = $r->name('foo');
  
  The name of this route, defaults to an automatically generated name based on
  the route pattern. Note that the name C<current> is reserved for referring to
  the current route.
  
    # Route with destination and custom name
    $r->get('/user')->to('user#show')->name('show_user');
  
  =head2 options
  
    my $route = $r->options;
    my $route = $r->options('/:foo');
    my $route = $r->options('/:foo' => sub {...});
    my $route = $r->options('/:foo' => sub {...} => 'name');
    my $route = $r->options('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->options('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->options('/:foo' => (agent => qr/Firefox/) => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<OPTIONS>
  requests, takes the same arguments as L</"any"> (except for the HTTP methods to
  match, which are implied). See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
    # Route with destination
    $r->options('/user')->to('user#overview');
  
  =head2 over
  
    my $over = $r->over;
    $r       = $r->over(foo => 1);
    $r       = $r->over(foo => 1, bar => {baz => 'yada'});
    $r       = $r->over([foo => 1, bar => {baz => 'yada'}]);
  
  Activate conditions for this route. Note that this automatically disables the
  routing cache, since conditions are too complex for caching.
  
    # Route with condition and destination
    $r->get('/foo')->over(host => qr/mojolicious\.org/)->to('foo#bar');
  
  =head2 parse
  
    $r = $r->parse('/:action');
    $r = $r->parse('/:action', action => qr/\w+/);
    $r = $r->parse(format => 0);
  
  Parse pattern.
  
  =head2 patch
  
    my $route = $r->patch;
    my $route = $r->patch('/:foo');
    my $route = $r->patch('/:foo' => sub {...});
    my $route = $r->patch('/:foo' => sub {...} => 'name');
    my $route = $r->patch('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->patch('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->patch('/:foo' => (agent => qr/Firefox/) => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<PATCH> requests,
  takes the same arguments as L</"any"> (except for the HTTP methods to match,
  which are implied). See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
    # Route with destination
    $r->patch('/user')->to('user#update');
  
  =head2 post
  
    my $route = $r->post;
    my $route = $r->post('/:foo');
    my $route = $r->post('/:foo' => sub {...});
    my $route = $r->post('/:foo' => sub {...} => 'name');
    my $route = $r->post('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->post('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->post('/:foo' => (agent => qr/Firefox/) => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<POST> requests,
  takes the same arguments as L</"any"> (except for the HTTP methods to match,
  which are implied). See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
    # Route with destination
    $r->post('/user')->to('user#create');
  
  =head2 put
  
    my $route = $r->put;
    my $route = $r->put('/:foo');
    my $route = $r->put('/:foo' => sub {...});
    my $route = $r->put('/:foo' => sub {...} => 'name');
    my $route = $r->put('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->put('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->put('/:foo' => (agent => qr/Firefox/) => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only C<PUT> requests,
  takes the same arguments as L</"any"> (except for the HTTP methods to match,
  which are implied). See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
    # Route with destination
    $r->put('/user')->to('user#replace');
  
  =head2 remove
  
    $r = $r->remove;
  
  Remove route from parent.
  
    # Remove route completely
    $r->find('foo')->remove;
  
    # Reattach route to new parent
    $r->route('/foo')->add_child($r->find('bar')->remove);
  
  =head2 render
  
    my $path = $r->render({foo => 'bar'});
  
  Render route with parameters into a path.
  
  =head2 root
  
    my $root = $r->root;
  
  The L<Mojolicious::Routes> object this route is a descendant of.
  
  =head2 route
  
    my $route = $r->route;
    my $route = $r->route('/:action');
    my $route = $r->route('/:action', action => qr/\w+/);
    my $route = $r->route(format => 0);
  
  Low-level generator for routes matching all HTTP request methods, returns a
  L<Mojolicious::Routes::Route> object.
  
  =head2 suggested_method
  
    my $method = $r->suggested_method;
  
  Suggested HTTP method for reaching this route, C<GET> and C<POST> are
  preferred.
  
  =head2 to
  
    my $defaults = $r->to;
    $r           = $r->to(action => 'foo');
    $r           = $r->to({action => 'foo'});
    $r           = $r->to('controller#action');
    $r           = $r->to('controller#action', foo => 'bar');
    $r           = $r->to('controller#action', {foo => 'bar'});
    $r           = $r->to(Mojolicious->new);
    $r           = $r->to(Mojolicious->new, foo => 'bar');
    $r           = $r->to(Mojolicious->new, {foo => 'bar'});
    $r           = $r->to('MyApp');
    $r           = $r->to('MyApp', foo => 'bar');
    $r           = $r->to('MyApp', {foo => 'bar'});
  
  Set default parameters for this route.
  
  =head2 to_string
  
    my $str = $r->to_string;
  
  Stringify the whole route.
  
  =head2 under
  
    my $route = $r->under(sub {...});
    my $route = $r->under('/:foo' => sub {...});
    my $route = $r->under('/:foo' => {foo => 'bar'});
    my $route = $r->under('/:foo' => [foo => qr/\w+/]);
    my $route = $r->under('/:foo' => (agent => qr/Firefox/));
    my $route = $r->under([format => 0]);
  
  Generate L<Mojolicious::Routes::Route> object for a nested route with its own
  intermediate destination, takes the same arguments as L</"any"> (except for the
  HTTP methods to match, which are not available). See
  L<Mojolicious::Guides::Tutorial> and L<Mojolicious::Guides::Routing> for more
  information.
  
    # Intermediate destination and prefix shared between two routes
    my $auth = $r->under('/user')->to('user#auth');
    $auth->get('/show')->to('#show');
    $auth->post('/create')->to('#create');
  
  =head2 via
  
    my $methods = $r->via;
    $r          = $r->via('GET');
    $r          = $r->via('GET', 'POST');
    $r          = $r->via(['GET', 'POST']);
  
  Restrict HTTP methods this route is allowed to handle, defaults to no
  restrictions.
  
    # Route with two methods and destination
    $r->route('/foo')->via('GET', 'POST')->to('foo#bar');
  
  =head2 websocket
  
    my $route = $r->websocket;
    my $route = $r->websocket('/:foo');
    my $route = $r->websocket('/:foo' => sub {...});
    my $route = $r->websocket('/:foo' => sub {...} => 'name');
    my $route = $r->websocket('/:foo' => {foo => 'bar'} => sub {...});
    my $route = $r->websocket('/:foo' => [foo => qr/\w+/] => sub {...});
    my $route = $r->websocket('/:foo' => (agent => qr/Firefox/) => sub {...});
  
  Generate L<Mojolicious::Routes::Route> object matching only WebSocket
  handshakes, takes the same arguments as L</"any"> (except for the HTTP methods
  to match, which are implied). See L<Mojolicious::Guides::Tutorial> and
  L<Mojolicious::Guides::Routing> for more information.
  
    # Route with destination
    $r->websocket('/echo')->to('example#echo');
  
  =head1 AUTOLOAD
  
  In addition to the L</"ATTRIBUTES"> and L</"METHODS"> above you can also call
  shortcuts provided by L</"root"> on L<Mojolicious::Routes::Route> objects.
  
    # Add a "firefox" shortcut
    $r->root->add_shortcut(firefox => sub {
      my ($r, $path) = @_;
      $r->get($path, agent => qr/Firefox/);
    });
  
    # Use "firefox" shortcut to generate routes
    $r->firefox('/welcome')->to('firefox#welcome');
    $r->firefox('/bye')->to('firefox#bye');
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_ROUTES_ROUTE

$fatpacked{"Mojolicious/Sessions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_SESSIONS';
  package Mojolicious::Sessions;
  use Mojo::Base -base;
  
  use Mojo::JSON;
  use Mojo::Util qw(b64_decode b64_encode);
  
  has [qw(cookie_domain secure)];
  has cookie_name        => 'mojolicious';
  has cookie_path        => '/';
  has default_expiration => 3600;
  has deserialize        => sub { \&Mojo::JSON::j };
  has serialize          => sub { \&Mojo::JSON::encode_json };
  
  sub load {
    my ($self, $c) = @_;
  
    return unless my $value = $c->signed_cookie($self->cookie_name);
    $value =~ y/-/=/;
    return unless my $session = $self->deserialize->(b64_decode $value);
  
    # "expiration" value is inherited
    my $expiration = $session->{expiration} // $self->default_expiration;
    return if !(my $expires = delete $session->{expires}) && $expiration;
    return if defined $expires && $expires <= time;
  
    my $stash = $c->stash;
    return unless $stash->{'mojo.active_session'} = keys %$session;
    $stash->{'mojo.session'} = $session;
    $session->{flash} = delete $session->{new_flash} if $session->{new_flash};
  }
  
  sub store {
    my ($self, $c) = @_;
  
    # Make sure session was active
    my $stash = $c->stash;
    return unless my $session = $stash->{'mojo.session'};
    return unless keys %$session || $stash->{'mojo.active_session'};
  
    # Don't reset flash for static files
    my $old = delete $session->{flash};
    $session->{new_flash} = $old if $stash->{'mojo.static'};
    delete $session->{new_flash} unless keys %{$session->{new_flash}};
  
    # Generate "expires" value from "expiration" if necessary
    my $expiration = $session->{expiration} // $self->default_expiration;
    my $default    = delete $session->{expires};
    $session->{expires} = $default || time + $expiration
      if $expiration || $default;
  
    my $value = b64_encode $self->serialize->($session), '';
    $value =~ y/=/-/;
    my $options = {
      domain   => $self->cookie_domain,
      expires  => $session->{expires},
      httponly => 1,
      path     => $self->cookie_path,
      secure   => $self->secure
    };
    $c->signed_cookie($self->cookie_name, $value, $options);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Sessions - Session manager based on signed cookies
  
  =head1 SYNOPSIS
  
    use Mojolicious::Sessions;
  
    my $sessions = Mojolicious::Sessions->new;
    $sessions->cookie_name('myapp');
    $sessions->default_expiration(86400);
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Sessions> manages sessions based on signed cookies for
  L<Mojolicious>. All data gets serialized with L<Mojo::JSON> and stored Base64
  encoded on the client-side, but is protected from unwanted changes with a
  HMAC-SHA1 signature.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Sessions> implements the following attributes.
  
  =head2 cookie_domain
  
    my $domain = $sessions->cookie_domain;
    $sessions  = $sessions->cookie_domain('.example.com');
  
  Domain for session cookies, not defined by default.
  
  =head2 cookie_name
  
    my $name  = $sessions->cookie_name;
    $sessions = $sessions->cookie_name('session');
  
  Name for session cookies, defaults to C<mojolicious>.
  
  =head2 cookie_path
  
    my $path  = $sessions->cookie_path;
    $sessions = $sessions->cookie_path('/foo');
  
  Path for session cookies, defaults to C</>.
  
  =head2 default_expiration
  
    my $time  = $sessions->default_expiration;
    $sessions = $sessions->default_expiration(3600);
  
  Default time for sessions to expire in seconds from now, defaults to C<3600>.
  The expiration timeout gets refreshed for every request. Setting the value to
  C<0> will allow sessions to persist until the browser window is closed, this
  can have security implications though. For more control you can also use the
  C<expiration> and C<expires> session values.
  
    # Expiration date in seconds from now (persists between requests)
    $c->session(expiration => 604800);
  
    # Expiration date as absolute epoch time (only valid for one request)
    $c->session(expires => time + 604800);
  
    # Delete whole session by setting an expiration date in the past
    $c->session(expires => 1);
  
  =head2 deserialize
  
    my $cb    = $sessions->deserialize;
    $sessions = $sessions->deserialize(sub {...});
  
  A callback used to deserialize sessions, defaults to L<Mojo::JSON/"j">.
  
    $sessions->deserialize(sub {
      my $bytes = shift;
      return {};
    });
  
  =head2 secure
  
    my $bool  = $sessions->secure;
    $sessions = $sessions->secure($bool);
  
  Set the secure flag on all session cookies, so that browsers send them only
  over HTTPS connections.
  
  =head2 serialize
  
    my $cb    = $sessions->serialize;
    $sessions = $sessions->serialize(sub {...});
  
  A callback used to serialize sessions, defaults to L<Mojo::JSON/"encode_json">.
  
    $sessions->serialize(sub {
      my $hash = shift;
      return '';
    });
  
  =head1 METHODS
  
  L<Mojolicious::Sessions> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 load
  
    $sessions->load(Mojolicious::Controller->new);
  
  Load session data from signed cookie.
  
  =head2 store
  
    $sessions->store(Mojolicious::Controller->new);
  
  Store session data in signed cookie.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_SESSIONS

$fatpacked{"Mojolicious/Static.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_STATIC';
  package Mojolicious::Static;
  use Mojo::Base -base;
  
  use Mojo::Asset::File;
  use Mojo::Asset::Memory;
  use Mojo::Date;
  use Mojo::File 'path';
  use Mojo::Home;
  use Mojo::Loader qw(data_section file_is_binary);
  use Mojo::Util qw(encode md5_sum);
  
  # Bundled files
  my $PUBLIC = Mojo::Home->new(Mojo::Home->new->mojo_lib_dir)
    ->child('Mojolicious', 'resources', 'public');
  my %EXTRA = $PUBLIC->list_tree->map(
    sub { join('/', @{$_->to_rel($PUBLIC)}), $_->realpath->to_string })->each;
  
  has classes => sub { ['main'] };
  has extra   => sub { +{%EXTRA} };
  has paths   => sub { [] };
  
  sub dispatch {
    my ($self, $c) = @_;
  
    # Method (GET or HEAD)
    my $req    = $c->req;
    my $method = $req->method;
    return undef unless $method eq 'GET' || $method eq 'HEAD';
  
    # Canonical path
    my $stash = $c->stash;
    my $path  = $req->url->path;
    $path = $stash->{path} ? $path->new($stash->{path}) : $path->clone;
    return undef unless my @parts = @{$path->canonicalize->parts};
  
    # Serve static file and prevent path traversal
    my $canon_path = join '/', @parts;
    return undef if $canon_path =~ /^\.\.\/|\\/ || !$self->serve($c, $canon_path);
    $stash->{'mojo.static'} = 1;
    return !!$c->rendered;
  }
  
  sub file {
    my ($self, $rel) = @_;
  
    # Search all paths
    my @parts = split '/', $rel;
    for my $path (@{$self->paths}) {
      next unless my $asset = _get_file(path($path, @parts)->to_string);
      return $asset;
    }
  
    # Search DATA
    if (my $asset = $self->_get_data_file($rel)) { return $asset }
  
    # Search extra files
    my $extra = $self->extra;
    return exists $extra->{$rel} ? _get_file($extra->{$rel}) : undef;
  }
  
  sub is_fresh {
    my ($self, $c, $options) = @_;
  
    my $res_headers = $c->res->headers;
    my ($last, $etag) = @$options{qw(last_modified etag)};
    $res_headers->last_modified(Mojo::Date->new($last)->to_string) if $last;
    $res_headers->etag($etag = qq{"$etag"}) if $etag;
  
    # Unconditional
    my $req_headers = $c->req->headers;
    my $match       = $req_headers->if_none_match;
    return undef unless (my $since = $req_headers->if_modified_since) || $match;
  
    # If-None-Match
    return undef if $match && ($etag // $res_headers->etag // '') ne $match;
  
    # If-Modified-Since
    return !!$match unless ($last //= $res_headers->last_modified) && $since;
    return _epoch($last) <= (_epoch($since) // 0);
  }
  
  sub serve {
    my ($self, $c, $rel) = @_;
  
    return undef unless my $asset = $self->file($rel);
    my $headers = $c->res->headers;
    return !!$self->serve_asset($c, $asset) if $headers->content_type;
  
    # Content-Type
    my $types = $c->app->types;
    my $type = $rel =~ /\.(\w+)$/ ? $types->type($1) : undef;
    $headers->content_type($type || $types->type('txt'));
    return !!$self->serve_asset($c, $asset);
  }
  
  sub serve_asset {
    my ($self, $c, $asset) = @_;
  
    # Last-Modified and ETag
    my $res = $c->res;
    $res->code(200)->headers->accept_ranges('bytes');
    my $mtime = $asset->mtime;
    my $options = {etag => md5_sum($mtime), last_modified => $mtime};
    return $res->code(304) if $self->is_fresh($c, $options);
  
    # Range
    return $res->content->asset($asset)
      unless my $range = $c->req->headers->range;
  
    # Not satisfiable
    return $res->code(416) unless my $size = $asset->size;
    return $res->code(416) unless $range =~ /^bytes=(\d+)?-(\d+)?/;
    my ($start, $end) = ($1 // 0, defined $2 && $2 < $size ? $2 : $size - 1);
    return $res->code(416) if $start > $end;
  
    # Satisfiable
    $res->code(206)->headers->content_length($end - $start + 1)
      ->content_range("bytes $start-$end/$size");
    return $res->content->asset($asset->start_range($start)->end_range($end));
  }
  
  sub warmup {
    my $self = shift;
    my $index = $self->{index} = {};
    for my $class (reverse @{$self->classes}) {
      $index->{$_} = $class for keys %{data_section $class};
    }
  }
  
  sub _epoch { Mojo::Date->new(shift)->epoch }
  
  sub _get_data_file {
    my ($self, $rel) = @_;
  
    # Protect files without extensions and templates with two extensions
    return undef if $rel !~ /\.\w+$/ || $rel =~ /\.\w+\.\w+$/;
  
    $self->warmup unless $self->{index};
  
    # Find file
    my @args = ($self->{index}{$rel}, $rel);
    return undef unless defined(my $data = data_section(@args));
    return Mojo::Asset::Memory->new->add_chunk(
      file_is_binary(@args) ? $data : encode 'UTF-8', $data);
  }
  
  sub _get_file {
    my $path = shift;
    no warnings 'newline';
    return -f $path && -r _ ? Mojo::Asset::File->new(path => $path) : undef;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Static - Serve static files
  
  =head1 SYNOPSIS
  
    use Mojolicious::Static;
  
    my $static = Mojolicious::Static->new;
    push @{$static->classes}, 'MyApp::Controller::Foo';
    push @{$static->paths}, '/home/sri/public';
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Static> is a static file server with C<Range>,
  C<If-Modified-Since> and C<If-None-Match> support, based on
  L<RFC 7232|http://tools.ietf.org/html/rfc7232> and
  L<RFC 7233|http://tools.ietf.org/html/rfc7233>.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Static> implements the following attributes.
  
  =head2 classes
  
    my $classes = $static->classes;
    $static     = $static->classes(['main']);
  
  Classes to use for finding files in C<DATA> sections with L<Mojo::Loader>,
  first one has the highest precedence, defaults to C<main>. Only files with
  exactly one extension will be used, like C<index.html>. Note that for files to
  be detected, these classes need to have already been loaded and added before
  L</"warmup"> is called, which usually happens automatically during application
  startup.
  
    # Add another class with static files in DATA section
    push @{$static->classes}, 'Mojolicious::Plugin::Fun';
  
    # Add another class with static files in DATA section and higher precedence
    unshift @{$static->classes}, 'Mojolicious::Plugin::MoreFun';
  
  =head2 extra
  
    my $extra = $static->extra;
    $static   = $static->extra({'foo/bar.txt' => '/home/sri/myapp/bar.txt'});
  
  Paths for extra files to be served from locations other than L</"paths">, such
  as the images used by the built-in exception and not found pages. Note that
  extra files are only served if no better alternative could be found in
  L</"paths"> and L</"classes">.
  
    # Remove built-in favicon
    delete $static->extra->{'favicon.ico'};
  
  =head2 paths
  
    my $paths = $static->paths;
    $static   = $static->paths(['/home/sri/public']);
  
  Directories to serve static files from, first one has the highest precedence.
  
    # Add another "public" directory
    push @{$static->paths}, '/home/sri/public';
  
    # Add another "public" directory with higher precedence
    unshift @{$static->paths}, '/home/sri/themes/blue/public';
  
  =head1 METHODS
  
  L<Mojolicious::Static> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 dispatch
  
    my $bool = $static->dispatch(Mojolicious::Controller->new);
  
  Serve static file for L<Mojolicious::Controller> object.
  
  =head2 file
  
    my $asset = $static->file('images/logo.png');
    my $asset = $static->file('../lib/MyApp.pm');
  
  Build L<Mojo::Asset::File> or L<Mojo::Asset::Memory> object for a file,
  relative to L</"paths"> or from L</"classes">, or return C<undef> if it doesn't
  exist. Note that this method uses a relative path, but does not protect from
  traversing to parent directories.
  
    my $content = $static->file('foo/bar.html')->slurp;
  
  =head2 is_fresh
  
    my $bool = $static->is_fresh(Mojolicious::Controller->new, {etag => 'abc'});
  
  Check freshness of request by comparing the C<If-None-Match> and
  C<If-Modified-Since> request headers to the C<ETag> and C<Last-Modified>
  response headers.
  
  These options are currently available:
  
  =over 2
  
  =item etag
  
    etag => 'abc'
  
  Add C<ETag> header before comparing.
  
  =item last_modified
  
    last_modified => $epoch
  
  Add C<Last-Modified> header before comparing.
  
  =back
  
  =head2 serve
  
    my $bool = $static->serve(Mojolicious::Controller->new, 'images/logo.png');
    my $bool = $static->serve(Mojolicious::Controller->new, '../lib/MyApp.pm');
  
  Serve a specific file, relative to L</"paths"> or from L</"classes">. Note that
  this method uses a relative path, but does not protect from traversing to parent
  directories.
  
  =head2 serve_asset
  
    $static->serve_asset(Mojolicious::Controller->new, Mojo::Asset::File->new);
  
  Serve a L<Mojo::Asset::File> or L<Mojo::Asset::Memory> object with C<Range>,
  C<If-Modified-Since> and C<If-None-Match> support.
  
  =head2 warmup
  
    $static->warmup;
  
  Prepare static files from L</"classes"> for future use.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_STATIC

$fatpacked{"Mojolicious/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_TYPES';
  package Mojolicious::Types;
  use Mojo::Base -base;
  
  has mapping => sub {
    {
      appcache => ['text/cache-manifest'],
      atom     => ['application/atom+xml'],
      bin      => ['application/octet-stream'],
      css      => ['text/css'],
      gif      => ['image/gif'],
      gz       => ['application/x-gzip'],
      htm      => ['text/html'],
      html     => ['text/html;charset=UTF-8'],
      ico      => ['image/x-icon'],
      jpeg     => ['image/jpeg'],
      jpg      => ['image/jpeg'],
      js       => ['application/javascript'],
      json     => ['application/json;charset=UTF-8'],
      mp3      => ['audio/mpeg'],
      mp4      => ['video/mp4'],
      ogg      => ['audio/ogg'],
      ogv      => ['video/ogg'],
      pdf      => ['application/pdf'],
      png      => ['image/png'],
      rss      => ['application/rss+xml'],
      svg      => ['image/svg+xml'],
      txt      => ['text/plain;charset=UTF-8'],
      webm     => ['video/webm'],
      woff     => ['application/font-woff'],
      xml      => ['application/xml', 'text/xml'],
      zip      => ['application/zip']
    };
  };
  
  sub detect {
    my ($self, $accept) = @_;
  
    # Extract and prioritize MIME types
    my %types;
    /^\s*([^,; ]+)(?:\s*\;\s*q\s*=\s*(\d+(?:\.\d+)?))?\s*$/i
      and $types{lc $1} = $2 // 1
      for split ',', $accept // '';
    my @detected = sort { $types{$b} <=> $types{$a} } sort keys %types;
  
    # Detect extensions from MIME types
    my %reverse;
    my $mapping = $self->mapping;
    for my $ext (sort keys %$mapping) {
      my @types = @{$mapping->{$ext}};
      push @{$reverse{$_}}, $ext for map { s/\;.*$//; lc $_ } @types;
    }
  
    return [map { @{$reverse{$_} // []} } @detected];
  }
  
  sub type {
    my ($self, $ext, $type) = @_;
    return $self->mapping->{lc $ext}[0] unless $type;
    $self->mapping->{lc $ext} = ref $type ? $type : [$type];
    return $self;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Types - MIME types
  
  =head1 SYNOPSIS
  
    use Mojolicious::Types;
  
    my $types = Mojolicious::Types->new;
    $types->type(foo => 'text/foo');
    say $types->type('foo');
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Types> manages MIME types for L<Mojolicious>.
  
    appcache -> text/cache-manifest
    atom     -> application/atom+xml
    bin      -> application/octet-stream
    css      -> text/css
    gif      -> image/gif
    gz       -> application/x-gzip
    htm      -> text/html
    html     -> text/html;charset=UTF-8
    ico      -> image/x-icon
    jpeg     -> image/jpeg
    jpg      -> image/jpeg
    js       -> application/javascript
    json     -> application/json;charset=UTF-8
    mp3      -> audio/mpeg
    mp4      -> video/mp4
    ogg      -> audio/ogg
    ogv      -> video/ogg
    pdf      -> application/pdf
    png      -> image/png
    rss      -> application/rss+xml
    svg      -> image/svg+xml
    txt      -> text/plain;charset=UTF-8
    webm     -> video/webm
    woff     -> application/font-woff
    xml      -> application/xml,text/xml
    zip      -> application/zip
  
  The most common ones are already defined.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Types> implements the following attributes.
  
  =head2 mapping
  
    my $mapping = $types->mapping;
    $types      = $types->mapping({png => ['image/png']});
  
  MIME type mapping.
  
  =head1 METHODS
  
  L<Mojolicious::Types> inherits all methods from L<Mojo::Base> and implements
  the following new ones.
  
  =head2 detect
  
    my $exts = $types->detect('text/html, application/json;q=9');
  
  Detect file extensions from C<Accept> header value.
  
    # List detected extensions prioritized
    say for @{$types->detect('application/json, text/xml;q=0.1', 1)};
  
  =head2 type
  
    my $type = $types->type('png');
    $types   = $types->type(png => 'image/png');
    $types   = $types->type(json => ['application/json', 'text/x-json']);
  
  Get or set MIME types for file extension, alternatives are only used for
  detection.
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_TYPES

$fatpacked{"Mojolicious/Validator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_VALIDATOR';
  package Mojolicious::Validator;
  use Mojo::Base -base;
  
  use Mojo::Util 'trim';
  use Mojolicious::Validator::Validation;
  
  has checks => sub {
    {
      equal_to => \&_equal_to,
      in       => \&_in,
      like     => sub { $_[2] !~ $_[3] },
      num      => \&_num,
      size     => \&_size,
      upload   => sub { !ref $_[2] || !$_[2]->isa('Mojo::Upload') }
    };
  };
  has filters => sub { {trim => \&_trim} };
  
  sub add_check  { $_[0]->checks->{$_[1]}  = $_[2] and return $_[0] }
  sub add_filter { $_[0]->filters->{$_[1]} = $_[2] and return $_[0] }
  
  sub validation {
    Mojolicious::Validator::Validation->new(validator => shift);
  }
  
  sub _equal_to {
    my ($v, $name, $value, $to) = @_;
    return 1 unless defined(my $other = $v->input->{$to});
    return $value ne $other;
  }
  
  sub _in {
    my ($v, $name, $value) = (shift, shift, shift);
    $value eq $_ && return undef for @_;
    return 1;
  }
  
  sub _num {
    my ($v, $name, $value, $min, $max) = @_;
    return 1 if $value !~ /^[0-9]+$/;
    return defined $min && $min > $value || defined $max && $max < $value;
  }
  
  sub _size {
    my ($v, $name, $value, $min, $max) = @_;
    my $len = ref $value ? $value->size : length $value;
    return $len < $min || $len > $max;
  }
  
  sub _trim { trim $_[2] // '' }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Validator - Validate values
  
  =head1 SYNOPSIS
  
    use Mojolicious::Validator;
  
    my $validator = Mojolicious::Validator->new;
    my $v = $validator->validation;
    $v->input({foo => 'bar'});
    $v->required('foo')->like(qr/ar$/);
    say $v->param('foo');
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Validator> validates values for L<Mojolicious>.
  
  =head1 CHECKS
  
  These validation checks are available by default.
  
  =head2 equal_to
  
    $v = $v->equal_to('foo');
  
  String value needs to be equal to the value of another field.
  
  =head2 in
  
    $v = $v->in('foo', 'bar', 'baz');
  
  String value needs to match one of the values in the list.
  
  =head2 like
  
    $v = $v->like(qr/^[A-Z]/);
  
  String value needs to match the regular expression.
  
  =head2 num
  
    $v = $v->num;
    $v = $v->num(2, 5);
    $v = $v->num(2, undef);
    $v = $v->num(undef, 5);
  
  String value needs to be a non-fractional number and if provided in the given
  range.
  
  =head2 size
  
    $v = $v->size(2, 5);
  
  String value length or size of L<Mojo::Upload> object in bytes needs to be
  between these two values.
  
  =head2 upload
  
    $v = $v->upload;
  
  Value needs to be a L<Mojo::Upload> object, representing a file upload.
  
  =head1 FILTERS
  
  These filters are available by default.
  
  =head2 trim
  
    $v = $v->optional('foo', 'trim');
  
  Trim whitespace characters from both ends of string value with
  L<Mojo::Util/"trim">.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Validator> implements the following attributes.
  
  =head2 checks
  
    my $checks = $validator->checks;
    $validator = $validator->checks({size => sub {...}});
  
  Registered validation checks, by default only L</"equal_to">, L</"in">,
  L</"like">, L</"num">, L</"size"> and L</"upload"> are already defined.
  
  =head1 METHODS
  
  L<Mojolicious::Validator> inherits all methods from L<Mojo::Base> and
  implements the following new ones.
  
  =head2 add_check
  
    $validator = $validator->add_check(size => sub {...});
  
  Register a validation check.
  
    $validator->add_check(foo => sub {
      my ($v, $name, $value, @args) = @_;
      ...
      return undef;
    });
  
  =head2 add_filter
  
    $validator = $validator->add_filter(trim => sub {...});
  
  Register a new filter.
  
    $validator->add_filter(foo => sub {
      my ($v, $name, $value) = @_;
      ...
      return $value;
    });
  
  =head2 validation
  
    my $v = $validator->validation;
  
  Build L<Mojolicious::Validator::Validation> object to perform validations.
  
    my $v = $validator->validation;
    $v->input({foo => 'bar'});
    $v->required('foo')->size(1, 5);
    say $v->param('foo');
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_VALIDATOR

$fatpacked{"Mojolicious/Validator/Validation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_VALIDATOR_VALIDATION';
  package Mojolicious::Validator::Validation;
  use Mojo::Base -base;
  
  use Carp         ();
  use Scalar::Util ();
  
  has [qw(csrf_token topic validator)];
  has [qw(input output)] => sub { {} };
  
  sub AUTOLOAD {
    my $self = shift;
  
    my ($package, $method) = our $AUTOLOAD =~ /^(.+)::(.+)$/;
    Carp::croak "Undefined subroutine &${package}::$method called"
      unless Scalar::Util::blessed $self && $self->isa(__PACKAGE__);
  
    return $self->check($method => @_) if $self->validator->checks->{$method};
    Carp::croak qq{Can't locate object method "$method" via package "$package"};
  }
  
  sub check {
    my ($self, $check) = (shift, shift);
  
    return $self unless $self->is_valid;
  
    my $cb     = $self->validator->checks->{$check};
    my $name   = $self->topic;
    my $values = $self->output->{$name};
    for my $value (ref $values eq 'ARRAY' ? @$values : $values) {
      next unless my $result = $self->$cb($name, $value, @_);
      return $self->error($name => [$check, $result, @_]);
    }
  
    return $self;
  }
  
  sub csrf_protect {
    my $self  = shift;
    my $token = $self->input->{csrf_token};
    $self->error(csrf_token => ['csrf_protect'])
      unless $token && $token eq ($self->csrf_token // '');
    return $self;
  }
  
  sub error {
    my ($self, $name) = (shift, shift);
    return $self->{error}{$name} unless @_;
    $self->{error}{$name} = shift;
    delete $self->output->{$name};
    return $self;
  }
  
  sub every_param {
    return [] unless defined(my $value = $_[0]->output->{$_[1] // $_[0]->topic});
    return [ref $value eq 'ARRAY' ? @$value : $value];
  }
  
  sub failed { [sort keys %{shift->{error}}] }
  
  sub has_data { !!keys %{shift->input} }
  
  sub has_error { $_[1] ? exists $_[0]{error}{$_[1]} : !!keys %{$_[0]{error}} }
  
  sub is_valid { exists $_[0]->output->{$_[1] // $_[0]->topic} }
  
  sub optional {
    my ($self, $name, @filters) = @_;
  
    return $self->topic($name) unless defined(my $input = $self->input->{$name});
  
    my @input = ref $input eq 'ARRAY' ? @$input : ($input);
    for my $cb (map { $self->validator->filters->{$_} } @filters) {
      @input = map { $self->$cb($name, $_) } @input;
    }
    $self->output->{$name} = ref $input eq 'ARRAY' ? \@input : $input[0]
      if @input && !grep { !length } @input;
  
    return $self->topic($name);
  }
  
  sub param { shift->every_param(shift)->[-1] }
  
  sub passed { [sort keys %{shift->output}] }
  
  sub required {
    my ($self, $name) = (shift, shift);
    return $self if $self->optional($name, @_)->is_valid;
    return $self->error($name => ['required']);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Mojolicious::Validator::Validation - Perform validations
  
  =head1 SYNOPSIS
  
    use Mojolicious::Validator;
    use Mojolicious::Validator::Validation;
  
    my $validator = Mojolicious::Validator->new;
    my $v = Mojolicious::Validator::Validation->new(validator => $validator);
    $v->input({foo => 'bar'});
    $v->required('foo')->in('bar', 'baz');
    say $v->param('foo');
  
  =head1 DESCRIPTION
  
  L<Mojolicious::Validator::Validation> performs L<Mojolicious::Validator>
  validation checks.
  
  =head1 ATTRIBUTES
  
  L<Mojolicious::Validator::Validation> implements the following attributes.
  
  =head2 csrf_token
  
    my $token = $v->csrf_token;
    $v        = $v->csrf_token('fa6a08...');
  
  CSRF token.
  
  =head2 input
  
    my $input = $v->input;
    $v        = $v->input({foo => 'bar', baz => [123, 'yada']});
  
  Data to be validated.
  
  =head2 output
  
    my $output = $v->output;
    $v         = $v->output({foo => 'bar', baz => [123, 'yada']});
  
  Validated data.
  
  =head2 topic
  
    my $topic = $v->topic;
    $v        = $v->topic('foo');
  
  Name of field currently being validated.
  
  =head2 validator
  
    my $v = $v->validator;
    $v    = $v->validator(Mojolicious::Validator->new);
  
  L<Mojolicious::Validator> object this validation belongs to.
  
  =head1 METHODS
  
  L<Mojolicious::Validator::Validation> inherits all methods from L<Mojo::Base>
  and implements the following new ones.
  
  =head2 check
  
    $v = $v->check('size', 2, 7);
  
  Perform validation check on all values of the current L</"topic">, no more
  checks will be performed on them after the first one failed. All checks from
  L<Mojolicious::Validator/"CHECKS"> are supported.
  
  =head2 csrf_protect
  
    $v = $v->csrf_protect;
  
  Validate C<csrf_token> and protect from cross-site request forgery.
  
  =head2 error
  
    my $err = $v->error('foo');
    $v      = $v->error(foo => ['custom_check']);
    $v      = $v->error(foo => [$check, $result, @args]);
  
  Get or set details for failed validation check, at any given time there can
  only be one per field.
  
    # Details about failed validation
    my ($check, $result, @args) = @{$v->error('foo')};
  
    # Force validation to fail for a field without performing a check
    $v->error(foo => ['some_made_up_check_name']);
  
  =head2 every_param
  
    my $values = $v->every_param;
    my $values = $v->every_param('foo');
  
  Similar to L</"param">, but returns all values sharing the same name as an
  array reference.
  
    # Get first value
    my $first = $v->every_param('foo')->[0];
  
  =head2 failed
  
    my $names = $v->failed;
  
  Return an array reference with all names for values that failed validation.
  
    # Names of all values that failed
    say for @{$v->failed};
  
  =head2 has_data
  
    my $bool = $v->has_data;
  
  Check if L</"input"> is available for validation.
  
  =head2 has_error
  
    my $bool = $v->has_error;
    my $bool = $v->has_error('foo');
  
  Check if validation resulted in errors, defaults to checking all fields.
  
  =head2 is_valid
  
    my $bool = $v->is_valid;
    my $bool = $v->is_valid('foo');
  
  Check if validation was successful and field has a value, defaults to checking
  the current L</"topic">.
  
  =head2 optional
  
    $v = $v->optional('foo');
    $v = $v->optional('foo', 'filter1', 'filter2');
  
  Change validation L</"topic"> and apply filters. All filters from
  L<Mojolicious::Validator/"FILTERS"> are supported.
  
    # Trim value and check size
    $v->optional('user', 'trim')->size(1, 15);
  
  =head2 param
  
    my $value = $v->param;
    my $value = $v->param('foo');
  
  Access validated values, defaults to the current L</"topic">. If there are
  multiple values sharing the same name, and you want to access more than just the
  last one, you can use L</"every_param">.
  
    # Get value right away
    my $user = $v->optional('user')->size(1, 15)->param;
  
  =head2 passed
  
    my $names = $v->passed;
  
  Return an array reference with all names for values that passed validation.
  
    # Names of all values that passed
    say for @{$v->passed};
  
  =head2 required
  
    $v = $v->required('foo');
    $v = $v->required('foo', 'filter1', 'filter2');
  
  Change validation L</"topic">, apply filters, and make sure a value is present
  and not an empty string. All filters from L<Mojolicious::Validator/"FILTERS">
  are supported.
  
    # Trim value and check size
    $v->required('user', 'trim')->size(1, 15);
  
  =head1 AUTOLOAD
  
  In addition to the L</"ATTRIBUTES"> and L</"METHODS"> above, you can also call
  validation checks provided by L</"validator"> on
  L<Mojolicious::Validator::Validation> objects, similar to L</"check">.
  
    # Call validation checks
    $v->required('foo')->size(2, 5)->like(qr/^[A-Z]/);
    $v->optional('bar')->equal_to('foo');
    $v->optional('baz')->in('test', '123');
  
    # Longer version
    $v->required('foo')->check('size', 2, 5)->check('like', qr/^[A-Z]/);
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
MOJOLICIOUS_VALIDATOR_VALIDATION

$fatpacked{"Role/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY';
  package Role::Tiny;
  
  sub _getglob { \*{$_[0]} }
  sub _getstash { \%{"$_[0]::"} }
  
  use strict;
  use warnings;
  
  our $VERSION = '2.000006';
  $VERSION =~ tr/_//d;
  
  our %INFO;
  our %APPLIED_TO;
  our %COMPOSED;
  our %COMPOSITE_INFO;
  our @ON_ROLE_CREATE;
  
  # Module state workaround totally stolen from Zefram's Module::Runtime.
  
  BEGIN {
    *_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
    *_WORK_AROUND_HINT_LEAKAGE
      = "$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
        ? sub(){1} : sub(){0};
    *_MRO_MODULE = "$]" < 5.010 ? sub(){"MRO/Compat.pm"} : sub(){"mro.pm"};
  }
  
  sub croak {
    require Carp;
    no warnings 'redefine';
    *croak = \&Carp::croak;
    goto &Carp::croak;
  }
  
  sub Role::Tiny::__GUARD__::DESTROY {
    delete $INC{$_[0]->[0]} if @{$_[0]};
  }
  
  sub _load_module {
    my ($module) = @_;
    (my $file = "$module.pm") =~ s{::}{/}g;
    return 1
      if $INC{$file};
  
    # can't just ->can('can') because a sub-package Foo::Bar::Baz
    # creates a 'Baz::' key in Foo::Bar's symbol table
    return 1
      if grep !/::\z/, keys %{_getstash($module)};
    my $guard = _WORK_AROUND_BROKEN_MODULE_STATE
      && bless([ $file ], 'Role::Tiny::__GUARD__');
    local %^H if _WORK_AROUND_HINT_LEAKAGE;
    require $file;
    pop @$guard if _WORK_AROUND_BROKEN_MODULE_STATE;
    return 1;
  }
  
  sub import {
    my $target = caller;
    my $me = shift;
    strict->import;
    warnings->import;
    $me->_install_subs($target);
    return if $me->is_role($target); # already exported into this package
    $INFO{$target}{is_role} = 1;
    # get symbol table reference
    my $stash = _getstash($target);
    # grab all *non-constant* (stash slot is not a scalarref) subs present
    # in the symbol table and store their refaddrs (no need to forcibly
    # inflate constant subs into real subs) with a map to the coderefs in
    # case of copying or re-use
    my @not_methods = map +(ref $_ eq 'CODE' ? $_ : ref $_ ? () : *$_{CODE}||()), values %$stash;
    @{$INFO{$target}{not_methods}={}}{@not_methods} = @not_methods;
    # a role does itself
    $APPLIED_TO{$target} = { $target => undef };
    foreach my $hook (@ON_ROLE_CREATE) {
      $hook->($target);
    }
  }
  
  sub _install_subs {
    my ($me, $target) = @_;
    return if $me->is_role($target);
    # install before/after/around subs
    foreach my $type (qw(before after around)) {
      *{_getglob "${target}::${type}"} = sub {
        push @{$INFO{$target}{modifiers}||=[]}, [ $type => @_ ];
        return;
      };
    }
    *{_getglob "${target}::requires"} = sub {
      push @{$INFO{$target}{requires}||=[]}, @_;
      return;
    };
    *{_getglob "${target}::with"} = sub {
      $me->apply_roles_to_package($target, @_);
      return;
    };
  }
  
  sub role_application_steps {
    qw(_install_methods _check_requires _install_modifiers _copy_applied_list);
  }
  
  sub apply_single_role_to_package {
    my ($me, $to, $role) = @_;
  
    _load_module($role);
  
    croak "This is apply_role_to_package" if ref($to);
    croak "${role} is not a Role::Tiny" unless $me->is_role($role);
  
    foreach my $step ($me->role_application_steps) {
      $me->$step($to, $role);
    }
  }
  
  sub _copy_applied_list {
    my ($me, $to, $role) = @_;
    # copy our role list into the target's
    @{$APPLIED_TO{$to}||={}}{keys %{$APPLIED_TO{$role}}} = ();
  }
  
  sub apply_roles_to_object {
    my ($me, $object, @roles) = @_;
    croak "No roles supplied!" unless @roles;
    my $class = ref($object);
    # on perl < 5.8.9, magic isn't copied to all ref copies. bless the parameter
    # directly, so at least the variable passed to us will get any magic applied
    bless($_[1], $me->create_class_with_roles($class, @roles));
  }
  
  my $role_suffix = 'A000';
  sub _composite_name {
    my ($me, $superclass, @roles) = @_;
  
    my $new_name = join(
      '__WITH__', $superclass, my $compose_name = join '__AND__', @roles
    );
  
    if (length($new_name) > 252) {
      $new_name = $COMPOSED{abbrev}{$new_name} ||= do {
        my $abbrev = substr $new_name, 0, 250 - length $role_suffix;
        $abbrev =~ s/(?<!:):$//;
        $abbrev.'__'.$role_suffix++;
      };
    }
    return wantarray ? ($new_name, $compose_name) : $new_name;
  }
  
  sub create_class_with_roles {
    my ($me, $superclass, @roles) = @_;
  
    croak "No roles supplied!" unless @roles;
  
    _load_module($superclass);
    {
      my %seen;
      if (my @dupes = grep 1 == $seen{$_}++, @roles) {
        croak "Duplicated roles: ".join(', ', @dupes);
      }
    }
  
    my ($new_name, $compose_name) = $me->_composite_name($superclass, @roles);
  
    return $new_name if $COMPOSED{class}{$new_name};
  
    foreach my $role (@roles) {
      _load_module($role);
      croak "${role} is not a Role::Tiny" unless $me->is_role($role);
    }
  
    require(_MRO_MODULE);
  
    my $composite_info = $me->_composite_info_for(@roles);
    my %conflicts = %{$composite_info->{conflicts}};
    if (keys %conflicts) {
      my $fail =
        join "\n",
          map {
            "Method name conflict for '$_' between roles "
            ."'".join("' and '", sort values %{$conflicts{$_}})."'"
            .", cannot apply these simultaneously to an object."
          } keys %conflicts;
      croak $fail;
    }
  
    my @composable = map $me->_composable_package_for($_), reverse @roles;
  
    # some methods may not exist in the role, but get generated by
    # _composable_package_for (Moose accessors via Moo).  filter out anything
    # provided by the composable packages, excluding the subs we generated to
    # make modifiers work.
    my @requires = grep {
      my $method = $_;
      !grep $_->can($method) && !$COMPOSED{role}{$_}{modifiers_only}{$method},
        @composable
    } @{$composite_info->{requires}};
  
    $me->_check_requires(
      $superclass, $compose_name, \@requires
    );
  
    *{_getglob("${new_name}::ISA")} = [ @composable, $superclass ];
  
    @{$APPLIED_TO{$new_name}||={}}{
      map keys %{$APPLIED_TO{$_}}, @roles
    } = ();
  
    $COMPOSED{class}{$new_name} = 1;
    return $new_name;
  }
  
  # preserved for compat, and apply_roles_to_package calls it to allow an
  # updated Role::Tiny to use a non-updated Moo::Role
  
  sub apply_role_to_package { shift->apply_single_role_to_package(@_) }
  
  sub apply_roles_to_package {
    my ($me, $to, @roles) = @_;
  
    return $me->apply_role_to_package($to, $roles[0]) if @roles == 1;
  
    my %conflicts = %{$me->_composite_info_for(@roles)->{conflicts}};
    my @have = grep $to->can($_), keys %conflicts;
    delete @conflicts{@have};
  
    if (keys %conflicts) {
      my $fail =
        join "\n",
          map {
            "Due to a method name conflict between roles "
            ."'".join(' and ', sort values %{$conflicts{$_}})."'"
            .", the method '$_' must be implemented by '${to}'"
          } keys %conflicts;
      croak $fail;
    }
  
    # conflicting methods are supposed to be treated as required by the
    # composed role. we don't have an actual composed role, but because
    # we know the target class already provides them, we can instead
    # pretend that the roles don't do for the duration of application.
    my @role_methods = map $me->_concrete_methods_of($_), @roles;
    # separate loops, since local ..., delete ... for ...; creates a scope
    local @{$_}{@have} for @role_methods;
    delete @{$_}{@have} for @role_methods;
  
    # the if guard here is essential since otherwise we accidentally create
    # a $INFO for something that isn't a Role::Tiny (or Moo::Role) because
    # autovivification hates us and wants us to die()
    if ($INFO{$to}) {
      delete $INFO{$to}{methods}; # reset since we're about to add methods
    }
  
    # backcompat: allow subclasses to use apply_single_role_to_package
    # to apply changes.  set a local var so ours does nothing.
    our %BACKCOMPAT_HACK;
    if($me ne __PACKAGE__
        and exists $BACKCOMPAT_HACK{$me} ? $BACKCOMPAT_HACK{$me} :
        $BACKCOMPAT_HACK{$me} =
          $me->can('role_application_steps')
            == \&role_application_steps
          && $me->can('apply_single_role_to_package')
            != \&apply_single_role_to_package
    ) {
      foreach my $role (@roles) {
        $me->apply_single_role_to_package($to, $role);
      }
    }
    else {
      foreach my $step ($me->role_application_steps) {
        foreach my $role (@roles) {
          $me->$step($to, $role);
        }
      }
    }
    $APPLIED_TO{$to}{join('|',@roles)} = 1;
  }
  
  sub _composite_info_for {
    my ($me, @roles) = @_;
    $COMPOSITE_INFO{join('|', sort @roles)} ||= do {
      foreach my $role (@roles) {
        _load_module($role);
      }
      my %methods;
      foreach my $role (@roles) {
        my $this_methods = $me->_concrete_methods_of($role);
        $methods{$_}{$this_methods->{$_}} = $role for keys %$this_methods;
      }
      my %requires;
      @requires{map @{$INFO{$_}{requires}||[]}, @roles} = ();
      delete $requires{$_} for keys %methods;
      delete $methods{$_} for grep keys(%{$methods{$_}}) == 1, keys %methods;
      +{ conflicts => \%methods, requires => [keys %requires] }
    };
  }
  
  sub _composable_package_for {
    my ($me, $role) = @_;
    my $composed_name = 'Role::Tiny::_COMPOSABLE::'.$role;
    return $composed_name if $COMPOSED{role}{$composed_name};
    $me->_install_methods($composed_name, $role);
    my $base_name = $composed_name.'::_BASE';
    # force stash to exist so ->can doesn't complain
    _getstash($base_name);
    # Not using _getglob, since setting @ISA via the typeglob breaks
    # inheritance on 5.10.0 if the stash has previously been accessed an
    # then a method called on the class (in that order!), which
    # ->_install_methods (with the help of ->_install_does) ends up doing.
    { no strict 'refs'; @{"${composed_name}::ISA"} = ( $base_name ); }
    my $modifiers = $INFO{$role}{modifiers}||[];
    my @mod_base;
    my @modifiers = grep !$composed_name->can($_),
      do { my %h; @h{map @{$_}[1..$#$_-1], @$modifiers} = (); keys %h };
    foreach my $modified (@modifiers) {
      push @mod_base, "sub ${modified} { shift->next::method(\@_) }";
    }
    my $e;
    {
      local $@;
      eval(my $code = join "\n", "package ${base_name};", @mod_base);
      $e = "Evaling failed: $@\nTrying to eval:\n${code}" if $@;
    }
    die $e if $e;
    $me->_install_modifiers($composed_name, $role);
    $COMPOSED{role}{$composed_name} = {
      modifiers_only => { map { $_ => 1 } @modifiers },
    };
    return $composed_name;
  }
  
  sub _check_requires {
    my ($me, $to, $name, $requires) = @_;
    return unless my @requires = @{$requires||$INFO{$name}{requires}||[]};
    if (my @requires_fail = grep !$to->can($_), @requires) {
      # role -> role, add to requires, role -> class, error out
      if (my $to_info = $INFO{$to}) {
        push @{$to_info->{requires}||=[]}, @requires_fail;
      } else {
        croak "Can't apply ${name} to ${to} - missing ".join(', ', @requires_fail);
      }
    }
  }
  
  sub _concrete_methods_of {
    my ($me, $role) = @_;
    my $info = $INFO{$role};
    # grab role symbol table
    my $stash = _getstash($role);
    # reverse so our keys become the values (captured coderefs) in case
    # they got copied or re-used since
    my $not_methods = { reverse %{$info->{not_methods}||{}} };
    $info->{methods} ||= +{
      # grab all code entries that aren't in the not_methods list
      map {;
        no strict 'refs';
        my $code = exists &{"${role}::$_"} ? \&{"${role}::$_"} : undef;
        ( ! $code or exists $not_methods->{$code} ) ? () : ($_ => $code)
      } grep +(!ref($stash->{$_}) || ref($stash->{$_}) eq 'CODE'), keys %$stash
    };
  }
  
  sub methods_provided_by {
    my ($me, $role) = @_;
    croak "${role} is not a Role::Tiny" unless $me->is_role($role);
    (keys %{$me->_concrete_methods_of($role)}, @{$INFO{$role}->{requires}||[]});
  }
  
  sub _install_methods {
    my ($me, $to, $role) = @_;
  
    my $info = $INFO{$role};
  
    my $methods = $me->_concrete_methods_of($role);
  
    # grab target symbol table
    my $stash = _getstash($to);
  
    # determine already extant methods of target
    my %has_methods;
    @has_methods{grep
      +(ref($stash->{$_}) || *{$stash->{$_}}{CODE}),
      keys %$stash
    } = ();
  
    foreach my $i (grep !exists $has_methods{$_}, keys %$methods) {
      no warnings 'once';
      my $glob = _getglob "${to}::${i}";
      *$glob = $methods->{$i};
  
      # overloads using method names have the method stored in the scalar slot
      # and &overload::nil in the code slot.
      next
        unless $i =~ /^\(/
          && ((defined &overload::nil && $methods->{$i} == \&overload::nil)
              || (defined &overload::_nil && $methods->{$i} == \&overload::_nil));
  
      my $overload = ${ *{_getglob "${role}::${i}"}{SCALAR} };
      next
        unless defined $overload;
  
      *$glob = \$overload;
    }
  
    $me->_install_does($to);
  }
  
  sub _install_modifiers {
    my ($me, $to, $name) = @_;
    return unless my $modifiers = $INFO{$name}{modifiers};
    my $info = $INFO{$to};
    my $existing = ($info ? $info->{modifiers} : $COMPOSED{modifiers}{$to}) ||= [];
    my @modifiers = grep {
      my $modifier = $_;
      !grep $_ == $modifier, @$existing;
    } @{$modifiers||[]};
    push @$existing, @modifiers;
  
    if (!$info) {
      foreach my $modifier (@modifiers) {
        $me->_install_single_modifier($to, @$modifier);
      }
    }
  }
  
  my $vcheck_error;
  
  sub _install_single_modifier {
    my ($me, @args) = @_;
    defined($vcheck_error) or $vcheck_error = do {
      local $@;
      eval {
        require Class::Method::Modifiers;
        Class::Method::Modifiers->VERSION(1.05);
        1;
      } ? 0 : $@;
    };
    $vcheck_error and die $vcheck_error;
    Class::Method::Modifiers::install_modifier(@args);
  }
  
  my $FALLBACK = sub { 0 };
  sub _install_does {
    my ($me, $to) = @_;
  
    # only add does() method to classes
    return if $me->is_role($to);
  
    my $does = $me->can('does_role');
    # add does() only if they don't have one
    *{_getglob "${to}::does"} = $does unless $to->can('does');
  
    return
      if $to->can('DOES') and $to->can('DOES') != (UNIVERSAL->can('DOES') || 0);
  
    my $existing = $to->can('DOES') || $to->can('isa') || $FALLBACK;
    my $new_sub = sub {
      my ($proto, $role) = @_;
      $proto->$does($role) or $proto->$existing($role);
    };
    no warnings 'redefine';
    return *{_getglob "${to}::DOES"} = $new_sub;
  }
  
  sub does_role {
    my ($proto, $role) = @_;
    require(_MRO_MODULE);
    foreach my $class (@{mro::get_linear_isa(ref($proto)||$proto)}) {
      return 1 if exists $APPLIED_TO{$class}{$role};
    }
    return 0;
  }
  
  sub is_role {
    my ($me, $role) = @_;
    return !!($INFO{$role} && ($INFO{$role}{is_role} || $INFO{$role}{not_methods}));
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Role::Tiny - Roles. Like a nouvelle cuisine portion size slice of Moose.
  
  =head1 SYNOPSIS
  
   package Some::Role;
  
   use Role::Tiny;
  
   sub foo { ... }
  
   sub bar { ... }
  
   around baz => sub { ... };
  
   1;
  
  elsewhere
  
   package Some::Class;
  
   use Role::Tiny::With;
  
   # bar gets imported, but not foo
   with 'Some::Role';
  
   sub foo { ... }
  
   # baz is wrapped in the around modifier by Class::Method::Modifiers
   sub baz { ... }
  
   1;
  
  If you wanted attributes as well, look at L<Moo::Role>.
  
  =head1 DESCRIPTION
  
  C<Role::Tiny> is a minimalist role composition tool.
  
  =head1 ROLE COMPOSITION
  
  Role composition can be thought of as much more clever and meaningful multiple
  inheritance.  The basics of this implementation of roles is:
  
  =over 2
  
  =item *
  
  If a method is already defined on a class, that method will not be composed in
  from the role. A method inherited by a class gets overridden by the role's
  method of the same name, though.
  
  =item *
  
  If a method that the role L</requires> to be implemented is not implemented,
  role application will fail loudly.
  
  =back
  
  Unlike L<Class::C3>, where the B<last> class inherited from "wins," role
  composition is the other way around, where the class wins. If multiple roles
  are applied in a single call (single with statement), then if any of their
  provided methods clash, an exception is raised unless the class provides
  a method since this conflict indicates a potential problem.
  
  =head1 IMPORTED SUBROUTINES
  
  =head2 requires
  
   requires qw(foo bar);
  
  Declares a list of methods that must be defined to compose role.
  
  =head2 with
  
   with 'Some::Role1';
  
   with 'Some::Role1', 'Some::Role2';
  
  Composes another role into the current role (or class via L<Role::Tiny::With>).
  
  If you have conflicts and want to resolve them in favour of Some::Role1 you
  can instead write:
  
   with 'Some::Role1';
   with 'Some::Role2';
  
  If you have conflicts and want to resolve different conflicts in favour of
  different roles, please refactor your codebase.
  
  =head2 before
  
   before foo => sub { ... };
  
  See L<< Class::Method::Modifiers/before method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head2 around
  
   around foo => sub { ... };
  
  See L<< Class::Method::Modifiers/around method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head2 after
  
   after foo => sub { ... };
  
  See L<< Class::Method::Modifiers/after method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head2 Strict and Warnings
  
  In addition to importing subroutines, using C<Role::Tiny> applies L<strict> and
  L<warnings> to the caller.
  
  =head1 SUBROUTINES
  
  =head2 does_role
  
   if (Role::Tiny::does_role($foo, 'Some::Role')) {
     ...
   }
  
  Returns true if class has been composed with role.
  
  This subroutine is also installed as ->does on any class a Role::Tiny is
  composed into unless that class already has an ->does method, so
  
    if ($foo->does('Some::Role')) {
      ...
    }
  
  will work for classes but to test a role, one must use ::does_role directly.
  
  Additionally, Role::Tiny will override the standard Perl C<DOES> method
  for your class. However, if C<any> class in your class' inheritance
  hierarchy provides C<DOES>, then Role::Tiny will not override it.
  
  =head1 METHODS
  
  =head2 apply_roles_to_package
  
   Role::Tiny->apply_roles_to_package(
     'Some::Package', 'Some::Role', 'Some::Other::Role'
   );
  
  Composes role with package.  See also L<Role::Tiny::With>.
  
  =head2 apply_roles_to_object
  
   Role::Tiny->apply_roles_to_object($foo, qw(Some::Role1 Some::Role2));
  
  Composes roles in order into object directly. Object is reblessed into the
  resulting class. Note that the object's methods get overridden by the role's
  ones with the same names.
  
  =head2 create_class_with_roles
  
   Role::Tiny->create_class_with_roles('Some::Base', qw(Some::Role1 Some::Role2));
  
  Creates a new class based on base, with the roles composed into it in order.
  New class is returned.
  
  =head2 is_role
  
   Role::Tiny->is_role('Some::Role1')
  
  Returns true if the given package is a role.
  
  =head1 CAVEATS
  
  =over 4
  
  =item * On perl 5.8.8 and earlier, applying a role to an object won't apply any
  overloads from the role to other copies of the object.
  
  =item * On perl 5.16 and earlier, applying a role to a class won't apply any
  overloads from the role to any existing instances of the class.
  
  =back
  
  =head1 SEE ALSO
  
  L<Role::Tiny> is the attribute-less subset of L<Moo::Role>; L<Moo::Role> is
  a meta-protocol-less subset of the king of role systems, L<Moose::Role>.
  
  Ovid's L<Role::Basic> provides roles with a similar scope, but without method
  modifiers, and having some extra usage restrictions.
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  hobbs - Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
  
  jnap - John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  chip - Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
  
  ajgb - Alex J. G. Burzyski (cpan:AJGB) <ajgb@cpan.org>
  
  doy - Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
  
  perigrin - Chris Prather (cpan:PERIGRIN) <chris@prather.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  ilmari - Dagfinn Ilmari Mannsker (cpan:ILMARI) <ilmari@ilmari.org>
  
  tobyink - Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@haarg.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2012 the Role::Tiny L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
ROLE_TINY

$fatpacked{"Role/Tiny/With.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY_WITH';
  package Role::Tiny::With;
  
  use strict;
  use warnings;
  
  our $VERSION = '2.000006';
  $VERSION = eval $VERSION;
  
  use Role::Tiny ();
  
  use Exporter 'import';
  our @EXPORT = qw( with );
  
  sub with {
      my $target = caller;
      Role::Tiny->apply_roles_to_package($target, @_)
  }
  
  1;
  
  =head1 NAME
  
  Role::Tiny::With - Neat interface for consumers of Role::Tiny roles
  
  =head1 SYNOPSIS
  
   package Some::Class;
  
   use Role::Tiny::With;
  
   with 'Some::Role';
  
   # The role is now mixed in
  
  =head1 DESCRIPTION
  
  C<Role::Tiny> is a minimalist role composition tool.  C<Role::Tiny::With>
  provides a C<with> function to compose such roles.
  
  =head1 AUTHORS
  
  See L<Role::Tiny> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Role::Tiny> for the copyright and license.
  
  =cut
  
  
ROLE_TINY_WITH

$fatpacked{"Test/Mojo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_MOJO';
  package Test::Mojo;
  use Mojo::Base -base;
  
  # "Amy: He knows when you are sleeping.
  #  Professor: He knows when you're on the can.
  #  Leela: He'll hunt you down and blast your ass from here to Pakistan.
  #  Zoidberg: Oh.
  #  Hermes: You'd better not breathe, you'd better not move.
  #  Bender: You're better off dead, I'm telling you, dude.
  #  Fry: Santa Claus is gunning you down!"
  use Mojo::IOLoop;
  use Mojo::JSON 'j';
  use Mojo::JSON::Pointer;
  use Mojo::Server;
  use Mojo::UserAgent;
  use Mojo::Util qw(decode encode);
  use Test::More ();
  
  has [qw(message success tx)];
  has ua =>
    sub { Mojo::UserAgent->new(insecure => 1)->ioloop(Mojo::IOLoop->singleton) };
  
  # Silent or loud tests
  $ENV{MOJO_LOG_LEVEL} ||= $ENV{HARNESS_IS_VERBOSE} ? 'debug' : 'fatal';
  
  sub app {
    my ($self, $app) = @_;
    return $self->ua->server->app unless $app;
    $self->ua->server->app($app);
    return $self;
  }
  
  sub content_is {
    my ($self, $value, $desc) = @_;
    return $self->_test('is', $self->tx->res->text,
      $value, _desc($desc, 'exact match for content'));
  }
  
  sub content_isnt {
    my ($self, $value, $desc) = @_;
    return $self->_test('isnt', $self->tx->res->text,
      $value, _desc($desc, 'no match for content'));
  }
  
  sub content_like {
    my ($self, $regex, $desc) = @_;
    return $self->_test('like', $self->tx->res->text,
      $regex, _desc($desc, 'content is similar'));
  }
  
  sub content_type_is {
    my ($self, $type, $desc) = @_;
    $desc = _desc($desc, "Content-Type: $type");
    return $self->_test('is', $self->tx->res->headers->content_type, $type,
      $desc);
  }
  
  sub content_type_isnt {
    my ($self, $type, $desc) = @_;
    $desc = _desc($desc, "not Content-Type: $type");
    return $self->_test('isnt', $self->tx->res->headers->content_type, $type,
      $desc);
  }
  
  sub content_type_like {
    my ($self, $regex, $desc) = @_;
    $desc = _desc($desc, 'Content-Type is similar');
    return $self->_test('like', $self->tx->res->headers->content_type, $regex,
      $desc);
  }
  
  sub content_type_unlike {
    my ($self, $regex, $desc) = @_;
    $desc = _desc($desc, 'Content-Type is not similar');
    return $self->_test('unlike', $self->tx->res->headers->content_type, $regex,
      $desc);
  }
  
  sub content_unlike {
    my ($self, $regex, $desc) = @_;
    return $self->_test('unlike', $self->tx->res->text,
      $regex, _desc($desc, 'content is not similar'));
  }
  
  sub delete_ok { shift->_build_ok(DELETE => @_) }
  
  sub element_count_is {
    my ($self, $selector, $count, $desc) = @_;
    my $size = $self->tx->res->dom->find($selector)->size;
    return $self->_test('is', $size, $count,
      _desc($desc, qq{element count for selector "$selector"}));
  }
  
  sub element_exists {
    my ($self, $selector, $desc) = @_;
    $desc = _desc($desc, qq{element for selector "$selector" exists});
    return $self->_test('ok', $self->tx->res->dom->at($selector), $desc);
  }
  
  sub element_exists_not {
    my ($self, $selector, $desc) = @_;
    $desc = _desc($desc, qq{no element for selector "$selector"});
    return $self->_test('ok', !$self->tx->res->dom->at($selector), $desc);
  }
  
  sub finish_ok {
    my $self = shift;
    $self->tx->finish(@_) if $self->tx->is_websocket;
    Mojo::IOLoop->one_tick while !$self->{finished};
    return $self->_test('ok', 1, 'closed WebSocket');
  }
  
  sub finished_ok {
    my ($self, $code) = @_;
    Mojo::IOLoop->one_tick while !$self->{finished};
    Test::More::diag "WebSocket closed with status $self->{finished}[0]"
      unless my $ok = $self->{finished}[0] == $code;
    return $self->_test('ok', $ok, "WebSocket closed with status $code");
  }
  
  sub get_ok  { shift->_build_ok(GET  => @_) }
  sub head_ok { shift->_build_ok(HEAD => @_) }
  
  sub header_is {
    my ($self, $name, $value, $desc) = @_;
    $desc = _desc($desc, "$name: " . ($value // ''));
    return $self->_test('is', $self->tx->res->headers->header($name), $value,
      $desc);
  }
  
  sub header_isnt {
    my ($self, $name, $value, $desc) = @_;
    $desc = _desc($desc, "not $name: " . ($value // ''));
    return $self->_test('isnt', $self->tx->res->headers->header($name), $value,
      $desc);
  }
  
  sub header_like {
    my ($self, $name, $regex, $desc) = @_;
    $desc = _desc($desc, "$name is similar");
    return $self->_test('like', $self->tx->res->headers->header($name), $regex,
      $desc);
  }
  
  sub header_unlike {
    my ($self, $name, $regex, $desc) = @_;
    $desc = _desc($desc, "$name is not similar");
    return $self->_test('unlike', $self->tx->res->headers->header($name),
      $regex, $desc);
  }
  
  sub json_has {
    my ($self, $p, $desc) = @_;
    $desc = _desc($desc, qq{has value for JSON Pointer "$p"});
    return $self->_test('ok',
      !!Mojo::JSON::Pointer->new($self->tx->res->json)->contains($p), $desc);
  }
  
  sub json_hasnt {
    my ($self, $p, $desc) = @_;
    $desc = _desc($desc, qq{has no value for JSON Pointer "$p"});
    return $self->_test('ok',
      !Mojo::JSON::Pointer->new($self->tx->res->json)->contains($p), $desc);
  }
  
  sub json_is {
    my $self = shift;
    my ($p, $data) = @_ > 1 ? (shift, shift) : ('', shift);
    my $desc = _desc(shift, qq{exact match for JSON Pointer "$p"});
    return $self->_test('is_deeply', $self->tx->res->json($p), $data, $desc);
  }
  
  sub json_like {
    my ($self, $p, $regex, $desc) = @_;
    return $self->_test('like', $self->tx->res->json($p),
      $regex, _desc($desc, qq{similar match for JSON Pointer "$p"}));
  }
  
  sub json_message_has {
    my ($self, $p, $desc) = @_;
    $desc = _desc($desc, qq{has value for JSON Pointer "$p"});
    return $self->_test('ok', $self->_json(contains => $p), $desc);
  }
  
  sub json_message_hasnt {
    my ($self, $p, $desc) = @_;
    $desc = _desc($desc, qq{has no value for JSON Pointer "$p"});
    return $self->_test('ok', !$self->_json(contains => $p), $desc);
  }
  
  sub json_message_is {
    my $self = shift;
    my ($p, $data) = @_ > 1 ? (shift, shift) : ('', shift);
    my $desc = _desc(shift, qq{exact match for JSON Pointer "$p"});
    return $self->_test('is_deeply', $self->_json(get => $p), $data, $desc);
  }
  
  sub json_message_like {
    my ($self, $p, $regex, $desc) = @_;
    return $self->_test('like', $self->_json(get => $p),
      $regex, _desc($desc, qq{similar match for JSON Pointer "$p"}));
  }
  
  sub json_message_unlike {
    my ($self, $p, $regex, $desc) = @_;
    return $self->_test('unlike', $self->_json(get => $p),
      $regex, _desc($desc, qq{no similar match for JSON Pointer "$p"}));
  }
  
  sub json_unlike {
    my ($self, $p, $regex, $desc) = @_;
    return $self->_test('unlike', $self->tx->res->json($p),
      $regex, _desc($desc, qq{no similar match for JSON Pointer "$p"}));
  }
  
  sub message_is {
    my ($self, $value, $desc) = @_;
    return $self->_message('is', $value, _desc($desc, 'exact match for message'));
  }
  
  sub message_isnt {
    my ($self, $value, $desc) = @_;
    return $self->_message('isnt', $value, _desc($desc, 'no match for message'));
  }
  
  sub message_like {
    my ($self, $regex, $desc) = @_;
    return $self->_message('like', $regex, _desc($desc, 'message is similar'));
  }
  
  sub message_ok {
    my ($self, $desc) = @_;
    return $self->_test('ok', !!$self->_wait, _desc($desc, 'message received'));
  }
  
  sub message_unlike {
    my ($self, $regex, $desc) = @_;
    return $self->_message('unlike', $regex,
      _desc($desc, 'message is not similar'));
  }
  
  sub new {
    my $self = shift->SUPER::new;
  
    return $self unless my $app = shift;
  
    my @args = @_ ? {config => {config_override => 1, %{shift()}}} : ();
    return $self->app(
      ref $app ? $app : Mojo::Server->new->build_app($app, @args));
  }
  
  sub options_ok { shift->_build_ok(OPTIONS => @_) }
  
  sub or {
    my ($self, $cb) = @_;
    $self->$cb unless $self->success;
    return $self;
  }
  
  sub patch_ok { shift->_build_ok(PATCH => @_) }
  sub post_ok  { shift->_build_ok(POST  => @_) }
  sub put_ok   { shift->_build_ok(PUT   => @_) }
  
  sub request_ok { shift->_request_ok($_[0], $_[0]->req->url->to_string) }
  
  sub reset_session {
    my $self = shift;
    $self->ua->cookie_jar->empty;
    return $self->tx(undef);
  }
  
  sub send_ok {
    my ($self, $msg, $desc) = @_;
  
    $desc = _desc($desc, 'send message');
    return $self->_test('ok', 0, $desc) unless $self->tx->is_websocket;
  
    $self->tx->send($msg => sub { Mojo::IOLoop->stop });
    Mojo::IOLoop->start;
    return $self->_test('ok', 1, $desc);
  }
  
  sub status_is {
    my ($self, $status, $desc) = @_;
    $desc = _desc($desc, "$status " . $self->tx->res->default_message($status));
    return $self->_test('is', $self->tx->res->code, $status, $desc);
  }
  
  sub status_isnt {
    my ($self, $status, $desc) = @_;
    return $self->_test('isnt', $self->tx->res->code,
      $status,
      _desc($desc, "not $status " . $self->tx->res->default_message($status)));
  }
  
  sub text_is {
    my ($self, $selector, $value, $desc) = @_;
    return $self->_test('is', $self->_text($selector),
      $value, _desc($desc, qq{exact match for selector "$selector"}));
  }
  
  sub text_isnt {
    my ($self, $selector, $value, $desc) = @_;
    return $self->_test('isnt', $self->_text($selector),
      $value, _desc($desc, qq{no match for selector "$selector"}));
  }
  
  sub text_like {
    my ($self, $selector, $regex, $desc) = @_;
    return $self->_test('like', $self->_text($selector),
      $regex, _desc($desc, qq{similar match for selector "$selector"}));
  }
  
  sub text_unlike {
    my ($self, $selector, $regex, $desc) = @_;
    return $self->_test('unlike', $self->_text($selector),
      $regex, _desc($desc, qq{no similar match for selector "$selector"}));
  }
  
  sub websocket_ok {
    my $self = shift;
    return $self->_request_ok($self->ua->build_websocket_tx(@_), $_[0]);
  }
  
  sub _build_ok {
    my ($self, $method, $url) = (shift, shift, shift);
    local $Test::Builder::Level = $Test::Builder::Level + 1;
    return $self->_request_ok($self->ua->build_tx($method, $url, @_), $url);
  }
  
  sub _desc { encode 'UTF-8', shift || shift }
  
  sub _json {
    my ($self, $method, $p) = @_;
    return Mojo::JSON::Pointer->new(j(@{$self->message // []}[1]))->$method($p);
  }
  
  sub _message {
    my ($self, $name, $value, $desc) = @_;
    local $Test::Builder::Level = $Test::Builder::Level + 1;
    my ($type, $msg) = @{$self->message // []};
  
    # Type check
    if (ref $value eq 'HASH') {
      my $expect = exists $value->{text} ? 'text' : 'binary';
      $value = $value->{$expect};
      $msg = '' unless ($type // '') eq $expect;
    }
  
    # Decode text frame if there is no type check
    else { $msg = decode 'UTF-8', $msg if ($type // '') eq 'text' }
  
    return $self->_test($name, $msg // '', $value, $desc);
  }
  
  sub _request_ok {
    my ($self, $tx, $url) = @_;
  
    local $Test::Builder::Level = $Test::Builder::Level + 1;
  
    # Establish WebSocket connection
    if ($tx->req->is_handshake) {
      @$self{qw(finished messages)} = (undef, []);
      $self->ua->start(
        $tx => sub {
          my ($ua, $tx) = @_;
          $self->{finished} = [] unless $self->tx($tx)->tx->is_websocket;
          $tx->on(finish => sub { shift; $self->{finished} = [@_] });
          $tx->on(binary => sub { push @{$self->{messages}}, [binary => pop] });
          $tx->on(text   => sub { push @{$self->{messages}}, [text   => pop] });
          Mojo::IOLoop->stop;
        }
      );
      Mojo::IOLoop->start;
  
      my $desc = _desc("WebSocket handshake with $url");
      return $self->_test('ok', $self->tx->is_websocket, $desc);
    }
  
    # Perform request
    $self->tx($self->ua->start($tx));
    my $err = $self->tx->error;
    Test::More::diag $err->{message}
      if !(my $ok = !$err->{message} || $err->{code}) && $err;
    return $self->_test('ok', $ok, _desc("@{[uc $tx->req->method]} $url"));
  }
  
  sub _test {
    my ($self, $name, @args) = @_;
    local $Test::Builder::Level = $Test::Builder::Level + 2;
    return $self->success(!!Test::More->can($name)->(@args));
  }
  
  sub _text {
    return '' unless my $e = shift->tx->res->dom->at(shift);
    return $e->text;
  }
  
  sub _wait {
    my $self = shift;
    Mojo::IOLoop->one_tick while !$self->{finished} && !@{$self->{messages}};
    return $self->message(shift @{$self->{messages}})->message;
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Test::Mojo - Testing Mojo
  
  =head1 SYNOPSIS
  
    use Test::More;
    use Test::Mojo;
  
    my $t = Test::Mojo->new('MyApp');
  
    # HTML/XML
    $t->get_ok('/welcome')->status_is(200)->text_is('div#message' => 'Hello!');
  
    # JSON
    $t->post_ok('/search.json' => form => {q => 'Perl'})
      ->status_is(200)
      ->header_is('Server' => 'Mojolicious (Perl)')
      ->header_isnt('X-Bender' => 'Bite my shiny metal ass!')
      ->json_is('/results/4/title' => 'Perl rocks!')
      ->json_like('/results/7/title' => qr/Perl/);
  
    # WebSocket
    $t->websocket_ok('/echo')
      ->send_ok('hello')
      ->message_ok
      ->message_is('echo: hello')
      ->finish_ok;
  
    done_testing();
  
  =head1 DESCRIPTION
  
  L<Test::Mojo> is a test user agent based on L<Mojo::UserAgent>, it is usually
  used together with L<Test::More> to test L<Mojolicious> applications. Just run
  your tests with the command L<Mojolicious::Command::test> or L<prove>.
  
    $ ./script/my_app test
    $ ./script/my_app test -v t/foo.t
    $ prove -l -v t/foo.t
  
  If it is not already defined, the C<MOJO_LOG_LEVEL> environment variable will
  be set to C<debug> or C<fatal>, depending on the value of the
  C<HARNESS_IS_VERBOSE> environment variable. And to make it esier to test
  HTTPS/WSS web services L<Mojo::UserAgent/"insecure"> will be activated by
  default for L</"ua">.
  
  See L<Mojolicious::Guides::Testing> for more.
  
  =head1 ATTRIBUTES
  
  L<Test::Mojo> implements the following attributes.
  
  =head2 message
  
    my $msg = $t->message;
    $t      = $t->message([text => $bytes]);
  
  Current WebSocket message represented as an array reference containing the
  frame type and payload.
  
    # More specific tests
    use Mojo::JSON 'decode_json';
    my $hash = decode_json $t->message->[1];
    is ref $hash, 'HASH', 'right reference';
    is $hash->{foo}, 'bar', 'right value';
  
    # Test custom message
    $t->message([binary => $bytes])
      ->json_message_has('/foo/bar')
      ->json_message_hasnt('/bar')
      ->json_message_is('/foo/baz' => {yada => [1, 2, 3]});
  
  =head2 success
  
    my $bool = $t->success;
    $t       = $t->success($bool);
  
  True if the last test was successful.
  
    # Build custom tests
    my $location_is = sub {
      my ($t, $value, $desc) = @_;
      $desc ||= "Location: $value";
      local $Test::Builder::Level = $Test::Builder::Level + 1;
      return $t->success(is($t->tx->res->headers->location, $value, $desc));
    };
    $t->get_ok('/')
      ->status_is(302)
      ->$location_is('https://mojolicious.org')
      ->or(sub { diag 'Must have been Joel!' });
  
  =head2 tx
  
    my $tx = $t->tx;
    $t     = $t->tx(Mojo::Transaction::HTTP->new);
  
  Current transaction, usually a L<Mojo::Transaction::HTTP> or
  L<Mojo::Transaction::WebSocket> object.
  
    # More specific tests
    is $t->tx->res->json->{foo}, 'bar', 'right value';
    ok $t->tx->res->content->is_multipart, 'multipart content';
    is $t->tx->previous->res->code, 302, 'right status';
  
  =head2 ua
  
    my $ua = $t->ua;
    $t     = $t->ua(Mojo::UserAgent->new);
  
  User agent used for testing, defaults to a L<Mojo::UserAgent> object.
  
    # Allow redirects
    $t->ua->max_redirects(10);
    $t->get_ok('/redirect')->status_is(200)->content_like(qr/redirected/);
  
    # Switch protocol from HTTP to HTTPS
    $t->ua->server->url('https');
    $t->get_ok('/secure')->status_is(200)->content_like(qr/secure/);
  
    # Use absolute URL for request with Basic authentication
    my $url = $t->ua->server->url->userinfo('sri:secr3t')->path('/secrets.json');
    $t->post_ok($url => json => {limit => 10})
      ->status_is(200)
      ->json_is('/1/content', 'Mojo rocks!');
  
    # Customize all transactions (including followed redirects)
    $t->ua->on(start => sub {
      my ($ua, $tx) = @_;
      $tx->req->headers->accept_language('en-US');
    });
    $t->get_ok('/hello')->status_is(200)->content_like(qr/Howdy/);
  
  =head1 METHODS
  
  L<Test::Mojo> inherits all methods from L<Mojo::Base> and implements the
  following new ones.
  
  =head2 app
  
    my $app = $t->app;
    $t      = $t->app(Mojolicious->new);
  
  Access application with L<Mojo::UserAgent::Server/"app">.
  
    # Change log level
    $t->app->log->level('fatal');
  
    # Test application directly
    is $t->app->defaults->{foo}, 'bar', 'right value';
    ok $t->app->routes->find('echo')->is_websocket, 'WebSocket route';
    my $c = $t->app->build_controller;
    ok $c->render(template => 'foo'), 'rendering was successful';
    is $c->res->status, 200, 'right status';
    is $c->res->body, 'Foo!', 'right content';
  
    # Change application behavior
    $t->app->hook(before_dispatch => sub {
      my $c = shift;
      $c->render(text => 'This request did not reach the router.')
        if $c->req->url->path->contains('/user');
    });
    $t->get_ok('/user')->status_is(200)->content_like(qr/not reach the router/);
  
    # Extract additional information
    my $stash;
    $t->app->hook(after_dispatch => sub { $stash = shift->stash });
    $t->get_ok('/hello')->status_is(200);
    is $stash->{foo}, 'bar', 'right value';
  
  =head2 content_is
  
    $t = $t->content_is('working!');
    $t = $t->content_is('working!', 'right content');
  
  Check response content for exact match after retrieving it from
  L<Mojo::Message/"text">.
  
  =head2 content_isnt
  
    $t = $t->content_isnt('working!');
    $t = $t->content_isnt('working!', 'different content');
  
  Opposite of L</"content_is">.
  
  =head2 content_like
  
    $t = $t->content_like(qr/working!/);
    $t = $t->content_like(qr/working!/, 'right content');
  
  Check response content for similar match after retrieving it from
  L<Mojo::Message/"text">.
  
  =head2 content_type_is
  
    $t = $t->content_type_is('text/html');
    $t = $t->content_type_is('text/html', 'right content type');
  
  Check response C<Content-Type> header for exact match.
  
  =head2 content_type_isnt
  
    $t = $t->content_type_isnt('text/html');
    $t = $t->content_type_isnt('text/html', 'different content type');
  
  Opposite of L</"content_type_is">.
  
  =head2 content_type_like
  
    $t = $t->content_type_like(qr/text/);
    $t = $t->content_type_like(qr/text/, 'right content type');
  
  Check response C<Content-Type> header for similar match.
  
  =head2 content_type_unlike
  
    $t = $t->content_type_unlike(qr/text/);
    $t = $t->content_type_unlike(qr/text/, 'different content type');
  
  Opposite of L</"content_type_like">.
  
  =head2 content_unlike
  
    $t = $t->content_unlike(qr/working!/);
    $t = $t->content_unlike(qr/working!/, 'different content');
  
  Opposite of L</"content_like">.
  
  =head2 delete_ok
  
    $t = $t->delete_ok('http://example.com/foo');
    $t = $t->delete_ok('/foo');
    $t = $t->delete_ok('/foo' => {Accept => '*/*'} => 'Content!');
    $t = $t->delete_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->delete_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<DELETE> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"delete">, except for the callback.
  
  =head2 element_count_is
  
    $t = $t->element_count_is('div.foo[x=y]', 5);
    $t = $t->element_count_is('html body div', 30, 'thirty elements');
  
  Checks the number of HTML/XML elements matched by the CSS selector with
  L<Mojo::DOM/"find">.
  
  =head2 element_exists
  
    $t = $t->element_exists('div.foo[x=y]');
    $t = $t->element_exists('html head title', 'has a title');
  
  Checks for existence of the CSS selectors first matching HTML/XML element with
  L<Mojo::DOM/"at">.
  
    # Check attribute values
    $t->get_ok('/login')
      ->element_exists('label[for=email]')
      ->element_exists('input[name=email][type=text][value*="example.com"]')
      ->element_exists('label[for=pass]')
      ->element_exists('input[name=pass][type=password]')
      ->element_exists('input[type=submit][value]');
  
  =head2 element_exists_not
  
    $t = $t->element_exists_not('div.foo[x=y]');
    $t = $t->element_exists_not('html head title', 'has no title');
  
  Opposite of L</"element_exists">.
  
  =head2 finish_ok
  
    $t = $t->finish_ok;
    $t = $t->finish_ok(1000);
    $t = $t->finish_ok(1003 => 'Cannot accept data!');
  
  Close WebSocket connection gracefully.
  
  =head2 finished_ok
  
    $t = $t->finished_ok(1000);
  
  Wait for WebSocket connection to be closed gracefully and check status.
  
  =head2 get_ok
  
    $t = $t->get_ok('http://example.com/foo');
    $t = $t->get_ok('/foo');
    $t = $t->get_ok('/foo' => {Accept => '*/*'} => 'Content!');
    $t = $t->get_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->get_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<GET> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"get">, except for the callback.
  
    # Run tests against remote host
    $t->get_ok('https://mojolicious.org/perldoc')->status_is(200);
  
    # Use relative URL for request with Basic authentication
    $t->get_ok('//sri:secr3t@/secrets.json')
      ->status_is(200)
      ->json_is('/1/content', 'Mojo rocks!');
  
    # Run additional tests on the transaction
    $t->get_ok('/foo')->status_is(200);
    is $t->tx->res->dom->at('input')->val, 'whatever', 'right value';
  
  =head2 head_ok
  
    $t = $t->head_ok('http://example.com/foo');
    $t = $t->head_ok('/foo');
    $t = $t->head_ok('/foo' => {Accept => '*/*'} => 'Content!');
    $t = $t->head_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->head_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<HEAD> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"head">, except for the callback.
  
  =head2 header_is
  
    $t = $t->header_is(ETag => '"abc321"');
    $t = $t->header_is(ETag => '"abc321"', 'right header');
  
  Check response header for exact match.
  
  =head2 header_isnt
  
    $t = $t->header_isnt(Etag => '"abc321"');
    $t = $t->header_isnt(ETag => '"abc321"', 'different header');
  
  Opposite of L</"header_is">.
  
  =head2 header_like
  
    $t = $t->header_like(ETag => qr/abc/);
    $t = $t->header_like(ETag => qr/abc/, 'right header');
  
  Check response header for similar match.
  
  =head2 header_unlike
  
    $t = $t->header_unlike(ETag => qr/abc/);
    $t = $t->header_unlike(ETag => qr/abc/, 'different header');
  
  Opposite of L</"header_like">.
  
  =head2 json_has
  
    $t = $t->json_has('/foo');
    $t = $t->json_has('/minibar', 'has a minibar');
  
  Check if JSON response contains a value that can be identified using the given
  JSON Pointer with L<Mojo::JSON::Pointer>.
  
  =head2 json_hasnt
  
    $t = $t->json_hasnt('/foo');
    $t = $t->json_hasnt('/minibar', 'no minibar');
  
  Opposite of L</"json_has">.
  
  =head2 json_is
  
    $t = $t->json_is({foo => [1, 2, 3]});
    $t = $t->json_is('/foo' => [1, 2, 3]);
    $t = $t->json_is('/foo/1' => 2, 'right value');
  
  Check the value extracted from JSON response using the given JSON Pointer with
  L<Mojo::JSON::Pointer>, which defaults to the root value if it is omitted.
  
  =head2 json_like
  
    $t = $t->json_like('/foo/1' => qr/^\d+$/);
    $t = $t->json_like('/foo/1' => qr/^\d+$/, 'right value');
  
  Check the value extracted from JSON response using the given JSON Pointer with
  L<Mojo::JSON::Pointer> for similar match.
  
  =head2 json_message_has
  
    $t = $t->json_message_has('/foo');
    $t = $t->json_message_has('/minibar', 'has a minibar');
  
  Check if JSON WebSocket message contains a value that can be identified using
  the given JSON Pointer with L<Mojo::JSON::Pointer>.
  
  =head2 json_message_hasnt
  
    $t = $t->json_message_hasnt('/foo');
    $t = $t->json_message_hasnt('/minibar', 'no minibar');
  
  Opposite of L</"json_message_has">.
  
  =head2 json_message_is
  
    $t = $t->json_message_is({foo => [1, 2, 3]});
    $t = $t->json_message_is('/foo' => [1, 2, 3]);
    $t = $t->json_message_is('/foo/1' => 2, 'right value');
  
  Check the value extracted from JSON WebSocket message using the given JSON
  Pointer with L<Mojo::JSON::Pointer>, which defaults to the root value if it is
  omitted.
  
  =head2 json_message_like
  
    $t = $t->json_message_like('/foo/1' => qr/^\d+$/);
    $t = $t->json_message_like('/foo/1' => qr/^\d+$/, 'right value');
  
  Check the value extracted from JSON WebSocket message using the given JSON
  Pointer with L<Mojo::JSON::Pointer> for similar match.
  
  =head2 json_message_unlike
  
    $t = $t->json_message_unlike('/foo/1' => qr/^\d+$/);
    $t = $t->json_message_unlike('/foo/1' => qr/^\d+$/, 'different value');
  
  Opposite of L</"json_message_like">.
  
  =head2 json_unlike
  
    $t = $t->json_unlike('/foo/1' => qr/^\d+$/);
    $t = $t->json_unlike('/foo/1' => qr/^\d+$/, 'different value');
  
  Opposite of L</"json_like">.
  
  =head2 message_is
  
    $t = $t->message_is({binary => $bytes});
    $t = $t->message_is({text   => $bytes});
    $t = $t->message_is('working!');
    $t = $t->message_is('working!', 'right message');
  
  Check WebSocket message for exact match.
  
  =head2 message_isnt
  
    $t = $t->message_isnt({binary => $bytes});
    $t = $t->message_isnt({text   => $bytes});
    $t = $t->message_isnt('working!');
    $t = $t->message_isnt('working!', 'different message');
  
  Opposite of L</"message_is">.
  
  =head2 message_like
  
    $t = $t->message_like({binary => qr/$bytes/});
    $t = $t->message_like({text   => qr/$bytes/});
    $t = $t->message_like(qr/working!/);
    $t = $t->message_like(qr/working!/, 'right message');
  
  Check WebSocket message for similar match.
  
  =head2 message_ok
  
    $t = $t->message_ok;
    $t = $t->message_ok('got a message');
  
  Wait for next WebSocket message to arrive.
  
    # Wait for message and perform multiple tests on it
    $t->websocket_ok('/time')
      ->message_ok
      ->message_like(qr/\d+/)
      ->message_unlike(qr/\w+/)
      ->finish_ok;
  
  =head2 message_unlike
  
    $t = $t->message_unlike({binary => qr/$bytes/});
    $t = $t->message_unlike({text   => qr/$bytes/});
    $t = $t->message_unlike(qr/working!/);
    $t = $t->message_unlike(qr/working!/, 'different message');
  
  Opposite of L</"message_like">.
  
  =head2 new
  
    my $t = Test::Mojo->new;
    my $t = Test::Mojo->new('MyApp');
    my $t = Test::Mojo->new(MyApp => {foo => 'bar', baz => 23});
    my $t = Test::Mojo->new(MyApp->new);
  
  Construct a new L<Test::Mojo> object. In addition to a class name, you can pass
  along a hash reference with configuration values that will be used to
  instantiate the application. The special configuration value C<config_override>
  will be set in L<Mojolicious/"config"> as well, which is used to disable
  configuration plugins like L<Mojolicious::Plugin::Config> and
  L<Mojolicious::Plugin::JSONConfig> for tests.
  
  =head2 options_ok
  
    $t = $t->options_ok('http://example.com/foo');
    $t = $t->options_ok('/foo');
    $t = $t->options_ok('/foo' => {Accept => '*/*'} => 'Content!');
    $t = $t->options_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->options_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<OPTIONS> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"options">, except for the callback.
  
  =head2 or
  
    $t = $t->or(sub {...});
  
  Execute callback if the value of L</"success"> is false.
  
    # Diagnostics
    $t->get_ok('/bad')->or(sub { diag 'Must have been Glen!' })
      ->status_is(200)->or(sub { diag $t->tx->res->dom->at('title')->text });
  
  =head2 patch_ok
  
    $t = $t->patch_ok('http://example.com/foo');
    $t = $t->patch_ok('/foo');
    $t = $t->patch_ok('/foo' => {Accept => '*/*'} => 'Content!');
    $t = $t->patch_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->patch_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<PATCH> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"patch">, except for the callback.
  
  =head2 post_ok
  
    $t = $t->post_ok('http://example.com/foo');
    $t = $t->post_ok('/foo');
    $t = $t->post_ok('/foo' => {Accept => '*/*'} => 'Content!');
    $t = $t->post_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->post_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<POST> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"post">, except for the callback.
  
    # Test file upload
    my $upload = {foo => {content => 'bar', filename => 'baz.txt'}};
    $t->post_ok('/upload' => form => $upload)->status_is(200);
  
    # Test JSON API
    $t->post_ok('/hello.json' => json => {hello => 'world'})
      ->status_is(200)
      ->json_is({bye => 'world'});
  
  =head2 put_ok
  
    $t = $t->put_ok('http://example.com/foo');
    $t = $t->put_ok('/foo');
    $t = $t->put_ok('/foo' => {Accept => '*/*'} => 'Content!');
    $t = $t->put_ok('/foo' => {Accept => '*/*'} => form => {a => 'b'});
    $t = $t->put_ok('/foo' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform a C<PUT> request and check for transport errors, takes the same
  arguments as L<Mojo::UserAgent/"put">, except for the callback.
  
  =head2 request_ok
  
    $t = $t->request_ok(Mojo::Transaction::HTTP->new);
  
  Perform request and check for transport errors.
  
    # Request with custom method
    my $tx = $t->ua->build_tx(FOO => '/test.json' => json => {foo => 1});
    $t->request_ok($tx)->status_is(200)->json_is({success => 1});
  
    # Request with custom cookie
    my $tx = $t->ua->build_tx(GET => '/account');
    $tx->req->cookies({name => 'user', value => 'sri'});
    $t->request_ok($tx)->status_is(200)->text_is('head > title' => 'Hello sri');
  
    # Custom WebSocket handshake
    my $tx = $t->ua->build_websocket_tx('/foo');
    $tx->req->headers->remove('User-Agent');
    $t->request_ok($tx)->message_ok->message_is('bar')->finish_ok;
  
  =head2 reset_session
  
    $t = $t->reset_session;
  
  Reset user agent session.
  
  =head2 send_ok
  
    $t = $t->send_ok({binary => $bytes});
    $t = $t->send_ok({text   => $bytes});
    $t = $t->send_ok({json   => {test => [1, 2, 3]}});
    $t = $t->send_ok([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);
    $t = $t->send_ok($chars);
    $t = $t->send_ok($chars, 'sent successfully');
  
  Send message or frame via WebSocket.
  
    # Send JSON object as "Text" message
    $t->websocket_ok('/echo.json')
      ->send_ok({json => {test => 'I  Mojolicious!'}})
      ->message_ok
      ->json_message_is('/test' => 'I  Mojolicious!')
      ->finish_ok;
  
  =head2 status_is
  
    $t = $t->status_is(200);
    $t = $t->status_is(200, 'right status');
  
  Check response status for exact match.
  
  =head2 status_isnt
  
    $t = $t->status_isnt(200);
    $t = $t->status_isnt(200, 'different status');
  
  Opposite of L</"status_is">.
  
  =head2 text_is
  
    $t = $t->text_is('div.foo[x=y]' => 'Hello!');
    $t = $t->text_is('html head title' => 'Hello!', 'right title');
  
  Checks text content of the CSS selectors first matching HTML/XML element for
  exact match with L<Mojo::DOM/"at">.
  
  =head2 text_isnt
  
    $t = $t->text_isnt('div.foo[x=y]' => 'Hello!');
    $t = $t->text_isnt('html head title' => 'Hello!', 'different title');
  
  Opposite of L</"text_is">.
  
  =head2 text_like
  
    $t = $t->text_like('div.foo[x=y]' => qr/Hello/);
    $t = $t->text_like('html head title' => qr/Hello/, 'right title');
  
  Checks text content of the CSS selectors first matching HTML/XML element for
  similar match with L<Mojo::DOM/"at">.
  
  =head2 text_unlike
  
    $t = $t->text_unlike('div.foo[x=y]' => qr/Hello/);
    $t = $t->text_unlike('html head title' => qr/Hello/, 'different title');
  
  Opposite of L</"text_like">.
  
  =head2 websocket_ok
  
    $t = $t->websocket_ok('http://example.com/echo');
    $t = $t->websocket_ok('/echo');
    $t = $t->websocket_ok('/echo' => {DNT => 1} => ['v1.proto']);
  
  Open a WebSocket connection with transparent handshake, takes the same
  arguments as L<Mojo::UserAgent/"websocket">, except for the callback.
  
    # WebSocket with permessage-deflate compression
    $t->websocket_ok('/' => {'Sec-WebSocket-Extensions' => 'permessage-deflate'})
      ->send_ok('y' x 50000)
      ->message_ok
      ->message_is('z' x 50000)
      ->finish_ok;
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
TEST_MOJO

$fatpacked{"ojo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OJO';
  package ojo;
  use Mojo::Base -strict;
  
  use Benchmark qw(timeit timestr :hireswallclock);
  use Mojo::ByteStream 'b';
  use Mojo::Collection 'c';
  use Mojo::DOM;
  use Mojo::File 'path';
  use Mojo::JSON 'j';
  use Mojo::Util qw(dumper monkey_patch);
  
  # Silent one-liners
  $ENV{MOJO_LOG_LEVEL} ||= 'fatal';
  
  sub import {
  
    # Mojolicious::Lite
    my $caller = caller;
    eval "package $caller; use Mojolicious::Lite; 1" or die $@;
    Mojo::Base->import(-strict, $] < 5.020 ? () : (-signatures));
    my $ua = $caller->app->ua;
    $ua->server->app->hook(around_action => sub { local $_ = $_[1]; $_[0]() });
  
    $ua->max_redirects(10) unless defined $ENV{MOJO_MAX_REDIRECTS};
    $ua->proxy->detect unless defined $ENV{MOJO_PROXY};
  
    # The ojo DSL
    monkey_patch $caller,
      a => sub { $caller->can('any')->(@_) and return $ua->server->app },
      b => \&b,
      c => \&c,
      d => sub { $ua->delete(@_)->result },
      f => \&path,
      g => sub { $ua->get(@_)->result },
      h => sub { $ua->head(@_)->result },
      j => \&j,
      n => sub (&@) { say STDERR timestr timeit($_[1] // 1, $_[0]) },
      o => sub { $ua->options(@_)->result },
      p => sub { $ua->post(@_)->result },
      r => \&dumper,
      t => sub { $ua->patch(@_)->result },
      u => sub { $ua->put(@_)->result },
      x => sub { Mojo::DOM->new(@_) };
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  ojo - Fun one-liners with Mojo
  
  =head1 SYNOPSIS
  
    $ perl -Mojo -E 'say g("mojolicious.org")->dom->at("title")->text'
  
  =head1 DESCRIPTION
  
  A collection of automatically exported functions for fun Perl one-liners. Ten
  redirects will be followed by default, you can change this behavior with the
  C<MOJO_MAX_REDIRECTS> environment variable.
  
    $ MOJO_MAX_REDIRECTS=0 perl -Mojo -E 'say g("example.com")->code'
  
  Proxy detection is enabled by default, but you can disable it with the
  C<MOJO_PROXY> environment variable.
  
    $ MOJO_PROXY=0 perl -Mojo -E 'say g("example.com")->body'
  
  TLS certificate verification can be disabled with the C<MOJO_INSECURE>
  environment variable.
  
    $ MOJO_INSECURE=1 perl -Mojo -E 'say g("https://127.0.0.1:3000")->body'
  
  Every L<ojo> one-liner is also a L<Mojolicious::Lite> application.
  
    $ perl -Mojo -E 'get "/" => {inline => "%= time"}; app->start' get /
  
  On Perl 5.20+ L<subroutine signatures|perlsub/"Signatures"> will be enabled
  automatically.
  
    $ perl -Mojo -E 'a(sub ($c) { $c->render(text => 'Hello!') })->start' get /
  
  If it is not already defined, the C<MOJO_LOG_LEVEL> environment variable will
  be set to C<fatal>.
  
  =head1 FUNCTIONS
  
  L<ojo> implements the following functions, which are automatically exported.
  
  =head2 a
  
    my $app = a('/hello' => sub { $_->render(json => {hello => 'world'}) });
  
  Create a route with L<Mojolicious::Lite/"any"> and return the current
  L<Mojolicious::Lite> object. The current controller object is also available to
  actions as C<$_>. See also L<Mojolicious::Guides::Tutorial> for more argument
  variations.
  
    $ perl -Mojo -E 'a("/hello" => {text => "Hello Mojo!"})->start' daemon
  
  =head2 b
  
    my $stream = b('lalala');
  
  Turn string into a L<Mojo::ByteStream> object.
  
    $ perl -Mojo -E 'b(g("mojolicious.org")->body)->html_unescape->say'
  
  =head2 c
  
    my $collection = c(1, 2, 3);
  
  Turn list into a L<Mojo::Collection> object.
  
  =head2 d
  
    my $res = d('example.com');
    my $res = d('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = d('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = d('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<DELETE> request with L<Mojo::UserAgent/"delete"> and return resulting
  L<Mojo::Message::Response> object.
  
  =head2 f
  
    my $path = f('/home/sri/foo.txt');
  
  Turn string into a L<Mojo::File> object.
  
    $ perl -Mojo -E 'say r j f("hello.json")->slurp'
  
  =head2 g
  
    my $res = g('example.com');
    my $res = g('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = g('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = g('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<GET> request with L<Mojo::UserAgent/"get"> and return resulting
  L<Mojo::Message::Response> object.
  
    $ perl -Mojo -E 'say g("mojolicious.org")->dom("h1")->map("text")->join("\n")'
  
  =head2 h
  
    my $res = h('example.com');
    my $res = h('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = h('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = h('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<HEAD> request with L<Mojo::UserAgent/"head"> and return resulting
  L<Mojo::Message::Response> object.
  
  =head2 j
  
    my $bytes = j([1, 2, 3]);
    my $bytes = j({foo => 'bar'});
    my $value = j($bytes);
  
  Encode Perl data structure or decode JSON with L<Mojo::JSON/"j">.
  
    $ perl -Mojo -E 'f("hello.json")->spurt(j {hello => "world!"})'
  
  =head2 n
  
    n {...};
    n {...} 100;
  
  Benchmark block and print the results to C<STDERR>, with an optional number of
  iterations, which defaults to C<1>.
  
    $ perl -Mojo -E 'n { say g("mojolicious.org")->code }'
  
  =head2 o
  
    my $res = o('example.com');
    my $res = o('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = o('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = o('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<OPTIONS> request with L<Mojo::UserAgent/"options"> and return
  resulting L<Mojo::Message::Response> object.
  
  =head2 p
  
    my $res = p('example.com');
    my $res = p('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = p('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = p('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<POST> request with L<Mojo::UserAgent/"post"> and return resulting
  L<Mojo::Message::Response> object.
  
  =head2 r
  
    my $perl = r({data => 'structure'});
  
  Dump a Perl data structure with L<Mojo::Util/"dumper">.
  
    perl -Mojo -E 'say r g("example.com")->headers->to_hash'
  
  =head2 t
  
    my $res = t('example.com');
    my $res = t('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = t('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = t('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<PATCH> request with L<Mojo::UserAgent/"patch"> and return resulting
  L<Mojo::Message::Response> object.
  
  =head2 u
  
    my $res = u('example.com');
    my $res = u('http://example.com' => {Accept => '*/*'} => 'Hi!');
    my $res = u('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
    my $res = u('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});
  
  Perform C<PUT> request with L<Mojo::UserAgent/"put"> and return resulting
  L<Mojo::Message::Response> object.
  
  =head2 x
  
    my $dom = x('<div>Hello!</div>');
  
  Turn HTML/XML input into L<Mojo::DOM> object.
  
    $ perl -Mojo -E 'say x(f("test.html")->slurp)->at("title")->text'
  
  =head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.
  
  =cut
OJO

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use Mojo::Base -strict;

use Mojolicious::Commands;

Mojolicious::Commands->start_app('Mojo::HelloWorld');

=encoding utf8

=head1 NAME

mojo - The Mojolicious command system

=head1 SYNOPSIS

  $ mojo --help

=head1 DESCRIPTION

List and run L<Mojolicious> commands as described in
L<Mojolicious::Commands>.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
