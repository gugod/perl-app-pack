#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Data/OptList.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_OPTLIST';
  use strict;
  use warnings;
  package Data::OptList;
  # ABSTRACT: parse and validate simple name/value option pairs
  $Data::OptList::VERSION = '0.110';
  use List::Util ();
  use Params::Util ();
  use Sub::Install 0.921 ();
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   use Data::OptList;
  #pod
  #pod   my $options = Data::OptList::mkopt([
  #pod     qw(key1 key2 key3 key4),
  #pod     key5 => { ... },
  #pod     key6 => [ ... ],
  #pod     key7 => sub { ... },
  #pod     key8 => { ... },
  #pod     key8 => [ ... ],
  #pod   ]);
  #pod
  #pod ...is the same thing, more or less, as:
  #pod
  #pod   my $options = [
  #pod     [ key1 => undef,        ],
  #pod     [ key2 => undef,        ],
  #pod     [ key3 => undef,        ],
  #pod     [ key4 => undef,        ],
  #pod     [ key5 => { ... },      ],
  #pod     [ key6 => [ ... ],      ],
  #pod     [ key7 => sub { ... },  ],
  #pod     [ key8 => { ... },      ],
  #pod     [ key8 => [ ... ],      ],
  #pod   ]);
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod Hashes are great for storing named data, but if you want more than one entry
  #pod for a name, you have to use a list of pairs.  Even then, this is really boring
  #pod to write:
  #pod
  #pod   $values = [
  #pod     foo => undef,
  #pod     bar => undef,
  #pod     baz => undef,
  #pod     xyz => { ... },
  #pod   ];
  #pod
  #pod Just look at all those undefs!  Don't worry, we can get rid of those:
  #pod
  #pod   $values = [
  #pod     map { $_ => undef } qw(foo bar baz),
  #pod     xyz => { ... },
  #pod   ];
  #pod
  #pod Aaaauuugh!  We've saved a little typing, but now it requires thought to read,
  #pod and thinking is even worse than typing... and it's got a bug!  It looked right,
  #pod didn't it?  Well, the C<< xyz => { ... } >> gets consumed by the map, and we
  #pod don't get the data we wanted.
  #pod
  #pod With Data::OptList, you can do this instead:
  #pod
  #pod   $values = Data::OptList::mkopt([
  #pod     qw(foo bar baz),
  #pod     xyz => { ... },
  #pod   ]);
  #pod
  #pod This works by assuming that any defined scalar is a name and any reference
  #pod following a name is its value.
  #pod
  #pod =func mkopt
  #pod
  #pod   my $opt_list = Data::OptList::mkopt($input, \%arg);
  #pod
  #pod Valid arguments are:
  #pod
  #pod   moniker        - a word used in errors to describe the opt list; encouraged
  #pod   require_unique - if true, no name may appear more than once
  #pod   must_be        - types to which opt list values are limited (described below)
  #pod   name_test      - a coderef used to test whether a value can be a name
  #pod                    (described below, but you probably don't want this)
  #pod
  #pod This produces an array of arrays; the inner arrays are name/value pairs.
  #pod Values will be either "undef" or a reference.
  #pod
  #pod Positional parameters may be used for compatibility with the old C<mkopt>
  #pod interface:
  #pod
  #pod   my $opt_list = Data::OptList::mkopt($input, $moniker, $req_uni, $must_be);
  #pod
  #pod Valid values for C<$input>:
  #pod
  #pod  undef    -> []
  #pod  hashref  -> [ [ key1 => value1 ] ... ] # non-ref values become undef
  #pod  arrayref -> every name followed by a non-name becomes a pair: [ name => ref ]
  #pod              every name followed by undef becomes a pair: [ name => undef ]
  #pod              otherwise, it becomes [ name => undef ] like so:
  #pod              [ "a", "b", [ 1, 2 ] ] -> [ [ a => undef ], [ b => [ 1, 2 ] ] ]
  #pod
  #pod By default, a I<name> is any defined non-reference.  The C<name_test> parameter
  #pod can be a code ref that tests whether the argument passed it is a name or not.
  #pod This should be used rarely.  Interactions between C<require_unique> and
  #pod C<name_test> are not yet particularly elegant, as C<require_unique> just tests
  #pod string equality.  B<This may change.>
  #pod
  #pod The C<must_be> parameter is either a scalar or array of scalars; it defines
  #pod what kind(s) of refs may be values.  If an invalid value is found, an exception
  #pod is thrown.  If no value is passed for this argument, any reference is valid.
  #pod If C<must_be> specifies that values must be CODE, HASH, ARRAY, or SCALAR, then
  #pod Params::Util is used to check whether the given value can provide that
  #pod interface.  Otherwise, it checks that the given value is an object of the kind.
  #pod
  #pod In other words:
  #pod
  #pod   [ qw(SCALAR HASH Object::Known) ]
  #pod
  #pod Means:
  #pod
  #pod   _SCALAR0($value) or _HASH($value) or _INSTANCE($value, 'Object::Known')
  #pod
  #pod =cut
  
  my %test_for;
  BEGIN {
    %test_for = (
      CODE   => \&Params::Util::_CODELIKE,  ## no critic
      HASH   => \&Params::Util::_HASHLIKE,  ## no critic
      ARRAY  => \&Params::Util::_ARRAYLIKE, ## no critic
      SCALAR => \&Params::Util::_SCALAR0,   ## no critic
    );
  }
  
  sub mkopt {
    my ($opt_list) = shift;
  
    my ($moniker, $require_unique, $must_be); # the old positional args
    my ($name_test, $is_a);
  
    if (@_) {
      if (@_ == 1 and Params::Util::_HASHLIKE($_[0])) {
        ($moniker, $require_unique, $must_be, $name_test)
          = @{$_[0]}{ qw(moniker require_unique must_be name_test) };
      } else {
        ($moniker, $require_unique, $must_be) = @_;
      }
  
      # Transform the $must_be specification into a closure $is_a
      # that will check if a value matches the spec
  
      if (defined $must_be) {
        $must_be = [ $must_be ] unless ref $must_be;
        my @checks = map {
            my $class = $_;
            $test_for{$_}
            || sub { $_[1] = $class; goto \&Params::Util::_INSTANCE }
        } @$must_be;
  
        $is_a = (@checks == 1)
              ? $checks[0]
              : sub {
                  my $value = $_[0];
                  List::Util::first { defined($_->($value)) } @checks
                };
  
        $moniker = 'unnamed' unless defined $moniker;
      }
    }
  
    return [] unless $opt_list;
  
    $name_test ||= sub { ! ref $_[0] };
  
    $opt_list = [
      map { $_ => (ref $opt_list->{$_} ? $opt_list->{$_} : ()) } keys %$opt_list
    ] if ref $opt_list eq 'HASH';
  
    my @return;
    my %seen;
  
    for (my $i = 0; $i < @$opt_list; $i++) { ## no critic
      my $name = $opt_list->[$i];
  
      if ($require_unique) {
        Carp::croak "multiple definitions provided for $name" if $seen{$name}++;
      }
  
      my $value;
  
      if ($i < $#$opt_list) {
        if (not defined $opt_list->[$i+1]) {
          $i++
        } elsif (! $name_test->($opt_list->[$i+1])) {
          $value = $opt_list->[++$i];
          if ($is_a && !$is_a->($value)) {
            my $ref = ref $value;
            Carp::croak "$ref-ref values are not valid in $moniker opt list";
          }
        }
      }
  
      push @return, [ $name => $value ];
    }
  
    return \@return;
  }
  
  #pod =func mkopt_hash
  #pod
  #pod   my $opt_hash = Data::OptList::mkopt_hash($input, $moniker, $must_be);
  #pod
  #pod Given valid C<L</mkopt>> input, this routine returns a reference to a hash.  It
  #pod will throw an exception if any name has more than one value.
  #pod
  #pod =cut
  
  sub mkopt_hash {
    my ($opt_list, $moniker, $must_be) = @_;
    return {} unless $opt_list;
  
    $opt_list = mkopt($opt_list, $moniker, 1, $must_be);
    my %hash = map { $_->[0] => $_->[1] } @$opt_list;
    return \%hash;
  }
  
  #pod =head1 EXPORTS
  #pod
  #pod Both C<mkopt> and C<mkopt_hash> may be exported on request.
  #pod
  #pod =cut
  
  BEGIN {
    *import = Sub::Install::exporter {
      exports => [qw(mkopt mkopt_hash)],
    };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Data::OptList - parse and validate simple name/value option pairs
  
  =head1 VERSION
  
  version 0.110
  
  =head1 SYNOPSIS
  
    use Data::OptList;
  
    my $options = Data::OptList::mkopt([
      qw(key1 key2 key3 key4),
      key5 => { ... },
      key6 => [ ... ],
      key7 => sub { ... },
      key8 => { ... },
      key8 => [ ... ],
    ]);
  
  ...is the same thing, more or less, as:
  
    my $options = [
      [ key1 => undef,        ],
      [ key2 => undef,        ],
      [ key3 => undef,        ],
      [ key4 => undef,        ],
      [ key5 => { ... },      ],
      [ key6 => [ ... ],      ],
      [ key7 => sub { ... },  ],
      [ key8 => { ... },      ],
      [ key8 => [ ... ],      ],
    ]);
  
  =head1 DESCRIPTION
  
  Hashes are great for storing named data, but if you want more than one entry
  for a name, you have to use a list of pairs.  Even then, this is really boring
  to write:
  
    $values = [
      foo => undef,
      bar => undef,
      baz => undef,
      xyz => { ... },
    ];
  
  Just look at all those undefs!  Don't worry, we can get rid of those:
  
    $values = [
      map { $_ => undef } qw(foo bar baz),
      xyz => { ... },
    ];
  
  Aaaauuugh!  We've saved a little typing, but now it requires thought to read,
  and thinking is even worse than typing... and it's got a bug!  It looked right,
  didn't it?  Well, the C<< xyz => { ... } >> gets consumed by the map, and we
  don't get the data we wanted.
  
  With Data::OptList, you can do this instead:
  
    $values = Data::OptList::mkopt([
      qw(foo bar baz),
      xyz => { ... },
    ]);
  
  This works by assuming that any defined scalar is a name and any reference
  following a name is its value.
  
  =head1 FUNCTIONS
  
  =head2 mkopt
  
    my $opt_list = Data::OptList::mkopt($input, \%arg);
  
  Valid arguments are:
  
    moniker        - a word used in errors to describe the opt list; encouraged
    require_unique - if true, no name may appear more than once
    must_be        - types to which opt list values are limited (described below)
    name_test      - a coderef used to test whether a value can be a name
                     (described below, but you probably don't want this)
  
  This produces an array of arrays; the inner arrays are name/value pairs.
  Values will be either "undef" or a reference.
  
  Positional parameters may be used for compatibility with the old C<mkopt>
  interface:
  
    my $opt_list = Data::OptList::mkopt($input, $moniker, $req_uni, $must_be);
  
  Valid values for C<$input>:
  
   undef    -> []
   hashref  -> [ [ key1 => value1 ] ... ] # non-ref values become undef
   arrayref -> every name followed by a non-name becomes a pair: [ name => ref ]
               every name followed by undef becomes a pair: [ name => undef ]
               otherwise, it becomes [ name => undef ] like so:
               [ "a", "b", [ 1, 2 ] ] -> [ [ a => undef ], [ b => [ 1, 2 ] ] ]
  
  By default, a I<name> is any defined non-reference.  The C<name_test> parameter
  can be a code ref that tests whether the argument passed it is a name or not.
  This should be used rarely.  Interactions between C<require_unique> and
  C<name_test> are not yet particularly elegant, as C<require_unique> just tests
  string equality.  B<This may change.>
  
  The C<must_be> parameter is either a scalar or array of scalars; it defines
  what kind(s) of refs may be values.  If an invalid value is found, an exception
  is thrown.  If no value is passed for this argument, any reference is valid.
  If C<must_be> specifies that values must be CODE, HASH, ARRAY, or SCALAR, then
  Params::Util is used to check whether the given value can provide that
  interface.  Otherwise, it checks that the given value is an object of the kind.
  
  In other words:
  
    [ qw(SCALAR HASH Object::Known) ]
  
  Means:
  
    _SCALAR0($value) or _HASH($value) or _INSTANCE($value, 'Object::Known')
  
  =head2 mkopt_hash
  
    my $opt_hash = Data::OptList::mkopt_hash($input, $moniker, $must_be);
  
  Given valid C<L</mkopt>> input, this routine returns a reference to a hash.  It
  will throw an exception if any name has more than one value.
  
  =head1 EXPORTS
  
  Both C<mkopt> and C<mkopt_hash> may be exported on request.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Olivier Mengué Ricardo SIGNES
  
  =over 4
  
  =item *
  
  Olivier Mengué <dolmen@cpan.org>
  
  =item *
  
  Ricardo SIGNES <rjbs@codesimply.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DATA_OPTLIST

$fatpacked{"Getopt/Long/Descriptive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG_DESCRIPTIVE';
  use strict;
  use warnings;
  package Getopt::Long::Descriptive;
  # ABSTRACT: Getopt::Long, but simpler and more powerful
  $Getopt::Long::Descriptive::VERSION = '0.102';
  use Carp qw(carp croak);
  use File::Basename ();
  use Getopt::Long 2.33;
  use List::Util qw(first);
  use Params::Validate 0.97 qw(:all);
  use Scalar::Util ();
  
  use Getopt::Long::Descriptive::Opts;
  use Getopt::Long::Descriptive::Usage;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   use Getopt::Long::Descriptive;
  #pod
  #pod   my ($opt, $usage) = describe_options(
  #pod     'my-program %o <some-arg>',
  #pod     [ 'server|s=s', "the server to connect to", { required => 1  } ],
  #pod     [ 'port|p=i',   "the port to connect to",   { default  => 79 } ],
  #pod     [],
  #pod     [ 'verbose|v',  "print extra stuff"            ],
  #pod     [ 'help',       "print usage message and exit", { shortcircuit => 1 } ],
  #pod   );
  #pod
  #pod   print($usage->text), exit if $opt->help;
  #pod
  #pod   Client->connect( $opt->server, $opt->port );
  #pod
  #pod   print "Connected!\n" if $opt->verbose;
  #pod
  #pod ...and running C<my-program --help> will produce:
  #pod
  #pod   my-program [-psv] [long options...] <some-arg>
  #pod     -s --server     the server to connect to
  #pod     -p --port       the port to connect to
  #pod
  #pod     -v --verbose    print extra stuff
  #pod     --help          print usage message and exit
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod Getopt::Long::Descriptive is yet another Getopt library.  It's built atop
  #pod Getopt::Long, and gets a lot of its features, but tries to avoid making you
  #pod think about its huge array of options.
  #pod
  #pod It also provides usage (help) messages, data validation, and a few other useful
  #pod features.
  #pod
  #pod =head1 FUNCTIONS
  #pod
  #pod Getopt::Long::Descriptive only exports one routine by default:
  #pod C<describe_options>.  All GLD's exports are exported by L<Sub::Exporter>.
  #pod
  #pod =head2 describe_options
  #pod
  #pod   my ($opt, $usage) = describe_options($usage_desc, @opt_spec, \%arg);
  #pod
  #pod This routine inspects C<@ARGV> for options that match the supplied spec. If all
  #pod the options are valid then it returns the options given and an object for
  #pod generating usage messages; if not then it dies with an explanation of what was
  #pod wrong and a usage message.
  #pod
  #pod The C<$opt> object will be a dynamically-generated subclass of
  #pod L<Getopt::Long::Descriptive::Opts>.  In brief, each of the options in
  #pod C<@opt_spec> becomes an accessor method on the object, using the first-given
  #pod name, with dashes converted to underscores.  For more information, see the
  #pod documentation for the Opts class.
  #pod
  #pod The C<$usage> object will be a L<Getopt::Long::Descriptive::Usage> object,
  #pod which provides a C<text> method to get the text of the usage message and C<die>
  #pod to die with it.  For more methods and options, consults the documentation for
  #pod the Usage class.
  #pod
  #pod =head3 $usage_desc
  #pod
  #pod The C<$usage_desc> parameter to C<describe_options> is a C<sprintf>-like string
  #pod that is used in generating the first line of the usage message.  It's a
  #pod one-line summary of how the command is to be invoked.  A typical usage
  #pod description might be:
  #pod
  #pod   $usage_desc = "%c %o <source> <desc>";
  #pod
  #pod C<%c> will be replaced with what Getopt::Long::Descriptive thinks is the
  #pod program name (it's computed from C<$0>, see L</prog_name>).
  #pod
  #pod C<%o> will be replaced with a list of the short options, as well as the text
  #pod "[long options...]" if any have been defined.
  #pod
  #pod The rest of the usage description can be used to summarize what arguments are
  #pod expected to follow the program's options, and is entirely free-form.
  #pod
  #pod Literal C<%> characters will need to be written as C<%%>, just like with
  #pod C<sprintf>.
  #pod
  #pod =head3 @opt_spec
  #pod
  #pod The C<@opt_spec> part of the args to C<describe_options> is used to configure
  #pod option parsing and to produce the usage message.  Each entry in the list is an
  #pod arrayref describing one option, like this:
  #pod
  #pod   @opt_spec = (
  #pod     [ "verbose|V" => "be noisy"       ],
  #pod     [ "logfile=s" => "file to log to" ],
  #pod   );
  #pod
  #pod The first value in the arrayref is a Getopt::Long-style option specification.
  #pod In brief, they work like this:  each one is a pipe-delimited list of names,
  #pod optionally followed by a type declaration.  Type declarations are '=x' or ':x',
  #pod where C<=> means a value is required and C<:> means it is optional.  I<x> may
  #pod be 's' to indicate a string is required, 'i' for an integer, or 'f' for a
  #pod number with a fractional part.  The type spec may end in C<@> to indicate that
  #pod the option may appear multiple times.
  #pod
  #pod For more information on how these work, see the L<Getopt::Long> documentation.
  #pod
  #pod The first name given should be the canonical name, as it will be used as the
  #pod accessor method on the C<$opt> object.  Dashes in the name will be converted to
  #pod underscores, and all letters will be lowercased.  For this reason, all options
  #pod should generally have a long-form name.
  #pod
  #pod The second value in the arrayref is a description of the option, for use in the
  #pod usage message.
  #pod
  #pod =head4 Special Option Specifications
  #pod
  #pod If the option specification (arrayref) is empty, it will have no effect other
  #pod than causing a blank line to appear in the usage message.
  #pod
  #pod If the option specification contains only one element, it will be printed in
  #pod the usage message with no other effect.
  #pod
  #pod If the option specification contains a third element, it adds extra constraints
  #pod or modifiers to the interpretation and validation of the value.  These are the
  #pod keys that may be present in that hashref, and how they behave:
  #pod
  #pod =over 4
  #pod
  #pod =item implies
  #pod
  #pod   implies => 'bar'
  #pod   implies => [qw(foo bar)]
  #pod   implies => { foo => 1, bar => 2 }
  #pod
  #pod If option I<A> has an "implies" entry, then if I<A> is given, other options
  #pod will be enabled.  The value may be a single option to set, an arrayref of
  #pod options to set, or a hashref of options to set to specific values.
  #pod
  #pod =item required
  #pod
  #pod   required => 1
  #pod
  #pod If an option is required, failure to provide the option will result in
  #pod C<describe_options> printing the usage message and exiting.
  #pod
  #pod =item hidden
  #pod
  #pod   hidden => 1
  #pod
  #pod This option will not show up in the usage text.
  #pod
  #pod You can achieve the same behavior by using the string "hidden" for the option's
  #pod description.
  #pod
  #pod =item one_of
  #pod
  #pod   one_of => \@subopt_specs
  #pod
  #pod This is useful for a group of options that are related.  Each option
  #pod spec is added to the list for normal parsing and validation.
  #pod
  #pod Your option name will end up with a value of the name of the
  #pod option that was chosen.  For example, given the following spec:
  #pod
  #pod   [ "mode" => hidden => { one_of => [
  #pod     [ "get|g"  => "get the value" ],
  #pod     [ "set|s"  => "set the value" ],
  #pod     [ "delete" => "delete it" ],
  #pod   ] } ],
  #pod
  #pod No usage text for 'mode' will be displayed, but text for get, set, and delete
  #pod will be displayed.
  #pod
  #pod If more than one of get, set, or delete is given, an error will be thrown.
  #pod
  #pod So, given the C<@opt_spec> above, and an C<@ARGV> of C<('--get')>, the
  #pod following would be true:
  #pod
  #pod   $opt->get == 1;
  #pod
  #pod   $opt->mode eq 'get';
  #pod
  #pod B<Note>: C<get> would not be set if C<mode> defaulted to 'get' and no arguments
  #pod were passed in.
  #pod
  #pod Even though the option sub-specs for C<one_of> are meant to be 'first
  #pod class' specs, some options don't make sense with them, e.g. C<required>.
  #pod
  #pod As a further shorthand, you may specify C<one_of> options using this form:
  #pod
  #pod   [ mode => \@option_specs, \%constraints ]
  #pod
  #pod
  #pod =item shortcircuit
  #pod
  #pod   shortcircuit => 1
  #pod
  #pod If this option is present no other options will be returned.  Other
  #pod options present will be checked for proper types, but I<not> for
  #pod constraints.  This provides a way of specifying C<--help> style options.
  #pod
  #pod =item Params::Validate
  #pod
  #pod In addition, any constraint understood by Params::Validate may be used.
  #pod
  #pod For example, to accept positive integers:
  #pod
  #pod   [ 'max-iterations=i', "maximum number of iterations",
  #pod     { callbacks => { positive => sub { shift() > 0 } } } ],
  #pod
  #pod (Internally, all constraints are translated into Params::Validate options or
  #pod callbacks.)
  #pod
  #pod =back
  #pod
  #pod =head3 %arg
  #pod
  #pod The C<%arg> to C<describe_options> is optional.  If the last parameter is a
  #pod hashref, it contains extra arguments to modify the way C<describe_options>
  #pod works.  Valid arguments are:
  #pod
  #pod   getopt_conf   - an arrayref of strings, passed to Getopt::Long::Configure
  #pod   show_defaults - a boolean which controls whether an option's default
  #pod                   value (if applicable) is shown as part of the usage message
  #pod                   (for backward compatibility this defaults to false)
  #pod
  #pod =head2 prog_name
  #pod
  #pod This routine, exported on demand, returns the basename of C<$0>, grabbed at
  #pod compile-time.  You can override this guess by calling C<prog_name($string)>
  #pod yourself.
  #pod
  #pod =head1 OTHER EXPORTS
  #pod
  #pod =head2 C<-types>
  #pod
  #pod Any of the Params::Validate type constants (C<SCALAR>, etc.) can be imported as
  #pod well.  You can get all of them at once by importing C<-types>.
  #pod
  #pod =head2 C<-all>
  #pod
  #pod This import group will import C<-type>, C<describe_options>, and C<prog_name>.
  #pod
  #pod =cut
  
  my $prog_name;
  sub prog_name { @_ ? ($prog_name = shift) : $prog_name }
  
  BEGIN {
    # grab this before someone decides to change it
    prog_name(File::Basename::basename($0));
  }
  
  use Sub::Exporter::Util ();
  use Sub::Exporter 0.972 -setup => {
    exports => [
      describe_options => \'_build_describe_options',
      q(prog_name),
      @{ $Params::Validate::EXPORT_TAGS{types} }
    ],
    groups  => [
      default => [ qw(describe_options) ],
      types   => $Params::Validate::EXPORT_TAGS{types},
    ],
  };
  
  my %CONSTRAINT = (
    implies  => \&_mk_implies,
    required => { optional => 0 },
    only_one => \&_mk_only_one,
  );
  
  our $MungeOptions = 1;
  
  sub _nohidden {
    return grep { ! $_->{constraint}->{hidden} } @_;
  }
  
  sub _expand {
    my @expanded;
  
    for my $opt (@_) {
      push @expanded, {
        spec       => $opt->[0] || '',
        desc       => @$opt > 1 ? $opt->[1] : 'spacer',
        constraint => $opt->[2] || {},
  
        # if @$_ is 0 then we got [], a spacer
        name       => @$opt ? _munge((split /[:=|!+]/, $opt->[0] || '')[0]) : '',
      };
    }
  
    return @expanded;
  }
  
  my %HIDDEN = (
    hidden => 1,
  );
  
  my $SPEC_RE = qr{(?:[:=][0-9\w\+]+[%@]?(\{[0-9]*,[0-9]*\})?|[!+])$};
  sub _strip_assignment {
    my ($self, $str) = @_;
  
    (my $copy = $str) =~ s{$SPEC_RE}{};
  
    if (wantarray) {
        my $len = length $copy;
        my $assignment = substr $str, $len;
        if (!defined($assignment)) {
            $assignment = '';
        }
        return ($copy, $assignment);
    }
    return $copy;
  }
  
  # This is here only to deal with people who were calling this fully-qualified
  # without importing.  Sucks to them!  -- rjbs, 2009-08-21
  sub describe_options {
    my $sub = __PACKAGE__->_build_describe_options(describe_options => {} => {});
    $sub->(@_);
  }
  
  sub usage_class { 'Getopt::Long::Descriptive::Usage' }
  
  sub _build_describe_options {
    my ($class) = @_;
  
    sub {
      my $format = shift;
      my $arg    = (ref $_[-1] and ref $_[-1] eq 'HASH') ? pop @_ : {};
      my @opts;
  
      my %parent_of;
  
      # special casing
      # wish we had real loop objects
      my %method_map;
      for my $opt (_expand(@_)) {
        $method_map{ $opt->{name} } = undef unless $opt->{desc} eq 'spacer';
  
        if (ref($opt->{desc}) eq 'ARRAY') {
          $opt->{constraint}->{one_of} = delete $opt->{desc};
          $opt->{desc} = 'hidden';
        }
  
        if ($HIDDEN{$opt->{desc}}) {
          $opt->{constraint}->{hidden}++;
        }
  
        if ($opt->{constraint}->{one_of}) {
          for my $one_opt (_expand(
            @{delete $opt->{constraint}->{one_of}}
          )) {
            $parent_of{$one_opt->{name}} = $opt->{name};
            $one_opt->{constraint}->{implies}
              ->{$opt->{name}} = $one_opt->{name};
            for my $wipe (qw(required default)) {
              if ($one_opt->{constraint}->{$wipe}) {
                carp "'$wipe' constraint does not make sense in sub-option";
                delete $one_opt->{constraint}->{$wipe};
              }
            }
            $one_opt->{constraint}->{one_of} = $opt->{name};
            push @opts, $one_opt;
          }
        }
  
        if ($opt->{constraint}{shortcircuit}
          && exists $opt->{constraint}{default}
        ) {
          carp('option "' . $opt->{name} . q[": 'default' does not make sense for shortcircuit options]);
        }
  
        push @opts, $opt;
      }
  
      my @go_conf = @{ $arg->{getopt_conf} || $arg->{getopt} || [] };
      if ($arg->{getopt}) {
        warn "describe_options: 'getopt' is deprecated, please use 'getopt_conf' instead\n";
      }
  
      push @go_conf, "bundling" unless grep { /bundling/i } @go_conf;
      push @go_conf, "no_auto_help"  unless grep { /no_auto_help/i } @go_conf;
      push @go_conf, "no_ignore_case"
        unless grep { /no_ignore_case/i } @go_conf;
  
      # not entirely sure that all of this (until the Usage->new) shouldn't be
      # moved into Usage -- rjbs, 2009-08-19
  
      # all specs including hidden
      my @getopt_specs =
        map  { $_->{spec} }
        grep { $_->{desc} ne 'spacer' }
        @opts;
  
      my @specs =
        map  { $_->{spec} }
        grep { $_->{desc} ne 'spacer' }
        _nohidden(@opts);
  
      my $short = join q{},
        sort  { lc $a cmp lc $b or $a cmp $b }
        grep  { /^.$/ }
        map   { split /\|/ }
        map   { scalar __PACKAGE__->_strip_assignment($_) }
        @specs;
  
      my $long = grep /\b[^|]{2,}/, @specs;
  
      my %replace = (
        "%" => "%",
        "c" => prog_name,
        "o" => join(q{ },
          ($short ? "[-$short]" : ()),
          ($long  ? "[long options...]" : ())
        ),
      );
  
      (my $str = $format) =~ s<%(.)><
        defined $replace{$1}
        ? $replace{$1}
        : Carp::croak("unknown sequence %$1 in first argument to describe_options")
      >ge;
  
      $str =~ s/[\x20\t]{2,}/ /g;
  
      my $usage = $class->usage_class->new({
        options       => [ _nohidden(@opts) ],
        leader_text   => $str,
        show_defaults => $arg->{show_defaults},
      });
  
      Getopt::Long::Configure(@go_conf);
  
      my %return;
      $usage->die unless GetOptions(\%return, grep { length } @getopt_specs);
      my @given_keys = keys %return;
  
      for my $opt (keys %return) {
        my $newopt = _munge($opt);
        next if $newopt eq $opt;
        $return{$newopt} = delete $return{$opt};
      }
  
      # ensure that shortcircuit options are handled first
      for my $copt (
        sort {     ($b->{constraint}{shortcircuit} || 0)
               <=> ($a->{constraint}{shortcircuit} || 0)
             } grep { $_->{constraint} } @opts
      ) {
        delete $copt->{constraint}->{hidden};
        my $is_shortcircuit = delete $copt->{constraint}{shortcircuit};
        my $name = $copt->{name};
        my $new  = _validate_with(
          name   => $name,
          params => \%return,
          spec   => $copt->{constraint},
          opts   => \@opts,
          usage  => $usage,
          given_keys => \@given_keys,
          parent_of  => \%parent_of,
        );
        next unless (defined($new) || exists($return{$name}));
        $return{$name} = $new;
  
        if ($is_shortcircuit) {
          %return = ($name => $return{$name});
          last;
        }
      }
  
      my $opt_obj = Getopt::Long::Descriptive::Opts->___new_opt_obj({
        values => { %method_map, %return },
        given  => { map {; $_ => 1 } @given_keys },
      });
  
      return($opt_obj, $usage);
    }
  }
  
  sub _munge {
    my ($opt) = @_;
    return $opt unless $MungeOptions;
    $opt = lc($opt);
    $opt =~ tr/-/_/;
    return $opt;
  }
  
  sub _validate_with {
    my (%arg) = validate(@_, {
      name   => 1,
      params => 1,
      spec   => 1,
      opts   => 1,
      usage  => 1,
      given_keys => 1,
      parent_of  => 1,
    });
  
    my $spec = $arg{spec};
    my %pvspec;
    for my $ct (keys %{$spec}) {
      if ($CONSTRAINT{$ct} and ref $CONSTRAINT{$ct} eq 'CODE') {
        $pvspec{callbacks} ||= {};
        $pvspec{callbacks} = {
          %{$pvspec{callbacks}},
          $CONSTRAINT{$ct}->(
            $arg{name},
            $spec->{$ct},
            $arg{params},
            $arg{opts},
          ),
        };
      } else {
        %pvspec = (
          %pvspec,
          $CONSTRAINT{$ct} ? %{$CONSTRAINT{$ct}} : ($ct => $spec->{$ct}),
        );
      }
    }
  
    $pvspec{optional} = 1 unless exists $pvspec{optional};
  
    # we need to implement 'default' by ourselves sometimes
    # because otherwise the implies won't be checked/executed
    # XXX this should be more generic -- we'll probably want
    # other callbacks to always run, too
    if (!defined($arg{params}{$arg{name}})
          && $pvspec{default}
            && $spec->{implies}) {
  
      $arg{params}{$arg{name}} = delete $pvspec{default};
    }
  
    my %p;
    my $ok = eval {
      %p = validate_with(
        params => [
          %{$arg{params}},
          '-given_keys', $arg{given_keys},
          '-parent_of',  $arg{parent_of},
        ],
        spec   => { $arg{name} => \%pvspec },
        allow_extra => 1,
        on_fail     => sub {
          my $fail_msg = shift;
          Getopt::Long::Descriptive::_PV_Error->throw($fail_msg);
        },
      );
      1;
    };
  
    if (! $ok) {
      my $error = $@;
      if (
        Scalar::Util::blessed($error)
        && $error->isa('Getopt::Long::Descriptive::_PV_Error')
      ) {
        $arg{usage}->die({ pre_text => $error->error . "\n" });
      }
  
      die $@;
    }
  
    return $p{$arg{name}};
  }
  
  # scalar:   single option = true
  # arrayref: multiple options = true
  # hashref:  single/multiple options = given values
  sub _norm_imply {
    my ($what) = @_;
  
    return { $what => 1 } unless my $ref = ref $what;
  
    return $what                      if $ref eq 'HASH';
    return { map { $_ => 1 } @$what } if $ref eq 'ARRAY';
  
    die "can't imply: $what";
  }
  
  sub _mk_implies {
    my $name = shift;
    my $what = _norm_imply(shift);
    my $param = shift;
    my $opts  = shift;
  
    for my $implied (keys %$what) {
      die("option specification for $name implies nonexistent option $implied\n")
        unless first { $_->{name} eq $implied } @$opts
    }
  
    my $whatstr = join(q{, }, map { "$_=$what->{$_}" } keys %$what);
  
    return "$name implies $whatstr" => sub {
      my ($pv_val, $rest) = @_;
  
      # negatable options will be 0 here, which is ok.
      return 1 unless defined $pv_val;
  
      while (my ($key, $val) = each %$what) {
        # Really, this should be called "-implies" and should include all implies
        # relationships, but they'll have to get handled by setting conflicts.
        my $parent   = $rest->{'-parent_of'}{$name};
        my @siblings = $parent
                     ? (grep {; defined $rest->{'-parent_of'}{$_}
                                && $rest->{'-parent_of'}{$_} eq $parent }
                        @{ $rest->{'-given_keys'} })
                     : ();
  
        if (@siblings > 1) {
          die "these options conflict; each wants to set the $parent: @siblings\n";
        }
  
        if (  exists $param->{$key}
          and $param->{$key} ne $val
          and grep {; $_ eq $key } @{ $rest->{'-given_keys'} }
        ) {
          die(
            "option specification for $name implies that $key should be "
            . "set to '$val', but it is '$param->{$key}' already\n"
          );
        }
        $param->{$key} = $val;
      }
  
      return 1;
    };
  }
  
  sub _mk_only_one {
    die "unimplemented";
  }
  
  {
    package
      Getopt::Long::Descriptive::_PV_Error;
    sub error { $_[0]->{error} }
    sub throw {
      my ($class, $error_msg) = @_;
      my $self = { error => $error_msg };
      bless $self, $class;
      die $self;
    }
  }
  
  #pod =head1 CUSTOMIZING
  #pod
  #pod Getopt::Long::Descriptive uses L<Sub::Exporter|Sub::Exporter> to build and
  #pod export the C<describe_options> routine.  By writing a new class that extends
  #pod Getopt::Long::Descriptive, the behavior of the constructed C<describe_options>
  #pod routine can be changed.
  #pod
  #pod The following methods can be overridden:
  #pod
  #pod =head2 usage_class
  #pod
  #pod   my $class = Getopt::Long::Descriptive->usage_class;
  #pod
  #pod This returns the class to be used for constructing a Usage object, and defaults
  #pod to Getopt::Long::Descriptive::Usage.
  #pod
  #pod =head1 SEE ALSO
  #pod
  #pod =for :list
  #pod * L<Getopt::Long>
  #pod * L<Params::Validate>
  #pod
  #pod =cut
  
  1; # End of Getopt::Long::Descriptive
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Getopt::Long::Descriptive - Getopt::Long, but simpler and more powerful
  
  =head1 VERSION
  
  version 0.102
  
  =head1 SYNOPSIS
  
    use Getopt::Long::Descriptive;
  
    my ($opt, $usage) = describe_options(
      'my-program %o <some-arg>',
      [ 'server|s=s', "the server to connect to", { required => 1  } ],
      [ 'port|p=i',   "the port to connect to",   { default  => 79 } ],
      [],
      [ 'verbose|v',  "print extra stuff"            ],
      [ 'help',       "print usage message and exit", { shortcircuit => 1 } ],
    );
  
    print($usage->text), exit if $opt->help;
  
    Client->connect( $opt->server, $opt->port );
  
    print "Connected!\n" if $opt->verbose;
  
  ...and running C<my-program --help> will produce:
  
    my-program [-psv] [long options...] <some-arg>
      -s --server     the server to connect to
      -p --port       the port to connect to
  
      -v --verbose    print extra stuff
      --help          print usage message and exit
  
  =head1 DESCRIPTION
  
  Getopt::Long::Descriptive is yet another Getopt library.  It's built atop
  Getopt::Long, and gets a lot of its features, but tries to avoid making you
  think about its huge array of options.
  
  It also provides usage (help) messages, data validation, and a few other useful
  features.
  
  =head1 FUNCTIONS
  
  Getopt::Long::Descriptive only exports one routine by default:
  C<describe_options>.  All GLD's exports are exported by L<Sub::Exporter>.
  
  =head2 describe_options
  
    my ($opt, $usage) = describe_options($usage_desc, @opt_spec, \%arg);
  
  This routine inspects C<@ARGV> for options that match the supplied spec. If all
  the options are valid then it returns the options given and an object for
  generating usage messages; if not then it dies with an explanation of what was
  wrong and a usage message.
  
  The C<$opt> object will be a dynamically-generated subclass of
  L<Getopt::Long::Descriptive::Opts>.  In brief, each of the options in
  C<@opt_spec> becomes an accessor method on the object, using the first-given
  name, with dashes converted to underscores.  For more information, see the
  documentation for the Opts class.
  
  The C<$usage> object will be a L<Getopt::Long::Descriptive::Usage> object,
  which provides a C<text> method to get the text of the usage message and C<die>
  to die with it.  For more methods and options, consults the documentation for
  the Usage class.
  
  =head3 $usage_desc
  
  The C<$usage_desc> parameter to C<describe_options> is a C<sprintf>-like string
  that is used in generating the first line of the usage message.  It's a
  one-line summary of how the command is to be invoked.  A typical usage
  description might be:
  
    $usage_desc = "%c %o <source> <desc>";
  
  C<%c> will be replaced with what Getopt::Long::Descriptive thinks is the
  program name (it's computed from C<$0>, see L</prog_name>).
  
  C<%o> will be replaced with a list of the short options, as well as the text
  "[long options...]" if any have been defined.
  
  The rest of the usage description can be used to summarize what arguments are
  expected to follow the program's options, and is entirely free-form.
  
  Literal C<%> characters will need to be written as C<%%>, just like with
  C<sprintf>.
  
  =head3 @opt_spec
  
  The C<@opt_spec> part of the args to C<describe_options> is used to configure
  option parsing and to produce the usage message.  Each entry in the list is an
  arrayref describing one option, like this:
  
    @opt_spec = (
      [ "verbose|V" => "be noisy"       ],
      [ "logfile=s" => "file to log to" ],
    );
  
  The first value in the arrayref is a Getopt::Long-style option specification.
  In brief, they work like this:  each one is a pipe-delimited list of names,
  optionally followed by a type declaration.  Type declarations are '=x' or ':x',
  where C<=> means a value is required and C<:> means it is optional.  I<x> may
  be 's' to indicate a string is required, 'i' for an integer, or 'f' for a
  number with a fractional part.  The type spec may end in C<@> to indicate that
  the option may appear multiple times.
  
  For more information on how these work, see the L<Getopt::Long> documentation.
  
  The first name given should be the canonical name, as it will be used as the
  accessor method on the C<$opt> object.  Dashes in the name will be converted to
  underscores, and all letters will be lowercased.  For this reason, all options
  should generally have a long-form name.
  
  The second value in the arrayref is a description of the option, for use in the
  usage message.
  
  =head4 Special Option Specifications
  
  If the option specification (arrayref) is empty, it will have no effect other
  than causing a blank line to appear in the usage message.
  
  If the option specification contains only one element, it will be printed in
  the usage message with no other effect.
  
  If the option specification contains a third element, it adds extra constraints
  or modifiers to the interpretation and validation of the value.  These are the
  keys that may be present in that hashref, and how they behave:
  
  =over 4
  
  =item implies
  
    implies => 'bar'
    implies => [qw(foo bar)]
    implies => { foo => 1, bar => 2 }
  
  If option I<A> has an "implies" entry, then if I<A> is given, other options
  will be enabled.  The value may be a single option to set, an arrayref of
  options to set, or a hashref of options to set to specific values.
  
  =item required
  
    required => 1
  
  If an option is required, failure to provide the option will result in
  C<describe_options> printing the usage message and exiting.
  
  =item hidden
  
    hidden => 1
  
  This option will not show up in the usage text.
  
  You can achieve the same behavior by using the string "hidden" for the option's
  description.
  
  =item one_of
  
    one_of => \@subopt_specs
  
  This is useful for a group of options that are related.  Each option
  spec is added to the list for normal parsing and validation.
  
  Your option name will end up with a value of the name of the
  option that was chosen.  For example, given the following spec:
  
    [ "mode" => hidden => { one_of => [
      [ "get|g"  => "get the value" ],
      [ "set|s"  => "set the value" ],
      [ "delete" => "delete it" ],
    ] } ],
  
  No usage text for 'mode' will be displayed, but text for get, set, and delete
  will be displayed.
  
  If more than one of get, set, or delete is given, an error will be thrown.
  
  So, given the C<@opt_spec> above, and an C<@ARGV> of C<('--get')>, the
  following would be true:
  
    $opt->get == 1;
  
    $opt->mode eq 'get';
  
  B<Note>: C<get> would not be set if C<mode> defaulted to 'get' and no arguments
  were passed in.
  
  Even though the option sub-specs for C<one_of> are meant to be 'first
  class' specs, some options don't make sense with them, e.g. C<required>.
  
  As a further shorthand, you may specify C<one_of> options using this form:
  
    [ mode => \@option_specs, \%constraints ]
  
  =item shortcircuit
  
    shortcircuit => 1
  
  If this option is present no other options will be returned.  Other
  options present will be checked for proper types, but I<not> for
  constraints.  This provides a way of specifying C<--help> style options.
  
  =item Params::Validate
  
  In addition, any constraint understood by Params::Validate may be used.
  
  For example, to accept positive integers:
  
    [ 'max-iterations=i', "maximum number of iterations",
      { callbacks => { positive => sub { shift() > 0 } } } ],
  
  (Internally, all constraints are translated into Params::Validate options or
  callbacks.)
  
  =back
  
  =head3 %arg
  
  The C<%arg> to C<describe_options> is optional.  If the last parameter is a
  hashref, it contains extra arguments to modify the way C<describe_options>
  works.  Valid arguments are:
  
    getopt_conf   - an arrayref of strings, passed to Getopt::Long::Configure
    show_defaults - a boolean which controls whether an option's default
                    value (if applicable) is shown as part of the usage message
                    (for backward compatibility this defaults to false)
  
  =head2 prog_name
  
  This routine, exported on demand, returns the basename of C<$0>, grabbed at
  compile-time.  You can override this guess by calling C<prog_name($string)>
  yourself.
  
  =head1 OTHER EXPORTS
  
  =head2 C<-types>
  
  Any of the Params::Validate type constants (C<SCALAR>, etc.) can be imported as
  well.  You can get all of them at once by importing C<-types>.
  
  =head2 C<-all>
  
  This import group will import C<-type>, C<describe_options>, and C<prog_name>.
  
  =head1 CUSTOMIZING
  
  Getopt::Long::Descriptive uses L<Sub::Exporter|Sub::Exporter> to build and
  export the C<describe_options> routine.  By writing a new class that extends
  Getopt::Long::Descriptive, the behavior of the constructed C<describe_options>
  routine can be changed.
  
  The following methods can be overridden:
  
  =head2 usage_class
  
    my $class = Getopt::Long::Descriptive->usage_class;
  
  This returns the class to be used for constructing a Usage object, and defaults
  to Getopt::Long::Descriptive::Usage.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<Getopt::Long>
  
  =item *
  
  L<Params::Validate>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Hans Dieter Pearcey <hdp@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Arthur Axel 'fREW' Schmidt Dave Rolsky Diab Jerius Hans Dieter Pearcey Harley Pig hdp@cpan.org Karen Etheridge Niels Thykier Olaf Alders Roman Hubacek Smylers Thomas Neumann zhouzhen1
  
  =over 4
  
  =item *
  
  Arthur Axel 'fREW' Schmidt <frioux@gmail.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Diab Jerius <djerius@cfa.harvard.edu>
  
  =item *
  
  Hans Dieter Pearcey <hdp@pobox.com>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Harley Pig <harleypig@gmail.com>
  
  =item *
  
  hdp@cpan.org <hdp@cpan.org@fc0e91e4-031c-0410-8307-be39b06d7656>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Niels Thykier <niels@thykier.net>
  
  =item *
  
  Olaf Alders <olaf@wundersolutions.com>
  
  =item *
  
  Roman Hubacek <roman.hubacek@centrum.cz>
  
  =item *
  
  Smylers <SMYLERS@cpan.fsck.com>
  
  =item *
  
  Thomas Neumann <blacky+perl@fluffbunny.de>
  
  =item *
  
  zhouzhen1 <zhouzhen1@gmail.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2005 by Hans Dieter Pearcey.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
GETOPT_LONG_DESCRIPTIVE

$fatpacked{"Getopt/Long/Descriptive/Opts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG_DESCRIPTIVE_OPTS';
  use strict;
  use warnings;
  package Getopt::Long::Descriptive::Opts;
  # ABSTRACT: object representing command line switches
  $Getopt::Long::Descriptive::Opts::VERSION = '0.102';
  use Scalar::Util qw(blessed weaken);
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This class is the base class of all C<$opt> objects returned by
  #pod L<Getopt::Long::Descriptive>.  In general, you do not want to think about this
  #pod class, look at it, or alter it.  Seriously, it's pretty dumb.
  #pod
  #pod Every call to C<describe_options> will return a object of a new subclass of
  #pod this class.  It will have a method for the canonical name of each option
  #pod possible given the option specifications.
  #pod
  #pod Method names beginning with an single underscore are public, and are named that
  #pod way to avoid conflict with automatically generated methods.  Methods with
  #pod multiple underscores (in case you're reading the source) are private.
  #pod
  #pod =head1 METHODS
  #pod
  #pod B<Achtung!>  All methods beginning with an underscore are experimental as of
  #pod today, 2009-12-12.  They are likely to be formally made permanent soon.
  #pod
  #pod =head2 _specified
  #pod
  #pod This method returns true if the given name was specified on the command line.
  #pod
  #pod For example, if C<@ARGS> was "C<< --foo --bar 10 >>" and C<baz> is defined by a
  #pod default, C<_specified> will return true for foo and bar, and false for baz.
  #pod
  #pod =cut
  
  my %_CREATED_OPTS;
  my $SERIAL_NUMBER = 1;
  
  sub _specified {
    my ($self, $name) = @_;
    my $meta = $_CREATED_OPTS{ blessed $self }{meta};
    return $meta->{given}{ $name };
  }
  
  #pod =head2 _specified_opts
  #pod
  #pod This method returns an opt object in which only explicitly specified values are
  #pod defined.  Values which were set by defaults will appear undef.
  #pod
  #pod =cut
  
  sub _specified_opts {
    my ($self) = @_;
  
    my $class = blessed $self;
    my $meta = $_CREATED_OPTS{ $class  }{meta};
  
    return $meta->{specified_opts} if $meta->{specified_opts};
  
    my @keys = grep { $meta->{given}{ $_ } } (keys %{ $meta->{given} });
  
    my %opts;
    @opts{ @keys } = @$self{ @keys };
  
    $meta->{specified_opts} = \%opts;
  
    bless $meta->{specified_opts} => $class;
    weaken $meta->{specified_opts};
  
    $meta->{specified_opts};
  }
  
  #pod =head2 _complete_opts
  #pod
  #pod This method returns the opts object with all values, including those set by
  #pod defaults.  It is probably not going to be very often-used.
  #pod
  #pod =cut
  
  sub _complete_opts {
    my ($self) = @_;
  
    my $class = blessed $self;
    my $meta = $_CREATED_OPTS{ $class  }{meta};
    return $meta->{complete_opts};
  }
  
  sub ___class_for_opt {
    my ($class, $arg) = @_;
  
    my $values = $arg->{values};
    my @bad = grep { $_ !~ /^[a-z_]\w*$/ } keys %$values;
    Carp::confess("perverse option names given: @bad") if @bad;
  
    my $new_class = "$class\::__OPT__::" . $SERIAL_NUMBER++;
    $_CREATED_OPTS{ $new_class } = { meta => $arg };
  
    {
      no strict 'refs';
      ${"$new_class\::VERSION"} = $class->VERSION;
      *{"$new_class\::ISA"} = [ 'Getopt::Long::Descriptive::Opts' ];
      for my $opt (keys %$values) {
        *{"$new_class\::$opt"} = sub { $_[0]->{ $opt } };
      }
    }
  
    return $new_class;
  }
  
  sub ___new_opt_obj {
    my ($class, $arg) = @_;
  
    my $copy = { %{ $arg->{values} } };
  
    my $new_class = $class->___class_for_opt($arg);
  
    # This is stupid, but the traditional behavior was that if --foo was not
    # given, there is no $opt->{foo}; it started to show up when we "needed" all
    # the keys to generate a class, but was undef; this wasn't a problem, but
    # broke tests of things that were relying on not-exists like tests of %$opt
    # contents or MooseX::Getopt which wanted to use things as args for new --
    # undef would not pass an Int TC.  Easier to just do this. -- rjbs,
    # 2009-11-27
    delete $copy->{$_} for grep { ! defined $copy->{$_} } keys %$copy;
  
    my $self = bless $copy => $new_class;
  
    $_CREATED_OPTS{ $new_class }{meta}{complete_opts} = $self;
    # weaken $_CREATED_OPTS{ $new_class }{meta}{complete_opts};
  
    return $self;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Getopt::Long::Descriptive::Opts - object representing command line switches
  
  =head1 VERSION
  
  version 0.102
  
  =head1 DESCRIPTION
  
  This class is the base class of all C<$opt> objects returned by
  L<Getopt::Long::Descriptive>.  In general, you do not want to think about this
  class, look at it, or alter it.  Seriously, it's pretty dumb.
  
  Every call to C<describe_options> will return a object of a new subclass of
  this class.  It will have a method for the canonical name of each option
  possible given the option specifications.
  
  Method names beginning with an single underscore are public, and are named that
  way to avoid conflict with automatically generated methods.  Methods with
  multiple underscores (in case you're reading the source) are private.
  
  =head1 METHODS
  
  B<Achtung!>  All methods beginning with an underscore are experimental as of
  today, 2009-12-12.  They are likely to be formally made permanent soon.
  
  =head2 _specified
  
  This method returns true if the given name was specified on the command line.
  
  For example, if C<@ARGS> was "C<< --foo --bar 10 >>" and C<baz> is defined by a
  default, C<_specified> will return true for foo and bar, and false for baz.
  
  =head2 _specified_opts
  
  This method returns an opt object in which only explicitly specified values are
  defined.  Values which were set by defaults will appear undef.
  
  =head2 _complete_opts
  
  This method returns the opts object with all values, including those set by
  defaults.  It is probably not going to be very often-used.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Hans Dieter Pearcey <hdp@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2005 by Hans Dieter Pearcey.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
GETOPT_LONG_DESCRIPTIVE_OPTS

$fatpacked{"Getopt/Long/Descriptive/Usage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG_DESCRIPTIVE_USAGE';
  use strict;
  use warnings;
  package Getopt::Long::Descriptive::Usage;
  # ABSTRACT: the usage description for GLD
  $Getopt::Long::Descriptive::Usage::VERSION = '0.102';
  use List::Util qw(max);
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   use Getopt::Long::Descriptive;
  #pod   my ($opt, $usage) = describe_options( ... );
  #pod
  #pod   $usage->text; # complete usage message
  #pod
  #pod   $usage->die;  # die with usage message
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This document only describes the methods of the Usage object.  For information
  #pod on how to use L<Getopt::Long::Descriptive>, consult its documentation.
  #pod
  #pod =head1 METHODS
  #pod
  #pod =head2 new
  #pod
  #pod   my $usage = Getopt::Long::Descriptive::Usage->new(\%arg);
  #pod
  #pod You B<really> don't need to call this.  GLD will do it for you.
  #pod
  #pod Valid arguments are:
  #pod
  #pod   options     - an arrayref of options
  #pod   leader_text - the text that leads the usage; this may go away!
  #pod
  #pod =cut
  
  sub new {
    my ($class, $arg) = @_;
  
    my @to_copy = qw(leader_text options show_defaults);
  
    my %copy;
    @copy{ @to_copy } = @$arg{ @to_copy };
  
    bless \%copy => $class;
  }
  
  #pod =head2 text
  #pod
  #pod This returns the full text of the usage message.
  #pod
  #pod =cut
  
  sub text {
    my ($self) = @_;
  
    return join qq{\n}, $self->leader_text, $self->option_text;
  }
  
  #pod =head2 leader_text
  #pod
  #pod This returns the text that comes at the beginning of the usage message.
  #pod
  #pod =cut
  
  sub leader_text { $_[0]->{leader_text} }
  
  #pod =head2 option_text
  #pod
  #pod This returns the text describing the available options.
  #pod
  #pod =cut
  
  sub option_text {
    my ($self) = @_;
  
    my @options  = @{ $self->{options} || [] };
    my $string   = q{};
    my @specs = map { $_->{spec} } grep { $_->{desc} ne 'spacer' } @options;
    my $length   = (max(map { _option_length($_) } @specs) || 0);
    my $spec_fmt = "\t%-${length}s";
  
    while (@options) {
      my $opt  = shift @options;
      my $spec = $opt->{spec};
      my $desc = $opt->{desc};
      my $assign;
      if ($desc eq 'spacer') {
        my @lines = $self->_split_description($length, $opt->{spec});
  
        $string .= length($_) ? sprintf("$spec_fmt\n", $_) : "\n" for @lines;
        next;
      }
  
      ($spec, $assign) = Getopt::Long::Descriptive->_strip_assignment($spec);
      $assign = _parse_assignment($assign);
      $spec = join " ", reverse map { length > 1 ? "--${_}$assign" : "-${_}$assign" }
                                split /\|/, $spec;
  
      my @desc = $self->_split_description($length, $desc);
  
      # add default value if it exists
      if (exists $opt->{constraint}->{default} and $self->{show_defaults}) {
        my $dflt = $opt->{constraint}->{default};
        $dflt = ! defined $dflt ? '(undef)'
              : ! length  $dflt ? '(empty string)'
              :                   $dflt;
        push @desc, "(default value: $dflt)";
      }
  
      $string .= sprintf "$spec_fmt  %s\n", $spec, shift @desc;
      for my $line (@desc) {
          $string .= "\t";
          $string .= q{ } x ( $length + 2 );
          $string .= "$line\n";
      }
    }
  
    return $string;
  }
  
  sub _option_length {
      my ($fullspec) = @_;
      my $number_opts = 1;
      my $last_pos = 0;
      my $number_shortopts = 0;
      my ($spec, $argspec) = Getopt::Long::Descriptive->_strip_assignment($fullspec);
      my $length = length $spec;
      my $arglen = length(_parse_assignment($argspec));
  
      # Spacing rules:
      #
      # For short options we want 1 space (for '-'), for long options 2
      # spaces (for '--').  Then one space for separating the options,
      # but we here abuse that $spec has a '|' char for that.
      #
      # For options that take arguments, we want 2 spaces for mandatory
      # options ('=X') and 4 for optional arguments ('[=X]').  Note we
      # consider {N,M} cases as "single argument" atm.
  
      # Count the number of "variants" (e.g. "long|s" has two variants)
      while ($spec =~ m{\|}g) {
          $number_opts++;
          if (pos($spec) - $last_pos == 2) {
              $number_shortopts++;
          }
          $last_pos = pos($spec);
      }
  
      # Was the last option a "short" one?
      if ($length - $last_pos == 1) {
          $number_shortopts++;
      }
  
      # We got $number_opts options, each with an argument length of
      # $arglen.  Plus each option (after the first) needs 3 a char
      # spacing.  $length gives us the total length of all options and 1
      # char spacing per option (after the first).  So the result should be:
  
      my $number_longopts = $number_opts - $number_shortopts;
      my $total_arglen = $number_opts * $arglen;
      my $total_optsep = 2 * $number_longopts + $number_shortopts;
      my $total = $length + $total_optsep + $total_arglen;
      return $total;
  }
  
  sub _split_description {
    my ($self, $length, $desc) = @_;
  
    # 8 for a tab, 2 for the space between option & desc;
    my $max_length = 78 - ( $length + 8 + 2 );
  
    return $desc if length $desc <= $max_length;
  
    my @lines;
    while (length $desc > $max_length) {
      my $idx = rindex( substr( $desc, 0, $max_length ), q{ }, );
      last unless $idx >= 0;
      push @lines, substr($desc, 0, $idx);
      substr($desc, 0, $idx + 1) = q{};
    }
    push @lines, $desc;
  
    return @lines;
  }
  
  sub _parse_assignment {
      my ($assign_spec) = @_;
  
      my $result = 'STR';
      my $desttype;
      if (length($assign_spec) < 2) {
          # empty, ! or +
          return '';
      }
  
      my $optional = substr($assign_spec, 0, 1) eq ':';
      my $argument = substr $assign_spec, 1, 2;
  
      if ($argument =~ m/^[io]/ or $assign_spec =~ m/^:[+0-9]/) {
          $result = 'INT';
      } elsif ($argument =~ m/^f/) {
          $result = 'NUM';
      }
  
      if (length($assign_spec) > 2) {
          $desttype = substr($assign_spec, 2, 1);
          if ($desttype eq '@') {
              # Imply it can be repeated
              $result .= '...';
          } elsif ($desttype eq '%') {
              $result = "KEY=${result}...";
          }
      }
  
      if ($optional) {
          return "[=$result]";
      }
  
      # with leading space so it can just blindly be appended.
      return " $result";
  }
  
  #pod =head2 warn
  #pod
  #pod This warns with the usage message.
  #pod
  #pod =cut
  
  sub warn { warn shift->text }
  
  #pod =head2 die
  #pod
  #pod This throws the usage message as an exception.
  #pod
  #pod   $usage_obj->die(\%arg);
  #pod
  #pod Some arguments can be provided 
  #pod
  #pod   pre_text  - text to be prepended to the usage message
  #pod   post_text - text to be appended to the usage message
  #pod
  #pod The C<pre_text> and C<post_text> arguments are concatenated with the usage
  #pod message with no line breaks, so supply this if you need them.
  #pod
  #pod =cut
  
  sub die  {
    my $self = shift;
    my $arg  = shift || {};
  
    die(
      join q{}, grep { defined } $arg->{pre_text}, $self->text, $arg->{post_text}
    );
  }
  
  use overload (
    q{""} => "text",
  
    # This is only needed because Usage used to be a blessed coderef that worked
    # this way.  Later we can toss a warning in here. -- rjbs, 2009-08-19
    '&{}' => sub {
      my ($self) = @_;
      Carp::cluck("use of __PACKAGE__ objects as a code ref is deprecated");
      return sub { return $_[0] ? $self->text : $self->warn; };
    }
  );
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Getopt::Long::Descriptive::Usage - the usage description for GLD
  
  =head1 VERSION
  
  version 0.102
  
  =head1 SYNOPSIS
  
    use Getopt::Long::Descriptive;
    my ($opt, $usage) = describe_options( ... );
  
    $usage->text; # complete usage message
  
    $usage->die;  # die with usage message
  
  =head1 DESCRIPTION
  
  This document only describes the methods of the Usage object.  For information
  on how to use L<Getopt::Long::Descriptive>, consult its documentation.
  
  =head1 METHODS
  
  =head2 new
  
    my $usage = Getopt::Long::Descriptive::Usage->new(\%arg);
  
  You B<really> don't need to call this.  GLD will do it for you.
  
  Valid arguments are:
  
    options     - an arrayref of options
    leader_text - the text that leads the usage; this may go away!
  
  =head2 text
  
  This returns the full text of the usage message.
  
  =head2 leader_text
  
  This returns the text that comes at the beginning of the usage message.
  
  =head2 option_text
  
  This returns the text describing the available options.
  
  =head2 warn
  
  This warns with the usage message.
  
  =head2 die
  
  This throws the usage message as an exception.
  
    $usage_obj->die(\%arg);
  
  Some arguments can be provided 
  
    pre_text  - text to be prepended to the usage message
    post_text - text to be appended to the usage message
  
  The C<pre_text> and C<post_text> arguments are concatenated with the usage
  message with no line breaks, so supply this if you need them.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Hans Dieter Pearcey <hdp@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2005 by Hans Dieter Pearcey.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
GETOPT_LONG_DESCRIPTIVE_USAGE

$fatpacked{"Module/Implementation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_IMPLEMENTATION';
  package Module::Implementation;
  # git description: v0.08-2-gd599347
  $Module::Implementation::VERSION = '0.09';
  
  use strict;
  use warnings;
  
  use Module::Runtime 0.012 qw( require_module );
  use Try::Tiny;
  
  # This is needed for the benefit of Test::CleanNamespaces, which in turn loads
  # Package::Stash, which in turn loads this module and expects a minimum
  # version.
  unless ( exists $Module::Implementation::{VERSION}
      && ${ $Module::Implementation::{VERSION} } ) {
  
      $Module::Implementation::{VERSION} = \42;
  }
  
  my %Implementation;
  
  sub build_loader_sub {
      my $caller = caller();
  
      return _build_loader( $caller, @_ );
  }
  
  sub _build_loader {
      my $package = shift;
      my %args    = @_;
  
      my @implementations = @{ $args{implementations} };
      my @symbols = @{ $args{symbols} || [] };
  
      my $implementation;
      my $env_var = uc $package;
      $env_var =~ s/::/_/g;
      $env_var .= '_IMPLEMENTATION';
  
      return sub {
          my ( $implementation, $loaded ) = _load_implementation(
              $package,
              $ENV{$env_var},
              \@implementations,
          );
  
          $Implementation{$package} = $implementation;
  
          _copy_symbols( $loaded, $package, \@symbols );
  
          return $loaded;
      };
  }
  
  sub implementation_for {
      my $package = shift;
  
      return $Implementation{$package};
  }
  
  sub _load_implementation {
      my $package         = shift;
      my $env_value       = shift;
      my $implementations = shift;
  
      if ($env_value) {
          die "$env_value is not a valid implementation for $package"
              unless grep { $_ eq $env_value } @{$implementations};
  
          my $requested = "${package}::$env_value";
  
          # Values from the %ENV hash are tainted. We know it's safe to untaint
          # this value because the value was one of our known implementations.
          ($requested) = $requested =~ /^(.+)$/;
  
          try {
              require_module($requested);
          }
          catch {
              require Carp;
              Carp::croak("Could not load $requested: $_");
          };
  
          return ( $env_value, $requested );
      }
      else {
          my $err;
          for my $possible ( @{$implementations} ) {
              my $try = "${package}::$possible";
  
              my $ok;
              try {
                  require_module($try);
                  $ok = 1;
              }
              catch {
                  $err .= $_ if defined $_;
              };
  
              return ( $possible, $try ) if $ok;
          }
  
          require Carp;
          if ( defined $err && length $err ) {
              Carp::croak(
                  "Could not find a suitable $package implementation: $err");
          }
          else {
              Carp::croak(
                  'Module::Runtime failed to load a module but did not throw a real error. This should never happen. Something is very broken'
              );
          }
      }
  }
  
  sub _copy_symbols {
      my $from_package = shift;
      my $to_package   = shift;
      my $symbols      = shift;
  
      for my $sym ( @{$symbols} ) {
          my $type = $sym =~ s/^([\$\@\%\&\*])// ? $1 : '&';
  
          my $from = "${from_package}::$sym";
          my $to   = "${to_package}::$sym";
  
          {
              no strict 'refs';
              no warnings 'once';
  
              # Copied from Exporter
              *{$to}
                  = $type eq '&' ? \&{$from}
                  : $type eq '$' ? \${$from}
                  : $type eq '@' ? \@{$from}
                  : $type eq '%' ? \%{$from}
                  : $type eq '*' ? *{$from}
                  : die
                  "Can't copy symbol from $from_package to $to_package: $type$sym";
          }
      }
  }
  
  1;
  
  # ABSTRACT: Loads one of several alternate underlying implementations for a module
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Module::Implementation - Loads one of several alternate underlying implementations for a module
  
  =head1 VERSION
  
  version 0.09
  
  =head1 SYNOPSIS
  
    package Foo::Bar;
  
    use Module::Implementation;
  
    BEGIN {
        my $loader = Module::Implementation::build_loader_sub(
            implementations => [ 'XS',  'PurePerl' ],
            symbols         => [ 'run', 'check' ],
        );
  
        $loader->();
    }
  
    package Consumer;
  
    # loads the first viable implementation
    use Foo::Bar;
  
  =head1 DESCRIPTION
  
  This module abstracts out the process of choosing one of several underlying
  implementations for a module. This can be used to provide XS and pure Perl
  implementations of a module, or it could be used to load an implementation for
  a given OS or any other case of needing to provide multiple implementations.
  
  This module is only useful when you know all the implementations ahead of
  time. If you want to load arbitrary implementations then you probably want
  something like a plugin system, not this module.
  
  =head1 API
  
  This module provides two subroutines, neither of which are exported.
  
  =head2 Module::Implementation::build_loader_sub(...)
  
  This subroutine takes the following arguments.
  
  =over 4
  
  =item * implementations
  
  This should be an array reference of implementation names. Each name should
  correspond to a module in the caller's namespace.
  
  In other words, using the example in the L</SYNOPSIS>, this module will look
  for the C<Foo::Bar::XS> and C<Foo::Bar::PurePerl> modules.
  
  This argument is required.
  
  =item * symbols
  
  A list of symbols to copy from the implementation package to the calling
  package.
  
  These can be prefixed with a variable type: C<$>, C<@>, C<%>, C<&>, or
  C<*)>. If no prefix is given, the symbol is assumed to be a subroutine.
  
  This argument is optional.
  
  =back
  
  This subroutine I<returns> the implementation loader as a sub reference.
  
  It is up to you to call this loader sub in your code.
  
  I recommend that you I<do not> call this loader in an C<import()> sub. If a
  caller explicitly requests no imports, your C<import()> sub will not be run at
  all, which can cause weird breakage.
  
  =head2 Module::Implementation::implementation_for($package)
  
  Given a package name, this subroutine returns the implementation that was
  loaded for the package. This is not a full package name, just the suffix that
  identifies the implementation. For the L</SYNOPSIS> example, this subroutine
  would be called as C<Module::Implementation::implementation_for('Foo::Bar')>,
  and it would return "XS" or "PurePerl".
  
  =head1 HOW THE IMPLEMENTATION LOADER WORKS
  
  The implementation loader works like this ...
  
  First, it checks for an C<%ENV> var specifying the implementation to load. The
  env var is based on the package name which loads the implementations. The
  C<::> package separator is replaced with C<_>, and made entirely
  upper-case. Finally, we append "_IMPLEMENTATION" to this name.
  
  So in our L</SYNOPSIS> example, the corresponding C<%ENV> key would be
  C<FOO_BAR_IMPLEMENTATION>.
  
  If this is set, then the loader will B<only> try to load this one
  implementation.
  
  If the env var requests an implementation which doesn't match one of the
  implementations specified when the loader was created, an error is thrown.
  
  If this one implementation fails to load then loader throws an error. This is
  useful for testing. You can request a specific implementation in a test file
  by writing something like this:
  
    BEGIN { $ENV{FOO_BAR_IMPLEMENTATION} = 'XS' }
    use Foo::Bar;
  
  If the environment variable is I<not> set, then the loader simply tries the
  implementations originally passed to C<Module::Implementation>. The
  implementations are tried in the order in which they were originally passed.
  
  The loader will use the first implementation that loads without an error. It
  will copy any requested symbols from this implementation.
  
  If none of the implementations can be loaded, then the loader throws an
  exception.
  
  The loader returns the name of the package it loaded.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
MODULE_IMPLEMENTATION

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  =head1 NAME
  
  Module::Runtime - runtime module handling
  
  =head1 SYNOPSIS
  
      use Module::Runtime qw(
  	$module_name_rx is_module_name check_module_name
  	module_notional_filename require_module);
  
      if($module_name =~ /\A$module_name_rx\z/o) { ...
      if(is_module_name($module_name)) { ...
      check_module_name($module_name);
  
      $notional_filename = module_notional_filename($module_name);
      require_module($module_name);
  
      use Module::Runtime qw(use_module use_package_optimistically);
  
      $bi = use_module("Math::BigInt", 1.31)->new("1_234");
      $widget = use_package_optimistically("Local::Widget")->new;
  
      use Module::Runtime qw(
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec check_module_spec
  	compose_module_name);
  
      if($spec =~ /\A$top_module_spec_rx\z/o) { ...
      if($spec =~ /\A$sub_module_spec_rx\z/o) { ...
      if(is_module_spec("Standard::Prefix", $spec)) { ...
      check_module_spec("Standard::Prefix", $spec);
  
      $module_name = compose_module_name("Standard::Prefix", $spec);
  
  =head1 DESCRIPTION
  
  The functions exported by this module deal with runtime handling of
  Perl modules, which are normally handled at compile time.  This module
  avoids using any other modules, so that it can be used in low-level
  infrastructure.
  
  The parts of this module that work with module names apply the same syntax
  that is used for barewords in Perl source.  In principle this syntax
  can vary between versions of Perl, and this module applies the syntax of
  the Perl on which it is running.  In practice the usable syntax hasn't
  changed yet.  There's some intent for Unicode module names to be supported
  in the future, but this hasn't yet amounted to any consistent facility.
  
  The functions of this module whose purpose is to load modules include
  workarounds for three old Perl core bugs regarding C<require>.  These
  workarounds are applied on any Perl version where the bugs exist, except
  for a case where one of the bugs cannot be adequately worked around in
  pure Perl.
  
  =head2 Module name syntax
  
  The usable module name syntax has not changed from Perl 5.000 up to
  Perl 5.19.8.  The syntax is composed entirely of ASCII characters.
  From Perl 5.6 onwards there has been some attempt to allow the use of
  non-ASCII Unicode characters in Perl source, but it was fundamentally
  broken (like the entirety of Perl 5.6's Unicode handling) and remained
  pretty much entirely unusable until it got some attention in the Perl
  5.15 series.  Although Unicode is now consistently accepted by the
  parser in some places, it remains broken for module names.  Furthermore,
  there has not yet been any work on how to map Unicode module names into
  filenames, so in that respect also Unicode module names are unusable.
  
  The module name syntax is, precisely: the string must consist of one or
  more segments separated by C<::>; each segment must consist of one or more
  identifier characters (ASCII alphanumerics plus "_"); the first character
  of the string must not be a digit.  Thus "C<IO::File>", "C<warnings>",
  and "C<foo::123::x_0>" are all valid module names, whereas "C<IO::>"
  and "C<1foo::bar>" are not.  C<'> separators are not permitted by this
  module, though they remain usable in Perl source, being translated to
  C<::> in the parser.
  
  =head2 Core bugs worked around
  
  The first bug worked around is core bug [perl #68590], which causes
  lexical state in one file to leak into another that is C<require>d/C<use>d
  from it.  This bug is present from Perl 5.6 up to Perl 5.10, and is
  fixed in Perl 5.11.0.  From Perl 5.9.4 up to Perl 5.10.0 no satisfactory
  workaround is possible in pure Perl.  The workaround means that modules
  loaded via this module don't suffer this pollution of their lexical
  state.  Modules loaded in other ways, or via this module on the Perl
  versions where the pure Perl workaround is impossible, remain vulnerable.
  The module L<Lexical::SealRequireHints> provides a complete workaround
  for this bug.
  
  The second bug worked around causes some kinds of failure in module
  loading, principally compilation errors in the loaded module, to be
  recorded in C<%INC> as if they were successful, so later attempts to load
  the same module immediately indicate success.  This bug is present up
  to Perl 5.8.9, and is fixed in Perl 5.9.0.  The workaround means that a
  compilation error in a module loaded via this module won't be cached as
  a success.  Modules loaded in other ways remain liable to produce bogus
  C<%INC> entries, and if a bogus entry exists then it will mislead this
  module if it is used to re-attempt loading.
  
  The third bug worked around causes the wrong context to be seen at
  file scope of a loaded module, if C<require> is invoked in a location
  that inherits context from a higher scope.  This bug is present up to
  Perl 5.11.2, and is fixed in Perl 5.11.3.  The workaround means that
  a module loaded via this module will always see the correct context.
  Modules loaded in other ways remain vulnerable.
  
  =cut
  
  package Module::Runtime;
  
  # Don't "use 5.006" here, because Perl 5.15.6 will load feature.pm if
  # the version check is done that way.
  BEGIN { require 5.006; }
  # Don't "use warnings" here, to avoid dependencies.  Do standardise the
  # warning status by lexical override; unfortunately the only safe bitset
  # to build in is the empty set, equivalent to "no warnings".
  BEGIN { ${^WARNING_BITS} = ""; }
  # Don't "use strict" here, to avoid dependencies.
  
  our $VERSION = "0.016";
  
  # Don't use Exporter here, to avoid dependencies.
  our @EXPORT_OK = qw(
  	$module_name_rx is_module_name is_valid_module_name check_module_name
  	module_notional_filename require_module
  	use_module use_package_optimistically
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec is_valid_module_spec check_module_spec
  	compose_module_name
  );
  my %export_ok = map { ($_ => undef) } @EXPORT_OK;
  sub import {
  	my $me = shift;
  	my $callpkg = caller(0);
  	my $errs = "";
  	foreach(@_) {
  		if(exists $export_ok{$_}) {
  			# We would need to do "no strict 'refs'" here
  			# if we had enabled strict at file scope.
  			if(/\A\$(.*)\z/s) {
  				*{$callpkg."::".$1} = \$$1;
  			} else {
  				*{$callpkg."::".$_} = \&$_;
  			}
  		} else {
  			$errs .= "\"$_\" is not exported by the $me module\n";
  		}
  	}
  	if($errs ne "") {
  		die "${errs}Can't continue after import errors ".
  			"at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n";
  	}
  }
  
  # Logic duplicated from Params::Classify.  Duplicating it here avoids
  # an extensive and potentially circular dependency graph.
  sub _is_string($) {
  	my($arg) = @_;
  	return defined($arg) && ref(\$arg) eq "SCALAR";
  }
  
  =head1 REGULAR EXPRESSIONS
  
  These regular expressions do not include any anchors, so to check
  whether an entire string matches a syntax item you must supply the
  anchors yourself.
  
  =over
  
  =item $module_name_rx
  
  Matches a valid Perl module name in bareword syntax.
  
  =cut
  
  our $module_name_rx = qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;
  
  =item $top_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where no prefix is being used.
  
  =cut
  
  my $qual_module_spec_rx =
  	qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  my $unqual_top_module_spec_rx =
  	qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $top_module_spec_rx = qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;
  
  =item $sub_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where a prefix is being used.
  
  =cut
  
  my $unqual_sub_module_spec_rx = qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $sub_module_spec_rx = qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 Basic module handling
  
  =over
  
  =item is_module_name(ARG)
  
  Returns a truth value indicating whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  
  =cut
  
  sub is_module_name($) { _is_string($_[0]) && $_[0] =~ /\A$module_name_rx\z/o }
  
  =item is_valid_module_name(ARG)
  
  Deprecated alias for L</is_module_name>.
  
  =cut
  
  *is_valid_module_name = \&is_module_name;
  
  =item check_module_name(ARG)
  
  Check whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_name($) {
  	unless(&is_module_name) {
  		die +(_is_string($_[0]) ? "`$_[0]'" : "argument").
  			" is not a module name\n";
  	}
  }
  
  =item module_notional_filename(NAME)
  
  Generates a notional relative filename for a module, which is used in
  some Perl core interfaces.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The notional filename for the named module is generated and returned.
  This filename is always in Unix style, with C</> directory separators
  and a C<.pm> suffix.  This kind of filename can be used as an argument to
  C<require>, and is the key that appears in C<%INC> to identify a module,
  regardless of actual local filename syntax.
  
  =cut
  
  sub module_notional_filename($) {
  	&check_module_name;
  	my($name) = @_;
  	$name =~ s!::!/!g;
  	return $name.".pm";
  }
  
  =item require_module(NAME)
  
  This is essentially the bareword form of C<require>, in runtime form.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The module specified by I<NAME> is loaded, if it hasn't been already,
  in the manner of the bareword form of C<require>.  That means that a
  search through C<@INC> is performed, and a byte-compiled form of the
  module will be used if available.
  
  The return value is as for C<require>.  That is, it is the value returned
  by the module itself if the module is loaded anew, or C<1> if the module
  was already loaded.
  
  =cut
  
  # Don't "use constant" here, to avoid dependencies.
  BEGIN {
  	*_WORK_AROUND_HINT_LEAKAGE =
  		"$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
  			? sub(){1} : sub(){0};
  	*_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
  }
  
  BEGIN { if(_WORK_AROUND_BROKEN_MODULE_STATE) { eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  }; die $@ if $@ ne ""; } }
  
  sub require_module($) {
  	# Localise %^H to work around [perl #68590], where the bug exists
  	# and this is a satisfactory workaround.  The bug consists of
  	# %^H state leaking into each required module, polluting the
  	# module's lexical state.
  	local %^H if _WORK_AROUND_HINT_LEAKAGE;
  	if(_WORK_AROUND_BROKEN_MODULE_STATE) {
  		my $notional_filename = &module_notional_filename;
  		my $guard = bless([ $notional_filename ],
  				"Module::Runtime::__GUARD__");
  		my $result = CORE::require($notional_filename);
  		pop @$guard;
  		return $result;
  	} else {
  		return scalar(CORE::require(&module_notional_filename));
  	}
  }
  
  =back
  
  =head2 Structured module use
  
  =over
  
  =item use_module(NAME[, VERSION])
  
  This is essentially C<use> in runtime form, but without the importing
  feature (which is fundamentally a compile-time thing).  The I<NAME> is
  handled just like in C<require_module> above: it must be a module name,
  and the named module is loaded as if by the bareword form of C<require>.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded module is
  called with the specified I<VERSION> as an argument.  This normally serves to
  ensure that the version loaded is at least the version required.  This is
  the same functionality provided by the I<VERSION> parameter of C<use>.
  
  On success, the name of the module is returned.  This is unlike
  L</require_module>, and is done so that the entire call to L</use_module>
  can be used as a class name to call a constructor, as in the example in
  the synopsis.
  
  =cut
  
  sub use_module($;$) {
  	my($name, $version) = @_;
  	require_module($name);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =item use_package_optimistically(NAME[, VERSION])
  
  This is an analogue of L</use_module> for the situation where there is
  uncertainty as to whether a package/class is defined in its own module
  or by some other means.  It attempts to arrange for the named package to
  be available, either by loading a module or by doing nothing and hoping.
  
  An attempt is made to load the named module (as if by the bareword form
  of C<require>).  If the module cannot be found then it is assumed that
  the package was actually already loaded by other means, and no error
  is signalled.  That's the optimistic bit.
  
  I<Warning:> this optional module loading is liable to cause unreliable
  behaviour, including security problems.  It interacts especially badly
  with having C<.> in C<@INC>, which was the default state of affairs in
  Perls prior to 5.25.11.  If a package is actually defined by some means
  other than a module, then applying this function to it causes a spurious
  attempt to load a module that is expected to be non-existent.  If a
  module actually exists under that name then it will be unintentionally
  loaded.  If C<.> is in C<@INC> and this code is ever run with the current
  directory being one writable by a malicious user (such as F</tmp>), then
  the malicious user can easily cause the victim to run arbitrary code, by
  creating a module file under the predictable spuriously-loaded name in the
  writable directory.  Generally, optional module loading should be avoided.
  
  This is mostly the same operation that is performed by the L<base> pragma
  to ensure that the specified base classes are available.  The behaviour
  of L<base> was simplified in version 2.18, and later improved in version
  2.20, and on both occasions this function changed to match.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded package is
  called with the specified I<VERSION> as an argument.  This normally serves
  to ensure that the version loaded is at least the version required.
  On success, the name of the package is returned.  These aspects of the
  function work just like L</use_module>.
  
  =cut
  
  sub use_package_optimistically($;$) {
  	my($name, $version) = @_;
  	my $fn = module_notional_filename($name);
  	eval { local $SIG{__DIE__}; require_module($name); };
  	die $@ if $@ ne "" &&
  		($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s ||
  		 $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =back
  
  =head2 Module name composition
  
  =over
  
  =item is_module_spec(PREFIX, SPEC)
  
  Returns a truth value indicating
  whether I<SPEC> is valid input for L</compose_module_name>.
  See below for what that entails.  Whether a I<PREFIX> is supplied affects
  the validity of I<SPEC>, but the exact value of the prefix is unimportant,
  so this function treats I<PREFIX> as a truth value.
  
  =cut
  
  sub is_module_spec($$) {
  	my($prefix, $spec) = @_;
  	return _is_string($spec) &&
  		$spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o :
  				    qr/\A$top_module_spec_rx\z/o);
  }
  
  =item is_valid_module_spec(PREFIX, SPEC)
  
  Deprecated alias for L</is_module_spec>.
  
  =cut
  
  *is_valid_module_spec = \&is_module_spec;
  
  =item check_module_spec(PREFIX, SPEC)
  
  Check whether I<SPEC> is valid input for L</compose_module_name>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_spec($$) {
  	unless(&is_module_spec) {
  		die +(_is_string($_[1]) ? "`$_[1]'" : "argument").
  			" is not a module specification\n";
  	}
  }
  
  =item compose_module_name(PREFIX, SPEC)
  
  This function is intended to make it more convenient for a user to specify
  a Perl module name at runtime.  Users have greater need for abbreviations
  and context-sensitivity than programmers, and Perl module names get a
  little unwieldy.  I<SPEC> is what the user specifies, and this function
  translates it into a module name in standard form, which it returns.
  
  I<SPEC> has syntax approximately that of a standard module name: it
  should consist of one or more name segments, each of which consists
  of one or more identifier characters.  However, C</> is permitted as a
  separator, in addition to the standard C<::>.  The two separators are
  entirely interchangeable.
  
  Additionally, if I<PREFIX> is not C<undef> then it must be a module
  name in standard form, and it is prefixed to the user-specified name.
  The user can inhibit the prefix addition by starting I<SPEC> with a
  separator (either C</> or C<::>).
  
  =cut
  
  sub compose_module_name($$) {
  	my($prefix, $spec) = @_;
  	check_module_name($prefix) if defined $prefix;
  	&check_module_spec;
  	if($spec =~ s#\A(?:/|::)##) {
  		# OK
  	} else {
  		$spec = $prefix."::".$spec if defined $prefix;
  	}
  	$spec =~ s#/#::#g;
  	return $spec;
  }
  
  =back
  
  =head1 BUGS
  
  On Perl versions 5.7.2 to 5.8.8, if C<require> is overridden by the
  C<CORE::GLOBAL> mechanism, it is likely to break the heuristics used by
  L</use_package_optimistically>, making it signal an error for a missing
  module rather than assume that it was already loaded.  From Perl 5.8.9
  onwards, and on 5.7.1 and earlier, this module can avoid being confused
  by such an override.  On the affected versions, a C<require> override
  might be installed by L<Lexical::SealRequireHints>, if something requires
  its bugfix but for some reason its XS implementation isn't available.
  
  =head1 SEE ALSO
  
  L<Lexical::SealRequireHints>,
  L<base>,
  L<perlfunc/require>,
  L<perlfunc/use>
  
  =head1 AUTHOR
  
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2004, 2006, 2007, 2009, 2010, 2011, 2012, 2014, 2017
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
MODULE_RUNTIME

$fatpacked{"Sub/Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER';
  use 5.006;
  use strict;
  use warnings;
  package Sub::Exporter;
  {
    $Sub::Exporter::VERSION = '0.987';
  }
  # ABSTRACT: a sophisticated exporter for custom-built routines
  
  use Carp ();
  use Data::OptList 0.100 ();
  use Params::Util 0.14 (); # _CODELIKE
  use Sub::Install 0.92 ();
  
  
  # Given a potential import name, this returns the group name -- if it's got a
  # group prefix.
  sub _group_name {
    my ($name) = @_;
  
    return if (index q{-:}, (substr $name, 0, 1)) == -1;
    return substr $name, 1;
  }
  
  # \@groups is a canonicalized opt list of exports and groups this returns
  # another canonicalized opt list with groups replaced with relevant exports.
  # \%seen is groups we've already expanded and can ignore.
  # \%merge is merged options from the group we're descending through.
  sub _expand_groups {
    my ($class, $config, $groups, $collection, $seen, $merge) = @_;
    $seen  ||= {};
    $merge ||= {};
    my @groups = @$groups;
  
    for my $i (reverse 0 .. $#groups) {
      if (my $group_name = _group_name($groups[$i][0])) {
        my $seen = { %$seen }; # faux-dynamic scoping
  
        splice @groups, $i, 1,
          _expand_group($class, $config, $groups[$i], $collection, $seen, $merge);
      } else {
        # there's nothing to munge in this export's args
        next unless my %merge = %$merge;
  
        # we have things to merge in; do so
        my $prefix = (delete $merge{-prefix}) || '';
        my $suffix = (delete $merge{-suffix}) || '';
  
        if (
          Params::Util::_CODELIKE($groups[$i][1]) ## no critic Private
          or
          Params::Util::_SCALAR0($groups[$i][1]) ## no critic Private
        ) {
          # this entry was build by a group generator
          $groups[$i][0] = $prefix . $groups[$i][0] . $suffix;
        } else {
          my $as
            = ref $groups[$i][1]{-as} ? $groups[$i][1]{-as}
            :     $groups[$i][1]{-as} ? $prefix . $groups[$i][1]{-as} . $suffix
            :                           $prefix . $groups[$i][0]      . $suffix;
  
          $groups[$i][1] = { %{ $groups[$i][1] }, %merge, -as => $as };
        }
      }
    }
  
    return \@groups;
  }
  
  # \@group is a name/value pair from an opt list.
  sub _expand_group {
    my ($class, $config, $group, $collection, $seen, $merge) = @_;
    $merge ||= {};
  
    my ($group_name, $group_arg) = @$group;
    $group_name = _group_name($group_name);
  
    Carp::croak qq(group "$group_name" is not exported by the $class module)
      unless exists $config->{groups}{$group_name};
  
    return if $seen->{$group_name}++;
  
    if (ref $group_arg) {
      my $prefix = (delete $merge->{-prefix}||'') . ($group_arg->{-prefix}||'');
      my $suffix = ($group_arg->{-suffix}||'') . (delete $merge->{-suffix}||'');
      $merge = {
        %$merge,
        %$group_arg,
        ($prefix ? (-prefix => $prefix) : ()),
        ($suffix ? (-suffix => $suffix) : ()),
      };
    }
  
    my $exports = $config->{groups}{$group_name};
  
    if (
      Params::Util::_CODELIKE($exports) ## no critic Private
      or
      Params::Util::_SCALAR0($exports) ## no critic Private
    ) {
      # I'm not very happy with this code for hiding -prefix and -suffix, but
      # it's needed, and I'm not sure, offhand, how to make it better.
      # -- rjbs, 2006-12-05
      my $group_arg = $merge ? { %$merge } : {};
      delete $group_arg->{-prefix};
      delete $group_arg->{-suffix};
  
      my $group = Params::Util::_CODELIKE($exports) ## no critic Private
                ? $exports->($class, $group_name, $group_arg, $collection)
                : $class->$$exports($group_name, $group_arg, $collection);
  
      Carp::croak qq(group generator "$group_name" did not return a hashref)
        if ref $group ne 'HASH';
  
      my $stuff = [ map { [ $_ => $group->{$_} ] } keys %$group ];
      return @{
        _expand_groups($class, $config, $stuff, $collection, $seen, $merge)
      };
    } else {
      $exports
        = Data::OptList::mkopt($exports, "$group_name exports");
  
      return @{
        _expand_groups($class, $config, $exports, $collection, $seen, $merge)
      };
    }
  }
  
  sub _mk_collection_builder {
    my ($col, $etc) = @_;
    my ($config, $import_args, $class, $into) = @$etc;
  
    my %seen;
    sub {
      my ($collection) = @_;
      my ($name, $value) = @$collection;
  
      Carp::croak "collection $name provided multiple times in import"
        if $seen{ $name }++;
  
      if (ref(my $hook = $config->{collectors}{$name})) {
        my $arg = {
          name        => $name,
          config      => $config,
          import_args => $import_args,
          class       => $class,
          into        => $into,
        };
  
        my $error_msg = "collection $name failed validation";
        if (Params::Util::_SCALAR0($hook)) { ## no critic Private
          Carp::croak $error_msg unless $class->$$hook($value, $arg);
        } else {
          Carp::croak $error_msg unless $hook->($value, $arg);
        }
      }
  
      $col->{ $name } = $value;
    }
  }
  
  # Given a config and pre-canonicalized importer args, remove collections from
  # the args and return them.
  sub _collect_collections {
    my ($config, $import_args, $class, $into) = @_;
  
    my @collections
      = map  { splice @$import_args, $_, 1 }
        grep { exists $config->{collectors}{ $import_args->[$_][0] } }
        reverse 0 .. $#$import_args;
  
    unshift @collections, [ INIT => {} ] if $config->{collectors}{INIT};
  
    my $col = {};
    my $builder = _mk_collection_builder($col, \@_);
    for my $collection (@collections) {
      $builder->($collection)
    }
  
    return $col;
  }
  
  
  sub setup_exporter {
    my ($config)  = @_;
  
    Carp::croak 'into and into_level may not both be supplied to exporter'
      if exists $config->{into} and exists $config->{into_level};
  
    my $as   = delete $config->{as}   || 'import';
    my $into
      = exists $config->{into}       ? delete $config->{into}
      : exists $config->{into_level} ? caller(delete $config->{into_level})
      :                                caller(0);
  
    my $import = build_exporter($config);
  
    Sub::Install::reinstall_sub({
      code => $import,
      into => $into,
      as   => $as,
    });
  }
  
  
  sub _key_intersection {
    my ($x, $y) = @_;
    my %seen = map { $_ => 1 } keys %$x;
    my @names = grep { $seen{$_} } keys %$y;
  }
  
  # Given the config passed to setup_exporter, which contains sugary opt list
  # data, rewrite the opt lists into hashes, catch a few kinds of invalid
  # configurations, and set up defaults.  Since the config is a reference, it's
  # rewritten in place.
  my %valid_config_key;
  BEGIN {
    %valid_config_key =
      map { $_ => 1 }
      qw(as collectors installer generator exports groups into into_level),
      qw(exporter), # deprecated
  }
  
  sub _assert_collector_names_ok {
    my ($collectors) = @_;
  
    for my $reserved_name (grep { /\A[_A-Z]+\z/ } keys %$collectors) {
      Carp::croak "unknown reserved collector name: $reserved_name"
        if $reserved_name ne 'INIT';
    }
  }
  
  sub _rewrite_build_config {
    my ($config) = @_;
  
    if (my @keys = grep { not exists $valid_config_key{$_} } keys %$config) {
      Carp::croak "unknown options (@keys) passed to Sub::Exporter";
    }
  
    Carp::croak q(into and into_level may not both be supplied to exporter)
      if exists $config->{into} and exists $config->{into_level};
  
    # XXX: Remove after deprecation period.
    if ($config->{exporter}) {
      Carp::cluck "'exporter' argument to build_exporter is deprecated. Use 'installer' instead; the semantics are identical.";
      $config->{installer} = delete $config->{exporter};
    }
  
    Carp::croak q(into and into_level may not both be supplied to exporter)
      if exists $config->{into} and exists $config->{into_level};
  
    for (qw(exports collectors)) {
      $config->{$_} = Data::OptList::mkopt_hash(
        $config->{$_},
        $_,
        [ 'CODE', 'SCALAR' ],
      );
    }
  
    _assert_collector_names_ok($config->{collectors});
  
    if (my @names = _key_intersection(@$config{qw(exports collectors)})) {
      Carp::croak "names (@names) used in both collections and exports";
    }
  
    $config->{groups} = Data::OptList::mkopt_hash(
        $config->{groups},
        'groups',
        [
          'HASH',   # standard opt list
          'ARRAY',  # standard opt list
          'CODE',   # group generator
          'SCALAR', # name of group generation method
        ]
      );
  
    # by default, export nothing
    $config->{groups}{default} ||= [];
  
    # by default, build an all-inclusive 'all' group
    $config->{groups}{all} ||= [ keys %{ $config->{exports} } ];
  
    $config->{generator} ||= \&default_generator;
    $config->{installer} ||= \&default_installer;
  }
  
  sub build_exporter {
    my ($config) = @_;
  
    _rewrite_build_config($config);
  
    my $import = sub {
      my ($class) = shift;
  
      # XXX: clean this up -- rjbs, 2006-03-16
      my $special = (ref $_[0]) ? shift(@_) : {};
      Carp::croak q(into and into_level may not both be supplied to exporter)
        if exists $special->{into} and exists $special->{into_level};
  
      if ($special->{exporter}) {
        Carp::cluck "'exporter' special import argument is deprecated. Use 'installer' instead; the semantics are identical.";
        $special->{installer} = delete $special->{exporter};
      }
  
      my $into
        = defined $special->{into}       ? delete $special->{into}
        : defined $special->{into_level} ? caller(delete $special->{into_level})
        : defined $config->{into}        ? $config->{into}
        : defined $config->{into_level}  ? caller($config->{into_level})
        :                                  caller(0);
  
      my $generator = delete $special->{generator} || $config->{generator};
      my $installer = delete $special->{installer} || $config->{installer};
  
      # this builds a AOA, where the inner arrays are [ name => value_ref ]
      my $import_args = Data::OptList::mkopt([ @_ ]);
  
      # is this right?  defaults first or collectors first? -- rjbs, 2006-06-24
      $import_args = [ [ -default => undef ] ] unless @$import_args;
  
      my $collection = _collect_collections($config, $import_args, $class, $into);
  
      my $to_import = _expand_groups($class, $config, $import_args, $collection);
  
      # now, finally $import_arg is really the "to do" list
      _do_import(
        {
          class     => $class,
          col       => $collection,
          config    => $config,
          into      => $into,
          generator => $generator,
          installer => $installer,
        },
        $to_import,
      );
    };
  
    return $import;
  }
  
  sub _do_import {
    my ($arg, $to_import) = @_;
  
    my @todo;
  
    for my $pair (@$to_import) {
      my ($name, $import_arg) = @$pair;
  
      my ($generator, $as);
  
      if ($import_arg and Params::Util::_CODELIKE($import_arg)) { ## no critic
        # This is the case when a group generator has inserted name/code pairs.
        $generator = sub { $import_arg };
        $as = $name;
      } else {
        $import_arg = { $import_arg ? %$import_arg : () };
  
        Carp::croak qq("$name" is not exported by the $arg->{class} module)
          unless exists $arg->{config}{exports}{$name};
  
        $generator = $arg->{config}{exports}{$name};
  
        $as = exists $import_arg->{-as} ? (delete $import_arg->{-as}) : $name;
      }
  
      my $code = $arg->{generator}->(
        { 
          class     => $arg->{class},
          name      => $name,
          arg       => $import_arg,
          col       => $arg->{col},
          generator => $generator,
        }
      );
  
      push @todo, $as, $code;
    }
  
    $arg->{installer}->(
      {
        class => $arg->{class},
        into  => $arg->{into},
        col   => $arg->{col},
      },
      \@todo,
    );
  }
  
  ## Cute idea, possibly for future use: also supply an "unimport" for:
  ## no Module::Whatever qw(arg arg arg);
  # sub _unexport {
  #   my (undef, undef, undef, undef, undef, $as, $into) = @_;
  # 
  #   if (ref $as eq 'SCALAR') {
  #     undef $$as;
  #   } elsif (ref $as) {
  #     Carp::croak "invalid reference type for $as: " . ref $as;
  #   } else {
  #     no strict 'refs';
  #     delete &{$into . '::' . $as};
  #   }
  # }
  
  
  sub default_generator {
    my ($arg) = @_;
    my ($class, $name, $generator) = @$arg{qw(class name generator)};
  
    if (not defined $generator) {
      my $code = $class->can($name)
        or Carp::croak "can't locate exported subroutine $name via $class";
      return $code;
    }
  
    # I considered making this "$class->$generator(" but it seems that
    # overloading precedence would turn an overloaded-as-code generator object
    # into a string before code. -- rjbs, 2006-06-11
    return $generator->($class, $name, $arg->{arg}, $arg->{col})
      if Params::Util::_CODELIKE($generator); ## no critic Private
  
    # This "must" be a scalar reference, to a generator method name.
    # -- rjbs, 2006-12-05
    return $class->$$generator($name, $arg->{arg}, $arg->{col});
  }
  
  
  sub default_installer {
    my ($arg, $to_export) = @_;
  
    for (my $i = 0; $i < @$to_export; $i += 2) {
      my ($as, $code) = @$to_export[ $i, $i+1 ];
  
      # Allow as isa ARRAY to push onto an array?
      # Allow into isa HASH to install name=>code into hash?
  
      if (ref $as eq 'SCALAR') {
        $$as = $code;
      } elsif (ref $as) {
        Carp::croak "invalid reference type for $as: " . ref $as;
      } else {
        Sub::Install::reinstall_sub({
          code => $code,
          into => $arg->{into},
          as   => $as
        });
      }
    }
  }
  
  sub default_exporter {
    Carp::cluck "default_exporter is deprecated; call default_installer instead; the semantics are identical";
    goto &default_installer;
  }
  
  
  setup_exporter({
    exports => [
      qw(setup_exporter build_exporter),
      _import => sub { build_exporter($_[2]) },
    ],
    groups  => {
      all   => [ qw(setup_exporter build_export) ],
    },
    collectors => { -setup => \&_setup },
  });
  
  sub _setup {
    my ($value, $arg) = @_;
  
    if (ref $value eq 'HASH') {
      push @{ $arg->{import_args} }, [ _import => { -as => 'import', %$value } ];
      return 1;
    } elsif (ref $value eq 'ARRAY') {
      push @{ $arg->{import_args} },
        [ _import => { -as => 'import', exports => $value } ];
      return 1;
    }
    return;
  }
  
  
  
  "jn8:32"; # <-- magic true value
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Sub::Exporter - a sophisticated exporter for custom-built routines
  
  =head1 VERSION
  
  version 0.987
  
  =head1 SYNOPSIS
  
  Sub::Exporter must be used in two places.  First, in an exporting module:
  
    # in the exporting module:
    package Text::Tweaker;
    use Sub::Exporter -setup => {
      exports => [
        qw(squish titlecase), # always works the same way
        reformat => \&build_reformatter, # generator to build exported function
        trim     => \&build_trimmer,
        indent   => \&build_indenter,
      ],
      collectors => [ 'defaults' ],
    };
  
  Then, in an importing module:
  
    # in the importing module:
    use Text::Tweaker
      'squish',
      indent   => { margin => 5 },
      reformat => { width => 79, justify => 'full', -as => 'prettify_text' },
      defaults => { eol => 'CRLF' };
  
  With this setup, the importing module ends up with three routines: C<squish>,
  C<indent>, and C<prettify_text>.  The latter two have been built to the
  specifications of the importer -- they are not just copies of the code in the
  exporting package.
  
  =head1 DESCRIPTION
  
  B<ACHTUNG!>  If you're not familiar with Exporter or exporting, read
  L<Sub::Exporter::Tutorial> first!
  
  =head2 Why Generators?
  
  The biggest benefit of Sub::Exporter over existing exporters (including the
  ubiquitous Exporter.pm) is its ability to build new coderefs for export, rather
  than to simply export code identical to that found in the exporting package.
  
  If your module's consumers get a routine that works like this:
  
    use Data::Analyze qw(analyze);
    my $value = analyze($data, $tolerance, $passes);
  
  and they constantly pass only one or two different set of values for the
  non-C<$data> arguments, your code can benefit from Sub::Exporter.  By writing a
  simple generator, you can let them do this, instead:
  
    use Data::Analyze
      analyze => { tolerance => 0.10, passes => 10, -as => analyze10 },
      analyze => { tolerance => 0.15, passes => 50, -as => analyze50 };
  
    my $value = analyze10($data);
  
  The package with the generator for that would look something like this:
  
    package Data::Analyze;
    use Sub::Exporter -setup => {
      exports => [
        analyze => \&build_analyzer,
      ],
    };
  
    sub build_analyzer {
      my ($class, $name, $arg) = @_;
  
      return sub {
        my $data      = shift;
        my $tolerance = shift || $arg->{tolerance}; 
        my $passes    = shift || $arg->{passes}; 
  
        analyze($data, $tolerance, $passes);
      }
    }
  
  Your module's user now has to do less work to benefit from it -- and remember,
  you're often your own user!  Investing in customized subroutines is an
  investment in future laziness.
  
  This also avoids a common form of ugliness seen in many modules: package-level
  configuration.  That is, you might have seen something like the above
  implemented like so:
  
    use Data::Analyze qw(analyze);
    $Data::Analyze::default_tolerance = 0.10;
    $Data::Analyze::default_passes    = 10;
  
  This might save time, until you have multiple modules using Data::Analyze.
  Because there is only one global configuration, they step on each other's toes
  and your code begins to have mysterious errors.
  
  Generators can also allow you to export class methods to be called as
  subroutines:
  
    package Data::Methodical;
    use Sub::Exporter -setup => { exports => { some_method => \&_curry_class } };
  
    sub _curry_class {
      my ($class, $name) = @_;
      sub { $class->$name(@_); };
    }
  
  Because of the way that exporters and Sub::Exporter work, any package that
  inherits from Data::Methodical can inherit its exporter and override its
  C<some_method>.  If a user imports C<some_method> from that package, he'll
  receive a subroutine that calls the method on the subclass, rather than on
  Data::Methodical itself.
  
  =head2 Other Customizations
  
  Building custom routines with generators isn't the only way that Sub::Exporters
  allows the importing code to refine its use of the exported routines.  They may
  also be renamed to avoid naming collisions.
  
  Consider the following code:
  
    # this program determines to which circle of Hell you will be condemned
    use Morality qw(sin virtue); # for calculating viciousness
    use Math::Trig qw(:all);     # for dealing with circles
  
  The programmer has inadvertently imported two C<sin> routines.  The solution,
  in Exporter.pm-based modules, would be to import only one and then call the
  other by its fully-qualified name.  Alternately, the importer could write a
  routine that did so, or could mess about with typeglobs.
  
  How much easier to write:
  
    # this program determines to which circle of Hell you will be condemned
    use Morality qw(virtue), sin => { -as => 'offense' };
    use Math::Trig -all => { -prefix => 'trig_' };
  
  and to have at one's disposal C<offense> and C<trig_sin> -- not to mention
  C<trig_cos> and C<trig_tan>.
  
  =head1 EXPORTER CONFIGURATION
  
  You can configure an exporter for your package by using Sub::Exporter like so:
  
    package Tools;
    use Sub::Exporter
      -setup => { exports => [ qw(function1 function2 function3) ] };
  
  This is the simplest way to use the exporter, and is basically equivalent to
  this:
  
    package Tools;
    use base qw(Exporter);
    our @EXPORT_OK = qw(function1 function2 function3);
  
  Any basic use of Sub::Exporter will look like this:
  
    package Tools;
    use Sub::Exporter -setup => \%config;
  
  The following keys are valid in C<%config>:
  
    exports - a list of routines to provide for exporting; each routine may be
              followed by generator
    groups  - a list of groups to provide for exporting; each must be followed by
              either (a) a list of exports, possibly with arguments for each
              export, or (b) a generator
  
    collectors - a list of names into which values are collected for use in
                 routine generation; each name may be followed by a validator
  
  In addition to the basic options above, a few more advanced options may be
  passed:
  
    into_level - how far up the caller stack to look for a target (default 0)
    into       - an explicit target (package) into which to export routines
  
  In other words: Sub::Exporter installs a C<import> routine which, when called,
  exports routines to the calling namespace.  The C<into> and C<into_level>
  options change where those exported routines are installed.
  
    generator  - a callback used to produce the code that will be installed
                 default: Sub::Exporter::default_generator
  
    installer  - a callback used to install the code produced by the generator
                 default: Sub::Exporter::default_installer
  
  For information on how these callbacks are used, see the documentation for
  C<L</default_generator>> and C<L</default_installer>>.
  
  =head2 Export Configuration
  
  The C<exports> list may be provided as an array reference or a hash reference.
  The list is processed in such a way that the following are equivalent:
  
    { exports => [ qw(foo bar baz), quux => \&quux_generator ] }
  
    { exports =>
      { foo => undef, bar => undef, baz => undef, quux => \&quux_generator } }
  
  Generators are code that return coderefs.  They are called with four
  parameters:
  
    $class - the class whose exporter has been called (the exporting class)
    $name  - the name of the export for which the routine is being build
   \%arg   - the arguments passed for this export
   \%col   - the collections for this import
  
  Given the configuration in the L</SYNOPSIS>, the following C<use> statement:
  
    use Text::Tweaker
      reformat => { -as => 'make_narrow', width => 33 },
      defaults => { eol => 'CR' };
  
  would result in the following call to C<&build_reformatter>:
  
    my $code = build_reformatter(
      'Text::Tweaker',
      'reformat',
      { width => 33 }, # note that -as is not passed in
      { defaults => { eol => 'CR' } },
    );
  
  The returned coderef (C<$code>) would then be installed as C<make_narrow> in the
  calling package.
  
  Instead of providing a coderef in the configuration, a reference to a method
  name may be provided.  This method will then be called on the invocant of the
  C<import> method.  (In this case, we do not pass the C<$class> parameter, as it
  would be redundant.)
  
  =head2 Group Configuration
  
  The C<groups> list can be passed in the same forms as C<exports>.  Groups must
  have values to be meaningful, which may either list exports that make up the
  group (optionally with arguments) or may provide a way to build the group.
  
  The simpler case is the first: a group definition is a list of exports.  Here's
  the example that could go in exporter in the L</SYNOPSIS>.
  
    groups  => {
      default    => [ qw(reformat) ],
      shorteners => [ qw(squish trim) ],
      email_safe => [
        'indent',
        reformat => { -as => 'email_format', width => 72 }
      ],
    },
  
  Groups are imported by specifying their name prefixed be either a dash or a
  colon.  This line of code would import the C<shorteners> group:
  
    use Text::Tweaker qw(-shorteners);
  
  Arguments passed to a group when importing are merged into the groups options
  and passed to any relevant generators.  Groups can contain other groups, but
  looping group structures are ignored.
  
  The other possible value for a group definition, a coderef, allows one
  generator to build several exportable routines simultaneously.  This is useful
  when many routines must share enclosed lexical variables.  The coderef must
  return a hash reference.  The keys will be used as export names and the values
  are the subs that will be exported.
  
  This example shows a simple use of the group generator.
  
    package Data::Crypto;
    use Sub::Exporter -setup => { groups => { cipher => \&build_cipher_group } };
  
    sub build_cipher_group {
      my ($class, $group, $arg) = @_;
      my ($encode, $decode) = build_codec($arg->{secret});
      return { cipher => $encode, decipher => $decode };
    }
  
  The C<cipher> and C<decipher> routines are built in a group because they are
  built together by code which encloses their secret in their environment.
  
  =head3 Default Groups
  
  If a module that uses Sub::Exporter is C<use>d with no arguments, it will try
  to export the group named C<default>.  If that group has not been specifically
  configured, it will be empty, and nothing will happen.
  
  Another group is also created if not defined: C<all>.  The C<all> group
  contains all the exports from the exports list.
  
  =head2 Collector Configuration
  
  The C<collectors> entry in the exporter configuration gives names which, when
  found in the import call, have their values collected and passed to every
  generator.
  
  For example, the C<build_analyzer> generator that we saw above could be
  rewritten as:
  
   sub build_analyzer {
     my ($class, $name, $arg, $col) = @_;
  
     return sub {
       my $data      = shift;
       my $tolerance = shift || $arg->{tolerance} || $col->{defaults}{tolerance}; 
       my $passes    = shift || $arg->{passes}    || $col->{defaults}{passes}; 
  
       analyze($data, $tolerance, $passes);
     }
   }
  
  That would allow the importer to specify global defaults for his imports:
  
    use Data::Analyze
      'analyze',
      analyze  => { tolerance => 0.10, -as => analyze10 },
      analyze  => { tolerance => 0.15, passes => 50, -as => analyze50 },
      defaults => { passes => 10 };
  
    my $A = analyze10($data);     # equivalent to analyze($data, 0.10, 10);
    my $C = analyze50($data);     # equivalent to analyze($data, 0.15, 50);
    my $B = analyze($data, 0.20); # equivalent to analyze($data, 0.20, 10);
  
  If values are provided in the C<collectors> list during exporter setup, they
  must be code references, and are used to validate the importer's values.  The
  validator is called when the collection is found, and if it returns false, an
  exception is thrown.  We could ensure that no one tries to set a global data
  default easily:
  
    collectors => { defaults => sub { return (exists $_[0]->{data}) ? 0 : 1 } }
  
  Collector coderefs can also be used as hooks to perform arbitrary actions
  before anything is exported.
  
  When the coderef is called, it is passed the value of the collection and a
  hashref containing the following entries:
  
    name        - the name of the collector
    config      - the exporter configuration (hashref)
    import_args - the arguments passed to the exporter, sans collections (aref)
    class       - the package on which the importer was called
    into        - the package into which exports will be exported
  
  Collectors with all-caps names (that is, made up of underscore or capital A
  through Z) are reserved for special use.  The only currently implemented
  special collector is C<INIT>, whose hook (if present in the exporter
  configuration) is always run before any other hook.
  
  =head1 CALLING THE EXPORTER
  
  Arguments to the exporter (that is, the arguments after the module name in a
  C<use> statement) are parsed as follows:
  
  First, the collectors gather any collections found in the arguments.  Any
  reference type may be given as the value for a collector.  For each collection
  given in the arguments, its validator (if any) is called.  
  
  Next, groups are expanded.  If the group is implemented by a group generator,
  the generator is called.  There are two special arguments which, if given to a
  group, have special meaning:
  
    -prefix - a string to prepend to any export imported from this group
    -suffix - a string to append to any export imported from this group
  
  Finally, individual export generators are called and all subs, generated or
  otherwise, are installed in the calling package.  There is only one special
  argument for export generators:
  
    -as     - where to install the exported sub
  
  Normally, C<-as> will contain an alternate name for the routine.  It may,
  however, contain a reference to a scalar.  If that is the case, a reference the
  generated routine will be placed in the scalar referenced by C<-as>.  It will
  not be installed into the calling package.
  
  =head2 Special Exporter Arguments
  
  The generated exporter accept some special options, which may be passed as the
  first argument, in a hashref.
  
  These options are:
  
    into_level
    into
    generator
    installer
  
  These override the same-named configuration options described in L</EXPORTER
  CONFIGURATION>.
  
  =head1 SUBROUTINES
  
  =head2 setup_exporter
  
  This routine builds and installs an C<import> routine.  It is called with one
  argument, a hashref containing the exporter configuration.  Using this, it
  builds an exporter and installs it into the calling package with the name
  "import."  In addition to the normal exporter configuration, a few named
  arguments may be passed in the hashref:
  
    into       - into what package should the exporter be installed
    into_level - into what level up the stack should the exporter be installed
    as         - what name should the installed exporter be given
  
  By default the exporter is installed with the name C<import> into the immediate
  caller of C<setup_exporter>.  In other words, if your package calls
  C<setup_exporter> without providing any of the three above arguments, it will
  have an C<import> routine installed.
  
  Providing both C<into> and C<into_level> will cause an exception to be thrown.
  
  The exporter is built by C<L</build_exporter>>.
  
  =head2 build_exporter
  
  Given a standard exporter configuration, this routine builds and returns an
  exporter -- that is, a subroutine that can be installed as a class method to
  perform exporting on request.
  
  Usually, this method is called by C<L</setup_exporter>>, which then installs
  the exporter as a package's import routine.
  
  =head2 default_generator
  
  This is Sub::Exporter's default generator.  It takes bits of configuration that
  have been gathered during the import and turns them into a coderef that can be
  installed.
  
    my $code = default_generator(\%arg);
  
  Passed arguments are:
  
    class - the class on which the import method was called
    name  - the name of the export being generated
    arg   - the arguments to the generator
    col   - the collections
  
    generator - the generator to be used to build the export (code or scalar ref)
  
  =head2 default_installer
  
  This is Sub::Exporter's default installer.  It does what Sub::Exporter
  promises: it installs code into the target package.
  
    default_installer(\%arg, \@to_export);
  
  Passed arguments are:
  
    into - the package into which exports should be delivered
  
  C<@to_export> is a list of name/value pairs.  The default exporter assigns code
  (the values) to named slots (the names) in the given package.  If the name is a
  scalar reference, the scalar reference is made to point to the code reference
  instead.
  
  =head1 EXPORTS
  
  Sub::Exporter also offers its own exports: the C<setup_exporter> and
  C<build_exporter> routines described above.  It also provides a special "setup"
  collector, which will set up an exporter using the parameters passed to it.
  
  Note that the "setup" collector (seen in examples like the L</SYNOPSIS> above)
  uses C<build_exporter>, not C<setup_exporter>.  This means that the special
  arguments like "into" and "as" for C<setup_exporter> are not accepted here.
  Instead, you may write something like:
  
    use Sub::Exporter
      { into => 'Target::Package' },
      -setup => {
        -as     => 'do_import',
        exports => [ ... ],
      }
    ;
  
  Finding a good reason for wanting to do this is left as an exercise for the
  reader.
  
  =head1 COMPARISONS
  
  There are a whole mess of exporters on the CPAN.  The features included in
  Sub::Exporter set it apart from any existing Exporter.  Here's a summary of
  some other exporters and how they compare.
  
  =over
  
  =item * L<Exporter> and co.
  
  This is the standard Perl exporter.  Its interface is a little clunky, but it's
  fast and ubiquitous.  It can do some things that Sub::Exporter can't:  it can
  export things other than routines, it can import "everything in this group
  except this symbol," and some other more esoteric things.  These features seem
  to go nearly entirely unused.
  
  It always exports things exactly as they appear in the exporting module; it
  can't rename or customize routines.  Its groups ("tags") can't be nested.
  
  L<Exporter::Lite> is a whole lot like Exporter, but it does significantly less:
  it supports exporting symbols, but not groups, pattern matching, or negation.
  
  The fact that Sub::Exporter can't export symbols other than subroutines is
  a good idea, not a missing feature.
  
  For simple uses, setting up Sub::Exporter is about as easy as Exporter.  For
  complex uses, Sub::Exporter makes hard things possible, which would not be
  possible with Exporter. 
  
  When using a module that uses Sub::Exporter, users familiar with Exporter will
  probably see no difference in the basics.  These two lines do about the same
  thing in whether the exporting module uses Exporter or Sub::Exporter.
  
    use Some::Module qw(foo bar baz);
    use Some::Module qw(foo :bar baz);
  
  The definition for exporting in Exporter.pm might look like this:
  
    package Some::Module;
    use base qw(Exporter);
    our @EXPORT_OK   = qw(foo bar baz quux);
    our %EXPORT_TAGS = (bar => [ qw(bar baz) ]);
  
  Using Sub::Exporter, it would look like this:
  
    package Some::Module;
    use Sub::Exporter -setup => {
      exports => [ qw(foo bar baz quux) ],
      groups  => { bar => [ qw(bar baz) ]}
    };
  
  Sub::Exporter respects inheritance, so that a package may export inherited
  routines, and will export the most inherited version.  Exporting methods
  without currying away the invocant is a bad idea, but Sub::Exporter allows you
  to do just that -- and anyway, there are other uses for this feature, like
  packages of exported subroutines which use inheritance specifically to allow
  more specialized, but similar, packages.
  
  L<Exporter::Easy> provides a wrapper around the standard Exporter.  It makes it
  simpler to build groups, but doesn't provide any more functionality.  Because
  it is a front-end to Exporter, it will store your exporter's configuration in
  global package variables.
  
  =item * Attribute-Based Exporters
  
  Some exporters use attributes to mark variables to export.  L<Exporter::Simple>
  supports exporting any kind of symbol, and supports groups.  Using a module
  like Exporter or Sub::Exporter, it's easy to look at one place and see what is
  exported, but it's impossible to look at a variable definition and see whether
  it is exported by that alone.  Exporter::Simple makes this trade in reverse:
  each variable's declaration includes its export definition, but there is no one
  place to look to find a manifest of exports.
  
  More importantly, Exporter::Simple does not add any new features to those of
  Exporter.  In fact, like Exporter::Easy, it is just a front-end to Exporter, so
  it ends up storing its configuration in global package variables.  (This means
  that there is one place to look for your exporter's manifest, actually.  You
  can inspect the C<@EXPORT> package variables, and other related package
  variables, at runtime.)
  
  L<Perl6::Export> isn't actually attribute based, but looks similar.  Its syntax
  is borrowed from Perl 6, and implemented by a source filter.  It is a prototype
  of an interface that is still being designed.  It should probably be avoided
  for production work.  On the other hand, L<Perl6::Export::Attrs> implements
  Perl 6-like exporting, but translates it into Perl 5 by providing attributes.
  
  =item * Other Exporters
  
  L<Exporter::Renaming> wraps the standard Exporter to allow it to export symbols
  with changed names.
  
  L<Class::Exporter> performs a special kind of routine generation, giving each
  importing package an instance of your class, and then exporting the instance's
  methods as normal routines.  (Sub::Exporter, of course, can easily emulate this
  behavior, as shown above.)
  
  L<Exporter::Tidy> implements a form of renaming (using its C<_map> argument)
  and of prefixing, and implements groups.  It also avoids using package
  variables for its configuration.
  
  =back
  
  =head1 TODO
  
  =over
  
  =item * write a set of longer, more demonstrative examples
  
  =item * solidify the "custom exporter" interface (see C<&default_exporter>)
  
  =item * add an "always" group
  
  =back
  
  =head1 THANKS
  
  Hans Dieter Pearcey provided helpful advice while I was writing Sub::Exporter.
  Ian Langworth and Shawn Sorichetti asked some good questions and helped me
  improve my documentation quite a bit.  Yuval Kogman helped me find a bunch of
  little problems.
  
  Thanks, guys! 
  
  =head1 BUGS
  
  Please report any bugs or feature requests through the web interface at
  L<http://rt.cpan.org>. I will be notified, and then you'll automatically be
  notified of progress on your bug as I make changes.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2007 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_EXPORTER

$fatpacked{"Sub/Exporter/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_UTIL';
  use strict;
  use warnings;
  package Sub::Exporter::Util;
  {
    $Sub::Exporter::Util::VERSION = '0.987';
  }
  # ABSTRACT: utilities to make Sub::Exporter easier
  
  use Data::OptList ();
  use Params::Util ();
  
  
  sub curry_method {
    my $override_name = shift;
    sub {
      my ($class, $name) = @_;
      $name = $override_name if defined $override_name;
      sub { $class->$name(@_); };
    }
  }
  
  BEGIN { *curry_class = \&curry_method; }
  
  
  sub curry_chain {
    # In the future, we can make \%arg an optional prepend, like the "special"
    # args to the default Sub::Exporter-generated import routine.
    my (@opt_list) = @_;
  
    my $pairs = Data::OptList::mkopt(\@opt_list, 'args', 'ARRAY');
  
    sub {
      my ($class) = @_;
  
      sub {
        my $next = $class;
  
        for my $i (0 .. $#$pairs) {
          my $pair = $pairs->[ $i ];
          
          unless (Params::Util::_INVOCANT($next)) { ## no critic Private
            my $str = defined $next ? "'$next'" : 'undef';
            Carp::croak("can't call $pair->[0] on non-invocant $str")
          }
  
          my ($method, $args) = @$pair;
  
          if ($i == $#$pairs) {
            return $next->$method($args ? @$args : ());
          } else {
            $next = $next->$method($args ? @$args : ());
          }
        }
      };
    }
  }
  
  # =head2 name_map
  # 
  # This utility returns an list to be used in specify export generators.  For
  # example, the following:
  # 
  #   exports => {
  #     name_map(
  #       '_?_gen'  => [ qw(fee fie) ],
  #       '_make_?' => [ qw(foo bar) ],
  #     ),
  #   }
  # 
  # is equivalent to:
  # 
  #   exports => {
  #     name_map(
  #       fee => \'_fee_gen',
  #       fie => \'_fie_gen',
  #       foo => \'_make_foo',
  #       bar => \'_make_bar',
  #     ),
  #   }
  # 
  # This can save a lot of typing, when providing many exports with similarly-named
  # generators.
  # 
  # =cut
  # 
  # sub name_map {
  #   my (%groups) = @_;
  # 
  #   my %map;
  # 
  #   while (my ($template, $names) = each %groups) {
  #     for my $name (@$names) {
  #       (my $export = $template) =~ s/\?/$name/
  #         or Carp::croak 'no ? found in name_map template';
  # 
  #       $map{ $name } = \$export;
  #     }
  #   }
  # 
  #   return %map;
  # }
  
  
  sub merge_col {
    my (%groups) = @_;
  
    my %merged;
  
    while (my ($default_name, $group) = each %groups) {
      while (my ($export_name, $gen) = each %$group) {
        $merged{$export_name} = sub {
          my ($class, $name, $arg, $col) = @_;
  
          my $merged_arg = exists $col->{$default_name}
                         ? { %{ $col->{$default_name} }, %$arg }
                         : $arg;
  
          if (Params::Util::_CODELIKE($gen)) { ## no critic Private
            $gen->($class, $name, $merged_arg, $col);
          } else {
            $class->$$gen($name, $merged_arg, $col);
          }
        }
      }
    }
  
    return %merged;
  }
  
  
  sub __mixin_class_for {
    my ($class, $mix_into) = @_;
    require Package::Generator;
    my $mixin_class = Package::Generator->new_package({
      base => "$class\:\:__mixin__",
    });
  
    ## no critic (ProhibitNoStrict)
    no strict 'refs';
    if (ref $mix_into) {
      unshift @{"$mixin_class" . "::ISA"}, ref $mix_into;
    } else {
      unshift @{"$mix_into" . "::ISA"}, $mixin_class;
    }
    return $mixin_class;
  }
  
  sub mixin_installer {
    sub {
      my ($arg, $to_export) = @_;
  
      my $mixin_class = __mixin_class_for($arg->{class}, $arg->{into});
      bless $arg->{into} => $mixin_class if ref $arg->{into};
  
      Sub::Exporter::default_installer(
        { %$arg, into => $mixin_class },
        $to_export,
      );
    };
  }
  
  sub mixin_exporter {
    Carp::cluck "mixin_exporter is deprecated; use mixin_installer instead; it behaves identically";
    return mixin_installer;
  }
  
  
  sub like {
    sub {
      my ($value, $arg) = @_;
      Carp::croak "no regex supplied to regex group generator" unless $value;
  
      # Oh, qr//, how you bother me!  See the p5p thread from around now about
      # fixing this problem... too bad it won't help me. -- rjbs, 2006-04-25
      my @values = eval { $value->isa('Regexp') } ? ($value, undef)
                 :                                  @$value;
  
      while (my ($re, $opt) = splice @values, 0, 2) {
        Carp::croak "given pattern for regex group generater is not a Regexp"
          unless eval { $re->isa('Regexp') };
        my @exports  = keys %{ $arg->{config}->{exports} };
        my @matching = grep { $_ =~ $re } @exports;
  
        my %merge = $opt ? %$opt : ();
        my $prefix = (delete $merge{-prefix}) || '';
        my $suffix = (delete $merge{-suffix}) || '';
  
        for my $name (@matching) {
          my $as = $prefix . $name . $suffix;
          push @{ $arg->{import_args} }, [ $name => { %merge, -as => $as } ];
        }
      }
  
      1;
    }
  }
  
  use Sub::Exporter -setup => {
    exports => [ qw(
      like
      name_map
      merge_col
      curry_method curry_class
      curry_chain
      mixin_installer mixin_exporter
    ) ]
  };
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Sub::Exporter::Util - utilities to make Sub::Exporter easier
  
  =head1 VERSION
  
  version 0.987
  
  =head1 DESCRIPTION
  
  This module provides a number of utility functions for performing common or
  useful operations when setting up a Sub::Exporter configuration.  All of the
  utilities may be exported, but none are by default.
  
  =head1 THE UTILITIES
  
  =head2 curry_method
  
    exports => {
      some_method => curry_method,
    }
  
  This utility returns a generator which will produce an invocant-curried version
  of a method.  In other words, it will export a method call with the exporting
  class built in as the invocant.
  
  A module importing the code some the above example might do this:
  
    use Some::Module qw(some_method);
  
    my $x = some_method;
  
  This would be equivalent to:
  
    use Some::Module;
  
    my $x = Some::Module->some_method;
  
  If Some::Module is subclassed and the subclass's import method is called to
  import C<some_method>, the subclass will be curried in as the invocant.
  
  If an argument is provided for C<curry_method> it is used as the name of the
  curried method to export.  This means you could export a Widget constructor
  like this:
  
    exports => { widget => curry_method('new') }
  
  This utility may also be called as C<curry_class>, for backwards compatibility.
  
  =head2 curry_chain
  
  C<curry_chain> behaves like C<L</curry_method>>, but is meant for generating
  exports that will call several methods in succession.
  
    exports => {
      reticulate => curry_chain(
        new => gather_data => analyze => [ detail => 100 ] => 'results'
      ),
    }
  
  If imported from Spliner, calling the C<reticulate> routine will be equivalent
  to:
  
    Spliner->new->gather_data->analyze(detail => 100)->results;
  
  If any method returns something on which methods may not be called, the routine
  croaks.
  
  The arguments to C<curry_chain> form an optlist.  The names are methods to be
  called and the arguments, if given, are arrayrefs to be dereferenced and passed
  as arguments to those methods.  C<curry_chain> returns a generator like those
  expected by Sub::Exporter.
  
  B<Achtung!> at present, there is no way to pass arguments from the generated
  routine to the method calls.  This will probably be solved in future revisions
  by allowing the opt list's values to be subroutines that will be called with
  the generated routine's stack.
  
  =head2 merge_col
  
    exports => {
      merge_col(defaults => {
        twiddle => \'_twiddle_gen',
        tweak   => \&_tweak_gen,
      }),
    }
  
  This utility wraps the given generator in one that will merge the named
  collection into its args before calling it.  This means that you can support a
  "default" collector in multiple exports without writing the code each time.
  
  You can specify as many pairs of collection names and generators as you like.
  
  =head2 mixin_installer
  
    use Sub::Exporter -setup => {
      installer => Sub::Exporter::Util::mixin_installer,
      exports   => [ qw(foo bar baz) ],
    };
  
  This utility returns an installer that will install into a superclass and
  adjust the ISA importing class to include the newly generated superclass.
  
  If the target of importing is an object, the hierarchy is reversed: the new
  class will be ISA the object's class, and the object will be reblessed.
  
  B<Prerequisites>: This utility requires that Package::Generator be installed.
  
  =head2 like
  
  It's a collector that adds imports for anything like given regex.
  
  If you provide this configuration:
  
    exports    => [ qw(igrep imap islurp exhausted) ],
    collectors => { -like => Sub::Exporter::Util::like },
  
  A user may import from your module like this:
  
    use Your::Iterator -like => qr/^i/; # imports igre, imap, islurp
  
  or
  
    use Your::Iterator -like => [ qr/^i/ => { -prefix => 'your_' } ];
  
  The group-like prefix and suffix arguments are respected; other arguments are
  passed on to the generators for matching exports.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2007 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_EXPORTER_UTIL

$fatpacked{"Sub/Install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_INSTALL';
  use strict;
  use warnings;
  package Sub::Install;
  # ABSTRACT: install subroutines into packages easily
  $Sub::Install::VERSION = '0.928';
  use Carp;
  use Scalar::Util ();
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   use Sub::Install;
  #pod
  #pod   Sub::Install::install_sub({
  #pod     code => sub { ... },
  #pod     into => $package,
  #pod     as   => $subname
  #pod   });
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This module makes it easy to install subroutines into packages without the
  #pod unsightly mess of C<no strict> or typeglobs lying about where just anyone can
  #pod see them.
  #pod
  #pod =func install_sub
  #pod
  #pod   Sub::Install::install_sub({
  #pod    code => \&subroutine,
  #pod    into => "Finance::Shady",
  #pod    as   => 'launder',
  #pod   });
  #pod
  #pod This routine installs a given code reference into a package as a normal
  #pod subroutine.  The above is equivalent to:
  #pod
  #pod   no strict 'refs';
  #pod   *{"Finance::Shady" . '::' . "launder"} = \&subroutine;
  #pod
  #pod If C<into> is not given, the sub is installed into the calling package.
  #pod
  #pod If C<code> is not a code reference, it is looked for as an existing sub in the
  #pod package named in the C<from> parameter.  If C<from> is not given, it will look
  #pod in the calling package.
  #pod
  #pod If C<as> is not given, and if C<code> is a name, C<as> will default to C<code>.
  #pod If C<as> is not given, but if C<code> is a code ref, Sub::Install will try to
  #pod find the name of the given code ref and use that as C<as>.
  #pod
  #pod That means that this code:
  #pod
  #pod   Sub::Install::install_sub({
  #pod     code => 'twitch',
  #pod     from => 'Person::InPain',
  #pod     into => 'Person::Teenager',
  #pod     as   => 'dance',
  #pod   });
  #pod
  #pod is the same as:
  #pod
  #pod   package Person::Teenager;
  #pod
  #pod   Sub::Install::install_sub({
  #pod     code => Person::InPain->can('twitch'),
  #pod     as   => 'dance',
  #pod   });
  #pod
  #pod =func reinstall_sub
  #pod
  #pod This routine behaves exactly like C<L</install_sub>>, but does not emit a
  #pod warning if warnings are on and the destination is already defined.
  #pod
  #pod =cut
  
  sub _name_of_code {
    my ($code) = @_;
    require B;
    my $name = B::svref_2object($code)->GV->NAME;
    return $name unless $name =~ /\A__ANON__/;
    return;
  }
  
  # See also Params::Util, to which this code was donated.
  sub _CODELIKE {
    (Scalar::Util::reftype($_[0])||'') eq 'CODE'
    || Scalar::Util::blessed($_[0])
    && (overload::Method($_[0],'&{}') ? $_[0] : undef);
  }
  
  # do the heavy lifting
  sub _build_public_installer {
    my ($installer) = @_;
  
    sub {
      my ($arg) = @_;
      my ($calling_pkg) = caller(0);
  
      # I'd rather use ||= but I'm whoring for Devel::Cover.
      for (qw(into from)) { $arg->{$_} = $calling_pkg unless $arg->{$_} }
  
      # This is the only absolutely required argument, in many cases.
      Carp::croak "named argument 'code' is not optional" unless $arg->{code};
  
      if (_CODELIKE($arg->{code})) {
        $arg->{as} ||= _name_of_code($arg->{code});
      } else {
        Carp::croak
          "couldn't find subroutine named $arg->{code} in package $arg->{from}"
          unless my $code = $arg->{from}->can($arg->{code});
  
        $arg->{as}   = $arg->{code} unless $arg->{as};
        $arg->{code} = $code;
      }
  
      Carp::croak "couldn't determine name under which to install subroutine"
        unless $arg->{as};
  
      $installer->(@$arg{qw(into as code) });
    }
  }
  
  # do the ugly work
  
  my $_misc_warn_re;
  my $_redef_warn_re;
  BEGIN {
    $_misc_warn_re = qr/
      Prototype\ mismatch:\ sub\ .+?  |
      Constant subroutine .+? redefined
    /x;
    $_redef_warn_re = qr/Subroutine\ .+?\ redefined/x;
  }
  
  my $eow_re;
  BEGIN { $eow_re = qr/ at .+? line \d+\.\Z/ };
  
  sub _do_with_warn {
    my ($arg) = @_;
    my $code = delete $arg->{code};
    my $wants_code = sub {
      my $code = shift;
      sub {
        my $warn = $SIG{__WARN__} ? $SIG{__WARN__} : sub { warn @_ }; ## no critic
        local $SIG{__WARN__} = sub {
          my ($error) = @_;
          for (@{ $arg->{suppress} }) {
              return if $error =~ $_;
          }
          for (@{ $arg->{croak} }) {
            if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
              Carp::croak $base_error;
            }
          }
          for (@{ $arg->{carp} }) {
            if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
              return $warn->(Carp::shortmess $base_error);
            }
          }
          ($arg->{default} || $warn)->($error);
        };
        $code->(@_);
      };
    };
    return $wants_code->($code) if $code;
    return $wants_code;
  }
  
  sub _installer {
    sub {
      my ($pkg, $name, $code) = @_;
      no strict 'refs'; ## no critic ProhibitNoStrict
      *{"$pkg\::$name"} = $code;
      return $code;
    }
  }
  
  BEGIN {
    *_ignore_warnings = _do_with_warn({
      carp => [ $_misc_warn_re, $_redef_warn_re ]
    });
  
    *install_sub = _build_public_installer(_ignore_warnings(_installer));
  
    *_carp_warnings =  _do_with_warn({
      carp     => [ $_misc_warn_re ],
      suppress => [ $_redef_warn_re ],
    });
  
    *reinstall_sub = _build_public_installer(_carp_warnings(_installer));
  
    *_install_fatal = _do_with_warn({
      code     => _installer,
      croak    => [ $_redef_warn_re ],
    });
  }
  
  #pod =func install_installers
  #pod
  #pod This routine is provided to allow Sub::Install compatibility with
  #pod Sub::Installer.  It installs C<install_sub> and C<reinstall_sub> methods into
  #pod the package named by its argument.
  #pod
  #pod  Sub::Install::install_installers('Code::Builder'); # just for us, please
  #pod  Code::Builder->install_sub({ name => $code_ref });
  #pod
  #pod  Sub::Install::install_installers('UNIVERSAL'); # feeling lucky, punk?
  #pod  Anything::At::All->install_sub({ name => $code_ref });
  #pod
  #pod The installed installers are similar, but not identical, to those provided by
  #pod Sub::Installer.  They accept a single hash as an argument.  The key/value pairs
  #pod are used as the C<as> and C<code> parameters to the C<install_sub> routine
  #pod detailed above.  The package name on which the method is called is used as the
  #pod C<into> parameter.
  #pod
  #pod Unlike Sub::Installer's C<install_sub> will not eval strings into code, but
  #pod will look for named code in the calling package.
  #pod
  #pod =cut
  
  sub install_installers {
    my ($into) = @_;
  
    for my $method (qw(install_sub reinstall_sub)) {
      my $code = sub {
        my ($package, $subs) = @_;
        my ($caller) = caller(0);
        my $return;
        for (my ($name, $sub) = %$subs) {
          $return = Sub::Install->can($method)->({
            code => $sub,
            from => $caller,
            into => $package,
            as   => $name
          });
        }
        return $return;
      };
      install_sub({ code => $code, into => $into, as => $method });
    }
  }
  
  #pod =head1 EXPORTS
  #pod
  #pod Sub::Install exports C<install_sub> and C<reinstall_sub> only if they are
  #pod requested.
  #pod
  #pod =head2 exporter
  #pod
  #pod Sub::Install has a never-exported subroutine called C<exporter>, which is used
  #pod to implement its C<import> routine.  It takes a hashref of named arguments,
  #pod only one of which is currently recognize: C<exports>.  This must be an arrayref
  #pod of subroutines to offer for export.
  #pod
  #pod This routine is mainly for Sub::Install's own consumption.  Instead, consider
  #pod L<Sub::Exporter>.
  #pod
  #pod =cut
  
  sub exporter {
    my ($arg) = @_;
  
    my %is_exported = map { $_ => undef } @{ $arg->{exports} };
  
    sub {
      my $class = shift;
      my $target = caller;
      for (@_) {
        Carp::croak "'$_' is not exported by $class" if !exists $is_exported{$_};
        install_sub({ code => $_, from => $class, into => $target });
      }
    }
  }
  
  BEGIN { *import = exporter({ exports => [ qw(install_sub reinstall_sub) ] }); }
  
  #pod =head1 SEE ALSO
  #pod
  #pod =over
  #pod
  #pod =item L<Sub::Installer>
  #pod
  #pod This module is (obviously) a reaction to Damian Conway's Sub::Installer, which
  #pod does the same thing, but does it by getting its greasy fingers all over
  #pod UNIVERSAL.  I was really happy about the idea of making the installation of
  #pod coderefs less ugly, but I couldn't bring myself to replace the ugliness of
  #pod typeglobs and loosened strictures with the ugliness of UNIVERSAL methods.
  #pod
  #pod =item L<Sub::Exporter>
  #pod
  #pod This is a complete Exporter.pm replacement, built atop Sub::Install.
  #pod
  #pod =back
  #pod
  #pod =head1 EXTRA CREDITS
  #pod
  #pod Several of the tests are adapted from tests that shipped with Damian Conway's
  #pod Sub-Installer distribution.
  #pod
  #pod =cut
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Sub::Install - install subroutines into packages easily
  
  =head1 VERSION
  
  version 0.928
  
  =head1 SYNOPSIS
  
    use Sub::Install;
  
    Sub::Install::install_sub({
      code => sub { ... },
      into => $package,
      as   => $subname
    });
  
  =head1 DESCRIPTION
  
  This module makes it easy to install subroutines into packages without the
  unsightly mess of C<no strict> or typeglobs lying about where just anyone can
  see them.
  
  =head1 FUNCTIONS
  
  =head2 install_sub
  
    Sub::Install::install_sub({
     code => \&subroutine,
     into => "Finance::Shady",
     as   => 'launder',
    });
  
  This routine installs a given code reference into a package as a normal
  subroutine.  The above is equivalent to:
  
    no strict 'refs';
    *{"Finance::Shady" . '::' . "launder"} = \&subroutine;
  
  If C<into> is not given, the sub is installed into the calling package.
  
  If C<code> is not a code reference, it is looked for as an existing sub in the
  package named in the C<from> parameter.  If C<from> is not given, it will look
  in the calling package.
  
  If C<as> is not given, and if C<code> is a name, C<as> will default to C<code>.
  If C<as> is not given, but if C<code> is a code ref, Sub::Install will try to
  find the name of the given code ref and use that as C<as>.
  
  That means that this code:
  
    Sub::Install::install_sub({
      code => 'twitch',
      from => 'Person::InPain',
      into => 'Person::Teenager',
      as   => 'dance',
    });
  
  is the same as:
  
    package Person::Teenager;
  
    Sub::Install::install_sub({
      code => Person::InPain->can('twitch'),
      as   => 'dance',
    });
  
  =head2 reinstall_sub
  
  This routine behaves exactly like C<L</install_sub>>, but does not emit a
  warning if warnings are on and the destination is already defined.
  
  =head2 install_installers
  
  This routine is provided to allow Sub::Install compatibility with
  Sub::Installer.  It installs C<install_sub> and C<reinstall_sub> methods into
  the package named by its argument.
  
   Sub::Install::install_installers('Code::Builder'); # just for us, please
   Code::Builder->install_sub({ name => $code_ref });
  
   Sub::Install::install_installers('UNIVERSAL'); # feeling lucky, punk?
   Anything::At::All->install_sub({ name => $code_ref });
  
  The installed installers are similar, but not identical, to those provided by
  Sub::Installer.  They accept a single hash as an argument.  The key/value pairs
  are used as the C<as> and C<code> parameters to the C<install_sub> routine
  detailed above.  The package name on which the method is called is used as the
  C<into> parameter.
  
  Unlike Sub::Installer's C<install_sub> will not eval strings into code, but
  will look for named code in the calling package.
  
  =head1 EXPORTS
  
  Sub::Install exports C<install_sub> and C<reinstall_sub> only if they are
  requested.
  
  =head2 exporter
  
  Sub::Install has a never-exported subroutine called C<exporter>, which is used
  to implement its C<import> routine.  It takes a hashref of named arguments,
  only one of which is currently recognize: C<exports>.  This must be an arrayref
  of subroutines to offer for export.
  
  This routine is mainly for Sub::Install's own consumption.  Instead, consider
  L<Sub::Exporter>.
  
  =head1 SEE ALSO
  
  =over
  
  =item L<Sub::Installer>
  
  This module is (obviously) a reaction to Damian Conway's Sub::Installer, which
  does the same thing, but does it by getting its greasy fingers all over
  UNIVERSAL.  I was really happy about the idea of making the installation of
  coderefs less ugly, but I couldn't bring myself to replace the ugliness of
  typeglobs and loosened strictures with the ugliness of UNIVERSAL methods.
  
  =item L<Sub::Exporter>
  
  This is a complete Exporter.pm replacement, built atop Sub::Install.
  
  =back
  
  =head1 EXTRA CREDITS
  
  Several of the tests are adapted from tests that shipped with Damian Conway's
  Sub-Installer distribution.
  
  =head1 AUTHOR
  
  Ricardo SIGNES <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2005 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_INSTALL

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny; # git description: v0.29-2-g3b23a06
  use 5.006;
  # ABSTRACT: Minimal try/catch with proper preservation of $@
  
  our $VERSION = '0.30';
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT = our @EXPORT_OK = qw(try catch finally);
  
  use Carp;
  $Carp::Internal{+__PACKAGE__}++;
  
  BEGIN {
    my $su = $INC{'Sub/Util.pm'} && defined &Sub::Util::set_subname;
    my $sn = $INC{'Sub/Name.pm'} && eval { Sub::Name->VERSION(0.08) };
    unless ($su || $sn) {
      $su = eval { require Sub::Util; } && defined &Sub::Util::set_subname;
      unless ($su) {
        $sn = eval { require Sub::Name; Sub::Name->VERSION(0.08) };
      }
    }
  
    *_subname = $su ? \&Sub::Util::set_subname
              : $sn ? \&Sub::Name::subname
              : sub { $_[1] };
    *_HAS_SUBNAME = ($su || $sn) ? sub(){1} : sub(){0};
  }
  
  my %_finally_guards;
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
    my ( $try, @code_refs ) = @_;
  
    # we need to save this here, the eval block will be in scalar context due
    # to $failed
    my $wantarray = wantarray;
  
    # work around perl bug by explicitly initializing these, due to the likelyhood
    # this will be used in global destruction (perl rt#119311)
    my ( $catch, @finally ) = ();
  
    # find labeled blocks in the argument list.
    # catch and finally tag the blocks by blessing a scalar reference to them.
    foreach my $code_ref (@code_refs) {
  
      if ( ref($code_ref) eq 'Try::Tiny::Catch' ) {
        croak 'A try() may not be followed by multiple catch() blocks'
          if $catch;
        $catch = ${$code_ref};
      } elsif ( ref($code_ref) eq 'Try::Tiny::Finally' ) {
        push @finally, ${$code_ref};
      } else {
        croak(
          'try() encountered an unexpected argument ('
        . ( defined $code_ref ? $code_ref : 'undef' )
        . ') - perhaps a missing semi-colon before or'
        );
      }
    }
  
    # FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
    # not perfect, but we could provide a list of additional errors for
    # $catch->();
  
    # name the blocks if we have Sub::Name installed
    _subname(caller().'::try {...} ' => $try)
      if _HAS_SUBNAME;
  
    # set up scope guards to invoke the finally blocks at the end.
    # this should really be a function scope lexical variable instead of
    # file scope + local but that causes issues with perls < 5.20 due to
    # perl rt#119311
    local $_finally_guards{guards} = [
      map { Try::Tiny::ScopeGuard->_new($_) }
      @finally
    ];
  
    # save the value of $@ so we can set $@ back to it in the beginning of the eval
    # and restore $@ after the eval finishes
    my $prev_error = $@;
  
    my ( @ret, $error );
  
    # failed will be true if the eval dies, because 1 will not be returned
    # from the eval body
    my $failed = not eval {
      $@ = $prev_error;
  
      # evaluate the try block in the correct context
      if ( $wantarray ) {
        @ret = $try->();
      } elsif ( defined $wantarray ) {
        $ret[0] = $try->();
      } else {
        $try->();
      };
  
      return 1; # properly set $failed to false
    };
  
    # preserve the current error and reset the original value of $@
    $error = $@;
    $@ = $prev_error;
  
    # at this point $failed contains a true value if the eval died, even if some
    # destructor overwrote $@ as the eval was unwinding.
    if ( $failed ) {
      # pass $error to the finally blocks
      push @$_, $error for @{$_finally_guards{guards}};
  
      # if we got an error, invoke the catch block.
      if ( $catch ) {
        # This works like given($error), but is backwards compatible and
        # sets $_ in the dynamic scope for the body of C<$catch>
        for ($error) {
          return $catch->($error);
        }
  
        # in case when() was used without an explicit return, the C<for>
        # loop will be aborted and there's no useful return value
      }
  
      return;
    } else {
      # no failure, $@ is back to what it was, everything is fine
      return $wantarray ? @ret : $ret[0];
    }
  }
  
  sub catch (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare catch()' unless wantarray;
  
    _subname(caller().'::catch {...} ' => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Catch'),
      @rest,
    );
  }
  
  sub finally (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare finally()' unless wantarray;
  
    _subname(caller().'::finally {...} ' => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Finally'),
      @rest,
    );
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    use constant UNSTABLE_DOLLARAT => ("$]" < '5.013002') ? 1 : 0;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my ($code, @args) = @{ $_[0] };
  
      local $@ if UNSTABLE_DOLLARAT;
      eval {
        $code->(@args);
        1;
      } or do {
        warn
          "Execution of finally() block $code resulted in an exception, which "
        . '*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. '
        . 'Your program will continue as if this event never took place. '
        . "Original exception text follows:\n\n"
        . (defined $@ ? $@ : '$@ left undefined...')
        . "\n"
        ;
      }
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Try::Tiny - Minimal try/catch with proper preservation of $@
  
  =head1 VERSION
  
  version 0.30
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
    # handle errors with a catch handler
    try {
      die "foo";
    } catch {
      warn "caught error: $_"; # not $@
    };
  
  You can also use it like a standalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
    # just silence errors
    try {
      die "foo";
    };
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the C<try> block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L</BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the C<try> block dies, it returns the value of the last statement executed in
  the C<catch> block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following examples all
  assign C<"bar"> to C<$x>:
  
    my $x = try { die "foo" } catch { "bar" };
    my $x = try { die "foo" } || "bar";
    my $x = (try { die "foo" }) // "bar";
  
    my $x = eval { die "foo" } || "bar";
  
  You can add C<finally> blocks, yielding the following:
  
    my $x;
    try { die 'foo' } finally { $x = 'bar' };
    try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  C<finally> blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many C<finally> blocks to a
  given C<try> block as you like.
  
  Note that adding a C<finally> block without a preceding C<catch> block
  suppresses any errors. This behaviour is consistent with using a standalone
  C<eval>, but it is not consistent with C<try>/C<finally> patterns found in
  other programming languages, such as Java, Python, Javascript or C#. If you
  learnt the C<try>/C<finally> pattern from one of these languages, watch out for
  this.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory C<try> subroutine, an optional C<catch> subroutine and C<finally>
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the C<finally> block, if given, will execute.
  
  =item catch (&;@)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
    catch { ... }
  
  Inside the C<catch> block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
    local $@ = $_;
  
  =item finally (&;@)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. C<finally> blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the C<finally> block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the C<finally> block does not
  localize C<$_> with the error, since unlike in a C<catch> block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the C<finally> block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  Furthermore B<exceptions in C<finally> blocks are not trappable and are unable
  to influence the execution of your program>. This is due to limitation of
  C<DESTROY>-based scope guards, which C<finally> is implemented on top of. This
  may change in a future version of Try::Tiny.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an C<eval> block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically,
  L<before Perl version 5.14.0|perl5140delta/"Exception Handling">
  C<$@> was clobbered at the beginning of the C<eval>, which
  also made it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (the one
  available before entering the C<try> block) in the beginning of the C<eval>
  block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an C<eval> block, C<die> behaves sort of like:
  
    sub die {
      $@ = $_[0];
      return_undef_from_eval();
    }
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
    my $error = do {
      local $@;
      eval { ... };
      $@;
    };
  
    ...
    die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
    if ( $@ ) {
      ...
    }
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode (fixed in L<Perl 5.14.0|perl5140delta/"Exception Handling">) is:
  
    sub Object::DESTROY {
      eval { ... }
    }
  
    eval {
      my $obj = Object->new;
  
      die "foo";
    };
  
    if ( $@ ) {
  
    }
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the C<eval> was aborted due to an error:
  
    my $failed = not eval {
      ...
  
      return 1;
    };
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 ALTERNATE SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements"> (but please don't,
  because that syntax has since been deprecated because there was too much
  unexpected magical behaviour).
  
  =for stopwords topicalizer
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
    try {
      require Foo;
    } catch {
      when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
      default { die $_ }
    };
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  argument list. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
    sub foo {
      my ( $self, @args ) = @_;
      try { $self->bar(@args) }
    }
  
  or
  
    sub bar_in_place {
      my $self = shift;
      my $args = \@_;
      try { $_ = $self->bar($_) for @$args }
    }
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
      try {
        die;
      }
      catch {
        return;
      };
  
      say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
      my $success = try {
        die;
        1;
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
    # OR
    sub parent_sub_with_catch {
      my $success = try {
        die;
        1;
      }
      catch {
        # do something with $_
        return undef; #see note
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
  
  Note that if you have a C<catch> block, it must return C<undef> for this to work,
  since if a C<catch> block exists, its return value is returned in place of C<undef>
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =for stopwords unhygienically
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygienically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
    my $obj = try {
      MightFail->new;
    } catch {
      ...
  
      return; # avoid returning a true value;
    };
  
    return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
    given ($foo) {
      when (...) {
        try {
          ...
        } catch {
          warn $_; # will print $foo, not the error
          warn $_[0]; # instead, get the error like this
        }
      }
    }
  
  Note that this behavior was changed once again in
  L<Perl5 version 18|https://metacpan.org/module/perldelta#given-now-aliases-the-global-_>.
  However, since the entirety of lexical C<$_> is now L<considered experimental
  |https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental>, it
  is unclear whether the new version 18 behavior is final.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul>
  
  Or read the source:
  
  L<http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Try-Tiny>
  (or L<bug-Try-Tiny@rt.cpan.org|mailto:bug-Try-Tiny@rt.cpan.org>).
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Karen Etheridge Peter Rabbitson Ricardo Signes Mark Fowler Graham Knop Lukas Mai Aristotle Pagaltzis Dagfinn Ilmari Mannsåker Paul Howarth Rudolf Leermakers anaxagoras awalker chromatic Alex cm-perl Andrew Yates David Lowe Glenn Hans Dieter Pearcey Jens Berthold Jonathan Yu Marc Mims Stosberg Pali
  
  =over 4
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Mark Fowler <mark@twoshortplanks.com>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Lukas Mai <l.mai@web.de>
  
  =item *
  
  Aristotle Pagaltzis <pagaltzis@gmx.de>
  
  =item *
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =item *
  
  Paul Howarth <paul@city-fan.org>
  
  =item *
  
  Rudolf Leermakers <rudolf@hatsuseno.org>
  
  =item *
  
  anaxagoras <walkeraj@gmail.com>
  
  =item *
  
  awalker <awalker@sourcefire.com>
  
  =item *
  
  chromatic <chromatic@wgz.org>
  
  =item *
  
  Alex <alex@koban.(none)>
  
  =item *
  
  cm-perl <cm-perl@users.noreply.github.com>
  
  =item *
  
  Andrew Yates <ayates@haddock.local>
  
  =item *
  
  David Lowe <davidl@lokku.com>
  
  =item *
  
  Glenn Fowler <cebjyre@cpan.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Jens Berthold <jens@jebecs.de>
  
  =item *
  
  Jonathan Yu <JAWNSY@cpan.org>
  
  =item *
  
  Marc Mims <marc@questright.com>
  
  =item *
  
  Mark Stosberg <mark@stosberg.com>
  
  =item *
  
  Pali <pali@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is Copyright (c) 2009 by יובל קוג'מן (Yuval Kogman).
  
  This is free software, licensed under:
  
    The MIT (X11) License
  
  =cut
TRY_TINY

$fatpacked{"x86_64-linux/Params/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PARAMS_UTIL';
  package Params::Util;
  
  =pod
  
  =head1 NAME
  
  Params::Util - Simple, compact and correct param-checking functions
  
  =head1 SYNOPSIS
  
    # Import some functions
    use Params::Util qw{_SCALAR _HASH _INSTANCE};
    
    # If you are lazy, or need a lot of them...
    use Params::Util ':ALL';
    
    sub foo {
        my $object  = _INSTANCE(shift, 'Foo') or return undef;
        my $image   = _SCALAR(shift)          or return undef;
        my $options = _HASH(shift)            or return undef;
        # etc...
    }
  
  =head1 DESCRIPTION
  
  C<Params::Util> provides a basic set of importable functions that makes
  checking parameters a hell of a lot easier
  
  While they can be (and are) used in other contexts, the main point
  behind this module is that the functions B<both> Do What You Mean,
  and Do The Right Thing, so they are most useful when you are getting
  params passed into your code from someone and/or somewhere else
  and you can't really trust the quality.
  
  Thus, C<Params::Util> is of most use at the edges of your API, where
  params and data are coming in from outside your code.
  
  The functions provided by C<Params::Util> check in the most strictly
  correct manner known, are documented as thoroughly as possible so their
  exact behaviour is clear, and heavily tested so make sure they are not
  fooled by weird data and Really Bad Things.
  
  To use, simply load the module providing the functions you want to use
  as arguments (as shown in the SYNOPSIS).
  
  To aid in maintainability, C<Params::Util> will B<never> export by
  default.
  
  You must explicitly name the functions you want to export, or use the
  C<:ALL> param to just have it export everything (although this is not
  recommended if you have any _FOO functions yourself with which future
  additions to C<Params::Util> may clash)
  
  =head1 FUNCTIONS
  
  =cut
  
  use 5.00503;
  use strict;
  require overload;
  require Exporter;
  require Scalar::Util;
  require DynaLoader;
  
  use vars qw{$VERSION @ISA @EXPORT_OK %EXPORT_TAGS};
  
  $VERSION   = '1.07';
  @ISA       = qw{
  	Exporter
  	DynaLoader
  };
  @EXPORT_OK = qw{
  	_STRING     _IDENTIFIER
  	_CLASS      _CLASSISA   _SUBCLASS  _DRIVER  _CLASSDOES
  	_NUMBER     _POSINT     _NONNEGINT
  	_SCALAR     _SCALAR0
  	_ARRAY      _ARRAY0     _ARRAYLIKE
  	_HASH       _HASH0      _HASHLIKE
  	_CODE       _CODELIKE
  	_INVOCANT   _REGEX      _INSTANCE  _INSTANCEDOES
  	_SET        _SET0
  	_HANDLE
  };
  %EXPORT_TAGS = ( ALL => \@EXPORT_OK );
  
  eval {
  	local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
  	bootstrap Params::Util $VERSION;
  	1;
  } unless $ENV{PERL_PARAMS_UTIL_PP};
  
  # Use a private pure-perl copy of looks_like_number if the version of
  # Scalar::Util is old (for whatever reason).
  my $SU = eval "$Scalar::Util::VERSION" || 0;
  if ( $SU >= 1.18 ) { 
  	Scalar::Util->import('looks_like_number');
  } else {
  	eval <<'END_PERL';
  sub looks_like_number {
  	local $_ = shift;
  
  	# checks from perlfaq4
  	return 0 if !defined($_);
  	if (ref($_)) {
  		return overload::Overloaded($_) ? defined(0 + $_) : 0;
  	}
  	return 1 if (/^[+-]?[0-9]+$/); # is a +/- integer
  	return 1 if (/^([+-]?)(?=[0-9]|\.[0-9])[0-9]*(\.[0-9]*)?([Ee]([+-]?[0-9]+))?$/); # a C float
  	return 1 if ($] >= 5.008 and /^(Inf(inity)?|NaN)$/i) or ($] >= 5.006001 and /^Inf$/i);
  
  	0;
  }
  END_PERL
  }
  
  
  
  
  
  #####################################################################
  # Param Checking Functions
  
  =pod
  
  =head2 _STRING $string
  
  The C<_STRING> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a normal non-false string of non-zero length.
  
  Note that this will NOT do anything magic to deal with the special
  C<'0'> false negative case, but will return it.
  
    # '0' not considered valid data
    my $name = _STRING(shift) or die "Bad name";
    
    # '0' is considered valid data
    my $string = _STRING($_[0]) ? shift : die "Bad string";
  
  Please also note that this function expects a normal string. It does
  not support overloading or other magic techniques to get a string.
  
  Returns the string as a conveince if it is a valid string, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_STRING;
  sub _STRING ($) {
  	(defined $_[0] and ! ref $_[0] and length($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _IDENTIFIER $string
  
  The C<_IDENTIFIER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl identifier.
  
  Returns the string as a convenience if it is a valid identifier, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_IDENTIFIER;
  sub _IDENTIFIER ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASS $string
  
  The C<_CLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl class.
  
  This function only checks that the format is valid, not that the
  class is actually loaded. It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASS;
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASSISA $string, $class
  
  The C<_CLASSISA> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a particularly class, or a subclass of it.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSISA;
  sub _CLASSISA ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =head2 _CLASSDOES $string, $role
  
  This routine behaves exactly like C<L</_CLASSISA>>, but checks with C<< ->DOES
  >> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
  5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
  implemented.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSDOES;
  sub _CLASSDOES ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SUBCLASS $string, $class
  
  The C<_SUBCLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a subclass of a specified class.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SUBCLASS;
  sub _SUBCLASS ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0] ne $_[1] and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NUMBER $scalar
  
  The C<_NUMBER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a number. That is, it is defined and perl thinks it's a number.
  
  This function is basically a Params::Util-style wrapper around the
  L<Scalar::Util> C<looks_like_number> function.
  
  Returns the value as a convience, or C<undef> if the value is not a
  number.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NUMBER;
  sub _NUMBER ($) {
  	( defined $_[0] and ! ref $_[0] and looks_like_number($_[0]) )
  	? $_[0]
  	: undef;
  }
  END_PERL
  
  =pod
  
  =head2 _POSINT $integer
  
  The C<_POSINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a positive integer (of any length).
  
  Returns the value as a convience, or C<undef> if the value is not a
  positive integer.
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_POSINT;
  sub _POSINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[1-9]\d*$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NONNEGINT $integer
  
  The C<_NONNEGINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a non-negative integer (of any length). That is, a positive integer,
  or zero.
  
  Returns the value as a convience, or C<undef> if the value is not a
  non-negative integer.
  
  As with other tests that may return false values, care should be taken
  to test via "defined" in boolean validy contexts.
  
    unless ( defined _NONNEGINT($value) ) {
       die "Invalid value";
    }
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NONNEGINT;
  sub _NONNEGINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^(?:0|[1-9]\d*)$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR \$scalar
  
  The C<_SCALAR> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR> reference, with content of non-zero length.
  
  For a version that allows zero length C<SCALAR> references, see
  the C<_SCALAR0> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR;
  sub _SCALAR ($) {
  	(ref $_[0] eq 'SCALAR' and defined ${$_[0]} and ${$_[0]} ne '') ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR0 \$scalar
  
  The C<_SCALAR0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR0> reference, allowing content of zero-length.
  
  For a simpler "give me some content" version that requires non-zero
  length, C<_SCALAR> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR0;
  sub _SCALAR0 ($) {
  	ref $_[0] eq 'SCALAR' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY $value
  
  The C<_ARRAY> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference containing B<at least> one element of any kind.
  
  For a more basic form that allows zero length ARRAY references, see
  the C<_ARRAY0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY;
  sub _ARRAY ($) {
  	(ref $_[0] eq 'ARRAY' and @{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY0 $value
  
  The C<_ARRAY0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference, allowing C<ARRAY> references that contain no
  elements.
  
  For a more basic "An array of something" form that also requires at
  least one element, see the C<_ARRAY> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY0;
  sub _ARRAY0 ($) {
  	ref $_[0] eq 'ARRAY' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAYLIKE $value
  
  The C<_ARRAYLIKE> function tests whether a given scalar value can respond to
  array dereferencing.  If it can, the value is returned.  If it cannot,
  C<_ARRAYLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAYLIKE;
  sub _ARRAYLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'ARRAY')
  		or
  		overload::Method($_[0], '@{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH $value
  
  The C<_HASH> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference with at least one entry.
  
  For a version of this function that allows the C<HASH> to be empty,
  see the C<_HASH0> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH;
  sub _HASH ($) {
  	(ref $_[0] eq 'HASH' and scalar %{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH0 $value
  
  The C<_HASH0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference, regardless of the C<HASH> content.
  
  For a simpler "A hash of something" version that requires at least one
  element, see the C<_HASH> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH0;
  sub _HASH0 ($) {
  	ref $_[0] eq 'HASH' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASHLIKE $value
  
  The C<_HASHLIKE> function tests whether a given scalar value can respond to
  hash dereferencing.  If it can, the value is returned.  If it cannot,
  C<_HASHLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASHLIKE;
  sub _HASHLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'HASH')
  		or
  		overload::Method($_[0], '%{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODE $value
  
  The C<_CODE> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<CODE> reference.
  
  Returns the C<CODE> reference itself as a convenience, or C<undef>
  if the value provided is not an C<CODE> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODE;
  sub _CODE ($) {
  	ref $_[0] eq 'CODE' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODELIKE $value
  
  The C<_CODELIKE> is the more generic version of C<_CODE>. Unlike C<_CODE>,
  which checks for an explicit C<CODE> reference, the C<_CODELIKE> function
  also includes things that act like them, such as blessed objects that
  overload C<'&{}'>.
  
  Please note that in the case of objects overloaded with '&{}', you will
  almost always end up also testing it in 'bool' context at some stage.
  
  For example:
  
    sub foo {
        my $code1 = _CODELIKE(shift) or die "No code param provided";
        my $code2 = _CODELIKE(shift);
        if ( $code2 ) {
             print "Got optional second code param";
        }
    }
  
  As such, you will most likely always want to make sure your class has
  at least the following to allow it to evaluate to true in boolean
  context.
  
    # Always evaluate to true in boolean context
    use overload 'bool' => sub () { 1 };
  
  Returns the callable value as a convenience, or C<undef> if the
  value provided is not callable.
  
  Note - This function was formerly known as _CALLABLE but has been renamed
  for greater symmetry with the other _XXXXLIKE functions.
  
  The use of _CALLABLE has been deprecated. It will continue to work, but
  with a warning, until end-2006, then will be removed.
  
  I apologise for any inconvenience caused.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODELIKE;
  sub _CODELIKE($) {
  	(
  		(Scalar::Util::reftype($_[0])||'') eq 'CODE'
  		or
  		Scalar::Util::blessed($_[0]) and overload::Method($_[0],'&{}')
  	)
  	? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INVOCANT $value
  
  This routine tests whether the given value is a valid method invocant.
  This can be either an instance of an object, or a class name.
  
  If so, the value itself is returned.  Otherwise, C<_INVOCANT>
  returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INVOCANT;
  sub _INVOCANT($) {
  	(defined $_[0] and
  		(defined Scalar::Util::blessed($_[0])
  		or      
  		# We used to check for stash definedness, but any class-like name is a
  		# valid invocant for UNIVERSAL methods, so we stopped. -- rjbs, 2006-07-02
  		Params::Util::_CLASS($_[0]))
  	) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INSTANCE $object, $class
  
  The C<_INSTANCE> function is intended to be imported into your package,
  and provides a convenient way to test for an object of a particular class
  in a strictly correct manner.
  
  Returns the object itself as a convenience, or C<undef> if the value
  provided is not an object of that type.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCE;
  sub _INSTANCE ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =head2 _INSTANCEDOES $object, $role
  
  This routine behaves exactly like C<L</_INSTANCE>>, but checks with C<< ->DOES
  >> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
  5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
  implemented.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCEDOES;
  sub _INSTANCEDOES ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _REGEX $value
  
  The C<_REGEX> function is intended to be imported into your package,
  and provides a convenient way to test for a regular expression.
  
  Returns the value itself as a convenience, or C<undef> if the value
  provided is not a regular expression.
  
  =cut
  
  eval <<'END_PERL' unless defined &_REGEX;
  sub _REGEX ($) {
  	(defined $_[0] and 'Regexp' eq ref($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SET \@array, $class
  
  The C<_SET> function is intended to be imported into your package,
  and provides a convenient way to test for set of at least one object of
  a particular class in a strictly correct manner.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that allows zero-length sets, see the
  C<_SET0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET;
  sub _SET ($$) {
  	my $set = shift;
  	_ARRAY($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _SET0 \@array, $class
  
  The C<_SET0> function is intended to be imported into your package,
  and provides a convenient way to test for a set of objects of a
  particular class in a strictly correct manner, allowing for zero objects.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that requires at least one object, see the
  C<_SET> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET0;
  sub _SET0 ($$) {
  	my $set = shift;
  	_ARRAY0($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _HANDLE
  
  The C<_HANDLE> function is intended to be imported into your package,
  and provides a convenient way to test whether or not a single scalar
  value is a file handle.
  
  Unfortunately, in Perl the definition of a file handle can be a little
  bit fuzzy, so this function is likely to be somewhat imperfect (at first
  anyway).
  
  That said, it is implement as well or better than the other file handle
  detectors in existance (and we stole from the best of them).
  
  =cut
  
  # We're doing this longhand for now. Once everything is perfect,
  # we'll compress this into something that compiles more efficiently.
  # Further, testing file handles is not something that is generally
  # done millions of times, so doing it slowly is not a big speed hit.
  eval <<'END_PERL' unless defined &_HANDLE;
  sub _HANDLE {
  	my $it = shift;
  
  	# It has to be defined, of course
  	unless ( defined $it ) {
  		return undef;
  	}
  
  	# Normal globs are considered to be file handles
  	if ( ref $it eq 'GLOB' ) {
  		return $it;
  	}
  
  	# Check for a normal tied filehandle
  	# Side Note: 5.5.4's tied() and can() doesn't like getting undef
  	if ( tied($it) and tied($it)->can('TIEHANDLE') ) {
  		return $it;
  	}
  
  	# There are no other non-object handles that we support
  	unless ( Scalar::Util::blessed($it) ) {
  		return undef;
  	}
  
  	# Check for a common base classes for conventional IO::Handle object
  	if ( $it->isa('IO::Handle') ) {
  		return $it;
  	}
  
  
  	# Check for tied file handles using Tie::Handle
  	if ( $it->isa('Tie::Handle') ) {
  		return $it;
  	}
  
  	# IO::Scalar is not a proper seekable, but it is valid is a
  	# regular file handle
  	if ( $it->isa('IO::Scalar') ) {
  		return $it;
  	}
  
  	# Yet another special case for IO::String, which refuses (for now
  	# anyway) to become a subclass of IO::Handle.
  	if ( $it->isa('IO::String') ) {
  		return $it;
  	}
  
  	# This is not any sort of object we know about
  	return undef;
  }
  END_PERL
  
  =pod
  
  =head2 _DRIVER $string
  
    sub foo {
      my $class = _DRIVER(shift, 'My::Driver::Base') or die "Bad driver";
      ...
    }
  
  The C<_DRIVER> function is intended to be imported into your
  package, and provides a convenient way to load and validate
  a driver class.
  
  The most common pattern when taking a driver class as a parameter
  is to check that the name is a class (i.e. check against _CLASS)
  and then to load the class (if it exists) and then ensure that
  the class returns true for the isa method on some base driver name.
  
  Return the value as a convenience, or C<undef> if the value is not
  a class name, the module does not exist, the module does not load,
  or the class fails the isa test.
  
  =cut
  
  eval <<'END_PERL' unless defined &_DRIVER;
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  END_PERL
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Add _CAN to help resolve the UNIVERSAL::can debacle
  
  - Would be even nicer if someone would demonstrate how the hell to
  build a Module::Install dist of the ::Util dual Perl/XS type. :/
  
  - Implement an assertion-like version of this module, that dies on
  error.
  
  - Implement a Test:: version of this module, for use in testing
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params-Util>
  
  For other issues, contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Params::Validate>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2012 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
X86_64-LINUX_PARAMS_UTIL

$fatpacked{"x86_64-linux/Params/Validate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PARAMS_VALIDATE';
  package Params::Validate;
  
  use 5.008001;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.29';
  
  use Exporter;
  use Module::Implementation;
  use Params::Validate::Constants;
  
  use vars qw( $NO_VALIDATION %OPTIONS $options );
  
  our @ISA = 'Exporter';
  
  my @types = qw(
      SCALAR
      ARRAYREF
      HASHREF
      CODEREF
      GLOB
      GLOBREF
      SCALARREF
      HANDLE
      BOOLEAN
      UNDEF
      OBJECT
  );
  
  our %EXPORT_TAGS = (
      'all' => [
          qw( validate validate_pos validation_options validate_with ),
          @types
      ],
      types => \@types,
  );
  
  our @EXPORT_OK = ( @{ $EXPORT_TAGS{all} }, 'set_options' );
  our @EXPORT = qw( validate validate_pos );
  
  $NO_VALIDATION = $ENV{PERL_NO_VALIDATION};
  
  {
      my $loader = Module::Implementation::build_loader_sub(
          implementations => [ 'XS', 'PP' ],
          symbols         => [
              qw(
                  validate
                  validate_pos
                  validate_with
                  validation_options
                  set_options
                  ),
          ],
      );
  
      $ENV{PARAMS_VALIDATE_IMPLEMENTATION} = 'PP' if $ENV{PV_TEST_PERL};
  
      $loader->();
  }
  
  1;
  
  # ABSTRACT: Validate method/function parameters
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Params::Validate - Validate method/function parameters
  
  =head1 VERSION
  
  version 1.29
  
  =head1 SYNOPSIS
  
      use Params::Validate qw(:all);
  
      # takes named params (hash or hashref)
      sub foo {
          validate(
              @_, {
                  foo => 1,    # mandatory
                  bar => 0,    # optional
              }
          );
      }
  
      # takes positional params
      sub bar {
          # first two are mandatory, third is optional
          validate_pos( @_, 1, 1, 0 );
      }
  
      sub foo2 {
          validate(
              @_, {
                  foo =>
                      # specify a type
                      { type => ARRAYREF },
                  bar =>
                      # specify an interface
                      { can => [ 'print', 'flush', 'frobnicate' ] },
                  baz => {
                      type      => SCALAR,     # a scalar ...
                                               # ... that is a plain integer ...
                      regex     => qr/^\d+$/,
                      callbacks => {           # ... and smaller than 90
                          'less than 90' => sub { shift() < 90 },
                      },
                  }
              }
          );
      }
  
      sub callback_with_custom_error {
          validate(
              @_,
              {
                  foo => {
                      callbacks => {
                          'is an integer' => sub {
                              return 1 if $_[0] =~ /^-?[1-9][0-9]*$/;
                              die "$_[0] is not a valid integer value";
                          },
                      },
                  }
              }
          );
      }
  
      sub with_defaults {
          my %p = validate(
              @_, {
                  # required
                  foo => 1,
                  # $p{bar} will be 99 if bar is not given. bar is now
                  # optional.
                  bar => { default => 99 }
              }
          );
      }
  
      sub pos_with_defaults {
          my @p = validate_pos( @_, 1, { default => 99 } );
      }
  
      sub sets_options_on_call {
          my %p = validate_with(
              params => \@_,
              spec   => { foo => { type => SCALAR, default => 2 } },
              normalize_keys => sub { $_[0] =~ s/^-//; lc $_[0] },
          );
      }
  
  =head1 DESCRIPTION
  
  B<< I would recommend you consider using L<Params::ValidationCompiler>
  instead. That module, despite being pure Perl, is I<significantly> faster than
  this one, at the cost of having to adopt a type system such as L<Specio>,
  L<Type::Tiny>, or the one shipped with L<Moose> >>.
  
  This module allows you to validate method or function call parameters to an
  arbitrary level of specificity. At the simplest level, it is capable of
  validating the required parameters were given and that no unspecified
  additional parameters were passed in.
  
  It is also capable of determining that a parameter is of a specific
  type, that it is an object of a certain class hierarchy, that it
  possesses certain methods, or applying validation callbacks to
  arguments.
  
  =head2 EXPORT
  
  The module always exports the C<validate()> and C<validate_pos()>
  functions.
  
  It also has an additional function available for export,
  C<validate_with>, which can be used to validate any type of
  parameters, and set various options on a per-invocation basis.
  
  In addition, it can export the following constants, which are used as
  part of the type checking. These are C<SCALAR>, C<ARRAYREF>,
  C<HASHREF>, C<CODEREF>, C<GLOB>, C<GLOBREF>, and C<SCALARREF>,
  C<UNDEF>, C<OBJECT>, C<BOOLEAN>, and C<HANDLE>. These are explained
  in the section on L<Type Validation|Params::Validate/Type Validation>.
  
  The constants are available via the export tag C<:types>. There is
  also an C<:all> tag which includes all of the constants as well as the
  C<validation_options()> function.
  
  =head1 PARAMETER VALIDATION
  
  The validation mechanisms provided by this module can handle both
  named or positional parameters. For the most part, the same features
  are available for each. The biggest difference is the way that the
  validation specification is given to the relevant subroutine. The
  other difference is in the error messages produced when validation
  checks fail.
  
  When handling named parameters, the module will accept either a hash
  or a hash reference.
  
  Subroutines expecting named parameters should call the C<validate()>
  subroutine like this:
  
      validate(
          @_, {
              parameter1 => validation spec,
              parameter2 => validation spec,
              ...
          }
      );
  
  Subroutines expecting positional parameters should call the
  C<validate_pos()> subroutine like this:
  
      validate_pos( @_, { validation spec }, { validation spec } );
  
  =head2 Mandatory/Optional Parameters
  
  If you just want to specify that some parameters are mandatory and
  others are optional, this can be done very simply.
  
  For a subroutine expecting named parameters, you would do this:
  
      validate( @_, { foo => 1, bar => 1, baz => 0 } );
  
  This says that the "foo" and "bar" parameters are mandatory and that
  the "baz" parameter is optional. The presence of any other
  parameters will cause an error.
  
  For a subroutine expecting positional parameters, you would do this:
  
      validate_pos( @_, 1, 1, 0, 0 );
  
  This says that you expect at least 2 and no more than 4 parameters.
  If you have a subroutine that has a minimum number of parameters but
  can take any maximum number, you can do this:
  
      validate_pos( @_, 1, 1, (0) x (@_ - 2) );
  
  This will always be valid as long as at least two parameters are
  given. A similar construct could be used for the more complex
  validation parameters described further on.
  
  Please note that this:
  
      validate_pos( @_, 1, 1, 0, 1, 1 );
  
  makes absolutely no sense, so don't do it. Any zeros must come at the
  end of the validation specification.
  
  In addition, if you specify that a parameter can have a default, then
  it is considered optional.
  
  =head2 Type Validation
  
  This module supports the following simple types, which can be
  L<exported as constants|/EXPORT>:
  
  =over 4
  
  =item * SCALAR
  
  A scalar which is not a reference, such as C<10> or C<'hello'>. A
  parameter that is undefined is B<not> treated as a scalar. If you
  want to allow undefined values, you will have to specify C<SCALAR |
  UNDEF>.
  
  =item * ARRAYREF
  
  An array reference such as C<[1, 2, 3]> or C<\@foo>.
  
  =item * HASHREF
  
  A hash reference such as C<< { a => 1, b => 2 } >> or C<\%bar>.
  
  =item * CODEREF
  
  A subroutine reference such as C<\&foo_sub> or C<sub { print "hello" }>.
  
  =item * GLOB
  
  This one is a bit tricky. A glob would be something like C<*FOO>, but
  not C<\*FOO>, which is a glob reference. It should be noted that this
  trick:
  
      my $fh = do { local *FH; };
  
  makes C<$fh> a glob, not a glob reference. On the other hand, the
  return value from C<Symbol::gensym> is a glob reference. Either can
  be used as a file or directory handle.
  
  =item * GLOBREF
  
  A glob reference such as C<\*FOO>. See the L<GLOB|GLOB> entry above
  for more details.
  
  =item * SCALARREF
  
  A reference to a scalar such as C<\$x>.
  
  =item * UNDEF
  
  An undefined value
  
  =item * OBJECT
  
  A blessed reference.
  
  =item * BOOLEAN
  
  This is a special option, and is just a shortcut for C<UNDEF | SCALAR>.
  
  =item * HANDLE
  
  This option is also special, and is just a shortcut for C<GLOB |
  GLOBREF>. However, it seems likely that most people interested in
  either globs or glob references are likely to really be interested in
  whether the parameter in question could be a valid file or directory
  handle.
  
  =back
  
  To specify that a parameter must be of a given type when using named
  parameters, do this:
  
      validate(
          @_, {
              foo => { type => SCALAR },
              bar => { type => HASHREF }
          }
      );
  
  If a parameter can be of more than one type, just use the bitwise or
  (C<|>) operator to combine them.
  
      validate( @_, { foo => { type => GLOB | GLOBREF } );
  
  For positional parameters, this can be specified as follows:
  
      validate_pos( @_, { type => SCALAR | ARRAYREF }, { type => CODEREF } );
  
  =head2 Interface Validation
  
  To specify that a parameter is expected to have a certain set of
  methods, we can do the following:
  
      validate(
          @_, {
              foo =>
                  # just has to be able to ->bar
                  { can => 'bar' }
          }
      );
  
   ... or ...
  
      validate(
          @_, {
              foo =>
                  # must be able to ->bar and ->print
                  { can => [qw( bar print )] }
          }
      );
  
  =head2 Class Validation
  
  A word of warning. When constructing your external interfaces, it is
  probably better to specify what methods you expect an object to
  have rather than what class it should be of (or a child of). This
  will make your API much more flexible.
  
  With that said, if you want to validate that an incoming parameter
  belongs to a class (or child class) or classes, do:
  
      validate(
          @_,
          { foo => { isa => 'My::Frobnicator' } }
      );
  
   ... or ...
  
      validate(
          @_,
          # must be both, not either!
          { foo => { isa => [qw( My::Frobnicator IO::Handle )] } }
      );
  
  =head2 Regex Validation
  
  If you want to specify that a given parameter must match a specific
  regular expression, this can be done with "regex" spec key. For
  example:
  
      validate(
          @_,
          { foo => { regex => qr/^\d+$/ } }
      );
  
  The value of the "regex" key may be either a string or a pre-compiled
  regex created via C<qr>.
  
  If the value being checked against a regex is undefined, the regex is
  explicitly checked against the empty string ('') instead, in order to
  avoid "Use of uninitialized value" warnings.
  
  The C<Regexp::Common> module on CPAN is an excellent source of regular
  expressions suitable for validating input.
  
  =head2 Callback Validation
  
  If none of the above are enough, it is possible to pass in one or more
  callbacks to validate the parameter. The callback will be given the
  B<value> of the parameter as its first argument. Its second argument
  will be all the parameters, as a reference to either a hash or array.
  Callbacks are specified as hash reference. The key is an id for the
  callback (used in error messages) and the value is a subroutine
  reference, such as:
  
      validate(
          @_,
          {
              foo => {
                  callbacks => {
                      'smaller than a breadbox' => sub { shift() < $breadbox },
                      'green or blue'           => sub {
                          return 1 if $_[0] eq 'green' || $_[0] eq 'blue';
                          die "$_[0] is not green or blue!";
                      }
                  }
              }
          }
      );
  
      validate(
          @_, {
              foo => {
                  callbacks => {
                      'bigger than baz' => sub { $_[0] > $_[1]->{baz} }
                  }
              }
          }
      );
  
  The callback should return a true value if the value is valid. If not, it can
  return false or die. If you return false, a generic error message will be
  thrown by C<Params::Validate>.
  
  If your callback dies instead you can provide a custom error message. If the
  callback dies with a plain string, this string will be appended to an
  exception message generated by C<Params::Validate>. If the callback dies with
  a reference (blessed or not), then this will be rethrown as-is by
  C<Params::Validate>.
  
  =head2 Untainting
  
  If you want values untainted, set the "untaint" key in a spec hashref
  to a true value, like this:
  
      my %p = validate(
          @_, {
              foo => { type => SCALAR, untaint => 1 },
              bar => { type => ARRAYREF }
          }
      );
  
  This will untaint the "foo" parameter if the parameters are valid.
  
  Note that untainting is only done if I<all parameters> are valid.
  Also, only the return values are untainted, not the original values
  passed into the validation function.
  
  Asking for untainting of a reference value will not do anything, as
  C<Params::Validate> will only attempt to untaint the reference itself.
  
  =head2 Mandatory/Optional Revisited
  
  If you want to specify something such as type or interface, plus the
  fact that a parameter can be optional, do this:
  
      validate(
          @_, {
              foo => { type => SCALAR },
              bar => { type => ARRAYREF, optional => 1 }
          }
      );
  
  or this for positional parameters:
  
      validate_pos(
          @_,
          { type => SCALAR },
          { type => ARRAYREF, optional => 1 }
      );
  
  By default, parameters are assumed to be mandatory unless specified as
  optional.
  
  =head2 Dependencies
  
  It also possible to specify that a given optional parameter depends on
  the presence of one or more other optional parameters.
  
      validate(
          @_, {
              cc_number => {
                  type     => SCALAR,
                  optional => 1,
                  depends  => [ 'cc_expiration', 'cc_holder_name' ],
              },
              cc_expiration  => { type => SCALAR, optional => 1 },
              cc_holder_name => { type => SCALAR, optional => 1 },
          }
      );
  
  In this case, "cc_number", "cc_expiration", and "cc_holder_name" are
  all optional. However, if "cc_number" is provided, then
  "cc_expiration" and "cc_holder_name" must be provided as well.
  
  This allows you to group together sets of parameters that all must be
  provided together.
  
  The C<validate_pos()> version of dependencies is slightly different,
  in that you can only depend on one other parameter. Also, if for
  example, the second parameter 2 depends on the fourth parameter, then
  it implies a dependency on the third parameter as well. This is
  because if the fourth parameter is required, then the user must also
  provide a third parameter so that there can be four parameters in
  total.
  
  C<Params::Validate> will die if you try to depend on a parameter not
  declared as part of your parameter specification.
  
  =head2 Specifying defaults
  
  If the C<validate()> or C<validate_pos()> functions are called in a list
  context, they will return a hash or containing the original parameters plus
  defaults as indicated by the validation spec.
  
  If the function is not called in a list context, providing a default
  in the validation spec still indicates that the parameter is optional.
  
  The hash or array returned from the function will always be a copy of
  the original parameters, in order to leave C<@_> untouched for the
  calling function.
  
  Simple examples of defaults would be:
  
      my %p = validate( @_, { foo => 1, bar => { default => 99 } } );
  
      my @p = validate_pos( @_, 1, { default => 99 } );
  
  In scalar context, a hash reference or array reference will be
  returned, as appropriate.
  
  =head1 USAGE NOTES
  
  =head2 Validation failure
  
  By default, when validation fails C<Params::Validate> calls
  C<Carp::confess()>. This can be overridden by setting the C<on_fail>
  option, which is described in the L<"GLOBAL" OPTIONS|"GLOBAL" OPTIONS>
  section.
  
  =head2 Method calls
  
  When using this module to validate the parameters passed to a method
  call, you will probably want to remove the class/object from the
  parameter list B<before> calling C<validate()> or C<validate_pos()>.
  If your method expects named parameters, then this is necessary for
  the C<validate()> function to actually work, otherwise C<@_> will not
  be usable as a hash, because it will first have your object (or
  class) B<followed> by a set of keys and values.
  
  Thus the idiomatic usage of C<validate()> in a method call will look
  something like this:
  
      sub method {
          my $self = shift;
  
          my %params = validate(
              @_, {
                  foo => 1,
                  bar => { type => ARRAYREF },
              }
          );
      }
  
  =head2 Speeding Up Validation
  
  In most cases, the validation spec will remain the same for each call to a
  subroutine. In that case, you can speed up validation by defining the
  validation spec just once, rather than on each call to the subroutine:
  
      my %spec = ( ... );
      sub foo {
          my %params = validate( @_, \%spec );
      }
  
  You can also use the C<state> feature to do this:
  
      use feature 'state';
  
      sub foo {
          state $spec = { ... };
          my %params = validate( @_, $spec );
      }
  
  =head1 "GLOBAL" OPTIONS
  
  Because the API for the C<validate()> and C<validate_pos()> functions does not
  make it possible to specify any options other than the validation spec, it is
  possible to set some options as pseudo-'globals'. These allow you to specify
  such things as whether or not the validation of named parameters should be
  case sensitive, for one example.
  
  These options are called pseudo-'globals' because these settings are
  B<only applied to calls originating from the package that set the
  options>.
  
  In other words, if I am in package C<Foo> and I call
  C<validation_options()>, those options are only in effect when I call
  C<validate()> from package C<Foo>.
  
  While this is quite different from how most other modules operate, I
  feel that this is necessary in able to make it possible for one
  module/application to use Params::Validate while still using other
  modules that also use Params::Validate, perhaps with different
  options set.
  
  The downside to this is that if you are writing an app with a standard
  calling style for all functions, and your app has ten modules, B<each
  module must include a call to C<validation_options()>>. You could of
  course write a module that all your modules use which uses various
  trickery to do this when imported.
  
  =head2 Options
  
  =over 4
  
  =item * normalize_keys => $callback
  
  This option is only relevant when dealing with named parameters.
  
  This callback will be used to transform the hash keys of both the
  parameters and the parameter spec when C<validate()> or
  C<validate_with()> are called.
  
  Any alterations made by this callback will be reflected in the
  parameter hash that is returned by the validation function. For
  example:
  
      sub foo {
          return validate_with(
              params => \@_,
              spec   => { foo => { type => SCALAR } },
              normalize_keys =>
                  sub { my $k = shift; $k =~ s/^-//; return uc $k },
          );
  
      }
  
      %p = foo( foo => 20 );
  
      # $p{FOO} is now 20
  
      %p = foo( -fOo => 50 );
  
      # $p{FOO} is now 50
  
  The callback must return a defined value.
  
  If a callback is given then the deprecated "ignore_case" and
  "strip_leading" options are ignored.
  
  =item * allow_extra => $boolean
  
  If true, then the validation routine will allow extra parameters not
  named in the validation specification. In the case of positional
  parameters, this allows an unlimited number of maximum parameters
  (though a minimum may still be set). Defaults to false.
  
  =item * on_fail => $callback
  
  If given, this callback will be called whenever a validation check
  fails. It will be called with a single parameter, which will be a
  string describing the failure. This is useful if you wish to have
  this module throw exceptions as objects rather than as strings, for
  example.
  
  This callback is expected to C<die()> internally. If it does not, the
  validation will proceed onwards, with unpredictable results.
  
  The default is to simply use the Carp module's C<confess()> function.
  
  =item * stack_skip => $number
  
  This tells Params::Validate how many stack frames to skip when finding
  a subroutine name to use in error messages. By default, it looks one
  frame back, at the immediate caller to C<validate()> or
  C<validate_pos()>. If this option is set, then the given number of
  frames are skipped instead.
  
  =item * ignore_case => $boolean
  
  DEPRECATED
  
  This is only relevant when dealing with named parameters. If it is
  true, then the validation code will ignore the case of parameter
  names. Defaults to false.
  
  =item * strip_leading => $characters
  
  DEPRECATED
  
  This too is only relevant when dealing with named parameters. If this
  is given then any parameters starting with these characters will be
  considered equivalent to parameters without them entirely. For
  example, if this is specified as '-', then C<-foo> and C<foo> would be
  considered identical.
  
  =back
  
  =head1 PER-INVOCATION OPTIONS
  
  The C<validate_with()> function can be used to set the options listed
  above on a per-invocation basis. For example:
  
      my %p = validate_with(
          params => \@_,
          spec   => {
              foo => { type    => SCALAR },
              bar => { default => 10 }
          },
          allow_extra => 1,
      );
  
  In addition to the options listed above, it is also possible to set
  the option "called", which should be a string. This string will be
  used in any error messages caused by a failure to meet the validation
  spec.
  
  This subroutine will validate named parameters as a hash if the "spec"
  parameter is a hash reference. If it is an array reference, the
  parameters are assumed to be positional.
  
      my %p = validate_with(
          params => \@_,
          spec   => {
              foo => { type    => SCALAR },
              bar => { default => 10 }
          },
          allow_extra => 1,
          called      => 'The Quux::Baz class constructor',
      );
  
      my @p = validate_with(
          params => \@_,
          spec   => [
              { type    => SCALAR },
              { default => 10 }
          ],
          allow_extra => 1,
          called      => 'The Quux::Baz class constructor',
      );
  
  =head1 DISABLING VALIDATION
  
  If the environment variable C<PERL_NO_VALIDATION> is set to something
  true, then validation is turned off. This may be useful if you only
  want to use this module during development but don't want the speed
  hit during production.
  
  The only error that will be caught will be when an odd number of
  parameters are passed into a function/method that expects a hash.
  
  If you want to selectively turn validation on and off at runtime, you
  can directly set the C<$Params::Validate::NO_VALIDATION> global
  variable. It is B<strongly> recommended that you B<localize> any
  changes to this variable, because other modules you are using may
  expect validation to be on when they execute. For example:
  
      {
          local $Params::Validate::NO_VALIDATION = 1;
  
          # no error
          foo( bar => 2 );
      }
  
      # error
      foo( bar => 2 );
  
      sub foo {
          my %p = validate( @_, { foo => 1 } );
          ...;
      }
  
  But if you want to shoot yourself in the foot and just turn it off, go
  ahead!
  
  =head1 SPECIFYING AN IMPLEMENTATION
  
  This module ships with two equivalent implementations, one in XS and one in
  pure Perl. By default, it will try to load the XS version and fall back to the
  pure Perl implementation as needed. If you want to request a specific version,
  you can set the C<PARAMS_VALIDATE_IMPLEMENTATION> environment variable to
  either C<XS> or C<PP>. If the implementation you ask for cannot be loaded,
  then this module will die when loaded.
  
  =head1 TAINT MODE
  
  The XS implementation of this module has some problems Under taint mode with
  versions of Perl before 5.14. If validation I<fails>, then instead of getting
  the expected error message you'll get a message like "Insecure dependency in
  eval_sv". This can be worked around by either untainting the arguments
  yourself, using the pure Perl implementation, or upgrading your Perl.
  
  =head1 LIMITATIONS
  
  Right now there is no way (short of a callback) to specify that
  something must be of one of a list of classes, or that it must possess
  one of a list of methods. If this is desired, it can be added in the
  future.
  
  Ideally, there would be only one validation function. If someone
  figures out how to do this, please let me know.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<http://rt.cpan.org/Public/Dist/Display.html?Name=Params-Validate> or via email to L<bug-params-validate@rt.cpan.org|mailto:bug-params-validate@rt.cpan.org>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Params-Validate can be found at L<https://github.com/houseabsolute/Params-Validate>.
  
  =head1 DONATIONS
  
  If you'd like to thank me for the work I've done on this module, please
  consider making a "donation" to me via PayPal. I spend a lot of free time
  creating free software, and would appreciate any support you'd care to offer.
  
  Please note that B<I am not suggesting that you must do this> in order for me
  to continue working on this particular software. I will continue to do so,
  inasmuch as I have in the past, for as long as it interests me.
  
  Similarly, a donation made in this way will probably not make me work on this
  software much more, unless I get so many donations that I can consider working
  on free software full time (let's all have a chuckle at that together).
  
  To donate, log into PayPal and send money to autarch@urth.org, or use the
  button at L<http://www.urth.org/~autarch/fs-donation.html>.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Ilya Martynov <ilya@martynov.org>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Andy Grundman E. Choroba Ivan Bessarabov J.R. Mash Karen Etheridge Noel Maddy Olivier Mengué Tony Cook Vincent Pit
  
  =over 4
  
  =item *
  
  Andy Grundman <andyg@activestate.com>
  
  =item *
  
  E. Choroba <choroba@matfyz.cz>
  
  =item *
  
  Ivan Bessarabov <ivan@bessarabov.ru>
  
  =item *
  
  J.R. Mash <jmash.code@gmail.com>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Noel Maddy <zhtwnpanta@gmail.com>
  
  =item *
  
  Olivier Mengué <dolmen@cpan.org>
  
  =item *
  
  Tony Cook <tony@develop-help.com>
  
  =item *
  
  Vincent Pit <perl@profvince.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2001 - 2017 by Dave Rolsky and Ilya Martynov.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
X86_64-LINUX_PARAMS_VALIDATE

$fatpacked{"x86_64-linux/Params/Validate/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PARAMS_VALIDATE_CONSTANTS';
  package Params::Validate::Constants;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.29';
  
  our @ISA = 'Exporter';
  
  our @EXPORT = qw(
      SCALAR
      ARRAYREF
      HASHREF
      CODEREF
      GLOB
      GLOBREF
      SCALARREF
      HANDLE
      BOOLEAN
      UNDEF
      OBJECT
      UNKNOWN
  );
  
  sub SCALAR ()    { 1 }
  sub ARRAYREF ()  { 2 }
  sub HASHREF ()   { 4 }
  sub CODEREF ()   { 8 }
  sub GLOB ()      { 16 }
  sub GLOBREF ()   { 32 }
  sub SCALARREF () { 64 }
  sub UNKNOWN ()   { 128 }
  sub UNDEF ()     { 256 }
  sub OBJECT ()    { 512 }
  
  sub HANDLE ()  { 16 | 32 }
  sub BOOLEAN () { 1 | 256 }
  
  1;
X86_64-LINUX_PARAMS_VALIDATE_CONSTANTS

$fatpacked{"x86_64-linux/Params/Validate/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PARAMS_VALIDATE_PP';
  package Params::Validate::PP;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.29';
  
  use Params::Validate::Constants;
  use Scalar::Util 1.10 ();
  
  our $options;
  
  # Various internals notes (for me and any future readers of this
  # monstrosity):
  #
  # - A lot of the weirdness is _intentional_, because it optimizes for
  #   the _success_ case.  It does not really matter how slow the code is
  #   after it enters a path that leads to reporting failure.  But the
  #   "success" path should be as fast as possible.
  #
  # -- We only calculate $called as needed for this reason, even though it
  #    means copying code all over.
  #
  # - All the validation routines need to be careful never to alter the
  #   references that are passed.
  #
  # -- The code assumes that _most_ callers will not be using the
  #    skip_leading or ignore_case features.  In order to not alter the
  #    references passed in, we copy them wholesale when normalizing them
  #    to make these features work.  This is slower but lets us be faster
  #    when not using them.
  
  # Matt Sergeant came up with this prototype, which slickly takes the
  # first array (which should be the caller's @_), and makes it a
  # reference.  Everything after is the parameters for validation.
  sub validate_pos (\@@) {
      return if $Params::Validate::NO_VALIDATION && !defined wantarray;
  
      my $p = shift;
  
      my @specs = @_;
  
      my @p = @$p;
      if ($Params::Validate::NO_VALIDATION) {
  
          # if the spec is bigger that's where we can start adding
          # defaults
          for ( my $x = $#p + 1; $x <= $#specs; $x++ ) {
              $p[$x] = $specs[$x]->{default}
                  if ref $specs[$x] && exists $specs[$x]->{default};
          }
  
          return wantarray ? @p : \@p;
      }
  
      # I'm too lazy to pass these around all over the place.
      local $options ||= _get_options( ( caller(0) )[0] )
          unless defined $options;
  
      my $min = 0;
  
      while (1) {
          last
              unless (
              ref $specs[$min]
              ? !( exists $specs[$min]->{default} || $specs[$min]->{optional} )
              : $specs[$min]
              );
  
          $min++;
      }
  
      my $max = scalar @specs;
  
      my $actual = scalar @p;
      unless ( $actual >= $min
          && ( $options->{allow_extra} || $actual <= $max ) ) {
          my $minmax = (
              $options->{allow_extra}
              ? "at least $min"
              : ( $min != $max ? "$min - $max" : $max )
          );
  
          my $val = $options->{allow_extra} ? $min : $max;
          $minmax .= $val != 1 ? ' were' : ' was';
  
          my $called = _get_called();
  
          $options->{on_fail}->( "$actual parameter"
                  . ( $actual != 1 ? 's'    : '' ) . " "
                  . ( $actual != 1 ? 'were' : 'was' )
                  . " passed to $called but $minmax expected\n" );
      }
  
      my $bigger = $#p > $#specs ? $#p : $#specs;
      foreach ( 0 .. $bigger ) {
          my $spec = $specs[$_];
  
          next unless ref $spec;
  
          if ( $_ <= $#p ) {
              _validate_one_param(
                  $p[$_], \@p, $spec,
                  'Parameter #' . ( $_ + 1 ) . ' (%s)'
              );
          }
  
          $p[$_] = $spec->{default} if $_ > $#p && exists $spec->{default};
      }
  
      _validate_pos_depends( \@p, \@specs );
  
      foreach (
          grep {
                     defined $p[$_]
                  && !ref $p[$_]
                  && ref $specs[$_]
                  && $specs[$_]{untaint}
          } 0 .. $bigger
          ) {
          ( $p[$_] ) = $p[$_] =~ /(.+)/;
      }
  
      return wantarray ? @p : \@p;
  }
  
  sub _validate_pos_depends {
      my ( $p, $specs ) = @_;
  
      for my $p_idx ( 0 .. $#$p ) {
          my $spec = $specs->[$p_idx];
  
          next
              unless $spec
              && UNIVERSAL::isa( $spec, 'HASH' )
              && exists $spec->{depends};
  
          my $depends = $spec->{depends};
  
          if ( ref $depends ) {
              require Carp;
              local $Carp::CarpLevel = 2;
              Carp::croak(
                  "Arguments to 'depends' for validate_pos() must be a scalar");
          }
  
          my $p_size = scalar @$p;
          if ( $p_size < $depends - 1 ) {
              my $error
                  = (   "Parameter #"
                      . ( $p_idx + 1 )
                      . " depends on parameter #"
                      . $depends
                      . ", which was not given" );
  
              $options->{on_fail}->($error);
          }
      }
      return 1;
  }
  
  sub _validate_named_depends {
      my ( $p, $specs ) = @_;
  
      foreach my $pname ( keys %$p ) {
          my $spec = $specs->{$pname};
  
          next
              unless $spec
              && UNIVERSAL::isa( $spec, 'HASH' )
              && $spec->{depends};
  
          unless ( UNIVERSAL::isa( $spec->{depends}, 'ARRAY' )
              || !ref $spec->{depends} ) {
              require Carp;
              local $Carp::CarpLevel = 2;
              Carp::croak(
                  "Arguments to 'depends' must be a scalar or arrayref");
          }
  
          foreach my $depends_name (
              ref $spec->{depends}
              ? @{ $spec->{depends} }
              : $spec->{depends}
              ) {
              unless ( exists $p->{$depends_name} ) {
                  my $error
                      = (   "Parameter '$pname' depends on parameter '"
                          . $depends_name
                          . "', which was not given" );
  
                  $options->{on_fail}->($error);
              }
          }
      }
  }
  
  sub validate (\@$) {
      return if $Params::Validate::NO_VALIDATION && !defined wantarray;
  
      my $p = $_[0];
  
      my $specs = $_[1];
      local $options = _get_options( ( caller(0) )[0] ) unless defined $options;
  
      if ( ref $p eq 'ARRAY' ) {
  
          # we were called as validate( @_, ... ) where @_ has a
          # single element, a hash reference
          if ( ref $p->[0] ) {
              $p = { %{ $p->[0] } };
          }
          elsif ( @$p % 2 ) {
              my $called = _get_called();
  
              $options->{on_fail}
                  ->(   "Odd number of parameters in call to $called "
                      . "when named parameters were expected\n" );
          }
          else {
              $p = {@$p};
          }
      }
  
      if ( $options->{normalize_keys} ) {
          $specs = _normalize_callback( $specs, $options->{normalize_keys} );
          $p     = _normalize_callback( $p,     $options->{normalize_keys} );
      }
      elsif ( $options->{ignore_case} || $options->{strip_leading} ) {
          $specs = _normalize_named($specs);
          $p     = _normalize_named($p);
      }
  
      if ($Params::Validate::NO_VALIDATION) {
          return (
              wantarray
              ? (
  
                  # this is a hash containing just the defaults
                  (
                      map { $_ => $specs->{$_}->{default} }
                          grep {
                          ref $specs->{$_}
                              && exists $specs->{$_}->{default}
                          }
                          keys %$specs
                  ),
                  (
                      ref $p eq 'ARRAY'
                      ? (
                          ref $p->[0]
                          ? %{ $p->[0] }
                          : @$p
                          )
                      : %$p
                  )
                  )
              : do {
                  my $ref = (
                      ref $p eq 'ARRAY'
                      ? (
                          ref $p->[0]
                          ? $p->[0]
                          : {@$p}
                          )
                      : $p
                  );
  
                  foreach (
                      grep {
                          ref $specs->{$_}
                              && exists $specs->{$_}->{default}
                      }
                      keys %$specs
                      ) {
                      $ref->{$_} = $specs->{$_}->{default}
                          unless exists $ref->{$_};
                  }
  
                  return $ref;
                  }
          );
      }
  
      _validate_named_depends( $p, $specs );
  
      unless ( $options->{allow_extra} ) {
          if ( my @unmentioned = grep { !exists $specs->{$_} } keys %$p ) {
              my $called = _get_called();
  
              $options->{on_fail}->( "The following parameter"
                      . ( @unmentioned > 1 ? 's were' : ' was' )
                      . " passed in the call to $called but "
                      . ( @unmentioned > 1 ? 'were' : 'was' )
                      . " not listed in the validation options: @unmentioned\n"
              );
          }
      }
  
      my @missing;
  
      # the iterator needs to be reset in case the same hashref is being
      # passed to validate() on successive calls, because we may not go
      # through all the hash's elements
      keys %$specs;
  OUTER:
      while ( my ( $key, $spec ) = each %$specs ) {
          if (
              !exists $p->{$key}
              && (
                  ref $spec
                  ? !(
                      do {
  
                          # we want to short circuit the loop here if we
                          # can assign a default, because there's no need
                          # check anything else at all.
                          if ( exists $spec->{default} ) {
                              $p->{$key} = $spec->{default};
                              next OUTER;
                          }
                      }
                      || do {
  
                          # Similarly, an optional parameter that is
                          # missing needs no additional processing.
                          next OUTER if $spec->{optional};
                      }
                  )
                  : $spec
              )
              ) {
              push @missing, $key;
          }
  
          # Can't validate a non hashref spec beyond the presence or
          # absence of the parameter.
          elsif ( ref $spec ) {
              my $value = defined $p->{$key} ? qq|"$p->{$key}"| : 'undef';
              _validate_one_param(
                  $p->{$key}, $p, $spec,
                  qq{The '$key' parameter (%s)}
              );
          }
      }
  
      if (@missing) {
          my $called = _get_called();
  
          my $missing = join ', ', map {"'$_'"} sort @missing;
          $options->{on_fail}->( "Mandatory parameter"
                  . ( @missing > 1 ? 's' : '' )
                  . " $missing missing in call to $called\n" );
      }
  
      # do untainting after we know everything passed
      foreach my $key (
          grep {
                     defined $p->{$_}
                  && !ref $p->{$_}
                  && ref $specs->{$_}
                  && $specs->{$_}{untaint}
          }
          keys %$p
          ) {
          ( $p->{$key} ) = $p->{$key} =~ /(.+)/;
      }
  
      return wantarray ? %$p : $p;
  }
  
  sub validate_with {
      return if $Params::Validate::NO_VALIDATION && !defined wantarray;
  
      my %p = @_;
  
      local $options = _get_options( ( caller(0) )[0], %p );
  
      unless ($Params::Validate::NO_VALIDATION) {
          unless ( exists $options->{called} ) {
              $options->{called} = ( caller( $options->{stack_skip} ) )[3];
          }
  
      }
  
      if ( UNIVERSAL::isa( $p{spec}, 'ARRAY' ) ) {
          return validate_pos( @{ $p{params} }, @{ $p{spec} } );
      }
      else {
  
          # intentionally ignore the prototype because this contains
          # either an array or hash reference, and validate() will
          # handle either one properly
          return &validate( $p{params}, $p{spec} );
      }
  }
  
  sub _normalize_callback {
      my ( $p, $func ) = @_;
  
      my %new;
  
      foreach my $key ( keys %$p ) {
          my $new_key = $func->($key);
  
          unless ( defined $new_key ) {
              die
                  "The normalize_keys callback did not return a defined value when normalizing the key '$key'";
          }
  
          if ( exists $new{$new_key} ) {
              die
                  "The normalize_keys callback returned a key that already exists, '$new_key', when normalizing the key '$key'";
          }
  
          $new{$new_key} = $p->{$key};
      }
  
      return \%new;
  }
  
  sub _normalize_named {
  
      # intentional copy so we don't destroy original
      my %h = ( ref $_[0] ) =~ /ARRAY/ ? @{ $_[0] } : %{ $_[0] };
  
      if ( $options->{ignore_case} ) {
          $h{ lc $_ } = delete $h{$_} for keys %h;
      }
  
      if ( $options->{strip_leading} ) {
          foreach my $key ( keys %h ) {
              my $new;
              ( $new = $key ) =~ s/^\Q$options->{strip_leading}\E//;
              $h{$new} = delete $h{$key};
          }
      }
  
      return \%h;
  }
  
  my %Valid = map { $_ => 1 }
      qw( callbacks can default depends isa optional regex type untaint  );
  
  sub _validate_one_param {
      my ( $value, $params, $spec, $id ) = @_;
  
      # for my $key ( keys %{$spec} ) {
      #     unless ( $Valid{$key} ) {
      #         $options->{on_fail}
      #             ->(qq{"$key" is not an allowed validation spec key});
      #     }
      # }
  
      if ( exists $spec->{type} ) {
          unless ( defined $spec->{type}
              && Scalar::Util::looks_like_number( $spec->{type} )
              && $spec->{type} > 0 ) {
              my $msg
                  = "$id has a type specification which is not a number. It is ";
              if ( defined $spec->{type} ) {
                  $msg .= "a string - $spec->{type}";
              }
              else {
                  $msg .= "undef";
              }
  
              $msg
                  .= ".\n Use the constants exported by Params::Validate to declare types.";
  
              $options->{on_fail}->( sprintf( $msg, _stringify($value) ) );
          }
  
          unless ( _get_type($value) & $spec->{type} ) {
              my $type = _get_type($value);
  
              my @is      = _typemask_to_strings($type);
              my @allowed = _typemask_to_strings( $spec->{type} );
              my $article = $is[0] =~ /^[aeiou]/i ? 'an' : 'a';
  
              my $called = _get_called(1);
  
              $options->{on_fail}->(
                  sprintf(
                      "$id to $called was $article '@is', which "
                          . "is not one of the allowed types: @allowed\n",
                      _stringify($value)
                  )
              );
          }
      }
  
      # short-circuit for common case
      return
          unless ( $spec->{isa}
          || $spec->{can}
          || $spec->{callbacks}
          || $spec->{regex} );
  
      if ( exists $spec->{isa} ) {
          foreach ( ref $spec->{isa} ? @{ $spec->{isa} } : $spec->{isa} ) {
              unless (
                  do {
                      local $@ = q{};
                      eval { $value->isa($_) };
                  }
                  ) {
                  my $is = ref $value ? ref $value : 'plain scalar';
                  my $article1 = $_ =~ /^[aeiou]/i  ? 'an' : 'a';
                  my $article2 = $is =~ /^[aeiou]/i ? 'an' : 'a';
  
                  my $called = _get_called(1);
  
                  $options->{on_fail}->(
                      sprintf(
                                "$id to $called was not $article1 '$_' "
                              . "(it is $article2 $is)\n", _stringify($value)
                      )
                  );
              }
          }
      }
  
      if ( exists $spec->{can} ) {
          foreach ( ref $spec->{can} ? @{ $spec->{can} } : $spec->{can} ) {
              unless (
                  do {
                      local $@ = q{};
                      eval { $value->can($_) };
                  }
                  ) {
                  my $called = _get_called(1);
  
                  $options->{on_fail}->(
                      sprintf(
                          "$id to $called does not have the method: '$_'\n",
                          _stringify($value)
                      )
                  );
              }
          }
      }
  
      if ( $spec->{callbacks} ) {
          unless ( UNIVERSAL::isa( $spec->{callbacks}, 'HASH' ) ) {
              my $called = _get_called(1);
  
              $options->{on_fail}->(
                  "'callbacks' validation parameter for $called must be a hash reference\n"
              );
          }
  
          foreach ( keys %{ $spec->{callbacks} } ) {
              unless ( UNIVERSAL::isa( $spec->{callbacks}{$_}, 'CODE' ) ) {
                  my $called = _get_called(1);
  
                  $options->{on_fail}->(
                      "callback '$_' for $called is not a subroutine reference\n"
                  );
              }
  
              my $ok;
              my $e = do {
                  local $@ = q{};
                  local $SIG{__DIE__};
                  $ok = eval { $spec->{callbacks}{$_}->( $value, $params ) };
                  $@;
              };
  
              if ( !$ok ) {
                  my $called = _get_called(1);
  
                  if ( ref $e ) {
                      $options->{on_fail}->($e);
                  }
                  else {
                      my $msg = "$id to $called did not pass the '$_' callback";
                      $msg .= ": $e" if length $e;
                      $msg .= "\n";
                      $options->{on_fail}->( sprintf( $msg, _stringify($value) ) );
                  }
              }
          }
      }
  
      if ( exists $spec->{regex} ) {
          unless ( ( defined $value ? $value : '' ) =~ /$spec->{regex}/ ) {
              my $called = _get_called(1);
  
              $options->{on_fail}->(
                  sprintf(
                      "$id to $called did not pass regex check\n",
                      _stringify($value)
                  )
              );
          }
      }
  }
  
  {
      # if it UNIVERSAL::isa the string on the left then its the type on
      # the right
      my %isas = (
          'ARRAY'  => ARRAYREF,
          'HASH'   => HASHREF,
          'CODE'   => CODEREF,
          'GLOB'   => GLOBREF,
          'SCALAR' => SCALARREF,
          'REGEXP' => SCALARREF,
      );
      my %simple_refs = map { $_ => 1 } keys %isas;
  
      sub _get_type {
          return UNDEF unless defined $_[0];
  
          my $ref = ref $_[0];
          unless ($ref) {
  
              # catches things like:  my $fh = do { local *FH; };
              return GLOB if UNIVERSAL::isa( \$_[0], 'GLOB' );
              return SCALAR;
          }
  
          return $isas{$ref} if $simple_refs{$ref};
  
          foreach ( keys %isas ) {
              return $isas{$_} | OBJECT if UNIVERSAL::isa( $_[0], $_ );
          }
  
          # I really hope this never happens.
          return UNKNOWN;
      }
  }
  
  {
      my %type_to_string = (
          SCALAR()    => 'scalar',
          ARRAYREF()  => 'arrayref',
          HASHREF()   => 'hashref',
          CODEREF()   => 'coderef',
          GLOB()      => 'glob',
          GLOBREF()   => 'globref',
          SCALARREF() => 'scalarref',
          UNDEF()     => 'undef',
          OBJECT()    => 'object',
          UNKNOWN()   => 'unknown',
      );
  
      sub _typemask_to_strings {
          my $mask = shift;
  
          my @types;
          foreach (
              SCALAR,    ARRAYREF, HASHREF, CODEREF, GLOB, GLOBREF,
              SCALARREF, UNDEF,    OBJECT,  UNKNOWN
              ) {
              push @types, $type_to_string{$_} if $mask & $_;
          }
          return @types ? @types : ('unknown');
      }
  }
  
  {
      my %defaults = (
          ignore_case   => 0,
          strip_leading => 0,
          allow_extra   => 0,
          on_fail       => sub {
              require Carp;
              Carp::croak( $_[0] );
          },
          stack_skip     => 1,
          normalize_keys => undef,
      );
  
      *set_options = \&validation_options;
  
      sub validation_options {
          my %opts = @_;
  
          my $caller = caller;
  
          foreach ( keys %defaults ) {
              $opts{$_} = $defaults{$_} unless exists $opts{$_};
          }
  
          $Params::Validate::OPTIONS{$caller} = \%opts;
      }
  
      sub _get_options {
          my $caller = shift;
  
          if (@_) {
  
              return (
                  $Params::Validate::OPTIONS{$caller}
                  ? {
                      %{ $Params::Validate::OPTIONS{$caller} },
                      @_
                      }
                  : { %defaults, @_ }
              );
          }
          else {
              return (
                  exists $Params::Validate::OPTIONS{$caller}
                  ? $Params::Validate::OPTIONS{$caller}
                  : \%defaults
              );
          }
      }
  }
  
  sub _get_called {
      my $extra_skip = $_[0] || 0;
  
      # always add one more for this sub
      $extra_skip++;
  
      my $called = (
          exists $options->{called}
          ? $options->{called}
          : ( caller( $options->{stack_skip} + $extra_skip ) )[3]
      );
  
      $called = '(unknown)' unless defined $called;
  
      return $called;
  }
  
  sub _stringify {
      return defined $_[0] ? qq{"$_[0]"} : 'undef';
  }
  
  1;
X86_64-LINUX_PARAMS_VALIDATE_PP

$fatpacked{"x86_64-linux/Params/Validate/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PARAMS_VALIDATE_XS';
  package Params::Validate::XS;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.29';
  
  use Carp;
  
  my $default_fail = sub {
      Carp::confess( $_[0] );
  };
  
  {
      my %defaults = (
          ignore_case    => 0,
          strip_leading  => 0,
          allow_extra    => 0,
          on_fail        => $default_fail,
          stack_skip     => 1,
          normalize_keys => undef,
      );
  
      *set_options = \&validation_options;
  
      sub validation_options {
          my %opts = @_;
  
          my $caller = caller;
  
          foreach ( keys %defaults ) {
              $opts{$_} = $defaults{$_} unless exists $opts{$_};
          }
  
          $Params::Validate::OPTIONS{$caller} = \%opts;
      }
  
      use XSLoader;
      XSLoader::load(
          __PACKAGE__,
          exists $Params::Validate::XS::{VERSION}
          ? ${ $Params::Validate::XS::{VERSION} }
          : (),
      );
  }
  
  sub _check_regex_from_xs {
      return ( defined $_[0] ? $_[0] : '' ) =~ /$_[1]/ ? 1 : 0;
  }
  
  1;
X86_64-LINUX_PARAMS_VALIDATE_XS

$fatpacked{"x86_64-linux/Params/ValidatePP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PARAMS_VALIDATEPP';
  package    # hide from PAUSE
      Params::Validate;
  
  our $VERSION = '1.29';
  
  BEGIN { $ENV{PARAMS_VALIDATE_IMPLEMENTATION} = 'PP' }
  use Params::Validate;
  
  1;
X86_64-LINUX_PARAMS_VALIDATEPP

$fatpacked{"x86_64-linux/Params/ValidateXS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PARAMS_VALIDATEXS';
  package # hide from PAUSE
      Params::Validate;
  
  our $VERSION = '1.29';
  
  BEGIN { $ENV{PARAMS_VALIDATE_IMPLEMENTATION} = 'XS' }
  use Params::Validate;
  
  1;
X86_64-LINUX_PARAMS_VALIDATEXS

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/usr/bin/env perl
    
use strict; 
use warnings;
    
use Getopt::Long::Descriptive;
use IO::Prompter;
    
our $VERSION = '0.003'; # VERSION
# PODNAME: git-ribbon

my ($option, $usage) = describe_options(
    'usage: git ribbon %o',
    ['save|s'       => 'Save your place at origin/branch'],
    ['help|h'       => 'Show this message'],
);  
    
die($usage) if $option->help;

$option->save 
    ? save($usage) 
    : ribbon($usage);



sub save { print `git tag --force _ribbon origin/master` }

sub ribbon {
    my $option = shift;

    my @logs = `git log --pretty=format:'git difftool -r %p -r %h --no-prompt %n%C(bold white)%an %cr %h%n%s%Creset' --stat --no-merges --reverse --topo-order _ribbon..origin/master`;

    my $i = 0;
    while ($i < $#logs) {
        my $cmd = $logs[$i];
        $i++;

        while ($logs[$i] !~ /^git difftool -r /) {
            print $logs[$i];
            $i++;
            last if $i >= $#logs;
        }

        my $answer = prompt "press 's' to skip", -echo => "", -single;

        unless ($answer eq 's') {
            my $pid = fork();
            if (!$pid) { # child
                exec($cmd);
            }
            waitpid $pid, 0;
        }
        
        print "\n";
    }
}

END { print "\n" unless $option->save }

__END__

=pod

=encoding utf-8

=head1 NAME

git-ribbon

=head1 AUTHOR

Eric Johnson <cpan at iijo dot nospamthanks dot org>

=head1 COPYRIGHT AND LICENSE

This software is Copyright (c) 2013 by Eric Johnson.

This is free software, licensed under:

  The Apache License, Version 2.0, January 2004

=cut
