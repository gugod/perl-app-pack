#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Contextual/Return.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONTEXTUAL_RETURN';
  package Contextual::Return;
  use warnings;
  use strict;
  our $VERSION = '0.004014';
  
  my %attrs_of;
  
  # This is localized as caller to hide the interim blocks...
  my $smart_caller;
  
  # Fake out Carp::*, and Scalar::Util::blessed() very early...
  BEGIN {
      no warnings 'redefine';
  
      my $fallback_caller = *CORE::GLOBAL::caller{CODE};
      if (!defined $fallback_caller) {
          *CORE::GLOBAL::caller = sub (;$) {
              my ($height) = @_;
              $height++;
              my @caller = CORE::caller($height);
              if ( CORE::caller() eq 'DB' ) {
                  # Oops, redo picking up @DB::args
                  package DB;
                  @caller = CORE::caller($height);
              }
  
              return if ! @caller;                  # empty
              return $caller[0] if ! wantarray;     # scalar context
              return @_ ? @caller : @caller[0..2];  # extra info or regular
          };
      }
      $smart_caller = sub (;$) {
          my ($uplevels) = $_[0] || 0;
          my @caller;
          if (CORE::caller eq 'DB') {
              package DB;
              if ($fallback_caller) {
                  @caller = $fallback_caller->($uplevels + 5 + $Contextual::Return::uplevel)
                      if $Contextual::Return::uplevel;
                  @caller = $fallback_caller->($uplevels + 4);
              }
              else {
                  @caller = CORE::caller($uplevels + 5 + $Contextual::Return::uplevel)
                      if $Contextual::Return::uplevel;
                  @caller = CORE::caller($uplevels + 4);
              }
          }
          else {
              if ($fallback_caller) {
                  @caller = $fallback_caller->($uplevels + 5 + $Contextual::Return::uplevel)
                      if $Contextual::Return::uplevel;
                  @caller = $fallback_caller->($uplevels + 4);
              }
              else {
                  @caller = CORE::caller($uplevels + 5 + $Contextual::Return::uplevel)
                      if $Contextual::Return::uplevel;
                  @caller = CORE::caller($uplevels + 4);
              }
          }
          return if ! @caller;                  # empty
          return $caller[0] if ! wantarray;     # scalar context
          return @_ ? @caller : @caller[0..2];  # extra info or regular
      };
  
      use Carp;
      my $real_carp  = *Carp::carp{CODE};
      my $real_croak = *Carp::croak{CODE};
  
      *Carp::carp = sub {
          goto &{$real_carp} if !$Contextual::Return::uplevel;
          warn _in_context(@_);
      };
  
      *Carp::croak = sub {
          goto &{$real_croak} if !$Contextual::Return::uplevel;
          die _in_context(@_);
      };
  
      # Scalar::Util::blessed()...
      use Scalar::Util 'refaddr';
  
      # Remember the current blessed()...
      my $original_blessing = *Scalar::Util::blessed{CODE};
  
      # ...and replace it...
      *Scalar::Util::blessed = sub($) {
          no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
          # Are we operating on a CRV???
          my $attrs = $attrs_of{refaddr $_[0] or q{}};
  
          # If not, use the original code...
          goto &{$original_blessing} if !$attrs;
  
          # Does this object have a BLESSED handler???
          if (exists $attrs->{BLESSED}) {
              return $attrs->{BLESSED}->(@{$attrs->{args}});
          }
  
          # Otherwise, find the appropriate scalar handler...
          handler:
          for my $context (qw( OBJREF LAZY REF SCALAR VALUE NONVOID DEFAULT )) {
              my $handler = $attrs->{$context}
                  or next handler;
  
              my $obj_ref = eval { $handler->(@{$attrs->{args}}) };
  
              my $was_blessed = $original_blessing->($obj_ref);
              return $was_blessed if $was_blessed;
          }
  
          # Otherwise, simulate unblessed status...
          return undef;
      };
  }
  
  
  
  sub _in_context {
      my $msg = join q{}, @_;
  
      # Start looking in caller...
      my $stack_frame = 1;
      my ($package, $file, $line, $sub) = CORE::caller($stack_frame++);
  
      my ($orig_package, $prev_package) = ($package) x 2;
      my $LOC = qq{at $file line $line};
  
      # Walk up stack...
      STACK_FRAME:
      while (1) {
          my ($package, $file, $line, $sub) = CORE::caller($stack_frame++);
  
          # Fall off the top of the stack...
          last STACK_FRAME if !defined $package;
  
          # Ignore this module (and any helpers)...
          next STACK_FRAME if $package =~ m{^Contextual::Return}xms;
  
          # Track the call up the stack...
          $LOC = qq{at $file line $line};
  
          # Ignore any @CARP_NOT'ed packages
          next STACK_FRAME
              if do { no strict 'refs'; *{$package.'::CARP_NOT'}{ARRAY}; };
  
          # Ignore transitions within original caller...
          next STACK_FRAME
              if $package eq $orig_package && $prev_package eq $orig_package;
  
          # If we get a transition out of the original package, we're there...
          last STACK_FRAME;
      }
  
      # Insert location details...
      $msg =~ s/<LOC>/$LOC/g or $msg =~ s/[^\S\n]*$/ $LOC/;
      $msg =~ s/$/\n/;
      return $msg;
  }
  
  # Indentation corresponds to inherited fall-back relationships...
  my @CONTEXTS = qw(
      DEFAULT
          VOID
          NONVOID
              LIST
              SCALAR
                  VALUE
                      STR
                      NUM
                      BOOL
                          PUREBOOL
                  REF
                      SCALARREF
                      ARRAYREF
                      CODEREF
                      HASHREF
                      GLOBREF
                      OBJREF
                          METHOD
                          BLESSED
  );
  
  my @ALL_EXPORTS = (
      @CONTEXTS,
      qw(
          LAZY       RESULT      RVALUE      METHOD     FAIL
          FIXED      RECOVER     LVALUE      RETOBJ     FAIL_WITH
          ACTIVE     CLEANUP     NVALUE      STRICT     BLESSED
      )
  );
  
  my %STD_NAME_FOR = map { $_ => $_ } @ALL_EXPORTS;
  
  sub import {
      # Load utility module for failure handlers...
      if (require Contextual::Return::Failure) {
          *FAIL      = \&Contextual::Return::Failure::_FAIL;
          *FAIL_WITH = \&Contextual::Return::Failure::_FAIL_WITH;
      }
  
      # Don't need the package name...
      shift @_;
  
      # If args, export nothing by default; otherwise export all...
      my %exports = @_ ? () : %STD_NAME_FOR;
  
      # All args are export either selectors and/or renamers...
      while (my $selector = shift @_) {
          my $next_arg = $_[0];
          my $renamer = (defined $next_arg
                      && !ref $next_arg
                      && !exists $STD_NAME_FOR{$next_arg})
                          ? shift(@_)
                          : undef;
          %exports = (%exports, _add_exports_for($selector, $renamer));
      }
  
      # Loop through possible exports, exporting anything requested...
      my $caller = CORE::caller;
      EXPORT:
      for my $subname (keys %exports) {
          no strict qw( refs );
          *{$caller.'::'.$exports{$subname}} = \&{$subname};
      }
  };
  
  sub _add_exports_for {
      my ($selector, $renamer) = @_;
  
      # If no renamer, use original name...
      $renamer ||= '%s';
  
      # Handle different types of selector...
      my $selector_type = ref($selector) || 'literal';
  
      # Array selector recursively export each element...
      if ($selector_type eq 'ARRAY') {
          return map { _add_exports_for($_,$renamer) } @{$selector};
      }
      elsif ($selector_type eq 'Regexp') {
          my @selected = grep {/$selector/} @ALL_EXPORTS;
          if (!@selected) {
              Carp::carp("use Contextual::Return $selector didn't export anything");
          }
          no if $] >= 5.022, warnings => 'redundant';
          return map { $_ => sprintf($renamer, $_) } @selected;
      }
      elsif ($selector_type eq 'literal') {
          Carp::croak "Can't export $selector: no such handler"
              if !exists $STD_NAME_FOR{$selector};
          no if $] >= 5.022, warnings => 'redundant';
          return ( $selector => sprintf($renamer, $selector) );
      }
      else {
          Carp::croak "Can't use $selector_type as export specifier";
      }
  }
  
  
  # Let handlers access the result object they're inside...
  
  sub RETOBJ() {
      our $__RETOBJ__;
      return $__RETOBJ__;
  }
  
  
  use Scalar::Util qw( refaddr );
  
  # Override return value in a C::R handler...
  sub RESULT(;&) {
      my ($block) = @_;
  
      # Determine call context and arg list...
      my $context;
      my $args = do { package DB; $context=(CORE::caller 1)[5]; my $args = \@DB::args; ()=CORE::caller(1); $args };
  
      # No args -> return appropriate value...
      if (!@_) {
          return $context ? @{ $Contextual::Return::__RESULT__ || [] }
                          :    $Contextual::Return::__RESULT__->[0]
                          ;
      }
  
      # Hide from caller() and the enclosing eval{}...
  
      # Evaluate block in context and cache result...
      local $Contextual::Return::uplevel = $Contextual::Return::uplevel+1;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
      $Contextual::Return::__RESULT__
          =         $context  ? [        $block->(@{$args})      ]
          : defined $context  ? [ scalar $block->(@{$args}) ]
          :                     do {     $block->(@{$args}); [] }
          ;
  
      return;
  }
  
  sub RVALUE(&;@) :lvalue;
  sub LVALUE(&;@) :lvalue;
  sub NVALUE(&;@) :lvalue;
  
  my %opposite_of = (
      'RVALUE' => 'LVALUE or NVALUE',
      'LVALUE' => 'RVALUE or NVALUE',
      'NVALUE' => 'LVALUE or RVALUE',
  );
  
  
  BEGIN {
      for my $subname (qw( RVALUE LVALUE NVALUE) ) {
          no strict 'refs';
          *{$subname} = sub(&;@) :lvalue {    # (handler, return_lvalue);
              my $handler = shift;
              my $impl;
              my $args = do{ package DB; ()=CORE::caller(1); my $args = \@DB::args; ()=CORE::caller(1); $args };
              if (@_==0) {
                  $impl = tie $_[0], 'Contextual::Return::Lvalue',
                      $subname => $handler, args=>$args;
              }
              elsif (@_==1 and $impl = tied $_[0]) {
                  die _in_context "Can't install two $subname handlers"
                      if exists $impl->{$subname};
                  $impl->{$subname} = $handler;
              }
              else {
                  my $vals = join q{, }, map { tied $_    ? keys %{tied $_}
                                             : defined $_ ? $_
                                             :              'undef'
                                             } @_;
                  die _in_context "Expected a $opposite_of{$subname} block ",
                                  "after the $subname block <LOC> ",
                                  "but found instead: $vals\n";
              }
  
              # Handle void context calls...
              if (!defined wantarray && $impl->{NVALUE}) {
                  # Fake out caller() and Carp...
                  local $Contextual::Return::uplevel = 1;
                  no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
                  # Call and clear handler...
                  local $Contextual::Return::__RETOBJ__ = $impl;
                  $impl->{NVALUE}( @{$impl->{args}} );
                  delete $impl->{NVALUE};
              }
              $_[0];
          }
      }
  }
  
  for my $modifier_name (qw< STRICT FIXED ACTIVE >) {
      no strict 'refs';
      *{$modifier_name} = sub ($) {
          my ($crv) = @_;
          my $attrs = $attrs_of{refaddr $crv or q{}};
  
          # Track context...
          my $wantarray = wantarray;
          use Want;
          $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
          # Remember the modification...
          $attrs->{$modifier_name} = 1;
  
          # Prepare for exception handling...
          my $recover = $attrs->{RECOVER};
          local $Contextual::Return::uplevel = 2;
          no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
          # Handle list context directly, if possible...
          if ($wantarray) {
              local $Contextual::Return::__RESULT__;
              # List or ancestral handlers...
              handler:
              for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  my @rv = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [@rv];
                      }
                      () = $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  return @rv if !$Contextual::Return::__RESULT__;
                  return @{$Contextual::Return::__RESULT__};
              }
              # Convert to list from arrayref handler...
              if (!$attrs->{STRICT} and my $handler = $attrs->{ARRAYREF}) {
                  my $array_ref = eval { $handler->(@{$attrs->{args}}) };
  
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$array_ref];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  # Array ref may be returned directly, or via RESULT{}...
                  $array_ref = $Contextual::Return::__RESULT__->[0]
                      if $Contextual::Return::__RESULT__;
  
                  return @{$array_ref} if (ref $array_ref||q{}) eq 'ARRAY';
              }
              # Return scalar object as one-elem list, if possible...
              handler:
              for my $context (qw(BOOL STR NUM VALUE SCALAR LAZY)) {
                  last handler if $attrs->{STRICT};
                  return $crv if exists $attrs->{$context};
              }
              $@ = _in_context "Can't call $attrs->{sub} in a list context";
              if ($recover) {
                  () = $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          }
  
          # Handle void context directly...
          if (!defined $wantarray) {
              handler:
              for my $context (qw< VOID DEFAULT >) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  eval { $attrs->{$context}->(@{$attrs->{args}}) };
                  if ($recover) {
                      $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
                  last handler;
              }
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Can't call $attrs->{sub} in a void context";
                  if ($recover) {
                      () = $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
              return;
          }
  
          # Otherwise, let someone else handle it...
          return $crv;
      }
  }
  
  sub LIST (;&$) {
      my ($block, $crv) = @_;
  
      # Handle simple context tests...
      return !!(CORE::caller 1)[5] if !@_;
  
      # Ensure we have an object...
      my $attrs;
      if (!refaddr $crv) {
          my $args = do{ package DB; ()=CORE::caller(1); my $args = \@DB::args; ()=CORE::caller(1); $args };
          my $subname = (CORE::caller(1))[3];
          if (!defined $subname) {
              $subname = 'bare LIST {...}';
          }
          $crv = bless \my $scalar, 'Contextual::Return::Value';
          $attrs = $attrs_of{refaddr $crv} = { args => $args, sub => $subname };
      }
      else {
          $attrs = $attrs_of{refaddr $crv};
      }
      local $Contextual::Return::__RETOBJ__ = $crv;
  
      # Handle repetitions...
      die _in_context "Can't install two LIST handlers"
          if exists $attrs->{LIST};
  
      # Identify contexts...
      my $wantarray = wantarray;
      use Want;
      $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
      # Prepare for exception handling...
      my $recover = $attrs->{RECOVER};
      local $Contextual::Return::uplevel = 2;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
      # Handle list context directly...
      if ($wantarray) {
          local $Contextual::Return::__RESULT__;
  
          my @rv = eval { $block->(@{$attrs->{args}}) };
          if ($recover) {
              if (!$Contextual::Return::__RESULT__) {
                  $Contextual::Return::__RESULT__ = [@rv];
              }
              () = $recover->(@{$attrs->{args}});
          }
          elsif ($@) {
              die $@;
          }
  
          return @rv if !$Contextual::Return::__RESULT__;
          return @{$Contextual::Return::__RESULT__};
      }
  
      # Handle void context directly...
      if (!defined $wantarray) {
          handler:
          for my $context (qw< VOID DEFAULT >) {
              my $handler = $attrs->{$context}
                  or $attrs->{STRICT} and last handler
                  or next handler;
  
              eval { $attrs->{$context}->(@{$attrs->{args}}) };
              if ($recover) {
                  $recover->(@{$attrs->{args}});
              }
              elsif ($@) {
                  die $@;
              }
              last handler;
          }
          if ($attrs->{STRICT}) {
              $@ = _in_context "Can't call $attrs->{sub} in a void context";
              if ($recover) {
                  () = $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          }
          return;
      }
  
      # Otherwise, cache handler...
      $attrs->{LIST} = $block;
      return $crv;
  }
  
  
  sub VOID (;&$) {
      my ($block, $crv) = @_;
  
      # Handle simple context tests...
      return !defined( (CORE::caller 1)[5] ) if !@_;
  
      # Ensure we have an object...
      my $attrs;
      if (!refaddr $crv) {
          my $args = do{ package DB; ()=CORE::caller(1); my $args = \@DB::args; ()=CORE::caller(1); $args };
          my $subname = (CORE::caller(1))[3];
          if (!defined $subname) {
              $subname = 'bare VOID {...}';
          }
          $crv = bless \my $scalar, 'Contextual::Return::Value';
          $attrs = $attrs_of{refaddr $crv} = { args => $args, sub => $subname };
      }
      else {
          $attrs = $attrs_of{refaddr $crv};
      }
      local $Contextual::Return::__RETOBJ__ = $crv;
  
      # Handle repetitions...
      die _in_context "Can't install two VOID handlers"
          if exists $attrs->{VOID};
  
      # Identify contexts...
      my $wantarray = wantarray;
      use Want;
      $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
      # Prepare for exception handling...
      my $recover = $attrs->{RECOVER};
      local $Contextual::Return::uplevel = 2;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
      # Handle list context directly, if possible...
      if ($wantarray) {
          local $Contextual::Return::__RESULT__;
          # List or ancestral handlers...
          handler:
          for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
              my $handler = $attrs->{$context}
                  or $attrs->{STRICT} and last handler
                  or next handler;
  
              my @rv = eval { $handler->(@{$attrs->{args}}) };
              if ($recover) {
                  if (!$Contextual::Return::__RESULT__) {
                      $Contextual::Return::__RESULT__ = [@rv];
                  }
                  () = $recover->(@{$attrs->{args}});
              }
              elsif ($@) {
                  die $@;
              }
  
              return @rv if !$Contextual::Return::__RESULT__;
              return @{$Contextual::Return::__RESULT__};
          }
          # Convert to list from arrayref handler...
          if (!$attrs->{STRICT} and my $handler = $attrs->{ARRAYREF}) {
              my $array_ref = eval { $handler->(@{$attrs->{args}}) };
  
              if ($recover) {
                  if (!$Contextual::Return::__RESULT__) {
                      $Contextual::Return::__RESULT__ = [$array_ref];
                  }
                  scalar $recover->(@{$attrs->{args}});
              }
              elsif ($@) {
                  die $@;
              }
  
              # Array ref may be returned directly, or via RESULT{}...
              $array_ref = $Contextual::Return::__RESULT__->[0]
                  if $Contextual::Return::__RESULT__;
  
              return @{$array_ref} if (ref $array_ref||q{}) eq 'ARRAY';
          }
          # Return scalar object as one-elem list, if possible...
          handler:
          for my $context (qw(BOOL STR NUM VALUE SCALAR LAZY)) {
              last handler if $attrs->{STRICT};
              return $crv if exists $attrs->{$context};
          }
          $@ = _in_context "Can't call $attrs->{sub} in a list context";
          if ($recover) {
              () = $recover->(@{$attrs->{args}});
          }
          else {
              die $@;
          }
      }
  
      # Handle void context directly...
      if (!defined $wantarray) {
          eval { $block->(@{$attrs->{args}}) };
  
          if ($recover) {
              $recover->(@{$attrs->{args}});
          }
          elsif ($@) {
              die $@;
          }
  
          return;
      }
  
      # Otherwise, cache handler...
      $attrs->{VOID} = $block;
      return $crv;
  }
  
  for my $context (qw( SCALAR NONVOID )) {
      no strict qw( refs );
      *{$context} = sub (;&$) {
          my ($block, $crv) = @_;
  
          # Handle simple context tests...
          if (!@_) {
              my $callers_context = (CORE::caller 1)[5];
              return defined $callers_context
                  && ($context eq 'NONVOID' || !$callers_context);
          }
  
          # Ensure we have an object...
          my $attrs;
          if (!refaddr $crv) {
              my $args = do{ package DB; ()=CORE::caller(1); my $args = \@DB::args; ()=CORE::caller(1); $args };
              my $subname = (CORE::caller(1))[3];
              if (!defined $subname) {
                  $subname = "bare $context {...}";
              }
              $crv = bless \my $scalar, 'Contextual::Return::Value';
              $attrs = $attrs_of{refaddr $crv}
                      = { args => $args, sub => $subname };
          }
          else {
              $attrs = $attrs_of{refaddr $crv};
          }
          local $Contextual::Return::__RETOBJ__ = $crv;
  
          # Make sure this block is a possibility too...
          die _in_context "Can't install two $context handlers"
              if exists $attrs->{$context};
          $attrs->{$context} = $block;
  
          # Identify contexts...
          my $wantarray = wantarray;
          use Want ();
          $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
          # Prepare for exception handling...
          my $recover = $attrs->{RECOVER};
          local $Contextual::Return::uplevel = 2;
          no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
          # Handle list context directly, if possible...
          if ($wantarray) {
              local $Contextual::Return::__RESULT__;
  
              # List or ancestral handlers...
              handler:
              for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  my @rv = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [@rv];
                      }
                      () = $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  return @rv if !$Contextual::Return::__RESULT__;
                  return @{$Contextual::Return::__RESULT__};
              }
              # Convert to list from arrayref handler...
              if (!$attrs->{STRICT} and my $handler = $attrs->{ARRAYREF}) {
  
                  my $array_ref = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$array_ref];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  # Array ref may be returned directly, or via RESULT{}...
                  $array_ref = $Contextual::Return::__RESULT__->[0]
                      if $Contextual::Return::__RESULT__;
  
                  return @{$array_ref} if (ref $array_ref||q{}) eq 'ARRAY';
              }
              # Return scalar object as one-elem list, if possible...
              handler:
              for my $context (qw(BOOL STR NUM VALUE SCALAR LAZY)) {
                  last if $attrs->{STRICT};
                  return $crv if exists $attrs->{$context};
              }
              die _in_context "Can't call $attrs->{sub} in a list context";
          }
  
          # Handle void context directly...
          if (!defined $wantarray) {
              handler:
              for my $context (qw< VOID DEFAULT >) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  last handler;
              }
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Can't call $attrs->{sub} in a void context";
                  if ($recover) {
                      () = $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
              return;
          }
  
          # Otherwise, defer evaluation by returning an object...
          return $crv;
      }
  }
  
  handler:
  for my $context_name (@CONTEXTS, qw< RECOVER _internal_LIST CLEANUP >) {
      next handler if $context_name eq 'LIST'       # These
                   || $context_name eq 'VOID'       #  four
                   || $context_name eq 'SCALAR'     #   handled
                   || $context_name eq 'NONVOID';   #    separately
  
      no strict qw( refs );
      *{$context_name} = sub (&;$) {
          my ($block, $crv) = @_;
  
          # Ensure we have an object...
          my $attrs;
          if (!refaddr $crv) {
              my $args = do{ package DB; ()=CORE::caller(1); my $args = \@DB::args; ()=CORE::caller(1); $args };
              my $subname = (CORE::caller(1))[3];
              if (!defined $subname) {
                  $subname = "bare $context_name {...}";
              }
              $crv = bless \my $scalar, 'Contextual::Return::Value';
              $attrs = $attrs_of{refaddr $crv}
                       = { args => $args, sub => $subname };
          }
          else {
              $attrs = $attrs_of{refaddr $crv};
          }
          local $Contextual::Return::__RETOBJ__ = $crv;
  
          # Make sure this block is a possibility too...
          if ($context_name ne '_internal_LIST') {
              die _in_context "Can't install two $context_name handlers"
                  if exists $attrs->{$context_name};
              $attrs->{$context_name} = $block;
          }
  
          # Identify contexts...
          my $wantarray = wantarray;
          use Want ();
          $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
          # Prepare for exception handling...
          my $recover = $attrs->{RECOVER};
          local $Contextual::Return::uplevel = 2;
          no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
          # Handle list context directly, if possible...
          if ($wantarray) {
              local $Contextual::Return::__RESULT__
                  = $context_name eq 'RECOVER' ? $Contextual::Return::__RESULT__
                  :                              undef
                  ;
  
              # List or ancestral handlers...
              handler:
              for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  my @rv = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [@rv];
                      }
                      () = $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  return @rv if !$Contextual::Return::__RESULT__;
                  return @{$Contextual::Return::__RESULT__};
              }
              # Convert to list from arrayref handler...
              if (!$attrs->{STRICT} and my $handler = $attrs->{ARRAYREF}) {
                  local $Contextual::Return::uplevel = 2;
  
                  # Array ref may be returned directly, or via RESULT{}...
                  my $array_ref = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$array_ref];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  $array_ref = $Contextual::Return::__RESULT__->[0]
                      if $Contextual::Return::__RESULT__;
  
                  return @{$array_ref} if (ref $array_ref||q{}) eq 'ARRAY';
              }
              # Return scalar object as one-elem list, if possible...
              handler:
              for my $context (qw(BOOL STR NUM VALUE SCALAR LAZY)) {
                  last if $attrs->{STRICT};
                  return $crv if exists $attrs->{$context};
              }
              $@ = _in_context "Can't call $attrs->{sub} in a list context";
              if ($recover) {
                  () = $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          }
  
          # Handle void context directly...
          if (!defined $wantarray) {
              handler:
              for my $context (qw(VOID DEFAULT)) {
                  if (!$attrs->{$context}) {
                      last handler if $attrs->{STRICT};
                      next handler;
                  }
  
                  eval { $attrs->{$context}->(@{$attrs->{args}}) };
  
                  if ($recover) {
                      $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  last handler;
              }
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Can't call $attrs->{sub} in a void context";
                  if ($recover) {
                      () = $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
              return;
          }
  
          # Otherwise, defer evaluation by returning an object...
          return $crv;
      }
  }
  
  # Alias LAZY to SCALAR...
  *LAZY = *SCALAR;
  
  
  # Set $Data::Dumper::Freezer to 'Contextual::Return::FREEZE' to be able to
  # dump contextual return values...
  
  my %operator_impl;
  
  my $no_handler_message = qr{
      ^ Can't [ ] call [ ] .*? [ ] in [ ] [\w]+ [ ] context
    | ^ [\w:]+ [ ] can't [ ] return [ ] a [ ] \w+ [ ] reference
  }xms;
  
  sub _flag_self_ref_in {
      my ($data_ref, $obj_ref) = @_;
      my $type = ref $data_ref;
      return if !$type;
      for my $ref ( $type eq 'SCALAR' ? ${$data_ref} : $type eq 'ARRAY' ? @{$data_ref} : ()) {
          no warnings 'numeric', 'uninitialized';
          if (refaddr($ref) == refaddr($obj_ref)) {
              $ref = '<<<self-reference>>>';
          }
      }
  }
  
  sub FREEZE {
      my ($self) = @_;
      my $attrs_ref = $attrs_of{refaddr $self};
      my $args_ref  = $attrs_ref->{args};
  
      my @no_handler;
  
      # Call appropriate operator handler, defusing and recording exceptions...
      my $overloaded = sub {
          my ($context, $op) = @_;
  
          # Try the operator...
          my $retval = eval { $operator_impl{$op}->($self,@{$args_ref}) };
  
          # Detect and report internal exceptions...
          if (my $exception = $@) {
              if ($exception =~ $no_handler_message) {
                  push @no_handler, $context;
                  return ();
              }
              chomp $exception;
              return { $context => "<<<Throws exception: $exception>>>" };
          }
  
          # Detect self-referential overloadings (to avoid infinite recursion)...
          {
              no warnings 'numeric', 'uninitialized';
              if (ref $retval eq 'REF' && eval{ ${$retval} == ${$self} }) {
                  return { $context => "<<<self-reference>>>" };
              }
          }
  
          # Normal return of contextual value labelled by context...
          return { $context => $retval };
      };
  
      my @values;
  
      # Where did this value originate?
      push @values, { ISA  => 'Contextual::Return::Value' };
      push @values, { FROM => $attrs_ref->{sub} };
  
      # Does it return a value in void context?
      if (exists $attrs_ref->{VOID} || exists $attrs_ref->{DEFAULT}) {
          push @values, { VOID => undef };
      }
      else {
          push @no_handler, 'VOID';
      }
  
      # Generate list context value by "pretend" LIST handler...
      push @values, { LIST => eval{ [ _internal_LIST(sub{}, $self) ] } // do{ chomp $@; "<<<Throws exception: $@>>>"} };
          _flag_self_ref_in($values[-1]{LIST}, $self);
  
      # Generate scalar context values by calling appropriate handler...
      push @values, $overloaded->( STR       => q{""}  );
      push @values, $overloaded->( NUM       => '0+'   );
      push @values, $overloaded->( BOOL      => 'bool' );
      push @values, $overloaded->( SCALARREF => '${}'  );
          _flag_self_ref_in($values[-1]{SCALARREF}, $self);
      push @values, $overloaded->( ARRAYREF  => '@{}'  );
          _flag_self_ref_in($values[-1]{ARRAYREF}, $self);
      push @values, $overloaded->( CODEREF   => '&{}'  );
      push @values, $overloaded->( HASHREF   => '%{}'  );
      push @values, $overloaded->( GLOBREF   => '*{}'  );
  
      # Are there handlers for various "generic" super-contexts...
      my @fallbacks = grep { $attrs_ref->{$_} }
                         qw< DEFAULT NONVOID SCALAR VALUE REF RECOVER >;
  
      push @values, { NO_HANDLER => \@no_handler };
      push @values, { FALLBACKS  => \@fallbacks  };
  
      # Temporarily replace object being dumped, by values found...
      $_[0] = \@values;
  }
  
  # Call this method on a contextual return value object to debug it...
  
  sub DUMP {
      if (eval{ require Data::Dumper; 1; }) {
          my ($crv) = @_;
          if (eval{ ref($crv)->isa('Contextual::Return::Value')}) {
              Contextual::Return::FREEZE($crv);
          }
          local $Data::Dumper::Terse = 1;
          local $Data::Dumper::Indent = 1;
          my $dump = Data::Dumper::Dumper($crv);
          $dump =~ s<,\n  \{><,ZZZZ{>msg;
          $dump =~ s<\n\s+>< >msg;
          $dump =~ s<,ZZZZ\{><\n  {>msg;
          return $dump;
      }
      else {
          Carp::carp("Can't DUMP contextual return value (no Data::Dumper!)");
          return;
      }
  }
  
  
  package Contextual::Return::Value;
  BEGIN { *_in_context = *Contextual::Return::_in_context; }
  use Scalar::Util qw( refaddr );
  
  BEGIN {
      %operator_impl = (
          q{""} => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(STR SCALAR LAZY VALUE NONVOID DEFAULT NUM)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Can't use return value of $attrs->{sub} as a string";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
  
          q{0+} => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(NUM SCALAR LAZY VALUE NONVOID DEFAULT STR)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Can't use return value of $attrs->{sub} as a number";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
  
          q{bool} => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
  
              # Handle Calls in Pure Boolean context...
              my @PUREBOOL = $attrs->{want_pure_bool} ? ('PUREBOOL') : ();
              $attrs->{want_pure_bool} = 0;
  
              handler:
              for my $context (@PUREBOOL, qw(BOOL STR NUM SCALAR LAZY VALUE NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $context eq 'BOOL' and $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $outer_sig_warn = $SIG{__WARN__};
                  local $SIG{__WARN__}
                      = sub{ return if $_[0] =~ /^Exiting \S+ via next/;
                             goto &{$outer_sig_warn} if $outer_sig_warn;
                             warn @_;
                        };
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Can't use return value of $attrs->{sub} as a boolean";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
          '${}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(SCALARREF REF NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the scalar dereference"
                          if ref($rv) ne 'SCALAR' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
  
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Call to $attrs->{sub} didn't return a scalar reference, as required <LOC>";
                  if (my $recover = $attrs->{RECOVER}) {
                      scalar $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
  
              if ( $attrs->{FIXED} ) {
                  $_[0] = \$self;
              }
              return \$self;
          },
          '@{}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              local $Contextual::Return::__RESULT__;
              handler:
              for my $context (qw(ARRAYREF REF)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the array dereference"
                          if ref($rv) ne 'ARRAY' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              handler:
              for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
                  last handler if $attrs->{STRICT};
                  my $handler = $attrs->{$context}
                      or next handler;
  
                  local $Contextual::Return::uplevel = 2;
                  my @rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [@rv];
                      }
                      () = $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      @rv = @{$Contextual::Return::__RESULT__->[0]};
                  }
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = \@rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { @rv };
                  }
                  return \@rv;
              }
  
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Call to $attrs->{sub} didn't return an array reference, as required <LOC>";
                  if (my $recover = $attrs->{RECOVER}) {
                      scalar $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
  
              return [ $self ];
          },
          '%{}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(HASHREF REF NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the hash dereference"
                          if ref($rv) ne 'HASH' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Call to $attrs->{sub} didn't return a hash reference, as required <LOC>";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
          '&{}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(CODEREF REF NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the subroutine dereference"
                          if ref($rv) ne 'CODE' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Call to $attrs->{sub} didn't return a subroutine reference, as required <LOC>";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
          '*{}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(GLOBREF REF NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the typeglob dereference"
                          if ref($rv) ne 'GLOB' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Call to $attrs->{sub} didn't return a typeglob reference, as required <LOC>";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
      );
  }
  
  use overload %operator_impl, fallback => 1;
  
  sub DESTROY {
      my ($id) = refaddr shift;
      my $attrs = $attrs_of{$id};
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
      if (my $handler = $attrs->{CLEANUP}) {
          $handler->(@{ $attrs->{args} });
      }
      delete $attrs_of{$id};
      return;
  }
  
  my $NO_SUCH_METHOD = qr/\ACan't (?:locate|call)(?: class| object)? method/ms;
  
  # Forward metainformation requests to actual class...
  sub can {
      my ($invocant) = @_;
      # Only forward requests on actual C::R::V objects...
      if (ref $invocant) {
          our $AUTOLOAD = 'can';
          goto &AUTOLOAD;
      }
  
      # Refer requests on classes to actual class hierarchy...
      return $invocant->SUPER::can(@_[1..$#_]);
  }
  
  sub isa {
      # Only forward requests on actual C::R::V objects...
      my ($invocant) = @_;
      if (ref $invocant) {
          our $AUTOLOAD = 'isa';
          goto &AUTOLOAD;
      }
  
      # Refer requests on classes to actual class hierarchy...
      return $invocant->SUPER::isa(@_[1..$#_]);
  }
  
  
  sub AUTOLOAD {
      my ($self) = @_;
      our $AUTOLOAD;
  
      my ($requested_method) = $AUTOLOAD =~ m{ .* :: (.*) }xms ? $1 : $AUTOLOAD;
  
      my $attrs = $attrs_of{refaddr $self} || {};
      local $Contextual::Return::__RETOBJ__ = $self;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
      # First, see if there is a method call handler...
      if (my $context_handler = $attrs->{METHOD}) {
          local $Contextual::Return::__RESULT__;
          local $Contextual::Return::uplevel = 2;
          my @method_handlers = eval { $context_handler->(@{$attrs->{args}}) };
  
          if (my $recover = $attrs->{RECOVER}) {
              if (!$Contextual::Return::__RESULT__) {
                  $Contextual::Return::__RESULT__ = [\@method_handlers];
              }
              scalar $recover->(@{$attrs->{args}});
          }
          elsif ($@) {
              die $@;
          }
  
          if ($Contextual::Return::__RESULT__) {
              @method_handlers = @{$Contextual::Return::__RESULT__};
          }
  
          # Locate the correct method handler (if any)...
          MATCHER:
          while (my ($matcher, $method_handler) = splice @method_handlers, 0, 2) {
  
              if (ref($matcher) eq 'ARRAY') {
                  next MATCHER
                      if !grep { $requested_method =~ $_ } @{$matcher};
              }
              elsif ($requested_method !~ $matcher) {
                  next MATCHER;
              }
  
              shift;
              if (wantarray) {
                  my @result = eval {
                      local $_ = $requested_method;
                      $method_handler->($self,@_);
                  };
                  die _in_context $@ if $@;
                  return @result;
              }
              else {
                  my $result = eval {
                      local $_ = $requested_method;
                      $method_handler->($self,@_);
                  };
                  die _in_context $@ if $@;
                  return $result;
              }
          }
      }
  
      # Next, try to create an object on which to call the method...
      handler:
      for my $context (qw(OBJREF STR SCALAR LAZY VALUE NONVOID DEFAULT)) {
          my $handler = $attrs->{$context}
              or $attrs->{STRICT} and last handler
              or next handler;
  
          local $Contextual::Return::__RESULT__;
          local $Contextual::Return::uplevel = 2;
          my $object = eval { $handler->(@{$attrs->{args}}) };
  
          if (my $recover = $attrs->{RECOVER}) {
              if (!$Contextual::Return::__RESULT__) {
                  $Contextual::Return::__RESULT__ = [$object];
              }
              scalar $recover->(@{$attrs->{args}});
          }
          elsif ($@) {
              die $@;
          }
  
          if ($Contextual::Return::__RESULT__) {
              $object = $Contextual::Return::__RESULT__->[0];
          }
  
          if ( $attrs->{FIXED} ) {
              $_[0] = $object;
          }
          elsif ( !$attrs->{ACTIVE} ) {
              $attrs->{$context} = sub { $object };
          }
          shift;
  
          if (wantarray) {
              my @result = eval { $object->$requested_method(@_) };
              my $exception = $@;
              return @result if !$exception;
              die _in_context $exception if $exception !~ $NO_SUCH_METHOD;
          }
          else {
              my $result = eval { $object->$requested_method(@_) };
              my $exception = $@;
              return $result if !$exception;
              die _in_context $exception if $exception !~ $NO_SUCH_METHOD;
          }
          $@ = _in_context "Can't call method '$requested_method' on $context value returned by $attrs->{sub}";
          if (my $recover = $attrs->{RECOVER}) {
              scalar $recover->(@{$attrs->{args}});
          }
          else {
              die $@;
          }
      }
  
      # Otherwise, the method cannot be called, so react accordingly...
      $@ = _in_context "Can't call method '$requested_method' on value returned by $attrs->{sub}";
      if (my $recover = $attrs->{RECOVER}) {
          return scalar $recover->(@{$attrs->{args}});
      }
      else {
          die $@;
      }
  }
  
  package Contextual::Return::Lvalue;
  
  sub TIESCALAR {
      my ($package, @handler) = @_;
      return bless {@handler}, $package;
  }
  
  # Handle calls that are lvalues...
  sub STORE {
      local *CALLER::_ = \$_;
      local *_         = \$_[1];
      local $Contextual::Return::uplevel = 1;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
      local $Contextual::Return::__RESULT__;
  
      my $rv = $_[0]{LVALUE}( @{$_[0]{args}} );
  
      return $rv if !$Contextual::Return::__RESULT__;
      return $Contextual::Return::__RESULT__->[0];
  }
  
  # Handle calls that are rvalues...
  sub FETCH {
      local $Contextual::Return::uplevel = 1;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
      local $Contextual::Return::__RESULT__;
  
      my $rv = $_[0]{RVALUE} ? $_[0]{RVALUE}( @{$_[0]{args}} ) : undef;
  
      return $rv if !$Contextual::Return::__RESULT__;
      return $Contextual::Return::__RESULT__->[0];
  }
  
  sub DESTROY {};
  
  1; # Magic true value required at end of module
  
  __END__
  
  =head1 NAME
  
  Contextual::Return - Create context-sensitive return values
  
  
  =head1 VERSION
  
  This document describes Contextual::Return version 0.004014
  
  
  =head1 SYNOPSIS
  
      use Contextual::Return;
      use Carp;
  
      sub foo {
          return
              SCALAR { 'thirty-twelve' }
              LIST   { 1,2,3 }
  
              BOOL { 1 }
              NUM  { 7*6 }
              STR  { 'forty-two' }
  
              HASHREF  { {name => 'foo', value => 99} }
              ARRAYREF { [3,2,1] }
  
              GLOBREF  { \*STDOUT }
              CODEREF  { croak "Don't use this result as code!"; }
          ;
      }
  
      # and later...
  
      if (my $foo = foo()) {
          for my $count (1..$foo) {
              print "$count: $foo is:\n"
                  . "  array: @{$foo}\n"
                  . "  hash:  $foo->{name} => $foo->{value}\n"
                  ;
          }
          print {$foo} $foo->();
      }
  
  =head1 DESCRIPTION
  
  Usually, when you need to create a subroutine that returns different values in
  different contexts (list, scalar, or void), you write something like:
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data,
          # depending on call context...
          if (wantarray()) {
              return @server_data{ qw(name uptime load users) };
          }
          if (defined wantarray()) {
              return $server_data{load};
          }
          if (!defined wantarray()) {
              carp 'Useless use of get_server_status() in void context';
              return;
          }
          else {
              croak q{Bad context! No biscuit!};
          }
      }
  
  That works okay, but the code could certainly be more readable. In
  its simplest usage, this module makes that code more readable by
  providing three subroutines--C<LIST()>, C<SCALAR()>, C<VOID()>--that
  are true only when the current subroutine is called in the
  corresponding context:
  
      use Contextual::Return;
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data
          # depending on call context...
          if (LIST)   { return @server_data{ qw(name uptime load users) } }
          if (SCALAR) { return $server_data{load}                         }
          if (VOID)   { print "$server_data{load}\n"                      }
          else        { croak q{Bad context! No biscuit!}                 }
      }
  
  =head2 Contextual returns
  
  Those three subroutines can also be used in another way: as labels on a
  series of I<contextual return blocks> (collectively known as a I<contextual
  return sequence>). When a context sequence is returned, it automatically
  selects the appropriate contextual return block for the calling context.
  So the previous example could be written even more cleanly as:
  
      use Contextual::Return;
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data
          # depending on call context...
          return (
              LIST    { return @server_data{ qw(name uptime load users) } }
              SCALAR  { return $server_data{load}                         }
              VOID    { print "$server_data{load}\n"                      }
              DEFAULT { croak q{Bad context! No biscuit!}                 }
          );
      }
  
  The context sequence automatically selects the appropriate block for each call
  context.
  
  
  =head2 Lazy contextual return values
  
  C<LIST> and C<VOID> blocks are always executed during the C<return>
  statement. However, scalar return blocks (C<SCALAR>, C<STR>, C<NUM>,
  C<BOOL>, etc.) blocks are not. Instead, returning any of scalar block
  types causes the subroutine to return an object that lazily
  evaluates that block only when the return value is used.
  
  This means that returning a C<SCALAR> block is a convenient way to
  implement a subroutine with a lazy return value. For example:
  
      sub digest {
          return SCALAR {
              my ($text) = @_;
              md5($text);
          }
      }
  
      my $digest = digest($text);
  
      print $digest;   # md5() called only when $digest used as string
  
  To better document this usage, the C<SCALAR> block has a synonym: C<LAZY>.
  
      sub digest {
          return LAZY {
              my ($text) = @_;
              md5($text);
          }
      }
  
  
  =head2 Active contextual return values
  
  Once a return value has been lazily evaluated in a given context,
  the resulting value is cached, and thereafter reused in that same context.
  
  However, you can specify that, rather than being cached, the value
  should be re-evaluated I<every> time the value is used:
  
       sub make_counter {
          my $counter = 0;
          return ACTIVE
              SCALAR   { ++$counter }
              ARRAYREF { [1..$counter] }
      }
  
      my $idx = make_counter();
  
      print "$idx\n";      # 1
      print "$idx\n";      # 2
      print "[@$idx]\n";   # [1 2]
      print "$idx\n";      # 3
      print "[@$idx]\n";   # [1 2 3]
  
  
  =head2 Semi-lazy contextual return values
  
  Sometimes, single or repeated lazy evaluation of a scalar return value
  in different contexts isn't what you really want. Sometimes what you
  really want is for the return value to be lazily evaluated once only (the
  first time it's used in any context), and then for that first value to
  be reused whenever the return value is subsequently reevaluated in any
  other context.
  
  To get that behaviour, you can use the C<FIXED> modifier, which causes
  the return value to morph itself into the actual value the first time it
  is used. For example:
  
      sub lazy {
          return
              SCALAR { 42 }
              ARRAYREF { [ 1, 2, 3 ] }
          ;
      }
  
      my $lazy = lazy();
      print $lazy + 1;            # 43
      print "@{$lazy}";           # 1 2 3
  
  
      sub semilazy {
          return FIXED
              SCALAR { 42 }
              ARRAYREF { [ 1, 2, 3 ] }
          ;
      }
  
      my $semi = semilazy();
      print $semi + 1;            # 43
      print "@{$semi}";           # die q{Can't use string ("42") as an ARRAY ref}
  
  
  
  =head2 Finer distinctions of scalar context
  
  Because the scalar values returned from a context sequence are lazily
  evaluated, it becomes possible to be more specific about I<what kind> of
  scalar value should be returned: a boolean, a number, or a string. To support
  those distinctions, Contextual::Return provides four extra context blocks:
  C<NUM>, C<STR>, C<BOOL>, and C<PUREBOOL>:
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data
          # depending on call context...
          return (
                 LIST { @server_data{ qw(name uptime load users) }          }
             PUREBOOL { $_ = $server_data{uptime}; $server_data{uptime} > 0 }
                 BOOL { $server_data{uptime} > 0                            }
                 NUM  { $server_data{load}                                  }
                 STR  { "$server_data{name}: $server_data{uptime}"          }
                 VOID { print "$server_data{load}\n"                        }
              DEFAULT { croak q{Bad context! No biscuit!}                   }
          );
      }
  
  With these in place, the object returned from a scalar-context call to
  C<get_server_status()> now behaves differently, depending on how
  it's used. For example:
  
      if ( my $status = get_server_status() ) {  # BOOL: True if uptime > 0
          $load_distribution[$status]++;         # INT:  Evaluates to load value
          print "$status\n";                     # STR:  Prints "name: uptime"
      }
  
      if (get_server_status()) {                 # PUREBOOL: also sets $_;
          print;                                 # ...which is then used here
      }
  
  =head3 Boolean vs Pure Boolean contexts
  
  There is a special subset of boolean contexts where the return value is being
  used and immediately thrown away. For example, in the loop:
  
      while (get_data()) {
          ...
      }
  
  the value returned by C<get_data()> is tested for truth and then discarded.
  This is known as "pure boolean context". In contrast, in the loop:
  
      while (my $data = get_data()) {
          ...
      }
  
  the value returned by C<get_data()> is first assigned to C<$data>, then
  tested for truth. Because of the assignment, the return value is I<not>
  discarded after the boolean test. This is ordinary "boolean context".
  
  In Perl, pure boolean context is often associated with a special side-effect,
  that does not occur in regular boolean contexts. For example:
  
      while (<>) {...}         # $_ set as side-effect of pure boolean context
  
      while ($v = <>) {...}    # $_ NOT set in ordinary boolean context
  
  Contextual::Return supports this with a special subcase of C<BOOL> named
  <PUREBOOL>. In pure boolean contexts, Contextual::Return will call a
  C<PUREBOOL> handler if one has been defined, or fall back to a C<BOOL>
  or C<SCALAR> handler if no C<PUREBOOL> handler exists. In ordinary
  boolean contexts only the C<BOOL> or C<SCALAR> handlers are tried, even
  if a C<PUREBOOL> handler is also defined.
  
  Typically C<PUREBOOL> handlers are set up to have some side-effect (most
  commonly: setting C<$_> or <$@>), like so:
  
      sub get_data {
          my ($succeeded, @data) = _go_and_get_data();
  
          return
              PUREBOOL { $_ = $data[0]; $succeeded; }
                  BOOL {                $succeeded; }
                SCALAR {                $data[0];   }
                  LIST {                @data;      }
      }
  
  However, there is no requirement that they have side-effects. For example,
  they can also be used to implement "look-but-don't-retrieve-yet" checking:
  
      sub get_data {
          my $data;
          return
              PUREBOOL {        _check_for_but_dont_get_data();   }
                  BOOL { defined( $data ||= _go_and_get_data() ); }
                   REF {          $data ||= _go_and_get_data();   }
      }
  
  
  =head2 Self-reference within handlers
  
  Any handler can refer to the contextual return object it is part of, by
  calling the C<RETOBJ()> function. This is particularly useful for C<PUREBOOL>
  and C<LIST> handlers. For example:
  
      return
          PUREBOOL { $_ = RETOBJ; next handler; }
              BOOL { !$failed;                  }
           DEFAULT { $data;                     };
  
  
  =head2 Referential contexts
  
  The other major kind of scalar return value is a reference.
  Contextual::Return provides contextual return blocks that allow you to
  specify what to (lazily) return when the return value of a subroutine is
  used as a reference to a scalar (C<SCALARREF {...}>), to an array
  (C<ARRAYREF {...}>), to a hash (C<HASHREF {...}>), to a subroutine
  (C<CODEREF {...}>), or to a typeglob (C<GLOBREF {...}>).
  
  For example, the server status subroutine shown earlier could be extended to
  allow it to return a hash reference, thereby supporting "named return values":
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data
          # depending on call context...
          return (
                 LIST { @server_data{ qw(name uptime load users) }  }
                 BOOL { $server_data{uptime} > 0                    }
                  NUM { $server_data{load}                          }
                  STR { "$server_data{name}: $server_data{uptime}"  }
                 VOID { print "$server_data{load}\n"                }
              HASHREF { return \%server_data                        }
              DEFAULT { croak q{Bad context! No biscuit!}           }
          );
      }
  
      # and later...
  
      my $users = get_server_status->{users};
  
  
      # or, lazily...
  
      my $server = get_server_status();
  
      print "$server->{name} load = $server->{load}\n";
  
  
  =head2 Interpolative referential contexts
  
  The C<SCALARREF {...}> and C<ARRAYREF {...}> context blocks are
  especially useful when you need to interpolate a subroutine into
  strings. For example, if you have a subroutine like:
  
      sub get_todo_tasks {
          return (
              SCALAR { scalar @todo_list }      # How many?
              LIST   { @todo_list        }      # What are they?
          );
      }
  
      # and later...
  
      print "There are ", scalar(get_todo_tasks()), " tasks:\n",
              get_todo_tasks();
  
  then you could make it much easier to interpolate calls to that
  subroutine by adding:
  
      sub get_todo_tasks {
          return (
              SCALAR { scalar @todo_list }      # How many?
              LIST   { @todo_list        }      # What are they?
  
              SCALARREF { \scalar @todo_list }  # Ref to how many
              ARRAYREF  { \@todo_list        }  # Ref to them
          );
      }
  
      # and then...
  
      print "There are ${get_todo_tasks()} tasks:\n@{get_todo_tasks()}";
  
  In fact, this behaviour is so useful that it's the default. If you
  don't provide an explicit C<SCALARREF {...}> block,
  Contextual::Return automatically provides an implicit one that simply
  returns a reference to whatever would have been returned in scalar context.
  Likewise, if no C<ARRAYREF {...}> block is specified, the module supplies one
  that returns the list-context return value wrapped up in an array reference.
  
  So you could just write:
  
      sub get_todo_tasks {
          return (
              SCALAR { scalar @todo_list }      # How many?
              LIST   { @todo_list        }      # What are they?
          );
      }
  
      # and still do this...
  
      print "There are ${get_todo_tasks()} tasks:\n@{get_todo_tasks()}";
  
  
  =head2 Fallback contexts
  
  As the previous sections imply, the C<BOOL {...}>, C<NUM {...}>, C<STR
  {...}>, and various C<*REF {...}> blocks, are special cases of the
  general C<SCALAR {...}> context block. If a subroutine is called in one
  of these specialized contexts but does not use the corresponding context
  block, then the more general C<SCALAR {...}> block is used instead (if
  it has been specified).
  
  So, for example:
  
      sub read_value_from {
          my ($fh) = @_;
  
          my $value = <$fh>;
          chomp $value;
  
          return (
              BOOL   { defined $value }
              SCALAR { $value         }
          );
      }
  
  ensures that the C<read_value_from()> subroutine returns true in boolean
  contexts if the read was successful. But, because no specific C<NUM {...}>
  or C<STR {...}> return behaviours were specified, the subroutine falls back on
  using its generic C<SCALAR {...}> block in all other scalar contexts.
  
  Another way to think about this behaviour is that the various kinds of
  scalar context blocks form a hierarchy:
  
      SCALAR
           ^
           |
           |--< BOOL
           |
           |--< NUM
           |
           `--< STR
  
  Contextual::Return uses this hierarchical relationship to choose the most
  specific context block available to handle any particular return context,
  working its way up the tree from the specific type it needs, to the more
  general type, if that's all that is available.
  
  There are two slight complications to this picture. The first is that Perl
  treats strings and numbers as interconvertable so the diagram (and the
  Contextual::Return module) also has to allow these interconversions as a
  fallback strategy:
  
      SCALAR
           ^
           |
           |--< BOOL
           |
           |--< NUM
           |    : ^
           |    v :
           `--< STR
  
  The dotted lines are meant to indicate that this intraconversion is secondary
  to the main hierarchical fallback. That is, in a numeric context, a C<STR
  {...}> block will only be used if there is no C<NUM {...}> block I<and> no
  C<SCALAR {...}> block. In other words, the generic context type is always
  used in preference to string<->number conversion.
  
  The second slight complication is that the above diagram only shows a
  small part of the complete hierarchy of contexts supported by
  Contextual::Return. The full fallback hierarchy (including dotted
  interconversions) is:
  
        DEFAULT
           ^
           |
           |--< VOID
           |
           `--< NONVOID
                   ^
                   |
                   |--< VALUE <...............
                   |      ^                   :
                   |      |                   :
                   |      |--< SCALAR <.......:...
                   |      |           ^           :
                   |      |           |           :
                   |      |           |--< BOOL   :
                   |      |           |     ^     :
                   |      |           |     |     :
                   |      |           |  PUREBOOL :
                   |      |           |           :
                   |      |           |--< NUM <..:.
                   |      |           |    : ^      :
                   |      |           |    v :      :
                   |      |           `--< STR <....:..
                   |      |                           :
                   |      |                          ::
                   |      `--< LIST ................: :
                   |            : ^                   :
                   |            : :                   :
                   `--- REF     : :                   :
                         ^      : :                   :
                         |      v :                   :
                         |--< ARRAYREF                :
                         |                            :
                         |--< SCALARREF .............:
                         |
                         |--< HASHREF
                         |
                         |--< CODEREF
                         |
                         |--< GLOBREF
                         |
                         `--< OBJREF <....... METHOD
                                 ^
                                 :........... BLESSED
  
  As before, each dashed arrow represents a fallback relationship. That
  is, if the required context specifier isn't available, the arrows are
  followed until a more generic one is found. The dotted arrows again
  represent the interconversion of return values, which is
  attempted only after the normal hierarchical fallback fails.
  
  For example, if a subroutine is called in a context that expects a
  scalar reference, but no C<SCALARREF {...}> block is provided, then
  Contextual::Return tries the following blocks in order:
  
          REF {...}
      NONVOID {...}
      DEFAULT {...}
          STR {...} (automatically taking a reference to the result)
          NUM {...} (automatically taking a reference to the result)
       SCALAR {...} (automatically taking a reference to the result)
        VALUE {...} (automatically taking a reference to the result)
  
  Likewise, in a list context, if there is no C<LIST {...}> context block, the
  module tries:
  
         VALUE {...}
       NONVOID {...}
       DEFAULT {...}
      ARRAYREF {...} (automatically dereferencing the result)
           STR {...} (treating it as a list of one element)
           NUM {...} (treating it as a list of one element)
        SCALAR {...} (treating it as a list of one element)
  
  The more generic context blocks are especially useful for intercepting
  unexpected and undesirable call contexts. For example, to turn I<off>
  the automatic scalar-ref and array-ref interpolative behaviour described
  in L<Interpolative referential contexts>, you could intercept I<all>
  referential contexts using a generic C<REF {...}> context block:
  
      sub get_todo_tasks {
          return (
              SCALAR { scalar @todo_list }      # How many?
              LIST   { @todo_list        }      # What are they?
  
              REF { croak q{get_todo_task() can't be used as a reference} }
          );
      }
  
      print 'There are ', get_todo_tasks(), '...';    # Still okay
      print "There are ${get_todo_tasks()}...";       # Throws an exception
  
  
  =head2 Treating return values as objects
  
  Normally, when a return value is treated as an object (i.e. has a method
  called on it), Contextual::Return invokes any C<OBJREF> handler that was
  specified in the contextual return list, and delegates the method call to
  the object returned by that handler.
  
  However, you can also be more specific, by specifying a C<METHOD> context
  handler in the contextual return list. The block of this handler is expected
  to return one or more method-name/method-handler pairs, like so:
  
      return
          METHOD {
              get_count => sub { my $n = shift; $data[$n]{count} },
              get_items => sub { my $n = shift; $data[$n]{items} },
              clear     => sub { @data = (); },
              reset     => sub { @data = (); },
          }
  
  Then, whenever one of the specified methods is called on the return value,
  the corresponding subroutine will be called to implement it.
  
  The method handlers must always be subroutine references, but the method-name
  specifiers may be strings (as in the previous example) or they may be
  specified generically, as either regexes or array references. Generic method
  names are used to call the same handler for two or more distinct method names.
  For example, the previous example could be simplified to:
  
      return
          METHOD {
              qr/get_(\w+)/     => sub { my $n = shift; $data[$n]{$1} },
              ['clear','reset'] => sub { @data = (); },
          }
  
  A method name specified by regex will invoke the corresponding handler for any
  method call request that the regex matches. A method name specified by array
  ref will invoke the corresponding handler if the method requested matches any
  of the elements of the array (which may themselves be strings or regexes).
  
  When the method handler is invoked, the name of the method requested is
  passed to the handler in C<$_>, and the method's argument list is passed
  (as usual) via C<@_>.
  
  Note that any methods not explicitly handled by the C<METHOD> handlers
  will still be delegated to the object returned by the C<OBJREF> handler
  (if it is also specified).
  
  
  =head2 Not treating return values as objects
  
  The use of C<OBJREF> and C<METHOD> are slightly complicated by the fact
  that contextual return values are themselves objects.
  
  For example, prior to version 0.4.4 of the module, if you passed a
  contextual return value to C<Scalar::Util::blessed()>, it always
  returned a true value (namely, the string: 'Contextual::Return::Value'),
  even if the return value had not specified handlers for C<OBJREF> or
  C<METHOD>.
  
  In other words, the I<implementation> of contextual return values (as
  objects) was getting in the way of the I<use> of contextual return
  values (as non-objects).
  
  So the module now also provides a C<BLESSED> handler, which allows you
  to explicitly control how contextual return values interact with
  C<Scalar::Util::blessed()>.
  
  If C<$crv> is a contextual return value, by default
  C<Scalar::Util::blessed($crv)> will now only return true if that return
  value has a C<OBJREF>, C<LAZY>, C<REF>, C<SCALAR>, C<VALUE>, C<NONVOID>,
  or C<DEFAULT> handler that in turn returns a blessed object.
  
  However if C<$crv> also provides a C<BLESSED> handler, C<blessed()>
  will return whatever that handler returns.
  
  This means:
  
      sub simulate_non_object {
          return BOOL { 1 }
                  NUM { 42 }
      }
  
      sub simulate_real_object {
          return OBJREF { bless {}, 'My::Class' }
                   BOOL { 1 }
                    NUM { 42 }
      }
  
      sub simulate_faked_object {
          return BLESSED { 'Foo' }
                    BOOL { 1 }
                     NUM { 42 }
      }
  
      sub simulate_previous_behaviour {
          return BLESSED { 'Contextual::Return::Value' }
                    BOOL { 1 }
                     NUM { 42 }
      }
  
  
      say blessed( simulate_non_object()         );   # undef
      say blessed( simulate_real_object()        );   # My::Class
      say blessed( simulate_faked_object()       );   # Foo
      say blessed( simulate_previous_behaviour() );   # Contextual::Return::Value
  
  Typically, you either want no C<BLESSED> handler (in which case
  contextual return values pretend not to be blessed objects), or you want
  C<BLESSED { 'Contextual::Return::Value' }> for backwards compatibility
  with pre-v0.4.7 behaviour.
  
  
  =head3 Preventing fallbacks
  
  Sometimes fallbacks can be too helpful. Or sometimes you want to impose
  strict type checking on a return value.
  
  Contextual::Returns allows that via the C<STRICT> specifier. If you include
  C<STRICT> anywhere in your return statement, the module disables all
  fallbacks and will therefore through an exception if the return value is
  used in any way not explicitly specified in the contextual return sequence.
  
  For example, to create a subroutine that returns only a string:
  
      sub get_name {
          return STRICT STR { 'Bruce' }
      }
  
  If the return value of the subroutine is used in any other way than as
  a string, an exception will be thrown.
  
  You can still specify handlers for more than a single kind of context
  when using C<STRICT>:
  
      sub get_name {
          return STRICT
              STR  { 'Bruce' }
              BOOL { 0 }
      }
  
  ...but these will still be the only contexts in which the return value
  can be used:
  
      my $n = get_name() ? 1 : 2;  # Okay because BOOL handler specified
  
      my $n = 'Dr' . get_name();   # Okay because STR handler specified
  
      my $n = 1 + get_name();      # Exception thrown because no NUM handler
  
  In other words, C<STRICT> allows you to impose strict type checking on
  your contextual return value.
  
  
  =head2 Deferring handlers
  
  Because the various handlers form a hierarchy, it's possible to
  implement more specific handlers by falling back on ("deferring to")
  more general ones. For example, L<a C<PUREBOOL> handler|"Boolean vs Pure
  Boolean contexts"> is almost always identical in its basic behaviour to
  the corresponding C<BOOL> handler, except that it adds some side-effect.
  For example:
  
      return
          PUREBOOL { $_ = $return_val; defined $return_val && $return_val > 0 }
              BOOL {                   defined $return_val && $return_val > 0 }
            SCALAR {                   $return_val;                           }
  
  So Contextual::Return allows you to have a handler perform some action
  and then defer to a more general handler to supply the actual return
  value. To fall back to a more general case in this way, you simply write:
  
      next handler;
  
  at the end of the handler in question, after which Contextual::Return
  will find the next-most-specific handler and execute it as well. So the
  previous example, could be re-written:
  
      return
          PUREBOOL { $_ = $return_val; next handler;        }
              BOOL { defined $return_val && $return_val > 0 }
            SCALAR { $return_val;                           }
  
  Note that I<any> specific handler can defer to a more general one in
  this same way. For example, you could provide consistent and
  maintainable type-checking for a subroutine that returns references by
  providing C<ARRAYREF>, C<HASHREF>, and C<SCALARREF> handlers that all
  defer to a generic C<REF> handler, like so:
  
      my $retval = _get_ref();
  
      return
         SCALARREF { croak 'Type mismatch' if ref($retval) ne 'SCALAR';
                     next handler;
                   }
          ARRAYREF { croak 'Type mismatch' if ref($retval) ne 'ARRAY';
                     next handler;
                   }
           HASHREF { croak 'Type mismatch' if ref($retval) ne 'HASH';
                     next handler;
                   }
               REF { $retval }
  
  If, at a later time, the process of returning a reference became more complex,
  only the C<REF> handler would have to be updated.
  
  
  =head2 Nested handlers
  
  Another way of factoring out return behaviour is to nest more specific
  handlers inside more general ones. For instance, in the final example given in
  L<"Boolean vs Pure Boolean contexts">:
  
      sub get_data {
          my $data;
          return
              PUREBOOL {        _check_for_but_dont_get_data();   }
                  BOOL { defined( $data ||= _go_and_get_data() ); }
                   REF {          $data ||= _go_and_get_data();   }
      }
  
  you could factor out the repeated calls to C<_go_and_get_data()> like so:
  
      sub get_data {
          return
              PUREBOOL { _check_for_but_dont_get_data(); }
               DEFAULT {
                  my $data = _go_and_get_data();
  
                  BOOL { defined $data; }
                   REF {         $data; }
               }
      }
  
  Here, the C<DEFAULT> handler deals with every return context except pure
  boolean. Within that C<DEFAULT> handler, the data is first retrieved,
  and then two "sub-handlers" deal with the ordinary boolean and
  referential contexts.
  
  Typically nested handlers are used in precisely this way: to optimize
  for inexpensive special cases (such as pure boolean or integer or void
  return contexts) and only do extra work for those other cases that
  require it.
  
  
  =head2 Failure contexts
  
  Two of the most common ways to specify that a subroutine has failed
  are to return a false value, or to throw an exception. The
  Contextual::Return module provides a mechanism that allows the
  subroutine writer to support I<both> of these mechanisms at the
  same time, by using the C<FAIL> specifier.
  
  A return statement of the form:
  
      return FAIL;
  
  causes the surrounding subroutine to return C<undef> (i.e. false) in
  boolean contexts, and to throw an exception in any other context. For example:
  
      use Contextual::Return;
  
      sub get_next_val {
          my $next_val = <>;
          return FAIL if !defined $next_val;
          chomp $next_val;
          return $next_val;
      }
  
  If the C<return FAIL> statement is executed, it will either return false in a
  boolean context:
  
      if (my $val = get_next_val()) {      # returns undef if no next val
          print "[$val]\n";
      }
  
  or else throw an exception if the return value is used in any
  other context:
  
      print get_next_val();       # throws exception if no next val
  
      my $next_val = get_next_val();
      print "[$next_val]\n";      # throws exception if no next val
  
  
  The exception that is thrown is of the form:
  
      Call to main::get_next_val() failed at demo.pl line 42
  
  but you can change that message by providing a block to the C<FAIL>, like so:
  
      return FAIL { "No more data" } if !defined $next_val;
  
  in which case, the final value of the block becomes the exception message:
  
      No more data at demo.pl line 42
  
  A failure value can be interrogated for its error message, by calling its
  C<error()> method, like so:
  
      my $val = get_next_val();
      if ($val) {
          print "[$val]\n";
      }
      else {
          print $val->error, "\n";
      }
  
  
  =head2 Configurable failure contexts
  
  The default C<FAIL> behaviour--false in boolean context, fatal in all
  others--works well in most situations, but violates the Platinum Rule ("Do
  unto others as I<they> would have done unto them").
  
  So it may be user-friendlier if the user of a module is allowed decide how
  the module's subroutines should behave on failure. For example, one user
  might prefer that failing subs always return undef; another might prefer
  that they always throw an exception; a third might prefer that they
  always log the problem and return a special Failure object; whilst a
  fourth user might want to get back C<0> in scalar contexts, an empty list
  in list contexts, and an exception everywhere else.
  
  You could create a module that allows the user to specify all these
  alternatives, like so:
  
      package MyModule;
      use Contextual::Return;
      use Log::StdLog;
  
      sub import {
          my ($package, @args) = @_;
  
          Contextual::Return::FAIL_WITH {
              ':false' => sub { return undef },
              ':fatal' => sub { croak @_       },
              ':filed' => sub {
                              print STDLOG 'Sub ', (caller 1)[3], ' failed';
                              return Failure->new();
                          },
              ':fussy' => sub {
                              SCALAR  { undef      }
                              LIST    { ()         }
                              DEFAULT { croak @_ }
                          },
          }, @args;
      }
  
  This configures Contextual::Return so that, instead of the usual
  false-or-fatal semantics, every C<return FAIL> within MyModule's namespace is
  implemented by one of the four subroutines specified in the hash that was
  passed to C<FAIL_WITH>.
  
  Which of those four subs implements the C<FAIL> is determined by the
  arguments passed after the hash (i.e. by the contents of C<@args>).
  C<FAIL_WITH> walks through that list of arguments and compares
  them against the keys of the hash. If a key matches an argument, the
  corresponding value is used as the implementation of C<FAIL>. Note that,
  if subsequent arguments also match a key, their subroutine overrides the
  previously installed implementation, so only the final override has any
  effect. Contextual::Return generates warnings when multiple overrides are
  specified.
  
  All of which mean that, if a user loaded the MyModule module like this:
  
      use MyModule qw( :fatal other args here );
  
  then every C<FAIL> within MyModule would be reconfigured to throw an exception
  in all circumstances, since the presence of the C<':fatal'> in the argument
  list will cause C<FAIL_WITH> to select the hash entry whose key is C<':fatal'>.
  
  On the other hand, if they loaded the module:
  
      use MyModule qw( :fussy other args here );
  
  then each C<FAIL> within MyModule would return undef or empty list or throw an
  exception, depending on context, since that's what the subroutine whose key is
  C<':fussy'> does.
  
  Many people prefer module interfaces with a C<< I<flag> => I<value> >>
  format, and C<FAIL_WITH> supports this too. For example, if you
  wanted your module to take a C<-fail> flag, whose associated value could
  be any of C<"undefined">, C<"exception">, C<"logged">, or C<"context">,
  then you could implement that simply by specifying the flag as the first
  argument (i.e. I<before> the hash) like so:
  
      sub import {
          my $package = shift;
  
          Contextual::Return::FAIL_WITH -fail => {
              'undefined' => sub { return undef },
              'exception' => sub { croak @_ },
              'logged'    => sub {
                              print STDLOG 'Sub ', (caller 1)[3], ' failed';
                              return Failure->new();
                          },
              'context' => sub {
                              SCALAR  { undef      }
                              LIST    { ()         }
                              DEFAULT { croak @_ }
                          },
          }, @_;
  
  and then load the module:
  
      use MyModule qw( other args here ), -fail=>'undefined';
  
  or:
  
      use MyModule qw( other args here ), -fail=>'exception';
  
  In this case, C<FAIL_WITH> scans the argument list for a pair of values: its
  flag string, followed by some other selector value. Then it looks up the
  selector value in the hash, and installs the corresponding subroutine as its
  local C<FAIL> handler.
  
  If this "flagged" interface is used, the user of the module can also
  specify their own handler directly, by passing a subroutine reference as
  the selector value instead of a string:
  
      use MyModule qw( other args here ), -fail=>sub{ die 'horribly'};
  
  If this last example were used, any call to C<FAIL> within MyModule
  would invoke the specified anonymous subroutine (and hence throw a
  'horribly' exception).
  
  Note that, any overriding of a C<FAIL> handler is specific to the
  namespace and file from which the subroutine that calls C<FAIL_WITH> is
  itself called. Since C<FAIL_WITH> is designed to be called from within a
  module's C<import()> subroutine, that generally means that the C<FAIL>s
  within a given module X are only overridden for the current namespace
  within the particular file from module X is loaded. This means that two
  separate pieces of code (in separate files or separate namespaces) can
  each independently override a module's C<FAIL> behaviour, without
  interfering with each other.
  
  =head2 Lvalue contexts
  
  Recent versions of Perl offer (limited) support for lvalue subroutines:
  subroutines that return a modifiable variable, rather than a simple constant
  value.
  
  Contextual::Return can make it easier to create such subroutines, within the
  limitations imposed by Perl itself. The limitations that Perl places on lvalue
  subs are:
  
  =over
  
  =item 1.
  
  The subroutine must be declared with an C<:lvalue> attribute:
  
      sub foo :lvalue {...}
  
  =item 2.
  
  The subroutine must not return via an explicit C<return>. Instead, the
  last statement must evaluate to a variable, or must be a call to another
  lvalue subroutine call.
  
      my ($foo, $baz);
  
      sub foo :lvalue {
          $foo;               # last statement evals to a var
      }
  
      sub bar :lvalue {
          foo();              # last statement is lvalue sub call
      }
  
      sub baz :lvalue {
          my ($arg) = @_;
  
          $arg > 0            # last statement evals...
              ? $baz          # ...to a var
              : bar();        # ...or to an lvalue sub call
      }
  
  =back
  
  Thereafter, any call to the lvalue subroutine produces a result that can be
  assigned to:
  
      baz(0) = 42;            # same as: $baz = 42
  
      baz(1) = 84;            # same as:                  bar() = 84
                              #  which is the same as:    foo() = 84
                              #   which is the same as:   $foo  = 84
  
  Ultimately, every lvalue subroutine must return a scalar variable, which
  is then used as the lvalue of the assignment (or whatever other lvalue
  operation is applied to the subroutine call). Unfortunately, because the
  subroutine has to return this variable I<before> the assignment
  can take place, there is no way that a normal lvalue subroutine can
  get access to the value that will eventually be assigned to its
  return value.
  
  This is occasionally annoying, so the Contextual::Return module offers
  a solution: in addition to all the context blocks described above, it
  provides three special contextual return blocks specifically for use in
  lvalue subroutines: C<LVALUE>, C<RVALUE>, and C<NVALUE>.
  
  Using these blocks you can specify what happens when an lvalue
  subroutine is used in lvalue and non-lvalue (rvalue) context. For
  example:
  
      my $verbosity_level = 1;
  
      # Verbosity values must be between 0 and 5...
      sub verbosity :lvalue {
          LVALUE { $verbosity_level = max(0, min($_, 5)) }
          RVALUE { $verbosity_level                      }
      }
  
  The C<LVALUE> block is executed whenever C<verbosity> is called as an lvalue:
  
      verbosity() = 7;
  
  The block has access to the value being assigned, which is passed to it
  as C<$_>. So, in the above example, the assigned value of 7 would be
  aliased to C<$_> within the C<LVALUE> block, would be reduced to 5 by the
  "min-of-max" expression, and then assigned to C<$verbosity_level>.
  
  (If you need to access the caller's C<$_>, it's also still available:
  as C<$CALLER::_>.)
  
  When the subroutine isn't used as an lvalue:
  
      print verbosity();
  
  the C<RVALUE> block is executed instead and its final value returned.
  Within an C<RVALUE> block you can use any of the other features of
  Contextual::Return. For example:
  
      sub verbosity :lvalue {
          LVALUE { $verbosity_level = int max(0, min($_, 5)) }
          RVALUE {
              NUM  { $verbosity_level               }
              STR  { $description[$verbosity_level] }
              BOOL { $verbosity_level > 2           }
          }
      }
  
  but the context sequence must be nested inside an C<RVALUE> block.
  
  You can also specify what an lvalue subroutine should do when it is used
  neither as an lvalue nor as an rvalue (i.e. in void context), by using an
  C<NVALUE> block:
  
      sub verbosity :lvalue {
          my ($level) = @_;
  
          NVALUE { $verbosity_level = int max(0, min($level, 5)) }
          LVALUE { $verbosity_level = int max(0, min($_,     5)) }
          RVALUE {
              NUM  { $verbosity_level               }
              STR  { $description[$verbosity_level] }
              BOOL { $verbosity_level > 2           }
          }
      }
  
  In this example, a call to C<verbosity()> in void context sets the verbosity
  level to whatever argument is passed to the subroutine:
  
      verbosity(1);
  
  Note that you I<cannot> get the same effect by nesting a C<VOID> block
  within an C<RVALUE> block:
  
          LVALUE { $verbosity_level = int max(0, min($_, 5)) }
          RVALUE {
              NUM  { $verbosity_level               }
              STR  { $description[$verbosity_level] }
              BOOL { $verbosity_level > 2           }
              VOID { $verbosity_level = $level      }  # Wrong!
          }
  
  That's because, in a void context the return value is never evaluated,
  so it is never treated as an rvalue, which means the C<RVALUE> block
  never executes.
  
  
  =head2 Result blocks
  
  Occasionally, it's convenient to calculate a return value I<before> the
  end of a contextual return block. For example, you may need to clean up
  external resources involved in the calculation after it's complete.
  Typically, this requirement produces a slightly awkward code sequence
  like this:
  
      return
          VALUE {
              $db->start_work();
              my $result = $db->retrieve_query($query);
              $db->commit();
              $result;
          }
  
  Such code sequences become considerably more awkward when you want
  the return value to be context sensitive, in which case you have to
  write either:
  
      return
          LIST {
              $db->start_work();
              my @result = $db->retrieve_query($query);
              $db->commit();
              @result;
          }
          SCALAR {
              $db->start_work();
              my $result = $db->retrieve_query($query);
              $db->commit();
              $result;
          }
  
  or, worse:
  
      return
          VALUE {
              $db->start_work();
              my $result = LIST ? [$db->retrieve_query($query)]
                                :  $db->retrieve_query($query);
              $db->commit();
              LIST ? @{$result} : $result;
          }
  
  To avoid these infelicities, Contextual::Return provides a second way of
  setting the result of a context block; a way that doesn't require that the
  result be the last statement in the block:
  
      return
          LIST {
              $db->start_work();
              RESULT { $db->retrieve_query($query) };
              $db->commit();
          }
          SCALAR {
              $db->start_work();
              RESULT { $db->retrieve_query($query) };
              $db->commit();
          }
  
  The presence of a C<RESULT> block inside a contextual return block causes
  that block to return the value of the final statement of the C<RESULT>
  block as the handler's return value, rather than returning the value of
  the handler's own final statement. In other words, the presence of a C<RESULT>
  block overrides the normal return value of a context handler.
  
  Better still, the C<RESULT> block always evaluates its final statement
  in the same context as the surrounding C<return>, so you can just write:
  
      return
          VALUE {
              $db->start_work();
              RESULT { $db->retrieve_query($query) };
              $db->commit();
          }
  
  and the C<retrieve_query()> method will be called in the appropriate context
  in all cases.
  
  A C<RESULT> block can appear anywhere inside any contextual return
  block, but may not be used outside a context block. That is, this
  is an error:
  
      if ($db->closed) {
          RESULT { undef }; # Error: not in a context block
      }
      return
          VALUE {
              $db->start_work();
              RESULT { $db->retrieve_query($query) };
              $db->commit();
          }
  
  
  =head2 Post-handler clean-up
  
  If a subroutine uses an external resource, it's often necessary to close
  or clean-up that resource after the subroutine ends...regardless of
  whether the subroutine exits normally or via an exception.
  
  Typically, this is done by encapsulating the resource in a lexically
  scoped object whose destructor does the clean-up. However, if the clean-up
  doesn't involve deallocation of an object (as in the C<< $db->commit() >>
  example in the previous section), it can be annoying to have to create a
  class and allocate a container object, merely to mediate the clean-up.
  
  To make it easier to manage such resources, Contextual::Return supplies
  a special labelled block: the C<RECOVER> block. If a C<RECOVER> block is
  specified as part of a contextual return sequence, that block is
  executed after any context handler, even if the context handler exits
  via an exception.
  
  So, for example, you could implement a simple commit-or-revert
  policy like so:
  
      return
          LIST    { $db->retrieve_all($query)  }
          SCALAR  { $db->retrieve_next($query) }
          RECOVER {
              if ($@) {
                  $db->revert();
              }
              else {
                  $db->commit();
              }
          }
  
  The presence of a C<RECOVER> block also intercepts all exceptions thrown
  in any other context block in the same contextual return sequence. Any
  such exception is passed into the C<RECOVER> block in the usual manner:
  via the C<$@> variable. The exception may be rethrown out of the
  C<RECOVER> block by calling C<die>:
  
      return
          LIST    { $db->retrieve_all($query) }
          DEFAULT { croak "Invalid call (not in list context)" }
          RECOVER {
              die $@ if $@;    # Propagate any exception
              $db->commit();   # Otherwise commit the changes
          }
  
  A C<RECOVER> block can also access or replace the returned value, by
  invoking a C<RESULT> block. For example:
  
      return
          LIST    { attempt_to_generate_list_for(@_)  }
          SCALAR  { attempt_to_generate_count_for(@_) }
          RECOVER {
              if ($@) {                # On any exception...
                  warn "Replacing return value. Previously: ", RESULT;
                  RESULT { undef }     # ...return undef
              }
          }
  
  
  =head2 Post-return clean-up
  
  Occasionally it's necessary to defer the clean-up of resources until
  after the return value has been used. Once again, this is usually
  done by returning an object with a suitable destructor.
  
  Using Contextual::Return you can get the same effect, by providing a
  C<CLEANUP> block in the contextual return sequence:
  
      return
          LIST    { $db->retrieve_all($query)  }
          SCALAR  { $db->retrieve_next($query) }
          CLEANUP { $db->commit()              }
  
  In this example, the C<commit> method call is only performed after the
  return value has been used by the caller. Note that this is quite
  different from using a C<RECOVER> block, which is called as the
  subroutine returns its value; a C<CLEANUP> is called when the returned
  value is garbage collected.
  
  A C<CLEANUP> block is useful for controlling resources allocated to support an
  C<ACTIVE> return value. For example:
  
      my %file;
  
      # Return an active value that is always the next line from a file...
      sub readline_from {
          my ($file_name) = @_;
  
          # Open the file, if not already open...
          if (!$file{$file_name}) {
              open $file{$file_name}{handle}, '<', $file_name;
          }
  
          # Track how many active return values are using this file...
          $file{$file_name}{count}++;
  
          return ACTIVE
              # Evaluating the return value returns the next line...
              VALUE   { readline $file{$file_name}{handle} }
  
              # Once the active value is finished with, clean up the filehandle...
              CLEANUP {
                  delete $file{$file_name}
                      if --$file{$file_name}{count} == 0;
              }
      }
  
  
  =head2 Debugging contextual return values
  
  Contextual return values are implemented as opaque objects (using the
  "inside-out" technique). This means that passing such values to
  Data::Dumper produces an uninformative output like:
  
      $VAR1 = bless( do{\(my $o = undef)}, 'Contextual::Return::Value' );
  
  So the module provides two methods that allow contextual return values
  to be correctly reported: either directly, or when dumped by
  Data::Dumper.
  
  To dump a contextual return value directly, call the module's C<DUMP()>
  method explicitly and print the result:
  
      print $crv->Contextual::Return::DUMP();
  
  This produces an output something like:
  
      [
       { FROM       => 'main::foo'                                       },
       { NO_HANDLER => [ 'VOID', 'CODEREF', 'HASHREF', 'GLOBREF' ]       },
       { FALLBACKS  => [ 'VALUE' ]                                       },
       { LIST       => [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]                 },
       { STR        => '<<<Throws exception: Died at demo.pl line 7.>>>' },
       { NUM        => 42                                                },
       { BOOL       => -1                                                },
       { SCALARREF  => '<<<self-reference>>>'                            },
       { ARRAYREF   => [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]                 },
      ];
  
  The C<FROM> hash entry names the subroutine that produced the return
  value. The C<NO_HANDLER> hash entry lists those contexts for which no
  handler was defined (and which would therefore normally produce "can't
  call" exceptions such as: C<"Can't call main::foo in VOID context">).
  The C<FALLBACKS> hash entry lists any "generic" contexts such as
  C<VALUE>, C<NONVOID>, C<REF>, C<DEFAULT>, etc. that the contextual
  return value can also handle. After these, all the remaining hash
  entries are actual contexts in which the return value could successfully
  be evaluated, and the value it would produce in each of those contexts.
  
  The Data::Dumper module also has a mechanism by which you can tell it
  how to produce a similar listing automatically whenever a contextual
  return value is passed to its C<Dumper> method. Data::Dumper allows you
  to register a "freezer" method, that is called prior to dumping, and
  which can be used to adapt an opaque object to make it dumpable.
  Contextual::Return provides just such a method
  (C<Contextual::Return::FREEZE()>) for you to register, like so:
  
      use Data::Dumper 'Dumper';
  
      local $Data::Dumper::Freezer = 'Contextual::Return::FREEZE';
  
      print Dumper $foo;
  
  The output is then precisely the same as C<Contextual::Return::DUMP()>
  would produce.
  
  Note that, with both of the above dumping mechanisms, it is essential to use
  the full name of the method. That is:
  
      print $crv->Contextual::Return::DUMP();
  
  rather than:
  
      print $crv->DUMP();
  
  This is because the shorter version is interpreted as calling the
  C<DUMP()> method on the object returned by the return value's C<OBJREF>
  context block (see L<"Scalar reference contexts">)
  
  For the same reason, you must write:
  
      local $Data::Dumper::Freezer = 'Contextual::Return::FREEZE';
  
  not:
  
      local $Data::Dumper::Freezer = 'FREEZE';
  
  
  =head2 Namespace controls
  
  By default the module exports a large number of return context markers:
  
      DEFAULT    REF          LAZY
      VOID       SCALARREF    FIXED
      NONVOID    ARRAYREF     ACTIVE
      LIST       CODEREF      RESULT
      SCALAR     HASHREF      RECOVER
      VALUE      GLOBREF      CLEANUP
      STR        OBJREF       RVALUE
      NUM        METHOD       LVALUE
      BOOL                    NVALUE
      PUREBOOL
  
  These are exported as subroutines, and so can conflict with existing
  subroutines in your namespace, or with subroutines imported from other
  modules.
  
  Contextual::Return allows you to control which contextual return blocks are
  exported into any namespace that uses the module. It also allows you to rename
  blocks to avoid namespace conflicts with existing subroutines.
  
  Both these features are controlled by passing arguments to the C<use>
  statement that loads the module as follows:
  
  =over
  
  =item *
  
  Any string passed as an argument to C<use Contextual::Return>,
  exports only the block name it specifies;
  
  =item *
  
  Any regex passed as an argument to C<use Contextual::Return>
  exports every block name it matches;
  
  =item *
  
  Any array ref (recursively) exports each of its elements
  
  =item *
  
  Any string that appears immediately after one of the above three specifiers,
  and which is not itself a block name, renames the handlers exported by that
  preceding specifier by filtering each handler name through C<sprintf()>
  
  =back
  
  That is, you can specify handlers to be exported by exact name (as a string),
  by general pattern (as a regex), or collectively (in an array). And after any
  of these export specifications, you can append a template in which any C<'%s'>
  will be replaced by the original name of the handler. For example:
  
      # Selectively export specific sets of handlers...
      use Contextual::Return  qr/[NLR]VALUE/;
      use Contextual::Return  qr/.*REF/;
  
      # Selective export specific sets and add a suffix to each...
      use Contextual::Return  qr/[NLR]VALUE/ => '%s_CONTEXT';
  
      # Selective export specific sets and add a prefix to each...
      use Contextual::Return  qr/.*REF/ => 'CR_%s';
  
      # Export a list of handlers...
      use Contextual::Return    'NUM', 'STR', 'BOOL' ;
      use Contextual::Return qw< NUM    STR    BOOL >;
      use Contextual::Return   ['NUM', 'STR', 'BOOL'];
  
      # Export a list of handlers, renaming them individually...
      use Contextual::Return  NUM => 'NUMERIC', STR => 'TEXT', BOOL => 'CR_%s';
  
      # Export a list of handlers, renaming them collectively...
      use Contextual::Return  ['NUM', 'STR', 'BOOL'] => '%s_CONTEXT';
  
      # Mixed exports and renames...
      use Contextual::Return (
          STR => 'TEXT',
          ['NUM', 'BOOL'] => 'CR_%s',
          ['LIST', 'SCALAR', 'VOID', qr/^[NLR]VALUE/] => '%s_CONTEXT',
      );
  
  
  
  =head1 INTERFACE
  
  =head2 Context tests
  
  =over
  
  =item C<< LIST() >>
  
  Returns true if the current subroutine was called in list context.
  A cleaner way of writing: C<< wantarray() >>
  
  =item C<< SCALAR() >>
  
  Returns true if the current subroutine was called in scalar context.
  A cleaner way of writing: C<< defined wantarray() && ! wantarray() >>
  
  
  =item C<< VOID() >>
  
  Returns true if the current subroutine was called in void context.
  A cleaner way of writing: C<< !defined wantarray() >>
  
  =item C<< NONVOID() >>
  
  Returns true if the current subroutine was called in list or scalar context.
  A cleaner way of writing: C<< defined wantarray() >>
  
  =back
  
  =head2 Standard contexts
  
  =over
  
  =item C<< LIST {...} >>
  
  The block specifies what the context sequence should evaluate to when
  called in list context.
  
  =item C<< SCALAR {...} >>
  
  The block specifies what the context sequence should evaluate to in
  scalar contexts, unless some more-specific specifier scalar context specifier
  (see below) also occurs in the same context sequence.
  
  =item C<< VOID {...} >>
  
  The block specifies what the context sequence should do when
  called in void context.
  
  =back
  
  =head2 Scalar value contexts
  
  =over
  
  =item C<< BOOL {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a boolean value.
  
  =item C<< NUM {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a numeric value.
  
  =item C<< STR {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a string value.
  
  =item C<< LAZY {...} >>
  
  Another name for C<SCALAR {...}>. Usefully self-documenting when the primary
  purpose of the contextual return is to defer evaluation of the return value
  until it's actually required.
  
  =back
  
  =head2 Scalar reference contexts
  
  =over
  
  =item C<< SCALARREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to a scalar.
  
  =item C<< ARRAYREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to an array.
  
  =item C<< HASHREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to a hash.
  
  Note that a common error here is to write:
  
  HASHREF { a=>1, b=>2, c=>3 }
  
  The curly braces there are a block, not a hash constructor, so the block
  doesn't return a hash reference and the interpreter throws an exception.
  What's needed is:
  
  HASHREF { {a=>1, b=>2, c=>3} }
  
  in which the inner braces I<are> a hash constructor.
  
  =item C<< CODEREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to a subroutine.
  
  =item C<< GLOBREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to a typeglob.
  
  =item C<< OBJREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to an object.
  
  =item C<< METHOD {...} >>
  
  The block can be used to specify particular handlers for specific method calls
  when the return value is treated as an object reference.
  It should return a list of methodname/methodbody pairs. Each method name can
  be specified as a string, a regex, or an array of strings or regexes. The
  method bodies must be specified as subroutine references (usually anonymous
  subs). The first method name that matches the actual method call selects the
  corresponding handler, which is then called.
  
  =back
  
  =head2 Generic contexts
  
  =over
  
  =item C<< VALUE {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a non-referential value (as a boolean, numeric, string,
  scalar, or list). Only used if there is no more-specific value context
  specifier in the context sequence.
  
  =item C<< REF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference of any kind. Only used if there is no
  more-specific referential context specifier in the context sequence.
  
  =item C<< NONVOID {...} >>
  
  The block specifies what the context sequence should evaluate to when
  used in a non-void context of any kind. Only used if there is no
  more-specific context specifier in the context sequence.
  
  =item C<< DEFAULT {...} >>
  
  The block specifies what the context sequence should evaluate to when
  used in a void or non-void context of any kind. Only used if there is no
  more-specific context specifier in the context sequence.
  
  =back
  
  =head2 Failure context
  
  =over
  
  =item C<< FAIL >>
  
  This block is executed unconditionally and is used to indicate failure. In a
  Boolean context it return false. In all other contexts it throws an exception
  consisting of the final evaluated value of the block.
  
  That is, using C<FAIL>:
  
  return
  FAIL { "Could not defenestrate the widget" }
  
  is exactly equivalent to writing:
  
  return
  BOOL { 0 }
  DEFAULT { croak "Could not defenestrate the widget" }
  
  except that the reporting of errors is a little smarter under C<FAIL>.
  
  If C<FAIL> is called without specifying a block:
  
  return FAIL;
  
  it is equivalent to:
  
  return FAIL { croak "Call to <subname> failed" }
  
  (where C<< <subname> >> is replaced with the name of the surrounding
  subroutine).
  
  Note that, because C<FAIL> implicitly covers every possible return
  context, it cannot be chained with other context specifiers.
  
  =item C<< Contextual::Return::FAIL_WITH >>
  
  This subroutine is not exported, but may be called directly to reconfigure
  C<FAIL> behaviour in the caller's namespace.
  
  The subroutine is called with an optional string (the I<flag>), followed
  by a mandatory hash reference (the I<configurations hash>), followed by a
  list of zero-or-more strings (the I<selector list>). The values of the
  configurations hash must all be subroutine references.
  
  If the optional flag is specified, C<FAIL_WITH> searches the selector
  list looking for that string, then uses the I<following> item in the
  selector list as its I<selector value>. If that selector value is a
  string, C<FAIL_WITH> looks up that key in the hash, and installs the
  corresponding subroutine as the namespace's C<FAIL> handler (an
  exception is thrown if the selector string is not a valid key of the
  configurations hash). If the selector value is a subroutine reference,
  C<FAIL_WITH> installs that subroutine as the C<FAIL> handler.
  
  If the optional flag is I<not> specified, C<FAIL_WITH> searches the
  entire selector list looking for the last element that matches any
  key in the configurations hash. It then looks up that key in the
  hash, and installs the corresponding subroutine as the namespace's
  C<FAIL> handler.
  
  See L<Configurable failure contexts> for examples of using this feature.
  
  =back
  
  =head2 Lvalue contexts
  
  =over
  
  =item C<< LVALUE >>
  
  This block is executed when the result of an C<:lvalue> subroutine is assigned
  to. The assigned value is passed to the block as C<$_>. To access the caller's
  C<$_> value, use C<$CALLER::_>.
  
  =item C<< RVALUE >>
  
  This block is executed when the result of an C<:lvalue> subroutine is used
  as an rvalue. The final value that is evaluated in the block becomes the
  rvalue.
  
  =item C<< NVALUE >>
  
  This block is executed when an C<:lvalue> subroutine is evaluated in void
  context.
  
  =back
  
  =head2 Explicit result blocks
  
  =over
  
  =item C<< RESULT >>
  
  This block may only appear inside a context handler block. It causes the
  surrounding handler to return the final value of the C<RESULT>'s block,
  rather than the final value of the handler's own block. This override occurs
  regardless of the location to the C<RESULT> block within the handler.
  
  If called without a trailing C<{...}>, it simply returns the current result
  value in scalar contexts, or the list of result values in list context.
  
  =back
  
  =head2 Recovery blocks
  
  =over
  
  =item C<< RECOVER >>
  
  If present in a context return sequence, this block grabs control after
  any context handler returns or exits via an exception. If an exception
  was thrown it is passed to the C<RECOVER> block via the C<$@> variable.
  
  =back
  
  =head2 Clean-up blocks
  
  =over
  
  =item C<< CLEANUP >>
  
  If present in a context return sequence, this block grabs control when
  a return value is garbage collected.
  
  =back
  
  
  =head2 Modifiers
  
  =over
  
  =item C<< FIXED >>
  
  This specifies that the scalar value will only be evaluated once, the
  first time it is used, and that the value will then morph into that
  evaluated value.
  
  =item C<< ACTIVE >>
  
  This specifies that the scalar value's originating block will be re-
  evaluated every time the return value is used.
  
  =back
  
  =head2 Debugging support
  
  =over
  
  =item C<< $crv->Contextual::Return::DUMP() >>
  
  Return a dumpable representation of the return value in all viable contexts.
  
  =item C<< local $Data::Dumper::Freezer = 'Contextual::Return::FREEZE'; >>
  
  =item C<< local $Data::Dumper::Freezer = \&Contextual::Return::FREEZE; >>
  
  Configure Data::Dumper to correctly dump a representation of the
  contextual return value.
  
  =back
  
  
  =head1 DIAGNOSTICS
  
  =over
  
  =item C<Can't use %s as export specifier>
  
  In your C<use Contextual::Return> statement you specified something (such as a
  hash or coderef) that can't be used to select what the module exports. Make
  sure the list of selectors includes only strings, regexes, or references to
  arrays of strings or regexes.
  
  
  =item C<use Contextual::Return qr{%s} didn't export anything>
  
  In your C<use Contextual::Return> statement you specified a regex to select
  which handlers to support, but the regex didn't select any handlers. Check
  that the regex you're using actually does match at least one of the names of
  the modules many handlers.
  
  
  =item C<Can't export %s: no such handler>
  
  In your C<use Contextual::Return> statement you specified a string as the
  name of a context handler to be exported, but the module doesn't export a
  handler of that name. Check the spelling for the requested export.
  
  
  =item C<Can't call %s in a %s context>
  
  =item C<Can't use return value of %s in a %s context>
  
  The subroutine you called uses a contextual return, but doesn't specify what
  to return in the particular context in which you called it. You either need to
  change the context in which you're calling the subroutine, or else add a
  context block corresponding to the offending context (or perhaps a
  C<DEFAULT {...}> block).
  
  
  =item C<Can't call bare %s {...} in %s context>
  
  You specified a handler (such as C<VOID {...}> or C<LIST {...}>)
  outside any subroutine, and in a context that it
  can't handle. Did you mean to place the handler outside of a subroutine?
  If so, then you need to put it in a context it can actually handle.
  Otherwise, perhaps you need to replace the trailing block with parens
  (that is: C<VOID()> or C<LIST()>).
  
  
  =item C<Call to %s at %s didn't return a %s reference">
  
  You called the subroutine in a context that expected to get back a
  reference of some kind but the subroutine didn't specify the
  corresponding C<SCALARREF>, C<ARRAYREF>, C<HASHREF>, C<CODEREF>,
  C<GLOBREF>, or generic C<REF>, C<NONVOID>, or C<DEFAULT> handlers.
  You need to specify the appropriate one of these handlers in the subroutine.
  
  
  =item C<Can't call method '%s' on %s value returned by %s">
  
  You called the subroutine and then tried to call a method on the return
  value, but the subroutine returned a classname or object that doesn't
  have that method. This probably means that the subroutine didn't return
  the classname or object you expected. Or perhaps you need to specify
  an C<OBJREF {...}> context block.
  
  
  =item C<Can't install two %s handlers>
  
  You attempted to specify two context blocks of the same name in the same
  return context, which is ambiguous. For example:
  
      sub foo: lvalue {
          LVALUE { $foo = $_ }
          RVALUE { $foo }
          LVALUE { $foo = substr($_,1,10) }
      }
  
  or:
  
      sub bar {
          return
              BOOL { 0 }
              NUM  { 1 }
              STR  { "two" }
              BOOL { 1 };
      }
  
  Did you cut-and-paste wrongly, or mislabel one of the blocks?
  
  
  =item C<Expected a %s block after the %s block but found instead: %s>
  
  If you specify any of C<LVALUE>, C<RVALUE>, or C<NVALUE>, then you can only
  specify C<LVALUE>, C<RVALUE>, or C<NVALUE> blocks in the same return context.
  If you need to specify other contexts (like C<BOOL>, or C<STR>, or C<REF>,
  etc.), put them inside an C<RVALUE> block. See L<Lvalue contexts> for an
  example.
  
  
  =item C<Call to %s failed at %s>
  
  This is the default exception that a C<FAIL> throws in a non-scalar
  context. Which means that the subroutine you called has signalled
  failure by throwing an exception, and you didn't catch that exception.
  You should either put the call in an C<eval {...}> block or else call the
  subroutine in boolean context instead.
  
  
  =item C<Call to %s failed at %s. Attempted to use failure value at %s>
  
  This is the default exception that a C<FAIL> throws when a failure value
  is captured in a scalar variable and later used in a non-boolean
  context. That means that the subroutine you called must have failed, and
  you didn't check the return value for that failure, so when you tried to
  use that invalid value it killed your program. You should either put the
  original call in an C<eval {...}> or else test the return value in a
  boolean context and avoid using it if it's false.
  
  
  =item C<Usage: FAIL_WITH $flag_opt, \%selector, @args>
  
  The C<FAIL_WITH> subroutine expects an optional flag, followed by a reference
  to a configuration hash, followed by a list or selector arguments. You gave it
  something else. See L<Configurable Failure Contexts>.
  
  
  =item C<Selector values must be sub refs>
  
  You passed a configuration hash to C<FAIL_WITH> that specified non-
  subroutines as possible C<FAIL> handlers. Since non-subroutines can't
  possibly be handlers, maybe you forgot the C<sub> keyword somewhere?
  
  
  =item C<Invalid option: %s => %s>
  
  The C<FAIL_WITH> subroutine was passed a flag/selector pair, but the selector
  was not one of those allowed by the configuration hash.
  
  
  =item C<FAIL handler for package %s redefined>
  
  A warning that the C<FAIL> handler for a particular package was
  reconfigured more than once. Typically that's because the module was
  loaded in two places with difference configurations specified. You can't
  reasonably expect two different sets of behaviours from the one module within
  the one namespace.
  
  =back
  
  
  =head1 CONFIGURATION AND ENVIRONMENT
  
  Contextual::Return requires no configuration files or environment variables.
  
  
  =head1 DEPENDENCIES
  
  Requires version.pm and Want.pm.
  
  
  =head1 INCOMPATIBILITIES
  
  C<LVALUE>, C<RVALUE>, and C<NVALUE> do not work correctly under the Perl
  debugger. This seems to be because the debugger injects code to capture
  the return values from subroutines, which interferes destructively with
  the optional final arguments that allow C<LVALUE>, C<RVALUE>, and C<NVALUE>
  to cascade within a single return.
  
  
  =head1 BUGS AND LIMITATIONS
  
  No bugs have been reported.
  
  
  =head1 AUTHOR
  
  Damian Conway  C<< <DCONWAY@cpan.org> >>
  
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2005-2011, Damian Conway C<< <DCONWAY@cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
CONTEXTUAL_RETURN

$fatpacked{"Contextual/Return/Failure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONTEXTUAL_RETURN_FAILURE';
  package Contextual::Return::Failure;
  our $VERSION = 0.000_003;
  
  use Contextual::Return;
  BEGIN { *_in_context = *Contextual::Return::_in_context }
  
  use warnings;
  use strict;
  
  my %handler_for;
  
  sub _FAIL_WITH {
      # Unpack and vet args...
      my $flag = shift;
      my $selector_ref;
      if (ref $flag eq 'HASH') {
          $selector_ref = $flag;
          $flag = undef;
      }
      else {
          $selector_ref = shift;
          die _in_context 'Usage: FAIL_WITH $flag_opt, \%selector, @args'
              if ref $selector_ref ne 'HASH';
      }
      die _in_context "Selector values must be sub refs"
          if grep {ref ne 'CODE'} values %{$selector_ref};
  
      # Search for handler sub;
      my $handler;
      if (defined $flag) {
          ARG:
          while (@_) {
              last ARG if shift(@_) eq $flag;
          }
          my $selector = shift @_;
          if (ref $selector eq 'CODE') {
              $handler = $selector;
              @_ = ();
          }
          else {
              @_ = $selector;
          }
      }
  
      SELECTION:
      for my $selection (reverse @_) {
          if (exists $selector_ref->{$selection}) {
              $handler = $selector_ref->{$selection};
              last SELECTION;
          }
          elsif ($flag) {
              die _in_context "Invalid option: $flag => $selection";
          }
      }
  
      # (Re)set handler...
      if ($handler) {
          my $caller_loc = join '|', (CORE::caller 1)[0,1];
          if (exists $handler_for{$caller_loc}) {
              warn _in_context "FAIL handler for package ", scalar CORE::caller, " redefined";
          }
          $handler_for{$caller_loc} = $handler;
      }
  };
  
  sub _FAIL (;&) {
      # Generate args...
      my $arg_generator_ref = shift;
      my @args;
      if ($arg_generator_ref) {
          package DB;
          ()=CORE::caller(1);
          @args = $arg_generator_ref->(@DB::args);
      }
  
      # Handle user-defined failure semantics...
      my $caller_loc = join '|', (CORE::caller 1)[0,1];
      if (exists $handler_for{$caller_loc} ) {
          # Fake out caller() and Carp...
          local $Contextual::Return::uplevel = 1;
  
          return $handler_for{$caller_loc}->(@args);
      }
  
      my $exception = @args == 1 ? $args[0]
                    : @args > 0  ? join(q{}, @args)
                    :              "Call to " . (CORE::caller 1)[3] . "() failed"
                    ;
  
      # Join message with croak() semantics, if string...
      if (!ref $exception) {
          $exception .= _in_context @_;
      }
  
  #    # Check for immediate failure...
  #    use Want qw( want );
  #    return 0 if want 'BOOL';
  #    die $exception if !want 'SCALAR';
  
      # Return a delayed failure object...
      return
          BOOL    { 0 }
          DEFAULT {
              if (ref $exception) {
                  my $message = "$exception";
                  $message =~ s/$/\n/;
                  die _in_context $message, "Attempted to use failure value";
              }
              else {
                  die _in_context $exception, "Attempted to use failure value";
              }
          }
          METHOD {
              error => sub { _in_context $exception }
          }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Contextual::Return::Failure - Utility module for Contextual::Return
  
  =head1 NOTE
  
  Contains no user serviceable parts. See L<Contextual::Return> instead.
  
  =head1 AUTHOR
  
  Damian Conway  C<< <DCONWAY@cpan.org> >>
  
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2006, Damian Conway C<< <DCONWAY@cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
  
CONTEXTUAL_RETURN_FAILURE

$fatpacked{"Data/OptList.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_OPTLIST';
  use strict;
  use warnings;
  package Data::OptList;
  # ABSTRACT: parse and validate simple name/value option pairs
  $Data::OptList::VERSION = '0.110';
  use List::Util ();
  use Params::Util ();
  use Sub::Install 0.921 ();
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   use Data::OptList;
  #pod
  #pod   my $options = Data::OptList::mkopt([
  #pod     qw(key1 key2 key3 key4),
  #pod     key5 => { ... },
  #pod     key6 => [ ... ],
  #pod     key7 => sub { ... },
  #pod     key8 => { ... },
  #pod     key8 => [ ... ],
  #pod   ]);
  #pod
  #pod ...is the same thing, more or less, as:
  #pod
  #pod   my $options = [
  #pod     [ key1 => undef,        ],
  #pod     [ key2 => undef,        ],
  #pod     [ key3 => undef,        ],
  #pod     [ key4 => undef,        ],
  #pod     [ key5 => { ... },      ],
  #pod     [ key6 => [ ... ],      ],
  #pod     [ key7 => sub { ... },  ],
  #pod     [ key8 => { ... },      ],
  #pod     [ key8 => [ ... ],      ],
  #pod   ]);
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod Hashes are great for storing named data, but if you want more than one entry
  #pod for a name, you have to use a list of pairs.  Even then, this is really boring
  #pod to write:
  #pod
  #pod   $values = [
  #pod     foo => undef,
  #pod     bar => undef,
  #pod     baz => undef,
  #pod     xyz => { ... },
  #pod   ];
  #pod
  #pod Just look at all those undefs!  Don't worry, we can get rid of those:
  #pod
  #pod   $values = [
  #pod     map { $_ => undef } qw(foo bar baz),
  #pod     xyz => { ... },
  #pod   ];
  #pod
  #pod Aaaauuugh!  We've saved a little typing, but now it requires thought to read,
  #pod and thinking is even worse than typing... and it's got a bug!  It looked right,
  #pod didn't it?  Well, the C<< xyz => { ... } >> gets consumed by the map, and we
  #pod don't get the data we wanted.
  #pod
  #pod With Data::OptList, you can do this instead:
  #pod
  #pod   $values = Data::OptList::mkopt([
  #pod     qw(foo bar baz),
  #pod     xyz => { ... },
  #pod   ]);
  #pod
  #pod This works by assuming that any defined scalar is a name and any reference
  #pod following a name is its value.
  #pod
  #pod =func mkopt
  #pod
  #pod   my $opt_list = Data::OptList::mkopt($input, \%arg);
  #pod
  #pod Valid arguments are:
  #pod
  #pod   moniker        - a word used in errors to describe the opt list; encouraged
  #pod   require_unique - if true, no name may appear more than once
  #pod   must_be        - types to which opt list values are limited (described below)
  #pod   name_test      - a coderef used to test whether a value can be a name
  #pod                    (described below, but you probably don't want this)
  #pod
  #pod This produces an array of arrays; the inner arrays are name/value pairs.
  #pod Values will be either "undef" or a reference.
  #pod
  #pod Positional parameters may be used for compatibility with the old C<mkopt>
  #pod interface:
  #pod
  #pod   my $opt_list = Data::OptList::mkopt($input, $moniker, $req_uni, $must_be);
  #pod
  #pod Valid values for C<$input>:
  #pod
  #pod  undef    -> []
  #pod  hashref  -> [ [ key1 => value1 ] ... ] # non-ref values become undef
  #pod  arrayref -> every name followed by a non-name becomes a pair: [ name => ref ]
  #pod              every name followed by undef becomes a pair: [ name => undef ]
  #pod              otherwise, it becomes [ name => undef ] like so:
  #pod              [ "a", "b", [ 1, 2 ] ] -> [ [ a => undef ], [ b => [ 1, 2 ] ] ]
  #pod
  #pod By default, a I<name> is any defined non-reference.  The C<name_test> parameter
  #pod can be a code ref that tests whether the argument passed it is a name or not.
  #pod This should be used rarely.  Interactions between C<require_unique> and
  #pod C<name_test> are not yet particularly elegant, as C<require_unique> just tests
  #pod string equality.  B<This may change.>
  #pod
  #pod The C<must_be> parameter is either a scalar or array of scalars; it defines
  #pod what kind(s) of refs may be values.  If an invalid value is found, an exception
  #pod is thrown.  If no value is passed for this argument, any reference is valid.
  #pod If C<must_be> specifies that values must be CODE, HASH, ARRAY, or SCALAR, then
  #pod Params::Util is used to check whether the given value can provide that
  #pod interface.  Otherwise, it checks that the given value is an object of the kind.
  #pod
  #pod In other words:
  #pod
  #pod   [ qw(SCALAR HASH Object::Known) ]
  #pod
  #pod Means:
  #pod
  #pod   _SCALAR0($value) or _HASH($value) or _INSTANCE($value, 'Object::Known')
  #pod
  #pod =cut
  
  my %test_for;
  BEGIN {
    %test_for = (
      CODE   => \&Params::Util::_CODELIKE,  ## no critic
      HASH   => \&Params::Util::_HASHLIKE,  ## no critic
      ARRAY  => \&Params::Util::_ARRAYLIKE, ## no critic
      SCALAR => \&Params::Util::_SCALAR0,   ## no critic
    );
  }
  
  sub mkopt {
    my ($opt_list) = shift;
  
    my ($moniker, $require_unique, $must_be); # the old positional args
    my ($name_test, $is_a);
  
    if (@_) {
      if (@_ == 1 and Params::Util::_HASHLIKE($_[0])) {
        ($moniker, $require_unique, $must_be, $name_test)
          = @{$_[0]}{ qw(moniker require_unique must_be name_test) };
      } else {
        ($moniker, $require_unique, $must_be) = @_;
      }
  
      # Transform the $must_be specification into a closure $is_a
      # that will check if a value matches the spec
  
      if (defined $must_be) {
        $must_be = [ $must_be ] unless ref $must_be;
        my @checks = map {
            my $class = $_;
            $test_for{$_}
            || sub { $_[1] = $class; goto \&Params::Util::_INSTANCE }
        } @$must_be;
  
        $is_a = (@checks == 1)
              ? $checks[0]
              : sub {
                  my $value = $_[0];
                  List::Util::first { defined($_->($value)) } @checks
                };
  
        $moniker = 'unnamed' unless defined $moniker;
      }
    }
  
    return [] unless $opt_list;
  
    $name_test ||= sub { ! ref $_[0] };
  
    $opt_list = [
      map { $_ => (ref $opt_list->{$_} ? $opt_list->{$_} : ()) } keys %$opt_list
    ] if ref $opt_list eq 'HASH';
  
    my @return;
    my %seen;
  
    for (my $i = 0; $i < @$opt_list; $i++) { ## no critic
      my $name = $opt_list->[$i];
  
      if ($require_unique) {
        Carp::croak "multiple definitions provided for $name" if $seen{$name}++;
      }
  
      my $value;
  
      if ($i < $#$opt_list) {
        if (not defined $opt_list->[$i+1]) {
          $i++
        } elsif (! $name_test->($opt_list->[$i+1])) {
          $value = $opt_list->[++$i];
          if ($is_a && !$is_a->($value)) {
            my $ref = ref $value;
            Carp::croak "$ref-ref values are not valid in $moniker opt list";
          }
        }
      }
  
      push @return, [ $name => $value ];
    }
  
    return \@return;
  }
  
  #pod =func mkopt_hash
  #pod
  #pod   my $opt_hash = Data::OptList::mkopt_hash($input, $moniker, $must_be);
  #pod
  #pod Given valid C<L</mkopt>> input, this routine returns a reference to a hash.  It
  #pod will throw an exception if any name has more than one value.
  #pod
  #pod =cut
  
  sub mkopt_hash {
    my ($opt_list, $moniker, $must_be) = @_;
    return {} unless $opt_list;
  
    $opt_list = mkopt($opt_list, $moniker, 1, $must_be);
    my %hash = map { $_->[0] => $_->[1] } @$opt_list;
    return \%hash;
  }
  
  #pod =head1 EXPORTS
  #pod
  #pod Both C<mkopt> and C<mkopt_hash> may be exported on request.
  #pod
  #pod =cut
  
  BEGIN {
    *import = Sub::Install::exporter {
      exports => [qw(mkopt mkopt_hash)],
    };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Data::OptList - parse and validate simple name/value option pairs
  
  =head1 VERSION
  
  version 0.110
  
  =head1 SYNOPSIS
  
    use Data::OptList;
  
    my $options = Data::OptList::mkopt([
      qw(key1 key2 key3 key4),
      key5 => { ... },
      key6 => [ ... ],
      key7 => sub { ... },
      key8 => { ... },
      key8 => [ ... ],
    ]);
  
  ...is the same thing, more or less, as:
  
    my $options = [
      [ key1 => undef,        ],
      [ key2 => undef,        ],
      [ key3 => undef,        ],
      [ key4 => undef,        ],
      [ key5 => { ... },      ],
      [ key6 => [ ... ],      ],
      [ key7 => sub { ... },  ],
      [ key8 => { ... },      ],
      [ key8 => [ ... ],      ],
    ]);
  
  =head1 DESCRIPTION
  
  Hashes are great for storing named data, but if you want more than one entry
  for a name, you have to use a list of pairs.  Even then, this is really boring
  to write:
  
    $values = [
      foo => undef,
      bar => undef,
      baz => undef,
      xyz => { ... },
    ];
  
  Just look at all those undefs!  Don't worry, we can get rid of those:
  
    $values = [
      map { $_ => undef } qw(foo bar baz),
      xyz => { ... },
    ];
  
  Aaaauuugh!  We've saved a little typing, but now it requires thought to read,
  and thinking is even worse than typing... and it's got a bug!  It looked right,
  didn't it?  Well, the C<< xyz => { ... } >> gets consumed by the map, and we
  don't get the data we wanted.
  
  With Data::OptList, you can do this instead:
  
    $values = Data::OptList::mkopt([
      qw(foo bar baz),
      xyz => { ... },
    ]);
  
  This works by assuming that any defined scalar is a name and any reference
  following a name is its value.
  
  =head1 FUNCTIONS
  
  =head2 mkopt
  
    my $opt_list = Data::OptList::mkopt($input, \%arg);
  
  Valid arguments are:
  
    moniker        - a word used in errors to describe the opt list; encouraged
    require_unique - if true, no name may appear more than once
    must_be        - types to which opt list values are limited (described below)
    name_test      - a coderef used to test whether a value can be a name
                     (described below, but you probably don't want this)
  
  This produces an array of arrays; the inner arrays are name/value pairs.
  Values will be either "undef" or a reference.
  
  Positional parameters may be used for compatibility with the old C<mkopt>
  interface:
  
    my $opt_list = Data::OptList::mkopt($input, $moniker, $req_uni, $must_be);
  
  Valid values for C<$input>:
  
   undef    -> []
   hashref  -> [ [ key1 => value1 ] ... ] # non-ref values become undef
   arrayref -> every name followed by a non-name becomes a pair: [ name => ref ]
               every name followed by undef becomes a pair: [ name => undef ]
               otherwise, it becomes [ name => undef ] like so:
               [ "a", "b", [ 1, 2 ] ] -> [ [ a => undef ], [ b => [ 1, 2 ] ] ]
  
  By default, a I<name> is any defined non-reference.  The C<name_test> parameter
  can be a code ref that tests whether the argument passed it is a name or not.
  This should be used rarely.  Interactions between C<require_unique> and
  C<name_test> are not yet particularly elegant, as C<require_unique> just tests
  string equality.  B<This may change.>
  
  The C<must_be> parameter is either a scalar or array of scalars; it defines
  what kind(s) of refs may be values.  If an invalid value is found, an exception
  is thrown.  If no value is passed for this argument, any reference is valid.
  If C<must_be> specifies that values must be CODE, HASH, ARRAY, or SCALAR, then
  Params::Util is used to check whether the given value can provide that
  interface.  Otherwise, it checks that the given value is an object of the kind.
  
  In other words:
  
    [ qw(SCALAR HASH Object::Known) ]
  
  Means:
  
    _SCALAR0($value) or _HASH($value) or _INSTANCE($value, 'Object::Known')
  
  =head2 mkopt_hash
  
    my $opt_hash = Data::OptList::mkopt_hash($input, $moniker, $must_be);
  
  Given valid C<L</mkopt>> input, this routine returns a reference to a hash.  It
  will throw an exception if any name has more than one value.
  
  =head1 EXPORTS
  
  Both C<mkopt> and C<mkopt_hash> may be exported on request.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Olivier Mengu Ricardo SIGNES
  
  =over 4
  
  =item *
  
  Olivier Mengu <dolmen@cpan.org>
  
  =item *
  
  Ricardo SIGNES <rjbs@codesimply.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DATA_OPTLIST

$fatpacked{"Getopt/Long/Descriptive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG_DESCRIPTIVE';
  use strict;
  use warnings;
  package Getopt::Long::Descriptive;
  # ABSTRACT: Getopt::Long, but simpler and more powerful
  $Getopt::Long::Descriptive::VERSION = '0.102';
  use Carp qw(carp croak);
  use File::Basename ();
  use Getopt::Long 2.33;
  use List::Util qw(first);
  use Params::Validate 0.97 qw(:all);
  use Scalar::Util ();
  
  use Getopt::Long::Descriptive::Opts;
  use Getopt::Long::Descriptive::Usage;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   use Getopt::Long::Descriptive;
  #pod
  #pod   my ($opt, $usage) = describe_options(
  #pod     'my-program %o <some-arg>',
  #pod     [ 'server|s=s', "the server to connect to", { required => 1  } ],
  #pod     [ 'port|p=i',   "the port to connect to",   { default  => 79 } ],
  #pod     [],
  #pod     [ 'verbose|v',  "print extra stuff"            ],
  #pod     [ 'help',       "print usage message and exit", { shortcircuit => 1 } ],
  #pod   );
  #pod
  #pod   print($usage->text), exit if $opt->help;
  #pod
  #pod   Client->connect( $opt->server, $opt->port );
  #pod
  #pod   print "Connected!\n" if $opt->verbose;
  #pod
  #pod ...and running C<my-program --help> will produce:
  #pod
  #pod   my-program [-psv] [long options...] <some-arg>
  #pod     -s --server     the server to connect to
  #pod     -p --port       the port to connect to
  #pod
  #pod     -v --verbose    print extra stuff
  #pod     --help          print usage message and exit
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod Getopt::Long::Descriptive is yet another Getopt library.  It's built atop
  #pod Getopt::Long, and gets a lot of its features, but tries to avoid making you
  #pod think about its huge array of options.
  #pod
  #pod It also provides usage (help) messages, data validation, and a few other useful
  #pod features.
  #pod
  #pod =head1 FUNCTIONS
  #pod
  #pod Getopt::Long::Descriptive only exports one routine by default:
  #pod C<describe_options>.  All GLD's exports are exported by L<Sub::Exporter>.
  #pod
  #pod =head2 describe_options
  #pod
  #pod   my ($opt, $usage) = describe_options($usage_desc, @opt_spec, \%arg);
  #pod
  #pod This routine inspects C<@ARGV> for options that match the supplied spec. If all
  #pod the options are valid then it returns the options given and an object for
  #pod generating usage messages; if not then it dies with an explanation of what was
  #pod wrong and a usage message.
  #pod
  #pod The C<$opt> object will be a dynamically-generated subclass of
  #pod L<Getopt::Long::Descriptive::Opts>.  In brief, each of the options in
  #pod C<@opt_spec> becomes an accessor method on the object, using the first-given
  #pod name, with dashes converted to underscores.  For more information, see the
  #pod documentation for the Opts class.
  #pod
  #pod The C<$usage> object will be a L<Getopt::Long::Descriptive::Usage> object,
  #pod which provides a C<text> method to get the text of the usage message and C<die>
  #pod to die with it.  For more methods and options, consults the documentation for
  #pod the Usage class.
  #pod
  #pod =head3 $usage_desc
  #pod
  #pod The C<$usage_desc> parameter to C<describe_options> is a C<sprintf>-like string
  #pod that is used in generating the first line of the usage message.  It's a
  #pod one-line summary of how the command is to be invoked.  A typical usage
  #pod description might be:
  #pod
  #pod   $usage_desc = "%c %o <source> <desc>";
  #pod
  #pod C<%c> will be replaced with what Getopt::Long::Descriptive thinks is the
  #pod program name (it's computed from C<$0>, see L</prog_name>).
  #pod
  #pod C<%o> will be replaced with a list of the short options, as well as the text
  #pod "[long options...]" if any have been defined.
  #pod
  #pod The rest of the usage description can be used to summarize what arguments are
  #pod expected to follow the program's options, and is entirely free-form.
  #pod
  #pod Literal C<%> characters will need to be written as C<%%>, just like with
  #pod C<sprintf>.
  #pod
  #pod =head3 @opt_spec
  #pod
  #pod The C<@opt_spec> part of the args to C<describe_options> is used to configure
  #pod option parsing and to produce the usage message.  Each entry in the list is an
  #pod arrayref describing one option, like this:
  #pod
  #pod   @opt_spec = (
  #pod     [ "verbose|V" => "be noisy"       ],
  #pod     [ "logfile=s" => "file to log to" ],
  #pod   );
  #pod
  #pod The first value in the arrayref is a Getopt::Long-style option specification.
  #pod In brief, they work like this:  each one is a pipe-delimited list of names,
  #pod optionally followed by a type declaration.  Type declarations are '=x' or ':x',
  #pod where C<=> means a value is required and C<:> means it is optional.  I<x> may
  #pod be 's' to indicate a string is required, 'i' for an integer, or 'f' for a
  #pod number with a fractional part.  The type spec may end in C<@> to indicate that
  #pod the option may appear multiple times.
  #pod
  #pod For more information on how these work, see the L<Getopt::Long> documentation.
  #pod
  #pod The first name given should be the canonical name, as it will be used as the
  #pod accessor method on the C<$opt> object.  Dashes in the name will be converted to
  #pod underscores, and all letters will be lowercased.  For this reason, all options
  #pod should generally have a long-form name.
  #pod
  #pod The second value in the arrayref is a description of the option, for use in the
  #pod usage message.
  #pod
  #pod =head4 Special Option Specifications
  #pod
  #pod If the option specification (arrayref) is empty, it will have no effect other
  #pod than causing a blank line to appear in the usage message.
  #pod
  #pod If the option specification contains only one element, it will be printed in
  #pod the usage message with no other effect.
  #pod
  #pod If the option specification contains a third element, it adds extra constraints
  #pod or modifiers to the interpretation and validation of the value.  These are the
  #pod keys that may be present in that hashref, and how they behave:
  #pod
  #pod =over 4
  #pod
  #pod =item implies
  #pod
  #pod   implies => 'bar'
  #pod   implies => [qw(foo bar)]
  #pod   implies => { foo => 1, bar => 2 }
  #pod
  #pod If option I<A> has an "implies" entry, then if I<A> is given, other options
  #pod will be enabled.  The value may be a single option to set, an arrayref of
  #pod options to set, or a hashref of options to set to specific values.
  #pod
  #pod =item required
  #pod
  #pod   required => 1
  #pod
  #pod If an option is required, failure to provide the option will result in
  #pod C<describe_options> printing the usage message and exiting.
  #pod
  #pod =item hidden
  #pod
  #pod   hidden => 1
  #pod
  #pod This option will not show up in the usage text.
  #pod
  #pod You can achieve the same behavior by using the string "hidden" for the option's
  #pod description.
  #pod
  #pod =item one_of
  #pod
  #pod   one_of => \@subopt_specs
  #pod
  #pod This is useful for a group of options that are related.  Each option
  #pod spec is added to the list for normal parsing and validation.
  #pod
  #pod Your option name will end up with a value of the name of the
  #pod option that was chosen.  For example, given the following spec:
  #pod
  #pod   [ "mode" => hidden => { one_of => [
  #pod     [ "get|g"  => "get the value" ],
  #pod     [ "set|s"  => "set the value" ],
  #pod     [ "delete" => "delete it" ],
  #pod   ] } ],
  #pod
  #pod No usage text for 'mode' will be displayed, but text for get, set, and delete
  #pod will be displayed.
  #pod
  #pod If more than one of get, set, or delete is given, an error will be thrown.
  #pod
  #pod So, given the C<@opt_spec> above, and an C<@ARGV> of C<('--get')>, the
  #pod following would be true:
  #pod
  #pod   $opt->get == 1;
  #pod
  #pod   $opt->mode eq 'get';
  #pod
  #pod B<Note>: C<get> would not be set if C<mode> defaulted to 'get' and no arguments
  #pod were passed in.
  #pod
  #pod Even though the option sub-specs for C<one_of> are meant to be 'first
  #pod class' specs, some options don't make sense with them, e.g. C<required>.
  #pod
  #pod As a further shorthand, you may specify C<one_of> options using this form:
  #pod
  #pod   [ mode => \@option_specs, \%constraints ]
  #pod
  #pod
  #pod =item shortcircuit
  #pod
  #pod   shortcircuit => 1
  #pod
  #pod If this option is present no other options will be returned.  Other
  #pod options present will be checked for proper types, but I<not> for
  #pod constraints.  This provides a way of specifying C<--help> style options.
  #pod
  #pod =item Params::Validate
  #pod
  #pod In addition, any constraint understood by Params::Validate may be used.
  #pod
  #pod For example, to accept positive integers:
  #pod
  #pod   [ 'max-iterations=i', "maximum number of iterations",
  #pod     { callbacks => { positive => sub { shift() > 0 } } } ],
  #pod
  #pod (Internally, all constraints are translated into Params::Validate options or
  #pod callbacks.)
  #pod
  #pod =back
  #pod
  #pod =head3 %arg
  #pod
  #pod The C<%arg> to C<describe_options> is optional.  If the last parameter is a
  #pod hashref, it contains extra arguments to modify the way C<describe_options>
  #pod works.  Valid arguments are:
  #pod
  #pod   getopt_conf   - an arrayref of strings, passed to Getopt::Long::Configure
  #pod   show_defaults - a boolean which controls whether an option's default
  #pod                   value (if applicable) is shown as part of the usage message
  #pod                   (for backward compatibility this defaults to false)
  #pod
  #pod =head2 prog_name
  #pod
  #pod This routine, exported on demand, returns the basename of C<$0>, grabbed at
  #pod compile-time.  You can override this guess by calling C<prog_name($string)>
  #pod yourself.
  #pod
  #pod =head1 OTHER EXPORTS
  #pod
  #pod =head2 C<-types>
  #pod
  #pod Any of the Params::Validate type constants (C<SCALAR>, etc.) can be imported as
  #pod well.  You can get all of them at once by importing C<-types>.
  #pod
  #pod =head2 C<-all>
  #pod
  #pod This import group will import C<-type>, C<describe_options>, and C<prog_name>.
  #pod
  #pod =cut
  
  my $prog_name;
  sub prog_name { @_ ? ($prog_name = shift) : $prog_name }
  
  BEGIN {
    # grab this before someone decides to change it
    prog_name(File::Basename::basename($0));
  }
  
  use Sub::Exporter::Util ();
  use Sub::Exporter 0.972 -setup => {
    exports => [
      describe_options => \'_build_describe_options',
      q(prog_name),
      @{ $Params::Validate::EXPORT_TAGS{types} }
    ],
    groups  => [
      default => [ qw(describe_options) ],
      types   => $Params::Validate::EXPORT_TAGS{types},
    ],
  };
  
  my %CONSTRAINT = (
    implies  => \&_mk_implies,
    required => { optional => 0 },
    only_one => \&_mk_only_one,
  );
  
  our $MungeOptions = 1;
  
  sub _nohidden {
    return grep { ! $_->{constraint}->{hidden} } @_;
  }
  
  sub _expand {
    my @expanded;
  
    for my $opt (@_) {
      push @expanded, {
        spec       => $opt->[0] || '',
        desc       => @$opt > 1 ? $opt->[1] : 'spacer',
        constraint => $opt->[2] || {},
  
        # if @$_ is 0 then we got [], a spacer
        name       => @$opt ? _munge((split /[:=|!+]/, $opt->[0] || '')[0]) : '',
      };
    }
  
    return @expanded;
  }
  
  my %HIDDEN = (
    hidden => 1,
  );
  
  my $SPEC_RE = qr{(?:[:=][0-9\w\+]+[%@]?(\{[0-9]*,[0-9]*\})?|[!+])$};
  sub _strip_assignment {
    my ($self, $str) = @_;
  
    (my $copy = $str) =~ s{$SPEC_RE}{};
  
    if (wantarray) {
        my $len = length $copy;
        my $assignment = substr $str, $len;
        if (!defined($assignment)) {
            $assignment = '';
        }
        return ($copy, $assignment);
    }
    return $copy;
  }
  
  # This is here only to deal with people who were calling this fully-qualified
  # without importing.  Sucks to them!  -- rjbs, 2009-08-21
  sub describe_options {
    my $sub = __PACKAGE__->_build_describe_options(describe_options => {} => {});
    $sub->(@_);
  }
  
  sub usage_class { 'Getopt::Long::Descriptive::Usage' }
  
  sub _build_describe_options {
    my ($class) = @_;
  
    sub {
      my $format = shift;
      my $arg    = (ref $_[-1] and ref $_[-1] eq 'HASH') ? pop @_ : {};
      my @opts;
  
      my %parent_of;
  
      # special casing
      # wish we had real loop objects
      my %method_map;
      for my $opt (_expand(@_)) {
        $method_map{ $opt->{name} } = undef unless $opt->{desc} eq 'spacer';
  
        if (ref($opt->{desc}) eq 'ARRAY') {
          $opt->{constraint}->{one_of} = delete $opt->{desc};
          $opt->{desc} = 'hidden';
        }
  
        if ($HIDDEN{$opt->{desc}}) {
          $opt->{constraint}->{hidden}++;
        }
  
        if ($opt->{constraint}->{one_of}) {
          for my $one_opt (_expand(
            @{delete $opt->{constraint}->{one_of}}
          )) {
            $parent_of{$one_opt->{name}} = $opt->{name};
            $one_opt->{constraint}->{implies}
              ->{$opt->{name}} = $one_opt->{name};
            for my $wipe (qw(required default)) {
              if ($one_opt->{constraint}->{$wipe}) {
                carp "'$wipe' constraint does not make sense in sub-option";
                delete $one_opt->{constraint}->{$wipe};
              }
            }
            $one_opt->{constraint}->{one_of} = $opt->{name};
            push @opts, $one_opt;
          }
        }
  
        if ($opt->{constraint}{shortcircuit}
          && exists $opt->{constraint}{default}
        ) {
          carp('option "' . $opt->{name} . q[": 'default' does not make sense for shortcircuit options]);
        }
  
        push @opts, $opt;
      }
  
      my @go_conf = @{ $arg->{getopt_conf} || $arg->{getopt} || [] };
      if ($arg->{getopt}) {
        warn "describe_options: 'getopt' is deprecated, please use 'getopt_conf' instead\n";
      }
  
      push @go_conf, "bundling" unless grep { /bundling/i } @go_conf;
      push @go_conf, "no_auto_help"  unless grep { /no_auto_help/i } @go_conf;
      push @go_conf, "no_ignore_case"
        unless grep { /no_ignore_case/i } @go_conf;
  
      # not entirely sure that all of this (until the Usage->new) shouldn't be
      # moved into Usage -- rjbs, 2009-08-19
  
      # all specs including hidden
      my @getopt_specs =
        map  { $_->{spec} }
        grep { $_->{desc} ne 'spacer' }
        @opts;
  
      my @specs =
        map  { $_->{spec} }
        grep { $_->{desc} ne 'spacer' }
        _nohidden(@opts);
  
      my $short = join q{},
        sort  { lc $a cmp lc $b or $a cmp $b }
        grep  { /^.$/ }
        map   { split /\|/ }
        map   { scalar __PACKAGE__->_strip_assignment($_) }
        @specs;
  
      my $long = grep /\b[^|]{2,}/, @specs;
  
      my %replace = (
        "%" => "%",
        "c" => prog_name,
        "o" => join(q{ },
          ($short ? "[-$short]" : ()),
          ($long  ? "[long options...]" : ())
        ),
      );
  
      (my $str = $format) =~ s<%(.)><
        defined $replace{$1}
        ? $replace{$1}
        : Carp::croak("unknown sequence %$1 in first argument to describe_options")
      >ge;
  
      $str =~ s/[\x20\t]{2,}/ /g;
  
      my $usage = $class->usage_class->new({
        options       => [ _nohidden(@opts) ],
        leader_text   => $str,
        show_defaults => $arg->{show_defaults},
      });
  
      Getopt::Long::Configure(@go_conf);
  
      my %return;
      $usage->die unless GetOptions(\%return, grep { length } @getopt_specs);
      my @given_keys = keys %return;
  
      for my $opt (keys %return) {
        my $newopt = _munge($opt);
        next if $newopt eq $opt;
        $return{$newopt} = delete $return{$opt};
      }
  
      # ensure that shortcircuit options are handled first
      for my $copt (
        sort {     ($b->{constraint}{shortcircuit} || 0)
               <=> ($a->{constraint}{shortcircuit} || 0)
             } grep { $_->{constraint} } @opts
      ) {
        delete $copt->{constraint}->{hidden};
        my $is_shortcircuit = delete $copt->{constraint}{shortcircuit};
        my $name = $copt->{name};
        my $new  = _validate_with(
          name   => $name,
          params => \%return,
          spec   => $copt->{constraint},
          opts   => \@opts,
          usage  => $usage,
          given_keys => \@given_keys,
          parent_of  => \%parent_of,
        );
        next unless (defined($new) || exists($return{$name}));
        $return{$name} = $new;
  
        if ($is_shortcircuit) {
          %return = ($name => $return{$name});
          last;
        }
      }
  
      my $opt_obj = Getopt::Long::Descriptive::Opts->___new_opt_obj({
        values => { %method_map, %return },
        given  => { map {; $_ => 1 } @given_keys },
      });
  
      return($opt_obj, $usage);
    }
  }
  
  sub _munge {
    my ($opt) = @_;
    return $opt unless $MungeOptions;
    $opt = lc($opt);
    $opt =~ tr/-/_/;
    return $opt;
  }
  
  sub _validate_with {
    my (%arg) = validate(@_, {
      name   => 1,
      params => 1,
      spec   => 1,
      opts   => 1,
      usage  => 1,
      given_keys => 1,
      parent_of  => 1,
    });
  
    my $spec = $arg{spec};
    my %pvspec;
    for my $ct (keys %{$spec}) {
      if ($CONSTRAINT{$ct} and ref $CONSTRAINT{$ct} eq 'CODE') {
        $pvspec{callbacks} ||= {};
        $pvspec{callbacks} = {
          %{$pvspec{callbacks}},
          $CONSTRAINT{$ct}->(
            $arg{name},
            $spec->{$ct},
            $arg{params},
            $arg{opts},
          ),
        };
      } else {
        %pvspec = (
          %pvspec,
          $CONSTRAINT{$ct} ? %{$CONSTRAINT{$ct}} : ($ct => $spec->{$ct}),
        );
      }
    }
  
    $pvspec{optional} = 1 unless exists $pvspec{optional};
  
    # we need to implement 'default' by ourselves sometimes
    # because otherwise the implies won't be checked/executed
    # XXX this should be more generic -- we'll probably want
    # other callbacks to always run, too
    if (!defined($arg{params}{$arg{name}})
          && $pvspec{default}
            && $spec->{implies}) {
  
      $arg{params}{$arg{name}} = delete $pvspec{default};
    }
  
    my %p;
    my $ok = eval {
      %p = validate_with(
        params => [
          %{$arg{params}},
          '-given_keys', $arg{given_keys},
          '-parent_of',  $arg{parent_of},
        ],
        spec   => { $arg{name} => \%pvspec },
        allow_extra => 1,
        on_fail     => sub {
          my $fail_msg = shift;
          Getopt::Long::Descriptive::_PV_Error->throw($fail_msg);
        },
      );
      1;
    };
  
    if (! $ok) {
      my $error = $@;
      if (
        Scalar::Util::blessed($error)
        && $error->isa('Getopt::Long::Descriptive::_PV_Error')
      ) {
        $arg{usage}->die({ pre_text => $error->error . "\n" });
      }
  
      die $@;
    }
  
    return $p{$arg{name}};
  }
  
  # scalar:   single option = true
  # arrayref: multiple options = true
  # hashref:  single/multiple options = given values
  sub _norm_imply {
    my ($what) = @_;
  
    return { $what => 1 } unless my $ref = ref $what;
  
    return $what                      if $ref eq 'HASH';
    return { map { $_ => 1 } @$what } if $ref eq 'ARRAY';
  
    die "can't imply: $what";
  }
  
  sub _mk_implies {
    my $name = shift;
    my $what = _norm_imply(shift);
    my $param = shift;
    my $opts  = shift;
  
    for my $implied (keys %$what) {
      die("option specification for $name implies nonexistent option $implied\n")
        unless first { $_->{name} eq $implied } @$opts
    }
  
    my $whatstr = join(q{, }, map { "$_=$what->{$_}" } keys %$what);
  
    return "$name implies $whatstr" => sub {
      my ($pv_val, $rest) = @_;
  
      # negatable options will be 0 here, which is ok.
      return 1 unless defined $pv_val;
  
      while (my ($key, $val) = each %$what) {
        # Really, this should be called "-implies" and should include all implies
        # relationships, but they'll have to get handled by setting conflicts.
        my $parent   = $rest->{'-parent_of'}{$name};
        my @siblings = $parent
                     ? (grep {; defined $rest->{'-parent_of'}{$_}
                                && $rest->{'-parent_of'}{$_} eq $parent }
                        @{ $rest->{'-given_keys'} })
                     : ();
  
        if (@siblings > 1) {
          die "these options conflict; each wants to set the $parent: @siblings\n";
        }
  
        if (  exists $param->{$key}
          and $param->{$key} ne $val
          and grep {; $_ eq $key } @{ $rest->{'-given_keys'} }
        ) {
          die(
            "option specification for $name implies that $key should be "
            . "set to '$val', but it is '$param->{$key}' already\n"
          );
        }
        $param->{$key} = $val;
      }
  
      return 1;
    };
  }
  
  sub _mk_only_one {
    die "unimplemented";
  }
  
  {
    package
      Getopt::Long::Descriptive::_PV_Error;
    sub error { $_[0]->{error} }
    sub throw {
      my ($class, $error_msg) = @_;
      my $self = { error => $error_msg };
      bless $self, $class;
      die $self;
    }
  }
  
  #pod =head1 CUSTOMIZING
  #pod
  #pod Getopt::Long::Descriptive uses L<Sub::Exporter|Sub::Exporter> to build and
  #pod export the C<describe_options> routine.  By writing a new class that extends
  #pod Getopt::Long::Descriptive, the behavior of the constructed C<describe_options>
  #pod routine can be changed.
  #pod
  #pod The following methods can be overridden:
  #pod
  #pod =head2 usage_class
  #pod
  #pod   my $class = Getopt::Long::Descriptive->usage_class;
  #pod
  #pod This returns the class to be used for constructing a Usage object, and defaults
  #pod to Getopt::Long::Descriptive::Usage.
  #pod
  #pod =head1 SEE ALSO
  #pod
  #pod =for :list
  #pod * L<Getopt::Long>
  #pod * L<Params::Validate>
  #pod
  #pod =cut
  
  1; # End of Getopt::Long::Descriptive
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Getopt::Long::Descriptive - Getopt::Long, but simpler and more powerful
  
  =head1 VERSION
  
  version 0.102
  
  =head1 SYNOPSIS
  
    use Getopt::Long::Descriptive;
  
    my ($opt, $usage) = describe_options(
      'my-program %o <some-arg>',
      [ 'server|s=s', "the server to connect to", { required => 1  } ],
      [ 'port|p=i',   "the port to connect to",   { default  => 79 } ],
      [],
      [ 'verbose|v',  "print extra stuff"            ],
      [ 'help',       "print usage message and exit", { shortcircuit => 1 } ],
    );
  
    print($usage->text), exit if $opt->help;
  
    Client->connect( $opt->server, $opt->port );
  
    print "Connected!\n" if $opt->verbose;
  
  ...and running C<my-program --help> will produce:
  
    my-program [-psv] [long options...] <some-arg>
      -s --server     the server to connect to
      -p --port       the port to connect to
  
      -v --verbose    print extra stuff
      --help          print usage message and exit
  
  =head1 DESCRIPTION
  
  Getopt::Long::Descriptive is yet another Getopt library.  It's built atop
  Getopt::Long, and gets a lot of its features, but tries to avoid making you
  think about its huge array of options.
  
  It also provides usage (help) messages, data validation, and a few other useful
  features.
  
  =head1 FUNCTIONS
  
  Getopt::Long::Descriptive only exports one routine by default:
  C<describe_options>.  All GLD's exports are exported by L<Sub::Exporter>.
  
  =head2 describe_options
  
    my ($opt, $usage) = describe_options($usage_desc, @opt_spec, \%arg);
  
  This routine inspects C<@ARGV> for options that match the supplied spec. If all
  the options are valid then it returns the options given and an object for
  generating usage messages; if not then it dies with an explanation of what was
  wrong and a usage message.
  
  The C<$opt> object will be a dynamically-generated subclass of
  L<Getopt::Long::Descriptive::Opts>.  In brief, each of the options in
  C<@opt_spec> becomes an accessor method on the object, using the first-given
  name, with dashes converted to underscores.  For more information, see the
  documentation for the Opts class.
  
  The C<$usage> object will be a L<Getopt::Long::Descriptive::Usage> object,
  which provides a C<text> method to get the text of the usage message and C<die>
  to die with it.  For more methods and options, consults the documentation for
  the Usage class.
  
  =head3 $usage_desc
  
  The C<$usage_desc> parameter to C<describe_options> is a C<sprintf>-like string
  that is used in generating the first line of the usage message.  It's a
  one-line summary of how the command is to be invoked.  A typical usage
  description might be:
  
    $usage_desc = "%c %o <source> <desc>";
  
  C<%c> will be replaced with what Getopt::Long::Descriptive thinks is the
  program name (it's computed from C<$0>, see L</prog_name>).
  
  C<%o> will be replaced with a list of the short options, as well as the text
  "[long options...]" if any have been defined.
  
  The rest of the usage description can be used to summarize what arguments are
  expected to follow the program's options, and is entirely free-form.
  
  Literal C<%> characters will need to be written as C<%%>, just like with
  C<sprintf>.
  
  =head3 @opt_spec
  
  The C<@opt_spec> part of the args to C<describe_options> is used to configure
  option parsing and to produce the usage message.  Each entry in the list is an
  arrayref describing one option, like this:
  
    @opt_spec = (
      [ "verbose|V" => "be noisy"       ],
      [ "logfile=s" => "file to log to" ],
    );
  
  The first value in the arrayref is a Getopt::Long-style option specification.
  In brief, they work like this:  each one is a pipe-delimited list of names,
  optionally followed by a type declaration.  Type declarations are '=x' or ':x',
  where C<=> means a value is required and C<:> means it is optional.  I<x> may
  be 's' to indicate a string is required, 'i' for an integer, or 'f' for a
  number with a fractional part.  The type spec may end in C<@> to indicate that
  the option may appear multiple times.
  
  For more information on how these work, see the L<Getopt::Long> documentation.
  
  The first name given should be the canonical name, as it will be used as the
  accessor method on the C<$opt> object.  Dashes in the name will be converted to
  underscores, and all letters will be lowercased.  For this reason, all options
  should generally have a long-form name.
  
  The second value in the arrayref is a description of the option, for use in the
  usage message.
  
  =head4 Special Option Specifications
  
  If the option specification (arrayref) is empty, it will have no effect other
  than causing a blank line to appear in the usage message.
  
  If the option specification contains only one element, it will be printed in
  the usage message with no other effect.
  
  If the option specification contains a third element, it adds extra constraints
  or modifiers to the interpretation and validation of the value.  These are the
  keys that may be present in that hashref, and how they behave:
  
  =over 4
  
  =item implies
  
    implies => 'bar'
    implies => [qw(foo bar)]
    implies => { foo => 1, bar => 2 }
  
  If option I<A> has an "implies" entry, then if I<A> is given, other options
  will be enabled.  The value may be a single option to set, an arrayref of
  options to set, or a hashref of options to set to specific values.
  
  =item required
  
    required => 1
  
  If an option is required, failure to provide the option will result in
  C<describe_options> printing the usage message and exiting.
  
  =item hidden
  
    hidden => 1
  
  This option will not show up in the usage text.
  
  You can achieve the same behavior by using the string "hidden" for the option's
  description.
  
  =item one_of
  
    one_of => \@subopt_specs
  
  This is useful for a group of options that are related.  Each option
  spec is added to the list for normal parsing and validation.
  
  Your option name will end up with a value of the name of the
  option that was chosen.  For example, given the following spec:
  
    [ "mode" => hidden => { one_of => [
      [ "get|g"  => "get the value" ],
      [ "set|s"  => "set the value" ],
      [ "delete" => "delete it" ],
    ] } ],
  
  No usage text for 'mode' will be displayed, but text for get, set, and delete
  will be displayed.
  
  If more than one of get, set, or delete is given, an error will be thrown.
  
  So, given the C<@opt_spec> above, and an C<@ARGV> of C<('--get')>, the
  following would be true:
  
    $opt->get == 1;
  
    $opt->mode eq 'get';
  
  B<Note>: C<get> would not be set if C<mode> defaulted to 'get' and no arguments
  were passed in.
  
  Even though the option sub-specs for C<one_of> are meant to be 'first
  class' specs, some options don't make sense with them, e.g. C<required>.
  
  As a further shorthand, you may specify C<one_of> options using this form:
  
    [ mode => \@option_specs, \%constraints ]
  
  =item shortcircuit
  
    shortcircuit => 1
  
  If this option is present no other options will be returned.  Other
  options present will be checked for proper types, but I<not> for
  constraints.  This provides a way of specifying C<--help> style options.
  
  =item Params::Validate
  
  In addition, any constraint understood by Params::Validate may be used.
  
  For example, to accept positive integers:
  
    [ 'max-iterations=i', "maximum number of iterations",
      { callbacks => { positive => sub { shift() > 0 } } } ],
  
  (Internally, all constraints are translated into Params::Validate options or
  callbacks.)
  
  =back
  
  =head3 %arg
  
  The C<%arg> to C<describe_options> is optional.  If the last parameter is a
  hashref, it contains extra arguments to modify the way C<describe_options>
  works.  Valid arguments are:
  
    getopt_conf   - an arrayref of strings, passed to Getopt::Long::Configure
    show_defaults - a boolean which controls whether an option's default
                    value (if applicable) is shown as part of the usage message
                    (for backward compatibility this defaults to false)
  
  =head2 prog_name
  
  This routine, exported on demand, returns the basename of C<$0>, grabbed at
  compile-time.  You can override this guess by calling C<prog_name($string)>
  yourself.
  
  =head1 OTHER EXPORTS
  
  =head2 C<-types>
  
  Any of the Params::Validate type constants (C<SCALAR>, etc.) can be imported as
  well.  You can get all of them at once by importing C<-types>.
  
  =head2 C<-all>
  
  This import group will import C<-type>, C<describe_options>, and C<prog_name>.
  
  =head1 CUSTOMIZING
  
  Getopt::Long::Descriptive uses L<Sub::Exporter|Sub::Exporter> to build and
  export the C<describe_options> routine.  By writing a new class that extends
  Getopt::Long::Descriptive, the behavior of the constructed C<describe_options>
  routine can be changed.
  
  The following methods can be overridden:
  
  =head2 usage_class
  
    my $class = Getopt::Long::Descriptive->usage_class;
  
  This returns the class to be used for constructing a Usage object, and defaults
  to Getopt::Long::Descriptive::Usage.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<Getopt::Long>
  
  =item *
  
  L<Params::Validate>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Hans Dieter Pearcey <hdp@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Arthur Axel 'fREW' Schmidt Dave Rolsky Diab Jerius Hans Dieter Pearcey Harley Pig hdp@cpan.org Karen Etheridge Niels Thykier Olaf Alders Roman Hubacek Smylers Thomas Neumann zhouzhen1
  
  =over 4
  
  =item *
  
  Arthur Axel 'fREW' Schmidt <frioux@gmail.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Diab Jerius <djerius@cfa.harvard.edu>
  
  =item *
  
  Hans Dieter Pearcey <hdp@pobox.com>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Harley Pig <harleypig@gmail.com>
  
  =item *
  
  hdp@cpan.org <hdp@cpan.org@fc0e91e4-031c-0410-8307-be39b06d7656>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Niels Thykier <niels@thykier.net>
  
  =item *
  
  Olaf Alders <olaf@wundersolutions.com>
  
  =item *
  
  Roman Hubacek <roman.hubacek@centrum.cz>
  
  =item *
  
  Smylers <SMYLERS@cpan.fsck.com>
  
  =item *
  
  Thomas Neumann <blacky+perl@fluffbunny.de>
  
  =item *
  
  zhouzhen1 <zhouzhen1@gmail.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2005 by Hans Dieter Pearcey.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
GETOPT_LONG_DESCRIPTIVE

$fatpacked{"Getopt/Long/Descriptive/Opts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG_DESCRIPTIVE_OPTS';
  use strict;
  use warnings;
  package Getopt::Long::Descriptive::Opts;
  # ABSTRACT: object representing command line switches
  $Getopt::Long::Descriptive::Opts::VERSION = '0.102';
  use Scalar::Util qw(blessed weaken);
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This class is the base class of all C<$opt> objects returned by
  #pod L<Getopt::Long::Descriptive>.  In general, you do not want to think about this
  #pod class, look at it, or alter it.  Seriously, it's pretty dumb.
  #pod
  #pod Every call to C<describe_options> will return a object of a new subclass of
  #pod this class.  It will have a method for the canonical name of each option
  #pod possible given the option specifications.
  #pod
  #pod Method names beginning with an single underscore are public, and are named that
  #pod way to avoid conflict with automatically generated methods.  Methods with
  #pod multiple underscores (in case you're reading the source) are private.
  #pod
  #pod =head1 METHODS
  #pod
  #pod B<Achtung!>  All methods beginning with an underscore are experimental as of
  #pod today, 2009-12-12.  They are likely to be formally made permanent soon.
  #pod
  #pod =head2 _specified
  #pod
  #pod This method returns true if the given name was specified on the command line.
  #pod
  #pod For example, if C<@ARGS> was "C<< --foo --bar 10 >>" and C<baz> is defined by a
  #pod default, C<_specified> will return true for foo and bar, and false for baz.
  #pod
  #pod =cut
  
  my %_CREATED_OPTS;
  my $SERIAL_NUMBER = 1;
  
  sub _specified {
    my ($self, $name) = @_;
    my $meta = $_CREATED_OPTS{ blessed $self }{meta};
    return $meta->{given}{ $name };
  }
  
  #pod =head2 _specified_opts
  #pod
  #pod This method returns an opt object in which only explicitly specified values are
  #pod defined.  Values which were set by defaults will appear undef.
  #pod
  #pod =cut
  
  sub _specified_opts {
    my ($self) = @_;
  
    my $class = blessed $self;
    my $meta = $_CREATED_OPTS{ $class  }{meta};
  
    return $meta->{specified_opts} if $meta->{specified_opts};
  
    my @keys = grep { $meta->{given}{ $_ } } (keys %{ $meta->{given} });
  
    my %opts;
    @opts{ @keys } = @$self{ @keys };
  
    $meta->{specified_opts} = \%opts;
  
    bless $meta->{specified_opts} => $class;
    weaken $meta->{specified_opts};
  
    $meta->{specified_opts};
  }
  
  #pod =head2 _complete_opts
  #pod
  #pod This method returns the opts object with all values, including those set by
  #pod defaults.  It is probably not going to be very often-used.
  #pod
  #pod =cut
  
  sub _complete_opts {
    my ($self) = @_;
  
    my $class = blessed $self;
    my $meta = $_CREATED_OPTS{ $class  }{meta};
    return $meta->{complete_opts};
  }
  
  sub ___class_for_opt {
    my ($class, $arg) = @_;
  
    my $values = $arg->{values};
    my @bad = grep { $_ !~ /^[a-z_]\w*$/ } keys %$values;
    Carp::confess("perverse option names given: @bad") if @bad;
  
    my $new_class = "$class\::__OPT__::" . $SERIAL_NUMBER++;
    $_CREATED_OPTS{ $new_class } = { meta => $arg };
  
    {
      no strict 'refs';
      ${"$new_class\::VERSION"} = $class->VERSION;
      *{"$new_class\::ISA"} = [ 'Getopt::Long::Descriptive::Opts' ];
      for my $opt (keys %$values) {
        *{"$new_class\::$opt"} = sub { $_[0]->{ $opt } };
      }
    }
  
    return $new_class;
  }
  
  sub ___new_opt_obj {
    my ($class, $arg) = @_;
  
    my $copy = { %{ $arg->{values} } };
  
    my $new_class = $class->___class_for_opt($arg);
  
    # This is stupid, but the traditional behavior was that if --foo was not
    # given, there is no $opt->{foo}; it started to show up when we "needed" all
    # the keys to generate a class, but was undef; this wasn't a problem, but
    # broke tests of things that were relying on not-exists like tests of %$opt
    # contents or MooseX::Getopt which wanted to use things as args for new --
    # undef would not pass an Int TC.  Easier to just do this. -- rjbs,
    # 2009-11-27
    delete $copy->{$_} for grep { ! defined $copy->{$_} } keys %$copy;
  
    my $self = bless $copy => $new_class;
  
    $_CREATED_OPTS{ $new_class }{meta}{complete_opts} = $self;
    # weaken $_CREATED_OPTS{ $new_class }{meta}{complete_opts};
  
    return $self;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Getopt::Long::Descriptive::Opts - object representing command line switches
  
  =head1 VERSION
  
  version 0.102
  
  =head1 DESCRIPTION
  
  This class is the base class of all C<$opt> objects returned by
  L<Getopt::Long::Descriptive>.  In general, you do not want to think about this
  class, look at it, or alter it.  Seriously, it's pretty dumb.
  
  Every call to C<describe_options> will return a object of a new subclass of
  this class.  It will have a method for the canonical name of each option
  possible given the option specifications.
  
  Method names beginning with an single underscore are public, and are named that
  way to avoid conflict with automatically generated methods.  Methods with
  multiple underscores (in case you're reading the source) are private.
  
  =head1 METHODS
  
  B<Achtung!>  All methods beginning with an underscore are experimental as of
  today, 2009-12-12.  They are likely to be formally made permanent soon.
  
  =head2 _specified
  
  This method returns true if the given name was specified on the command line.
  
  For example, if C<@ARGS> was "C<< --foo --bar 10 >>" and C<baz> is defined by a
  default, C<_specified> will return true for foo and bar, and false for baz.
  
  =head2 _specified_opts
  
  This method returns an opt object in which only explicitly specified values are
  defined.  Values which were set by defaults will appear undef.
  
  =head2 _complete_opts
  
  This method returns the opts object with all values, including those set by
  defaults.  It is probably not going to be very often-used.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Hans Dieter Pearcey <hdp@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2005 by Hans Dieter Pearcey.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
GETOPT_LONG_DESCRIPTIVE_OPTS

$fatpacked{"Getopt/Long/Descriptive/Usage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG_DESCRIPTIVE_USAGE';
  use strict;
  use warnings;
  package Getopt::Long::Descriptive::Usage;
  # ABSTRACT: the usage description for GLD
  $Getopt::Long::Descriptive::Usage::VERSION = '0.102';
  use List::Util qw(max);
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   use Getopt::Long::Descriptive;
  #pod   my ($opt, $usage) = describe_options( ... );
  #pod
  #pod   $usage->text; # complete usage message
  #pod
  #pod   $usage->die;  # die with usage message
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This document only describes the methods of the Usage object.  For information
  #pod on how to use L<Getopt::Long::Descriptive>, consult its documentation.
  #pod
  #pod =head1 METHODS
  #pod
  #pod =head2 new
  #pod
  #pod   my $usage = Getopt::Long::Descriptive::Usage->new(\%arg);
  #pod
  #pod You B<really> don't need to call this.  GLD will do it for you.
  #pod
  #pod Valid arguments are:
  #pod
  #pod   options     - an arrayref of options
  #pod   leader_text - the text that leads the usage; this may go away!
  #pod
  #pod =cut
  
  sub new {
    my ($class, $arg) = @_;
  
    my @to_copy = qw(leader_text options show_defaults);
  
    my %copy;
    @copy{ @to_copy } = @$arg{ @to_copy };
  
    bless \%copy => $class;
  }
  
  #pod =head2 text
  #pod
  #pod This returns the full text of the usage message.
  #pod
  #pod =cut
  
  sub text {
    my ($self) = @_;
  
    return join qq{\n}, $self->leader_text, $self->option_text;
  }
  
  #pod =head2 leader_text
  #pod
  #pod This returns the text that comes at the beginning of the usage message.
  #pod
  #pod =cut
  
  sub leader_text { $_[0]->{leader_text} }
  
  #pod =head2 option_text
  #pod
  #pod This returns the text describing the available options.
  #pod
  #pod =cut
  
  sub option_text {
    my ($self) = @_;
  
    my @options  = @{ $self->{options} || [] };
    my $string   = q{};
    my @specs = map { $_->{spec} } grep { $_->{desc} ne 'spacer' } @options;
    my $length   = (max(map { _option_length($_) } @specs) || 0);
    my $spec_fmt = "\t%-${length}s";
  
    while (@options) {
      my $opt  = shift @options;
      my $spec = $opt->{spec};
      my $desc = $opt->{desc};
      my $assign;
      if ($desc eq 'spacer') {
        my @lines = $self->_split_description($length, $opt->{spec});
  
        $string .= length($_) ? sprintf("$spec_fmt\n", $_) : "\n" for @lines;
        next;
      }
  
      ($spec, $assign) = Getopt::Long::Descriptive->_strip_assignment($spec);
      $assign = _parse_assignment($assign);
      $spec = join " ", reverse map { length > 1 ? "--${_}$assign" : "-${_}$assign" }
                                split /\|/, $spec;
  
      my @desc = $self->_split_description($length, $desc);
  
      # add default value if it exists
      if (exists $opt->{constraint}->{default} and $self->{show_defaults}) {
        my $dflt = $opt->{constraint}->{default};
        $dflt = ! defined $dflt ? '(undef)'
              : ! length  $dflt ? '(empty string)'
              :                   $dflt;
        push @desc, "(default value: $dflt)";
      }
  
      $string .= sprintf "$spec_fmt  %s\n", $spec, shift @desc;
      for my $line (@desc) {
          $string .= "\t";
          $string .= q{ } x ( $length + 2 );
          $string .= "$line\n";
      }
    }
  
    return $string;
  }
  
  sub _option_length {
      my ($fullspec) = @_;
      my $number_opts = 1;
      my $last_pos = 0;
      my $number_shortopts = 0;
      my ($spec, $argspec) = Getopt::Long::Descriptive->_strip_assignment($fullspec);
      my $length = length $spec;
      my $arglen = length(_parse_assignment($argspec));
  
      # Spacing rules:
      #
      # For short options we want 1 space (for '-'), for long options 2
      # spaces (for '--').  Then one space for separating the options,
      # but we here abuse that $spec has a '|' char for that.
      #
      # For options that take arguments, we want 2 spaces for mandatory
      # options ('=X') and 4 for optional arguments ('[=X]').  Note we
      # consider {N,M} cases as "single argument" atm.
  
      # Count the number of "variants" (e.g. "long|s" has two variants)
      while ($spec =~ m{\|}g) {
          $number_opts++;
          if (pos($spec) - $last_pos == 2) {
              $number_shortopts++;
          }
          $last_pos = pos($spec);
      }
  
      # Was the last option a "short" one?
      if ($length - $last_pos == 1) {
          $number_shortopts++;
      }
  
      # We got $number_opts options, each with an argument length of
      # $arglen.  Plus each option (after the first) needs 3 a char
      # spacing.  $length gives us the total length of all options and 1
      # char spacing per option (after the first).  So the result should be:
  
      my $number_longopts = $number_opts - $number_shortopts;
      my $total_arglen = $number_opts * $arglen;
      my $total_optsep = 2 * $number_longopts + $number_shortopts;
      my $total = $length + $total_optsep + $total_arglen;
      return $total;
  }
  
  sub _split_description {
    my ($self, $length, $desc) = @_;
  
    # 8 for a tab, 2 for the space between option & desc;
    my $max_length = 78 - ( $length + 8 + 2 );
  
    return $desc if length $desc <= $max_length;
  
    my @lines;
    while (length $desc > $max_length) {
      my $idx = rindex( substr( $desc, 0, $max_length ), q{ }, );
      last unless $idx >= 0;
      push @lines, substr($desc, 0, $idx);
      substr($desc, 0, $idx + 1) = q{};
    }
    push @lines, $desc;
  
    return @lines;
  }
  
  sub _parse_assignment {
      my ($assign_spec) = @_;
  
      my $result = 'STR';
      my $desttype;
      if (length($assign_spec) < 2) {
          # empty, ! or +
          return '';
      }
  
      my $optional = substr($assign_spec, 0, 1) eq ':';
      my $argument = substr $assign_spec, 1, 2;
  
      if ($argument =~ m/^[io]/ or $assign_spec =~ m/^:[+0-9]/) {
          $result = 'INT';
      } elsif ($argument =~ m/^f/) {
          $result = 'NUM';
      }
  
      if (length($assign_spec) > 2) {
          $desttype = substr($assign_spec, 2, 1);
          if ($desttype eq '@') {
              # Imply it can be repeated
              $result .= '...';
          } elsif ($desttype eq '%') {
              $result = "KEY=${result}...";
          }
      }
  
      if ($optional) {
          return "[=$result]";
      }
  
      # with leading space so it can just blindly be appended.
      return " $result";
  }
  
  #pod =head2 warn
  #pod
  #pod This warns with the usage message.
  #pod
  #pod =cut
  
  sub warn { warn shift->text }
  
  #pod =head2 die
  #pod
  #pod This throws the usage message as an exception.
  #pod
  #pod   $usage_obj->die(\%arg);
  #pod
  #pod Some arguments can be provided 
  #pod
  #pod   pre_text  - text to be prepended to the usage message
  #pod   post_text - text to be appended to the usage message
  #pod
  #pod The C<pre_text> and C<post_text> arguments are concatenated with the usage
  #pod message with no line breaks, so supply this if you need them.
  #pod
  #pod =cut
  
  sub die  {
    my $self = shift;
    my $arg  = shift || {};
  
    die(
      join q{}, grep { defined } $arg->{pre_text}, $self->text, $arg->{post_text}
    );
  }
  
  use overload (
    q{""} => "text",
  
    # This is only needed because Usage used to be a blessed coderef that worked
    # this way.  Later we can toss a warning in here. -- rjbs, 2009-08-19
    '&{}' => sub {
      my ($self) = @_;
      Carp::cluck("use of __PACKAGE__ objects as a code ref is deprecated");
      return sub { return $_[0] ? $self->text : $self->warn; };
    }
  );
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Getopt::Long::Descriptive::Usage - the usage description for GLD
  
  =head1 VERSION
  
  version 0.102
  
  =head1 SYNOPSIS
  
    use Getopt::Long::Descriptive;
    my ($opt, $usage) = describe_options( ... );
  
    $usage->text; # complete usage message
  
    $usage->die;  # die with usage message
  
  =head1 DESCRIPTION
  
  This document only describes the methods of the Usage object.  For information
  on how to use L<Getopt::Long::Descriptive>, consult its documentation.
  
  =head1 METHODS
  
  =head2 new
  
    my $usage = Getopt::Long::Descriptive::Usage->new(\%arg);
  
  You B<really> don't need to call this.  GLD will do it for you.
  
  Valid arguments are:
  
    options     - an arrayref of options
    leader_text - the text that leads the usage; this may go away!
  
  =head2 text
  
  This returns the full text of the usage message.
  
  =head2 leader_text
  
  This returns the text that comes at the beginning of the usage message.
  
  =head2 option_text
  
  This returns the text describing the available options.
  
  =head2 warn
  
  This warns with the usage message.
  
  =head2 die
  
  This throws the usage message as an exception.
  
    $usage_obj->die(\%arg);
  
  Some arguments can be provided 
  
    pre_text  - text to be prepended to the usage message
    post_text - text to be appended to the usage message
  
  The C<pre_text> and C<post_text> arguments are concatenated with the usage
  message with no line breaks, so supply this if you need them.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Hans Dieter Pearcey <hdp@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2005 by Hans Dieter Pearcey.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
GETOPT_LONG_DESCRIPTIVE_USAGE

$fatpacked{"IO/Prompter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_PROMPTER';
  use 5.010;
  package IO::Prompter;
  
  use warnings;
  no if $] >= 5.018000, warnings => 'experimental';
  use strict;
  use Carp;
  use Contextual::Return qw< PUREBOOL BOOL SCALAR METHOD VOID LIST RETOBJ >;
  use Scalar::Util qw< openhandle looks_like_number >;
  use Symbol       qw< qualify_to_ref >;
  
  our $VERSION = '0.004014';
  
  my $fake_input;     # Flag that we're faking input from the source
  
  my $DEFAULT_TERM_WIDTH   = 80;
  my $DEFAULT_VERBATIM_KEY = "\cV";
  
  # Completion control...
  my $COMPLETE_DISPLAY_FIELDS = 4;  #...per line
  my $COMPLETE_DISPLAY_GAP    = 3;  #...spaces
  
  my $COMPLETE_KEY  = $ENV{IO_PROMPTER_COMPLETE_KEY} // qq{\t};
  my $COMPLETE_HIST = $ENV{IO_PROMPTER_HISTORY_KEY}  // qq{\cR};
  my $COMPLETE_NEXT = qq{\cN};
  my $COMPLETE_PREV = qq{\cP};
  
  my $COMPLETE_INIT  = qr{ [\Q$COMPLETE_KEY$COMPLETE_HIST\E] }xms;
  my $COMPLETE_CYCLE = qr{ [$COMPLETE_NEXT$COMPLETE_PREV] }xms;
  
  my %COMPLETE_MODE = (
      $COMPLETE_KEY
          => [split /\s+/, $ENV{IO_PROMPTER_COMPLETE_MODES}//q{list+longest  full}],
      $COMPLETE_HIST
          => [split /\s+/, $ENV{IO_PROMPTER_HISTORY_MODES} // q{full}],
  );
  
  my $FAKE_ESC    = "\e";
  my $FAKE_INSERT = "\cF";
  my $MENU_ESC    = "\e";
  my $MENU_MK     = '__M_E_N_U__';
  
  my %EDIT = (
      BACK    => qq{\cB},
      FORWARD => qq{\cF},
      START   => qq{\cA},
      END     => qq{\cE},
  );
  my $EDIT_KEY = '['.join(q{},values %EDIT).']';
  
  # Extracting key letters...
  my $KL_EXTRACT = qr{ (?| \[  ( [[:alnum:]]++ )  \]
                         | \(  ( [[:alnum:]]++ )  \)
                         | \<  ( [[:alnum:]]++ )  \>
                         | \{  ( [[:alnum:]]++ )  \}
                       )
                     }xms;
  my $KL_DEF_EXTRACT = qr{ \[  ( [[:alnum:]]++ )  \] }xms;
  
  
  # Auxiliary prompts for -Yes => N construct...
  my @YESNO_PROMPTS = (
      q{Really?},
      q{You're quite certain?},
      q{Definitely?},
      q{You mean it?},
      q{You truly mean it?},
      q{You're sure?},
      q{Have you thought this through?},
      q{You understand the consequences?},
  );
  
  
  # Remember returned values for history completion...
  my %history_cache;
  
  # Track lexically-scoped default options and wrapper subs...
  my @lexical_options  = [];
  my @lexical_wrappers = [];
  
  # Export the prompt() sub...
  sub import {
      my (undef, $config_data, @other_args) = @_;
  
      # Handle -argv requests...
      if (defined $config_data && $config_data eq '-argv') {
          scalar prompt(-argv, @other_args);
      }
  
      # Handle lexical options...
      elsif (ref $config_data eq 'ARRAY') {
          push @lexical_options, $config_data;
          $^H{'IO::Prompter::scope_number'} = $#lexical_options;
      }
  
      # Handle lexical wrappers...
      elsif (ref $config_data eq 'HASH') {
          push @lexical_options, [];
          $lexical_wrappers[ $#lexical_options ] = $config_data;
          $^H{'IO::Prompter::scope_number'} = $#lexical_options;
          for my $subname (keys %{$config_data}) {
              my @args = @{$config_data->{$subname}};
              no strict 'refs';
              no warnings 'redefine';
              *{caller().'::'.$subname} = sub {
                  my $scope_number = (caller 0)[10]{'IO::Prompter::scope_number'};
                  return prompt(@{$lexical_wrappers[$scope_number]{$subname}//[]}, @_);
              };
          }
      }
  
      # Handler faked input specifications...
      elsif (defined $config_data) {
          $fake_input = $config_data;
      }
  
      no strict 'refs';
      *{caller().'::prompt'} = \&prompt;
  }
  
  # Prompt for, read, vet, and return input...
  sub prompt {
      # Reclaim full control of print statements while prompting...
      local $\ = '';
  
      # Locate any lexical default options...
      my $hints_hash = (caller 0)[10] // {};
      my $scope_num = $hints_hash->{'IO::Prompter::scope_number'} // 0;
  
      # Extract and sanitize configuration arguments...
      my $opt_ref = _decode_args(@{$lexical_options[$scope_num]}, @_);
  
      _warn( void => 'Useless use of prompt() in void context' )
          if VOID && !$opt_ref->{-void};
  
      # Set up yesno prompts if required...
      my @yesno_prompts
          = ($opt_ref->{-yesno}{count}//0) > 1 ? @YESNO_PROMPTS : ();
  
      # Work out where the prompts go, and where the input comes from...
      my $in_filehandle  = $opt_ref->{-in}  // _open_ARGV();
      my $out_filehandle = $opt_ref->{-out} // qualify_to_ref(select);
      if (!openhandle $in_filehandle) {
          open my $fh, '<', $in_filehandle
              or _opt_err('Unacceptable', '-in', 'valid filehandle or filename');
          $in_filehandle = $fh;
      }
      if (!openhandle $out_filehandle) {
          open my $fh, '>', $out_filehandle
              or _opt_err('Unacceptable', '-out', 'valid filehandle or filename');
          $out_filehandle = $fh;
      }
  
      # Track timeouts...
      my $in_pos = do { no warnings;  tell $in_filehandle } // 0;
  
      # Short-circuit if not valid handles...
      return if !openhandle($in_filehandle) || !openhandle($out_filehandle);
  
      # Work out how they're arriving and departing...
      my $outputter_ref = -t $in_filehandle && -t $out_filehandle
                              ? _std_printer_to($out_filehandle, $opt_ref)
                              : _null_printer()
                              ;
      my $inputter_ref = _generate_unbuffered_reader_from(
                              $in_filehandle, $outputter_ref, $opt_ref
                         );
  
      # Clear the screen if requested to...
      if ($opt_ref->{-wipe}) {
          $outputter_ref->(-nostyle => "\n" x 1000);
      }
  
      # Handle menu structures...
      my $input;
      REPROMPT_YESNO:
      if ($opt_ref->{-menu}) {
          # Remember top of (possibly nested) menu...
          my @menu = ( $opt_ref->{-menu} );
          my $top_prompt = $opt_ref->{-prompt};
          $top_prompt =~ s{$MENU_MK}{$opt_ref->{-menu}{prompt}}xms;
          $menu[-1]{prompt} = $top_prompt;
  
          MENU:
          while (1) {
              # Track the current level...
              $opt_ref->{-menu_curr_level} = $menu[-1]{value_for};
  
              # Show menu and retreive choice...
              $outputter_ref->(-style => $menu[-1]{prompt});
              my $tag = $inputter_ref->($menu[-1]{constraint});
  
              # Handle a failure by exiting the loop...
              last MENU if !defined $tag;
              $tag =~ s{\A\s*(\S*).*}{$1}xms;
  
              # Handle <ESC> by moving up menu stack...
              if ($tag eq $MENU_ESC) {
                  $input = undef;
                  last MENU if @menu <= 1;
                  pop @menu;
                  next MENU;
              }
  
              # Handle defaults by selecting and ejecting...
              if ($tag =~ /\A\R?\Z/ && exists $opt_ref->{-def}) {
                  $input = $tag;
                  last MENU;
              }
  
              # Otherwise, retrieve value for selected tag and exit if not a nested menu...
              $input = $menu[-1]{value_for}{$tag};
              last MENU if !ref $input;
  
              # Otherwise, go down the menu one level...
              push @menu,
                  _build_menu($input,
                               "Select from $menu[-1]{key_for}{$tag}: ",
                               $opt_ref->{-number} || $opt_ref->{-integer}
                  );
              $menu[-1]{prompt} .= '> ';
          }
      }
  
      # Otherwise, simply ask and ye shall receive...
      else {
          $outputter_ref->(-style => $opt_ref->{-prompt});
          $input = $inputter_ref->();
      }
  
      # Provide default value if available and necessary...
      my $defaulted = 0;
      if (defined $input && $input =~ /\A\R?\Z/ && exists $opt_ref->{-def}) {
          $input = $opt_ref->{-def};
          $defaulted = 1;
      }
  
      # The input line is usually chomped before being returned...
      if (defined $input && !$opt_ref->{-line}) {
          chomp $input;
      }
  
      # Check for a value indicating failure...
      if (exists $opt_ref->{-fail} && $input ~~ $opt_ref->{-fail}) {
          $input = undef;
      }
  
      # Setting @ARGV is a special case; process it like a command-line...
      if ($opt_ref->{-argv}) {
          @ARGV = map { _shell_expand($_) }
                      grep {defined}
                              $input =~ m{
                                      ( '  [^'\\]* (?: \\. [^'\\]* )* ' )
                                  |   ( "  [^"\\]* (?: \\. [^"\\]* )* " )
                                  |   (?: ^ | \s)  ( [^\s"'] \S*        )
                              }gxms;
          return 1;
      }
  
      # "Those who remember history are enabled to repeat it"...
      if (defined $input and $opt_ref->{-history} ne 'NONE') {
          my $history_set = $history_cache{ $opt_ref->{-history} } //= [] ;
          @{ $history_set } = ($input, grep { $_ ne $input } @{ $history_set });
      }
  
      # If input timed out insert the default, if any...
      my $timedout = $in_pos == do{ no warnings; tell $in_filehandle } // 0;
      if ($timedout && exists $opt_ref->{-def}) {
          $input = $opt_ref->{-def};
          $defaulted = 1;
      }
  
      # A defined input is a successful input...
      my $succeeded = defined $input;
  
      # The -yesno variants also need a 'y' to be successful...
      if ($opt_ref->{-yesno}{count}) {
          $succeeded &&= $input =~ m{\A \s* y}ixms;
          if ($succeeded && $opt_ref->{-yesno}{count} > 1) {
              my $count = --$opt_ref->{-yesno}{count};
              $opt_ref->{-prompt}
                  = @yesno_prompts ? shift(@yesno_prompts) . q{ }
                  : $count > 1     ? qq{Please confirm $count more times }
                  :                   q{Please confirm one last time }
                  ;
              goto REPROMPT_YESNO;    # Gasp, yes goto is the cleanest way!
          }
      }
  
      # Verbatim return doesn't do fancy tricks...
      if ($opt_ref->{-verbatim}) {
          return $input // ();
      }
  
      # Failure in a list context returns nothing...
      return if LIST && !$succeeded;
  
      # Otherwise, be context sensitive...
      return
          PUREBOOL { $_ = RETOBJ; next handler;      }
              BOOL { $succeeded;                     }
            SCALAR { $input;                         }
            METHOD {
                      defaulted => sub { $defaulted  },
                      timedout  => sub {
                          return q{} if !$timedout;
                          return "timed out after $opt_ref->{-timeout} second"
                               . ($opt_ref->{-timeout} == 1 ? q{} : q{s});
                      },
                   };
  }
  
  
  # Simulate a command line expansion for the -argv option...
  sub _shell_expand {
      my ($text) = @_;
  
      # Single-quoted text is literal...
      if ($text =~ m{\A ' (.*) ' \z}xms) {
          return $1;
      }
  
      # Everything else has shell variables expanded...
      my $ENV_PAT = join '|', reverse sort keys %ENV;
      $text =~ s{\$ ($ENV_PAT)}{$ENV{$1}}gxms;
  
      # Double-quoted text isn't globbed...
      if ($text =~ m{\A " (.*) " \z}xms) {
          return $1;
      }
  
      # Everything else is...
      return glob($text);
  }
  
  # No completion is the default...
  my $DEFAULT_COMPLETER = sub { q{} };
  
  # Translate std constraints...
  my %STD_CONSTRAINT = (
      positive  => sub { $_ > 0      },
      negative  => sub { $_ < 0      },
      zero      => sub { $_ == 0     },
      even      => sub { $_ % 2 == 0 },
      odd       => sub { $_ % 2 != 0 },
  );
  
  # Create abbreviations...
  $STD_CONSTRAINT{pos} = $STD_CONSTRAINT{positive};
  $STD_CONSTRAINT{neg} = $STD_CONSTRAINT{negative};
  
  # Create antitheses...
  for my $constraint (keys %STD_CONSTRAINT) {
      my $implementation = $STD_CONSTRAINT{$constraint};
      $STD_CONSTRAINT{"non$constraint"}
          = sub { ! $implementation->(@_) };
  }
  
  # Special style specifications require decoding...
  
  sub _decode_echo {
      my $style = shift;
  
      # Not a special style...
      return $style if ref $style || $style !~ m{/};
  
      # A slash means yes/no echoes...
      my ($yes, $no) = split m{/}, $style;
      return sub{ /y/i ? $yes : $no };
  }
  
  sub _decode_echostyle {
      my $style = shift;
  
      # Not a special style...
      return $style if ref $style || $style !~ m{/};
  
      # A slash means yes/no styles...
      my ($yes, $no) = split m{/}, $style;
      return sub{ /y/i ? $yes : $no };
  }
  
  sub _decode_style {
      # No special prompt styles (yet)...
      return shift;
  }
  
  # Generate safe closure around active sub...
  sub _gen_wrapper_for {
      my ($arg) = @_;
      return ref $arg ne 'CODE'
             ? sub { $arg }
             : sub { eval { for (shift) { no warnings; return $arg->($_) // $_ } } };
  }
  
  # Create recognizer...
  my $STD_CONSTRAINT
      = '^(?:' . join('|', reverse sort keys %STD_CONSTRAINT) . ')';
  
  # Translate name constraints to implementations...
  sub _standardize_constraint {
      my ($option_type, $constraint_spec) = @_;
  
      return ("be an acceptable $option_type", $constraint_spec)
          if ref $constraint_spec;
  
      my @constraint_names = split /\s+/, $constraint_spec;
      my @constraints =
          map { $STD_CONSTRAINT{$_}
                // _opt_err('invalid',-$option_type,'"pos", "neg", "even", etc.')
              } @constraint_names;
  
      return (
          'be ' . join(' and ', @constraint_names),
          sub {
              my ($compare_val) = @_;
              for my $constraint (@constraints) {
                  return 0 if !$constraint->($compare_val);
              }
              return 1;
          }
      );
  }
  
  
  # Convert args to prompt + options hash...
  sub _decode_args {
      my %option = (
          -prompt    => undef,
          -complete  => $DEFAULT_COMPLETER,
          -must      => {},
          -history   => 'DEFAULT',
          -style     => sub{ q{} },
          -nostyle   => sub{ q{} },
          -echostyle => sub{ q{} },
          -echo      => sub { my $char = shift; $char eq "\t" ? q{ } : $char },
          -return    => sub { "\n" },
      );
  
      DECODING:
      while (defined(my $arg = shift @_)) {
          if (my $type = ref $arg) {
              _warn( reserved =>
                  'prompt(): Unexpected argument (' . lc($type) . ' ref) ignored'
              );
          }
          else {
              my $redo;
              given ($arg) {
                  # The sound of one hand clapping...
                  when (/^-_/) {
                      $redo = 1;
                  }
  
                  # Non-chomping option...
                  when (/^-line$/) {
                      $option{-line}++;
                  }
                  when (/^-l/) {
                      $option{-line}++;
                      $redo = 1;
                  }
  
                  # The -yesno variants...
                  when (/^-YesNo$/) {
                      my $count = @_ && looks_like_number($_[0]) ? shift @_ : 1;
                      $option{-yesno} = {
                          must => { '[YN]' => qr{\A \s* [YN] }xms },
                          count  => $count,
                      };
                  }
                  when (/^-YN/) {
                      $option{-yesno} = {
                          must => { '[YN]' => qr{\A \s* [YN] }xms },
                          count  => 1,
                      };
                      $redo = 2;
                  }
                  when (/^-yesno$/) {
                      my $count = @_ && looks_like_number($_[0]) ? shift @_ : 1;
                      $option{-yesno} = {
                          must => { '[yn]' => qr{\A \s* [YN] }ixms },
                          count  => $count,
                      };
                  }
                  when (/^-yn/) {
                      $option{-yesno} = {
                          must => { '[yn]' => qr{\A \s* [YN] }ixms },
                          count  => 1,
                      };
                      $redo = 2;
                  }
                  when (/^-Yes$/) {
                      my $count = @_ && looks_like_number($_[0]) ? shift @_ : 1;
                      $option{-yesno} = {
                          must => { '[Y for yes]' => qr{\A \s* (?: [^y] | \Z) }xms },
                          count  => $count,
                      };
                  }
                  when (/^-Y/) {
                      $option{-yesno} = {
                          must => { '[Y for yes]' => qr{\A \s* (?: [^y] | \Z) }xms },
                          count  => 1,
                      };
                      $redo = 1;
                  }
                  when (/^-yes$/) {
                      my $count = @_ && looks_like_number($_[0]) ? shift @_ : 1;
                      $option{-yesno} = { count  => $count };
                  }
                  when (/^-y/) {
                      $option{-yesno} = { count  => 1 };
                      $redo = 1;
                  }
  
                  # Load @ARGV...
                  when (/^-argv$/) {
                      $option{-argv} = 1;
                  }
  
                  when (/^-a/) {
                      $option{-argv} = 1;
                      $redo = 1;
                  }
  
                  # Clear screen before prompt...
                  state $already_wiped;
                  when (/^-wipe(first)?$/) {
                      $option{-wipe} = $1 ? !$already_wiped : 1;
                      $already_wiped = 1;
                  }
                  when (/^-w/) {
                      $option{-wipe} = 1;
                      $already_wiped = 1;
                      $redo = 1;
                  }
  
                  # Specify a failure condition...
                  when (/^-fail$/) {
                      _opt_err('Missing', -fail, 'failure condition') if !@_;
                      $option{-fail} = shift @_;
                  }
  
                  # Specify a file request...
                  when (/^-f(?:ilenames?)?$/) {
                      $option{-must}{'0: be an existing file'} = sub { -e $_[0] };
                      $option{-must}{'1: be readable'}         = sub { -r $_[0] };
                      $option{-complete}                       = 'filenames';
                  }
  
                  # Specify prompt echoing colour/style...
                  when (/^-style/) {
                      _opt_err('Missing -style specification') if !@_;
                      my $style = _decode_style(shift @_);
                      $option{-style} = _gen_wrapper_for($style);
                  }
  
                  # Specify input colour/style...
                  when (/^-echostyle/) {
                      _opt_err('Missing -echostyle specification') if !@_;
                      my $style = _decode_echostyle(shift @_);
                      $option{-echostyle} = _gen_wrapper_for($style);
                  }
  
  
                  # Specify input and output filehandles...
                  when (/^-stdio$/) { $option{-in}  = *STDIN;
                                     $option{-out} = *STDOUT;
                                    }
                  when (/^-in$/)    { $option{-in}  = shift @_; }
                  when (/^-out$/)   { $option{-out} = shift @_; }
  
                  # Specify integer and number return value...
                  when (/^-integer$/)       {
                      $option{-integer} = 1;
                      if (@_ && (ref $_[0] || $_[0] =~ $STD_CONSTRAINT)) {
                          my ($errmsg, $constraint)
                              = _standardize_constraint('integer',shift);
                          $option{-must}{$errmsg} = $constraint;
                      }
                  }
                  when (/^-num(?:ber)?$/)   {
                      $option{-number}  = 1;
                      if (@_ && (ref $_[0] || $_[0] =~ $STD_CONSTRAINT)) {
                          my ($errmsg, $constraint)
                              = _standardize_constraint('number',shift);
                          $option{-must}{$errmsg} = $constraint;
                      }
                  }
                  when (/^-i/)              { $option{-integer} = 1; $redo = 1; }
                  when (/^-n/)              { $option{-number}  = 1; $redo = 1; }
  
                  # Specify void context is okay...
                  when (/^-void$/)          { $option{-void} = 1;               }
  
                  # Specify verbatim return value...
                  when (/^-verb(?:atim)?$/) { $option{-verbatim} = 1;           }
                  when (/^-v/)              { $option{-verbatim} = 1; $redo = 1;}
  
                  # Specify single character return...
                  when (/^-sing(?:le)?$/)   { $option{-single} = 1;             }
                  when (/^-[s1]/)           { $option{-single} = 1; $redo = 1;  }
  
                  # Specify a default...
                  when (/^-DEF(?:AULT)?/) {
                      _opt_err('Missing', '-DEFAULT', 'string') if !@_;
                      $option{-def} = shift @_;
                      $option{-def_nocheck} = 1;
                      _opt_err('Invalid', '-DEFAULT', 'string')
                          if ref($option{-def});
                  }
                  when (/^-def(?:ault)?/) {
                      _opt_err('Missing', '-default', 'string') if !@_;
                      $option{-def} = shift @_;
                      _opt_err('Invalid', '-default', 'string')
                          if ref($option{-def});
                  }
                  when (/^-d(.+)$/)   { $option{-def} = $1; }
  
                  # Specify a timeout...
                  when (/^-t(\d+)/)   {
                      $option{-timeout} = $1;
                      $arg =~ s{\d+}{}xms;
                      $redo = 1;
                  }
                  when (/^-timeout$/) {
                      _opt_err('Missing', -timeout, 'number of seconds') if !@_;
                      $option{-timeout} = shift @_;
                      _opt_err('Invalid', -timeout,'number of seconds')
                          if !looks_like_number($option{-timeout});
                  }
  
                  # Specify a set of input constraints...
                  when (/^-g.*/) {
                      _opt_err('Missing', -guarantee, 'input restriction') if !@_;
                      my $restriction = shift @_;
                      my $restriction_type = ref $restriction;
  
                      $option{-must}{'be a valid input'} = $restriction;
  
                      # Hashes restrict input to their keys...
                      if ($restriction_type eq 'HASH') {
                          $restriction_type = 'ARRAY';
                          $restriction = [ keys %{$restriction} ];
                      }
                      # Arrays of strings matched (and completed) char-by-char...
                      if ($restriction_type eq 'ARRAY') {
                          my @restrictions = @{$restriction};
                          $option{-guarantee}
                              = '\A(?:'
                              . join('|', map {
                                    join(q{}, map { "(?:\Q$_\E" } split(q{}, $_))
                                  . ')?' x length($_)
                                } @restrictions)
                              . ')\z'
                              ;
                          if ($option{-complete} == $DEFAULT_COMPLETER) {
                              $option{-complete} = \@restrictions;
                          }
                      }
                      # Regexes matched as-is...
                      elsif ($restriction_type eq 'Regexp') {
                          $option{-guarantee} = $restriction;
                      }
                      else {
                          _opt_err( 'Invalid', -guarantee,
                                    'array or hash reference, or regex'
                          );
                      }
                  }
  
                  # Specify a set of key letters...
                  when ('-keyletters_implement') {
                      # Extract all keys and default keys...
                      my @keys  = ($option{-prompt} =~ m{$KL_EXTRACT}gxms);
  
                      # Convert default to a -default...
                      my @defaults = ($option{-prompt} =~ m{$KL_DEF_EXTRACT}gxms);
                      if (@defaults > 1) {
                          _warn( ambiguous =>
                              "prompt(): -keyletters found too many defaults"
                          )
                      }
                      elsif (@defaults) {
                          push @_, -default => $defaults[0];
                      }
  
                      # Convert key letters to a -guarantee...
                      @keys = ( map({uc} @keys), map({lc} @keys) );
                      if (@defaults == 1) {
                          push @keys, q{};
                      }
                      push @_, -guarantee => \@keys;
  
                  }
                  when (/^-key(?:let(?:ter)?)(?:s)?/) {
                      push @_, '-keyletters_implement';
                  }
                  when (/^-k/) {
                      push @_, '-keyletters_implement';
                      $redo = 1;
                  }
  
                  # Specify a set of return constraints...
                  when (/^-must$/) {
                      _opt_err('Missing', -must, 'constraint hash') if !@_;
                      my $must = shift @_;
                      _opt_err('Invalid', -must, 'hash reference')
                          if ref($must) ne 'HASH';
                      for my $errmsg (keys %{$must}) {
                          $option{-must}{$errmsg} = $must->{$errmsg};
                      }
                  }
  
                  # Specify a history set...
                  when (/^-history/) {
                      $option{-history}
                          = @_ && $_[0] !~ /^-/ ? shift @_
                          :                       undef;
                      _opt_err('Invalid', -history, 'history set name')
                          if ref($option{-history});
                  }
                  when (/^-h(.*)/)   { $option{-history} = length($1) ? $1 : undef; }
  
                  # Specify completions...
                  when (/^-comp(?:lete)?/) {
                      _opt_err('Missing', -complete, 'completions') if !@_;
                      my $comp_spec = shift @_;
                      my $comp_type = ref($comp_spec) || $comp_spec || '???';
                      if ($comp_type =~ m{\A(?: file\w* | dir\w* | ARRAY | HASH | CODE )\Z}xms) {
                          $option{-complete} = $comp_spec;
                      }
                      else {
                          _opt_err( 'Invalid', -complete,
                                      '"filenames", "dirnames", or reference to array, hash, or subroutine');
                      }
                  }
  
                  # Specify what to echo when a character is keyed...
                  when (/^-(echo|ret(?:urn)?)$/) {
                      my $flag = $1 eq 'echo' ? '-echo' : '-return';
                      if ($flag eq '-echo' && !eval { no warnings 'deprecated'; require Term::ReadKey }) {
                          _warn( bareword => "Warning: next input will be in plaintext\n");
                      }
                      my $arg = @_ && $_[0] !~ /^-/ ? shift(@_)
                              : $flag eq '-echo'    ? q{}
                              :                       qq{\n};
                      $option{$flag} = _gen_wrapper_for(_decode_echo($arg));
                  }
                  when (/^-e(.*)/) {
                      if (!eval { no warnings 'deprecated'; require Term::ReadKey }) {
                          _warn( bareword => "Warning: next input will be in plaintext\n");
                      }
                      my $arg = $1;
                      $option{-echo} = _gen_wrapper_for(_decode_echo($arg));
                  }
                  when (/^-r(.+)/) {
                      my $arg = $1;
                      $option{-return} = _gen_wrapper_for(_decode_echo($arg));
                  }
                  when (/^-r/) {
                      $option{-return} = sub{ "\n" };
                  }
  
                  # Explicit prompt replaces implicit prompts...
                  when (/^-prompt$/) {
                      _opt_err('Missing', '-prompt', 'prompt string') if !@_;
                      $option{-prompt} = shift @_;
                      _opt_err('Invalid', '-prompt', 'string')
                          if ref($option{-prompt});
                  }
                  when (/^-p(\S*)$/) {
                      $option{-prompt} = $1;
                  }
  
                  # Menus inject a placeholder in the prompt string...
                  when (/^-menu$/) {
                      _opt_err('Missing', '-menu', 'menu specification') if !@_;
                      $option{-menu}         = ref $_[0] ? shift(@_) : \shift(@_);
                      $option{-prompt}      .= $MENU_MK;
                      $option{-def_nocheck}  = 1;
                  }
  
                  # Anything else of the form '-...' is a misspelt option...
                  when (/^-\w+$/) { _warn(misc => "prompt(): Unknown option $arg ignored"); }
  
                  # Anything else is part fo the prompt...
                  default       { $option{-prompt} .= $arg; }
              }
  
              # Handle option bundling...
              redo DECODING if $redo && $arg =~ s{\A -.{$redo} (?=.)}{-}xms;
          }
      }
  
      # Precompute top-level menu, if menuing...
      if (exists $option{-menu}) {
          $option{-menu} = _build_menu($option{-menu},
                                       undef,
                                       $option{-number}||$option{-integer}
                           );
      }
  
      # Handle return magic on -single...
      if (defined $option{-single} && length($option{-echo}('X')//'echoself')) {
          $option{-return} //= sub{ "\n" };
      }
  
      # Adjust prompt as necessary...
      if ($option{-argv}) {
          my $progname = $option{-prompt} // $0;
          $progname =~ s{^.*/}{}xms;
  
          my $HINT = '[enter command line args here]';
          $option{-prompt} = "> $progname  $HINT\r> $progname ";
  
          $option{-complete} = 'filenames';
  
          my $not_first;
          $option{-echo}   = sub{
              my $char = shift;
              $option{-prompt} = "> $progname ";  # Sneaky resetting to handle completions
              return $char if $not_first++;
              return "\r> $progname  " . (q{ } x length $HINT) . "\r> $progname $char";
          }
      }
      elsif (!defined $option{-prompt}) {
          $option{-prompt} = '> ';
      }
      elsif ($option{-prompt} =~ m{ \S \z}xms) {
          # If prompt doesn't end in whitespace, make it so...
          $option{-prompt} .= ' ';
      }
      elsif ($option{-prompt} =~ m{ (.*) \n \z}xms) {
          # If prompt ends in a newline, remove it...
          $option{-prompt} = $1;
      }
  
      # Steal history set name if -h given without a specification...
      $option{-history} //= $option{-prompt};
  
      # Verify any default satisfies any constraints...
      if (exists $option{-def} && !$option{-def_nocheck}) {
          if (!_verify_input_constraints(\q{},undef,undef,\%option)) {
              _warn( misc =>
                  'prompt(): -default value does not satisfy -must constraints'
              );
          }
      }
  
      return \%option;
  }
  
  #====[ Error Handlers ]=========================================
  
  sub _opt_err {
      my ($problem, $option, $expectation) = @_;
      Carp::croak "prompt(): $problem value for $option (expected $expectation)";
  }
  
  sub _warn {
      my ($category, @message) = @_;
  
      return if !warnings::enabled($category);
  
      my $message = join(q{},@message);
      warn $message =~ /\n$/ ? $message : Carp::shortmess($message);
  }
  
  
  #====[ Utility subroutines ]====================================
  
  # Return the *ARGV filehandle, "magic-opening" it if necessary...
  sub _open_ARGV {
      if (!openhandle \*ARGV) {
          $ARGV = shift @ARGV // '-';
          open *ARGV or Carp::croak(qq{prompt(): Can't open *ARGV: $!});
      }
      return \*ARGV;
  }
  
  my $INTEGER_PAT = qr{ \A \s*+ [+-]?+ \d++ (?: [Ee] \+? \d+ )? \s*+ \Z }xms;
  
  my $NUMBER_PAT  = qr{
      \A \s*+ [+-]?+
      (?:
          \d++ (?: [.,] \d*+ )?
      |   [.,] \d++
      )
      (?: [eE] [+-]?+ \d++ )?
      \s*+ \Z
  }xms;
  
  # Verify interactive constraints...
  sub _verify_input_constraints {
      my ($input_ref, $local_fake_input_ref, $outputter_ref, $opt_ref, $extras)
          = @_;
  
      # Use default if appropriate (but short-circuit checks if -DEFAULT set)...
      my $input = ${$input_ref};
      if (${$input_ref} =~ m{^\R?$}xms && exists $opt_ref->{-def}) {
          return 1 if $opt_ref->{-def_nocheck};
          $input = $opt_ref->{-def}
      }
      chomp $input;
  
      my $failed;
      # Integer constraint is hard-coded...
      if ($opt_ref->{-integer} && $input !~ $INTEGER_PAT) {
          $failed = $opt_ref->{-prompt} . "(must be an integer) ";
      }
  
      # Numeric constraint is hard-coded...
      if (!$failed && $opt_ref->{-number} && $input !~ $NUMBER_PAT) {
          $failed = $opt_ref->{-prompt} . "(must be a number) ";
      }
  
      # Sort and clean up -must list...
      my $must_ref = $opt_ref->{-must} // {};
      my @must_keys     = sort keys %{$must_ref};
      my %clean_key_for = map { $_ => (/^\d+[.:]?\s*(.*)/s ? $1 : $_) } @must_keys;
      my @must_kv_list  = map { $clean_key_for{$_} => $must_ref->{$_} } @must_keys;
  
      # Combine -yesno and -must constraints...
      my %constraint_for = (
          %{ $extras // {} },
          %{ $opt_ref->{-yesno}{must} // {} },
          @must_kv_list,
      );
      my @constraints = (
          keys %{ $extras // {} },
          keys %{ $opt_ref->{-yesno}{must} // {} },
          @clean_key_for{@must_keys},
      );
  
      # User-specified constraints...
      if (!$failed && keys %constraint_for) {
          CONSTRAINT:
          for my $msg (@constraints) {
              my $constraint = $constraint_for{$msg};
              next CONSTRAINT if eval { no warnings; local $_ = $input; $input ~~ $constraint; };
              $failed = $msg =~ m{\A [[:upper:]] }xms ? "$msg "
                      : $msg =~ m{\A \W }xms          ? $opt_ref->{-prompt}
                                                      . "$msg "
                      :                                 $opt_ref->{-prompt}
                                                      . "(must $msg) "
                      ;
              last CONSTRAINT;
          }
      }
  
      # If any constraint not satisfied...
      if ($failed) {
          # Return failure if not actually prompting at the moment...
          return 0 if !$outputter_ref;
  
          # Redraw post-menu prompt with failure message appended...
          $failed =~ s{.*$MENU_MK}{}xms;
          $outputter_ref->(-style => _wipe_line(), $failed);
  
          # Reset input collector...
          ${$input_ref}  = q{};
  
          # Reset faked input, if any...
          if (defined $fake_input && length($fake_input) > 0) {
              $fake_input =~ s{ \A (.*) \R? }{}xm;
              ${$local_fake_input_ref} = $1;
          }
  
          no warnings 'exiting';
          next INPUT;
      }
  
      # Otherwise succeed...
      return 1;
  }
  
  # Build a sub to read from specified filehandle, with or without timeout...
  sub _generate_buffered_reader_from {
      my ($in_fh, $outputter_ref, $opt_ref) = @_;
  
      # Set-up for timeouts...
      my $fileno      = fileno($in_fh) // -1;
      my $has_timeout = exists $opt_ref->{-timeout} && $fileno >= 0;
      my $timeout     = $opt_ref->{-timeout};
      my $readbits    = q{};
      if ($has_timeout && $fileno >= 0) {
          vec($readbits,$fileno,1) = 1;
      }
  
      # Set up local faked input, if any...
      my $local_fake_input;
      my $orig_fake_input;
      if (defined $fake_input && length($fake_input) > 0) {
          $fake_input =~ s{ \A (.*) \R? }{}xm;
          $orig_fake_input = $local_fake_input = $1;
      }
  
      return sub {
          my ($extra_constraints) = @_;
  
          INPUT:
          while (1) {
              if (!$has_timeout || select $readbits, undef, undef, $timeout) {
                  my $input;
  
                  # Real input comes from real filehandles...
                  if (!defined $local_fake_input) {
                      $input = readline $in_fh;
                  }
                  # Fake input has to be typed...
                  else {
                      $input = $local_fake_input;
                      sleep 1;
                      for (split q{}, $local_fake_input) {
                          _simulate_typing();
                          $outputter_ref->(-echostyle => $opt_ref->{-echo}($_));
                      }
                      readline $in_fh;
  
                      # Check for simulated EOF...
                      if ($input =~ m{^ \s* (?: \cD | \cZ ) }xms) {
                          $input = undef;
                      }
                  }
  
                  if (defined $input) {
                      _verify_input_constraints(
                          \$input, \$local_fake_input, $outputter_ref, $opt_ref, $extra_constraints
                      );
                  }
  
                  return defined $input && $opt_ref->{-single}
                              ? substr($input, 0, 1)
                              : $input;
              }
              else {
                  return;
              }
          }
      }
  }
  
  sub _autoflush {
      my ($fh) = @_;
      my $prev_selected = select $fh;
      $| = 1;
      select $prev_selected;
      return;
  }
  
  sub _simulate_typing {
      state $TYPING_SPEED = 0.07; # seconds per character
      select undef, undef, undef, rand $TYPING_SPEED;
  }
  
  sub _term_width {
      my ($term_width) = eval { no warnings 'deprecated'; Term::ReadKey::GetTerminalSize(\*STDERR) };
      return $term_width // $DEFAULT_TERM_WIDTH;
  }
  
  sub _wipe_line {
      return qq{\r} . q{ } x (_term_width()-1) . qq{\r};
  }
  
  # Convert a specification into a list of possible completions...
  sub _current_completions_for {
      my ($input_text, $opt_ref) = @_;
      my $completer = $opt_ref->{-complete};
  
      # Isolate the final whitespace-separated word...
      my ($prefix, $lastword)
          = $input_text =~ m{
              (?| ^ (.*\s+) (.*)
                | ^ ()      (.*)
              )
            }xms;
  
      # Find candidates...
      my @candidates;
      given (ref($completer) || $completer // q{}) {
          # If completer is sub, recursively call it with input words...
          when ('CODE') {
              ($prefix, @candidates)
                  = _current_completions_for(
                      $input_text,
                      { %{$opt_ref},
                        -complete => $completer->(split /\s+/, $input_text, -1)
                      }
                    );
          }
  
          # If completer is array, grep the appropriate elements...
          when ('ARRAY') {
              @candidates = grep { /\A\Q$lastword\E/ } @{$completer};
          }
  
          # If completer is hash, grep the appropriate keys...
          when ('HASH') {
              @candidates = grep { /\A\Q$lastword\E/ } keys %{$completer};
          }
  
          # If completer is 'file...', glob up the appropriate filenames...
          when (/^file\w*$/) {
              @candidates = glob($lastword.'*');
          }
  
          # If completer is 'dir...', glob up the appropriate directories...
          when (/^dir\w*$/) {
              @candidates = grep {-d} glob($lastword.'*');
          }
      }
  
      chomp @candidates;
      return ($prefix, @candidates);
  }
  
  
  sub _current_history_for {
      my ($prefix, $opt_ref) = @_;
  
      my $prefix_len = length($prefix);
      return q{}, map { /\A (.*?) \R \Z/x ? $1 : $_ }
                 grep { substr($_,0,$prefix_len) eq $prefix }
                      @{ $history_cache{$opt_ref->{-history}} };
  }
  
  sub _longest_common_prefix_for {
      my $prefix = shift @_;
      for my $comparison (@_) {
          ($comparison ^ $prefix) =~ m{ \A (\0*) }xms;
          my $common_length = length($1);
          return q{} if !$common_length;
          $prefix = substr($prefix, 0, $common_length);
      }
      return $prefix;
  }
  
  sub _display_completions {
      my ($input, @candidates) = @_;
  
      return q{} if @candidates <= 1;
  
      # How big is each field in the table?
      my $field_width
          = _term_width() / $COMPLETE_DISPLAY_FIELDS - $COMPLETE_DISPLAY_GAP;
  
      # Crop the possibilities intelligently to that width...
      for my $candidate (@candidates) {
          substr($candidate, 0, length($input)) =~ s{ \A .* [/\\] }{}xms;
          $candidate
              = sprintf "%-*s", $field_width, substr($candidate,0,$field_width);
      }
  
      # Collect them into rows...
      my $display = "\n";
      my $gap     = q{ } x $COMPLETE_DISPLAY_GAP;
      while (@candidates) {
          $display .= $gap
                    . join($gap, splice(@candidates, 0, $COMPLETE_DISPLAY_FIELDS))
                    . "\n";
      }
  
      return $display;
  }
  
  sub _generate_unbuffered_reader_from {
      my ($in_fh, $outputter_ref, $opt_ref) = @_;
  
      my $has_readkey = eval { no warnings 'deprecated'; require Term::ReadKey };
  
      # If no per-character reads, fall back on buffered input...
      if (!-t $in_fh || !$has_readkey) {
          return _generate_buffered_reader_from($in_fh, $outputter_ref, $opt_ref);
      }
  
      # Adapt to local control characters...
      my %ctrl = eval { Term::ReadKey::GetControlChars($in_fh) };
      delete $ctrl{$_} for grep { $ctrl{$_} eq "\cA" } keys %ctrl;
  
      $ctrl{EOF}       //= "\4";
      $ctrl{INTERRUPT} //= "\3";
      $ctrl{ERASE}     //= $^O eq 'MSWin32' ? "\10" : "0177";
  
      my $ctrl           = join '|', values %ctrl;
  
      my $VERBATIM_KEY = $ctrl{QUOTENEXT} // $DEFAULT_VERBATIM_KEY;
  
      # Translate timeout for ReadKey (with 32-bit MAXINT workaround for Windows)...
      my $timeout = !defined $opt_ref->{-timeout} ? 0x7FFFFFFF    # 68 years
                  : $opt_ref->{-timeout} == 0     ? -1
                  :                                 $opt_ref->{-timeout}
                  ;
  
      return sub {
          my ($extra_constraints) = @_;
  
          # Short-circuit on unreadable filehandle...
          return if !openhandle($in_fh);
  
          # Set up direct reading, and prepare to clean up on abnormal exit...
          Term::ReadKey::ReadMode('raw', $in_fh);
          my $prev_SIGINT = $SIG{INT};
          local $SIG{INT} = sub { given ($prev_SIGINT) {
                                      when ('IGNORE')  { }
                                      Term::ReadKey::ReadMode('restore', $in_fh);
                                      when ('DEFAULT') { exit(1) }
                                      when (undef)     { exit(1) }
                                      default {
                                          package main;
                                          no strict 'refs';
                                          $prev_SIGINT->()
                                      }
                                  }
                            };
  
          # Set up local faked input, if any...
          my $local_fake_input;
          my $orig_fake_input;
          if (defined $fake_input && length($fake_input) > 0) {
              $fake_input =~ s{ \A (.*) \R? }{}xm;
              $orig_fake_input = $local_fake_input = $1;
          }
  
          my $input = q{};
          my $insert_offset = 0;
          INPUT:
          while (1) {
              state $prev_was_verbatim = 0;
              state $completion_level  = 0;
              state $completion_type   = q{};
  
              # Get next character entered...
              my $next = Term::ReadKey::ReadKey($timeout, $in_fh);
  
              # Finished with completion mode?
              if (($next//q{}) !~ m{ $COMPLETE_INIT | $COMPLETE_CYCLE }xms) {
                  $completion_level = 0;
                  $completion_type = q{};
              }
  
              # Are we faking input?
              my $faking = defined $local_fake_input;
  
              # If not EOF...
              if (defined $next) {
                  # Remember where we were parked...
                  my $prev_insert_offset = $insert_offset;
  
                  # Handle interrupts...
                  if ($next eq $ctrl{INTERRUPT}) {
                      $SIG{INT}();
                      next INPUT;
                  }
  
                  # Handle verbatim quoter...
                  elsif (!$prev_was_verbatim && $next eq $VERBATIM_KEY) {
                      $prev_was_verbatim = 1;
                      next INPUT;
                  }
  
                  # Handle completions...
                  elsif (!$prev_was_verbatim
                         && ( $next =~ $COMPLETE_INIT
                           || $completion_level > 0 && $next =~ $COMPLETE_CYCLE
                         )
                  ) {
                      state @completion_list;  # ...all candidates for completion
                      state @completion_ring;  # ..."next" candidate cycle
                      state $completion_ring_first;  # ...special case first time
                      state $completion_prefix;      # ...skipped before completing
  
                      # Track completion type and level (switch if necessary)...
                      if ($next =~ $COMPLETE_INIT && index($completion_type, $next) < 0) {
                          $completion_type = index($COMPLETE_KEY, $next) >= 0 ? $COMPLETE_KEY : $COMPLETE_HIST;
                          $completion_level = 1;
                      }
                      else {
                          $completion_level++;
                      }
  
                      # If starting completion, cache completions...
                      if ($completion_level == 1) {
                          ($completion_prefix, @completion_list)
                             = index($COMPLETE_KEY, $next) >= 0
                                  ? _current_completions_for($input, $opt_ref)
                                  : _current_history_for($input, $opt_ref);
                          @completion_ring = (@completion_list, q{});
                          $completion_ring_first = 1;
                      }
  
                      # Can only complete if there are completions to be had...
                      if (@completion_list) {
                          # Select the appropriate mode...
                          my $mode = $COMPLETE_MODE{$completion_type}[$completion_level-1]
                                  // $COMPLETE_MODE{$completion_type}[-1];
  
                          # 'longest mode' finds longest consistent prefix...
                          if ($mode =~ /longest/) {
                              $input
                                  = $completion_prefix
                                  . _longest_common_prefix_for(@completion_list);
                          }
                          # 'full mode' suggests next full match...
                          elsif ($mode =~ /full/) {
                              if (!$completion_ring_first) {
                                  if ($next eq $COMPLETE_PREV) {
                                      unshift @completion_ring,
                                              pop @completion_ring;
                                  }
                                  else {
                                      push @completion_ring,
                                           shift @completion_ring;
                                  }
                              }
                              $input = $completion_prefix . $completion_ring[0];
                              $completion_ring_first = 0;
                          }
                          # 'list mode' lists all possibilities...
                          my $list_display = $mode =~ /list/
                              ? _display_completions($input, @completion_list)
                              : q{};
  
                          # Update prompt with selected completion...
                          $outputter_ref->( -style =>
                              $list_display,
                              _wipe_line(),
                              $opt_ref->{-prompt}, $input
                          );
  
                          # If last completion was unique choice, completed...
                          if (@completion_list <= 1) {
                              $completion_level = 0;
                          }
                      }
                      next INPUT;
                  }
  
                  # Handle erasures (including pushbacks if faking)...
                  elsif (!$prev_was_verbatim && $next eq $ctrl{ERASE}) {
                      if (!length $input) {
                          # Do nothing...
                      }
                      elsif ($insert_offset) {
                          # Can't erase past start of input...
                          next INPUT if $insert_offset >= length($input);
  
                          # Erase character just before cursor...
                          substr($input, -$insert_offset-1, 1, q{});
  
                          # Redraw...
                          my $input_pre  = substr($input.' ',0,length($input)-$insert_offset+1);
                          my $input_post = substr($input.' ',length($input)-$insert_offset);
                          my $display_pre  = join q{}, map { $opt_ref->{-echo}($_) } split //, $input_pre;
                          my $display_post = join q{}, map { $opt_ref->{-echo}($_) } split //, $input_post;
                          $outputter_ref->( -echostyle =>
                                "\b" x length($display_pre)
                              . join(q{}, map { $opt_ref->{-echo}($_) } split //, $input)
                              . q{ } x length($opt_ref->{-echo}(q{ }))
                              . "\b" x length($display_post)
                          );
                      }
                      else {
                          my $erased = substr($input, -1, 1, q{});
                          if ($faking) {
                              substr($local_fake_input,0,0,$erased);
                          }
                          $outputter_ref->( -nostyle =>
                              map { $_ x (length($opt_ref->{-echo}($_)//'X')) }
                                  "\b", ' ', "\b"
                          );
                      }
                      next INPUT;
                  }
  
                  # Handle EOF (including cancelling any remaining fake input)...
                  elsif (!$prev_was_verbatim && $next eq $ctrl{EOF}) {
                      Term::ReadKey::ReadMode('restore', $in_fh);
                      close $in_fh;
                      undef $fake_input;
                      return length($input) ? $input : undef;
                  }
  
                  # Handle escape from faking...
                  elsif (!$prev_was_verbatim && $faking && $next eq $FAKE_ESC) {
                      my $lookahead = Term::ReadKey::ReadKey(0, $in_fh);
  
                      # Two <ESC> implies the current faked line is deferred...
                      if ($lookahead eq $FAKE_ESC) {
                          $fake_input =~ s{ \A }{$orig_fake_input\n}xm;
                      }
                      # Only one <ESC> implies the current faked line is replaced...
                      else {
                          $in_fh->ungetc(ord($lookahead));
                      }
                      undef $local_fake_input;
                      $faking = 0;
                      next INPUT;
                  }
  
                  # Handle returns...
                  elsif (!$prev_was_verbatim && $next =~ /\A\R\z/) {
                      # Complete faked line, if faked input incomplete...
                      if ($faking && length($local_fake_input)) {
                          for (split q{}, $local_fake_input) {
                              _simulate_typing();
                              $outputter_ref->(-echostyle => $opt_ref->{-echo}($_));
                          }
                          $input .= $local_fake_input;
                      }
  
                      # Add newline to the accumulated input string...
                      $input .= $next;
  
                      # Check that input satisfied any constraints...
                      _verify_input_constraints(
                          \$input, \$local_fake_input, $outputter_ref,
                          $opt_ref, $extra_constraints,
                      );
  
                      # Echo a default value if appropriate...
                      if ($input =~ m{\A\R?\Z}xms && defined $opt_ref->{-def}) {
                          my $def_val = $opt_ref->{-def};
  
                          # Try to find the key, for a menu...
                          if (exists $opt_ref->{-menu_curr_level}) {
                              for my $key ( keys %{$opt_ref->{-menu_curr_level}}) {
                                  if ($def_val ~~ $opt_ref->{-menu_curr_level}{$key}) {
                                      $def_val = $key;
                                      last;
                                  }
                              }
                          }
  
                          # Echo it as if it had been typed...
                          $outputter_ref->(-echostyle => $opt_ref->{-echo}($def_val));
                      }
  
                      # Echo the return (or otherwise, as specified)...
                      $outputter_ref->(-echostyle => $opt_ref->{-return}($next));
  
                      # Clean up, and return the input...
                      Term::ReadKey::ReadMode('restore', $in_fh);
  
                      # Handle fake EOF...
                      if ($faking && $input =~ m{^ (?: \cD | \cZ) }xms) {
                          return undef;
                      }
  
                      return $input;
                  }
  
                  # Handle anything else...
                  elsif ($prev_was_verbatim || $next !~ /$ctrl/) {
                      # If so, get the next fake character...
                      if ($faking) {
                          $next = length($local_fake_input)
                                      ? substr($local_fake_input,0,1,q{})
                                      : q{};
                      }
  
                      # Handle editing...
                      if ($next eq $EDIT{BACK}) {
                          $insert_offset += ($insert_offset < length $input) ? 1 : 0;
                      }
                      elsif ($next eq $EDIT{FORWARD}) {
                          $insert_offset += ($insert_offset > 0) ? -1 : 0;
                      }
                      elsif ($next eq $EDIT{START}) {
                          $insert_offset = length($input);
                      }
                      elsif ($next eq $EDIT{END}) {
                          $insert_offset = 0;
                      }
  
                      # Handle non-editing...
                      else {
                          # Check for input restrictions...
                          if (exists $opt_ref->{-guarantee}) {
                              next INPUT if ($input.$next) !~ $opt_ref->{-guarantee};
                          }
  
                          # Add the new input char to the accumulated input string...
                          if ($insert_offset) {
                              substr($input, -$insert_offset, 0) = $next;
                              $prev_insert_offset++;
                          }
                          else {
                              $input .= $next;
                          }
                      }
  
                      # Display the character (or whatever was specified)...
  
                      if ($insert_offset || $prev_insert_offset) {
                          my $input_pre  = substr($input,0,length($input)-$prev_insert_offset);
                          my $input_post = substr($input,length($input)-$insert_offset);
                          my $display_pre  = join q{}, map { $opt_ref->{-echo}($_) } split //, $input_pre;
                          my $display_post = join q{}, map { $opt_ref->{-echo}($_) } split //, $input_post;
                          $outputter_ref->( -echostyle =>
                                "\b" x length($display_pre)
                              . join(q{}, map { $opt_ref->{-echo}($_) } split //, $input)
                              . "\b" x length($display_post)
                          );
                      }
                      elsif ($next !~ $EDIT_KEY) {
                          $outputter_ref->(-echostyle => $opt_ref->{-echo}($next));
                      }
  
                      # Not verbatim after this...
                      $prev_was_verbatim = 0;
                  }
                  else {
                      # Not verbatim after mysterious ctrl input...
                      $prev_was_verbatim = 0;
  
                      next INPUT;
                  }
              }
              if ($opt_ref->{-single} || !defined $next || $input =~ m{\Q$/\E$}) {
                  # Did we get an acceptable value?
                  if (defined $next) {
                      _verify_input_constraints(
                         \$input, \$local_fake_input, $outputter_ref,
                         $opt_ref, $extra_constraints,
                      );
                  }
  
                  # Reset terminal...
                  Term::ReadKey::ReadMode('restore', $in_fh);
  
                  # Return failure if failed before input...
                  return undef if !defined $next && length($input) == 0;
  
                  # Otherwise supply a final newline if necessary...
                  if ( $opt_ref->{-single}
                  &&   exists $opt_ref->{-return}
                  &&   $input !~ /\A\R\z/ ) {
                      $outputter_ref->(-echostyle => $opt_ref->{-return}(q{}));
                  }
  
                  return $input;
              }
          }
      }
  }
  
  # Build a menu...
  sub _build_menu {
      my ($source_ref, $initial_prompt, $is_numeric) = @_;
      my $prompt = ($initial_prompt//q{}) . qq{\n};
      my $final = q{};
      my %value_for;
      my %key_for;
      my @selectors;
  
      given (ref $source_ref) {
          when ('HASH') {
              my @sorted_keys = sort(keys(%{$source_ref}));
              @selectors = $is_numeric ? (1..@sorted_keys) : ('a'..'z','A'..'Z');
              @key_for{@selectors}   = @sorted_keys;
              @value_for{@selectors} = @{$source_ref}{@sorted_keys};
              $source_ref = \@sorted_keys;
              $_ = 'ARRAY';
              continue;
          }
          when ('SCALAR') {
              $source_ref = [ split "\n", ${$source_ref} ];
              $_ = 'ARRAY';
              continue;
          }
          when ('ARRAY') {
              my @source = @{$source_ref};
              @selectors = $is_numeric ? (1..@source) : ('a'..'z','A'..'Z');
              if (!keys %value_for) {
                  @value_for{@selectors} = @source;
              }
              ITEM:
              for my $tag (@selectors) {
                  my $item = shift(@source) // last ITEM;
                  chomp $item;
                  $prompt .= sprintf("%4s. $item\n", $tag);
                  $final = $tag;
              }
              if (@source) {
                  _warn( misc =>
                      "prompt(): Too many menu items. Ignoring the final " . @source
                  );
              }
          }
      }
  
      my $constraint = $is_numeric       ? '(?:' . join('|',@selectors) .')'
                     : $final =~ /[A-Z]/ ? "[a-zA-$final]"
                     :                     "[a-$final]";
      my $constraint_desc = $is_numeric  ? "[1-$selectors[-1]]" : $constraint;
      $constraint = '\A\s*' . $constraint . '\s*\Z';
  
      return {
          data       => $source_ref,
          key_for    => \%key_for,
          value_for  => \%value_for,
          prompt     => "$prompt\n",
          is_numeric => $is_numeric,
          constraint => { "Enter $constraint_desc: " => qr/$constraint|$MENU_ESC/ },
      };
  }
  
  # Vocabulary that _stylize understands...
  my %synonyms = (
      bold      => [qw<boldly strong heavy emphasis emphatic highlight highlighted fort forte>],
      dark      => [qw<darkly dim deep>],
      faint     => [qw<faintly light soft>],
      underline => [qw<underlined underscore underscored italic italics>],
      blink     => [qw<blinking flicker flickering flash flashing>],
      reverse   => [qw<reversed inverse inverted>],
      concealed => [qw<hidden blank invisible>],
      reset     => [qw<normal default standard usual ordinary regular>],
      bright_   => [qw< bright\s+ vivid\s+ >],
      red       => [qw< scarlet vermilion crimson ruby cherry cerise cardinal carmine
                        burgundy claret chestnut copper garnet geranium russet
                        salmon titian coral cochineal rose cinnamon ginger gules >],
      yellow    => [qw< gold golden lemon cadmium daffodil mustard primrose tawny
                        amber aureate canary champagne citrine citron cream goldenrod honey straw >],
      green     => [qw< olive jade pea emerald lime chartreuse forest sage vert >],
      cyan      => [qw< aqua aquamarine teal turquoise ultramarine >],
      blue      => [qw< azure cerulean cobalt indigo navy sapphire >],
      magenta   => [qw< amaranthine amethyst lavender lilac mauve mulberry orchid periwinkle
                        plum pomegranate violet purple aubergine cyclamen fuchsia modena puce
                        purpure >],
      black     => [qw< charcoal ebon ebony jet obsidian onyx raven sable slate >],
      white     => [qw< alabaster ash chalk ivory milk pearl silver argent >],
  );
  
  # Back-mapping to standard terms...
  my %normalize
      = map { join('|', map { "$_\\b" } reverse sort @{$synonyms{$_}}) => $_ }
            keys %synonyms;
  
  my $BACKGROUND = qr{
       (\S+) \s+ (?: behind | beneath | below | under(?:neath)? )\b
     | \b (?:upon|over|on) \s+ (?:an?)? \s+ (.*?) \s+ (?:background|bg|field) \b
     | \b (?:upon\s+ | over\s+ | (?:(on|upon|over)\s+a\s+)?  (?:background|bg|field) \s+ (?:of\s+|in\s+)? | on\s+) (\S+)
  }ixms;
  
  # Convert a description to ANSI colour codes...
  sub _stylize {
      my $spec = shift // q{};
  
      # Handle arrays and hashes as args...
      if (ref($spec) eq 'ARRAY') {
          $spec = join q{ }, @{$spec};
      }
      elsif (ref($spec) eq 'HASH') {
          $spec = join q{ }, keys %{$spec};
      }
  
      # Ignore punctuation...
      $spec =~ s/[^\w\s]//g;
  
      # Handle backgrounds...
      $spec =~ s/$BACKGROUND/on_$+/g;
  
      # Apply standard translations...
      for my $pattern (keys %normalize) {
          $spec =~ s{\b(on_|\b) $pattern}{($1//q{}).$normalize{$pattern}}geixms;
      }
  
      # Ignore anything unknown...
      $spec =~ s{((?:on_)?(\S+))}{ exists $synonyms{$2} ? $1 : q{} }gxmse;
  
      # Build ANSI terminal codes around text...
      my $raw_text = join q{}, @_;
      my ($prews, $text, $postws) = $raw_text =~ m{\A (\s*) (.*?) (\s*) \Z}xms;
      my @style = split /\s+/, $spec;
      return $prews
           . ( @style ? Term::ANSIColor::colored(\@style, $text) : $text )
           . $postws;
  }
  
  # Build a subroutine that prints printable chars to the specified filehandle...
  sub _std_printer_to {
      my ($out_filehandle, $opt_ref) = @_;
      no strict 'refs';
      _autoflush($out_filehandle);
      if (eval { require Term::ANSIColor}) {
          return sub {
              my $style = shift;
              my @loc = (@_);
              s{\e}{^}gxms for @loc;
              print {$out_filehandle} _stylize($opt_ref->{$style}(@loc), @loc);
          };
      }
      else {
          return sub {
              shift; # ...ignore style
              my @loc = (@_);
              s{\e}{^}gxms for @loc;
              print {$out_filehandle} @loc;
          };
      }
  }
  
  # Build a subroutine that prints to nowhere...
  sub _null_printer {
      return sub {};
  }
  
  1; # Magic true value required at end of module
  __END__
  
  =head1 NAME
  
  IO::Prompter - Prompt for input, read it, clean it, return it.
  
  
  =head1 VERSION
  
  This document describes IO::Prompter version 0.004014
  
  
  =head1 SYNOPSIS
  
      use IO::Prompter;
  
      while (prompt -num, 'Enter a number') {
          say "You entered: $_";
      }
  
      my $passwd
          = prompt 'Enter your password', -echo=>'*';
  
      my $selection
          = prompt 'Choose wisely...', -menu => {
                  wealth => [ 'moderate', 'vast', 'incalculable' ],
                  health => [ 'hale', 'hearty', 'rude' ],
                  wisdom => [ 'cosmic', 'folk' ],
            }, '>';
  
  
  =head1 DESCRIPTION
  
  IO::Prompter exports a single subroutine, C<prompt>, that prints a
  prompt (but only if the program's selected input and output streams are
  connected to a terminal), then reads some input, then chomps it, and
  finally returns an object representing that text.
  
  The C<prompt()> subroutine expects zero-or-more arguments.
  
  Any argument that starts with a hyphen (C<->) is treated as a named
  option (many of which require an associated value, that may be passed as
  the next argument). See L<"Summary of options"> and L<"Options
  reference"> for details of the available options.
  
  Any other argument that is a string is treated as (part of) the prompt
  to be displayed. All such arguments are concatenated together before the
  prompt is issued. If no prompt string is provided, the string
  C<< '> ' >> is used instead.
  
  Normally, when C<prompt()> is called in either list or scalar context,
  it returns an opaque object that autoconverts to a string. In scalar
  boolean contexts this return object evaluates true if the input
  operation succeeded. In list contexts, if the input operation fails
  C<prompt()> returns an empty list instead of a return object. This
  allows failures in list context to behave correctly (i.e. be false).
  
  If you particularly need a list-context call to C<prompt()> to always
  return a value (i.e. even on failure), prefix the call with C<scalar>:
  
      # Only produces as many elements
      # as there were successful inputs...
      my @data = (
          prompt('Name:'),
          prompt(' Age:'),
          prompt(' Sex:'),
      );
  
      # Always produces exactly three elements
      # (some of which may be failure objects)...
      my @data = (
          scalar prompt('Name:'),
          scalar prompt(' Age:'),
          scalar prompt(' Sex:'),
      );
  
  In void contexts, C<prompt()> still requests input, but also issues a
  warning about the general uselessness of performing an I/O operation
  whose results are then immediately thrown away.
  See L<"Useful useless uses of C<prompt()>"> for an exception to this.
  
  The C<prompt()> function also sets C<$_> if it is called in a boolean
  context but its return value is not assigned to a variable. Hence, it is
  designed to be a drop-in replacement for C<readline> or C<< <> >>.
  
  =head1 INTERFACE
  
  All the options for C<prompt()> start with a hyphen (C<->).
  Most have both a short and long form. The short form is always
  the first letter of the long form.
  
  Most options have some associated value. For short-form options, this
  value is specified as a string appended to the option itself. The
  associated value for long-form options is always specified as a
  separated argument, immediately following the option (typically
  separated from it by a C<< => >>).
  
  Note that this implies that short-form options may not be able to
  specify every possible associated value (for example, the short-form
  C<-d> option cannot specify defaults with values C<'efault'> or
  C<'$%^!'>).  In such cases, just use the long form of the option
  (for example: S<< C<< -def => 'efault' >> >> or C<< -default=>'$%^!' >>).
  
  
  =head2 Summary of options
  
  Note: For options preceded by an asterisk, the short form is actually
  a Perl file operator, and hence cannot be used by itself.
  Either use the long form of these options,
  or L<bundle them with another option|"Bundling short-form options">,
  or add a L<"no-op"|"Escaping otherwise magic options"> to them.
  
  
      Short   Long
      form    form               Effect
      =====   =============      ======================================
  
      -a      -argv              Prompt for @ARGV data if !@ARGV
  
              -comp[lete]=>SPEC  Complete input on <TAB>, as specified
  
      -dSTR   -def[ault]=>STR    What to return if only <ENTER> typed
              -DEF[AULT]=>STR    (as above, but skip any -must checking)
  
    * -e[STR] -echo=>STR         Echo string for each character typed
  
              -echostyle=>SPEC   What colour/style to echo input in
  
    * -f      -filenames         Input should be name of a readable file
  
              -fail=>VALUE       Return failure if input smartmatches value
  
              -guar[antee]=>SPEC Only allow the specified words to be entered
  
      -h[STR] -hist[ory][=>SPEC] Specify the history set this call belongs to
  
              -in=>HANDLE        Read from specified handle
  
      -i      -integer[=>SPEC]   Accept only valid integers (that smartmatch SPEC)
  
      -k      -keyletters        Accept only keyletters (as specified in prompt)
  
    * -l      -line              Don't autochomp
  
              -menu=>SPEC        Specify a menu of responses to be displayed
  
              -must=>HASHREF     Specify requirements/constraints on input
  
      -n      -num[ber][=>SPEC]  Accept only valid numbers (that smartmatch SPEC)
  
              -out=>HANDLE       Prompt to specified handle
  
              -prompt=>STR       Specify prompt explicitly
  
    * -rSTR   -ret[urn]=>STR     After input, echo this string instead of <CR>
  
    * -s -1   -sing[le]          Return immediately after first key pressed
  
              -stdio             Use STDIN and STDOUT for prompting
  
              -style=>SPEC       What colour/style to display the prompt text in
  
      -tNUM   -time[out]=>NUM    Specify a timeout on the input operation
  
      -v      -verb[atim]        Return the input string (no context sensitivity)
  
              -void              Don't complain in void context
  
    * -w      -wipe              Clear screen
              -wipefirst         Clear screen on first prompt() call only
  
    * -y      -yes    [=> NUM]   Return true if [yY] entered, false otherwise
      -yn     -yesno  [=> NUM]   Return true if [yY] entered, false if [nN]
      -Y      -Yes    [=> NUM]   Return true if Y entered, false otherwise
      -YN     -YesNo  [=> NUM]   Return true if Y entered, false if N
  
    * -_                         No-op (handy for bundling ambiguous short forms)
  
  
  =head2 Automatic options
  
  Any of the options listed above (and described in detail below) can be
  automatically applied to every call to C<prompt()> in the current
  lexical scope, by passing them (via an array reference) as the arguments
  to a C<use IO::Prompter> statement.
  
  For example:
  
      use IO::Prompter;
  
      # This call has no automatically added options...
      my $assent = prompt "Do you wish to take the test?", -yn;
  
      {
          use IO::Prompter [-yesno, -single, -style=>'bold'];
  
          # These three calls all have: -yesno, -single, -style=>'bold' options
          my $ready = prompt 'Are you ready to begin?';
          my $prev  = prompt 'Have you taken this test before?';
          my $hints = prompt 'Do you want hints as we go?';
      }
  
      # This call has no automatically added options...
      scalar prompt 'Type any key to start...', -single;
  
  The current scope's lexical options are always I<prepended> to the
  argument list of any call to C<prompt()> in that scope.
  
  To turn off any existing automatic options for the rest of the current
  scope, use:
  
      use IO::Prompter [];
  
  
  =head2 Prebound options
  
  You can also ask IO::Prompter to export modified versions of C<prompt()>
  with zero or more options prebound. For example, you can request an
  C<ask()> subroutine that acts exactly like C<prompt()> but has the C<-
  yn> option pre-specified, or a C<pause()> subroutine that is C<prompt()>
  with a "canned" prompt and the C<-echo>, C<-single>, and C<-void> options.
  
  To specify such subroutines, pass a single hash reference when
  loading the module:
  
      use IO::Prompter {
          ask     => [-yn],
          pause   => [-prompt=>'(Press any key to continue)', -echo, -single, -void],
      }
  
  Each key will be used as the name of a separate subroutine to be
  exported, and each value must be an array reference, containing the
  arguments that are to be automatically supplied.
  
  The resulting subroutines are simply lexically scoped wrappers around
  C<prompt()>, with the specified arguments prepended to the normal
  argument list, equivalent to something like:
  
      my sub ask {
          return prompt(-yn, @_);
      }
  
      my sub pause {
          return prompt(-prompt=>'(Press any key to continue)', -echo, -single, -void, @_);
      }
  
  Note that these subroutines are lexically scoped, so if you want to use
  them throughtout a source file, they should be declared in the outermost
  scope of your program.
  
  
  =head2 Options reference
  
  =head3 Specifying what to prompt
  
  =over 4
  
  C<< -prompt => I<STRING> >>
  
  C<< -pI<STRING> >>
  
  =back
  
  By default, any argument passed to C<prompt()> that does not begin with
  a hyphen is taken to be part of the prompt string to be displayed before
  the input operation. Moreover, if no such string is specified in the
  argument list, the function supplies a default prompt (C<< '> ' >>)
  automatically.
  
  The C<-prompt> option allows you to specify a prompt explicitly, thereby
  enabling you to use a prompt that starts with a hyphen:
  
      my $input
          = prompt -prompt=>'-echo';
  
  or to disable prompting entirely:
  
      my $input
          = prompt -prompt => "";
  
  Note that the use of the C<-prompt> option doesn't override other string
  arguments, it merely adds its argument to the collective prompt.
  
  =head4 Prompt prettification
  
  If the specified prompt ends in a non-whitespace character, C<prompt()>
  adds a single space after it, to better format the output. On the other
  hand, if the prompt ends in a newline, C<prompt()> removes that
  character, to keep the input position on the same line as the prompt.
  
  You can use that second feature to override the first, if necessary. For
  example, if you wanted your prompt to look like:
  
      Load /usr/share/dict/_
  
  (where the _ represents the input cursor), then a call like:
  
      $filename = prompt 'Load /usr/share/dict/';
  
  would not work because it would automatically add a space, producing:
  
      Load /usr/share/dict/ _
  
  But since a terminal newline is removed, you could achieve the desired effect
  with:
  
      $filename = prompt "Load /usr/share/dict/\n";
  
  If for some reason you I<do> want a newline at the end of the prompt (i.e.
  with the input starting on the next line) just put two newlines at the end
  of the prompt. Only the very last one will be removed.
  
  
  =head3 Specifying how the prompt looks
  
  =over 4
  
  C<< -style  => I<SPECIFICATION> >>
  
  =back
  
  If the C<Term::ANSIColor> module is available, this option can be used
  to specify the colour and styling (e.g. bold, inverse, underlined, etc.)
  in which the prompt is displayed.
  
  You can can specify that styling as a single string:
  
      prompt 'next:' -style=>'bold red on yellow';
  
  or an array of styles:
  
      prompt 'next:' -style=>['bold', 'red', 'on_yellow'];
  
  The range of styles and colour names that the option understands is
  quite extensive. All of the following work as expected:
  
      prompt 'next:' -style=>'bold red on yellow';
  
      prompt 'next:' -style=>'strong crimson on gold';
  
      prompt 'next:' -style=>'highlighted vermilion, background of cadmium';
  
      prompt 'next:' -style=>'vivid russet over amber';
  
      prompt 'next:' -style=>'gules fort on a field or';
  
  However, because C<Term::ANSIColor> maps everything back to the
  standard eight ANSI text colours and seven ANSI text styles, all of the
  above will also be rendered identically. See that module's
  documentation for details.
  
  If C<Term::ANSIColor> is not available, this option is silently ignored.
  
  Please bear in mind that up to 10% of people using your interface will
  have some form of colour vision impairment, so its always a good idea
  to differentiate information by style I<and> colour, rather than by colour
  alone. For example:
  
      if ($dangerous_action) {
          prompt 'Really proceed?', -style=>'bold red underlined';
      }
      else {
          prompt 'Proceed?', -style=>'green';
      }
  
  Also bear in mind that (even though C<-style> does support the C<'blink'>
  style) up to 99% of people using your interface will have Flashing Text
  Tolerance Deficiency. Just say "no".
  
  
  =head3 Specifying where to prompt
  
  =over 4
  
  C<< -out => FILEHANDLE >>
  
  C<< -in => FILEHANDLE >>
  
  C<< -stdio >>
  
  =back
  
  The C<-out> option (which has no short form) is used to specify
  where the prompt should be written to. If this option is not specified,
  prompts are written to the currently C<select>-ed filehandle. The most
  common usage is:
  
      prompt(out => *STDERR)
  
  The C<-in> option (which also has no short form) specifies where the input
  should be read from. If this option is not specified, input is read from
  the C<*ARGV> filehandle. The most common usage is:
  
      prompt(in => *STDIN)
  
  in those cases where C<*ARGV> has been opened to a file, but you still
  wish to interact with the terminal (assuming C<*STDIN> is opened to that
  terminal).
  
  The C<-stdio> option (which again has no short form) is simply a shorthand
  for: C<< -in => *STDIN, -out => *STDOUT >>. This is particularly useful when
  there are arguments on the commandline, but you don't want prompt to treat
  those arguments as filenames for magic C<*ARGV> reads.
  
  
  =head3 Specifying how long to wait for input
  
  =over 4
  
  C<< -timeout => I<N> >>
  
  C<< -tI<N> >>
  
  =back
  
  Normally, the C<prompt()> function simply waits for input. However,
  you can use this option to specify a timeout on the read operation.
  If no input is received within the specified I<N> seconds, the call
  to C<prompt()> either returns the value specified by
  L<the C<-default> option|"Specifying what to return by default">
  (if any), or else an object indicating the read failed.
  
  Note that, if the short form is used, I<N> must be an integer. If the long
  form is used, I<N> may be an integer or floating point value.
  
  You can determine whether an input operation timed out, even if a
  default value was returned, by calling the C<timedout()> method on the
  object returned by C<prompt()>:
  
      if (prompt('Continue?', -y1, -timeout=>60) && !$_->timedout) {
          ...
      }
  
  If a time-out occurred, the return value of C<timedout()> is a string
  describing the timeout, such as:
  
      "timed out after 60 seconds"
  
  
  =head3 Providing a menu of responses
  
  =over
  
  =item C<< -menu => I<SPECIFICATION> >>
  
  =back
  
  You can limit the allowable responses to a prompt, by providing a menu.
  
  A menu is specified using the C<-menu> option, and the menu choices
  are specified as an argument to the option, either as a reference to
  an array, hash, or string, or else as a literal string.
  
  If the menu is specified in a hash, C<prompt()> displays the keys of the
  hash, sorted alphabetically, and with each alternative marked with a
  single alphabetic character (its "selector key").
  
  For example, given:
  
      prompt 'Choose...',
             -menu=>{ 'live free'=>1, 'die'=>0, 'transcend'=>-1 },
             '>';
  
  C<prompt()> will display:
  
      Choose...
          a. die
          b. live free
          c. transcend
      > _
  
  It will then only permit the user to enter a valid selector key (in the
  previous example: 'a', 'b', or 'c'). Once one of the alternatives is
  selected, C<prompt()> will return the corresponding value from the hash
  (0, 1, or -1, respectively, in this case).
  
  Note that the use of alphabetics as selector keys inherently limits the
  number of usable menu items to 52. See L<"Numeric menus"> for a way to
  overcome this limitation.
  
  A menu is treated like a special kind of prompt, so that any
  other prompt strings in the C<prompt()> call will appear either before or
  after the menu of choices, depending on whether they appear before or
  after the menu specification in the call to C<prompt()>.
  
  If an array is used to specify the choices:
  
      prompt 'Choose...',
             -menu=>[ 'live free', 'die', 'transcend' ],
             '>';
  
  then each array element is displayed (in the original array order) with
  a selector key:
  
      Choose...
          a. live free
          b. die
          c. transcend
      > _
  
  and C<prompt()> returns the element corresponding to the selection (i.e.
  it returns 'live free' if 'a' is entered, 'die' if 'b' is entered, or
  'transcend' if 'c' is entered).
  
  Hence, the difference between using an array and a hash is that the
  array allows you to control the order of items in the menu, whereas a
  hash allows you to show one thing (i.e. keys) but have something related
  (i.e. values) returned instead.
  
  If the argument after C<-menu> is a string or a reference to a string, the
  option splits the string on newlines, and treats the resulting list as if it
  were an array of choices. This is useful, for example, to request the user
  select a filename:
  
      my $files = `ls`;
      prompt 'Select a file...', -menu=>$files, '>';
  
  
  =head4 Numbered menus
  
  As the previous examples indicate, each menu item is given a unique
  alphabetic selector key. However, if the C<-number> or C<-integer>
  option is specified as well:
  
      prompt 'Choose...',
             -number,
             -menu=>{ 'live free'=>1, 'die'=>0, 'transcend'=>-1 },
             '>';
  
  C<prompt()> will number each menu item instead, using consecutive integers
  as the selector keys:
  
      Choose...
          1. die
          2. live free
          3. transcend
      > _
  
  This allows for an unlimited number of alternatives in a single menu,
  but prevents the use of C<-single> for one-key selection from menus if
  the menu has more than nine items.
  
  
  =head4 Hierarchical menus
  
  If you use a hash to specify a menu, the values of the hash do not have
  to be strings. Instead, they can be references to nested hashes or
  arrays.
  
  This allows you to create hierarchical menus, where a selection at the
  top level may lead to a secondary menu, etc. until an actual choice is
  possible. For example, the following call to prompt:
  
      my $choices = {
          animates => {
              animals => {
                  felines => [qw<cat lion lynx>],
                  canines => [qw<dog fox wolf>],
                  bovines => [qw<cow ox buffalo>],
              },
              fish => [qw<shark carp trout bream>],
          },
          inanimates => {
              rocks     => [qw<igneous metamorphic sedimentary>],
              languages => [qw<Perl Python Ruby Tcl>],
          },
      };
  
      my $result = prompt -1, 'Select a species...', -menu=>$choices, '> ';
  
  might result in an interaction like this:
  
      Select a species...
      a.  animates
      b.  inanimates
      > a
  
      Select from animates:
      a.  animals
      b.  fish
      > b
  
      Select from fish:
      a.  shark
      b.  carp
      c.  trout
      d.  bream
      > c
  
  At which point, C<prompt()> would return the string C<'trout'>.
  
  Note that you can nest an arbitrary number of hashes, but that each
  "bottom" level choice has to be either a single string, or an array
  of strings.
  
  
  =head4 Navigating hierarchical menus
  
  Within a hierarchical menu, the user must either select a valid option
  (by entering the corresponding letter), or else may request that they be
  taken back up a level in the hierarchy, by entering C<< <ESC> >>.
  Pressing C<< <ESC> >> at the top level of a menu causes the call to
  C<prompt()> to immediately return with failure.
  
  
  =head3 Simulating a command-line
  
  =over 4
  
  C<< -argv >>
  
  C<< -a  >>
  
  =back
  
  The C<prompt()> subroutine can be used to request that the user provide
  command-line arguments interactively. When requested, the input
  operation is only carried out if C<@ARGV> is empty.
  
  Whatever the user enters is broken into a list and assigned to C<@ARGV>.
  
  The input is first C<glob>bed for file expansions, and has any
  environment variables (of the form C<$VARNAME> interpolated). The
  resulting string is then broken into individual words, except where
  parts of it contain single or double quotes, the contents of which are
  always treated as a single string.
  
  This feature is most useful during development, to allow a program to be
  run from within an editor, and yet pass it a variety of command-lines. The
  typical usage is (at the start of a program):
  
      use IO::Prompter;
      BEGIN { prompt -argv }
  
  However, because this pattern is so typical, there is a shortcut:
  
      use IO::Prompter -argv;
  
  You can also specify the name with which the program args, are to
  be prompted, in the usual way (i.e. by providing a prompt):
  
      use IO::Prompter -argv, 'demo.pl';
  
  Note, however, the critical difference between that shortcut
  (which calls C<prompt -argv> when the module is loaded) and:
  
      use IO::Prompter [-argv];
  
  (which sets C<-argv> as an automatic option for every subsequent call to
  C<prompt()> in the current lexical scope).
  
  Note too that the C<-argv> option also implies C<-complete=>'filenames'>.
  
  
  =head3 Input autocompletion
  
  =over 4
  
  C<< -comp[lete] => I<SPECIFICATION> >>
  
  =back
  
  When this option is specified, the C<prompt()> subroutine will complete
  input using the specified collection of strings. By default, when
  completion is active, word completion is requested using the C<< <TAB> >>
  key, but this can be changed by setting the C<$IO_PROMPTER_COMPLETE_KEY>
  environment variable. Once completion has been initiated, you can use
  the completion key or else C<< <CTRL-N> >> to advance to the next completion
  candidate. You can also use C<< <CTRL-P> >> to back up to the previous
  candidate.
  
  The specific completion mechanism can be defined either using a
  subroutine, an array reference, a hash reference, or a special string:
  
      Specification       Possible completions supplied by...
  
        sub {...}         ...whatever non-subroutine specification
                          (as listed below) is returned when the
                          subroutine is called. The subroutine is passed
                          the words of the current input text, split on
                          whitespace, as its argument list.
  
          [...]           ...the elements of the array
  
          {...}           ...the keys of the hash
  
       'filenames'        ...the list of files supplied by globbing the
                          last whitespace-separated word of the input text
  
       'dirnames'         ...the list of directories supplied by globbing the
                          last whitespace-separated word of the input text
  
  If an array or hash is used, only those elements or keys that begin with
  the last whitespace-separated word of the current input are offered as
  completions.
  
  For example:
  
      # Complete with the possible commands...
      my $next_cmd
          = prompt -complete => \%cmds;
  
      # Complete with valid usernames...
      my $user
          = prompt -complete => \@usernames;
  
      # Complete with valid directory names...
      my $file
          = prompt -complete => 'dirnames';
  
      # Complete with cmds on the first word, and filenames on the rest...
      my $cmdline
          = prompt -complete => sub { @_ <= 1 ? \%cmds : 'filenames' };
  
  
  =head4 Completing from your own input history
  
  The C<prompt()> subroutine also tracks previous input and allows you to
  complete with that instead. No special option is required, as the
  feature is enabled by default.
  
  At the start of a prompted input, the user can cycle backwards through
  previous inputs by pressing C<< <CTRL-R> >> (this can be changed
  externally by setting the C<$IO_PROMPTER_HISTORY_KEY> environment
  variable, or internally by assigning a new keyname to
  C<$ENV{IO_PROMPTER_HISTORY_KEY}>). After the first C<< <CTRL-R> >>,
  subsequent C<< <CTRL-R> >>'s will recall earlier inputs. You can also
  use C<< <CTRL-N> >> and C<< <CTRL-P> >>
  (as in L<user-specified completions|"Input autocompletion">) to move
  back and forth through your input history.
  
  If the user has already typed some input, the completion mechanism
  will only show previous inputs that begin with that partial input.
  
  
  =head4 History sets
  
  =over 4
  
  =item C<< -h[NAME] >>
  
  =item C<< -hist[ory] [=> NAME] >>
  
  =back
  
  By default, IO::Prompter tracks every call to C<prompt()> within a
  program, and accumulates a single set of history completions for all of
  them. That means that, at any prompt, C<< <CTRL-R> >> will take the user
  back through I<every> previous input, regardless of which call to
  C<prompt()> originally retrieved it.
  
  Sometimes that's useful, but sometimes you might prefer that different
  calls to C<prompt()> retained distinct memories. For example, consider
  the following input loop:
  
      while (my $name = prompt 'Name:') {
          my $grade   = prompt 'Grade:', -integer;
          my $comment = prompt 'Comment:';
          ...
      }
  
  If you're entering a name, there's no point in C<prompt()> offering
  to complete it with previous grades or comments. In fact, that's
  just annoying.
  
  IO::Prompter allows you to specify that a particular call to
  C<prompt()> belongs to a particular "history set". Then it completes
  input history using only the history of those calls belonging to the
  same history set.
  
  So the previous example could be improved like so:
  
      while (my $name = prompt 'Name:', -hNAME) {
          my $grade   = prompt 'Grade:', -hGRADE, -integer;
          my $comment = prompt 'Comment:', -hOTHER;
          ...
      }
  
  Now, when prompting for a name, only those inputs in the C<'NAME'>
  history set will be offered as history completions. Likewise only
  previous grades will be recalled when prompting for grades and earlier
  only comments when requesting comments.
  
  If you specify the C<-h> or C<-history> option without providing the
  name of the required history set, C<prompt()> uses the prompt text
  itself as the name of the call's history set. So the previous example
  would work equally well if written:
  
      while (my $name = prompt 'Name:', -h) {
          my $grade   = prompt 'Grade:', -h, -integer;
          my $comment = prompt 'Comment:', -h;
          ...
      }
  
  though now the names of the respective history sets would now be
  C<'Name: '>, C<'Grade: '>, and C<'Comment: '>. This is by far the more
  common method of specifying history sets, with explicitly named sets
  generally only being used when two or more separate calls to
  C<prompt()> have to share a common history despite using distinct
  prompts. For example:
  
      for my $n (1..3) {
          $address .= prompt "Address (line $n):", -hADDR;
      }
  
  If you specify C<'NONE'> as the history set, the input is not
  recorded in the history. This is useful when inputting passwords.
  
  
  =head4 Configuring the autocompletion interaction
  
  By default, when user-defined autocompletion is requested, the
  C<prompt()> subroutine determines the list of possible completions,
  displays it above the prompt, and completes to the longest common
  prefix. If the completion key is pressed again immediately, the
  subroutine then proceeds to complete with each possible completion in a
  cyclic sequence. This is known as "list+longest full" mode.
  
  On the other hand, when historical completion is requested, C<prompt()>
  just immediately cycles through previous full inputs. This is known as "full"
  mode.
  
  You can change these behaviours by setting the
  C<$IO_PROMPTER_COMPLETE_MODES> and C<$IO_PROMPTER_HISTORY_MODES>
  environment variables I<before the module is loaded> (either in your shell,
  or in a C<BEGIN> block before the module is imported).
  
  Specifically, you can set the individual string values of either of
  these variables to a whitespace-separated sequence containing any of the
  following:
  
      list         List all options above the input line
  
      longest      Complete to the longest common prefix
  
      full         Complete with each full match in turn
  
  For example:
  
      # Just list options without actually completing...
      BEGIN{ $ENV{IO_PROMPTER_COMPLETE_MODES} = 'list'; }
  
      # Just cycle full alternatives on each <TAB>...
      BEGIN{ $ENV{IO_PROMPTER_COMPLETE_MODES} = 'full'; }
  
      # For history completion, always start with the
      # longest common prefix on the first <CTRL-R>,
      # then just list the alternatives on a subsequent press...
      BEGIN{ $ENV{IO_PROMPTER_HISTORY_MODES} = 'longest list'; }
  
  
  =head3 Specifying what to return by default
  
  =over
  
  C<< -DEF[AULT] => I<STRING> >>
  
  C<< -def[ault] => I<STRING> >>
  
  C<< -dI<STRING> >>
  
  =back
  
  If a default value is specified, that value will be returned if the user
  enters an empty string at the prompt (i.e. if they just hit
  C<< <ENTER>/<RETURN> >> immediately) or if the input operation times out under
  L<the C<timeout> option|"Specifying how long to wait for input">.
  
  Note that the default value is not added to the prompt, unless you
  do so yourself. A typical usage might therefore be:
  
      my $frequency
          = prompt "Enter polling frequency [default: $DEF_FREQ]",
                   -num, -def=>$DEF_FREQ;
  
  You can determine if the default value was autoselected (as opposed to
  the same value being typed in explicitly) by calling the C<defaulted()>
  method on the object returned by C<prompt()>, like so:
  
      if ($frequency->defaulted) {
          say "Using default frequency";
      }
  
  If you use the L<< C<-must> option|"Constraining what can be returned" >>
  any default value must also satisfy all the constraints you specify,
  unless you use the C<-DEFAULT> form, which skips constraint checking
  when the default value is selected.
  
  If you use the L<< C<-menu> option|"Providing a menu of responses" >>,
  the specified default value will be returned immediately C<< <ENTER>/<RETURN> >> is
  pressed, regardless of the depth you are within the menu. Note that the
  default value specifies the value to be returned, not the selector key
  to be entered. The default value does not even have to be one of the
  menu choices.
  
  
  =head3 Specifying what to echo on input
  
  =over
  
  C<< -echo => I<STR> >>
  
  C<< -eI<STR> >>
  
  =back
  
  When this option is specified, the C<prompt()> subroutine will echo the
  specified string once for each character that is entered. Typically this
  would be used to shroud a password entry, like so:
  
      # Enter password silently:
      my $passwd
          = prompt 'Password:', -echo=>"";
  
      # Echo password showing only asterisks:
      my $passwd
          = prompt 'Password:', -echo=>"*";
  
  As a special case, if the C<-echo> value contains a slash (C</>) and the
  any of the <-yesno> options is also specified, the substring before the
  slash is taken as the string to echo for a 'yes' input, and the
  substring after the slash is echoed for a 'no' input.
  
  Note that this option is only available when the Term::ReadKey module
  is installed. If it is used when that module is not available, a warning
  will be issued.
  
  
  =head4 Specifying how to echo on input
  
  C<< -echostyle => I<SPECIFICATION> >>
  
  The C<-echostyle> option works for the text the user types in
  the same way that the C<-style> option works for the prompt.
  That is, you can specify the style and colour in which the user's
  input will be rendered like so:
  
      # Echo password showing only black asterisks on a red background:
      my $passwd
          = prompt 'Password:', -echo=>"*", -echostyle=>'black on red';
  
  Note that C<-echostyle> is completely independent of C<-echo>:
  
      # Echo user's name input in bold white:
      my $passwd
          = prompt 'Name:', -echostyle=>'bold white';
  
  The C<-echostyle> option requires C<Term::ANSIColor>, and will
  be silently ignored if that module is not available.
  
  
  =head4 Input editing
  
  When the Term::ReadKey module is available, C<prompt()> also honours a
  subset of the usual input cursor motion commands:
  
  =over
  
  =item C<CTRL-B>
  
  Move the cursor back one character
  
  =item C<CTRL-F>
  
  Move the cursor forward one character
  
  =item C<CTRL-A>
  
  Move the cursor to the start of the input
  
  =item C<CTRL-E>
  
  Move the cursor to the end of the input
  
  =back
  
  
  =head3 Specifying when input should fail
  
  =over 4
  
  C<< -fail => I<VALUE> >>
  
  C<< -fI<STRING> >>
  
  =back
  
  If this option is specified, the final input value is compared with the
  associated string or value, by smartmatching just before the call to
  C<prompt()> returns. If the two match, C<prompt()> returns a failure
  value. This means that instead of writing:
  
      while (my $cmd = prompt '>') {
          last if $cmd eq 'quit';
          ...
      }
  
  you can just write:
  
      while (my $cmd = prompt '>', -fail=>'quit') {
          ...
      }
  
  
  =head3 Constraining what can be typed
  
  =over 4
  
  =item C<< -guar[antee] => SPEC >>
  
  =back
  
  This option allows you to control what input users can provide.
  The specification can be a regex or a reference to an array or a hash.
  
  If the specification is a regex, that regex is matched against the input
  so far, every time an extra character is input. If the regex ever fails
  to match, the guarantee fails.
  
  If the specification is an array, the input so far is matched against
  the same number of characters from the start of each of the (string)
  elements of the array. If none of these substrings match the input, the
  guarantee fails.
  
  If the specification is a hash, the input so far is matched against the
  same number of characters from the start of each key of the hash. If
  none of these substrings match the input, the guarantee fails.
  
  If the guarantee fails, the input is rejected
  (just as L<< the C<-must> option|"Constraining what can be returned" >>
  does). However, unlike C<-must>, C<-guarantee> rejects the input
  character-by-character as it typed, and I<before> it is even echoed. For
  example, if your call to C<prompt()> is:
  
      my $animal = prompt -guarantee=>['cat','dog','cow'];
  
  then at the prompt:
  
      > _
  
  you will only be able to type in 'c' or 'd'. If you typed 'c', then you would
  only be able to type 'a' or 'o'. If you then typed 'o', you would only be able
  to type 'w'.
  
  In other words, C<-guarantee> ensures that you can only type in a valid input,
  and simply ignores any typing that would not lead to such an input.
  
  To help users get the input right, specifying C<-guarantee> as an array
  or hash reference also automatically specifies a
  L<< C<-complete> option|"Input autocompletion" >> with the array or hash
  as its completion list as well. So, whenever a C<-guarantee> is in
  effect, the user can usually autocomplete the acceptable inputs.
  
  Note, however, that C<-guarantee> can only reject (or autocomplete)
  input as it is typed if the Term::ReadKey module is available. If that
  module cannot be loaded, C<-guarantee> only applies its test after the
  C<< <ENTER>/<RETURN> >> key is pressed, and there will be no autocompletion
  available.
  
  =head4 Constraining input to numbers
  
  =over 4
  
  =item C<< -i >>
  
  =item C<< -integer [=> SPEC] >>
  
  =item C<< -n  >>
  
  =item C<< -num[ber] [=> SPEC] >>
  
  =back
  
  If any of these options are specified, C<prompt()> will only accept a valid
  integer or number as input, and will reprompt until one is entered.
  
  If you need to restrict the kind of number further (say, to positive
  integers), you can supply an extra constraint as an argument to the
  long-form option. Any number entered must satisfy this constraint by
  successfully smart-matching it. For example:
  
      $rep_count = prompt 'How many reps?', -integer => sub{ $_ > 0 };
  
      $die_roll = prompt 'What did you roll?', -integer => [1..6];
  
      $factor = prompt 'Prime factor:', -integer => \&is_prime;
  
      $score = prompt 'Enter score:', -number => sub{ 0 <= $_ && $_ <= 100 };
  
  If the constraint is specified as a subroutine, the entered number will be
  passed to it both as its single argument and in C<$_>.
  
  You cannot pass a scalar value directly as a constraint, except those strings
  listed below. If you want a scalar value as a constraint, use a regex or
  array reference instead:
  
      # Wrong...
      $answer = prompt "What's the ultimate answer?",
                        -integer => 42;
  
      # Use this instead...
      $answer = prompt "What's the ultimate answer?",
                       -integer => qr/^42$/;
  
      # Or this...
      $answer = prompt "What's the ultimate answer?",
                       -integer => [42];
  
  
  Only the following strings may be passed directly as scalar value
  constraints. They do mot match exactly, but instead act as specifiers
  for one or more built-in constraints. You can also pass a string that
  contains two or more of them, separated by whitespace, in which case
  they must all be satisfied. The specifiers are:
  
  =over 4
  
  =item C<'pos'> or C<'positive'>
  
  The number must be greater than zero
  
  =item C<'neg'> or C<'negative'>
  
  The number must be less than zero
  
  =item C<'zero'>
  
  The number must be equal to zero
  
  =item C<'even'> or C<'odd'>
  
  The number must have the correct parity
  
  =back
  
  You can also prepend C<"non"> to any of the above to reverse their meaning.
  
  For example:
  
      $rep_count = prompt 'How much do you bid?', -number => 'positive';
  
      $step_value = prompt 'Next step:', -integer => 'even nonzero';
  
  
  =head4 Constraining input to filenames
  
  =over 4
  
  =item C<< -f >>
  
  =item C<< -filenames >>
  
  =back
  
  You can tell C<prompt()> to accept only valid filenames, using the
  C<-filenames> option (or its shortcut: C<-f>).
  
  This option is equivalent to the options:
  
      -must => {
          'File must exist'       => sub { -e },
          'File must be readable' => sub { -r },
      },
      -complete => 'filenames',
  
  In other words C<-filenames> requires C<prompt()> to accept only the name
  of an existing, readable file, and it also activates filename completion.
  
  
  =head4 Constraining input to "keyletters"
  
  =over
  
  =item C<< -k >>
  
  =item C<< -key[let[ter]][s] >>
  
  =back
  
  A common interaction is to offer the user a range of actions, each of
  which is specified by keying a unique letter, like so:
  
      INPUT:
      given (prompt '[S]ave, (R)evert, or (D)iscard:', -default=>'S') {
          when (/R/i) { revert_file()  }
          when (/D/i) { discard_file() }
          when (/S/i) { save_file()    }
          default     { goto INPUT;    }
      }
  
  This can be cleaned up (very slightly) by using a guarantee:
  
      given (prompt '[S]ave, (R)evert, or (D)iscard:', -default=>'S',
                    -guarantee=>qr/[SRD]/i
      ) {
          when (/R/i) { revert_file()  }
          when (/D/i) { discard_file() }
          default     { save_file()    }
      }
  
  However, it's still annoying to have to specify the three key letters
  twice (and the default choice three times) within the call to
  C<prompt()>. So IO::Prompter provides an option that extracts this
  information directly from the prompt itself:
  
      given (prompt '[S]ave, (R)evert, or (D)iscard:', -keyletters) {
          when (/R/i) { revert_file()  }
          when (/D/i) { discard_file() }
          default     { save_file()    }
      }
  
  This option scans the prompt string and extracts any purely alphanumeric
  character sequences that are enclosed in balanced brackets of any kind
  (square, angle, round, or curly). It then makes each of these character
  sequences a valid input (by implicitly setting the C<-guarantee>
  option), and adds the first option in square brackets (if any) as the
  C<-default> value of the prompt.
  
  Note that the key letters don't have to be at the start of a word, don't
  have to be a single character, and can be either upper or lower case.
  For example:
  
      my $action = prompt -k, '(S)ave, Save(a)ll, (Ex)it without saving';
  
  Multi-character key letters are often a good choice for options with
  serious or irreversible consequences.
  
  A common idiom with key letters is to use the C<-single> option as well,
  so that pressing any key letter immediately completes the input, without
  the user having to also press C<< <ENTER>/<RETURN> >>:
  
      given (prompt -k1, '[S]ave, (R)evert, or (D)iscard:') {
          when (/R/i) { revert_file()  }
          when (/D/i) { discard_file() }
          default     { save_file()    }
      }
  
  
  
  =head3 Preserving terminal newlines
  
  =over 4
  
  =item C<< -l  >>
  
  =item C<< -line >>
  
  =back
  
  The (encapsulated) string returned by C<prompt()> is automatically chomped by
  default. To prevent that chomping, specify this option.
  
  
  =head3 Constraining what can be returned
  
  =over 4
  
  =item C<< -must => HASHREF >>
  
  =back
  
  This option allows you to specify requirements and constraints on the input
  string that is returned by C<prompt()>. These limitations are specified as the
  values of a hash.
  
  If the C<-must> option is specified, once input is complete every value in the
  specified hash is smartmatched against the input text. If any of them fail to
  match, the input is discarded, the corresponding hash key is printed as an
  error message, and the prompt is repeated.
  
  Note that the values of the constraint hash cannot be single strings or
  numbers, except for certain strings (such as C<'pos'>, C<'nonzero'>, or
  C<'even'>, as described in L<"Constraining input to numbers">).
  
  If you want to constrain the input to a single string or number (a very
  unusual requirement), just place the value in an array, or match it
  with a regex:
  
      # This doesn't work...
      my $magic_word = prompt "What's the magic word?",
                              -must => { 'be polite' => 'please' };
  
      # Use this instead...
      my $magic_word = prompt "What's the magic word?",
                              -must => { 'be polite' => ['please'] };
  
      # Or, better still...
      my $magic_word = prompt "What's the magic word?",
                              -must => { 'be polite' => qr/please/i };
  
  
  The C<-must> option allows you to test inputs against multiple
  conditions and have the appropriate error messages for each displayed.
  It also ensures that, when C<prompt()> eventually returns, you are
  guaranteed that the input meets all the specified conditions.
  
  For example, suppose the user is required to enter a positive odd prime
  number less than 100. You could enforce that with:
  
      my $opnlt100 = prompt 'Enter your guess:',
                            -integer,
                            -must => { 'be odd'                 => 'odd',
                                       'be in range'            => [1..100],
                                       'It must also be prime:' => \&isprime,
                                     };
  
  Note that, if the error message begins with anything except an uppercase
  character, the prompt is reissued followed by the error message in
  parentheses with the word "must" prepended (where appropriate).
  Otherwise, if the error message does start with an uppercase character,
  the prompt is not reissued and the error message is printed verbatim. So
  a typical input sequence for the previous example might look like:
  
      Enter your guess: 101
      Enter your guess: (must be in range) 42
      It must also be prime: 2
      Enter your guess: (must be odd) 7
  
  at which point, the call to C<prompt()> would accept the input and return.
  
  See also L<the C<-guarantee> option|"Constraining what can be typed">,
  which allows you to constrain inputs as they are typed, rather than
  after they are entered.
  
  
  =head3 Changing how returns are echoed
  
  =over 4
  
  =item C<< -r[STR] >>
  
  =item C<< -ret[urn] [=> STR] >>
  
  =back
  
  When C<< <ENTER>/<RETURN> >> is pressed, C<prompt()> usually echoes a carriage return.
  However, if this option is given, C<prompt()> echoes the specified string
  instead. If the string is omitted, it defaults to C<"\n">.
  
  For example:
  
      while (1) {
          my $expr = prompt 'Calculate:', -ret=>' = ';
          say evaluate($expr);
      }
  
  would prompt for something like this:
  
      Calculate: 2*3+4^5_
  
  and when the C<< <ENTER>/<RETURN> >> key is pressed, respond with:
  
      Calculate: 2*3+4^5 = 1030
      Calculate: _
  
  The string specified with C<-return> is also automatically echoed if the
  L<< C<-single> option|"Single-character input" >> is used. So if you
  don't want the automatic carriage return that C<-single> mode supplies,
  specify C<< -return=>"" >>.
  
  
  =head3 Single-character input
  
  =over 4
  
  =item C<< -s >>
  
  =item C<< -1 >>
  
  =item C<< -sing[le] >>
  
  =back
  
  This option causes C<prompt()> to return immediately once any single
  character is input. The user does not have to push the C<< <ENTER>/<RETURN> >>
  key to complete the input operation. C<-single> mode input is only
  available if the Term::ReadKey module can be loaded.
  
  By default, C<prompt()> echoes the single character that is entered. Use
  the L<C<-echo> option|"Specifying what to echo on input"> to change or
  prevent that.
  
      # Let user navigate through maze by single, silent keypresses...
      while ($nextdir = prompt "\n", -single, -echo, -guarantee=>qr/[nsew]/) {
          move_player($nextdir);
      }
  
  Unless echoing has been disabled, by default C<prompt()> also supplies a
  carriage return after the input character. Use
  L<the C<-return> option|"Changing how returns are echoed"> to change
  that behaviour. For example, this:
  
      my $question = <<END_QUESTION;
      Bast is the goddess of: (a) dogs  (b) cats  (c) cooking  (d) war?
      Your answer:
      END_QUESTION
  
      my $response = prompt $question, -1, -return=>' is ', -g=>['a'..'d'];
      say $response eq $answer ? 'CORRECT' : 'incorrect';
  
  prompts like this:
  
      Bast is the goddess of: (a) dogs  (b) cats  (c) cooking  (d) war?
      Your answer: _
  
  accepts a single character, like so:
  
      Bast is the goddess of: (a) dogs  (b) cats  (c) cooking  (d) war?
      Your answer: b_
  
  and completes the line thus:
  
      Bast is the goddess of: (a) dogs  (b) cats  (c) cooking  (d) war?
      Your answer: b is CORRECT
      _
  
  
  =head3 Returning raw data
  
  =over 4
  
  =item C<< -v >>
  
  =item C<< -verb[atim] >>
  
  =back
  
  Normally, C<prompt()> returns a special object that contains the text
  input, the success value, and other information such as whether the
  default was selected and whether the input operation timed out.
  
  However, if you prefer to have C<prompt()> just return the input text string
  directly, you can specify this option.
  
  Note however that, under C<-verbatim>, the input is still
  autochomped (unless you also specify
  L<the C<-line> option|"Preserving terminal newlines">.
  
  
  =head3 Prompting on a clear screen
  
  =over 4
  
  =item C<< -w >>
  
  =item C<< -wipe[first] >>
  
  =back
  
  If this option is present, C<prompt()> prints 1000 newlines before
  printing its prompt, effectively wiping the screen clear of other text.
  
  If the C<-wipefirst> variant is used, the wipe will only occur if the
  particular call to C<prompt()> is the first such call anywhere in your
  program. This is useful if you'd like the screen cleared at the start of
  input only, but you're not sure which call to C<prompt()> will happen
  first: just use C<-wipefirst> on all possible initial calls and only the
  actual first call will wipe the screen.
  
  
  =head3 Requesting confirmations
  
  =over 4
  
  =item C<< -y[n] >> or C<< -Y[N] >>
  
  =item C<< -yes[no] >> or C<< -Yes[No] >>
  
  =item C<< -yes[no] => COUNT >> or C<< -Yes[No] => COUNT >>
  
  =back
  
  This option invokes a special mode that can be used to confirm (or deny)
  something. If one of these options is specified, C<prompt> still
  returns the user's input, but the success or failure of the object returned
  now depends on what the user types in.
  
  A true result is returned if C<'y'> is the first character entered. If
  the flag includes an C<n> or C<N>, a false result is returned if C<'n'>
  is the first character entered (and any other input causes the prompt to
  be reissued). If the option doesn't contain an C<n> or C<N>, any input
  except C<'y'> is treated as a "no" and a false value is returned.
  
  If the option is capitalized (C<-Y> or C<-YN>), the first letter of the
  input must be likewise a capital (this is a handy means of slowing down
  automatic unthinking C<y>..."Oh no!" responses to potentially serious
  decisions).
  
  This option is most often used in conjunction with the C<-single> option, like
  so:
  
      $continue = prompt("Continue? ", -yn1);
  
  so that the user can just hit C<y> or C<n> to continue, without having to hit
  C<< <ENTER>/<RETURN> >> as well.
  
  If the optional I<COUNT> argument is supplied, the prompting is repeated
  that many times, with increasingly insistent requests for confirmation.
  The answer must be "yes" in each case for the final result to be true.
  For example:
  
      $rm_star = prompt("Do you want to delete all files? ", -Yes=>3 );
  
  might prompt:
  
      Do you want to delete all files?  Y
      Really?  Y
      Are you sure?  Y
  
  
  
  =head3 Bundling short-form options
  
  You can bundle together any number of short-form options, including those that
  take string arguments. For example, instead of writing:
  
      if (prompt "Continue? ", -yes, -1, -t10, -dn) {
  
  you could just write:
  
      if (prompt "Continue? ", -y1t10dn) {...}
  
  This often does I<not> improve readability (as the preceding example
  demonstrates), but is handy for common usages such as C<-y1> ("ask for
  confirmation, don't require an C<< <ENTER>/<RETURN> >>) or C<-vl>
  ("Return a verbatim and unchomped string").
  
  
  =head3 Escaping otherwise-magic options
  
  =over 4
  
  C<< -_ >>
  
  =back
  
  The C<-_> option exists only to be an explicit no-op. It allows you to
  specify short-form options that would otherwise be interpreted as Perl
  file operators or other special constructs, simply by prepending or
  appending a C<_> to them. For example:
  
      my $input
          = prompt -l_;  # option -l, not the -l file operator.
  
  The following single-letter options require an underscore to chaperone them
  when they're on their own: C<-e>, C<-l>, C<-r>, C<-s>, C<-w>, and C<-y>.
  However, an underscore is not required if two or more are bundled together.
  
  
  =head2 Useful useless uses of C<prompt()>
  
  Normally, in a void context, a call to C<prompt()> issues a warning that
  you are doing an input operation whose input is immediately thrown away.
  
  There is, however, one situation where this useless use of C<prompt()> in a
  void context is actually useful:
  
      say $data;
      prompt('END OF DATA. Press any key to exit', -echo, -single);
      exit;
  
  Here, we're using prompt simply to pause the application after the data is
  printed. It doesn't matter what the user types in; the typing itself is the
  message (and the message is "move along").
  
  In such cases, the "useless use..." warning can be suppressed using the 
  C<< -void >> option:
  
      say $data;
      prompt('END OF DATA. Press any key to exit', -echo, -single, -void);
      exit;
  
  
  =head2 Simulating input
  
  IO::Prompter provides a mechanism with which you can "script" a sequence of
  inputs to an application. This is particularly useful when demonstrating
  software during a presentation, as you do not have to remember what to type,
  or concentrate on typing at all.
  
  If you pass a string as an argument to C<use IO::Prompter>, the
  individual lines of that string are used as successive input lines to
  any call to C<prompt()>. So for example, you could specify several sets
  of input data, like so:
  
      use IO::Prompter <<END_DATA
      Leslie
      45
      165
      Jessie
      28
      178
      Dana
      12
      120
      END_DATA
  
  and then read this data in an input loop:
  
      while (my $name   = prompt 'Name:') {
             my $age    = prompt 'Age:';
             my $height = prompt 'Height:';
  
             process($name, $age, $height);
      }
  
  Because the C<use IO::Prompter> supplies input data,
  the three calls to C<prompt()> will no longer read
  data from C<*ARGV>. Instead they will read it from
  the supplied input data.
  
  Moreover, each call to C<prompt()> will simulate the typing-in process
  automatically. That is, C<prompt()> uses a special input mode where,
  each time you press a keyboard letter, it echoes not that character, but
  rather the next character from the specified input. The effect is that
  you can just type on the keyboard at random, but have the correct input
  appear. This greatly increases the convincingness of the simulation.
  
  If at any point, you hit C<< <ENTER>/<RETURN> >> on the keyboard, C<prompt()>
  finishes typing in the input for you (using a realistic typing speed),
  and returns the input string. So you can also just hit C<< <ENTER>/<RETURN> >>
  when the prompt first appears, to have the entire line of input typed
  for you.
  
  Alternatively, if you hit C<< <ESC> >> at any point, C<prompt()> escapes
  from the simulated input mode for that particular call to C<prompt()>,
  and allows you to (temporarily) type text in directly. If you enter only
  a single C<< <ESC> >>, then C<prompt()> throws away the current line of
  simulated input; if you enter two C<< <ESC> >>'s, the simulated input is
  merely deferred to the next call to C<prompt()>.
  
  All these keyboard behaviours require the Term::ReadKey module to be
  available. If it isn't, C<prompt()> falls back on a simpler simulation,
  where it just autotypes each entire line for you and pauses at the
  end of the line, waiting for you to hit C<< <ENTER>/<RETURN> >> manually.
  
  Note that any line of the simulated input that begins with
  a <CTRL-D> or <CTRL-Z> is treated as an input failure (just as
  if you'd typed that character as input).
  
  =head1 DIAGNOSTICS
  
  All non-fatal diagnostics can be disabled using a C<no warnings> with the
  appropriate category.
  
  =over
  
  =item C<< prompt(): Can't open *ARGV: %s >>
  
  (F)  By default, C<prompt()> attempts to read input from
       the C<*ARGV> filehandle. However, it failed to open
       that filehandle. The reason is specified at the end of
       the message.
  
  
  =item C<< prompt(): Missing value for %s (expected %s) >>
  
  (F)  A named option that requires an argument was specified,
       but no argument was provided after the option. See
       L<"Summary of options">.
  
  
  =item C<< prompt(): Invalid value for %s (expected %s) >>
  
  (F)  The named option specified expects an particular type
       of argument, but found one of an incompatible type
       instead. See L<"Summary of options">.
  
  
  =item C<< prompt(): Unknown option %s ignored >>
  
  (W misc)  C<prompt()> was passed a string starting with
            a hyphen, but could not parse that string as a
            valid option. The option may have been misspelt.
            Alternatively, if the string was supposed to be
            (part of) the prompt, it will be necessary to use
            L<the C<-prompt> option|"Specifying what to
            prompt"> to specify it.
  
  
  =item C<< prompt(): Unexpected argument (% ref) ignored >>
  
  (W reserved)  C<prompt()> was passed a reference to
                an array or hash or subroutine in a position
                where an option flag or a prompt string was
                expected. This may indicate that a string
                variable in the argument list didn't contain
                what was expected, or a reference variable was
                not properly dereferenced. Alternatively, the
                argument may have been intended as the
                argument to an option, but has become
                separated from it somehow, or perhaps the
                option was deleted without removing the
                argument as well.
  
  
  =item C<< Useless use of prompt() in void context >>
  
  (W void)  C<prompt()> was called but its return value was
            not stored or used in any way. Since the
            subroutine has no side effects in void context,
            calling it this way achieves nothing. Either make
            use of the return value directly or, if the usage
            is deliberate, put a C<scalar> in front of the
            call to remove the void context.
  
  
  =item C<< prompt(): -default value does not satisfy -must constraints >>
  
  (W misc)  The C<-must> flag was used to specify one or more
            input constraints. The C<-default> flag was also
            specified. Unfortunately, the default value
            provided did not satisfy the requirements
            specified by the C<-must> flag. The call to
            C<prompt()> will still go ahead (after issuing the
            warning), but the default value will never be
            returned, since the constraint check will reject
            it. It is probably better simply to include the
            default value in the list of constraints.
  
  
  =item C<< prompt(): -keyletters found too many defaults >>
  
  (W ambiguous)  The C<-keyletters> option was specified,
                 but analysis of the prompt revealed two or
                 more character sequences enclosed in square
                 brackets. Since such sequences are taken to
                 indicate a default value, having two or more
                 makes the default ambiguous. The prompt
                 should be rewritten with no more than one set
                 of square brackets.
  
  
  =item C<< Warning: next input will be in plaintext >>
  
  (W bareword)  The C<prompt()> subroutine was called with
                the C<-echo> flag, but the Term::ReadKey
                module was not available to implement this
                feature. The input will proceed as normal, but
                this warning is issued to ensure that the user
                doesn't type in something secret, expecting it
                to remain hidden, which it won't.
  
  
  =item C<< prompt(): Too many menu items. Ignoring the final %d >>
  
  (W misc)  A C<-menu> was specified with more than 52 choices.
            Because, by default, menus use upper and lower-
            case alphabetic characters as their selectors,
            there were no available selectors for the extra
            items after the first 52. Either reduce the number
            of choices to 52 or less, or else add the
            C<-number> option to use numeric selectors instead.
  
  =back
  
  
  =head1 CONFIGURATION AND ENVIRONMENT
  
  IO::Prompter can be configured by setting any of the following
  environment variables:
  
  =over
  
  =item C<$IO_PROMPTER_COMPLETE_KEY>
  
  Specifies the key used to initiate
  L<user-specified completions|"Input autocompletion">.
  Defaults to <TAB>
  
  =item C<$IO_PROMPTER_HISTORY_KEY>
  
  Specifies the key used to initiate
  L<history completions|"Completing from your input history">.
  Defaults to <CTRL-R>
  
  =item C<$IO_PROMPTER_COMPLETE_MODES>
  
  Specifies the
  L<response sequence|"Configuring the autocompletion interaction">
  for user-defined completions.  Defaults to C<'list+longest  full'>
  
  =item C<$IO_PROMPTER_HISTORY_MODES>
  
  Specifies the
  L<response sequence|"Configuring the autocompletion interaction">
  for history completions.  Defaults to C<'full'>.
  
  =back
  
  
  =head1 DEPENDENCIES
  
  Requires the Contextual::Return module.
  
  The module also works much better if Term::ReadKey is available
  (though this is not essential).
  
  
  =head1 INCOMPATIBILITIES
  
  This module does not play well with Moose (or more specifically, with
  Moose::Exporter) because both of them try to play sneaky games with
  Scalar::Util::blessed.
  
  The current solution is to make sure that you load Moose before
  loading IO::Prompter. Even just doing this:
  
      use Moose ();
      use IO::Prompter;
  
  is sufficient.
  
  
  =head1 BUGS AND LIMITATIONS
  
  No unresolved bugs have been reported.
  
  Please report any bugs or feature requests to
  C<bug-io-prompter@rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org>.
  
  
  =head1 AUTHOR
  
  Damian Conway  C<< <DCONWAY@CPAN.org> >>
  
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2009, Damian Conway C<< <DCONWAY@CPAN.org> >>.
  All rights reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself. See L<perlartistic>.
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
IO_PROMPTER

$fatpacked{"Module/Implementation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_IMPLEMENTATION';
  package Module::Implementation;
  # git description: v0.08-2-gd599347
  $Module::Implementation::VERSION = '0.09';
  
  use strict;
  use warnings;
  
  use Module::Runtime 0.012 qw( require_module );
  use Try::Tiny;
  
  # This is needed for the benefit of Test::CleanNamespaces, which in turn loads
  # Package::Stash, which in turn loads this module and expects a minimum
  # version.
  unless ( exists $Module::Implementation::{VERSION}
      && ${ $Module::Implementation::{VERSION} } ) {
  
      $Module::Implementation::{VERSION} = \42;
  }
  
  my %Implementation;
  
  sub build_loader_sub {
      my $caller = caller();
  
      return _build_loader( $caller, @_ );
  }
  
  sub _build_loader {
      my $package = shift;
      my %args    = @_;
  
      my @implementations = @{ $args{implementations} };
      my @symbols = @{ $args{symbols} || [] };
  
      my $implementation;
      my $env_var = uc $package;
      $env_var =~ s/::/_/g;
      $env_var .= '_IMPLEMENTATION';
  
      return sub {
          my ( $implementation, $loaded ) = _load_implementation(
              $package,
              $ENV{$env_var},
              \@implementations,
          );
  
          $Implementation{$package} = $implementation;
  
          _copy_symbols( $loaded, $package, \@symbols );
  
          return $loaded;
      };
  }
  
  sub implementation_for {
      my $package = shift;
  
      return $Implementation{$package};
  }
  
  sub _load_implementation {
      my $package         = shift;
      my $env_value       = shift;
      my $implementations = shift;
  
      if ($env_value) {
          die "$env_value is not a valid implementation for $package"
              unless grep { $_ eq $env_value } @{$implementations};
  
          my $requested = "${package}::$env_value";
  
          # Values from the %ENV hash are tainted. We know it's safe to untaint
          # this value because the value was one of our known implementations.
          ($requested) = $requested =~ /^(.+)$/;
  
          try {
              require_module($requested);
          }
          catch {
              require Carp;
              Carp::croak("Could not load $requested: $_");
          };
  
          return ( $env_value, $requested );
      }
      else {
          my $err;
          for my $possible ( @{$implementations} ) {
              my $try = "${package}::$possible";
  
              my $ok;
              try {
                  require_module($try);
                  $ok = 1;
              }
              catch {
                  $err .= $_ if defined $_;
              };
  
              return ( $possible, $try ) if $ok;
          }
  
          require Carp;
          if ( defined $err && length $err ) {
              Carp::croak(
                  "Could not find a suitable $package implementation: $err");
          }
          else {
              Carp::croak(
                  'Module::Runtime failed to load a module but did not throw a real error. This should never happen. Something is very broken'
              );
          }
      }
  }
  
  sub _copy_symbols {
      my $from_package = shift;
      my $to_package   = shift;
      my $symbols      = shift;
  
      for my $sym ( @{$symbols} ) {
          my $type = $sym =~ s/^([\$\@\%\&\*])// ? $1 : '&';
  
          my $from = "${from_package}::$sym";
          my $to   = "${to_package}::$sym";
  
          {
              no strict 'refs';
              no warnings 'once';
  
              # Copied from Exporter
              *{$to}
                  = $type eq '&' ? \&{$from}
                  : $type eq '$' ? \${$from}
                  : $type eq '@' ? \@{$from}
                  : $type eq '%' ? \%{$from}
                  : $type eq '*' ? *{$from}
                  : die
                  "Can't copy symbol from $from_package to $to_package: $type$sym";
          }
      }
  }
  
  1;
  
  # ABSTRACT: Loads one of several alternate underlying implementations for a module
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Module::Implementation - Loads one of several alternate underlying implementations for a module
  
  =head1 VERSION
  
  version 0.09
  
  =head1 SYNOPSIS
  
    package Foo::Bar;
  
    use Module::Implementation;
  
    BEGIN {
        my $loader = Module::Implementation::build_loader_sub(
            implementations => [ 'XS',  'PurePerl' ],
            symbols         => [ 'run', 'check' ],
        );
  
        $loader->();
    }
  
    package Consumer;
  
    # loads the first viable implementation
    use Foo::Bar;
  
  =head1 DESCRIPTION
  
  This module abstracts out the process of choosing one of several underlying
  implementations for a module. This can be used to provide XS and pure Perl
  implementations of a module, or it could be used to load an implementation for
  a given OS or any other case of needing to provide multiple implementations.
  
  This module is only useful when you know all the implementations ahead of
  time. If you want to load arbitrary implementations then you probably want
  something like a plugin system, not this module.
  
  =head1 API
  
  This module provides two subroutines, neither of which are exported.
  
  =head2 Module::Implementation::build_loader_sub(...)
  
  This subroutine takes the following arguments.
  
  =over 4
  
  =item * implementations
  
  This should be an array reference of implementation names. Each name should
  correspond to a module in the caller's namespace.
  
  In other words, using the example in the L</SYNOPSIS>, this module will look
  for the C<Foo::Bar::XS> and C<Foo::Bar::PurePerl> modules.
  
  This argument is required.
  
  =item * symbols
  
  A list of symbols to copy from the implementation package to the calling
  package.
  
  These can be prefixed with a variable type: C<$>, C<@>, C<%>, C<&>, or
  C<*)>. If no prefix is given, the symbol is assumed to be a subroutine.
  
  This argument is optional.
  
  =back
  
  This subroutine I<returns> the implementation loader as a sub reference.
  
  It is up to you to call this loader sub in your code.
  
  I recommend that you I<do not> call this loader in an C<import()> sub. If a
  caller explicitly requests no imports, your C<import()> sub will not be run at
  all, which can cause weird breakage.
  
  =head2 Module::Implementation::implementation_for($package)
  
  Given a package name, this subroutine returns the implementation that was
  loaded for the package. This is not a full package name, just the suffix that
  identifies the implementation. For the L</SYNOPSIS> example, this subroutine
  would be called as C<Module::Implementation::implementation_for('Foo::Bar')>,
  and it would return "XS" or "PurePerl".
  
  =head1 HOW THE IMPLEMENTATION LOADER WORKS
  
  The implementation loader works like this ...
  
  First, it checks for an C<%ENV> var specifying the implementation to load. The
  env var is based on the package name which loads the implementations. The
  C<::> package separator is replaced with C<_>, and made entirely
  upper-case. Finally, we append "_IMPLEMENTATION" to this name.
  
  So in our L</SYNOPSIS> example, the corresponding C<%ENV> key would be
  C<FOO_BAR_IMPLEMENTATION>.
  
  If this is set, then the loader will B<only> try to load this one
  implementation.
  
  If the env var requests an implementation which doesn't match one of the
  implementations specified when the loader was created, an error is thrown.
  
  If this one implementation fails to load then loader throws an error. This is
  useful for testing. You can request a specific implementation in a test file
  by writing something like this:
  
    BEGIN { $ENV{FOO_BAR_IMPLEMENTATION} = 'XS' }
    use Foo::Bar;
  
  If the environment variable is I<not> set, then the loader simply tries the
  implementations originally passed to C<Module::Implementation>. The
  implementations are tried in the order in which they were originally passed.
  
  The loader will use the first implementation that loads without an error. It
  will copy any requested symbols from this implementation.
  
  If none of the implementations can be loaded, then the loader throws an
  exception.
  
  The loader returns the name of the package it loaded.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
MODULE_IMPLEMENTATION

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  =head1 NAME
  
  Module::Runtime - runtime module handling
  
  =head1 SYNOPSIS
  
      use Module::Runtime qw(
  	$module_name_rx is_module_name check_module_name
  	module_notional_filename require_module);
  
      if($module_name =~ /\A$module_name_rx\z/o) { ...
      if(is_module_name($module_name)) { ...
      check_module_name($module_name);
  
      $notional_filename = module_notional_filename($module_name);
      require_module($module_name);
  
      use Module::Runtime qw(use_module use_package_optimistically);
  
      $bi = use_module("Math::BigInt", 1.31)->new("1_234");
      $widget = use_package_optimistically("Local::Widget")->new;
  
      use Module::Runtime qw(
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec check_module_spec
  	compose_module_name);
  
      if($spec =~ /\A$top_module_spec_rx\z/o) { ...
      if($spec =~ /\A$sub_module_spec_rx\z/o) { ...
      if(is_module_spec("Standard::Prefix", $spec)) { ...
      check_module_spec("Standard::Prefix", $spec);
  
      $module_name = compose_module_name("Standard::Prefix", $spec);
  
  =head1 DESCRIPTION
  
  The functions exported by this module deal with runtime handling of
  Perl modules, which are normally handled at compile time.  This module
  avoids using any other modules, so that it can be used in low-level
  infrastructure.
  
  The parts of this module that work with module names apply the same syntax
  that is used for barewords in Perl source.  In principle this syntax
  can vary between versions of Perl, and this module applies the syntax of
  the Perl on which it is running.  In practice the usable syntax hasn't
  changed yet.  There's some intent for Unicode module names to be supported
  in the future, but this hasn't yet amounted to any consistent facility.
  
  The functions of this module whose purpose is to load modules include
  workarounds for three old Perl core bugs regarding C<require>.  These
  workarounds are applied on any Perl version where the bugs exist, except
  for a case where one of the bugs cannot be adequately worked around in
  pure Perl.
  
  =head2 Module name syntax
  
  The usable module name syntax has not changed from Perl 5.000 up to
  Perl 5.19.8.  The syntax is composed entirely of ASCII characters.
  From Perl 5.6 onwards there has been some attempt to allow the use of
  non-ASCII Unicode characters in Perl source, but it was fundamentally
  broken (like the entirety of Perl 5.6's Unicode handling) and remained
  pretty much entirely unusable until it got some attention in the Perl
  5.15 series.  Although Unicode is now consistently accepted by the
  parser in some places, it remains broken for module names.  Furthermore,
  there has not yet been any work on how to map Unicode module names into
  filenames, so in that respect also Unicode module names are unusable.
  
  The module name syntax is, precisely: the string must consist of one or
  more segments separated by C<::>; each segment must consist of one or more
  identifier characters (ASCII alphanumerics plus "_"); the first character
  of the string must not be a digit.  Thus "C<IO::File>", "C<warnings>",
  and "C<foo::123::x_0>" are all valid module names, whereas "C<IO::>"
  and "C<1foo::bar>" are not.  C<'> separators are not permitted by this
  module, though they remain usable in Perl source, being translated to
  C<::> in the parser.
  
  =head2 Core bugs worked around
  
  The first bug worked around is core bug [perl #68590], which causes
  lexical state in one file to leak into another that is C<require>d/C<use>d
  from it.  This bug is present from Perl 5.6 up to Perl 5.10, and is
  fixed in Perl 5.11.0.  From Perl 5.9.4 up to Perl 5.10.0 no satisfactory
  workaround is possible in pure Perl.  The workaround means that modules
  loaded via this module don't suffer this pollution of their lexical
  state.  Modules loaded in other ways, or via this module on the Perl
  versions where the pure Perl workaround is impossible, remain vulnerable.
  The module L<Lexical::SealRequireHints> provides a complete workaround
  for this bug.
  
  The second bug worked around causes some kinds of failure in module
  loading, principally compilation errors in the loaded module, to be
  recorded in C<%INC> as if they were successful, so later attempts to load
  the same module immediately indicate success.  This bug is present up
  to Perl 5.8.9, and is fixed in Perl 5.9.0.  The workaround means that a
  compilation error in a module loaded via this module won't be cached as
  a success.  Modules loaded in other ways remain liable to produce bogus
  C<%INC> entries, and if a bogus entry exists then it will mislead this
  module if it is used to re-attempt loading.
  
  The third bug worked around causes the wrong context to be seen at
  file scope of a loaded module, if C<require> is invoked in a location
  that inherits context from a higher scope.  This bug is present up to
  Perl 5.11.2, and is fixed in Perl 5.11.3.  The workaround means that
  a module loaded via this module will always see the correct context.
  Modules loaded in other ways remain vulnerable.
  
  =cut
  
  package Module::Runtime;
  
  # Don't "use 5.006" here, because Perl 5.15.6 will load feature.pm if
  # the version check is done that way.
  BEGIN { require 5.006; }
  # Don't "use warnings" here, to avoid dependencies.  Do standardise the
  # warning status by lexical override; unfortunately the only safe bitset
  # to build in is the empty set, equivalent to "no warnings".
  BEGIN { ${^WARNING_BITS} = ""; }
  # Don't "use strict" here, to avoid dependencies.
  
  our $VERSION = "0.016";
  
  # Don't use Exporter here, to avoid dependencies.
  our @EXPORT_OK = qw(
  	$module_name_rx is_module_name is_valid_module_name check_module_name
  	module_notional_filename require_module
  	use_module use_package_optimistically
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec is_valid_module_spec check_module_spec
  	compose_module_name
  );
  my %export_ok = map { ($_ => undef) } @EXPORT_OK;
  sub import {
  	my $me = shift;
  	my $callpkg = caller(0);
  	my $errs = "";
  	foreach(@_) {
  		if(exists $export_ok{$_}) {
  			# We would need to do "no strict 'refs'" here
  			# if we had enabled strict at file scope.
  			if(/\A\$(.*)\z/s) {
  				*{$callpkg."::".$1} = \$$1;
  			} else {
  				*{$callpkg."::".$_} = \&$_;
  			}
  		} else {
  			$errs .= "\"$_\" is not exported by the $me module\n";
  		}
  	}
  	if($errs ne "") {
  		die "${errs}Can't continue after import errors ".
  			"at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n";
  	}
  }
  
  # Logic duplicated from Params::Classify.  Duplicating it here avoids
  # an extensive and potentially circular dependency graph.
  sub _is_string($) {
  	my($arg) = @_;
  	return defined($arg) && ref(\$arg) eq "SCALAR";
  }
  
  =head1 REGULAR EXPRESSIONS
  
  These regular expressions do not include any anchors, so to check
  whether an entire string matches a syntax item you must supply the
  anchors yourself.
  
  =over
  
  =item $module_name_rx
  
  Matches a valid Perl module name in bareword syntax.
  
  =cut
  
  our $module_name_rx = qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;
  
  =item $top_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where no prefix is being used.
  
  =cut
  
  my $qual_module_spec_rx =
  	qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  my $unqual_top_module_spec_rx =
  	qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $top_module_spec_rx = qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;
  
  =item $sub_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where a prefix is being used.
  
  =cut
  
  my $unqual_sub_module_spec_rx = qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $sub_module_spec_rx = qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 Basic module handling
  
  =over
  
  =item is_module_name(ARG)
  
  Returns a truth value indicating whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  
  =cut
  
  sub is_module_name($) { _is_string($_[0]) && $_[0] =~ /\A$module_name_rx\z/o }
  
  =item is_valid_module_name(ARG)
  
  Deprecated alias for L</is_module_name>.
  
  =cut
  
  *is_valid_module_name = \&is_module_name;
  
  =item check_module_name(ARG)
  
  Check whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_name($) {
  	unless(&is_module_name) {
  		die +(_is_string($_[0]) ? "`$_[0]'" : "argument").
  			" is not a module name\n";
  	}
  }
  
  =item module_notional_filename(NAME)
  
  Generates a notional relative filename for a module, which is used in
  some Perl core interfaces.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The notional filename for the named module is generated and returned.
  This filename is always in Unix style, with C</> directory separators
  and a C<.pm> suffix.  This kind of filename can be used as an argument to
  C<require>, and is the key that appears in C<%INC> to identify a module,
  regardless of actual local filename syntax.
  
  =cut
  
  sub module_notional_filename($) {
  	&check_module_name;
  	my($name) = @_;
  	$name =~ s!::!/!g;
  	return $name.".pm";
  }
  
  =item require_module(NAME)
  
  This is essentially the bareword form of C<require>, in runtime form.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The module specified by I<NAME> is loaded, if it hasn't been already,
  in the manner of the bareword form of C<require>.  That means that a
  search through C<@INC> is performed, and a byte-compiled form of the
  module will be used if available.
  
  The return value is as for C<require>.  That is, it is the value returned
  by the module itself if the module is loaded anew, or C<1> if the module
  was already loaded.
  
  =cut
  
  # Don't "use constant" here, to avoid dependencies.
  BEGIN {
  	*_WORK_AROUND_HINT_LEAKAGE =
  		"$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
  			? sub(){1} : sub(){0};
  	*_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
  }
  
  BEGIN { if(_WORK_AROUND_BROKEN_MODULE_STATE) { eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  }; die $@ if $@ ne ""; } }
  
  sub require_module($) {
  	# Localise %^H to work around [perl #68590], where the bug exists
  	# and this is a satisfactory workaround.  The bug consists of
  	# %^H state leaking into each required module, polluting the
  	# module's lexical state.
  	local %^H if _WORK_AROUND_HINT_LEAKAGE;
  	if(_WORK_AROUND_BROKEN_MODULE_STATE) {
  		my $notional_filename = &module_notional_filename;
  		my $guard = bless([ $notional_filename ],
  				"Module::Runtime::__GUARD__");
  		my $result = CORE::require($notional_filename);
  		pop @$guard;
  		return $result;
  	} else {
  		return scalar(CORE::require(&module_notional_filename));
  	}
  }
  
  =back
  
  =head2 Structured module use
  
  =over
  
  =item use_module(NAME[, VERSION])
  
  This is essentially C<use> in runtime form, but without the importing
  feature (which is fundamentally a compile-time thing).  The I<NAME> is
  handled just like in C<require_module> above: it must be a module name,
  and the named module is loaded as if by the bareword form of C<require>.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded module is
  called with the specified I<VERSION> as an argument.  This normally serves to
  ensure that the version loaded is at least the version required.  This is
  the same functionality provided by the I<VERSION> parameter of C<use>.
  
  On success, the name of the module is returned.  This is unlike
  L</require_module>, and is done so that the entire call to L</use_module>
  can be used as a class name to call a constructor, as in the example in
  the synopsis.
  
  =cut
  
  sub use_module($;$) {
  	my($name, $version) = @_;
  	require_module($name);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =item use_package_optimistically(NAME[, VERSION])
  
  This is an analogue of L</use_module> for the situation where there is
  uncertainty as to whether a package/class is defined in its own module
  or by some other means.  It attempts to arrange for the named package to
  be available, either by loading a module or by doing nothing and hoping.
  
  An attempt is made to load the named module (as if by the bareword form
  of C<require>).  If the module cannot be found then it is assumed that
  the package was actually already loaded by other means, and no error
  is signalled.  That's the optimistic bit.
  
  I<Warning:> this optional module loading is liable to cause unreliable
  behaviour, including security problems.  It interacts especially badly
  with having C<.> in C<@INC>, which was the default state of affairs in
  Perls prior to 5.25.11.  If a package is actually defined by some means
  other than a module, then applying this function to it causes a spurious
  attempt to load a module that is expected to be non-existent.  If a
  module actually exists under that name then it will be unintentionally
  loaded.  If C<.> is in C<@INC> and this code is ever run with the current
  directory being one writable by a malicious user (such as F</tmp>), then
  the malicious user can easily cause the victim to run arbitrary code, by
  creating a module file under the predictable spuriously-loaded name in the
  writable directory.  Generally, optional module loading should be avoided.
  
  This is mostly the same operation that is performed by the L<base> pragma
  to ensure that the specified base classes are available.  The behaviour
  of L<base> was simplified in version 2.18, and later improved in version
  2.20, and on both occasions this function changed to match.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded package is
  called with the specified I<VERSION> as an argument.  This normally serves
  to ensure that the version loaded is at least the version required.
  On success, the name of the package is returned.  These aspects of the
  function work just like L</use_module>.
  
  =cut
  
  sub use_package_optimistically($;$) {
  	my($name, $version) = @_;
  	my $fn = module_notional_filename($name);
  	eval { local $SIG{__DIE__}; require_module($name); };
  	die $@ if $@ ne "" &&
  		($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s ||
  		 $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =back
  
  =head2 Module name composition
  
  =over
  
  =item is_module_spec(PREFIX, SPEC)
  
  Returns a truth value indicating
  whether I<SPEC> is valid input for L</compose_module_name>.
  See below for what that entails.  Whether a I<PREFIX> is supplied affects
  the validity of I<SPEC>, but the exact value of the prefix is unimportant,
  so this function treats I<PREFIX> as a truth value.
  
  =cut
  
  sub is_module_spec($$) {
  	my($prefix, $spec) = @_;
  	return _is_string($spec) &&
  		$spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o :
  				    qr/\A$top_module_spec_rx\z/o);
  }
  
  =item is_valid_module_spec(PREFIX, SPEC)
  
  Deprecated alias for L</is_module_spec>.
  
  =cut
  
  *is_valid_module_spec = \&is_module_spec;
  
  =item check_module_spec(PREFIX, SPEC)
  
  Check whether I<SPEC> is valid input for L</compose_module_name>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_spec($$) {
  	unless(&is_module_spec) {
  		die +(_is_string($_[1]) ? "`$_[1]'" : "argument").
  			" is not a module specification\n";
  	}
  }
  
  =item compose_module_name(PREFIX, SPEC)
  
  This function is intended to make it more convenient for a user to specify
  a Perl module name at runtime.  Users have greater need for abbreviations
  and context-sensitivity than programmers, and Perl module names get a
  little unwieldy.  I<SPEC> is what the user specifies, and this function
  translates it into a module name in standard form, which it returns.
  
  I<SPEC> has syntax approximately that of a standard module name: it
  should consist of one or more name segments, each of which consists
  of one or more identifier characters.  However, C</> is permitted as a
  separator, in addition to the standard C<::>.  The two separators are
  entirely interchangeable.
  
  Additionally, if I<PREFIX> is not C<undef> then it must be a module
  name in standard form, and it is prefixed to the user-specified name.
  The user can inhibit the prefix addition by starting I<SPEC> with a
  separator (either C</> or C<::>).
  
  =cut
  
  sub compose_module_name($$) {
  	my($prefix, $spec) = @_;
  	check_module_name($prefix) if defined $prefix;
  	&check_module_spec;
  	if($spec =~ s#\A(?:/|::)##) {
  		# OK
  	} else {
  		$spec = $prefix."::".$spec if defined $prefix;
  	}
  	$spec =~ s#/#::#g;
  	return $spec;
  }
  
  =back
  
  =head1 BUGS
  
  On Perl versions 5.7.2 to 5.8.8, if C<require> is overridden by the
  C<CORE::GLOBAL> mechanism, it is likely to break the heuristics used by
  L</use_package_optimistically>, making it signal an error for a missing
  module rather than assume that it was already loaded.  From Perl 5.8.9
  onwards, and on 5.7.1 and earlier, this module can avoid being confused
  by such an override.  On the affected versions, a C<require> override
  might be installed by L<Lexical::SealRequireHints>, if something requires
  its bugfix but for some reason its XS implementation isn't available.
  
  =head1 SEE ALSO
  
  L<Lexical::SealRequireHints>,
  L<base>,
  L<perlfunc/require>,
  L<perlfunc/use>
  
  =head1 AUTHOR
  
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2004, 2006, 2007, 2009, 2010, 2011, 2012, 2014, 2017
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
MODULE_RUNTIME

$fatpacked{"Sub/Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER';
  use 5.006;
  use strict;
  use warnings;
  package Sub::Exporter;
  {
    $Sub::Exporter::VERSION = '0.987';
  }
  # ABSTRACT: a sophisticated exporter for custom-built routines
  
  use Carp ();
  use Data::OptList 0.100 ();
  use Params::Util 0.14 (); # _CODELIKE
  use Sub::Install 0.92 ();
  
  
  # Given a potential import name, this returns the group name -- if it's got a
  # group prefix.
  sub _group_name {
    my ($name) = @_;
  
    return if (index q{-:}, (substr $name, 0, 1)) == -1;
    return substr $name, 1;
  }
  
  # \@groups is a canonicalized opt list of exports and groups this returns
  # another canonicalized opt list with groups replaced with relevant exports.
  # \%seen is groups we've already expanded and can ignore.
  # \%merge is merged options from the group we're descending through.
  sub _expand_groups {
    my ($class, $config, $groups, $collection, $seen, $merge) = @_;
    $seen  ||= {};
    $merge ||= {};
    my @groups = @$groups;
  
    for my $i (reverse 0 .. $#groups) {
      if (my $group_name = _group_name($groups[$i][0])) {
        my $seen = { %$seen }; # faux-dynamic scoping
  
        splice @groups, $i, 1,
          _expand_group($class, $config, $groups[$i], $collection, $seen, $merge);
      } else {
        # there's nothing to munge in this export's args
        next unless my %merge = %$merge;
  
        # we have things to merge in; do so
        my $prefix = (delete $merge{-prefix}) || '';
        my $suffix = (delete $merge{-suffix}) || '';
  
        if (
          Params::Util::_CODELIKE($groups[$i][1]) ## no critic Private
          or
          Params::Util::_SCALAR0($groups[$i][1]) ## no critic Private
        ) {
          # this entry was build by a group generator
          $groups[$i][0] = $prefix . $groups[$i][0] . $suffix;
        } else {
          my $as
            = ref $groups[$i][1]{-as} ? $groups[$i][1]{-as}
            :     $groups[$i][1]{-as} ? $prefix . $groups[$i][1]{-as} . $suffix
            :                           $prefix . $groups[$i][0]      . $suffix;
  
          $groups[$i][1] = { %{ $groups[$i][1] }, %merge, -as => $as };
        }
      }
    }
  
    return \@groups;
  }
  
  # \@group is a name/value pair from an opt list.
  sub _expand_group {
    my ($class, $config, $group, $collection, $seen, $merge) = @_;
    $merge ||= {};
  
    my ($group_name, $group_arg) = @$group;
    $group_name = _group_name($group_name);
  
    Carp::croak qq(group "$group_name" is not exported by the $class module)
      unless exists $config->{groups}{$group_name};
  
    return if $seen->{$group_name}++;
  
    if (ref $group_arg) {
      my $prefix = (delete $merge->{-prefix}||'') . ($group_arg->{-prefix}||'');
      my $suffix = ($group_arg->{-suffix}||'') . (delete $merge->{-suffix}||'');
      $merge = {
        %$merge,
        %$group_arg,
        ($prefix ? (-prefix => $prefix) : ()),
        ($suffix ? (-suffix => $suffix) : ()),
      };
    }
  
    my $exports = $config->{groups}{$group_name};
  
    if (
      Params::Util::_CODELIKE($exports) ## no critic Private
      or
      Params::Util::_SCALAR0($exports) ## no critic Private
    ) {
      # I'm not very happy with this code for hiding -prefix and -suffix, but
      # it's needed, and I'm not sure, offhand, how to make it better.
      # -- rjbs, 2006-12-05
      my $group_arg = $merge ? { %$merge } : {};
      delete $group_arg->{-prefix};
      delete $group_arg->{-suffix};
  
      my $group = Params::Util::_CODELIKE($exports) ## no critic Private
                ? $exports->($class, $group_name, $group_arg, $collection)
                : $class->$$exports($group_name, $group_arg, $collection);
  
      Carp::croak qq(group generator "$group_name" did not return a hashref)
        if ref $group ne 'HASH';
  
      my $stuff = [ map { [ $_ => $group->{$_} ] } keys %$group ];
      return @{
        _expand_groups($class, $config, $stuff, $collection, $seen, $merge)
      };
    } else {
      $exports
        = Data::OptList::mkopt($exports, "$group_name exports");
  
      return @{
        _expand_groups($class, $config, $exports, $collection, $seen, $merge)
      };
    }
  }
  
  sub _mk_collection_builder {
    my ($col, $etc) = @_;
    my ($config, $import_args, $class, $into) = @$etc;
  
    my %seen;
    sub {
      my ($collection) = @_;
      my ($name, $value) = @$collection;
  
      Carp::croak "collection $name provided multiple times in import"
        if $seen{ $name }++;
  
      if (ref(my $hook = $config->{collectors}{$name})) {
        my $arg = {
          name        => $name,
          config      => $config,
          import_args => $import_args,
          class       => $class,
          into        => $into,
        };
  
        my $error_msg = "collection $name failed validation";
        if (Params::Util::_SCALAR0($hook)) { ## no critic Private
          Carp::croak $error_msg unless $class->$$hook($value, $arg);
        } else {
          Carp::croak $error_msg unless $hook->($value, $arg);
        }
      }
  
      $col->{ $name } = $value;
    }
  }
  
  # Given a config and pre-canonicalized importer args, remove collections from
  # the args and return them.
  sub _collect_collections {
    my ($config, $import_args, $class, $into) = @_;
  
    my @collections
      = map  { splice @$import_args, $_, 1 }
        grep { exists $config->{collectors}{ $import_args->[$_][0] } }
        reverse 0 .. $#$import_args;
  
    unshift @collections, [ INIT => {} ] if $config->{collectors}{INIT};
  
    my $col = {};
    my $builder = _mk_collection_builder($col, \@_);
    for my $collection (@collections) {
      $builder->($collection)
    }
  
    return $col;
  }
  
  
  sub setup_exporter {
    my ($config)  = @_;
  
    Carp::croak 'into and into_level may not both be supplied to exporter'
      if exists $config->{into} and exists $config->{into_level};
  
    my $as   = delete $config->{as}   || 'import';
    my $into
      = exists $config->{into}       ? delete $config->{into}
      : exists $config->{into_level} ? caller(delete $config->{into_level})
      :                                caller(0);
  
    my $import = build_exporter($config);
  
    Sub::Install::reinstall_sub({
      code => $import,
      into => $into,
      as   => $as,
    });
  }
  
  
  sub _key_intersection {
    my ($x, $y) = @_;
    my %seen = map { $_ => 1 } keys %$x;
    my @names = grep { $seen{$_} } keys %$y;
  }
  
  # Given the config passed to setup_exporter, which contains sugary opt list
  # data, rewrite the opt lists into hashes, catch a few kinds of invalid
  # configurations, and set up defaults.  Since the config is a reference, it's
  # rewritten in place.
  my %valid_config_key;
  BEGIN {
    %valid_config_key =
      map { $_ => 1 }
      qw(as collectors installer generator exports groups into into_level),
      qw(exporter), # deprecated
  }
  
  sub _assert_collector_names_ok {
    my ($collectors) = @_;
  
    for my $reserved_name (grep { /\A[_A-Z]+\z/ } keys %$collectors) {
      Carp::croak "unknown reserved collector name: $reserved_name"
        if $reserved_name ne 'INIT';
    }
  }
  
  sub _rewrite_build_config {
    my ($config) = @_;
  
    if (my @keys = grep { not exists $valid_config_key{$_} } keys %$config) {
      Carp::croak "unknown options (@keys) passed to Sub::Exporter";
    }
  
    Carp::croak q(into and into_level may not both be supplied to exporter)
      if exists $config->{into} and exists $config->{into_level};
  
    # XXX: Remove after deprecation period.
    if ($config->{exporter}) {
      Carp::cluck "'exporter' argument to build_exporter is deprecated. Use 'installer' instead; the semantics are identical.";
      $config->{installer} = delete $config->{exporter};
    }
  
    Carp::croak q(into and into_level may not both be supplied to exporter)
      if exists $config->{into} and exists $config->{into_level};
  
    for (qw(exports collectors)) {
      $config->{$_} = Data::OptList::mkopt_hash(
        $config->{$_},
        $_,
        [ 'CODE', 'SCALAR' ],
      );
    }
  
    _assert_collector_names_ok($config->{collectors});
  
    if (my @names = _key_intersection(@$config{qw(exports collectors)})) {
      Carp::croak "names (@names) used in both collections and exports";
    }
  
    $config->{groups} = Data::OptList::mkopt_hash(
        $config->{groups},
        'groups',
        [
          'HASH',   # standard opt list
          'ARRAY',  # standard opt list
          'CODE',   # group generator
          'SCALAR', # name of group generation method
        ]
      );
  
    # by default, export nothing
    $config->{groups}{default} ||= [];
  
    # by default, build an all-inclusive 'all' group
    $config->{groups}{all} ||= [ keys %{ $config->{exports} } ];
  
    $config->{generator} ||= \&default_generator;
    $config->{installer} ||= \&default_installer;
  }
  
  sub build_exporter {
    my ($config) = @_;
  
    _rewrite_build_config($config);
  
    my $import = sub {
      my ($class) = shift;
  
      # XXX: clean this up -- rjbs, 2006-03-16
      my $special = (ref $_[0]) ? shift(@_) : {};
      Carp::croak q(into and into_level may not both be supplied to exporter)
        if exists $special->{into} and exists $special->{into_level};
  
      if ($special->{exporter}) {
        Carp::cluck "'exporter' special import argument is deprecated. Use 'installer' instead; the semantics are identical.";
        $special->{installer} = delete $special->{exporter};
      }
  
      my $into
        = defined $special->{into}       ? delete $special->{into}
        : defined $special->{into_level} ? caller(delete $special->{into_level})
        : defined $config->{into}        ? $config->{into}
        : defined $config->{into_level}  ? caller($config->{into_level})
        :                                  caller(0);
  
      my $generator = delete $special->{generator} || $config->{generator};
      my $installer = delete $special->{installer} || $config->{installer};
  
      # this builds a AOA, where the inner arrays are [ name => value_ref ]
      my $import_args = Data::OptList::mkopt([ @_ ]);
  
      # is this right?  defaults first or collectors first? -- rjbs, 2006-06-24
      $import_args = [ [ -default => undef ] ] unless @$import_args;
  
      my $collection = _collect_collections($config, $import_args, $class, $into);
  
      my $to_import = _expand_groups($class, $config, $import_args, $collection);
  
      # now, finally $import_arg is really the "to do" list
      _do_import(
        {
          class     => $class,
          col       => $collection,
          config    => $config,
          into      => $into,
          generator => $generator,
          installer => $installer,
        },
        $to_import,
      );
    };
  
    return $import;
  }
  
  sub _do_import {
    my ($arg, $to_import) = @_;
  
    my @todo;
  
    for my $pair (@$to_import) {
      my ($name, $import_arg) = @$pair;
  
      my ($generator, $as);
  
      if ($import_arg and Params::Util::_CODELIKE($import_arg)) { ## no critic
        # This is the case when a group generator has inserted name/code pairs.
        $generator = sub { $import_arg };
        $as = $name;
      } else {
        $import_arg = { $import_arg ? %$import_arg : () };
  
        Carp::croak qq("$name" is not exported by the $arg->{class} module)
          unless exists $arg->{config}{exports}{$name};
  
        $generator = $arg->{config}{exports}{$name};
  
        $as = exists $import_arg->{-as} ? (delete $import_arg->{-as}) : $name;
      }
  
      my $code = $arg->{generator}->(
        { 
          class     => $arg->{class},
          name      => $name,
          arg       => $import_arg,
          col       => $arg->{col},
          generator => $generator,
        }
      );
  
      push @todo, $as, $code;
    }
  
    $arg->{installer}->(
      {
        class => $arg->{class},
        into  => $arg->{into},
        col   => $arg->{col},
      },
      \@todo,
    );
  }
  
  ## Cute idea, possibly for future use: also supply an "unimport" for:
  ## no Module::Whatever qw(arg arg arg);
  # sub _unexport {
  #   my (undef, undef, undef, undef, undef, $as, $into) = @_;
  # 
  #   if (ref $as eq 'SCALAR') {
  #     undef $$as;
  #   } elsif (ref $as) {
  #     Carp::croak "invalid reference type for $as: " . ref $as;
  #   } else {
  #     no strict 'refs';
  #     delete &{$into . '::' . $as};
  #   }
  # }
  
  
  sub default_generator {
    my ($arg) = @_;
    my ($class, $name, $generator) = @$arg{qw(class name generator)};
  
    if (not defined $generator) {
      my $code = $class->can($name)
        or Carp::croak "can't locate exported subroutine $name via $class";
      return $code;
    }
  
    # I considered making this "$class->$generator(" but it seems that
    # overloading precedence would turn an overloaded-as-code generator object
    # into a string before code. -- rjbs, 2006-06-11
    return $generator->($class, $name, $arg->{arg}, $arg->{col})
      if Params::Util::_CODELIKE($generator); ## no critic Private
  
    # This "must" be a scalar reference, to a generator method name.
    # -- rjbs, 2006-12-05
    return $class->$$generator($name, $arg->{arg}, $arg->{col});
  }
  
  
  sub default_installer {
    my ($arg, $to_export) = @_;
  
    for (my $i = 0; $i < @$to_export; $i += 2) {
      my ($as, $code) = @$to_export[ $i, $i+1 ];
  
      # Allow as isa ARRAY to push onto an array?
      # Allow into isa HASH to install name=>code into hash?
  
      if (ref $as eq 'SCALAR') {
        $$as = $code;
      } elsif (ref $as) {
        Carp::croak "invalid reference type for $as: " . ref $as;
      } else {
        Sub::Install::reinstall_sub({
          code => $code,
          into => $arg->{into},
          as   => $as
        });
      }
    }
  }
  
  sub default_exporter {
    Carp::cluck "default_exporter is deprecated; call default_installer instead; the semantics are identical";
    goto &default_installer;
  }
  
  
  setup_exporter({
    exports => [
      qw(setup_exporter build_exporter),
      _import => sub { build_exporter($_[2]) },
    ],
    groups  => {
      all   => [ qw(setup_exporter build_export) ],
    },
    collectors => { -setup => \&_setup },
  });
  
  sub _setup {
    my ($value, $arg) = @_;
  
    if (ref $value eq 'HASH') {
      push @{ $arg->{import_args} }, [ _import => { -as => 'import', %$value } ];
      return 1;
    } elsif (ref $value eq 'ARRAY') {
      push @{ $arg->{import_args} },
        [ _import => { -as => 'import', exports => $value } ];
      return 1;
    }
    return;
  }
  
  
  
  "jn8:32"; # <-- magic true value
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Sub::Exporter - a sophisticated exporter for custom-built routines
  
  =head1 VERSION
  
  version 0.987
  
  =head1 SYNOPSIS
  
  Sub::Exporter must be used in two places.  First, in an exporting module:
  
    # in the exporting module:
    package Text::Tweaker;
    use Sub::Exporter -setup => {
      exports => [
        qw(squish titlecase), # always works the same way
        reformat => \&build_reformatter, # generator to build exported function
        trim     => \&build_trimmer,
        indent   => \&build_indenter,
      ],
      collectors => [ 'defaults' ],
    };
  
  Then, in an importing module:
  
    # in the importing module:
    use Text::Tweaker
      'squish',
      indent   => { margin => 5 },
      reformat => { width => 79, justify => 'full', -as => 'prettify_text' },
      defaults => { eol => 'CRLF' };
  
  With this setup, the importing module ends up with three routines: C<squish>,
  C<indent>, and C<prettify_text>.  The latter two have been built to the
  specifications of the importer -- they are not just copies of the code in the
  exporting package.
  
  =head1 DESCRIPTION
  
  B<ACHTUNG!>  If you're not familiar with Exporter or exporting, read
  L<Sub::Exporter::Tutorial> first!
  
  =head2 Why Generators?
  
  The biggest benefit of Sub::Exporter over existing exporters (including the
  ubiquitous Exporter.pm) is its ability to build new coderefs for export, rather
  than to simply export code identical to that found in the exporting package.
  
  If your module's consumers get a routine that works like this:
  
    use Data::Analyze qw(analyze);
    my $value = analyze($data, $tolerance, $passes);
  
  and they constantly pass only one or two different set of values for the
  non-C<$data> arguments, your code can benefit from Sub::Exporter.  By writing a
  simple generator, you can let them do this, instead:
  
    use Data::Analyze
      analyze => { tolerance => 0.10, passes => 10, -as => analyze10 },
      analyze => { tolerance => 0.15, passes => 50, -as => analyze50 };
  
    my $value = analyze10($data);
  
  The package with the generator for that would look something like this:
  
    package Data::Analyze;
    use Sub::Exporter -setup => {
      exports => [
        analyze => \&build_analyzer,
      ],
    };
  
    sub build_analyzer {
      my ($class, $name, $arg) = @_;
  
      return sub {
        my $data      = shift;
        my $tolerance = shift || $arg->{tolerance}; 
        my $passes    = shift || $arg->{passes}; 
  
        analyze($data, $tolerance, $passes);
      }
    }
  
  Your module's user now has to do less work to benefit from it -- and remember,
  you're often your own user!  Investing in customized subroutines is an
  investment in future laziness.
  
  This also avoids a common form of ugliness seen in many modules: package-level
  configuration.  That is, you might have seen something like the above
  implemented like so:
  
    use Data::Analyze qw(analyze);
    $Data::Analyze::default_tolerance = 0.10;
    $Data::Analyze::default_passes    = 10;
  
  This might save time, until you have multiple modules using Data::Analyze.
  Because there is only one global configuration, they step on each other's toes
  and your code begins to have mysterious errors.
  
  Generators can also allow you to export class methods to be called as
  subroutines:
  
    package Data::Methodical;
    use Sub::Exporter -setup => { exports => { some_method => \&_curry_class } };
  
    sub _curry_class {
      my ($class, $name) = @_;
      sub { $class->$name(@_); };
    }
  
  Because of the way that exporters and Sub::Exporter work, any package that
  inherits from Data::Methodical can inherit its exporter and override its
  C<some_method>.  If a user imports C<some_method> from that package, he'll
  receive a subroutine that calls the method on the subclass, rather than on
  Data::Methodical itself.
  
  =head2 Other Customizations
  
  Building custom routines with generators isn't the only way that Sub::Exporters
  allows the importing code to refine its use of the exported routines.  They may
  also be renamed to avoid naming collisions.
  
  Consider the following code:
  
    # this program determines to which circle of Hell you will be condemned
    use Morality qw(sin virtue); # for calculating viciousness
    use Math::Trig qw(:all);     # for dealing with circles
  
  The programmer has inadvertently imported two C<sin> routines.  The solution,
  in Exporter.pm-based modules, would be to import only one and then call the
  other by its fully-qualified name.  Alternately, the importer could write a
  routine that did so, or could mess about with typeglobs.
  
  How much easier to write:
  
    # this program determines to which circle of Hell you will be condemned
    use Morality qw(virtue), sin => { -as => 'offense' };
    use Math::Trig -all => { -prefix => 'trig_' };
  
  and to have at one's disposal C<offense> and C<trig_sin> -- not to mention
  C<trig_cos> and C<trig_tan>.
  
  =head1 EXPORTER CONFIGURATION
  
  You can configure an exporter for your package by using Sub::Exporter like so:
  
    package Tools;
    use Sub::Exporter
      -setup => { exports => [ qw(function1 function2 function3) ] };
  
  This is the simplest way to use the exporter, and is basically equivalent to
  this:
  
    package Tools;
    use base qw(Exporter);
    our @EXPORT_OK = qw(function1 function2 function3);
  
  Any basic use of Sub::Exporter will look like this:
  
    package Tools;
    use Sub::Exporter -setup => \%config;
  
  The following keys are valid in C<%config>:
  
    exports - a list of routines to provide for exporting; each routine may be
              followed by generator
    groups  - a list of groups to provide for exporting; each must be followed by
              either (a) a list of exports, possibly with arguments for each
              export, or (b) a generator
  
    collectors - a list of names into which values are collected for use in
                 routine generation; each name may be followed by a validator
  
  In addition to the basic options above, a few more advanced options may be
  passed:
  
    into_level - how far up the caller stack to look for a target (default 0)
    into       - an explicit target (package) into which to export routines
  
  In other words: Sub::Exporter installs a C<import> routine which, when called,
  exports routines to the calling namespace.  The C<into> and C<into_level>
  options change where those exported routines are installed.
  
    generator  - a callback used to produce the code that will be installed
                 default: Sub::Exporter::default_generator
  
    installer  - a callback used to install the code produced by the generator
                 default: Sub::Exporter::default_installer
  
  For information on how these callbacks are used, see the documentation for
  C<L</default_generator>> and C<L</default_installer>>.
  
  =head2 Export Configuration
  
  The C<exports> list may be provided as an array reference or a hash reference.
  The list is processed in such a way that the following are equivalent:
  
    { exports => [ qw(foo bar baz), quux => \&quux_generator ] }
  
    { exports =>
      { foo => undef, bar => undef, baz => undef, quux => \&quux_generator } }
  
  Generators are code that return coderefs.  They are called with four
  parameters:
  
    $class - the class whose exporter has been called (the exporting class)
    $name  - the name of the export for which the routine is being build
   \%arg   - the arguments passed for this export
   \%col   - the collections for this import
  
  Given the configuration in the L</SYNOPSIS>, the following C<use> statement:
  
    use Text::Tweaker
      reformat => { -as => 'make_narrow', width => 33 },
      defaults => { eol => 'CR' };
  
  would result in the following call to C<&build_reformatter>:
  
    my $code = build_reformatter(
      'Text::Tweaker',
      'reformat',
      { width => 33 }, # note that -as is not passed in
      { defaults => { eol => 'CR' } },
    );
  
  The returned coderef (C<$code>) would then be installed as C<make_narrow> in the
  calling package.
  
  Instead of providing a coderef in the configuration, a reference to a method
  name may be provided.  This method will then be called on the invocant of the
  C<import> method.  (In this case, we do not pass the C<$class> parameter, as it
  would be redundant.)
  
  =head2 Group Configuration
  
  The C<groups> list can be passed in the same forms as C<exports>.  Groups must
  have values to be meaningful, which may either list exports that make up the
  group (optionally with arguments) or may provide a way to build the group.
  
  The simpler case is the first: a group definition is a list of exports.  Here's
  the example that could go in exporter in the L</SYNOPSIS>.
  
    groups  => {
      default    => [ qw(reformat) ],
      shorteners => [ qw(squish trim) ],
      email_safe => [
        'indent',
        reformat => { -as => 'email_format', width => 72 }
      ],
    },
  
  Groups are imported by specifying their name prefixed be either a dash or a
  colon.  This line of code would import the C<shorteners> group:
  
    use Text::Tweaker qw(-shorteners);
  
  Arguments passed to a group when importing are merged into the groups options
  and passed to any relevant generators.  Groups can contain other groups, but
  looping group structures are ignored.
  
  The other possible value for a group definition, a coderef, allows one
  generator to build several exportable routines simultaneously.  This is useful
  when many routines must share enclosed lexical variables.  The coderef must
  return a hash reference.  The keys will be used as export names and the values
  are the subs that will be exported.
  
  This example shows a simple use of the group generator.
  
    package Data::Crypto;
    use Sub::Exporter -setup => { groups => { cipher => \&build_cipher_group } };
  
    sub build_cipher_group {
      my ($class, $group, $arg) = @_;
      my ($encode, $decode) = build_codec($arg->{secret});
      return { cipher => $encode, decipher => $decode };
    }
  
  The C<cipher> and C<decipher> routines are built in a group because they are
  built together by code which encloses their secret in their environment.
  
  =head3 Default Groups
  
  If a module that uses Sub::Exporter is C<use>d with no arguments, it will try
  to export the group named C<default>.  If that group has not been specifically
  configured, it will be empty, and nothing will happen.
  
  Another group is also created if not defined: C<all>.  The C<all> group
  contains all the exports from the exports list.
  
  =head2 Collector Configuration
  
  The C<collectors> entry in the exporter configuration gives names which, when
  found in the import call, have their values collected and passed to every
  generator.
  
  For example, the C<build_analyzer> generator that we saw above could be
  rewritten as:
  
   sub build_analyzer {
     my ($class, $name, $arg, $col) = @_;
  
     return sub {
       my $data      = shift;
       my $tolerance = shift || $arg->{tolerance} || $col->{defaults}{tolerance}; 
       my $passes    = shift || $arg->{passes}    || $col->{defaults}{passes}; 
  
       analyze($data, $tolerance, $passes);
     }
   }
  
  That would allow the importer to specify global defaults for his imports:
  
    use Data::Analyze
      'analyze',
      analyze  => { tolerance => 0.10, -as => analyze10 },
      analyze  => { tolerance => 0.15, passes => 50, -as => analyze50 },
      defaults => { passes => 10 };
  
    my $A = analyze10($data);     # equivalent to analyze($data, 0.10, 10);
    my $C = analyze50($data);     # equivalent to analyze($data, 0.15, 50);
    my $B = analyze($data, 0.20); # equivalent to analyze($data, 0.20, 10);
  
  If values are provided in the C<collectors> list during exporter setup, they
  must be code references, and are used to validate the importer's values.  The
  validator is called when the collection is found, and if it returns false, an
  exception is thrown.  We could ensure that no one tries to set a global data
  default easily:
  
    collectors => { defaults => sub { return (exists $_[0]->{data}) ? 0 : 1 } }
  
  Collector coderefs can also be used as hooks to perform arbitrary actions
  before anything is exported.
  
  When the coderef is called, it is passed the value of the collection and a
  hashref containing the following entries:
  
    name        - the name of the collector
    config      - the exporter configuration (hashref)
    import_args - the arguments passed to the exporter, sans collections (aref)
    class       - the package on which the importer was called
    into        - the package into which exports will be exported
  
  Collectors with all-caps names (that is, made up of underscore or capital A
  through Z) are reserved for special use.  The only currently implemented
  special collector is C<INIT>, whose hook (if present in the exporter
  configuration) is always run before any other hook.
  
  =head1 CALLING THE EXPORTER
  
  Arguments to the exporter (that is, the arguments after the module name in a
  C<use> statement) are parsed as follows:
  
  First, the collectors gather any collections found in the arguments.  Any
  reference type may be given as the value for a collector.  For each collection
  given in the arguments, its validator (if any) is called.  
  
  Next, groups are expanded.  If the group is implemented by a group generator,
  the generator is called.  There are two special arguments which, if given to a
  group, have special meaning:
  
    -prefix - a string to prepend to any export imported from this group
    -suffix - a string to append to any export imported from this group
  
  Finally, individual export generators are called and all subs, generated or
  otherwise, are installed in the calling package.  There is only one special
  argument for export generators:
  
    -as     - where to install the exported sub
  
  Normally, C<-as> will contain an alternate name for the routine.  It may,
  however, contain a reference to a scalar.  If that is the case, a reference the
  generated routine will be placed in the scalar referenced by C<-as>.  It will
  not be installed into the calling package.
  
  =head2 Special Exporter Arguments
  
  The generated exporter accept some special options, which may be passed as the
  first argument, in a hashref.
  
  These options are:
  
    into_level
    into
    generator
    installer
  
  These override the same-named configuration options described in L</EXPORTER
  CONFIGURATION>.
  
  =head1 SUBROUTINES
  
  =head2 setup_exporter
  
  This routine builds and installs an C<import> routine.  It is called with one
  argument, a hashref containing the exporter configuration.  Using this, it
  builds an exporter and installs it into the calling package with the name
  "import."  In addition to the normal exporter configuration, a few named
  arguments may be passed in the hashref:
  
    into       - into what package should the exporter be installed
    into_level - into what level up the stack should the exporter be installed
    as         - what name should the installed exporter be given
  
  By default the exporter is installed with the name C<import> into the immediate
  caller of C<setup_exporter>.  In other words, if your package calls
  C<setup_exporter> without providing any of the three above arguments, it will
  have an C<import> routine installed.
  
  Providing both C<into> and C<into_level> will cause an exception to be thrown.
  
  The exporter is built by C<L</build_exporter>>.
  
  =head2 build_exporter
  
  Given a standard exporter configuration, this routine builds and returns an
  exporter -- that is, a subroutine that can be installed as a class method to
  perform exporting on request.
  
  Usually, this method is called by C<L</setup_exporter>>, which then installs
  the exporter as a package's import routine.
  
  =head2 default_generator
  
  This is Sub::Exporter's default generator.  It takes bits of configuration that
  have been gathered during the import and turns them into a coderef that can be
  installed.
  
    my $code = default_generator(\%arg);
  
  Passed arguments are:
  
    class - the class on which the import method was called
    name  - the name of the export being generated
    arg   - the arguments to the generator
    col   - the collections
  
    generator - the generator to be used to build the export (code or scalar ref)
  
  =head2 default_installer
  
  This is Sub::Exporter's default installer.  It does what Sub::Exporter
  promises: it installs code into the target package.
  
    default_installer(\%arg, \@to_export);
  
  Passed arguments are:
  
    into - the package into which exports should be delivered
  
  C<@to_export> is a list of name/value pairs.  The default exporter assigns code
  (the values) to named slots (the names) in the given package.  If the name is a
  scalar reference, the scalar reference is made to point to the code reference
  instead.
  
  =head1 EXPORTS
  
  Sub::Exporter also offers its own exports: the C<setup_exporter> and
  C<build_exporter> routines described above.  It also provides a special "setup"
  collector, which will set up an exporter using the parameters passed to it.
  
  Note that the "setup" collector (seen in examples like the L</SYNOPSIS> above)
  uses C<build_exporter>, not C<setup_exporter>.  This means that the special
  arguments like "into" and "as" for C<setup_exporter> are not accepted here.
  Instead, you may write something like:
  
    use Sub::Exporter
      { into => 'Target::Package' },
      -setup => {
        -as     => 'do_import',
        exports => [ ... ],
      }
    ;
  
  Finding a good reason for wanting to do this is left as an exercise for the
  reader.
  
  =head1 COMPARISONS
  
  There are a whole mess of exporters on the CPAN.  The features included in
  Sub::Exporter set it apart from any existing Exporter.  Here's a summary of
  some other exporters and how they compare.
  
  =over
  
  =item * L<Exporter> and co.
  
  This is the standard Perl exporter.  Its interface is a little clunky, but it's
  fast and ubiquitous.  It can do some things that Sub::Exporter can't:  it can
  export things other than routines, it can import "everything in this group
  except this symbol," and some other more esoteric things.  These features seem
  to go nearly entirely unused.
  
  It always exports things exactly as they appear in the exporting module; it
  can't rename or customize routines.  Its groups ("tags") can't be nested.
  
  L<Exporter::Lite> is a whole lot like Exporter, but it does significantly less:
  it supports exporting symbols, but not groups, pattern matching, or negation.
  
  The fact that Sub::Exporter can't export symbols other than subroutines is
  a good idea, not a missing feature.
  
  For simple uses, setting up Sub::Exporter is about as easy as Exporter.  For
  complex uses, Sub::Exporter makes hard things possible, which would not be
  possible with Exporter. 
  
  When using a module that uses Sub::Exporter, users familiar with Exporter will
  probably see no difference in the basics.  These two lines do about the same
  thing in whether the exporting module uses Exporter or Sub::Exporter.
  
    use Some::Module qw(foo bar baz);
    use Some::Module qw(foo :bar baz);
  
  The definition for exporting in Exporter.pm might look like this:
  
    package Some::Module;
    use base qw(Exporter);
    our @EXPORT_OK   = qw(foo bar baz quux);
    our %EXPORT_TAGS = (bar => [ qw(bar baz) ]);
  
  Using Sub::Exporter, it would look like this:
  
    package Some::Module;
    use Sub::Exporter -setup => {
      exports => [ qw(foo bar baz quux) ],
      groups  => { bar => [ qw(bar baz) ]}
    };
  
  Sub::Exporter respects inheritance, so that a package may export inherited
  routines, and will export the most inherited version.  Exporting methods
  without currying away the invocant is a bad idea, but Sub::Exporter allows you
  to do just that -- and anyway, there are other uses for this feature, like
  packages of exported subroutines which use inheritance specifically to allow
  more specialized, but similar, packages.
  
  L<Exporter::Easy> provides a wrapper around the standard Exporter.  It makes it
  simpler to build groups, but doesn't provide any more functionality.  Because
  it is a front-end to Exporter, it will store your exporter's configuration in
  global package variables.
  
  =item * Attribute-Based Exporters
  
  Some exporters use attributes to mark variables to export.  L<Exporter::Simple>
  supports exporting any kind of symbol, and supports groups.  Using a module
  like Exporter or Sub::Exporter, it's easy to look at one place and see what is
  exported, but it's impossible to look at a variable definition and see whether
  it is exported by that alone.  Exporter::Simple makes this trade in reverse:
  each variable's declaration includes its export definition, but there is no one
  place to look to find a manifest of exports.
  
  More importantly, Exporter::Simple does not add any new features to those of
  Exporter.  In fact, like Exporter::Easy, it is just a front-end to Exporter, so
  it ends up storing its configuration in global package variables.  (This means
  that there is one place to look for your exporter's manifest, actually.  You
  can inspect the C<@EXPORT> package variables, and other related package
  variables, at runtime.)
  
  L<Perl6::Export> isn't actually attribute based, but looks similar.  Its syntax
  is borrowed from Perl 6, and implemented by a source filter.  It is a prototype
  of an interface that is still being designed.  It should probably be avoided
  for production work.  On the other hand, L<Perl6::Export::Attrs> implements
  Perl 6-like exporting, but translates it into Perl 5 by providing attributes.
  
  =item * Other Exporters
  
  L<Exporter::Renaming> wraps the standard Exporter to allow it to export symbols
  with changed names.
  
  L<Class::Exporter> performs a special kind of routine generation, giving each
  importing package an instance of your class, and then exporting the instance's
  methods as normal routines.  (Sub::Exporter, of course, can easily emulate this
  behavior, as shown above.)
  
  L<Exporter::Tidy> implements a form of renaming (using its C<_map> argument)
  and of prefixing, and implements groups.  It also avoids using package
  variables for its configuration.
  
  =back
  
  =head1 TODO
  
  =over
  
  =item * write a set of longer, more demonstrative examples
  
  =item * solidify the "custom exporter" interface (see C<&default_exporter>)
  
  =item * add an "always" group
  
  =back
  
  =head1 THANKS
  
  Hans Dieter Pearcey provided helpful advice while I was writing Sub::Exporter.
  Ian Langworth and Shawn Sorichetti asked some good questions and helped me
  improve my documentation quite a bit.  Yuval Kogman helped me find a bunch of
  little problems.
  
  Thanks, guys! 
  
  =head1 BUGS
  
  Please report any bugs or feature requests through the web interface at
  L<http://rt.cpan.org>. I will be notified, and then you'll automatically be
  notified of progress on your bug as I make changes.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2007 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_EXPORTER

$fatpacked{"Sub/Exporter/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_UTIL';
  use strict;
  use warnings;
  package Sub::Exporter::Util;
  {
    $Sub::Exporter::Util::VERSION = '0.987';
  }
  # ABSTRACT: utilities to make Sub::Exporter easier
  
  use Data::OptList ();
  use Params::Util ();
  
  
  sub curry_method {
    my $override_name = shift;
    sub {
      my ($class, $name) = @_;
      $name = $override_name if defined $override_name;
      sub { $class->$name(@_); };
    }
  }
  
  BEGIN { *curry_class = \&curry_method; }
  
  
  sub curry_chain {
    # In the future, we can make \%arg an optional prepend, like the "special"
    # args to the default Sub::Exporter-generated import routine.
    my (@opt_list) = @_;
  
    my $pairs = Data::OptList::mkopt(\@opt_list, 'args', 'ARRAY');
  
    sub {
      my ($class) = @_;
  
      sub {
        my $next = $class;
  
        for my $i (0 .. $#$pairs) {
          my $pair = $pairs->[ $i ];
          
          unless (Params::Util::_INVOCANT($next)) { ## no critic Private
            my $str = defined $next ? "'$next'" : 'undef';
            Carp::croak("can't call $pair->[0] on non-invocant $str")
          }
  
          my ($method, $args) = @$pair;
  
          if ($i == $#$pairs) {
            return $next->$method($args ? @$args : ());
          } else {
            $next = $next->$method($args ? @$args : ());
          }
        }
      };
    }
  }
  
  # =head2 name_map
  # 
  # This utility returns an list to be used in specify export generators.  For
  # example, the following:
  # 
  #   exports => {
  #     name_map(
  #       '_?_gen'  => [ qw(fee fie) ],
  #       '_make_?' => [ qw(foo bar) ],
  #     ),
  #   }
  # 
  # is equivalent to:
  # 
  #   exports => {
  #     name_map(
  #       fee => \'_fee_gen',
  #       fie => \'_fie_gen',
  #       foo => \'_make_foo',
  #       bar => \'_make_bar',
  #     ),
  #   }
  # 
  # This can save a lot of typing, when providing many exports with similarly-named
  # generators.
  # 
  # =cut
  # 
  # sub name_map {
  #   my (%groups) = @_;
  # 
  #   my %map;
  # 
  #   while (my ($template, $names) = each %groups) {
  #     for my $name (@$names) {
  #       (my $export = $template) =~ s/\?/$name/
  #         or Carp::croak 'no ? found in name_map template';
  # 
  #       $map{ $name } = \$export;
  #     }
  #   }
  # 
  #   return %map;
  # }
  
  
  sub merge_col {
    my (%groups) = @_;
  
    my %merged;
  
    while (my ($default_name, $group) = each %groups) {
      while (my ($export_name, $gen) = each %$group) {
        $merged{$export_name} = sub {
          my ($class, $name, $arg, $col) = @_;
  
          my $merged_arg = exists $col->{$default_name}
                         ? { %{ $col->{$default_name} }, %$arg }
                         : $arg;
  
          if (Params::Util::_CODELIKE($gen)) { ## no critic Private
            $gen->($class, $name, $merged_arg, $col);
          } else {
            $class->$$gen($name, $merged_arg, $col);
          }
        }
      }
    }
  
    return %merged;
  }
  
  
  sub __mixin_class_for {
    my ($class, $mix_into) = @_;
    require Package::Generator;
    my $mixin_class = Package::Generator->new_package({
      base => "$class\:\:__mixin__",
    });
  
    ## no critic (ProhibitNoStrict)
    no strict 'refs';
    if (ref $mix_into) {
      unshift @{"$mixin_class" . "::ISA"}, ref $mix_into;
    } else {
      unshift @{"$mix_into" . "::ISA"}, $mixin_class;
    }
    return $mixin_class;
  }
  
  sub mixin_installer {
    sub {
      my ($arg, $to_export) = @_;
  
      my $mixin_class = __mixin_class_for($arg->{class}, $arg->{into});
      bless $arg->{into} => $mixin_class if ref $arg->{into};
  
      Sub::Exporter::default_installer(
        { %$arg, into => $mixin_class },
        $to_export,
      );
    };
  }
  
  sub mixin_exporter {
    Carp::cluck "mixin_exporter is deprecated; use mixin_installer instead; it behaves identically";
    return mixin_installer;
  }
  
  
  sub like {
    sub {
      my ($value, $arg) = @_;
      Carp::croak "no regex supplied to regex group generator" unless $value;
  
      # Oh, qr//, how you bother me!  See the p5p thread from around now about
      # fixing this problem... too bad it won't help me. -- rjbs, 2006-04-25
      my @values = eval { $value->isa('Regexp') } ? ($value, undef)
                 :                                  @$value;
  
      while (my ($re, $opt) = splice @values, 0, 2) {
        Carp::croak "given pattern for regex group generater is not a Regexp"
          unless eval { $re->isa('Regexp') };
        my @exports  = keys %{ $arg->{config}->{exports} };
        my @matching = grep { $_ =~ $re } @exports;
  
        my %merge = $opt ? %$opt : ();
        my $prefix = (delete $merge{-prefix}) || '';
        my $suffix = (delete $merge{-suffix}) || '';
  
        for my $name (@matching) {
          my $as = $prefix . $name . $suffix;
          push @{ $arg->{import_args} }, [ $name => { %merge, -as => $as } ];
        }
      }
  
      1;
    }
  }
  
  use Sub::Exporter -setup => {
    exports => [ qw(
      like
      name_map
      merge_col
      curry_method curry_class
      curry_chain
      mixin_installer mixin_exporter
    ) ]
  };
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Sub::Exporter::Util - utilities to make Sub::Exporter easier
  
  =head1 VERSION
  
  version 0.987
  
  =head1 DESCRIPTION
  
  This module provides a number of utility functions for performing common or
  useful operations when setting up a Sub::Exporter configuration.  All of the
  utilities may be exported, but none are by default.
  
  =head1 THE UTILITIES
  
  =head2 curry_method
  
    exports => {
      some_method => curry_method,
    }
  
  This utility returns a generator which will produce an invocant-curried version
  of a method.  In other words, it will export a method call with the exporting
  class built in as the invocant.
  
  A module importing the code some the above example might do this:
  
    use Some::Module qw(some_method);
  
    my $x = some_method;
  
  This would be equivalent to:
  
    use Some::Module;
  
    my $x = Some::Module->some_method;
  
  If Some::Module is subclassed and the subclass's import method is called to
  import C<some_method>, the subclass will be curried in as the invocant.
  
  If an argument is provided for C<curry_method> it is used as the name of the
  curried method to export.  This means you could export a Widget constructor
  like this:
  
    exports => { widget => curry_method('new') }
  
  This utility may also be called as C<curry_class>, for backwards compatibility.
  
  =head2 curry_chain
  
  C<curry_chain> behaves like C<L</curry_method>>, but is meant for generating
  exports that will call several methods in succession.
  
    exports => {
      reticulate => curry_chain(
        new => gather_data => analyze => [ detail => 100 ] => 'results'
      ),
    }
  
  If imported from Spliner, calling the C<reticulate> routine will be equivalent
  to:
  
    Spliner->new->gather_data->analyze(detail => 100)->results;
  
  If any method returns something on which methods may not be called, the routine
  croaks.
  
  The arguments to C<curry_chain> form an optlist.  The names are methods to be
  called and the arguments, if given, are arrayrefs to be dereferenced and passed
  as arguments to those methods.  C<curry_chain> returns a generator like those
  expected by Sub::Exporter.
  
  B<Achtung!> at present, there is no way to pass arguments from the generated
  routine to the method calls.  This will probably be solved in future revisions
  by allowing the opt list's values to be subroutines that will be called with
  the generated routine's stack.
  
  =head2 merge_col
  
    exports => {
      merge_col(defaults => {
        twiddle => \'_twiddle_gen',
        tweak   => \&_tweak_gen,
      }),
    }
  
  This utility wraps the given generator in one that will merge the named
  collection into its args before calling it.  This means that you can support a
  "default" collector in multiple exports without writing the code each time.
  
  You can specify as many pairs of collection names and generators as you like.
  
  =head2 mixin_installer
  
    use Sub::Exporter -setup => {
      installer => Sub::Exporter::Util::mixin_installer,
      exports   => [ qw(foo bar baz) ],
    };
  
  This utility returns an installer that will install into a superclass and
  adjust the ISA importing class to include the newly generated superclass.
  
  If the target of importing is an object, the hierarchy is reversed: the new
  class will be ISA the object's class, and the object will be reblessed.
  
  B<Prerequisites>: This utility requires that Package::Generator be installed.
  
  =head2 like
  
  It's a collector that adds imports for anything like given regex.
  
  If you provide this configuration:
  
    exports    => [ qw(igrep imap islurp exhausted) ],
    collectors => { -like => Sub::Exporter::Util::like },
  
  A user may import from your module like this:
  
    use Your::Iterator -like => qr/^i/; # imports igre, imap, islurp
  
  or
  
    use Your::Iterator -like => [ qr/^i/ => { -prefix => 'your_' } ];
  
  The group-like prefix and suffix arguments are respected; other arguments are
  passed on to the generators for matching exports.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2007 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_EXPORTER_UTIL

$fatpacked{"Sub/Install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_INSTALL';
  use strict;
  use warnings;
  package Sub::Install;
  # ABSTRACT: install subroutines into packages easily
  $Sub::Install::VERSION = '0.928';
  use Carp;
  use Scalar::Util ();
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   use Sub::Install;
  #pod
  #pod   Sub::Install::install_sub({
  #pod     code => sub { ... },
  #pod     into => $package,
  #pod     as   => $subname
  #pod   });
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This module makes it easy to install subroutines into packages without the
  #pod unsightly mess of C<no strict> or typeglobs lying about where just anyone can
  #pod see them.
  #pod
  #pod =func install_sub
  #pod
  #pod   Sub::Install::install_sub({
  #pod    code => \&subroutine,
  #pod    into => "Finance::Shady",
  #pod    as   => 'launder',
  #pod   });
  #pod
  #pod This routine installs a given code reference into a package as a normal
  #pod subroutine.  The above is equivalent to:
  #pod
  #pod   no strict 'refs';
  #pod   *{"Finance::Shady" . '::' . "launder"} = \&subroutine;
  #pod
  #pod If C<into> is not given, the sub is installed into the calling package.
  #pod
  #pod If C<code> is not a code reference, it is looked for as an existing sub in the
  #pod package named in the C<from> parameter.  If C<from> is not given, it will look
  #pod in the calling package.
  #pod
  #pod If C<as> is not given, and if C<code> is a name, C<as> will default to C<code>.
  #pod If C<as> is not given, but if C<code> is a code ref, Sub::Install will try to
  #pod find the name of the given code ref and use that as C<as>.
  #pod
  #pod That means that this code:
  #pod
  #pod   Sub::Install::install_sub({
  #pod     code => 'twitch',
  #pod     from => 'Person::InPain',
  #pod     into => 'Person::Teenager',
  #pod     as   => 'dance',
  #pod   });
  #pod
  #pod is the same as:
  #pod
  #pod   package Person::Teenager;
  #pod
  #pod   Sub::Install::install_sub({
  #pod     code => Person::InPain->can('twitch'),
  #pod     as   => 'dance',
  #pod   });
  #pod
  #pod =func reinstall_sub
  #pod
  #pod This routine behaves exactly like C<L</install_sub>>, but does not emit a
  #pod warning if warnings are on and the destination is already defined.
  #pod
  #pod =cut
  
  sub _name_of_code {
    my ($code) = @_;
    require B;
    my $name = B::svref_2object($code)->GV->NAME;
    return $name unless $name =~ /\A__ANON__/;
    return;
  }
  
  # See also Params::Util, to which this code was donated.
  sub _CODELIKE {
    (Scalar::Util::reftype($_[0])||'') eq 'CODE'
    || Scalar::Util::blessed($_[0])
    && (overload::Method($_[0],'&{}') ? $_[0] : undef);
  }
  
  # do the heavy lifting
  sub _build_public_installer {
    my ($installer) = @_;
  
    sub {
      my ($arg) = @_;
      my ($calling_pkg) = caller(0);
  
      # I'd rather use ||= but I'm whoring for Devel::Cover.
      for (qw(into from)) { $arg->{$_} = $calling_pkg unless $arg->{$_} }
  
      # This is the only absolutely required argument, in many cases.
      Carp::croak "named argument 'code' is not optional" unless $arg->{code};
  
      if (_CODELIKE($arg->{code})) {
        $arg->{as} ||= _name_of_code($arg->{code});
      } else {
        Carp::croak
          "couldn't find subroutine named $arg->{code} in package $arg->{from}"
          unless my $code = $arg->{from}->can($arg->{code});
  
        $arg->{as}   = $arg->{code} unless $arg->{as};
        $arg->{code} = $code;
      }
  
      Carp::croak "couldn't determine name under which to install subroutine"
        unless $arg->{as};
  
      $installer->(@$arg{qw(into as code) });
    }
  }
  
  # do the ugly work
  
  my $_misc_warn_re;
  my $_redef_warn_re;
  BEGIN {
    $_misc_warn_re = qr/
      Prototype\ mismatch:\ sub\ .+?  |
      Constant subroutine .+? redefined
    /x;
    $_redef_warn_re = qr/Subroutine\ .+?\ redefined/x;
  }
  
  my $eow_re;
  BEGIN { $eow_re = qr/ at .+? line \d+\.\Z/ };
  
  sub _do_with_warn {
    my ($arg) = @_;
    my $code = delete $arg->{code};
    my $wants_code = sub {
      my $code = shift;
      sub {
        my $warn = $SIG{__WARN__} ? $SIG{__WARN__} : sub { warn @_ }; ## no critic
        local $SIG{__WARN__} = sub {
          my ($error) = @_;
          for (@{ $arg->{suppress} }) {
              return if $error =~ $_;
          }
          for (@{ $arg->{croak} }) {
            if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
              Carp::croak $base_error;
            }
          }
          for (@{ $arg->{carp} }) {
            if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
              return $warn->(Carp::shortmess $base_error);
            }
          }
          ($arg->{default} || $warn)->($error);
        };
        $code->(@_);
      };
    };
    return $wants_code->($code) if $code;
    return $wants_code;
  }
  
  sub _installer {
    sub {
      my ($pkg, $name, $code) = @_;
      no strict 'refs'; ## no critic ProhibitNoStrict
      *{"$pkg\::$name"} = $code;
      return $code;
    }
  }
  
  BEGIN {
    *_ignore_warnings = _do_with_warn({
      carp => [ $_misc_warn_re, $_redef_warn_re ]
    });
  
    *install_sub = _build_public_installer(_ignore_warnings(_installer));
  
    *_carp_warnings =  _do_with_warn({
      carp     => [ $_misc_warn_re ],
      suppress => [ $_redef_warn_re ],
    });
  
    *reinstall_sub = _build_public_installer(_carp_warnings(_installer));
  
    *_install_fatal = _do_with_warn({
      code     => _installer,
      croak    => [ $_redef_warn_re ],
    });
  }
  
  #pod =func install_installers
  #pod
  #pod This routine is provided to allow Sub::Install compatibility with
  #pod Sub::Installer.  It installs C<install_sub> and C<reinstall_sub> methods into
  #pod the package named by its argument.
  #pod
  #pod  Sub::Install::install_installers('Code::Builder'); # just for us, please
  #pod  Code::Builder->install_sub({ name => $code_ref });
  #pod
  #pod  Sub::Install::install_installers('UNIVERSAL'); # feeling lucky, punk?
  #pod  Anything::At::All->install_sub({ name => $code_ref });
  #pod
  #pod The installed installers are similar, but not identical, to those provided by
  #pod Sub::Installer.  They accept a single hash as an argument.  The key/value pairs
  #pod are used as the C<as> and C<code> parameters to the C<install_sub> routine
  #pod detailed above.  The package name on which the method is called is used as the
  #pod C<into> parameter.
  #pod
  #pod Unlike Sub::Installer's C<install_sub> will not eval strings into code, but
  #pod will look for named code in the calling package.
  #pod
  #pod =cut
  
  sub install_installers {
    my ($into) = @_;
  
    for my $method (qw(install_sub reinstall_sub)) {
      my $code = sub {
        my ($package, $subs) = @_;
        my ($caller) = caller(0);
        my $return;
        for (my ($name, $sub) = %$subs) {
          $return = Sub::Install->can($method)->({
            code => $sub,
            from => $caller,
            into => $package,
            as   => $name
          });
        }
        return $return;
      };
      install_sub({ code => $code, into => $into, as => $method });
    }
  }
  
  #pod =head1 EXPORTS
  #pod
  #pod Sub::Install exports C<install_sub> and C<reinstall_sub> only if they are
  #pod requested.
  #pod
  #pod =head2 exporter
  #pod
  #pod Sub::Install has a never-exported subroutine called C<exporter>, which is used
  #pod to implement its C<import> routine.  It takes a hashref of named arguments,
  #pod only one of which is currently recognize: C<exports>.  This must be an arrayref
  #pod of subroutines to offer for export.
  #pod
  #pod This routine is mainly for Sub::Install's own consumption.  Instead, consider
  #pod L<Sub::Exporter>.
  #pod
  #pod =cut
  
  sub exporter {
    my ($arg) = @_;
  
    my %is_exported = map { $_ => undef } @{ $arg->{exports} };
  
    sub {
      my $class = shift;
      my $target = caller;
      for (@_) {
        Carp::croak "'$_' is not exported by $class" if !exists $is_exported{$_};
        install_sub({ code => $_, from => $class, into => $target });
      }
    }
  }
  
  BEGIN { *import = exporter({ exports => [ qw(install_sub reinstall_sub) ] }); }
  
  #pod =head1 SEE ALSO
  #pod
  #pod =over
  #pod
  #pod =item L<Sub::Installer>
  #pod
  #pod This module is (obviously) a reaction to Damian Conway's Sub::Installer, which
  #pod does the same thing, but does it by getting its greasy fingers all over
  #pod UNIVERSAL.  I was really happy about the idea of making the installation of
  #pod coderefs less ugly, but I couldn't bring myself to replace the ugliness of
  #pod typeglobs and loosened strictures with the ugliness of UNIVERSAL methods.
  #pod
  #pod =item L<Sub::Exporter>
  #pod
  #pod This is a complete Exporter.pm replacement, built atop Sub::Install.
  #pod
  #pod =back
  #pod
  #pod =head1 EXTRA CREDITS
  #pod
  #pod Several of the tests are adapted from tests that shipped with Damian Conway's
  #pod Sub-Installer distribution.
  #pod
  #pod =cut
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Sub::Install - install subroutines into packages easily
  
  =head1 VERSION
  
  version 0.928
  
  =head1 SYNOPSIS
  
    use Sub::Install;
  
    Sub::Install::install_sub({
      code => sub { ... },
      into => $package,
      as   => $subname
    });
  
  =head1 DESCRIPTION
  
  This module makes it easy to install subroutines into packages without the
  unsightly mess of C<no strict> or typeglobs lying about where just anyone can
  see them.
  
  =head1 FUNCTIONS
  
  =head2 install_sub
  
    Sub::Install::install_sub({
     code => \&subroutine,
     into => "Finance::Shady",
     as   => 'launder',
    });
  
  This routine installs a given code reference into a package as a normal
  subroutine.  The above is equivalent to:
  
    no strict 'refs';
    *{"Finance::Shady" . '::' . "launder"} = \&subroutine;
  
  If C<into> is not given, the sub is installed into the calling package.
  
  If C<code> is not a code reference, it is looked for as an existing sub in the
  package named in the C<from> parameter.  If C<from> is not given, it will look
  in the calling package.
  
  If C<as> is not given, and if C<code> is a name, C<as> will default to C<code>.
  If C<as> is not given, but if C<code> is a code ref, Sub::Install will try to
  find the name of the given code ref and use that as C<as>.
  
  That means that this code:
  
    Sub::Install::install_sub({
      code => 'twitch',
      from => 'Person::InPain',
      into => 'Person::Teenager',
      as   => 'dance',
    });
  
  is the same as:
  
    package Person::Teenager;
  
    Sub::Install::install_sub({
      code => Person::InPain->can('twitch'),
      as   => 'dance',
    });
  
  =head2 reinstall_sub
  
  This routine behaves exactly like C<L</install_sub>>, but does not emit a
  warning if warnings are on and the destination is already defined.
  
  =head2 install_installers
  
  This routine is provided to allow Sub::Install compatibility with
  Sub::Installer.  It installs C<install_sub> and C<reinstall_sub> methods into
  the package named by its argument.
  
   Sub::Install::install_installers('Code::Builder'); # just for us, please
   Code::Builder->install_sub({ name => $code_ref });
  
   Sub::Install::install_installers('UNIVERSAL'); # feeling lucky, punk?
   Anything::At::All->install_sub({ name => $code_ref });
  
  The installed installers are similar, but not identical, to those provided by
  Sub::Installer.  They accept a single hash as an argument.  The key/value pairs
  are used as the C<as> and C<code> parameters to the C<install_sub> routine
  detailed above.  The package name on which the method is called is used as the
  C<into> parameter.
  
  Unlike Sub::Installer's C<install_sub> will not eval strings into code, but
  will look for named code in the calling package.
  
  =head1 EXPORTS
  
  Sub::Install exports C<install_sub> and C<reinstall_sub> only if they are
  requested.
  
  =head2 exporter
  
  Sub::Install has a never-exported subroutine called C<exporter>, which is used
  to implement its C<import> routine.  It takes a hashref of named arguments,
  only one of which is currently recognize: C<exports>.  This must be an arrayref
  of subroutines to offer for export.
  
  This routine is mainly for Sub::Install's own consumption.  Instead, consider
  L<Sub::Exporter>.
  
  =head1 SEE ALSO
  
  =over
  
  =item L<Sub::Installer>
  
  This module is (obviously) a reaction to Damian Conway's Sub::Installer, which
  does the same thing, but does it by getting its greasy fingers all over
  UNIVERSAL.  I was really happy about the idea of making the installation of
  coderefs less ugly, but I couldn't bring myself to replace the ugliness of
  typeglobs and loosened strictures with the ugliness of UNIVERSAL methods.
  
  =item L<Sub::Exporter>
  
  This is a complete Exporter.pm replacement, built atop Sub::Install.
  
  =back
  
  =head1 EXTRA CREDITS
  
  Several of the tests are adapted from tests that shipped with Damian Conway's
  Sub-Installer distribution.
  
  =head1 AUTHOR
  
  Ricardo SIGNES <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2005 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_INSTALL

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;
  BEGIN {
    $Try::Tiny::AUTHORITY = 'cpan:NUFFIN';
  }
  $Try::Tiny::VERSION = '0.20';
  use 5.006;
  # ABSTRACT: minimal try/catch with proper preservation of $@
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT = our @EXPORT_OK = qw(try catch finally);
  
  use Carp;
  $Carp::Internal{+__PACKAGE__}++;
  
  BEGIN { eval "use Sub::Name; 1" or *{subname} = sub {1} }
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
    my ( $try, @code_refs ) = @_;
  
    # we need to save this here, the eval block will be in scalar context due
    # to $failed
    my $wantarray = wantarray;
  
    # work around perl bug by explicitly initializing these, due to the likelyhood
    # this will be used in global destruction (perl rt#119311)
    my ( $catch, @finally ) = ();
  
    # find labeled blocks in the argument list.
    # catch and finally tag the blocks by blessing a scalar reference to them.
    foreach my $code_ref (@code_refs) {
  
      if ( ref($code_ref) eq 'Try::Tiny::Catch' ) {
        croak 'A try() may not be followed by multiple catch() blocks'
          if $catch;
        $catch = ${$code_ref};
      } elsif ( ref($code_ref) eq 'Try::Tiny::Finally' ) {
        push @finally, ${$code_ref};
      } else {
        croak(
          'try() encountered an unexpected argument ('
        . ( defined $code_ref ? $code_ref : 'undef' )
        . ') - perhaps a missing semi-colon before or'
        );
      }
    }
  
    # FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
    # not perfect, but we could provide a list of additional errors for
    # $catch->();
  
    # name the blocks if we have Sub::Name installed
    my $caller = caller;
    subname("${caller}::try {...} " => $try);
    subname("${caller}::catch {...} " => $catch) if $catch;
    subname("${caller}::finally {...} " => $_) foreach @finally;
  
    # save the value of $@ so we can set $@ back to it in the beginning of the eval
    # and restore $@ after the eval finishes
    my $prev_error = $@;
  
    my ( @ret, $error );
  
    # failed will be true if the eval dies, because 1 will not be returned
    # from the eval body
    my $failed = not eval {
      $@ = $prev_error;
  
      # evaluate the try block in the correct context
      if ( $wantarray ) {
        @ret = $try->();
      } elsif ( defined $wantarray ) {
        $ret[0] = $try->();
      } else {
        $try->();
      };
  
      return 1; # properly set $fail to false
    };
  
    # preserve the current error and reset the original value of $@
    $error = $@;
    $@ = $prev_error;
  
    # set up a scope guard to invoke the finally block at the end
    my @guards =
      map { Try::Tiny::ScopeGuard->_new($_, $failed ? $error : ()) }
      @finally;
  
    # at this point $failed contains a true value if the eval died, even if some
    # destructor overwrote $@ as the eval was unwinding.
    if ( $failed ) {
      # if we got an error, invoke the catch block.
      if ( $catch ) {
        # This works like given($error), but is backwards compatible and
        # sets $_ in the dynamic scope for the body of C<$catch>
        for ($error) {
          return $catch->($error);
        }
  
        # in case when() was used without an explicit return, the C<for>
        # loop will be aborted and there's no useful return value
      }
  
      return;
    } else {
      # no failure, $@ is back to what it was, everything is fine
      return $wantarray ? @ret : $ret[0];
    }
  }
  
  sub catch (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare catch()' unless wantarray;
  
    return (
      bless(\$block, 'Try::Tiny::Catch'),
      @rest,
    );
  }
  
  sub finally (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare finally()' unless wantarray;
  
    return (
      bless(\$block, 'Try::Tiny::Finally'),
      @rest,
    );
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    use constant UNSTABLE_DOLLARAT => ($] < '5.013002') ? 1 : 0;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my ($code, @args) = @{ $_[0] };
  
      local $@ if UNSTABLE_DOLLARAT;
      eval {
        $code->(@args);
        1;
      } or do {
        warn
          "Execution of finally() block $code resulted in an exception, which "
        . '*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. '
        . 'Your program will continue as if this event never took place. '
        . "Original exception text follows:\n\n"
        . (defined $@ ? $@ : '$@ left undefined...')
        . "\n"
        ;
      }
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Try::Tiny - minimal try/catch with proper preservation of $@
  
  =head1 VERSION
  
  version 0.20
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
    # handle errors with a catch handler
    try {
      die "foo";
    } catch {
      warn "caught error: $_"; # not $@
    };
  
  You can also use it like a standalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
    # just silence errors
    try {
      die "foo";
    };
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the C<try> block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L</BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the C<try> block dies, it returns the value of the last statement executed in
  the C<catch> block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following examples all
  assign C<"bar"> to C<$x>:
  
    my $x = try { die "foo" } catch { "bar" };
    my $x = try { die "foo" } || { "bar" };
    my $x = (try { die "foo" }) // { "bar" };
  
    my $x = eval { die "foo" } || "bar";
  
  You can add C<finally> blocks, yielding the following:
  
    my $x;
    try { die 'foo' } finally { $x = 'bar' };
    try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  C<finally> blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many C<finally> blocks to a
  given C<try> block as you like.
  
  Note that adding a C<finally> block without a preceding C<catch> block
  suppresses any errors. This behaviour is consistent with using a standalone
  C<eval>, but it is not consistent with C<try>/C<finally> patterns found in
  other programming languages, such as Java, Python, Javascript or C#. If you
  learnt the C<try>/C<finally> pattern from one of these languages, watch out for
  this.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory C<try> subroutine, an optional C<catch> subroutine and C<finally>
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the C<finally> block, if given, will execute.
  
  =item catch (&;@)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
    catch { ... }
  
  Inside the C<catch> block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
    local $@ = $_;
  
  =item finally (&;@)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. C<finally> blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the C<finally> block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the C<finally> block does not
  localize C<$_> with the error, since unlike in a C<catch> block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the C<finally> block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  Furthermore B<exceptions in C<finally> blocks are not trappable and are unable
  to influence the execution of your program>. This is due to limitation of
  C<DESTROY>-based scope guards, which C<finally> is implemented on top of. This
  may change in a future version of Try::Tiny.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an C<eval> block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically, C<$@> is clobbered at the beginning of the C<eval>, which
  also makes it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (the one
  available before entering the C<try> block) in the beginning of the C<eval>
  block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an C<eval> block, C<die> behaves sort of like:
  
    sub die {
      $@ = $_[0];
      return_undef_from_eval();
    }
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
    my $error = do {
      local $@;
      eval { ... };
      $@;
    };
  
    ...
    die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
    if ( $@ ) {
      ...
    }
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode is:
  
    sub Object::DESTROY {
      eval { ... }
    }
  
    eval {
      my $obj = Object->new;
  
      die "foo";
    };
  
    if ( $@ ) {
  
    }
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the C<eval> was aborted due to an error:
  
    my $failed = not eval {
      ...
  
      return 1;
    };
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 SHINY SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements">.
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
    try {
      require Foo;
    } catch {
      when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
      default { die $_ }
    };
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  arglist. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
    sub foo {
      my ( $self, @args ) = @_;
      try { $self->bar(@args) }
    }
  
  or
  
    sub bar_in_place {
      my $self = shift;
      my $args = \@_;
      try { $_ = $self->bar($_) for @$args }
    }
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
      try {
        die;
      }
      catch {
        return;
      };
  
      say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
      my $success = try {
        die;
        1;
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
    # OR
    sub parent_sub_with_catch {
      my $success = try {
        die;
        1;
      }
      catch {
        # do something with $_
        return undef; #see note
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
  
  Note that if you have a C<catch> block, it must return C<undef> for this to work,
  since if a C<catch> block exists, its return value is returned in place of C<undef>
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygenically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
    my $obj = try {
      MightFail->new;
    } catch {
      ...
  
      return; # avoid returning a true value;
    };
  
    return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
    given ($foo) {
      when (...) {
        try {
          ...
        } catch {
          warn $_; # will print $foo, not the error
          warn $_[0]; # instead, get the error like this
        }
      }
    }
  
  Note that this behavior was changed once again in L<Perl5 version 18
  |https://metacpan.org/module/perldelta#given-now-aliases-the-global-_>.
  However, since the entirety of lexical C<$_> is now L<considired experimental
  |https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental>, it
  is unclear whether the new version 18 behavior is final.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul>
  
  Or read the source:
  
  L<http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 VERSION CONTROL
  
  L<http://github.com/doy/try-tiny/>
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Yuval Kogman <nothingmuch@woobling.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by Yuval Kogman.
  
  This is free software, licensed under:
  
    The MIT (X11) License
  
  =cut
TRY_TINY

$fatpacked{"x86_64-linux/Params/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PARAMS_UTIL';
  package Params::Util;
  
  =pod
  
  =head1 NAME
  
  Params::Util - Simple, compact and correct param-checking functions
  
  =head1 SYNOPSIS
  
    # Import some functions
    use Params::Util qw{_SCALAR _HASH _INSTANCE};
    
    # If you are lazy, or need a lot of them...
    use Params::Util ':ALL';
    
    sub foo {
        my $object  = _INSTANCE(shift, 'Foo') or return undef;
        my $image   = _SCALAR(shift)          or return undef;
        my $options = _HASH(shift)            or return undef;
        # etc...
    }
  
  =head1 DESCRIPTION
  
  C<Params::Util> provides a basic set of importable functions that makes
  checking parameters a hell of a lot easier
  
  While they can be (and are) used in other contexts, the main point
  behind this module is that the functions B<both> Do What You Mean,
  and Do The Right Thing, so they are most useful when you are getting
  params passed into your code from someone and/or somewhere else
  and you can't really trust the quality.
  
  Thus, C<Params::Util> is of most use at the edges of your API, where
  params and data are coming in from outside your code.
  
  The functions provided by C<Params::Util> check in the most strictly
  correct manner known, are documented as thoroughly as possible so their
  exact behaviour is clear, and heavily tested so make sure they are not
  fooled by weird data and Really Bad Things.
  
  To use, simply load the module providing the functions you want to use
  as arguments (as shown in the SYNOPSIS).
  
  To aid in maintainability, C<Params::Util> will B<never> export by
  default.
  
  You must explicitly name the functions you want to export, or use the
  C<:ALL> param to just have it export everything (although this is not
  recommended if you have any _FOO functions yourself with which future
  additions to C<Params::Util> may clash)
  
  =head1 FUNCTIONS
  
  =cut
  
  use 5.00503;
  use strict;
  require overload;
  require Exporter;
  require Scalar::Util;
  require DynaLoader;
  
  use vars qw{$VERSION @ISA @EXPORT_OK %EXPORT_TAGS};
  
  $VERSION   = '1.07';
  @ISA       = qw{
  	Exporter
  	DynaLoader
  };
  @EXPORT_OK = qw{
  	_STRING     _IDENTIFIER
  	_CLASS      _CLASSISA   _SUBCLASS  _DRIVER  _CLASSDOES
  	_NUMBER     _POSINT     _NONNEGINT
  	_SCALAR     _SCALAR0
  	_ARRAY      _ARRAY0     _ARRAYLIKE
  	_HASH       _HASH0      _HASHLIKE
  	_CODE       _CODELIKE
  	_INVOCANT   _REGEX      _INSTANCE  _INSTANCEDOES
  	_SET        _SET0
  	_HANDLE
  };
  %EXPORT_TAGS = ( ALL => \@EXPORT_OK );
  
  eval {
  	local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
  	bootstrap Params::Util $VERSION;
  	1;
  } unless $ENV{PERL_PARAMS_UTIL_PP};
  
  # Use a private pure-perl copy of looks_like_number if the version of
  # Scalar::Util is old (for whatever reason).
  my $SU = eval "$Scalar::Util::VERSION" || 0;
  if ( $SU >= 1.18 ) { 
  	Scalar::Util->import('looks_like_number');
  } else {
  	eval <<'END_PERL';
  sub looks_like_number {
  	local $_ = shift;
  
  	# checks from perlfaq4
  	return 0 if !defined($_);
  	if (ref($_)) {
  		return overload::Overloaded($_) ? defined(0 + $_) : 0;
  	}
  	return 1 if (/^[+-]?[0-9]+$/); # is a +/- integer
  	return 1 if (/^([+-]?)(?=[0-9]|\.[0-9])[0-9]*(\.[0-9]*)?([Ee]([+-]?[0-9]+))?$/); # a C float
  	return 1 if ($] >= 5.008 and /^(Inf(inity)?|NaN)$/i) or ($] >= 5.006001 and /^Inf$/i);
  
  	0;
  }
  END_PERL
  }
  
  
  
  
  
  #####################################################################
  # Param Checking Functions
  
  =pod
  
  =head2 _STRING $string
  
  The C<_STRING> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a normal non-false string of non-zero length.
  
  Note that this will NOT do anything magic to deal with the special
  C<'0'> false negative case, but will return it.
  
    # '0' not considered valid data
    my $name = _STRING(shift) or die "Bad name";
    
    # '0' is considered valid data
    my $string = _STRING($_[0]) ? shift : die "Bad string";
  
  Please also note that this function expects a normal string. It does
  not support overloading or other magic techniques to get a string.
  
  Returns the string as a conveince if it is a valid string, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_STRING;
  sub _STRING ($) {
  	(defined $_[0] and ! ref $_[0] and length($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _IDENTIFIER $string
  
  The C<_IDENTIFIER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl identifier.
  
  Returns the string as a convenience if it is a valid identifier, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_IDENTIFIER;
  sub _IDENTIFIER ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASS $string
  
  The C<_CLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl class.
  
  This function only checks that the format is valid, not that the
  class is actually loaded. It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASS;
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASSISA $string, $class
  
  The C<_CLASSISA> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a particularly class, or a subclass of it.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSISA;
  sub _CLASSISA ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =head2 _CLASSDOES $string, $role
  
  This routine behaves exactly like C<L</_CLASSISA>>, but checks with C<< ->DOES
  >> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
  5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
  implemented.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSDOES;
  sub _CLASSDOES ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SUBCLASS $string, $class
  
  The C<_SUBCLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a subclass of a specified class.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SUBCLASS;
  sub _SUBCLASS ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0] ne $_[1] and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NUMBER $scalar
  
  The C<_NUMBER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a number. That is, it is defined and perl thinks it's a number.
  
  This function is basically a Params::Util-style wrapper around the
  L<Scalar::Util> C<looks_like_number> function.
  
  Returns the value as a convience, or C<undef> if the value is not a
  number.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NUMBER;
  sub _NUMBER ($) {
  	( defined $_[0] and ! ref $_[0] and looks_like_number($_[0]) )
  	? $_[0]
  	: undef;
  }
  END_PERL
  
  =pod
  
  =head2 _POSINT $integer
  
  The C<_POSINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a positive integer (of any length).
  
  Returns the value as a convience, or C<undef> if the value is not a
  positive integer.
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_POSINT;
  sub _POSINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[1-9]\d*$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NONNEGINT $integer
  
  The C<_NONNEGINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a non-negative integer (of any length). That is, a positive integer,
  or zero.
  
  Returns the value as a convience, or C<undef> if the value is not a
  non-negative integer.
  
  As with other tests that may return false values, care should be taken
  to test via "defined" in boolean validy contexts.
  
    unless ( defined _NONNEGINT($value) ) {
       die "Invalid value";
    }
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NONNEGINT;
  sub _NONNEGINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^(?:0|[1-9]\d*)$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR \$scalar
  
  The C<_SCALAR> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR> reference, with content of non-zero length.
  
  For a version that allows zero length C<SCALAR> references, see
  the C<_SCALAR0> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR;
  sub _SCALAR ($) {
  	(ref $_[0] eq 'SCALAR' and defined ${$_[0]} and ${$_[0]} ne '') ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR0 \$scalar
  
  The C<_SCALAR0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR0> reference, allowing content of zero-length.
  
  For a simpler "give me some content" version that requires non-zero
  length, C<_SCALAR> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR0;
  sub _SCALAR0 ($) {
  	ref $_[0] eq 'SCALAR' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY $value
  
  The C<_ARRAY> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference containing B<at least> one element of any kind.
  
  For a more basic form that allows zero length ARRAY references, see
  the C<_ARRAY0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY;
  sub _ARRAY ($) {
  	(ref $_[0] eq 'ARRAY' and @{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY0 $value
  
  The C<_ARRAY0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference, allowing C<ARRAY> references that contain no
  elements.
  
  For a more basic "An array of something" form that also requires at
  least one element, see the C<_ARRAY> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY0;
  sub _ARRAY0 ($) {
  	ref $_[0] eq 'ARRAY' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAYLIKE $value
  
  The C<_ARRAYLIKE> function tests whether a given scalar value can respond to
  array dereferencing.  If it can, the value is returned.  If it cannot,
  C<_ARRAYLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAYLIKE;
  sub _ARRAYLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'ARRAY')
  		or
  		overload::Method($_[0], '@{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH $value
  
  The C<_HASH> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference with at least one entry.
  
  For a version of this function that allows the C<HASH> to be empty,
  see the C<_HASH0> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH;
  sub _HASH ($) {
  	(ref $_[0] eq 'HASH' and scalar %{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH0 $value
  
  The C<_HASH0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference, regardless of the C<HASH> content.
  
  For a simpler "A hash of something" version that requires at least one
  element, see the C<_HASH> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH0;
  sub _HASH0 ($) {
  	ref $_[0] eq 'HASH' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASHLIKE $value
  
  The C<_HASHLIKE> function tests whether a given scalar value can respond to
  hash dereferencing.  If it can, the value is returned.  If it cannot,
  C<_HASHLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASHLIKE;
  sub _HASHLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'HASH')
  		or
  		overload::Method($_[0], '%{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODE $value
  
  The C<_CODE> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<CODE> reference.
  
  Returns the C<CODE> reference itself as a convenience, or C<undef>
  if the value provided is not an C<CODE> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODE;
  sub _CODE ($) {
  	ref $_[0] eq 'CODE' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODELIKE $value
  
  The C<_CODELIKE> is the more generic version of C<_CODE>. Unlike C<_CODE>,
  which checks for an explicit C<CODE> reference, the C<_CODELIKE> function
  also includes things that act like them, such as blessed objects that
  overload C<'&{}'>.
  
  Please note that in the case of objects overloaded with '&{}', you will
  almost always end up also testing it in 'bool' context at some stage.
  
  For example:
  
    sub foo {
        my $code1 = _CODELIKE(shift) or die "No code param provided";
        my $code2 = _CODELIKE(shift);
        if ( $code2 ) {
             print "Got optional second code param";
        }
    }
  
  As such, you will most likely always want to make sure your class has
  at least the following to allow it to evaluate to true in boolean
  context.
  
    # Always evaluate to true in boolean context
    use overload 'bool' => sub () { 1 };
  
  Returns the callable value as a convenience, or C<undef> if the
  value provided is not callable.
  
  Note - This function was formerly known as _CALLABLE but has been renamed
  for greater symmetry with the other _XXXXLIKE functions.
  
  The use of _CALLABLE has been deprecated. It will continue to work, but
  with a warning, until end-2006, then will be removed.
  
  I apologise for any inconvenience caused.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODELIKE;
  sub _CODELIKE($) {
  	(
  		(Scalar::Util::reftype($_[0])||'') eq 'CODE'
  		or
  		Scalar::Util::blessed($_[0]) and overload::Method($_[0],'&{}')
  	)
  	? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INVOCANT $value
  
  This routine tests whether the given value is a valid method invocant.
  This can be either an instance of an object, or a class name.
  
  If so, the value itself is returned.  Otherwise, C<_INVOCANT>
  returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INVOCANT;
  sub _INVOCANT($) {
  	(defined $_[0] and
  		(defined Scalar::Util::blessed($_[0])
  		or      
  		# We used to check for stash definedness, but any class-like name is a
  		# valid invocant for UNIVERSAL methods, so we stopped. -- rjbs, 2006-07-02
  		Params::Util::_CLASS($_[0]))
  	) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INSTANCE $object, $class
  
  The C<_INSTANCE> function is intended to be imported into your package,
  and provides a convenient way to test for an object of a particular class
  in a strictly correct manner.
  
  Returns the object itself as a convenience, or C<undef> if the value
  provided is not an object of that type.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCE;
  sub _INSTANCE ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =head2 _INSTANCEDOES $object, $role
  
  This routine behaves exactly like C<L</_INSTANCE>>, but checks with C<< ->DOES
  >> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
  5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
  implemented.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCEDOES;
  sub _INSTANCEDOES ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _REGEX $value
  
  The C<_REGEX> function is intended to be imported into your package,
  and provides a convenient way to test for a regular expression.
  
  Returns the value itself as a convenience, or C<undef> if the value
  provided is not a regular expression.
  
  =cut
  
  eval <<'END_PERL' unless defined &_REGEX;
  sub _REGEX ($) {
  	(defined $_[0] and 'Regexp' eq ref($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SET \@array, $class
  
  The C<_SET> function is intended to be imported into your package,
  and provides a convenient way to test for set of at least one object of
  a particular class in a strictly correct manner.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that allows zero-length sets, see the
  C<_SET0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET;
  sub _SET ($$) {
  	my $set = shift;
  	_ARRAY($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _SET0 \@array, $class
  
  The C<_SET0> function is intended to be imported into your package,
  and provides a convenient way to test for a set of objects of a
  particular class in a strictly correct manner, allowing for zero objects.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that requires at least one object, see the
  C<_SET> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET0;
  sub _SET0 ($$) {
  	my $set = shift;
  	_ARRAY0($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _HANDLE
  
  The C<_HANDLE> function is intended to be imported into your package,
  and provides a convenient way to test whether or not a single scalar
  value is a file handle.
  
  Unfortunately, in Perl the definition of a file handle can be a little
  bit fuzzy, so this function is likely to be somewhat imperfect (at first
  anyway).
  
  That said, it is implement as well or better than the other file handle
  detectors in existance (and we stole from the best of them).
  
  =cut
  
  # We're doing this longhand for now. Once everything is perfect,
  # we'll compress this into something that compiles more efficiently.
  # Further, testing file handles is not something that is generally
  # done millions of times, so doing it slowly is not a big speed hit.
  eval <<'END_PERL' unless defined &_HANDLE;
  sub _HANDLE {
  	my $it = shift;
  
  	# It has to be defined, of course
  	unless ( defined $it ) {
  		return undef;
  	}
  
  	# Normal globs are considered to be file handles
  	if ( ref $it eq 'GLOB' ) {
  		return $it;
  	}
  
  	# Check for a normal tied filehandle
  	# Side Note: 5.5.4's tied() and can() doesn't like getting undef
  	if ( tied($it) and tied($it)->can('TIEHANDLE') ) {
  		return $it;
  	}
  
  	# There are no other non-object handles that we support
  	unless ( Scalar::Util::blessed($it) ) {
  		return undef;
  	}
  
  	# Check for a common base classes for conventional IO::Handle object
  	if ( $it->isa('IO::Handle') ) {
  		return $it;
  	}
  
  
  	# Check for tied file handles using Tie::Handle
  	if ( $it->isa('Tie::Handle') ) {
  		return $it;
  	}
  
  	# IO::Scalar is not a proper seekable, but it is valid is a
  	# regular file handle
  	if ( $it->isa('IO::Scalar') ) {
  		return $it;
  	}
  
  	# Yet another special case for IO::String, which refuses (for now
  	# anyway) to become a subclass of IO::Handle.
  	if ( $it->isa('IO::String') ) {
  		return $it;
  	}
  
  	# This is not any sort of object we know about
  	return undef;
  }
  END_PERL
  
  =pod
  
  =head2 _DRIVER $string
  
    sub foo {
      my $class = _DRIVER(shift, 'My::Driver::Base') or die "Bad driver";
      ...
    }
  
  The C<_DRIVER> function is intended to be imported into your
  package, and provides a convenient way to load and validate
  a driver class.
  
  The most common pattern when taking a driver class as a parameter
  is to check that the name is a class (i.e. check against _CLASS)
  and then to load the class (if it exists) and then ensure that
  the class returns true for the isa method on some base driver name.
  
  Return the value as a convenience, or C<undef> if the value is not
  a class name, the module does not exist, the module does not load,
  or the class fails the isa test.
  
  =cut
  
  eval <<'END_PERL' unless defined &_DRIVER;
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  END_PERL
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Add _CAN to help resolve the UNIVERSAL::can debacle
  
  - Would be even nicer if someone would demonstrate how the hell to
  build a Module::Install dist of the ::Util dual Perl/XS type. :/
  
  - Implement an assertion-like version of this module, that dies on
  error.
  
  - Implement a Test:: version of this module, for use in testing
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params-Util>
  
  For other issues, contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Params::Validate>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2012 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
X86_64-LINUX_PARAMS_UTIL

$fatpacked{"x86_64-linux/Params/Validate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PARAMS_VALIDATE';
  package Params::Validate;
  
  use 5.008001;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.29';
  
  use Exporter;
  use Module::Implementation;
  use Params::Validate::Constants;
  
  use vars qw( $NO_VALIDATION %OPTIONS $options );
  
  our @ISA = 'Exporter';
  
  my @types = qw(
      SCALAR
      ARRAYREF
      HASHREF
      CODEREF
      GLOB
      GLOBREF
      SCALARREF
      HANDLE
      BOOLEAN
      UNDEF
      OBJECT
  );
  
  our %EXPORT_TAGS = (
      'all' => [
          qw( validate validate_pos validation_options validate_with ),
          @types
      ],
      types => \@types,
  );
  
  our @EXPORT_OK = ( @{ $EXPORT_TAGS{all} }, 'set_options' );
  our @EXPORT = qw( validate validate_pos );
  
  $NO_VALIDATION = $ENV{PERL_NO_VALIDATION};
  
  {
      my $loader = Module::Implementation::build_loader_sub(
          implementations => [ 'XS', 'PP' ],
          symbols         => [
              qw(
                  validate
                  validate_pos
                  validate_with
                  validation_options
                  set_options
                  ),
          ],
      );
  
      $ENV{PARAMS_VALIDATE_IMPLEMENTATION} = 'PP' if $ENV{PV_TEST_PERL};
  
      $loader->();
  }
  
  1;
  
  # ABSTRACT: Validate method/function parameters
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Params::Validate - Validate method/function parameters
  
  =head1 VERSION
  
  version 1.29
  
  =head1 SYNOPSIS
  
      use Params::Validate qw(:all);
  
      # takes named params (hash or hashref)
      sub foo {
          validate(
              @_, {
                  foo => 1,    # mandatory
                  bar => 0,    # optional
              }
          );
      }
  
      # takes positional params
      sub bar {
          # first two are mandatory, third is optional
          validate_pos( @_, 1, 1, 0 );
      }
  
      sub foo2 {
          validate(
              @_, {
                  foo =>
                      # specify a type
                      { type => ARRAYREF },
                  bar =>
                      # specify an interface
                      { can => [ 'print', 'flush', 'frobnicate' ] },
                  baz => {
                      type      => SCALAR,     # a scalar ...
                                               # ... that is a plain integer ...
                      regex     => qr/^\d+$/,
                      callbacks => {           # ... and smaller than 90
                          'less than 90' => sub { shift() < 90 },
                      },
                  }
              }
          );
      }
  
      sub callback_with_custom_error {
          validate(
              @_,
              {
                  foo => {
                      callbacks => {
                          'is an integer' => sub {
                              return 1 if $_[0] =~ /^-?[1-9][0-9]*$/;
                              die "$_[0] is not a valid integer value";
                          },
                      },
                  }
              }
          );
      }
  
      sub with_defaults {
          my %p = validate(
              @_, {
                  # required
                  foo => 1,
                  # $p{bar} will be 99 if bar is not given. bar is now
                  # optional.
                  bar => { default => 99 }
              }
          );
      }
  
      sub pos_with_defaults {
          my @p = validate_pos( @_, 1, { default => 99 } );
      }
  
      sub sets_options_on_call {
          my %p = validate_with(
              params => \@_,
              spec   => { foo => { type => SCALAR, default => 2 } },
              normalize_keys => sub { $_[0] =~ s/^-//; lc $_[0] },
          );
      }
  
  =head1 DESCRIPTION
  
  B<< I would recommend you consider using L<Params::ValidationCompiler>
  instead. That module, despite being pure Perl, is I<significantly> faster than
  this one, at the cost of having to adopt a type system such as L<Specio>,
  L<Type::Tiny>, or the one shipped with L<Moose> >>.
  
  This module allows you to validate method or function call parameters to an
  arbitrary level of specificity. At the simplest level, it is capable of
  validating the required parameters were given and that no unspecified
  additional parameters were passed in.
  
  It is also capable of determining that a parameter is of a specific
  type, that it is an object of a certain class hierarchy, that it
  possesses certain methods, or applying validation callbacks to
  arguments.
  
  =head2 EXPORT
  
  The module always exports the C<validate()> and C<validate_pos()>
  functions.
  
  It also has an additional function available for export,
  C<validate_with>, which can be used to validate any type of
  parameters, and set various options on a per-invocation basis.
  
  In addition, it can export the following constants, which are used as
  part of the type checking. These are C<SCALAR>, C<ARRAYREF>,
  C<HASHREF>, C<CODEREF>, C<GLOB>, C<GLOBREF>, and C<SCALARREF>,
  C<UNDEF>, C<OBJECT>, C<BOOLEAN>, and C<HANDLE>. These are explained
  in the section on L<Type Validation|Params::Validate/Type Validation>.
  
  The constants are available via the export tag C<:types>. There is
  also an C<:all> tag which includes all of the constants as well as the
  C<validation_options()> function.
  
  =head1 PARAMETER VALIDATION
  
  The validation mechanisms provided by this module can handle both
  named or positional parameters. For the most part, the same features
  are available for each. The biggest difference is the way that the
  validation specification is given to the relevant subroutine. The
  other difference is in the error messages produced when validation
  checks fail.
  
  When handling named parameters, the module will accept either a hash
  or a hash reference.
  
  Subroutines expecting named parameters should call the C<validate()>
  subroutine like this:
  
      validate(
          @_, {
              parameter1 => validation spec,
              parameter2 => validation spec,
              ...
          }
      );
  
  Subroutines expecting positional parameters should call the
  C<validate_pos()> subroutine like this:
  
      validate_pos( @_, { validation spec }, { validation spec } );
  
  =head2 Mandatory/Optional Parameters
  
  If you just want to specify that some parameters are mandatory and
  others are optional, this can be done very simply.
  
  For a subroutine expecting named parameters, you would do this:
  
      validate( @_, { foo => 1, bar => 1, baz => 0 } );
  
  This says that the "foo" and "bar" parameters are mandatory and that
  the "baz" parameter is optional. The presence of any other
  parameters will cause an error.
  
  For a subroutine expecting positional parameters, you would do this:
  
      validate_pos( @_, 1, 1, 0, 0 );
  
  This says that you expect at least 2 and no more than 4 parameters.
  If you have a subroutine that has a minimum number of parameters but
  can take any maximum number, you can do this:
  
      validate_pos( @_, 1, 1, (0) x (@_ - 2) );
  
  This will always be valid as long as at least two parameters are
  given. A similar construct could be used for the more complex
  validation parameters described further on.
  
  Please note that this:
  
      validate_pos( @_, 1, 1, 0, 1, 1 );
  
  makes absolutely no sense, so don't do it. Any zeros must come at the
  end of the validation specification.
  
  In addition, if you specify that a parameter can have a default, then
  it is considered optional.
  
  =head2 Type Validation
  
  This module supports the following simple types, which can be
  L<exported as constants|/EXPORT>:
  
  =over 4
  
  =item * SCALAR
  
  A scalar which is not a reference, such as C<10> or C<'hello'>. A
  parameter that is undefined is B<not> treated as a scalar. If you
  want to allow undefined values, you will have to specify C<SCALAR |
  UNDEF>.
  
  =item * ARRAYREF
  
  An array reference such as C<[1, 2, 3]> or C<\@foo>.
  
  =item * HASHREF
  
  A hash reference such as C<< { a => 1, b => 2 } >> or C<\%bar>.
  
  =item * CODEREF
  
  A subroutine reference such as C<\&foo_sub> or C<sub { print "hello" }>.
  
  =item * GLOB
  
  This one is a bit tricky. A glob would be something like C<*FOO>, but
  not C<\*FOO>, which is a glob reference. It should be noted that this
  trick:
  
      my $fh = do { local *FH; };
  
  makes C<$fh> a glob, not a glob reference. On the other hand, the
  return value from C<Symbol::gensym> is a glob reference. Either can
  be used as a file or directory handle.
  
  =item * GLOBREF
  
  A glob reference such as C<\*FOO>. See the L<GLOB|GLOB> entry above
  for more details.
  
  =item * SCALARREF
  
  A reference to a scalar such as C<\$x>.
  
  =item * UNDEF
  
  An undefined value
  
  =item * OBJECT
  
  A blessed reference.
  
  =item * BOOLEAN
  
  This is a special option, and is just a shortcut for C<UNDEF | SCALAR>.
  
  =item * HANDLE
  
  This option is also special, and is just a shortcut for C<GLOB |
  GLOBREF>. However, it seems likely that most people interested in
  either globs or glob references are likely to really be interested in
  whether the parameter in question could be a valid file or directory
  handle.
  
  =back
  
  To specify that a parameter must be of a given type when using named
  parameters, do this:
  
      validate(
          @_, {
              foo => { type => SCALAR },
              bar => { type => HASHREF }
          }
      );
  
  If a parameter can be of more than one type, just use the bitwise or
  (C<|>) operator to combine them.
  
      validate( @_, { foo => { type => GLOB | GLOBREF } );
  
  For positional parameters, this can be specified as follows:
  
      validate_pos( @_, { type => SCALAR | ARRAYREF }, { type => CODEREF } );
  
  =head2 Interface Validation
  
  To specify that a parameter is expected to have a certain set of
  methods, we can do the following:
  
      validate(
          @_, {
              foo =>
                  # just has to be able to ->bar
                  { can => 'bar' }
          }
      );
  
   ... or ...
  
      validate(
          @_, {
              foo =>
                  # must be able to ->bar and ->print
                  { can => [qw( bar print )] }
          }
      );
  
  =head2 Class Validation
  
  A word of warning. When constructing your external interfaces, it is
  probably better to specify what methods you expect an object to
  have rather than what class it should be of (or a child of). This
  will make your API much more flexible.
  
  With that said, if you want to validate that an incoming parameter
  belongs to a class (or child class) or classes, do:
  
      validate(
          @_,
          { foo => { isa => 'My::Frobnicator' } }
      );
  
   ... or ...
  
      validate(
          @_,
          # must be both, not either!
          { foo => { isa => [qw( My::Frobnicator IO::Handle )] } }
      );
  
  =head2 Regex Validation
  
  If you want to specify that a given parameter must match a specific
  regular expression, this can be done with "regex" spec key. For
  example:
  
      validate(
          @_,
          { foo => { regex => qr/^\d+$/ } }
      );
  
  The value of the "regex" key may be either a string or a pre-compiled
  regex created via C<qr>.
  
  If the value being checked against a regex is undefined, the regex is
  explicitly checked against the empty string ('') instead, in order to
  avoid "Use of uninitialized value" warnings.
  
  The C<Regexp::Common> module on CPAN is an excellent source of regular
  expressions suitable for validating input.
  
  =head2 Callback Validation
  
  If none of the above are enough, it is possible to pass in one or more
  callbacks to validate the parameter. The callback will be given the
  B<value> of the parameter as its first argument. Its second argument
  will be all the parameters, as a reference to either a hash or array.
  Callbacks are specified as hash reference. The key is an id for the
  callback (used in error messages) and the value is a subroutine
  reference, such as:
  
      validate(
          @_,
          {
              foo => {
                  callbacks => {
                      'smaller than a breadbox' => sub { shift() < $breadbox },
                      'green or blue'           => sub {
                          return 1 if $_[0] eq 'green' || $_[0] eq 'blue';
                          die "$_[0] is not green or blue!";
                      }
                  }
              }
          }
      );
  
      validate(
          @_, {
              foo => {
                  callbacks => {
                      'bigger than baz' => sub { $_[0] > $_[1]->{baz} }
                  }
              }
          }
      );
  
  The callback should return a true value if the value is valid. If not, it can
  return false or die. If you return false, a generic error message will be
  thrown by C<Params::Validate>.
  
  If your callback dies instead you can provide a custom error message. If the
  callback dies with a plain string, this string will be appended to an
  exception message generated by C<Params::Validate>. If the callback dies with
  a reference (blessed or not), then this will be rethrown as-is by
  C<Params::Validate>.
  
  =head2 Untainting
  
  If you want values untainted, set the "untaint" key in a spec hashref
  to a true value, like this:
  
      my %p = validate(
          @_, {
              foo => { type => SCALAR, untaint => 1 },
              bar => { type => ARRAYREF }
          }
      );
  
  This will untaint the "foo" parameter if the parameters are valid.
  
  Note that untainting is only done if I<all parameters> are valid.
  Also, only the return values are untainted, not the original values
  passed into the validation function.
  
  Asking for untainting of a reference value will not do anything, as
  C<Params::Validate> will only attempt to untaint the reference itself.
  
  =head2 Mandatory/Optional Revisited
  
  If you want to specify something such as type or interface, plus the
  fact that a parameter can be optional, do this:
  
      validate(
          @_, {
              foo => { type => SCALAR },
              bar => { type => ARRAYREF, optional => 1 }
          }
      );
  
  or this for positional parameters:
  
      validate_pos(
          @_,
          { type => SCALAR },
          { type => ARRAYREF, optional => 1 }
      );
  
  By default, parameters are assumed to be mandatory unless specified as
  optional.
  
  =head2 Dependencies
  
  It also possible to specify that a given optional parameter depends on
  the presence of one or more other optional parameters.
  
      validate(
          @_, {
              cc_number => {
                  type     => SCALAR,
                  optional => 1,
                  depends  => [ 'cc_expiration', 'cc_holder_name' ],
              },
              cc_expiration  => { type => SCALAR, optional => 1 },
              cc_holder_name => { type => SCALAR, optional => 1 },
          }
      );
  
  In this case, "cc_number", "cc_expiration", and "cc_holder_name" are
  all optional. However, if "cc_number" is provided, then
  "cc_expiration" and "cc_holder_name" must be provided as well.
  
  This allows you to group together sets of parameters that all must be
  provided together.
  
  The C<validate_pos()> version of dependencies is slightly different,
  in that you can only depend on one other parameter. Also, if for
  example, the second parameter 2 depends on the fourth parameter, then
  it implies a dependency on the third parameter as well. This is
  because if the fourth parameter is required, then the user must also
  provide a third parameter so that there can be four parameters in
  total.
  
  C<Params::Validate> will die if you try to depend on a parameter not
  declared as part of your parameter specification.
  
  =head2 Specifying defaults
  
  If the C<validate()> or C<validate_pos()> functions are called in a list
  context, they will return a hash or containing the original parameters plus
  defaults as indicated by the validation spec.
  
  If the function is not called in a list context, providing a default
  in the validation spec still indicates that the parameter is optional.
  
  The hash or array returned from the function will always be a copy of
  the original parameters, in order to leave C<@_> untouched for the
  calling function.
  
  Simple examples of defaults would be:
  
      my %p = validate( @_, { foo => 1, bar => { default => 99 } } );
  
      my @p = validate_pos( @_, 1, { default => 99 } );
  
  In scalar context, a hash reference or array reference will be
  returned, as appropriate.
  
  =head1 USAGE NOTES
  
  =head2 Validation failure
  
  By default, when validation fails C<Params::Validate> calls
  C<Carp::confess()>. This can be overridden by setting the C<on_fail>
  option, which is described in the L<"GLOBAL" OPTIONS|"GLOBAL" OPTIONS>
  section.
  
  =head2 Method calls
  
  When using this module to validate the parameters passed to a method
  call, you will probably want to remove the class/object from the
  parameter list B<before> calling C<validate()> or C<validate_pos()>.
  If your method expects named parameters, then this is necessary for
  the C<validate()> function to actually work, otherwise C<@_> will not
  be usable as a hash, because it will first have your object (or
  class) B<followed> by a set of keys and values.
  
  Thus the idiomatic usage of C<validate()> in a method call will look
  something like this:
  
      sub method {
          my $self = shift;
  
          my %params = validate(
              @_, {
                  foo => 1,
                  bar => { type => ARRAYREF },
              }
          );
      }
  
  =head2 Speeding Up Validation
  
  In most cases, the validation spec will remain the same for each call to a
  subroutine. In that case, you can speed up validation by defining the
  validation spec just once, rather than on each call to the subroutine:
  
      my %spec = ( ... );
      sub foo {
          my %params = validate( @_, \%spec );
      }
  
  You can also use the C<state> feature to do this:
  
      use feature 'state';
  
      sub foo {
          state $spec = { ... };
          my %params = validate( @_, $spec );
      }
  
  =head1 "GLOBAL" OPTIONS
  
  Because the API for the C<validate()> and C<validate_pos()> functions does not
  make it possible to specify any options other than the validation spec, it is
  possible to set some options as pseudo-'globals'. These allow you to specify
  such things as whether or not the validation of named parameters should be
  case sensitive, for one example.
  
  These options are called pseudo-'globals' because these settings are
  B<only applied to calls originating from the package that set the
  options>.
  
  In other words, if I am in package C<Foo> and I call
  C<validation_options()>, those options are only in effect when I call
  C<validate()> from package C<Foo>.
  
  While this is quite different from how most other modules operate, I
  feel that this is necessary in able to make it possible for one
  module/application to use Params::Validate while still using other
  modules that also use Params::Validate, perhaps with different
  options set.
  
  The downside to this is that if you are writing an app with a standard
  calling style for all functions, and your app has ten modules, B<each
  module must include a call to C<validation_options()>>. You could of
  course write a module that all your modules use which uses various
  trickery to do this when imported.
  
  =head2 Options
  
  =over 4
  
  =item * normalize_keys => $callback
  
  This option is only relevant when dealing with named parameters.
  
  This callback will be used to transform the hash keys of both the
  parameters and the parameter spec when C<validate()> or
  C<validate_with()> are called.
  
  Any alterations made by this callback will be reflected in the
  parameter hash that is returned by the validation function. For
  example:
  
      sub foo {
          return validate_with(
              params => \@_,
              spec   => { foo => { type => SCALAR } },
              normalize_keys =>
                  sub { my $k = shift; $k =~ s/^-//; return uc $k },
          );
  
      }
  
      %p = foo( foo => 20 );
  
      # $p{FOO} is now 20
  
      %p = foo( -fOo => 50 );
  
      # $p{FOO} is now 50
  
  The callback must return a defined value.
  
  If a callback is given then the deprecated "ignore_case" and
  "strip_leading" options are ignored.
  
  =item * allow_extra => $boolean
  
  If true, then the validation routine will allow extra parameters not
  named in the validation specification. In the case of positional
  parameters, this allows an unlimited number of maximum parameters
  (though a minimum may still be set). Defaults to false.
  
  =item * on_fail => $callback
  
  If given, this callback will be called whenever a validation check
  fails. It will be called with a single parameter, which will be a
  string describing the failure. This is useful if you wish to have
  this module throw exceptions as objects rather than as strings, for
  example.
  
  This callback is expected to C<die()> internally. If it does not, the
  validation will proceed onwards, with unpredictable results.
  
  The default is to simply use the Carp module's C<confess()> function.
  
  =item * stack_skip => $number
  
  This tells Params::Validate how many stack frames to skip when finding
  a subroutine name to use in error messages. By default, it looks one
  frame back, at the immediate caller to C<validate()> or
  C<validate_pos()>. If this option is set, then the given number of
  frames are skipped instead.
  
  =item * ignore_case => $boolean
  
  DEPRECATED
  
  This is only relevant when dealing with named parameters. If it is
  true, then the validation code will ignore the case of parameter
  names. Defaults to false.
  
  =item * strip_leading => $characters
  
  DEPRECATED
  
  This too is only relevant when dealing with named parameters. If this
  is given then any parameters starting with these characters will be
  considered equivalent to parameters without them entirely. For
  example, if this is specified as '-', then C<-foo> and C<foo> would be
  considered identical.
  
  =back
  
  =head1 PER-INVOCATION OPTIONS
  
  The C<validate_with()> function can be used to set the options listed
  above on a per-invocation basis. For example:
  
      my %p = validate_with(
          params => \@_,
          spec   => {
              foo => { type    => SCALAR },
              bar => { default => 10 }
          },
          allow_extra => 1,
      );
  
  In addition to the options listed above, it is also possible to set
  the option "called", which should be a string. This string will be
  used in any error messages caused by a failure to meet the validation
  spec.
  
  This subroutine will validate named parameters as a hash if the "spec"
  parameter is a hash reference. If it is an array reference, the
  parameters are assumed to be positional.
  
      my %p = validate_with(
          params => \@_,
          spec   => {
              foo => { type    => SCALAR },
              bar => { default => 10 }
          },
          allow_extra => 1,
          called      => 'The Quux::Baz class constructor',
      );
  
      my @p = validate_with(
          params => \@_,
          spec   => [
              { type    => SCALAR },
              { default => 10 }
          ],
          allow_extra => 1,
          called      => 'The Quux::Baz class constructor',
      );
  
  =head1 DISABLING VALIDATION
  
  If the environment variable C<PERL_NO_VALIDATION> is set to something
  true, then validation is turned off. This may be useful if you only
  want to use this module during development but don't want the speed
  hit during production.
  
  The only error that will be caught will be when an odd number of
  parameters are passed into a function/method that expects a hash.
  
  If you want to selectively turn validation on and off at runtime, you
  can directly set the C<$Params::Validate::NO_VALIDATION> global
  variable. It is B<strongly> recommended that you B<localize> any
  changes to this variable, because other modules you are using may
  expect validation to be on when they execute. For example:
  
      {
          local $Params::Validate::NO_VALIDATION = 1;
  
          # no error
          foo( bar => 2 );
      }
  
      # error
      foo( bar => 2 );
  
      sub foo {
          my %p = validate( @_, { foo => 1 } );
          ...;
      }
  
  But if you want to shoot yourself in the foot and just turn it off, go
  ahead!
  
  =head1 SPECIFYING AN IMPLEMENTATION
  
  This module ships with two equivalent implementations, one in XS and one in
  pure Perl. By default, it will try to load the XS version and fall back to the
  pure Perl implementation as needed. If you want to request a specific version,
  you can set the C<PARAMS_VALIDATE_IMPLEMENTATION> environment variable to
  either C<XS> or C<PP>. If the implementation you ask for cannot be loaded,
  then this module will die when loaded.
  
  =head1 TAINT MODE
  
  The XS implementation of this module has some problems Under taint mode with
  versions of Perl before 5.14. If validation I<fails>, then instead of getting
  the expected error message you'll get a message like "Insecure dependency in
  eval_sv". This can be worked around by either untainting the arguments
  yourself, using the pure Perl implementation, or upgrading your Perl.
  
  =head1 LIMITATIONS
  
  Right now there is no way (short of a callback) to specify that
  something must be of one of a list of classes, or that it must possess
  one of a list of methods. If this is desired, it can be added in the
  future.
  
  Ideally, there would be only one validation function. If someone
  figures out how to do this, please let me know.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<http://rt.cpan.org/Public/Dist/Display.html?Name=Params-Validate> or via email to L<bug-params-validate@rt.cpan.org|mailto:bug-params-validate@rt.cpan.org>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Params-Validate can be found at L<https://github.com/houseabsolute/Params-Validate>.
  
  =head1 DONATIONS
  
  If you'd like to thank me for the work I've done on this module, please
  consider making a "donation" to me via PayPal. I spend a lot of free time
  creating free software, and would appreciate any support you'd care to offer.
  
  Please note that B<I am not suggesting that you must do this> in order for me
  to continue working on this particular software. I will continue to do so,
  inasmuch as I have in the past, for as long as it interests me.
  
  Similarly, a donation made in this way will probably not make me work on this
  software much more, unless I get so many donations that I can consider working
  on free software full time (let's all have a chuckle at that together).
  
  To donate, log into PayPal and send money to autarch@urth.org, or use the
  button at L<http://www.urth.org/~autarch/fs-donation.html>.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Ilya Martynov <ilya@martynov.org>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Andy Grundman E. Choroba Ivan Bessarabov J.R. Mash Karen Etheridge Noel Maddy Olivier Mengu Tony Cook Vincent Pit
  
  =over 4
  
  =item *
  
  Andy Grundman <andyg@activestate.com>
  
  =item *
  
  E. Choroba <choroba@matfyz.cz>
  
  =item *
  
  Ivan Bessarabov <ivan@bessarabov.ru>
  
  =item *
  
  J.R. Mash <jmash.code@gmail.com>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Noel Maddy <zhtwnpanta@gmail.com>
  
  =item *
  
  Olivier Mengu <dolmen@cpan.org>
  
  =item *
  
  Tony Cook <tony@develop-help.com>
  
  =item *
  
  Vincent Pit <perl@profvince.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2001 - 2017 by Dave Rolsky and Ilya Martynov.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
X86_64-LINUX_PARAMS_VALIDATE

$fatpacked{"x86_64-linux/Params/Validate/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PARAMS_VALIDATE_CONSTANTS';
  package Params::Validate::Constants;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.29';
  
  our @ISA = 'Exporter';
  
  our @EXPORT = qw(
      SCALAR
      ARRAYREF
      HASHREF
      CODEREF
      GLOB
      GLOBREF
      SCALARREF
      HANDLE
      BOOLEAN
      UNDEF
      OBJECT
      UNKNOWN
  );
  
  sub SCALAR ()    { 1 }
  sub ARRAYREF ()  { 2 }
  sub HASHREF ()   { 4 }
  sub CODEREF ()   { 8 }
  sub GLOB ()      { 16 }
  sub GLOBREF ()   { 32 }
  sub SCALARREF () { 64 }
  sub UNKNOWN ()   { 128 }
  sub UNDEF ()     { 256 }
  sub OBJECT ()    { 512 }
  
  sub HANDLE ()  { 16 | 32 }
  sub BOOLEAN () { 1 | 256 }
  
  1;
X86_64-LINUX_PARAMS_VALIDATE_CONSTANTS

$fatpacked{"x86_64-linux/Params/Validate/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PARAMS_VALIDATE_PP';
  package Params::Validate::PP;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.29';
  
  use Params::Validate::Constants;
  use Scalar::Util 1.10 ();
  
  our $options;
  
  # Various internals notes (for me and any future readers of this
  # monstrosity):
  #
  # - A lot of the weirdness is _intentional_, because it optimizes for
  #   the _success_ case.  It does not really matter how slow the code is
  #   after it enters a path that leads to reporting failure.  But the
  #   "success" path should be as fast as possible.
  #
  # -- We only calculate $called as needed for this reason, even though it
  #    means copying code all over.
  #
  # - All the validation routines need to be careful never to alter the
  #   references that are passed.
  #
  # -- The code assumes that _most_ callers will not be using the
  #    skip_leading or ignore_case features.  In order to not alter the
  #    references passed in, we copy them wholesale when normalizing them
  #    to make these features work.  This is slower but lets us be faster
  #    when not using them.
  
  # Matt Sergeant came up with this prototype, which slickly takes the
  # first array (which should be the caller's @_), and makes it a
  # reference.  Everything after is the parameters for validation.
  sub validate_pos (\@@) {
      return if $Params::Validate::NO_VALIDATION && !defined wantarray;
  
      my $p = shift;
  
      my @specs = @_;
  
      my @p = @$p;
      if ($Params::Validate::NO_VALIDATION) {
  
          # if the spec is bigger that's where we can start adding
          # defaults
          for ( my $x = $#p + 1; $x <= $#specs; $x++ ) {
              $p[$x] = $specs[$x]->{default}
                  if ref $specs[$x] && exists $specs[$x]->{default};
          }
  
          return wantarray ? @p : \@p;
      }
  
      # I'm too lazy to pass these around all over the place.
      local $options ||= _get_options( ( caller(0) )[0] )
          unless defined $options;
  
      my $min = 0;
  
      while (1) {
          last
              unless (
              ref $specs[$min]
              ? !( exists $specs[$min]->{default} || $specs[$min]->{optional} )
              : $specs[$min]
              );
  
          $min++;
      }
  
      my $max = scalar @specs;
  
      my $actual = scalar @p;
      unless ( $actual >= $min
          && ( $options->{allow_extra} || $actual <= $max ) ) {
          my $minmax = (
              $options->{allow_extra}
              ? "at least $min"
              : ( $min != $max ? "$min - $max" : $max )
          );
  
          my $val = $options->{allow_extra} ? $min : $max;
          $minmax .= $val != 1 ? ' were' : ' was';
  
          my $called = _get_called();
  
          $options->{on_fail}->( "$actual parameter"
                  . ( $actual != 1 ? 's'    : '' ) . " "
                  . ( $actual != 1 ? 'were' : 'was' )
                  . " passed to $called but $minmax expected\n" );
      }
  
      my $bigger = $#p > $#specs ? $#p : $#specs;
      foreach ( 0 .. $bigger ) {
          my $spec = $specs[$_];
  
          next unless ref $spec;
  
          if ( $_ <= $#p ) {
              _validate_one_param(
                  $p[$_], \@p, $spec,
                  'Parameter #' . ( $_ + 1 ) . ' (%s)'
              );
          }
  
          $p[$_] = $spec->{default} if $_ > $#p && exists $spec->{default};
      }
  
      _validate_pos_depends( \@p, \@specs );
  
      foreach (
          grep {
                     defined $p[$_]
                  && !ref $p[$_]
                  && ref $specs[$_]
                  && $specs[$_]{untaint}
          } 0 .. $bigger
          ) {
          ( $p[$_] ) = $p[$_] =~ /(.+)/;
      }
  
      return wantarray ? @p : \@p;
  }
  
  sub _validate_pos_depends {
      my ( $p, $specs ) = @_;
  
      for my $p_idx ( 0 .. $#$p ) {
          my $spec = $specs->[$p_idx];
  
          next
              unless $spec
              && UNIVERSAL::isa( $spec, 'HASH' )
              && exists $spec->{depends};
  
          my $depends = $spec->{depends};
  
          if ( ref $depends ) {
              require Carp;
              local $Carp::CarpLevel = 2;
              Carp::croak(
                  "Arguments to 'depends' for validate_pos() must be a scalar");
          }
  
          my $p_size = scalar @$p;
          if ( $p_size < $depends - 1 ) {
              my $error
                  = (   "Parameter #"
                      . ( $p_idx + 1 )
                      . " depends on parameter #"
                      . $depends
                      . ", which was not given" );
  
              $options->{on_fail}->($error);
          }
      }
      return 1;
  }
  
  sub _validate_named_depends {
      my ( $p, $specs ) = @_;
  
      foreach my $pname ( keys %$p ) {
          my $spec = $specs->{$pname};
  
          next
              unless $spec
              && UNIVERSAL::isa( $spec, 'HASH' )
              && $spec->{depends};
  
          unless ( UNIVERSAL::isa( $spec->{depends}, 'ARRAY' )
              || !ref $spec->{depends} ) {
              require Carp;
              local $Carp::CarpLevel = 2;
              Carp::croak(
                  "Arguments to 'depends' must be a scalar or arrayref");
          }
  
          foreach my $depends_name (
              ref $spec->{depends}
              ? @{ $spec->{depends} }
              : $spec->{depends}
              ) {
              unless ( exists $p->{$depends_name} ) {
                  my $error
                      = (   "Parameter '$pname' depends on parameter '"
                          . $depends_name
                          . "', which was not given" );
  
                  $options->{on_fail}->($error);
              }
          }
      }
  }
  
  sub validate (\@$) {
      return if $Params::Validate::NO_VALIDATION && !defined wantarray;
  
      my $p = $_[0];
  
      my $specs = $_[1];
      local $options = _get_options( ( caller(0) )[0] ) unless defined $options;
  
      if ( ref $p eq 'ARRAY' ) {
  
          # we were called as validate( @_, ... ) where @_ has a
          # single element, a hash reference
          if ( ref $p->[0] ) {
              $p = { %{ $p->[0] } };
          }
          elsif ( @$p % 2 ) {
              my $called = _get_called();
  
              $options->{on_fail}
                  ->(   "Odd number of parameters in call to $called "
                      . "when named parameters were expected\n" );
          }
          else {
              $p = {@$p};
          }
      }
  
      if ( $options->{normalize_keys} ) {
          $specs = _normalize_callback( $specs, $options->{normalize_keys} );
          $p     = _normalize_callback( $p,     $options->{normalize_keys} );
      }
      elsif ( $options->{ignore_case} || $options->{strip_leading} ) {
          $specs = _normalize_named($specs);
          $p     = _normalize_named($p);
      }
  
      if ($Params::Validate::NO_VALIDATION) {
          return (
              wantarray
              ? (
  
                  # this is a hash containing just the defaults
                  (
                      map { $_ => $specs->{$_}->{default} }
                          grep {
                          ref $specs->{$_}
                              && exists $specs->{$_}->{default}
                          }
                          keys %$specs
                  ),
                  (
                      ref $p eq 'ARRAY'
                      ? (
                          ref $p->[0]
                          ? %{ $p->[0] }
                          : @$p
                          )
                      : %$p
                  )
                  )
              : do {
                  my $ref = (
                      ref $p eq 'ARRAY'
                      ? (
                          ref $p->[0]
                          ? $p->[0]
                          : {@$p}
                          )
                      : $p
                  );
  
                  foreach (
                      grep {
                          ref $specs->{$_}
                              && exists $specs->{$_}->{default}
                      }
                      keys %$specs
                      ) {
                      $ref->{$_} = $specs->{$_}->{default}
                          unless exists $ref->{$_};
                  }
  
                  return $ref;
                  }
          );
      }
  
      _validate_named_depends( $p, $specs );
  
      unless ( $options->{allow_extra} ) {
          if ( my @unmentioned = grep { !exists $specs->{$_} } keys %$p ) {
              my $called = _get_called();
  
              $options->{on_fail}->( "The following parameter"
                      . ( @unmentioned > 1 ? 's were' : ' was' )
                      . " passed in the call to $called but "
                      . ( @unmentioned > 1 ? 'were' : 'was' )
                      . " not listed in the validation options: @unmentioned\n"
              );
          }
      }
  
      my @missing;
  
      # the iterator needs to be reset in case the same hashref is being
      # passed to validate() on successive calls, because we may not go
      # through all the hash's elements
      keys %$specs;
  OUTER:
      while ( my ( $key, $spec ) = each %$specs ) {
          if (
              !exists $p->{$key}
              && (
                  ref $spec
                  ? !(
                      do {
  
                          # we want to short circuit the loop here if we
                          # can assign a default, because there's no need
                          # check anything else at all.
                          if ( exists $spec->{default} ) {
                              $p->{$key} = $spec->{default};
                              next OUTER;
                          }
                      }
                      || do {
  
                          # Similarly, an optional parameter that is
                          # missing needs no additional processing.
                          next OUTER if $spec->{optional};
                      }
                  )
                  : $spec
              )
              ) {
              push @missing, $key;
          }
  
          # Can't validate a non hashref spec beyond the presence or
          # absence of the parameter.
          elsif ( ref $spec ) {
              my $value = defined $p->{$key} ? qq|"$p->{$key}"| : 'undef';
              _validate_one_param(
                  $p->{$key}, $p, $spec,
                  qq{The '$key' parameter (%s)}
              );
          }
      }
  
      if (@missing) {
          my $called = _get_called();
  
          my $missing = join ', ', map {"'$_'"} sort @missing;
          $options->{on_fail}->( "Mandatory parameter"
                  . ( @missing > 1 ? 's' : '' )
                  . " $missing missing in call to $called\n" );
      }
  
      # do untainting after we know everything passed
      foreach my $key (
          grep {
                     defined $p->{$_}
                  && !ref $p->{$_}
                  && ref $specs->{$_}
                  && $specs->{$_}{untaint}
          }
          keys %$p
          ) {
          ( $p->{$key} ) = $p->{$key} =~ /(.+)/;
      }
  
      return wantarray ? %$p : $p;
  }
  
  sub validate_with {
      return if $Params::Validate::NO_VALIDATION && !defined wantarray;
  
      my %p = @_;
  
      local $options = _get_options( ( caller(0) )[0], %p );
  
      unless ($Params::Validate::NO_VALIDATION) {
          unless ( exists $options->{called} ) {
              $options->{called} = ( caller( $options->{stack_skip} ) )[3];
          }
  
      }
  
      if ( UNIVERSAL::isa( $p{spec}, 'ARRAY' ) ) {
          return validate_pos( @{ $p{params} }, @{ $p{spec} } );
      }
      else {
  
          # intentionally ignore the prototype because this contains
          # either an array or hash reference, and validate() will
          # handle either one properly
          return &validate( $p{params}, $p{spec} );
      }
  }
  
  sub _normalize_callback {
      my ( $p, $func ) = @_;
  
      my %new;
  
      foreach my $key ( keys %$p ) {
          my $new_key = $func->($key);
  
          unless ( defined $new_key ) {
              die
                  "The normalize_keys callback did not return a defined value when normalizing the key '$key'";
          }
  
          if ( exists $new{$new_key} ) {
              die
                  "The normalize_keys callback returned a key that already exists, '$new_key', when normalizing the key '$key'";
          }
  
          $new{$new_key} = $p->{$key};
      }
  
      return \%new;
  }
  
  sub _normalize_named {
  
      # intentional copy so we don't destroy original
      my %h = ( ref $_[0] ) =~ /ARRAY/ ? @{ $_[0] } : %{ $_[0] };
  
      if ( $options->{ignore_case} ) {
          $h{ lc $_ } = delete $h{$_} for keys %h;
      }
  
      if ( $options->{strip_leading} ) {
          foreach my $key ( keys %h ) {
              my $new;
              ( $new = $key ) =~ s/^\Q$options->{strip_leading}\E//;
              $h{$new} = delete $h{$key};
          }
      }
  
      return \%h;
  }
  
  my %Valid = map { $_ => 1 }
      qw( callbacks can default depends isa optional regex type untaint  );
  
  sub _validate_one_param {
      my ( $value, $params, $spec, $id ) = @_;
  
      # for my $key ( keys %{$spec} ) {
      #     unless ( $Valid{$key} ) {
      #         $options->{on_fail}
      #             ->(qq{"$key" is not an allowed validation spec key});
      #     }
      # }
  
      if ( exists $spec->{type} ) {
          unless ( defined $spec->{type}
              && Scalar::Util::looks_like_number( $spec->{type} )
              && $spec->{type} > 0 ) {
              my $msg
                  = "$id has a type specification which is not a number. It is ";
              if ( defined $spec->{type} ) {
                  $msg .= "a string - $spec->{type}";
              }
              else {
                  $msg .= "undef";
              }
  
              $msg
                  .= ".\n Use the constants exported by Params::Validate to declare types.";
  
              $options->{on_fail}->( sprintf( $msg, _stringify($value) ) );
          }
  
          unless ( _get_type($value) & $spec->{type} ) {
              my $type = _get_type($value);
  
              my @is      = _typemask_to_strings($type);
              my @allowed = _typemask_to_strings( $spec->{type} );
              my $article = $is[0] =~ /^[aeiou]/i ? 'an' : 'a';
  
              my $called = _get_called(1);
  
              $options->{on_fail}->(
                  sprintf(
                      "$id to $called was $article '@is', which "
                          . "is not one of the allowed types: @allowed\n",
                      _stringify($value)
                  )
              );
          }
      }
  
      # short-circuit for common case
      return
          unless ( $spec->{isa}
          || $spec->{can}
          || $spec->{callbacks}
          || $spec->{regex} );
  
      if ( exists $spec->{isa} ) {
          foreach ( ref $spec->{isa} ? @{ $spec->{isa} } : $spec->{isa} ) {
              unless (
                  do {
                      local $@ = q{};
                      eval { $value->isa($_) };
                  }
                  ) {
                  my $is = ref $value ? ref $value : 'plain scalar';
                  my $article1 = $_ =~ /^[aeiou]/i  ? 'an' : 'a';
                  my $article2 = $is =~ /^[aeiou]/i ? 'an' : 'a';
  
                  my $called = _get_called(1);
  
                  $options->{on_fail}->(
                      sprintf(
                                "$id to $called was not $article1 '$_' "
                              . "(it is $article2 $is)\n", _stringify($value)
                      )
                  );
              }
          }
      }
  
      if ( exists $spec->{can} ) {
          foreach ( ref $spec->{can} ? @{ $spec->{can} } : $spec->{can} ) {
              unless (
                  do {
                      local $@ = q{};
                      eval { $value->can($_) };
                  }
                  ) {
                  my $called = _get_called(1);
  
                  $options->{on_fail}->(
                      sprintf(
                          "$id to $called does not have the method: '$_'\n",
                          _stringify($value)
                      )
                  );
              }
          }
      }
  
      if ( $spec->{callbacks} ) {
          unless ( UNIVERSAL::isa( $spec->{callbacks}, 'HASH' ) ) {
              my $called = _get_called(1);
  
              $options->{on_fail}->(
                  "'callbacks' validation parameter for $called must be a hash reference\n"
              );
          }
  
          foreach ( keys %{ $spec->{callbacks} } ) {
              unless ( UNIVERSAL::isa( $spec->{callbacks}{$_}, 'CODE' ) ) {
                  my $called = _get_called(1);
  
                  $options->{on_fail}->(
                      "callback '$_' for $called is not a subroutine reference\n"
                  );
              }
  
              my $ok;
              my $e = do {
                  local $@ = q{};
                  local $SIG{__DIE__};
                  $ok = eval { $spec->{callbacks}{$_}->( $value, $params ) };
                  $@;
              };
  
              if ( !$ok ) {
                  my $called = _get_called(1);
  
                  if ( ref $e ) {
                      $options->{on_fail}->($e);
                  }
                  else {
                      my $msg = "$id to $called did not pass the '$_' callback";
                      $msg .= ": $e" if length $e;
                      $msg .= "\n";
                      $options->{on_fail}->( sprintf( $msg, _stringify($value) ) );
                  }
              }
          }
      }
  
      if ( exists $spec->{regex} ) {
          unless ( ( defined $value ? $value : '' ) =~ /$spec->{regex}/ ) {
              my $called = _get_called(1);
  
              $options->{on_fail}->(
                  sprintf(
                      "$id to $called did not pass regex check\n",
                      _stringify($value)
                  )
              );
          }
      }
  }
  
  {
      # if it UNIVERSAL::isa the string on the left then its the type on
      # the right
      my %isas = (
          'ARRAY'  => ARRAYREF,
          'HASH'   => HASHREF,
          'CODE'   => CODEREF,
          'GLOB'   => GLOBREF,
          'SCALAR' => SCALARREF,
          'REGEXP' => SCALARREF,
      );
      my %simple_refs = map { $_ => 1 } keys %isas;
  
      sub _get_type {
          return UNDEF unless defined $_[0];
  
          my $ref = ref $_[0];
          unless ($ref) {
  
              # catches things like:  my $fh = do { local *FH; };
              return GLOB if UNIVERSAL::isa( \$_[0], 'GLOB' );
              return SCALAR;
          }
  
          return $isas{$ref} if $simple_refs{$ref};
  
          foreach ( keys %isas ) {
              return $isas{$_} | OBJECT if UNIVERSAL::isa( $_[0], $_ );
          }
  
          # I really hope this never happens.
          return UNKNOWN;
      }
  }
  
  {
      my %type_to_string = (
          SCALAR()    => 'scalar',
          ARRAYREF()  => 'arrayref',
          HASHREF()   => 'hashref',
          CODEREF()   => 'coderef',
          GLOB()      => 'glob',
          GLOBREF()   => 'globref',
          SCALARREF() => 'scalarref',
          UNDEF()     => 'undef',
          OBJECT()    => 'object',
          UNKNOWN()   => 'unknown',
      );
  
      sub _typemask_to_strings {
          my $mask = shift;
  
          my @types;
          foreach (
              SCALAR,    ARRAYREF, HASHREF, CODEREF, GLOB, GLOBREF,
              SCALARREF, UNDEF,    OBJECT,  UNKNOWN
              ) {
              push @types, $type_to_string{$_} if $mask & $_;
          }
          return @types ? @types : ('unknown');
      }
  }
  
  {
      my %defaults = (
          ignore_case   => 0,
          strip_leading => 0,
          allow_extra   => 0,
          on_fail       => sub {
              require Carp;
              Carp::croak( $_[0] );
          },
          stack_skip     => 1,
          normalize_keys => undef,
      );
  
      *set_options = \&validation_options;
  
      sub validation_options {
          my %opts = @_;
  
          my $caller = caller;
  
          foreach ( keys %defaults ) {
              $opts{$_} = $defaults{$_} unless exists $opts{$_};
          }
  
          $Params::Validate::OPTIONS{$caller} = \%opts;
      }
  
      sub _get_options {
          my $caller = shift;
  
          if (@_) {
  
              return (
                  $Params::Validate::OPTIONS{$caller}
                  ? {
                      %{ $Params::Validate::OPTIONS{$caller} },
                      @_
                      }
                  : { %defaults, @_ }
              );
          }
          else {
              return (
                  exists $Params::Validate::OPTIONS{$caller}
                  ? $Params::Validate::OPTIONS{$caller}
                  : \%defaults
              );
          }
      }
  }
  
  sub _get_called {
      my $extra_skip = $_[0] || 0;
  
      # always add one more for this sub
      $extra_skip++;
  
      my $called = (
          exists $options->{called}
          ? $options->{called}
          : ( caller( $options->{stack_skip} + $extra_skip ) )[3]
      );
  
      $called = '(unknown)' unless defined $called;
  
      return $called;
  }
  
  sub _stringify {
      return defined $_[0] ? qq{"$_[0]"} : 'undef';
  }
  
  1;
X86_64-LINUX_PARAMS_VALIDATE_PP

$fatpacked{"x86_64-linux/Params/Validate/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PARAMS_VALIDATE_XS';
  package Params::Validate::XS;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.29';
  
  use Carp;
  
  my $default_fail = sub {
      Carp::confess( $_[0] );
  };
  
  {
      my %defaults = (
          ignore_case    => 0,
          strip_leading  => 0,
          allow_extra    => 0,
          on_fail        => $default_fail,
          stack_skip     => 1,
          normalize_keys => undef,
      );
  
      *set_options = \&validation_options;
  
      sub validation_options {
          my %opts = @_;
  
          my $caller = caller;
  
          foreach ( keys %defaults ) {
              $opts{$_} = $defaults{$_} unless exists $opts{$_};
          }
  
          $Params::Validate::OPTIONS{$caller} = \%opts;
      }
  
      use XSLoader;
      XSLoader::load(
          __PACKAGE__,
          exists $Params::Validate::XS::{VERSION}
          ? ${ $Params::Validate::XS::{VERSION} }
          : (),
      );
  }
  
  sub _check_regex_from_xs {
      return ( defined $_[0] ? $_[0] : '' ) =~ /$_[1]/ ? 1 : 0;
  }
  
  1;
X86_64-LINUX_PARAMS_VALIDATE_XS

$fatpacked{"x86_64-linux/Params/ValidatePP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PARAMS_VALIDATEPP';
  package    # hide from PAUSE
      Params::Validate;
  
  our $VERSION = '1.29';
  
  BEGIN { $ENV{PARAMS_VALIDATE_IMPLEMENTATION} = 'PP' }
  use Params::Validate;
  
  1;
X86_64-LINUX_PARAMS_VALIDATEPP

$fatpacked{"x86_64-linux/Params/ValidateXS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PARAMS_VALIDATEXS';
  package # hide from PAUSE
      Params::Validate;
  
  our $VERSION = '1.29';
  
  BEGIN { $ENV{PARAMS_VALIDATE_IMPLEMENTATION} = 'XS' }
  use Params::Validate;
  
  1;
X86_64-LINUX_PARAMS_VALIDATEXS

$fatpacked{"x86_64-linux/Want.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_WANT';
  package Want;
  
  require 5.006;
  use Carp 'croak';
  use strict;
  use warnings;
  
  require Exporter;
  require DynaLoader;
  
  our @ISA = qw(Exporter DynaLoader);
  
  our @EXPORT = qw(want rreturn lnoreturn);
  our @EXPORT_OK = qw(howmany wantref);
  our $VERSION = '0.29';
  
  bootstrap Want $VERSION;
  
  my %reftype = (
      ARRAY  => 1,
      HASH   => 1,
      CODE   => 1,
      GLOB   => 1,
      OBJECT => 1,
  );
  
  sub _wantone {
      my ($uplevel, $arg) = @_;
      
      my $wantref = wantref($uplevel + 1);
      if	  ($arg =~ /^\d+$/) {
  	my $want_count = want_count($uplevel);
  	return ($want_count == -1 || $want_count >= $arg);
      }
      elsif (lc($arg) eq 'infinity') {
  	return (want_count($uplevel) == -1);
      }
      elsif ($arg eq 'REF') {
  	return $wantref;
      }
      elsif ($reftype{$arg}) {
  	return ($wantref eq $arg);
      }
      elsif ($arg eq 'REFSCALAR') {
  	return ($wantref eq 'SCALAR');
      }
      elsif ($arg eq 'LVALUE') {
  	return want_lvalue($uplevel);
      }
      elsif ($arg eq 'RVALUE') {
  	return !want_lvalue($uplevel);
      }
      elsif ($arg eq 'VOID') {
  	return !defined(wantarray_up($uplevel));
      }
      elsif ($arg eq 'SCALAR') {
  	my $gimme = wantarray_up($uplevel);
  	return (defined($gimme) && 0 == $gimme);
      }
      elsif ($arg eq 'BOOL' || $arg eq 'BOOLEAN') {
  	return want_boolean(bump_level($uplevel));
      }
      elsif ($arg eq 'LIST') {
  	return wantarray_up($uplevel);
      }
      elsif ($arg eq 'COUNT') {
  	croak("want: COUNT must be the *only* parameter");
      }
      elsif ($arg eq 'ASSIGN') {
  	return !!wantassign($uplevel + 1);
      }
      else {
  	croak ("want: Unrecognised specifier $arg");
      }    
  }
  
  sub want {
      if (@_ == 1 && $_[0] eq 'ASSIGN') {
  	@_ = (1);
  	goto &wantassign;
      }
      want_uplevel(1, @_);
  }
  
  # Simulate the propagation of context through a return value.
  sub bump_level {
      my ($level) = @_;
      for(;;) {
  	my ($p, $r) = parent_op_name($level+1);
  	if ($p eq "return"
          or  $p eq "(none)" && $r =~ /^leavesub(lv)?$/)
  	{
  	    ++$level
  	}
  	else {
  	    return $level
  	}
      }
  }
  
  sub want_uplevel {
      my ($level, @args) = @_;
  
      # Deal with special cases (for RFC21-consistency):
      if (1 == @args) {
  	@_ = (1 + $level);
  	goto &wantref    if $args[0] eq 'REF';
  	goto &howmany    if $args[0] eq 'COUNT';
  	goto &wantassign if $args[0] eq 'ASSIGN';
      }
  
      for my $arg (map split, @args) {
  	if ($arg =~ /^!(.*)/) {
  	    return 0 unless !_wantone(2 + $level, $1);
  	}
  	else {
  	    return 0 unless _wantone(2 + $level, $arg);
  	}
      }
      
      return 1;
  }
  
  sub howmany () {
      my $level = bump_level(@_, 1);
      my $count = want_count($level);
      return ($count < 0 ? undef : $count);
  }
  
  sub wantref {
      my $level = bump_level(@_, 1);
      my $n = parent_op_name($level);
      if    ($n eq 'rv2av') {
  	return "ARRAY";
      }
      elsif ($n eq 'rv2hv') {
  	return "HASH";
      }
      elsif ($n eq 'rv2cv' || $n eq 'entersub') {
  	return "CODE";
      }
      elsif ($n eq 'rv2gv' || $n eq 'gelem') {
  	return "GLOB";
      }
      elsif ($n eq 'rv2sv') {
  	return "SCALAR";
      }
      elsif ($n eq 'method_call') {
  	return 'OBJECT';
      }
      elsif ($n eq 'multideref') {
  	return first_multideref_type($level);
      }
      else {
  	return "";
      }
  }
  
  sub wantassign {
      my $uplevel = shift();
      return unless want_lvalue($uplevel);
      my $r = want_assign(bump_level($uplevel));
      if (want('BOOL')) {
  	return (defined($r) && 0 != $r);
      }
      else {
  	return $r ? (want('SCALAR') ? $r->[$#$r] : @$r) : ();
      }
  }
  
  sub double_return :lvalue;
  
  sub rreturn (@) {
      if (want_lvalue(1)) {
          croak "Can't rreturn in lvalue context";
      }
  
      # Extra scope needed to work with perl-5.19.7 or greater.
      # Prevents the return being optimised out, which is needed
      # since it's actually going to be used a stack level above
      # this sub.
      {
          return double_return(@_);
      }
  }
  
  sub lnoreturn () : lvalue {
      if (!want_lvalue(1) || !want_assign(1)) {
          croak "Can't lnoreturn except in ASSIGN context";
      }
  
      # Extra scope needed to work with perl-5.19.7 or greater.
      # Prevents the return being optimised out, which is needed
      # since it's actually going to be used a stack level above
      # this sub.
      #
      # But in older versions of perl, adding the extra scope
      # causes the error:
      #   Can't modify loop exit in lvalue subroutine return
      # so we have to check the version.
      if ($] >= 5.019) {
          return double_return(disarm_temp(my $undef));
      }
      return double_return(disarm_temp(my $undef));
  }
  
  # Some naughty people were relying on these internal methods.
  *_wantref = \&wantref;
  *_wantassign = \&wantassign;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Want - A generalisation of C<wantarray>
  
  =head1 SYNOPSIS
  
    use Want;
    sub foo :lvalue {
        if    (want(qw'LVALUE ASSIGN')) {
          print "We have been assigned ", want('ASSIGN');
          lnoreturn;
        }
        elsif (want('LIST')) {
          rreturn (1, 2, 3);
        }
        elsif (want('BOOL')) {
          rreturn 0;
        }
        elsif (want(qw'SCALAR !REF')) {
          rreturn 23;
        }
        elsif (want('HASH')) {
          rreturn { foo => 17, bar => 23 };
        }
        return;  # You have to put this at the end to keep the compiler happy
    }
  
  =head1 DESCRIPTION
  
  This module generalises the mechanism of the B<wantarray> function,
  allowing a function to determine in some detail how its return value
  is going to be immediately used.
  
  =head2 Top-level contexts:
  
  The three kinds of top-level context are well known:
  
  =over 4
  
  =item B<VOID>
  
  The return value is not being used in any way. It could be an entire statement
  like C<foo();>, or the last component of a compound statement which is itself in
  void context, such as C<$test || foo();>n. Be warned that the last statement
  of a subroutine will be in whatever context the subroutine was called in, because
  the result is implicitly returned.
  
  =item B<SCALAR>
  
  The return value is being treated as a scalar value of some sort:
  
    my $x = foo();
    $y += foo();
    print "123" x foo();
    print scalar foo();
    warn foo()->{23};
    ...etc...
  
  =item B<LIST>
  
  The return value is treated as a list of values:
  
    my @x = foo();
    my ($x) = foo();
    () = foo();		# even though the results are discarded
    print foo();
    bar(foo());		# unless the bar subroutine has a prototype
    print @hash{foo()};	# (hash slice)
    ...etc...
  
  =back
  
  =head2 Lvalue subroutines:
  
  The introduction of B<lvalue subroutines> in Perl 5.6 has created a new type
  of contextual information, which is independent of those listed above. When
  an lvalue subroutine is called, it can either be called in the ordinary way
  (so that its result is treated as an ordinary value, an B<rvalue>); or else
  it can be called so that its result is considered updatable, an B<lvalue>.
  
  These rather arcane terms (lvalue and rvalue) are easier to remember if you
  know why they are so called. If you consider a simple assignment statement
  C<left = right>, then the B<l>eft-hand side is an B<l>value and the B<r>ight-hand
  side is an B<r>value.
  
  So (for lvalue subroutines only) there are two new types of context:
  
  =over 4
  
  =item B<RVALUE>
  
  The caller is definitely not trying to assign to the result:
  
    foo();
    my $x = foo();
    ...etc...
  
  If the sub is declared without the C<:lvalue> attribute, then it will
  I<always> be in RVALUE context.
  
  If you need to return values from an lvalue subroutine in RVALUE context,
  you should use the C<rreturn> function rather than an ordinary C<return>.
  Otherwise you'll probably get a compile-time error in perl 5.6.1 and later.
  
  =item B<LVALUE>
  
  Either the caller is directly assigning to the result of the sub call:
  
    foo() = $x;
    foo() = (1, 1, 2, 3, 5, 8);
  
  or the caller is making a reference to the result, which might be assigned to
  later:
  
    my $ref = \(foo());	# Could now have: $$ref = 99;
    
    # Note that this example imposes LIST context on the sub call.
    # So we're taking a reference to the first element to be
    # returned _in list context_.
    # If we want to call the function in scalar context, we can
    # do it like this:
    my $ref = \(scalar foo());
  
  or else the result of the function call is being used as part of the argument list
  for I<another> function call:
  
    bar(foo());	# Will *always* call foo in lvalue context,
    		# (provided that foo is an C<:lvalue> sub)
    		# regardless of what bar actually does.
  
  The reason for this last case is that bar might be a sub which modifies its
  arguments. They're rare in contemporary Perl code, but perfectly possible:
  
    sub bar {
      $_[0] = 23;
    }
  
  (This is really a throwback to Perl 4, which didn't support explicit references.)
  
  =back
  
  =head2 Assignment context:
  
  The commonest use of lvalue subroutines is with the assignment statement:
  
    size() = 12;
    (list()) = (1..10);
  
  A useful motto to remember when thinking about assignment statements is
  I<context comes from the left>. Consider code like this:
  
    my ($x, $y, $z);
    sub list () :lvalue { ($x, $y, $z) }
    list = (1, 2, 3);
    print "\$x = $x; \$y = $y; \$z = $z\n";
  
  This prints C<$x = ; $y = ; $z = 3>, which may not be what you were expecting.
  The reason is that the assignment is in scalar context, so the comma operator
  is in scalar context too, and discards all values but the last. You can fix
  it by writing C<(list) = (1,2,3);> instead.
  
  If your lvalue subroutine is used on the left of an assignment statement,
  it's in B<ASSIGN> context.  If ASSIGN is the only argument to C<want()>, then
  it returns a reference to an array of the value(s) of the right-hand side.
  
  In this case, you should return with the C<lnoreturn> function, rather than
  an ordinary C<return>. 
  
  This makes it very easy to write lvalue subroutines which do clever things:
  
    use Want;
    use strict;
    sub backstr :lvalue {
      if (want(qw'LVALUE ASSIGN')) {
        my ($a) = want('ASSIGN');
        $_[0] = reverse $a;
        lnoreturn;
      }
      elsif (want('RVALUE')) {
        rreturn scalar reverse $_[0];
      }
      else {
        carp("Not in ASSIGN context");
      }
      return
    }
   
    print "foo -> ", backstr("foo"), "\n";	# foo -> oof
    backstr(my $robin) = "nibor";
    print "\$robin is now $robin\n";		# $robin is now robin
  
  Notice that you need to put a (meaningless) return
  statement at the end of the function, otherwise you will get the
  error
  I<Can't modify non-lvalue subroutine call in lvalue subroutine return>.
  
  The only way to write that C<backstr> function without using Want is to return
  a tied variable which is tied to a custom class.
  
  =head2 Reference context:
  
  Sometimes in scalar context the caller is expecting a reference of some sort
  to be returned:
  
      print foo()->();     # CODE reference expected
      print foo()->{bar};  # HASH reference expected
      print foo()->[23];   # ARRAY reference expected
      print ${foo()};	 # SCALAR reference expected
      print foo()->bar();	 # OBJECT reference expected
      
      my $format = *{foo()}{FORMAT} # GLOB reference expected
  
  You can check this using conditionals like C<if (want('CODE'))>.
  There is also a function C<wantref()> which returns one of the strings
  "CODE", "HASH", "ARRAY", "GLOB", "SCALAR" or "OBJECT"; or the empty string
  if a reference is not expected.
  
  Because C<want('SCALAR')> is already used to select ordinary scalar context,
  you have to use C<want('REFSCALAR')> to find out if a SCALAR reference is
  expected. Or you could use C<want('REF') eq 'SCALAR'> of course.
  
  Be warned that C<want('ARRAY')> is a B<very> different thing from C<wantarray()>.
  
  =head2 Item count
  
  Sometimes in list context the caller is expecting a particular number of items
  to be returned:
  
      my ($x, $y) = foo();   # foo is expected to return two items
  
  If you pass a number to the C<want> function, then it will return true or false
  according to whether at least that many items are wanted. So if we are in the
  definition of a sub which is being called as above, then:
  
      want(1) returns true
      want(2) returns true
      want(3) returns false
  
  Sometimes there is no limit to the number of items that might be used:
  
      my @x = foo();
      do_something_with( foo() );
  
  In this case, C<want(2)>, C<want(100)>, C<want(1E9)> and so on will all return
  true; and so will C<want('Infinity')>.
  
  The C<howmany> function can be used to find out how many items are wanted.
  If the context is scalar, then C<want(1)> returns true and C<howmany()> returns
  1. If you want to check whether your result is being assigned to a singleton
  list, you can say C<if (want('LIST', 1)) { ... }>.
  
  
  =head2 Boolean context
  
  Sometimes the caller is only interested in the truth or falsity of a function's
  return value:
  
      if (everything_is_okay()) {
  	# Carry on
      }
      
      print (foo() ? "ok\n" : "not ok\n");
      
  In the following example, all subroutine calls are in BOOL context:
  
      my $x = ( (foo() && !bar()) xor (baz() || quux()) );
  
  Boolean context, like the reference contexts above, is considered to be a subcontext
  of SCALAR.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item want(SPECIFIERS)
  
  This is the primary interface to this module, and should suffice for most
  purposes. You pass it a list of context specifiers, and the return value
  is true whenever all of the specifiers hold.
  
      want('LVALUE', 'SCALAR');   # Are we in scalar lvalue context?
      want('RVALUE', 3);		# Are at least three rvalues wanted?
      want('ARRAY');	# Is the return value used as an array ref?
  
  You can also prefix a specifier with an exclamation mark to indicate that you
  B<don't> want it to be true
  
      want(2, '!3');		# Caller wants exactly two items.
      want(qw'REF !CODE !GLOB');  # Expecting a reference that
      				#   isn't a CODE or GLOB ref.
      want(100, '!Infinity');	# Expecting at least 100 items,
      				#   but there is a limit.
  
  If the I<REF> keyword is the only parameter passed, then the type of reference will be
  returned.  This is just a synonym for the C<wantref> function: it's included because
  you might find it useful if you don't want to pollute your namespace by importing
  several functions, and to conform to Damian Conway's suggestion in RFC 21.
  
  Finally, the keyword I<COUNT> can be used, provided that it's the only keyword
  you pass. Mixing COUNT with other keywords is an error. This is a synonym for the
  C<howmany> function.
  
  A full list of the permitted keyword is in the B<ARGUMENTS> section below.
  
  =item rreturn
  
  Use this function instead of C<return> from inside an lvalue subroutine when
  you know that you're in RVALUE context. If you try to use a normal C<return>,
  you'll get a compile-time error in Perl 5.6.1 and above unless you return an
  lvalue. (Note: this is no longer true in Perl 5.16, where an ordinary return
  will once again work.)
  
  =item lnoreturn
  
  Use this function instead of C<return> from inside an lvalue subroutine when
  you're in ASSIGN context and you've used C<want('ASSIGN')> to carry out the
  appropriate action.
  
  If you use C<rreturn> or C<lnoreturn>, then you have to put a bare C<return;>
  at the very end of your lvalue subroutine, in order to stop the Perl compiler
  from complaining. Think of it as akin to the C<1;> that you have to put at the
  end of a module. (Note: this is no longer true in Perl 5.16.)
  
  =item howmany()
  
  Returns the I<expectation count>, i.e. the number of items expected. If the 
  expectation count is undefined, that
  indicates that an unlimited number of items might be used (e.g. the return
  value is being assigned to an array). In void context the expectation count
  is zero, and in scalar context it is one.
  
  The same as C<want('COUNT')>.
  
  =item wantref()
  
  Returns the type of reference which the caller is expecting, or the empty string
  if the caller isn't expecting a reference immediately.
  
  The same as C<want('REF')>.
  
  =back
  
  =head1 EXAMPLES
  
      use Carp 'croak';
      use Want 'howmany';
      sub numbers {
  	my $count = howmany();
  	croak("Can't make an infinite list") if !defined($count);
  	return (1..$count);
      }
      my ($one, $two, $three) = numbers();
      
      
      use Want 'want';
      sub pi () {
  	if    (want('ARRAY')) {
  	    return [3, 1, 4, 1, 5, 9];
  	}
  	elsif (want('LIST')) {
  	    return (3, 1, 4, 1, 5, 9);
  	}
  	else {
  	    return 3;
  	}
      }
      print pi->[2];	# prints 4
      print ((pi)[3]);	# prints 1
  
  =head1 ARGUMENTS
  
  The permitted arguments to the C<want> function are listed below.
  The list is structured so that sub-contexts appear below the context that they
  are part of.
  
  =over 4
  
  =item *
  
  VOID
  
  =item *
  
  SCALAR
  
  =over 4
  
  =item *
  
  REF
  
  =over 4
  
  =item *
  
  REFSCALAR
  
  =item *
  
  CODE
  
  =item *
  
  HASH
  
  =item *
  
  ARRAY
  
  =item *
  
  GLOB
  
  =item *
  
  OBJECT
  
  =back
  
  =item *
  
  BOOL
  
  =back
  
  =item *
  
  LIST
  
  =over 4
  
  =item *
  
  COUNT
  
  =item *
  
  E<lt>numberE<gt>
  
  =item *
  
  Infinity
  
  =back
  
  =item *
  
  LVALUE
  
  =over 4
  
  =item *
  
  ASSIGN
  
  =back
  
  =item *
  
  RVALUE
  
  =back
  
  =head1 EXPORT
  
  The C<want> and C<rreturn> functions are exported by default.
  The C<wantref> and/or C<howmany> functions can also be imported:
  
    use Want qw'want howmany';
  
  If you don't import these functions, you must qualify their names as (e.g.)
  C<Want::wantref>.
  
  =head1 INTERFACE
  
  This module is still under development, and the public interface may change in
  future versions. The C<want> function can now be regarded as stable.
  
  I'd be interested to know how you're using this module.
  
  =head1 SUBTLETIES
  
  There are two different levels of B<BOOL> context. I<Pure> boolean context
  occurs in conditional expressions, and the operands of the C<xor> and C<!>/C<not>
  operators.
  Pure boolean context also propagates down through the C<&&> and C<||> operators.
  
  However, consider an expression like C<my $x = foo() && "yes">. The subroutine
  is called in I<pseudo>-boolean context - its return value isn't B<entirely>
  ignored, because the undefined value, the empty string and the integer 0 are
  all false.
  
  At the moment C<want('BOOL')> is true in either pure or pseudo boolean
  context. Let me know if this is a problem.
  
  =head1 BUGS
  
   * Doesn't work from inside a tie-handler.
  
  =head1 AUTHOR
  
  Robin Houston, E<lt>robin@cpan.orgE<gt>
  
  Thanks to Damian Conway for encouragement and good suggestions,
  and Father Chrysostomos for a patch.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<perlfunc/wantarray>
  
  =item *
  
  Perl6 RFC 21, by Damian Conway.
  http://dev.perl.org/rfc/21.html
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2001-2012, Robin Houston. All Rights Reserved.
  This module is free software. It may be used, redistributed
  and/or modified under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_WANT

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/usr/bin/env perl
    
use strict; 
use warnings;
    
use Getopt::Long::Descriptive;
use IO::Prompter;
    
our $VERSION = '0.003'; # VERSION
# PODNAME: git-ribbon

my ($option, $usage) = describe_options(
    'usage: git ribbon %o',
    ['save|s'       => 'Save your place at origin/branch'],
    ['help|h'       => 'Show this message'],
);  
    
die($usage) if $option->help;

$option->save 
    ? save($usage) 
    : ribbon($usage);



sub save { print `git tag --force _ribbon origin/master` }

sub ribbon {
    my $option = shift;

    my @logs = `git log --pretty=format:'git difftool -r %p -r %h --no-prompt %n%C(bold white)%an %cr %h%n%s%Creset' --stat --no-merges --reverse --topo-order _ribbon..origin/master`;

    my $i = 0;
    while ($i < $#logs) {
        my $cmd = $logs[$i];
        $i++;

        while ($logs[$i] !~ /^git difftool -r /) {
            print $logs[$i];
            $i++;
            last if $i >= $#logs;
        }

        my $answer = prompt "press 's' to skip", -echo => "", -single;

        unless ($answer eq 's') {
            my $pid = fork();
            if (!$pid) { # child
                exec($cmd);
            }
            waitpid $pid, 0;
        }
        
        print "\n";
    }
}

END { print "\n" unless $option->save }

__END__

=pod

=encoding utf-8

=head1 NAME

git-ribbon

=head1 AUTHOR

Eric Johnson <cpan at iijo dot nospamthanks dot org>

=head1 COPYRIGHT AND LICENSE

This software is Copyright (c) 2013 by Eric Johnson.

This is free software, licensed under:

  The Apache License, Version 2.0, January 2004

=cut
