#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/Prove.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROVE';
  package App::Prove;
  
  use strict;
  use warnings;
  
  use TAP::Harness::Env;
  use Text::ParseWords qw(shellwords);
  use File::Spec;
  use Getopt::Long;
  use App::Prove::State;
  use Carp;
  
  use base 'TAP::Object';
  
  =head1 NAME
  
  App::Prove - Implements the C<prove> command.
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 DESCRIPTION
  
  L<Test::Harness> provides a command, C<prove>, which runs a TAP based
  test suite and prints a report. The C<prove> command is a minimal
  wrapper around an instance of this module.
  
  =head1 SYNOPSIS
  
      use App::Prove;
  
      my $app = App::Prove->new;
      $app->process_args(@ARGV);
      $app->run;
  
  =cut
  
  use constant IS_WIN32 => ( $^O =~ /^(MS)?Win32$/ );
  use constant IS_VMS => $^O eq 'VMS';
  use constant IS_UNIXY => !( IS_VMS || IS_WIN32 );
  
  use constant STATE_FILE => IS_UNIXY ? '.prove'   : '_prove';
  use constant RC_FILE    => IS_UNIXY ? '.proverc' : '_proverc';
  
  use constant PLUGINS => 'App::Prove::Plugin';
  
  my @ATTR;
  
  BEGIN {
      @ATTR = qw(
        archive argv blib show_count color directives exec failures comments
        formatter harness includes modules plugins jobs lib merge parse quiet
        really_quiet recurse backwards shuffle taint_fail taint_warn timer
        verbose warnings_fail warnings_warn show_help show_man show_version
        state_class test_args state dry extensions ignore_exit rules state_manager
        normalize sources tapversion trap
        statefile
      );
      __PACKAGE__->mk_methods(@ATTR);
  }
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
  Create a new C<App::Prove>. Optionally a hash ref of attribute
  initializers may be passed.
  
  =cut
  
  # new() implementation supplied by TAP::Object
  
  sub _initialize {
      my $self = shift;
      my $args = shift || {};
  
      my @is_array = qw(
        argv rc_opts includes modules state plugins rules sources
      );
  
      # setup defaults:
      for my $key (@is_array) {
          $self->{$key} = [];
      }
  
      for my $attr (@ATTR) {
          if ( exists $args->{$attr} ) {
  
              # TODO: Some validation here
              $self->{$attr} = $args->{$attr};
          }
      }
  
      $self->state_class('App::Prove::State');
      return $self;
  }
  
  =head3 C<state_class>
  
  Getter/setter for the name of the class used for maintaining state.  This
  class should either subclass from C<App::Prove::State> or provide an identical
  interface.
  
  =head3 C<state_manager>
  
  Getter/setter for the instance of the C<state_class>.
  
  =cut
  
  =head3 C<add_rc_file>
  
      $prove->add_rc_file('myproj/.proverc');
  
  Called before C<process_args> to prepend the contents of an rc file to
  the options.
  
  =cut
  
  sub add_rc_file {
      my ( $self, $rc_file ) = @_;
  
      local *RC;
      open RC, "<$rc_file" or croak "Can't read $rc_file ($!)";
      while ( defined( my $line = <RC> ) ) {
          push @{ $self->{rc_opts} },
            grep { defined and not /^#/ }
            $line =~ m{ ' ([^']*) ' | " ([^"]*) " | (\#.*) | (\S+) }xg;
      }
      close RC;
  }
  
  =head3 C<process_args>
  
      $prove->process_args(@args);
  
  Processes the command-line arguments. Attributes will be set
  appropriately. Any filenames may be found in the C<argv> attribute.
  
  Dies on invalid arguments.
  
  =cut
  
  sub process_args {
      my $self = shift;
  
      my @rc = RC_FILE;
      unshift @rc, glob '~/' . RC_FILE if IS_UNIXY;
  
      # Preprocess meta-args.
      my @args;
      while ( defined( my $arg = shift ) ) {
          if ( $arg eq '--norc' ) {
              @rc = ();
          }
          elsif ( $arg eq '--rc' ) {
              defined( my $rc = shift )
                or croak "Missing argument to --rc";
              push @rc, $rc;
          }
          elsif ( $arg =~ m{^--rc=(.+)$} ) {
              push @rc, $1;
          }
          else {
              push @args, $arg;
          }
      }
  
      # Everything after the arisdottle '::' gets passed as args to
      # test programs.
      if ( defined( my $stop_at = _first_pos( '::', @args ) ) ) {
          my @test_args = splice @args, $stop_at;
          shift @test_args;
          $self->{test_args} = \@test_args;
      }
  
      # Grab options from RC files
      $self->add_rc_file($_) for grep -f, @rc;
      unshift @args, @{ $self->{rc_opts} };
  
      if ( my @bad = map {"-$_"} grep {/^-(man|help)$/} @args ) {
          die "Long options should be written with two dashes: ",
            join( ', ', @bad ), "\n";
      }
  
      # And finally...
  
      {
          local @ARGV = @args;
          Getopt::Long::Configure(qw(no_ignore_case bundling pass_through));
  
          # Don't add coderefs to GetOptions
          GetOptions(
              'v|verbose'  => \$self->{verbose},
              'f|failures' => \$self->{failures},
              'o|comments' => \$self->{comments},
              'l|lib'      => \$self->{lib},
              'b|blib'     => \$self->{blib},
              's|shuffle'  => \$self->{shuffle},
              'color!'     => \$self->{color},
              'colour!'    => \$self->{color},
              'count!'     => \$self->{show_count},
              'c'          => \$self->{color},
              'D|dry'      => \$self->{dry},
              'ext=s@'     => sub {
                  my ( $opt, $val ) = @_;
  
                  # Workaround for Getopt::Long 2.25 handling of
                  # multivalue options
                  push @{ $self->{extensions} ||= [] }, $val;
              },
              'harness=s'    => \$self->{harness},
              'ignore-exit'  => \$self->{ignore_exit},
              'source=s@'    => $self->{sources},
              'formatter=s'  => \$self->{formatter},
              'r|recurse'    => \$self->{recurse},
              'reverse'      => \$self->{backwards},
              'p|parse'      => \$self->{parse},
              'q|quiet'      => \$self->{quiet},
              'Q|QUIET'      => \$self->{really_quiet},
              'e|exec=s'     => \$self->{exec},
              'm|merge'      => \$self->{merge},
              'I=s@'         => $self->{includes},
              'M=s@'         => $self->{modules},
              'P=s@'         => $self->{plugins},
              'state=s@'     => $self->{state},
              'statefile=s'  => \$self->{statefile},
              'directives'   => \$self->{directives},
              'h|help|?'     => \$self->{show_help},
              'H|man'        => \$self->{show_man},
              'V|version'    => \$self->{show_version},
              'a|archive=s'  => \$self->{archive},
              'j|jobs=i'     => \$self->{jobs},
              'timer'        => \$self->{timer},
              'T'            => \$self->{taint_fail},
              't'            => \$self->{taint_warn},
              'W'            => \$self->{warnings_fail},
              'w'            => \$self->{warnings_warn},
              'normalize'    => \$self->{normalize},
              'rules=s@'     => $self->{rules},
              'tapversion=s' => \$self->{tapversion},
              'trap'         => \$self->{trap},
          ) or croak('Unable to continue');
  
          # Stash the remainder of argv for later
          $self->{argv} = [@ARGV];
      }
  
      return;
  }
  
  sub _first_pos {
      my $want = shift;
      for ( 0 .. $#_ ) {
          return $_ if $_[$_] eq $want;
      }
      return;
  }
  
  sub _help {
      my ( $self, $verbosity ) = @_;
  
      eval('use Pod::Usage 1.12 ()');
      if ( my $err = $@ ) {
          die 'Please install Pod::Usage for the --help option '
            . '(or try `perldoc prove`.)'
            . "\n ($@)";
      }
  
      Pod::Usage::pod2usage( { -verbose => $verbosity } );
  
      return;
  }
  
  sub _color_default {
      my $self = shift;
  
      return -t STDOUT && !$ENV{HARNESS_NOTTY};
  }
  
  sub _get_args {
      my $self = shift;
  
      my %args;
  
      $args{trap} = 1 if $self->trap;
  
      if ( defined $self->color ? $self->color : $self->_color_default ) {
          $args{color} = 1;
      }
      if ( !defined $self->show_count ) {
          $args{show_count} = 1;
      }
      else {
          $args{show_count} = $self->show_count;
      }
  
      if ( $self->archive ) {
          $self->require_harness( archive => 'TAP::Harness::Archive' );
          $args{archive} = $self->archive;
      }
  
      if ( my $jobs = $self->jobs ) {
          $args{jobs} = $jobs;
      }
  
      if ( my $harness_opt = $self->harness ) {
          $self->require_harness( harness => $harness_opt );
      }
  
      if ( my $formatter = $self->formatter ) {
          $args{formatter_class} = $formatter;
      }
  
      for my $handler ( @{ $self->sources } ) {
          my ( $name, $config ) = $self->_parse_source($handler);
          $args{sources}->{$name} = $config;
      }
  
      if ( $self->ignore_exit ) {
          $args{ignore_exit} = 1;
      }
  
      if ( $self->taint_fail && $self->taint_warn ) {
          die '-t and -T are mutually exclusive';
      }
  
      if ( $self->warnings_fail && $self->warnings_warn ) {
          die '-w and -W are mutually exclusive';
      }
  
      for my $a (qw( lib switches )) {
          my $method = "_get_$a";
          my $val    = $self->$method();
          $args{$a} = $val if defined $val;
      }
  
      # Handle verbose, quiet, really_quiet flags
      my %verb_map = ( verbose => 1, quiet => -1, really_quiet => -2, );
  
      my @verb_adj = grep {$_} map { $self->$_() ? $verb_map{$_} : 0 }
        keys %verb_map;
  
      die "Only one of verbose, quiet or really_quiet should be specified\n"
        if @verb_adj > 1;
  
      $args{verbosity} = shift @verb_adj || 0;
  
      for my $a (qw( merge failures comments timer directives normalize )) {
          $args{$a} = 1 if $self->$a();
      }
  
      $args{errors} = 1 if $self->parse;
  
      # defined but zero-length exec runs test files as binaries
      $args{exec} = [ split( /\s+/, $self->exec ) ]
        if ( defined( $self->exec ) );
  
      $args{version} = $self->tapversion if defined( $self->tapversion );
  
      if ( defined( my $test_args = $self->test_args ) ) {
          $args{test_args} = $test_args;
      }
  
      if ( @{ $self->rules } ) {
          my @rules;
          for ( @{ $self->rules } ) {
              if (/^par=(.*)/) {
                  push @rules, $1;
              }
              elsif (/^seq=(.*)/) {
                  push @rules, { seq => $1 };
              }
          }
          $args{rules} = { par => [@rules] };
      }
      $args{harness_class} = $self->{harness_class} if $self->{harness_class};
  
      return \%args;
  }
  
  sub _find_module {
      my ( $self, $class, @search ) = @_;
  
      croak "Bad module name $class"
        unless $class =~ /^ \w+ (?: :: \w+ ) *$/x;
  
      for my $pfx (@search) {
          my $name = join( '::', $pfx, $class );
          eval "require $name";
          return $name unless $@;
      }
  
      eval "require $class";
      return $class unless $@;
      return;
  }
  
  sub _load_extension {
      my ( $self, $name, @search ) = @_;
  
      my @args = ();
      if ( $name =~ /^(.*?)=(.*)/ ) {
          $name = $1;
          @args = split( /,/, $2 );
      }
  
      if ( my $class = $self->_find_module( $name, @search ) ) {
          $class->import(@args);
          if ( $class->can('load') ) {
              $class->load( { app_prove => $self, args => [@args] } );
          }
      }
      else {
          croak "Can't load module $name";
      }
  }
  
  sub _load_extensions {
      my ( $self, $ext, @search ) = @_;
      $self->_load_extension( $_, @search ) for @$ext;
  }
  
  sub _parse_source {
      my ( $self, $handler ) = @_;
  
      # Load any options.
      ( my $opt_name = lc $handler ) =~ s/::/-/g;
      local @ARGV = @{ $self->{argv} };
      my %config;
      Getopt::Long::GetOptions(
          "$opt_name-option=s%" => sub {
              my ( $name, $k, $v ) = @_;
              if ( $v =~ /(?<!\\)=/ ) {
  
                  # It's a hash option.
                  croak "Option $name must be consistently used as a hash"
                    if exists $config{$k} && ref $config{$k} ne 'HASH';
                  $config{$k} ||= {};
                  my ( $hk, $hv ) = split /(?<!\\)=/, $v, 2;
                  $config{$k}{$hk} = $hv;
              }
              else {
                  $v =~ s/\\=/=/g;
                  if ( exists $config{$k} ) {
                      $config{$k} = [ $config{$k} ]
                        unless ref $config{$k} eq 'ARRAY';
                      push @{ $config{$k} } => $v;
                  }
                  else {
                      $config{$k} = $v;
                  }
              }
          }
      );
      $self->{argv} = \@ARGV;
      return ( $handler, \%config );
  }
  
  =head3 C<run>
  
  Perform whatever actions the command line args specified. The C<prove>
  command line tool consists of the following code:
  
      use App::Prove;
  
      my $app = App::Prove->new;
      $app->process_args(@ARGV);
      exit( $app->run ? 0 : 1 );  # if you need the exit code
  
  =cut
  
  sub run {
      my $self = shift;
  
      unless ( $self->state_manager ) {
          $self->state_manager(
              $self->state_class->new( { store => $self->statefile || STATE_FILE } ) );
      }
  
      if ( $self->show_help ) {
          $self->_help(1);
      }
      elsif ( $self->show_man ) {
          $self->_help(2);
      }
      elsif ( $self->show_version ) {
          $self->print_version;
      }
      elsif ( $self->dry ) {
          print "$_\n" for $self->_get_tests;
      }
      else {
  
          $self->_load_extensions( $self->modules );
          $self->_load_extensions( $self->plugins, PLUGINS );
  
          local $ENV{TEST_VERBOSE} = 1 if $self->verbose;
  
          return $self->_runtests( $self->_get_args, $self->_get_tests );
      }
  
      return 1;
  }
  
  sub _get_tests {
      my $self = shift;
  
      my $state = $self->state_manager;
      my $ext   = $self->extensions;
      $state->extensions($ext) if defined $ext;
      if ( defined( my $state_switch = $self->state ) ) {
          $state->apply_switch(@$state_switch);
      }
  
      my @tests = $state->get_tests( $self->recurse, @{ $self->argv } );
  
      $self->_shuffle(@tests) if $self->shuffle;
      @tests = reverse @tests if $self->backwards;
  
      return @tests;
  }
  
  sub _runtests {
      my ( $self, $args, @tests ) = @_;
      my $harness = TAP::Harness::Env->create($args);
  
      my $state = $self->state_manager;
  
      $harness->callback(
          after_test => sub {
              $state->observe_test(@_);
          }
      );
  
      $harness->callback(
          after_runtests => sub {
              $state->commit(@_);
          }
      );
  
      my $aggregator = $harness->runtests(@tests);
  
      return !$aggregator->has_errors;
  }
  
  sub _get_switches {
      my $self = shift;
      my @switches;
  
      # notes that -T or -t must be at the front of the switches!
      if ( $self->taint_fail ) {
          push @switches, '-T';
      }
      elsif ( $self->taint_warn ) {
          push @switches, '-t';
      }
      if ( $self->warnings_fail ) {
          push @switches, '-W';
      }
      elsif ( $self->warnings_warn ) {
          push @switches, '-w';
      }
  
      return @switches ? \@switches : ();
  }
  
  sub _get_lib {
      my $self = shift;
      my @libs;
      if ( $self->lib ) {
          push @libs, 'lib';
      }
      if ( $self->blib ) {
          push @libs, 'blib/lib', 'blib/arch';
      }
      if ( @{ $self->includes } ) {
          push @libs, @{ $self->includes };
      }
  
      #24926
      @libs = map { File::Spec->rel2abs($_) } @libs;
  
      # Huh?
      return @libs ? \@libs : ();
  }
  
  sub _shuffle {
      my $self = shift;
  
      # Fisher-Yates shuffle
      my $i = @_;
      while ($i) {
          my $j = rand $i--;
          @_[ $i, $j ] = @_[ $j, $i ];
      }
      return;
  }
  
  =head3 C<require_harness>
  
  Load a harness replacement class.
  
    $prove->require_harness($for => $class_name);
  
  =cut
  
  sub require_harness {
      my ( $self, $for, $class ) = @_;
  
      my ($class_name) = $class =~ /^(\w+(?:::\w+)*)/;
  
      # Emulate Perl's -MModule=arg1,arg2 behaviour
      $class =~ s!^(\w+(?:::\w+)*)=(.*)$!$1 split(/,/,q{$2})!;
  
      eval("use $class;");
      die "$class_name is required to use the --$for feature: $@" if $@;
  
      $self->{harness_class} = $class_name;
  
      return;
  }
  
  =head3 C<print_version>
  
  Display the version numbers of the loaded L<TAP::Harness> and the
  current Perl.
  
  =cut
  
  sub print_version {
      my $self = shift;
      require TAP::Harness;
      printf(
          "TAP::Harness v%s and Perl v%vd\n",
          $TAP::Harness::VERSION, $^V
      );
  
      return;
  }
  
  1;
  
  # vim:ts=4:sw=4:et:sta
  
  __END__
  
  =head2 Attributes
  
  After command line parsing the following attributes reflect the values
  of the corresponding command line switches. They may be altered before
  calling C<run>.
  
  =over
  
  =item C<archive>
  
  =item C<argv>
  
  =item C<backwards>
  
  =item C<blib>
  
  =item C<color>
  
  =item C<directives>
  
  =item C<dry>
  
  =item C<exec>
  
  =item C<extensions>
  
  =item C<failures>
  
  =item C<comments>
  
  =item C<formatter>
  
  =item C<harness>
  
  =item C<ignore_exit>
  
  =item C<includes>
  
  =item C<jobs>
  
  =item C<lib>
  
  =item C<merge>
  
  =item C<modules>
  
  =item C<parse>
  
  =item C<plugins>
  
  =item C<quiet>
  
  =item C<really_quiet>
  
  =item C<recurse>
  
  =item C<rules>
  
  =item C<show_count>
  
  =item C<show_help>
  
  =item C<show_man>
  
  =item C<show_version>
  
  =item C<shuffle>
  
  =item C<state>
  
  =item C<state_class>
  
  =item C<taint_fail>
  
  =item C<taint_warn>
  
  =item C<test_args>
  
  =item C<timer>
  
  =item C<verbose>
  
  =item C<warnings_fail>
  
  =item C<warnings_warn>
  
  =item C<tapversion>
  
  =item C<trap>
  
  =back
  
  =head1 PLUGINS
  
  C<App::Prove> provides support for 3rd-party plugins.  These are currently
  loaded at run-time, I<after> arguments have been parsed (so you can not
  change the way arguments are processed, sorry), typically with the
  C<< -PI<plugin> >> switch, eg:
  
    prove -PMyPlugin
  
  This will search for a module named C<App::Prove::Plugin::MyPlugin>, or failing
  that, C<MyPlugin>.  If the plugin can't be found, C<prove> will complain & exit.
  
  You can pass an argument to your plugin by appending an C<=> after the plugin
  name, eg C<-PMyPlugin=foo>.  You can pass multiple arguments using commas:
  
    prove -PMyPlugin=foo,bar,baz
  
  These are passed in to your plugin's C<load()> class method (if it has one),
  along with a reference to the C<App::Prove> object that is invoking your plugin:
  
    sub load {
        my ($class, $p) = @_;
  
        my @args = @{ $p->{args} };
        # @args will contain ( 'foo', 'bar', 'baz' )
        $p->{app_prove}->do_something;
        ...
    }
  
  Note that the user's arguments are also passed to your plugin's C<import()>
  function as a list, eg:
  
    sub import {
        my ($class, @args) = @_;
        # @args will contain ( 'foo', 'bar', 'baz' )
        ...
    }
  
  This is for backwards compatibility, and may be deprecated in the future.
  
  =head2 Sample Plugin
  
  Here's a sample plugin, for your reference:
  
    package App::Prove::Plugin::Foo;
  
    # Sample plugin, try running with:
    # prove -PFoo=bar -r -j3
    # prove -PFoo -Q
    # prove -PFoo=bar,My::Formatter
  
    use strict;
    use warnings;
  
    sub load {
        my ($class, $p) = @_;
        my @args = @{ $p->{args} };
        my $app  = $p->{app_prove};
  
        print "loading plugin: $class, args: ", join(', ', @args ), "\n";
  
        # turn on verbosity
        $app->verbose( 1 );
  
        # set the formatter?
        $app->formatter( $args[1] ) if @args > 1;
  
        # print some of App::Prove's state:
        for my $attr (qw( jobs quiet really_quiet recurse verbose )) {
            my $val = $app->$attr;
            $val    = 'undef' unless defined( $val );
            print "$attr: $val\n";
        }
  
        return 1;
    }
  
    1;
  
  =head1 SEE ALSO
  
  L<prove>, L<TAP::Harness>
  
  =cut
APP_PROVE

$fatpacked{"App/Prove/State.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROVE_STATE';
  package App::Prove::State;
  
  use strict;
  use warnings;
  
  use File::Find;
  use File::Spec;
  use Carp;
  
  use App::Prove::State::Result;
  use TAP::Parser::YAMLish::Reader ();
  use TAP::Parser::YAMLish::Writer ();
  use base 'TAP::Base';
  
  BEGIN {
      __PACKAGE__->mk_methods('result_class');
  }
  
  use constant IS_WIN32 => ( $^O =~ /^(MS)?Win32$/ );
  use constant NEED_GLOB => IS_WIN32;
  
  =head1 NAME
  
  App::Prove::State - State storage for the C<prove> command.
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 DESCRIPTION
  
  The C<prove> command supports a C<--state> option that instructs it to
  store persistent state across runs. This module implements that state
  and the operations that may be performed on it.
  
  =head1 SYNOPSIS
  
      # Re-run failed tests
      $ prove --state=failed,save -rbv
  
  =cut
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
  Accepts a hashref with the following key/value pairs:
  
  =over 4
  
  =item * C<store>
  
  The filename of the data store holding the data that App::Prove::State reads.
  
  =item * C<extensions> (optional)
  
  The test name extensions.  Defaults to C<.t>.
  
  =item * C<result_class> (optional)
  
  The name of the C<result_class>.  Defaults to C<App::Prove::State::Result>.
  
  =back
  
  =cut
  
  # override TAP::Base::new:
  sub new {
      my $class = shift;
      my %args = %{ shift || {} };
  
      my $self = bless {
          select     => [],
          seq        => 1,
          store      => delete $args{store},
          extensions => ( delete $args{extensions} || ['.t'] ),
          result_class =>
            ( delete $args{result_class} || 'App::Prove::State::Result' ),
      }, $class;
  
      $self->{_} = $self->result_class->new(
          {   tests      => {},
              generation => 1,
          }
      );
      my $store = $self->{store};
      $self->load($store)
        if defined $store && -f $store;
  
      return $self;
  }
  
  =head2 C<result_class>
  
  Getter/setter for the name of the class used for tracking test results.  This
  class should either subclass from C<App::Prove::State::Result> or provide an
  identical interface.
  
  =cut
  
  =head2 C<extensions>
  
  Get or set the list of extensions that files must have in order to be
  considered tests. Defaults to ['.t'].
  
  =cut
  
  sub extensions {
      my $self = shift;
      $self->{extensions} = shift if @_;
      return $self->{extensions};
  }
  
  =head2 C<results>
  
  Get the results of the last test run.  Returns a C<result_class()> instance.
  
  =cut
  
  sub results {
      my $self = shift;
      $self->{_} || $self->result_class->new;
  }
  
  =head2 C<commit>
  
  Save the test results. Should be called after all tests have run.
  
  =cut
  
  sub commit {
      my $self = shift;
      if ( $self->{should_save} ) {
          $self->save;
      }
  }
  
  =head2 Instance Methods
  
  =head3 C<apply_switch>
  
   $self->apply_switch('failed,save');
  
  Apply a list of switch options to the state, updating the internal
  object state as a result. Nothing is returned.
  
  Diagnostics:
      - "Illegal state option: %s"
  
  =over
  
  =item C<last>
  
  Run in the same order as last time
  
  =item C<failed>
  
  Run only the failed tests from last time
  
  =item C<passed>
  
  Run only the passed tests from last time
  
  =item C<all>
  
  Run all tests in normal order
  
  =item C<hot>
  
  Run the tests that most recently failed first
  
  =item C<todo>
  
  Run the tests ordered by number of todos.
  
  =item C<slow>
  
  Run the tests in slowest to fastest order.
  
  =item C<fast>
  
  Run test tests in fastest to slowest order.
  
  =item C<new>
  
  Run the tests in newest to oldest order.
  
  =item C<old>
  
  Run the tests in oldest to newest order.
  
  =item C<save>
  
  Save the state on exit.
  
  =back
  
  =cut
  
  sub apply_switch {
      my $self = shift;
      my @opts = @_;
  
      my $last_gen      = $self->results->generation - 1;
      my $last_run_time = $self->results->last_run_time;
      my $now           = $self->get_time;
  
      my @switches = map { split /,/ } @opts;
  
      my %handler = (
          last => sub {
              $self->_select(
                  limit => shift,
                  where => sub { $_->generation >= $last_gen },
                  order => sub { $_->sequence }
              );
          },
          failed => sub {
              $self->_select(
                  limit => shift,
                  where => sub { $_->result != 0 },
                  order => sub { -$_->result }
              );
          },
          passed => sub {
              $self->_select(
                  limit => shift,
                  where => sub { $_->result == 0 }
              );
          },
          all => sub {
              $self->_select( limit => shift );
          },
          todo => sub {
              $self->_select(
                  limit => shift,
                  where => sub { $_->num_todo != 0 },
                  order => sub { -$_->num_todo; }
              );
          },
          hot => sub {
              $self->_select(
                  limit => shift,
                  where => sub { defined $_->last_fail_time },
                  order => sub { $now - $_->last_fail_time }
              );
          },
          slow => sub {
              $self->_select(
                  limit => shift,
                  order => sub { -$_->elapsed }
              );
          },
          fast => sub {
              $self->_select(
                  limit => shift,
                  order => sub { $_->elapsed }
              );
          },
          new => sub {
              $self->_select(
                  limit => shift,
                  order => sub { -$_->mtime }
              );
          },
          old => sub {
              $self->_select(
                  limit => shift,
                  order => sub { $_->mtime }
              );
          },
          fresh => sub {
              $self->_select(
                  limit => shift,
                  where => sub { $_->mtime >= $last_run_time }
              );
          },
          save => sub {
              $self->{should_save}++;
          },
          adrian => sub {
              unshift @switches, qw( hot all save );
          },
      );
  
      while ( defined( my $ele = shift @switches ) ) {
          my ( $opt, $arg )
            = ( $ele =~ /^([^:]+):(.*)/ )
            ? ( $1, $2 )
            : ( $ele, undef );
          my $code = $handler{$opt}
            || croak "Illegal state option: $opt";
          $code->($arg);
      }
      return;
  }
  
  sub _select {
      my ( $self, %spec ) = @_;
      push @{ $self->{select} }, \%spec;
  }
  
  =head3 C<get_tests>
  
  Given a list of args get the names of tests that should run
  
  =cut
  
  sub get_tests {
      my $self    = shift;
      my $recurse = shift;
      my @argv    = @_;
      my %seen;
  
      my @selected = $self->_query;
  
      unless ( @argv || @{ $self->{select} } ) {
          @argv = $recurse ? '.' : 't';
          croak qq{No tests named and '@argv' directory not found}
            unless -d $argv[0];
      }
  
      push @selected, $self->_get_raw_tests( $recurse, @argv ) if @argv;
      return grep { !$seen{$_}++ } @selected;
  }
  
  sub _query {
      my $self = shift;
      if ( my @sel = @{ $self->{select} } ) {
          warn "No saved state, selection will be empty\n"
            unless $self->results->num_tests;
          return map { $self->_query_clause($_) } @sel;
      }
      return;
  }
  
  sub _query_clause {
      my ( $self, $clause ) = @_;
      my @got;
      my $results = $self->results;
      my $where = $clause->{where} || sub {1};
  
      # Select
      for my $name ( $results->test_names ) {
          next unless -f $name;
          local $_ = $results->test($name);
          push @got, $name if $where->();
      }
  
      # Sort
      if ( my $order = $clause->{order} ) {
          @got = map { $_->[0] }
            sort {
                   ( defined $b->[1] <=> defined $a->[1] )
                || ( ( $a->[1] || 0 ) <=> ( $b->[1] || 0 ) )
            } map {
              [   $_,
                  do { local $_ = $results->test($_); $order->() }
              ]
            } @got;
      }
  
      if ( my $limit = $clause->{limit} ) {
          @got = splice @got, 0, $limit if @got > $limit;
      }
  
      return @got;
  }
  
  sub _get_raw_tests {
      my $self    = shift;
      my $recurse = shift;
      my @argv    = @_;
      my @tests;
  
      # Do globbing on Win32.
      if (NEED_GLOB) {
          eval "use File::Glob::Windows";    # [49732]
          @argv = map { glob "$_" } @argv;
      }
      my $extensions = $self->{extensions};
  
      for my $arg (@argv) {
          if ( '-' eq $arg ) {
              push @argv => <STDIN>;
              chomp(@argv);
              next;
          }
  
          push @tests,
              sort -d $arg
            ? $recurse
                ? $self->_expand_dir_recursive( $arg, $extensions )
                : map { glob( File::Spec->catfile( $arg, "*$_" ) ) }
                @{$extensions}
            : $arg;
      }
      return @tests;
  }
  
  sub _expand_dir_recursive {
      my ( $self, $dir, $extensions ) = @_;
  
      my @tests;
      my $ext_string = join( '|', map {quotemeta} @{$extensions} );
  
      find(
          {   follow      => 1,      #21938
              follow_skip => 2,
              wanted      => sub {
                  -f 
                    && /(?:$ext_string)$/
                    && push @tests => $File::Find::name;
                }
          },
          $dir
      );
      return @tests;
  }
  
  =head3 C<observe_test>
  
  Store the results of a test.
  
  =cut
  
  # Store:
  #     last fail time
  #     last pass time
  #     last run time
  #     most recent result
  #     most recent todos
  #     total failures
  #     total passes
  #     state generation
  #     parser
  
  sub observe_test {
  
      my ( $self, $test_info, $parser ) = @_;
      my $name = $test_info->[0];
      my $fail = scalar( $parser->failed ) + ( $parser->has_problems ? 1 : 0 );
      my $todo = scalar( $parser->todo );
      my $start_time = $parser->start_time;
      my $end_time   = $parser->end_time,
  
        my $test = $self->results->test($name);
  
      $test->sequence( $self->{seq}++ );
      $test->generation( $self->results->generation );
  
      $test->run_time($end_time);
      $test->result($fail);
      $test->num_todo($todo);
      $test->elapsed( $end_time - $start_time );
  
      $test->parser($parser);
  
      if ($fail) {
          $test->total_failures( $test->total_failures + 1 );
          $test->last_fail_time($end_time);
      }
      else {
          $test->total_passes( $test->total_passes + 1 );
          $test->last_pass_time($end_time);
      }
  }
  
  =head3 C<save>
  
  Write the state to a file.
  
  =cut
  
  sub save {
      my ($self) = @_;
  
      my $store = $self->{store} or return;
      $self->results->last_run_time( $self->get_time );
  
      my $writer = TAP::Parser::YAMLish::Writer->new;
      local *FH;
      open FH, ">$store" or croak "Can't write $store ($!)";
      $writer->write( $self->results->raw, \*FH );
      close FH;
  }
  
  =head3 C<load>
  
  Load the state from a file
  
  =cut
  
  sub load {
      my ( $self, $name ) = @_;
      my $reader = TAP::Parser::YAMLish::Reader->new;
      local *FH;
      open FH, "<$name" or croak "Can't read $name ($!)";
  
      # XXX this is temporary
      $self->{_} = $self->result_class->new(
          $reader->read(
              sub {
                  my $line = <FH>;
                  defined $line && chomp $line;
                  return $line;
              }
          )
      );
  
      # $writer->write( $self->{tests} || {}, \*FH );
      close FH;
      $self->_regen_seq;
      $self->_prune_and_stamp;
      $self->results->generation( $self->results->generation + 1 );
  }
  
  sub _prune_and_stamp {
      my $self = shift;
  
      my $results = $self->results;
      my @tests   = $self->results->tests;
      for my $test (@tests) {
          my $name = $test->name;
          if ( my @stat = stat $name ) {
              $test->mtime( $stat[9] );
          }
          else {
              $results->remove($name);
          }
      }
  }
  
  sub _regen_seq {
      my $self = shift;
      for my $test ( $self->results->tests ) {
          $self->{seq} = $test->sequence + 1
            if defined $test->sequence && $test->sequence >= $self->{seq};
      }
  }
  
  1;
APP_PROVE_STATE

$fatpacked{"App/Prove/State/Result.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROVE_STATE_RESULT';
  package App::Prove::State::Result;
  
  use strict;
  use warnings;
  use Carp 'croak';
  
  use App::Prove::State::Result::Test;
  
  use constant STATE_VERSION => 1;
  
  =head1 NAME
  
  App::Prove::State::Result - Individual test suite results.
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 DESCRIPTION
  
  The C<prove> command supports a C<--state> option that instructs it to
  store persistent state across runs. This module encapsulates the results for a
  single test suite run.
  
  =head1 SYNOPSIS
  
      # Re-run failed tests
      $ prove --state=failed,save -rbv
  
  =cut
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
      my $result = App::Prove::State::Result->new({
          generation => $generation,
          tests      => \%tests,
      });
  
  Returns a new C<App::Prove::State::Result> instance.
  
  =cut
  
  sub new {
      my ( $class, $arg_for ) = @_;
      $arg_for ||= {};
      my %instance_data = %$arg_for;    # shallow copy
      $instance_data{version} = $class->state_version;
      my $tests = delete $instance_data{tests} || {};
      my $self = bless \%instance_data => $class;
      $self->_initialize($tests);
      return $self;
  }
  
  sub _initialize {
      my ( $self, $tests ) = @_;
      my %tests;
      while ( my ( $name, $test ) = each %$tests ) {
          $tests{$name} = $self->test_class->new(
              {   %$test,
                  name => $name
              }
          );
      }
      $self->tests( \%tests );
      return $self;
  }
  
  =head2 C<state_version>
  
  Returns the current version of state storage.
  
  =cut
  
  sub state_version {STATE_VERSION}
  
  =head2 C<test_class>
  
  Returns the name of the class used for tracking individual tests.  This class
  should either subclass from C<App::Prove::State::Result::Test> or provide an
  identical interface.
  
  =cut
  
  sub test_class {
      return 'App::Prove::State::Result::Test';
  }
  
  my %methods = (
      generation    => { method => 'generation',    default => 0 },
      last_run_time => { method => 'last_run_time', default => undef },
  );
  
  while ( my ( $key, $description ) = each %methods ) {
      my $default = $description->{default};
      no strict 'refs';
      *{ $description->{method} } = sub {
          my $self = shift;
          if (@_) {
              $self->{$key} = shift;
              return $self;
          }
          return $self->{$key} || $default;
      };
  }
  
  =head3 C<generation>
  
  Getter/setter for the "generation" of the test suite run. The first
  generation is 1 (one) and subsequent generations are 2, 3, etc.
  
  =head3 C<last_run_time>
  
  Getter/setter for the time of the test suite run.
  
  =head3 C<tests>
  
  Returns the tests for a given generation. This is a hashref or a hash,
  depending on context called. The keys to the hash are the individual
  test names and the value is a hashref with various interesting values.
  Each k/v pair might resemble something like this:
  
   't/foo.t' => {
      elapsed        => '0.0428488254547119',
      gen            => '7',
      last_pass_time => '1219328376.07815',
      last_result    => '0',
      last_run_time  => '1219328376.07815',
      last_todo      => '0',
      mtime          => '1191708862',
      seq            => '192',
      total_passes   => '6',
    }
  
  =cut
  
  sub tests {
      my $self = shift;
      if (@_) {
          $self->{tests} = shift;
          return $self;
      }
      my %tests = %{ $self->{tests} };
      my @tests = sort { $a->sequence <=> $b->sequence } values %tests;
      return wantarray ? @tests : \@tests;
  }
  
  =head3 C<test>
  
   my $test = $result->test('t/customer/create.t');
  
  Returns an individual C<App::Prove::State::Result::Test> instance for the
  given test name (usually the filename).  Will return a new
  C<App::Prove::State::Result::Test> instance if the name is not found.
  
  =cut
  
  sub test {
      my ( $self, $name ) = @_;
      croak("test() requires a test name") unless defined $name;
  
      my $tests = $self->{tests} ||= {};
      if ( my $test = $tests->{$name} ) {
          return $test;
      }
      else {
          my $test = $self->test_class->new( { name => $name } );
          $self->{tests}->{$name} = $test;
          return $test;
      }
  }
  
  =head3 C<test_names>
  
  Returns an list of test names, sorted by run order.
  
  =cut
  
  sub test_names {
      my $self = shift;
      return map { $_->name } $self->tests;
  }
  
  =head3 C<remove>
  
   $result->remove($test_name);            # remove the test
   my $test = $result->test($test_name);   # fatal error
  
  Removes a given test from results.  This is a no-op if the test name is not
  found.
  
  =cut
  
  sub remove {
      my ( $self, $name ) = @_;
      delete $self->{tests}->{$name};
      return $self;
  }
  
  =head3 C<num_tests>
  
  Returns the number of tests for a given test suite result.
  
  =cut
  
  sub num_tests { keys %{ shift->{tests} } }
  
  =head3 C<raw>
  
  Returns a hashref of raw results, suitable for serialization by YAML.
  
  =cut
  
  sub raw {
      my $self = shift;
      my %raw  = %$self;
  
      my %tests;
      for my $test ( $self->tests ) {
          $tests{ $test->name } = $test->raw;
      }
      $raw{tests} = \%tests;
      return \%raw;
  }
  
  1;
APP_PROVE_STATE_RESULT

$fatpacked{"App/Prove/State/Result/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROVE_STATE_RESULT_TEST';
  package App::Prove::State::Result::Test;
  
  use strict;
  use warnings;
  
  =head1 NAME
  
  App::Prove::State::Result::Test - Individual test results.
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 DESCRIPTION
  
  The C<prove> command supports a C<--state> option that instructs it to
  store persistent state across runs. This module encapsulates the results for a
  single test.
  
  =head1 SYNOPSIS
  
      # Re-run failed tests
      $ prove --state=failed,save -rbv
  
  =cut
  
  my %methods = (
      name           => { method => 'name' },
      elapsed        => { method => 'elapsed', default => 0 },
      gen            => { method => 'generation', default => 1 },
      last_pass_time => { method => 'last_pass_time', default => undef },
      last_fail_time => { method => 'last_fail_time', default => undef },
      last_result    => { method => 'result', default => 0 },
      last_run_time  => { method => 'run_time', default => undef },
      last_todo      => { method => 'num_todo', default => 0 },
      mtime          => { method => 'mtime', default => undef },
      seq            => { method => 'sequence', default => 1 },
      total_passes   => { method => 'total_passes', default => 0 },
      total_failures => { method => 'total_failures', default => 0 },
      parser         => { method => 'parser' },
  );
  
  while ( my ( $key, $description ) = each %methods ) {
      my $default = $description->{default};
      no strict 'refs';
      *{ $description->{method} } = sub {
          my $self = shift;
          if (@_) {
              $self->{$key} = shift;
              return $self;
          }
          return $self->{$key} || $default;
      };
  }
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
  =cut
  
  sub new {
      my ( $class, $arg_for ) = @_;
      $arg_for ||= {};
      bless $arg_for => $class;
  }
  
  =head2 Instance Methods
  
  =head3 C<name>
  
  The name of the test.  Usually a filename.
  
  =head3 C<elapsed>
  
  The total elapsed times the test took to run, in seconds from the epoch..
  
  =head3 C<generation>
  
  The number for the "generation" of the test run.  The first generation is 1
  (one) and subsequent generations are 2, 3, etc.
  
  =head3 C<last_pass_time>
  
  The last time the test program passed, in seconds from the epoch.
  
  Returns C<undef> if the program has never passed.
  
  =head3 C<last_fail_time>
  
  The last time the test suite failed, in seconds from the epoch.
  
  Returns C<undef> if the program has never failed.
  
  =head3 C<mtime>
  
  Returns the mtime of the test, in seconds from the epoch.
  
  =head3 C<raw>
  
  Returns a hashref of raw test data, suitable for serialization by YAML.
  
  =head3 C<result>
  
  Currently, whether or not the test suite passed with no 'problems' (such as
  TODO passed).
  
  =head3 C<run_time>
  
  The total time it took for the test to run, in seconds.  If C<Time::HiRes> is
  available, it will have finer granularity.
  
  =head3 C<num_todo>
  
  The number of tests with TODO directives.
  
  =head3 C<sequence>
  
  The order in which this test was run for the given test suite result. 
  
  =head3 C<total_passes>
  
  The number of times the test has passed.
  
  =head3 C<total_failures>
  
  The number of times the test has failed.
  
  =head3 C<parser>
  
  The underlying parser object.  This is useful if you need the full
  information for the test program.
  
  =cut
  
  sub raw {
      my $self = shift;
      my %raw  = %$self;
  
      # this is backwards-compatibility hack and is not guaranteed.
      delete $raw{name};
      delete $raw{parser};
      return \%raw;
  }
  
  1;
APP_PROVE_STATE_RESULT_TEST

$fatpacked{"Getopt/Long.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG';
  #! perl
  
  # Getopt::Long.pm -- Universal options parsing
  # Author          : Johan Vromans
  # Created On      : Tue Sep 11 15:00:12 1990
  # Last Modified By: Johan Vromans
  # Last Modified On: Sat May 27 12:11:39 2017
  # Update Count    : 1715
  # Status          : Released
  
  ################ Module Preamble ################
  
  use 5.004;
  
  use strict;
  use warnings;
  
  package Getopt::Long;
  
  use vars qw($VERSION);
  $VERSION        =  2.50;
  # For testing versions only.
  use vars qw($VERSION_STRING);
  $VERSION_STRING = "2.50";
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  # Exported subroutines.
  sub GetOptions(@);		# always
  sub GetOptionsFromArray(@);	# on demand
  sub GetOptionsFromString(@);	# on demand
  sub Configure(@);		# on demand
  sub HelpMessage(@);		# on demand
  sub VersionMessage(@);		# in demand
  
  BEGIN {
      # Init immediately so their contents can be used in the 'use vars' below.
      @EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
      @EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
  		    &GetOptionsFromArray &GetOptionsFromString);
  }
  
  # User visible variables.
  use vars @EXPORT, @EXPORT_OK;
  use vars qw($error $debug $major_version $minor_version);
  # Deprecated visible variables.
  use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
  	    $passthrough);
  # Official invisible variables.
  use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
  
  # Really invisible variables.
  my $bundling_values;
  
  # Public subroutines.
  sub config(@);			# deprecated name
  
  # Private subroutines.
  sub ConfigDefaults();
  sub ParseOptionSpec($$);
  sub OptCtl($);
  sub FindOption($$$$$);
  sub ValidValue ($$$$$);
  
  ################ Local Variables ################
  
  # $requested_version holds the version that was mentioned in the 'use'
  # or 'require', if any. It can be used to enable or disable specific
  # features.
  my $requested_version = 0;
  
  ################ Resident subroutines ################
  
  sub ConfigDefaults() {
      # Handle POSIX compliancy.
      if ( defined $ENV{"POSIXLY_CORRECT"} ) {
  	$genprefix = "(--|-)";
  	$autoabbrev = 0;		# no automatic abbrev of options
  	$bundling = 0;			# no bundling of single letter switches
  	$getopt_compat = 0;		# disallow '+' to start options
  	$order = $REQUIRE_ORDER;
      }
      else {
  	$genprefix = "(--|-|\\+)";
  	$autoabbrev = 1;		# automatic abbrev of options
  	$bundling = 0;			# bundling off by default
  	$getopt_compat = 1;		# allow '+' to start options
  	$order = $PERMUTE;
      }
      # Other configurable settings.
      $debug = 0;			# for debugging
      $error = 0;			# error tally
      $ignorecase = 1;		# ignore case when matching options
      $passthrough = 0;		# leave unrecognized options alone
      $gnu_compat = 0;		# require --opt=val if value is optional
      $longprefix = "(--)";       # what does a long prefix look like
      $bundling_values = 0;	# no bundling of values
  }
  
  # Override import.
  sub import {
      my $pkg = shift;		# package
      my @syms = ();		# symbols to import
      my @config = ();		# configuration
      my $dest = \@syms;		# symbols first
      for ( @_ ) {
  	if ( $_ eq ':config' ) {
  	    $dest = \@config;	# config next
  	    next;
  	}
  	push(@$dest, $_);	# push
      }
      # Hide one level and call super.
      local $Exporter::ExportLevel = 1;
      push(@syms, qw(&GetOptions)) if @syms; # always export GetOptions
      $requested_version = 0;
      $pkg->SUPER::import(@syms);
      # And configure.
      Configure(@config) if @config;
  }
  
  ################ Initialization ################
  
  # Values for $order. See GNU getopt.c for details.
  ($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
  # Version major/minor numbers.
  ($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;
  
  ConfigDefaults();
  
  ################ OO Interface ################
  
  package Getopt::Long::Parser;
  
  # Store a copy of the default configuration. Since ConfigDefaults has
  # just been called, what we get from Configure is the default.
  my $default_config = do {
      Getopt::Long::Configure ()
  };
  
  sub new {
      my $that = shift;
      my $class = ref($that) || $that;
      my %atts = @_;
  
      # Register the callers package.
      my $self = { caller_pkg => (caller)[0] };
  
      bless ($self, $class);
  
      # Process config attributes.
      if ( defined $atts{config} ) {
  	my $save = Getopt::Long::Configure ($default_config, @{$atts{config}});
  	$self->{settings} = Getopt::Long::Configure ($save);
  	delete ($atts{config});
      }
      # Else use default config.
      else {
  	$self->{settings} = $default_config;
      }
  
      if ( %atts ) {		# Oops
  	die(__PACKAGE__.": unhandled attributes: ".
  	    join(" ", sort(keys(%atts)))."\n");
      }
  
      $self;
  }
  
  sub configure {
      my ($self) = shift;
  
      # Restore settings, merge new settings in.
      my $save = Getopt::Long::Configure ($self->{settings}, @_);
  
      # Restore orig config and save the new config.
      $self->{settings} = Getopt::Long::Configure ($save);
  }
  
  sub getoptions {
      my ($self) = shift;
  
      return $self->getoptionsfromarray(\@ARGV, @_);
  }
  
  sub getoptionsfromarray {
      my ($self) = shift;
  
      # Restore config settings.
      my $save = Getopt::Long::Configure ($self->{settings});
  
      # Call main routine.
      my $ret = 0;
      $Getopt::Long::caller = $self->{caller_pkg};
  
      eval {
  	# Locally set exception handler to default, otherwise it will
  	# be called implicitly here, and again explicitly when we try
  	# to deliver the messages.
  	local ($SIG{__DIE__}) = 'DEFAULT';
  	$ret = Getopt::Long::GetOptionsFromArray (@_);
      };
  
      # Restore saved settings.
      Getopt::Long::Configure ($save);
  
      # Handle errors and return value.
      die ($@) if $@;
      return $ret;
  }
  
  package Getopt::Long;
  
  ################ Back to Normal ################
  
  # Indices in option control info.
  # Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
  use constant CTL_TYPE    => 0;
  #use constant   CTL_TYPE_FLAG   => '';
  #use constant   CTL_TYPE_NEG    => '!';
  #use constant   CTL_TYPE_INCR   => '+';
  #use constant   CTL_TYPE_INT    => 'i';
  #use constant   CTL_TYPE_INTINC => 'I';
  #use constant   CTL_TYPE_XINT   => 'o';
  #use constant   CTL_TYPE_FLOAT  => 'f';
  #use constant   CTL_TYPE_STRING => 's';
  
  use constant CTL_CNAME   => 1;
  
  use constant CTL_DEFAULT => 2;
  
  use constant CTL_DEST    => 3;
   use constant   CTL_DEST_SCALAR => 0;
   use constant   CTL_DEST_ARRAY  => 1;
   use constant   CTL_DEST_HASH   => 2;
   use constant   CTL_DEST_CODE   => 3;
  
  use constant CTL_AMIN    => 4;
  use constant CTL_AMAX    => 5;
  
  # FFU.
  #use constant CTL_RANGE   => ;
  #use constant CTL_REPEAT  => ;
  
  # Rather liberal patterns to match numbers.
  use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
  use constant PAT_XINT  =>
    "(?:".
  	  "[-+]?_*[1-9][0-9_]*".
    "|".
  	  "0x_*[0-9a-f][0-9a-f_]*".
    "|".
  	  "0b_*[01][01_]*".
    "|".
  	  "0[0-7_]*".
    ")";
  use constant PAT_FLOAT =>
    "[-+]?".			# optional sign
    "(?=[0-9.])".			# must start with digit or dec.point
    "[0-9_]*".			# digits before the dec.point
    "(\.[0-9_]+)?".		# optional fraction
    "([eE][-+]?[0-9_]+)?";	# optional exponent
  
  sub GetOptions(@) {
      # Shift in default array.
      unshift(@_, \@ARGV);
      # Try to keep caller() and Carp consistent.
      goto &GetOptionsFromArray;
  }
  
  sub GetOptionsFromString(@) {
      my ($string) = shift;
      require Text::ParseWords;
      my $args = [ Text::ParseWords::shellwords($string) ];
      $caller ||= (caller)[0];	# current context
      my $ret = GetOptionsFromArray($args, @_);
      return ( $ret, $args ) if wantarray;
      if ( @$args ) {
  	$ret = 0;
  	warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n");
      }
      $ret;
  }
  
  sub GetOptionsFromArray(@) {
  
      my ($argv, @optionlist) = @_;	# local copy of the option descriptions
      my $argend = '--';		# option list terminator
      my %opctl = ();		# table of option specs
      my $pkg = $caller || (caller)[0];	# current context
  				# Needed if linkage is omitted.
      my @ret = ();		# accum for non-options
      my %linkage;		# linkage
      my $userlinkage;		# user supplied HASH
      my $opt;			# current option
      my $prefix = $genprefix;	# current prefix
  
      $error = '';
  
      if ( $debug ) {
  	# Avoid some warnings if debugging.
  	local ($^W) = 0;
  	print STDERR
  	  ("Getopt::Long $Getopt::Long::VERSION ",
  	   "called from package \"$pkg\".",
  	   "\n  ",
  	   "argv: ",
  	   defined($argv)
  	   ? UNIVERSAL::isa( $argv, 'ARRAY' ) ? "(@$argv)" : $argv
  	   : "<undef>",
  	   "\n  ",
  	   "autoabbrev=$autoabbrev,".
  	   "bundling=$bundling,",
  	   "bundling_values=$bundling_values,",
  	   "getopt_compat=$getopt_compat,",
  	   "gnu_compat=$gnu_compat,",
  	   "order=$order,",
  	   "\n  ",
  	   "ignorecase=$ignorecase,",
  	   "requested_version=$requested_version,",
  	   "passthrough=$passthrough,",
  	   "genprefix=\"$genprefix\",",
  	   "longprefix=\"$longprefix\".",
  	   "\n");
      }
  
      # Check for ref HASH as first argument.
      # First argument may be an object. It's OK to use this as long
      # as it is really a hash underneath.
      $userlinkage = undef;
      if ( @optionlist && ref($optionlist[0]) and
  	 UNIVERSAL::isa($optionlist[0],'HASH') ) {
  	$userlinkage = shift (@optionlist);
  	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
      }
  
      # See if the first element of the optionlist contains option
      # starter characters.
      # Be careful not to interpret '<>' as option starters.
      if ( @optionlist && $optionlist[0] =~ /^\W+$/
  	 && !($optionlist[0] eq '<>'
  	      && @optionlist > 0
  	      && ref($optionlist[1])) ) {
  	$prefix = shift (@optionlist);
  	# Turn into regexp. Needs to be parenthesized!
  	$prefix =~ s/(\W)/\\$1/g;
  	$prefix = "([" . $prefix . "])";
  	print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
      }
  
      # Verify correctness of optionlist.
      %opctl = ();
      while ( @optionlist ) {
  	my $opt = shift (@optionlist);
  
  	unless ( defined($opt) ) {
  	    $error .= "Undefined argument in option spec\n";
  	    next;
  	}
  
  	# Strip leading prefix so people can specify "--foo=i" if they like.
  	$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  
  	if ( $opt eq '<>' ) {
  	    if ( (defined $userlinkage)
  		&& !(@optionlist > 0 && ref($optionlist[0]))
  		&& (exists $userlinkage->{$opt})
  		&& ref($userlinkage->{$opt}) ) {
  		unshift (@optionlist, $userlinkage->{$opt});
  	    }
  	    unless ( @optionlist > 0
  		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
  		$error .= "Option spec <> requires a reference to a subroutine\n";
  		# Kill the linkage (to avoid another error).
  		shift (@optionlist)
  		  if @optionlist && ref($optionlist[0]);
  		next;
  	    }
  	    $linkage{'<>'} = shift (@optionlist);
  	    next;
  	}
  
  	# Parse option spec.
  	my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  	unless ( defined $name ) {
  	    # Failed. $orig contains the error message. Sorry for the abuse.
  	    $error .= $orig;
  	    # Kill the linkage (to avoid another error).
  	    shift (@optionlist)
  	      if @optionlist && ref($optionlist[0]);
  	    next;
  	}
  
  	# If no linkage is supplied in the @optionlist, copy it from
  	# the userlinkage if available.
  	if ( defined $userlinkage ) {
  	    unless ( @optionlist > 0 && ref($optionlist[0]) ) {
  		if ( exists $userlinkage->{$orig} &&
  		     ref($userlinkage->{$orig}) ) {
  		    print STDERR ("=> found userlinkage for \"$orig\": ",
  				  "$userlinkage->{$orig}\n")
  			if $debug;
  		    unshift (@optionlist, $userlinkage->{$orig});
  		}
  		else {
  		    # Do nothing. Being undefined will be handled later.
  		    next;
  		}
  	    }
  	}
  
  	# Copy the linkage. If omitted, link to global variable.
  	if ( @optionlist > 0 && ref($optionlist[0]) ) {
  	    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  		if $debug;
  	    my $rl = ref($linkage{$orig} = shift (@optionlist));
  
  	    if ( $rl eq "ARRAY" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  	    }
  	    elsif ( $rl eq "HASH" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
  	    }
  	    elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
  #		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  #		    my $t = $linkage{$orig};
  #		    $$t = $linkage{$orig} = [];
  #		}
  #		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  #		}
  #		else {
  		    # Ok.
  #		}
  	    }
  	    elsif ( $rl eq "CODE" ) {
  		# Ok.
  	    }
  	    else {
  		$error .= "Invalid option linkage for \"$opt\"\n";
  	    }
  	}
  	else {
  	    # Link to global $opt_XXX variable.
  	    # Make sure a valid perl identifier results.
  	    my $ov = $orig;
  	    $ov =~ s/\W/_/g;
  	    if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  		print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;");
  	    }
  	    elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  		print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
  	    }
  	    else {
  		print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
  	    }
  	}
  
  	if ( $opctl{$name}[CTL_TYPE] eq 'I'
  	     && ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY
  		  || $opctl{$name}[CTL_DEST] == CTL_DEST_HASH )
  	   ) {
  	    $error .= "Invalid option linkage for \"$opt\"\n";
  	}
  
      }
  
      $error .= "GetOptionsFromArray: 1st parameter is not an array reference\n"
        unless $argv && UNIVERSAL::isa( $argv, 'ARRAY' );
  
      # Bail out if errors found.
      die ($error) if $error;
      $error = 0;
  
      # Supply --version and --help support, if needed and allowed.
      if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{version}) ) {
  	    $opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
  	    $linkage{version} = \&VersionMessage;
  	}
  	$auto_version = 1;
      }
      if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
  	    $opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
  	    $linkage{help} = \&HelpMessage;
  	}
  	$auto_help = 1;
      }
  
      # Show the options tables if debugging.
      if ( $debug ) {
  	my ($arrow, $k, $v);
  	$arrow = "=> ";
  	while ( ($k,$v) = each(%opctl) ) {
  	    print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
  	    $arrow = "   ";
  	}
      }
  
      # Process argument list
      my $goon = 1;
      while ( $goon && @$argv > 0 ) {
  
  	# Get next argument.
  	$opt = shift (@$argv);
  	print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  
  	# Double dash is option list terminator.
  	if ( defined($opt) && $opt eq $argend ) {
  	  push (@ret, $argend) if $passthrough;
  	  last;
  	}
  
  	# Look it up.
  	my $tryopt = $opt;
  	my $found;		# success status
  	my $key;		# key (if hash type)
  	my $arg;		# option argument
  	my $ctl;		# the opctl entry
  
  	($found, $opt, $ctl, $arg, $key) =
  	  FindOption ($argv, $prefix, $argend, $opt, \%opctl);
  
  	if ( $found ) {
  
  	    # FindOption undefines $opt in case of errors.
  	    next unless defined $opt;
  
  	    my $argcnt = 0;
  	    while ( defined $arg ) {
  
  		# Get the canonical name.
  		print STDERR ("=> cname for \"$opt\" is ") if $debug;
  		$opt = $ctl->[CTL_CNAME];
  		print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  
  		if ( defined $linkage{$opt} ) {
  		    print STDERR ("=> ref(\$L{$opt}) -> ",
  				  ref($linkage{$opt}), "\n") if $debug;
  
  		    if ( ref($linkage{$opt}) eq 'SCALAR'
  			 || ref($linkage{$opt}) eq 'REF' ) {
  			if ( $ctl->[CTL_TYPE] eq '+' ) {
  			    print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
  			      if $debug;
  			    if ( defined ${$linkage{$opt}} ) {
  			        ${$linkage{$opt}} += $arg;
  			    }
  		            else {
  			        ${$linkage{$opt}} = $arg;
  			    }
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to ARRAY\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = [];
  			    print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			      if $debug;
  			    push (@{$linkage{$opt}}, $arg);
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to HASH\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = {};
  			    print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			      if $debug;
  			    $linkage{$opt}->{$key} = $arg;
  			}
  			else {
  			    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  			      if $debug;
  			    ${$linkage{$opt}} = $arg;
  		        }
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
  			print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			    if $debug;
  			push (@{$linkage{$opt}}, $arg);
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
  			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$linkage{$opt}->{$key} = $arg;
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
  			print STDERR ("=> &L{$opt}(\"$opt\"",
  				      $ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
  				      ", \"$arg\")\n")
  			    if $debug;
  			my $eval_error = do {
  			    local $@;
  			    local $SIG{__DIE__}  = 'DEFAULT';
  			    eval {
  				&{$linkage{$opt}}
  				  (Getopt::Long::CallBack->new
  				   (name    => $opt,
  				    ctl     => $ctl,
  				    opctl   => \%opctl,
  				    linkage => \%linkage,
  				    prefix  => $prefix,
  				   ),
  				   $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
  				   $arg);
  			    };
  			    $@;
  			};
  			print STDERR ("=> die($eval_error)\n")
  			  if $debug && $eval_error ne '';
  			if ( $eval_error =~ /^!/ ) {
  			    if ( $eval_error =~ /^!FINISH\b/ ) {
  				$goon = 0;
  			    }
  			}
  			elsif ( $eval_error ne '' ) {
  			    warn ($eval_error);
  			    $error++;
  			}
  		    }
  		    else {
  			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
  				      "\" in linkage\n");
  			die("Getopt::Long -- internal error!\n");
  		    }
  		}
  		# No entry in linkage means entry in userlinkage.
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")
  			    if $debug;
  			push (@{$userlinkage->{$opt}}, $arg);
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
  			    if $debug;
  			$userlinkage->{$opt} = [$arg];
  		    }
  		}
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$userlinkage->{$opt}->{$key} = $arg;
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
  			    if $debug;
  			$userlinkage->{$opt} = {$key => $arg};
  		    }
  		}
  		else {
  		    if ( $ctl->[CTL_TYPE] eq '+' ) {
  			print STDERR ("=> \$L{$opt} += \"$arg\"\n")
  			  if $debug;
  			if ( defined $userlinkage->{$opt} ) {
  			    $userlinkage->{$opt} += $arg;
  			}
  			else {
  			    $userlinkage->{$opt} = $arg;
  			}
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
  			$userlinkage->{$opt} = $arg;
  		    }
  		}
  
  		$argcnt++;
  		last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  		undef($arg);
  
  		# Need more args?
  		if ( $argcnt < $ctl->[CTL_AMIN] ) {
  		    if ( @$argv ) {
  			if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
  			    $arg = shift(@$argv);
  			    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  				$arg =~ tr/_//d;
  				$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  				  ? oct($arg)
  				  : 0+$arg
  			    }
  			    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  			      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  			    next;
  			}
  			warn("Value \"$$argv[0]\" invalid for option $opt\n");
  			$error++;
  		    }
  		    else {
  			warn("Insufficient arguments for option $opt\n");
  			$error++;
  		    }
  		}
  
  		# Any more args?
  		if ( @$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
  		    $arg = shift(@$argv);
  		    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  			$arg =~ tr/_//d;
  			$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  			  ? oct($arg)
  			  : 0+$arg
  		    }
  		    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  		      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  		    next;
  		}
  	    }
  	}
  
  	# Not an option. Save it if we $PERMUTE and don't have a <>.
  	elsif ( $order == $PERMUTE ) {
  	    # Try non-options call-back.
  	    my $cb;
  	    if ( defined ($cb = $linkage{'<>'}) ) {
  		print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
  		  if $debug;
  		my $eval_error = do {
  		    local $@;
  		    local $SIG{__DIE__}  = 'DEFAULT';
  		    eval {
  			# The arg to <> cannot be the CallBack object
  			# since it may be passed to other modules that
  			# get confused (e.g., Archive::Tar). Well,
  			# it's not relevant for this callback anyway.
  			&$cb($tryopt);
  		    };
  		    $@;
  		};
  		print STDERR ("=> die($eval_error)\n")
  		  if $debug && $eval_error ne '';
  		if ( $eval_error =~ /^!/ ) {
  		    if ( $eval_error =~ /^!FINISH\b/ ) {
  			$goon = 0;
  		    }
  		}
  		elsif ( $eval_error ne '' ) {
  		    warn ($eval_error);
  		    $error++;
  		}
  	    }
  	    else {
  		print STDERR ("=> saving \"$tryopt\" ",
  			      "(not an option, may permute)\n") if $debug;
  		push (@ret, $tryopt);
  	    }
  	    next;
  	}
  
  	# ...otherwise, terminate.
  	else {
  	    # Push this one back and exit.
  	    unshift (@$argv, $tryopt);
  	    return ($error == 0);
  	}
  
      }
  
      # Finish.
      if ( @ret && $order == $PERMUTE ) {
  	#  Push back accumulated arguments
  	print STDERR ("=> restoring \"", join('" "', @ret), "\"\n")
  	    if $debug;
  	unshift (@$argv, @ret);
      }
  
      return ($error == 0);
  }
  
  # A readable representation of what's in an optbl.
  sub OptCtl ($) {
      my ($v) = @_;
      my @v = map { defined($_) ? ($_) : ("<undef>") } @$v;
      "[".
        join(",",
  	   "\"$v[CTL_TYPE]\"",
  	   "\"$v[CTL_CNAME]\"",
  	   "\"$v[CTL_DEFAULT]\"",
  	   ("\$","\@","\%","\&")[$v[CTL_DEST] || 0],
  	   $v[CTL_AMIN] || '',
  	   $v[CTL_AMAX] || '',
  #	   $v[CTL_RANGE] || '',
  #	   $v[CTL_REPEAT] || '',
  	  ). "]";
  }
  
  # Parse an option specification and fill the tables.
  sub ParseOptionSpec ($$) {
      my ($opt, $opctl) = @_;
  
      # Match option spec.
      if ( $opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Alias names, or "?"
  		     (?: \| (?: \? | \w[-\w]* ) )*
  		     # Aliases
  		     (?: \| (?: [^-|!+=:][^|!+=:]* )? )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x ) {
  	return (undef, "Error in option spec: \"$opt\"\n");
      }
  
      my ($names, $spec) = ($1, $2);
      $spec = '' unless defined $spec;
  
      # $orig keeps track of the primary name the user specified.
      # This name will be used for the internal or external linkage.
      # In other words, if the user specifies "FoO|BaR", it will
      # match any case combinations of 'foo' and 'bar', but if a global
      # variable needs to be set, it will be $opt_FoO in the exact case
      # as specified.
      my $orig;
  
      my @names;
      if ( defined $names ) {
  	@names =  split (/\|/, $names);
  	$orig = $names[0];
      }
      else {
  	@names = ('');
  	$orig = '';
      }
  
      # Construct the opctl entries.
      my $entry;
      if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
  	# Fields are hard-wired here.
  	$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
      }
      elsif ( $spec =~ /^:(-?\d+|\+)([@%])?$/ ) {
  	my $def = $1;
  	my $dest = $2;
  	my $type = $def eq '+' ? 'I' : 'i';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,$def eq '+' ? undef : $def,
  		  $dest,0,1];
      }
      else {
  	my ($mand, $type, $dest) =
  	  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
  	return (undef, "Cannot repeat while bundling: \"$opt\"\n")
  	  if $bundling && defined($4);
  	my ($mi, $cm, $ma) = ($5, $6, $7);
  	return (undef, "{0} is useless in option spec: \"$opt\"\n")
  	  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
  
  	$type = 'i' if $type eq 'n';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Default minargs to 1/0 depending on mand status.
  	$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
  	# Adjust mand status according to minargs.
  	$mand = $mi ? '=' : ':';
  	# Adjust maxargs.
  	$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
  	return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
  	  if defined($ma) && !$ma;
  	return (undef, "Max less than min in option spec: \"$opt\"\n")
  	  if defined($ma) && $ma < $mi;
  
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
      }
  
      # Process all names. First is canonical, the rest are aliases.
      my $dups = '';
      foreach ( @names ) {
  
  	$_ = lc ($_)
  	  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
  
  	if ( exists $opctl->{$_} ) {
  	    $dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
  	}
  
  	if ( $spec eq '!' ) {
  	    $opctl->{"no$_"} = $entry;
  	    $opctl->{"no-$_"} = $entry;
  	    $opctl->{$_} = [@$entry];
  	    $opctl->{$_}->[CTL_TYPE] = '';
  	}
  	else {
  	    $opctl->{$_} = $entry;
  	}
      }
  
      if ( $dups && $^W ) {
  	foreach ( split(/\n+/, $dups) ) {
  	    warn($_."\n");
  	}
      }
      ($names[0], $orig);
  }
  
  # Option lookup.
  sub FindOption ($$$$$) {
  
      # returns (1, $opt, $ctl, $arg, $key) if okay,
      # returns (1, undef) if option in error,
      # returns (0) otherwise.
  
      my ($argv, $prefix, $argend, $opt, $opctl) = @_;
  
      print STDERR ("=> find \"$opt\"\n") if $debug;
  
      return (0) unless defined($opt);
      return (0) unless $opt =~ /^($prefix)(.*)$/s;
      return (0) if $opt eq "-" && !defined $opctl->{''};
  
      $opt = substr( $opt, length($1) ); # retain taintedness
      my $starter = $1;
  
      print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
  
      my $optarg;			# value supplied with --opt=value
      my $rest;			# remainder from unbundling
  
      # If it is a long option, it may include the value.
      # With getopt_compat, only if not bundling.
      if ( ($starter=~/^$longprefix$/
  	  || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
  	 && (my $oppos = index($opt, '=', 1)) > 0) {
  	my $optorg = $opt;
  	$opt = substr($optorg, 0, $oppos);
  	$optarg = substr($optorg, $oppos + 1); # retain tainedness
  	print STDERR ("=> option \"", $opt,
  		      "\", optarg = \"$optarg\"\n") if $debug;
      }
  
      #### Look it up ###
  
      my $tryopt = $opt;		# option to try
  
      if ( ( $bundling || $bundling_values ) && $starter eq '-' ) {
  
  	# To try overrides, obey case ignore.
  	$tryopt = $ignorecase ? lc($opt) : $opt;
  
  	# If bundling == 2, long options can override bundles.
  	if ( $bundling == 2 && length($tryopt) > 1
  	     && defined ($opctl->{$tryopt}) ) {
  	    print STDERR ("=> $starter$tryopt overrides unbundling\n")
  	      if $debug;
  	}
  
  	# If bundling_values, option may be followed by the value.
  	elsif ( $bundling_values ) {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    # Whatever remains may not be considered an option.
  	    $optarg = $rest eq '' ? undef : $rest;
  	    $rest = undef;
  	}
  
  	# Split off a single letter and leave the rest for
  	# further processing.
  	else {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    $rest = undef unless $rest ne '';
  	}
      }
  
      # Try auto-abbreviation.
      elsif ( $autoabbrev && $opt ne "" ) {
  	# Sort the possible long option names.
  	my @names = sort(keys (%$opctl));
  	# Downcase if allowed.
  	$opt = lc ($opt) if $ignorecase;
  	$tryopt = $opt;
  	# Turn option name into pattern.
  	my $pat = quotemeta ($opt);
  	# Look up in option names.
  	my @hits = grep (/^$pat/, @names);
  	print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
  		      "out of ", scalar(@names), "\n") if $debug;
  
  	# Check for ambiguous results.
  	unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
  	    # See if all matches are for the same option.
  	    my %hit;
  	    foreach ( @hits ) {
  		my $hit = $opctl->{$_}->[CTL_CNAME]
  		  if defined $opctl->{$_}->[CTL_CNAME];
  		$hit = "no" . $hit if $opctl->{$_}->[CTL_TYPE] eq '!';
  		$hit{$hit} = 1;
  	    }
  	    # Remove auto-supplied options (version, help).
  	    if ( keys(%hit) == 2 ) {
  		if ( $auto_version && exists($hit{version}) ) {
  		    delete $hit{version};
  		}
  		elsif ( $auto_help && exists($hit{help}) ) {
  		    delete $hit{help};
  		}
  	    }
  	    # Now see if it really is ambiguous.
  	    unless ( keys(%hit) == 1 ) {
  		return (0) if $passthrough;
  		warn ("Option ", $opt, " is ambiguous (",
  		      join(", ", @hits), ")\n");
  		$error++;
  		return (1, undef);
  	    }
  	    @hits = keys(%hit);
  	}
  
  	# Complete the option name, if appropriate.
  	if ( @hits == 1 && $hits[0] ne $opt ) {
  	    $tryopt = $hits[0];
  	    $tryopt = lc ($tryopt)
  	      if $ignorecase > (($bundling && length($tryopt) == 1) ? 1 : 0);
  	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
  		if $debug;
  	}
      }
  
      # Map to all lowercase if ignoring case.
      elsif ( $ignorecase ) {
  	$tryopt = lc ($opt);
      }
  
      # Check validity by fetching the info.
      my $ctl = $opctl->{$tryopt};
      unless  ( defined $ctl ) {
  	return (0) if $passthrough;
  	# Pretend one char when bundling.
  	if ( $bundling == 1 && length($starter) == 1 ) {
  	    $opt = substr($opt,0,1);
              unshift (@$argv, $starter.$rest) if defined $rest;
  	}
  	if ( $opt eq "" ) {
  	    warn ("Missing option after ", $starter, "\n");
  	}
  	else {
  	    warn ("Unknown option: ", $opt, "\n");
  	}
  	$error++;
  	return (1, undef);
      }
      # Apparently valid.
      $opt = $tryopt;
      print STDERR ("=> found ", OptCtl($ctl),
  		  " for \"", $opt, "\"\n") if $debug;
  
      #### Determine argument status ####
  
      # If it is an option w/o argument, we're almost finished with it.
      my $type = $ctl->[CTL_TYPE];
      my $arg;
  
      if ( $type eq '' || $type eq '!' || $type eq '+' ) {
  	if ( defined $optarg ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " does not take an argument\n");
  	    $error++;
  	    undef $opt;
  	    undef $optarg if $bundling_values;
  	}
  	elsif ( $type eq '' || $type eq '+' ) {
  	    # Supply explicit value.
  	    $arg = 1;
  	}
  	else {
  	    $opt =~ s/^no-?//i;	# strip NO prefix
  	    $arg = 0;		# supply explicit value
  	}
  	unshift (@$argv, $starter.$rest) if defined $rest;
  	return (1, $opt, $ctl, $arg);
      }
  
      # Get mandatory status and type info.
      my $mand = $ctl->[CTL_AMIN];
  
      # Check if there is an option argument available.
      if ( $gnu_compat ) {
  	my $optargtype = 0; # none, 1 = empty, 2 = nonempty, 3 = aux
  	if ( defined($optarg) ) {
  	    $optargtype = (length($optarg) == 0) ? 1 : 2;
  	}
  	elsif ( defined $rest || @$argv > 0 ) {
  	    # GNU getopt_long() does not accept the (optional)
  	    # argument to be passed to the option without = sign.
  	    # We do, since not doing so breaks existing scripts.
  	    $optargtype = 3;
  	}
  	if(($optargtype == 0) && !$mand) {
  	    my $val
  	      = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT]
  	      : $type eq 's'                 ? ''
  	      :                                0;
  	    return (1, $opt, $ctl, $val);
  	}
  	return (1, $opt, $ctl, $type eq 's' ? '' : 0)
  	  if $optargtype == 1;  # --foo=  -> return nothing
      }
  
      # Check if there is an option argument available.
      if ( defined $optarg
  	 ? ($optarg eq '')
  	 : !(defined $rest || @$argv > 0) ) {
  	# Complain if this option needs an argument.
  #	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
  	if ( $mand ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " requires an argument\n");
  	    $error++;
  	    return (1, undef);
  	}
  	if ( $type eq 'I' ) {
  	    # Fake incremental type.
  	    my @c = @$ctl;
  	    $c[CTL_TYPE] = '+';
  	    return (1, $opt, \@c, 1);
  	}
  	return (1, $opt, $ctl,
  		defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  		$type eq 's' ? '' : 0);
      }
  
      # Get (possibly optional) argument.
      $arg = (defined $rest ? $rest
  	    : (defined $optarg ? $optarg : shift (@$argv)));
  
      # Get key if this is a "name=value" pair for a hash option.
      my $key;
      if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
  	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
  	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  	     ($mand ? undef : ($type eq 's' ? "" : 1)));
  	if (! defined $arg) {
  	    warn ("Option $opt, key \"$key\", requires a value\n");
  	    $error++;
  	    # Push back.
  	    unshift (@$argv, $starter.$rest) if defined $rest;
  	    return (1, undef);
  	}
      }
  
      #### Check if the argument is valid for this option ####
  
      my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1, $opt, $ctl, $arg, $key) if $mand;
  
  	# Same for optional string as a hash value
  	return (1, $opt, $ctl, $arg, $key)
  	  if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  
  	# An optional string takes almost anything.
  	return (1, $opt, $ctl, $arg, $key)
  	  if defined $optarg || defined $rest;
  	return (1, $opt, $ctl, $arg, $key) if $arg eq "-"; # ??
  
  	# Check for option or option list terminator.
  	if ($arg eq $argend ||
  	    $arg =~ /^$prefix.+/) {
  	    # Push back.
  	    unshift (@$argv, $arg);
  	    # Supply empty value.
  	    $arg = '';
  	}
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  
  	if ( $bundling && defined $rest
  	     && $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/si ) {
  	    $arg =~ tr/_//d;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (",
  		      $type eq 'o' ? "extended " : '',
  		      "number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		if ( $type eq 'I' ) {
  		    # Fake incremental type.
  		    my @c = @$ctl;
  		    $c[CTL_TYPE] = '+';
  		    return (1, $opt, \@c, 1);
  		}
  		# Supply default value.
  		$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
  	    }
  	}
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	if ( $bundling && defined $rest &&
  	     $rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
  	    $arg =~ tr/_//d;
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/ ) {
  	    $arg =~ tr/_//d;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (real number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		# Supply default value.
  		$arg = 0.0;
  	    }
  	}
      }
      else {
  	die("Getopt::Long internal error (Can't happen)\n");
      }
      return (1, $opt, $ctl, $arg, $key);
  }
  
  sub ValidValue ($$$$$) {
      my ($ctl, $arg, $mand, $argend, $prefix) = @_;
  
      if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  	return 0 unless $arg =~ /[^=]+=(.*)/;
  	$arg = $1;
      }
  
      my $type = $ctl->[CTL_TYPE];
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1) if $mand;
  
  	return (1) if $arg eq "-";
  
  	# Check for option or option list terminator.
  	return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
  	return 1;
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  	return $arg =~ /^$o_valid$/si;
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	return $arg =~ /^$o_valid$/;
      }
      die("ValidValue: Cannot happen\n");
  }
  
  # Getopt::Long Configuration.
  sub Configure (@) {
      my (@options) = @_;
  
      my $prevconfig =
        [ $error, $debug, $major_version, $minor_version, $caller,
  	$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	$longprefix, $bundling_values ];
  
      if ( ref($options[0]) eq 'ARRAY' ) {
  	( $error, $debug, $major_version, $minor_version, $caller,
  	  $autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	  $longprefix, $bundling_values ) = @{shift(@options)};
      }
  
      my $opt;
      foreach $opt ( @options ) {
  	my $try = lc ($opt);
  	my $action = 1;
  	if ( $try =~ /^no_?(.*)$/s ) {
  	    $action = 0;
  	    $try = $+;
  	}
  	if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
  	    ConfigDefaults ();
  	}
  	elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
  	    local $ENV{POSIXLY_CORRECT};
  	    $ENV{POSIXLY_CORRECT} = 1 if $action;
  	    ConfigDefaults ();
  	}
  	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
  	    $autoabbrev = $action;
  	}
  	elsif ( $try eq 'getopt_compat' ) {
  	    $getopt_compat = $action;
              $genprefix = $action ? "(--|-|\\+)" : "(--|-)";
  	}
  	elsif ( $try eq 'gnu_getopt' ) {
  	    if ( $action ) {
  		$gnu_compat = 1;
  		$bundling = 1;
  		$getopt_compat = 0;
                  $genprefix = "(--|-)";
  		$order = $PERMUTE;
  		$bundling_values = 0;
  	    }
  	}
  	elsif ( $try eq 'gnu_compat' ) {
  	    $gnu_compat = $action;
  	    $bundling = 0;
  	    $bundling_values = 1;
  	}
  	elsif ( $try =~ /^(auto_?)?version$/ ) {
  	    $auto_version = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?help$/ ) {
  	    $auto_help = $action;
  	}
  	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
  	    $ignorecase = $action;
  	}
  	elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
  	    $ignorecase = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'bundling' ) {
  	    $bundling = $action;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_override' ) {
  	    $bundling = $action ? 2 : 0;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_values' ) {
  	    $bundling_values = $action;
  	    $bundling = 0 if $action;
  	}
  	elsif ( $try eq 'require_order' ) {
  	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
  	}
  	elsif ( $try eq 'permute' ) {
  	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
  	}
  	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
  	    $passthrough = $action;
  	}
  	elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Turn into regexp. Needs to be parenthesized!
  	    $genprefix = "(" . quotemeta($genprefix) . ")";
  	    eval { '' =~ /$genprefix/; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Parenthesize if needed.
  	    $genprefix = "(" . $genprefix . ")"
  	      unless $genprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$genprefix"; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
  	    $longprefix = $1;
  	    # Parenthesize if needed.
  	    $longprefix = "(" . $longprefix . ")"
  	      unless $longprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$longprefix"; };
  	    die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n") if $@;
  	}
  	elsif ( $try eq 'debug' ) {
  	    $debug = $action;
  	}
  	else {
  	    die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")
  	}
      }
      $prevconfig;
  }
  
  # Deprecated name.
  sub config (@) {
      Configure (@_);
  }
  
  # Issue a standard message for --version.
  #
  # The arguments are mostly the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub VersionMessage(@) {
      # Massage args.
      my $pa = setup_pa_args("version", @_);
  
      my $v = $main::VERSION;
      my $fh = $pa->{-output} ||
        ( ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR );
  
      print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
  	       $0, defined $v ? " version $v" : (),
  	       "\n",
  	       "(", __PACKAGE__, "::", "GetOptions",
  	       " version ",
  	       defined($Getopt::Long::VERSION_STRING)
  	         ? $Getopt::Long::VERSION_STRING : $VERSION, ";",
  	       " Perl version ",
  	       $] >= 5.006 ? sprintf("%vd", $^V) : $],
  	       ")\n");
      exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
  }
  
  # Issue a standard message for --help.
  #
  # The arguments are the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub HelpMessage(@) {
      eval {
  	require Pod::Usage;
  	import Pod::Usage;
  	1;
      } || die("Cannot provide help: cannot load Pod::Usage\n");
  
      # Note that pod2usage will issue a warning if -exitval => NOEXIT.
      pod2usage(setup_pa_args("help", @_));
  
  }
  
  # Helper routine to set up a normalized hash ref to be used as
  # argument to pod2usage.
  sub setup_pa_args($@) {
      my $tag = shift;		# who's calling
  
      # If called by direct binding to an option, it will get the option
      # name and value as arguments. Remove these, if so.
      @_ = () if @_ == 2 && $_[0] eq $tag;
  
      my $pa;
      if ( @_ > 1 ) {
  	$pa = { @_ };
      }
      else {
  	$pa = shift || {};
      }
  
      # At this point, $pa can be a number (exit value), string
      # (message) or hash with options.
  
      if ( UNIVERSAL::isa($pa, 'HASH') ) {
  	# Get rid of -msg vs. -message ambiguity.
  	$pa->{-message} = $pa->{-msg};
  	delete($pa->{-msg});
      }
      elsif ( $pa =~ /^-?\d+$/ ) {
  	$pa = { -exitval => $pa };
      }
      else {
  	$pa = { -message => $pa };
      }
  
      # These are _our_ defaults.
      $pa->{-verbose} = 0 unless exists($pa->{-verbose});
      $pa->{-exitval} = 0 unless exists($pa->{-exitval});
      $pa;
  }
  
  # Sneak way to know what version the user requested.
  sub VERSION {
      $requested_version = $_[1];
      shift->SUPER::VERSION(@_);
  }
  
  package Getopt::Long::CallBack;
  
  sub new {
      my ($pkg, %atts) = @_;
      bless { %atts }, $pkg;
  }
  
  sub name {
      my $self = shift;
      ''.$self->{name};
  }
  
  use overload
    # Treat this object as an ordinary string for legacy API.
    '""'	   => \&name,
    fallback => 1;
  
  1;
  
  ################ Documentation ################
  
  =head1 NAME
  
  Getopt::Long - Extended processing of command line options
  
  =head1 SYNOPSIS
  
    use Getopt::Long;
    my $data   = "file.dat";
    my $length = 24;
    my $verbose;
    GetOptions ("length=i" => \$length,    # numeric
                "file=s"   => \$data,      # string
                "verbose"  => \$verbose)   # flag
    or die("Error in command line arguments\n");
  
  =head1 DESCRIPTION
  
  The Getopt::Long module implements an extended getopt function called
  GetOptions(). It parses the command line from C<@ARGV>, recognizing
  and removing specified options and their possible values.
  
  This function adheres to the POSIX syntax for command
  line options, with GNU extensions. In general, this means that options
  have long names instead of single letters, and are introduced with a
  double dash "--". Support for bundling of command line options, as was
  the case with the more traditional single-letter approach, is provided
  but not enabled by default.
  
  =head1 Command Line Options, an Introduction
  
  Command line operated programs traditionally take their arguments from
  the command line, for example filenames or other information that the
  program needs to know. Besides arguments, these programs often take
  command line I<options> as well. Options are not necessary for the
  program to work, hence the name 'option', but are used to modify its
  default behaviour. For example, a program could do its job quietly,
  but with a suitable option it could provide verbose information about
  what it did.
  
  Command line options come in several flavours. Historically, they are
  preceded by a single dash C<->, and consist of a single letter.
  
      -l -a -c
  
  Usually, these single-character options can be bundled:
  
      -lac
  
  Options can have values, the value is placed after the option
  character. Sometimes with whitespace in between, sometimes not:
  
      -s 24 -s24
  
  Due to the very cryptic nature of these options, another style was
  developed that used long names. So instead of a cryptic C<-l> one
  could use the more descriptive C<--long>. To distinguish between a
  bundle of single-character options and a long one, two dashes are used
  to precede the option name. Early implementations of long options used
  a plus C<+> instead. Also, option values could be specified either
  like
  
      --size=24
  
  or
  
      --size 24
  
  The C<+> form is now obsolete and strongly deprecated.
  
  =head1 Getting Started with Getopt::Long
  
  Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was the
  first Perl module that provided support for handling the new style of
  command line options, in particular long option names, hence the Perl5
  name Getopt::Long. This module also supports single-character options
  and bundling.
  
  To use Getopt::Long from a Perl program, you must include the
  following line in your Perl program:
  
      use Getopt::Long;
  
  This will load the core of the Getopt::Long module and prepare your
  program for using it. Most of the actual Getopt::Long code is not
  loaded until you really call one of its functions.
  
  In the default configuration, options names may be abbreviated to
  uniqueness, case does not matter, and a single dash is sufficient,
  even for long option names. Also, options may be placed between
  non-option arguments. See L<Configuring Getopt::Long> for more
  details on how to configure Getopt::Long.
  
  =head2 Simple options
  
  The most simple options are the ones that take no values. Their mere
  presence on the command line enables the option. Popular examples are:
  
      --all --verbose --quiet --debug
  
  Handling simple options is straightforward:
  
      my $verbose = '';	# option variable with default value (false)
      my $all = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose, 'all' => \$all);
  
  The call to GetOptions() parses the command line arguments that are
  present in C<@ARGV> and sets the option variable to the value C<1> if
  the option did occur on the command line. Otherwise, the option
  variable is not touched. Setting the option value to true is often
  called I<enabling> the option.
  
  The option name as specified to the GetOptions() function is called
  the option I<specification>. Later we'll see that this specification
  can contain more than just the option name. The reference to the
  variable is called the option I<destination>.
  
  GetOptions() will return a true value if the command line could be
  processed successfully. Otherwise, it will write error messages using
  die() and warn(), and return a false result.
  
  =head2 A little bit less simple options
  
  Getopt::Long supports two useful variants of simple options:
  I<negatable> options and I<incremental> options.
  
  A negatable option is specified with an exclamation mark C<!> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose!' => \$verbose);
  
  Now, using C<--verbose> on the command line will enable C<$verbose>,
  as expected. But it is also allowed to use C<--noverbose>, which will
  disable C<$verbose> by setting its value to C<0>. Using a suitable
  default value, the program can find out whether C<$verbose> is false
  by default, or disabled by using C<--noverbose>.
  
  An incremental option is specified with a plus C<+> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose+' => \$verbose);
  
  Using C<--verbose> on the command line will increment the value of
  C<$verbose>. This way the program can keep track of how many times the
  option occurred on the command line. For example, each occurrence of
  C<--verbose> could increase the verbosity level of the program.
  
  =head2 Mixing command line option with other arguments
  
  Usually programs take command line options as well as other arguments,
  for example, file names. It is good practice to always specify the
  options first, and the other arguments last. Getopt::Long will,
  however, allow the options and arguments to be mixed and 'filter out'
  all the options before passing the rest of the arguments to the
  program. To stop Getopt::Long from processing further arguments,
  insert a double dash C<--> on the command line:
  
      --size 24 -- --all
  
  In this example, C<--all> will I<not> be treated as an option, but
  passed to the program unharmed, in C<@ARGV>.
  
  =head2 Options with values
  
  For options that take values it must be specified whether the option
  value is required or not, and what kind of value the option expects.
  
  Three kinds of values are supported: integer numbers, floating point
  numbers, and strings.
  
  If the option value is required, Getopt::Long will take the
  command line argument that follows the option and assign this to the
  option variable. If, however, the option value is specified as
  optional, this will only be done if that value does not look like a
  valid command line option itself.
  
      my $tag = '';	# option variable with default value
      GetOptions ('tag=s' => \$tag);
  
  In the option specification, the option name is followed by an equals
  sign C<=> and the letter C<s>. The equals sign indicates that this
  option requires a value. The letter C<s> indicates that this value is
  an arbitrary string. Other possible value types are C<i> for integer
  values, and C<f> for floating point values. Using a colon C<:> instead
  of the equals sign indicates that the option value is optional. In
  this case, if no suitable value is supplied, string valued options get
  an empty string C<''> assigned, while numeric options are set to C<0>.
  
  =head2 Options with multiple values
  
  Options sometimes take several values. For example, a program could
  use multiple directories to search for library files:
  
      --library lib/stdlib --library lib/extlib
  
  To accomplish this behaviour, simply specify an array reference as the
  destination for the option:
  
      GetOptions ("library=s" => \@libfiles);
  
  Alternatively, you can specify that the option can have multiple
  values by adding a "@", and pass a reference to a scalar as the
  destination:
  
      GetOptions ("library=s@" => \$libfiles);
  
  Used with the example above, C<@libfiles> c.q. C<@$libfiles> would
  contain two strings upon completion: C<"lib/stdlib"> and
  C<"lib/extlib">, in that order. It is also possible to specify that
  only integer or floating point numbers are acceptable values.
  
  Often it is useful to allow comma-separated lists of values as well as
  multiple occurrences of the options. This is easy using Perl's split()
  and join() operators:
  
      GetOptions ("library=s" => \@libfiles);
      @libfiles = split(/,/,join(',',@libfiles));
  
  Of course, it is important to choose the right separator string for
  each purpose.
  
  Warning: What follows is an experimental feature.
  
  Options can take multiple values at once, for example
  
      --coordinates 52.2 16.4 --rgbcolor 255 255 149
  
  This can be accomplished by adding a repeat specifier to the option
  specification. Repeat specifiers are very similar to the C<{...}>
  repeat specifiers that can be used with regular expression patterns.
  For example, the above command line would be handled as follows:
  
      GetOptions('coordinates=f{2}' => \@coor, 'rgbcolor=i{3}' => \@color);
  
  The destination for the option must be an array or array reference.
  
  It is also possible to specify the minimal and maximal number of
  arguments an option takes. C<foo=s{2,4}> indicates an option that
  takes at least two and at most 4 arguments. C<foo=s{1,}> indicates one
  or more values; C<foo:s{,}> indicates zero or more option values.
  
  =head2 Options with hash values
  
  If the option destination is a reference to a hash, the option will
  take, as value, strings of the form I<key>C<=>I<value>. The value will
  be stored with the specified key in the hash.
  
      GetOptions ("define=s" => \%defines);
  
  Alternatively you can use:
  
      GetOptions ("define=s%" => \$defines);
  
  When used with command line options:
  
      --define os=linux --define vendor=redhat
  
  the hash C<%defines> (or C<%$defines>) will contain two keys, C<"os">
  with value C<"linux"> and C<"vendor"> with value C<"redhat">. It is
  also possible to specify that only integer or floating point numbers
  are acceptable values. The keys are always taken to be strings.
  
  =head2 User-defined subroutines to handle options
  
  Ultimate control over what should be done when (actually: each time)
  an option is encountered on the command line can be achieved by
  designating a reference to a subroutine (or an anonymous subroutine)
  as the option destination. When GetOptions() encounters the option, it
  will call the subroutine with two or three arguments. The first
  argument is the name of the option. (Actually, it is an object that
  stringifies to the name of the option.) For a scalar or array destination,
  the second argument is the value to be stored. For a hash destination,
  the second argument is the key to the hash, and the third argument
  the value to be stored. It is up to the subroutine to store the value,
  or do whatever it thinks is appropriate.
  
  A trivial application of this mechanism is to implement options that
  are related to each other. For example:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose,
  	        'quiet'   => sub { $verbose = 0 });
  
  Here C<--verbose> and C<--quiet> control the same variable
  C<$verbose>, but with opposite values.
  
  If the subroutine needs to signal an error, it should call die() with
  the desired error message as its argument. GetOptions() will catch the
  die(), issue the error message, and record that an error result must
  be returned upon completion.
  
  If the text of the error message starts with an exclamation mark C<!>
  it is interpreted specially by GetOptions(). There is currently one
  special command implemented: C<die("!FINISH")> will cause GetOptions()
  to stop processing options, as if it encountered a double dash C<-->.
  
  In version 2.37 the first argument to the callback function was
  changed from string to object. This was done to make room for
  extensions and more detailed control. The object stringifies to the
  option name so this change should not introduce compatibility
  problems.
  
  Here is an example of how to access the option name and value from within
  a subroutine:
  
      GetOptions ('opt=i' => \&handler);
      sub handler {
          my ($opt_name, $opt_value) = @_;
          print("Option name is $opt_name and value is $opt_value\n");
      }
  
  =head2 Options with multiple names
  
  Often it is user friendly to supply alternate mnemonic names for
  options. For example C<--height> could be an alternate name for
  C<--length>. Alternate names can be included in the option
  specification, separated by vertical bar C<|> characters. To implement
  the above example:
  
      GetOptions ('length|height=f' => \$length);
  
  The first name is called the I<primary> name, the other names are
  called I<aliases>. When using a hash to store options, the key will
  always be the primary name.
  
  Multiple alternate names are possible.
  
  =head2 Case and abbreviations
  
  Without additional configuration, GetOptions() will ignore the case of
  option names, and allow the options to be abbreviated to uniqueness.
  
      GetOptions ('length|height=f' => \$length, "head" => \$head);
  
  This call will allow C<--l> and C<--L> for the length option, but
  requires a least C<--hea> and C<--hei> for the head and height options.
  
  =head2 Summary of Option Specifications
  
  Each option specifier consists of two parts: the name specification
  and the argument specification.
  
  The name specification contains the name of the option, optionally
  followed by a list of alternative names separated by vertical bar
  characters.
  
      length	      option name is "length"
      length|size|l     name is "length", aliases are "size" and "l"
  
  The argument specification is optional. If omitted, the option is
  considered boolean, a value of 1 will be assigned when the option is
  used on the command line.
  
  The argument specification can be
  
  =over 4
  
  =item !
  
  The option does not take an argument and may be negated by prefixing
  it with "no" or "no-". E.g. C<"foo!"> will allow C<--foo> (a value of
  1 will be assigned) as well as C<--nofoo> and C<--no-foo> (a value of
  0 will be assigned). If the option has aliases, this applies to the
  aliases as well.
  
  Using negation on a single letter option when bundling is in effect is
  pointless and will result in a warning.
  
  =item +
  
  The option does not take an argument and will be incremented by 1
  every time it appears on the command line. E.g. C<"more+">, when used
  with C<--more --more --more>, will increment the value three times,
  resulting in a value of 3 (provided it was 0 or undefined at first).
  
  The C<+> specifier is ignored if the option destination is not a scalar.
  
  =item = I<type> [ I<desttype> ] [ I<repeat> ]
  
  The option requires an argument of the given type. Supported types
  are:
  
  =over 4
  
  =item s
  
  String. An arbitrary sequence of characters. It is valid for the
  argument to start with C<-> or C<-->.
  
  =item i
  
  Integer. An optional leading plus or minus sign, followed by a
  sequence of digits.
  
  =item o
  
  Extended integer, Perl style. This can be either an optional leading
  plus or minus sign, followed by a sequence of digits, or an octal
  string (a zero, optionally followed by '0', '1', .. '7'), or a
  hexadecimal string (C<0x> followed by '0' .. '9', 'a' .. 'f', case
  insensitive), or a binary string (C<0b> followed by a series of '0'
  and '1').
  
  =item f
  
  Real number. For example C<3.14>, C<-6.23E24> and so on.
  
  =back
  
  The I<desttype> can be C<@> or C<%> to specify that the option is
  list or a hash valued. This is only needed when the destination for
  the option value is not otherwise specified. It should be omitted when
  not needed.
  
  The I<repeat> specifies the number of values this option takes per
  occurrence on the command line. It has the format C<{> [ I<min> ] [ C<,> [ I<max> ] ] C<}>.
  
  I<min> denotes the minimal number of arguments. It defaults to 1 for
  options with C<=> and to 0 for options with C<:>, see below. Note that
  I<min> overrules the C<=> / C<:> semantics.
  
  I<max> denotes the maximum number of arguments. It must be at least
  I<min>. If I<max> is omitted, I<but the comma is not>, there is no
  upper bound to the number of argument values taken.
  
  =item : I<type> [ I<desttype> ]
  
  Like C<=>, but designates the argument as optional.
  If omitted, an empty string will be assigned to string values options,
  and the value zero to numeric options.
  
  Note that if a string argument starts with C<-> or C<-->, it will be
  considered an option on itself.
  
  =item : I<number> [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the I<number> will be assigned.
  
  =item : + [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the current value for the
  option will be incremented.
  
  =back
  
  =head1 Advanced Possibilities
  
  =head2 Object oriented interface
  
  Getopt::Long can be used in an object oriented way as well:
  
      use Getopt::Long;
      $p = Getopt::Long::Parser->new;
      $p->configure(...configuration options...);
      if ($p->getoptions(...options descriptions...)) ...
      if ($p->getoptionsfromarray( \@array, ...options descriptions...)) ...
  
  Configuration options can be passed to the constructor:
  
      $p = new Getopt::Long::Parser
               config => [...configuration options...];
  
  =head2 Thread Safety
  
  Getopt::Long is thread safe when using ithreads as of Perl 5.8.  It is
  I<not> thread safe when using the older (experimental and now
  obsolete) threads implementation that was added to Perl 5.005.
  
  =head2 Documentation and help texts
  
  Getopt::Long encourages the use of Pod::Usage to produce help
  messages. For example:
  
      use Getopt::Long;
      use Pod::Usage;
  
      my $man = 0;
      my $help = 0;
  
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-exitval => 0, -verbose => 2) if $man;
  
      __END__
  
      =head1 NAME
  
      sample - Using Getopt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 8
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  See L<Pod::Usage> for details.
  
  =head2 Parsing options from an arbitrary array
  
  By default, GetOptions parses the options that are present in the
  global array C<@ARGV>. A special entry C<GetOptionsFromArray> can be
  used to parse options from an arbitrary array.
  
      use Getopt::Long qw(GetOptionsFromArray);
      $ret = GetOptionsFromArray(\@myopts, ...);
  
  When used like this, options and their possible values are removed
  from C<@myopts>, the global C<@ARGV> is not touched at all.
  
  The following two calls behave identically:
  
      $ret = GetOptions( ... );
      $ret = GetOptionsFromArray(\@ARGV, ... );
  
  This also means that a first argument hash reference now becomes the
  second argument:
  
      $ret = GetOptions(\%opts, ... );
      $ret = GetOptionsFromArray(\@ARGV, \%opts, ... );
  
  =head2 Parsing options from an arbitrary string
  
  A special entry C<GetOptionsFromString> can be used to parse options
  from an arbitrary string.
  
      use Getopt::Long qw(GetOptionsFromString);
      $ret = GetOptionsFromString($string, ...);
  
  The contents of the string are split into arguments using a call to
  C<Text::ParseWords::shellwords>. As with C<GetOptionsFromArray>, the
  global C<@ARGV> is not touched.
  
  It is possible that, upon completion, not all arguments in the string
  have been processed. C<GetOptionsFromString> will, when called in list
  context, return both the return status and an array reference to any
  remaining arguments:
  
      ($ret, $args) = GetOptionsFromString($string, ... );
  
  If any arguments remain, and C<GetOptionsFromString> was not called in
  list context, a message will be given and C<GetOptionsFromString> will
  return failure.
  
  As with GetOptionsFromArray, a first argument hash reference now
  becomes the second argument.
  
  =head2 Storing options values in a hash
  
  Sometimes, for example when there are a lot of options, having a
  separate variable for each of them can be cumbersome. GetOptions()
  supports, as an alternative mechanism, storing options values in a
  hash.
  
  To obtain this, a reference to a hash must be passed I<as the first
  argument> to GetOptions(). For each option that is specified on the
  command line, the option value will be stored in the hash with the
  option name as key. Options that are not actually used on the command
  line will not be put in the hash, on other words,
  C<exists($h{option})> (or defined()) can be used to test if an option
  was used. The drawback is that warnings will be issued if the program
  runs under C<use strict> and uses C<$h{option}> without testing with
  exists() or defined() first.
  
      my %h = ();
      GetOptions (\%h, 'length=i');	# will store in $h{length}
  
  For options that take list or hash values, it is necessary to indicate
  this by appending an C<@> or C<%> sign after the type:
  
      GetOptions (\%h, 'colours=s@');	# will push to @{$h{colours}}
  
  To make things more complicated, the hash may contain references to
  the actual destinations, for example:
  
      my $len = 0;
      my %h = ('length' => \$len);
      GetOptions (\%h, 'length=i');	# will store in $len
  
  This example is fully equivalent with:
  
      my $len = 0;
      GetOptions ('length=i' => \$len);	# will store in $len
  
  Any mixture is possible. For example, the most frequently used options
  could be stored in variables while all other options get stored in the
  hash:
  
      my $verbose = 0;			# frequently referred
      my $debug = 0;			# frequently referred
      my %h = ('verbose' => \$verbose, 'debug' => \$debug);
      GetOptions (\%h, 'verbose', 'debug', 'filter', 'size=i');
      if ( $verbose ) { ... }
      if ( exists $h{filter} ) { ... option 'filter' was specified ... }
  
  =head2 Bundling
  
  With bundling it is possible to set several single-character options
  at once. For example if C<a>, C<v> and C<x> are all valid options,
  
      -vax
  
  will set all three.
  
  Getopt::Long supports three styles of bundling. To enable bundling, a
  call to Getopt::Long::Configure is required.
  
  The simplest style of bundling can be enabled with:
  
      Getopt::Long::Configure ("bundling");
  
  Configured this way, single-character options can be bundled but long
  options B<must> always start with a double dash C<--> to avoid
  ambiguity. For example, when C<vax>, C<a>, C<v> and C<x> are all valid
  options,
  
      -vax
  
  will set C<a>, C<v> and C<x>, but
  
      --vax
  
  will set C<vax>.
  
  The second style of bundling lifts this restriction. It can be enabled
  with:
  
      Getopt::Long::Configure ("bundling_override");
  
  Now, C<-vax> will set the option C<vax>.
  
  In all of the above cases, option values may be inserted in the
  bundle. For example:
  
      -h24w80
  
  is equivalent to
  
      -h 24 -w 80
  
  A third style of bundling allows only values to be bundled with
  options. It can be enabled with:
  
      Getopt::Long::Configure ("bundling_values");
  
  Now, C<-h24> will set the option C<h> to C<24>, but option bundles
  like C<-vxa> and C<-h24w80> are flagged as errors.
  
  Enabling C<bundling_values> will disable the other two styles of
  bundling.
  
  When configured for bundling, single-character options are matched
  case sensitive while long options are matched case insensitive. To
  have the single-character options matched case insensitive as well,
  use:
  
      Getopt::Long::Configure ("bundling", "ignorecase_always");
  
  It goes without saying that bundling can be quite confusing.
  
  =head2 The lonesome dash
  
  Normally, a lone dash C<-> on the command line will not be considered
  an option. Option processing will terminate (unless "permute" is
  configured) and the dash will be left in C<@ARGV>.
  
  It is possible to get special treatment for a lone dash. This can be
  achieved by adding an option specification with an empty name, for
  example:
  
      GetOptions ('' => \$stdio);
  
  A lone dash on the command line will now be a legal option, and using
  it will set variable C<$stdio>.
  
  =head2 Argument callback
  
  A special option 'name' C<< <> >> can be used to designate a subroutine
  to handle non-option arguments. When GetOptions() encounters an
  argument that does not look like an option, it will immediately call this
  subroutine and passes it one parameter: the argument name. Well, actually
  it is an object that stringifies to the argument name.
  
  For example:
  
      my $width = 80;
      sub process { ... }
      GetOptions ('width=i' => \$width, '<>' => \&process);
  
  When applied to the following command line:
  
      arg1 --width=72 arg2 --width=60 arg3
  
  This will call
  C<process("arg1")> while C<$width> is C<80>,
  C<process("arg2")> while C<$width> is C<72>, and
  C<process("arg3")> while C<$width> is C<60>.
  
  This feature requires configuration option B<permute>, see section
  L<Configuring Getopt::Long>.
  
  =head1 Configuring Getopt::Long
  
  Getopt::Long can be configured by calling subroutine
  Getopt::Long::Configure(). This subroutine takes a list of quoted
  strings, each specifying a configuration option to be enabled, e.g.
  C<ignore_case>, or disabled, e.g. C<no_ignore_case>. Case does not
  matter. Multiple calls to Configure() are possible.
  
  Alternatively, as of version 2.24, the configuration options may be
  passed together with the C<use> statement:
  
      use Getopt::Long qw(:config no_ignore_case bundling);
  
  The following options are available:
  
  =over 12
  
  =item default
  
  This option causes all configuration options to be reset to their
  default values.
  
  =item posix_default
  
  This option causes all configuration options to be reset to their
  default values as if the environment variable POSIXLY_CORRECT had
  been set.
  
  =item auto_abbrev
  
  Allow option names to be abbreviated to uniqueness.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is disabled.
  
  =item getopt_compat
  
  Allow C<+> to start options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<getopt_compat> is disabled.
  
  =item gnu_compat
  
  C<gnu_compat> controls whether C<--opt=> is allowed, and what it should
  do. Without C<gnu_compat>, C<--opt=> gives an error. With C<gnu_compat>,
  C<--opt=> will give option C<opt> and empty value.
  This is the way GNU getopt_long() does it.
  
  Note that C<--opt value> is still accepted, even though GNU
  getopt_long() doesn't.
  
  =item gnu_getopt
  
  This is a short way of setting C<gnu_compat> C<bundling> C<permute>
  C<no_getopt_compat>. With C<gnu_getopt>, command line handling should be
  reasonably compatible with GNU getopt_long().
  
  =item require_order
  
  Whether command line arguments are allowed to be mixed with options.
  Default is disabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<require_order> is enabled.
  
  See also C<permute>, which is the opposite of C<require_order>.
  
  =item permute
  
  Whether command line arguments are allowed to be mixed with options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<permute> is disabled.
  Note that C<permute> is the opposite of C<require_order>.
  
  If C<permute> is enabled, this means that
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo --bar arg1 arg2 arg3
  
  If an argument callback routine is specified, C<@ARGV> will always be
  empty upon successful return of GetOptions() since all options have been
  processed. The only exception is when C<--> is used:
  
      --foo arg1 --bar arg2 -- arg3
  
  This will call the callback routine for arg1 and arg2, and then
  terminate GetOptions() leaving C<"arg3"> in C<@ARGV>.
  
  If C<require_order> is enabled, options processing
  terminates when the first non-option is encountered.
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo -- arg1 --bar arg2 arg3
  
  If C<pass_through> is also enabled, options processing will terminate
  at the first unrecognized option, or non-option, whichever comes
  first.
  
  =item bundling (default: disabled)
  
  Enabling this option will allow single-character options to be
  bundled. To distinguish bundles from long option names, long options
  I<must> be introduced with C<--> and bundles with C<->.
  
  Note that, if you have options C<a>, C<l> and C<all>, and
  auto_abbrev enabled, possible arguments and option settings are:
  
      using argument               sets option(s)
      ------------------------------------------
      -a, --a                      a
      -l, --l                      l
      -al, -la, -ala, -all,...     a, l
      --al, --all                  all
  
  The surprising part is that C<--a> sets option C<a> (due to auto
  completion), not C<all>.
  
  Note: disabling C<bundling> also disables C<bundling_override>.
  
  =item bundling_override (default: disabled)
  
  If C<bundling_override> is enabled, bundling is enabled as with
  C<bundling> but now long option names override option bundles.
  
  Note: disabling C<bundling_override> also disables C<bundling>.
  
  B<Note:> Using option bundling can easily lead to unexpected results,
  especially when mixing long options and bundles. Caveat emptor.
  
  =item ignore_case  (default: enabled)
  
  If enabled, case is ignored when matching option names. If, however,
  bundling is enabled as well, single character options will be treated
  case-sensitive.
  
  With C<ignore_case>, option specifications for options that only
  differ in case, e.g., C<"foo"> and C<"Foo">, will be flagged as
  duplicates.
  
  Note: disabling C<ignore_case> also disables C<ignore_case_always>.
  
  =item ignore_case_always (default: disabled)
  
  When bundling is in effect, case is ignored on single-character
  options also.
  
  Note: disabling C<ignore_case_always> also disables C<ignore_case>.
  
  =item auto_version (default:disabled)
  
  Automatically provide support for the B<--version> option if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a standard version message that includes the
  program name, its version (if $main::VERSION is defined), and the
  versions of Getopt::Long and Perl. The message will be written to
  standard output and processing will terminate.
  
  C<auto_version> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item auto_help (default:disabled)
  
  Automatically provide support for the B<--help> and B<-?> options if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a help message using module L<Pod::Usage>. The
  message, derived from the SYNOPSIS POD section, will be written to
  standard output and processing will terminate.
  
  C<auto_help> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item pass_through (default: disabled)
  
  With C<pass_through> anything that is unknown, ambiguous or supplied with
  an invalid option will not be flagged as an error. Instead the unknown
  option(s) will be passed to the catchall C<< <> >> if present, otherwise
  through to C<@ARGV>. This makes it possible to write wrapper scripts that
  process only part of the user supplied command line arguments, and pass the
  remaining options to some other program.
  
  If C<require_order> is enabled, options processing will terminate at the
  first unrecognized option, or non-option, whichever comes first and all
  remaining arguments are passed to C<@ARGV> instead of the catchall
  C<< <> >> if present.  However, if C<permute> is enabled instead, results
  can become confusing.
  
  Note that the options terminator (default C<-->), if present, will
  also be passed through in C<@ARGV>.
  
  =item prefix
  
  The string that starts options. If a constant string is not
  sufficient, see C<prefix_pattern>.
  
  =item prefix_pattern
  
  A Perl pattern that identifies the strings that introduce options.
  Default is C<--|-|\+> unless environment variable
  POSIXLY_CORRECT has been set, in which case it is C<--|->.
  
  =item long_prefix_pattern
  
  A Perl pattern that allows the disambiguation of long and short
  prefixes. Default is C<-->.
  
  Typically you only need to set this if you are using nonstandard
  prefixes and want some or all of them to have the same semantics as
  '--' does under normal circumstances.
  
  For example, setting prefix_pattern to C<--|-|\+|\/> and
  long_prefix_pattern to C<--|\/> would add Win32 style argument
  handling.
  
  =item debug (default: disabled)
  
  Enable debugging output.
  
  =back
  
  =head1 Exportable Methods
  
  =over
  
  =item VersionMessage
  
  This subroutine provides a standard version message. Its argument can be:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the standard message.
  
  =item *
  
  A numeric value corresponding to the desired exit status.
  
  =item *
  
  A reference to a hash.
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message>
  
  =item C<-msg>
  
  The text of a message to print immediately prior to printing the
  program's usage message.
  
  =item C<-exitval>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string "NOEXIT" to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-output>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =back
  
  You cannot tie this routine directly to an option, e.g.:
  
      GetOptions("version" => \&VersionMessage);
  
  Use this instead:
  
      GetOptions("version" => sub { VersionMessage() });
  
  =item HelpMessage
  
  This subroutine produces a standard help message, derived from the
  program's POD section SYNOPSIS using L<Pod::Usage>. It takes the same
  arguments as VersionMessage(). In particular, you cannot tie it
  directly to an option, e.g.:
  
      GetOptions("help" => \&HelpMessage);
  
  Use this instead:
  
      GetOptions("help" => sub { HelpMessage() });
  
  =back
  
  =head1 Return values and Errors
  
  Configuration errors and errors in the option definitions are
  signalled using die() and will terminate the calling program unless
  the call to Getopt::Long::GetOptions() was embedded in C<eval { ...
  }>, or die() was trapped using C<$SIG{__DIE__}>.
  
  GetOptions returns true to indicate success.
  It returns false when the function detected one or more errors during
  option parsing. These errors are signalled using warn() and can be
  trapped with C<$SIG{__WARN__}>.
  
  =head1 Legacy
  
  The earliest development of C<newgetopt.pl> started in 1990, with Perl
  version 4. As a result, its development, and the development of
  Getopt::Long, has gone through several stages. Since backward
  compatibility has always been extremely important, the current version
  of Getopt::Long still supports a lot of constructs that nowadays are
  no longer necessary or otherwise unwanted. This section describes
  briefly some of these 'features'.
  
  =head2 Default destinations
  
  When no destination is specified for an option, GetOptions will store
  the resultant value in a global variable named C<opt_>I<XXX>, where
  I<XXX> is the primary name of this option. When a program executes
  under C<use strict> (recommended), these variables must be
  pre-declared with our() or C<use vars>.
  
      our $opt_length = 0;
      GetOptions ('length=i');	# will store in $opt_length
  
  To yield a usable Perl variable, characters that are not part of the
  syntax for variables are translated to underscores. For example,
  C<--fpp-struct-return> will set the variable
  C<$opt_fpp_struct_return>. Note that this variable resides in the
  namespace of the calling program, not necessarily C<main>. For
  example:
  
      GetOptions ("size=i", "sizes=i@");
  
  with command line "-size 10 -sizes 24 -sizes 48" will perform the
  equivalent of the assignments
  
      $opt_size = 10;
      @opt_sizes = (24, 48);
  
  =head2 Alternative option starters
  
  A string of alternative option starter characters may be passed as the
  first argument (or the first argument after a leading hash reference
  argument).
  
      my $len = 0;
      GetOptions ('/', 'length=i' => $len);
  
  Now the command line may look like:
  
      /length 24 -- arg
  
  Note that to terminate options processing still requires a double dash
  C<-->.
  
  GetOptions() will not interpret a leading C<< "<>" >> as option starters
  if the next argument is a reference. To force C<< "<" >> and C<< ">" >> as
  option starters, use C<< "><" >>. Confusing? Well, B<using a starter
  argument is strongly deprecated> anyway.
  
  =head2 Configuration variables
  
  Previous versions of Getopt::Long used variables for the purpose of
  configuring. Although manipulating these variables still work, it is
  strongly encouraged to use the C<Configure> routine that was introduced
  in version 2.17. Besides, it is much easier.
  
  =head1 Tips and Techniques
  
  =head2 Pushing multiple values in a hash option
  
  Sometimes you want to combine the best of hashes and arrays. For
  example, the command line:
  
    --list add=first --list add=second --list add=third
  
  where each successive 'list add' option will push the value of add
  into array ref $list->{'add'}. The result would be like
  
    $list->{add} = [qw(first second third)];
  
  This can be accomplished with a destination routine:
  
    GetOptions('list=s%' =>
                 sub { push(@{$list{$_[1]}}, $_[2]) });
  
  =head1 Troubleshooting
  
  =head2 GetOptions does not return a false result when an option is not supplied
  
  That's why they're called 'options'.
  
  =head2 GetOptions does not split the command line correctly
  
  The command line is not split by GetOptions, but by the command line
  interpreter (CLI). On Unix, this is the shell. On Windows, it is
  COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.
  
  It is important to know that these CLIs may behave different when the
  command line contains special characters, in particular quotes or
  backslashes. For example, with Unix shells you can use single quotes
  (C<'>) and double quotes (C<">) to group words together. The following
  alternatives are equivalent on Unix:
  
      "two words"
      'two words'
      two\ words
  
  In case of doubt, insert the following statement in front of your Perl
  program:
  
      print STDERR (join("|",@ARGV),"\n");
  
  to verify how your CLI passes the arguments to the program.
  
  =head2 Undefined subroutine &main::GetOptions called
  
  Are you running Windows, and did you write
  
      use GetOpt::Long;
  
  (note the capital 'O')?
  
  =head2 How do I put a "-?" option into a Getopt::Long?
  
  You can only obtain this using an alias, and Getopt::Long of at least
  version 2.13.
  
      use Getopt::Long;
      GetOptions ("help|?");    # -help and -? will both set $opt_help
  
  Other characters that can't appear in Perl identifiers are also supported
  as aliases with Getopt::Long of at least version 2.39.
  
  As of version 2.32 Getopt::Long provides auto-help, a quick and easy way
  to add the options --help and -? to your program, and handle them.
  
  See C<auto_help> in section L<Configuring Getopt::Long>.
  
  =head1 AUTHOR
  
  Johan Vromans <jvromans@squirrel.nl>
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  This program is Copyright 1990,2015 by Johan Vromans.
  This program is free software; you can redistribute it and/or
  modify it under the terms of the Perl Artistic License or the
  GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any
  later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  If you do not have a copy of the GNU General Public License write to
  the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
  MA 02139, USA.
  
  =cut
  
GETOPT_LONG

$fatpacked{"TAP/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_BASE';
  package TAP::Base;
  
  use strict;
  use warnings;
  
  use base 'TAP::Object';
  
  =head1 NAME
  
  TAP::Base - Base class that provides common functionality to L<TAP::Parser>
  and L<TAP::Harness>
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  use constant GOT_TIME_HIRES => do {
      eval 'use Time::HiRes qw(time);';
      $@ ? 0 : 1;
  };
  
  =head1 SYNOPSIS
  
      package TAP::Whatever;
  
      use base 'TAP::Base';
  
      # ... later ...
      
      my $thing = TAP::Whatever->new();
      
      $thing->callback( event => sub {
          # do something interesting
      } );
  
  =head1 DESCRIPTION
  
  C<TAP::Base> provides callback management.
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =cut
  
  sub _initialize {
      my ( $self, $arg_for, $ok_callback ) = @_;
  
      my %ok_map = map { $_ => 1 } @$ok_callback;
  
      $self->{ok_callbacks} = \%ok_map;
  
      if ( my $cb = delete $arg_for->{callbacks} ) {
          while ( my ( $event, $callback ) = each %$cb ) {
              $self->callback( $event, $callback );
          }
      }
  
      return $self;
  }
  
  =head3 C<callback>
  
  Install a callback for a named event.
  
  =cut
  
  sub callback {
      my ( $self, $event, $callback ) = @_;
  
      my %ok_map = %{ $self->{ok_callbacks} };
  
      $self->_croak('No callbacks may be installed')
        unless %ok_map;
  
      $self->_croak( "Callback $event is not supported. Valid callbacks are "
            . join( ', ', sort keys %ok_map ) )
        unless exists $ok_map{$event};
  
      push @{ $self->{code_for}{$event} }, $callback;
  
      return;
  }
  
  sub _has_callbacks {
      my $self = shift;
      return keys %{ $self->{code_for} } != 0;
  }
  
  sub _callback_for {
      my ( $self, $event ) = @_;
      return $self->{code_for}{$event};
  }
  
  sub _make_callback {
      my $self  = shift;
      my $event = shift;
  
      my $cb = $self->_callback_for($event);
      return unless defined $cb;
      return map { $_->(@_) } @$cb;
  }
  
  =head3 C<get_time>
  
  Return the current time using Time::HiRes if available.
  
  =cut
  
  sub get_time { return time() }
  
  =head3 C<time_is_hires>
  
  Return true if the time returned by get_time is high resolution (i.e. if Time::HiRes is available).
  
  =cut
  
  sub time_is_hires { return GOT_TIME_HIRES }
  
  =head3 C<get_times>
  
  Return array reference of the four-element list of CPU seconds,
  as with L<perlfunc/times>.
  
  =cut
  
  sub get_times { return [ times() ] }
  
  1;
TAP_BASE

$fatpacked{"TAP/Formatter/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_BASE';
  package TAP::Formatter::Base;
  
  use strict;
  use warnings;
  use base 'TAP::Base';
  use POSIX qw(strftime);
  
  my $MAX_ERRORS = 5;
  my %VALIDATION_FOR;
  
  BEGIN {
      %VALIDATION_FOR = (
          directives => sub { shift; shift },
          verbosity  => sub { shift; shift },
          normalize  => sub { shift; shift },
          timer      => sub { shift; shift },
          failures   => sub { shift; shift },
          comments   => sub { shift; shift },
          errors     => sub { shift; shift },
          color      => sub { shift; shift },
          jobs       => sub { shift; shift },
          show_count => sub { shift; shift },
          stdout     => sub {
              my ( $self, $ref ) = @_;
  
              $self->_croak("option 'stdout' needs a filehandle")
                unless $self->_is_filehandle($ref);
  
              return $ref;
          },
      );
  
      sub _is_filehandle {
          my ( $self, $ref ) = @_;
  
          return 0 if !defined $ref;
  
          return 1 if ref $ref eq 'GLOB';    # lexical filehandle
          return 1 if !ref $ref && ref \$ref eq 'GLOB'; # bare glob like *STDOUT
  
          return 1 if eval { $ref->can('print') };
  
          return 0;
      }
  
      my @getter_setters = qw(
        _longest
        _printed_summary_header
        _colorizer
      );
  
      __PACKAGE__->mk_methods( @getter_setters, keys %VALIDATION_FOR );
  }
  
  =head1 NAME
  
  TAP::Formatter::Base - Base class for harness output delegates
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 DESCRIPTION
  
  This provides console orientated output formatting for TAP::Harness.
  
  =head1 SYNOPSIS
  
   use TAP::Formatter::Console;
   my $harness = TAP::Formatter::Console->new( \%args );
  
  =cut
  
  sub _initialize {
      my ( $self, $arg_for ) = @_;
      $arg_for ||= {};
  
      $self->SUPER::_initialize($arg_for);
      my %arg_for = %$arg_for;    # force a shallow copy
  
      $self->verbosity(0);
  
      for my $name ( keys %VALIDATION_FOR ) {
          my $property = delete $arg_for{$name};
          if ( defined $property ) {
              my $validate = $VALIDATION_FOR{$name};
              $self->$name( $self->$validate($property) );
          }
      }
  
      if ( my @props = keys %arg_for ) {
          $self->_croak(
              "Unknown arguments to " . __PACKAGE__ . "::new (@props)" );
      }
  
      $self->stdout( \*STDOUT ) unless $self->stdout;
  
      if ( $self->color ) {
          require TAP::Formatter::Color;
          $self->_colorizer( TAP::Formatter::Color->new );
      }
  
      return $self;
  }
  
  sub verbose      { shift->verbosity >= 1 }
  sub quiet        { shift->verbosity <= -1 }
  sub really_quiet { shift->verbosity <= -2 }
  sub silent       { shift->verbosity <= -3 }
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
   my %args = (
      verbose => 1,
   )
   my $harness = TAP::Formatter::Console->new( \%args );
  
  The constructor returns a new C<TAP::Formatter::Console> object. If
  a L<TAP::Harness> is created with no C<formatter> a
  C<TAP::Formatter::Console> is automatically created. If any of the
  following options were given to TAP::Harness->new they well be passed to
  this constructor which accepts an optional hashref whose allowed keys are:
  
  =over 4
  
  =item * C<verbosity>
  
  Set the verbosity level.
  
  =item * C<verbose>
  
  Printing individual test results to STDOUT.
  
  =item * C<timer>
  
  Append run time for each test to output. Uses L<Time::HiRes> if available.
  
  =item * C<failures>
  
  Show test failures (this is a no-op if C<verbose> is selected).
  
  =item * C<comments>
  
  Show test comments (this is a no-op if C<verbose> is selected).
  
  =item * C<quiet>
  
  Suppressing some test output (mostly failures while tests are running).
  
  =item * C<really_quiet>
  
  Suppressing everything but the tests summary.
  
  =item * C<silent>
  
  Suppressing all output.
  
  =item * C<errors>
  
  If parse errors are found in the TAP output, a note of this will be made
  in the summary report.  To see all of the parse errors, set this argument to
  true:
  
    errors => 1
  
  =item * C<directives>
  
  If set to a true value, only test results with directives will be displayed.
  This overrides other settings such as C<verbose>, C<failures>, or C<comments>.
  
  =item * C<stdout>
  
  A filehandle for catching standard output.
  
  =item * C<color>
  
  If defined specifies whether color output is desired. If C<color> is not
  defined it will default to color output if color support is available on
  the current platform and output is not being redirected.
  
  =item * C<jobs>
  
  The number of concurrent jobs this formatter will handle.
  
  =item * C<show_count>
  
  Boolean value.  If false, disables the C<X/Y> test count which shows up while
  tests are running.
  
  =back
  
  Any keys for which the value is C<undef> will be ignored.
  
  =cut
  
  # new supplied by TAP::Base
  
  =head3 C<prepare>
  
  Called by Test::Harness before any test output is generated. 
  
  This is an advisory and may not be called in the case where tests are
  being supplied to Test::Harness by an iterator.
  
  =cut
  
  sub prepare {
      my ( $self, @tests ) = @_;
  
      my $longest = 0;
  
      for my $test (@tests) {
          $longest = length $test if length $test > $longest;
      }
  
      $self->_longest($longest);
  }
  
  sub _format_now { strftime "[%H:%M:%S]", localtime }
  
  sub _format_name {
      my ( $self, $test ) = @_;
      my $name = $test;
      my $periods = '.' x ( $self->_longest + 2 - length $test );
      $periods = " $periods ";
  
      if ( $self->timer ) {
          my $stamp = $self->_format_now();
          return "$stamp $name$periods";
      }
      else {
          return "$name$periods";
      }
  
  }
  
  =head3 C<open_test>
  
  Called to create a new test session. A test session looks like this:
  
      my $session = $formatter->open_test( $test, $parser );
      while ( defined( my $result = $parser->next ) ) {
          $session->result($result);
          exit 1 if $result->is_bailout;
      }
      $session->close_test;
  
  =cut
  
  sub open_test {
      die "Unimplemented.";
  }
  
  sub _output_success {
      my ( $self, $msg ) = @_;
      $self->_output($msg);
  }
  
  =head3 C<summary>
  
    $harness->summary( $aggregate );
  
  C<summary> prints the summary report after all tests are run. The first
  argument is an aggregate to summarise. An optional second argument may
  be set to a true value to indicate that the summary is being output as a
  result of an interrupted test run.
  
  =cut
  
  sub summary {
      my ( $self, $aggregate, $interrupted ) = @_;
  
      return if $self->silent;
  
      my @t     = $aggregate->descriptions;
      my $tests = \@t;
  
      my $runtime = $aggregate->elapsed_timestr;
  
      my $total  = $aggregate->total;
      my $passed = $aggregate->passed;
  
      if ( $self->timer ) {
          $self->_output( $self->_format_now(), "\n" );
      }
  
      $self->_failure_output("Test run interrupted!\n")
        if $interrupted;
  
      # TODO: Check this condition still works when all subtests pass but
      # the exit status is nonzero
  
      if ( $aggregate->all_passed ) {
          $self->_output_success("All tests successful.\n");
      }
  
      # ~TODO option where $aggregate->skipped generates reports
      if ( $total != $passed or $aggregate->has_problems ) {
          $self->_output("\nTest Summary Report");
          $self->_output("\n-------------------\n");
          for my $test (@$tests) {
              $self->_printed_summary_header(0);
              my ($parser) = $aggregate->parsers($test);
              $self->_output_summary_failure(
                  'failed',
                  [ '  Failed test:  ', '  Failed tests:  ' ],
                  $test, $parser
              );
              $self->_output_summary_failure(
                  'todo_passed',
                  "  TODO passed:   ", $test, $parser
              );
  
              # ~TODO this cannot be the default
              #$self->_output_summary_failure( 'skipped', "  Tests skipped: " );
  
              if ( my $exit = $parser->exit ) {
                  $self->_summary_test_header( $test, $parser );
                  $self->_failure_output("  Non-zero exit status: $exit\n");
              }
              elsif ( my $wait = $parser->wait ) {
                  $self->_summary_test_header( $test, $parser );
                  $self->_failure_output("  Non-zero wait status: $wait\n");
              }
  
              if ( my @errors = $parser->parse_errors ) {
                  my $explain;
                  if ( @errors > $MAX_ERRORS && !$self->errors ) {
                      $explain
                        = "Displayed the first $MAX_ERRORS of "
                        . scalar(@errors)
                        . " TAP syntax errors.\n"
                        . "Re-run prove with the -p option to see them all.\n";
                      splice @errors, $MAX_ERRORS;
                  }
                  $self->_summary_test_header( $test, $parser );
                  $self->_failure_output(
                      sprintf "  Parse errors: %s\n",
                      shift @errors
                  );
                  for my $error (@errors) {
                      my $spaces = ' ' x 16;
                      $self->_failure_output("$spaces$error\n");
                  }
                  $self->_failure_output($explain) if $explain;
              }
          }
      }
      my $files = @$tests;
      $self->_output("Files=$files, Tests=$total, $runtime\n");
      my $status = $aggregate->get_status;
      $self->_output("Result: $status\n");
  }
  
  sub _output_summary_failure {
      my ( $self, $method, $name, $test, $parser ) = @_;
  
      # ugly hack.  Must rethink this :(
      my $output = $method eq 'failed' ? '_failure_output' : '_output';
  
      if ( my @r = $parser->$method() ) {
          $self->_summary_test_header( $test, $parser );
          my ( $singular, $plural )
            = 'ARRAY' eq ref $name ? @$name : ( $name, $name );
          $self->$output( @r == 1 ? $singular : $plural );
          my @results = $self->_balanced_range( 40, @r );
          $self->$output( sprintf "%s\n" => shift @results );
          my $spaces = ' ' x 16;
          while (@results) {
              $self->$output( sprintf "$spaces%s\n" => shift @results );
          }
      }
  }
  
  sub _summary_test_header {
      my ( $self, $test, $parser ) = @_;
      return if $self->_printed_summary_header;
      my $spaces = ' ' x ( $self->_longest - length $test );
      $spaces = ' ' unless $spaces;
      my $output = $self->_get_output_method($parser);
      my $wait   = $parser->wait;
      defined $wait or $wait = '(none)';
      $self->$output(
          sprintf "$test$spaces(Wstat: %s Tests: %d Failed: %d)\n",
          $wait, $parser->tests_run, scalar $parser->failed
      );
      $self->_printed_summary_header(1);
  }
  
  sub _output {
      my $self = shift;
  
      print { $self->stdout } @_;
  }
  
  sub _failure_output {
      my $self = shift;
  
      $self->_output(@_);
  }
  
  sub _balanced_range {
      my ( $self, $limit, @range ) = @_;
      @range = $self->_range(@range);
      my $line = "";
      my @lines;
      my $curr = 0;
      while (@range) {
          if ( $curr < $limit ) {
              my $range = ( shift @range ) . ", ";
              $line .= $range;
              $curr += length $range;
          }
          elsif (@range) {
              $line =~ s/, $//;
              push @lines => $line;
              $line = '';
              $curr = 0;
          }
      }
      if ($line) {
          $line =~ s/, $//;
          push @lines => $line;
      }
      return @lines;
  }
  
  sub _range {
      my ( $self, @numbers ) = @_;
  
      # shouldn't be needed, but subclasses might call this
      @numbers = sort { $a <=> $b } @numbers;
      my ( $min, @range );
  
      for my $i ( 0 .. $#numbers ) {
          my $num  = $numbers[$i];
          my $next = $numbers[ $i + 1 ];
          if ( defined $next && $next == $num + 1 ) {
              if ( !defined $min ) {
                  $min = $num;
              }
          }
          elsif ( defined $min ) {
              push @range => "$min-$num";
              undef $min;
          }
          else {
              push @range => $num;
          }
      }
      return @range;
  }
  
  sub _get_output_method {
      my ( $self, $parser ) = @_;
      return $parser->has_problems ? '_failure_output' : '_output';
  }
  
  1;
TAP_FORMATTER_BASE

$fatpacked{"TAP/Formatter/Color.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_COLOR';
  package TAP::Formatter::Color;
  
  use strict;
  use warnings;
  
  use constant IS_WIN32 => ( $^O =~ /^(MS)?Win32$/ );
  
  use base 'TAP::Object';
  
  my $NO_COLOR;
  
  BEGIN {
      $NO_COLOR = 0;
  
      eval 'require Term::ANSIColor';
      if ($@) {
          $NO_COLOR = $@;
      };
      if (IS_WIN32) {
          eval 'use Win32::Console::ANSI';
          if ($@) {
              $NO_COLOR = $@;
          }
      };
  
      if ($NO_COLOR) {
          *set_color = sub { };
      } else {
          *set_color = sub {
              my ( $self, $output, $color ) = @_;
              $output->( Term::ANSIColor::color($color) );
          };
      }
  }
  
  =head1 NAME
  
  TAP::Formatter::Color - Run Perl test scripts with color
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 DESCRIPTION
  
  Note that this harness is I<experimental>.  You may not like the colors I've
  chosen and I haven't yet provided an easy way to override them.
  
  This test harness is the same as L<TAP::Harness>, but test results are output
  in color.  Passing tests are printed in green.  Failing tests are in red.
  Skipped tests are blue on a white background and TODO tests are printed in
  white.
  
  If L<Term::ANSIColor> cannot be found (and L<Win32::Console::ANSI> if running
  under Windows) tests will be run without color.
  
  =head1 SYNOPSIS
  
   use TAP::Formatter::Color;
   my $harness = TAP::Formatter::Color->new( \%args );
   $harness->runtests(@tests);
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
  The constructor returns a new C<TAP::Formatter::Color> object. If
  L<Term::ANSIColor> is not installed, returns undef.
  
  =cut
  
  # new() implementation supplied by TAP::Object
  
  sub _initialize {
      my $self = shift;
  
      if ($NO_COLOR) {
  
          # shorten that message a bit
          ( my $error = $NO_COLOR ) =~ s/ in \@INC .*//s;
          warn "Note: Cannot run tests in color: $error\n";
          return;    # abort object construction
      }
  
      return $self;
  }
  
  ##############################################################################
  
  =head3 C<can_color>
  
    Test::Formatter::Color->can_color()
  
  Returns a boolean indicating whether or not this module can actually
  generate colored output. This will be false if it could not load the
  modules needed for the current platform.
  
  =cut
  
  sub can_color {
      return !$NO_COLOR;
  }
  
  =head3 C<set_color>
  
  Set the output color.
  
  =cut
  
  1;
TAP_FORMATTER_COLOR

$fatpacked{"TAP/Formatter/Console.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_CONSOLE';
  package TAP::Formatter::Console;
  
  use strict;
  use warnings;
  use base 'TAP::Formatter::Base';
  use POSIX qw(strftime);
  
  =head1 NAME
  
  TAP::Formatter::Console - Harness output delegate for default console output
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 DESCRIPTION
  
  This provides console orientated output formatting for TAP::Harness.
  
  =head1 SYNOPSIS
  
   use TAP::Formatter::Console;
   my $harness = TAP::Formatter::Console->new( \%args );
  
  =head2 C<< open_test >>
  
  See L<TAP::Formatter::Base>
  
  =cut
  
  sub open_test {
      my ( $self, $test, $parser ) = @_;
  
      my $class
        = $self->jobs > 1
        ? 'TAP::Formatter::Console::ParallelSession'
        : 'TAP::Formatter::Console::Session';
  
      eval "require $class";
      $self->_croak($@) if $@;
  
      my $session = $class->new(
          {   name       => $test,
              formatter  => $self,
              parser     => $parser,
              show_count => $self->show_count,
          }
      );
  
      $session->header;
  
      return $session;
  }
  
  # Use _colorizer delegate to set output color. NOP if we have no delegate
  sub _set_colors {
      my ( $self, @colors ) = @_;
      if ( my $colorizer = $self->_colorizer ) {
          my $output_func = $self->{_output_func} ||= sub {
              $self->_output(@_);
          };
          $colorizer->set_color( $output_func, $_ ) for @colors;
      }
  }
  
  sub _failure_color {
      my ($self) = @_;
  
      return $ENV{'HARNESS_SUMMARY_COLOR_FAIL'} || 'red';
  }
  
  sub _success_color {
      my ($self) = @_;
  
      return $ENV{'HARNESS_SUMMARY_COLOR_SUCCESS'} || 'green';
  }
  
  sub _output_success {
      my ( $self, $msg ) = @_;
      $self->_set_colors( $self->_success_color() );
      $self->_output($msg);
      $self->_set_colors('reset');
  }
  
  sub _failure_output {
      my $self = shift;
      $self->_set_colors( $self->_failure_color() );
      my $out = join '', @_;
      my $has_newline = chomp $out;
      $self->_output($out);
      $self->_set_colors('reset');
      $self->_output($/)
        if $has_newline;
  }
  
  1;
TAP_FORMATTER_CONSOLE

$fatpacked{"TAP/Formatter/Console/ParallelSession.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_CONSOLE_PARALLELSESSION';
  package TAP::Formatter::Console::ParallelSession;
  
  use strict;
  use warnings;
  use File::Spec;
  use File::Path;
  use Carp;
  
  use base 'TAP::Formatter::Console::Session';
  
  use constant WIDTH => 72;    # Because Eric says
  
  my %shared;
  
  sub _initialize {
      my ( $self, $arg_for ) = @_;
  
      $self->SUPER::_initialize($arg_for);
      my $formatter = $self->formatter;
  
      # Horrid bodge. This creates our shared context per harness. Maybe
      # TAP::Harness should give us this?
      my $context = $shared{$formatter} ||= $self->_create_shared_context;
      push @{ $context->{active} }, $self;
  
      return $self;
  }
  
  sub _create_shared_context {
      my $self = shift;
      return {
          active => [],
          tests  => 0,
          fails  => 0,
      };
  }
  
  =head1 NAME
  
  TAP::Formatter::Console::ParallelSession - Harness output delegate for parallel console output
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 DESCRIPTION
  
  This provides console orientated output formatting for L<TAP::Harness>
  when run with multiple L<TAP::Harness/jobs>.
  
  =head1 SYNOPSIS
  
  =cut
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<header>
  
  Output test preamble
  
  =cut
  
  sub header {
  }
  
  sub _clear_ruler {
      my $self = shift;
      $self->formatter->_output( "\r" . ( ' ' x WIDTH ) . "\r" );
  }
  
  my $now = 0;
  my $start;
  
  my $trailer     = '... )===';
  my $chop_length = WIDTH - length $trailer;
  
  sub _output_ruler {
      my ( $self, $refresh ) = @_;
      my $new_now = time;
      return if $new_now == $now and !$refresh;
      $now = $new_now;
      $start ||= $now;
      my $formatter = $self->formatter;
      return if $formatter->really_quiet;
  
      my $context = $shared{$formatter};
  
      my $ruler = sprintf '===( %7d;%d  ', $context->{tests}, $now - $start;
  
      for my $active ( @{ $context->{active} } ) {
          my $parser  = $active->parser;
          my $tests   = $parser->tests_run;
          my $planned = $parser->tests_planned || '?';
  
          $ruler .= sprintf '%' . length($planned) . "d/$planned  ", $tests;
      }
      chop $ruler;    # Remove a trailing space
      $ruler .= ')===';
  
      if ( length $ruler > WIDTH ) {
          $ruler =~ s/(.{$chop_length}).*/$1$trailer/o;
      }
      else {
          $ruler .= '=' x ( WIDTH - length($ruler) );
      }
      $formatter->_output("\r$ruler");
  }
  
  =head3 C<result>
  
    Called by the harness for each line of TAP it receives .
  
  =cut
  
  sub result {
      my ( $self, $result ) = @_;
      my $formatter = $self->formatter;
  
      # my $really_quiet = $formatter->really_quiet;
      # my $show_count   = $self->_should_show_count;
  
      if ( $result->is_test ) {
          my $context = $shared{$formatter};
          $context->{tests}++;
  
          my $active = $context->{active};
          if ( @$active == 1 ) {
  
              # There is only one test, so use the serial output format.
              return $self->SUPER::result($result);
          }
  
          $self->_output_ruler( $self->parser->tests_run == 1 );
      }
      elsif ( $result->is_bailout ) {
          $formatter->_failure_output(
                  "Bailout called.  Further testing stopped:  "
                . $result->explanation
                . "\n" );
      }
  }
  
  =head3 C<clear_for_close>
  
  =cut
  
  sub clear_for_close {
      my $self      = shift;
      my $formatter = $self->formatter;
      return if $formatter->really_quiet;
      my $context = $shared{$formatter};
      if ( @{ $context->{active} } == 1 ) {
          $self->SUPER::clear_for_close;
      }
      else {
          $self->_clear_ruler;
      }
  }
  
  =head3 C<close_test>
  
  =cut
  
  sub close_test {
      my $self      = shift;
      my $name      = $self->name;
      my $parser    = $self->parser;
      my $formatter = $self->formatter;
      my $context   = $shared{$formatter};
  
      $self->SUPER::close_test;
  
      my $active = $context->{active};
  
      my @pos = grep { $active->[$_]->name eq $name } 0 .. $#$active;
  
      die "Can't find myself" unless @pos;
      splice @$active, $pos[0], 1;
  
      if ( @$active > 1 ) {
          $self->_output_ruler(1);
      }
      elsif ( @$active == 1 ) {
  
          # Print out "test/name.t ...."
          $active->[0]->SUPER::header;
      }
      else {
  
          # $self->formatter->_output("\n");
          delete $shared{$formatter};
      }
  }
  
  1;
TAP_FORMATTER_CONSOLE_PARALLELSESSION

$fatpacked{"TAP/Formatter/Console/Session.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_CONSOLE_SESSION';
  package TAP::Formatter::Console::Session;
  
  use strict;
  use warnings;
  
  use base 'TAP::Formatter::Session';
  
  my @ACCESSOR;
  
  BEGIN {
      my @CLOSURE_BINDING = qw( header result clear_for_close close_test );
  
      for my $method (@CLOSURE_BINDING) {
          no strict 'refs';
          *$method = sub {
              my $self = shift;
              return ( $self->{_closures} ||= $self->_closures )->{$method}
                ->(@_);
          };
      }
  }
  
  =head1 NAME
  
  TAP::Formatter::Console::Session - Harness output delegate for default console output
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 DESCRIPTION
  
  This provides console orientated output formatting for TAP::Harness.
  
  =cut
  
  sub _get_output_result {
      my $self = shift;
  
      my @color_map = (
          {   test => sub { $_->is_test && !$_->is_ok },
              colors => ['red'],
          },
          {   test => sub { $_->is_test && $_->has_skip },
              colors => [
                  'white',
                  'on_blue'
              ],
          },
          {   test => sub { $_->is_test && $_->has_todo },
              colors => ['yellow'],
          },
      );
  
      my $formatter = $self->formatter;
      my $parser    = $self->parser;
  
      return $formatter->_colorizer
        ? sub {
          my $result = shift;
          for my $col (@color_map) {
              local $_ = $result;
              if ( $col->{test}->() ) {
                  $formatter->_set_colors( @{ $col->{colors} } );
                  last;
              }
          }
          $formatter->_output( $self->_format_for_output($result) );
          $formatter->_set_colors('reset');
        }
        : sub {
          $formatter->_output( $self->_format_for_output(shift) );
        };
  }
  
  sub _closures {
      my $self = shift;
  
      my $parser     = $self->parser;
      my $formatter  = $self->formatter;
      my $pretty     = $formatter->_format_name( $self->name );
      my $show_count = $self->show_count;
  
      my $really_quiet = $formatter->really_quiet;
      my $quiet        = $formatter->quiet;
      my $verbose      = $formatter->verbose;
      my $directives   = $formatter->directives;
      my $failures     = $formatter->failures;
      my $comments     = $formatter->comments;
  
      my $output_result = $self->_get_output_result;
  
      my $output          = '_output';
      my $plan            = '';
      my $newline_printed = 0;
  
      my $last_status_printed = 0;
  
      return {
          header => sub {
              $formatter->_output($pretty)
                unless $really_quiet;
          },
  
          result => sub {
              my $result = shift;
  
              if ( $result->is_bailout ) {
                  $formatter->_failure_output(
                          "Bailout called.  Further testing stopped:  "
                        . $result->explanation
                        . "\n" );
              }
  
              return if $really_quiet;
  
              my $is_test = $result->is_test;
  
              # These are used in close_test - but only if $really_quiet
              # is false - so it's safe to only set them here unless that
              # relationship changes.
  
              if ( !$plan ) {
                  my $planned = $parser->tests_planned || '?';
                  $plan = "/$planned ";
              }
              $output = $formatter->_get_output_method($parser);
  
              if ( $show_count and $is_test ) {
                  my $number = $result->number;
                  my $now    = CORE::time;
  
                  # Print status roughly once per second.
                  # We will always get the first number as a side effect of
                  # $last_status_printed starting with the value 0, which $now
                  # will never be. (Unless someone sets their clock to 1970)
                  if ( $last_status_printed != $now ) {
                      $formatter->$output("\r$pretty$number$plan");
                      $last_status_printed = $now;
                  }
              }
  
              if (!$quiet
                  && (   $verbose
                      || ( $is_test && $failures && !$result->is_ok )
                      || ( $comments   && $result->is_comment )
                      || ( $directives && $result->has_directive ) )
                )
              {
                  unless ($newline_printed) {
                      $formatter->_output("\n");
                      $newline_printed = 1;
                  }
                  $output_result->($result);
                  $formatter->_output("\n");
              }
          },
  
          clear_for_close => sub {
              my $spaces
                = ' ' x length( '.' . $pretty . $plan . $parser->tests_run );
              $formatter->$output("\r$spaces");
          },
  
          close_test => sub {
              if ( $show_count && !$really_quiet ) {
                  $self->clear_for_close;
                  $formatter->$output("\r$pretty");
              }
  
              # Avoid circular references
              $self->parser(undef);
              $self->{_closures} = {};
  
              return if $really_quiet;
  
              if ( my $skip_all = $parser->skip_all ) {
                  $formatter->_output("skipped: $skip_all\n");
              }
              elsif ( $parser->has_problems ) {
                  $self->_output_test_failure($parser);
              }
              else {
                  my $time_report = $self->time_report($formatter, $parser);
                  $formatter->_output( $self->_make_ok_line($time_report) );
              }
          },
      };
  }
  
  =head2 C<< 	clear_for_close >>
  
  =head2 C<< 	close_test >>
  
  =head2 C<< 	header >>
  
  =head2 C<< 	result >>
  
  =cut
  
  1;
TAP_FORMATTER_CONSOLE_SESSION

$fatpacked{"TAP/Formatter/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_FILE';
  package TAP::Formatter::File;
  
  use strict;
  use warnings;
  use TAP::Formatter::File::Session;
  use POSIX qw(strftime);
  
  use base 'TAP::Formatter::Base';
  
  =head1 NAME
  
  TAP::Formatter::File - Harness output delegate for file output
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 DESCRIPTION
  
  This provides file orientated output formatting for TAP::Harness.
  
  =head1 SYNOPSIS
  
   use TAP::Formatter::File;
   my $harness = TAP::Formatter::File->new( \%args );
  
  =head2 C<< open_test >>
  
  See L<TAP::Formatter::Base>
  
  =cut
  
  sub open_test {
      my ( $self, $test, $parser ) = @_;
  
      my $session = TAP::Formatter::File::Session->new(
          {   name      => $test,
              formatter => $self,
              parser    => $parser,
          }
      );
  
      $session->header;
  
      return $session;
  }
  
  sub _should_show_count {
      return 0;
  }
  
  1;
TAP_FORMATTER_FILE

$fatpacked{"TAP/Formatter/File/Session.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_FILE_SESSION';
  package TAP::Formatter::File::Session;
  
  use strict;
  use warnings;
  use base 'TAP::Formatter::Session';
  
  =head1 NAME
  
  TAP::Formatter::File::Session - Harness output delegate for file output
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 DESCRIPTION
  
  This provides file orientated output formatting for L<TAP::Harness>.
  It is particularly important when running with parallel tests, as it
  ensures that test results are not interleaved, even when run
  verbosely.
  
  =cut
  
  =head1 METHODS
  
  =head2 result
  
  Stores results for later output, all together.
  
  =cut
  
  sub result {
      my $self   = shift;
      my $result = shift;
  
      my $parser    = $self->parser;
      my $formatter = $self->formatter;
  
      if ( $result->is_bailout ) {
          $formatter->_failure_output(
                  "Bailout called.  Further testing stopped:  "
                . $result->explanation
                . "\n" );
          return;
      }
  
      if (!$formatter->quiet
          && (   $formatter->verbose
              || ( $result->is_test && $formatter->failures && !$result->is_ok )
              || ( $formatter->comments   && $result->is_comment )
              || ( $result->has_directive && $formatter->directives ) )
        )
      {
          $self->{results} .= $self->_format_for_output($result) . "\n";
      }
  }
  
  =head2 close_test
  
  When the test file finishes, outputs the summary, together.
  
  =cut
  
  sub close_test {
      my $self = shift;
  
      # Avoid circular references
      $self->parser(undef);
  
      my $parser    = $self->parser;
      my $formatter = $self->formatter;
      my $pretty    = $formatter->_format_name( $self->name );
  
      return if $formatter->really_quiet;
      if ( my $skip_all = $parser->skip_all ) {
          $formatter->_output( $pretty . "skipped: $skip_all\n" );
      }
      elsif ( $parser->has_problems ) {
          $formatter->_output(
              $pretty . ( $self->{results} ? "\n" . $self->{results} : "\n" ) );
          $self->_output_test_failure($parser);
      }
      else {
          my $time_report = $self->time_report($formatter, $parser);
          $formatter->_output( $pretty
                . ( $self->{results} ? "\n" . $self->{results} : "" )
                . $self->_make_ok_line($time_report) );
      }
  }
  
  1;
TAP_FORMATTER_FILE_SESSION

$fatpacked{"TAP/Formatter/Session.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_SESSION';
  package TAP::Formatter::Session;
  
  use strict;
  use warnings;
  
  use base 'TAP::Base';
  
  my @ACCESSOR;
  
  BEGIN {
  
      @ACCESSOR = qw( name formatter parser show_count );
  
      for my $method (@ACCESSOR) {
          no strict 'refs';
          *$method = sub { shift->{$method} };
      }
  }
  
  =head1 NAME
  
  TAP::Formatter::Session - Abstract base class for harness output delegate 
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
   my %args = (
      formatter => $self,
   )
   my $harness = TAP::Formatter::Console::Session->new( \%args );
  
  The constructor returns a new C<TAP::Formatter::Console::Session> object.
  
  =over 4
  
  =item * C<formatter>
  
  =item * C<parser>
  
  =item * C<name>
  
  =item * C<show_count>
  
  =back
  
  =cut
  
  sub _initialize {
      my ( $self, $arg_for ) = @_;
      $arg_for ||= {};
  
      $self->SUPER::_initialize($arg_for);
      my %arg_for = %$arg_for;    # force a shallow copy
  
      for my $name (@ACCESSOR) {
          $self->{$name} = delete $arg_for{$name};
      }
  
      if ( !defined $self->show_count ) {
          $self->{show_count} = 1;    # defaults to true
      }
      if ( $self->show_count ) {      # but may be a damned lie!
          $self->{show_count} = $self->_should_show_count;
      }
  
      if ( my @props = sort keys %arg_for ) {
          $self->_croak(
              "Unknown arguments to " . __PACKAGE__ . "::new (@props)" );
      }
  
      return $self;
  }
  
  =head3 C<header>
  
  Output test preamble
  
  =head3 C<result>
  
  Called by the harness for each line of TAP it receives.
  
  =head3 C<close_test>
  
  Called to close a test session.
  
  =head3 C<clear_for_close>
  
  Called by C<close_test> to clear the line showing test progress, or the parallel
  test ruler, prior to printing the final test result.
  
  =head3 C<time_report>
  
  Return a formatted string about the elapsed (wall-clock) time
  and about the consumed CPU time.
  
  =cut
  
  sub header { }
  
  sub result { }
  
  sub close_test { }
  
  sub clear_for_close { }
  
  sub _should_show_count {
      my $self = shift;
      return
           !$self->formatter->verbose
        && -t $self->formatter->stdout
        && !$ENV{HARNESS_NOTTY};
  }
  
  sub _format_for_output {
      my ( $self, $result ) = @_;
      return $self->formatter->normalize ? $result->as_string : $result->raw;
  }
  
  sub _output_test_failure {
      my ( $self, $parser ) = @_;
      my $formatter = $self->formatter;
      return if $formatter->really_quiet;
  
      my $tests_run     = $parser->tests_run;
      my $tests_planned = $parser->tests_planned;
  
      my $total
        = defined $tests_planned
        ? $tests_planned
        : $tests_run;
  
      my $passed = $parser->passed;
  
      # The total number of fails includes any tests that were planned but
      # didn't run
      my $failed = $parser->failed + $total - $tests_run;
      my $exit   = $parser->exit;
  
      if ( my $exit = $parser->exit ) {
          my $wstat = $parser->wait;
          my $status = sprintf( "%d (wstat %d, 0x%x)", $exit, $wstat, $wstat );
          $formatter->_failure_output("Dubious, test returned $status\n");
      }
  
      if ( $failed == 0 ) {
          $formatter->_failure_output(
              $total
              ? "All $total subtests passed "
              : 'No subtests run '
          );
      }
      else {
          $formatter->_failure_output("Failed $failed/$total subtests ");
          if ( !$total ) {
              $formatter->_failure_output("\nNo tests run!");
          }
      }
  
      if ( my $skipped = $parser->skipped ) {
          $passed -= $skipped;
          my $test = 'subtest' . ( $skipped != 1 ? 's' : '' );
          $formatter->_output(
              "\n\t(less $skipped skipped $test: $passed okay)");
      }
  
      if ( my $failed = $parser->todo_passed ) {
          my $test = $failed > 1 ? 'tests' : 'test';
          $formatter->_output(
              "\n\t($failed TODO $test unexpectedly succeeded)");
      }
  
      $formatter->_output("\n");
  }
  
  sub _make_ok_line {
      my ( $self, $suffix ) = @_;
      return "ok$suffix\n";
  }
  
  sub time_report {
      my ( $self, $formatter, $parser ) = @_;
  
      my @time_report;
      if ( $formatter->timer ) {
          my $start_time = $parser->start_time;
          my $end_time   = $parser->end_time;
          if ( defined $start_time and defined $end_time ) {
              my $elapsed = $end_time - $start_time;
              push @time_report,
                $self->time_is_hires
                  ? sprintf( ' %8d ms', $elapsed * 1000 )
                  : sprintf( ' %8s s', $elapsed || '<1' );
          }
          my $start_times = $parser->start_times();
          my $end_times   = $parser->end_times();
          my $usr  = $end_times->[0] - $start_times->[0];
          my $sys  = $end_times->[1] - $start_times->[1];
          my $cusr = $end_times->[2] - $start_times->[2];
          my $csys = $end_times->[3] - $start_times->[3];
          push @time_report,
            sprintf('(%5.2f usr %5.2f sys + %5.2f cusr %5.2f csys = %5.2f CPU)',
                    $usr, $sys, $cusr, $csys,
                    $usr + $sys + $cusr + $csys);
      }
  
      return "@time_report";
  }
  
  1;
TAP_FORMATTER_SESSION

$fatpacked{"TAP/Harness.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_HARNESS';
  package TAP::Harness;
  
  use strict;
  use warnings;
  use Carp;
  
  use File::Spec;
  use File::Path;
  use IO::Handle;
  
  use base 'TAP::Base';
  
  =head1 NAME
  
  TAP::Harness - Run test scripts with statistics
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  $ENV{HARNESS_ACTIVE}  = 1;
  $ENV{HARNESS_VERSION} = $VERSION;
  
  END {
  
      # For VMS.
      delete $ENV{HARNESS_ACTIVE};
      delete $ENV{HARNESS_VERSION};
  }
  
  =head1 DESCRIPTION
  
  This is a simple test harness which allows tests to be run and results
  automatically aggregated and output to STDOUT.
  
  =head1 SYNOPSIS
  
   use TAP::Harness;
   my $harness = TAP::Harness->new( \%args );
   $harness->runtests(@tests);
  
  =cut
  
  my %VALIDATION_FOR;
  my @FORMATTER_ARGS;
  
  sub _error {
      my $self = shift;
      return $self->{error} unless @_;
      $self->{error} = shift;
  }
  
  BEGIN {
  
      @FORMATTER_ARGS = qw(
        directives verbosity timer failures comments errors stdout color
        show_count normalize
      );
  
      %VALIDATION_FOR = (
          lib => sub {
              my ( $self, $libs ) = @_;
              $libs = [$libs] unless 'ARRAY' eq ref $libs;
  
              return [ map {"-I$_"} @$libs ];
          },
          switches          => sub { shift; shift },
          exec              => sub { shift; shift },
          merge             => sub { shift; shift },
          aggregator_class  => sub { shift; shift },
          formatter_class   => sub { shift; shift },
          multiplexer_class => sub { shift; shift },
          parser_class      => sub { shift; shift },
          scheduler_class   => sub { shift; shift },
          formatter         => sub { shift; shift },
          jobs              => sub { shift; shift },
          test_args         => sub { shift; shift },
          ignore_exit       => sub { shift; shift },
          rules             => sub { shift; shift },
          rulesfile         => sub { shift; shift },
          sources           => sub { shift; shift },
          version           => sub { shift; shift },
          trap              => sub { shift; shift },
      );
  
      for my $method ( sort keys %VALIDATION_FOR ) {
          no strict 'refs';
          if ( $method eq 'lib' || $method eq 'switches' ) {
              *{$method} = sub {
                  my $self = shift;
                  unless (@_) {
                      $self->{$method} ||= [];
                      return wantarray
                        ? @{ $self->{$method} }
                        : $self->{$method};
                  }
                  $self->_croak("Too many arguments to method '$method'")
                    if @_ > 1;
                  my $args = shift;
                  $args = [$args] unless ref $args;
                  $self->{$method} = $args;
                  return $self;
              };
          }
          else {
              *{$method} = sub {
                  my $self = shift;
                  return $self->{$method} unless @_;
                  $self->{$method} = shift;
              };
          }
      }
  
      for my $method (@FORMATTER_ARGS) {
          no strict 'refs';
          *{$method} = sub {
              my $self = shift;
              return $self->formatter->$method(@_);
          };
      }
  }
  
  ##############################################################################
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
   my %args = (
      verbosity => 1,
      lib     => [ 'lib', 'blib/lib', 'blib/arch' ],
   )
   my $harness = TAP::Harness->new( \%args );
  
  The constructor returns a new C<TAP::Harness> object. It accepts an
  optional hashref whose allowed keys are:
  
  =over 4
  
  =item * C<verbosity>
  
  Set the verbosity level:
  
       1   verbose        Print individual test results to STDOUT.
       0   normal
      -1   quiet          Suppress some test output (mostly failures 
                          while tests are running).
      -2   really quiet   Suppress everything but the tests summary.
      -3   silent         Suppress everything.
  
  =item * C<timer>
  
  Append run time for each test to output. Uses L<Time::HiRes> if
  available.
  
  =item * C<failures>
  
  Show test failures (this is a no-op if C<verbose> is selected).
  
  =item * C<comments>
  
  Show test comments (this is a no-op if C<verbose> is selected).
  
  =item * C<show_count>
  
  Update the running test count during testing.
  
  =item * C<normalize>
  
  Set to a true value to normalize the TAP that is emitted in verbose modes.
  
  =item * C<lib>
  
  Accepts a scalar value or array ref of scalar values indicating which
  paths to allowed libraries should be included if Perl tests are
  executed. Naturally, this only makes sense in the context of tests
  written in Perl.
  
  =item * C<switches>
  
  Accepts a scalar value or array ref of scalar values indicating which
  switches should be included if Perl tests are executed. Naturally, this
  only makes sense in the context of tests written in Perl.
  
  =item * C<test_args>
  
  A reference to an C<@INC> style array of arguments to be passed to each
  test program.
  
    test_args => ['foo', 'bar'],
  
  if you want to pass different arguments to each test then you should
  pass a hash of arrays, keyed by the alias for each test:
  
    test_args => {
      my_test    => ['foo', 'bar'],
      other_test => ['baz'],
    }
  
  =item * C<color>
  
  Attempt to produce color output.
  
  =item * C<exec>
  
  Typically, Perl tests are run through this. However, anything which
  spits out TAP is fine. You can use this argument to specify the name of
  the program (and optional switches) to run your tests with:
  
    exec => ['/usr/bin/ruby', '-w']
  
  You can also pass a subroutine reference in order to determine and
  return the proper program to run based on a given test script. The
  subroutine reference should expect the TAP::Harness object itself as the
  first argument, and the file name as the second argument. It should
  return an array reference containing the command to be run and including
  the test file name. It can also simply return C<undef>, in which case
  TAP::Harness will fall back on executing the test script in Perl:
  
      exec => sub {
          my ( $harness, $test_file ) = @_;
  
          # Let Perl tests run.
          return undef if $test_file =~ /[.]t$/;
          return [ qw( /usr/bin/ruby -w ), $test_file ]
            if $test_file =~ /[.]rb$/;
        }
  
  If the subroutine returns a scalar with a newline or a filehandle, it
  will be interpreted as raw TAP or as a TAP stream, respectively.
  
  =item * C<merge>
  
  If C<merge> is true the harness will create parsers that merge STDOUT
  and STDERR together for any processes they start.
  
  =item * C<sources>
  
  I<NEW to 3.18>.
  
  If set, C<sources> must be a hashref containing the names of the
  L<TAP::Parser::SourceHandler>s to load and/or configure.  The values are a
  hash of configuration that will be accessible to the source handlers via
  L<TAP::Parser::Source/config_for>.
  
  For example:
  
    sources => {
      Perl => { exec => '/path/to/custom/perl' },
      File => { extensions => [ '.tap', '.txt' ] },
      MyCustom => { some => 'config' },
    }
  
  The C<sources> parameter affects how C<source>, C<tap> and C<exec> parameters
  are handled.
  
  For more details, see the C<sources> parameter in L<TAP::Parser/new>,
  L<TAP::Parser::Source>, and L<TAP::Parser::IteratorFactory>.
  
  =item * C<aggregator_class>
  
  The name of the class to use to aggregate test results. The default is
  L<TAP::Parser::Aggregator>.
  
  =item * C<version>
  
  I<NEW to 3.22>.
  
  Assume this TAP version for L<TAP::Parser> instead of default TAP
  version 12.
  
  =item * C<formatter_class>
  
  The name of the class to use to format output. The default is
  L<TAP::Formatter::Console>, or L<TAP::Formatter::File> if the output
  isn't a TTY.
  
  =item * C<multiplexer_class>
  
  The name of the class to use to multiplex tests during parallel testing.
  The default is L<TAP::Parser::Multiplexer>.
  
  =item * C<parser_class>
  
  The name of the class to use to parse TAP. The default is
  L<TAP::Parser>.
  
  =item * C<scheduler_class>
  
  The name of the class to use to schedule test execution. The default is
  L<TAP::Parser::Scheduler>.
  
  =item * C<formatter>
  
  If set C<formatter> must be an object that is capable of formatting the
  TAP output. See L<TAP::Formatter::Console> for an example.
  
  =item * C<errors>
  
  If parse errors are found in the TAP output, a note of this will be
  made in the summary report. To see all of the parse errors, set this
  argument to true:
  
    errors => 1
  
  =item * C<directives>
  
  If set to a true value, only test results with directives will be
  displayed. This overrides other settings such as C<verbose> or
  C<failures>.
  
  =item * C<ignore_exit>
  
  If set to a true value instruct C<TAP::Parser> to ignore exit and wait
  status from test scripts.
  
  =item * C<jobs>
  
  The maximum number of parallel tests to run at any time.  Which tests
  can be run in parallel is controlled by C<rules>.  The default is to
  run only one test at a time.
  
  =item * C<rules>
  
  A reference to a hash of rules that control which tests may be executed in
  parallel. If no rules are declared and L<CPAN::Meta::YAML> is available,
  C<TAP::Harness> attempts to load rules from a YAML file specified by the
  C<rulesfile> parameter. If no rules file exists, the default is for all
  tests to be eligible to be run in parallel.
  
  Here some simple examples. For the full details of the data structure
  and the related glob-style pattern matching, see
  L<TAP::Parser::Scheduler/"Rules data structure">.
  
      # Run all tests in sequence, except those starting with "p"
      $harness->rules({
          par => 't/p*.t'
      });
  
      # Equivalent YAML file
      ---
      par: t/p*.t
  
      # Run all tests in parallel, except those starting with "p"
      $harness->rules({
          seq => [
                    { seq => 't/p*.t' },
                    { par => '**'     },
                 ],
      });
  
      # Equivalent YAML file
      ---
      seq:
          - seq: t/p*.t
          - par: **
  
      # Run some  startup tests in sequence, then some parallel tests than some
      # teardown tests in sequence.
      $harness->rules({
          seq => [
              { seq => 't/startup/*.t' },
              { par => ['t/a/*.t','t/b/*.t','t/c/*.t'], }
              { seq => 't/shutdown/*.t' },
          ],
  
      });
  
      # Equivalent YAML file
      ---
      seq:
          - seq: t/startup/*.t
          - par:
              - t/a/*.t
              - t/b/*.t
              - t/c/*.t
          - seq: t/shutdown/*.t
  
  This is an experimental feature and the interface may change.
  
  =item * C<rulesfiles>
  
  This specifies where to find a YAML file of test scheduling rules.  If not
  provided, it looks for a default file to use.  It first checks for a file given
  in the C<HARNESS_RULESFILE> environment variable, then it checks for
  F<testrules.yml> and then F<t/testrules.yml>.
  
  =item * C<stdout>
  
  A filehandle for catching standard output.
  
  =item * C<trap>
  
  Attempt to print summary information if run is interrupted by
  SIGINT (Ctrl-C).
  
  =back
  
  Any keys for which the value is C<undef> will be ignored.
  
  =cut
  
  # new supplied by TAP::Base
  
  {
      my @legal_callback = qw(
        parser_args
        made_parser
        before_runtests
        after_runtests
        after_test
      );
  
      my %default_class = (
          aggregator_class  => 'TAP::Parser::Aggregator',
          formatter_class   => 'TAP::Formatter::Console',
          multiplexer_class => 'TAP::Parser::Multiplexer',
          parser_class      => 'TAP::Parser',
          scheduler_class   => 'TAP::Parser::Scheduler',
      );
  
      sub _initialize {
          my ( $self, $arg_for ) = @_;
          $arg_for ||= {};
  
          $self->SUPER::_initialize( $arg_for, \@legal_callback );
          my %arg_for = %$arg_for;    # force a shallow copy
  
          for my $name ( sort keys %VALIDATION_FOR ) {
              my $property = delete $arg_for{$name};
              if ( defined $property ) {
                  my $validate = $VALIDATION_FOR{$name};
  
                  my $value = $self->$validate($property);
                  if ( $self->_error ) {
                      $self->_croak;
                  }
                  $self->$name($value);
              }
          }
  
          $self->jobs(1) unless defined $self->jobs;
  
          if ( ! defined $self->rules ) {
              $self->_maybe_load_rulesfile;
          }
  
          local $default_class{formatter_class} = 'TAP::Formatter::File'
            unless -t ( $arg_for{stdout} || \*STDOUT ) && !$ENV{HARNESS_NOTTY};
  
          while ( my ( $attr, $class ) = each %default_class ) {
              $self->$attr( $self->$attr() || $class );
          }
  
          unless ( $self->formatter ) {
  
              # This is a little bodge to preserve legacy behaviour. It's
              # pretty horrible that we know which args are destined for
              # the formatter.
              my %formatter_args = ( jobs => $self->jobs );
              for my $name (@FORMATTER_ARGS) {
                  if ( defined( my $property = delete $arg_for{$name} ) ) {
                      $formatter_args{$name} = $property;
                  }
              }
  
              $self->formatter(
                  $self->_construct( $self->formatter_class, \%formatter_args )
              );
          }
  
          if ( my @props = sort keys %arg_for ) {
              $self->_croak("Unknown arguments to TAP::Harness::new (@props)");
          }
  
          return $self;
      }
  
      sub _maybe_load_rulesfile {
          my ($self) = @_;
  
          my ($rulesfile) =   defined $self->rulesfile ? $self->rulesfile :
                              defined($ENV{HARNESS_RULESFILE}) ? $ENV{HARNESS_RULESFILE} :
                              grep { -r } qw(./testrules.yml t/testrules.yml);
  
          if ( defined $rulesfile && -r $rulesfile ) {
              if ( ! eval { require CPAN::Meta::YAML; 1} ) {
                 warn "CPAN::Meta::YAML required to process $rulesfile" ;
                 return;
              }
              my $layer = $] lt "5.008" ? "" : ":encoding(UTF-8)";
              open my $fh, "<$layer", $rulesfile
                  or die "Couldn't open $rulesfile: $!";
              my $yaml_text = do { local $/; <$fh> };
              my $yaml = CPAN::Meta::YAML->read_string($yaml_text)
                  or die CPAN::Meta::YAML->errstr;
              $self->rules( $yaml->[0] );
          }
          return;
      }
  }
  
  ##############################################################################
  
  =head2 Instance Methods
  
  =head3 C<runtests>
  
      $harness->runtests(@tests);
  
  Accepts an array of C<@tests> to be run. This should generally be the
  names of test files, but this is not required. Each element in C<@tests>
  will be passed to C<TAP::Parser::new()> as a C<source>. See
  L<TAP::Parser> for more information.
  
  It is possible to provide aliases that will be displayed in place of the
  test name by supplying the test as a reference to an array containing
  C<< [ $test, $alias ] >>:
  
      $harness->runtests( [ 't/foo.t', 'Foo Once' ],
                          [ 't/foo.t', 'Foo Twice' ] );
  
  Normally it is an error to attempt to run the same test twice. Aliases
  allow you to overcome this limitation by giving each run of the test a
  unique name.
  
  Tests will be run in the order found.
  
  If the environment variable C<PERL_TEST_HARNESS_DUMP_TAP> is defined it
  should name a directory into which a copy of the raw TAP for each test
  will be written. TAP is written to files named for each test.
  Subdirectories will be created as needed.
  
  Returns a L<TAP::Parser::Aggregator> containing the test results.
  
  =cut
  
  sub runtests {
      my ( $self, @tests ) = @_;
  
      my $aggregate = $self->_construct( $self->aggregator_class );
  
      $self->_make_callback( 'before_runtests', $aggregate );
      $aggregate->start;
      my $finish = sub {
          my $interrupted = shift;
          $aggregate->stop;
          $self->summary( $aggregate, $interrupted );
          $self->_make_callback( 'after_runtests', $aggregate );
      };
      my $run = sub {
          $self->aggregate_tests( $aggregate, @tests );
          $finish->();
      };
  
      if ( $self->trap ) {
          local $SIG{INT} = sub {
              print "\n";
              $finish->(1);
              exit;
          };
          $run->();
      }
      else {
          $run->();
      }
  
      return $aggregate;
  }
  
  =head3 C<summary>
  
    $harness->summary( $aggregator );
  
  Output the summary for a L<TAP::Parser::Aggregator>.
  
  =cut
  
  sub summary {
      my ( $self, @args ) = @_;
      $self->formatter->summary(@args);
  }
  
  sub _after_test {
      my ( $self, $aggregate, $job, $parser ) = @_;
  
      $self->_make_callback( 'after_test', $job->as_array_ref, $parser );
      $aggregate->add( $job->description, $parser );
  }
  
  sub _bailout {
      my ( $self, $result ) = @_;
      my $explanation = $result->explanation;
      die "FAILED--Further testing stopped"
        . ( $explanation ? ": $explanation\n" : ".\n" );
  }
  
  sub _aggregate_parallel {
      my ( $self, $aggregate, $scheduler ) = @_;
  
      my $jobs = $self->jobs;
      my $mux  = $self->_construct( $self->multiplexer_class );
  
      RESULT: {
  
          # Keep multiplexer topped up
          FILL:
          while ( $mux->parsers < $jobs ) {
              my $job = $scheduler->get_job;
  
              # If we hit a spinner stop filling and start running.
              last FILL if !defined $job || $job->is_spinner;
  
              my ( $parser, $session ) = $self->make_parser($job);
              $mux->add( $parser, [ $session, $job ] );
          }
  
          if ( my ( $parser, $stash, $result ) = $mux->next ) {
              my ( $session, $job ) = @$stash;
              if ( defined $result ) {
                  $session->result($result);
                  $self->_bailout($result) if $result->is_bailout;
              }
              else {
  
                  # End of parser. Automatically removed from the mux.
                  $self->finish_parser( $parser, $session );
                  $self->_after_test( $aggregate, $job, $parser );
                  $job->finish;
              }
              redo RESULT;
          }
      }
  
      return;
  }
  
  sub _aggregate_single {
      my ( $self, $aggregate, $scheduler ) = @_;
  
      JOB:
      while ( my $job = $scheduler->get_job ) {
          next JOB if $job->is_spinner;
  
          my ( $parser, $session ) = $self->make_parser($job);
  
          while ( defined( my $result = $parser->next ) ) {
              $session->result($result);
              if ( $result->is_bailout ) {
  
                  # Keep reading until input is exhausted in the hope
                  # of allowing any pending diagnostics to show up.
                  1 while $parser->next;
                  $self->_bailout($result);
              }
          }
  
          $self->finish_parser( $parser, $session );
          $self->_after_test( $aggregate, $job, $parser );
          $job->finish;
      }
  
      return;
  }
  
  =head3 C<aggregate_tests>
  
    $harness->aggregate_tests( $aggregate, @tests );
  
  Run the named tests and display a summary of result. Tests will be run
  in the order found.
  
  Test results will be added to the supplied L<TAP::Parser::Aggregator>.
  C<aggregate_tests> may be called multiple times to run several sets of
  tests. Multiple C<Test::Harness> instances may be used to pass results
  to a single aggregator so that different parts of a complex test suite
  may be run using different C<TAP::Harness> settings. This is useful, for
  example, in the case where some tests should run in parallel but others
  are unsuitable for parallel execution.
  
      my $formatter   = TAP::Formatter::Console->new;
      my $ser_harness = TAP::Harness->new( { formatter => $formatter } );
      my $par_harness = TAP::Harness->new(
          {   formatter => $formatter,
              jobs      => 9
          }
      );
      my $aggregator = TAP::Parser::Aggregator->new;
  
      $aggregator->start();
      $ser_harness->aggregate_tests( $aggregator, @ser_tests );
      $par_harness->aggregate_tests( $aggregator, @par_tests );
      $aggregator->stop();
      $formatter->summary($aggregator);
  
  Note that for simpler testing requirements it will often be possible to
  replace the above code with a single call to C<runtests>.
  
  Each element of the C<@tests> array is either:
  
  =over
  
  =item * the source name of a test to run
  
  =item * a reference to a [ source name, display name ] array
  
  =back
  
  In the case of a perl test suite, typically I<source names> are simply the file
  names of the test scripts to run.
  
  When you supply a separate display name it becomes possible to run a
  test more than once; the display name is effectively the alias by which
  the test is known inside the harness. The harness doesn't care if it
  runs the same test more than once when each invocation uses a
  different name.
  
  =cut
  
  sub aggregate_tests {
      my ( $self, $aggregate, @tests ) = @_;
  
      my $jobs      = $self->jobs;
      my $scheduler = $self->make_scheduler(@tests);
  
      # #12458
      local $ENV{HARNESS_IS_VERBOSE} = 1
        if $self->formatter->verbosity > 0;
  
      # Formatter gets only names.
      $self->formatter->prepare( map { $_->description } $scheduler->get_all );
  
      if ( $self->jobs > 1 ) {
          $self->_aggregate_parallel( $aggregate, $scheduler );
      }
      else {
          $self->_aggregate_single( $aggregate, $scheduler );
      }
  
      return;
  }
  
  sub _add_descriptions {
      my $self = shift;
  
      # Turn unwrapped scalars into anonymous arrays and copy the name as
      # the description for tests that have only a name.
      return map { @$_ == 1 ? [ $_->[0], $_->[0] ] : $_ }
        map { 'ARRAY' eq ref $_ ? $_ : [$_] } @_;
  }
  
  =head3 C<make_scheduler>
  
  Called by the harness when it needs to create a
  L<TAP::Parser::Scheduler>. Override in a subclass to provide an
  alternative scheduler. C<make_scheduler> is passed the list of tests
  that was passed to C<aggregate_tests>.
  
  =cut
  
  sub make_scheduler {
      my ( $self, @tests ) = @_;
      return $self->_construct(
          $self->scheduler_class,
          tests => [ $self->_add_descriptions(@tests) ],
          rules => $self->rules
      );
  }
  
  =head3 C<jobs>
  
  Gets or sets the number of concurrent test runs the harness is
  handling.  By default, this value is 1 -- for parallel testing, this
  should be set higher.
  
  =cut
  
  ##############################################################################
  
  sub _get_parser_args {
      my ( $self, $job ) = @_;
      my $test_prog = $job->filename;
      my %args      = ();
  
      $args{sources} = $self->sources if $self->sources;
  
      my @switches;
      @switches = $self->lib if $self->lib;
      push @switches => $self->switches if $self->switches;
      $args{switches}    = \@switches;
      $args{spool}       = $self->_open_spool($test_prog);
      $args{merge}       = $self->merge;
      $args{ignore_exit} = $self->ignore_exit;
      $args{version}     = $self->version if $self->version;
  
      if ( my $exec = $self->exec ) {
          $args{exec}
            = ref $exec eq 'CODE'
            ? $exec->( $self, $test_prog )
            : [ @$exec, $test_prog ];
          if ( not defined $args{exec} ) {
              $args{source} = $test_prog;
          }
          elsif ( ( ref( $args{exec} ) || "" ) ne "ARRAY" ) {
              $args{source} = delete $args{exec};
          }
      }
      else {
          $args{source} = $test_prog;
      }
  
      if ( defined( my $test_args = $self->test_args ) ) {
  
          if ( ref($test_args) eq 'HASH' ) {
  
              # different args for each test
              if ( exists( $test_args->{ $job->description } ) ) {
                  $test_args = $test_args->{ $job->description };
              }
              else {
                  $self->_croak( "TAP::Harness Can't find test_args for "
                        . $job->description );
              }
          }
  
          $args{test_args} = $test_args;
      }
  
      return \%args;
  }
  
  =head3 C<make_parser>
  
  Make a new parser and display formatter session. Typically used and/or
  overridden in subclasses.
  
      my ( $parser, $session ) = $harness->make_parser;
  
  =cut
  
  sub make_parser {
      my ( $self, $job ) = @_;
  
      my $args = $self->_get_parser_args($job);
      $self->_make_callback( 'parser_args', $args, $job->as_array_ref );
      my $parser = $self->_construct( $self->parser_class, $args );
  
      $self->_make_callback( 'made_parser', $parser, $job->as_array_ref );
      my $session = $self->formatter->open_test( $job->description, $parser );
  
      return ( $parser, $session );
  }
  
  =head3 C<finish_parser>
  
  Terminate use of a parser. Typically used and/or overridden in
  subclasses. The parser isn't destroyed as a result of this.
  
  =cut
  
  sub finish_parser {
      my ( $self, $parser, $session ) = @_;
  
      $session->close_test;
      $self->_close_spool($parser);
  
      return $parser;
  }
  
  sub _open_spool {
      my $self = shift;
      my $test = shift;
  
      if ( my $spool_dir = $ENV{PERL_TEST_HARNESS_DUMP_TAP} ) {
  
          my $spool = File::Spec->catfile( $spool_dir, $test );
  
          # Make the directory
          my ( $vol, $dir, undef ) = File::Spec->splitpath($spool);
          my $path = File::Spec->catpath( $vol, $dir, '' );
          eval { mkpath($path) };
          $self->_croak($@) if $@;
  
          my $spool_handle = IO::Handle->new;
          open( $spool_handle, ">$spool" )
            or $self->_croak(" Can't write $spool ( $! ) ");
  
          return $spool_handle;
      }
  
      return;
  }
  
  sub _close_spool {
      my $self = shift;
      my ($parser) = @_;
  
      if ( my $spool_handle = $parser->delete_spool ) {
          close($spool_handle)
            or $self->_croak(" Error closing TAP spool file( $! ) \n ");
      }
  
      return;
  }
  
  sub _croak {
      my ( $self, $message ) = @_;
      unless ($message) {
          $message = $self->_error;
      }
      $self->SUPER::_croak($message);
  
      return;
  }
  
  1;
  
  __END__
  
  ##############################################################################
  
  =head1 CONFIGURING
  
  C<TAP::Harness> is designed to be easy to configure.
  
  =head2 Plugins
  
  C<TAP::Parser> plugins let you change the way TAP is I<input> to and I<output>
  from the parser.
  
  L<TAP::Parser::SourceHandler>s handle TAP I<input>.  You can configure them
  and load custom handlers using the C<sources> parameter to L</new>.
  
  L<TAP::Formatter>s handle TAP I<output>.  You can load custom formatters by
  using the C<formatter_class> parameter to L</new>.  To configure a formatter,
  you currently need to instantiate it outside of L<TAP::Harness> and pass it in
  with the C<formatter> parameter to L</new>.  This I<may> be addressed by adding
  a I<formatters> parameter to L</new> in the future.
  
  =head2 C<Module::Build>
  
  L<Module::Build> version C<0.30> supports C<TAP::Harness>.
  
  To load C<TAP::Harness> plugins, you'll need to use the C<tap_harness_args>
  parameter to C<new>, typically from your C<Build.PL>.  For example:
  
    Module::Build->new(
        module_name        => 'MyApp',
        test_file_exts     => [qw(.t .tap .txt)],
        use_tap_harness    => 1,
        tap_harness_args   => {
            sources => {
                MyCustom => {},
                File => {
                    extensions => ['.tap', '.txt'],
                },
            },
            formatter_class => 'TAP::Formatter::HTML',
        },
        build_requires     => {
            'Module::Build' => '0.30',
            'TAP::Harness'  => '3.18',
        },
    )->create_build_script;
  
  See L</new>
  
  =head2 C<ExtUtils::MakeMaker>
  
  L<ExtUtils::MakeMaker> does not support L<TAP::Harness> out-of-the-box.
  
  =head2 C<prove>
  
  L<prove> supports C<TAP::Harness> plugins, and has a plugin system of its
  own.  See L<prove/FORMATTERS>, L<prove/SOURCE HANDLERS> and L<App::Prove>
  for more details.
  
  =head1 WRITING PLUGINS
  
  If you can't configure C<TAP::Harness> to do what you want, and you can't find
  an existing plugin, consider writing one.
  
  The two primary use cases supported by L<TAP::Harness> for plugins are I<input>
  and I<output>:
  
  =over 2
  
  =item Customize how TAP gets into the parser
  
  To do this, you can either extend an existing L<TAP::Parser::SourceHandler>,
  or write your own.  It's a pretty simple API, and they can be loaded and
  configured using the C<sources> parameter to L</new>.
  
  =item Customize how TAP results are output from the parser
  
  To do this, you can either extend an existing L<TAP::Formatter>, or write your
  own.  Writing formatters are a bit more involved than writing a
  I<SourceHandler>, as you'll need to understand the L<TAP::Parser> API.  A
  good place to start is by understanding how L</aggregate_tests> works.
  
  Custom formatters can be loaded configured using the C<formatter_class>
  parameter to L</new>.
  
  =back
  
  =head1 SUBCLASSING
  
  If you can't configure C<TAP::Harness> to do exactly what you want, and writing
  a plugin isn't an option, consider extending it.  It is designed to be (mostly)
  easy to subclass, though the cases when sub-classing is necessary should be few
  and far between.
  
  =head2 Methods
  
  The following methods are ones you may wish to override if you want to
  subclass C<TAP::Harness>.
  
  =over 4
  
  =item L</new>
  
  =item L</runtests>
  
  =item L</summary>
  
  =back
  
  =cut
  
  =head1 REPLACING
  
  If you like the C<prove> utility and L<TAP::Parser> but you want your
  own harness, all you need to do is write one and provide C<new> and
  C<runtests> methods. Then you can use the C<prove> utility like so:
  
   prove --harness My::Test::Harness
  
  Note that while C<prove> accepts a list of tests (or things to be
  tested), C<new> has a fairly rich set of arguments. You'll probably want
  to read over this code carefully to see how all of them are being used.
  
  =head1 SEE ALSO
  
  L<Test::Harness>
  
  =cut
  
  # vim:ts=4:sw=4:et:sta
TAP_HARNESS

$fatpacked{"TAP/Harness/Env.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_HARNESS_ENV';
  package TAP::Harness::Env;
  
  use strict;
  use warnings;
  
  use constant IS_VMS => ( $^O eq 'VMS' );
  use TAP::Object;
  use Text::ParseWords qw/shellwords/;
  
  our $VERSION = '3.42';
  
  # Get the parts of @INC which are changed from the stock list AND
  # preserve reordering of stock directories.
  sub _filtered_inc_vms {
      my @inc = grep { !ref } @INC;    #28567
  
      # VMS has a 255-byte limit on the length of %ENV entries, so
      # toss the ones that involve perl_root, the install location
      @inc = grep { !/perl_root/i } @inc;
  
      my @default_inc = _default_inc();
  
      my @new_inc;
      my %seen;
      for my $dir (@inc) {
          next if $seen{$dir}++;
  
          if ( $dir eq ( $default_inc[0] || '' ) ) {
              shift @default_inc;
          }
          else {
              push @new_inc, $dir;
          }
  
          shift @default_inc while @default_inc and $seen{ $default_inc[0] };
      }
      return @new_inc;
  }
  
  # Cache this to avoid repeatedly shelling out to Perl.
  my @inc;
  
  sub _default_inc {
      return @inc if @inc;
  
      local $ENV{PERL5LIB};
      local $ENV{PERLLIB};
  
      my $perl = $ENV{HARNESS_PERL} || $^X;
  
      # Avoid using -l for the benefit of Perl 6
      chomp( @inc = `"$perl" -e "print join qq[\\n], \@INC, q[]"` );
      return @inc;
  }
  
  sub create {
  	my $package = shift;
      my %input = %{ shift || {} };
  
      my @libs         = @{ delete $input{libs}     || [] };
      my @raw_switches = @{ delete $input{switches} || [] };
      my @opt
        = ( @raw_switches, shellwords( $ENV{HARNESS_PERL_SWITCHES} || '' ) );
      my @switches;
      while ( my $opt = shift @opt ) {
          if ( $opt =~ /^ -I (.*) $ /x ) {
              push @libs, length($1) ? $1 : shift @opt;
          }
          else {
              push @switches, $opt;
          }
      }
  
      # Do things the old way on VMS...
      push @libs, _filtered_inc_vms() if IS_VMS;
  
      # If $Verbose isn't numeric default to 1. This helps core.
      my $verbose
        = $ENV{HARNESS_VERBOSE}
        ? $ENV{HARNESS_VERBOSE} !~ /\d/
            ? 1
            : $ENV{HARNESS_VERBOSE}
        : 0;
  
      my %args = (
          lib         => \@libs,
          timer       => $ENV{HARNESS_TIMER} || 0,
          switches    => \@switches,
          color       => $ENV{HARNESS_COLOR} || 0,
          verbosity   => $verbose,
          ignore_exit => $ENV{HARNESS_IGNORE_EXIT} || 0,
      );
  
      my $class = delete $input{harness_class} || $ENV{HARNESS_SUBCLASS} || 'TAP::Harness';
      if ( defined( my $env_opt = $ENV{HARNESS_OPTIONS} ) ) {
          for my $opt ( split /:/, $env_opt ) {
              if ( $opt =~ /^j(\d*)$/ ) {
                  $args{jobs} = $1 || 9;
              }
              elsif ( $opt eq 'c' ) {
                  $args{color} = 1;
              }
              elsif ( $opt =~ m/^f(.*)$/ ) {
                  my $fmt = $1;
                  $fmt =~ s/-/::/g;
                  $args{formatter_class} = $fmt;
              }
              elsif ( $opt =~ m/^a(.*)$/ ) {
                  my $archive = $1;
                  $class = 'TAP::Harness::Archive';
                  $args{archive} = $archive;
              }
              else {
                  die "Unknown HARNESS_OPTIONS item: $opt\n";
              }
          }
      }
      return TAP::Object->_construct($class, { %args, %input });
  }
  
  1;
  
  =head1 NAME
  
  TAP::Harness::Env - Parsing harness related environmental variables where appropriate
  
  =head1 VERSION
  
  Version 3.42
  
  =head1 SYNOPSIS
  
   my $harness = TAP::Harness::Env->create(\%extra_args)
  
  =head1 DESCRIPTION
  
  This module implements the environmental variables that L<Test::Harness> uses with TAP::Harness, and instantiates the appropriate class with the appropriate arguments.
  
  =head1 METHODS
  
  =over 4
  
  =item * create( \%args )
  
  This function reads the environment and generates an appropriate argument hash from it. If given any arguments in C<%extra_args>, these will override the environmental defaults. In accepts C<harness_class> (which defaults to C<TAP::Harness>), and any argument the harness class accepts.
  
  =back
  
  =head1 ENVIRONMENTAL VARIABLES
  
  =over 4
  
  =item C<HARNESS_PERL_SWITCHES>
  
  Setting this adds perl command line switches to each test file run.
  
  For example, C<HARNESS_PERL_SWITCHES=-T> will turn on taint mode.
  C<HARNESS_PERL_SWITCHES=-MDevel::Cover> will run C<Devel::Cover> for
  each test.
  
  =item C<HARNESS_VERBOSE>
  
  If true, C<TAP::Harness> will output the verbose results of running
  its tests.
  
  =item C<HARNESS_SUBCLASS>
  
  Specifies a TAP::Harness subclass to be used in place of TAP::Harness.
  
  =item C<HARNESS_OPTIONS>
  
  Provide additional options to the harness. Currently supported options are:
  
  =over
  
  =item C<< j<n> >>
  
  Run <n> (default 9) parallel jobs.
  
  =item C<< c >>
  
  Try to color output. See L<TAP::Formatter::Base/"new">.
  
  =item C<< a<file.tgz> >>
  
  Will use L<TAP::Harness::Archive> as the harness class, and save the TAP to
  C<file.tgz>
  
  =item C<< fPackage-With-Dashes >>
  
  Set the formatter_class of the harness being run. Since the C<HARNESS_OPTIONS>
  is seperated by C<:>, we use C<-> instead.
  
  =back
  
  Multiple options may be separated by colons:
  
      HARNESS_OPTIONS=j9:c make test
  
  =item C<HARNESS_TIMER>
  
  Setting this to true will make the harness display the number of
  milliseconds each test took.  You can also use F<prove>'s C<--timer>
  switch.
  
  =item C<HARNESS_COLOR>
  
  Attempt to produce color output.
  
  =item C<HARNESS_IGNORE_EXIT>
  
  If set to a true value instruct C<TAP::Parser> to ignore exit and wait
  status from test scripts.
  
  =back
TAP_HARNESS_ENV

$fatpacked{"TAP/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_OBJECT';
  package TAP::Object;
  
  use strict;
  use warnings;
  
  =head1 NAME
  
  TAP::Object - Base class that provides common functionality to all C<TAP::*> modules
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 SYNOPSIS
  
      package TAP::Whatever;
  
      use strict;
  
      use base 'TAP::Object';
  
      # new() implementation by TAP::Object
      sub _initialize {
          my ( $self, @args) = @_;
          # initialize your object
          return $self;
      }
  
      # ... later ...
      my $obj = TAP::Whatever->new(@args);
  
  =head1 DESCRIPTION
  
  C<TAP::Object> provides a default constructor and exception model for all
  C<TAP::*> classes.  Exceptions are raised using L<Carp>.
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
  Create a new object.  Any arguments passed to C<new> will be passed on to the
  L</_initialize> method.  Returns a new object.
  
  =cut
  
  sub new {
      my $class = shift;
      my $self = bless {}, $class;
      return $self->_initialize(@_);
  }
  
  =head2 Instance Methods
  
  =head3 C<_initialize>
  
  Initializes a new object.  This method is a stub by default, you should override
  it as appropriate.
  
  I<Note:> L</new> expects you to return C<$self> or raise an exception.  See
  L</_croak>, and L<Carp>.
  
  =cut
  
  sub _initialize {
      return $_[0];
  }
  
  =head3 C<_croak>
  
  Raise an exception using C<croak> from L<Carp>, eg:
  
      $self->_croak( 'why me?', 'aaarrgh!' );
  
  May also be called as a I<class> method.
  
      $class->_croak( 'this works too' );
  
  =cut
  
  sub _croak {
      my $proto = shift;
      require Carp;
      Carp::croak(@_);
      return;
  }
  
  =head3 C<_confess>
  
  Raise an exception using C<confess> from L<Carp>, eg:
  
      $self->_confess( 'why me?', 'aaarrgh!' );
  
  May also be called as a I<class> method.
  
      $class->_confess( 'this works too' );
  
  =cut
  
  sub _confess {
      my $proto = shift;
      require Carp;
      Carp::confess(@_);
      return;
  }
  
  =head3 C<_construct>
  
  Create a new instance of the specified class.
  
  =cut
  
  sub _construct {
      my ( $self, $class, @args ) = @_;
  
      $self->_croak("Bad module name $class")
        unless $class =~ /^ \w+ (?: :: \w+ ) *$/x;
  
      unless ( $class->can('new') ) {
          local $@;
          eval "require $class";
          $self->_croak("Can't load $class: $@") if $@;
      }
  
      return $class->new(@args);
  }
  
  =head3 C<mk_methods>
  
  Create simple getter/setters.
  
   __PACKAGE__->mk_methods(@method_names);
  
  =cut
  
  sub mk_methods {
      my ( $class, @methods ) = @_;
      for my $method_name (@methods) {
          my $method = "${class}::$method_name";
          no strict 'refs';
          *$method = sub {
              my $self = shift;
              $self->{$method_name} = shift if @_;
              return $self->{$method_name};
          };
      }
  }
  
  1;
  
TAP_OBJECT

$fatpacked{"TAP/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER';
  package TAP::Parser;
  
  use strict;
  use warnings;
  
  use TAP::Parser::Grammar                   ();
  use TAP::Parser::Result                    ();
  use TAP::Parser::ResultFactory             ();
  use TAP::Parser::Source                    ();
  use TAP::Parser::Iterator                  ();
  use TAP::Parser::IteratorFactory           ();
  use TAP::Parser::SourceHandler::Executable ();
  use TAP::Parser::SourceHandler::Perl       ();
  use TAP::Parser::SourceHandler::File       ();
  use TAP::Parser::SourceHandler::RawTAP     ();
  use TAP::Parser::SourceHandler::Handle     ();
  
  use Carp qw( confess );
  
  use base 'TAP::Base';
  
  =encoding utf8
  
  =head1 NAME
  
  TAP::Parser - Parse L<TAP|Test::Harness::TAP> output
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  my $DEFAULT_TAP_VERSION = 12;
  my $MAX_TAP_VERSION     = 13;
  
  $ENV{TAP_VERSION} = $MAX_TAP_VERSION;
  
  END {
  
      # For VMS.
      delete $ENV{TAP_VERSION};
  }
  
  BEGIN {    # making accessors
      __PACKAGE__->mk_methods(
          qw(
            _iterator
            _spool
            exec
            exit
            is_good_plan
            plan
            tests_planned
            tests_run
            wait
            version
            in_todo
            start_time
            end_time
            start_times
            end_times
            skip_all
            grammar_class
            result_factory_class
            iterator_factory_class
            )
      );
  
      sub _stream {    # deprecated
          my $self = shift;
          $self->_iterator(@_);
      }
  }    # done making accessors
  
  =head1 SYNOPSIS
  
      use TAP::Parser;
  
      my $parser = TAP::Parser->new( { source => $source } );
  
      while ( my $result = $parser->next ) {
          print $result->as_string;
      }
  
  =head1 DESCRIPTION
  
  C<TAP::Parser> is designed to produce a proper parse of TAP output. For
  an example of how to run tests through this module, see the simple
  harnesses C<examples/>.
  
  There's a wiki dedicated to the Test Anything Protocol:
  
  L<http://testanything.org>
  
  It includes the TAP::Parser Cookbook:
  
  L<http://testanything.org/testing-with-tap/perl/tap::parser-cookbook.html>
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
   my $parser = TAP::Parser->new(\%args);
  
  Returns a new C<TAP::Parser> object.
  
  The arguments should be a hashref with I<one> of the following keys:
  
  =over 4
  
  =item * C<source>
  
  I<CHANGED in 3.18>
  
  This is the preferred method of passing input to the constructor.
  
  The C<source> is used to create a L<TAP::Parser::Source> that is passed to the
  L</iterator_factory_class> which in turn figures out how to handle the source and
  creates a <TAP::Parser::Iterator> for it.  The iterator is used by the parser to
  read in the TAP stream.
  
  To configure the I<IteratorFactory> use the C<sources> parameter below.
  
  Note that C<source>, C<tap> and C<exec> are I<mutually exclusive>.
  
  =item * C<tap>
  
  I<CHANGED in 3.18>
  
  The value should be the complete TAP output.
  
  The I<tap> is used to create a L<TAP::Parser::Source> that is passed to the
  L</iterator_factory_class> which in turn figures out how to handle the source and
  creates a <TAP::Parser::Iterator> for it.  The iterator is used by the parser to
  read in the TAP stream.
  
  To configure the I<IteratorFactory> use the C<sources> parameter below.
  
  Note that C<source>, C<tap> and C<exec> are I<mutually exclusive>.
  
  =item * C<exec>
  
  Must be passed an array reference.
  
  The I<exec> array ref is used to create a L<TAP::Parser::Source> that is passed
  to the L</iterator_factory_class> which in turn figures out how to handle the
  source and creates a <TAP::Parser::Iterator> for it.  The iterator is used by
  the parser to read in the TAP stream.
  
  By default the L<TAP::Parser::SourceHandler::Executable> class will create a
  L<TAP::Parser::Iterator::Process> object to handle the source.  This passes the
  array reference strings as command arguments to L<IPC::Open3::open3|IPC::Open3>:
  
   exec => [ '/usr/bin/ruby', 't/my_test.rb' ]
  
  If any C<test_args> are given they will be appended to the end of the command
  argument list.
  
  To configure the I<IteratorFactory> use the C<sources> parameter below.
  
  Note that C<source>, C<tap> and C<exec> are I<mutually exclusive>.
  
  =back
  
  The following keys are optional.
  
  =over 4
  
  =item * C<sources>
  
  I<NEW to 3.18>.
  
  If set, C<sources> must be a hashref containing the names of the
  L<TAP::Parser::SourceHandler>s to load and/or configure.  The values are a
  hash of configuration that will be accessible to the source handlers via
  L<TAP::Parser::Source/config_for>.
  
  For example:
  
    sources => {
      Perl => { exec => '/path/to/custom/perl' },
      File => { extensions => [ '.tap', '.txt' ] },
      MyCustom => { some => 'config' },
    }
  
  This will cause C<TAP::Parser> to pass custom configuration to two of the built-
  in source handlers - L<TAP::Parser::SourceHandler::Perl>,
  L<TAP::Parser::SourceHandler::File> - and attempt to load the C<MyCustom>
  class.  See L<TAP::Parser::IteratorFactory/load_handlers> for more detail.
  
  The C<sources> parameter affects how C<source>, C<tap> and C<exec> parameters
  are handled.
  
  See L<TAP::Parser::IteratorFactory>, L<TAP::Parser::SourceHandler> and subclasses for
  more details.
  
  =item * C<callback>
  
  If present, each callback corresponding to a given result type will be called
  with the result as the argument if the C<run> method is used:
  
   my %callbacks = (
       test    => \&test_callback,
       plan    => \&plan_callback,
       comment => \&comment_callback,
       bailout => \&bailout_callback,
       unknown => \&unknown_callback,
   );
  
   my $aggregator = TAP::Parser::Aggregator->new;
   for my $file ( @test_files ) {
       my $parser = TAP::Parser->new(
           {
               source    => $file,
               callbacks => \%callbacks,
           }
       );
       $parser->run;
       $aggregator->add( $file, $parser );
   }
  
  =item * C<switches>
  
  If using a Perl file as a source, optional switches may be passed which will
  be used when invoking the perl executable.
  
   my $parser = TAP::Parser->new( {
       source   => $test_file,
       switches => [ '-Ilib' ],
   } );
  
  =item * C<test_args>
  
  Used in conjunction with the C<source> and C<exec> option to supply a reference
  to an C<@ARGV> style array of arguments to pass to the test program.
  
  =item * C<spool>
  
  If passed a filehandle will write a copy of all parsed TAP to that handle.
  
  =item * C<merge>
  
  If false, STDERR is not captured (though it is 'relayed' to keep it
  somewhat synchronized with STDOUT.)
  
  If true, STDERR and STDOUT are the same filehandle.  This may cause
  breakage if STDERR contains anything resembling TAP format, but does
  allow exact synchronization.
  
  Subtleties of this behavior may be platform-dependent and may change in
  the future.
  
  =item * C<grammar_class>
  
  This option was introduced to let you easily customize which I<grammar> class
  the parser should use.  It defaults to L<TAP::Parser::Grammar>.
  
  See also L</make_grammar>.
  
  =item * C<result_factory_class>
  
  This option was introduced to let you easily customize which I<result>
  factory class the parser should use.  It defaults to
  L<TAP::Parser::ResultFactory>.
  
  See also L</make_result>.
  
  =item * C<iterator_factory_class>
  
  I<CHANGED in 3.18>
  
  This option was introduced to let you easily customize which I<iterator>
  factory class the parser should use.  It defaults to
  L<TAP::Parser::IteratorFactory>.
  
  =back
  
  =cut
  
  # new() implementation supplied by TAP::Base
  
  # This should make overriding behaviour of the Parser in subclasses easier:
  sub _default_grammar_class          {'TAP::Parser::Grammar'}
  sub _default_result_factory_class   {'TAP::Parser::ResultFactory'}
  sub _default_iterator_factory_class {'TAP::Parser::IteratorFactory'}
  
  ##############################################################################
  
  =head2 Instance Methods
  
  =head3 C<next>
  
    my $parser = TAP::Parser->new( { source => $file } );
    while ( my $result = $parser->next ) {
        print $result->as_string, "\n";
    }
  
  This method returns the results of the parsing, one result at a time.  Note
  that it is destructive.  You can't rewind and examine previous results.
  
  If callbacks are used, they will be issued before this call returns.
  
  Each result returned is a subclass of L<TAP::Parser::Result>.  See that
  module and related classes for more information on how to use them.
  
  =cut
  
  sub next {
      my $self = shift;
      return ( $self->{_iter} ||= $self->_iter )->();
  }
  
  ##############################################################################
  
  =head3 C<run>
  
    $parser->run;
  
  This method merely runs the parser and parses all of the TAP.
  
  =cut
  
  sub run {
      my $self = shift;
      while ( defined( my $result = $self->next ) ) {
  
          # do nothing
      }
  }
  
  ##############################################################################
  
  =head3 C<make_grammar>
  
  Make a new L<TAP::Parser::Grammar> object and return it.  Passes through any
  arguments given.
  
  The C<grammar_class> can be customized, as described in L</new>.
  
  =head3 C<make_result>
  
  Make a new L<TAP::Parser::Result> object using the parser's
  L<TAP::Parser::ResultFactory>, and return it.  Passes through any arguments
  given.
  
  The C<result_factory_class> can be customized, as described in L</new>.
  
  =head3 C<make_iterator_factory>
  
  I<NEW to 3.18>.
  
  Make a new L<TAP::Parser::IteratorFactory> object and return it.  Passes through
  any arguments given.
  
  C<iterator_factory_class> can be customized, as described in L</new>.
  
  =cut
  
  # This should make overriding behaviour of the Parser in subclasses easier:
  sub make_iterator_factory { shift->iterator_factory_class->new(@_); }
  sub make_grammar          { shift->grammar_class->new(@_); }
  sub make_result           { shift->result_factory_class->make_result(@_); }
  
  {
  
      # of the following, anything beginning with an underscore is strictly
      # internal and should not be exposed.
      my %initialize = (
          version       => $DEFAULT_TAP_VERSION,
          plan          => '',                    # the test plan (e.g., 1..3)
          tests_run     => 0,                     # actual current test numbers
          skipped       => [],                    #
          todo          => [],                    #
          passed        => [],                    #
          failed        => [],                    #
          actual_failed => [],                    # how many tests really failed
          actual_passed => [],                    # how many tests really passed
          todo_passed  => [],    # tests which unexpectedly succeed
          parse_errors => [],    # perfect TAP should have none
      );
  
      # We seem to have this list hanging around all over the place. We could
      #probably get it from somewhere else to avoid the repetition.
      my @legal_callback = qw(
        test
        version
        plan
        comment
        bailout
        unknown
        yaml
        ALL
        ELSE
        EOF
      );
  
      my @class_overrides = qw(
        grammar_class
        result_factory_class
        iterator_factory_class
      );
  
      sub _initialize {
          my ( $self, $arg_for ) = @_;
  
          # everything here is basically designed to convert any TAP source to a
          # TAP::Parser::Iterator.
  
          # Shallow copy
          my %args = %{ $arg_for || {} };
  
          $self->SUPER::_initialize( \%args, \@legal_callback );
  
          # get any class overrides out first:
          for my $key (@class_overrides) {
              my $default_method = "_default_$key";
              my $val = delete $args{$key} || $self->$default_method();
              $self->$key($val);
          }
  
          my $iterator = delete $args{iterator};
          $iterator ||= delete $args{stream};    # deprecated
          my $tap         = delete $args{tap};
          my $version     = delete $args{version};
          my $raw_source  = delete $args{source};
          my $sources     = delete $args{sources};
          my $exec        = delete $args{exec};
          my $merge       = delete $args{merge};
          my $spool       = delete $args{spool};
          my $switches    = delete $args{switches};
          my $ignore_exit = delete $args{ignore_exit};
          my $test_args   = delete $args{test_args} || [];
  
          if ( 1 < grep {defined} $iterator, $tap, $raw_source, $exec ) {
              $self->_croak(
                  "You may only choose one of 'exec', 'tap', 'source' or 'iterator'"
              );
          }
  
          if ( my @excess = sort keys %args ) {
              $self->_croak("Unknown options: @excess");
          }
  
          # convert $tap & $exec to $raw_source equiv.
          my $type   = '';
          my $source = TAP::Parser::Source->new;
          if ($tap) {
              $type = 'raw TAP';
              $source->raw( \$tap );
          }
          elsif ($exec) {
              $type = 'exec ' . $exec->[0];
              $source->raw( { exec => $exec } );
          }
          elsif ($raw_source) {
              $type = 'source ' . ref($raw_source) || $raw_source;
              $source->raw( ref($raw_source) ? $raw_source : \$raw_source );
          }
          elsif ($iterator) {
              $type = 'iterator ' . ref($iterator);
          }
  
          if ( $source->raw ) {
              my $src_factory = $self->make_iterator_factory($sources);
              $source->merge($merge)->switches($switches)
                ->test_args($test_args);
              $iterator = $src_factory->make_iterator($source);
          }
  
          unless ($iterator) {
              $self->_croak(
                  "PANIC: could not determine iterator for input $type");
          }
  
          while ( my ( $k, $v ) = each %initialize ) {
              $self->{$k} = 'ARRAY' eq ref $v ? [] : $v;
          }
  
          $self->version($version) if $version;
          $self->_iterator($iterator);
          $self->_spool($spool);
          $self->ignore_exit($ignore_exit);
  
          return $self;
      }
  }
  
  =head1 INDIVIDUAL RESULTS
  
  If you've read this far in the docs, you've seen this:
  
      while ( my $result = $parser->next ) {
          print $result->as_string;
      }
  
  Each result returned is a L<TAP::Parser::Result> subclass, referred to as
  I<result types>.
  
  =head2 Result types
  
  Basically, you fetch individual results from the TAP.  The six types, with
  examples of each, are as follows:
  
  =over 4
  
  =item * Version
  
   TAP version 12
  
  =item * Plan
  
   1..42
  
  =item * Pragma
  
   pragma +strict
  
  =item * Test
  
   ok 3 - We should start with some foobar!
  
  =item * Comment
  
   # Hope we don't use up the foobar.
  
  =item * Bailout
  
   Bail out!  We ran out of foobar!
  
  =item * Unknown
  
   ... yo, this ain't TAP! ...
  
  =back
  
  Each result fetched is a result object of a different type.  There are common
  methods to each result object and different types may have methods unique to
  their type.  Sometimes a type method may be overridden in a subclass, but its
  use is guaranteed to be identical.
  
  =head2 Common type methods
  
  =head3 C<type>
  
  Returns the type of result, such as C<comment> or C<test>.
  
  =head3 C<as_string>
  
  Prints a string representation of the token.  This might not be the exact
  output, however.  Tests will have test numbers added if not present, TODO and
  SKIP directives will be capitalized and, in general, things will be cleaned
  up.  If you need the original text for the token, see the C<raw> method.
  
  =head3  C<raw>
  
  Returns the original line of text which was parsed.
  
  =head3 C<is_plan>
  
  Indicates whether or not this is the test plan line.
  
  =head3 C<is_test>
  
  Indicates whether or not this is a test line.
  
  =head3 C<is_comment>
  
  Indicates whether or not this is a comment. Comments will generally only
  appear in the TAP stream if STDERR is merged to STDOUT. See the
  C<merge> option.
  
  =head3 C<is_bailout>
  
  Indicates whether or not this is bailout line.
  
  =head3 C<is_yaml>
  
  Indicates whether or not the current item is a YAML block.
  
  =head3 C<is_unknown>
  
  Indicates whether or not the current line could be parsed.
  
  =head3 C<is_ok>
  
    if ( $result->is_ok ) { ... }
  
  Reports whether or not a given result has passed.  Anything which is B<not> a
  test result returns true.  This is merely provided as a convenient shortcut
  which allows you to do this:
  
   my $parser = TAP::Parser->new( { source => $source } );
   while ( my $result = $parser->next ) {
       # only print failing results
       print $result->as_string unless $result->is_ok;
   }
  
  =head2 C<plan> methods
  
   if ( $result->is_plan ) { ... }
  
  If the above evaluates as true, the following methods will be available on the
  C<$result> object.
  
  =head3 C<plan>
  
    if ( $result->is_plan ) {
       print $result->plan;
    }
  
  This is merely a synonym for C<as_string>.
  
  =head3 C<directive>
  
   my $directive = $result->directive;
  
  If a SKIP directive is included with the plan, this method will return it.
  
   1..0 # SKIP: why bother?
  
  =head3 C<explanation>
  
   my $explanation = $result->explanation;
  
  If a SKIP directive was included with the plan, this method will return the
  explanation, if any.
  
  =head2 C<pragma> methods
  
   if ( $result->is_pragma ) { ... }
  
  If the above evaluates as true, the following methods will be available on the
  C<$result> object.
  
  =head3 C<pragmas>
  
  Returns a list of pragmas each of which is a + or - followed by the
  pragma name.
  
  =head2 C<comment> methods
  
   if ( $result->is_comment ) { ... }
  
  If the above evaluates as true, the following methods will be available on the
  C<$result> object.
  
  =head3 C<comment>
  
    if ( $result->is_comment ) {
        my $comment = $result->comment;
        print "I have something to say:  $comment";
    }
  
  =head2 C<bailout> methods
  
   if ( $result->is_bailout ) { ... }
  
  If the above evaluates as true, the following methods will be available on the
  C<$result> object.
  
  =head3 C<explanation>
  
    if ( $result->is_bailout ) {
        my $explanation = $result->explanation;
        print "We bailed out because ($explanation)";
    }
  
  If, and only if, a token is a bailout token, you can get an "explanation" via
  this method.  The explanation is the text after the mystical "Bail out!" words
  which appear in the tap output.
  
  =head2 C<unknown> methods
  
   if ( $result->is_unknown ) { ... }
  
  There are no unique methods for unknown results.
  
  =head2 C<test> methods
  
   if ( $result->is_test ) { ... }
  
  If the above evaluates as true, the following methods will be available on the
  C<$result> object.
  
  =head3 C<ok>
  
    my $ok = $result->ok;
  
  Returns the literal text of the C<ok> or C<not ok> status.
  
  =head3 C<number>
  
    my $test_number = $result->number;
  
  Returns the number of the test, even if the original TAP output did not supply
  that number.
  
  =head3 C<description>
  
    my $description = $result->description;
  
  Returns the description of the test, if any.  This is the portion after the
  test number but before the directive.
  
  =head3 C<directive>
  
    my $directive = $result->directive;
  
  Returns either C<TODO> or C<SKIP> if either directive was present for a test
  line.
  
  =head3 C<explanation>
  
    my $explanation = $result->explanation;
  
  If a test had either a C<TODO> or C<SKIP> directive, this method will return
  the accompanying explanation, if present.
  
    not ok 17 - 'Pigs can fly' # TODO not enough acid
  
  For the above line, the explanation is I<not enough acid>.
  
  =head3 C<is_ok>
  
    if ( $result->is_ok ) { ... }
  
  Returns a boolean value indicating whether or not the test passed.  Remember
  that for TODO tests, the test always passes.
  
  B<Note:>  this was formerly C<passed>.  The latter method is deprecated and
  will issue a warning.
  
  =head3 C<is_actual_ok>
  
    if ( $result->is_actual_ok ) { ... }
  
  Returns a boolean value indicating whether or not the test passed, regardless
  of its TODO status.
  
  B<Note:>  this was formerly C<actual_passed>.  The latter method is deprecated
  and will issue a warning.
  
  =head3 C<is_unplanned>
  
    if ( $test->is_unplanned ) { ... }
  
  If a test number is greater than the number of planned tests, this method will
  return true.  Unplanned tests will I<always> return false for C<is_ok>,
  regardless of whether or not the test C<has_todo> (see
  L<TAP::Parser::Result::Test> for more information about this).
  
  =head3 C<has_skip>
  
    if ( $result->has_skip ) { ... }
  
  Returns a boolean value indicating whether or not this test had a SKIP
  directive.
  
  =head3 C<has_todo>
  
    if ( $result->has_todo ) { ... }
  
  Returns a boolean value indicating whether or not this test had a TODO
  directive.
  
  Note that TODO tests I<always> pass.  If you need to know whether or not
  they really passed, check the C<is_actual_ok> method.
  
  =head3 C<in_todo>
  
    if ( $parser->in_todo ) { ... }
  
  True while the most recent result was a TODO. Becomes true before the
  TODO result is returned and stays true until just before the next non-
  TODO test is returned.
  
  =head1 TOTAL RESULTS
  
  After parsing the TAP, there are many methods available to let you dig through
  the results and determine what is meaningful to you.
  
  =head2 Individual Results
  
  These results refer to individual tests which are run.
  
  =head3 C<passed>
  
   my @passed = $parser->passed; # the test numbers which passed
   my $passed = $parser->passed; # the number of tests which passed
  
  This method lets you know which (or how many) tests passed.  If a test failed
  but had a TODO directive, it will be counted as a passed test.
  
  =cut
  
  sub passed {
      return @{ $_[0]->{passed} }
        if ref $_[0]->{passed};
      return wantarray ? 1 .. $_[0]->{passed} : $_[0]->{passed};
  }
  
  =head3 C<failed>
  
   my @failed = $parser->failed; # the test numbers which failed
   my $failed = $parser->failed; # the number of tests which failed
  
  This method lets you know which (or how many) tests failed.  If a test passed
  but had a TODO directive, it will B<NOT> be counted as a failed test.
  
  =cut
  
  sub failed { @{ shift->{failed} } }
  
  =head3 C<actual_passed>
  
   # the test numbers which actually passed
   my @actual_passed = $parser->actual_passed;
  
   # the number of tests which actually passed
   my $actual_passed = $parser->actual_passed;
  
  This method lets you know which (or how many) tests actually passed,
  regardless of whether or not a TODO directive was found.
  
  =cut
  
  sub actual_passed {
      return @{ $_[0]->{actual_passed} }
        if ref $_[0]->{actual_passed};
      return wantarray ? 1 .. $_[0]->{actual_passed} : $_[0]->{actual_passed};
  }
  *actual_ok = \&actual_passed;
  
  =head3 C<actual_ok>
  
  This method is a synonym for C<actual_passed>.
  
  =head3 C<actual_failed>
  
   # the test numbers which actually failed
   my @actual_failed = $parser->actual_failed;
  
   # the number of tests which actually failed
   my $actual_failed = $parser->actual_failed;
  
  This method lets you know which (or how many) tests actually failed,
  regardless of whether or not a TODO directive was found.
  
  =cut
  
  sub actual_failed { @{ shift->{actual_failed} } }
  
  ##############################################################################
  
  =head3 C<todo>
  
   my @todo = $parser->todo; # the test numbers with todo directives
   my $todo = $parser->todo; # the number of tests with todo directives
  
  This method lets you know which (or how many) tests had TODO directives.
  
  =cut
  
  sub todo { @{ shift->{todo} } }
  
  =head3 C<todo_passed>
  
   # the test numbers which unexpectedly succeeded
   my @todo_passed = $parser->todo_passed;
  
   # the number of tests which unexpectedly succeeded
   my $todo_passed = $parser->todo_passed;
  
  This method lets you know which (or how many) tests actually passed but were
  declared as "TODO" tests.
  
  =cut
  
  sub todo_passed { @{ shift->{todo_passed} } }
  
  ##############################################################################
  
  =head3 C<todo_failed>
  
    # deprecated in favor of 'todo_passed'.  This method was horribly misnamed.
  
  This was a badly misnamed method.  It indicates which TODO tests unexpectedly
  succeeded.  Will now issue a warning and call C<todo_passed>.
  
  =cut
  
  sub todo_failed {
      warn
        '"todo_failed" is deprecated.  Please use "todo_passed".  See the docs.';
      goto &todo_passed;
  }
  
  =head3 C<skipped>
  
   my @skipped = $parser->skipped; # the test numbers with SKIP directives
   my $skipped = $parser->skipped; # the number of tests with SKIP directives
  
  This method lets you know which (or how many) tests had SKIP directives.
  
  =cut
  
  sub skipped { @{ shift->{skipped} } }
  
  =head2 Pragmas
  
  =head3 C<pragma>
  
  Get or set a pragma. To get the state of a pragma:
  
    if ( $p->pragma('strict') ) {
        # be strict
    }
  
  To set the state of a pragma:
  
    $p->pragma('strict', 1); # enable strict mode
  
  =cut
  
  sub pragma {
      my ( $self, $pragma ) = splice @_, 0, 2;
  
      return $self->{pragma}->{$pragma} unless @_;
  
      if ( my $state = shift ) {
          $self->{pragma}->{$pragma} = 1;
      }
      else {
          delete $self->{pragma}->{$pragma};
      }
  
      return;
  }
  
  =head3 C<pragmas>
  
  Get a list of all the currently enabled pragmas:
  
    my @pragmas_enabled = $p->pragmas;
  
  =cut
  
  sub pragmas { sort keys %{ shift->{pragma} || {} } }
  
  =head2 Summary Results
  
  These results are "meta" information about the total results of an individual
  test program.
  
  =head3 C<plan>
  
   my $plan = $parser->plan;
  
  Returns the test plan, if found.
  
  =head3 C<good_plan>
  
  Deprecated.  Use C<is_good_plan> instead.
  
  =cut
  
  sub good_plan {
      warn 'good_plan() is deprecated.  Please use "is_good_plan()"';
      goto &is_good_plan;
  }
  
  ##############################################################################
  
  =head3 C<is_good_plan>
  
    if ( $parser->is_good_plan ) { ... }
  
  Returns a boolean value indicating whether or not the number of tests planned
  matches the number of tests run.
  
  B<Note:>  this was formerly C<good_plan>.  The latter method is deprecated and
  will issue a warning.
  
  And since we're on that subject ...
  
  =head3 C<tests_planned>
  
    print $parser->tests_planned;
  
  Returns the number of tests planned, according to the plan.  For example, a
  plan of '1..17' will mean that 17 tests were planned.
  
  =head3 C<tests_run>
  
    print $parser->tests_run;
  
  Returns the number of tests which actually were run.  Hopefully this will
  match the number of C<< $parser->tests_planned >>.
  
  =head3 C<skip_all>
  
  Returns a true value (actually the reason for skipping) if all tests
  were skipped.
  
  =head3 C<start_time>
  
  Returns the wall-clock time when the Parser was created.
  
  =head3 C<end_time>
  
  Returns the wall-clock time when the end of TAP input was seen.
  
  =head3 C<start_times>
  
  Returns the CPU times (like L<perlfunc/times> when the Parser was created.
  
  =head3 C<end_times>
  
  Returns the CPU times (like L<perlfunc/times> when the end of TAP
  input was seen.
  
  =head3 C<has_problems>
  
    if ( $parser->has_problems ) {
        ...
    }
  
  This is a 'catch-all' method which returns true if any tests have currently
  failed, any TODO tests unexpectedly succeeded, or any parse errors occurred.
  
  =cut
  
  sub has_problems {
      my $self = shift;
      return
           $self->failed
        || $self->parse_errors
        || ( !$self->ignore_exit && ( $self->wait || $self->exit ) );
  }
  
  =head3 C<version>
  
    $parser->version;
  
  Once the parser is done, this will return the version number for the
  parsed TAP. Version numbers were introduced with TAP version 13 so if no
  version number is found version 12 is assumed.
  
  =head3 C<exit>
  
    $parser->exit;
  
  Once the parser is done, this will return the exit status.  If the parser ran
  an executable, it returns the exit status of the executable.
  
  =head3 C<wait>
  
    $parser->wait;
  
  Once the parser is done, this will return the wait status.  If the parser ran
  an executable, it returns the wait status of the executable.  Otherwise, this
  merely returns the C<exit> status.
  
  =head2 C<ignore_exit>
  
    $parser->ignore_exit(1);
  
  Tell the parser to ignore the exit status from the test when determining
  whether the test passed. Normally tests with non-zero exit status are
  considered to have failed even if all individual tests passed. In cases
  where it is not possible to control the exit value of the test script
  use this option to ignore it.
  
  =cut
  
  sub ignore_exit { shift->pragma( 'ignore_exit', @_ ) }
  
  =head3 C<parse_errors>
  
   my @errors = $parser->parse_errors; # the parser errors
   my $errors = $parser->parse_errors; # the number of parser_errors
  
  Fortunately, all TAP output is perfect.  In the event that it is not, this
  method will return parser errors.  Note that a junk line which the parser does
  not recognize is C<not> an error.  This allows this parser to handle future
  versions of TAP.  The following are all TAP errors reported by the parser:
  
  =over 4
  
  =item * Misplaced plan
  
  The plan (for example, '1..5'), must only come at the beginning or end of the
  TAP output.
  
  =item * No plan
  
  Gotta have a plan!
  
  =item * More than one plan
  
   1..3
   ok 1 - input file opened
   not ok 2 - first line of the input valid # todo some data
   ok 3 read the rest of the file
   1..3
  
  Right.  Very funny.  Don't do that.
  
  =item * Test numbers out of sequence
  
   1..3
   ok 1 - input file opened
   not ok 2 - first line of the input valid # todo some data
   ok 2 read the rest of the file
  
  That last test line above should have the number '3' instead of '2'.
  
  Note that it's perfectly acceptable for some lines to have test numbers and
  others to not have them.  However, when a test number is found, it must be in
  sequence.  The following is also an error:
  
   1..3
   ok 1 - input file opened
   not ok - first line of the input valid # todo some data
   ok 2 read the rest of the file
  
  But this is not:
  
   1..3
   ok  - input file opened
   not ok - first line of the input valid # todo some data
   ok 3 read the rest of the file
  
  =back
  
  =cut
  
  sub parse_errors { @{ shift->{parse_errors} } }
  
  sub _add_error {
      my ( $self, $error ) = @_;
      push @{ $self->{parse_errors} } => $error;
      return $self;
  }
  
  sub _make_state_table {
      my $self = shift;
      my %states;
      my %planned_todo = ();
  
      #These transitions are defaults for all states
      my %state_globals = (
          comment => {},
          bailout => {},
          yaml    => {},
          version => {
              act => sub {
                  $self->_add_error(
                      'If TAP version is present it must be the first line of output'
                  );
              },
          },
          unknown => {
              act => sub {
                  my $unk = shift;
                  if ( $self->pragma('strict') ) {
                      $self->_add_error(
                          'Unknown TAP token: "' . $unk->raw . '"' );
                  }
              },
          },
          pragma => {
              act => sub {
                  my ($pragma) = @_;
                  for my $pr ( $pragma->pragmas ) {
                      if ( $pr =~ /^ ([-+])(\w+) $/x ) {
                          $self->pragma( $2, $1 eq '+' );
                      }
                  }
              },
          },
      );
  
      # Provides default elements for transitions
      my %state_defaults = (
          plan => {
              act => sub {
                  my ($plan) = @_;
                  $self->tests_planned( $plan->tests_planned );
                  $self->plan( $plan->plan );
                  if ( $plan->has_skip ) {
                      $self->skip_all( $plan->explanation
                            || '(no reason given)' );
                  }
  
                  $planned_todo{$_}++ for @{ $plan->todo_list };
              },
          },
          test => {
              act => sub {
                  my ($test) = @_;
  
                  my ( $number, $tests_run )
                    = ( $test->number, ++$self->{tests_run} );
  
                  # Fake TODO state
                  if ( defined $number && delete $planned_todo{$number} ) {
                      $test->set_directive('TODO');
                  }
  
                  my $has_todo = $test->has_todo;
  
                  $self->in_todo($has_todo);
                  if ( defined( my $tests_planned = $self->tests_planned ) ) {
                      if ( $tests_run > $tests_planned ) {
                          $test->is_unplanned(1);
                      }
                  }
  
                  if ( defined $number ) {
                      if ( $number != $tests_run ) {
                          my $count = $tests_run;
                          $self->_add_error( "Tests out of sequence.  Found "
                                . "($number) but expected ($count)" );
                      }
                  }
                  else {
                      $test->_number( $number = $tests_run );
                  }
  
                  push @{ $self->{todo} } => $number if $has_todo;
                  push @{ $self->{todo_passed} } => $number
                    if $test->todo_passed;
                  push @{ $self->{skipped} } => $number
                    if $test->has_skip;
  
                  push @{ $self->{ $test->is_ok ? 'passed' : 'failed' } } =>
                    $number;
                  push @{
                      $self->{
                          $test->is_actual_ok
                          ? 'actual_passed'
                          : 'actual_failed'
                        }
                    } => $number;
              },
          },
          yaml => { act => sub { }, },
      );
  
      # Each state contains a hash the keys of which match a token type. For
      # each token
      # type there may be:
      #   act      A coderef to run
      #   goto     The new state to move to. Stay in this state if
      #            missing
      #   continue Goto the new state and run the new state for the
      #            current token
      %states = (
          INIT => {
              version => {
                  act => sub {
                      my ($version) = @_;
                      my $ver_num = $version->version;
                      if ( $ver_num <= $DEFAULT_TAP_VERSION ) {
                          my $ver_min = $DEFAULT_TAP_VERSION + 1;
                          $self->_add_error(
                                  "Explicit TAP version must be at least "
                                . "$ver_min. Got version $ver_num" );
                          $ver_num = $DEFAULT_TAP_VERSION;
                      }
                      if ( $ver_num > $MAX_TAP_VERSION ) {
                          $self->_add_error(
                                  "TAP specified version $ver_num but "
                                . "we don't know about versions later "
                                . "than $MAX_TAP_VERSION" );
                          $ver_num = $MAX_TAP_VERSION;
                      }
                      $self->version($ver_num);
                      $self->_grammar->set_version($ver_num);
                  },
                  goto => 'PLAN'
              },
              plan => { goto => 'PLANNED' },
              test => { goto => 'UNPLANNED' },
          },
          PLAN => {
              plan => { goto => 'PLANNED' },
              test => { goto => 'UNPLANNED' },
          },
          PLANNED => {
              test => { goto => 'PLANNED_AFTER_TEST' },
              plan => {
                  act => sub {
                      my ($version) = @_;
                      $self->_add_error(
                          'More than one plan found in TAP output');
                  },
              },
          },
          PLANNED_AFTER_TEST => {
              test => { goto => 'PLANNED_AFTER_TEST' },
              plan => { act  => sub { }, continue => 'PLANNED' },
              yaml => { goto => 'PLANNED' },
          },
          GOT_PLAN => {
              test => {
                  act => sub {
                      my ($plan) = @_;
                      my $line = $self->plan;
                      $self->_add_error(
                              "Plan ($line) must be at the beginning "
                            . "or end of the TAP output" );
                      $self->is_good_plan(0);
                  },
                  continue => 'PLANNED'
              },
              plan => { continue => 'PLANNED' },
          },
          UNPLANNED => {
              test => { goto => 'UNPLANNED_AFTER_TEST' },
              plan => { goto => 'GOT_PLAN' },
          },
          UNPLANNED_AFTER_TEST => {
              test => { act  => sub { }, continue => 'UNPLANNED' },
              plan => { act  => sub { }, continue => 'UNPLANNED' },
              yaml => { goto => 'UNPLANNED' },
          },
      );
  
      # Apply globals and defaults to state table
      for my $name ( keys %states ) {
  
          # Merge with globals
          my $st = { %state_globals, %{ $states{$name} } };
  
          # Add defaults
          for my $next ( sort keys %{$st} ) {
              if ( my $default = $state_defaults{$next} ) {
                  for my $def ( sort keys %{$default} ) {
                      $st->{$next}->{$def} ||= $default->{$def};
                  }
              }
          }
  
          # Stuff back in table
          $states{$name} = $st;
      }
  
      return \%states;
  }
  
  =head3 C<get_select_handles>
  
  Get an a list of file handles which can be passed to C<select> to
  determine the readiness of this parser.
  
  =cut
  
  sub get_select_handles { shift->_iterator->get_select_handles }
  
  sub _grammar {
      my $self = shift;
      return $self->{_grammar} = shift if @_;
  
      return $self->{_grammar} ||= $self->make_grammar(
          {   iterator => $self->_iterator,
              parser   => $self,
              version  => $self->version
          }
      );
  }
  
  sub _iter {
      my $self        = shift;
      my $iterator    = $self->_iterator;
      my $grammar     = $self->_grammar;
      my $spool       = $self->_spool;
      my $state       = 'INIT';
      my $state_table = $self->_make_state_table;
  
      $self->start_time( $self->get_time );
      $self->start_times( $self->get_times );
  
      # Make next_state closure
      my $next_state = sub {
          my $token = shift;
          my $type  = $token->type;
          TRANS: {
              my $state_spec = $state_table->{$state}
                or die "Illegal state: $state";
  
              if ( my $next = $state_spec->{$type} ) {
                  if ( my $act = $next->{act} ) {
                      $act->($token);
                  }
                  if ( my $cont = $next->{continue} ) {
                      $state = $cont;
                      redo TRANS;
                  }
                  elsif ( my $goto = $next->{goto} ) {
                      $state = $goto;
                  }
              }
              else {
                  confess("Unhandled token type: $type\n");
              }
          }
          return $token;
      };
  
      # Handle end of stream - which means either pop a block or finish
      my $end_handler = sub {
          $self->exit( $iterator->exit );
          $self->wait( $iterator->wait );
          $self->_finish;
          return;
      };
  
      # Finally make the closure that we return. For performance reasons
      # there are two versions of the returned function: one that handles
      # callbacks and one that does not.
      if ( $self->_has_callbacks ) {
          return sub {
              my $result = eval { $grammar->tokenize };
              $self->_add_error($@) if $@;
  
              if ( defined $result ) {
                  $result = $next_state->($result);
  
                  if ( my $code = $self->_callback_for( $result->type ) ) {
                      $_->($result) for @{$code};
                  }
                  else {
                      $self->_make_callback( 'ELSE', $result );
                  }
  
                  $self->_make_callback( 'ALL', $result );
  
                  # Echo TAP to spool file
                  print {$spool} $result->raw, "\n" if $spool;
              }
              else {
                  $result = $end_handler->();
                  $self->_make_callback( 'EOF', $self )
                    unless defined $result;
              }
  
              return $result;
          };
      }    # _has_callbacks
      else {
          return sub {
              my $result = eval { $grammar->tokenize };
              $self->_add_error($@) if $@;
  
              if ( defined $result ) {
                  $result = $next_state->($result);
  
                  # Echo TAP to spool file
                  print {$spool} $result->raw, "\n" if $spool;
              }
              else {
                  $result = $end_handler->();
              }
  
              return $result;
          };
      }    # no callbacks
  }
  
  sub _finish {
      my $self = shift;
  
      $self->end_time( $self->get_time );
      $self->end_times( $self->get_times );
  
      # Avoid leaks
      $self->_iterator(undef);
      $self->_grammar(undef);
  
      # If we just delete the iter we won't get a fault if it's recreated.
      # Instead we set it to a sub that returns an infinite
      # stream of undef. This segfaults on 5.5.4, presumably because
      # we're still executing the closure that gets replaced and it hasn't
      # been protected with a refcount.
      $self->{_iter} = sub {return}
        if $] >= 5.006;
  
      # sanity checks
      if ( !$self->plan ) {
          $self->_add_error('No plan found in TAP output');
      }
      else {
          $self->is_good_plan(1) unless defined $self->is_good_plan;
      }
      if ( $self->tests_run != ( $self->tests_planned || 0 ) ) {
          $self->is_good_plan(0);
          if ( defined( my $planned = $self->tests_planned ) ) {
              my $ran = $self->tests_run;
              $self->_add_error(
                  "Bad plan.  You planned $planned tests but ran $ran.");
          }
      }
      if ( $self->tests_run != ( $self->passed + $self->failed ) ) {
  
          # this should never happen
          my $actual = $self->tests_run;
          my $passed = $self->passed;
          my $failed = $self->failed;
          $self->_croak( "Panic: planned test count ($actual) did not equal "
                . "sum of passed ($passed) and failed ($failed) tests!" );
      }
  
      $self->is_good_plan(0) unless defined $self->is_good_plan;
  
      unless ( $self->parse_errors ) {
          # Optimise storage where possible
          if ( $self->tests_run == @{$self->{passed}} ) {
              $self->{passed} = $self->tests_run;
          }
          if ( $self->tests_run == @{$self->{actual_passed}} ) {
              $self->{actual_passed} = $self->tests_run;
          }
      }
  
      return $self;
  }
  
  =head3 C<delete_spool>
  
  Delete and return the spool.
  
    my $fh = $parser->delete_spool;
  
  =cut
  
  sub delete_spool {
      my $self = shift;
  
      return delete $self->{_spool};
  }
  
  ##############################################################################
  
  =head1 CALLBACKS
  
  As mentioned earlier, a "callback" key may be added to the
  C<TAP::Parser> constructor. If present, each callback corresponding to a
  given result type will be called with the result as the argument if the
  C<run> method is used. The callback is expected to be a subroutine
  reference (or anonymous subroutine) which is invoked with the parser
  result as its argument.
  
   my %callbacks = (
       test    => \&test_callback,
       plan    => \&plan_callback,
       comment => \&comment_callback,
       bailout => \&bailout_callback,
       unknown => \&unknown_callback,
   );
  
   my $aggregator = TAP::Parser::Aggregator->new;
   for my $file ( @test_files ) {
       my $parser = TAP::Parser->new(
           {
               source    => $file,
               callbacks => \%callbacks,
           }
       );
       $parser->run;
       $aggregator->add( $file, $parser );
   }
  
  Callbacks may also be added like this:
  
   $parser->callback( test => \&test_callback );
   $parser->callback( plan => \&plan_callback );
  
  The following keys allowed for callbacks. These keys are case-sensitive.
  
  =over 4
  
  =item * C<test>
  
  Invoked if C<< $result->is_test >> returns true.
  
  =item * C<version>
  
  Invoked if C<< $result->is_version >> returns true.
  
  =item * C<plan>
  
  Invoked if C<< $result->is_plan >> returns true.
  
  =item * C<comment>
  
  Invoked if C<< $result->is_comment >> returns true.
  
  =item * C<bailout>
  
  Invoked if C<< $result->is_unknown >> returns true.
  
  =item * C<yaml>
  
  Invoked if C<< $result->is_yaml >> returns true.
  
  =item * C<unknown>
  
  Invoked if C<< $result->is_unknown >> returns true.
  
  =item * C<ELSE>
  
  If a result does not have a callback defined for it, this callback will
  be invoked. Thus, if all of the previous result types are specified as
  callbacks, this callback will I<never> be invoked.
  
  =item * C<ALL>
  
  This callback will always be invoked and this will happen for each
  result after one of the above callbacks is invoked.  For example, if
  L<Term::ANSIColor> is loaded, you could use the following to color your
  test output:
  
   my %callbacks = (
       test => sub {
           my $test = shift;
           if ( $test->is_ok && not $test->directive ) {
               # normal passing test
               print color 'green';
           }
           elsif ( !$test->is_ok ) {    # even if it's TODO
               print color 'white on_red';
           }
           elsif ( $test->has_skip ) {
               print color 'white on_blue';
  
           }
           elsif ( $test->has_todo ) {
               print color 'white';
           }
       },
       ELSE => sub {
           # plan, comment, and so on (anything which isn't a test line)
           print color 'black on_white';
       },
       ALL => sub {
           # now print them
           print shift->as_string;
           print color 'reset';
           print "\n";
       },
   );
  
  =item * C<EOF>
  
  Invoked when there are no more lines to be parsed. Since there is no
  accompanying L<TAP::Parser::Result> object the C<TAP::Parser> object is
  passed instead.
  
  =back
  
  =head1 TAP GRAMMAR
  
  If you're looking for an EBNF grammar, see L<TAP::Parser::Grammar>.
  
  =head1 BACKWARDS COMPATIBILITY
  
  The Perl-QA list attempted to ensure backwards compatibility with
  L<Test::Harness>.  However, there are some minor differences.
  
  =head2 Differences
  
  =over 4
  
  =item * TODO plans
  
  A little-known feature of L<Test::Harness> is that it supported TODO
  lists in the plan:
  
   1..2 todo 2
   ok 1 - We have liftoff
   not ok 2 - Anti-gravity device activated
  
  Under L<Test::Harness>, test number 2 would I<pass> because it was
  listed as a TODO test on the plan line. However, we are not aware of
  anyone actually using this feature and hard-coding test numbers is
  discouraged because it's very easy to add a test and break the test
  number sequence. This makes test suites very fragile. Instead, the
  following should be used:
  
   1..2
   ok 1 - We have liftoff
   not ok 2 - Anti-gravity device activated # TODO
  
  =item * 'Missing' tests
  
  It rarely happens, but sometimes a harness might encounter
  'missing tests:
  
   ok 1
   ok 2
   ok 15
   ok 16
   ok 17
  
  L<Test::Harness> would report tests 3-14 as having failed. For the
  C<TAP::Parser>, these tests are not considered failed because they've
  never run. They're reported as parse failures (tests out of sequence).
  
  =back
  
  =head1 SUBCLASSING
  
  If you find you need to provide custom functionality (as you would have using
  L<Test::Harness::Straps>), you're in luck: C<TAP::Parser> and friends are
  designed to be easily plugged-into and/or subclassed.
  
  Before you start, it's important to know a few things:
  
  =over 2
  
  =item 1
  
  All C<TAP::*> objects inherit from L<TAP::Object>.
  
  =item 2
  
  Many C<TAP::*> classes have a I<SUBCLASSING> section to guide you.
  
  =item 3
  
  Note that C<TAP::Parser> is designed to be the central "maker" - ie: it is
  responsible for creating most new objects in the C<TAP::Parser::*> namespace.
  
  This makes it possible for you to have a single point of configuring what
  subclasses should be used, which means that in many cases you'll find
  you only need to sub-class one of the parser's components.
  
  The exception to this rule are I<SourceHandlers> & I<Iterators>, but those are
  both created with customizable I<IteratorFactory>.
  
  =item 4
  
  By subclassing, you may end up overriding undocumented methods.  That's not
  a bad thing per se, but be forewarned that undocumented methods may change
  without warning from one release to the next - we cannot guarantee backwards
  compatibility.  If any I<documented> method needs changing, it will be
  deprecated first, and changed in a later release.
  
  =back
  
  =head2 Parser Components
  
  =head3 Sources
  
  A TAP parser consumes input from a single I<raw source> of TAP, which could come
  from anywhere (a file, an executable, a database, an IO handle, a URI, etc..).
  The source gets bundled up in a L<TAP::Parser::Source> object which gathers some
  meta data about it.  The parser then uses a L<TAP::Parser::IteratorFactory> to
  determine which L<TAP::Parser::SourceHandler> to use to turn the raw source
  into a stream of TAP by way of L</Iterators>.
  
  If you simply want C<TAP::Parser> to handle a new source of TAP you probably
  don't need to subclass C<TAP::Parser> itself.  Rather, you'll need to create a
  new L<TAP::Parser::SourceHandler> class, and just plug it into the parser using
  the I<sources> param to L</new>.  Before you start writing one, read through
  L<TAP::Parser::IteratorFactory> to get a feel for how the system works first.
  
  If you find you really need to use your own iterator factory you can still do
  so without sub-classing C<TAP::Parser> by setting L</iterator_factory_class>.
  
  If you just need to customize the objects on creation, subclass L<TAP::Parser>
  and override L</make_iterator_factory>.
  
  Note that C<make_source> & C<make_perl_source> have been I<DEPRECATED> and
  are now removed.
  
  =head3 Iterators
  
  A TAP parser uses I<iterators> to loop through the I<stream> of TAP read in
  from the I<source> it was given.  There are a few types of Iterators available
  by default, all sub-classes of L<TAP::Parser::Iterator>.  Choosing which
  iterator to use is the responsibility of the I<iterator factory>, though it
  simply delegates to the I<Source Handler> it uses.
  
  If you're writing your own L<TAP::Parser::SourceHandler>, you may need to
  create your own iterators too.  If so you'll need to subclass
  L<TAP::Parser::Iterator>.
  
  Note that L</make_iterator> has been I<DEPRECATED> and is now removed.
  
  =head3 Results
  
  A TAP parser creates L<TAP::Parser::Result>s as it iterates through the
  input I<stream>.  There are quite a few result types available; choosing
  which class to use is the responsibility of the I<result factory>.
  
  To create your own result types you have two options:
  
  =over 2
  
  =item option 1
  
  Subclass L<TAP::Parser::Result> and register your new result type/class with
  the default L<TAP::Parser::ResultFactory>.
  
  =item option 2
  
  Subclass L<TAP::Parser::ResultFactory> itself and implement your own
  L<TAP::Parser::Result> creation logic.  Then you'll need to customize the
  class used by your parser by setting the C<result_factory_class> parameter.
  See L</new> for more details.
  
  =back
  
  If you need to customize the objects on creation, subclass L<TAP::Parser> and
  override L</make_result>.
  
  =head3 Grammar
  
  L<TAP::Parser::Grammar> is the heart of the parser.  It tokenizes the TAP
  input I<stream> and produces results.  If you need to customize its behaviour
  you should probably familiarize yourself with the source first.  Enough
  lecturing.
  
  Subclass L<TAP::Parser::Grammar> and customize your parser by setting the
  C<grammar_class> parameter.  See L</new> for more details.
  
  If you need to customize the objects on creation, subclass L<TAP::Parser> and
  override L</make_grammar>
  
  =head1 ACKNOWLEDGMENTS
  
  All of the following have helped. Bug reports, patches, (im)moral
  support, or just words of encouragement have all been forthcoming.
  
  =over 4
  
  =item * Michael Schwern
  
  =item * Andy Lester
  
  =item * chromatic
  
  =item * GEOFFR
  
  =item * Shlomi Fish
  
  =item * Torsten Schoenfeld
  
  =item * Jerry Gay
  
  =item * Aristotle
  
  =item * Adam Kennedy
  
  =item * Yves Orton
  
  =item * Adrian Howard
  
  =item * Sean & Lil
  
  =item * Andreas J. Koenig
  
  =item * Florian Ragwitz
  
  =item * Corion
  
  =item * Mark Stosberg
  
  =item * Matt Kraai
  
  =item * David Wheeler
  
  =item * Alex Vandiver
  
  =item * Cosimo Streppone
  
  =item * Ville Skytt
  
  =back
  
  =head1 AUTHORS
  
  Curtis "Ovid" Poe <ovid@cpan.org>
  
  Andy Armstong <andy@hexten.net>
  
  Eric Wilhelm @ <ewilhelm at cpan dot org>
  
  Michael Peters <mpeters at plusthree dot com>
  
  Leif Eriksen <leif dot eriksen at bigpond dot com>
  
  Steve Purkis <spurkis@cpan.org>
  
  Nicholas Clark <nick@ccl4.org>
  
  Lee Johnson <notfadeaway at btinternet dot com>
  
  Philippe Bruhat <book@cpan.org>
  
  =head1 BUGS
  
  Please report any bugs or feature requests to
  C<bug-test-harness@rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness>.
  We will be notified, and then you'll automatically be notified of
  progress on your bug as we make changes.
  
  Obviously, bugs which include patches are best. If you prefer, you can
  patch against bleed by via anonymous checkout of the latest version:
  
   git clone git://github.com/Perl-Toolchain-Gang/Test-Harness.git
  
  =head1 COPYRIGHT & LICENSE
  
  Copyright 2006-2008 Curtis "Ovid" Poe, all rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
TAP_PARSER

$fatpacked{"TAP/Parser/Aggregator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_AGGREGATOR';
  package TAP::Parser::Aggregator;
  
  use strict;
  use warnings;
  use Benchmark;
  
  use base 'TAP::Object';
  
  =head1 NAME
  
  TAP::Parser::Aggregator - Aggregate TAP::Parser results
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 SYNOPSIS
  
      use TAP::Parser::Aggregator;
  
      my $aggregate = TAP::Parser::Aggregator->new;
      $aggregate->add( 't/00-load.t', $load_parser );
      $aggregate->add( 't/10-lex.t',  $lex_parser  );
  
      my $summary = <<'END_SUMMARY';
      Passed:  %s
      Failed:  %s
      Unexpectedly succeeded: %s
      END_SUMMARY
      printf $summary,
             scalar $aggregate->passed,
             scalar $aggregate->failed,
             scalar $aggregate->todo_passed;
  
  =head1 DESCRIPTION
  
  C<TAP::Parser::Aggregator> collects parser objects and allows
  reporting/querying their aggregate results.
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
   my $aggregate = TAP::Parser::Aggregator->new;
  
  Returns a new C<TAP::Parser::Aggregator> object.
  
  =cut
  
  # new() implementation supplied by TAP::Object
  
  my %SUMMARY_METHOD_FOR;
  
  BEGIN {    # install summary methods
      %SUMMARY_METHOD_FOR = map { $_ => $_ } qw(
        failed
        parse_errors
        passed
        skipped
        todo
        todo_passed
        total
        wait
        exit
      );
      $SUMMARY_METHOD_FOR{total}   = 'tests_run';
      $SUMMARY_METHOD_FOR{planned} = 'tests_planned';
  
      for my $method ( keys %SUMMARY_METHOD_FOR ) {
          next if 'total' eq $method;
          no strict 'refs';
          *$method = sub {
              my $self = shift;
              return wantarray
                ? @{ $self->{"descriptions_for_$method"} }
                : $self->{$method};
          };
      }
  }    # end install summary methods
  
  sub _initialize {
      my ($self) = @_;
      $self->{parser_for}  = {};
      $self->{parse_order} = [];
      for my $summary ( keys %SUMMARY_METHOD_FOR ) {
          $self->{$summary} = 0;
          next if 'total' eq $summary;
          $self->{"descriptions_for_$summary"} = [];
      }
      return $self;
  }
  
  ##############################################################################
  
  =head2 Instance Methods
  
  =head3 C<add>
  
    $aggregate->add( $description => $parser );
  
  The C<$description> is usually a test file name (but only by
  convention.)  It is used as a unique identifier (see e.g.
  L<"parsers">.)  Reusing a description is a fatal error.
  
  The C<$parser> is a L<TAP::Parser|TAP::Parser> object.
  
  =cut
  
  sub add {
      my ( $self, $description, $parser ) = @_;
      if ( exists $self->{parser_for}{$description} ) {
          $self->_croak( "You already have a parser for ($description)."
                . " Perhaps you have run the same test twice." );
      }
      push @{ $self->{parse_order} } => $description;
      $self->{parser_for}{$description} = $parser;
  
      while ( my ( $summary, $method ) = each %SUMMARY_METHOD_FOR ) {
  
          # Slightly nasty. Instead we should maybe have 'cooked' accessors
          # for results that may be masked by the parser.
          next
            if ( $method eq 'exit' || $method eq 'wait' )
            && $parser->ignore_exit;
  
          if ( my $count = $parser->$method() ) {
              $self->{$summary} += $count;
              push @{ $self->{"descriptions_for_$summary"} } => $description;
          }
      }
  
      return $self;
  }
  
  ##############################################################################
  
  =head3 C<parsers>
  
    my $count   = $aggregate->parsers;
    my @parsers = $aggregate->parsers;
    my @parsers = $aggregate->parsers(@descriptions);
  
  In scalar context without arguments, this method returns the number of parsers
  aggregated.  In list context without arguments, returns the parsers in the
  order they were added.
  
  If C<@descriptions> is given, these correspond to the keys used in each
  call to the add() method.  Returns an array of the requested parsers (in
  the requested order) in list context or an array reference in scalar
  context.
  
  Requesting an unknown identifier is a fatal error.
  
  =cut
  
  sub parsers {
      my $self = shift;
      return $self->_get_parsers(@_) if @_;
      my $descriptions = $self->{parse_order};
      my @parsers      = @{ $self->{parser_for} }{@$descriptions};
  
      # Note:  Because of the way context works, we must assign the parsers to
      # the @parsers array or else this method does not work as documented.
      return @parsers;
  }
  
  sub _get_parsers {
      my ( $self, @descriptions ) = @_;
      my @parsers;
      for my $description (@descriptions) {
          $self->_croak("A parser for ($description) could not be found")
            unless exists $self->{parser_for}{$description};
          push @parsers => $self->{parser_for}{$description};
      }
      return wantarray ? @parsers : \@parsers;
  }
  
  =head3 C<descriptions>
  
  Get an array of descriptions in the order in which they were added to
  the aggregator.
  
  =cut
  
  sub descriptions { @{ shift->{parse_order} || [] } }
  
  =head3 C<start>
  
  Call C<start> immediately before adding any results to the aggregator.
  Among other times it records the start time for the test run.
  
  =cut
  
  sub start {
      my $self = shift;
      $self->{start_time} = Benchmark->new;
  }
  
  =head3 C<stop>
  
  Call C<stop> immediately after adding all test results to the aggregator.
  
  =cut
  
  sub stop {
      my $self = shift;
      $self->{end_time} = Benchmark->new;
  }
  
  =head3 C<elapsed>
  
  Elapsed returns a L<Benchmark> object that represents the running time
  of the aggregated tests. In order for C<elapsed> to be valid you must
  call C<start> before running the tests and C<stop> immediately
  afterwards.
  
  =cut
  
  sub elapsed {
      my $self = shift;
  
      require Carp;
      Carp::croak
        q{Can't call elapsed without first calling start and then stop}
        unless defined $self->{start_time} && defined $self->{end_time};
      return timediff( $self->{end_time}, $self->{start_time} );
  }
  
  =head3 C<elapsed_timestr>
  
  Returns a formatted string representing the runtime returned by
  C<elapsed()>.  This lets the caller not worry about Benchmark.
  
  =cut
  
  sub elapsed_timestr {
      my $self = shift;
  
      my $elapsed = $self->elapsed;
  
      return timestr($elapsed);
  }
  
  =head3 C<all_passed>
  
  Return true if all the tests passed and no parse errors were detected.
  
  =cut
  
  sub all_passed {
      my $self = shift;
      return
           $self->total
        && $self->total == $self->passed
        && !$self->has_errors;
  }
  
  =head3 C<get_status>
  
  Get a single word describing the status of the aggregated tests.
  Depending on the outcome of the tests returns 'PASS', 'FAIL' or
  'NOTESTS'. This token is understood by L<CPAN::Reporter>.
  
  =cut
  
  sub get_status {
      my $self = shift;
  
      my $total  = $self->total;
      my $passed = $self->passed;
  
      return
          ( $self->has_errors || $total != $passed ) ? 'FAIL'
        : $total ? 'PASS'
        :          'NOTESTS';
  }
  
  ##############################################################################
  
  =head2 Summary methods
  
  Each of the following methods will return the total number of corresponding
  tests if called in scalar context.  If called in list context, returns the
  descriptions of the parsers which contain the corresponding tests (see C<add>
  for an explanation of description.
  
  =over 4
  
  =item * failed
  
  =item * parse_errors
  
  =item * passed
  
  =item * planned
  
  =item * skipped
  
  =item * todo
  
  =item * todo_passed
  
  =item * wait
  
  =item * exit
  
  =back
  
  For example, to find out how many tests unexpectedly succeeded (TODO tests
  which passed when they shouldn't):
  
   my $count        = $aggregate->todo_passed;
   my @descriptions = $aggregate->todo_passed;
  
  Note that C<wait> and C<exit> are the totals of the wait and exit
  statuses of each of the tests. These values are totalled only to provide
  a true value if any of them are non-zero.
  
  =cut
  
  ##############################################################################
  
  =head3 C<total>
  
    my $tests_run = $aggregate->total;
  
  Returns the total number of tests run.
  
  =cut
  
  sub total { shift->{total} }
  
  ##############################################################################
  
  =head3 C<has_problems>
  
    if ( $parser->has_problems ) {
        ...
    }
  
  Identical to C<has_errors>, but also returns true if any TODO tests
  unexpectedly succeeded.  This is more akin to "warnings".
  
  =cut
  
  sub has_problems {
      my $self = shift;
      return $self->todo_passed
        || $self->has_errors;
  }
  
  ##############################################################################
  
  =head3 C<has_errors>
  
    if ( $parser->has_errors ) {
        ...
    }
  
  Returns true if I<any> of the parsers failed.  This includes:
  
  =over 4
  
  =item * Failed tests
  
  =item * Parse errors
  
  =item * Bad exit or wait status
  
  =back
  
  =cut
  
  sub has_errors {
      my $self = shift;
      return
           $self->failed
        || $self->parse_errors
        || $self->exit
        || $self->wait;
  }
  
  ##############################################################################
  
  =head3 C<todo_failed>
  
    # deprecated in favor of 'todo_passed'.  This method was horribly misnamed.
  
  This was a badly misnamed method.  It indicates which TODO tests unexpectedly
  succeeded.  Will now issue a warning and call C<todo_passed>.
  
  =cut
  
  sub todo_failed {
      warn
        '"todo_failed" is deprecated.  Please use "todo_passed".  See the docs.';
      goto &todo_passed;
  }
  
  =head1 See Also
  
  L<TAP::Parser>
  
  L<TAP::Harness>
  
  =cut
  
  1;
TAP_PARSER_AGGREGATOR

$fatpacked{"TAP/Parser/Grammar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_GRAMMAR';
  package TAP::Parser::Grammar;
  
  use strict;
  use warnings;
  
  use TAP::Parser::ResultFactory   ();
  use TAP::Parser::YAMLish::Reader ();
  
  use base 'TAP::Object';
  
  =head1 NAME
  
  TAP::Parser::Grammar - A grammar for the Test Anything Protocol.
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 SYNOPSIS
  
    use TAP::Parser::Grammar;
    my $grammar = $self->make_grammar({
      iterator => $tap_parser_iterator,
      parser   => $tap_parser,
      version  => 12,
    });
  
    my $result = $grammar->tokenize;
  
  =head1 DESCRIPTION
  
  C<TAP::Parser::Grammar> tokenizes lines from a L<TAP::Parser::Iterator> and
  constructs L<TAP::Parser::Result> subclasses to represent the tokens.
  
  Do not attempt to use this class directly.  It won't make sense.  It's mainly
  here to ensure that we will be able to have pluggable grammars when TAP is
  expanded at some future date (plus, this stuff was really cluttering the
  parser).
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
    my $grammar = TAP::Parser::Grammar->new({
        iterator => $iterator,
        parser   => $parser,
        version  => $version,
    });
  
  Returns L<TAP::Parser> grammar object that will parse the TAP stream from the
  specified iterator.  Both C<iterator> and C<parser> are required arguments.
  If C<version> is not set it defaults to C<12> (see L</set_version> for more
  details).
  
  =cut
  
  # new() implementation supplied by TAP::Object
  sub _initialize {
      my ( $self, $args ) = @_;
      $self->{iterator} = $args->{iterator};    # TODO: accessor
      $self->{iterator} ||= $args->{stream};    # deprecated
      $self->{parser} = $args->{parser};        # TODO: accessor
      $self->set_version( $args->{version} || 12 );
      return $self;
  }
  
  my %language_for;
  
  {
  
      # XXX the 'not' and 'ok' might be on separate lines in VMS ...
      my $ok  = qr/(?:not )?ok\b/;
      my $num = qr/\d+/;
  
      my %v12 = (
          version => {
              syntax  => qr/^TAP\s+version\s+(\d+)\s*\z/i,
              handler => sub {
                  my ( $self, $line ) = @_;
                  my $version = $1;
                  return $self->_make_version_token( $line, $version, );
              },
          },
          plan => {
              syntax  => qr/^1\.\.(\d+)\s*(.*)\z/,
              handler => sub {
                  my ( $self, $line ) = @_;
                  my ( $tests_planned, $tail ) = ( $1, $2 );
                  my $explanation = undef;
                  my $skip        = '';
  
                  if ( $tail =~ /^todo((?:\s+\d+)+)/ ) {
                      my @todo = split /\s+/, _trim($1);
                      return $self->_make_plan_token(
                          $line, $tests_planned, 'TODO',
                          '',    \@todo
                      );
                  }
                  elsif ( 0 == $tests_planned ) {
                      $skip = 'SKIP';
  
                      # If we can't match # SKIP the directive should be undef.
                      ($explanation) = $tail =~ /^#\s*SKIP\S*\s+(.*)/i;
                  }
                  elsif ( $tail !~ /^\s*$/ ) {
                      return $self->_make_unknown_token($line);
                  }
  
                  $explanation = '' unless defined $explanation;
  
                  return $self->_make_plan_token(
                      $line, $tests_planned, $skip,
                      $explanation, []
                  );
  
              },
          },
  
          # An optimization to handle the most common test lines without
          # directives.
          simple_test => {
              syntax  => qr/^($ok) \ ($num) (?:\ ([^#]+))? \z/x,
              handler => sub {
                  my ( $self, $line ) = @_;
                  my ( $ok, $num, $desc ) = ( $1, $2, $3 );
  
                  return $self->_make_test_token(
                      $line, $ok, $num,
                      $desc
                  );
              },
          },
          test => {
              syntax  => qr/^($ok) \s* ($num)? \s* (.*) \z/x,
              handler => sub {
                  my ( $self, $line ) = @_;
                  my ( $ok, $num, $desc ) = ( $1, $2, $3 );
                  my ( $dir, $explanation ) = ( '', '' );
                  if ($desc =~ m/^ ( [^\\\#]* (?: \\. [^\\\#]* )* )
                         \# \s* (SKIP|TODO) \b \s* (.*) $/ix
                    )
                  {
                      ( $desc, $dir, $explanation ) = ( $1, $2, $3 );
                  }
                  return $self->_make_test_token(
                      $line, $ok, $num, $desc,
                      $dir,  $explanation
                  );
              },
          },
          comment => {
              syntax  => qr/^#(.*)/,
              handler => sub {
                  my ( $self, $line ) = @_;
                  my $comment = $1;
                  return $self->_make_comment_token( $line, $comment );
              },
          },
          bailout => {
              syntax  => qr/^\s*Bail out!\s*(.*)/,
              handler => sub {
                  my ( $self, $line ) = @_;
                  my $explanation = $1;
                  return $self->_make_bailout_token(
                      $line,
                      $explanation
                  );
              },
          },
      );
  
      my %v13 = (
          %v12,
          plan => {
              syntax  => qr/^1\.\.(\d+)\s*(?:\s*#\s*SKIP\b(.*))?\z/i,
              handler => sub {
                  my ( $self, $line ) = @_;
                  my ( $tests_planned, $explanation ) = ( $1, $2 );
                  my $skip
                    = ( 0 == $tests_planned || defined $explanation )
                    ? 'SKIP'
                    : '';
                  $explanation = '' unless defined $explanation;
                  return $self->_make_plan_token(
                      $line, $tests_planned, $skip,
                      $explanation, []
                  );
              },
          },
          yaml => {
              syntax  => qr/^ (\s+) (---.*) $/x,
              handler => sub {
                  my ( $self, $line ) = @_;
                  my ( $pad, $marker ) = ( $1, $2 );
                  return $self->_make_yaml_token( $pad, $marker );
              },
          },
          pragma => {
              syntax =>
                qr/^ pragma \s+ ( [-+] \w+ \s* (?: , \s* [-+] \w+ \s* )* ) $/x,
              handler => sub {
                  my ( $self, $line ) = @_;
                  my $pragmas = $1;
                  return $self->_make_pragma_token( $line, $pragmas );
              },
          },
      );
  
      %language_for = (
          '12' => {
              tokens => \%v12,
          },
          '13' => {
              tokens => \%v13,
              setup  => sub {
                  shift->{iterator}->handle_unicode;
              },
          },
      );
  }
  
  ##############################################################################
  
  =head2 Instance Methods
  
  =head3 C<set_version>
  
    $grammar->set_version(13);
  
  Tell the grammar which TAP syntax version to support. The lowest
  supported version is 12. Although 'TAP version' isn't valid version 12
  syntax it is accepted so that higher version numbers may be parsed.
  
  =cut
  
  sub set_version {
      my $self    = shift;
      my $version = shift;
  
      if ( my $language = $language_for{$version} ) {
          $self->{version} = $version;
          $self->{tokens}  = $language->{tokens};
  
          if ( my $setup = $language->{setup} ) {
              $self->$setup();
          }
  
          $self->_order_tokens;
      }
      else {
          require Carp;
          Carp::croak("Unsupported syntax version: $version");
      }
  }
  
  # Optimization to put the most frequent tokens first.
  sub _order_tokens {
      my $self = shift;
  
      my %copy = %{ $self->{tokens} };
      my @ordered_tokens = grep {defined}
        map { delete $copy{$_} } qw( simple_test test comment plan );
      push @ordered_tokens, values %copy;
  
      $self->{ordered_tokens} = \@ordered_tokens;
  }
  
  ##############################################################################
  
  =head3 C<tokenize>
  
    my $token = $grammar->tokenize;
  
  This method will return a L<TAP::Parser::Result> object representing the
  current line of TAP.
  
  =cut
  
  sub tokenize {
      my $self = shift;
  
      my $line = $self->{iterator}->next;
      unless ( defined $line ) {
          delete $self->{parser};    # break circular ref
          return;
      }
  
      my $token;
  
      for my $token_data ( @{ $self->{ordered_tokens} } ) {
          if ( $line =~ $token_data->{syntax} ) {
              my $handler = $token_data->{handler};
              $token = $self->$handler($line);
              last;
          }
      }
  
      $token = $self->_make_unknown_token($line) unless $token;
  
      return $self->{parser}->make_result($token);
  }
  
  ##############################################################################
  
  =head3 C<token_types>
  
    my @types = $grammar->token_types;
  
  Returns the different types of tokens which this grammar can parse.
  
  =cut
  
  sub token_types {
      my $self = shift;
      return keys %{ $self->{tokens} };
  }
  
  ##############################################################################
  
  =head3 C<syntax_for>
  
    my $syntax = $grammar->syntax_for($token_type);
  
  Returns a pre-compiled regular expression which will match a chunk of TAP
  corresponding to the token type.  For example (not that you should really pay
  attention to this, C<< $grammar->syntax_for('comment') >> will return
  C<< qr/^#(.*)/ >>.
  
  =cut
  
  sub syntax_for {
      my ( $self, $type ) = @_;
      return $self->{tokens}->{$type}->{syntax};
  }
  
  ##############################################################################
  
  =head3 C<handler_for>
  
    my $handler = $grammar->handler_for($token_type);
  
  Returns a code reference which, when passed an appropriate line of TAP,
  returns the lexed token corresponding to that line.  As a result, the basic
  TAP parsing loop looks similar to the following:
  
   my @tokens;
   my $grammar = TAP::Grammar->new;
   LINE: while ( defined( my $line = $parser->_next_chunk_of_tap ) ) {
       for my $type ( $grammar->token_types ) {
           my $syntax  = $grammar->syntax_for($type);
           if ( $line =~ $syntax ) {
               my $handler = $grammar->handler_for($type);
               push @tokens => $grammar->$handler($line);
               next LINE;
           }
       }
       push @tokens => $grammar->_make_unknown_token($line);
   }
  
  =cut
  
  sub handler_for {
      my ( $self, $type ) = @_;
      return $self->{tokens}->{$type}->{handler};
  }
  
  sub _make_version_token {
      my ( $self, $line, $version ) = @_;
      return {
          type    => 'version',
          raw     => $line,
          version => $version,
      };
  }
  
  sub _make_plan_token {
      my ( $self, $line, $tests_planned, $directive, $explanation, $todo ) = @_;
  
      if (   $directive eq 'SKIP'
          && 0 != $tests_planned
          && $self->{version} < 13 )
      {
          warn
            "Specified SKIP directive in plan but more than 0 tests ($line)\n";
      }
  
      return {
          type          => 'plan',
          raw           => $line,
          tests_planned => $tests_planned,
          directive     => $directive,
          explanation   => _trim($explanation),
          todo_list     => $todo,
      };
  }
  
  sub _make_test_token {
      my ( $self, $line, $ok, $num, $desc, $dir, $explanation ) = @_;
      return {
          ok          => $ok,
  
          # forcing this to be an integer (and not a string) reduces memory
          # consumption. RT #84939
          test_num    => ( defined $num ? 0 + $num : undef ),
          description => _trim($desc),
          directive   => ( defined $dir ? uc $dir : '' ),
          explanation => _trim($explanation),
          raw         => $line,
          type        => 'test',
      };
  }
  
  sub _make_unknown_token {
      my ( $self, $line ) = @_;
      return {
          raw  => $line,
          type => 'unknown',
      };
  }
  
  sub _make_comment_token {
      my ( $self, $line, $comment ) = @_;
      return {
          type    => 'comment',
          raw     => $line,
          comment => _trim($comment)
      };
  }
  
  sub _make_bailout_token {
      my ( $self, $line, $explanation ) = @_;
      return {
          type    => 'bailout',
          raw     => $line,
          bailout => _trim($explanation)
      };
  }
  
  sub _make_yaml_token {
      my ( $self, $pad, $marker ) = @_;
  
      my $yaml = TAP::Parser::YAMLish::Reader->new;
  
      my $iterator = $self->{iterator};
  
      # Construct a reader that reads from our input stripping leading
      # spaces from each line.
      my $leader = length($pad);
      my $strip  = qr{ ^ (\s{$leader}) (.*) $ }x;
      my @extra  = ($marker);
      my $reader = sub {
          return shift @extra if @extra;
          my $line = $iterator->next;
          return $2 if $line =~ $strip;
          return;
      };
  
      my $data = $yaml->read($reader);
  
      # Reconstitute input. This is convoluted. Maybe we should just
      # record it on the way in...
      chomp( my $raw = $yaml->get_raw );
      $raw =~ s/^/$pad/mg;
  
      return {
          type => 'yaml',
          raw  => $raw,
          data => $data
      };
  }
  
  sub _make_pragma_token {
      my ( $self, $line, $pragmas ) = @_;
      return {
          type    => 'pragma',
          raw     => $line,
          pragmas => [ split /\s*,\s*/, _trim($pragmas) ],
      };
  }
  
  sub _trim {
      my $data = shift;
  
      return '' unless defined $data;
  
      $data =~ s/^\s+//;
      $data =~ s/\s+$//;
      return $data;
  }
  
  1;
  
  =head1 TAP GRAMMAR
  
  B<NOTE:>  This grammar is slightly out of date.  There's still some discussion
  about it and a new one will be provided when we have things better defined.
  
  The L<TAP::Parser> does not use a formal grammar because TAP is essentially a
  stream-based protocol.  In fact, it's quite legal to have an infinite stream.
  For the same reason that we don't apply regexes to streams, we're not using a
  formal grammar here.  Instead, we parse the TAP in lines.
  
  For purposes for forward compatibility, any result which does not match the
  following grammar is currently referred to as
  L<TAP::Parser::Result::Unknown>.  It is I<not> a parse error.
  
  A formal grammar would look similar to the following:
  
   (*
       For the time being, I'm cheating on the EBNF by allowing
       certain terms to be defined by POSIX character classes by
       using the following syntax:
  
         digit ::= [:digit:]
  
       As far as I am aware, that's not valid EBNF.  Sue me.  I
       didn't know how to write "char" otherwise (Unicode issues).
       Suggestions welcome.
   *)
  
   tap            ::= version? { comment | unknown } leading_plan lines
                      |
                      lines trailing_plan {comment}
  
   version        ::= 'TAP version ' positiveInteger {positiveInteger} "\n"
  
   leading_plan   ::= plan skip_directive? "\n"
  
   trailing_plan  ::= plan "\n"
  
   plan           ::= '1..' nonNegativeInteger
  
   lines          ::= line {line}
  
   line           ::= (comment | test | unknown | bailout ) "\n"
  
   test           ::= status positiveInteger? description? directive?
  
   status         ::= 'not '? 'ok '
  
   description    ::= (character - (digit | '#')) {character - '#'}
  
   directive      ::= todo_directive | skip_directive
  
   todo_directive ::= hash_mark 'TODO' ' ' {character}
  
   skip_directive ::= hash_mark 'SKIP' ' ' {character}
  
   comment        ::= hash_mark {character}
  
   hash_mark      ::= '#' {' '}
  
   bailout        ::= 'Bail out!' {character}
  
   unknown        ::= { (character - "\n") }
  
   (* POSIX character classes and other terminals *)
  
   digit              ::= [:digit:]
   character          ::= ([:print:] - "\n")
   positiveInteger    ::= ( digit - '0' ) {digit}
   nonNegativeInteger ::= digit {digit}
  
  =head1 SUBCLASSING
  
  Please see L<TAP::Parser/SUBCLASSING> for a subclassing overview.
  
  If you I<really> want to subclass L<TAP::Parser>'s grammar the best thing to
  do is read through the code.  There's no easy way of summarizing it here.
  
  =head1 SEE ALSO
  
  L<TAP::Object>,
  L<TAP::Parser>,
  L<TAP::Parser::Iterator>,
  L<TAP::Parser::Result>,
  
  =cut
TAP_PARSER_GRAMMAR

$fatpacked{"TAP/Parser/Iterator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATOR';
  package TAP::Parser::Iterator;
  
  use strict;
  use warnings;
  
  use base 'TAP::Object';
  
  =head1 NAME
  
  TAP::Parser::Iterator - Base class for TAP source iterators
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 SYNOPSIS
  
    # to subclass:
    use TAP::Parser::Iterator ();
    use base 'TAP::Parser::Iterator';
    sub _initialize {
      # see TAP::Object...
    }
  
    sub next_raw { ... }
    sub wait     { ... }
    sub exit     { ... }
  
  =head1 DESCRIPTION
  
  This is a simple iterator base class that defines L<TAP::Parser>'s iterator
  API.  Iterators are typically created from L<TAP::Parser::SourceHandler>s.
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
  Create an iterator.  Provided by L<TAP::Object>.
  
  =head2 Instance Methods
  
  =head3 C<next>
  
   while ( my $item = $iter->next ) { ... }
  
  Iterate through it, of course.
  
  =head3 C<next_raw>
  
  B<Note:> this method is abstract and should be overridden.
  
   while ( my $item = $iter->next_raw ) { ... }
  
  Iterate raw input without applying any fixes for quirky input syntax.
  
  =cut
  
  sub next {
      my $self = shift;
      my $line = $self->next_raw;
  
      # vms nit:  When encountering 'not ok', vms often has the 'not' on a line
      # by itself:
      #   not
      #   ok 1 - 'I hate VMS'
      if ( defined($line) and $line =~ /^\s*not\s*$/ ) {
          $line .= ( $self->next_raw || '' );
      }
  
      return $line;
  }
  
  sub next_raw {
      require Carp;
      my $msg = Carp::longmess('abstract method called directly!');
      $_[0]->_croak($msg);
  }
  
  =head3 C<handle_unicode>
  
  If necessary switch the input stream to handle unicode. This only has
  any effect for I/O handle based streams.
  
  The default implementation does nothing.
  
  =cut
  
  sub handle_unicode { }
  
  =head3 C<get_select_handles>
  
  Return a list of filehandles that may be used upstream in a select()
  call to signal that this Iterator is ready. Iterators that are not
  handle-based should return an empty list.
  
  The default implementation does nothing.
  
  =cut
  
  sub get_select_handles {
      return;
  }
  
  =head3 C<wait>
  
  B<Note:> this method is abstract and should be overridden.
  
   my $wait_status = $iter->wait;
  
  Return the C<wait> status for this iterator.
  
  =head3 C<exit>
  
  B<Note:> this method is abstract and should be overridden.
  
   my $wait_status = $iter->exit;
  
  Return the C<exit> status for this iterator.
  
  =cut
  
  sub wait {
      require Carp;
      my $msg = Carp::longmess('abstract method called directly!');
      $_[0]->_croak($msg);
  }
  
  sub exit {
      require Carp;
      my $msg = Carp::longmess('abstract method called directly!');
      $_[0]->_croak($msg);
  }
  
  1;
  
  =head1 SUBCLASSING
  
  Please see L<TAP::Parser/SUBCLASSING> for a subclassing overview.
  
  You must override the abstract methods as noted above.
  
  =head2 Example
  
  L<TAP::Parser::Iterator::Array> is probably the easiest example to follow.
  There's not much point repeating it here.
  
  =head1 SEE ALSO
  
  L<TAP::Object>,
  L<TAP::Parser>,
  L<TAP::Parser::Iterator::Array>,
  L<TAP::Parser::Iterator::Stream>,
  L<TAP::Parser::Iterator::Process>,
  
  =cut
  
TAP_PARSER_ITERATOR

$fatpacked{"TAP/Parser/Iterator/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATOR_ARRAY';
  package TAP::Parser::Iterator::Array;
  
  use strict;
  use warnings;
  
  use base 'TAP::Parser::Iterator';
  
  =head1 NAME
  
  TAP::Parser::Iterator::Array - Iterator for array-based TAP sources
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 SYNOPSIS
  
    use TAP::Parser::Iterator::Array;
    my @data = ('foo', 'bar', baz');
    my $it   = TAP::Parser::Iterator::Array->new(\@data);
    my $line = $it->next;
  
  =head1 DESCRIPTION
  
  This is a simple iterator wrapper for arrays of scalar content, used by
  L<TAP::Parser>.  Unless you're writing a plugin or subclassing, you probably
  won't need to use this module directly.
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
  Create an iterator.  Takes one argument: an C<$array_ref>
  
  =head2 Instance Methods
  
  =head3 C<next>
  
  Iterate through it, of course.
  
  =head3 C<next_raw>
  
  Iterate raw input without applying any fixes for quirky input syntax.
  
  =head3 C<wait>
  
  Get the wait status for this iterator. For an array iterator this will always
  be zero.
  
  =head3 C<exit>
  
  Get the exit status for this iterator. For an array iterator this will always
  be zero.
  
  =cut
  
  # new() implementation supplied by TAP::Object
  
  sub _initialize {
      my ( $self, $thing ) = @_;
      chomp @$thing;
      $self->{idx}   = 0;
      $self->{array} = $thing;
      $self->{exit}  = undef;
      return $self;
  }
  
  sub wait { shift->exit }
  
  sub exit {
      my $self = shift;
      return 0 if $self->{idx} >= @{ $self->{array} };
      return;
  }
  
  sub next_raw {
      my $self = shift;
      return $self->{array}->[ $self->{idx}++ ];
  }
  
  1;
  
  =head1 ATTRIBUTION
  
  Originally ripped off from L<Test::Harness>.
  
  =head1 SEE ALSO
  
  L<TAP::Object>,
  L<TAP::Parser>,
  L<TAP::Parser::Iterator>,
  
  =cut
  
TAP_PARSER_ITERATOR_ARRAY

$fatpacked{"TAP/Parser/Iterator/Process.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATOR_PROCESS';
  package TAP::Parser::Iterator::Process;
  
  use strict;
  use warnings;
  
  use Config;
  use IO::Handle;
  
  use base 'TAP::Parser::Iterator';
  
  my $IS_WIN32 = ( $^O =~ /^(MS)?Win32$/ );
  
  =head1 NAME
  
  TAP::Parser::Iterator::Process - Iterator for process-based TAP sources
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 SYNOPSIS
  
    use TAP::Parser::Iterator::Process;
    my %args = (
     command  => ['python', 'setup.py', 'test'],
     merge    => 1,
     setup    => sub { ... },
     teardown => sub { ... },
    );
    my $it   = TAP::Parser::Iterator::Process->new(\%args);
    my $line = $it->next;
  
  =head1 DESCRIPTION
  
  This is a simple iterator wrapper for executing external processes, used by
  L<TAP::Parser>.  Unless you're writing a plugin or subclassing, you probably
  won't need to use this module directly.
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
  Create an iterator.  Expects one argument containing a hashref of the form:
  
     command  => \@command_to_execute
     merge    => $attempt_merge_stderr_and_stdout?
     setup    => $callback_to_setup_command
     teardown => $callback_to_teardown_command
  
  Tries to uses L<IPC::Open3> & L<IO::Select> to communicate with the spawned
  process if they are available.  Falls back onto C<open()>.
  
  =head2 Instance Methods
  
  =head3 C<next>
  
  Iterate through the process output, of course.
  
  =head3 C<next_raw>
  
  Iterate raw input without applying any fixes for quirky input syntax.
  
  =head3 C<wait>
  
  Get the wait status for this iterator's process.
  
  =head3 C<exit>
  
  Get the exit status for this iterator's process.
  
  =cut
  
  {
  
      no warnings 'uninitialized';
         # get around a catch22 in the test suite that causes failures on Win32:
      local $SIG{__DIE__} = undef;
      eval { require POSIX; &POSIX::WEXITSTATUS(0) };
      if ($@) {
          *_wait2exit = sub { $_[1] >> 8 };
      }
      else {
          *_wait2exit = sub { POSIX::WEXITSTATUS( $_[1] ) }
      }
  }
  
  sub _use_open3 {
      my $self = shift;
      return unless $Config{d_fork} || $IS_WIN32;
      for my $module (qw( IPC::Open3 IO::Select )) {
          eval "use $module";
          return if $@;
      }
      return 1;
  }
  
  {
      my $got_unicode;
  
      sub _get_unicode {
          return $got_unicode if defined $got_unicode;
          eval 'use Encode qw(decode_utf8);';
          $got_unicode = $@ ? 0 : 1;
  
      }
  }
  
  # new() implementation supplied by TAP::Object
  
  sub _initialize {
      my ( $self, $args ) = @_;
  
      my @command = @{ delete $args->{command} || [] }
        or die "Must supply a command to execute";
  
      $self->{command} = [@command];
  
      # Private. Used to frig with chunk size during testing.
      my $chunk_size = delete $args->{_chunk_size} || 65536;
  
      my $merge = delete $args->{merge};
      my ( $pid, $err, $sel );
  
      if ( my $setup = delete $args->{setup} ) {
          $setup->(@command);
      }
  
      my $out = IO::Handle->new;
  
      if ( $self->_use_open3 ) {
  
          # HOTPATCH {{{
          my $xclose = \&IPC::Open3::xclose;
          no warnings;
          local *IPC::Open3::xclose = sub {
              my $fh = shift;
              no strict 'refs';
              return if ( fileno($fh) == fileno(STDIN) );
              $xclose->($fh);
          };
  
          # }}}
  
          if ($IS_WIN32) {
              $err = $merge ? '' : '>&STDERR';
              eval {
                  $pid = open3(
                      '<&STDIN', $out, $merge ? '' : $err,
                      @command
                  );
              };
              die "Could not execute (@command): $@" if $@;
              if ( $] >= 5.006 ) {
                  binmode($out, ":crlf");
              }
          }
          else {
              $err = $merge ? '' : IO::Handle->new;
              eval { $pid = open3( '<&STDIN', $out, $err, @command ); };
              die "Could not execute (@command): $@" if $@;
              $sel = $merge ? undef : IO::Select->new( $out, $err );
          }
      }
      else {
          $err = '';
          my $command
            = join( ' ', map { $_ =~ /\s/ ? qq{"$_"} : $_ } @command );
          open( $out, "$command|" )
            or die "Could not execute ($command): $!";
      }
  
      $self->{out}        = $out;
      $self->{err}        = $err;
      $self->{sel}        = $sel;
      $self->{pid}        = $pid;
      $self->{exit}       = undef;
      $self->{chunk_size} = $chunk_size;
  
      if ( my $teardown = delete $args->{teardown} ) {
          $self->{teardown} = sub {
              $teardown->(@command);
          };
      }
  
      return $self;
  }
  
  =head3 C<handle_unicode>
  
  Upgrade the input stream to handle UTF8.
  
  =cut
  
  sub handle_unicode {
      my $self = shift;
  
      if ( $self->{sel} ) {
          if ( _get_unicode() ) {
  
              # Make sure our iterator has been constructed and...
              my $next = $self->{_next} ||= $self->_next;
  
              # ...wrap it to do UTF8 casting
              $self->{_next} = sub {
                  my $line = $next->();
                  return decode_utf8($line) if defined $line;
                  return;
              };
          }
      }
      else {
          if ( $] >= 5.008 ) {
              eval 'binmode($self->{out}, ":utf8")';
          }
      }
  
  }
  
  ##############################################################################
  
  sub wait { shift->{wait} }
  sub exit { shift->{exit} }
  
  sub _next {
      my $self = shift;
  
      if ( my $out = $self->{out} ) {
          if ( my $sel = $self->{sel} ) {
              my $err        = $self->{err};
              my @buf        = ();
              my $partial    = '';                    # Partial line
              my $chunk_size = $self->{chunk_size};
              return sub {
                  return shift @buf if @buf;
  
                  READ:
                  while ( my @ready = $sel->can_read ) {
                      for my $fh (@ready) {
                          my $got = sysread $fh, my ($chunk), $chunk_size;
  
                          if ( $got == 0 ) {
                              $sel->remove($fh);
                          }
                          elsif ( $fh == $err ) {
                              print STDERR $chunk;    # echo STDERR
                          }
                          else {
                              $chunk   = $partial . $chunk;
                              $partial = '';
  
                              # Make sure we have a complete line
                              unless ( substr( $chunk, -1, 1 ) eq "\n" ) {
                                  my $nl = rindex $chunk, "\n";
                                  if ( $nl == -1 ) {
                                      $partial = $chunk;
                                      redo READ;
                                  }
                                  else {
                                      $partial = substr( $chunk, $nl + 1 );
                                      $chunk = substr( $chunk, 0, $nl );
                                  }
                              }
  
                              push @buf, split /\n/, $chunk;
                              return shift @buf if @buf;
                          }
                      }
                  }
  
                  # Return partial last line
                  if ( length $partial ) {
                      my $last = $partial;
                      $partial = '';
                      return $last;
                  }
  
                  $self->_finish;
                  return;
              };
          }
          else {
              return sub {
                  if ( defined( my $line = <$out> ) ) {
                      chomp $line;
                      return $line;
                  }
                  $self->_finish;
                  return;
              };
          }
      }
      else {
          return sub {
              $self->_finish;
              return;
          };
      }
  }
  
  sub next_raw {
      my $self = shift;
      return ( $self->{_next} ||= $self->_next )->();
  }
  
  sub _finish {
      my $self = shift;
  
      my $status = $?;
  
      # Avoid circular refs
      $self->{_next} = sub {return}
        if $] >= 5.006;
  
      # If we have a subprocess we need to wait for it to terminate
      if ( defined $self->{pid} ) {
          if ( $self->{pid} == waitpid( $self->{pid}, 0 ) ) {
              $status = $?;
          }
      }
  
      ( delete $self->{out} )->close if $self->{out};
  
      # If we have an IO::Select we also have an error handle to close.
      if ( $self->{sel} ) {
          ( delete $self->{err} )->close;
          delete $self->{sel};
      }
      else {
          $status = $?;
      }
  
      # Sometimes we get -1 on Windows. Presumably that means status not
      # available.
      $status = 0 if $IS_WIN32 && $status == -1;
  
      $self->{wait} = $status;
      $self->{exit} = $self->_wait2exit($status);
  
      if ( my $teardown = $self->{teardown} ) {
          $teardown->();
      }
  
      return $self;
  }
  
  =head3 C<get_select_handles>
  
  Return a list of filehandles that may be used upstream in a select()
  call to signal that this Iterator is ready. Iterators that are not
  handle based should return an empty list.
  
  =cut
  
  sub get_select_handles {
      my $self = shift;
      return grep $_, ( $self->{out}, $self->{err} );
  }
  
  1;
  
  =head1 ATTRIBUTION
  
  Originally ripped off from L<Test::Harness>.
  
  =head1 SEE ALSO
  
  L<TAP::Object>,
  L<TAP::Parser>,
  L<TAP::Parser::Iterator>,
  
  =cut
  
TAP_PARSER_ITERATOR_PROCESS

$fatpacked{"TAP/Parser/Iterator/Stream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATOR_STREAM';
  package TAP::Parser::Iterator::Stream;
  
  use strict;
  use warnings;
  
  use base 'TAP::Parser::Iterator';
  
  =head1 NAME
  
  TAP::Parser::Iterator::Stream - Iterator for filehandle-based TAP sources
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 SYNOPSIS
  
    use TAP::Parser::Iterator::Stream;
    open( TEST, 'test.tap' );
    my $it   = TAP::Parser::Iterator::Stream->new(\*TEST);
    my $line = $it->next;
  
  =head1 DESCRIPTION
  
  This is a simple iterator wrapper for reading from filehandles, used by
  L<TAP::Parser>.  Unless you're writing a plugin or subclassing, you probably
  won't need to use this module directly.
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
  Create an iterator.  Expects one argument containing a filehandle.
  
  =cut
  
  # new() implementation supplied by TAP::Object
  
  sub _initialize {
      my ( $self, $thing ) = @_;
      $self->{fh} = $thing;
      return $self;
  }
  
  =head2 Instance Methods
  
  =head3 C<next>
  
  Iterate through it, of course.
  
  =head3 C<next_raw>
  
  Iterate raw input without applying any fixes for quirky input syntax.
  
  =head3 C<wait>
  
  Get the wait status for this iterator. Always returns zero.
  
  =head3 C<exit>
  
  Get the exit status for this iterator. Always returns zero.
  
  =cut
  
  sub wait { shift->exit }
  sub exit { shift->{fh} ? () : 0 }
  
  sub next_raw {
      my $self = shift;
      my $fh   = $self->{fh};
  
      if ( defined( my $line = <$fh> ) ) {
          chomp $line;
          return $line;
      }
      else {
          $self->_finish;
          return;
      }
  }
  
  sub _finish {
      my $self = shift;
      close delete $self->{fh};
  }
  
  sub get_select_handles {
      my $self = shift;
  
      # return our handle in case it's a socket or pipe (select()-able)
      return ( $self->{fh}, )
          if (-S $self->{fh} || -p $self->{fh});
  
      return;
  }
  
  1;
  
  =head1 ATTRIBUTION
  
  Originally ripped off from L<Test::Harness>.
  
  =head1 SEE ALSO
  
  L<TAP::Object>,
  L<TAP::Parser>,
  L<TAP::Parser::Iterator>,
  
  =cut
  
TAP_PARSER_ITERATOR_STREAM

$fatpacked{"TAP/Parser/IteratorFactory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATORFACTORY';
  package TAP::Parser::IteratorFactory;
  
  use strict;
  use warnings;
  
  use Carp qw( confess );
  use File::Basename qw( fileparse );
  
  use base 'TAP::Object';
  
  use constant handlers => [];
  
  =head1 NAME
  
  TAP::Parser::IteratorFactory - Figures out which SourceHandler objects to use for a given Source
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 SYNOPSIS
  
    use TAP::Parser::IteratorFactory;
    my $factory = TAP::Parser::IteratorFactory->new({ %config });
    my $iterator  = $factory->make_iterator( $filename );
  
  =head1 DESCRIPTION
  
  This is a factory class that takes a L<TAP::Parser::Source> and runs it through all the
  registered L<TAP::Parser::SourceHandler>s to see which one should handle the source.
  
  If you're a plugin author, you'll be interested in how to L</register_handler>s,
  how L</detect_source> works.
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
  Creates a new factory class:
  
    my $sf = TAP::Parser::IteratorFactory->new( $config );
  
  C<$config> is optional.  If given, sets L</config> and calls L</load_handlers>.
  
  =cut
  
  sub _initialize {
      my ( $self, $config ) = @_;
      $self->config( $config || {} )->load_handlers;
      return $self;
  }
  
  =head3 C<register_handler>
  
  Registers a new L<TAP::Parser::SourceHandler> with this factory.
  
    __PACKAGE__->register_handler( $handler_class );
  
  =head3 C<handlers>
  
  List of handlers that have been registered.
  
  =cut
  
  sub register_handler {
      my ( $class, $dclass ) = @_;
  
      confess("$dclass must implement can_handle & make_iterator methods!")
        unless UNIVERSAL::can( $dclass, 'can_handle' )
            && UNIVERSAL::can( $dclass, 'make_iterator' );
  
      my $handlers = $class->handlers;
      push @{$handlers}, $dclass
        unless grep { $_ eq $dclass } @{$handlers};
  
      return $class;
  }
  
  ##############################################################################
  
  =head2 Instance Methods
  
  =head3 C<config>
  
   my $cfg = $sf->config;
   $sf->config({ Perl => { %config } });
  
  Chaining getter/setter for the configuration of the available source handlers.
  This is a hashref keyed on handler class whose values contain config to be passed
  onto the handlers during detection & creation.  Class names may be fully qualified
  or abbreviated, eg:
  
    # these are equivalent
    $sf->config({ 'TAP::Parser::SourceHandler::Perl' => { %config } });
    $sf->config({ 'Perl' => { %config } });
  
  =cut
  
  sub config {
      my $self = shift;
      return $self->{config} unless @_;
      unless ( 'HASH' eq ref $_[0] ) {
          $self->_croak('Argument to &config must be a hash reference');
      }
      $self->{config} = shift;
      return $self;
  }
  
  sub _last_handler {
      my $self = shift;
      return $self->{last_handler} unless @_;
      $self->{last_handler} = shift;
      return $self;
  }
  
  sub _testing {
      my $self = shift;
      return $self->{testing} unless @_;
      $self->{testing} = shift;
      return $self;
  }
  
  ##############################################################################
  
  =head3 C<load_handlers>
  
   $sf->load_handlers;
  
  Loads the handler classes defined in L</config>.  For example, given a config:
  
    $sf->config({
      MySourceHandler => { some => 'config' },
    });
  
  C<load_handlers> will attempt to load the C<MySourceHandler> class by looking in
  C<@INC> for it in this order:
  
    TAP::Parser::SourceHandler::MySourceHandler
    MySourceHandler
  
  C<croak>s on error.
  
  =cut
  
  sub load_handlers {
      my ($self) = @_;
      for my $handler ( keys %{ $self->config } ) {
          my $sclass = $self->_load_handler($handler);
  
          # TODO: store which class we loaded anywhere?
      }
      return $self;
  }
  
  sub _load_handler {
      my ( $self, $handler ) = @_;
  
      my @errors;
      for my $dclass ( "TAP::Parser::SourceHandler::$handler", $handler ) {
          return $dclass
            if UNIVERSAL::can( $dclass, 'can_handle' )
                && UNIVERSAL::can( $dclass, 'make_iterator' );
  
          eval "use $dclass";
          if ( my $e = $@ ) {
              push @errors, $e;
              next;
          }
  
          return $dclass
            if UNIVERSAL::can( $dclass, 'can_handle' )
                && UNIVERSAL::can( $dclass, 'make_iterator' );
          push @errors,
            "handler '$dclass' does not implement can_handle & make_iterator";
      }
  
      $self->_croak(
          "Cannot load handler '$handler': " . join( "\n", @errors ) );
  }
  
  ##############################################################################
  
  =head3 C<make_iterator>
  
    my $iterator = $src_factory->make_iterator( $source );
  
  Given a L<TAP::Parser::Source>, finds the most suitable L<TAP::Parser::SourceHandler>
  to use to create a L<TAP::Parser::Iterator> (see L</detect_source>).  Dies on error.
  
  =cut
  
  sub make_iterator {
      my ( $self, $source ) = @_;
  
      $self->_croak('no raw source defined!') unless defined $source->raw;
  
      $source->config( $self->config )->assemble_meta;
  
      # is the raw source already an object?
      return $source->raw
        if ( $source->meta->{is_object}
          && UNIVERSAL::isa( $source->raw, 'TAP::Parser::SourceHandler' ) );
  
      # figure out what kind of source it is
      my $sd_class = $self->detect_source($source);
      $self->_last_handler($sd_class);
  
      return if $self->_testing;
  
      # create it
      my $iterator = $sd_class->make_iterator($source);
  
      return $iterator;
  }
  
  =head3 C<detect_source>
  
  Given a L<TAP::Parser::Source>, detects what kind of source it is and
  returns I<one> L<TAP::Parser::SourceHandler> (the most confident one).  Dies
  on error.
  
  The detection algorithm works something like this:
  
    for (@registered_handlers) {
      # ask them how confident they are about handling this source
      $confidence{$handler} = $handler->can_handle( $source )
    }
    # choose the most confident handler
  
  Ties are handled by choosing the first handler.
  
  =cut
  
  sub detect_source {
      my ( $self, $source ) = @_;
  
      confess('no raw source ref defined!') unless defined $source->raw;
  
      # find a list of handlers that can handle this source:
      my %confidence_for;
      for my $handler ( @{ $self->handlers } ) {
          my $confidence = $handler->can_handle($source);
          # warn "handler: $handler: $confidence\n";
          $confidence_for{$handler} = $confidence if $confidence;
      }
  
      if ( !%confidence_for ) {
          # error: can't detect source
          my $raw_source_short = substr( ${ $source->raw }, 0, 50 );
          confess("Cannot detect source of '$raw_source_short'!");
          return;
      }
  
      # if multiple handlers can handle it, choose the most confident one
      my @handlers =
            sort { $confidence_for{$b} <=> $confidence_for{$a} }
            keys %confidence_for;
  
      # Check for a tie.
      if( @handlers > 1 &&
          $confidence_for{$handlers[0]} == $confidence_for{$handlers[1]}
      ) {
          my $filename = $source->meta->{file}{basename};
          die("There is a tie between $handlers[0] and $handlers[1].\n".
              "Both voted $confidence_for{$handlers[0]} on $filename.\n");
      }
  
      # this is really useful for debugging handlers:
      if ( $ENV{TAP_HARNESS_SOURCE_FACTORY_VOTES} ) {
          warn(
              "votes: ",
              join( ', ', map {"$_: $confidence_for{$_}"} @handlers ),
              "\n"
          );
      }
  
      # return 1st
      return $handlers[0];
  }
  
  1;
  
  __END__
  
  =head1 SUBCLASSING
  
  Please see L<TAP::Parser/SUBCLASSING> for a subclassing overview.
  
  =head2 Example
  
  If we've done things right, you'll probably want to write a new source,
  rather than sub-classing this (see L<TAP::Parser::SourceHandler> for that).
  
  But in case you find the need to...
  
    package MyIteratorFactory;
  
    use strict;
  
    use base 'TAP::Parser::IteratorFactory';
  
    # override source detection algorithm
    sub detect_source {
      my ($self, $raw_source_ref, $meta) = @_;
      # do detective work, using $meta and whatever else...
    }
  
    1;
  
  =head1 AUTHORS
  
  Steve Purkis
  
  =head1 ATTRIBUTION
  
  Originally ripped off from L<Test::Harness>.
  
  Moved out of L<TAP::Parser> & converted to a factory class to support
  extensible TAP source detective work by Steve Purkis.
  
  =head1 SEE ALSO
  
  L<TAP::Object>,
  L<TAP::Parser>,
  L<TAP::Parser::SourceHandler>,
  L<TAP::Parser::SourceHandler::File>,
  L<TAP::Parser::SourceHandler::Perl>,
  L<TAP::Parser::SourceHandler::RawTAP>,
  L<TAP::Parser::SourceHandler::Handle>,
  L<TAP::Parser::SourceHandler::Executable>
  
  =cut
  
TAP_PARSER_ITERATORFACTORY

$fatpacked{"TAP/Parser/Multiplexer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_MULTIPLEXER';
  package TAP::Parser::Multiplexer;
  
  use strict;
  use warnings;
  
  use IO::Select;
  
  use base 'TAP::Object';
  
  use constant IS_WIN32 => $^O =~ /^(MS)?Win32$/;
  use constant IS_VMS => $^O eq 'VMS';
  use constant SELECT_OK => !( IS_VMS || IS_WIN32 );
  
  =head1 NAME
  
  TAP::Parser::Multiplexer - Multiplex multiple TAP::Parsers
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 SYNOPSIS
  
      use TAP::Parser::Multiplexer;
  
      my $mux = TAP::Parser::Multiplexer->new;
      $mux->add( $parser1, $stash1 );
      $mux->add( $parser2, $stash2 );
      while ( my ( $parser, $stash, $result ) = $mux->next ) {
          # do stuff
      }
  
  =head1 DESCRIPTION
  
  C<TAP::Parser::Multiplexer> gathers input from multiple TAP::Parsers.
  Internally it calls select on the input file handles for those parsers
  to wait for one or more of them to have input available.
  
  See L<TAP::Harness> for an example of its use.
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
      my $mux = TAP::Parser::Multiplexer->new;
  
  Returns a new C<TAP::Parser::Multiplexer> object.
  
  =cut
  
  # new() implementation supplied by TAP::Object
  
  sub _initialize {
      my $self = shift;
      $self->{select} = IO::Select->new;
      $self->{avid}   = [];                # Parsers that can't select
      $self->{count}  = 0;
      return $self;
  }
  
  ##############################################################################
  
  =head2 Instance Methods
  
  =head3 C<add>
  
    $mux->add( $parser, $stash );
  
  Add a TAP::Parser to the multiplexer. C<$stash> is an optional opaque
  reference that will be returned from C<next> along with the parser and
  the next result.
  
  =cut
  
  sub add {
      my ( $self, $parser, $stash ) = @_;
  
      if ( SELECT_OK && ( my @handles = $parser->get_select_handles ) ) {
          my $sel = $self->{select};
  
          # We have to turn handles into file numbers here because by
          # the time we want to remove them from our IO::Select they
          # will already have been closed by the iterator.
          my @filenos = map { fileno $_ } @handles;
          for my $h (@handles) {
              $sel->add( [ $h, $parser, $stash, @filenos ] );
          }
  
          $self->{count}++;
      }
      else {
          push @{ $self->{avid} }, [ $parser, $stash ];
      }
  }
  
  =head3 C<parsers>
  
    my $count   = $mux->parsers;
  
  Returns the number of parsers. Parsers are removed from the multiplexer
  when their input is exhausted.
  
  =cut
  
  sub parsers {
      my $self = shift;
      return $self->{count} + scalar @{ $self->{avid} };
  }
  
  sub _iter {
      my $self = shift;
  
      my $sel   = $self->{select};
      my $avid  = $self->{avid};
      my @ready = ();
  
      return sub {
  
          # Drain all the non-selectable parsers first
          if (@$avid) {
              my ( $parser, $stash ) = @{ $avid->[0] };
              my $result = $parser->next;
              shift @$avid unless defined $result;
              return ( $parser, $stash, $result );
          }
  
          unless (@ready) {
              return unless $sel->count;
              @ready = $sel->can_read;
          }
  
          my ( $h, $parser, $stash, @handles ) = @{ shift @ready };
          my $result = $parser->next;
  
          unless ( defined $result ) {
              $sel->remove(@handles);
              $self->{count}--;
  
              # Force another can_read - we may now have removed a handle
              # thought to have been ready.
              @ready = ();
          }
  
          return ( $parser, $stash, $result );
      };
  }
  
  =head3 C<next>
  
  Return a result from the next available parser. Returns a list
  containing the parser from which the result came, the stash that
  corresponds with that parser and the result.
  
      my ( $parser, $stash, $result ) = $mux->next;
  
  If C<$result> is undefined the corresponding parser has reached the end
  of its input (and will automatically be removed from the multiplexer).
  
  When all parsers are exhausted an empty list will be returned.
  
      if ( my ( $parser, $stash, $result ) = $mux->next ) {
          if ( ! defined $result ) {
              # End of this parser
          }
          else {
              # Process result
          }
      }
      else {
          # All parsers finished
      }
  
  =cut
  
  sub next {
      my $self = shift;
      return ( $self->{_iter} ||= $self->_iter )->();
  }
  
  =head1 See Also
  
  L<TAP::Parser>
  
  L<TAP::Harness>
  
  =cut
  
  1;
TAP_PARSER_MULTIPLEXER

$fatpacked{"TAP/Parser/Result.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT';
  package TAP::Parser::Result;
  
  use strict;
  use warnings;
  
  use base 'TAP::Object';
  
  BEGIN {
  
      # make is_* methods
      my @attrs = qw( plan pragma test comment bailout version unknown yaml );
      no strict 'refs';
      for my $token (@attrs) {
          my $method = "is_$token";
          *$method = sub { return $token eq shift->type };
      }
  }
  
  ##############################################################################
  
  =head1 NAME
  
  TAP::Parser::Result - Base class for TAP::Parser output objects
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 SYNOPSIS
  
    # abstract class - not meant to be used directly
    # see TAP::Parser::ResultFactory for preferred usage
  
    # directly:
    use TAP::Parser::Result;
    my $token  = {...};
    my $result = TAP::Parser::Result->new( $token );
  
  =head2 DESCRIPTION
  
  This is a simple base class used by L<TAP::Parser> to store objects that
  represent the current bit of test output data from TAP (usually a single
  line).  Unless you're subclassing, you probably won't need to use this module
  directly.
  
  =head2 METHODS
  
  =head3 C<new>
  
    # see TAP::Parser::ResultFactory for preferred usage
  
    # to use directly:
    my $result = TAP::Parser::Result->new($token);
  
  Returns an instance the appropriate class for the test token passed in.
  
  =cut
  
  # new() implementation provided by TAP::Object
  
  sub _initialize {
      my ( $self, $token ) = @_;
      if ($token) {
  
         # assign to a hash slice to make a shallow copy of the token.
         # I guess we could assign to the hash as (by default) there are not
         # contents, but that seems less helpful if someone wants to subclass us
          @{$self}{ keys %$token } = values %$token;
      }
      return $self;
  }
  
  ##############################################################################
  
  =head2 Boolean methods
  
  The following methods all return a boolean value and are to be overridden in
  the appropriate subclass.
  
  =over 4
  
  =item * C<is_plan>
  
  Indicates whether or not this is the test plan line.
  
   1..3
  
  =item * C<is_pragma>
  
  Indicates whether or not this is a pragma line.
  
   pragma +strict
  
  =item * C<is_test>
  
  Indicates whether or not this is a test line.
  
   ok 1 Is OK!
  
  =item * C<is_comment>
  
  Indicates whether or not this is a comment.
  
   # this is a comment
  
  =item * C<is_bailout>
  
  Indicates whether or not this is bailout line.
  
   Bail out! We're out of dilithium crystals.
  
  =item * C<is_version>
  
  Indicates whether or not this is a TAP version line.
  
   TAP version 4
  
  =item * C<is_unknown>
  
  Indicates whether or not the current line could be parsed.
  
   ... this line is junk ...
  
  =item * C<is_yaml>
  
  Indicates whether or not this is a YAML chunk.
  
  =back
  
  =cut
  
  ##############################################################################
  
  =head3 C<raw>
  
    print $result->raw;
  
  Returns the original line of text which was parsed.
  
  =cut
  
  sub raw { shift->{raw} }
  
  ##############################################################################
  
  =head3 C<type>
  
    my $type = $result->type;
  
  Returns the "type" of a token, such as C<comment> or C<test>.
  
  =cut
  
  sub type { shift->{type} }
  
  ##############################################################################
  
  =head3 C<as_string>
  
    print $result->as_string;
  
  Prints a string representation of the token.  This might not be the exact
  output, however.  Tests will have test numbers added if not present, TODO and
  SKIP directives will be capitalized and, in general, things will be cleaned
  up.  If you need the original text for the token, see the C<raw> method.
  
  =cut
  
  sub as_string { shift->{raw} }
  
  ##############################################################################
  
  =head3 C<is_ok>
  
    if ( $result->is_ok ) { ... }
  
  Reports whether or not a given result has passed.  Anything which is B<not> a
  test result returns true.  This is merely provided as a convenient shortcut.
  
  =cut
  
  sub is_ok {1}
  
  ##############################################################################
  
  =head3 C<passed>
  
  Deprecated.  Please use C<is_ok> instead.
  
  =cut
  
  sub passed {
      warn 'passed() is deprecated.  Please use "is_ok()"';
      shift->is_ok;
  }
  
  ##############################################################################
  
  =head3 C<has_directive>
  
    if ( $result->has_directive ) {
       ...
    }
  
  Indicates whether or not the given result has a TODO or SKIP directive.
  
  =cut
  
  sub has_directive {
      my $self = shift;
      return ( $self->has_todo || $self->has_skip );
  }
  
  ##############################################################################
  
  =head3 C<has_todo>
  
   if ( $result->has_todo ) {
       ...
   }
  
  Indicates whether or not the given result has a TODO directive.
  
  =cut
  
  sub has_todo { 'TODO' eq ( shift->{directive} || '' ) }
  
  ##############################################################################
  
  =head3 C<has_skip>
  
   if ( $result->has_skip ) {
       ...
   }
  
  Indicates whether or not the given result has a SKIP directive.
  
  =cut
  
  sub has_skip { 'SKIP' eq ( shift->{directive} || '' ) }
  
  =head3 C<set_directive>
  
  Set the directive associated with this token. Used internally to fake
  TODO tests.
  
  =cut
  
  sub set_directive {
      my ( $self, $dir ) = @_;
      $self->{directive} = $dir;
  }
  
  1;
  
  =head1 SUBCLASSING
  
  Please see L<TAP::Parser/SUBCLASSING> for a subclassing overview.
  
  Remember: if you want your subclass to be automatically used by the parser,
  you'll have to register it with L<TAP::Parser::ResultFactory/register_type>.
  
  If you're creating a completely new result I<type>, you'll probably need to
  subclass L<TAP::Parser::Grammar> too, or else it'll never get used.
  
  =head2 Example
  
    package MyResult;
  
    use strict;
  
    use base 'TAP::Parser::Result';
  
    # register with the factory:
    TAP::Parser::ResultFactory->register_type( 'my_type' => __PACKAGE__ );
  
    sub as_string { 'My results all look the same' }
  
  =head1 SEE ALSO
  
  L<TAP::Object>,
  L<TAP::Parser>,
  L<TAP::Parser::ResultFactory>,
  L<TAP::Parser::Result::Bailout>,
  L<TAP::Parser::Result::Comment>,
  L<TAP::Parser::Result::Plan>,
  L<TAP::Parser::Result::Pragma>,
  L<TAP::Parser::Result::Test>,
  L<TAP::Parser::Result::Unknown>,
  L<TAP::Parser::Result::Version>,
  L<TAP::Parser::Result::YAML>,
  
  =cut
TAP_PARSER_RESULT

$fatpacked{"TAP/Parser/Result/Bailout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_BAILOUT';
  package TAP::Parser::Result::Bailout;
  
  use strict;
  use warnings;
  
  use base 'TAP::Parser::Result';
  
  =head1 NAME
  
  TAP::Parser::Result::Bailout - Bailout result token.
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 DESCRIPTION
  
  This is a subclass of L<TAP::Parser::Result>.  A token of this class will be
  returned if a bail out line is encountered.
  
   1..5
   ok 1 - woo hooo!
   Bail out! Well, so much for "woo hooo!"
  
  =head1 OVERRIDDEN METHODS
  
  Mainly listed here to shut up the pitiful screams of the pod coverage tests.
  They keep me awake at night.
  
  =over 4
  
  =item * C<as_string>
  
  =back
  
  =cut
  
  ##############################################################################
  
  =head2 Instance Methods
  
  =head3 C<explanation>
  
    if ( $result->is_bailout ) {
        my $explanation = $result->explanation;
        print "We bailed out because ($explanation)";
    }
  
  If, and only if, a token is a bailout token, you can get an "explanation" via
  this method.  The explanation is the text after the mystical "Bail out!" words
  which appear in the tap output.
  
  =cut
  
  sub explanation { shift->{bailout} }
  sub as_string   { shift->{bailout} }
  
  1;
TAP_PARSER_RESULT_BAILOUT

$fatpacked{"TAP/Parser/Result/Comment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_COMMENT';
  package TAP::Parser::Result::Comment;
  
  use strict;
  use warnings;
  
  use base 'TAP::Parser::Result';
  
  =head1 NAME
  
  TAP::Parser::Result::Comment - Comment result token.
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 DESCRIPTION
  
  This is a subclass of L<TAP::Parser::Result>.  A token of this class will be
  returned if a comment line is encountered.
  
   1..1
   ok 1 - woo hooo!
   # this is a comment
  
  =head1 OVERRIDDEN METHODS
  
  Mainly listed here to shut up the pitiful screams of the pod coverage tests.
  They keep me awake at night.
  
  =over 4
  
  =item * C<as_string>
  
  Note that this method merely returns the comment preceded by a '# '.
  
  =back
  
  =cut
  
  ##############################################################################
  
  =head2 Instance Methods
  
  =head3 C<comment> 
  
    if ( $result->is_comment ) {
        my $comment = $result->comment;
        print "I have something to say:  $comment";
    }
  
  =cut
  
  sub comment   { shift->{comment} }
  sub as_string { shift->{raw} }
  
  1;
TAP_PARSER_RESULT_COMMENT

$fatpacked{"TAP/Parser/Result/Plan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_PLAN';
  package TAP::Parser::Result::Plan;
  
  use strict;
  use warnings;
  
  use base 'TAP::Parser::Result';
  
  =head1 NAME
  
  TAP::Parser::Result::Plan - Plan result token.
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 DESCRIPTION
  
  This is a subclass of L<TAP::Parser::Result>.  A token of this class will be
  returned if a plan line is encountered.
  
   1..1
   ok 1 - woo hooo!
  
  C<1..1> is the plan.  Gotta have a plan.
  
  =head1 OVERRIDDEN METHODS
  
  Mainly listed here to shut up the pitiful screams of the pod coverage tests.
  They keep me awake at night.
  
  =over 4
  
  =item * C<as_string>
  
  =item * C<raw>
  
  =back
  
  =cut
  
  ##############################################################################
  
  =head2 Instance Methods
  
  =head3 C<plan> 
  
    if ( $result->is_plan ) {
       print $result->plan;
    }
  
  This is merely a synonym for C<as_string>.
  
  =cut
  
  sub plan { '1..' . shift->{tests_planned} }
  
  ##############################################################################
  
  =head3 C<tests_planned>
  
    my $planned = $result->tests_planned;
  
  Returns the number of tests planned.  For example, a plan of C<1..17> will
  cause this method to return '17'.
  
  =cut
  
  sub tests_planned { shift->{tests_planned} }
  
  ##############################################################################
  
  =head3 C<directive>
  
   my $directive = $plan->directive; 
  
  If a SKIP directive is included with the plan, this method will return it.
  
   1..0 # SKIP: why bother?
  
  =cut
  
  sub directive { shift->{directive} }
  
  ##############################################################################
  
  =head3 C<has_skip>
  
    if ( $result->has_skip ) { ... }
  
  Returns a boolean value indicating whether or not this test has a SKIP
  directive.
  
  =head3 C<explanation>
  
   my $explanation = $plan->explanation;
  
  If a SKIP directive was included with the plan, this method will return the
  explanation, if any.
  
  =cut
  
  sub explanation { shift->{explanation} }
  
  =head3 C<todo_list>
  
    my $todo = $result->todo_list;
    for ( @$todo ) {
        ...
    }
  
  =cut
  
  sub todo_list { shift->{todo_list} }
  
  1;
TAP_PARSER_RESULT_PLAN

$fatpacked{"TAP/Parser/Result/Pragma.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_PRAGMA';
  package TAP::Parser::Result::Pragma;
  
  use strict;
  use warnings;
  
  use base 'TAP::Parser::Result';
  
  =head1 NAME
  
  TAP::Parser::Result::Pragma - TAP pragma token.
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 DESCRIPTION
  
  This is a subclass of L<TAP::Parser::Result>.  A token of this class will be
  returned if a pragma is encountered.
  
   TAP version 13
   pragma +strict, -foo
  
  Pragmas are only supported from TAP version 13 onwards.
  
  =head1 OVERRIDDEN METHODS
  
  Mainly listed here to shut up the pitiful screams of the pod coverage tests.
  They keep me awake at night.
  
  =over 4
  
  =item * C<as_string>
  
  =item * C<raw>
  
  =back
  
  =cut
  
  ##############################################################################
  
  =head2 Instance Methods
  
  =head3 C<pragmas> 
  
  if ( $result->is_pragma ) {
      @pragmas = $result->pragmas;
  }
  
  =cut
  
  sub pragmas {
      my @pragmas = @{ shift->{pragmas} };
      return wantarray ? @pragmas : \@pragmas;
  }
  
  1;
TAP_PARSER_RESULT_PRAGMA

$fatpacked{"TAP/Parser/Result/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_TEST';
  package TAP::Parser::Result::Test;
  
  use strict;
  use warnings;
  
  use base 'TAP::Parser::Result';
  
  =head1 NAME
  
  TAP::Parser::Result::Test - Test result token.
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 DESCRIPTION
  
  This is a subclass of L<TAP::Parser::Result>.  A token of this class will be
  returned if a test line is encountered.
  
   1..1
   ok 1 - woo hooo!
  
  =head1 OVERRIDDEN METHODS
  
  This class is the workhorse of the L<TAP::Parser> system.  Most TAP lines will
  be test lines and if C<< $result->is_test >>, then you have a bunch of methods
  at your disposal.
  
  =head2 Instance Methods
  
  =cut
  
  ##############################################################################
  
  =head3 C<ok>
  
    my $ok = $result->ok;
  
  Returns the literal text of the C<ok> or C<not ok> status.
  
  =cut
  
  sub ok { shift->{ok} }
  
  ##############################################################################
  
  =head3 C<number>
  
    my $test_number = $result->number;
  
  Returns the number of the test, even if the original TAP output did not supply
  that number.
  
  =cut
  
  sub number { shift->{test_num} }
  
  sub _number {
      my ( $self, $number ) = @_;
      $self->{test_num} = $number;
  }
  
  ##############################################################################
  
  =head3 C<description>
  
    my $description = $result->description;
  
  Returns the description of the test, if any.  This is the portion after the
  test number but before the directive.
  
  =cut
  
  sub description { shift->{description} }
  
  ##############################################################################
  
  =head3 C<directive>
  
    my $directive = $result->directive;
  
  Returns either C<TODO> or C<SKIP> if either directive was present for a test
  line.
  
  =cut
  
  sub directive { shift->{directive} }
  
  ##############################################################################
  
  =head3 C<explanation>
  
    my $explanation = $result->explanation;
  
  If a test had either a C<TODO> or C<SKIP> directive, this method will return
  the accompanying explanation, if present.
  
    not ok 17 - 'Pigs can fly' # TODO not enough acid
  
  For the above line, the explanation is I<not enough acid>.
  
  =cut
  
  sub explanation { shift->{explanation} }
  
  ##############################################################################
  
  =head3 C<is_ok>
  
    if ( $result->is_ok ) { ... }
  
  Returns a boolean value indicating whether or not the test passed.  Remember
  that for TODO tests, the test always passes.
  
  If the test is unplanned, this method will always return false.  See
  C<is_unplanned>.
  
  =cut
  
  sub is_ok {
      my $self = shift;
  
      return if $self->is_unplanned;
  
      # TODO directives reverse the sense of a test.
      return $self->has_todo ? 1 : $self->ok !~ /not/;
  }
  
  ##############################################################################
  
  =head3 C<is_actual_ok>
  
    if ( $result->is_actual_ok ) { ... }
  
  Returns a boolean value indicating whether or not the test passed, regardless
  of its TODO status.
  
  =cut
  
  sub is_actual_ok {
      my $self = shift;
      return $self->{ok} !~ /not/;
  }
  
  ##############################################################################
  
  =head3 C<actual_passed>
  
  Deprecated.  Please use C<is_actual_ok> instead.
  
  =cut
  
  sub actual_passed {
      warn 'actual_passed() is deprecated.  Please use "is_actual_ok()"';
      goto &is_actual_ok;
  }
  
  ##############################################################################
  
  =head3 C<todo_passed>
  
    if ( $test->todo_passed ) {
       # test unexpectedly succeeded
    }
  
  If this is a TODO test and an 'ok' line, this method returns true.
  Otherwise, it will always return false (regardless of passing status on
  non-todo tests).
  
  This is used to track which tests unexpectedly succeeded.
  
  =cut
  
  sub todo_passed {
      my $self = shift;
      return $self->has_todo && $self->is_actual_ok;
  }
  
  ##############################################################################
  
  =head3 C<todo_failed>
  
    # deprecated in favor of 'todo_passed'.  This method was horribly misnamed.
  
  This was a badly misnamed method.  It indicates which TODO tests unexpectedly
  succeeded.  Will now issue a warning and call C<todo_passed>.
  
  =cut
  
  sub todo_failed {
      warn 'todo_failed() is deprecated.  Please use "todo_passed()"';
      goto &todo_passed;
  }
  
  ##############################################################################
  
  =head3 C<has_skip>
  
    if ( $result->has_skip ) { ... }
  
  Returns a boolean value indicating whether or not this test has a SKIP
  directive.
  
  =head3 C<has_todo>
  
    if ( $result->has_todo ) { ... }
  
  Returns a boolean value indicating whether or not this test has a TODO
  directive.
  
  =head3 C<as_string>
  
    print $result->as_string;
  
  This method prints the test as a string.  It will probably be similar, but
  not necessarily identical, to the original test line.  Directives are
  capitalized, some whitespace may be trimmed and a test number will be added if
  it was not present in the original line.  If you need the original text of the
  test line, use the C<raw> method.
  
  =cut
  
  sub as_string {
      my $self   = shift;
      my $string = $self->ok . " " . $self->number;
      if ( my $description = $self->description ) {
          $string .= " $description";
      }
      if ( my $directive = $self->directive ) {
          my $explanation = $self->explanation;
          $string .= " # $directive $explanation";
      }
      return $string;
  }
  
  ##############################################################################
  
  =head3 C<is_unplanned>
  
    if ( $test->is_unplanned ) { ... }
    $test->is_unplanned(1);
  
  If a test number is greater than the number of planned tests, this method will
  return true.  Unplanned tests will I<always> return false for C<is_ok>,
  regardless of whether or not the test C<has_todo>.
  
  Note that if tests have a trailing plan, it is not possible to set this
  property for unplanned tests as we do not know it's unplanned until the plan
  is reached:
  
    print <<'END';
    ok 1
    ok 2
    1..1
    END
  
  =cut
  
  sub is_unplanned {
      my $self = shift;
      return ( $self->{unplanned} || '' ) unless @_;
      $self->{unplanned} = !!shift;
      return $self;
  }
  
  1;
TAP_PARSER_RESULT_TEST

$fatpacked{"TAP/Parser/Result/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_UNKNOWN';
  package TAP::Parser::Result::Unknown;
  
  use strict;
  use warnings;
  
  use base 'TAP::Parser::Result';
  
  =head1 NAME
  
  TAP::Parser::Result::Unknown - Unknown result token.
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 DESCRIPTION
  
  This is a subclass of L<TAP::Parser::Result>.  A token of this class will be
  returned if the parser does not recognize the token line.  For example:
  
   1..5
   VERSION 7
   ok 1 - woo hooo!
   ... woo hooo! is cool!
  
  In the above "TAP", the second and fourth lines will generate "Unknown"
  tokens.
  
  =head1 OVERRIDDEN METHODS
  
  Mainly listed here to shut up the pitiful screams of the pod coverage tests.
  They keep me awake at night.
  
  =over 4
  
  =item * C<as_string>
  
  =item * C<raw>
  
  =back
  
  =cut
  
  1;
TAP_PARSER_RESULT_UNKNOWN

$fatpacked{"TAP/Parser/Result/Version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_VERSION';
  package TAP::Parser::Result::Version;
  
  use strict;
  use warnings;
  
  use base 'TAP::Parser::Result';
  
  =head1 NAME
  
  TAP::Parser::Result::Version - TAP syntax version token.
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 DESCRIPTION
  
  This is a subclass of L<TAP::Parser::Result>.  A token of this class will be
  returned if a version line is encountered.
  
   TAP version 13
   ok 1
   not ok 2
  
  The first version of TAP to include an explicit version number is 13.
  
  =head1 OVERRIDDEN METHODS
  
  Mainly listed here to shut up the pitiful screams of the pod coverage tests.
  They keep me awake at night.
  
  =over 4
  
  =item * C<as_string>
  
  =item * C<raw>
  
  =back
  
  =cut
  
  ##############################################################################
  
  =head2 Instance Methods
  
  =head3 C<version> 
  
    if ( $result->is_version ) {
       print $result->version;
    }
  
  This is merely a synonym for C<as_string>.
  
  =cut
  
  sub version { shift->{version} }
  
  1;
TAP_PARSER_RESULT_VERSION

$fatpacked{"TAP/Parser/Result/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_YAML';
  package TAP::Parser::Result::YAML;
  
  use strict;
  use warnings;
  
  use base 'TAP::Parser::Result';
  
  =head1 NAME
  
  TAP::Parser::Result::YAML - YAML result token.
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 DESCRIPTION
  
  This is a subclass of L<TAP::Parser::Result>.  A token of this class will be
  returned if a YAML block is encountered.
  
   1..1
   ok 1 - woo hooo!
  
  C<1..1> is the plan.  Gotta have a plan.
  
  =head1 OVERRIDDEN METHODS
  
  Mainly listed here to shut up the pitiful screams of the pod coverage tests.
  They keep me awake at night.
  
  =over 4
  
  =item * C<as_string>
  
  =item * C<raw>
  
  =back
  
  =cut
  
  ##############################################################################
  
  =head2 Instance Methods
  
  =head3 C<data> 
  
    if ( $result->is_yaml ) {
       print $result->data;
    }
  
  Return the parsed YAML data for this result
  
  =cut
  
  sub data { shift->{data} }
  
  1;
TAP_PARSER_RESULT_YAML

$fatpacked{"TAP/Parser/ResultFactory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULTFACTORY';
  package TAP::Parser::ResultFactory;
  
  use strict;
  use warnings;
  
  use TAP::Parser::Result::Bailout ();
  use TAP::Parser::Result::Comment ();
  use TAP::Parser::Result::Plan    ();
  use TAP::Parser::Result::Pragma  ();
  use TAP::Parser::Result::Test    ();
  use TAP::Parser::Result::Unknown ();
  use TAP::Parser::Result::Version ();
  use TAP::Parser::Result::YAML    ();
  
  use base 'TAP::Object';
  
  ##############################################################################
  
  =head1 NAME
  
  TAP::Parser::ResultFactory - Factory for creating TAP::Parser output objects
  
  =head1 SYNOPSIS
  
    use TAP::Parser::ResultFactory;
    my $token   = {...};
    my $factory = TAP::Parser::ResultFactory->new;
    my $result  = $factory->make_result( $token );
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head2 DESCRIPTION
  
  This is a simple factory class which returns a L<TAP::Parser::Result> subclass
  representing the current bit of test data from TAP (usually a single line).
  It is used primarily by L<TAP::Parser::Grammar>.  Unless you're subclassing,
  you probably won't need to use this module directly.
  
  =head2 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
  Creates a new factory class.
  I<Note:> You currently don't need to instantiate a factory in order to use it.
  
  =head3 C<make_result>
  
  Returns an instance the appropriate class for the test token passed in.
  
    my $result = TAP::Parser::ResultFactory->make_result($token);
  
  Can also be called as an instance method.
  
  =cut
  
  sub make_result {
      my ( $proto, $token ) = @_;
      my $type = $token->{type};
      return $proto->class_for($type)->new($token);
  }
  
  =head3 C<class_for>
  
  Takes one argument: C<$type>.  Returns the class for this $type, or C<croak>s
  with an error.
  
  =head3 C<register_type>
  
  Takes two arguments: C<$type>, C<$class>
  
  This lets you override an existing type with your own custom type, or register
  a completely new type, eg:
  
    # create a custom result type:
    package MyResult;
    use strict;
    use base 'TAP::Parser::Result';
  
    # register with the factory:
    TAP::Parser::ResultFactory->register_type( 'my_type' => __PACKAGE__ );
  
    # use it:
    my $r = TAP::Parser::ResultFactory->( { type => 'my_type' } );
  
  Your custom type should then be picked up automatically by the L<TAP::Parser>.
  
  =cut
  
  our %CLASS_FOR = (
  	plan    => 'TAP::Parser::Result::Plan',
  	pragma  => 'TAP::Parser::Result::Pragma',
  	test    => 'TAP::Parser::Result::Test',
  	comment => 'TAP::Parser::Result::Comment',
  	bailout => 'TAP::Parser::Result::Bailout',
  	version => 'TAP::Parser::Result::Version',
  	unknown => 'TAP::Parser::Result::Unknown',
  	yaml    => 'TAP::Parser::Result::YAML',
  );
  
  sub class_for {
      my ( $class, $type ) = @_;
  
      # return target class:
      return $CLASS_FOR{$type} if exists $CLASS_FOR{$type};
  
      # or complain:
      require Carp;
      Carp::croak("Could not determine class for result type '$type'");
  }
  
  sub register_type {
      my ( $class, $type, $rclass ) = @_;
  
      # register it blindly, assume they know what they're doing
      $CLASS_FOR{$type} = $rclass;
      return $class;
  }
  
  1;
  
  =head1 SUBCLASSING
  
  Please see L<TAP::Parser/SUBCLASSING> for a subclassing overview.
  
  There are a few things to bear in mind when creating your own
  C<ResultFactory>:
  
  =over 4
  
  =item 1
  
  The factory itself is never instantiated (this I<may> change in the future).
  This means that C<_initialize> is never called.
  
  =item 2
  
  C<TAP::Parser::Result-E<gt>new> is never called, $tokens are reblessed.
  This I<will> change in a future version!
  
  =item 3
  
  L<TAP::Parser::Result> subclasses will register themselves with
  L<TAP::Parser::ResultFactory> directly:
  
    package MyFooResult;
    TAP::Parser::ResultFactory->register_type( foo => __PACKAGE__ );
  
  Of course, it's up to you to decide whether or not to ignore them.
  
  =back
  
  =head2 Example
  
    package MyResultFactory;
  
    use strict;
  
    use MyResult;
  
    use base 'TAP::Parser::ResultFactory';
  
    # force all results to be 'MyResult'
    sub class_for {
      return 'MyResult';
    }
  
    1;
  
  =head1 SEE ALSO
  
  L<TAP::Parser>,
  L<TAP::Parser::Result>,
  L<TAP::Parser::Grammar>
  
  =cut
TAP_PARSER_RESULTFACTORY

$fatpacked{"TAP/Parser/Scheduler.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SCHEDULER';
  package TAP::Parser::Scheduler;
  
  use strict;
  use warnings;
  
  use Carp;
  use TAP::Parser::Scheduler::Job;
  use TAP::Parser::Scheduler::Spinner;
  
  =head1 NAME
  
  TAP::Parser::Scheduler - Schedule tests during parallel testing
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 SYNOPSIS
  
      use TAP::Parser::Scheduler;
  
  =head1 DESCRIPTION
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
      my $sched = TAP::Parser::Scheduler->new(tests => \@tests);
      my $sched = TAP::Parser::Scheduler->new(
          tests => [ ['t/test_name.t','Test Description'], ... ],
          rules => \%rules,
      );
  
  Given 'tests' and optional 'rules' as input, returns a new
  C<TAP::Parser::Scheduler> object.  Each member of C<@tests> should be either a
  a test file name, or a two element arrayref, where the first element is a test
  file name, and the second element is a test description. By default, we'll use
  the test name as the description.
  
  The optional C<rules> attribute provides direction on which tests should be run
  in parallel and which should be run sequentially. If no rule data structure is
  provided, a default data structure is used which makes every test eligible to
  be run in parallel:
  
      { par => '**' },
  
  The rules data structure is documented more in the next section.
  
  =head2 Rules data structure
  
  The "C<rules>" data structure is the the heart of the scheduler. It allows you
  to express simple rules like "run all tests in sequence" or "run all tests in
  parallel except these five tests.". However, the rules structure also supports
  glob-style pattern matching and recursive definitions, so you can also express
  arbitarily complicated patterns.
  
  The rule must only have one top level key: either 'par' for "parallel" or 'seq'
  for "sequence".
  
  Values must be either strings with possible glob-style matching, or arrayrefs
  of strings or hashrefs which follow this pattern recursively.
  
  Every element in an arrayref directly below a 'par' key is eligible to be run
  in parallel, while vavalues directly below a 'seq' key must be run in sequence.
  
  =head3 Rules examples
  
  Here are some examples:
  
      # All tests be run in parallel (the default rule)
      { par => '**' },
  
      # Run all tests in sequence, except those starting with "p"
      { par => 't/p*.t' },
  
      # Run all tests in parallel, except those starting with "p"
      {
          seq => [
                    { seq => 't/p*.t' },
                    { par => '**'     },
                 ],
      }
  
      # Run some  startup tests in sequence, then some parallel tests then some
      # teardown tests in sequence.
      {
          seq => [
              { seq => 't/startup/*.t' },
              { par => ['t/a/*.t','t/b/*.t','t/c/*.t'], }
              { seq => 't/shutdown/*.t' },
          ],
      },
  
  
  =head3 Rules resolution
  
  =over 4
  
  =item * By default, all tests are eligible to be run in parallel. Specifying any of your own rules removes this one.
  
  =item * "First match wins". The first rule that matches a test will be the one that applies.
  
  =item * Any test which does not match a rule will be run in sequence at the end of the run.
  
  =item * The existence of a rule does not imply selecting a test. You must still specify the tests to run.
  
  =item * Specifying a rule to allow tests to run in parallel does not make the run in parallel. You still need specify the number of parallel C<jobs> in your Harness object.
  
  =back
  
  =head3 Glob-style pattern matching for rules
  
  We implement our own glob-style pattern matching. Here are the patterns it supports:
  
      ** is any number of characters, including /, within a pathname
      * is zero or more characters within a filename/directory name
      ? is exactly one character within a filename/directory name
      {foo,bar,baz} is any of foo, bar or baz.
      \ is an escape character
  
  =cut
  
  sub new {
      my $class = shift;
  
      croak "Need a number of key, value pairs" if @_ % 2;
  
      my %args  = @_;
      my $tests = delete $args{tests} || croak "Need a 'tests' argument";
      my $rules = delete $args{rules} || { par => '**' };
  
      croak "Unknown arg(s): ", join ', ', sort keys %args
        if keys %args;
  
      # Turn any simple names into a name, description pair. TODO: Maybe
      # construct jobs here?
      my $self = bless {}, $class;
  
      $self->_set_rules( $rules, $tests );
  
      return $self;
  }
  
  # Build the scheduler data structure.
  #
  # SCHEDULER-DATA ::= JOB
  #                ||  ARRAY OF ARRAY OF SCHEDULER-DATA
  #
  # The nested arrays are the key to scheduling. The outer array contains
  # a list of things that may be executed in parallel. Whenever an
  # eligible job is sought any element of the outer array that is ready to
  # execute can be selected. The inner arrays represent sequential
  # execution. They can only proceed when the first job is ready to run.
  
  sub _set_rules {
      my ( $self, $rules, $tests ) = @_;
  
      # Convert all incoming tests to job objects. 
      # If no test description is provided use the file name as the description. 
      my @tests = map { TAP::Parser::Scheduler::Job->new(@$_) }
        map { 'ARRAY' eq ref $_ ? $_ : [ $_, $_ ] } @$tests;
      my $schedule = $self->_rule_clause( $rules, \@tests );
  
      # If any tests are left add them as a sequential block at the end of
      # the run.
      $schedule = [ [ $schedule, @tests ] ] if @tests;
  
      $self->{schedule} = $schedule;
  }
  
  sub _rule_clause {
      my ( $self, $rule, $tests ) = @_;
      croak 'Rule clause must be a hash'
        unless 'HASH' eq ref $rule;
  
      my @type = keys %$rule;
      croak 'Rule clause must have exactly one key'
        unless @type == 1;
  
      my %handlers = (
          par => sub {
              [ map { [$_] } @_ ];
          },
          seq => sub { [ [@_] ] },
      );
  
      my $handler = $handlers{ $type[0] }
        || croak 'Unknown scheduler type: ', $type[0];
      my $val = $rule->{ $type[0] };
  
      return $handler->(
          map {
              'HASH' eq ref $_
                ? $self->_rule_clause( $_, $tests )
                : $self->_expand( $_, $tests )
            } 'ARRAY' eq ref $val ? @$val : $val
      );
  }
  
  sub _glob_to_regexp {
      my ( $self, $glob ) = @_;
      my $nesting;
      my $pattern;
  
      while (1) {
          if ( $glob =~ /\G\*\*/gc ) {
  
              # ** is any number of characters, including /, within a pathname
              $pattern .= '.*?';
          }
          elsif ( $glob =~ /\G\*/gc ) {
  
              # * is zero or more characters within a filename/directory name
              $pattern .= '[^/]*';
          }
          elsif ( $glob =~ /\G\?/gc ) {
  
              # ? is exactly one character within a filename/directory name
              $pattern .= '[^/]';
          }
          elsif ( $glob =~ /\G\{/gc ) {
  
              # {foo,bar,baz} is any of foo, bar or baz.
              $pattern .= '(?:';
              ++$nesting;
          }
          elsif ( $nesting and $glob =~ /\G,/gc ) {
  
              # , is only special inside {}
              $pattern .= '|';
          }
          elsif ( $nesting and $glob =~ /\G\}/gc ) {
  
              # } that matches { is special. But unbalanced } are not.
              $pattern .= ')';
              --$nesting;
          }
          elsif ( $glob =~ /\G(\\.)/gc ) {
  
              # A quoted literal
              $pattern .= $1;
          }
          elsif ( $glob =~ /\G([\},])/gc ) {
  
              # Sometimes meta characters
              $pattern .= '\\' . $1;
          }
          else {
  
              # Eat everything that is not a meta character.
              $glob =~ /\G([^{?*\\\},]*)/gc;
              $pattern .= quotemeta $1;
          }
          return $pattern if pos $glob == length $glob;
      }
  }
  
  sub _expand {
      my ( $self, $name, $tests ) = @_;
  
      my $pattern = $self->_glob_to_regexp($name);
      $pattern = qr/^ $pattern $/x;
      my @match = ();
  
      for ( my $ti = 0; $ti < @$tests; $ti++ ) {
          if ( $tests->[$ti]->filename =~ $pattern ) {
              push @match, splice @$tests, $ti, 1;
              $ti--;
          }
      }
  
      return @match;
  }
  
  =head2 Instance Methods
  
  =head3 C<get_all>
  
  Get a list of all remaining tests.
  
  =cut
  
  sub get_all {
      my $self = shift;
      my @all  = $self->_gather( $self->{schedule} );
      $self->{count} = @all;
      @all;
  }
  
  sub _gather {
      my ( $self, $rule ) = @_;
      return unless defined $rule;
      return $rule unless 'ARRAY' eq ref $rule;
      return map { defined() ? $self->_gather($_) : () } map {@$_} @$rule;
  }
  
  =head3 C<get_job>
  
  Return the next available job as L<TAP::Parser::Scheduler::Job> object or
  C<undef> if none are available. Returns a L<TAP::Parser::Scheduler::Spinner> if
  the scheduler still has pending jobs but none are available to run right now.
  
  =cut
  
  sub get_job {
      my $self = shift;
      $self->{count} ||= $self->get_all;
      my @jobs = $self->_find_next_job( $self->{schedule} );
      if (@jobs) {
          --$self->{count};
          return $jobs[0];
      }
  
      return TAP::Parser::Scheduler::Spinner->new
        if $self->{count};
  
      return;
  }
  
  sub _not_empty {
      my $ar = shift;
      return 1 unless 'ARRAY' eq ref $ar;
      for (@$ar) {
          return 1 if _not_empty($_);
      }
      return;
  }
  
  sub _is_empty { !_not_empty(@_) }
  
  sub _find_next_job {
      my ( $self, $rule ) = @_;
  
      my @queue = ();
      my $index = 0;
      while ( $index < @$rule ) {
          my $seq = $rule->[$index];
  
          # Prune any exhausted items.
          shift @$seq while @$seq && _is_empty( $seq->[0] );
          if (@$seq) {
              if ( defined $seq->[0] ) {
                  if ( 'ARRAY' eq ref $seq->[0] ) {
                      push @queue, $seq;
                  }
                  else {
                      my $job = splice @$seq, 0, 1, undef;
                      $job->on_finish( sub { shift @$seq } );
                      return $job;
                  }
              }
              ++$index;
          }
          else {
  
              # Remove the empty sub-array from the array
              splice @$rule, $index, 1;
          }
      }
  
      for my $seq (@queue) {
          if ( my @jobs = $self->_find_next_job( $seq->[0] ) ) {
              return @jobs;
          }
      }
  
      return;
  }
  
  =head3 C<as_string>
  
  Return a human readable representation of the scheduling tree.
  For example:
  
      my @tests = (qw{
          t/startup/foo.t 
          t/shutdown/foo.t
      
          t/a/foo.t t/b/foo.t t/c/foo.t t/d/foo.t
      });
      my $sched = TAP::Parser::Scheduler->new(
          tests => \@tests,
          rules => {
              seq => [
                  { seq => 't/startup/*.t' },
                  { par => ['t/a/*.t','t/b/*.t','t/c/*.t'] },
                  { seq => 't/shutdown/*.t' },
              ],
          },
      );
  
  Produces:
  
      par:
        seq:
          par:
            seq:
              par:
                seq:
                  't/startup/foo.t'
              par:
                seq:
                  't/a/foo.t'
                seq:
                  't/b/foo.t'
                seq:
                  't/c/foo.t'
              par:
                seq:
                  't/shutdown/foo.t'
          't/d/foo.t'
  
  
  =cut
  
  
  sub as_string {
      my $self = shift;
      return $self->_as_string( $self->{schedule} );
  }
  
  sub _as_string {
      my ( $self, $rule, $depth ) = ( shift, shift, shift || 0 );
      my $pad    = ' ' x 2;
      my $indent = $pad x $depth;
      if ( !defined $rule ) {
          return "$indent(undef)\n";
      }
      elsif ( 'ARRAY' eq ref $rule ) {
          return unless @$rule;
          my $type = ( 'par', 'seq' )[ $depth % 2 ];
          return join(
              '', "$indent$type:\n",
              map { $self->_as_string( $_, $depth + 1 ) } @$rule
          );
      }
      else {
          return "$indent'" . $rule->filename . "'\n";
      }
  }
  
  1;
TAP_PARSER_SCHEDULER

$fatpacked{"TAP/Parser/Scheduler/Job.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SCHEDULER_JOB';
  package TAP::Parser::Scheduler::Job;
  
  use strict;
  use warnings;
  use Carp;
  
  =head1 NAME
  
  TAP::Parser::Scheduler::Job - A single testing job.
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 SYNOPSIS
  
      use TAP::Parser::Scheduler::Job;
  
  =head1 DESCRIPTION
  
  Represents a single test 'job'.
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
      my $job = TAP::Parser::Scheduler::Job->new(
          $filename, $description
      );
  
  Given the filename and description of a test as scalars, returns a new
  L<TAP::Parser::Scheduler::Job> object.
  
  =cut
  
  sub new {
      my ( $class, $name, $desc, @ctx ) = @_;
      return bless {
          filename    => $name,
          description => $desc,
          @ctx ? ( context => \@ctx ) : (),
      }, $class;
  }
  
  =head2 Instance Methods
  
  =head3 C<on_finish>
  
      $self->on_finish(\&method).
  
  Register a closure to be called when this job is destroyed. The callback
  will be passed the C<TAP::Parser::Scheduler::Job> object as it's only argument.
  
  =cut
  
  sub on_finish {
      my ( $self, $cb ) = @_;
      $self->{on_finish} = $cb;
  }
  
  =head3 C<finish>
  
     $self->finish;
  
  Called when a job is complete to unlock it. If a callback has been registered
  with C<on_finish>, it calls it. Otherwise, it does nothing. 
  
  =cut
  
  sub finish {
      my $self = shift;
      if ( my $cb = $self->{on_finish} ) {
          $cb->($self);
      }
  }
  
  =head2 Attributes
  
    $self->filename;
    $self->description;
    $self->context;
  
  These are all "getters" which return the data set for these attributes during object construction.
  
  
  =head3 C<filename>
  
  =head3 C<description>
  
  =head3 C<context>
  
  =cut
  
  sub filename    { shift->{filename} }
  sub description { shift->{description} }
  sub context     { @{ shift->{context} || [] } }
  
  =head3 C<as_array_ref>
  
  For backwards compatibility in callbacks.
  
  =cut
  
  sub as_array_ref {
      my $self = shift;
      return [ $self->filename, $self->description, $self->{context} ||= [] ];
  }
  
  =head3 C<is_spinner>
  
    $self->is_spinner;
  
  Returns false indicating that this is a real job rather than a
  'spinner'. Spinners are returned when the scheduler still has pending
  jobs but can't (because of locking) return one right now.
  
  =cut
  
  sub is_spinner {0}
  
  1;
TAP_PARSER_SCHEDULER_JOB

$fatpacked{"TAP/Parser/Scheduler/Spinner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SCHEDULER_SPINNER';
  package TAP::Parser::Scheduler::Spinner;
  
  use strict;
  use warnings;
  use Carp;
  
  =head1 NAME
  
  TAP::Parser::Scheduler::Spinner - A no-op job.
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 SYNOPSIS
  
      use TAP::Parser::Scheduler::Spinner;
  
  =head1 DESCRIPTION
  
  A no-op job. Returned by C<TAP::Parser::Scheduler> as an instruction to
  the harness to spin (keep executing tests) while the scheduler can't
  return a real job.
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
      my $job = TAP::Parser::Scheduler::Spinner->new;
  
  Ignores any arguments and returns a new C<TAP::Parser::Scheduler::Spinner> object.
  
  =cut
  
  sub new { bless {}, shift }
  
  =head2 Instance Methods
  
  =head3 C<is_spinner>
  
  Returns true indicating that is a 'spinner' job. Spinners are returned
  when the scheduler still has pending jobs but can't (because of locking)
  return one right now.
  
  =cut
  
  sub is_spinner {1}
  
  =head1 SEE ALSO
  
  L<TAP::Parser::Scheduler>, L<TAP::Parser::Scheduler::Job>
  
  =cut
  
  1;
TAP_PARSER_SCHEDULER_SPINNER

$fatpacked{"TAP/Parser/Source.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCE';
  package TAP::Parser::Source;
  
  use strict;
  use warnings;
  
  use File::Basename qw( fileparse );
  use base 'TAP::Object';
  
  use constant BLK_SIZE => 512;
  
  =head1 NAME
  
  TAP::Parser::Source - a TAP source & meta data about it
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 SYNOPSIS
  
    use TAP::Parser::Source;
    my $source = TAP::Parser::Source->new;
    $source->raw( \'reference to raw TAP source' )
           ->config( \%config )
           ->merge( $boolean )
           ->switches( \@switches )
           ->test_args( \@args )
           ->assemble_meta;
  
    do { ... } if $source->meta->{is_file};
    # see assemble_meta for a full list of data available
  
  =head1 DESCRIPTION
  
  A TAP I<source> is something that produces a stream of TAP for the parser to
  consume, such as an executable file, a text file, an archive, an IO handle, a
  database, etc.  C<TAP::Parser::Source>s encapsulate these I<raw> sources, and
  provide some useful meta data about them.  They are used by
  L<TAP::Parser::SourceHandler>s, which do whatever is required to produce &
  capture a stream of TAP from the I<raw> source, and package it up in a
  L<TAP::Parser::Iterator> for the parser to consume.
  
  Unless you're writing a new L<TAP::Parser::SourceHandler>, a plugin or
  subclassing L<TAP::Parser>, you probably won't need to use this module directly.
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
   my $source = TAP::Parser::Source->new;
  
  Returns a new C<TAP::Parser::Source> object.
  
  =cut
  
  # new() implementation supplied by TAP::Object
  
  sub _initialize {
      my ($self) = @_;
      $self->meta(   {} );
      $self->config( {} );
      return $self;
  }
  
  ##############################################################################
  
  =head2 Instance Methods
  
  =head3 C<raw>
  
    my $raw = $source->raw;
    $source->raw( $some_value );
  
  Chaining getter/setter for the raw TAP source.  This is a reference, as it may
  contain large amounts of data (eg: raw TAP).
  
  =head3 C<meta>
  
    my $meta = $source->meta;
    $source->meta({ %some_value });
  
  Chaining getter/setter for meta data about the source.  This defaults to an
  empty hashref.  See L</assemble_meta> for more info.
  
  =head3 C<has_meta>
  
  True if the source has meta data.
  
  =head3 C<config>
  
    my $config = $source->config;
    $source->config({ %some_value });
  
  Chaining getter/setter for the source's configuration, if any has been provided
  by the user.  How it's used is up to you.  This defaults to an empty hashref.
  See L</config_for> for more info.
  
  =head3 C<merge>
  
    my $merge = $source->merge;
    $source->config( $bool );
  
  Chaining getter/setter for the flag that dictates whether STDOUT and STDERR
  should be merged (where appropriate).  Defaults to undef.
  
  =head3 C<switches>
  
    my $switches = $source->switches;
    $source->config([ @switches ]);
  
  Chaining getter/setter for the list of command-line switches that should be
  passed to the source (where appropriate).  Defaults to undef.
  
  =head3 C<test_args>
  
    my $test_args = $source->test_args;
    $source->config([ @test_args ]);
  
  Chaining getter/setter for the list of command-line arguments that should be
  passed to the source (where appropriate).  Defaults to undef.
  
  =cut
  
  sub raw {
      my $self = shift;
      return $self->{raw} unless @_;
      $self->{raw} = shift;
      return $self;
  }
  
  sub meta {
      my $self = shift;
      return $self->{meta} unless @_;
      $self->{meta} = shift;
      return $self;
  }
  
  sub has_meta {
      return scalar %{ shift->meta } ? 1 : 0;
  }
  
  sub config {
      my $self = shift;
      return $self->{config} unless @_;
      $self->{config} = shift;
      return $self;
  }
  
  sub merge {
      my $self = shift;
      return $self->{merge} unless @_;
      $self->{merge} = shift;
      return $self;
  }
  
  sub switches {
      my $self = shift;
      return $self->{switches} unless @_;
      $self->{switches} = shift;
      return $self;
  }
  
  sub test_args {
      my $self = shift;
      return $self->{test_args} unless @_;
      $self->{test_args} = shift;
      return $self;
  }
  
  =head3 C<assemble_meta>
  
    my $meta = $source->assemble_meta;
  
  Gathers meta data about the L</raw> source, stashes it in L</meta> and returns
  it as a hashref.  This is done so that the L<TAP::Parser::SourceHandler>s don't
  have to repeat common checks.  Currently this includes:
  
      is_scalar => $bool,
      is_hash   => $bool,
      is_array  => $bool,
  
      # for scalars:
      length => $n
      has_newlines => $bool
  
      # only done if the scalar looks like a filename
      is_file => $bool,
      is_dir  => $bool,
      is_symlink => $bool,
      file => {
          # only done if the scalar looks like a filename
          basename => $string, # including ext
          dir      => $string,
          ext      => $string,
          lc_ext   => $string,
          # system checks
          exists  => $bool,
          stat    => [ ... ], # perldoc -f stat
          empty   => $bool,
          size    => $n,
          text    => $bool,
          binary  => $bool,
          read    => $bool,
          write   => $bool,
          execute => $bool,
          setuid  => $bool,
          setgid  => $bool,
          sticky  => $bool,
          is_file => $bool,
          is_dir  => $bool,
          is_symlink => $bool,
          # only done if the file's a symlink
          lstat      => [ ... ], # perldoc -f lstat
          # only done if the file's a readable text file
          shebang => $first_line,
      }
  
    # for arrays:
    size => $n,
  
  =cut
  
  sub assemble_meta {
      my ($self) = @_;
  
      return $self->meta if $self->has_meta;
  
      my $meta = $self->meta;
      my $raw  = $self->raw;
  
      # rudimentary is object test - if it's blessed it'll
      # inherit from UNIVERSAL
      $meta->{is_object} = UNIVERSAL::isa( $raw, 'UNIVERSAL' ) ? 1 : 0;
  
      if ( $meta->{is_object} ) {
          $meta->{class} = ref($raw);
      }
      else {
          my $ref = lc( ref($raw) );
          $meta->{"is_$ref"} = 1;
      }
  
      if ( $meta->{is_scalar} ) {
          my $source = $$raw;
          $meta->{length} = length($$raw);
          $meta->{has_newlines} = $$raw =~ /\n/ ? 1 : 0;
  
          # only do file checks if it looks like a filename
          if ( !$meta->{has_newlines} and $meta->{length} < 1024 ) {
              my $file = {};
              $file->{exists} = -e $source ? 1 : 0;
              if ( $file->{exists} ) {
                  $meta->{file} = $file;
  
                  # avoid extra system calls (see `perldoc -f -X`)
                  $file->{stat}    = [ stat(_) ];
                  $file->{empty}   = -z _ ? 1 : 0;
                  $file->{size}    = -s _;
                  $file->{text}    = -T _ ? 1 : 0;
                  $file->{binary}  = -B _ ? 1 : 0;
                  $file->{read}    = -r _ ? 1 : 0;
                  $file->{write}   = -w _ ? 1 : 0;
                  $file->{execute} = -x _ ? 1 : 0;
                  $file->{setuid}  = -u _ ? 1 : 0;
                  $file->{setgid}  = -g _ ? 1 : 0;
                  $file->{sticky}  = -k _ ? 1 : 0;
  
                  $meta->{is_file} = $file->{is_file} = -f _ ? 1 : 0;
                  $meta->{is_dir}  = $file->{is_dir}  = -d _ ? 1 : 0;
  
                  # symlink check requires another system call
                  $meta->{is_symlink} = $file->{is_symlink}
                    = -l $source ? 1 : 0;
                  if ( $file->{is_symlink} ) {
                      $file->{lstat} = [ lstat(_) ];
                  }
  
                  # put together some common info about the file
                  ( $file->{basename}, $file->{dir}, $file->{ext} )
                    = map { defined $_ ? $_ : '' }
                    fileparse( $source, qr/\.[^.]*/ );
                  $file->{lc_ext} = lc( $file->{ext} );
                  $file->{basename} .= $file->{ext} if $file->{ext};
  
                  if ( !$file->{is_dir} && $file->{read} ) {
                      eval { $file->{shebang} = $self->shebang($$raw); };
                      if ( my $e = $@ ) {
                          warn $e;
                      }
                  }
              }
          }
      }
      elsif ( $meta->{is_array} ) {
          $meta->{size} = $#$raw + 1;
      }
      elsif ( $meta->{is_hash} ) {
          ;    # do nothing
      }
  
      return $meta;
  }
  
  =head3 C<shebang>
  
  Get the shebang line for a script file.
  
    my $shebang = TAP::Parser::Source->shebang( $some_script );
  
  May be called as a class method
  
  =cut
  
  {
  
      # Global shebang cache.
      my %shebang_for;
  
      sub _read_shebang {
          my ( $class, $file ) = @_;
          open my $fh, '<', $file or die "Can't read $file: $!\n";
  
          # Might be a binary file - so read a fixed number of bytes.
          my $got = read $fh, my ($buf), BLK_SIZE;
          defined $got or die "I/O error: $!\n";
          return $1 if $buf =~ /(.*)/;
          return;
      }
  
      sub shebang {
          my ( $class, $file ) = @_;
          $shebang_for{$file} = $class->_read_shebang($file)
            unless exists $shebang_for{$file};
          return $shebang_for{$file};
      }
  }
  
  =head3 C<config_for>
  
    my $config = $source->config_for( $class );
  
  Returns L</config> for the $class given.  Class names may be fully qualified
  or abbreviated, eg:
  
    # these are equivalent
    $source->config_for( 'Perl' );
    $source->config_for( 'TAP::Parser::SourceHandler::Perl' );
  
  If a fully qualified $class is given, its abbreviated version is checked first.
  
  =cut
  
  sub config_for {
      my ( $self, $class ) = @_;
      my ($abbrv_class) = ( $class =~ /(?:\:\:)?(\w+)$/ );
      my $config = $self->config->{$abbrv_class} || $self->config->{$class};
      return $config;
  }
  
  1;
  
  __END__
  
  =head1 AUTHORS
  
  Steve Purkis.
  
  =head1 SEE ALSO
  
  L<TAP::Object>,
  L<TAP::Parser>,
  L<TAP::Parser::IteratorFactory>,
  L<TAP::Parser::SourceHandler>
  
  =cut
TAP_PARSER_SOURCE

$fatpacked{"TAP/Parser/SourceHandler.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER';
  package TAP::Parser::SourceHandler;
  
  use strict;
  use warnings;
  
  use TAP::Parser::Iterator ();
  use base 'TAP::Object';
  
  =head1 NAME
  
  TAP::Parser::SourceHandler - Base class for different TAP source handlers
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 SYNOPSIS
  
    # abstract class - don't use directly!
    # see TAP::Parser::IteratorFactory for general usage
  
    # must be sub-classed for use
    package MySourceHandler;
    use base 'TAP::Parser::SourceHandler';
    sub can_handle    { return $confidence_level }
    sub make_iterator { return $iterator }
  
    # see example below for more details
  
  =head1 DESCRIPTION
  
  This is an abstract base class for L<TAP::Parser::Source> handlers / handlers.
  
  A C<TAP::Parser::SourceHandler> does whatever is necessary to produce & capture
  a stream of TAP from the I<raw> source, and package it up in a
  L<TAP::Parser::Iterator> for the parser to consume.
  
  C<SourceHandlers> must implement the I<source detection & handling> interface
  used by L<TAP::Parser::IteratorFactory>.  At 2 methods, the interface is pretty
  simple: L</can_handle> and L</make_source>.
  
  Unless you're writing a new L<TAP::Parser::SourceHandler>, a plugin, or
  subclassing L<TAP::Parser>, you probably won't need to use this module directly.
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<can_handle>
  
  I<Abstract method>.
  
    my $vote = $class->can_handle( $source );
  
  C<$source> is a L<TAP::Parser::Source>.
  
  Returns a number between C<0> & C<1> reflecting how confidently the raw source
  can be handled.  For example, C<0> means the source cannot handle it, C<0.5>
  means it may be able to, and C<1> means it definitely can.  See
  L<TAP::Parser::IteratorFactory/detect_source> for details on how this is used.
  
  =cut
  
  sub can_handle {
      my ( $class, $args ) = @_;
      $class->_croak(
          "Abstract method 'can_handle' not implemented for $class!");
      return;
  }
  
  =head3 C<make_iterator>
  
  I<Abstract method>.
  
    my $iterator = $class->make_iterator( $source );
  
  C<$source> is a L<TAP::Parser::Source>.
  
  Returns a new L<TAP::Parser::Iterator> object for use by the L<TAP::Parser>.
  C<croak>s on error.
  
  =cut
  
  sub make_iterator {
      my ( $class, $args ) = @_;
      $class->_croak(
          "Abstract method 'make_iterator' not implemented for $class!");
      return;
  }
  1;
  
  __END__
  
  =head1 SUBCLASSING
  
  Please see L<TAP::Parser/SUBCLASSING> for a subclassing overview, and any
  of the subclasses that ship with this module as an example.  What follows is
  a quick overview.
  
  Start by familiarizing yourself with L<TAP::Parser::Source> and
  L<TAP::Parser::IteratorFactory>.  L<TAP::Parser::SourceHandler::RawTAP> is
  the easiest sub-class to use as an example.
  
  It's important to point out that if you want your subclass to be automatically
  used by L<TAP::Parser> you'll have to and make sure it gets loaded somehow.
  If you're using L<prove> you can write an L<App::Prove> plugin.  If you're
  using L<TAP::Parser> or L<TAP::Harness> directly (e.g. through a custom script,
  L<ExtUtils::MakeMaker>, or L<Module::Build>) you can use the C<config> option
  which will cause L<TAP::Parser::IteratorFactory/load_sources> to load your
  subclass).
  
  Don't forget to register your class with
  L<TAP::Parser::IteratorFactory/register_handler>.
  
  =head2 Example
  
    package MySourceHandler;
  
    use strict;
  
    use MySourceHandler; # see TAP::Parser::SourceHandler
    use TAP::Parser::IteratorFactory;
  
    use base 'TAP::Parser::SourceHandler';
  
    TAP::Parser::IteratorFactory->register_handler( __PACKAGE__ );
  
    sub can_handle {
        my ( $class, $src ) = @_;
        my $meta   = $src->meta;
        my $config = $src->config_for( $class );
  
        if ($config->{accept_all}) {
            return 1.0;
        } elsif (my $file = $meta->{file}) {
            return 0.0 unless $file->{exists};
            return 1.0 if $file->{lc_ext} eq '.tap';
            return 0.9 if $file->{shebang} && $file->{shebang} =~ /^#!.+tap/;
            return 0.5 if $file->{text};
            return 0.1 if $file->{binary};
        } elsif ($meta->{scalar}) {
            return 0.8 if $$raw_source_ref =~ /\d\.\.\d/;
            return 0.6 if $meta->{has_newlines};
        } elsif ($meta->{array}) {
            return 0.8 if $meta->{size} < 5;
            return 0.6 if $raw_source_ref->[0] =~ /foo/;
            return 0.5;
        } elsif ($meta->{hash}) {
            return 0.6 if $raw_source_ref->{foo};
            return 0.2;
        }
  
        return 0;
    }
  
    sub make_iterator {
        my ($class, $source) = @_;
        # this is where you manipulate the source and
        # capture the stream of TAP in an iterator
        # either pick a TAP::Parser::Iterator::* or write your own...
        my $iterator = TAP::Parser::Iterator::Array->new([ 'foo', 'bar' ]);
        return $iterator;
    }
  
    1;
  
  =head1 AUTHORS
  
  TAPx Developers.
  
  Source detection stuff added by Steve Purkis
  
  =head1 SEE ALSO
  
  L<TAP::Object>,
  L<TAP::Parser>,
  L<TAP::Parser::Source>,
  L<TAP::Parser::Iterator>,
  L<TAP::Parser::IteratorFactory>,
  L<TAP::Parser::SourceHandler::Executable>,
  L<TAP::Parser::SourceHandler::Perl>,
  L<TAP::Parser::SourceHandler::File>,
  L<TAP::Parser::SourceHandler::Handle>,
  L<TAP::Parser::SourceHandler::RawTAP>
  
  =cut
  
TAP_PARSER_SOURCEHANDLER

$fatpacked{"TAP/Parser/SourceHandler/Executable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_EXECUTABLE';
  package TAP::Parser::SourceHandler::Executable;
  
  use strict;
  use warnings;
  
  use TAP::Parser::IteratorFactory   ();
  use TAP::Parser::Iterator::Process ();
  
  use base 'TAP::Parser::SourceHandler';
  
  TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);
  
  =head1 NAME
  
  TAP::Parser::SourceHandler::Executable - Stream output from an executable TAP source
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 SYNOPSIS
  
    use TAP::Parser::Source;
    use TAP::Parser::SourceHandler::Executable;
  
    my $source = TAP::Parser::Source->new->raw(['/usr/bin/ruby', 'mytest.rb']);
    $source->assemble_meta;
  
    my $class = 'TAP::Parser::SourceHandler::Executable';
    my $vote  = $class->can_handle( $source );
    my $iter  = $class->make_iterator( $source );
  
  =head1 DESCRIPTION
  
  This is an I<executable> L<TAP::Parser::SourceHandler> - it has 2 jobs:
  
  1. Figure out if the L<TAP::Parser::Source> it's given is an executable
     command (L</can_handle>).
  
  2. Creates an iterator for executable commands (L</make_iterator>).
  
  Unless you're writing a plugin or subclassing L<TAP::Parser>, you
  probably won't need to use this module directly.
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<can_handle>
  
    my $vote = $class->can_handle( $source );
  
  Only votes if $source looks like an executable file. Casts the
  following votes:
  
    0.9  if it's a hash with an 'exec' key
    0.8  if it's a .bat file
    0.75 if it's got an execute bit set
  
  =cut
  
  sub can_handle {
      my ( $class, $src ) = @_;
      my $meta = $src->meta;
  
      if ( $meta->{is_file} ) {
          my $file = $meta->{file};
  
          return 0.85 if $file->{execute} && $file->{binary};
          return 0.8 if $file->{lc_ext} eq '.bat';
          return 0.25 if $file->{execute};
      }
      elsif ( $meta->{is_hash} ) {
          return 0.9 if $src->raw->{exec};
      }
  
      return 0;
  }
  
  =head3 C<make_iterator>
  
    my $iterator = $class->make_iterator( $source );
  
  Returns a new L<TAP::Parser::Iterator::Process> for the source.
  C<$source-E<gt>raw> must be in one of the following forms:
  
    { exec => [ @exec ] }
  
    [ @exec ]
  
    $file
  
  C<croak>s on error.
  
  =cut
  
  sub make_iterator {
      my ( $class, $source ) = @_;
      my $meta = $source->meta;
  
      my @command;
      if ( $meta->{is_hash} ) {
          @command = @{ $source->raw->{exec} || [] };
      }
      elsif ( $meta->{is_scalar} ) {
          @command = ${ $source->raw };
      }
      elsif ( $meta->{is_array} ) {
          @command = @{ $source->raw };
      }
  
      $class->_croak('No command found in $source->raw!') unless @command;
  
      $class->_autoflush( \*STDOUT );
      $class->_autoflush( \*STDERR );
  
      push @command, @{ $source->test_args || [] };
  
      return $class->iterator_class->new(
          {   command => \@command,
              merge   => $source->merge
          }
      );
  }
  
  =head3 C<iterator_class>
  
  The class of iterator to use, override if you're sub-classing.  Defaults
  to L<TAP::Parser::Iterator::Process>.
  
  =cut
  
  use constant iterator_class => 'TAP::Parser::Iterator::Process';
  
  # Turns on autoflush for the handle passed
  sub _autoflush {
      my ( $class, $flushed ) = @_;
      my $old_fh = select $flushed;
      $| = 1;
      select $old_fh;
  }
  
  1;
  
  =head1 SUBCLASSING
  
  Please see L<TAP::Parser/SUBCLASSING> for a subclassing overview.
  
  =head2 Example
  
    package MyRubySourceHandler;
  
    use strict;
  
    use Carp qw( croak );
    use TAP::Parser::SourceHandler::Executable;
  
    use base 'TAP::Parser::SourceHandler::Executable';
  
    # expect $handler->(['mytest.rb', 'cmdline', 'args']);
    sub make_iterator {
      my ($self, $source) = @_;
      my @test_args = @{ $source->test_args };
      my $rb_file   = $test_args[0];
      croak("error: Ruby file '$rb_file' not found!") unless (-f $rb_file);
      return $self->SUPER::raw_source(['/usr/bin/ruby', @test_args]);
    }
  
  =head1 SEE ALSO
  
  L<TAP::Object>,
  L<TAP::Parser>,
  L<TAP::Parser::IteratorFactory>,
  L<TAP::Parser::SourceHandler>,
  L<TAP::Parser::SourceHandler::Perl>,
  L<TAP::Parser::SourceHandler::File>,
  L<TAP::Parser::SourceHandler::Handle>,
  L<TAP::Parser::SourceHandler::RawTAP>
  
  =cut
TAP_PARSER_SOURCEHANDLER_EXECUTABLE

$fatpacked{"TAP/Parser/SourceHandler/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_FILE';
  package TAP::Parser::SourceHandler::File;
  
  use strict;
  use warnings;
  
  use TAP::Parser::IteratorFactory  ();
  use TAP::Parser::Iterator::Stream ();
  
  use base 'TAP::Parser::SourceHandler';
  
  TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);
  
  =head1 NAME
  
  TAP::Parser::SourceHandler::File - Stream TAP from a text file.
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 SYNOPSIS
  
    use TAP::Parser::Source;
    use TAP::Parser::SourceHandler::File;
  
    my $source = TAP::Parser::Source->new->raw( \'file.tap' );
    $source->assemble_meta;
  
    my $class = 'TAP::Parser::SourceHandler::File';
    my $vote  = $class->can_handle( $source );
    my $iter  = $class->make_iterator( $source );
  
  =head1 DESCRIPTION
  
  This is a I<raw TAP stored in a file> L<TAP::Parser::SourceHandler> - it has 2 jobs:
  
  1. Figure out if the I<raw> source it's given is a file containing raw TAP
  output.  See L<TAP::Parser::IteratorFactory> for more details.
  
  2. Takes raw TAP from the text file given, and converts into an iterator.
  
  Unless you're writing a plugin or subclassing L<TAP::Parser>, you probably
  won't need to use this module directly.
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<can_handle>
  
    my $vote = $class->can_handle( $source );
  
  Only votes if $source looks like a regular file.  Casts the following votes:
  
    0.9 if it's a .tap file
    0.9 if it has an extension matching any given in user config.
  
  =cut
  
  sub can_handle {
      my ( $class, $src ) = @_;
      my $meta   = $src->meta;
      my $config = $src->config_for($class);
  
      return 0 unless $meta->{is_file};
      my $file = $meta->{file};
      return 0.9 if $file->{lc_ext} eq '.tap';
  
      if ( my $exts = $config->{extensions} ) {
          my @exts = ref $exts eq 'ARRAY' ? @$exts : $exts;
          return 0.9 if grep { lc($_) eq $file->{lc_ext} } @exts;
      }
  
      return 0;
  }
  
  =head3 C<make_iterator>
  
    my $iterator = $class->make_iterator( $source );
  
  Returns a new L<TAP::Parser::Iterator::Stream> for the source.  C<croak>s
  on error.
  
  =cut
  
  sub make_iterator {
      my ( $class, $source ) = @_;
  
      $class->_croak('$source->raw must be a scalar ref')
        unless $source->meta->{is_scalar};
  
      my $file = ${ $source->raw };
      my $fh;
      open( $fh, '<', $file )
        or $class->_croak("error opening TAP source file '$file': $!");
      return $class->iterator_class->new($fh);
  }
  
  =head3 C<iterator_class>
  
  The class of iterator to use, override if you're sub-classing.  Defaults
  to L<TAP::Parser::Iterator::Stream>.
  
  =cut
  
  use constant iterator_class => 'TAP::Parser::Iterator::Stream';
  
  1;
  
  __END__
  
  =head1 CONFIGURATION
  
    {
     extensions => [ @case_insensitive_exts_to_match ]
    }
  
  =head1 SUBCLASSING
  
  Please see L<TAP::Parser/SUBCLASSING> for a subclassing overview.
  
  =head1 SEE ALSO
  
  L<TAP::Object>,
  L<TAP::Parser>,
  L<TAP::Parser::SourceHandler>,
  L<TAP::Parser::SourceHandler::Executable>,
  L<TAP::Parser::SourceHandler::Perl>,
  L<TAP::Parser::SourceHandler::Handle>,
  L<TAP::Parser::SourceHandler::RawTAP>
  
  =cut
TAP_PARSER_SOURCEHANDLER_FILE

$fatpacked{"TAP/Parser/SourceHandler/Handle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_HANDLE';
  package TAP::Parser::SourceHandler::Handle;
  
  use strict;
  use warnings;
  
  use TAP::Parser::IteratorFactory  ();
  use TAP::Parser::Iterator::Stream ();
  
  use base 'TAP::Parser::SourceHandler';
  
  TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);
  
  =head1 NAME
  
  TAP::Parser::SourceHandler::Handle - Stream TAP from an IO::Handle or a GLOB.
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 SYNOPSIS
  
    use TAP::Parser::Source;
    use TAP::Parser::SourceHandler::Executable;
  
    my $source = TAP::Parser::Source->new->raw( \*TAP_FILE );
    $source->assemble_meta;
  
    my $class = 'TAP::Parser::SourceHandler::Handle';
    my $vote  = $class->can_handle( $source );
    my $iter  = $class->make_iterator( $source );
  
  =head1 DESCRIPTION
  
  This is a I<raw TAP stored in an IO Handle> L<TAP::Parser::SourceHandler> class.  It
  has 2 jobs:
  
  1. Figure out if the L<TAP::Parser::Source> it's given is an L<IO::Handle> or
  GLOB containing raw TAP output (L</can_handle>).
  
  2. Creates an iterator for IO::Handle's & globs (L</make_iterator>).
  
  Unless you're writing a plugin or subclassing L<TAP::Parser>, you probably
  won't need to use this module directly.
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<can_handle>
  
    my $vote = $class->can_handle( $source );
  
  Casts the following votes:
  
    0.9 if $source is an IO::Handle
    0.8 if $source is a glob
  
  =cut
  
  sub can_handle {
      my ( $class, $src ) = @_;
      my $meta = $src->meta;
  
      return 0.9
        if $meta->{is_object}
            && UNIVERSAL::isa( $src->raw, 'IO::Handle' );
  
      return 0.8 if $meta->{is_glob};
  
      return 0;
  }
  
  =head3 C<make_iterator>
  
    my $iterator = $class->make_iterator( $source );
  
  Returns a new L<TAP::Parser::Iterator::Stream> for the source.
  
  =cut
  
  sub make_iterator {
      my ( $class, $source ) = @_;
  
      $class->_croak('$source->raw must be a glob ref or an IO::Handle')
        unless $source->meta->{is_glob}
            || UNIVERSAL::isa( $source->raw, 'IO::Handle' );
  
      return $class->iterator_class->new( $source->raw );
  }
  
  =head3 C<iterator_class>
  
  The class of iterator to use, override if you're sub-classing.  Defaults
  to L<TAP::Parser::Iterator::Stream>.
  
  =cut
  
  use constant iterator_class => 'TAP::Parser::Iterator::Stream';
  
  1;
  
  =head1 SUBCLASSING
  
  Please see L<TAP::Parser/SUBCLASSING> for a subclassing overview.
  
  =head1 SEE ALSO
  
  L<TAP::Object>,
  L<TAP::Parser>,
  L<TAP::Parser::Iterator>,
  L<TAP::Parser::Iterator::Stream>,
  L<TAP::Parser::IteratorFactory>,
  L<TAP::Parser::SourceHandler>,
  L<TAP::Parser::SourceHandler::Executable>,
  L<TAP::Parser::SourceHandler::Perl>,
  L<TAP::Parser::SourceHandler::File>,
  L<TAP::Parser::SourceHandler::RawTAP>
  
  =cut
TAP_PARSER_SOURCEHANDLER_HANDLE

$fatpacked{"TAP/Parser/SourceHandler/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_PERL';
  package TAP::Parser::SourceHandler::Perl;
  
  use strict;
  use warnings;
  use Config;
  
  use constant IS_WIN32 => ( $^O =~ /^(MS)?Win32$/ );
  use constant IS_VMS => ( $^O eq 'VMS' );
  
  use TAP::Parser::IteratorFactory           ();
  use TAP::Parser::Iterator::Process         ();
  use Text::ParseWords qw(shellwords);
  
  use base 'TAP::Parser::SourceHandler::Executable';
  
  TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);
  
  =head1 NAME
  
  TAP::Parser::SourceHandler::Perl - Stream TAP from a Perl executable
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 SYNOPSIS
  
    use TAP::Parser::Source;
    use TAP::Parser::SourceHandler::Perl;
  
    my $source = TAP::Parser::Source->new->raw( \'script.pl' );
    $source->assemble_meta;
  
    my $class = 'TAP::Parser::SourceHandler::Perl';
    my $vote  = $class->can_handle( $source );
    my $iter  = $class->make_iterator( $source );
  
  =head1 DESCRIPTION
  
  This is a I<Perl> L<TAP::Parser::SourceHandler> - it has 2 jobs:
  
  1. Figure out if the L<TAP::Parser::Source> it's given is actually a Perl
  script (L</can_handle>).
  
  2. Creates an iterator for Perl sources (L</make_iterator>).
  
  Unless you're writing a plugin or subclassing L<TAP::Parser>, you probably
  won't need to use this module directly.
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<can_handle>
  
    my $vote = $class->can_handle( $source );
  
  Only votes if $source looks like a file.  Casts the following votes:
  
    0.9  if it has a shebang ala "#!...perl"
    0.75 if it has any shebang
    0.8  if it's a .t file
    0.9  if it's a .pl file
    0.75 if it's in a 't' directory
    0.25 by default (backwards compat)
  
  =cut
  
  sub can_handle {
      my ( $class, $source ) = @_;
      my $meta = $source->meta;
  
      return 0 unless $meta->{is_file};
      my $file = $meta->{file};
  
      if ( my $shebang = $file->{shebang} ) {
          return 0.9 if $shebang =~ /^#!.*\bperl/;
  
          # We favour Perl as the interpreter for any shebang to preserve
          # previous semantics: we used to execute everything via Perl and
          # relied on it to pass the shebang off to the appropriate
          # interpreter.
          return 0.3;
      }
  
      return 0.8 if $file->{lc_ext} eq '.t';    # vote higher than Executable
      return 0.9 if $file->{lc_ext} eq '.pl';
  
      return 0.75 if $file->{dir} =~ /^t\b/;    # vote higher than Executable
  
      # backwards compat, always vote:
      return 0.25;
  }
  
  =head3 C<make_iterator>
  
    my $iterator = $class->make_iterator( $source );
  
  Constructs & returns a new L<TAP::Parser::Iterator::Process> for the source.
  Assumes C<$source-E<gt>raw> contains a reference to the perl script.  C<croak>s
  if the file could not be found.
  
  The command to run is built as follows:
  
    $perl @switches $perl_script @test_args
  
  The perl command to use is determined by L</get_perl>.  The command generated
  is guaranteed to preserve:
  
    PERL5LIB
    PERL5OPT
    Taint Mode, if set in the script's shebang
  
  I<Note:> the command generated will I<not> respect any shebang line defined in
  your Perl script.  This is only a problem if you have compiled a custom version
  of Perl or if you want to use a specific version of Perl for one test and a
  different version for another, for example:
  
    #!/path/to/a/custom_perl --some --args
    #!/usr/local/perl-5.6/bin/perl -w
  
  Currently you need to write a plugin to get around this.
  
  =cut
  
  sub _autoflush_stdhandles {
      my ($class) = @_;
  
      $class->_autoflush( \*STDOUT );
      $class->_autoflush( \*STDERR );
  }
  
  sub make_iterator {
      my ( $class, $source ) = @_;
      my $meta        = $source->meta;
      my $perl_script = ${ $source->raw };
  
      $class->_croak("Cannot find ($perl_script)") unless $meta->{is_file};
  
      # TODO: does this really need to be done here?
      $class->_autoflush_stdhandles;
  
      my ( $libs, $switches )
        = $class->_mangle_switches(
          $class->_filter_libs( $class->_switches($source) ) );
  
      $class->_run( $source, $libs, $switches );
  }
  
  
  sub _has_taint_switch {
      my( $class, $switches ) = @_;
  
      my $has_taint = grep { $_ eq "-T" || $_ eq "-t" } @{$switches};
      return $has_taint ? 1 : 0;
  }
  
  sub _mangle_switches {
      my ( $class, $libs, $switches ) = @_;
  
      # Taint mode ignores environment variables so we must retranslate
      # PERL5LIB as -I switches and place PERL5OPT on the command line
      # in order that it be seen.
      if ( $class->_has_taint_switch($switches) ) {
          my @perl5lib = defined $ENV{PERL5LIB} ? split /$Config{path_sep}/, $ENV{PERL5LIB} : ();
          return (
              $libs,
              [   @{$switches},
                  $class->_libs2switches([@$libs, @perl5lib]),
                  defined $ENV{PERL5OPT} ? shellwords( $ENV{PERL5OPT} ) : ()
              ],
          );
      }
  
      return ( $libs, $switches );
  }
  
  sub _filter_libs {
      my ( $class, @switches ) = @_;
  
      my $path_sep = $Config{path_sep};
      my $path_re  = qr{$path_sep};
  
      # Filter out any -I switches to be handled as libs later.
      #
      # Nasty kludge. It might be nicer if we got the libs separately
      # although at least this way we find any -I switches that were
      # supplied other then as explicit libs.
      #
      # We filter out any names containing colons because they will break
      # PERL5LIB
      my @libs;
      my @filtered_switches;
      for (@switches) {
          if ( !/$path_re/ && m/ ^ ['"]? -I ['"]? (.*?) ['"]? $ /x ) {
              push @libs, $1;
          }
          else {
              push @filtered_switches, $_;
          }
      }
  
      return \@libs, \@filtered_switches;
  }
  
  sub _iterator_hooks {
      my ( $class, $source, $libs, $switches ) = @_;
  
      my $setup = sub {
          if ( @{$libs} and !$class->_has_taint_switch($switches) ) {
              $ENV{PERL5LIB} = join(
                  $Config{path_sep}, grep {defined} @{$libs},
                  $ENV{PERL5LIB}
              );
          }
      };
  
      # VMS environment variables aren't guaranteed to reset at the end of
      # the process, so we need to put PERL5LIB back.
      my $previous = $ENV{PERL5LIB};
      my $teardown = sub {
          if ( defined $previous ) {
              $ENV{PERL5LIB} = $previous;
          }
          else {
              delete $ENV{PERL5LIB};
          }
      };
  
      return ( $setup, $teardown );
  }
  
  sub _run {
      my ( $class, $source, $libs, $switches ) = @_;
  
      my @command = $class->_get_command_for_switches( $source, $switches )
        or $class->_croak("No command found!");
  
      my ( $setup, $teardown ) = $class->_iterator_hooks( $source, $libs, $switches );
  
      return $class->_create_iterator( $source, \@command, $setup, $teardown );
  }
  
  sub _create_iterator {
      my ( $class, $source, $command, $setup, $teardown ) = @_;
  
      return TAP::Parser::Iterator::Process->new(
          {   command  => $command,
              merge    => $source->merge,
              setup    => $setup,
              teardown => $teardown,
          }
      );
  }
  
  sub _get_command_for_switches {
      my ( $class, $source, $switches ) = @_;
      my $file    = ${ $source->raw };
      my @args    = @{ $source->test_args || [] };
      my $command = $class->get_perl;
  
     # XXX don't need to quote if we treat the parts as atoms (except maybe vms)
     #$file = qq["$file"] if ( $file =~ /\s/ ) && ( $file !~ /^".*"$/ );
      my @command = ( $command, @{$switches}, $file, @args );
      return @command;
  }
  
  sub _libs2switches {
      my $class = shift;
      return map {"-I$_"} grep {$_} @{ $_[0] };
  }
  
  =head3 C<get_taint>
  
  Decode any taint switches from a Perl shebang line.
  
    # $taint will be 't'
    my $taint = TAP::Parser::SourceHandler::Perl->get_taint( '#!/usr/bin/perl -t' );
  
    # $untaint will be undefined
    my $untaint = TAP::Parser::SourceHandler::Perl->get_taint( '#!/usr/bin/perl' );
  
  =cut
  
  sub get_taint {
      my ( $class, $shebang ) = @_;
      return
        unless defined $shebang
            && $shebang =~ /^#!.*\bperl.*\s-\w*([Tt]+)/;
      return $1;
  }
  
  sub _switches {
      my ( $class, $source ) = @_;
      my $file     = ${ $source->raw };
      my @switches = @{ $source->switches || [] };
      my $shebang  = $source->meta->{file}->{shebang};
      return unless defined $shebang;
  
      my $taint = $class->get_taint($shebang);
      push @switches, "-$taint" if defined $taint;
  
      # Quote the argument if we're VMS, since VMS will downcase anything
      # not quoted.
      if (IS_VMS) {
          for (@switches) {
              $_ = qq["$_"];
          }
      }
  
      return @switches;
  }
  
  =head3 C<get_perl>
  
  Gets the version of Perl currently running the test suite.
  
  =cut
  
  sub get_perl {
      my $class = shift;
      return $ENV{HARNESS_PERL} if defined $ENV{HARNESS_PERL};
      return qq["$^X"] if IS_WIN32 && ( $^X =~ /[^\w\.\/\\]/ );
      return $^X;
  }
  
  1;
  
  __END__
  
  =head1 SUBCLASSING
  
  Please see L<TAP::Parser/SUBCLASSING> for a subclassing overview.
  
  =head2 Example
  
    package MyPerlSourceHandler;
  
    use strict;
  
    use TAP::Parser::SourceHandler::Perl;
  
    use base 'TAP::Parser::SourceHandler::Perl';
  
    # use the version of perl from the shebang line in the test file
    sub get_perl {
        my $self = shift;
        if (my $shebang = $self->shebang( $self->{file} )) {
            $shebang =~ /^#!(.*\bperl.*?)(?:(?:\s)|(?:$))/;
  	  return $1 if $1;
        }
        return $self->SUPER::get_perl(@_);
    }
  
  =head1 SEE ALSO
  
  L<TAP::Object>,
  L<TAP::Parser>,
  L<TAP::Parser::IteratorFactory>,
  L<TAP::Parser::SourceHandler>,
  L<TAP::Parser::SourceHandler::Executable>,
  L<TAP::Parser::SourceHandler::File>,
  L<TAP::Parser::SourceHandler::Handle>,
  L<TAP::Parser::SourceHandler::RawTAP>
  
  =cut
TAP_PARSER_SOURCEHANDLER_PERL

$fatpacked{"TAP/Parser/SourceHandler/RawTAP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_RAWTAP';
  package TAP::Parser::SourceHandler::RawTAP;
  
  use strict;
  use warnings;
  
  use TAP::Parser::IteratorFactory ();
  use TAP::Parser::Iterator::Array ();
  
  use base 'TAP::Parser::SourceHandler';
  
  TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);
  
  =head1 NAME
  
  TAP::Parser::SourceHandler::RawTAP - Stream output from raw TAP in a scalar/array ref.
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  =head1 SYNOPSIS
  
    use TAP::Parser::Source;
    use TAP::Parser::SourceHandler::RawTAP;
  
    my $source = TAP::Parser::Source->new->raw( \"1..1\nok 1\n" );
    $source->assemble_meta;
  
    my $class = 'TAP::Parser::SourceHandler::RawTAP';
    my $vote  = $class->can_handle( $source );
    my $iter  = $class->make_iterator( $source );
  
  =head1 DESCRIPTION
  
  This is a I<raw TAP output> L<TAP::Parser::SourceHandler> - it has 2 jobs:
  
  1. Figure out if the L<TAP::Parser::Source> it's given is raw TAP output
  (L</can_handle>).
  
  2. Creates an iterator for raw TAP output (L</make_iterator>).
  
  Unless you're writing a plugin or subclassing L<TAP::Parser>, you probably
  won't need to use this module directly.
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<can_handle>
  
    my $vote = $class->can_handle( $source );
  
  Only votes if $source is an array, or a scalar with newlines.  Casts the
  following votes:
  
    0.9  if it's a scalar with '..' in it
    0.7  if it's a scalar with 'ok' in it
    0.3  if it's just a scalar with newlines
    0.5  if it's an array
  
  =cut
  
  sub can_handle {
      my ( $class, $src ) = @_;
      my $meta = $src->meta;
  
      return 0 if $meta->{file};
      if ( $meta->{is_scalar} ) {
          return 0 unless $meta->{has_newlines};
          return 0.9 if ${ $src->raw } =~ /\d\.\.\d/;
          return 0.7 if ${ $src->raw } =~ /ok/;
          return 0.3;
      }
      elsif ( $meta->{is_array} ) {
          return 0.5;
      }
      return 0;
  }
  
  =head3 C<make_iterator>
  
    my $iterator = $class->make_iterator( $source );
  
  Returns a new L<TAP::Parser::Iterator::Array> for the source.
  C<$source-E<gt>raw> must be an array ref, or a scalar ref.
  
  C<croak>s on error.
  
  =cut
  
  sub make_iterator {
      my ( $class, $src ) = @_;
      my $meta = $src->meta;
  
      my $tap_array;
      if ( $meta->{is_scalar} ) {
          $tap_array = [ split "\n" => ${ $src->raw } ];
      }
      elsif ( $meta->{is_array} ) {
          $tap_array = $src->raw;
      }
  
      $class->_croak('No raw TAP found in $source->raw')
        unless scalar $tap_array;
  
      return TAP::Parser::Iterator::Array->new($tap_array);
  }
  
  1;
  
  =head1 SUBCLASSING
  
  Please see L<TAP::Parser/SUBCLASSING> for a subclassing overview.
  
  =head1 SEE ALSO
  
  L<TAP::Object>,
  L<TAP::Parser>,
  L<TAP::Parser::IteratorFactory>,
  L<TAP::Parser::SourceHandler>,
  L<TAP::Parser::SourceHandler::Executable>,
  L<TAP::Parser::SourceHandler::Perl>,
  L<TAP::Parser::SourceHandler::File>,
  L<TAP::Parser::SourceHandler::Handle>
  
  =cut
TAP_PARSER_SOURCEHANDLER_RAWTAP

$fatpacked{"TAP/Parser/YAMLish/Reader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_YAMLISH_READER';
  package TAP::Parser::YAMLish::Reader;
  
  use strict;
  use warnings;
  
  use base 'TAP::Object';
  
  our $VERSION = '3.42';
  
  # TODO:
  #   Handle blessed object syntax
  
  # Printable characters for escapes
  my %UNESCAPES = (
      z => "\x00", a => "\x07", t    => "\x09",
      n => "\x0a", v => "\x0b", f    => "\x0c",
      r => "\x0d", e => "\x1b", '\\' => '\\',
  );
  
  my $QQ_STRING    = qr{ " (?:\\. | [^"])* " }x;
  my $HASH_LINE    = qr{ ^ ($QQ_STRING|\S+) \s* : \s* (?: (.+?) \s* )? $ }x;
  my $IS_HASH_KEY  = qr{ ^ [\w\'\"] }x;
  my $IS_END_YAML  = qr{ ^ \.\.\. \s* $ }x;
  my $IS_QQ_STRING = qr{ ^ $QQ_STRING $ }x;
  
  # new() implementation supplied by TAP::Object
  
  sub read {
      my $self = shift;
      my $obj  = shift;
  
      die "Must have a code reference to read input from"
        unless ref $obj eq 'CODE';
  
      $self->{reader}  = $obj;
      $self->{capture} = [];
  
      #Prime the reader
      $self->_next;
      return unless $self->{next};
  
      my $doc = $self->_read;
  
      # The terminator is mandatory otherwise we'd consume a line from the
      # iterator that doesn't belong to us. If we want to remove this
      # restriction we'll have to implement look-ahead in the iterators.
      # Which might not be a bad idea.
      my $dots = $self->_peek;
      die "Missing '...' at end of YAMLish"
        unless defined $dots
            and $dots =~ $IS_END_YAML;
  
      delete $self->{reader};
      delete $self->{next};
  
      return $doc;
  }
  
  sub get_raw { join( "\n", grep defined, @{ shift->{capture} || [] } ) . "\n" }
  
  sub _peek {
      my $self = shift;
      return $self->{next} unless wantarray;
      my $line = $self->{next};
      $line =~ /^ (\s*) (.*) $ /x;
      return ( $2, length $1 );
  }
  
  sub _next {
      my $self = shift;
      die "_next called with no reader"
        unless $self->{reader};
      my $line = $self->{reader}->();
      $self->{next} = $line;
      push @{ $self->{capture} }, $line;
  }
  
  sub _read {
      my $self = shift;
  
      my $line = $self->_peek;
  
      # Do we have a document header?
      if ( $line =~ /^ --- (?: \s* (.+?)? \s* )? $/x ) {
          $self->_next;
  
          return $self->_read_scalar($1) if defined $1;    # Inline?
  
          my ( $next, $indent ) = $self->_peek;
  
          if ( $next =~ /^ - /x ) {
              return $self->_read_array($indent);
          }
          elsif ( $next =~ $IS_HASH_KEY ) {
              return $self->_read_hash( $next, $indent );
          }
          elsif ( $next =~ $IS_END_YAML ) {
              die "Premature end of YAMLish";
          }
          else {
              die "Unsupported YAMLish syntax: '$next'";
          }
      }
      else {
          die "YAMLish document header not found";
      }
  }
  
  # Parse a double quoted string
  sub _read_qq {
      my $self = shift;
      my $str  = shift;
  
      unless ( $str =~ s/^ " (.*?) " $/$1/x ) {
          die "Internal: not a quoted string";
      }
  
      $str =~ s/\\"/"/gx;
      $str =~ s/ \\ ( [tartan\\favez] | x([0-9a-fA-F]{2}) ) 
                   / (length($1) > 1) ? pack("H2", $2) : $UNESCAPES{$1} /gex;
      return $str;
  }
  
  # Parse a scalar string to the actual scalar
  sub _read_scalar {
      my $self   = shift;
      my $string = shift;
  
      return undef if $string eq '~';
      return {} if $string eq '{}';
      return [] if $string eq '[]';
  
      if ( $string eq '>' || $string eq '|' ) {
  
          my ( $line, $indent ) = $self->_peek;
          die "Multi-line scalar content missing" unless defined $line;
  
          my @multiline = ($line);
  
          while (1) {
              $self->_next;
              my ( $next, $ind ) = $self->_peek;
              last if $ind < $indent;
  
              my $pad = $string eq '|' ? ( ' ' x ( $ind - $indent ) ) : '';
              push @multiline, $pad . $next;
          }
  
          return join( ( $string eq '>' ? ' ' : "\n" ), @multiline ) . "\n";
      }
  
      if ( $string =~ /^ ' (.*) ' $/x ) {
          ( my $rv = $1 ) =~ s/''/'/g;
          return $rv;
      }
  
      if ( $string =~ $IS_QQ_STRING ) {
          return $self->_read_qq($string);
      }
  
      if ( $string =~ /^['"]/ ) {
  
          # A quote with folding... we don't support that
          die __PACKAGE__ . " does not support multi-line quoted scalars";
      }
  
      # Regular unquoted string
      return $string;
  }
  
  sub _read_nested {
      my $self = shift;
  
      my ( $line, $indent ) = $self->_peek;
  
      if ( $line =~ /^ -/x ) {
          return $self->_read_array($indent);
      }
      elsif ( $line =~ $IS_HASH_KEY ) {
          return $self->_read_hash( $line, $indent );
      }
      else {
          die "Unsupported YAMLish syntax: '$line'";
      }
  }
  
  # Parse an array
  sub _read_array {
      my ( $self, $limit ) = @_;
  
      my $ar = [];
  
      while (1) {
          my ( $line, $indent ) = $self->_peek;
          last
            if $indent < $limit
                || !defined $line
                || $line =~ $IS_END_YAML;
  
          if ( $indent > $limit ) {
              die "Array line over-indented";
          }
  
          if ( $line =~ /^ (- \s+) \S+ \s* : (?: \s+ | $ ) /x ) {
              $indent += length $1;
              $line =~ s/-\s+//;
              push @$ar, $self->_read_hash( $line, $indent );
          }
          elsif ( $line =~ /^ - \s* (.+?) \s* $/x ) {
              die "Unexpected start of YAMLish" if $line =~ /^---/;
              $self->_next;
              push @$ar, $self->_read_scalar($1);
          }
          elsif ( $line =~ /^ - \s* $/x ) {
              $self->_next;
              push @$ar, $self->_read_nested;
          }
          elsif ( $line =~ $IS_HASH_KEY ) {
              $self->_next;
              push @$ar, $self->_read_hash( $line, $indent, );
          }
          else {
              die "Unsupported YAMLish syntax: '$line'";
          }
      }
  
      return $ar;
  }
  
  sub _read_hash {
      my ( $self, $line, $limit ) = @_;
  
      my $indent;
      my $hash = {};
  
      while (1) {
          die "Badly formed hash line: '$line'"
            unless $line =~ $HASH_LINE;
  
          my ( $key, $value ) = ( $self->_read_scalar($1), $2 );
          $self->_next;
  
          if ( defined $value ) {
              $hash->{$key} = $self->_read_scalar($value);
          }
          else {
              $hash->{$key} = $self->_read_nested;
          }
  
          ( $line, $indent ) = $self->_peek;
          last
            if $indent < $limit
                || !defined $line
                || $line =~ $IS_END_YAML;
      }
  
      return $hash;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  TAP::Parser::YAMLish::Reader - Read YAMLish data from iterator
  
  =head1 VERSION
  
  Version 3.42
  
  =head1 SYNOPSIS
  
  =head1 DESCRIPTION
  
  Note that parts of this code were derived from L<YAML::Tiny> with the
  permission of Adam Kennedy.
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
  The constructor C<new> creates and returns an empty
  C<TAP::Parser::YAMLish::Reader> object.
  
   my $reader = TAP::Parser::YAMLish::Reader->new; 
  
  =head2 Instance Methods
  
  =head3 C<read>
  
   my $got = $reader->read($iterator);
  
  Read YAMLish from a L<TAP::Parser::Iterator> and return the data structure it
  represents.
  
  =head3 C<get_raw>
  
   my $source = $reader->get_source;
  
  Return the raw YAMLish source from the most recent C<read>.
  
  =head1 AUTHOR
  
  Andy Armstrong, <andy@hexten.net>
  
  Adam Kennedy wrote L<YAML::Tiny> which provided the template and many of
  the YAML matching regular expressions for this module.
  
  =head1 SEE ALSO
  
  L<YAML::Tiny>, L<YAML>, L<YAML::Syck>, L<Config::Tiny>, L<CSS::Tiny>,
  L<http://use.perl.org/~Alias/journal/29427>
  
  =head1 COPYRIGHT
  
  Copyright 2007-2011 Andy Armstrong.
  
  Portions copyright 2006-2008 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
  
TAP_PARSER_YAMLISH_READER

$fatpacked{"TAP/Parser/YAMLish/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_YAMLISH_WRITER';
  package TAP::Parser::YAMLish::Writer;
  
  use strict;
  use warnings;
  
  use base 'TAP::Object';
  
  our $VERSION = '3.42';
  
  my $ESCAPE_CHAR = qr{ [ \x00-\x1f \" ] }x;
  my $ESCAPE_KEY  = qr{ (?: ^\W ) | $ESCAPE_CHAR }x;
  
  my @UNPRINTABLE = qw(
    z    x01  x02  x03  x04  x05  x06  a
    x08  t    n    v    f    r    x0e  x0f
    x10  x11  x12  x13  x14  x15  x16  x17
    x18  x19  x1a  e    x1c  x1d  x1e  x1f
  );
  
  # new() implementation supplied by TAP::Object
  
  sub write {
      my $self = shift;
  
      die "Need something to write"
        unless @_;
  
      my $obj = shift;
      my $out = shift || \*STDOUT;
  
      die "Need a reference to something I can write to"
        unless ref $out;
  
      $self->{writer} = $self->_make_writer($out);
  
      $self->_write_obj( '---', $obj );
      $self->_put('...');
  
      delete $self->{writer};
  }
  
  sub _make_writer {
      my $self = shift;
      my $out  = shift;
  
      my $ref = ref $out;
  
      if ( 'CODE' eq $ref ) {
          return $out;
      }
      elsif ( 'ARRAY' eq $ref ) {
          return sub { push @$out, shift };
      }
      elsif ( 'SCALAR' eq $ref ) {
          return sub { $$out .= shift() . "\n" };
      }
      elsif ( 'GLOB' eq $ref || 'IO::Handle' eq $ref ) {
          return sub { print $out shift(), "\n" };
      }
  
      die "Can't write to $out";
  }
  
  sub _put {
      my $self = shift;
      $self->{writer}->( join '', @_ );
  }
  
  sub _enc_scalar {
      my $self = shift;
      my $val  = shift;
      my $rule = shift;
  
      return '~' unless defined $val;
  
      if ( $val =~ /$rule/ ) {
          $val =~ s/\\/\\\\/g;
          $val =~ s/"/\\"/g;
          $val =~ s/ ( [\x00-\x1f] ) / '\\' . $UNPRINTABLE[ ord($1) ] /gex;
          return qq{"$val"};
      }
  
      if ( length($val) == 0 or $val =~ /\s/ ) {
          $val =~ s/'/''/;
          return "'$val'";
      }
  
      return $val;
  }
  
  sub _write_obj {
      my $self   = shift;
      my $prefix = shift;
      my $obj    = shift;
      my $indent = shift || 0;
  
      if ( my $ref = ref $obj ) {
          my $pad = '  ' x $indent;
          if ( 'HASH' eq $ref ) {
              if ( keys %$obj ) {
                  $self->_put($prefix);
                  for my $key ( sort keys %$obj ) {
                      my $value = $obj->{$key};
                      $self->_write_obj(
                          $pad . $self->_enc_scalar( $key, $ESCAPE_KEY ) . ':',
                          $value, $indent + 1
                      );
                  }
              }
              else {
                  $self->_put( $prefix, ' {}' );
              }
          }
          elsif ( 'ARRAY' eq $ref ) {
              if (@$obj) {
                  $self->_put($prefix);
                  for my $value (@$obj) {
                      $self->_write_obj(
                          $pad . '-', $value,
                          $indent + 1
                      );
                  }
              }
              else {
                  $self->_put( $prefix, ' []' );
              }
          }
          else {
              die "Don't know how to encode $ref";
          }
      }
      else {
          $self->_put( $prefix, ' ', $self->_enc_scalar( $obj, $ESCAPE_CHAR ) );
      }
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  TAP::Parser::YAMLish::Writer - Write YAMLish data
  
  =head1 VERSION
  
  Version 3.42
  
  =head1 SYNOPSIS
  
      use TAP::Parser::YAMLish::Writer;
      
      my $data = {
          one => 1,
          two => 2,
          three => [ 1, 2, 3 ],
      };
      
      my $yw = TAP::Parser::YAMLish::Writer->new;
      
      # Write to an array...
      $yw->write( $data, \@some_array );
      
      # ...an open file handle...
      $yw->write( $data, $some_file_handle );
      
      # ...a string ...
      $yw->write( $data, \$some_string );
      
      # ...or a closure
      $yw->write( $data, sub {
          my $line = shift;
          print "$line\n";
      } );
  
  =head1 DESCRIPTION
  
  Encodes a scalar, hash reference or array reference as YAMLish.
  
  =head1 METHODS
  
  =head2 Class Methods
  
  =head3 C<new>
  
   my $writer = TAP::Parser::YAMLish::Writer->new;
  
  The constructor C<new> creates and returns an empty
  C<TAP::Parser::YAMLish::Writer> object.
  
  =head2 Instance Methods
  
  =head3 C<write>
  
   $writer->write($obj, $output );
  
  Encode a scalar, hash reference or array reference as YAML.
  
      my $writer = sub {
          my $line = shift;
          print SOMEFILE "$line\n";
      };
      
      my $data = {
          one => 1,
          two => 2,
          three => [ 1, 2, 3 ],
      };
      
      my $yw = TAP::Parser::YAMLish::Writer->new;
      $yw->write( $data, $writer );
  
  
  The C< $output > argument may be:
  
  =over
  
  =item * a reference to a scalar to append YAML to
  
  =item * the handle of an open file
  
  =item * a reference to an array into which YAML will be pushed
  
  =item * a code reference
  
  =back
  
  If you supply a code reference the subroutine will be called once for
  each line of output with the line as its only argument. Passed lines
  will have no trailing newline.
  
  =head1 AUTHOR
  
  Andy Armstrong, <andy@hexten.net>
  
  =head1 SEE ALSO
  
  L<YAML::Tiny>, L<YAML>, L<YAML::Syck>, L<Config::Tiny>, L<CSS::Tiny>,
  L<http://use.perl.org/~Alias/journal/29427>
  
  =head1 COPYRIGHT
  
  Copyright 2007-2011 Andy Armstrong.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
  
TAP_PARSER_YAMLISH_WRITER

$fatpacked{"Test/Harness.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_HARNESS';
  package Test::Harness;
  
  use 5.006;
  
  use strict;
  use warnings;
  
  use constant IS_WIN32 => ( $^O =~ /^(MS)?Win32$/ );
  use constant IS_VMS => ( $^O eq 'VMS' );
  
  use TAP::Harness                     ();
  use TAP::Parser::Aggregator          ();
  use TAP::Parser::Source              ();
  use TAP::Parser::SourceHandler::Perl ();
  
  use Text::ParseWords qw(shellwords);
  
  use Config;
  use base 'Exporter';
  
  # $ML $Last_ML_Print
  
  BEGIN {
      eval q{use Time::HiRes 'time'};
      our $has_time_hires = !$@;
  }
  
  =head1 NAME
  
  Test::Harness - Run Perl standard test scripts with statistics
  
  =head1 VERSION
  
  Version 3.42
  
  =cut
  
  our $VERSION = '3.42';
  
  # Backwards compatibility for exportable variable names.
  *verbose  = *Verbose;
  *switches = *Switches;
  *debug    = *Debug;
  
  $ENV{HARNESS_ACTIVE}  = 1;
  $ENV{HARNESS_VERSION} = $VERSION;
  
  END {
  
      # For VMS.
      delete $ENV{HARNESS_ACTIVE};
      delete $ENV{HARNESS_VERSION};
  }
  
  our @EXPORT    = qw(&runtests);
  our @EXPORT_OK = qw(&execute_tests $verbose $switches);
  
  our $Verbose = $ENV{HARNESS_VERBOSE} || 0;
  our $Debug   = $ENV{HARNESS_DEBUG}   || 0;
  our $Switches = '-w';
  our $Columns = $ENV{HARNESS_COLUMNS} || $ENV{COLUMNS} || 80;
  $Columns--;    # Some shells have trouble with a full line of text.
  our $Timer      = $ENV{HARNESS_TIMER}       || 0;
  our $Color      = $ENV{HARNESS_COLOR}       || 0;
  our $IgnoreExit = $ENV{HARNESS_IGNORE_EXIT} || 0;
  
  =head1 SYNOPSIS
  
    use Test::Harness;
  
    runtests(@test_files);
  
  =head1 DESCRIPTION
  
  Although, for historical reasons, the L<Test::Harness> distribution
  takes its name from this module it now exists only to provide
  L<TAP::Harness> with an interface that is somewhat backwards compatible
  with L<Test::Harness> 2.xx. If you're writing new code consider using
  L<TAP::Harness> directly instead.
  
  Emulation is provided for C<runtests> and C<execute_tests> but the
  pluggable 'Straps' interface that previous versions of L<Test::Harness>
  supported is not reproduced here. Straps is now available as a stand
  alone module: L<Test::Harness::Straps>.
  
  See L<TAP::Parser>, L<TAP::Harness> for the main documentation for this
  distribution.
  
  =head1 FUNCTIONS
  
  The following functions are available.
  
  =head2 runtests( @test_files )
  
  This runs all the given I<@test_files> and divines whether they passed
  or failed based on their output to STDOUT (details above).  It prints
  out each individual test which failed along with a summary report and
  a how long it all took.
  
  It returns true if everything was ok.  Otherwise it will C<die()> with
  one of the messages in the DIAGNOSTICS section.
  
  =cut
  
  sub _has_taint {
      my $test = shift;
      return TAP::Parser::SourceHandler::Perl->get_taint(
          TAP::Parser::Source->shebang($test) );
  }
  
  sub _aggregate {
      my ( $harness, $aggregate, @tests ) = @_;
  
      # Don't propagate to our children
      local $ENV{HARNESS_OPTIONS};
  
      _apply_extra_INC($harness);
      _aggregate_tests( $harness, $aggregate, @tests );
  }
  
  # Make sure the child sees all the extra junk in @INC
  sub _apply_extra_INC {
      my $harness = shift;
  
      $harness->callback(
          parser_args => sub {
              my ( $args, $test ) = @_;
              push @{ $args->{switches} }, map {"-I$_"} _filtered_inc();
          }
      );
  }
  
  sub _aggregate_tests {
      my ( $harness, $aggregate, @tests ) = @_;
      $aggregate->start();
      $harness->aggregate_tests( $aggregate, @tests );
      $aggregate->stop();
  
  }
  
  sub runtests {
      my @tests = @_;
  
      # shield against -l
      local ( $\, $, );
  
      my $harness   = _new_harness();
      my $aggregate = TAP::Parser::Aggregator->new();
  
      local $ENV{PERL_USE_UNSAFE_INC} = 1 if not exists $ENV{PERL_USE_UNSAFE_INC};
      _aggregate( $harness, $aggregate, @tests );
  
      $harness->formatter->summary($aggregate);
  
      my $total  = $aggregate->total;
      my $passed = $aggregate->passed;
      my $failed = $aggregate->failed;
  
      my @parsers = $aggregate->parsers;
  
      my $num_bad = 0;
      for my $parser (@parsers) {
          $num_bad++ if $parser->has_problems;
      }
  
      die(sprintf(
              "Failed %d/%d test programs. %d/%d subtests failed.\n",
              $num_bad, scalar @parsers, $failed, $total
          )
      ) if $num_bad;
  
      return $total && $total == $passed;
  }
  
  sub _canon {
      my @list   = sort { $a <=> $b } @_;
      my @ranges = ();
      my $count  = scalar @list;
      my $pos    = 0;
  
      while ( $pos < $count ) {
          my $end = $pos + 1;
          $end++ while $end < $count && $list[$end] <= $list[ $end - 1 ] + 1;
          push @ranges, ( $end == $pos + 1 )
            ? $list[$pos]
            : join( '-', $list[$pos], $list[ $end - 1 ] );
          $pos = $end;
      }
  
      return join( ' ', @ranges );
  }
  
  sub _new_harness {
      my $sub_args = shift || {};
  
      my ( @lib, @switches );
      my @opt = map { shellwords($_) } grep { defined } $Switches, $ENV{HARNESS_PERL_SWITCHES};
      while ( my $opt = shift @opt ) {
          if ( $opt =~ /^ -I (.*) $ /x ) {
              push @lib, length($1) ? $1 : shift @opt;
          }
          else {
              push @switches, $opt;
          }
      }
  
      # Do things the old way on VMS...
      push @lib, _filtered_inc() if IS_VMS;
  
      # If $Verbose isn't numeric default to 1. This helps core.
      my $verbosity = ( $Verbose ? ( $Verbose !~ /\d/ ) ? 1 : $Verbose : 0 );
  
      my $args = {
          timer       => $Timer,
          directives  => our $Directives,
          lib         => \@lib,
          switches    => \@switches,
          color       => $Color,
          verbosity   => $verbosity,
          ignore_exit => $IgnoreExit,
      };
  
      $args->{stdout} = $sub_args->{out}
        if exists $sub_args->{out};
  
      my $class = $ENV{HARNESS_SUBCLASS} || 'TAP::Harness';
      if ( defined( my $env_opt = $ENV{HARNESS_OPTIONS} ) ) {
          for my $opt ( split /:/, $env_opt ) {
              if ( $opt =~ /^j(\d*)$/ ) {
                  $args->{jobs} = $1 || 9;
              }
              elsif ( $opt eq 'c' ) {
                  $args->{color} = 1;
              }
              elsif ( $opt =~ m/^f(.*)$/ ) {
                  my $fmt = $1;
                  $fmt =~ s/-/::/g;
                  $args->{formatter_class} = $fmt;
              }
              elsif ( $opt =~ m/^a(.*)$/ ) {
                  my $archive = $1;
                  $class = "TAP::Harness::Archive";
                  $args->{archive} = $archive;
              }
              else {
                  die "Unknown HARNESS_OPTIONS item: $opt\n";
              }
          }
      }
  
      return TAP::Harness->_construct( $class, $args );
  }
  
  # Get the parts of @INC which are changed from the stock list AND
  # preserve reordering of stock directories.
  sub _filtered_inc {
      my @inc = grep { !ref } @INC;    #28567
  
      if (IS_VMS) {
  
          # VMS has a 255-byte limit on the length of %ENV entries, so
          # toss the ones that involve perl_root, the install location
          @inc = grep !/perl_root/i, @inc;
  
      }
      elsif (IS_WIN32) {
  
          # Lose any trailing backslashes in the Win32 paths
          s/[\\\/]+$// for @inc;
      }
  
      my @default_inc = _default_inc();
  
      my @new_inc;
      my %seen;
      for my $dir (@inc) {
          next if $seen{$dir}++;
  
          if ( $dir eq ( $default_inc[0] || '' ) ) {
              shift @default_inc;
          }
          else {
              push @new_inc, $dir;
          }
  
          shift @default_inc while @default_inc and $seen{ $default_inc[0] };
      }
  
      return @new_inc;
  }
  
  {
  
      # Cache this to avoid repeatedly shelling out to Perl.
      my @inc;
  
      sub _default_inc {
          return @inc if @inc;
  
          local $ENV{PERL5LIB};
          local $ENV{PERLLIB};
  
          my $perl = $ENV{HARNESS_PERL} || $^X;
  
          # Avoid using -l for the benefit of Perl 6
          chomp( @inc = `"$perl" -e "print join qq[\\n], \@INC, q[]"` );
          return @inc;
      }
  }
  
  sub _check_sequence {
      my @list = @_;
      my $prev;
      while ( my $next = shift @list ) {
          return if defined $prev && $next <= $prev;
          $prev = $next;
      }
  
      return 1;
  }
  
  sub execute_tests {
      my %args = @_;
  
      my $harness   = _new_harness( \%args );
      my $aggregate = TAP::Parser::Aggregator->new();
  
      my %tot = (
          bonus       => 0,
          max         => 0,
          ok          => 0,
          bad         => 0,
          good        => 0,
          files       => 0,
          tests       => 0,
          sub_skipped => 0,
          todo        => 0,
          skipped     => 0,
          bench       => undef,
      );
  
      # Install a callback so we get to see any plans the
      #harness executes.
      $harness->callback(
          made_parser => sub {
              my $parser = shift;
              $parser->callback(
                  plan => sub {
                      my $plan = shift;
                      if ( $plan->directive eq 'SKIP' ) {
                          $tot{skipped}++;
                      }
                  }
              );
          }
      );
  
      local $ENV{PERL_USE_UNSAFE_INC} = 1 if not exists $ENV{PERL_USE_UNSAFE_INC};
      _aggregate( $harness, $aggregate, @{ $args{tests} } );
  
      $tot{bench} = $aggregate->elapsed;
      my @tests = $aggregate->descriptions;
  
      # TODO: Work out the circumstances under which the files
      # and tests totals can differ.
      $tot{files} = $tot{tests} = scalar @tests;
  
      my %failedtests = ();
      my %todo_passed = ();
  
      for my $test (@tests) {
          my ($parser) = $aggregate->parsers($test);
  
          my @failed = $parser->failed;
  
          my $wstat         = $parser->wait;
          my $estat         = $parser->exit;
          my $planned       = $parser->tests_planned;
          my @errors        = $parser->parse_errors;
          my $passed        = $parser->passed;
          my $actual_passed = $parser->actual_passed;
  
          my $ok_seq = _check_sequence( $parser->actual_passed );
  
          # Duplicate exit, wait status semantics of old version
          $estat ||= '' unless $wstat;
          $wstat ||= '';
  
          $tot{max} += ( $planned || 0 );
          $tot{bonus} += $parser->todo_passed;
          $tot{ok} += $passed > $actual_passed ? $passed : $actual_passed;
          $tot{sub_skipped} += $parser->skipped;
          $tot{todo}        += $parser->todo;
  
          if ( @failed || $estat || @errors ) {
              $tot{bad}++;
  
              my $huh_planned = $planned ? undef : '??';
              my $huh_errors  = $ok_seq  ? undef : '??';
  
              $failedtests{$test} = {
                  'canon' => $huh_planned
                    || $huh_errors
                    || _canon(@failed)
                    || '??',
                  'estat'  => $estat,
                  'failed' => $huh_planned
                    || $huh_errors
                    || scalar @failed,
                  'max' => $huh_planned || $planned,
                  'name'  => $test,
                  'wstat' => $wstat
              };
          }
          else {
              $tot{good}++;
          }
  
          my @todo = $parser->todo_passed;
          if (@todo) {
              $todo_passed{$test} = {
                  'canon'  => _canon(@todo),
                  'estat'  => $estat,
                  'failed' => scalar @todo,
                  'max'    => scalar $parser->todo,
                  'name'   => $test,
                  'wstat'  => $wstat
              };
          }
      }
  
      return ( \%tot, \%failedtests, \%todo_passed );
  }
  
  =head2 execute_tests( tests => \@test_files, out => \*FH )
  
  Runs all the given C<@test_files> (just like C<runtests()>) but
  doesn't generate the final report.  During testing, progress
  information will be written to the currently selected output
  filehandle (usually C<STDOUT>), or to the filehandle given by the
  C<out> parameter.  The I<out> is optional.
  
  Returns a list of two values, C<$total> and C<$failed>, describing the
  results.  C<$total> is a hash ref summary of all the tests run.  Its
  keys and values are this:
  
      bonus           Number of individual todo tests unexpectedly passed
      max             Number of individual tests ran
      ok              Number of individual tests passed
      sub_skipped     Number of individual tests skipped
      todo            Number of individual todo tests
  
      files           Number of test files ran
      good            Number of test files passed
      bad             Number of test files failed
      tests           Number of test files originally given
      skipped         Number of test files skipped
  
  If C<< $total->{bad} == 0 >> and C<< $total->{max} > 0 >>, you've
  got a successful test.
  
  C<$failed> is a hash ref of all the test scripts that failed.  Each key
  is the name of a test script, each value is another hash representing
  how that script failed.  Its keys are these:
  
      name        Name of the test which failed
      estat       Script's exit value
      wstat       Script's wait status
      max         Number of individual tests
      failed      Number which failed
      canon       List of tests which failed (as string).
  
  C<$failed> should be empty if everything passed.
  
  =cut
  
  1;
  __END__
  
  =head1 EXPORT
  
  C<&runtests> is exported by C<Test::Harness> by default.
  
  C<&execute_tests>, C<$verbose>, C<$switches> and C<$debug> are
  exported upon request.
  
  =head1 ENVIRONMENT VARIABLES THAT TAP::HARNESS::COMPATIBLE SETS
  
  C<Test::Harness> sets these before executing the individual tests.
  
  =over 4
  
  =item C<HARNESS_ACTIVE>
  
  This is set to a true value.  It allows the tests to determine if they
  are being executed through the harness or by any other means.
  
  =item C<HARNESS_VERSION>
  
  This is the version of C<Test::Harness>.
  
  =back
  
  =head1 ENVIRONMENT VARIABLES THAT AFFECT TEST::HARNESS
  
  =over 4
  
  =item C<HARNESS_PERL_SWITCHES>
  
  Setting this adds perl command line switches to each test file run.
  
  For example, C<HARNESS_PERL_SWITCHES=-T> will turn on taint mode.
  C<HARNESS_PERL_SWITCHES=-MDevel::Cover> will run C<Devel::Cover> for
  each test.
  
  C<-w> is always set.  You can turn this off in the test with C<BEGIN {
  $^W = 0 }>.
  
  =item C<HARNESS_TIMER>
  
  Setting this to true will make the harness display the number of
  milliseconds each test took.  You can also use F<prove>'s C<--timer>
  switch.
  
  =item C<HARNESS_VERBOSE>
  
  If true, C<Test::Harness> will output the verbose results of running
  its tests.  Setting C<$Test::Harness::verbose> will override this,
  or you can use the C<-v> switch in the F<prove> utility.
  
  =item C<HARNESS_OPTIONS>
  
  Provide additional options to the harness. Currently supported options are:
  
  =over
  
  =item C<< j<n> >>
  
  Run <n> (default 9) parallel jobs.
  
  =item C<< c >>
  
  Try to color output. See L<TAP::Formatter::Base/"new">.
  
  =item C<< a<file.tgz> >>
  
  Will use L<TAP::Harness::Archive> as the harness class, and save the TAP to
  C<file.tgz>
  
  =item C<< fPackage-With-Dashes >>
  
  Set the formatter_class of the harness being run. Since the C<HARNESS_OPTIONS>
  is seperated by C<:>, we use C<-> instead.
  
  =back
  
  Multiple options may be separated by colons:
  
      HARNESS_OPTIONS=j9:c make test
  
  =item C<HARNESS_SUBCLASS>
  
  Specifies a TAP::Harness subclass to be used in place of TAP::Harness.
  
  =item C<HARNESS_SUMMARY_COLOR_SUCCESS>
  
  Determines the L<Term::ANSIColor> for the summary in case it is successful.
  This color defaults to C<'green'>.
  
  =item C<HARNESS_SUMMARY_COLOR_FAIL>
  
  Determines the L<Term::ANSIColor> for the failure in case it is successful.
  This color defaults to C<'red'>.
  
  =back
  
  =head1 Taint Mode
  
  Normally when a Perl program is run in taint mode the contents of the
  C<PERL5LIB> environment variable do not appear in C<@INC>.
  
  Because C<PERL5LIB> is often used during testing to add build
  directories to C<@INC> C<Test::Harness> passes the names of any
  directories found in C<PERL5LIB> as -I switches. The net effect of this
  is that C<PERL5LIB> is honoured even in taint mode.
  
  =head1 SEE ALSO
  
  L<TAP::Harness>
  
  =head1 BUGS
  
  Please report any bugs or feature requests to
  C<bug-test-harness at rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness>.  I will be 
  notified, and then you'll automatically be notified of progress on your bug 
  as I make changes.
  
  =head1 AUTHORS
  
  Andy Armstrong  C<< <andy@hexten.net> >>
  
  L<Test::Harness> 2.64 (maintained by Andy Lester and on which this
  module is based) has this attribution:
  
      Either Tim Bunce or Andreas Koenig, we don't know. What we know for
      sure is, that it was inspired by Larry Wall's F<TEST> script that came
      with perl distributions for ages. Numerous anonymous contributors
      exist.  Andreas Koenig held the torch for many years, and then
      Michael G Schwern.
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2007-2011, Andy Armstrong C<< <andy@hexten.net> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself. See L<perlartistic>.
  
TEST_HARNESS

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/Users/st21277/perl5/perlbrew/perls/perl-5.18.4/bin/perl -w

eval 'exec /Users/st21277/perl5/perlbrew/perls/perl-5.18.4/bin/perl -w -S $0 ${1+"$@"}'
    if 0; # not running under some shell

BEGIN { pop @INC if $INC[-1] eq '.' }
use strict;
use warnings;
use App::Prove;

my $app = App::Prove->new;
$app->process_args(@ARGV);
exit( $app->run ? 0 : 1 );

__END__

=head1 NAME

prove - Run tests through a TAP harness.

=head1 USAGE

 prove [options] [files or directories]

=head1 OPTIONS

Boolean options:

 -v,  --verbose         Print all test lines.
 -l,  --lib             Add 'lib' to the path for your tests (-Ilib).
 -b,  --blib            Add 'blib/lib' and 'blib/arch' to the path for
                        your tests
 -s,  --shuffle         Run the tests in random order.
 -c,  --color           Colored test output (default).
      --nocolor         Do not color test output.
      --count           Show the X/Y test count when not verbose
                        (default)
      --nocount         Disable the X/Y test count.
 -D   --dry             Dry run. Show test that would have run.
 -f,  --failures        Show failed tests.
 -o,  --comments        Show comments.
      --ignore-exit     Ignore exit status from test scripts.
 -m,  --merge           Merge test scripts' STDERR with their STDOUT.
 -r,  --recurse         Recursively descend into directories.
      --reverse         Run the tests in reverse order.
 -q,  --quiet           Suppress some test output while running tests.
 -Q,  --QUIET           Only print summary results.
 -p,  --parse           Show full list of TAP parse errors, if any.
      --directives      Only show results with TODO or SKIP directives.
      --timer           Print elapsed time after each test.
      --trap            Trap Ctrl-C and print summary on interrupt.
      --normalize       Normalize TAP output in verbose output
 -T                     Enable tainting checks.
 -t                     Enable tainting warnings.
 -W                     Enable fatal warnings.
 -w                     Enable warnings.
 -h,  --help            Display this help
 -?,                    Display this help
 -V,  --version         Display the version
 -H,  --man             Longer manpage for prove
      --norc            Don't process default .proverc

Options that take arguments:

 -I                     Library paths to include.
 -P                     Load plugin (searches App::Prove::Plugin::*.)
 -M                     Load a module.
 -e,  --exec            Interpreter to run the tests ('' for compiled
                        tests.)
      --ext             Set the extension for tests (default '.t')
      --harness         Define test harness to use.  See TAP::Harness.
      --formatter       Result formatter to use. See FORMATTERS.
      --source          Load and/or configure a SourceHandler. See
                        SOURCE HANDLERS.
 -a,  --archive out.tgz Store the resulting TAP in an archive file.
 -j,  --jobs N          Run N test jobs in parallel (try 9.)
      --state=opts      Control prove's persistent state.
      --statefile=file  Use `file` instead of `.prove` for state
      --rc=rcfile       Process options from rcfile
      --rules           Rules for parallel vs sequential processing.

=head1 NOTES

=head2 .proverc

If F<~/.proverc> or F<./.proverc> exist they will be read and any
options they contain processed before the command line options. Options
in F<.proverc> are specified in the same way as command line options:

    # .proverc
    --state=hot,fast,save
    -j9

Additional option files may be specified with the C<--rc> option.
Default option file processing is disabled by the C<--norc> option.

Under Windows and VMS the option file is named F<_proverc> rather than
F<.proverc> and is sought only in the current directory.

=head2 Reading from C<STDIN>

If you have a list of tests (or URLs, or anything else you want to test) in a
file, you can add them to your tests by using a '-':

 prove - < my_list_of_things_to_test.txt

See the C<README> in the C<examples> directory of this distribution.

=head2 Default Test Directory

If no files or directories are supplied, C<prove> looks for all files
matching the pattern C<t/*.t>.

=head2 Colored Test Output

Colored test output using L<TAP::Formatter::Color> is the default, but
if output is not to a terminal, color is disabled. You can override this by
adding the C<--color> switch.

Color support requires L<Term::ANSIColor> and, on windows platforms, also
L<Win32::Console::ANSI>. If the necessary module(s) are not installed
colored output will not be available.

=head2 Exit Code

If the tests fail C<prove> will exit with non-zero status.

=head2 Arguments to Tests

It is possible to supply arguments to tests. To do so separate them from
prove's own arguments with the arisdottle, '::'. For example

 prove -v t/mytest.t :: --url http://example.com

would run F<t/mytest.t> with the options '--url http://example.com'.
When running multiple tests they will each receive the same arguments.

=head2 C<--exec>

Normally you can just pass a list of Perl tests and the harness will know how
to execute them.  However, if your tests are not written in Perl or if you
want all tests invoked exactly the same way, use the C<-e>, or C<--exec>
switch:

 prove --exec '/usr/bin/ruby -w' t/
 prove --exec '/usr/bin/perl -Tw -mstrict -Ilib' t/
 prove --exec '/path/to/my/customer/exec'

=head2 C<--merge>

If you need to make sure your diagnostics are displayed in the correct
order relative to test results you can use the C<--merge> option to
merge the test scripts' STDERR into their STDOUT.

This guarantees that STDOUT (where the test results appear) and STDERR
(where the diagnostics appear) will stay in sync. The harness will
display any diagnostics your tests emit on STDERR.

Caveat: this is a bit of a kludge. In particular note that if anything
that appears on STDERR looks like a test result the test harness will
get confused. Use this option only if you understand the consequences
and can live with the risk.

=head2 C<--trap>

The C<--trap> option will attempt to trap SIGINT (Ctrl-C) during a test
run and display the test summary even if the run is interrupted

=head2 C<--state>

You can ask C<prove> to remember the state of previous test runs and
select and/or order the tests to be run based on that saved state.

The C<--state> switch requires an argument which must be a comma
separated list of one or more of the following options.

=over

=item C<last>

Run the same tests as the last time the state was saved. This makes it
possible, for example, to recreate the ordering of a shuffled test.

    # Run all tests in random order
    $ prove -b --state=save --shuffle

    # Run them again in the same order
    $ prove -b --state=last

=item C<failed>

Run only the tests that failed on the last run.

    # Run all tests
    $ prove -b --state=save

    # Run failures
    $ prove -b --state=failed

If you also specify the C<save> option newly passing tests will be
excluded from subsequent runs.

    # Repeat until no more failures
    $ prove -b --state=failed,save

=item C<passed>

Run only the passed tests from last time. Useful to make sure that no
new problems have been introduced.

=item C<all>

Run all tests in normal order. Multple options may be specified, so to
run all tests with the failures from last time first:

    $ prove -b --state=failed,all,save

=item C<hot>

Run the tests that most recently failed first. The last failure time of
each test is stored. The C<hot> option causes tests to be run in most-recent-
failure order.

    $ prove -b --state=hot,save

Tests that have never failed will not be selected. To run all tests with
the most recently failed first use

    $ prove -b --state=hot,all,save

This combination of options may also be specified thus

    $ prove -b --state=adrian

=item C<todo>

Run any tests with todos.

=item C<slow>

Run the tests in slowest to fastest order. This is useful in conjunction
with the C<-j> parallel testing switch to ensure that your slowest tests
start running first.

    $ prove -b --state=slow -j9

=item C<fast>

Run test tests in fastest to slowest order.

=item C<new>

Run the tests in newest to oldest order based on the modification times
of the test scripts.

=item C<old>

Run the tests in oldest to newest order.

=item C<fresh>

Run those test scripts that have been modified since the last test run.

=item C<save>

Save the state on exit. The state is stored in a file called F<.prove>
(F<_prove> on Windows and VMS) in the current directory.

=back

The C<--state> switch may be used more than once.

    $ prove -b --state=hot --state=all,save

=head2 --rules

The C<--rules> option is used to control which tests are run sequentially and
which are run in parallel, if the C<--jobs> option is specified. The option may
be specified multiple times, and the order matters.

The most practical use is likely to specify that some tests are not
"parallel-ready".  Since mentioning a file with --rules doesn't cause it to
be selected to run as a test, you can "set and forget" some rules preferences in
your .proverc file. Then you'll be able to take maximum advantage of the
performance benefits of parallel testing, while some exceptions are still run
in parallel.

=head3 --rules examples

    # All tests are allowed to run in parallel, except those starting with "p"
    --rules='seq=t/p*.t' --rules='par=**'

    # All tests must run in sequence except those starting with "p", which should be run parallel
    --rules='par=t/p*.t'

=head3 --rules resolution

=over 4

=item * By default, all tests are eligible to be run in parallel. Specifying any of your own rules removes this one.

=item * "First match wins". The first rule that matches a test will be the one that applies.

=item * Any test which does not match a rule will be run in sequence at the end of the run.

=item * The existence of a rule does not imply selecting a test. You must still specify the tests to run.

=item * Specifying a rule to allow tests to run in parallel does not make them run in parallel. You still need specify the number of parallel C<jobs> in your Harness object.

=back

=head3 --rules Glob-style pattern matching

We implement our own glob-style pattern matching for --rules. Here are the
supported patterns:

    ** is any number of characters, including /, within a pathname
    * is zero or more characters within a filename/directory name
    ? is exactly one character within a filename/directory name
    {foo,bar,baz} is any of foo, bar or baz.
    \ is an escape character

=head3 More advanced specifications for parallel vs sequence run rules

If you need more advanced management of what runs in parallel vs in sequence, see
the associated 'rules' documentation in L<TAP::Harness> and L<TAP::Parser::Scheduler>.
If what's possible directly through C<prove> is not sufficient, you can write your own
harness to access these features directly.

=head2 @INC

prove introduces a separation between "options passed to the perl which
runs prove" and "options passed to the perl which runs tests"; this
distinction is by design. Thus the perl which is running a test starts
with the default C<@INC>. Additional library directories can be added
via the C<PERL5LIB> environment variable, via -Ifoo in C<PERL5OPT> or
via the C<-Ilib> option to F<prove>.

=head2 Taint Mode

Normally when a Perl program is run in taint mode the contents of the
C<PERL5LIB> environment variable do not appear in C<@INC>.

Because C<PERL5LIB> is often used during testing to add build
directories to C<@INC> prove passes the names of any directories found
in C<PERL5LIB> as -I switches. The net effect of this is that
C<PERL5LIB> is honoured even when prove is run in taint mode.


=head1 FORMATTERS

You can load a custom L<TAP::Parser::Formatter>:

  prove --formatter MyFormatter

=head1 SOURCE HANDLERS

You can load custom L<TAP::Parser::SourceHandler>s, to change the way the
parser interprets particular I<sources> of TAP.

  prove --source MyHandler --source YetAnother t

If you want to provide config to the source you can use:

  prove --source MyCustom \
        --source Perl --perl-option 'foo=bar baz' --perl-option avg=0.278 \
        --source File --file-option extensions=.txt --file-option extensions=.tmp t
        --source pgTAP --pgtap-option pset=format=html --pgtap-option pset=border=2

Each C<--$source-option> option must specify a key/value pair separated by an
C<=>. If an option can take multiple values, just specify it multiple times,
as with the C<extensions=> examples above. If the option should be a hash
reference, specify the value as a second pair separated by a C<=>, as in the
C<pset=> examples above (escape C<=> with a backslash).

All C<--sources> are combined into a hash, and passed to L<TAP::Harness/new>'s
C<sources> parameter.

See L<TAP::Parser::IteratorFactory> for more details on how configuration is
passed to I<SourceHandlers>.

=head1 PLUGINS

Plugins can be loaded using the C<< -PI<plugin> >> syntax, eg:

  prove -PMyPlugin

This will search for a module named C<App::Prove::Plugin::MyPlugin>, or failing
that, C<MyPlugin>.  If the plugin can't be found, C<prove> will complain & exit.

You can pass arguments to your plugin by appending C<=arg1,arg2,etc> to the
plugin name:

  prove -PMyPlugin=fou,du,fafa

Please check individual plugin documentation for more details.

=head2 Available Plugins

For an up-to-date list of plugins available, please check CPAN:

L<http://search.cpan.org/search?query=App%3A%3AProve+Plugin>

=head2 Writing Plugins

Please see L<App::Prove/PLUGINS>.

=cut

# vim:ts=4:sw=4:et:sta
