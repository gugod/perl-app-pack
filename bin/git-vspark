#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"B/Hooks/EndOfScope.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE';
  package B::Hooks::EndOfScope; # git description: 0.23-2-ga391106
  # ABSTRACT: Execute code after a scope finished compilation
  # KEYWORDS: code hooks execution scope
  
  use strict;
  use warnings;
  
  our $VERSION = '0.24';
  
  use 5.006001;
  
  BEGIN {
    use Module::Implementation 0.05;
    Module::Implementation::build_loader_sub(
      implementations => [ 'XS', 'PP' ],
      symbols => [ 'on_scope_end' ],
    )->();
  }
  
  use Sub::Exporter::Progressive 0.001006 -setup => {
    exports => [ 'on_scope_end' ],
    groups  => { default => ['on_scope_end'] },
  };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  B::Hooks::EndOfScope - Execute code after a scope finished compilation
  
  =head1 VERSION
  
  version 0.24
  
  =head1 SYNOPSIS
  
      on_scope_end { ... };
  
  =head1 DESCRIPTION
  
  This module allows you to execute code when perl finished compiling the
  surrounding scope.
  
  =head1 FUNCTIONS
  
  =head2 on_scope_end
  
      on_scope_end { ... };
  
      on_scope_end $code;
  
  Registers C<$code> to be executed after the surrounding scope has been
  compiled.
  
  This is exported by default. See L<Sub::Exporter> on how to customize it.
  
  =head1 LIMITATIONS
  
  =head2 Pure-perl mode caveat
  
  This caveat applies to B<any> version of perl where L<Variable::Magic>
  is unavailable or otherwise disabled.
  
  While L<Variable::Magic> has access to some very dark sorcery to make it
  possible to throw an exception from within a callback, the pure-perl
  implementation does not have access to these hacks. Therefore, what
  would have been a B<compile-time exception> is instead B<converted to a
  warning>, and your execution will continue as if the exception never
  happened.
  
  To explicitly request an XS (or PP) implementation one has two choices. Either
  to import from the desired implementation explicitly:
  
   use B::Hooks::EndOfScope::XS
     or
   use B::Hooks::EndOfScope::PP
  
  or by setting C<$ENV{B_HOOKS_ENDOFSCOPE_IMPLEMENTATION}> to either C<XS> or
  C<PP>.
  
  =head2 Perl 5.8.0 ~ 5.8.3
  
  Due to a L<core interpreter bug
  |https://rt.perl.org/Public/Bug/Display.html?id=27040#txn-82797> present in
  older perl versions, the implementation of B::Hooks::EndOfScope deliberately
  leaks a single empty hash for every scope being cleaned. This is done to
  avoid the memory corruption associated with the bug mentioned above.
  
  In order to stabilize this workaround use of L<Variable::Magic> is disabled
  on perls prior to version 5.8.4. On such systems loading/requesting
  L<B::Hooks::EndOfScope::XS> explicitly will result in a compile-time
  exception.
  
  =head2 Perl versions 5.6.x
  
  Versions of perl before 5.8.0 lack a feature allowing changing the visibility
  of C<%^H> via setting bit 17 within C<$^H>. As such the only way to achieve
  the effect necessary for this module to work, is to use the C<local> operator
  explicitly on these platforms. This might lead to unexpected interference
  with other scope-driven libraries relying on the same mechanism. On the flip
  side there are no such known incompatibilities at the time this note was
  written.
  
  For further details on the unavailable behavior please refer to the test
  file F<t/02-localise.t> included with the distribution.
  
  =head1 SEE ALSO
  
  L<Sub::Exporter>
  
  L<Variable::Magic>
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=B-Hooks-EndOfScope>
  (or L<bug-B-Hooks-EndOfScope@rt.cpan.org|mailto:bug-B-Hooks-EndOfScope@rt.cpan.org>).
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@leporine.io>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Karen Etheridge Tatsuhiko Miyagawa Christian Walde Tomas Doran Graham Knop Simon Wilper
  
  =over 4
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Tatsuhiko Miyagawa <miyagawa@bulknews.net>
  
  =item *
  
  Christian Walde <walde.christian@googlemail.com>
  
  =item *
  
  Tomas Doran <bobtfish@bobtfish.net>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Simon Wilper <sxw@chronowerks.de>
  
  =back
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2008 by Florian Ragwitz.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
B_HOOKS_ENDOFSCOPE

$fatpacked{"B/Hooks/EndOfScope/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE_PP';
  package B::Hooks::EndOfScope::PP;
  # ABSTRACT: Execute code after a scope finished compilation - PP implementation
  
  use warnings;
  use strict;
  
  our $VERSION = '0.24';
  
  use constant _PERL_VERSION => "$]";
  
  BEGIN {
    if (_PERL_VERSION =~ /^5\.009/) {
      # CBA to figure out where %^H got broken and which H::U::HH is sane enough
      die "By design B::Hooks::EndOfScope does not operate in pure-perl mode on perl 5.9.X\n"
    }
    elsif (_PERL_VERSION < '5.010') {
      require B::Hooks::EndOfScope::PP::HintHash;
      *on_scope_end = \&B::Hooks::EndOfScope::PP::HintHash::on_scope_end;
    }
    else {
      require B::Hooks::EndOfScope::PP::FieldHash;
      *on_scope_end = \&B::Hooks::EndOfScope::PP::FieldHash::on_scope_end;
    }
  }
  
  use Sub::Exporter::Progressive 0.001006 -setup => {
    exports => ['on_scope_end'],
    groups  => { default => ['on_scope_end'] },
  };
  
  sub __invoke_callback {
    local $@;
    eval { $_[0]->(); 1 } or do {
      my $err = $@;
      require Carp;
      Carp::cluck( (join ' ',
        'A scope-end callback raised an exception, which can not be propagated when',
        'B::Hooks::EndOfScope operates in pure-perl mode. Your program will CONTINUE',
        'EXECUTION AS IF NOTHING HAPPENED AFTER THIS WARNING. Below is the complete',
        'exception text, followed by a stack-trace of the callback execution:',
      ) . "\n\n$err\n\r" );
  
      sleep 1 if -t *STDERR;  # maybe a bad idea...?
    };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  B::Hooks::EndOfScope::PP - Execute code after a scope finished compilation - PP implementation
  
  =head1 VERSION
  
  version 0.24
  
  =head1 DESCRIPTION
  
  This is the pure-perl implementation of L<B::Hooks::EndOfScope> based only on
  modules available as part of the perl core. Its leaner sibling
  L<B::Hooks::EndOfScope::XS> will be automatically preferred if all
  dependencies are available and C<$ENV{B_HOOKS_ENDOFSCOPE_IMPLEMENTATION}> is
  not set to C<'PP'>.
  
  =head1 FUNCTIONS
  
  =head2 on_scope_end
  
      on_scope_end { ... };
  
      on_scope_end $code;
  
  Registers C<$code> to be executed after the surrounding scope has been
  compiled.
  
  This is exported by default. See L<Sub::Exporter> on how to customize it.
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=B-Hooks-EndOfScope>
  (or L<bug-B-Hooks-EndOfScope@rt.cpan.org|mailto:bug-B-Hooks-EndOfScope@rt.cpan.org>).
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@leporine.io>
  
  =back
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2008 by Florian Ragwitz.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
B_HOOKS_ENDOFSCOPE_PP

$fatpacked{"B/Hooks/EndOfScope/PP/FieldHash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE_PP_FIELDHASH';
  # Implementation of a pure-perl on_scope_end for perls > 5.10
  # (relies on Hash::Util:FieldHash)
  
  package # hide from pause
    B::Hooks::EndOfScope::PP::FieldHash;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.24';
  
  use Tie::Hash ();
  use Hash::Util::FieldHash 'fieldhash';
  
  # Here we rely on a combination of several behaviors:
  #
  # * %^H is deallocated on scope exit, so any references to it disappear
  # * A lost weakref in a fieldhash causes the corresponding key to be deleted
  # * Deletion of a key on a tied hash triggers DELETE
  #
  # Therefore the DELETE of a tied fieldhash containing a %^H reference will
  # be the hook to fire all our callbacks.
  
  fieldhash my %hh;
  {
    package # hide from pause too
      B::Hooks::EndOfScope::PP::_TieHintHashFieldHash;
    our @ISA = ( 'Tie::StdHash' );  # in Tie::Hash, in core
    sub DELETE {
      my $ret = shift->SUPER::DELETE(@_);
      B::Hooks::EndOfScope::PP::__invoke_callback($_) for @$ret;
      $ret;
    }
  }
  
  sub on_scope_end (&) {
    $^H |= 0x020000;
  
    tie(%hh, 'B::Hooks::EndOfScope::PP::_TieHintHashFieldHash')
      unless tied %hh;
  
    push @{ $hh{\%^H} ||= [] }, $_[0];
  }
  
  1;
B_HOOKS_ENDOFSCOPE_PP_FIELDHASH

$fatpacked{"B/Hooks/EndOfScope/PP/HintHash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE_PP_HINTHASH';
  # Implementation of a pure-perl on_scope_end for perls < 5.10
  # (relies on lack of compile/runtime duality of %^H before 5.10
  # which makes guard object operation possible)
  
  package # hide from the pauses
    B::Hooks::EndOfScope::PP::HintHash;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.24';
  
  use Scalar::Util ();
  use constant _NEEDS_MEMORY_CORRUPTION_FIXUP => (
    "$]" >= 5.008
      and
    "$]" < 5.008004
  ) ? 1 : 0;
  
  
  use constant _PERL_VERSION => "$]";
  
  # This is the original implementation, which sadly is broken
  # on perl 5.10+ within string evals
  sub on_scope_end (&) {
  
    # the scope-implicit %^H localization is a 5.8+ feature
    $^H |= 0x020000
      if _PERL_VERSION >= 5.008;
  
    # the explicit localization of %^H works on anything < 5.10
    # but we use it only on 5.6 where fiddling $^H has no effect
    local %^H = %^H
      if _PERL_VERSION < 5.008;
  
    # Workaround for memory corruption during implicit $^H-induced
    # localization of %^H on 5.8.0~5.8.3, see extended comment below
    bless \%^H, 'B::Hooks::EndOfScope::PP::HintHash::__GraveyardTransport' if (
      _NEEDS_MEMORY_CORRUPTION_FIXUP
        and
      ref \%^H eq 'HASH'  # only bless if it is a "pure hash" to start with
    );
  
    # localised %^H behaves funny on 5.8 - a
    # 'local %^H;'
    # is in effect the same as
    # 'local %^H = %^H;'
    # therefore make sure we use different keys so that things do not
    # fire too early due to hashkey overwrite
    push @{
      $^H{sprintf '__B_H_EOS__guardstack_0X%x', Scalar::Util::refaddr(\%^H) }
        ||= bless ([], 'B::Hooks::EndOfScope::PP::_SG_STACK')
    }, $_[0];
  }
  
  sub B::Hooks::EndOfScope::PP::_SG_STACK::DESTROY {
    B::Hooks::EndOfScope::PP::__invoke_callback($_) for @{$_[0]};
  }
  
  # This scope implements a clunky yet effective workaround for a core perl bug
  # https://rt.perl.org/Public/Bug/Display.html?id=27040#txn-82797
  #
  # While we can not prevent the hinthash being marked for destruction twice,
  # we *can* intercept the first DESTROY pass, and squirrel away the entire
  # structure, until a time it can (hopefully) no longer do any visible harm
  #
  # There still *will* be corruption by the time we get to free it for real,
  # since we can not prevent Perl's erroneous SAVEFREESV mark. What we hope is
  # that by then the corruption will no longer matter
  #
  # Yes, this code does leak by design. Yes it is better than the alternative.
  {
    my @Hint_Hash_Graveyard;
  
    # "Leak" this entire structure: ensures it and its contents will not be
    # garbage collected until the very very very end
    push @Hint_Hash_Graveyard, \@Hint_Hash_Graveyard
      if _NEEDS_MEMORY_CORRUPTION_FIXUP;
  
    sub B::Hooks::EndOfScope::PP::HintHash::__GraveyardTransport::DESTROY {
  
      # Resurrect the hinthash being destroyed, persist it into the graveyard
      push @Hint_Hash_Graveyard, $_[0];
  
      # ensure we won't try to re-resurrect during GlobalDestroy
      bless $_[0], 'B::Hooks::EndOfScope::PP::HintHash::__DeactivateGraveyardTransport';
  
      # Perform explicit free of elements (if any) triggering all callbacks
      # This is what would have happened without this code being active
      %{$_[0]} = ();
    }
  }
  
  1;
B_HOOKS_ENDOFSCOPE_PP_HINTHASH

$fatpacked{"B/Hooks/EndOfScope/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'B_HOOKS_ENDOFSCOPE_XS';
  package B::Hooks::EndOfScope::XS;
  # ABSTRACT: Execute code after a scope finished compilation - XS implementation
  
  use strict;
  use warnings;
  
  our $VERSION = '0.24';
  
  # Limit the V::M-based (XS) version to perl 5.8.4+
  #
  # Given the unorthodox stuff we do to work around the hinthash double-free
  # might as well play it safe and only implement it in the PP version
  # and leave it at that
  # https://rt.perl.org/Public/Bug/Display.html?id=27040#txn-82797
  #
  use 5.008004;
  
  use Variable::Magic 0.48 ();
  use Sub::Exporter::Progressive 0.001006 -setup => {
    exports => ['on_scope_end'],
    groups  => { default => ['on_scope_end'] },
  };
  
  my $wiz = Variable::Magic::wizard
    data => sub { [$_[1]] },
    free => sub { $_->() for @{ $_[1] }; () },
    # When someone localise %^H, our magic doesn't want to be copied
    # down. We want it to be around only for the scope we've initially
    # attached ourselves to. Merely having MGf_LOCAL and a noop svt_local
    # callback achieves this. If anything wants to attach more magic of our
    # kind to a localised %^H, things will continue to just work as we'll be
    # attached with a new and empty callback list.
    local => \undef
  ;
  
  sub on_scope_end (&) {
    $^H |= 0x020000;
  
    if (my $stack = Variable::Magic::getdata %^H, $wiz) {
      push @{ $stack }, $_[0];
    }
    else {
      Variable::Magic::cast %^H, $wiz, $_[0];
    }
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  B::Hooks::EndOfScope::XS - Execute code after a scope finished compilation - XS implementation
  
  =head1 VERSION
  
  version 0.24
  
  =head1 DESCRIPTION
  
  This is the implementation of L<B::Hooks::EndOfScope> based on
  L<Variable::Magic>, which is an XS module dependent on a compiler. It will
  always be automatically preferred if L<Variable::Magic> is available.
  
  =head1 FUNCTIONS
  
  =head2 on_scope_end
  
      on_scope_end { ... };
  
      on_scope_end $code;
  
  Registers C<$code> to be executed after the surrounding scope has been
  compiled.
  
  This is exported by default. See L<Sub::Exporter> on how to customize it.
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=B-Hooks-EndOfScope>
  (or L<bug-B-Hooks-EndOfScope@rt.cpan.org|mailto:bug-B-Hooks-EndOfScope@rt.cpan.org>).
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@leporine.io>
  
  =back
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2008 by Florian Ragwitz.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
B_HOOKS_ENDOFSCOPE_XS

$fatpacked{"Class/Data/Inheritable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_DATA_INHERITABLE';
  package Class::Data::Inheritable;
  
  use strict qw(vars subs);
  use vars qw($VERSION);
  $VERSION = '0.08';
  
  sub mk_classdata {
      my ($declaredclass, $attribute, $data) = @_;
  
      if( ref $declaredclass ) {
          require Carp;
          Carp::croak("mk_classdata() is a class method, not an object method");
      }
  
      my $accessor = sub {
          my $wantclass = ref($_[0]) || $_[0];
  
          return $wantclass->mk_classdata($attribute)->(@_)
            if @_>1 && $wantclass ne $declaredclass;
  
          $data = $_[1] if @_>1;
          return $data;
      };
  
      my $alias = "_${attribute}_accessor";
      *{$declaredclass.'::'.$attribute} = $accessor;
      *{$declaredclass.'::'.$alias}     = $accessor;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::Data::Inheritable - Inheritable, overridable class data
  
  =head1 SYNOPSIS
  
    package Stuff;
    use base qw(Class::Data::Inheritable);
  
    # Set up DataFile as inheritable class data.
    Stuff->mk_classdata('DataFile');
  
    # Declare the location of the data file for this class.
    Stuff->DataFile('/etc/stuff/data');
  
    # Or, all in one shot:
    Stuff->mk_classdata(DataFile => '/etc/stuff/data');
  
  =head1 DESCRIPTION
  
  Class::Data::Inheritable is for creating accessor/mutators to class
  data.  That is, if you want to store something about your class as a
  whole (instead of about a single object).  This data is then inherited
  by your subclasses and can be overriden.
  
  For example:
  
    Pere::Ubu->mk_classdata('Suitcase');
  
  will generate the method Suitcase() in the class Pere::Ubu.
  
  This new method can be used to get and set a piece of class data.
  
    Pere::Ubu->Suitcase('Red');
    $suitcase = Pere::Ubu->Suitcase;
  
  The interesting part happens when a class inherits from Pere::Ubu:
  
    package Raygun;
    use base qw(Pere::Ubu);
    
    # Raygun's suitcase is Red.
    $suitcase = Raygun->Suitcase;
  
  Raygun inherits its Suitcase class data from Pere::Ubu.
  
  Inheritance of class data works analogous to method inheritance.  As
  long as Raygun does not "override" its inherited class data (by using
  Suitcase() to set a new value) it will continue to use whatever is set
  in Pere::Ubu and inherit further changes:
  
    # Both Raygun's and Pere::Ubu's suitcases are now Blue
    Pere::Ubu->Suitcase('Blue');
  
  However, should Raygun decide to set its own Suitcase() it has now
  "overridden" Pere::Ubu and is on its own, just like if it had
  overriden a method:
  
    # Raygun has an orange suitcase, Pere::Ubu's is still Blue.
    Raygun->Suitcase('Orange');
  
  Now that Raygun has overridden Pere::Ubu futher changes by Pere::Ubu
  no longer effect Raygun.
  
    # Raygun still has an orange suitcase, but Pere::Ubu is using Samsonite.
    Pere::Ubu->Suitcase('Samsonite');
  
  =head1 Methods
  
  =head2 mk_classdata
  
    Class->mk_classdata($data_accessor_name);
    Class->mk_classdata($data_accessor_name => $value);
  
  This is a class method used to declare new class data accessors.
  A new accessor will be created in the Class using the name from
  $data_accessor_name, and optionally initially setting it to the given
  value.
  
  To facilitate overriding, mk_classdata creates an alias to the
  accessor, _field_accessor().  So Suitcase() would have an alias
  _Suitcase_accessor() that does the exact same thing as Suitcase().
  This is useful if you want to alter the behavior of a single accessor
  yet still get the benefits of inheritable class data.  For example.
  
    sub Suitcase {
        my($self) = shift;
        warn "Fashion tragedy" if @_ and $_[0] eq 'Plaid';
  
        $self->_Suitcase_accessor(@_);
    }
  
  =head1 AUTHOR
  
  Original code by Damian Conway.
  
  Maintained by Michael G Schwern until September 2005.
  
  Now maintained by Tony Bowden.
  
  =head1 BUGS and QUERIES
  
  Please direct all correspondence regarding this module to:
    bug-Class-Data-Inheritable@rt.cpan.org
  
  =head1 COPYRIGHT and LICENSE
  
  Copyright (c) 2000-2005, Damian Conway and Michael G Schwern. 
  All Rights Reserved.  
  
  This module is free software. It may be used, redistributed and/or
  modified under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<perltooc> has a very elaborate discussion of class data in Perl.
  
CLASS_DATA_INHERITABLE

$fatpacked{"Class/Inspector.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_INSPECTOR';
  package Class::Inspector;
  
  use 5.006;
  # We don't want to use strict refs anywhere in this module, since we do a
  # lot of things in here that aren't strict refs friendly.
  use strict qw{vars subs};
  use warnings;
  use File::Spec ();
  
  # ABSTRACT: Get information about a class and its structure
  our $VERSION = '1.32'; # VERSION
  
  
  # If Unicode is available, enable it so that the
  # pattern matches below match unicode method names.
  # We can safely ignore any failure here.
  BEGIN {
    local $@;
    eval "require utf8; utf8->import";
  }
  
  # Predefine some regexs
  our $RE_IDENTIFIER = qr/\A[^\W\d]\w*\z/s;
  our $RE_CLASS      = qr/\A[^\W\d]\w*(?:(?:\'|::)\w+)*\z/s;
  
  # Are we on something Unix-like?
  our $UNIX  = !! ( $File::Spec::ISA[0] eq 'File::Spec::Unix'  );
  
  
  #####################################################################
  # Basic Methods
  
  
  sub _resolved_inc_handler {
    my $class    = shift;
    my $filename = $class->_inc_filename(shift) or return undef;
    
    foreach my $inc ( @INC ) {
      my $ref = ref $inc;
      if($ref eq 'CODE') {
        my @ret = $inc->($inc, $filename);
        if(@ret) {
          return 1;
        }
      }
      elsif($ref eq 'ARRAY' && ref($inc->[0]) eq 'CODE') {
        my @ret = $inc->[0]->($inc, $filename);
        if(@ret) {
          return 1;
        }
      }
      elsif($ref && eval { $inc->can('INC') }) {
        my @ret = $inc->INC($filename);
        if(@ret) {
          return 1;
        }
      }
    }
    
    '';
  }
  
  sub installed {
    my $class = shift;
    !! ($class->loaded_filename($_[0]) or $class->resolved_filename($_[0]) or $class->_resolved_inc_handler($_[0]));
  }
  
  
  sub loaded {
    my $class = shift;
    my $name  = $class->_class(shift) or return undef;
    $class->_loaded($name);
  }
  
  sub _loaded {
    my $class = shift;
    my $name  = shift;
  
    # Handle by far the two most common cases
    # This is very fast and handles 99% of cases.
    return 1 if defined ${"${name}::VERSION"};
    return 1 if @{"${name}::ISA"};
  
    # Are there any symbol table entries other than other namespaces
    foreach ( keys %{"${name}::"} ) {
      next if substr($_, -2, 2) eq '::';
      return 1 if defined &{"${name}::$_"};
    }
  
    # No functions, and it doesn't have a version, and isn't anything.
    # As an absolute last resort, check for an entry in %INC
    my $filename = $class->_inc_filename($name);
    return 1 if defined $INC{$filename};
  
    '';
  }
  
  
  sub filename {
    my $class = shift;
    my $name  = $class->_class(shift) or return undef;
    File::Spec->catfile( split /(?:\'|::)/, $name ) . '.pm';
  }
  
  
  sub resolved_filename {
    my $class     = shift;
    my $filename  = $class->_inc_filename(shift) or return undef;
    my @try_first = @_;
  
    # Look through the @INC path to find the file
    foreach ( @try_first, @INC ) {
      my $full = "$_/$filename";
      next unless -e $full;
      return $UNIX ? $full : $class->_inc_to_local($full);
    }
  
    # File not found
    '';
  }
  
  
  sub loaded_filename {
    my $class    = shift;
    my $filename = $class->_inc_filename(shift);
    $UNIX ? $INC{$filename} : $class->_inc_to_local($INC{$filename});
  }
  
  
  
  
  
  #####################################################################
  # Sub Related Methods
  
  
  sub functions {
    my $class = shift;
    my $name  = $class->_class(shift) or return undef;
    return undef unless $class->loaded( $name );
  
    # Get all the CODE symbol table entries
    my @functions = sort grep { /$RE_IDENTIFIER/o }
      grep { defined &{"${name}::$_"} }
      keys %{"${name}::"};
    \@functions;
  }
  
  
  sub function_refs {
    my $class = shift;
    my $name  = $class->_class(shift) or return undef;
    return undef unless $class->loaded( $name );
  
    # Get all the CODE symbol table entries, but return
    # the actual CODE refs this time.
    my @functions = map { \&{"${name}::$_"} }
      sort grep { /$RE_IDENTIFIER/o }
      grep { defined &{"${name}::$_"} }
      keys %{"${name}::"};
    \@functions;
  }
  
  
  sub function_exists {
    my $class    = shift;
    my $name     = $class->_class( shift ) or return undef;
    my $function = shift or return undef;
  
    # Only works if the class is loaded
    return undef unless $class->loaded( $name );
  
    # Does the GLOB exist and its CODE part exist
    defined &{"${name}::$function"};
  }
  
  
  sub methods {
    my $class     = shift;
    my $name      = $class->_class( shift ) or return undef;
    my @arguments = map { lc $_ } @_;
  
    # Process the arguments to determine the options
    my %options = ();
    foreach ( @arguments ) {
      if ( $_ eq 'public' ) {
        # Only get public methods
        return undef if $options{private};
        $options{public} = 1;
  
      } elsif ( $_ eq 'private' ) {
        # Only get private methods
        return undef if $options{public};
        $options{private} = 1;
  
      } elsif ( $_ eq 'full' ) {
        # Return the full method name
        return undef if $options{expanded};
        $options{full} = 1;
  
      } elsif ( $_ eq 'expanded' ) {
        # Returns class, method and function ref
        return undef if $options{full};
        $options{expanded} = 1;
  
      } else {
        # Unknown or unsupported options
        return undef;
      }
    }
  
    # Only works if the class is loaded
    return undef unless $class->loaded( $name );
  
    # Get the super path ( not including UNIVERSAL )
    # Rather than using Class::ISA, we'll use an inlined version
    # that implements the same basic algorithm.
    my @path  = ();
    my @queue = ( $name );
    my %seen  = ( $name => 1 );
    while ( my $cl = shift @queue ) {
      push @path, $cl;
      unshift @queue, grep { ! $seen{$_}++ }
        map { s/^::/main::/; s/\'/::/g; $_ }
        ( @{"${cl}::ISA"} );
    }
  
    # Find and merge the function names across the entire super path.
    # Sort alphabetically and return.
    my %methods = ();
    foreach my $namespace ( @path ) {
      my @functions = grep { ! $methods{$_} }
        grep { /$RE_IDENTIFIER/o }
        grep { defined &{"${namespace}::$_"} } 
        keys %{"${namespace}::"};
      foreach ( @functions ) {
        $methods{$_} = $namespace;
      }
    }
  
    # Filter to public or private methods if needed
    my @methodlist = sort keys %methods;
    @methodlist = grep { ! /^\_/ } @methodlist if $options{public};
    @methodlist = grep {   /^\_/ } @methodlist if $options{private};
  
    # Return in the correct format
    @methodlist = map { "$methods{$_}::$_" } @methodlist if $options{full};
    @methodlist = map { 
      [ "$methods{$_}::$_", $methods{$_}, $_, \&{"$methods{$_}::$_"} ] 
      } @methodlist if $options{expanded};
  
    \@methodlist;
  }
  
  
  
  
  
  #####################################################################
  # Search Methods
  
  
  sub subclasses {
    my $class = shift;
    my $name  = $class->_class( shift ) or return undef;
  
    # Prepare the search queue
    my @found = ();
    my @queue = grep { $_ ne 'main' } $class->_subnames('');
    while ( @queue ) {
      my $c = shift(@queue); # c for class
      if ( $class->_loaded($c) ) {
        # At least one person has managed to misengineer
        # a situation in which ->isa could die, even if the
        # class is real. Trap these cases and just skip
        # over that (bizarre) class. That would at limit
        # problems with finding subclasses to only the
        # modules that have broken ->isa implementation.
        local $@;
        eval {
          if ( $c->isa($name) ) {
            # Add to the found list, but don't add the class itself
            push @found, $c unless $c eq $name;
          }
        };
      }
  
      # Add any child namespaces to the head of the queue.
      # This keeps the queue length shorted, and allows us
      # not to have to do another sort at the end.
      unshift @queue, map { "${c}::$_" } $class->_subnames($c);
    }
  
    @found ? \@found : '';
  }
  
  sub _subnames {
    my ($class, $name) = @_;
    return sort
      grep {
        substr($_, -2, 2, '') eq '::'
        and
        /$RE_IDENTIFIER/o
      }
      keys %{"${name}::"};
  }
  
  
  
  
  
  #####################################################################
  # Children Related Methods
  
  # These can go undocumented for now, until I decide if its best to
  # just search the children in namespace only, or if I should do it via
  # the file system.
  
  # Find all the loaded classes below us
  sub children {
    my $class = shift;
    my $name  = $class->_class(shift) or return ();
  
    # Find all the Foo:: elements in our symbol table
    no strict 'refs';
    map { "${name}::$_" } sort grep { s/::$// } keys %{"${name}::"};
  }
  
  # As above, but recursively
  sub recursive_children {
    my $class    = shift;
    my $name     = $class->_class(shift) or return ();
    my @children = ( $name );
  
    # Do the search using a nicer, more memory efficient 
    # variant of actual recursion.
    my $i = 0;
    no strict 'refs';
    while ( my $namespace = $children[$i++] ) {
      push @children, map { "${namespace}::$_" }
        grep { ! /^::/ } # Ignore things like ::ISA::CACHE::
        grep { s/::$// }
        keys %{"${namespace}::"};
    }
  
    sort @children;
  }
  
  
  
  
  
  #####################################################################
  # Private Methods
  
  # Checks and expands ( if needed ) a class name
  sub _class {
    my $class = shift;
    my $name  = shift or return '';
  
    # Handle main shorthand
    return 'main' if $name eq '::';
    $name =~ s/\A::/main::/;
  
    # Check the class name is valid
    $name =~ /$RE_CLASS/o ? $name : '';
  }
  
  # Create a INC-specific filename, which always uses '/'
  # regardless of platform.
  sub _inc_filename {
    my $class = shift;
    my $name  = $class->_class(shift) or return undef;
    join( '/', split /(?:\'|::)/, $name ) . '.pm';
  }
  
  # Convert INC-specific file name to local file name
  sub _inc_to_local {
    # Shortcut in the Unix case
    return $_[1] if $UNIX;
  
    # On other places, we have to deal with an unusual path that might look
    # like C:/foo/bar.pm which doesn't fit ANY normal pattern.
    # Putting it through splitpath/dir and back again seems to normalise
    # it to a reasonable amount.
    my $class              = shift;
    my $inc_name           = shift or return undef;
    my ($vol, $dir, $file) = File::Spec->splitpath( $inc_name );
    $dir = File::Spec->catdir( File::Spec->splitdir( $dir || "" ) );
    File::Spec->catpath( $vol, $dir, $file || "" );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::Inspector - Get information about a class and its structure
  
  =head1 VERSION
  
  version 1.32
  
  =head1 SYNOPSIS
  
    use Class::Inspector;
    
    # Is a class installed and/or loaded
    Class::Inspector->installed( 'Foo::Class' );
    Class::Inspector->loaded( 'Foo::Class' );
    
    # Filename related information
    Class::Inspector->filename( 'Foo::Class' );
    Class::Inspector->resolved_filename( 'Foo::Class' );
    
    # Get subroutine related information
    Class::Inspector->functions( 'Foo::Class' );
    Class::Inspector->function_refs( 'Foo::Class' );
    Class::Inspector->function_exists( 'Foo::Class', 'bar' );
    Class::Inspector->methods( 'Foo::Class', 'full', 'public' );
    
    # Find all loaded subclasses or something
    Class::Inspector->subclasses( 'Foo::Class' );
  
  =head1 DESCRIPTION
  
  Class::Inspector allows you to get information about a loaded class. Most or
  all of this information can be found in other ways, but they aren't always
  very friendly, and usually involve a relatively high level of Perl wizardry,
  or strange and unusual looking code. Class::Inspector attempts to provide 
  an easier, more friendly interface to this information.
  
  =head1 METHODS
  
  =head2 installed
  
   my $bool = Class::Inspector->installed($class);
  
  The C<installed> static method tries to determine if a class is installed
  on the machine, or at least available to Perl. It does this by wrapping
  around C<resolved_filename>.
  
  Returns true if installed/available, false if the class is not installed,
  or C<undef> if the class name is invalid.
  
  =head2 loaded
  
   my $bool = Class::Inspector->loaded($class);
  
  The C<loaded> static method tries to determine if a class is loaded by
  looking for symbol table entries.
  
  This method it uses to determine this will work even if the class does not
  have its own file, but is contained inside a single file with multiple
  classes in it. Even in the case of some sort of run-time loading class
  being used, these typically leave some trace in the symbol table, so an
  L<Autoload> or L<Class::Autouse>-based class should correctly appear
  loaded.
  
  Returns true if the class is loaded, false if not, or C<undef> if the
  class name is invalid.
  
  =head2 filename
  
   my $filename = Class::Inspector->filename($class);
  
  For a given class, returns the base filename for the class. This will NOT
  be a fully resolved filename, just the part of the filename BELOW the
  C<@INC> entry.
  
    print Class->filename( 'Foo::Bar' );
    > Foo/Bar.pm
  
  This filename will be returned with the right separator for the local
  platform, and should work on all platforms.
  
  Returns the filename on success or C<undef> if the class name is invalid.
  
  =head2 resolved_filename
  
   my $filename = Class::Inspector->resolved_filename($class);
   my $filename = Class::Inspector->resolved_filename($class, @try_first);
  
  For a given class, the C<resolved_filename> static method returns the fully
  resolved filename for a class. That is, the file that the class would be
  loaded from.
  
  This is not necessarily the file that the class WAS loaded from, as the
  value returned is determined each time it runs, and the C<@INC> include
  path may change.
  
  To get the actual file for a loaded class, see the C<loaded_filename>
  method.
  
  Returns the filename for the class, or C<undef> if the class name is
  invalid.
  
  =head2 loaded_filename
  
   my $filename = Class::Inspector->loaded_filename($class);
  
  For a given loaded class, the C<loaded_filename> static method determines
  (via the C<%INC> hash) the name of the file that it was originally loaded
  from.
  
  Returns a resolved file path, or false if the class did not have it's own
  file.
  
  =head2 functions
  
   my $arrayref = Class::Inspector->functions($class);
  
  For a loaded class, the C<functions> static method returns a list of the
  names of all the functions in the classes immediate namespace.
  
  Note that this is not the METHODS of the class, just the functions.
  
  Returns a reference to an array of the function names on success, or C<undef>
  if the class name is invalid or the class is not loaded.
  
  =head2 function_refs
  
   my $arrayref = Class::Inspector->function_refs($class);
  
  For a loaded class, the C<function_refs> static method returns references to
  all the functions in the classes immediate namespace.
  
  Note that this is not the METHODS of the class, just the functions.
  
  Returns a reference to an array of C<CODE> refs of the functions on
  success, or C<undef> if the class is not loaded.
  
  =head2 function_exists
  
   my $bool = Class::Inspector->function_exists($class, $functon);
  
  Given a class and function name the C<function_exists> static method will
  check to see if the function exists in the class.
  
  Note that this is as a function, not as a method. To see if a method
  exists for a class, use the C<can> method for any class or object.
  
  Returns true if the function exists, false if not, or C<undef> if the
  class or function name are invalid, or the class is not loaded.
  
  =head2 methods
  
   my $arrayref = Class::Inspector->methods($class, @options);
  
  For a given class name, the C<methods> static method will returns ALL
  the methods available to that class. This includes all methods available
  from every class up the class' C<@ISA> tree.
  
  Returns a reference to an array of the names of all the available methods
  on success, or C<undef> if the class name is invalid or the class is not
  loaded.
  
  A number of options are available to the C<methods> method that will alter
  the results returned. These should be listed after the class name, in any
  order.
  
    # Only get public methods
    my $method = Class::Inspector->methods( 'My::Class', 'public' );
  
  =over 4
  
  =item public
  
  The C<public> option will return only 'public' methods, as defined by the Perl
  convention of prepending an underscore to any 'private' methods. The C<public> 
  option will effectively remove any methods that start with an underscore.
  
  =item private
  
  The C<private> options will return only 'private' methods, as defined by the
  Perl convention of prepending an underscore to an private methods. The
  C<private> option will effectively remove an method that do not start with an
  underscore.
  
  B<Note: The C<public> and C<private> options are mutually exclusive>
  
  =item full
  
  C<methods> normally returns just the method name. Supplying the C<full> option
  will cause the methods to be returned as the full names. That is, instead of
  returning C<[ 'method1', 'method2', 'method3' ]>, you would instead get
  C<[ 'Class::method1', 'AnotherClass::method2', 'Class::method3' ]>.
  
  =item expanded
  
  The C<expanded> option will cause a lot more information about method to be 
  returned. Instead of just the method name, you will instead get an array
  reference containing the method name as a single combined name, a la C<full>,
  the separate class and method, and a CODE ref to the actual function ( if
  available ). Please note that the function reference is not guaranteed to 
  be available. C<Class::Inspector> is intended at some later time, to work 
  with modules that have some kind of common run-time loader in place ( e.g
  C<Autoloader> or C<Class::Autouse> for example.
  
  The response from C<methods( 'Class', 'expanded' )> would look something like
  the following.
  
    [
      [ 'Class::method1',   'Class',   'method1', \&Class::method1   ],
      [ 'Another::method2', 'Another', 'method2', \&Another::method2 ],
      [ 'Foo::bar',         'Foo',     'bar',     \&Foo::bar         ],
    ]
  
  =back
  
  =head2 subclasses
  
   my $arrayref = Class::Inspector->subclasses($class);
  
  The C<subclasses> static method will search then entire namespace (and thus
  B<all> currently loaded classes) to find all classes that are subclasses
  of the class provided as a the parameter.
  
  The actual test will be done by calling C<isa> on the class as a static
  method. (i.e. C<My::Class-E<gt>isa($class)>.
  
  Returns a reference to a list of the loaded classes that match the class
  provided, or false is none match, or C<undef> if the class name provided
  is invalid.
  
  =head1 SEE ALSO
  
  L<http://ali.as/>, L<Class::Handle>, L<Class::Inspector::Functions>
  
  =head1 AUTHOR
  
  Original author: Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Current maintainer: Graham Ollis E<lt>plicease@cpan.orgE<gt>
  
  Contributors:
  
  Tom Wyant
  
  Steffen Müller
  
  Kivanc Yazan (KYZN)
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Adam Kennedy.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
CLASS_INSPECTOR

$fatpacked{"Class/Inspector/Functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_INSPECTOR_FUNCTIONS';
  package Class::Inspector::Functions;
  
  use 5.006;
  use strict;
  use warnings;
  use Exporter         ();
  use Class::Inspector ();
  
  # ABSTRACT: Get information about a class and its structure
  our $VERSION = '1.32'; # VERSION
  
  BEGIN {
    our @ISA     = 'Exporter';
  
  
    our @EXPORT = qw(
      installed
      loaded
  
      filename
      functions
      methods
  
      subclasses
    );
  
    our @EXPORT_OK = qw(
      resolved_filename
      loaded_filename
  
      function_refs
      function_exists
    );
      #children
      #recursive_children
  
    our %EXPORT_TAGS = ( ALL => [ @EXPORT_OK, @EXPORT ] );
  
    foreach my $meth (@EXPORT, @EXPORT_OK) {
        my $sub = Class::Inspector->can($meth);
        no strict 'refs';
        *{$meth} = sub {&$sub('Class::Inspector', @_)};
    }
  
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::Inspector::Functions - Get information about a class and its structure
  
  =head1 VERSION
  
  version 1.32
  
  =head1 SYNOPSIS
  
    use Class::Inspector::Functions;
    # Class::Inspector provides a non-polluting,
    # method based interface!
    
    # Is a class installed and/or loaded
    installed( 'Foo::Class' );
    loaded( 'Foo::Class' );
    
    # Filename related information
    filename( 'Foo::Class' );
    resolved_filename( 'Foo::Class' );
    
    # Get subroutine related information
    functions( 'Foo::Class' );
    function_refs( 'Foo::Class' );
    function_exists( 'Foo::Class', 'bar' );
    methods( 'Foo::Class', 'full', 'public' );
    
    # Find all loaded subclasses or something
    subclasses( 'Foo::Class' );
  
  =head1 DESCRIPTION
  
  Class::Inspector::Functions is a function based interface of
  L<Class::Inspector>. For a thorough documentation of the available
  functions, please check the manual for the main module.
  
  =head2 Exports
  
  The following functions are exported by default.
  
    installed
    loaded
    filename
    functions
    methods
    subclasses
  
  The following functions are exported only by request.
  
    resolved_filename
    loaded_filename
    function_refs
    function_exists
  
  All the functions may be imported using the C<:ALL> tag.
  
  =head1 SEE ALSO
  
  L<http://ali.as/>, L<Class::Handle>, L<Class::Inspector>
  
  =head1 AUTHOR
  
  Original author: Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Current maintainer: Graham Ollis E<lt>plicease@cpan.orgE<gt>
  
  Contributors:
  
  Tom Wyant
  
  Steffen Müller
  
  Kivanc Yazan (KYZN)
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Adam Kennedy.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
CLASS_INSPECTOR_FUNCTIONS

$fatpacked{"Data/OptList.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_OPTLIST';
  use strict;
  use warnings;
  package Data::OptList;
  # ABSTRACT: parse and validate simple name/value option pairs
  $Data::OptList::VERSION = '0.110';
  use List::Util ();
  use Params::Util ();
  use Sub::Install 0.921 ();
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   use Data::OptList;
  #pod
  #pod   my $options = Data::OptList::mkopt([
  #pod     qw(key1 key2 key3 key4),
  #pod     key5 => { ... },
  #pod     key6 => [ ... ],
  #pod     key7 => sub { ... },
  #pod     key8 => { ... },
  #pod     key8 => [ ... ],
  #pod   ]);
  #pod
  #pod ...is the same thing, more or less, as:
  #pod
  #pod   my $options = [
  #pod     [ key1 => undef,        ],
  #pod     [ key2 => undef,        ],
  #pod     [ key3 => undef,        ],
  #pod     [ key4 => undef,        ],
  #pod     [ key5 => { ... },      ],
  #pod     [ key6 => [ ... ],      ],
  #pod     [ key7 => sub { ... },  ],
  #pod     [ key8 => { ... },      ],
  #pod     [ key8 => [ ... ],      ],
  #pod   ]);
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod Hashes are great for storing named data, but if you want more than one entry
  #pod for a name, you have to use a list of pairs.  Even then, this is really boring
  #pod to write:
  #pod
  #pod   $values = [
  #pod     foo => undef,
  #pod     bar => undef,
  #pod     baz => undef,
  #pod     xyz => { ... },
  #pod   ];
  #pod
  #pod Just look at all those undefs!  Don't worry, we can get rid of those:
  #pod
  #pod   $values = [
  #pod     map { $_ => undef } qw(foo bar baz),
  #pod     xyz => { ... },
  #pod   ];
  #pod
  #pod Aaaauuugh!  We've saved a little typing, but now it requires thought to read,
  #pod and thinking is even worse than typing... and it's got a bug!  It looked right,
  #pod didn't it?  Well, the C<< xyz => { ... } >> gets consumed by the map, and we
  #pod don't get the data we wanted.
  #pod
  #pod With Data::OptList, you can do this instead:
  #pod
  #pod   $values = Data::OptList::mkopt([
  #pod     qw(foo bar baz),
  #pod     xyz => { ... },
  #pod   ]);
  #pod
  #pod This works by assuming that any defined scalar is a name and any reference
  #pod following a name is its value.
  #pod
  #pod =func mkopt
  #pod
  #pod   my $opt_list = Data::OptList::mkopt($input, \%arg);
  #pod
  #pod Valid arguments are:
  #pod
  #pod   moniker        - a word used in errors to describe the opt list; encouraged
  #pod   require_unique - if true, no name may appear more than once
  #pod   must_be        - types to which opt list values are limited (described below)
  #pod   name_test      - a coderef used to test whether a value can be a name
  #pod                    (described below, but you probably don't want this)
  #pod
  #pod This produces an array of arrays; the inner arrays are name/value pairs.
  #pod Values will be either "undef" or a reference.
  #pod
  #pod Positional parameters may be used for compatibility with the old C<mkopt>
  #pod interface:
  #pod
  #pod   my $opt_list = Data::OptList::mkopt($input, $moniker, $req_uni, $must_be);
  #pod
  #pod Valid values for C<$input>:
  #pod
  #pod  undef    -> []
  #pod  hashref  -> [ [ key1 => value1 ] ... ] # non-ref values become undef
  #pod  arrayref -> every name followed by a non-name becomes a pair: [ name => ref ]
  #pod              every name followed by undef becomes a pair: [ name => undef ]
  #pod              otherwise, it becomes [ name => undef ] like so:
  #pod              [ "a", "b", [ 1, 2 ] ] -> [ [ a => undef ], [ b => [ 1, 2 ] ] ]
  #pod
  #pod By default, a I<name> is any defined non-reference.  The C<name_test> parameter
  #pod can be a code ref that tests whether the argument passed it is a name or not.
  #pod This should be used rarely.  Interactions between C<require_unique> and
  #pod C<name_test> are not yet particularly elegant, as C<require_unique> just tests
  #pod string equality.  B<This may change.>
  #pod
  #pod The C<must_be> parameter is either a scalar or array of scalars; it defines
  #pod what kind(s) of refs may be values.  If an invalid value is found, an exception
  #pod is thrown.  If no value is passed for this argument, any reference is valid.
  #pod If C<must_be> specifies that values must be CODE, HASH, ARRAY, or SCALAR, then
  #pod Params::Util is used to check whether the given value can provide that
  #pod interface.  Otherwise, it checks that the given value is an object of the kind.
  #pod
  #pod In other words:
  #pod
  #pod   [ qw(SCALAR HASH Object::Known) ]
  #pod
  #pod Means:
  #pod
  #pod   _SCALAR0($value) or _HASH($value) or _INSTANCE($value, 'Object::Known')
  #pod
  #pod =cut
  
  my %test_for;
  BEGIN {
    %test_for = (
      CODE   => \&Params::Util::_CODELIKE,  ## no critic
      HASH   => \&Params::Util::_HASHLIKE,  ## no critic
      ARRAY  => \&Params::Util::_ARRAYLIKE, ## no critic
      SCALAR => \&Params::Util::_SCALAR0,   ## no critic
    );
  }
  
  sub mkopt {
    my ($opt_list) = shift;
  
    my ($moniker, $require_unique, $must_be); # the old positional args
    my ($name_test, $is_a);
  
    if (@_) {
      if (@_ == 1 and Params::Util::_HASHLIKE($_[0])) {
        ($moniker, $require_unique, $must_be, $name_test)
          = @{$_[0]}{ qw(moniker require_unique must_be name_test) };
      } else {
        ($moniker, $require_unique, $must_be) = @_;
      }
  
      # Transform the $must_be specification into a closure $is_a
      # that will check if a value matches the spec
  
      if (defined $must_be) {
        $must_be = [ $must_be ] unless ref $must_be;
        my @checks = map {
            my $class = $_;
            $test_for{$_}
            || sub { $_[1] = $class; goto \&Params::Util::_INSTANCE }
        } @$must_be;
  
        $is_a = (@checks == 1)
              ? $checks[0]
              : sub {
                  my $value = $_[0];
                  List::Util::first { defined($_->($value)) } @checks
                };
  
        $moniker = 'unnamed' unless defined $moniker;
      }
    }
  
    return [] unless $opt_list;
  
    $name_test ||= sub { ! ref $_[0] };
  
    $opt_list = [
      map { $_ => (ref $opt_list->{$_} ? $opt_list->{$_} : ()) } keys %$opt_list
    ] if ref $opt_list eq 'HASH';
  
    my @return;
    my %seen;
  
    for (my $i = 0; $i < @$opt_list; $i++) { ## no critic
      my $name = $opt_list->[$i];
  
      if ($require_unique) {
        Carp::croak "multiple definitions provided for $name" if $seen{$name}++;
      }
  
      my $value;
  
      if ($i < $#$opt_list) {
        if (not defined $opt_list->[$i+1]) {
          $i++
        } elsif (! $name_test->($opt_list->[$i+1])) {
          $value = $opt_list->[++$i];
          if ($is_a && !$is_a->($value)) {
            my $ref = ref $value;
            Carp::croak "$ref-ref values are not valid in $moniker opt list";
          }
        }
      }
  
      push @return, [ $name => $value ];
    }
  
    return \@return;
  }
  
  #pod =func mkopt_hash
  #pod
  #pod   my $opt_hash = Data::OptList::mkopt_hash($input, $moniker, $must_be);
  #pod
  #pod Given valid C<L</mkopt>> input, this routine returns a reference to a hash.  It
  #pod will throw an exception if any name has more than one value.
  #pod
  #pod =cut
  
  sub mkopt_hash {
    my ($opt_list, $moniker, $must_be) = @_;
    return {} unless $opt_list;
  
    $opt_list = mkopt($opt_list, $moniker, 1, $must_be);
    my %hash = map { $_->[0] => $_->[1] } @$opt_list;
    return \%hash;
  }
  
  #pod =head1 EXPORTS
  #pod
  #pod Both C<mkopt> and C<mkopt_hash> may be exported on request.
  #pod
  #pod =cut
  
  BEGIN {
    *import = Sub::Install::exporter {
      exports => [qw(mkopt mkopt_hash)],
    };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Data::OptList - parse and validate simple name/value option pairs
  
  =head1 VERSION
  
  version 0.110
  
  =head1 SYNOPSIS
  
    use Data::OptList;
  
    my $options = Data::OptList::mkopt([
      qw(key1 key2 key3 key4),
      key5 => { ... },
      key6 => [ ... ],
      key7 => sub { ... },
      key8 => { ... },
      key8 => [ ... ],
    ]);
  
  ...is the same thing, more or less, as:
  
    my $options = [
      [ key1 => undef,        ],
      [ key2 => undef,        ],
      [ key3 => undef,        ],
      [ key4 => undef,        ],
      [ key5 => { ... },      ],
      [ key6 => [ ... ],      ],
      [ key7 => sub { ... },  ],
      [ key8 => { ... },      ],
      [ key8 => [ ... ],      ],
    ]);
  
  =head1 DESCRIPTION
  
  Hashes are great for storing named data, but if you want more than one entry
  for a name, you have to use a list of pairs.  Even then, this is really boring
  to write:
  
    $values = [
      foo => undef,
      bar => undef,
      baz => undef,
      xyz => { ... },
    ];
  
  Just look at all those undefs!  Don't worry, we can get rid of those:
  
    $values = [
      map { $_ => undef } qw(foo bar baz),
      xyz => { ... },
    ];
  
  Aaaauuugh!  We've saved a little typing, but now it requires thought to read,
  and thinking is even worse than typing... and it's got a bug!  It looked right,
  didn't it?  Well, the C<< xyz => { ... } >> gets consumed by the map, and we
  don't get the data we wanted.
  
  With Data::OptList, you can do this instead:
  
    $values = Data::OptList::mkopt([
      qw(foo bar baz),
      xyz => { ... },
    ]);
  
  This works by assuming that any defined scalar is a name and any reference
  following a name is its value.
  
  =head1 FUNCTIONS
  
  =head2 mkopt
  
    my $opt_list = Data::OptList::mkopt($input, \%arg);
  
  Valid arguments are:
  
    moniker        - a word used in errors to describe the opt list; encouraged
    require_unique - if true, no name may appear more than once
    must_be        - types to which opt list values are limited (described below)
    name_test      - a coderef used to test whether a value can be a name
                     (described below, but you probably don't want this)
  
  This produces an array of arrays; the inner arrays are name/value pairs.
  Values will be either "undef" or a reference.
  
  Positional parameters may be used for compatibility with the old C<mkopt>
  interface:
  
    my $opt_list = Data::OptList::mkopt($input, $moniker, $req_uni, $must_be);
  
  Valid values for C<$input>:
  
   undef    -> []
   hashref  -> [ [ key1 => value1 ] ... ] # non-ref values become undef
   arrayref -> every name followed by a non-name becomes a pair: [ name => ref ]
               every name followed by undef becomes a pair: [ name => undef ]
               otherwise, it becomes [ name => undef ] like so:
               [ "a", "b", [ 1, 2 ] ] -> [ [ a => undef ], [ b => [ 1, 2 ] ] ]
  
  By default, a I<name> is any defined non-reference.  The C<name_test> parameter
  can be a code ref that tests whether the argument passed it is a name or not.
  This should be used rarely.  Interactions between C<require_unique> and
  C<name_test> are not yet particularly elegant, as C<require_unique> just tests
  string equality.  B<This may change.>
  
  The C<must_be> parameter is either a scalar or array of scalars; it defines
  what kind(s) of refs may be values.  If an invalid value is found, an exception
  is thrown.  If no value is passed for this argument, any reference is valid.
  If C<must_be> specifies that values must be CODE, HASH, ARRAY, or SCALAR, then
  Params::Util is used to check whether the given value can provide that
  interface.  Otherwise, it checks that the given value is an object of the kind.
  
  In other words:
  
    [ qw(SCALAR HASH Object::Known) ]
  
  Means:
  
    _SCALAR0($value) or _HASH($value) or _INSTANCE($value, 'Object::Known')
  
  =head2 mkopt_hash
  
    my $opt_hash = Data::OptList::mkopt_hash($input, $moniker, $must_be);
  
  Given valid C<L</mkopt>> input, this routine returns a reference to a hash.  It
  will throw an exception if any name has more than one value.
  
  =head1 EXPORTS
  
  Both C<mkopt> and C<mkopt_hash> may be exported on request.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Olivier Mengué Ricardo SIGNES
  
  =over 4
  
  =item *
  
  Olivier Mengué <dolmen@cpan.org>
  
  =item *
  
  Ricardo SIGNES <rjbs@codesimply.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DATA_OPTLIST

$fatpacked{"DateTime/Locale.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATETIME_LOCALE';
  package DateTime::Locale;
  
  use 5.008004;
  
  use strict;
  use warnings;
  use namespace::autoclean;
  
  our $VERSION = '1.22';
  
  use DateTime::Locale::Data;
  use DateTime::Locale::FromData;
  use DateTime::Locale::Util qw( parse_locale_code );
  use Params::ValidationCompiler 0.13 qw( validation_for );
  use Specio::Library::String;
  
  my %Class;
  my %DataForCode;
  my %NameToCode;
  my %NativeNameToCode;
  my %UserDefinedAlias;
  
  my %LoadCache;
  
  sub register {
      my $class = shift;
  
      %LoadCache = ();
  
      if ( ref $_[0] ) {
          $class->_register(%$_) foreach @_;
      }
      else {
          $class->_register(@_);
      }
  }
  
  sub _register {
      shift;
      my %p = @_;
  
      my $id = $p{id};
  
      die q{'\@' or '=' are not allowed in locale ids}
          if $id =~ /[\@=]/;
  
      die
          "You cannot replace an existing locale ('$id') unless you also specify the 'replace' parameter as true\n"
          if !delete $p{replace} && exists $DataForCode{$id};
  
      $p{native_language} = $p{en_language}
          unless exists $p{native_language};
  
      my @en_pieces;
      my @native_pieces;
      foreach my $p (qw( language script territory variant )) {
          push @en_pieces,     $p{"en_$p"}     if exists $p{"en_$p"};
          push @native_pieces, $p{"native_$p"} if exists $p{"native_$p"};
      }
  
      $p{en_complete_name}     = join q{ }, @en_pieces;
      $p{native_complete_name} = join q{ }, @native_pieces;
  
      $id =~ s/_/-/g;
  
      $DataForCode{$id} = \%p;
  
      $NameToCode{ $p{en_complete_name} }           = $id;
      $NativeNameToCode{ $p{native_complete_name} } = $id;
  
      $Class{$id} = $p{class} if defined exists $p{class};
  }
  
  sub register_from_data {
      shift;
  
      %LoadCache = ();
  
      my %p = ref $_[0] ? %{ $_[0] } : @_;
  
      my $code = $p{code};
  
      die q{'\@' or '=' are not allowed in locale codes}
          if $code =~ /[\@=]/;
  
      $code =~ s/_/-/g;
  
      DateTime::Locale::Data::add_locale( $code, \%p );
      return $LoadCache{$code} = DateTime::Locale::FromData->new( \%p );
  }
  
  sub add_aliases {
      shift;
  
      %LoadCache = ();
  
      my $aliases = ref $_[0] ? $_[0] : {@_};
  
      for my $alias ( keys %{$aliases} ) {
          my $code = $aliases->{$alias};
  
          die q{Can't alias an id to itself}
              if $alias eq $code;
  
          # check for overwrite?
  
          my %seen = ( $alias => 1, $code => 1 );
          my $copy = $code;
          while ( $copy = $UserDefinedAlias{$copy} ) {
              die
                  "Creating an alias from $alias to $code would create a loop.\n"
                  if $seen{$copy};
  
              $seen{$copy} = 1;
          }
  
          $UserDefinedAlias{$alias} = $code;
      }
  }
  
  sub remove_alias {
      shift;
  
      %LoadCache = ();
  
      my $alias = shift;
  
      return delete $UserDefinedAlias{$alias};
  }
  
  # deprecated
  sub ids {
      shift->codes;
  }
  
  ## no critic (Variables::ProhibitPackageVars)
  sub codes {
      wantarray
          ? keys %DateTime::Locale::Data::Codes
          : [ keys %DateTime::Locale::Data::Codes ];
  }
  
  sub names {
      wantarray
          ? keys %DateTime::Locale::Data::Names
          : [ keys %DateTime::Locale::Data::Names ];
  }
  
  sub native_names {
      wantarray
          ? keys %DateTime::Locale::Data::NativeNames
          : [ keys %DateTime::Locale::Data::NativeNames ];
  }
  
  # These are hard-coded for backwards comaptibility with the DateTime::Language
  # code.
  my %DateTimeLanguageAliases = (
  
      #    'Afar'      => 'aa',
      'Amharic'   => 'am-ET',
      'Austrian'  => 'de-AT',
      'Brazilian' => 'pt-BR',
      'Czech'     => 'cs-CZ',
      'Danish'    => 'da-DK',
      'Dutch'     => 'nl-NL',
      'English'   => 'en-US',
      'French'    => 'fr-FR',
  
      #      'Gedeo'             => undef, # XXX
      'German'    => 'de-DE',
      'Italian'   => 'it-IT',
      'Norwegian' => 'no-NO',
      'Oromo'     => 'om-ET',    # Maybe om-KE or plain om ?
      'Portugese' => 'pt-PT',
  
      #    'Sidama'            => 'sid',
      'Somali'  => 'so-SO',
      'Spanish' => 'es-ES',
      'Swedish' => 'sv-SE',
  
      #    'Tigre'             => 'tig',
      'TigrinyaEthiopian' => 'ti-ET',
      'TigrinyaEritrean'  => 'ti-ER',
  );
  
  my %POSIXAliases = (
      C     => 'en-US-POSIX',
      POSIX => 'en-US-POSIX',
  );
  
  {
      my $validator = validation_for(
          name             => '_check_load_params',
          name_is_optional => 1,
          params           => [
              { type => t('NonEmptyStr') },
          ],
      );
  
      sub load {
          my $class = shift;
          my ($code) = $validator->(@_);
  
          # We used to use underscores in codes instead of dashes. We want to
          # support both indefinitely.
          $code =~ tr/_/-/;
  
          # Strip off charset for LC_* codes : en_GB.UTF-8 etc
          $code =~ s/\..*$//;
  
          return $LoadCache{$code} if exists $LoadCache{$code};
  
          while ( exists $UserDefinedAlias{$code} ) {
              $code = $UserDefinedAlias{$code};
          }
  
          $code = $DateTimeLanguageAliases{$code}
              if exists $DateTimeLanguageAliases{$code};
          $code = $POSIXAliases{$code} if exists $POSIXAliases{$code};
          $code = $DateTime::Locale::Data::ISO639Aliases{$code}
              if exists $DateTime::Locale::Data::ISO639Aliases{$code};
  
          if ( exists $DateTime::Locale::Data::Codes{$code} ) {
              return $class->_locale_object_for($code);
          }
  
          if ( exists $DateTime::Locale::Data::Names{$code} ) {
              return $class->_locale_object_for(
                  $DateTime::Locale::Data::Names{$code} );
          }
  
          if ( exists $DateTime::Locale::Data::NativeNames{$code} ) {
              return $class->_locale_object_for(
                  $DateTime::Locale::Data::NativeNames{$code} );
          }
  
          if ( my $locale = $class->_registered_locale_for($code) ) {
              return $locale;
          }
  
          if ( my $guessed = $class->_guess_code($code) ) {
              return $class->_locale_object_for($guessed);
          }
  
          die "Invalid locale code or name: $code\n";
      }
  }
  
  sub _guess_code {
      shift;
      my $code = shift;
  
      my %codes = parse_locale_code($code);
  
      my @guesses;
  
      if ( $codes{script} ) {
          my $guess = join q{-}, $codes{language}, $codes{script};
  
          push @guesses, $guess;
  
          $guess .= q{-} . $codes{territory} if defined $codes{territory};
  
          # version with script comes first
          unshift @guesses, $guess;
      }
  
      if ( $codes{variant} ) {
          push @guesses, join q{-}, $codes{language}, $codes{territory},
              $codes{variant};
      }
  
      if ( $codes{territory} ) {
          push @guesses, join q{-}, $codes{language}, $codes{territory};
      }
  
      push @guesses, $codes{language};
  
      for my $code (@guesses) {
          return $code
              if exists $DateTime::Locale::Data::Codes{$code}
              || exists $DateTime::Locale::Data::Names{$code};
      }
  }
  
  sub _locale_object_for {
      shift;
      my $code = shift;
  
      my $data = DateTime::Locale::Data::locale_data($code)
          or return;
  
      # We want to make a copy of the data just in case ...
      return $LoadCache{$code} = DateTime::Locale::FromData->new( \%{$data} );
  }
  
  sub _registered_locale_for {
      my $class = shift;
      my $code  = shift;
  
      # Custom locale registered by user
      if ( $Class{$code} ) {
          return $LoadCache{$code}
              = $class->_load_class_from_code( $code, $Class{$code} );
      }
  
      if ( $DataForCode{$code} ) {
          return $LoadCache{$code} = $class->_load_class_from_code($code);
      }
  
      if ( $NameToCode{$code} ) {
          return $LoadCache{$code}
              = $class->_load_class_from_code( $NameToCode{$code} );
      }
  
      if ( $NativeNameToCode{$code} ) {
          return $LoadCache{$code}
              = $class->_load_class_from_code( $NativeNameToCode{$code} );
      }
  }
  
  sub _load_class_from_code {
      my $class      = shift;
      my $code       = shift;
      my $real_class = shift;
  
      # We want the first alias for which there is data, even if it has
      # no corresponding .pm file.  There may be multiple levels of
      # alias to go through.
      my $data_code = $code;
      while ( exists $UserDefinedAlias{$data_code}
          && !exists $DataForCode{$data_code} ) {
  
          $data_code = $UserDefinedAlias{$data_code};
      }
  
      ( my $underscore_code = $data_code ) =~ s/-/_/g;
      $real_class ||= "DateTime::Locale::$underscore_code";
  
      unless ( $real_class->can('new') ) {
          ## no critic (BuiltinFunctions::ProhibitStringyEval, ErrorHandling::RequireCheckingReturnValueOfEval)
          eval "require $real_class";
          die $@ if $@;
          ## use critic
      }
  
      my $locale = $real_class->new(
          %{ $DataForCode{$data_code} },
          code => $code,
      );
  
      if ( $locale->can('cldr_version') ) {
          my $object_version = $locale->cldr_version;
  
          if ( $object_version ne $DateTime::Locale::Data::CLDRVersion ) {
              warn
                  "Loaded $real_class, which is from an older version ($object_version)"
                  . ' of the CLDR database than this installation of'
                  . " DateTime::Locale ($DateTime::Locale::Data::CLDRVersion).\n";
          }
      }
  
      return $locale;
  }
  ## use critic
  
  1;
  
  # ABSTRACT: Localization support for DateTime.pm
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  DateTime::Locale - Localization support for DateTime.pm
  
  =head1 VERSION
  
  version 1.22
  
  =head1 SYNOPSIS
  
    use DateTime::Locale;
  
    my $loc = DateTime::Locale->load('en-GB');
  
    print $loc->native_name, "\n", $loc->datetime_format_long, "\n";
  
    # but mostly just things like ...
  
    my $dt = DateTime->now( locale => 'fr' );
    print "Aujourd'hui le mois est " . $dt->month_name, "\n";
  
  =head1 DESCRIPTION
  
  DateTime::Locale is primarily a factory for the various locale subclasses. It
  also provides some functions for getting information on all the available
  locales.
  
  If you want to know what methods are available for locale objects, then please
  read the C<DateTime::Locale::FromData> documentation.
  
  =head1 USAGE
  
  This module provides the following class methods:
  
  =head2 DateTime::Locale->load( $locale_code | $locale_name )
  
  Returns the locale object for the specified locale code or name - see the
  C<DateTime::Locale::Catalog> documentation for the list of available codes and
  names. The name provided may be either the English or native name.
  
  If the requested locale is not found, a fallback search takes place to
  find a suitable replacement.
  
  The fallback search order is:
  
    {language}-{script}-{territory}
    {language}-{script}
    {language}-{territory}-{variant}
    {language}-{territory}
    {language}
  
  Eg. For the locale code C<es-XX-UNKNOWN> the fallback search would be:
  
    es-XX-UNKNOWN   # Fails - no such locale
    es-XX           # Fails - no such locale
    es              # Found - the es locale is returned as the
                    # closest match to the requested id
  
  Eg. For the locale code C<es-Latn-XX> the fallback search would be:
  
    es-Latn-XX      # Fails - no such locale
    es-Latn         # Fails - no such locale
    es-XX           # Fails - no such locale
    es              # Found - the es locale is returned as the
                    # closest match to the requested id
  
  If no suitable replacement is found, then an exception is thrown.
  
  The loaded locale is cached, so that B<locale objects may be
  singletons>. Calling C<< DateTime::Locale->register_from_data >>, C<<
  DateTime::Locale->add_aliases >>, or C<< DateTime::Locale->remove_alias >>
  clears the cache.
  
  =head2 DateTime::Locale->codes
  
    my @codes = DateTime::Locale->codes;
    my $codes = DateTime::Locale->codes;
  
  Returns an unsorted list of the available locale codes, or an array reference if
  called in a scalar context. This list does not include aliases.
  
  =head2 DateTime::Locale->names
  
    my @names = DateTime::Locale->names;
    my $names = DateTime::Locale->names;
  
  Returns an unsorted list of the available locale names in English, or an array
  reference if called in a scalar context.
  
  =head2 DateTime::Locale->native_names
  
    my @names = DateTime::Locale->native_names;
    my $names = DateTime::Locale->native_names;
  
  Returns an unsorted list of the available locale names in their native
  language, or an array reference if called in a scalar context. All native
  names use UTF-8 as appropriate.
  
  =head2 DateTime::Locale->register_from_data( $locale_data )
  
  This method allows you to register a custom locale. The data for the locale is
  specified as a hash (or hashref) where the keys match the method names given
  in C<DateTime::Locale::FromData>.
  
  If you just want to make some small changes on top of an existing locale you
  can get that locale's data by calling C<< $locale->locale_data >>.
  
  Here is an example of making a custom locale based off of C<en-US>:
  
    my $locale = DateTime::Locale->load('en-US');
    my %data   = $locale->locale_data;
    $data{code}               = 'en-US-CUSTOM';
    $data{time_format_medium} = 'HH:mm:ss';
  
    DateTime::Locale->register_from_data(%data);
  
    # Prints 18:24:38
    say DateTime->now( locale => 'en-US-CUSTOM' )->strftime('%X');
  
    # Prints 6:24:38 PM
    say DateTime->now( locale => 'en-US' )->strftime('%X');
  
  The keys that should be present in the hash are the same as the accessor
  methods provided by L<DateTime::Locale::FromData>, except for the following:
  
  =over 4
  
  =item The C<*_code> methods
  
  While you should provide a C<code> key, the other methods like
  C<language_code> and C<script_code> are determined by parsing the code.
  
  =item All C<id> returning methods
  
  These are aliases for the corresponding C<*code> methods.
  
  =item C<prefers_24_hour_time>
  
  This is determined by looking at the short time format to see how it formats
  hours,
  
  =item C<date_format_default> and C<time_format_default>
  
  These are the corresponding medium formats.
  
  =item C<datetime_format> and C<datetime_format_default>
  
  This is the same as the medium format.
  
  =item C<date_formats> and C<time_formats>
  
  These are calculated as needed.
  
  =item C<available_formats>
  
  This should be provided as a hashref where the keys are things like C<Gy> or
  C<MMMEd> and the values are an actual format like C<"y G"> or C<"E, MMM d">.
  
  =item C<locale_data>
  
  This is everything you pass in.
  
  =back
  
  =head1 LOADING LOCALES IN A PRE-FORKING SYSTEM
  
  If you are running an application that does pre-forking (for example with
  Starman), then you should try to load all the locales that you'll need in the
  parent process. Locales are loaded on-demand, so loading them once in each
  child will waste memory that could otherwise be shared.
  
  =head1 CLDR DATA BUGS
  
  Please be aware that all locale data has been generated from the CLDR (Common
  Locale Data Repository) project locales data). The data is incomplete, and may
  contain errors in some locales.
  
  When reporting errors in data, please check the primary data sources first,
  then where necessary report errors directly to the primary source via the CLDR
  bug report system. See http://unicode.org/cldr/filing_bug_reports.html for
  details.
  
  Once these errors have been confirmed, please forward the error report and
  corrections to the DateTime mailing list, datetime@perl.org.
  
  =head1 AUTHOR EMERITUS
  
  Richard Evans wrote the first version of DateTime::Locale, including the tools
  to extract the CLDR data.
  
  =head1 SEE ALSO
  
  L<DateTime::Locale::Base>
  
  datetime@perl.org mailing list
  
  http://datetime.perl.org/
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/DateTime-Locale/issues>.
  
  There is a mailing list available for users of this distribution,
  L<mailto:datetime@perl.org>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for DateTime-Locale can be found at L<https://github.com/houseabsolute/DateTime-Locale>.
  
  =head1 DONATIONS
  
  If you'd like to thank me for the work I've done on this module, please
  consider making a "donation" to me via PayPal. I spend a lot of free time
  creating free software, and would appreciate any support you'd care to offer.
  
  Please note that B<I am not suggesting that you must do this> in order for me
  to continue working on this particular software. I will continue to do so,
  inasmuch as I have in the past, for as long as it interests me.
  
  Similarly, a donation made in this way will probably not make me work on this
  software much more, unless I get so many donations that I can consider working
  on free software full time (let's all have a chuckle at that together).
  
  To donate, log into PayPal and send money to autarch@urth.org, or use the
  button at L<http://www.urth.org/~autarch/fs-donation.html>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Karen Etheridge Mohammad S Anwar Ryley Breiddal Sergey Leschenko yasu47b
  
  =over 4
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Mohammad S Anwar <mohammad.anwar@yahoo.com>
  
  =item *
  
  Ryley Breiddal <rbreiddal@presinet.com>
  
  =item *
  
  Sergey Leschenko <Sergey.Leschenko@portaone.com>
  
  =item *
  
  yasu47b <nakayamayasuhiro1986@gmail.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2003 - 2018 by Dave Rolsky.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
DATETIME_LOCALE

$fatpacked{"DateTime/Locale/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATETIME_LOCALE_BASE';
  package DateTime::Locale::Base;
  
  use strict;
  use warnings;
  use namespace::autoclean;
  
  our $VERSION = '1.22';
  
  use Carp qw( carp );
  use DateTime::Locale;
  use List::Util 1.45 ();
  use Params::ValidationCompiler 0.13 qw( validation_for );
  use Specio::Declare;
  
  BEGIN {
      foreach my $field (
          qw( id en_complete_name native_complete_name
          en_language en_script en_territory en_variant
          native_language native_script native_territory native_variant
          )
      ) {
  
          # remove leading 'en_' for method name
          ( my $meth_name = $field ) =~ s/^en_//;
  
          # also remove 'complete_'
          $meth_name =~ s/complete_//;
  
          no strict 'refs';
          *{$meth_name} = sub { $_[0]->{$field} };
      }
  }
  
  sub new {
      my $class = shift;
  
      # By making the default format lengths part of the object's hash
      # key, it allows them to be settable.
      return bless {
          @_,
          default_date_format_length => 'long',
          default_time_format_length => 'long',
      }, $class;
  }
  
  sub language_id  { ( DateTime::Locale::_parse_id( $_[0]->id ) )[0] }
  sub script_id    { ( DateTime::Locale::_parse_id( $_[0]->id ) )[1] }
  sub territory_id { ( DateTime::Locale::_parse_id( $_[0]->id ) )[2] }
  sub variant_id   { ( DateTime::Locale::_parse_id( $_[0]->id ) )[3] }
  
  my @FormatLengths = qw( short medium long full );
  
  sub date_format_default {
      my $meth = 'date_format_' . $_[0]->default_date_format_length();
      $_[0]->$meth();
  }
  
  sub date_formats {
      return {
          map {
              my $meth = 'date_format_' . $_;
              $_ => $_[0]->$meth()
          } @FormatLengths
      };
  }
  
  sub time_format_default {
      my $meth = 'time_format_' . $_[0]->default_time_format_length();
      $_[0]->$meth();
  }
  
  sub time_formats {
      return {
          map {
              my $meth = 'time_format_' . $_;
              $_ => $_[0]->$meth()
          } @FormatLengths
      };
  }
  
  sub format_for {
      my $self = shift;
      my $for  = shift;
  
      my $meth = '_format_for_' . $for;
  
      return unless $self->can($meth);
  
      return $self->$meth();
  }
  
  sub available_formats {
      my $self = shift;
  
      # The various parens seem to be necessary to force uniq() to see
      # the caller's list context. Go figure.
      my @uniq
          = List::Util::uniq( map { keys %{ $_->_available_formats() || {} } }
              _self_and_super_path( ref $self ) );
  
      # Doing the sort in the same expression doesn't work under 5.6.x.
      return sort @uniq;
  }
  
  # Copied wholesale from Class::ISA, because said module warns as deprecated
  # with perl 5.11.0+, which is kind of annoying.
  sub _self_and_super_path {
  
      # Assumption: searching is depth-first.
      # Assumption: '' (empty string) can't be a class package name.
      # Note: 'UNIVERSAL' is not given any special treatment.
      return () unless @_;
  
      my @out = ();
  
      my @in_stack = ( $_[0] );
      my %seen = ( $_[0] => 1 );
  
      my $current;
      while (@in_stack) {
          next unless defined( $current = shift @in_stack ) && length($current);
          push @out, $current;
          no strict 'refs';
          unshift @in_stack, map {
              my $c = $_;    # copy, to avoid being destructive
              substr( $c, 0, 2 ) = "main::" if substr( $c, 0, 2 ) eq '::';
  
              # Canonize the :: -> main::, ::foo -> main::foo thing.
              # Should I ever canonize the Foo'Bar = Foo::Bar thing?
              $seen{$c}++ ? () : $c;
          } @{"$current\::ISA"};
  
          # I.e., if this class has any parents (at least, ones I've never seen
          # before), push them, in order, onto the stack of classes I need to
          # explore.
      }
  
      return @out;
  }
  
  # Just needed for the above method.
  sub _available_formats { }
  
  sub default_date_format_length { $_[0]->{default_date_format_length} }
  
  my $length = enum( values => [qw( full long medium short )] );
  my $validator = validation_for(
      name             => '_check_length_parameter',
      name_is_optional => 1,
      params           => [ { type => $length } ],
  );
  
  sub set_default_date_format_length {
      my $self = shift;
      my ($l) = $validator->(@_);
  
      $self->{default_date_format_length} = lc $l;
  }
  
  sub default_time_format_length { $_[0]->{default_time_format_length} }
  
  sub set_default_time_format_length {
      my $self = shift;
      my ($l) = $validator->(@_);
  
      $self->{default_time_format_length} = lc $l;
  }
  
  for my $length (qw( full long medium short )) {
      my $key = 'datetime_format_' . $length;
  
      my $sub = sub {
          my $self = shift;
  
          return $self->{$key} if exists $self->{$key};
  
          my $date_meth = 'date_format_' . $length;
          my $time_meth = 'time_format_' . $length;
  
          return $self->{$key}
              = $self->_make_datetime_format( $date_meth, $time_meth );
      };
  
      no strict 'refs';
      *{$key} = $sub;
  }
  
  sub datetime_format_default {
      my $self = shift;
  
      my $date_meth = 'date_format_' . $self->default_date_format_length();
      my $time_meth = 'time_format_' . $self->default_time_format_length();
  
      return $self->_make_datetime_format( $date_meth, $time_meth );
  }
  
  sub _make_datetime_format {
      my $self      = shift;
      my $date_meth = shift;
      my $time_meth = shift;
  
      my $dt_format = $self->datetime_format();
  
      my $time = $self->$time_meth();
      my $date = $self->$date_meth();
  
      $dt_format =~ s/\{0\}/$time/g;
      $dt_format =~ s/\{1\}/$date/g;
  
      return $dt_format;
  }
  
  sub prefers_24_hour_time {
      my $self = shift;
  
      return $self->{prefers_24_hour_time}
          if exists $self->{prefers_24_hour_time};
  
      $self->{prefers_24_hour_time}
          = $self->time_format_short() =~ /h|K/ ? 0 : 1;
  }
  
  # Backwards compat for DateTime.pm version <= 0.42
  {
      my %subs = (
          month_name => sub { $_[0]->month_format_wide()->[ $_[1]->month_0 ] },
  
          month_abbreviation => sub {
              $_[0]->month_format_abbreviated()->[ $_[1]->month_0 ];
          },
          month_narrow =>
              sub { $_[0]->month_format_narrow()->[ $_[1]->month_0 ]; },
  
          month_names         => sub { $_[0]->month_format_wide() },
          month_abbreviations => sub { $_[0]->month_format_abbreviated() },
          month_narrows       => sub { $_[0]->month_format_narrow() },
  
          day_name =>
              sub { $_[0]->day_format_wide()->[ $_[1]->day_of_week_0 ] },
  
          day_abbreviation => sub {
              $_[0]->day_format_abbreviated()->[ $_[1]->day_of_week_0 ];
          },
          day_narrow =>
              sub { $_[0]->day_format_narrow()->[ $_[1]->day_of_week_0 ]; },
  
          day_names         => sub { $_[0]->day_format_wide() },
          day_abbreviations => sub { $_[0]->day_format_abbreviated() },
          day_narrows       => sub { $_[0]->day_format_narrow() },
  
          quarter_name =>
              sub { $_[0]->quarter_format_wide()->[ $_[1]->quarter - 1 ] },
  
          quarter_abbreviation => sub {
              $_[0]->quarter_format_abbreviated()->[ $_[1]->quarter - 1 ];
          },
          quarter_narrow =>
              sub { $_[0]->quarter_format_narrow()->[ $_[1]->quarter - 1 ] },
  
          quarter_names         => sub { $_[0]->quarter_format_wide() },
          quarter_abbreviations => sub { $_[0]->quarter_format_abbreviated() },
  
          am_pm =>
              sub { $_[0]->am_pm_abbreviated()->[ $_[1]->hour < 12 ? 0 : 1 ] },
          am_pms => sub { $_[0]->am_pm_abbreviated() },
  
          era_name => sub { $_[0]->era_wide()->[ $_[1]->ce_year < 0 ? 0 : 1 ] },
  
          era_abbreviation => sub {
              $_[0]->era_abbreviated()->[ $_[1]->ce_year < 0 ? 0 : 1 ];
          },
          era_narrow =>
              sub { $_[0]->era_narrow()->[ $_[1]->ce_year < 0 ? 0 : 1 ] },
  
          era_names         => sub { $_[0]->era_wide() },
          era_abbreviations => sub { $_[0]->era_abbreviated() },
  
          # ancient backwards compat
          era  => sub { $_[0]->era_abbreviation },
          eras => sub { $_[0]->era_abbreviations },
  
          date_before_time => sub {
              my $self = shift;
  
              my $dt_format = $self->datetime_format();
  
              return $dt_format =~ /\{1\}.*\{0\}/ ? 1 : 0;
          },
  
          date_parts_order => sub {
              my $self = shift;
  
              my $short = $self->date_format_short();
  
              $short =~ tr{dmyDMY}{}cd;
              $short =~ tr{dmyDMY}{dmydmy}s;
  
              return $short;
          },
  
          full_date_format => sub {
              $_[0]->_convert_to_strftime( $_[0]->date_format_full() );
          },
  
          long_date_format => sub {
              $_[0]->_convert_to_strftime( $_[0]->date_format_long() );
          },
  
          medium_date_format => sub {
              $_[0]->_convert_to_strftime( $_[0]->date_format_medium() );
          },
  
          short_date_format => sub {
              $_[0]->_convert_to_strftime( $_[0]->date_format_short() );
          },
  
          default_date_format => sub {
              $_[0]->_convert_to_strftime( $_[0]->date_format_default() );
          },
  
          full_time_format => sub {
              $_[0]->_convert_to_strftime( $_[0]->time_format_full() );
          },
  
          long_time_format => sub {
              $_[0]->_convert_to_strftime( $_[0]->time_format_long() );
          },
  
          medium_time_format => sub {
              $_[0]->_convert_to_strftime( $_[0]->time_format_medium() );
          },
  
          short_time_format => sub {
              $_[0]->_convert_to_strftime( $_[0]->time_format_short() );
          },
  
          default_time_format => sub {
              $_[0]->_convert_to_strftime( $_[0]->time_format_default() );
          },
  
          full_datetime_format => sub {
              $_[0]->_convert_to_strftime( $_[0]->datetime_format_full() );
          },
  
          long_datetime_format => sub {
              $_[0]->_convert_to_strftime( $_[0]->datetime_format_long() );
          },
  
          medium_datetime_format => sub {
              $_[0]->_convert_to_strftime( $_[0]->datetime_format_medium() );
          },
  
          short_datetime_format => sub {
              $_[0]->_convert_to_strftime( $_[0]->datetime_format_short() );
          },
  
          default_datetime_format => sub {
              $_[0]->_convert_to_strftime( $_[0]->datetime_format_default() );
          },
      );
  
      for my $name ( keys %subs ) {
          my $real_sub = $subs{$name};
  
          my $sub = sub {
              carp
                  "The $name method in DateTime::Locale::Base has been deprecated. Please see the DateTime::Locale distribution's Changes file for details";
              return shift->$real_sub(@_);
          };
  
          no strict 'refs';
          *{$name} = $sub;
      }
  }
  
  # Older versions of DateTime.pm will not pass in the $cldr_ok flag, so
  # we will give them the converted-to-strftime pattern (bugs and all).
  sub _convert_to_strftime {
      my $self    = shift;
      my $pattern = shift;
      my $cldr_ok = shift;
  
      return $pattern if $cldr_ok;
  
      return $self->{_converted_patterns}{$pattern}
          if exists $self->{_converted_patterns}{$pattern};
  
      return $self->{_converted_patterns}{$pattern}
          = $self->_cldr_to_strftime($pattern);
  }
  
  {
      my @JavaPatterns = (
          qr/G/    => '{era}',
          qr/yyyy/ => '{ce_year}',
          qr/y/    => 'y',
          qr/u/    => 'Y',
          qr/MMMM/ => 'B',
          qr/MMM/  => 'b',
          qr/MM/   => 'm',
          qr/M/    => '{month}',
          qr/dd/   => 'd',
          qr/d/    => '{day}',
          qr/hh/   => 'l',
          qr/h/    => '{hour_12}',
          qr/HH/   => 'H',
          qr/H/    => '{hour}',
          qr/mm/   => 'M',
          qr/m/    => '{minute}',
          qr/ss/   => 'S',
          qr/s/    => '{second}',
          qr/S/    => 'N',
          qr/EEEE/ => 'A',
          qr/E/    => 'a',
          qr/D/    => 'j',
          qr/F/    => '{weekday_of_month}',
          qr/w/    => 'V',
          qr/W/    => '{week_month}',
          qr/a/    => 'p',
          qr/k/    => '{hour_1}',
          qr/K/    => '{hour_12_0}',
          qr/z/    => '{time_zone_long_name}',
      );
  
      sub _cldr_to_strftime {
          shift;
          my $simple = shift;
  
          $simple
              =~ s/(G+|y+|u+|M+|d+|h+|H+|m+|s+|S+|E+|D+|F+|w+|W+|a+|k+|K+|z+)|'((?:[^']|'')*)'/
                  $2 ? _stringify($2) : $1 ? _convert($1) : "'"/eg;
  
          return $simple;
      }
  
      sub _convert {
          my $simple = shift;
  
          for ( my $x = 0; $x < @JavaPatterns; $x += 2 ) {
              return '%' . $JavaPatterns[ $x + 1 ]
                  if $simple =~ /$JavaPatterns[$x]/;
          }
  
          die "**Dont know $simple***";
      }
  
      sub _stringify {
          my $string = shift;
  
          $string =~ s/%(?:[^%])/%%/g;
          $string =~ s/\'\'/\'/g;
  
          return $string;
      }
  }
  
  # end backwards compat
  
  sub STORABLE_freeze {
      my $self    = shift;
      my $cloning = shift;
  
      return if $cloning;
  
      return $self->id();
  }
  
  sub STORABLE_thaw {
      my $self = shift;
      shift;
      my $serialized = shift;
  
      my $obj = DateTime::Locale->load($serialized);
  
      %$self = %$obj;
  
      return $self;
  }
  
  1;
  
  # ABSTRACT: Base class for individual locale objects
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  DateTime::Locale::Base - Base class for individual locale objects
  
  =head1 VERSION
  
  version 1.22
  
  =head1 SYNOPSIS
  
    use base 'DateTime::Locale::Base';
  
  =head1 DESCRIPTION
  
  B<This module is no longer used by the code in the distribution.> It is still
  included for the sake of any code out in the wild that may subclass this
  class. This class will be removed in a future release.
  
  =head1 DEFAULT FORMATS
  
  Each locale has a set of four default date and time formats.  They are
  distinguished by length, and are called "full", "long", "medium", and
  "short". Each locale may have a different default length which it uses
  when its C<< $locale->date_format_default() >>, C<<
  $locale->time_format_default() >>, or C<<
  $locale->datetime_format_default() >> methods are called.
  
  This can be changed by calling the C<<
  $locale->set_default_date_format() >> or C<<
  $locale->set_default_time_format() >> methods.  These methods accept a
  string which must be one of "full", "long", "medium", or "short".
  
  =head1 NAME FORMS
  
  Most names come in a number of variations. First, they may vary based
  on length, with wide, abbreviated, and narrow forms. The wide form is
  typically the full name, while the narrow form is often a single
  character. The narrow forms may not be unique. For example, "T" may be
  used for Tuesday and Thursday in the English narrow forms.
  
  Many names also distinguish between "format" and "stand-alone" forms
  of a pattern. The format pattern is used when the thing in question is
  being placed into a larger string. The stand-alone form is used when
  displaying that item by itself, for example in a calendar.
  
  =head1 METHODS
  
  All locales provide the following methods:
  
  =over 4
  
  =item * $locale->id()
  
  The locale's id.
  
  =item * $locale->language_id()
  
  The language portion of the id.
  
  =item * $locale->script_id()
  
  The script portion of the id, if any.
  
  =item * $locale->territory_id()
  
  The territory portion of the id, if any.
  
  =item * $locale->variant_id()
  
  The variant portion of the id, if any.
  
  =item * $locale->name()
  
  The full name for the locale in English.
  
  =item * $locale->language()
  
  The language name for the locale in English.
  
  =item * $locale->script()
  
  The script name for the locale in English, if any.
  
  =item * $locale->territory()
  
  The territory name for the locale in English, if any.
  
  =item * $locale->variant()
  
  The variant name for the locale in English, if any.
  
  =item * $locale->native_name()
  
  The full name for the locale in its native language, if any.
  
  =item * $locale->native_language()
  
  The language name for the locale in its native language, if any.
  
  =item * $locale->native_script()
  
  The script name for the locale in its native language, if any.
  
  =item * $locale->native_territory()
  
  The territory name for the locale in its native language, if any.
  
  =item * $locale->native_variant()
  
  The variant name for the locale in its native language, if any.
  
  =item * $locale->month_format_wide()
  
  Returns an array reference containing the wide format names of the
  months, with January as the first month.
  
  =item * $locale->month_format_abbreviated()
  
  Returns an array reference containing the abbreviated format names of
  the months, with January as the first month.
  
  =item * $locale->month_format_narrow()
  
  Returns an array reference containing the narrow format names of the
  months, with January as the first month.
  
  =item * $locale->month_stand_alone_wide()
  
  Returns an array reference containing the wide stand-alone names of
  the months, with January as the first month.
  
  =item * $locale->month_stand_alone_abbreviated()
  
  Returns an array reference containing the abbreviated stand-alone
  names of the months, with January as the first month.
  
  =item * $locale->month_stand_alone_narrow()
  
  Returns an array reference containing the narrow stand-alone names of the
  months, with January as the first month.
  
  =item * $locale->day_format_wide()
  
  Returns an array reference containing the wide format names of the
  days, with Monday as the first day.
  
  =item * $locale->day_format_abbreviated()
  
  Returns an array reference containing the abbreviated format names of
  the days, with Monday as the first day.
  
  =item * $locale->day_format_narrow()
  
  Returns an array reference containing the narrow format names of the
  days, with Monday as the first day.
  
  =item * $locale->day_stand_alone_wide()
  
  Returns an array reference containing the wide stand-alone names of
  the days, with Monday as the first day.
  
  =item * $locale->day_stand_alone_abbreviated()
  
  Returns an array reference containing the abbreviated stand-alone
  names of the days, with Monday as the first day.
  
  =item * $locale->day_stand_alone_narrow()
  
  Returns an array reference containing the narrow stand-alone names of
  the days, with Monday as the first day.
  
  =item * $locale->quarter_format_wide()
  
  Returns an array reference containing the wide format names of the
  quarters.
  
  =item * $locale->quarter_format_abbreviated()
  
  Returns an array reference containing the abbreviated format names of
  the quarters.
  
  =item * $locale->quarter_format_narrow()
  
  Returns an array reference containing the narrow format names of the
  quarters.
  
  =item * $locale->quarter_stand_alone_wide()
  
  Returns an array reference containing the wide stand-alone names of
  the quarters.
  
  =item * $locale->quarter_stand_alone_abbreviated()
  
  Returns an array reference containing the abbreviated stand-alone
  names of the quarters.
  
  =item * $locale->quarter_stand_alone_narrow()
  
  Returns an array reference containing the narrow stand-alone names of the
  quarters.
  
  =item * $locale->era_wide()
  
  Returns an array reference containing the wide names of the eras, with
  "BCE" first.
  
  =item * $locale->era_abbreviated()
  
  Returns an array reference containing the abbreviated names of the
  eras, with "BCE" first.
  
  =item * $locale->era_narrow()
  
  Returns an array reference containing the abbreviated names of the
  eras, with "BCE" first. However, most locales do not differ between
  the narrow and abbreviated length of the era.
  
  =item * $locale->am_pm_abbreviated()
  
  Returns an array reference containing the abbreviated names of "AM"
  and "PM".
  
  =item * $locale->date_format_long()
  
  =item * $locale->date_format_full()
  
  =item * $locale->date_format_medium()
  
  =item * $locale->date_format_short()
  
  Returns the CLDR date pattern of the appropriate length.
  
  =item * $locale->date_formats()
  
  Returns a hash reference of CLDR date patterns for the date formats,
  where the keys are "full", "long", "medium", and "short".
  
  =item * $locale->time_format_long()
  
  =item * $locale->time_format_full()
  
  =item * $locale->time_format_medium()
  
  =item * $locale->time_format_short()
  
  Returns the CLDR date pattern of the appropriate length.
  
  =item * $locale->time_formats()
  
  Returns a hash reference of CLDR date patterns for the time formats,
  where the keys are "full", "long", "medium", and "short".
  
  =item * $locale->datetime_format_long()
  
  =item * $locale->datetime_format_full()
  
  =item * $locale->datetime_format_medium()
  
  =item * $locale->datetime_format_short()
  
  Returns the CLDR date pattern of the appropriate length.
  
  =item * $locale->datetime_formats()
  
  Returns a hash reference of CLDR date patterns for the datetime
  formats, where the keys are "full", "long", "medium", and "short".
  
  =item * $locale->date_format_default()
  
  =item * $locale->time_format_default()
  
  =item * $locale->datetime_format_default()
  
  Returns the default CLDR date pattern. The length of this format is
  based on the value of C<< $locale->default_date_format_length() >>
  and/or C<< $locale->default_time_format_length() >>.
  
  =item * $locale->default_date_format_length()
  
  =item * $locale->default_time_format_length()
  
  Returns the default length for the format, one of "full", "long",
  "medium", or "short".
  
  =item * $locale->set_default_date_format_length()
  
  =item * $locale->set_default_time_format_length()
  
  Sets the default length for the format. This must be one of "full",
  "long", "medium", or "short".
  
  =item * $locale->prefers_24_hour_time()
  
  Returns a boolean indicating the preferred hour format for this
  locale.
  
  =item * $locale->first_day_of_week()
  
  Returns a number from 1 to 7 indicating the I<local> first day of the week,
  with Monday being 1 and Sunday being 7. For example, for a US locale this
  returns 7.
  
  =item * $locale->available_formats()
  
  A list of format names, like "MMdd" or "yyyyMM". This should be the
  list directly supported by the subclass, not its parents.
  
  =item * $locale->format_for($key)
  
  Given a valid name, returns the CLDR date pattern for that thing, if
  one exists.
  
  =back
  
  =head1 SUPPORT
  
  See L<DateTime::Locale>.
  
  Bugs may be submitted at L<https://github.com/houseabsolute/DateTime-Locale/issues>.
  
  There is a mailing list available for users of this distribution,
  L<mailto:datetime@perl.org>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for DateTime-Locale can be found at L<https://github.com/houseabsolute/DateTime-Locale>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2003 - 2018 by Dave Rolsky.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
DATETIME_LOCALE_BASE

$fatpacked{"DateTime/Locale/Catalog.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATETIME_LOCALE_CATALOG';
  package DateTime::Locale::Catalog;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.22';
  
  1;
  
  # ABSTRACT: Provides a catalog of all valid locale names
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  DateTime::Locale::Catalog - Provides a catalog of all valid locale names
  
  =head1 VERSION
  
  version 1.22
  
  =head1 DESCRIPTION
  
  This module contains a list of all known locales.
  
  =head1 LOCALES
  
  Any method taking locale code or name arguments should use one of the values
  listed below. Codes and names are case sensitive. The code starts with the
  ISO639-1 language code, and may also include information identifying any or
  all of territory, script, or variant.
  
  Always select the closest matching locale - for example, French Canadians
  would choose C<fr-CA> over fr - and B<always> use locale codes in preference
  to names; locale codes offer greater compatibility when using localized third
  party modules.
  
  The available locales are:
  
  =begin :locales
  
  
  
  =end :locales
  
   Locale code      Locale name (in English)                    Native locale name
   ==========================================================================================================
   af               Afrikaans                                   Afrikaans
   af-NA            Afrikaans Namibia                           Afrikaans Namibië
   af-ZA            Afrikaans South Africa                      Afrikaans Suid-Afrika
   agq              Aghem                                       Aghem
   agq-CM           Aghem Cameroon                              Aghem Kàmàlûŋ
   ak               Akan                                        Akan
   ak-GH            Akan Ghana                                  Akan Gaana
   am               Amharic                                     አማርኛ
   am-ET            Amharic Ethiopia                            አማርኛ ኢትዮጵያ
   ar               Arabic                                      العربية
   ar-001           Arabic World                                العربية العالم
   ar-AE            Arabic United Arab Emirates                 العربية الإمارات العربية المتحدة
   ar-BH            Arabic Bahrain                              العربية البحرين
   ar-DJ            Arabic Djibouti                             العربية جيبوتي
   ar-DZ            Arabic Algeria                              العربية الجزائر
   ar-EG            Arabic Egypt                                العربية مصر
   ar-EH            Arabic Western Sahara                       العربية الصحراء الغربية
   ar-ER            Arabic Eritrea                              العربية إريتريا
   ar-IL            Arabic Israel                               العربية إسرائيل
   ar-IQ            Arabic Iraq                                 العربية العراق
   ar-JO            Arabic Jordan                               العربية الأردن
   ar-KM            Arabic Comoros                              العربية جزر القمر
   ar-KW            Arabic Kuwait                               العربية الكويت
   ar-LB            Arabic Lebanon                              العربية لبنان
   ar-LY            Arabic Libya                                العربية ليبيا
   ar-MA            Arabic Morocco                              العربية المغرب
   ar-MR            Arabic Mauritania                           العربية موريتانيا
   ar-OM            Arabic Oman                                 العربية عُمان
   ar-PS            Arabic Palestinian Territories              العربية الأراضي الفلسطينية
   ar-QA            Arabic Qatar                                العربية قطر
   ar-SA            Arabic Saudi Arabia                         العربية المملكة العربية السعودية
   ar-SD            Arabic Sudan                                العربية السودان
   ar-SO            Arabic Somalia                              العربية الصومال
   ar-SS            Arabic South Sudan                          العربية جنوب السودان
   ar-SY            Arabic Syria                                العربية سوريا
   ar-TD            Arabic Chad                                 العربية تشاد
   ar-TN            Arabic Tunisia                              العربية تونس
   ar-YE            Arabic Yemen                                العربية اليمن
   as               Assamese                                    অসমীয়া
   as-IN            Assamese India                              অসমীয়া ভাৰত
   asa              Asu                                         Kipare
   asa-TZ           Asu Tanzania                                Kipare Tadhania
   ast              Asturian                                    asturianu
   ast-ES           Asturian Spain                              asturianu España
   az               Azerbaijani                                 azərbaycan
   az-Cyrl          Azerbaijani Cyrillic                        азәрбајҹан Кирил
   az-Cyrl-AZ       Azerbaijani Azerbaijan Cyrillic             азәрбајҹан Азәрбајҹан Кирил
   az-Latn          Azerbaijani Latin                           azərbaycan latın
   az-Latn-AZ       Azerbaijani Azerbaijan Latin                azərbaycan Azərbaycan latın
   bas              Basaa                                       Ɓàsàa
   bas-CM           Basaa Cameroon                              Ɓàsàa Kàmɛ̀rûn
   be               Belarusian                                  беларуская
   be-BY            Belarusian Belarus                          беларуская Беларусь
   bem              Bemba                                       Ichibemba
   bem-ZM           Bemba Zambia                                Ichibemba Zambia
   bez              Bena                                        Hibena
   bez-TZ           Bena Tanzania                               Hibena Hutanzania
   bg               Bulgarian                                   български
   bg-BG            Bulgarian Bulgaria                          български България
   bm               Bambara                                     bamanakan
   bm-ML            Bambara Mali                                bamanakan Mali
   bn               Bangla                                      বাংলা
   bn-BD            Bangla Bangladesh                           বাংলা বাংলাদেশ
   bn-IN            Bangla India                                বাংলা ভারত
   bo               Tibetan                                     བོད་སྐད་
   bo-CN            Tibetan China                               བོད་སྐད་ རྒྱ་ནག
   bo-IN            Tibetan India                               བོད་སྐད་ རྒྱ་གར་
   br               Breton                                      brezhoneg
   br-FR            Breton France                               brezhoneg Frañs
   brx              Bodo                                        बड़ो
   brx-IN           Bodo India                                  बड़ो भारत
   bs               Bosnian                                     bosanski
   bs-Cyrl          Bosnian Cyrillic                            босански ћирилица
   bs-Cyrl-BA       Bosnian Bosnia & Herzegovina Cyrillic       босански Босна и Херцеговина ћирилица
   bs-Latn          Bosnian Latin                               bosanski latinica
   bs-Latn-BA       Bosnian Bosnia & Herzegovina Latin          bosanski Bosna i Hercegovina latinica
   ca               Catalan                                     català
   ca-AD            Catalan Andorra                             català Andorra
   ca-ES            Catalan Spain                               català Espanya
   ca-ES-VALENCIA   Catalan Spain Valencian                     català Espanya valencià
   ca-FR            Catalan France                              català França
   ca-IT            Catalan Italy                               català Itàlia
   ccp              Chakma                                      𑄌𑄋𑄴𑄟𑄳𑄦
   ccp-BD           Chakma Bangladesh                           𑄌𑄋𑄴𑄟𑄳𑄦 𑄝𑄁𑄣𑄘𑄬𑄌𑄴
   ccp-IN           Chakma India                                𑄌𑄋𑄴𑄟𑄳𑄦 𑄞𑄢𑄧𑄖𑄴
   ce               Chechen                                     нохчийн
   ce-RU            Chechen Russia                              нохчийн Росси
   cgg              Chiga                                       Rukiga
   cgg-UG           Chiga Uganda                                Rukiga Uganda
   chr              Cherokee                                    ᏣᎳᎩ
   chr-US           Cherokee United States                      ᏣᎳᎩ ᏌᏊ ᎢᏳᎾᎵᏍᏔᏅ ᏍᎦᏚᎩ
   ckb              Central Kurdish                             کوردیی ناوەندی
   ckb-IQ           Central Kurdish Iraq                        کوردیی ناوەندی عێراق
   ckb-IR           Central Kurdish Iran                        کوردیی ناوەندی ئێران
   cs               Czech                                       čeština
   cs-CZ            Czech Czechia                               čeština Česko
   cu               Church Slavic                               cu
   cu-RU            Church Slavic Russia                        cu RU
   cy               Welsh                                       Cymraeg
   cy-GB            Welsh United Kingdom                        Cymraeg Y Deyrnas Unedig
   da               Danish                                      dansk
   da-DK            Danish Denmark                              dansk Danmark
   da-GL            Danish Greenland                            dansk Grønland
   dav              Taita                                       Kitaita
   dav-KE           Taita Kenya                                 Kitaita Kenya
   de               German                                      Deutsch
   de-AT            German Austria                              Deutsch Österreich
   de-BE            German Belgium                              Deutsch Belgien
   de-CH            German Switzerland                          Deutsch Schweiz
   de-DE            German Germany                              Deutsch Deutschland
   de-IT            German Italy                                Deutsch Italien
   de-LI            German Liechtenstein                        Deutsch Liechtenstein
   de-LU            German Luxembourg                           Deutsch Luxemburg
   dje              Zarma                                       Zarmaciine
   dje-NE           Zarma Niger                                 Zarmaciine Nižer
   dsb              Lower Sorbian                               dolnoserbšćina
   dsb-DE           Lower Sorbian Germany                       dolnoserbšćina Nimska
   dua              Duala                                       duálá
   dua-CM           Duala Cameroon                              duálá Cameroun
   dyo              Jola-Fonyi                                  joola
   dyo-SN           Jola-Fonyi Senegal                          joola Senegal
   dz               Dzongkha                                    རྫོང་ཁ
   dz-BT            Dzongkha Bhutan                             རྫོང་ཁ འབྲུག
   ebu              Embu                                        Kĩembu
   ebu-KE           Embu Kenya                                  Kĩembu Kenya
   ee               Ewe                                         Eʋegbe
   ee-GH            Ewe Ghana                                   Eʋegbe Ghana nutome
   ee-TG            Ewe Togo                                    Eʋegbe Togo nutome
   el               Greek                                       Ελληνικά
   el-CY            Greek Cyprus                                Ελληνικά Κύπρος
   el-GR            Greek Greece                                Ελληνικά Ελλάδα
   en               English                                     English
   en-001           English World                               English World
   en-150           English Europe                              English Europe
   en-AG            English Antigua & Barbuda                   English Antigua & Barbuda
   en-AI            English Anguilla                            English Anguilla
   en-AS            English American Samoa                      English American Samoa
   en-AT            English Austria                             English Austria
   en-AU            English Australia                           English Australia
   en-BB            English Barbados                            English Barbados
   en-BE            English Belgium                             English Belgium
   en-BI            English Burundi                             English Burundi
   en-BM            English Bermuda                             English Bermuda
   en-BS            English Bahamas                             English Bahamas
   en-BW            English Botswana                            English Botswana
   en-BZ            English Belize                              English Belize
   en-CA            English Canada                              English Canada
   en-CC            English Cocos (Keeling) Islands             English Cocos (Keeling) Islands
   en-CH            English Switzerland                         English Switzerland
   en-CK            English Cook Islands                        English Cook Islands
   en-CM            English Cameroon                            English Cameroon
   en-CX            English Christmas Island                    English Christmas Island
   en-CY            English Cyprus                              English Cyprus
   en-DE            English Germany                             English Germany
   en-DG            English Diego Garcia                        English Diego Garcia
   en-DK            English Denmark                             English Denmark
   en-DM            English Dominica                            English Dominica
   en-ER            English Eritrea                             English Eritrea
   en-FI            English Finland                             English Finland
   en-FJ            English Fiji                                English Fiji
   en-FK            English Falkland Islands                    English Falkland Islands
   en-FM            English Micronesia                          English Micronesia
   en-GB            English United Kingdom                      English United Kingdom
   en-GD            English Grenada                             English Grenada
   en-GG            English Guernsey                            English Guernsey
   en-GH            English Ghana                               English Ghana
   en-GI            English Gibraltar                           English Gibraltar
   en-GM            English Gambia                              English Gambia
   en-GU            English Guam                                English Guam
   en-GY            English Guyana                              English Guyana
   en-HK            English Hong Kong SAR China                 English Hong Kong SAR China
   en-IE            English Ireland                             English Ireland
   en-IL            English Israel                              English Israel
   en-IM            English Isle of Man                         English Isle of Man
   en-IN            English India                               English India
   en-IO            English British Indian Ocean Territory      English British Indian Ocean Territory
   en-JE            English Jersey                              English Jersey
   en-JM            English Jamaica                             English Jamaica
   en-KE            English Kenya                               English Kenya
   en-KI            English Kiribati                            English Kiribati
   en-KN            English St. Kitts & Nevis                   English St. Kitts & Nevis
   en-KY            English Cayman Islands                      English Cayman Islands
   en-LC            English St. Lucia                           English St. Lucia
   en-LR            English Liberia                             English Liberia
   en-LS            English Lesotho                             English Lesotho
   en-MG            English Madagascar                          English Madagascar
   en-MH            English Marshall Islands                    English Marshall Islands
   en-MO            English Macau SAR China                     English Macau SAR China
   en-MP            English Northern Mariana Islands            English Northern Mariana Islands
   en-MS            English Montserrat                          English Montserrat
   en-MT            English Malta                               English Malta
   en-MU            English Mauritius                           English Mauritius
   en-MW            English Malawi                              English Malawi
   en-MY            English Malaysia                            English Malaysia
   en-NA            English Namibia                             English Namibia
   en-NF            English Norfolk Island                      English Norfolk Island
   en-NG            English Nigeria                             English Nigeria
   en-NL            English Netherlands                         English Netherlands
   en-NR            English Nauru                               English Nauru
   en-NU            English Niue                                English Niue
   en-NZ            English New Zealand                         English New Zealand
   en-PG            English Papua New Guinea                    English Papua New Guinea
   en-PH            English Philippines                         English Philippines
   en-PK            English Pakistan                            English Pakistan
   en-PN            English Pitcairn Islands                    English Pitcairn Islands
   en-PR            English Puerto Rico                         English Puerto Rico
   en-PW            English Palau                               English Palau
   en-RW            English Rwanda                              English Rwanda
   en-SB            English Solomon Islands                     English Solomon Islands
   en-SC            English Seychelles                          English Seychelles
   en-SD            English Sudan                               English Sudan
   en-SE            English Sweden                              English Sweden
   en-SG            English Singapore                           English Singapore
   en-SH            English St. Helena                          English St. Helena
   en-SI            English Slovenia                            English Slovenia
   en-SL            English Sierra Leone                        English Sierra Leone
   en-SS            English South Sudan                         English South Sudan
   en-SX            English Sint Maarten                        English Sint Maarten
   en-SZ            English Swaziland                           English Swaziland
   en-TC            English Turks & Caicos Islands              English Turks & Caicos Islands
   en-TK            English Tokelau                             English Tokelau
   en-TO            English Tonga                               English Tonga
   en-TT            English Trinidad & Tobago                   English Trinidad & Tobago
   en-TV            English Tuvalu                              English Tuvalu
   en-TZ            English Tanzania                            English Tanzania
   en-UG            English Uganda                              English Uganda
   en-UM            English U.S. Outlying Islands               English U.S. Outlying Islands
   en-US            English United States                       English United States
   en-US-POSIX      English United States Computer              English United States Computer
   en-VC            English St. Vincent & Grenadines            English St. Vincent & Grenadines
   en-VG            English British Virgin Islands              English British Virgin Islands
   en-VI            English U.S. Virgin Islands                 English U.S. Virgin Islands
   en-VU            English Vanuatu                             English Vanuatu
   en-WS            English Samoa                               English Samoa
   en-ZA            English South Africa                        English South Africa
   en-ZM            English Zambia                              English Zambia
   en-ZW            English Zimbabwe                            English Zimbabwe
   eo               Esperanto                                   esperanto
   eo-001           Esperanto World                             esperanto 001
   es               Spanish                                     español
   es-419           Spanish Latin America                       español Latinoamérica
   es-AR            Spanish Argentina                           español Argentina
   es-BO            Spanish Bolivia                             español Bolivia
   es-BR            Spanish Brazil                              español Brasil
   es-BZ            Spanish Belize                              español Belice
   es-CL            Spanish Chile                               español Chile
   es-CO            Spanish Colombia                            español Colombia
   es-CR            Spanish Costa Rica                          español Costa Rica
   es-CU            Spanish Cuba                                español Cuba
   es-DO            Spanish Dominican Republic                  español República Dominicana
   es-EA            Spanish Ceuta & Melilla                     español Ceuta y Melilla
   es-EC            Spanish Ecuador                             español Ecuador
   es-ES            Spanish Spain                               español España
   es-GQ            Spanish Equatorial Guinea                   español Guinea Ecuatorial
   es-GT            Spanish Guatemala                           español Guatemala
   es-HN            Spanish Honduras                            español Honduras
   es-IC            Spanish Canary Islands                      español Canarias
   es-MX            Spanish Mexico                              español México
   es-NI            Spanish Nicaragua                           español Nicaragua
   es-PA            Spanish Panama                              español Panamá
   es-PE            Spanish Peru                                español Perú
   es-PH            Spanish Philippines                         español Filipinas
   es-PR            Spanish Puerto Rico                         español Puerto Rico
   es-PY            Spanish Paraguay                            español Paraguay
   es-SV            Spanish El Salvador                         español El Salvador
   es-US            Spanish United States                       español Estados Unidos
   es-UY            Spanish Uruguay                             español Uruguay
   es-VE            Spanish Venezuela                           español Venezuela
   et               Estonian                                    eesti
   et-EE            Estonian Estonia                            eesti Eesti
   eu               Basque                                      euskara
   eu-ES            Basque Spain                                euskara Espainia
   ewo              Ewondo                                      ewondo
   ewo-CM           Ewondo Cameroon                             ewondo Kamərún
   fa               Persian                                     فارسی
   fa-AF            Persian Afghanistan                         فارسی افغانستان
   fa-IR            Persian Iran                                فارسی ایران
   ff               Fulah                                       Pulaar
   ff-CM            Fulah Cameroon                              Pulaar Kameruun
   ff-GN            Fulah Guinea                                Pulaar Gine
   ff-MR            Fulah Mauritania                            Pulaar Muritani
   ff-SN            Fulah Senegal                               Pulaar Senegaal
   fi               Finnish                                     suomi
   fi-FI            Finnish Finland                             suomi Suomi
   fil              Filipino                                    Filipino
   fil-PH           Filipino Philippines                        Filipino Pilipinas
   fo               Faroese                                     føroyskt
   fo-DK            Faroese Denmark                             føroyskt Danmark
   fo-FO            Faroese Faroe Islands                       føroyskt Føroyar
   fr               French                                      français
   fr-BE            French Belgium                              français Belgique
   fr-BF            French Burkina Faso                         français Burkina Faso
   fr-BI            French Burundi                              français Burundi
   fr-BJ            French Benin                                français Bénin
   fr-BL            French St. Barthélemy                       français Saint-Barthélemy
   fr-CA            French Canada                               français Canada
   fr-CD            French Congo - Kinshasa                     français Congo-Kinshasa
   fr-CF            French Central African Republic             français République centrafricaine
   fr-CG            French Congo - Brazzaville                  français Congo-Brazzaville
   fr-CH            French Switzerland                          français Suisse
   fr-CI            French Côte d’Ivoire                        français Côte d’Ivoire
   fr-CM            French Cameroon                             français Cameroun
   fr-DJ            French Djibouti                             français Djibouti
   fr-DZ            French Algeria                              français Algérie
   fr-FR            French France                               français France
   fr-GA            French Gabon                                français Gabon
   fr-GF            French French Guiana                        français Guyane française
   fr-GN            French Guinea                               français Guinée
   fr-GP            French Guadeloupe                           français Guadeloupe
   fr-GQ            French Equatorial Guinea                    français Guinée équatoriale
   fr-HT            French Haiti                                français Haïti
   fr-KM            French Comoros                              français Comores
   fr-LU            French Luxembourg                           français Luxembourg
   fr-MA            French Morocco                              français Maroc
   fr-MC            French Monaco                               français Monaco
   fr-MF            French St. Martin                           français Saint-Martin
   fr-MG            French Madagascar                           français Madagascar
   fr-ML            French Mali                                 français Mali
   fr-MQ            French Martinique                           français Martinique
   fr-MR            French Mauritania                           français Mauritanie
   fr-MU            French Mauritius                            français Maurice
   fr-NC            French New Caledonia                        français Nouvelle-Calédonie
   fr-NE            French Niger                                français Niger
   fr-PF            French French Polynesia                     français Polynésie française
   fr-PM            French St. Pierre & Miquelon                français Saint-Pierre-et-Miquelon
   fr-RE            French Réunion                              français La Réunion
   fr-RW            French Rwanda                               français Rwanda
   fr-SC            French Seychelles                           français Seychelles
   fr-SN            French Senegal                              français Sénégal
   fr-SY            French Syria                                français Syrie
   fr-TD            French Chad                                 français Tchad
   fr-TG            French Togo                                 français Togo
   fr-TN            French Tunisia                              français Tunisie
   fr-VU            French Vanuatu                              français Vanuatu
   fr-WF            French Wallis & Futuna                      français Wallis-et-Futuna
   fr-YT            French Mayotte                              français Mayotte
   fur              Friulian                                    furlan
   fur-IT           Friulian Italy                              furlan Italie
   fy               Western Frisian                             Frysk
   fy-NL            Western Frisian Netherlands                 Frysk Nederlân
   ga               Irish                                       Gaeilge
   ga-IE            Irish Ireland                               Gaeilge Éire
   gd               Scottish Gaelic                             Gàidhlig
   gd-GB            Scottish Gaelic United Kingdom              Gàidhlig An Rìoghachd Aonaichte
   gl               Galician                                    galego
   gl-ES            Galician Spain                              galego España
   gsw              Swiss German                                Schwiizertüütsch
   gsw-CH           Swiss German Switzerland                    Schwiizertüütsch Schwiiz
   gsw-FR           Swiss German France                         Schwiizertüütsch Frankriich
   gsw-LI           Swiss German Liechtenstein                  Schwiizertüütsch Liächteschtäi
   gu               Gujarati                                    ગુજરાતી
   gu-IN            Gujarati India                              ગુજરાતી ભારત
   guz              Gusii                                       Ekegusii
   guz-KE           Gusii Kenya                                 Ekegusii Kenya
   gv               Manx                                        Gaelg
   gv-IM            Manx Isle of Man                            Gaelg Ellan Vannin
   ha               Hausa                                       Hausa
   ha-GH            Hausa Ghana                                 Hausa Gana
   ha-NE            Hausa Niger                                 Hausa Nijar
   ha-NG            Hausa Nigeria                               Hausa Najeriya
   haw              Hawaiian                                    ʻŌlelo Hawaiʻi
   haw-US           Hawaiian United States                      ʻŌlelo Hawaiʻi ʻAmelika Hui Pū ʻIa
   he               Hebrew                                      עברית
   he-IL            Hebrew Israel                               עברית ישראל
   hi               Hindi                                       हिन्दी
   hi-IN            Hindi India                                 हिन्दी भारत
   hr               Croatian                                    hrvatski
   hr-BA            Croatian Bosnia & Herzegovina               hrvatski Bosna i Hercegovina
   hr-HR            Croatian Croatia                            hrvatski Hrvatska
   hsb              Upper Sorbian                               hornjoserbšćina
   hsb-DE           Upper Sorbian Germany                       hornjoserbšćina Němska
   hu               Hungarian                                   magyar
   hu-HU            Hungarian Hungary                           magyar Magyarország
   hy               Armenian                                    հայերեն
   hy-AM            Armenian Armenia                            հայերեն Հայաստան
   id               Indonesian                                  Indonesia
   id-ID            Indonesian Indonesia                        Indonesia Indonesia
   ig               Igbo                                        Igbo
   ig-NG            Igbo Nigeria                                Igbo Naịjịrịa
   ii               Sichuan Yi                                  ꆈꌠꉙ
   ii-CN            Sichuan Yi China                            ꆈꌠꉙ ꍏꇩ
   is               Icelandic                                   íslenska
   is-IS            Icelandic Iceland                           íslenska Ísland
   it               Italian                                     italiano
   it-CH            Italian Switzerland                         italiano Svizzera
   it-IT            Italian Italy                               italiano Italia
   it-SM            Italian San Marino                          italiano San Marino
   it-VA            Italian Vatican City                        italiano Città del Vaticano
   ja               Japanese                                    日本語
   ja-JP            Japanese Japan                              日本語 日本
   jgo              Ngomba                                      Ndaꞌa
   jgo-CM           Ngomba Cameroon                             Ndaꞌa Kamɛlûn
   jmc              Machame                                     Kimachame
   jmc-TZ           Machame Tanzania                            Kimachame Tanzania
   ka               Georgian                                    ქართული
   ka-GE            Georgian Georgia                            ქართული საქართველო
   kab              Kabyle                                      Taqbaylit
   kab-DZ           Kabyle Algeria                              Taqbaylit Lezzayer
   kam              Kamba                                       Kikamba
   kam-KE           Kamba Kenya                                 Kikamba Kenya
   kde              Makonde                                     Chimakonde
   kde-TZ           Makonde Tanzania                            Chimakonde Tanzania
   kea              Kabuverdianu                                kabuverdianu
   kea-CV           Kabuverdianu Cape Verde                     kabuverdianu Kabu Verdi
   khq              Koyra Chiini                                Koyra ciini
   khq-ML           Koyra Chiini Mali                           Koyra ciini Maali
   ki               Kikuyu                                      Gikuyu
   ki-KE            Kikuyu Kenya                                Gikuyu Kenya
   kk               Kazakh                                      қазақ тілі
   kk-KZ            Kazakh Kazakhstan                           қазақ тілі Қазақстан
   kkj              Kako                                        kakɔ
   kkj-CM           Kako Cameroon                               kakɔ Kamɛrun
   kl               Kalaallisut                                 kalaallisut
   kl-GL            Kalaallisut Greenland                       kalaallisut Kalaallit Nunaat
   kln              Kalenjin                                    Kalenjin
   kln-KE           Kalenjin Kenya                              Kalenjin Emetab Kenya
   km               Khmer                                       ខ្មែរ
   km-KH            Khmer Cambodia                              ខ្មែរ កម្ពុជា
   kn               Kannada                                     ಕನ್ನಡ
   kn-IN            Kannada India                               ಕನ್ನಡ ಭಾರತ
   ko               Korean                                      한국어
   ko-KP            Korean North Korea                          한국어 조선민주주의인민공화국
   ko-KR            Korean South Korea                          한국어 대한민국
   kok              Konkani                                     कोंकणी
   kok-IN           Konkani India                               कोंकणी भारत
   ks               Kashmiri                                    کٲشُر
   ks-IN            Kashmiri India                              کٲشُر ہِنٛدوستان
   ksb              Shambala                                    Kishambaa
   ksb-TZ           Shambala Tanzania                           Kishambaa Tanzania
   ksf              Bafia                                       rikpa
   ksf-CM           Bafia Cameroon                              rikpa kamɛrún
   ksh              Colognian                                   Kölsch
   ksh-DE           Colognian Germany                           Kölsch Doütschland
   kw               Cornish                                     kernewek
   kw-GB            Cornish United Kingdom                      kernewek Rywvaneth Unys
   ky               Kyrgyz                                      кыргызча
   ky-KG            Kyrgyz Kyrgyzstan                           кыргызча Кыргызстан
   lag              Langi                                       Kɨlaangi
   lag-TZ           Langi Tanzania                              Kɨlaangi Taansanía
   lb               Luxembourgish                               Lëtzebuergesch
   lb-LU            Luxembourgish Luxembourg                    Lëtzebuergesch Lëtzebuerg
   lg               Ganda                                       Luganda
   lg-UG            Ganda Uganda                                Luganda Yuganda
   lkt              Lakota                                      Lakȟólʼiyapi
   lkt-US           Lakota United States                        Lakȟólʼiyapi Mílahaŋska Tȟamákȟočhe
   ln               Lingala                                     lingála
   ln-AO            Lingala Angola                              lingála Angóla
   ln-CD            Lingala Congo - Kinshasa                    lingála Republíki ya Kongó Demokratíki
   ln-CF            Lingala Central African Republic            lingála Repibiki ya Afríka ya Káti
   ln-CG            Lingala Congo - Brazzaville                 lingála Kongo
   lo               Lao                                         ລາວ
   lo-LA            Lao Laos                                    ລາວ ລາວ
   lrc              Northern Luri                               لۊری شومالی
   lrc-IQ           Northern Luri Iraq                          لۊری شومالی IQ
   lrc-IR           Northern Luri Iran                          لۊری شومالی IR
   lt               Lithuanian                                  lietuvių
   lt-LT            Lithuanian Lithuania                        lietuvių Lietuva
   lu               Luba-Katanga                                Tshiluba
   lu-CD            Luba-Katanga Congo - Kinshasa               Tshiluba Ditunga wa Kongu
   luo              Luo                                         Dholuo
   luo-KE           Luo Kenya                                   Dholuo Kenya
   luy              Luyia                                       Luluhia
   luy-KE           Luyia Kenya                                 Luluhia Kenya
   lv               Latvian                                     latviešu
   lv-LV            Latvian Latvia                              latviešu Latvija
   mas              Masai                                       Maa
   mas-KE           Masai Kenya                                 Maa Kenya
   mas-TZ           Masai Tanzania                              Maa Tansania
   mer              Meru                                        Kĩmĩrũ
   mer-KE           Meru Kenya                                  Kĩmĩrũ Kenya
   mfe              Morisyen                                    kreol morisien
   mfe-MU           Morisyen Mauritius                          kreol morisien Moris
   mg               Malagasy                                    Malagasy
   mg-MG            Malagasy Madagascar                         Malagasy Madagasikara
   mgh              Makhuwa-Meetto                              Makua
   mgh-MZ           Makhuwa-Meetto Mozambique                   Makua Umozambiki
   mgo              Metaʼ                                       metaʼ
   mgo-CM           Metaʼ Cameroon                              metaʼ Kamalun
   mk               Macedonian                                  македонски
   mk-MK            Macedonian Macedonia                        македонски Македонија
   ml               Malayalam                                   മലയാളം
   ml-IN            Malayalam India                             മലയാളം ഇന്ത്യ
   mn               Mongolian                                   монгол
   mn-MN            Mongolian Mongolia                          монгол Монгол
   mr               Marathi                                     मराठी
   mr-IN            Marathi India                               मराठी भारत
   ms               Malay                                       Melayu
   ms-BN            Malay Brunei                                Melayu Brunei
   ms-MY            Malay Malaysia                              Melayu Malaysia
   ms-SG            Malay Singapore                             Melayu Singapura
   mt               Maltese                                     Malti
   mt-MT            Maltese Malta                               Malti Malta
   mua              Mundang                                     MUNDAŊ
   mua-CM           Mundang Cameroon                            MUNDAŊ kameruŋ
   my               Burmese                                     မြန်မာ
   my-MM            Burmese Myanmar (Burma)                     မြန်မာ မြန်မာ
   mzn              Mazanderani                                 مازرونی
   mzn-IR           Mazanderani Iran                            مازرونی ایران
   naq              Nama                                        Khoekhoegowab
   naq-NA           Nama Namibia                                Khoekhoegowab Namibiab
   nb               Norwegian Bokmål                            norsk bokmål
   nb-NO            Norwegian Bokmål Norway                     norsk bokmål Norge
   nb-SJ            Norwegian Bokmål Svalbard & Jan Mayen       norsk bokmål Svalbard og Jan Mayen
   nd               North Ndebele                               isiNdebele
   nd-ZW            North Ndebele Zimbabwe                      isiNdebele Zimbabwe
   nds              Low German
   nds-DE           Low German Germany                          DE
   nds-NL           Low German Netherlands                      NL
   ne               Nepali                                      नेपाली
   ne-IN            Nepali India                                नेपाली भारत
   ne-NP            Nepali Nepal                                नेपाली नेपाल
   nl               Dutch                                       Nederlands
   nl-AW            Dutch Aruba                                 Nederlands Aruba
   nl-BE            Dutch Belgium                               Nederlands België
   nl-BQ            Dutch Caribbean Netherlands                 Nederlands Caribisch Nederland
   nl-CW            Dutch Curaçao                               Nederlands Curaçao
   nl-NL            Dutch Netherlands                           Nederlands Nederland
   nl-SR            Dutch Suriname                              Nederlands Suriname
   nl-SX            Dutch Sint Maarten                          Nederlands Sint-Maarten
   nmg              Kwasio                                      nmg
   nmg-CM           Kwasio Cameroon                             nmg Kamerun
   nn               Norwegian Nynorsk                           nynorsk
   nn-NO            Norwegian Nynorsk Norway                    nynorsk Noreg
   nnh              Ngiemboon                                   Shwóŋò ngiembɔɔn
   nnh-CM           Ngiemboon Cameroon                          Shwóŋò ngiembɔɔn Kàmalûm
   nus              Nuer                                        Thok Nath
   nus-SS           Nuer South Sudan                            Thok Nath SS
   nyn              Nyankole                                    Runyankore
   nyn-UG           Nyankole Uganda                             Runyankore Uganda
   om               Oromo                                       Oromoo
   om-ET            Oromo Ethiopia                              Oromoo Itoophiyaa
   om-KE            Oromo Kenya                                 Oromoo Keeniyaa
   or               Odia                                        ଓଡ଼ିଆ
   or-IN            Odia India                                  ଓଡ଼ିଆ ଭାରତ
   os               Ossetic                                     ирон
   os-GE            Ossetic Georgia                             ирон Гуырдзыстон
   os-RU            Ossetic Russia                              ирон Уӕрӕсе
   pa               Punjabi                                     ਪੰਜਾਬੀ
   pa-Arab          Punjabi Arabic                              پنجابی عربی
   pa-Arab-PK       Punjabi Pakistan Arabic                     پنجابی پاکستان عربی
   pa-Guru          Punjabi Gurmukhi                            ਪੰਜਾਬੀ ਗੁਰਮੁਖੀ
   pa-Guru-IN       Punjabi India Gurmukhi                      ਪੰਜਾਬੀ ਭਾਰਤ ਗੁਰਮੁਖੀ
   pl               Polish                                      polski
   pl-PL            Polish Poland                               polski Polska
   prg              Prussian                                    prūsiskan
   prg-001          Prussian World                              prūsiskan 001
   ps               Pashto                                      پښتو
   ps-AF            Pashto Afghanistan                          پښتو افغانستان
   pt               Portuguese                                  português
   pt-AO            Portuguese Angola                           português Angola
   pt-BR            Portuguese Brazil                           português Brasil
   pt-CH            Portuguese Switzerland                      português Suíça
   pt-CV            Portuguese Cape Verde                       português Cabo Verde
   pt-GQ            Portuguese Equatorial Guinea                português Guiné Equatorial
   pt-GW            Portuguese Guinea-Bissau                    português Guiné-Bissau
   pt-LU            Portuguese Luxembourg                       português Luxemburgo
   pt-MO            Portuguese Macau SAR China                  português Macau, RAE da China
   pt-MZ            Portuguese Mozambique                       português Moçambique
   pt-PT            Portuguese Portugal                         português Portugal
   pt-ST            Portuguese São Tomé & Príncipe              português São Tomé e Príncipe
   pt-TL            Portuguese Timor-Leste                      português Timor-Leste
   qu               Quechua                                     Runasimi
   qu-BO            Quechua Bolivia                             Runasimi Bolivia
   qu-EC            Quechua Ecuador                             Runasimi Ecuador
   qu-PE            Quechua Peru                                Runasimi Perú
   rm               Romansh                                     rumantsch
   rm-CH            Romansh Switzerland                         rumantsch Svizra
   rn               Rundi                                       Ikirundi
   rn-BI            Rundi Burundi                               Ikirundi Uburundi
   ro               Romanian                                    română
   ro-MD            Romanian Moldova                            română Republica Moldova
   ro-RO            Romanian Romania                            română România
   rof              Rombo                                       Kihorombo
   rof-TZ           Rombo Tanzania                              Kihorombo Tanzania
   root             Root                                        root
   ru               Russian                                     русский
   ru-BY            Russian Belarus                             русский Беларусь
   ru-KG            Russian Kyrgyzstan                          русский Киргизия
   ru-KZ            Russian Kazakhstan                          русский Казахстан
   ru-MD            Russian Moldova                             русский Молдова
   ru-RU            Russian Russia                              русский Россия
   ru-UA            Russian Ukraine                             русский Украина
   rw               Kinyarwanda                                 Kinyarwanda
   rw-RW            Kinyarwanda Rwanda                          Kinyarwanda U Rwanda
   rwk              Rwa                                         Kiruwa
   rwk-TZ           Rwa Tanzania                                Kiruwa Tanzania
   sah              Sakha                                       саха тыла
   sah-RU           Sakha Russia                                саха тыла Арассыыйа
   saq              Samburu                                     Kisampur
   saq-KE           Samburu Kenya                               Kisampur Kenya
   sbp              Sangu                                       Ishisangu
   sbp-TZ           Sangu Tanzania                              Ishisangu Tansaniya
   sd               Sindhi                                      سنڌي
   sd-PK            Sindhi Pakistan                             سنڌي پاڪستان
   se               Northern Sami                               davvisámegiella
   se-FI            Northern Sami Finland                       davvisámegiella Suopma
   se-NO            Northern Sami Norway                        davvisámegiella Norga
   se-SE            Northern Sami Sweden                        davvisámegiella Ruoŧŧa
   seh              Sena                                        sena
   seh-MZ           Sena Mozambique                             sena Moçambique
   ses              Koyraboro Senni                             Koyraboro senni
   ses-ML           Koyraboro Senni Mali                        Koyraboro senni Maali
   sg               Sango                                       Sängö
   sg-CF            Sango Central African Republic              Sängö Ködörösêse tî Bêafrîka
   shi              Tachelhit                                   ⵜⴰⵛⵍⵃⵉⵜ
   shi-Latn         Tachelhit Latin                             Tashelḥiyt Latn
   shi-Latn-MA      Tachelhit Morocco Latin                     Tashelḥiyt lmɣrib Latn
   shi-Tfng         Tachelhit Tifinagh                          ⵜⴰⵛⵍⵃⵉⵜ Tfng
   shi-Tfng-MA      Tachelhit Morocco Tifinagh                  ⵜⴰⵛⵍⵃⵉⵜ ⵍⵎⵖⵔⵉⴱ Tfng
   si               Sinhala                                     සිංහල
   si-LK            Sinhala Sri Lanka                           සිංහල ශ්‍රී ලංකාව
   sk               Slovak                                      slovenčina
   sk-SK            Slovak Slovakia                             slovenčina Slovensko
   sl               Slovenian                                   slovenščina
   sl-SI            Slovenian Slovenia                          slovenščina Slovenija
   smn              Inari Sami                                  anarâškielâ
   smn-FI           Inari Sami Finland                          anarâškielâ Suomâ
   sn               Shona                                       chiShona
   sn-ZW            Shona Zimbabwe                              chiShona Zimbabwe
   so               Somali                                      Soomaali
   so-DJ            Somali Djibouti                             Soomaali Jabuuti
   so-ET            Somali Ethiopia                             Soomaali Itoobiya
   so-KE            Somali Kenya                                Soomaali Kiiniya
   so-SO            Somali Somalia                              Soomaali Soomaaliya
   sq               Albanian                                    shqip
   sq-AL            Albanian Albania                            shqip Shqipëri
   sq-MK            Albanian Macedonia                          shqip Maqedoni
   sq-XK            Albanian Kosovo                             shqip Kosovë
   sr               Serbian                                     српски
   sr-Cyrl          Serbian Cyrillic                            српски ћирилица
   sr-Cyrl-BA       Serbian Bosnia & Herzegovina Cyrillic       српски Босна и Херцеговина ћирилица
   sr-Cyrl-ME       Serbian Montenegro Cyrillic                 српски Црна Гора ћирилица
   sr-Cyrl-RS       Serbian Serbia Cyrillic                     српски Србија ћирилица
   sr-Cyrl-XK       Serbian Kosovo Cyrillic                     српски Косово ћирилица
   sr-Latn          Serbian Latin                               srpski latinica
   sr-Latn-BA       Serbian Bosnia & Herzegovina Latin          srpski Bosna i Hercegovina latinica
   sr-Latn-ME       Serbian Montenegro Latin                    srpski Crna Gora latinica
   sr-Latn-RS       Serbian Serbia Latin                        srpski Srbija latinica
   sr-Latn-XK       Serbian Kosovo Latin                        srpski Kosovo latinica
   sv               Swedish                                     svenska
   sv-AX            Swedish Åland Islands                       svenska Åland
   sv-FI            Swedish Finland                             svenska Finland
   sv-SE            Swedish Sweden                              svenska Sverige
   sw               Swahili                                     Kiswahili
   sw-CD            Swahili Congo - Kinshasa                    Kiswahili Jamhuri ya Kidemokrasia ya Kongo
   sw-KE            Swahili Kenya                               Kiswahili Kenya
   sw-TZ            Swahili Tanzania                            Kiswahili Tanzania
   sw-UG            Swahili Uganda                              Kiswahili Uganda
   ta               Tamil                                       தமிழ்
   ta-IN            Tamil India                                 தமிழ் இந்தியா
   ta-LK            Tamil Sri Lanka                             தமிழ் இலங்கை
   ta-MY            Tamil Malaysia                              தமிழ் மலேசியா
   ta-SG            Tamil Singapore                             தமிழ் சிங்கப்பூர்
   te               Telugu                                      తెలుగు
   te-IN            Telugu India                                తెలుగు భారతదేశం
   teo              Teso                                        Kiteso
   teo-KE           Teso Kenya                                  Kiteso Kenia
   teo-UG           Teso Uganda                                 Kiteso Uganda
   tg               Tajik                                       тоҷикӣ
   tg-TJ            Tajik Tajikistan                            тоҷикӣ Тоҷикистон
   th               Thai                                        ไทย
   th-TH            Thai Thailand                               ไทย ไทย
   ti               Tigrinya                                    ትግርኛ
   ti-ER            Tigrinya Eritrea                            ትግርኛ ኤርትራ
   ti-ET            Tigrinya Ethiopia                           ትግርኛ ኢትዮጵያ
   tk               Turkmen                                     türkmen dili
   tk-TM            Turkmen Turkmenistan                        türkmen dili Türkmenistan
   to               Tongan                                      lea fakatonga
   to-TO            Tongan Tonga                                lea fakatonga Tonga
   tr               Turkish                                     Türkçe
   tr-CY            Turkish Cyprus                              Türkçe Kıbrıs
   tr-TR            Turkish Turkey                              Türkçe Türkiye
   tt               Tatar                                       татар
   tt-RU            Tatar Russia                                татар Россия
   twq              Tasawaq                                     Tasawaq senni
   twq-NE           Tasawaq Niger                               Tasawaq senni Nižer
   tzm              Central Atlas Tamazight                     Tamaziɣt n laṭlaṣ
   tzm-MA           Central Atlas Tamazight Morocco             Tamaziɣt n laṭlaṣ Meṛṛuk
   ug               Uyghur                                      ئۇيغۇرچە
   ug-CN            Uyghur China                                ئۇيغۇرچە جۇڭگو
   uk               Ukrainian                                   українська
   uk-UA            Ukrainian Ukraine                           українська Україна
   ur               Urdu                                        اردو
   ur-IN            Urdu India                                  اردو بھارت
   ur-PK            Urdu Pakistan                               اردو پاکستان
   uz               Uzbek                                       o‘zbek
   uz-Arab          Uzbek Arabic                                اوزبیک عربی
   uz-Arab-AF       Uzbek Afghanistan Arabic                    اوزبیک افغانستان عربی
   uz-Cyrl          Uzbek Cyrillic                              ўзбекча Кирил
   uz-Cyrl-UZ       Uzbek Uzbekistan Cyrillic                   ўзбекча Ўзбекистон Кирил
   uz-Latn          Uzbek Latin                                 o‘zbek lotin
   uz-Latn-UZ       Uzbek Uzbekistan Latin                      o‘zbek Oʻzbekiston lotin
   vai              Vai                                         ꕙꔤ
   vai-Latn         Vai Latin                                   Vai Latn
   vai-Latn-LR      Vai Liberia Latin                           Vai Laibhiya Latn
   vai-Vaii         Vai Vai                                     ꕙꔤ Vaii
   vai-Vaii-LR      Vai Liberia Vai                             ꕙꔤ ꕞꔤꔫꕩ Vaii
   vi               Vietnamese                                  Tiếng Việt
   vi-VN            Vietnamese Vietnam                          Tiếng Việt Việt Nam
   vo               Volapük                                     vo
   vo-001           Volapük World                               vo 001
   vun              Vunjo                                       Kyivunjo
   vun-TZ           Vunjo Tanzania                              Kyivunjo Tanzania
   wae              Walser                                      Walser
   wae-CH           Walser Switzerland                          Walser Schwiz
   wo               Wolof                                       Wolof
   wo-SN            Wolof Senegal                               Wolof Senegaal
   xog              Soga                                        Olusoga
   xog-UG           Soga Uganda                                 Olusoga Yuganda
   yav              Yangben                                     nuasue
   yav-CM           Yangben Cameroon                            nuasue Kemelún
   yi               Yiddish                                     ייִדיש
   yi-001           Yiddish World                               ייִדיש וועלט
   yo               Yoruba                                      Èdè Yorùbá
   yo-BJ            Yoruba Benin                                Èdè Yorùbá Orílɛ́ède Bɛ̀nɛ̀
   yo-NG            Yoruba Nigeria                              Èdè Yorùbá Orílẹ́ède Nàìjíríà
   yue              Cantonese                                   粵語
   yue-Hans         Cantonese Simplified                        粤语 简体
   yue-Hans-CN      Cantonese China Simplified                  粤语 中华人民共和国 简体
   yue-Hant         Cantonese Traditional                       粵語 繁體
   yue-Hant-HK      Cantonese Hong Kong SAR China Traditional   粵語 中華人民共和國香港特別行政區 繁體
   zgh              Standard Moroccan Tamazight                 ⵜⴰⵎⴰⵣⵉⵖⵜ
   zgh-MA           Standard Moroccan Tamazight Morocco         ⵜⴰⵎⴰⵣⵉⵖⵜ ⵍⵎⵖⵔⵉⴱ
   zh               Chinese                                     中文
   zh-Hans          Chinese Simplified                          中文 简体
   zh-Hans-CN       Chinese China Simplified                    中文 中国 简体
   zh-Hans-HK       Chinese Hong Kong SAR China Simplified      中文 中国香港特别行政区 简体
   zh-Hans-MO       Chinese Macau SAR China Simplified          中文 中国澳门特别行政区 简体
   zh-Hans-SG       Chinese Singapore Simplified                中文 新加坡 简体
   zh-Hant          Chinese Traditional                         中文 繁體
   zh-Hant-HK       Chinese Hong Kong SAR China Traditional     中文 中國香港特別行政區 繁體字
   zh-Hant-MO       Chinese Macau SAR China Traditional         中文 中國澳門特別行政區 繁體字
   zh-Hant-TW       Chinese Taiwan Traditional                  中文 台灣 繁體
   zu               Zulu                                        isiZulu
   zu-ZA            Zulu South Africa                           isiZulu iNingizimu Afrika
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/DateTime-Locale/issues>.
  
  There is a mailing list available for users of this distribution,
  L<mailto:datetime@perl.org>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for DateTime-Locale can be found at L<https://github.com/houseabsolute/DateTime-Locale>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2003 - 2018 by Dave Rolsky.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
DATETIME_LOCALE_CATALOG

$fatpacked{"DateTime/Locale/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATETIME_LOCALE_CONFLICTS';
  package # hide from PAUSE
      DateTime::Locale::Conflicts;
  
  use strict;
  use warnings;
  
  # this module was generated with Dist::Zilla::Plugin::Conflicts 0.19
  
  use Dist::CheckConflicts
      -dist      => 'DateTime::Locale',
      -conflicts => {
          'DateTime::Format::Strptime' => '1.1000',
      },
      -also => [ qw(
          Carp
          Dist::CheckConflicts
          Exporter
          File::ShareDir
          List::Util
          Params::ValidationCompiler
          Specio::Declare
          Specio::Library::String
          namespace::autoclean
          strict
          warnings
      ) ],
  
  ;
  
  1;
  
  # ABSTRACT: Provide information on conflicts for DateTime::Locale
  # Dist::Zilla: -PodWeaver
DATETIME_LOCALE_CONFLICTS

$fatpacked{"DateTime/Locale/Data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATETIME_LOCALE_DATA';
  ###########################################################################
  #
  # This file is partially auto-generated by the DateTime::Locale generator
  # tools (v0.10). This code generator comes with the DateTime::Locale
  # distribution in the tools/ directory, and is called generate-modules.
  #
  # This file was generated from the CLDR JSON locale data. See the LICENSE.cldr
  # file included in this distribution for license details.
  #
  # Do not edit this file directly unless you are sure the part you are editing
  # is not created by the generator.
  #
  ###########################################################################
  
  package DateTime::Locale::Data;
  
  use strict;
  use warnings;
  use namespace::autoclean;
  
  use File::ShareDir qw( dist_file );
  
  our $VERSION = '1.22';
  
  #<<<
  ### :start CLDRVersion:
  our $CLDRVersion = 33;
  ### :end CLDRVersion:
  #>>>
  
  #<<<
  ### :start Codes:
  our %Codes = (
    af => 1,
    "af-NA" => 1,
    "af-ZA" => 1,
    agq => 1,
    "agq-CM" => 1,
    ak => 1,
    "ak-GH" => 1,
    am => 1,
    "am-ET" => 1,
    ar => 1,
    "ar-001" => 1,
    "ar-AE" => 1,
    "ar-BH" => 1,
    "ar-DJ" => 1,
    "ar-DZ" => 1,
    "ar-EG" => 1,
    "ar-EH" => 1,
    "ar-ER" => 1,
    "ar-IL" => 1,
    "ar-IQ" => 1,
    "ar-JO" => 1,
    "ar-KM" => 1,
    "ar-KW" => 1,
    "ar-LB" => 1,
    "ar-LY" => 1,
    "ar-MA" => 1,
    "ar-MR" => 1,
    "ar-OM" => 1,
    "ar-PS" => 1,
    "ar-QA" => 1,
    "ar-SA" => 1,
    "ar-SD" => 1,
    "ar-SO" => 1,
    "ar-SS" => 1,
    "ar-SY" => 1,
    "ar-TD" => 1,
    "ar-TN" => 1,
    "ar-YE" => 1,
    as => 1,
    "as-IN" => 1,
    asa => 1,
    "asa-TZ" => 1,
    ast => 1,
    "ast-ES" => 1,
    az => 1,
    "az-Cyrl" => 1,
    "az-Cyrl-AZ" => 1,
    "az-Latn" => 1,
    "az-Latn-AZ" => 1,
    bas => 1,
    "bas-CM" => 1,
    be => 1,
    "be-BY" => 1,
    bem => 1,
    "bem-ZM" => 1,
    bez => 1,
    "bez-TZ" => 1,
    bg => 1,
    "bg-BG" => 1,
    bm => 1,
    "bm-ML" => 1,
    bn => 1,
    "bn-BD" => 1,
    "bn-IN" => 1,
    bo => 1,
    "bo-CN" => 1,
    "bo-IN" => 1,
    br => 1,
    "br-FR" => 1,
    brx => 1,
    "brx-IN" => 1,
    bs => 1,
    "bs-Cyrl" => 1,
    "bs-Cyrl-BA" => 1,
    "bs-Latn" => 1,
    "bs-Latn-BA" => 1,
    ca => 1,
    "ca-AD" => 1,
    "ca-ES" => 1,
    "ca-ES-VALENCIA" => 1,
    "ca-FR" => 1,
    "ca-IT" => 1,
    ccp => 1,
    "ccp-BD" => 1,
    "ccp-IN" => 1,
    ce => 1,
    "ce-RU" => 1,
    cgg => 1,
    "cgg-UG" => 1,
    chr => 1,
    "chr-US" => 1,
    ckb => 1,
    "ckb-IQ" => 1,
    "ckb-IR" => 1,
    cs => 1,
    "cs-CZ" => 1,
    cu => 1,
    "cu-RU" => 1,
    cy => 1,
    "cy-GB" => 1,
    da => 1,
    "da-DK" => 1,
    "da-GL" => 1,
    dav => 1,
    "dav-KE" => 1,
    de => 1,
    "de-AT" => 1,
    "de-BE" => 1,
    "de-CH" => 1,
    "de-DE" => 1,
    "de-IT" => 1,
    "de-LI" => 1,
    "de-LU" => 1,
    dje => 1,
    "dje-NE" => 1,
    dsb => 1,
    "dsb-DE" => 1,
    dua => 1,
    "dua-CM" => 1,
    dyo => 1,
    "dyo-SN" => 1,
    dz => 1,
    "dz-BT" => 1,
    ebu => 1,
    "ebu-KE" => 1,
    ee => 1,
    "ee-GH" => 1,
    "ee-TG" => 1,
    el => 1,
    "el-CY" => 1,
    "el-GR" => 1,
    en => 1,
    "en-001" => 1,
    "en-150" => 1,
    "en-AG" => 1,
    "en-AI" => 1,
    "en-AS" => 1,
    "en-AT" => 1,
    "en-AU" => 1,
    "en-BB" => 1,
    "en-BE" => 1,
    "en-BI" => 1,
    "en-BM" => 1,
    "en-BS" => 1,
    "en-BW" => 1,
    "en-BZ" => 1,
    "en-CA" => 1,
    "en-CC" => 1,
    "en-CH" => 1,
    "en-CK" => 1,
    "en-CM" => 1,
    "en-CX" => 1,
    "en-CY" => 1,
    "en-DE" => 1,
    "en-DG" => 1,
    "en-DK" => 1,
    "en-DM" => 1,
    "en-ER" => 1,
    "en-FI" => 1,
    "en-FJ" => 1,
    "en-FK" => 1,
    "en-FM" => 1,
    "en-GB" => 1,
    "en-GD" => 1,
    "en-GG" => 1,
    "en-GH" => 1,
    "en-GI" => 1,
    "en-GM" => 1,
    "en-GU" => 1,
    "en-GY" => 1,
    "en-HK" => 1,
    "en-IE" => 1,
    "en-IL" => 1,
    "en-IM" => 1,
    "en-IN" => 1,
    "en-IO" => 1,
    "en-JE" => 1,
    "en-JM" => 1,
    "en-KE" => 1,
    "en-KI" => 1,
    "en-KN" => 1,
    "en-KY" => 1,
    "en-LC" => 1,
    "en-LR" => 1,
    "en-LS" => 1,
    "en-MG" => 1,
    "en-MH" => 1,
    "en-MO" => 1,
    "en-MP" => 1,
    "en-MS" => 1,
    "en-MT" => 1,
    "en-MU" => 1,
    "en-MW" => 1,
    "en-MY" => 1,
    "en-NA" => 1,
    "en-NF" => 1,
    "en-NG" => 1,
    "en-NL" => 1,
    "en-NR" => 1,
    "en-NU" => 1,
    "en-NZ" => 1,
    "en-PG" => 1,
    "en-PH" => 1,
    "en-PK" => 1,
    "en-PN" => 1,
    "en-PR" => 1,
    "en-PW" => 1,
    "en-RW" => 1,
    "en-SB" => 1,
    "en-SC" => 1,
    "en-SD" => 1,
    "en-SE" => 1,
    "en-SG" => 1,
    "en-SH" => 1,
    "en-SI" => 1,
    "en-SL" => 1,
    "en-SS" => 1,
    "en-SX" => 1,
    "en-SZ" => 1,
    "en-TC" => 1,
    "en-TK" => 1,
    "en-TO" => 1,
    "en-TT" => 1,
    "en-TV" => 1,
    "en-TZ" => 1,
    "en-UG" => 1,
    "en-UM" => 1,
    "en-US" => 1,
    "en-US-POSIX" => 1,
    "en-VC" => 1,
    "en-VG" => 1,
    "en-VI" => 1,
    "en-VU" => 1,
    "en-WS" => 1,
    "en-ZA" => 1,
    "en-ZM" => 1,
    "en-ZW" => 1,
    eo => 1,
    "eo-001" => 1,
    es => 1,
    "es-419" => 1,
    "es-AR" => 1,
    "es-BO" => 1,
    "es-BR" => 1,
    "es-BZ" => 1,
    "es-CL" => 1,
    "es-CO" => 1,
    "es-CR" => 1,
    "es-CU" => 1,
    "es-DO" => 1,
    "es-EA" => 1,
    "es-EC" => 1,
    "es-ES" => 1,
    "es-GQ" => 1,
    "es-GT" => 1,
    "es-HN" => 1,
    "es-IC" => 1,
    "es-MX" => 1,
    "es-NI" => 1,
    "es-PA" => 1,
    "es-PE" => 1,
    "es-PH" => 1,
    "es-PR" => 1,
    "es-PY" => 1,
    "es-SV" => 1,
    "es-US" => 1,
    "es-UY" => 1,
    "es-VE" => 1,
    et => 1,
    "et-EE" => 1,
    eu => 1,
    "eu-ES" => 1,
    ewo => 1,
    "ewo-CM" => 1,
    fa => 1,
    "fa-AF" => 1,
    "fa-IR" => 1,
    ff => 1,
    "ff-CM" => 1,
    "ff-GN" => 1,
    "ff-MR" => 1,
    "ff-SN" => 1,
    fi => 1,
    "fi-FI" => 1,
    fil => 1,
    "fil-PH" => 1,
    fo => 1,
    "fo-DK" => 1,
    "fo-FO" => 1,
    fr => 1,
    "fr-BE" => 1,
    "fr-BF" => 1,
    "fr-BI" => 1,
    "fr-BJ" => 1,
    "fr-BL" => 1,
    "fr-CA" => 1,
    "fr-CD" => 1,
    "fr-CF" => 1,
    "fr-CG" => 1,
    "fr-CH" => 1,
    "fr-CI" => 1,
    "fr-CM" => 1,
    "fr-DJ" => 1,
    "fr-DZ" => 1,
    "fr-FR" => 1,
    "fr-GA" => 1,
    "fr-GF" => 1,
    "fr-GN" => 1,
    "fr-GP" => 1,
    "fr-GQ" => 1,
    "fr-HT" => 1,
    "fr-KM" => 1,
    "fr-LU" => 1,
    "fr-MA" => 1,
    "fr-MC" => 1,
    "fr-MF" => 1,
    "fr-MG" => 1,
    "fr-ML" => 1,
    "fr-MQ" => 1,
    "fr-MR" => 1,
    "fr-MU" => 1,
    "fr-NC" => 1,
    "fr-NE" => 1,
    "fr-PF" => 1,
    "fr-PM" => 1,
    "fr-RE" => 1,
    "fr-RW" => 1,
    "fr-SC" => 1,
    "fr-SN" => 1,
    "fr-SY" => 1,
    "fr-TD" => 1,
    "fr-TG" => 1,
    "fr-TN" => 1,
    "fr-VU" => 1,
    "fr-WF" => 1,
    "fr-YT" => 1,
    fur => 1,
    "fur-IT" => 1,
    fy => 1,
    "fy-NL" => 1,
    ga => 1,
    "ga-IE" => 1,
    gd => 1,
    "gd-GB" => 1,
    gl => 1,
    "gl-ES" => 1,
    gsw => 1,
    "gsw-CH" => 1,
    "gsw-FR" => 1,
    "gsw-LI" => 1,
    gu => 1,
    "gu-IN" => 1,
    guz => 1,
    "guz-KE" => 1,
    gv => 1,
    "gv-IM" => 1,
    ha => 1,
    "ha-GH" => 1,
    "ha-NE" => 1,
    "ha-NG" => 1,
    haw => 1,
    "haw-US" => 1,
    he => 1,
    "he-IL" => 1,
    hi => 1,
    "hi-IN" => 1,
    hr => 1,
    "hr-BA" => 1,
    "hr-HR" => 1,
    hsb => 1,
    "hsb-DE" => 1,
    hu => 1,
    "hu-HU" => 1,
    hy => 1,
    "hy-AM" => 1,
    id => 1,
    "id-ID" => 1,
    ig => 1,
    "ig-NG" => 1,
    ii => 1,
    "ii-CN" => 1,
    is => 1,
    "is-IS" => 1,
    it => 1,
    "it-CH" => 1,
    "it-IT" => 1,
    "it-SM" => 1,
    "it-VA" => 1,
    ja => 1,
    "ja-JP" => 1,
    jgo => 1,
    "jgo-CM" => 1,
    jmc => 1,
    "jmc-TZ" => 1,
    ka => 1,
    "ka-GE" => 1,
    kab => 1,
    "kab-DZ" => 1,
    kam => 1,
    "kam-KE" => 1,
    kde => 1,
    "kde-TZ" => 1,
    kea => 1,
    "kea-CV" => 1,
    khq => 1,
    "khq-ML" => 1,
    ki => 1,
    "ki-KE" => 1,
    kk => 1,
    "kk-KZ" => 1,
    kkj => 1,
    "kkj-CM" => 1,
    kl => 1,
    "kl-GL" => 1,
    kln => 1,
    "kln-KE" => 1,
    km => 1,
    "km-KH" => 1,
    kn => 1,
    "kn-IN" => 1,
    ko => 1,
    "ko-KP" => 1,
    "ko-KR" => 1,
    kok => 1,
    "kok-IN" => 1,
    ks => 1,
    "ks-IN" => 1,
    ksb => 1,
    "ksb-TZ" => 1,
    ksf => 1,
    "ksf-CM" => 1,
    ksh => 1,
    "ksh-DE" => 1,
    kw => 1,
    "kw-GB" => 1,
    ky => 1,
    "ky-KG" => 1,
    lag => 1,
    "lag-TZ" => 1,
    lb => 1,
    "lb-LU" => 1,
    lg => 1,
    "lg-UG" => 1,
    lkt => 1,
    "lkt-US" => 1,
    ln => 1,
    "ln-AO" => 1,
    "ln-CD" => 1,
    "ln-CF" => 1,
    "ln-CG" => 1,
    lo => 1,
    "lo-LA" => 1,
    lrc => 1,
    "lrc-IQ" => 1,
    "lrc-IR" => 1,
    lt => 1,
    "lt-LT" => 1,
    lu => 1,
    "lu-CD" => 1,
    luo => 1,
    "luo-KE" => 1,
    luy => 1,
    "luy-KE" => 1,
    lv => 1,
    "lv-LV" => 1,
    mas => 1,
    "mas-KE" => 1,
    "mas-TZ" => 1,
    mer => 1,
    "mer-KE" => 1,
    mfe => 1,
    "mfe-MU" => 1,
    mg => 1,
    "mg-MG" => 1,
    mgh => 1,
    "mgh-MZ" => 1,
    mgo => 1,
    "mgo-CM" => 1,
    mk => 1,
    "mk-MK" => 1,
    ml => 1,
    "ml-IN" => 1,
    mn => 1,
    "mn-MN" => 1,
    mr => 1,
    "mr-IN" => 1,
    ms => 1,
    "ms-BN" => 1,
    "ms-MY" => 1,
    "ms-SG" => 1,
    mt => 1,
    "mt-MT" => 1,
    mua => 1,
    "mua-CM" => 1,
    my => 1,
    "my-MM" => 1,
    mzn => 1,
    "mzn-IR" => 1,
    naq => 1,
    "naq-NA" => 1,
    nb => 1,
    "nb-NO" => 1,
    "nb-SJ" => 1,
    nd => 1,
    "nd-ZW" => 1,
    nds => 1,
    "nds-DE" => 1,
    "nds-NL" => 1,
    ne => 1,
    "ne-IN" => 1,
    "ne-NP" => 1,
    nl => 1,
    "nl-AW" => 1,
    "nl-BE" => 1,
    "nl-BQ" => 1,
    "nl-CW" => 1,
    "nl-NL" => 1,
    "nl-SR" => 1,
    "nl-SX" => 1,
    nmg => 1,
    "nmg-CM" => 1,
    nn => 1,
    "nn-NO" => 1,
    nnh => 1,
    "nnh-CM" => 1,
    nus => 1,
    "nus-SS" => 1,
    nyn => 1,
    "nyn-UG" => 1,
    om => 1,
    "om-ET" => 1,
    "om-KE" => 1,
    or => 1,
    "or-IN" => 1,
    os => 1,
    "os-GE" => 1,
    "os-RU" => 1,
    pa => 1,
    "pa-Arab" => 1,
    "pa-Arab-PK" => 1,
    "pa-Guru" => 1,
    "pa-Guru-IN" => 1,
    pl => 1,
    "pl-PL" => 1,
    prg => 1,
    "prg-001" => 1,
    ps => 1,
    "ps-AF" => 1,
    pt => 1,
    "pt-AO" => 1,
    "pt-BR" => 1,
    "pt-CH" => 1,
    "pt-CV" => 1,
    "pt-GQ" => 1,
    "pt-GW" => 1,
    "pt-LU" => 1,
    "pt-MO" => 1,
    "pt-MZ" => 1,
    "pt-PT" => 1,
    "pt-ST" => 1,
    "pt-TL" => 1,
    qu => 1,
    "qu-BO" => 1,
    "qu-EC" => 1,
    "qu-PE" => 1,
    rm => 1,
    "rm-CH" => 1,
    rn => 1,
    "rn-BI" => 1,
    ro => 1,
    "ro-MD" => 1,
    "ro-RO" => 1,
    rof => 1,
    "rof-TZ" => 1,
    root => 1,
    ru => 1,
    "ru-BY" => 1,
    "ru-KG" => 1,
    "ru-KZ" => 1,
    "ru-MD" => 1,
    "ru-RU" => 1,
    "ru-UA" => 1,
    rw => 1,
    "rw-RW" => 1,
    rwk => 1,
    "rwk-TZ" => 1,
    sah => 1,
    "sah-RU" => 1,
    saq => 1,
    "saq-KE" => 1,
    sbp => 1,
    "sbp-TZ" => 1,
    sd => 1,
    "sd-PK" => 1,
    se => 1,
    "se-FI" => 1,
    "se-NO" => 1,
    "se-SE" => 1,
    seh => 1,
    "seh-MZ" => 1,
    ses => 1,
    "ses-ML" => 1,
    sg => 1,
    "sg-CF" => 1,
    shi => 1,
    "shi-Latn" => 1,
    "shi-Latn-MA" => 1,
    "shi-Tfng" => 1,
    "shi-Tfng-MA" => 1,
    si => 1,
    "si-LK" => 1,
    sk => 1,
    "sk-SK" => 1,
    sl => 1,
    "sl-SI" => 1,
    smn => 1,
    "smn-FI" => 1,
    sn => 1,
    "sn-ZW" => 1,
    so => 1,
    "so-DJ" => 1,
    "so-ET" => 1,
    "so-KE" => 1,
    "so-SO" => 1,
    sq => 1,
    "sq-AL" => 1,
    "sq-MK" => 1,
    "sq-XK" => 1,
    sr => 1,
    "sr-Cyrl" => 1,
    "sr-Cyrl-BA" => 1,
    "sr-Cyrl-ME" => 1,
    "sr-Cyrl-RS" => 1,
    "sr-Cyrl-XK" => 1,
    "sr-Latn" => 1,
    "sr-Latn-BA" => 1,
    "sr-Latn-ME" => 1,
    "sr-Latn-RS" => 1,
    "sr-Latn-XK" => 1,
    sv => 1,
    "sv-AX" => 1,
    "sv-FI" => 1,
    "sv-SE" => 1,
    sw => 1,
    "sw-CD" => 1,
    "sw-KE" => 1,
    "sw-TZ" => 1,
    "sw-UG" => 1,
    ta => 1,
    "ta-IN" => 1,
    "ta-LK" => 1,
    "ta-MY" => 1,
    "ta-SG" => 1,
    te => 1,
    "te-IN" => 1,
    teo => 1,
    "teo-KE" => 1,
    "teo-UG" => 1,
    tg => 1,
    "tg-TJ" => 1,
    th => 1,
    "th-TH" => 1,
    ti => 1,
    "ti-ER" => 1,
    "ti-ET" => 1,
    tk => 1,
    "tk-TM" => 1,
    to => 1,
    "to-TO" => 1,
    tr => 1,
    "tr-CY" => 1,
    "tr-TR" => 1,
    tt => 1,
    "tt-RU" => 1,
    twq => 1,
    "twq-NE" => 1,
    tzm => 1,
    "tzm-MA" => 1,
    ug => 1,
    "ug-CN" => 1,
    uk => 1,
    "uk-UA" => 1,
    ur => 1,
    "ur-IN" => 1,
    "ur-PK" => 1,
    uz => 1,
    "uz-Arab" => 1,
    "uz-Arab-AF" => 1,
    "uz-Cyrl" => 1,
    "uz-Cyrl-UZ" => 1,
    "uz-Latn" => 1,
    "uz-Latn-UZ" => 1,
    vai => 1,
    "vai-Latn" => 1,
    "vai-Latn-LR" => 1,
    "vai-Vaii" => 1,
    "vai-Vaii-LR" => 1,
    vi => 1,
    "vi-VN" => 1,
    vo => 1,
    "vo-001" => 1,
    vun => 1,
    "vun-TZ" => 1,
    wae => 1,
    "wae-CH" => 1,
    wo => 1,
    "wo-SN" => 1,
    xog => 1,
    "xog-UG" => 1,
    yav => 1,
    "yav-CM" => 1,
    yi => 1,
    "yi-001" => 1,
    yo => 1,
    "yo-BJ" => 1,
    "yo-NG" => 1,
    yue => 1,
    "yue-Hans" => 1,
    "yue-Hans-CN" => 1,
    "yue-Hant" => 1,
    "yue-Hant-HK" => 1,
    zgh => 1,
    "zgh-MA" => 1,
    zh => 1,
    "zh-Hans" => 1,
    "zh-Hans-CN" => 1,
    "zh-Hans-HK" => 1,
    "zh-Hans-MO" => 1,
    "zh-Hans-SG" => 1,
    "zh-Hant" => 1,
    "zh-Hant-HK" => 1,
    "zh-Hant-MO" => 1,
    "zh-Hant-TW" => 1,
    zu => 1,
    "zu-ZA" => 1,
  );
  ### :end Codes:
  #>>>
  
  #<<<
  ### :start Names:
  our %Names = (
    Afrikaans => "af",
    "Afrikaans Namibia" => "af-NA",
    "Afrikaans South Africa" => "af-ZA",
    Aghem => "agq",
    "Aghem Cameroon" => "agq-CM",
    Akan => "ak",
    "Akan Ghana" => "ak-GH",
    Albanian => "sq",
    "Albanian Albania" => "sq-AL",
    "Albanian Kosovo" => "sq-XK",
    "Albanian Macedonia" => "sq-MK",
    Amharic => "am",
    "Amharic Ethiopia" => "am-ET",
    Arabic => "ar",
    "Arabic Algeria" => "ar-DZ",
    "Arabic Bahrain" => "ar-BH",
    "Arabic Chad" => "ar-TD",
    "Arabic Comoros" => "ar-KM",
    "Arabic Djibouti" => "ar-DJ",
    "Arabic Egypt" => "ar-EG",
    "Arabic Eritrea" => "ar-ER",
    "Arabic Iraq" => "ar-IQ",
    "Arabic Israel" => "ar-IL",
    "Arabic Jordan" => "ar-JO",
    "Arabic Kuwait" => "ar-KW",
    "Arabic Lebanon" => "ar-LB",
    "Arabic Libya" => "ar-LY",
    "Arabic Mauritania" => "ar-MR",
    "Arabic Morocco" => "ar-MA",
    "Arabic Oman" => "ar-OM",
    "Arabic Palestinian Territories" => "ar-PS",
    "Arabic Qatar" => "ar-QA",
    "Arabic Saudi Arabia" => "ar-SA",
    "Arabic Somalia" => "ar-SO",
    "Arabic South Sudan" => "ar-SS",
    "Arabic Sudan" => "ar-SD",
    "Arabic Syria" => "ar-SY",
    "Arabic Tunisia" => "ar-TN",
    "Arabic United Arab Emirates" => "ar-AE",
    "Arabic Western Sahara" => "ar-EH",
    "Arabic World" => "ar-001",
    "Arabic Yemen" => "ar-YE",
    Armenian => "hy",
    "Armenian Armenia" => "hy-AM",
    Assamese => "as",
    "Assamese India" => "as-IN",
    Asturian => "ast",
    "Asturian Spain" => "ast-ES",
    Asu => "asa",
    "Asu Tanzania" => "asa-TZ",
    Azerbaijani => "az",
    "Azerbaijani Azerbaijan Cyrillic" => "az-Cyrl-AZ",
    "Azerbaijani Azerbaijan Latin" => "az-Latn-AZ",
    "Azerbaijani Cyrillic" => "az-Cyrl",
    "Azerbaijani Latin" => "az-Latn",
    Bafia => "ksf",
    "Bafia Cameroon" => "ksf-CM",
    Bambara => "bm",
    "Bambara Mali" => "bm-ML",
    Bangla => "bn",
    "Bangla Bangladesh" => "bn-BD",
    "Bangla India" => "bn-IN",
    Basaa => "bas",
    "Basaa Cameroon" => "bas-CM",
    Basque => "eu",
    "Basque Spain" => "eu-ES",
    Belarusian => "be",
    "Belarusian Belarus" => "be-BY",
    Bemba => "bem",
    "Bemba Zambia" => "bem-ZM",
    Bena => "bez",
    "Bena Tanzania" => "bez-TZ",
    Bodo => "brx",
    "Bodo India" => "brx-IN",
    Bosnian => "bs",
    "Bosnian Bosnia & Herzegovina Cyrillic" => "bs-Cyrl-BA",
    "Bosnian Bosnia & Herzegovina Latin" => "bs-Latn-BA",
    "Bosnian Cyrillic" => "bs-Cyrl",
    "Bosnian Latin" => "bs-Latn",
    Breton => "br",
    "Breton France" => "br-FR",
    Bulgarian => "bg",
    "Bulgarian Bulgaria" => "bg-BG",
    Burmese => "my",
    "Burmese Myanmar (Burma)" => "my-MM",
    Cantonese => "yue",
    "Cantonese China Simplified" => "yue-Hans-CN",
    "Cantonese Hong Kong SAR China Traditional" => "yue-Hant-HK",
    "Cantonese Simplified" => "yue-Hans",
    "Cantonese Traditional" => "yue-Hant",
    Catalan => "ca",
    "Catalan Andorra" => "ca-AD",
    "Catalan France" => "ca-FR",
    "Catalan Italy" => "ca-IT",
    "Catalan Spain" => "ca-ES",
    "Catalan Spain Valencian" => "ca-ES-VALENCIA",
    "Central Atlas Tamazight" => "tzm",
    "Central Atlas Tamazight Morocco" => "tzm-MA",
    "Central Kurdish" => "ckb",
    "Central Kurdish Iran" => "ckb-IR",
    "Central Kurdish Iraq" => "ckb-IQ",
    Chakma => "ccp",
    "Chakma Bangladesh" => "ccp-BD",
    "Chakma India" => "ccp-IN",
    Chechen => "ce",
    "Chechen Russia" => "ce-RU",
    Cherokee => "chr",
    "Cherokee United States" => "chr-US",
    Chiga => "cgg",
    "Chiga Uganda" => "cgg-UG",
    Chinese => "zh",
    "Chinese China Simplified" => "zh-Hans-CN",
    "Chinese Hong Kong SAR China Simplified" => "zh-Hans-HK",
    "Chinese Hong Kong SAR China Traditional" => "zh-Hant-HK",
    "Chinese Macau SAR China Simplified" => "zh-Hans-MO",
    "Chinese Macau SAR China Traditional" => "zh-Hant-MO",
    "Chinese Simplified" => "zh-Hans",
    "Chinese Singapore Simplified" => "zh-Hans-SG",
    "Chinese Taiwan Traditional" => "zh-Hant-TW",
    "Chinese Traditional" => "zh-Hant",
    "Church Slavic" => "cu",
    "Church Slavic Russia" => "cu-RU",
    Colognian => "ksh",
    "Colognian Germany" => "ksh-DE",
    Cornish => "kw",
    "Cornish United Kingdom" => "kw-GB",
    Croatian => "hr",
    "Croatian Bosnia & Herzegovina" => "hr-BA",
    "Croatian Croatia" => "hr-HR",
    Czech => "cs",
    "Czech Czechia" => "cs-CZ",
    Danish => "da",
    "Danish Denmark" => "da-DK",
    "Danish Greenland" => "da-GL",
    Duala => "dua",
    "Duala Cameroon" => "dua-CM",
    Dutch => "nl",
    "Dutch Aruba" => "nl-AW",
    "Dutch Belgium" => "nl-BE",
    "Dutch Caribbean Netherlands" => "nl-BQ",
    "Dutch Cura\N{U+00e7}ao" => "nl-CW",
    "Dutch Netherlands" => "nl-NL",
    "Dutch Sint Maarten" => "nl-SX",
    "Dutch Suriname" => "nl-SR",
    Dzongkha => "dz",
    "Dzongkha Bhutan" => "dz-BT",
    Embu => "ebu",
    "Embu Kenya" => "ebu-KE",
    English => "en",
    "English American Samoa" => "en-AS",
    "English Anguilla" => "en-AI",
    "English Antigua & Barbuda" => "en-AG",
    "English Australia" => "en-AU",
    "English Austria" => "en-AT",
    "English Bahamas" => "en-BS",
    "English Barbados" => "en-BB",
    "English Belgium" => "en-BE",
    "English Belize" => "en-BZ",
    "English Bermuda" => "en-BM",
    "English Botswana" => "en-BW",
    "English British Indian Ocean Territory" => "en-IO",
    "English British Virgin Islands" => "en-VG",
    "English Burundi" => "en-BI",
    "English Cameroon" => "en-CM",
    "English Canada" => "en-CA",
    "English Cayman Islands" => "en-KY",
    "English Christmas Island" => "en-CX",
    "English Cocos (Keeling) Islands" => "en-CC",
    "English Cook Islands" => "en-CK",
    "English Cyprus" => "en-CY",
    "English Denmark" => "en-DK",
    "English Diego Garcia" => "en-DG",
    "English Dominica" => "en-DM",
    "English Eritrea" => "en-ER",
    "English Europe" => "en-150",
    "English Falkland Islands" => "en-FK",
    "English Fiji" => "en-FJ",
    "English Finland" => "en-FI",
    "English Gambia" => "en-GM",
    "English Germany" => "en-DE",
    "English Ghana" => "en-GH",
    "English Gibraltar" => "en-GI",
    "English Grenada" => "en-GD",
    "English Guam" => "en-GU",
    "English Guernsey" => "en-GG",
    "English Guyana" => "en-GY",
    "English Hong Kong SAR China" => "en-HK",
    "English India" => "en-IN",
    "English Ireland" => "en-IE",
    "English Isle of Man" => "en-IM",
    "English Israel" => "en-IL",
    "English Jamaica" => "en-JM",
    "English Jersey" => "en-JE",
    "English Kenya" => "en-KE",
    "English Kiribati" => "en-KI",
    "English Lesotho" => "en-LS",
    "English Liberia" => "en-LR",
    "English Macau SAR China" => "en-MO",
    "English Madagascar" => "en-MG",
    "English Malawi" => "en-MW",
    "English Malaysia" => "en-MY",
    "English Malta" => "en-MT",
    "English Marshall Islands" => "en-MH",
    "English Mauritius" => "en-MU",
    "English Micronesia" => "en-FM",
    "English Montserrat" => "en-MS",
    "English Namibia" => "en-NA",
    "English Nauru" => "en-NR",
    "English Netherlands" => "en-NL",
    "English New Zealand" => "en-NZ",
    "English Nigeria" => "en-NG",
    "English Niue" => "en-NU",
    "English Norfolk Island" => "en-NF",
    "English Northern Mariana Islands" => "en-MP",
    "English Pakistan" => "en-PK",
    "English Palau" => "en-PW",
    "English Papua New Guinea" => "en-PG",
    "English Philippines" => "en-PH",
    "English Pitcairn Islands" => "en-PN",
    "English Puerto Rico" => "en-PR",
    "English Rwanda" => "en-RW",
    "English Samoa" => "en-WS",
    "English Seychelles" => "en-SC",
    "English Sierra Leone" => "en-SL",
    "English Singapore" => "en-SG",
    "English Sint Maarten" => "en-SX",
    "English Slovenia" => "en-SI",
    "English Solomon Islands" => "en-SB",
    "English South Africa" => "en-ZA",
    "English South Sudan" => "en-SS",
    "English St. Helena" => "en-SH",
    "English St. Kitts & Nevis" => "en-KN",
    "English St. Lucia" => "en-LC",
    "English St. Vincent & Grenadines" => "en-VC",
    "English Sudan" => "en-SD",
    "English Swaziland" => "en-SZ",
    "English Sweden" => "en-SE",
    "English Switzerland" => "en-CH",
    "English Tanzania" => "en-TZ",
    "English Tokelau" => "en-TK",
    "English Tonga" => "en-TO",
    "English Trinidad & Tobago" => "en-TT",
    "English Turks & Caicos Islands" => "en-TC",
    "English Tuvalu" => "en-TV",
    "English U.S. Outlying Islands" => "en-UM",
    "English U.S. Virgin Islands" => "en-VI",
    "English Uganda" => "en-UG",
    "English United Kingdom" => "en-GB",
    "English United States" => "en-US",
    "English United States Computer" => "en-US-POSIX",
    "English Vanuatu" => "en-VU",
    "English World" => "en-001",
    "English Zambia" => "en-ZM",
    "English Zimbabwe" => "en-ZW",
    Esperanto => "eo",
    "Esperanto World" => "eo-001",
    Estonian => "et",
    "Estonian Estonia" => "et-EE",
    Ewe => "ee",
    "Ewe Ghana" => "ee-GH",
    "Ewe Togo" => "ee-TG",
    Ewondo => "ewo",
    "Ewondo Cameroon" => "ewo-CM",
    Faroese => "fo",
    "Faroese Denmark" => "fo-DK",
    "Faroese Faroe Islands" => "fo-FO",
    Filipino => "fil",
    "Filipino Philippines" => "fil-PH",
    Finnish => "fi",
    "Finnish Finland" => "fi-FI",
    French => "fr",
    "French Algeria" => "fr-DZ",
    "French Belgium" => "fr-BE",
    "French Benin" => "fr-BJ",
    "French Burkina Faso" => "fr-BF",
    "French Burundi" => "fr-BI",
    "French Cameroon" => "fr-CM",
    "French Canada" => "fr-CA",
    "French Central African Republic" => "fr-CF",
    "French Chad" => "fr-TD",
    "French Comoros" => "fr-KM",
    "French Congo - Brazzaville" => "fr-CG",
    "French Congo - Kinshasa" => "fr-CD",
    "French C\N{U+00f4}te d\N{U+2019}Ivoire" => "fr-CI",
    "French Djibouti" => "fr-DJ",
    "French Equatorial Guinea" => "fr-GQ",
    "French France" => "fr-FR",
    "French French Guiana" => "fr-GF",
    "French French Polynesia" => "fr-PF",
    "French Gabon" => "fr-GA",
    "French Guadeloupe" => "fr-GP",
    "French Guinea" => "fr-GN",
    "French Haiti" => "fr-HT",
    "French Luxembourg" => "fr-LU",
    "French Madagascar" => "fr-MG",
    "French Mali" => "fr-ML",
    "French Martinique" => "fr-MQ",
    "French Mauritania" => "fr-MR",
    "French Mauritius" => "fr-MU",
    "French Mayotte" => "fr-YT",
    "French Monaco" => "fr-MC",
    "French Morocco" => "fr-MA",
    "French New Caledonia" => "fr-NC",
    "French Niger" => "fr-NE",
    "French Rwanda" => "fr-RW",
    "French R\N{U+00e9}union" => "fr-RE",
    "French Senegal" => "fr-SN",
    "French Seychelles" => "fr-SC",
    "French St. Barth\N{U+00e9}lemy" => "fr-BL",
    "French St. Martin" => "fr-MF",
    "French St. Pierre & Miquelon" => "fr-PM",
    "French Switzerland" => "fr-CH",
    "French Syria" => "fr-SY",
    "French Togo" => "fr-TG",
    "French Tunisia" => "fr-TN",
    "French Vanuatu" => "fr-VU",
    "French Wallis & Futuna" => "fr-WF",
    Friulian => "fur",
    "Friulian Italy" => "fur-IT",
    Fulah => "ff",
    "Fulah Cameroon" => "ff-CM",
    "Fulah Guinea" => "ff-GN",
    "Fulah Mauritania" => "ff-MR",
    "Fulah Senegal" => "ff-SN",
    Galician => "gl",
    "Galician Spain" => "gl-ES",
    Ganda => "lg",
    "Ganda Uganda" => "lg-UG",
    Georgian => "ka",
    "Georgian Georgia" => "ka-GE",
    German => "de",
    "German Austria" => "de-AT",
    "German Belgium" => "de-BE",
    "German Germany" => "de-DE",
    "German Italy" => "de-IT",
    "German Liechtenstein" => "de-LI",
    "German Luxembourg" => "de-LU",
    "German Switzerland" => "de-CH",
    Greek => "el",
    "Greek Cyprus" => "el-CY",
    "Greek Greece" => "el-GR",
    Gujarati => "gu",
    "Gujarati India" => "gu-IN",
    Gusii => "guz",
    "Gusii Kenya" => "guz-KE",
    Hausa => "ha",
    "Hausa Ghana" => "ha-GH",
    "Hausa Niger" => "ha-NE",
    "Hausa Nigeria" => "ha-NG",
    Hawaiian => "haw",
    "Hawaiian United States" => "haw-US",
    Hebrew => "he",
    "Hebrew Israel" => "he-IL",
    Hindi => "hi",
    "Hindi India" => "hi-IN",
    Hungarian => "hu",
    "Hungarian Hungary" => "hu-HU",
    Icelandic => "is",
    "Icelandic Iceland" => "is-IS",
    Igbo => "ig",
    "Igbo Nigeria" => "ig-NG",
    "Inari Sami" => "smn",
    "Inari Sami Finland" => "smn-FI",
    Indonesian => "id",
    "Indonesian Indonesia" => "id-ID",
    Irish => "ga",
    "Irish Ireland" => "ga-IE",
    Italian => "it",
    "Italian Italy" => "it-IT",
    "Italian San Marino" => "it-SM",
    "Italian Switzerland" => "it-CH",
    "Italian Vatican City" => "it-VA",
    Japanese => "ja",
    "Japanese Japan" => "ja-JP",
    "Jola-Fonyi" => "dyo",
    "Jola-Fonyi Senegal" => "dyo-SN",
    Kabuverdianu => "kea",
    "Kabuverdianu Cape Verde" => "kea-CV",
    Kabyle => "kab",
    "Kabyle Algeria" => "kab-DZ",
    Kako => "kkj",
    "Kako Cameroon" => "kkj-CM",
    Kalaallisut => "kl",
    "Kalaallisut Greenland" => "kl-GL",
    Kalenjin => "kln",
    "Kalenjin Kenya" => "kln-KE",
    Kamba => "kam",
    "Kamba Kenya" => "kam-KE",
    Kannada => "kn",
    "Kannada India" => "kn-IN",
    Kashmiri => "ks",
    "Kashmiri India" => "ks-IN",
    Kazakh => "kk",
    "Kazakh Kazakhstan" => "kk-KZ",
    Khmer => "km",
    "Khmer Cambodia" => "km-KH",
    Kikuyu => "ki",
    "Kikuyu Kenya" => "ki-KE",
    Kinyarwanda => "rw",
    "Kinyarwanda Rwanda" => "rw-RW",
    Konkani => "kok",
    "Konkani India" => "kok-IN",
    Korean => "ko",
    "Korean North Korea" => "ko-KP",
    "Korean South Korea" => "ko-KR",
    "Koyra Chiini" => "khq",
    "Koyra Chiini Mali" => "khq-ML",
    "Koyraboro Senni" => "ses",
    "Koyraboro Senni Mali" => "ses-ML",
    Kwasio => "nmg",
    "Kwasio Cameroon" => "nmg-CM",
    Kyrgyz => "ky",
    "Kyrgyz Kyrgyzstan" => "ky-KG",
    Lakota => "lkt",
    "Lakota United States" => "lkt-US",
    Langi => "lag",
    "Langi Tanzania" => "lag-TZ",
    Lao => "lo",
    "Lao Laos" => "lo-LA",
    Latvian => "lv",
    "Latvian Latvia" => "lv-LV",
    Lingala => "ln",
    "Lingala Angola" => "ln-AO",
    "Lingala Central African Republic" => "ln-CF",
    "Lingala Congo - Brazzaville" => "ln-CG",
    "Lingala Congo - Kinshasa" => "ln-CD",
    Lithuanian => "lt",
    "Lithuanian Lithuania" => "lt-LT",
    "Low German" => "nds",
    "Low German Germany" => "nds-DE",
    "Low German Netherlands" => "nds-NL",
    "Lower Sorbian" => "dsb",
    "Lower Sorbian Germany" => "dsb-DE",
    "Luba-Katanga" => "lu",
    "Luba-Katanga Congo - Kinshasa" => "lu-CD",
    Luo => "luo",
    "Luo Kenya" => "luo-KE",
    Luxembourgish => "lb",
    "Luxembourgish Luxembourg" => "lb-LU",
    Luyia => "luy",
    "Luyia Kenya" => "luy-KE",
    Macedonian => "mk",
    "Macedonian Macedonia" => "mk-MK",
    Machame => "jmc",
    "Machame Tanzania" => "jmc-TZ",
    "Makhuwa-Meetto" => "mgh",
    "Makhuwa-Meetto Mozambique" => "mgh-MZ",
    Makonde => "kde",
    "Makonde Tanzania" => "kde-TZ",
    Malagasy => "mg",
    "Malagasy Madagascar" => "mg-MG",
    Malay => "ms",
    "Malay Brunei" => "ms-BN",
    "Malay Malaysia" => "ms-MY",
    "Malay Singapore" => "ms-SG",
    Malayalam => "ml",
    "Malayalam India" => "ml-IN",
    Maltese => "mt",
    "Maltese Malta" => "mt-MT",
    Manx => "gv",
    "Manx Isle of Man" => "gv-IM",
    Marathi => "mr",
    "Marathi India" => "mr-IN",
    Masai => "mas",
    "Masai Kenya" => "mas-KE",
    "Masai Tanzania" => "mas-TZ",
    Mazanderani => "mzn",
    "Mazanderani Iran" => "mzn-IR",
    Meru => "mer",
    "Meru Kenya" => "mer-KE",
    "Meta\N{U+02bc}" => "mgo",
    "Meta\N{U+02bc} Cameroon" => "mgo-CM",
    Mongolian => "mn",
    "Mongolian Mongolia" => "mn-MN",
    Morisyen => "mfe",
    "Morisyen Mauritius" => "mfe-MU",
    Mundang => "mua",
    "Mundang Cameroon" => "mua-CM",
    Nama => "naq",
    "Nama Namibia" => "naq-NA",
    Nepali => "ne",
    "Nepali India" => "ne-IN",
    "Nepali Nepal" => "ne-NP",
    Ngiemboon => "nnh",
    "Ngiemboon Cameroon" => "nnh-CM",
    Ngomba => "jgo",
    "Ngomba Cameroon" => "jgo-CM",
    "North Ndebele" => "nd",
    "North Ndebele Zimbabwe" => "nd-ZW",
    "Northern Luri" => "lrc",
    "Northern Luri Iran" => "lrc-IR",
    "Northern Luri Iraq" => "lrc-IQ",
    "Northern Sami" => "se",
    "Northern Sami Finland" => "se-FI",
    "Northern Sami Norway" => "se-NO",
    "Northern Sami Sweden" => "se-SE",
    "Norwegian Bokm\N{U+00e5}l" => "nb",
    "Norwegian Bokm\N{U+00e5}l Norway" => "nb-NO",
    "Norwegian Bokm\N{U+00e5}l Svalbard & Jan Mayen" => "nb-SJ",
    "Norwegian Nynorsk" => "nn",
    "Norwegian Nynorsk Norway" => "nn-NO",
    Nuer => "nus",
    "Nuer South Sudan" => "nus-SS",
    Nyankole => "nyn",
    "Nyankole Uganda" => "nyn-UG",
    Odia => "or",
    "Odia India" => "or-IN",
    Oromo => "om",
    "Oromo Ethiopia" => "om-ET",
    "Oromo Kenya" => "om-KE",
    Ossetic => "os",
    "Ossetic Georgia" => "os-GE",
    "Ossetic Russia" => "os-RU",
    Pashto => "ps",
    "Pashto Afghanistan" => "ps-AF",
    Persian => "fa",
    "Persian Afghanistan" => "fa-AF",
    "Persian Iran" => "fa-IR",
    Polish => "pl",
    "Polish Poland" => "pl-PL",
    Portuguese => "pt",
    "Portuguese Angola" => "pt-AO",
    "Portuguese Brazil" => "pt-BR",
    "Portuguese Cape Verde" => "pt-CV",
    "Portuguese Equatorial Guinea" => "pt-GQ",
    "Portuguese Guinea-Bissau" => "pt-GW",
    "Portuguese Luxembourg" => "pt-LU",
    "Portuguese Macau SAR China" => "pt-MO",
    "Portuguese Mozambique" => "pt-MZ",
    "Portuguese Portugal" => "pt-PT",
    "Portuguese Switzerland" => "pt-CH",
    "Portuguese S\N{U+00e3}o Tom\N{U+00e9} & Pr\N{U+00ed}ncipe" => "pt-ST",
    "Portuguese Timor-Leste" => "pt-TL",
    Prussian => "prg",
    "Prussian World" => "prg-001",
    Punjabi => "pa",
    "Punjabi Arabic" => "pa-Arab",
    "Punjabi Gurmukhi" => "pa-Guru",
    "Punjabi India Gurmukhi" => "pa-Guru-IN",
    "Punjabi Pakistan Arabic" => "pa-Arab-PK",
    Quechua => "qu",
    "Quechua Bolivia" => "qu-BO",
    "Quechua Ecuador" => "qu-EC",
    "Quechua Peru" => "qu-PE",
    Romanian => "ro",
    "Romanian Moldova" => "ro-MD",
    "Romanian Romania" => "ro-RO",
    Romansh => "rm",
    "Romansh Switzerland" => "rm-CH",
    Rombo => "rof",
    "Rombo Tanzania" => "rof-TZ",
    Root => "root",
    Rundi => "rn",
    "Rundi Burundi" => "rn-BI",
    Russian => "ru",
    "Russian Belarus" => "ru-BY",
    "Russian Kazakhstan" => "ru-KZ",
    "Russian Kyrgyzstan" => "ru-KG",
    "Russian Moldova" => "ru-MD",
    "Russian Russia" => "ru-RU",
    "Russian Ukraine" => "ru-UA",
    Rwa => "rwk",
    "Rwa Tanzania" => "rwk-TZ",
    Sakha => "sah",
    "Sakha Russia" => "sah-RU",
    Samburu => "saq",
    "Samburu Kenya" => "saq-KE",
    Sango => "sg",
    "Sango Central African Republic" => "sg-CF",
    Sangu => "sbp",
    "Sangu Tanzania" => "sbp-TZ",
    "Scottish Gaelic" => "gd",
    "Scottish Gaelic United Kingdom" => "gd-GB",
    Sena => "seh",
    "Sena Mozambique" => "seh-MZ",
    Serbian => "sr",
    "Serbian Bosnia & Herzegovina Cyrillic" => "sr-Cyrl-BA",
    "Serbian Bosnia & Herzegovina Latin" => "sr-Latn-BA",
    "Serbian Cyrillic" => "sr-Cyrl",
    "Serbian Kosovo Cyrillic" => "sr-Cyrl-XK",
    "Serbian Kosovo Latin" => "sr-Latn-XK",
    "Serbian Latin" => "sr-Latn",
    "Serbian Montenegro Cyrillic" => "sr-Cyrl-ME",
    "Serbian Montenegro Latin" => "sr-Latn-ME",
    "Serbian Serbia Cyrillic" => "sr-Cyrl-RS",
    "Serbian Serbia Latin" => "sr-Latn-RS",
    Shambala => "ksb",
    "Shambala Tanzania" => "ksb-TZ",
    Shona => "sn",
    "Shona Zimbabwe" => "sn-ZW",
    "Sichuan Yi" => "ii",
    "Sichuan Yi China" => "ii-CN",
    Sindhi => "sd",
    "Sindhi Pakistan" => "sd-PK",
    Sinhala => "si",
    "Sinhala Sri Lanka" => "si-LK",
    Slovak => "sk",
    "Slovak Slovakia" => "sk-SK",
    Slovenian => "sl",
    "Slovenian Slovenia" => "sl-SI",
    Soga => "xog",
    "Soga Uganda" => "xog-UG",
    Somali => "so",
    "Somali Djibouti" => "so-DJ",
    "Somali Ethiopia" => "so-ET",
    "Somali Kenya" => "so-KE",
    "Somali Somalia" => "so-SO",
    Spanish => "es",
    "Spanish Argentina" => "es-AR",
    "Spanish Belize" => "es-BZ",
    "Spanish Bolivia" => "es-BO",
    "Spanish Brazil" => "es-BR",
    "Spanish Canary Islands" => "es-IC",
    "Spanish Ceuta & Melilla" => "es-EA",
    "Spanish Chile" => "es-CL",
    "Spanish Colombia" => "es-CO",
    "Spanish Costa Rica" => "es-CR",
    "Spanish Cuba" => "es-CU",
    "Spanish Dominican Republic" => "es-DO",
    "Spanish Ecuador" => "es-EC",
    "Spanish El Salvador" => "es-SV",
    "Spanish Equatorial Guinea" => "es-GQ",
    "Spanish Guatemala" => "es-GT",
    "Spanish Honduras" => "es-HN",
    "Spanish Latin America" => "es-419",
    "Spanish Mexico" => "es-MX",
    "Spanish Nicaragua" => "es-NI",
    "Spanish Panama" => "es-PA",
    "Spanish Paraguay" => "es-PY",
    "Spanish Peru" => "es-PE",
    "Spanish Philippines" => "es-PH",
    "Spanish Puerto Rico" => "es-PR",
    "Spanish Spain" => "es-ES",
    "Spanish United States" => "es-US",
    "Spanish Uruguay" => "es-UY",
    "Spanish Venezuela" => "es-VE",
    "Standard Moroccan Tamazight" => "zgh",
    "Standard Moroccan Tamazight Morocco" => "zgh-MA",
    Swahili => "sw",
    "Swahili Congo - Kinshasa" => "sw-CD",
    "Swahili Kenya" => "sw-KE",
    "Swahili Tanzania" => "sw-TZ",
    "Swahili Uganda" => "sw-UG",
    Swedish => "sv",
    "Swedish Finland" => "sv-FI",
    "Swedish Sweden" => "sv-SE",
    "Swedish \N{U+00c5}land Islands" => "sv-AX",
    "Swiss German" => "gsw",
    "Swiss German France" => "gsw-FR",
    "Swiss German Liechtenstein" => "gsw-LI",
    "Swiss German Switzerland" => "gsw-CH",
    Tachelhit => "shi",
    "Tachelhit Latin" => "shi-Latn",
    "Tachelhit Morocco Latin" => "shi-Latn-MA",
    "Tachelhit Morocco Tifinagh" => "shi-Tfng-MA",
    "Tachelhit Tifinagh" => "shi-Tfng",
    Taita => "dav",
    "Taita Kenya" => "dav-KE",
    Tajik => "tg",
    "Tajik Tajikistan" => "tg-TJ",
    Tamil => "ta",
    "Tamil India" => "ta-IN",
    "Tamil Malaysia" => "ta-MY",
    "Tamil Singapore" => "ta-SG",
    "Tamil Sri Lanka" => "ta-LK",
    Tasawaq => "twq",
    "Tasawaq Niger" => "twq-NE",
    Tatar => "tt",
    "Tatar Russia" => "tt-RU",
    Telugu => "te",
    "Telugu India" => "te-IN",
    Teso => "teo",
    "Teso Kenya" => "teo-KE",
    "Teso Uganda" => "teo-UG",
    Thai => "th",
    "Thai Thailand" => "th-TH",
    Tibetan => "bo",
    "Tibetan China" => "bo-CN",
    "Tibetan India" => "bo-IN",
    Tigrinya => "ti",
    "Tigrinya Eritrea" => "ti-ER",
    "Tigrinya Ethiopia" => "ti-ET",
    Tongan => "to",
    "Tongan Tonga" => "to-TO",
    Turkish => "tr",
    "Turkish Cyprus" => "tr-CY",
    "Turkish Turkey" => "tr-TR",
    Turkmen => "tk",
    "Turkmen Turkmenistan" => "tk-TM",
    Ukrainian => "uk",
    "Ukrainian Ukraine" => "uk-UA",
    "Upper Sorbian" => "hsb",
    "Upper Sorbian Germany" => "hsb-DE",
    Urdu => "ur",
    "Urdu India" => "ur-IN",
    "Urdu Pakistan" => "ur-PK",
    Uyghur => "ug",
    "Uyghur China" => "ug-CN",
    Uzbek => "uz",
    "Uzbek Afghanistan Arabic" => "uz-Arab-AF",
    "Uzbek Arabic" => "uz-Arab",
    "Uzbek Cyrillic" => "uz-Cyrl",
    "Uzbek Latin" => "uz-Latn",
    "Uzbek Uzbekistan Cyrillic" => "uz-Cyrl-UZ",
    "Uzbek Uzbekistan Latin" => "uz-Latn-UZ",
    Vai => "vai",
    "Vai Latin" => "vai-Latn",
    "Vai Liberia Latin" => "vai-Latn-LR",
    "Vai Liberia Vai" => "vai-Vaii-LR",
    "Vai Vai" => "vai-Vaii",
    Vietnamese => "vi",
    "Vietnamese Vietnam" => "vi-VN",
    "Volap\N{U+00fc}k" => "vo",
    "Volap\N{U+00fc}k World" => "vo-001",
    Vunjo => "vun",
    "Vunjo Tanzania" => "vun-TZ",
    Walser => "wae",
    "Walser Switzerland" => "wae-CH",
    Welsh => "cy",
    "Welsh United Kingdom" => "cy-GB",
    "Western Frisian" => "fy",
    "Western Frisian Netherlands" => "fy-NL",
    Wolof => "wo",
    "Wolof Senegal" => "wo-SN",
    Yangben => "yav",
    "Yangben Cameroon" => "yav-CM",
    Yiddish => "yi",
    "Yiddish World" => "yi-001",
    Yoruba => "yo",
    "Yoruba Benin" => "yo-BJ",
    "Yoruba Nigeria" => "yo-NG",
    Zarma => "dje",
    "Zarma Niger" => "dje-NE",
    Zulu => "zu",
    "Zulu South Africa" => "zu-ZA",
  );
  ### :end Names:
  #>>>
  
  #<<<
  ### :start NativeNames:
  our %NativeNames = (
    Afrikaans => "af",
    "Afrikaans Namibi\N{U+00eb}" => "af-NA",
    "Afrikaans Suid-Afrika" => "af-ZA",
    Aghem => "agq",
    "Aghem K\N{U+00e0}m\N{U+00e0}l\N{U+00fb}\N{U+014b}" => "agq-CM",
    Akan => "ak",
    "Akan Gaana" => "ak-GH",
    Chimakonde => "kde",
    "Chimakonde Tanzania" => "kde-TZ",
    Cymraeg => "cy",
    "Cymraeg Y Deyrnas Unedig" => "cy-GB",
    DE => "nds-DE",
    Deutsch => "de",
    "Deutsch Belgien" => "de-BE",
    "Deutsch Deutschland" => "de-DE",
    "Deutsch Italien" => "de-IT",
    "Deutsch Liechtenstein" => "de-LI",
    "Deutsch Luxemburg" => "de-LU",
    "Deutsch Schweiz" => "de-CH",
    "Deutsch \N{U+00d6}sterreich" => "de-AT",
    Dholuo => "luo",
    "Dholuo Kenya" => "luo-KE",
    Ekegusii => "guz",
    "Ekegusii Kenya" => "guz-KE",
    English => "en",
    "English American Samoa" => "en-AS",
    "English Anguilla" => "en-AI",
    "English Antigua & Barbuda" => "en-AG",
    "English Australia" => "en-AU",
    "English Austria" => "en-AT",
    "English Bahamas" => "en-BS",
    "English Barbados" => "en-BB",
    "English Belgium" => "en-BE",
    "English Belize" => "en-BZ",
    "English Bermuda" => "en-BM",
    "English Botswana" => "en-BW",
    "English British Indian Ocean Territory" => "en-IO",
    "English British Virgin Islands" => "en-VG",
    "English Burundi" => "en-BI",
    "English Cameroon" => "en-CM",
    "English Canada" => "en-CA",
    "English Cayman Islands" => "en-KY",
    "English Christmas Island" => "en-CX",
    "English Cocos (Keeling) Islands" => "en-CC",
    "English Cook Islands" => "en-CK",
    "English Cyprus" => "en-CY",
    "English Denmark" => "en-DK",
    "English Diego Garcia" => "en-DG",
    "English Dominica" => "en-DM",
    "English Eritrea" => "en-ER",
    "English Europe" => "en-150",
    "English Falkland Islands" => "en-FK",
    "English Fiji" => "en-FJ",
    "English Finland" => "en-FI",
    "English Gambia" => "en-GM",
    "English Germany" => "en-DE",
    "English Ghana" => "en-GH",
    "English Gibraltar" => "en-GI",
    "English Grenada" => "en-GD",
    "English Guam" => "en-GU",
    "English Guernsey" => "en-GG",
    "English Guyana" => "en-GY",
    "English Hong Kong SAR China" => "en-HK",
    "English India" => "en-IN",
    "English Ireland" => "en-IE",
    "English Isle of Man" => "en-IM",
    "English Israel" => "en-IL",
    "English Jamaica" => "en-JM",
    "English Jersey" => "en-JE",
    "English Kenya" => "en-KE",
    "English Kiribati" => "en-KI",
    "English Lesotho" => "en-LS",
    "English Liberia" => "en-LR",
    "English Macau SAR China" => "en-MO",
    "English Madagascar" => "en-MG",
    "English Malawi" => "en-MW",
    "English Malaysia" => "en-MY",
    "English Malta" => "en-MT",
    "English Marshall Islands" => "en-MH",
    "English Mauritius" => "en-MU",
    "English Micronesia" => "en-FM",
    "English Montserrat" => "en-MS",
    "English Namibia" => "en-NA",
    "English Nauru" => "en-NR",
    "English Netherlands" => "en-NL",
    "English New Zealand" => "en-NZ",
    "English Nigeria" => "en-NG",
    "English Niue" => "en-NU",
    "English Norfolk Island" => "en-NF",
    "English Northern Mariana Islands" => "en-MP",
    "English Pakistan" => "en-PK",
    "English Palau" => "en-PW",
    "English Papua New Guinea" => "en-PG",
    "English Philippines" => "en-PH",
    "English Pitcairn Islands" => "en-PN",
    "English Puerto Rico" => "en-PR",
    "English Rwanda" => "en-RW",
    "English Samoa" => "en-WS",
    "English Seychelles" => "en-SC",
    "English Sierra Leone" => "en-SL",
    "English Singapore" => "en-SG",
    "English Sint Maarten" => "en-SX",
    "English Slovenia" => "en-SI",
    "English Solomon Islands" => "en-SB",
    "English South Africa" => "en-ZA",
    "English South Sudan" => "en-SS",
    "English St. Helena" => "en-SH",
    "English St. Kitts & Nevis" => "en-KN",
    "English St. Lucia" => "en-LC",
    "English St. Vincent & Grenadines" => "en-VC",
    "English Sudan" => "en-SD",
    "English Swaziland" => "en-SZ",
    "English Sweden" => "en-SE",
    "English Switzerland" => "en-CH",
    "English Tanzania" => "en-TZ",
    "English Tokelau" => "en-TK",
    "English Tonga" => "en-TO",
    "English Trinidad & Tobago" => "en-TT",
    "English Turks & Caicos Islands" => "en-TC",
    "English Tuvalu" => "en-TV",
    "English U.S. Outlying Islands" => "en-UM",
    "English U.S. Virgin Islands" => "en-VI",
    "English Uganda" => "en-UG",
    "English United Kingdom" => "en-GB",
    "English United States" => "en-US",
    "English United States Computer" => "en-US-POSIX",
    "English Vanuatu" => "en-VU",
    "English World" => "en-001",
    "English Zambia" => "en-ZM",
    "English Zimbabwe" => "en-ZW",
    "E\N{U+028b}egbe" => "ee",
    "E\N{U+028b}egbe Ghana nutome" => "ee-GH",
    "E\N{U+028b}egbe Togo nutome" => "ee-TG",
    Filipino => "fil",
    "Filipino Pilipinas" => "fil-PH",
    Frysk => "fy",
    "Frysk Nederl\N{U+00e2}n" => "fy-NL",
    Gaeilge => "ga",
    "Gaeilge \N{U+00c9}ire" => "ga-IE",
    Gaelg => "gv",
    "Gaelg Ellan Vannin" => "gv-IM",
    Gikuyu => "ki",
    "Gikuyu Kenya" => "ki-KE",
    "G\N{U+00e0}idhlig" => "gd",
    "G\N{U+00e0}idhlig An R\N{U+00ec}oghachd Aonaichte" => "gd-GB",
    Hausa => "ha",
    "Hausa Gana" => "ha-GH",
    "Hausa Najeriya" => "ha-NG",
    "Hausa Nijar" => "ha-NE",
    Hibena => "bez",
    "Hibena Hutanzania" => "bez-TZ",
    Ichibemba => "bem",
    "Ichibemba Zambia" => "bem-ZM",
    Igbo => "ig",
    "Igbo Na\N{U+1ecb}j\N{U+1ecb}r\N{U+1ecb}a" => "ig-NG",
    Ikirundi => "rn",
    "Ikirundi Uburundi" => "rn-BI",
    Indonesia => "id",
    "Indonesia Indonesia" => "id-ID",
    Ishisangu => "sbp",
    "Ishisangu Tansaniya" => "sbp-TZ",
    Kalenjin => "kln",
    "Kalenjin Emetab Kenya" => "kln-KE",
    Khoekhoegowab => "naq",
    "Khoekhoegowab Namibiab" => "naq-NA",
    Kihorombo => "rof",
    "Kihorombo Tanzania" => "rof-TZ",
    Kikamba => "kam",
    "Kikamba Kenya" => "kam-KE",
    Kimachame => "jmc",
    "Kimachame Tanzania" => "jmc-TZ",
    Kinyarwanda => "rw",
    "Kinyarwanda U Rwanda" => "rw-RW",
    Kipare => "asa",
    "Kipare Tadhania" => "asa-TZ",
    Kiruwa => "rwk",
    "Kiruwa Tanzania" => "rwk-TZ",
    Kisampur => "saq",
    "Kisampur Kenya" => "saq-KE",
    Kishambaa => "ksb",
    "Kishambaa Tanzania" => "ksb-TZ",
    Kiswahili => "sw",
    "Kiswahili Jamhuri ya Kidemokrasia ya Kongo" => "sw-CD",
    "Kiswahili Kenya" => "sw-KE",
    "Kiswahili Tanzania" => "sw-TZ",
    "Kiswahili Uganda" => "sw-UG",
    Kitaita => "dav",
    "Kitaita Kenya" => "dav-KE",
    Kiteso => "teo",
    "Kiteso Kenia" => "teo-KE",
    "Kiteso Uganda" => "teo-UG",
    "Koyra ciini" => "khq",
    "Koyra ciini Maali" => "khq-ML",
    "Koyraboro senni" => "ses",
    "Koyraboro senni Maali" => "ses-ML",
    Kyivunjo => "vun",
    "Kyivunjo Tanzania" => "vun-TZ",
    "K\N{U+00f6}lsch" => "ksh",
    "K\N{U+00f6}lsch Do\N{U+00fc}tschland" => "ksh-DE",
    "K\N{U+0129}embu" => "ebu",
    "K\N{U+0129}embu Kenya" => "ebu-KE",
    "K\N{U+0129}m\N{U+0129}r\N{U+0169}" => "mer",
    "K\N{U+0129}m\N{U+0129}r\N{U+0169} Kenya" => "mer-KE",
    "K\N{U+0268}laangi" => "lag",
    "K\N{U+0268}laangi Taansan\N{U+00ed}a" => "lag-TZ",
    "Lak\N{U+021f}\N{U+00f3}l\N{U+02bc}iyapi" => "lkt",
    "Lak\N{U+021f}\N{U+00f3}l\N{U+02bc}iyapi M\N{U+00ed}laha\N{U+014b}ska T\N{U+021f}am\N{U+00e1}k\N{U+021f}o\N{U+010d}he" => "lkt-US",
    Luganda => "lg",
    "Luganda Yuganda" => "lg-UG",
    Luluhia => "luy",
    "Luluhia Kenya" => "luy-KE",
    "L\N{U+00eb}tzebuergesch" => "lb",
    "L\N{U+00eb}tzebuergesch L\N{U+00eb}tzebuerg" => "lb-LU",
    "MUNDA\N{U+014a}" => "mua",
    "MUNDA\N{U+014a} kameru\N{U+014b}" => "mua-CM",
    Maa => "mas",
    "Maa Kenya" => "mas-KE",
    "Maa Tansania" => "mas-TZ",
    Makua => "mgh",
    "Makua Umozambiki" => "mgh-MZ",
    Malagasy => "mg",
    "Malagasy Madagasikara" => "mg-MG",
    Malti => "mt",
    "Malti Malta" => "mt-MT",
    Melayu => "ms",
    "Melayu Brunei" => "ms-BN",
    "Melayu Malaysia" => "ms-MY",
    "Melayu Singapura" => "ms-SG",
    NL => "nds-NL",
    "Nda\N{U+a78c}a" => "jgo",
    "Nda\N{U+a78c}a Kam\N{U+025b}l\N{U+00fb}n" => "jgo-CM",
    Nederlands => "nl",
    "Nederlands Aruba" => "nl-AW",
    "Nederlands Belgi\N{U+00eb}" => "nl-BE",
    "Nederlands Caribisch Nederland" => "nl-BQ",
    "Nederlands Cura\N{U+00e7}ao" => "nl-CW",
    "Nederlands Nederland" => "nl-NL",
    "Nederlands Sint-Maarten" => "nl-SX",
    "Nederlands Suriname" => "nl-SR",
    Olusoga => "xog",
    "Olusoga Yuganda" => "xog-UG",
    Oromoo => "om",
    "Oromoo Itoophiyaa" => "om-ET",
    "Oromoo Keeniyaa" => "om-KE",
    Pulaar => "ff",
    "Pulaar Gine" => "ff-GN",
    "Pulaar Kameruun" => "ff-CM",
    "Pulaar Muritani" => "ff-MR",
    "Pulaar Senegaal" => "ff-SN",
    Rukiga => "cgg",
    "Rukiga Uganda" => "cgg-UG",
    Runasimi => "qu",
    "Runasimi Bolivia" => "qu-BO",
    "Runasimi Ecuador" => "qu-EC",
    "Runasimi Per\N{U+00fa}" => "qu-PE",
    Runyankore => "nyn",
    "Runyankore Uganda" => "nyn-UG",
    "Schwiizert\N{U+00fc}\N{U+00fc}tsch" => "gsw",
    "Schwiizert\N{U+00fc}\N{U+00fc}tsch Frankriich" => "gsw-FR",
    "Schwiizert\N{U+00fc}\N{U+00fc}tsch Li\N{U+00e4}chtescht\N{U+00e4}i" => "gsw-LI",
    "Schwiizert\N{U+00fc}\N{U+00fc}tsch Schwiiz" => "gsw-CH",
    "Shw\N{U+00f3}\N{U+014b}\N{U+00f2} ngiemb\N{U+0254}\N{U+0254}n" => "nnh",
    "Shw\N{U+00f3}\N{U+014b}\N{U+00f2} ngiemb\N{U+0254}\N{U+0254}n K\N{U+00e0}mal\N{U+00fb}m" => "nnh-CM",
    Soomaali => "so",
    "Soomaali Itoobiya" => "so-ET",
    "Soomaali Jabuuti" => "so-DJ",
    "Soomaali Kiiniya" => "so-KE",
    "Soomaali Soomaaliya" => "so-SO",
    "S\N{U+00e4}ng\N{U+00f6}" => "sg",
    "S\N{U+00e4}ng\N{U+00f6} K\N{U+00f6}d\N{U+00f6}r\N{U+00f6}s\N{U+00ea}se t\N{U+00ee} B\N{U+00ea}afr\N{U+00ee}ka" => "sg-CF",
    "Tamazi\N{U+0263}t n la\N{U+1e6d}la\N{U+1e63}" => "tzm",
    "Tamazi\N{U+0263}t n la\N{U+1e6d}la\N{U+1e63} Me\N{U+1e5b}\N{U+1e5b}uk" => "tzm-MA",
    Taqbaylit => "kab",
    "Taqbaylit Lezzayer" => "kab-DZ",
    "Tasawaq senni" => "twq",
    "Tasawaq senni Ni\N{U+017e}er" => "twq-NE",
    "Tashel\N{U+1e25}iyt Latn" => "shi-Latn",
    "Tashel\N{U+1e25}iyt lm\N{U+0263}rib Latn" => "shi-Latn-MA",
    "Thok Nath" => "nus",
    "Thok Nath SS" => "nus-SS",
    "Ti\N{U+1ebf}ng Vi\N{U+1ec7}t" => "vi",
    "Ti\N{U+1ebf}ng Vi\N{U+1ec7}t Vi\N{U+1ec7}t Nam" => "vi-VN",
    Tshiluba => "lu",
    "Tshiluba Ditunga wa Kongu" => "lu-CD",
    "T\N{U+00fc}rk\N{U+00e7}e" => "tr",
    "T\N{U+00fc}rk\N{U+00e7}e K\N{U+0131}br\N{U+0131}s" => "tr-CY",
    "T\N{U+00fc}rk\N{U+00e7}e T\N{U+00fc}rkiye" => "tr-TR",
    "Vai Laibhiya Latn" => "vai-Latn-LR",
    "Vai Latn" => "vai-Latn",
    Walser => "wae",
    "Walser Schwiz" => "wae-CH",
    Wolof => "wo",
    "Wolof Senegaal" => "wo-SN",
    Zarmaciine => "dje",
    "Zarmaciine Ni\N{U+017e}er" => "dje-NE",
    "anar\N{U+00e2}\N{U+0161}kiel\N{U+00e2}" => "smn",
    "anar\N{U+00e2}\N{U+0161}kiel\N{U+00e2} Suom\N{U+00e2}" => "smn-FI",
    asturianu => "ast",
    "asturianu Espa\N{U+00f1}a" => "ast-ES",
    "az\N{U+0259}rbaycan" => "az",
    "az\N{U+0259}rbaycan Az\N{U+0259}rbaycan lat\N{U+0131}n" => "az-Latn-AZ",
    "az\N{U+0259}rbaycan lat\N{U+0131}n" => "az-Latn",
    bamanakan => "bm",
    "bamanakan Mali" => "bm-ML",
    bosanski => "bs",
    "bosanski Bosna i Hercegovina latinica" => "bs-Latn-BA",
    "bosanski latinica" => "bs-Latn",
    brezhoneg => "br",
    "brezhoneg Fra\N{U+00f1}s" => "br-FR",
    "catal\N{U+00e0}" => "ca",
    "catal\N{U+00e0} Andorra" => "ca-AD",
    "catal\N{U+00e0} Espanya" => "ca-ES",
    "catal\N{U+00e0} Espanya valenci\N{U+00e0}" => "ca-ES-VALENCIA",
    "catal\N{U+00e0} Fran\N{U+00e7}a" => "ca-FR",
    "catal\N{U+00e0} It\N{U+00e0}lia" => "ca-IT",
    chiShona => "sn",
    "chiShona Zimbabwe" => "sn-ZW",
    cu => "cu",
    "cu RU" => "cu-RU",
    dansk => "da",
    "dansk Danmark" => "da-DK",
    "dansk Gr\N{U+00f8}nland" => "da-GL",
    "davvis\N{U+00e1}megiella" => "se",
    "davvis\N{U+00e1}megiella Norga" => "se-NO",
    "davvis\N{U+00e1}megiella Ruo\N{U+0167}\N{U+0167}a" => "se-SE",
    "davvis\N{U+00e1}megiella Suopma" => "se-FI",
    "dolnoserb\N{U+0161}\N{U+0107}ina" => "dsb",
    "dolnoserb\N{U+0161}\N{U+0107}ina Nimska" => "dsb-DE",
    "du\N{U+00e1}l\N{U+00e1}" => "dua",
    "du\N{U+00e1}l\N{U+00e1} Cameroun" => "dua-CM",
    eesti => "et",
    "eesti Eesti" => "et-EE",
    "espa\N{U+00f1}ol" => "es",
    "espa\N{U+00f1}ol Argentina" => "es-AR",
    "espa\N{U+00f1}ol Belice" => "es-BZ",
    "espa\N{U+00f1}ol Bolivia" => "es-BO",
    "espa\N{U+00f1}ol Brasil" => "es-BR",
    "espa\N{U+00f1}ol Canarias" => "es-IC",
    "espa\N{U+00f1}ol Ceuta y Melilla" => "es-EA",
    "espa\N{U+00f1}ol Chile" => "es-CL",
    "espa\N{U+00f1}ol Colombia" => "es-CO",
    "espa\N{U+00f1}ol Costa Rica" => "es-CR",
    "espa\N{U+00f1}ol Cuba" => "es-CU",
    "espa\N{U+00f1}ol Ecuador" => "es-EC",
    "espa\N{U+00f1}ol El Salvador" => "es-SV",
    "espa\N{U+00f1}ol Espa\N{U+00f1}a" => "es-ES",
    "espa\N{U+00f1}ol Estados Unidos" => "es-US",
    "espa\N{U+00f1}ol Filipinas" => "es-PH",
    "espa\N{U+00f1}ol Guatemala" => "es-GT",
    "espa\N{U+00f1}ol Guinea Ecuatorial" => "es-GQ",
    "espa\N{U+00f1}ol Honduras" => "es-HN",
    "espa\N{U+00f1}ol Latinoam\N{U+00e9}rica" => "es-419",
    "espa\N{U+00f1}ol M\N{U+00e9}xico" => "es-MX",
    "espa\N{U+00f1}ol Nicaragua" => "es-NI",
    "espa\N{U+00f1}ol Panam\N{U+00e1}" => "es-PA",
    "espa\N{U+00f1}ol Paraguay" => "es-PY",
    "espa\N{U+00f1}ol Per\N{U+00fa}" => "es-PE",
    "espa\N{U+00f1}ol Puerto Rico" => "es-PR",
    "espa\N{U+00f1}ol Rep\N{U+00fa}blica Dominicana" => "es-DO",
    "espa\N{U+00f1}ol Uruguay" => "es-UY",
    "espa\N{U+00f1}ol Venezuela" => "es-VE",
    esperanto => "eo",
    "esperanto 001" => "eo-001",
    euskara => "eu",
    "euskara Espainia" => "eu-ES",
    ewondo => "ewo",
    "ewondo Kam\N{U+0259}r\N{U+00fa}n" => "ewo-CM",
    "fran\N{U+00e7}ais" => "fr",
    "fran\N{U+00e7}ais Alg\N{U+00e9}rie" => "fr-DZ",
    "fran\N{U+00e7}ais Belgique" => "fr-BE",
    "fran\N{U+00e7}ais Burkina Faso" => "fr-BF",
    "fran\N{U+00e7}ais Burundi" => "fr-BI",
    "fran\N{U+00e7}ais B\N{U+00e9}nin" => "fr-BJ",
    "fran\N{U+00e7}ais Cameroun" => "fr-CM",
    "fran\N{U+00e7}ais Canada" => "fr-CA",
    "fran\N{U+00e7}ais Comores" => "fr-KM",
    "fran\N{U+00e7}ais Congo-Brazzaville" => "fr-CG",
    "fran\N{U+00e7}ais Congo-Kinshasa" => "fr-CD",
    "fran\N{U+00e7}ais C\N{U+00f4}te d\N{U+2019}Ivoire" => "fr-CI",
    "fran\N{U+00e7}ais Djibouti" => "fr-DJ",
    "fran\N{U+00e7}ais France" => "fr-FR",
    "fran\N{U+00e7}ais Gabon" => "fr-GA",
    "fran\N{U+00e7}ais Guadeloupe" => "fr-GP",
    "fran\N{U+00e7}ais Guin\N{U+00e9}e" => "fr-GN",
    "fran\N{U+00e7}ais Guin\N{U+00e9}e \N{U+00e9}quatoriale" => "fr-GQ",
    "fran\N{U+00e7}ais Guyane fran\N{U+00e7}aise" => "fr-GF",
    "fran\N{U+00e7}ais Ha\N{U+00ef}ti" => "fr-HT",
    "fran\N{U+00e7}ais La R\N{U+00e9}union" => "fr-RE",
    "fran\N{U+00e7}ais Luxembourg" => "fr-LU",
    "fran\N{U+00e7}ais Madagascar" => "fr-MG",
    "fran\N{U+00e7}ais Mali" => "fr-ML",
    "fran\N{U+00e7}ais Maroc" => "fr-MA",
    "fran\N{U+00e7}ais Martinique" => "fr-MQ",
    "fran\N{U+00e7}ais Maurice" => "fr-MU",
    "fran\N{U+00e7}ais Mauritanie" => "fr-MR",
    "fran\N{U+00e7}ais Mayotte" => "fr-YT",
    "fran\N{U+00e7}ais Monaco" => "fr-MC",
    "fran\N{U+00e7}ais Niger" => "fr-NE",
    "fran\N{U+00e7}ais Nouvelle-Cal\N{U+00e9}donie" => "fr-NC",
    "fran\N{U+00e7}ais Polyn\N{U+00e9}sie fran\N{U+00e7}aise" => "fr-PF",
    "fran\N{U+00e7}ais Rwanda" => "fr-RW",
    "fran\N{U+00e7}ais R\N{U+00e9}publique centrafricaine" => "fr-CF",
    "fran\N{U+00e7}ais Saint-Barth\N{U+00e9}lemy" => "fr-BL",
    "fran\N{U+00e7}ais Saint-Martin" => "fr-MF",
    "fran\N{U+00e7}ais Saint-Pierre-et-Miquelon" => "fr-PM",
    "fran\N{U+00e7}ais Seychelles" => "fr-SC",
    "fran\N{U+00e7}ais Suisse" => "fr-CH",
    "fran\N{U+00e7}ais Syrie" => "fr-SY",
    "fran\N{U+00e7}ais S\N{U+00e9}n\N{U+00e9}gal" => "fr-SN",
    "fran\N{U+00e7}ais Tchad" => "fr-TD",
    "fran\N{U+00e7}ais Togo" => "fr-TG",
    "fran\N{U+00e7}ais Tunisie" => "fr-TN",
    "fran\N{U+00e7}ais Vanuatu" => "fr-VU",
    "fran\N{U+00e7}ais Wallis-et-Futuna" => "fr-WF",
    furlan => "fur",
    "furlan Italie" => "fur-IT",
    "f\N{U+00f8}royskt" => "fo",
    "f\N{U+00f8}royskt Danmark" => "fo-DK",
    "f\N{U+00f8}royskt F\N{U+00f8}royar" => "fo-FO",
    galego => "gl",
    "galego Espa\N{U+00f1}a" => "gl-ES",
    "hornjoserb\N{U+0161}\N{U+0107}ina" => "hsb",
    "hornjoserb\N{U+0161}\N{U+0107}ina N\N{U+011b}mska" => "hsb-DE",
    hrvatski => "hr",
    "hrvatski Bosna i Hercegovina" => "hr-BA",
    "hrvatski Hrvatska" => "hr-HR",
    isiNdebele => "nd",
    "isiNdebele Zimbabwe" => "nd-ZW",
    isiZulu => "zu",
    "isiZulu iNingizimu Afrika" => "zu-ZA",
    italiano => "it",
    "italiano Citt\N{U+00e0} del Vaticano" => "it-VA",
    "italiano Italia" => "it-IT",
    "italiano San Marino" => "it-SM",
    "italiano Svizzera" => "it-CH",
    joola => "dyo",
    "joola Senegal" => "dyo-SN",
    kabuverdianu => "kea",
    "kabuverdianu Kabu Verdi" => "kea-CV",
    "kak\N{U+0254}" => "kkj",
    "kak\N{U+0254} Kam\N{U+025b}run" => "kkj-CM",
    kalaallisut => "kl",
    "kalaallisut Kalaallit Nunaat" => "kl-GL",
    kernewek => "kw",
    "kernewek Rywvaneth Unys" => "kw-GB",
    "kreol morisien" => "mfe",
    "kreol morisien Moris" => "mfe-MU",
    "latvie\N{U+0161}u" => "lv",
    "latvie\N{U+0161}u Latvija" => "lv-LV",
    "lea fakatonga" => "to",
    "lea fakatonga Tonga" => "to-TO",
    "lietuvi\N{U+0173}" => "lt",
    "lietuvi\N{U+0173} Lietuva" => "lt-LT",
    "ling\N{U+00e1}la" => "ln",
    "ling\N{U+00e1}la Ang\N{U+00f3}la" => "ln-AO",
    "ling\N{U+00e1}la Kongo" => "ln-CG",
    "ling\N{U+00e1}la Repibiki ya Afr\N{U+00ed}ka ya K\N{U+00e1}ti" => "ln-CF",
    "ling\N{U+00e1}la Republ\N{U+00ed}ki ya Kong\N{U+00f3} Demokrat\N{U+00ed}ki" => "ln-CD",
    magyar => "hu",
    "magyar Magyarorsz\N{U+00e1}g" => "hu-HU",
    "meta\N{U+02bc}" => "mgo",
    "meta\N{U+02bc} Kamalun" => "mgo-CM",
    nmg => "nmg",
    "nmg Kamerun" => "nmg-CM",
    "norsk bokm\N{U+00e5}l" => "nb",
    "norsk bokm\N{U+00e5}l Norge" => "nb-NO",
    "norsk bokm\N{U+00e5}l Svalbard og Jan Mayen" => "nb-SJ",
    nuasue => "yav",
    "nuasue Kemel\N{U+00fa}n" => "yav-CM",
    nynorsk => "nn",
    "nynorsk Noreg" => "nn-NO",
    "o\N{U+2018}zbek" => "uz",
    "o\N{U+2018}zbek O\N{U+02bb}zbekiston lotin" => "uz-Latn-UZ",
    "o\N{U+2018}zbek lotin" => "uz-Latn",
    polski => "pl",
    "polski Polska" => "pl-PL",
    "portugu\N{U+00ea}s" => "pt",
    "portugu\N{U+00ea}s Angola" => "pt-AO",
    "portugu\N{U+00ea}s Brasil" => "pt-BR",
    "portugu\N{U+00ea}s Cabo Verde" => "pt-CV",
    "portugu\N{U+00ea}s Guin\N{U+00e9} Equatorial" => "pt-GQ",
    "portugu\N{U+00ea}s Guin\N{U+00e9}-Bissau" => "pt-GW",
    "portugu\N{U+00ea}s Luxemburgo" => "pt-LU",
    "portugu\N{U+00ea}s Macau, RAE da China" => "pt-MO",
    "portugu\N{U+00ea}s Mo\N{U+00e7}ambique" => "pt-MZ",
    "portugu\N{U+00ea}s Portugal" => "pt-PT",
    "portugu\N{U+00ea}s Su\N{U+00ed}\N{U+00e7}a" => "pt-CH",
    "portugu\N{U+00ea}s S\N{U+00e3}o Tom\N{U+00e9} e Pr\N{U+00ed}ncipe" => "pt-ST",
    "portugu\N{U+00ea}s Timor-Leste" => "pt-TL",
    "pr\N{U+016b}siskan" => "prg",
    "pr\N{U+016b}siskan 001" => "prg-001",
    rikpa => "ksf",
    "rikpa kam\N{U+025b}r\N{U+00fa}n" => "ksf-CM",
    "rom\N{U+00e2}n\N{U+0103}" => "ro",
    "rom\N{U+00e2}n\N{U+0103} Republica Moldova" => "ro-MD",
    "rom\N{U+00e2}n\N{U+0103} Rom\N{U+00e2}nia" => "ro-RO",
    root => "root",
    rumantsch => "rm",
    "rumantsch Svizra" => "rm-CH",
    sena => "seh",
    "sena Mo\N{U+00e7}ambique" => "seh-MZ",
    shqip => "sq",
    "shqip Kosov\N{U+00eb}" => "sq-XK",
    "shqip Maqedoni" => "sq-MK",
    "shqip Shqip\N{U+00eb}ri" => "sq-AL",
    "sloven\N{U+010d}ina" => "sk",
    "sloven\N{U+010d}ina Slovensko" => "sk-SK",
    "sloven\N{U+0161}\N{U+010d}ina" => "sl",
    "sloven\N{U+0161}\N{U+010d}ina Slovenija" => "sl-SI",
    "srpski Bosna i Hercegovina latinica" => "sr-Latn-BA",
    "srpski Crna Gora latinica" => "sr-Latn-ME",
    "srpski Kosovo latinica" => "sr-Latn-XK",
    "srpski Srbija latinica" => "sr-Latn-RS",
    "srpski latinica" => "sr-Latn",
    suomi => "fi",
    "suomi Suomi" => "fi-FI",
    svenska => "sv",
    "svenska Finland" => "sv-FI",
    "svenska Sverige" => "sv-SE",
    "svenska \N{U+00c5}land" => "sv-AX",
    "t\N{U+00fc}rkmen dili" => "tk",
    "t\N{U+00fc}rkmen dili T\N{U+00fc}rkmenistan" => "tk-TM",
    vo => "vo",
    "vo 001" => "vo-001",
    "\N{U+00c8}d\N{U+00e8} Yor\N{U+00f9}b\N{U+00e1}" => "yo",
    "\N{U+00c8}d\N{U+00e8} Yor\N{U+00f9}b\N{U+00e1} Or\N{U+00ed}l\N{U+025b}\N{U+0301}\N{U+00e8}de B\N{U+025b}\N{U+0300}n\N{U+025b}\N{U+0300}" => "yo-BJ",
    "\N{U+00c8}d\N{U+00e8} Yor\N{U+00f9}b\N{U+00e1} Or\N{U+00ed}l\N{U+1eb9}\N{U+0301}\N{U+00e8}de N\N{U+00e0}\N{U+00ec}j\N{U+00ed}r\N{U+00ed}\N{U+00e0}" => "yo-NG",
    "\N{U+00ed}slenska" => "is",
    "\N{U+00ed}slenska \N{U+00cd}sland" => "is-IS",
    "\N{U+010d}e\N{U+0161}tina" => "cs",
    "\N{U+010d}e\N{U+0161}tina \N{U+010c}esko" => "cs-CZ",
    "\N{U+0181}\N{U+00e0}s\N{U+00e0}a" => "bas",
    "\N{U+0181}\N{U+00e0}s\N{U+00e0}a K\N{U+00e0}m\N{U+025b}\N{U+0300}r\N{U+00fb}n" => "bas-CM",
    "\N{U+02bb}\N{U+014c}lelo Hawai\N{U+02bb}i" => "haw",
    "\N{U+02bb}\N{U+014c}lelo Hawai\N{U+02bb}i \N{U+02bb}Amelika Hui P\N{U+016b} \N{U+02bb}Ia" => "haw-US",
    "\N{U+0395}\N{U+03bb}\N{U+03bb}\N{U+03b7}\N{U+03bd}\N{U+03b9}\N{U+03ba}\N{U+03ac}" => "el",
    "\N{U+0395}\N{U+03bb}\N{U+03bb}\N{U+03b7}\N{U+03bd}\N{U+03b9}\N{U+03ba}\N{U+03ac} \N{U+0395}\N{U+03bb}\N{U+03bb}\N{U+03ac}\N{U+03b4}\N{U+03b1}" => "el-GR",
    "\N{U+0395}\N{U+03bb}\N{U+03bb}\N{U+03b7}\N{U+03bd}\N{U+03b9}\N{U+03ba}\N{U+03ac} \N{U+039a}\N{U+03cd}\N{U+03c0}\N{U+03c1}\N{U+03bf}\N{U+03c2}" => "el-CY",
    "\N{U+0430}\N{U+0437}\N{U+04d9}\N{U+0440}\N{U+0431}\N{U+0430}\N{U+0458}\N{U+04b9}\N{U+0430}\N{U+043d} \N{U+0410}\N{U+0437}\N{U+04d9}\N{U+0440}\N{U+0431}\N{U+0430}\N{U+0458}\N{U+04b9}\N{U+0430}\N{U+043d} \N{U+041a}\N{U+0438}\N{U+0440}\N{U+0438}\N{U+043b}" => "az-Cyrl-AZ",
    "\N{U+0430}\N{U+0437}\N{U+04d9}\N{U+0440}\N{U+0431}\N{U+0430}\N{U+0458}\N{U+04b9}\N{U+0430}\N{U+043d} \N{U+041a}\N{U+0438}\N{U+0440}\N{U+0438}\N{U+043b}" => "az-Cyrl",
    "\N{U+0431}\N{U+0435}\N{U+043b}\N{U+0430}\N{U+0440}\N{U+0443}\N{U+0441}\N{U+043a}\N{U+0430}\N{U+044f}" => "be",
    "\N{U+0431}\N{U+0435}\N{U+043b}\N{U+0430}\N{U+0440}\N{U+0443}\N{U+0441}\N{U+043a}\N{U+0430}\N{U+044f} \N{U+0411}\N{U+0435}\N{U+043b}\N{U+0430}\N{U+0440}\N{U+0443}\N{U+0441}\N{U+044c}" => "be-BY",
    "\N{U+0431}\N{U+043e}\N{U+0441}\N{U+0430}\N{U+043d}\N{U+0441}\N{U+043a}\N{U+0438} \N{U+0411}\N{U+043e}\N{U+0441}\N{U+043d}\N{U+0430} \N{U+0438} \N{U+0425}\N{U+0435}\N{U+0440}\N{U+0446}\N{U+0435}\N{U+0433}\N{U+043e}\N{U+0432}\N{U+0438}\N{U+043d}\N{U+0430} \N{U+045b}\N{U+0438}\N{U+0440}\N{U+0438}\N{U+043b}\N{U+0438}\N{U+0446}\N{U+0430}" => "bs-Cyrl-BA",
    "\N{U+0431}\N{U+043e}\N{U+0441}\N{U+0430}\N{U+043d}\N{U+0441}\N{U+043a}\N{U+0438} \N{U+045b}\N{U+0438}\N{U+0440}\N{U+0438}\N{U+043b}\N{U+0438}\N{U+0446}\N{U+0430}" => "bs-Cyrl",
    "\N{U+0431}\N{U+044a}\N{U+043b}\N{U+0433}\N{U+0430}\N{U+0440}\N{U+0441}\N{U+043a}\N{U+0438}" => "bg",
    "\N{U+0431}\N{U+044a}\N{U+043b}\N{U+0433}\N{U+0430}\N{U+0440}\N{U+0441}\N{U+043a}\N{U+0438} \N{U+0411}\N{U+044a}\N{U+043b}\N{U+0433}\N{U+0430}\N{U+0440}\N{U+0438}\N{U+044f}" => "bg-BG",
    "\N{U+0438}\N{U+0440}\N{U+043e}\N{U+043d}" => "os",
    "\N{U+0438}\N{U+0440}\N{U+043e}\N{U+043d} \N{U+0413}\N{U+0443}\N{U+044b}\N{U+0440}\N{U+0434}\N{U+0437}\N{U+044b}\N{U+0441}\N{U+0442}\N{U+043e}\N{U+043d}" => "os-GE",
    "\N{U+0438}\N{U+0440}\N{U+043e}\N{U+043d} \N{U+0423}\N{U+04d5}\N{U+0440}\N{U+04d5}\N{U+0441}\N{U+0435}" => "os-RU",
    "\N{U+043a}\N{U+044b}\N{U+0440}\N{U+0433}\N{U+044b}\N{U+0437}\N{U+0447}\N{U+0430}" => "ky",
    "\N{U+043a}\N{U+044b}\N{U+0440}\N{U+0433}\N{U+044b}\N{U+0437}\N{U+0447}\N{U+0430} \N{U+041a}\N{U+044b}\N{U+0440}\N{U+0433}\N{U+044b}\N{U+0437}\N{U+0441}\N{U+0442}\N{U+0430}\N{U+043d}" => "ky-KG",
    "\N{U+043c}\N{U+0430}\N{U+043a}\N{U+0435}\N{U+0434}\N{U+043e}\N{U+043d}\N{U+0441}\N{U+043a}\N{U+0438}" => "mk",
    "\N{U+043c}\N{U+0430}\N{U+043a}\N{U+0435}\N{U+0434}\N{U+043e}\N{U+043d}\N{U+0441}\N{U+043a}\N{U+0438} \N{U+041c}\N{U+0430}\N{U+043a}\N{U+0435}\N{U+0434}\N{U+043e}\N{U+043d}\N{U+0438}\N{U+0458}\N{U+0430}" => "mk-MK",
    "\N{U+043c}\N{U+043e}\N{U+043d}\N{U+0433}\N{U+043e}\N{U+043b}" => "mn",
    "\N{U+043c}\N{U+043e}\N{U+043d}\N{U+0433}\N{U+043e}\N{U+043b} \N{U+041c}\N{U+043e}\N{U+043d}\N{U+0433}\N{U+043e}\N{U+043b}" => "mn-MN",
    "\N{U+043d}\N{U+043e}\N{U+0445}\N{U+0447}\N{U+0438}\N{U+0439}\N{U+043d}" => "ce",
    "\N{U+043d}\N{U+043e}\N{U+0445}\N{U+0447}\N{U+0438}\N{U+0439}\N{U+043d} \N{U+0420}\N{U+043e}\N{U+0441}\N{U+0441}\N{U+0438}" => "ce-RU",
    "\N{U+0440}\N{U+0443}\N{U+0441}\N{U+0441}\N{U+043a}\N{U+0438}\N{U+0439}" => "ru",
    "\N{U+0440}\N{U+0443}\N{U+0441}\N{U+0441}\N{U+043a}\N{U+0438}\N{U+0439} \N{U+0411}\N{U+0435}\N{U+043b}\N{U+0430}\N{U+0440}\N{U+0443}\N{U+0441}\N{U+044c}" => "ru-BY",
    "\N{U+0440}\N{U+0443}\N{U+0441}\N{U+0441}\N{U+043a}\N{U+0438}\N{U+0439} \N{U+041a}\N{U+0430}\N{U+0437}\N{U+0430}\N{U+0445}\N{U+0441}\N{U+0442}\N{U+0430}\N{U+043d}" => "ru-KZ",
    "\N{U+0440}\N{U+0443}\N{U+0441}\N{U+0441}\N{U+043a}\N{U+0438}\N{U+0439} \N{U+041a}\N{U+0438}\N{U+0440}\N{U+0433}\N{U+0438}\N{U+0437}\N{U+0438}\N{U+044f}" => "ru-KG",
    "\N{U+0440}\N{U+0443}\N{U+0441}\N{U+0441}\N{U+043a}\N{U+0438}\N{U+0439} \N{U+041c}\N{U+043e}\N{U+043b}\N{U+0434}\N{U+043e}\N{U+0432}\N{U+0430}" => "ru-MD",
    "\N{U+0440}\N{U+0443}\N{U+0441}\N{U+0441}\N{U+043a}\N{U+0438}\N{U+0439} \N{U+0420}\N{U+043e}\N{U+0441}\N{U+0441}\N{U+0438}\N{U+044f}" => "ru-RU",
    "\N{U+0440}\N{U+0443}\N{U+0441}\N{U+0441}\N{U+043a}\N{U+0438}\N{U+0439} \N{U+0423}\N{U+043a}\N{U+0440}\N{U+0430}\N{U+0438}\N{U+043d}\N{U+0430}" => "ru-UA",
    "\N{U+0441}\N{U+0430}\N{U+0445}\N{U+0430} \N{U+0442}\N{U+044b}\N{U+043b}\N{U+0430}" => "sah",
    "\N{U+0441}\N{U+0430}\N{U+0445}\N{U+0430} \N{U+0442}\N{U+044b}\N{U+043b}\N{U+0430} \N{U+0410}\N{U+0440}\N{U+0430}\N{U+0441}\N{U+0441}\N{U+044b}\N{U+044b}\N{U+0439}\N{U+0430}" => "sah-RU",
    "\N{U+0441}\N{U+0440}\N{U+043f}\N{U+0441}\N{U+043a}\N{U+0438}" => "sr",
    "\N{U+0441}\N{U+0440}\N{U+043f}\N{U+0441}\N{U+043a}\N{U+0438} \N{U+0411}\N{U+043e}\N{U+0441}\N{U+043d}\N{U+0430} \N{U+0438} \N{U+0425}\N{U+0435}\N{U+0440}\N{U+0446}\N{U+0435}\N{U+0433}\N{U+043e}\N{U+0432}\N{U+0438}\N{U+043d}\N{U+0430} \N{U+045b}\N{U+0438}\N{U+0440}\N{U+0438}\N{U+043b}\N{U+0438}\N{U+0446}\N{U+0430}" => "sr-Cyrl-BA",
    "\N{U+0441}\N{U+0440}\N{U+043f}\N{U+0441}\N{U+043a}\N{U+0438} \N{U+041a}\N{U+043e}\N{U+0441}\N{U+043e}\N{U+0432}\N{U+043e} \N{U+045b}\N{U+0438}\N{U+0440}\N{U+0438}\N{U+043b}\N{U+0438}\N{U+0446}\N{U+0430}" => "sr-Cyrl-XK",
    "\N{U+0441}\N{U+0440}\N{U+043f}\N{U+0441}\N{U+043a}\N{U+0438} \N{U+0421}\N{U+0440}\N{U+0431}\N{U+0438}\N{U+0458}\N{U+0430} \N{U+045b}\N{U+0438}\N{U+0440}\N{U+0438}\N{U+043b}\N{U+0438}\N{U+0446}\N{U+0430}" => "sr-Cyrl-RS",
    "\N{U+0441}\N{U+0440}\N{U+043f}\N{U+0441}\N{U+043a}\N{U+0438} \N{U+0426}\N{U+0440}\N{U+043d}\N{U+0430} \N{U+0413}\N{U+043e}\N{U+0440}\N{U+0430} \N{U+045b}\N{U+0438}\N{U+0440}\N{U+0438}\N{U+043b}\N{U+0438}\N{U+0446}\N{U+0430}" => "sr-Cyrl-ME",
    "\N{U+0441}\N{U+0440}\N{U+043f}\N{U+0441}\N{U+043a}\N{U+0438} \N{U+045b}\N{U+0438}\N{U+0440}\N{U+0438}\N{U+043b}\N{U+0438}\N{U+0446}\N{U+0430}" => "sr-Cyrl",
    "\N{U+0442}\N{U+0430}\N{U+0442}\N{U+0430}\N{U+0440}" => "tt",
    "\N{U+0442}\N{U+0430}\N{U+0442}\N{U+0430}\N{U+0440} \N{U+0420}\N{U+043e}\N{U+0441}\N{U+0441}\N{U+0438}\N{U+044f}" => "tt-RU",
    "\N{U+0442}\N{U+043e}\N{U+04b7}\N{U+0438}\N{U+043a}\N{U+04e3}" => "tg",
    "\N{U+0442}\N{U+043e}\N{U+04b7}\N{U+0438}\N{U+043a}\N{U+04e3} \N{U+0422}\N{U+043e}\N{U+04b7}\N{U+0438}\N{U+043a}\N{U+0438}\N{U+0441}\N{U+0442}\N{U+043e}\N{U+043d}" => "tg-TJ",
    "\N{U+0443}\N{U+043a}\N{U+0440}\N{U+0430}\N{U+0457}\N{U+043d}\N{U+0441}\N{U+044c}\N{U+043a}\N{U+0430}" => "uk",
    "\N{U+0443}\N{U+043a}\N{U+0440}\N{U+0430}\N{U+0457}\N{U+043d}\N{U+0441}\N{U+044c}\N{U+043a}\N{U+0430} \N{U+0423}\N{U+043a}\N{U+0440}\N{U+0430}\N{U+0457}\N{U+043d}\N{U+0430}" => "uk-UA",
    "\N{U+045e}\N{U+0437}\N{U+0431}\N{U+0435}\N{U+043a}\N{U+0447}\N{U+0430} \N{U+040e}\N{U+0437}\N{U+0431}\N{U+0435}\N{U+043a}\N{U+0438}\N{U+0441}\N{U+0442}\N{U+043e}\N{U+043d} \N{U+041a}\N{U+0438}\N{U+0440}\N{U+0438}\N{U+043b}" => "uz-Cyrl-UZ",
    "\N{U+045e}\N{U+0437}\N{U+0431}\N{U+0435}\N{U+043a}\N{U+0447}\N{U+0430} \N{U+041a}\N{U+0438}\N{U+0440}\N{U+0438}\N{U+043b}" => "uz-Cyrl",
    "\N{U+049b}\N{U+0430}\N{U+0437}\N{U+0430}\N{U+049b} \N{U+0442}\N{U+0456}\N{U+043b}\N{U+0456}" => "kk",
    "\N{U+049b}\N{U+0430}\N{U+0437}\N{U+0430}\N{U+049b} \N{U+0442}\N{U+0456}\N{U+043b}\N{U+0456} \N{U+049a}\N{U+0430}\N{U+0437}\N{U+0430}\N{U+049b}\N{U+0441}\N{U+0442}\N{U+0430}\N{U+043d}" => "kk-KZ",
    "\N{U+0570}\N{U+0561}\N{U+0575}\N{U+0565}\N{U+0580}\N{U+0565}\N{U+0576}" => "hy",
    "\N{U+0570}\N{U+0561}\N{U+0575}\N{U+0565}\N{U+0580}\N{U+0565}\N{U+0576} \N{U+0540}\N{U+0561}\N{U+0575}\N{U+0561}\N{U+057d}\N{U+057f}\N{U+0561}\N{U+0576}" => "hy-AM",
    "\N{U+05d9}\N{U+05d9}\N{U+05b4}\N{U+05d3}\N{U+05d9}\N{U+05e9}" => "yi",
    "\N{U+05d9}\N{U+05d9}\N{U+05b4}\N{U+05d3}\N{U+05d9}\N{U+05e9} \N{U+05d5}\N{U+05d5}\N{U+05e2}\N{U+05dc}\N{U+05d8}" => "yi-001",
    "\N{U+05e2}\N{U+05d1}\N{U+05e8}\N{U+05d9}\N{U+05ea}" => "he",
    "\N{U+05e2}\N{U+05d1}\N{U+05e8}\N{U+05d9}\N{U+05ea} \N{U+05d9}\N{U+05e9}\N{U+05e8}\N{U+05d0}\N{U+05dc}" => "he-IL",
    "\N{U+0626}\N{U+06c7}\N{U+064a}\N{U+063a}\N{U+06c7}\N{U+0631}\N{U+0686}\N{U+06d5}" => "ug",
    "\N{U+0626}\N{U+06c7}\N{U+064a}\N{U+063a}\N{U+06c7}\N{U+0631}\N{U+0686}\N{U+06d5} \N{U+062c}\N{U+06c7}\N{U+06ad}\N{U+06af}\N{U+0648}" => "ug-CN",
    "\N{U+0627}\N{U+0631}\N{U+062f}\N{U+0648}" => "ur",
    "\N{U+0627}\N{U+0631}\N{U+062f}\N{U+0648} \N{U+0628}\N{U+06be}\N{U+0627}\N{U+0631}\N{U+062a}" => "ur-IN",
    "\N{U+0627}\N{U+0631}\N{U+062f}\N{U+0648} \N{U+067e}\N{U+0627}\N{U+06a9}\N{U+0633}\N{U+062a}\N{U+0627}\N{U+0646}" => "ur-PK",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629}" => "ar",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0625}\N{U+0631}\N{U+064a}\N{U+062a}\N{U+0631}\N{U+064a}\N{U+0627}" => "ar-ER",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0625}\N{U+0633}\N{U+0631}\N{U+0627}\N{U+0626}\N{U+064a}\N{U+0644}" => "ar-IL",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0627}\N{U+0644}\N{U+0623}\N{U+0631}\N{U+0627}\N{U+0636}\N{U+064a} \N{U+0627}\N{U+0644}\N{U+0641}\N{U+0644}\N{U+0633}\N{U+0637}\N{U+064a}\N{U+0646}\N{U+064a}\N{U+0629}" => "ar-PS",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0627}\N{U+0644}\N{U+0623}\N{U+0631}\N{U+062f}\N{U+0646}" => "ar-JO",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0627}\N{U+0644}\N{U+0625}\N{U+0645}\N{U+0627}\N{U+0631}\N{U+0627}\N{U+062a} \N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0627}\N{U+0644}\N{U+0645}\N{U+062a}\N{U+062d}\N{U+062f}\N{U+0629}" => "ar-AE",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0627}\N{U+0644}\N{U+0628}\N{U+062d}\N{U+0631}\N{U+064a}\N{U+0646}" => "ar-BH",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0627}\N{U+0644}\N{U+062c}\N{U+0632}\N{U+0627}\N{U+0626}\N{U+0631}" => "ar-DZ",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0627}\N{U+0644}\N{U+0633}\N{U+0648}\N{U+062f}\N{U+0627}\N{U+0646}" => "ar-SD",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0627}\N{U+0644}\N{U+0635}\N{U+062d}\N{U+0631}\N{U+0627}\N{U+0621} \N{U+0627}\N{U+0644}\N{U+063a}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629}" => "ar-EH",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0627}\N{U+0644}\N{U+0635}\N{U+0648}\N{U+0645}\N{U+0627}\N{U+0644}" => "ar-SO",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0627}\N{U+0644}\N{U+0639}\N{U+0627}\N{U+0644}\N{U+0645}" => "ar-001",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0627}\N{U+0642}" => "ar-IQ",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0627}\N{U+0644}\N{U+0643}\N{U+0648}\N{U+064a}\N{U+062a}" => "ar-KW",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0627}\N{U+0644}\N{U+0645}\N{U+063a}\N{U+0631}\N{U+0628}" => "ar-MA",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0627}\N{U+0644}\N{U+0645}\N{U+0645}\N{U+0644}\N{U+0643}\N{U+0629} \N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0627}\N{U+0644}\N{U+0633}\N{U+0639}\N{U+0648}\N{U+062f}\N{U+064a}\N{U+0629}" => "ar-SA",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0627}\N{U+0644}\N{U+064a}\N{U+0645}\N{U+0646}" => "ar-YE",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+062a}\N{U+0634}\N{U+0627}\N{U+062f}" => "ar-TD",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+062a}\N{U+0648}\N{U+0646}\N{U+0633}" => "ar-TN",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+062c}\N{U+0632}\N{U+0631} \N{U+0627}\N{U+0644}\N{U+0642}\N{U+0645}\N{U+0631}" => "ar-KM",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+062c}\N{U+0646}\N{U+0648}\N{U+0628} \N{U+0627}\N{U+0644}\N{U+0633}\N{U+0648}\N{U+062f}\N{U+0627}\N{U+0646}" => "ar-SS",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+062c}\N{U+064a}\N{U+0628}\N{U+0648}\N{U+062a}\N{U+064a}" => "ar-DJ",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0633}\N{U+0648}\N{U+0631}\N{U+064a}\N{U+0627}" => "ar-SY",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0639}\N{U+064f}\N{U+0645}\N{U+0627}\N{U+0646}" => "ar-OM",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0642}\N{U+0637}\N{U+0631}" => "ar-QA",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0644}\N{U+0628}\N{U+0646}\N{U+0627}\N{U+0646}" => "ar-LB",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0644}\N{U+064a}\N{U+0628}\N{U+064a}\N{U+0627}" => "ar-LY",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0645}\N{U+0635}\N{U+0631}" => "ar-EG",
    "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629} \N{U+0645}\N{U+0648}\N{U+0631}\N{U+064a}\N{U+062a}\N{U+0627}\N{U+0646}\N{U+064a}\N{U+0627}" => "ar-MR",
    "\N{U+0627}\N{U+0648}\N{U+0632}\N{U+0628}\N{U+06cc}\N{U+06a9} \N{U+0627}\N{U+0641}\N{U+063a}\N{U+0627}\N{U+0646}\N{U+0633}\N{U+062a}\N{U+0627}\N{U+0646} \N{U+0639}\N{U+0631}\N{U+0628}\N{U+06cc}" => "uz-Arab-AF",
    "\N{U+0627}\N{U+0648}\N{U+0632}\N{U+0628}\N{U+06cc}\N{U+06a9} \N{U+0639}\N{U+0631}\N{U+0628}\N{U+06cc}" => "uz-Arab",
    "\N{U+0633}\N{U+0646}\N{U+068c}\N{U+064a}" => "sd",
    "\N{U+0633}\N{U+0646}\N{U+068c}\N{U+064a} \N{U+067e}\N{U+0627}\N{U+06aa}\N{U+0633}\N{U+062a}\N{U+0627}\N{U+0646}" => "sd-PK",
    "\N{U+0641}\N{U+0627}\N{U+0631}\N{U+0633}\N{U+06cc}" => "fa",
    "\N{U+0641}\N{U+0627}\N{U+0631}\N{U+0633}\N{U+06cc} \N{U+0627}\N{U+0641}\N{U+063a}\N{U+0627}\N{U+0646}\N{U+0633}\N{U+062a}\N{U+0627}\N{U+0646}" => "fa-AF",
    "\N{U+0641}\N{U+0627}\N{U+0631}\N{U+0633}\N{U+06cc} \N{U+0627}\N{U+06cc}\N{U+0631}\N{U+0627}\N{U+0646}" => "fa-IR",
    "\N{U+0644}\N{U+06ca}\N{U+0631}\N{U+06cc} \N{U+0634}\N{U+0648}\N{U+0645}\N{U+0627}\N{U+0644}\N{U+06cc}" => "lrc",
    "\N{U+0644}\N{U+06ca}\N{U+0631}\N{U+06cc} \N{U+0634}\N{U+0648}\N{U+0645}\N{U+0627}\N{U+0644}\N{U+06cc} IQ" => "lrc-IQ",
    "\N{U+0644}\N{U+06ca}\N{U+0631}\N{U+06cc} \N{U+0634}\N{U+0648}\N{U+0645}\N{U+0627}\N{U+0644}\N{U+06cc} IR" => "lrc-IR",
    "\N{U+0645}\N{U+0627}\N{U+0632}\N{U+0631}\N{U+0648}\N{U+0646}\N{U+06cc}" => "mzn",
    "\N{U+0645}\N{U+0627}\N{U+0632}\N{U+0631}\N{U+0648}\N{U+0646}\N{U+06cc} \N{U+0627}\N{U+06cc}\N{U+0631}\N{U+0627}\N{U+0646}" => "mzn-IR",
    "\N{U+067e}\N{U+0646}\N{U+062c}\N{U+0627}\N{U+0628}\N{U+06cc} \N{U+0639}\N{U+0631}\N{U+0628}\N{U+06cc}" => "pa-Arab",
    "\N{U+067e}\N{U+0646}\N{U+062c}\N{U+0627}\N{U+0628}\N{U+06cc} \N{U+067e}\N{U+0627}\N{U+06a9}\N{U+0633}\N{U+062a}\N{U+0627}\N{U+0646} \N{U+0639}\N{U+0631}\N{U+0628}\N{U+06cc}" => "pa-Arab-PK",
    "\N{U+067e}\N{U+069a}\N{U+062a}\N{U+0648}" => "ps",
    "\N{U+067e}\N{U+069a}\N{U+062a}\N{U+0648} \N{U+0627}\N{U+0641}\N{U+063a}\N{U+0627}\N{U+0646}\N{U+0633}\N{U+062a}\N{U+0627}\N{U+0646}" => "ps-AF",
    "\N{U+06a9}\N{U+0648}\N{U+0631}\N{U+062f}\N{U+06cc}\N{U+06cc} \N{U+0646}\N{U+0627}\N{U+0648}\N{U+06d5}\N{U+0646}\N{U+062f}\N{U+06cc}" => "ckb",
    "\N{U+06a9}\N{U+0648}\N{U+0631}\N{U+062f}\N{U+06cc}\N{U+06cc} \N{U+0646}\N{U+0627}\N{U+0648}\N{U+06d5}\N{U+0646}\N{U+062f}\N{U+06cc} \N{U+0626}\N{U+06ce}\N{U+0631}\N{U+0627}\N{U+0646}" => "ckb-IR",
    "\N{U+06a9}\N{U+0648}\N{U+0631}\N{U+062f}\N{U+06cc}\N{U+06cc} \N{U+0646}\N{U+0627}\N{U+0648}\N{U+06d5}\N{U+0646}\N{U+062f}\N{U+06cc} \N{U+0639}\N{U+06ce}\N{U+0631}\N{U+0627}\N{U+0642}" => "ckb-IQ",
    "\N{U+06a9}\N{U+0672}\N{U+0634}\N{U+064f}\N{U+0631}" => "ks",
    "\N{U+06a9}\N{U+0672}\N{U+0634}\N{U+064f}\N{U+0631} \N{U+06c1}\N{U+0650}\N{U+0646}\N{U+065b}\N{U+062f}\N{U+0648}\N{U+0633}\N{U+062a}\N{U+0627}\N{U+0646}" => "ks-IN",
    "\N{U+0915}\N{U+094b}\N{U+0902}\N{U+0915}\N{U+0923}\N{U+0940}" => "kok",
    "\N{U+0915}\N{U+094b}\N{U+0902}\N{U+0915}\N{U+0923}\N{U+0940} \N{U+092d}\N{U+093e}\N{U+0930}\N{U+0924}" => "kok-IN",
    "\N{U+0928}\N{U+0947}\N{U+092a}\N{U+093e}\N{U+0932}\N{U+0940}" => "ne",
    "\N{U+0928}\N{U+0947}\N{U+092a}\N{U+093e}\N{U+0932}\N{U+0940} \N{U+0928}\N{U+0947}\N{U+092a}\N{U+093e}\N{U+0932}" => "ne-NP",
    "\N{U+0928}\N{U+0947}\N{U+092a}\N{U+093e}\N{U+0932}\N{U+0940} \N{U+092d}\N{U+093e}\N{U+0930}\N{U+0924}" => "ne-IN",
    "\N{U+092c}\N{U+0921}\N{U+093c}\N{U+094b}" => "brx",
    "\N{U+092c}\N{U+0921}\N{U+093c}\N{U+094b} \N{U+092d}\N{U+093e}\N{U+0930}\N{U+0924}" => "brx-IN",
    "\N{U+092e}\N{U+0930}\N{U+093e}\N{U+0920}\N{U+0940}" => "mr",
    "\N{U+092e}\N{U+0930}\N{U+093e}\N{U+0920}\N{U+0940} \N{U+092d}\N{U+093e}\N{U+0930}\N{U+0924}" => "mr-IN",
    "\N{U+0939}\N{U+093f}\N{U+0928}\N{U+094d}\N{U+0926}\N{U+0940}" => "hi",
    "\N{U+0939}\N{U+093f}\N{U+0928}\N{U+094d}\N{U+0926}\N{U+0940} \N{U+092d}\N{U+093e}\N{U+0930}\N{U+0924}" => "hi-IN",
    "\N{U+0985}\N{U+09b8}\N{U+09ae}\N{U+09c0}\N{U+09af}\N{U+09bc}\N{U+09be}" => "as",
    "\N{U+0985}\N{U+09b8}\N{U+09ae}\N{U+09c0}\N{U+09af}\N{U+09bc}\N{U+09be} \N{U+09ad}\N{U+09be}\N{U+09f0}\N{U+09a4}" => "as-IN",
    "\N{U+09ac}\N{U+09be}\N{U+0982}\N{U+09b2}\N{U+09be}" => "bn",
    "\N{U+09ac}\N{U+09be}\N{U+0982}\N{U+09b2}\N{U+09be} \N{U+09ac}\N{U+09be}\N{U+0982}\N{U+09b2}\N{U+09be}\N{U+09a6}\N{U+09c7}\N{U+09b6}" => "bn-BD",
    "\N{U+09ac}\N{U+09be}\N{U+0982}\N{U+09b2}\N{U+09be} \N{U+09ad}\N{U+09be}\N{U+09b0}\N{U+09a4}" => "bn-IN",
    "\N{U+0a2a}\N{U+0a70}\N{U+0a1c}\N{U+0a3e}\N{U+0a2c}\N{U+0a40}" => "pa",
    "\N{U+0a2a}\N{U+0a70}\N{U+0a1c}\N{U+0a3e}\N{U+0a2c}\N{U+0a40} \N{U+0a17}\N{U+0a41}\N{U+0a30}\N{U+0a2e}\N{U+0a41}\N{U+0a16}\N{U+0a40}" => "pa-Guru",
    "\N{U+0a2a}\N{U+0a70}\N{U+0a1c}\N{U+0a3e}\N{U+0a2c}\N{U+0a40} \N{U+0a2d}\N{U+0a3e}\N{U+0a30}\N{U+0a24} \N{U+0a17}\N{U+0a41}\N{U+0a30}\N{U+0a2e}\N{U+0a41}\N{U+0a16}\N{U+0a40}" => "pa-Guru-IN",
    "\N{U+0a97}\N{U+0ac1}\N{U+0a9c}\N{U+0ab0}\N{U+0abe}\N{U+0aa4}\N{U+0ac0}" => "gu",
    "\N{U+0a97}\N{U+0ac1}\N{U+0a9c}\N{U+0ab0}\N{U+0abe}\N{U+0aa4}\N{U+0ac0} \N{U+0aad}\N{U+0abe}\N{U+0ab0}\N{U+0aa4}" => "gu-IN",
    "\N{U+0b13}\N{U+0b21}\N{U+0b3c}\N{U+0b3f}\N{U+0b06}" => "or",
    "\N{U+0b13}\N{U+0b21}\N{U+0b3c}\N{U+0b3f}\N{U+0b06} \N{U+0b2d}\N{U+0b3e}\N{U+0b30}\N{U+0b24}" => "or-IN",
    "\N{U+0ba4}\N{U+0bae}\N{U+0bbf}\N{U+0bb4}\N{U+0bcd}" => "ta",
    "\N{U+0ba4}\N{U+0bae}\N{U+0bbf}\N{U+0bb4}\N{U+0bcd} \N{U+0b87}\N{U+0ba8}\N{U+0bcd}\N{U+0ba4}\N{U+0bbf}\N{U+0baf}\N{U+0bbe}" => "ta-IN",
    "\N{U+0ba4}\N{U+0bae}\N{U+0bbf}\N{U+0bb4}\N{U+0bcd} \N{U+0b87}\N{U+0bb2}\N{U+0b99}\N{U+0bcd}\N{U+0b95}\N{U+0bc8}" => "ta-LK",
    "\N{U+0ba4}\N{U+0bae}\N{U+0bbf}\N{U+0bb4}\N{U+0bcd} \N{U+0b9a}\N{U+0bbf}\N{U+0b99}\N{U+0bcd}\N{U+0b95}\N{U+0baa}\N{U+0bcd}\N{U+0baa}\N{U+0bc2}\N{U+0bb0}\N{U+0bcd}" => "ta-SG",
    "\N{U+0ba4}\N{U+0bae}\N{U+0bbf}\N{U+0bb4}\N{U+0bcd} \N{U+0bae}\N{U+0bb2}\N{U+0bc7}\N{U+0b9a}\N{U+0bbf}\N{U+0baf}\N{U+0bbe}" => "ta-MY",
    "\N{U+0c24}\N{U+0c46}\N{U+0c32}\N{U+0c41}\N{U+0c17}\N{U+0c41}" => "te",
    "\N{U+0c24}\N{U+0c46}\N{U+0c32}\N{U+0c41}\N{U+0c17}\N{U+0c41} \N{U+0c2d}\N{U+0c3e}\N{U+0c30}\N{U+0c24}\N{U+0c26}\N{U+0c47}\N{U+0c36}\N{U+0c02}" => "te-IN",
    "\N{U+0c95}\N{U+0ca8}\N{U+0ccd}\N{U+0ca8}\N{U+0ca1}" => "kn",
    "\N{U+0c95}\N{U+0ca8}\N{U+0ccd}\N{U+0ca8}\N{U+0ca1} \N{U+0cad}\N{U+0cbe}\N{U+0cb0}\N{U+0ca4}" => "kn-IN",
    "\N{U+0d2e}\N{U+0d32}\N{U+0d2f}\N{U+0d3e}\N{U+0d33}\N{U+0d02}" => "ml",
    "\N{U+0d2e}\N{U+0d32}\N{U+0d2f}\N{U+0d3e}\N{U+0d33}\N{U+0d02} \N{U+0d07}\N{U+0d28}\N{U+0d4d}\N{U+0d24}\N{U+0d4d}\N{U+0d2f}" => "ml-IN",
    "\N{U+0dc3}\N{U+0dd2}\N{U+0d82}\N{U+0dc4}\N{U+0dbd}" => "si",
    "\N{U+0dc3}\N{U+0dd2}\N{U+0d82}\N{U+0dc4}\N{U+0dbd} \N{U+0dc1}\N{U+0dca}\N{U+200d}\N{U+0dbb}\N{U+0dd3} \N{U+0dbd}\N{U+0d82}\N{U+0d9a}\N{U+0dcf}\N{U+0dc0}" => "si-LK",
    "\N{U+0e44}\N{U+0e17}\N{U+0e22}" => "th",
    "\N{U+0e44}\N{U+0e17}\N{U+0e22} \N{U+0e44}\N{U+0e17}\N{U+0e22}" => "th-TH",
    "\N{U+0ea5}\N{U+0eb2}\N{U+0ea7}" => "lo",
    "\N{U+0ea5}\N{U+0eb2}\N{U+0ea7} \N{U+0ea5}\N{U+0eb2}\N{U+0ea7}" => "lo-LA",
    "\N{U+0f56}\N{U+0f7c}\N{U+0f51}\N{U+0f0b}\N{U+0f66}\N{U+0f90}\N{U+0f51}\N{U+0f0b}" => "bo",
    "\N{U+0f56}\N{U+0f7c}\N{U+0f51}\N{U+0f0b}\N{U+0f66}\N{U+0f90}\N{U+0f51}\N{U+0f0b} \N{U+0f62}\N{U+0f92}\N{U+0fb1}\N{U+0f0b}\N{U+0f42}\N{U+0f62}\N{U+0f0b}" => "bo-IN",
    "\N{U+0f56}\N{U+0f7c}\N{U+0f51}\N{U+0f0b}\N{U+0f66}\N{U+0f90}\N{U+0f51}\N{U+0f0b} \N{U+0f62}\N{U+0f92}\N{U+0fb1}\N{U+0f0b}\N{U+0f53}\N{U+0f42}" => "bo-CN",
    "\N{U+0f62}\N{U+0fab}\N{U+0f7c}\N{U+0f44}\N{U+0f0b}\N{U+0f41}" => "dz",
    "\N{U+0f62}\N{U+0fab}\N{U+0f7c}\N{U+0f44}\N{U+0f0b}\N{U+0f41} \N{U+0f60}\N{U+0f56}\N{U+0fb2}\N{U+0f74}\N{U+0f42}" => "dz-BT",
    "\N{U+1019}\N{U+103c}\N{U+1014}\N{U+103a}\N{U+1019}\N{U+102c}" => "my",
    "\N{U+1019}\N{U+103c}\N{U+1014}\N{U+103a}\N{U+1019}\N{U+102c} \N{U+1019}\N{U+103c}\N{U+1014}\N{U+103a}\N{U+1019}\N{U+102c}" => "my-MM",
    "\N{U+10e5}\N{U+10d0}\N{U+10e0}\N{U+10d7}\N{U+10e3}\N{U+10da}\N{U+10d8}" => "ka",
    "\N{U+10e5}\N{U+10d0}\N{U+10e0}\N{U+10d7}\N{U+10e3}\N{U+10da}\N{U+10d8} \N{U+10e1}\N{U+10d0}\N{U+10e5}\N{U+10d0}\N{U+10e0}\N{U+10d7}\N{U+10d5}\N{U+10d4}\N{U+10da}\N{U+10dd}" => "ka-GE",
    "\N{U+1275}\N{U+130d}\N{U+122d}\N{U+129b}" => "ti",
    "\N{U+1275}\N{U+130d}\N{U+122d}\N{U+129b} \N{U+12a2}\N{U+1275}\N{U+12ee}\N{U+1335}\N{U+12eb}" => "ti-ET",
    "\N{U+1275}\N{U+130d}\N{U+122d}\N{U+129b} \N{U+12a4}\N{U+122d}\N{U+1275}\N{U+122b}" => "ti-ER",
    "\N{U+12a0}\N{U+121b}\N{U+122d}\N{U+129b}" => "am",
    "\N{U+12a0}\N{U+121b}\N{U+122d}\N{U+129b} \N{U+12a2}\N{U+1275}\N{U+12ee}\N{U+1335}\N{U+12eb}" => "am-ET",
    "\N{U+13e3}\N{U+13b3}\N{U+13a9}" => "chr",
    "\N{U+13e3}\N{U+13b3}\N{U+13a9} \N{U+13cc}\N{U+13ca} \N{U+13a2}\N{U+13f3}\N{U+13be}\N{U+13b5}\N{U+13cd}\N{U+13d4}\N{U+13c5} \N{U+13cd}\N{U+13a6}\N{U+13da}\N{U+13a9}" => "chr-US",
    "\N{U+1781}\N{U+17d2}\N{U+1798}\N{U+17c2}\N{U+179a}" => "km",
    "\N{U+1781}\N{U+17d2}\N{U+1798}\N{U+17c2}\N{U+179a} \N{U+1780}\N{U+1798}\N{U+17d2}\N{U+1796}\N{U+17bb}\N{U+1787}\N{U+17b6}" => "km-KH",
    "\N{U+2d5c}\N{U+2d30}\N{U+2d4e}\N{U+2d30}\N{U+2d63}\N{U+2d49}\N{U+2d56}\N{U+2d5c}" => "zgh",
    "\N{U+2d5c}\N{U+2d30}\N{U+2d4e}\N{U+2d30}\N{U+2d63}\N{U+2d49}\N{U+2d56}\N{U+2d5c} \N{U+2d4d}\N{U+2d4e}\N{U+2d56}\N{U+2d54}\N{U+2d49}\N{U+2d31}" => "zgh-MA",
    "\N{U+2d5c}\N{U+2d30}\N{U+2d5b}\N{U+2d4d}\N{U+2d43}\N{U+2d49}\N{U+2d5c}" => "shi",
    "\N{U+2d5c}\N{U+2d30}\N{U+2d5b}\N{U+2d4d}\N{U+2d43}\N{U+2d49}\N{U+2d5c} Tfng" => "shi-Tfng",
    "\N{U+2d5c}\N{U+2d30}\N{U+2d5b}\N{U+2d4d}\N{U+2d43}\N{U+2d49}\N{U+2d5c} \N{U+2d4d}\N{U+2d4e}\N{U+2d56}\N{U+2d54}\N{U+2d49}\N{U+2d31} Tfng" => "shi-Tfng-MA",
    "\N{U+4e2d}\N{U+6587}" => "zh",
    "\N{U+4e2d}\N{U+6587} \N{U+4e2d}\N{U+56fd} \N{U+7b80}\N{U+4f53}" => "zh-Hans-CN",
    "\N{U+4e2d}\N{U+6587} \N{U+4e2d}\N{U+56fd}\N{U+6fb3}\N{U+95e8}\N{U+7279}\N{U+522b}\N{U+884c}\N{U+653f}\N{U+533a} \N{U+7b80}\N{U+4f53}" => "zh-Hans-MO",
    "\N{U+4e2d}\N{U+6587} \N{U+4e2d}\N{U+56fd}\N{U+9999}\N{U+6e2f}\N{U+7279}\N{U+522b}\N{U+884c}\N{U+653f}\N{U+533a} \N{U+7b80}\N{U+4f53}" => "zh-Hans-HK",
    "\N{U+4e2d}\N{U+6587} \N{U+4e2d}\N{U+570b}\N{U+6fb3}\N{U+9580}\N{U+7279}\N{U+5225}\N{U+884c}\N{U+653f}\N{U+5340} \N{U+7e41}\N{U+9ad4}\N{U+5b57}" => "zh-Hant-MO",
    "\N{U+4e2d}\N{U+6587} \N{U+4e2d}\N{U+570b}\N{U+9999}\N{U+6e2f}\N{U+7279}\N{U+5225}\N{U+884c}\N{U+653f}\N{U+5340} \N{U+7e41}\N{U+9ad4}\N{U+5b57}" => "zh-Hant-HK",
    "\N{U+4e2d}\N{U+6587} \N{U+53f0}\N{U+7063} \N{U+7e41}\N{U+9ad4}" => "zh-Hant-TW",
    "\N{U+4e2d}\N{U+6587} \N{U+65b0}\N{U+52a0}\N{U+5761} \N{U+7b80}\N{U+4f53}" => "zh-Hans-SG",
    "\N{U+4e2d}\N{U+6587} \N{U+7b80}\N{U+4f53}" => "zh-Hans",
    "\N{U+4e2d}\N{U+6587} \N{U+7e41}\N{U+9ad4}" => "zh-Hant",
    "\N{U+65e5}\N{U+672c}\N{U+8a9e}" => "ja",
    "\N{U+65e5}\N{U+672c}\N{U+8a9e} \N{U+65e5}\N{U+672c}" => "ja-JP",
    "\N{U+7ca4}\N{U+8bed} \N{U+4e2d}\N{U+534e}\N{U+4eba}\N{U+6c11}\N{U+5171}\N{U+548c}\N{U+56fd} \N{U+7b80}\N{U+4f53}" => "yue-Hans-CN",
    "\N{U+7ca4}\N{U+8bed} \N{U+7b80}\N{U+4f53}" => "yue-Hans",
    "\N{U+7cb5}\N{U+8a9e}" => "yue",
    "\N{U+7cb5}\N{U+8a9e} \N{U+4e2d}\N{U+83ef}\N{U+4eba}\N{U+6c11}\N{U+5171}\N{U+548c}\N{U+570b}\N{U+9999}\N{U+6e2f}\N{U+7279}\N{U+5225}\N{U+884c}\N{U+653f}\N{U+5340} \N{U+7e41}\N{U+9ad4}" => "yue-Hant-HK",
    "\N{U+7cb5}\N{U+8a9e} \N{U+7e41}\N{U+9ad4}" => "yue-Hant",
    "\N{U+a188}\N{U+a320}\N{U+a259}" => "ii",
    "\N{U+a188}\N{U+a320}\N{U+a259} \N{U+a34f}\N{U+a1e9}" => "ii-CN",
    "\N{U+a559}\N{U+a524}" => "vai",
    "\N{U+a559}\N{U+a524} Vaii" => "vai-Vaii",
    "\N{U+a559}\N{U+a524} \N{U+a55e}\N{U+a524}\N{U+a52b}\N{U+a569} Vaii" => "vai-Vaii-LR",
    "\N{U+d55c}\N{U+ad6d}\N{U+c5b4}" => "ko",
    "\N{U+d55c}\N{U+ad6d}\N{U+c5b4} \N{U+b300}\N{U+d55c}\N{U+bbfc}\N{U+ad6d}" => "ko-KR",
    "\N{U+d55c}\N{U+ad6d}\N{U+c5b4} \N{U+c870}\N{U+c120}\N{U+bbfc}\N{U+c8fc}\N{U+c8fc}\N{U+c758}\N{U+c778}\N{U+bbfc}\N{U+acf5}\N{U+d654}\N{U+ad6d}" => "ko-KP",
    "\N{U+1110c}\N{U+1110b}\N{U+11134}\N{U+1111f}\N{U+11133}\N{U+11126}" => "ccp",
    "\N{U+1110c}\N{U+1110b}\N{U+11134}\N{U+1111f}\N{U+11133}\N{U+11126} \N{U+1111d}\N{U+11101}\N{U+11123}\N{U+11118}\N{U+1112c}\N{U+1110c}\N{U+11134}" => "ccp-BD",
    "\N{U+1110c}\N{U+1110b}\N{U+11134}\N{U+1111f}\N{U+11133}\N{U+11126} \N{U+1111e}\N{U+11122}\N{U+11127}\N{U+11116}\N{U+11134}" => "ccp-IN",
  );
  ### :end NativeNames:
  #>>>
  
  #<<<
  ### :start ISO639Aliases:
  our %ISO639Aliases = (
    afr => "af",
    "afr-NA" => "af-NA",
    "afr-ZA" => "af-ZA",
    aka => "ak",
    "aka-GH" => "ak-GH",
    alb => "sq",
    "alb-AL" => "sq-AL",
    "alb-MK" => "sq-MK",
    "alb-XK" => "sq-XK",
    amh => "am",
    "amh-ET" => "am-ET",
    ara => "ar",
    "ara-001" => "ar-001",
    "ara-AE" => "ar-AE",
    "ara-BH" => "ar-BH",
    "ara-DJ" => "ar-DJ",
    "ara-DZ" => "ar-DZ",
    "ara-EG" => "ar-EG",
    "ara-EH" => "ar-EH",
    "ara-ER" => "ar-ER",
    "ara-IL" => "ar-IL",
    "ara-IQ" => "ar-IQ",
    "ara-JO" => "ar-JO",
    "ara-KM" => "ar-KM",
    "ara-KW" => "ar-KW",
    "ara-LB" => "ar-LB",
    "ara-LY" => "ar-LY",
    "ara-MA" => "ar-MA",
    "ara-MR" => "ar-MR",
    "ara-OM" => "ar-OM",
    "ara-PS" => "ar-PS",
    "ara-QA" => "ar-QA",
    "ara-SA" => "ar-SA",
    "ara-SD" => "ar-SD",
    "ara-SO" => "ar-SO",
    "ara-SS" => "ar-SS",
    "ara-SY" => "ar-SY",
    "ara-TD" => "ar-TD",
    "ara-TN" => "ar-TN",
    "ara-YE" => "ar-YE",
    arm => "hy",
    "arm-AM" => "hy-AM",
    asm => "as",
    "asm-IN" => "as-IN",
    aze => "az",
    "aze-Cyrl" => "az-Cyrl",
    "aze-Cyrl-AZ" => "az-Cyrl-AZ",
    "aze-Latn" => "az-Latn",
    "aze-Latn-AZ" => "az-Latn-AZ",
    bam => "bm",
    "bam-ML" => "bm-ML",
    baq => "eu",
    "baq-ES" => "eu-ES",
    bel => "be",
    "bel-BY" => "be-BY",
    ben => "bn",
    "ben-BD" => "bn-BD",
    "ben-IN" => "bn-IN",
    bos => "bs",
    "bos-Cyrl" => "bs-Cyrl",
    "bos-Cyrl-BA" => "bs-Cyrl-BA",
    "bos-Latn" => "bs-Latn",
    "bos-Latn-BA" => "bs-Latn-BA",
    bre => "br",
    "bre-FR" => "br-FR",
    bul => "bg",
    "bul-BG" => "bg-BG",
    bur => "my",
    "bur-MM" => "my-MM",
    cat => "ca",
    "cat-AD" => "ca-AD",
    "cat-ES" => "ca-ES",
    "cat-ES-VALENCIA" => "ca-ES-VALENCIA",
    "cat-FR" => "ca-FR",
    "cat-IT" => "ca-IT",
    che => "ce",
    "che-RU" => "ce-RU",
    chi => "zh",
    "chi-Hans" => "zh-Hans",
    "chi-Hans-CN" => "zh-Hans-CN",
    "chi-Hans-HK" => "zh-Hans-HK",
    "chi-Hans-MO" => "zh-Hans-MO",
    "chi-Hans-SG" => "zh-Hans-SG",
    "chi-Hant" => "zh-Hant",
    "chi-Hant-HK" => "zh-Hant-HK",
    "chi-Hant-MO" => "zh-Hant-MO",
    "chi-Hant-TW" => "zh-Hant-TW",
    chu => "cu",
    "chu-RU" => "cu-RU",
    cor => "kw",
    "cor-GB" => "kw-GB",
    cze => "cs",
    "cze-CZ" => "cs-CZ",
    dan => "da",
    "dan-DK" => "da-DK",
    "dan-GL" => "da-GL",
    dut => "nl",
    "dut-AW" => "nl-AW",
    "dut-BE" => "nl-BE",
    "dut-BQ" => "nl-BQ",
    "dut-CW" => "nl-CW",
    "dut-NL" => "nl-NL",
    "dut-SR" => "nl-SR",
    "dut-SX" => "nl-SX",
    dzo => "dz",
    "dzo-BT" => "dz-BT",
    eng => "en",
    "eng-001" => "en-001",
    "eng-150" => "en-150",
    "eng-AG" => "en-AG",
    "eng-AI" => "en-AI",
    "eng-AS" => "en-AS",
    "eng-AT" => "en-AT",
    "eng-AU" => "en-AU",
    "eng-BB" => "en-BB",
    "eng-BE" => "en-BE",
    "eng-BI" => "en-BI",
    "eng-BM" => "en-BM",
    "eng-BS" => "en-BS",
    "eng-BW" => "en-BW",
    "eng-BZ" => "en-BZ",
    "eng-CA" => "en-CA",
    "eng-CC" => "en-CC",
    "eng-CH" => "en-CH",
    "eng-CK" => "en-CK",
    "eng-CM" => "en-CM",
    "eng-CX" => "en-CX",
    "eng-CY" => "en-CY",
    "eng-DE" => "en-DE",
    "eng-DG" => "en-DG",
    "eng-DK" => "en-DK",
    "eng-DM" => "en-DM",
    "eng-ER" => "en-ER",
    "eng-FI" => "en-FI",
    "eng-FJ" => "en-FJ",
    "eng-FK" => "en-FK",
    "eng-FM" => "en-FM",
    "eng-GB" => "en-GB",
    "eng-GD" => "en-GD",
    "eng-GG" => "en-GG",
    "eng-GH" => "en-GH",
    "eng-GI" => "en-GI",
    "eng-GM" => "en-GM",
    "eng-GU" => "en-GU",
    "eng-GY" => "en-GY",
    "eng-HK" => "en-HK",
    "eng-IE" => "en-IE",
    "eng-IL" => "en-IL",
    "eng-IM" => "en-IM",
    "eng-IN" => "en-IN",
    "eng-IO" => "en-IO",
    "eng-JE" => "en-JE",
    "eng-JM" => "en-JM",
    "eng-KE" => "en-KE",
    "eng-KI" => "en-KI",
    "eng-KN" => "en-KN",
    "eng-KY" => "en-KY",
    "eng-LC" => "en-LC",
    "eng-LR" => "en-LR",
    "eng-LS" => "en-LS",
    "eng-MG" => "en-MG",
    "eng-MH" => "en-MH",
    "eng-MO" => "en-MO",
    "eng-MP" => "en-MP",
    "eng-MS" => "en-MS",
    "eng-MT" => "en-MT",
    "eng-MU" => "en-MU",
    "eng-MW" => "en-MW",
    "eng-MY" => "en-MY",
    "eng-NA" => "en-NA",
    "eng-NF" => "en-NF",
    "eng-NG" => "en-NG",
    "eng-NL" => "en-NL",
    "eng-NR" => "en-NR",
    "eng-NU" => "en-NU",
    "eng-NZ" => "en-NZ",
    "eng-PG" => "en-PG",
    "eng-PH" => "en-PH",
    "eng-PK" => "en-PK",
    "eng-PN" => "en-PN",
    "eng-PR" => "en-PR",
    "eng-PW" => "en-PW",
    "eng-RW" => "en-RW",
    "eng-SB" => "en-SB",
    "eng-SC" => "en-SC",
    "eng-SD" => "en-SD",
    "eng-SE" => "en-SE",
    "eng-SG" => "en-SG",
    "eng-SH" => "en-SH",
    "eng-SI" => "en-SI",
    "eng-SL" => "en-SL",
    "eng-SS" => "en-SS",
    "eng-SX" => "en-SX",
    "eng-SZ" => "en-SZ",
    "eng-TC" => "en-TC",
    "eng-TK" => "en-TK",
    "eng-TO" => "en-TO",
    "eng-TT" => "en-TT",
    "eng-TV" => "en-TV",
    "eng-TZ" => "en-TZ",
    "eng-UG" => "en-UG",
    "eng-UM" => "en-UM",
    "eng-US" => "en-US",
    "eng-US-POSIX" => "en-US-POSIX",
    "eng-VC" => "en-VC",
    "eng-VG" => "en-VG",
    "eng-VI" => "en-VI",
    "eng-VU" => "en-VU",
    "eng-WS" => "en-WS",
    "eng-ZA" => "en-ZA",
    "eng-ZM" => "en-ZM",
    "eng-ZW" => "en-ZW",
    epo => "eo",
    "epo-001" => "eo-001",
    est => "et",
    "est-EE" => "et-EE",
    ewe => "ee",
    "ewe-GH" => "ee-GH",
    "ewe-TG" => "ee-TG",
    fao => "fo",
    "fao-DK" => "fo-DK",
    "fao-FO" => "fo-FO",
    fin => "fi",
    "fin-FI" => "fi-FI",
    fre => "fr",
    "fre-BE" => "fr-BE",
    "fre-BF" => "fr-BF",
    "fre-BI" => "fr-BI",
    "fre-BJ" => "fr-BJ",
    "fre-BL" => "fr-BL",
    "fre-CA" => "fr-CA",
    "fre-CD" => "fr-CD",
    "fre-CF" => "fr-CF",
    "fre-CG" => "fr-CG",
    "fre-CH" => "fr-CH",
    "fre-CI" => "fr-CI",
    "fre-CM" => "fr-CM",
    "fre-DJ" => "fr-DJ",
    "fre-DZ" => "fr-DZ",
    "fre-FR" => "fr-FR",
    "fre-GA" => "fr-GA",
    "fre-GF" => "fr-GF",
    "fre-GN" => "fr-GN",
    "fre-GP" => "fr-GP",
    "fre-GQ" => "fr-GQ",
    "fre-HT" => "fr-HT",
    "fre-KM" => "fr-KM",
    "fre-LU" => "fr-LU",
    "fre-MA" => "fr-MA",
    "fre-MC" => "fr-MC",
    "fre-MF" => "fr-MF",
    "fre-MG" => "fr-MG",
    "fre-ML" => "fr-ML",
    "fre-MQ" => "fr-MQ",
    "fre-MR" => "fr-MR",
    "fre-MU" => "fr-MU",
    "fre-NC" => "fr-NC",
    "fre-NE" => "fr-NE",
    "fre-PF" => "fr-PF",
    "fre-PM" => "fr-PM",
    "fre-RE" => "fr-RE",
    "fre-RW" => "fr-RW",
    "fre-SC" => "fr-SC",
    "fre-SN" => "fr-SN",
    "fre-SY" => "fr-SY",
    "fre-TD" => "fr-TD",
    "fre-TG" => "fr-TG",
    "fre-TN" => "fr-TN",
    "fre-VU" => "fr-VU",
    "fre-WF" => "fr-WF",
    "fre-YT" => "fr-YT",
    fry => "fy",
    "fry-NL" => "fy-NL",
    ful => "ff",
    "ful-CM" => "ff-CM",
    "ful-GN" => "ff-GN",
    "ful-MR" => "ff-MR",
    "ful-SN" => "ff-SN",
    geo => "ka",
    "geo-GE" => "ka-GE",
    ger => "de",
    "ger-AT" => "de-AT",
    "ger-BE" => "de-BE",
    "ger-CH" => "de-CH",
    "ger-DE" => "de-DE",
    "ger-IT" => "de-IT",
    "ger-LI" => "de-LI",
    "ger-LU" => "de-LU",
    gla => "gd",
    "gla-GB" => "gd-GB",
    gle => "ga",
    "gle-IE" => "ga-IE",
    glg => "gl",
    "glg-ES" => "gl-ES",
    glv => "gv",
    "glv-IM" => "gv-IM",
    gre => "el",
    "gre-CY" => "el-CY",
    "gre-GR" => "el-GR",
    guj => "gu",
    "guj-IN" => "gu-IN",
    hau => "ha",
    "hau-GH" => "ha-GH",
    "hau-NE" => "ha-NE",
    "hau-NG" => "ha-NG",
    heb => "he",
    "heb-IL" => "he-IL",
    hin => "hi",
    "hin-IN" => "hi-IN",
    hrv => "hr",
    "hrv-BA" => "hr-BA",
    "hrv-HR" => "hr-HR",
    hun => "hu",
    "hun-HU" => "hu-HU",
    ibo => "ig",
    "ibo-NG" => "ig-NG",
    ice => "is",
    "ice-IS" => "is-IS",
    iii => "ii",
    "iii-CN" => "ii-CN",
    ind => "id",
    "ind-ID" => "id-ID",
    ita => "it",
    "ita-CH" => "it-CH",
    "ita-IT" => "it-IT",
    "ita-SM" => "it-SM",
    "ita-VA" => "it-VA",
    jpn => "ja",
    "jpn-JP" => "ja-JP",
    kal => "kl",
    "kal-GL" => "kl-GL",
    kan => "kn",
    "kan-IN" => "kn-IN",
    kas => "ks",
    "kas-IN" => "ks-IN",
    kaz => "kk",
    "kaz-KZ" => "kk-KZ",
    khm => "km",
    "khm-KH" => "km-KH",
    kik => "ki",
    "kik-KE" => "ki-KE",
    kin => "rw",
    "kin-RW" => "rw-RW",
    kir => "ky",
    "kir-KG" => "ky-KG",
    kor => "ko",
    "kor-KP" => "ko-KP",
    "kor-KR" => "ko-KR",
    lao => "lo",
    "lao-LA" => "lo-LA",
    lav => "lv",
    "lav-LV" => "lv-LV",
    lin => "ln",
    "lin-AO" => "ln-AO",
    "lin-CD" => "ln-CD",
    "lin-CF" => "ln-CF",
    "lin-CG" => "ln-CG",
    lit => "lt",
    "lit-LT" => "lt-LT",
    ltz => "lb",
    "ltz-LU" => "lb-LU",
    lub => "lu",
    "lub-CD" => "lu-CD",
    lug => "lg",
    "lug-UG" => "lg-UG",
    mac => "mk",
    "mac-MK" => "mk-MK",
    mal => "ml",
    "mal-IN" => "ml-IN",
    mar => "mr",
    "mar-IN" => "mr-IN",
    may => "ms",
    "may-BN" => "ms-BN",
    "may-MY" => "ms-MY",
    "may-SG" => "ms-SG",
    mlg => "mg",
    "mlg-MG" => "mg-MG",
    mlt => "mt",
    "mlt-MT" => "mt-MT",
    mon => "mn",
    "mon-MN" => "mn-MN",
    nde => "nd",
    "nde-ZW" => "nd-ZW",
    nep => "ne",
    "nep-IN" => "ne-IN",
    "nep-NP" => "ne-NP",
    nno => "nn",
    "nno-NO" => "nn-NO",
    nob => "nb",
    "nob-NO" => "nb-NO",
    "nob-SJ" => "nb-SJ",
    ori => "or",
    "ori-IN" => "or-IN",
    orm => "om",
    "orm-ET" => "om-ET",
    "orm-KE" => "om-KE",
    oss => "os",
    "oss-GE" => "os-GE",
    "oss-RU" => "os-RU",
    pan => "pa",
    "pan-Arab" => "pa-Arab",
    "pan-Arab-PK" => "pa-Arab-PK",
    "pan-Guru" => "pa-Guru",
    "pan-Guru-IN" => "pa-Guru-IN",
    per => "fa",
    "per-AF" => "fa-AF",
    "per-IR" => "fa-IR",
    pol => "pl",
    "pol-PL" => "pl-PL",
    por => "pt",
    "por-AO" => "pt-AO",
    "por-BR" => "pt-BR",
    "por-CH" => "pt-CH",
    "por-CV" => "pt-CV",
    "por-GQ" => "pt-GQ",
    "por-GW" => "pt-GW",
    "por-LU" => "pt-LU",
    "por-MO" => "pt-MO",
    "por-MZ" => "pt-MZ",
    "por-PT" => "pt-PT",
    "por-ST" => "pt-ST",
    "por-TL" => "pt-TL",
    pus => "ps",
    "pus-AF" => "ps-AF",
    que => "qu",
    "que-BO" => "qu-BO",
    "que-EC" => "qu-EC",
    "que-PE" => "qu-PE",
    roh => "rm",
    "roh-CH" => "rm-CH",
    rum => "ro",
    "rum-MD" => "ro-MD",
    "rum-RO" => "ro-RO",
    run => "rn",
    "run-BI" => "rn-BI",
    rus => "ru",
    "rus-BY" => "ru-BY",
    "rus-KG" => "ru-KG",
    "rus-KZ" => "ru-KZ",
    "rus-MD" => "ru-MD",
    "rus-RU" => "ru-RU",
    "rus-UA" => "ru-UA",
    sag => "sg",
    "sag-CF" => "sg-CF",
    sin => "si",
    "sin-LK" => "si-LK",
    slo => "sk",
    "slo-SK" => "sk-SK",
    slv => "sl",
    "slv-SI" => "sl-SI",
    sme => "se",
    "sme-FI" => "se-FI",
    "sme-NO" => "se-NO",
    "sme-SE" => "se-SE",
    sna => "sn",
    "sna-ZW" => "sn-ZW",
    snd => "sd",
    "snd-PK" => "sd-PK",
    som => "so",
    "som-DJ" => "so-DJ",
    "som-ET" => "so-ET",
    "som-KE" => "so-KE",
    "som-SO" => "so-SO",
    spa => "es",
    "spa-419" => "es-419",
    "spa-AR" => "es-AR",
    "spa-BO" => "es-BO",
    "spa-BR" => "es-BR",
    "spa-BZ" => "es-BZ",
    "spa-CL" => "es-CL",
    "spa-CO" => "es-CO",
    "spa-CR" => "es-CR",
    "spa-CU" => "es-CU",
    "spa-DO" => "es-DO",
    "spa-EA" => "es-EA",
    "spa-EC" => "es-EC",
    "spa-ES" => "es-ES",
    "spa-GQ" => "es-GQ",
    "spa-GT" => "es-GT",
    "spa-HN" => "es-HN",
    "spa-IC" => "es-IC",
    "spa-MX" => "es-MX",
    "spa-NI" => "es-NI",
    "spa-PA" => "es-PA",
    "spa-PE" => "es-PE",
    "spa-PH" => "es-PH",
    "spa-PR" => "es-PR",
    "spa-PY" => "es-PY",
    "spa-SV" => "es-SV",
    "spa-US" => "es-US",
    "spa-UY" => "es-UY",
    "spa-VE" => "es-VE",
    srp => "sr",
    "srp-Cyrl" => "sr-Cyrl",
    "srp-Cyrl-BA" => "sr-Cyrl-BA",
    "srp-Cyrl-ME" => "sr-Cyrl-ME",
    "srp-Cyrl-RS" => "sr-Cyrl-RS",
    "srp-Cyrl-XK" => "sr-Cyrl-XK",
    "srp-Latn" => "sr-Latn",
    "srp-Latn-BA" => "sr-Latn-BA",
    "srp-Latn-ME" => "sr-Latn-ME",
    "srp-Latn-RS" => "sr-Latn-RS",
    "srp-Latn-XK" => "sr-Latn-XK",
    swa => "sw",
    "swa-CD" => "sw-CD",
    "swa-KE" => "sw-KE",
    "swa-TZ" => "sw-TZ",
    "swa-UG" => "sw-UG",
    swe => "sv",
    "swe-AX" => "sv-AX",
    "swe-FI" => "sv-FI",
    "swe-SE" => "sv-SE",
    tam => "ta",
    "tam-IN" => "ta-IN",
    "tam-LK" => "ta-LK",
    "tam-MY" => "ta-MY",
    "tam-SG" => "ta-SG",
    tat => "tt",
    "tat-RU" => "tt-RU",
    tel => "te",
    "tel-IN" => "te-IN",
    tgk => "tg",
    "tgk-TJ" => "tg-TJ",
    tha => "th",
    "tha-TH" => "th-TH",
    tib => "bo",
    "tib-CN" => "bo-CN",
    "tib-IN" => "bo-IN",
    tir => "ti",
    "tir-ER" => "ti-ER",
    "tir-ET" => "ti-ET",
    ton => "to",
    "ton-TO" => "to-TO",
    tuk => "tk",
    "tuk-TM" => "tk-TM",
    tur => "tr",
    "tur-CY" => "tr-CY",
    "tur-TR" => "tr-TR",
    uig => "ug",
    "uig-CN" => "ug-CN",
    ukr => "uk",
    "ukr-UA" => "uk-UA",
    urd => "ur",
    "urd-IN" => "ur-IN",
    "urd-PK" => "ur-PK",
    uzb => "uz",
    "uzb-Arab" => "uz-Arab",
    "uzb-Arab-AF" => "uz-Arab-AF",
    "uzb-Cyrl" => "uz-Cyrl",
    "uzb-Cyrl-UZ" => "uz-Cyrl-UZ",
    "uzb-Latn" => "uz-Latn",
    "uzb-Latn-UZ" => "uz-Latn-UZ",
    vie => "vi",
    "vie-VN" => "vi-VN",
    vol => "vo",
    "vol-001" => "vo-001",
    wel => "cy",
    "wel-GB" => "cy-GB",
    wol => "wo",
    "wol-SN" => "wo-SN",
    yid => "yi",
    "yid-001" => "yi-001",
    yor => "yo",
    "yor-BJ" => "yo-BJ",
    "yor-NG" => "yo-NG",
    zul => "zu",
    "zul-ZA" => "zu-ZA",
  );
  ### :end ISO639Aliases:
  #>>>
  
  #<<<
  ### :start LocaleData:
  my %LocaleData = (
    ar => {
      am_pm_abbreviated => [
        "\N{U+0635}",
        "\N{U+0645}",
      ],
      available_formats => {
        Bh => "h B",
        Bhm => "h:mm B",
        Bhms => "h:mm:ss B",
        E => "ccc",
        EBhm => "E h:mm B",
        EBhms => "E h:mm:ss B",
        EHm => "E HH:mm",
        EHms => "E HH:mm:ss",
        Ed => "E\N{U+060c} d",
        Ehm => "E h:mm a",
        Ehms => "E h:mm:ss a",
        Gy => "y G",
        GyMMM => "MMM y G",
        GyMMMEd => "E\N{U+060c} d MMM y G",
        GyMMMd => "d MMM y G",
        H => "HH",
        Hm => "HH:mm",
        Hms => "HH:mm:ss",
        Hmsv => "HH:mm:ss v",
        Hmv => "HH:mm v",
        M => "L",
        MEd => "E\N{U+060c} d/M",
        MMM => "LLL",
        MMMEd => "E\N{U+060c} d MMM",
        MMMMEd => "E\N{U+060c} d MMMM",
        "MMMMW-count-few" => "\N{U+0627}\N{U+0644}\N{U+0623}\N{U+0633}\N{U+0628}\N{U+0648}\N{U+0639} W \N{U+0645}\N{U+0646} MMM",
        "MMMMW-count-many" => "\N{U+0627}\N{U+0644}\N{U+0623}\N{U+0633}\N{U+0628}\N{U+0648}\N{U+0639} W \N{U+0645}\N{U+0646} MMM",
        "MMMMW-count-one" => "\N{U+0627}\N{U+0644}\N{U+0623}\N{U+0633}\N{U+0628}\N{U+0648}\N{U+0639} W \N{U+0645}\N{U+0646} MMM",
        "MMMMW-count-other" => "\N{U+0627}\N{U+0644}\N{U+0623}\N{U+0633}\N{U+0628}\N{U+0648}\N{U+0639} W \N{U+0645}\N{U+0646} MMM",
        "MMMMW-count-two" => "\N{U+0627}\N{U+0644}\N{U+0623}\N{U+0633}\N{U+0628}\N{U+0648}\N{U+0639} W \N{U+0645}\N{U+0646} MMM",
        "MMMMW-count-zero" => "\N{U+0627}\N{U+0644}\N{U+0623}\N{U+0633}\N{U+0628}\N{U+0648}\N{U+0639} W \N{U+0645}\N{U+0646} MMM",
        MMMMd => "d MMMM",
        MMMd => "d MMM",
        MMdd => "dd\N{U+200f}/MM",
        Md => "d/\N{U+200f}M",
        d => "d",
        h => "h a",
        hm => "h:mm a",
        hms => "h:mm:ss a",
        hmsv => "h:mm:ss a v",
        hmv => "h:mm a v",
        ms => "mm:ss",
        y => "y",
        yM => "M\N{U+200f}/y",
        yMEd => "E\N{U+060c} d/\N{U+200f}M/\N{U+200f}y",
        yMM => "MM\N{U+200f}/y",
        yMMM => "MMM y",
        yMMMEd => "E\N{U+060c} d MMM y",
        yMMMM => "MMMM y",
        yMMMd => "d MMM y",
        yMd => "d\N{U+200f}/M\N{U+200f}/y",
        yQQQ => "QQQ y",
        yQQQQ => "QQQQ y",
        "yw-count-few" => "\N{U+0627}\N{U+0644}\N{U+0623}\N{U+0633}\N{U+0628}\N{U+0648}\N{U+0639} w \N{U+0645}\N{U+0646} \N{U+0633}\N{U+0646}\N{U+0629} Y",
        "yw-count-many" => "\N{U+0627}\N{U+0644}\N{U+0623}\N{U+0633}\N{U+0628}\N{U+0648}\N{U+0639} w \N{U+0645}\N{U+0646} \N{U+0633}\N{U+0646}\N{U+0629} Y",
        "yw-count-one" => "\N{U+0627}\N{U+0644}\N{U+0623}\N{U+0633}\N{U+0628}\N{U+0648}\N{U+0639} w \N{U+0645}\N{U+0646} \N{U+0633}\N{U+0646}\N{U+0629} Y",
        "yw-count-other" => "\N{U+0627}\N{U+0644}\N{U+0623}\N{U+0633}\N{U+0628}\N{U+0648}\N{U+0639} w \N{U+0645}\N{U+0646} \N{U+0633}\N{U+0646}\N{U+0629} Y",
        "yw-count-two" => "\N{U+0627}\N{U+0644}\N{U+0623}\N{U+0633}\N{U+0628}\N{U+0648}\N{U+0639} w \N{U+0645}\N{U+0646} \N{U+0633}\N{U+0646}\N{U+0629} Y",
        "yw-count-zero" => "\N{U+0627}\N{U+0644}\N{U+0623}\N{U+0633}\N{U+0628}\N{U+0648}\N{U+0639} w \N{U+0645}\N{U+0646} \N{U+0633}\N{U+0646}\N{U+0629} Y",
      },
      code => "ar",
      date_format_full => "EEEE\N{U+060c} d MMMM y",
      date_format_long => "d MMMM y",
      date_format_medium => "dd\N{U+200f}/MM\N{U+200f}/y",
      date_format_short => "d\N{U+200f}/M\N{U+200f}/y",
      datetime_format_full => "{1} {0}",
      datetime_format_long => "{1} {0}",
      datetime_format_medium => "{1} {0}",
      datetime_format_short => "{1} {0}",
      day_format_abbreviated => [
        "\N{U+0627}\N{U+0644}\N{U+0627}\N{U+062b}\N{U+0646}\N{U+064a}\N{U+0646}",
        "\N{U+0627}\N{U+0644}\N{U+062b}\N{U+0644}\N{U+0627}\N{U+062b}\N{U+0627}\N{U+0621}",
        "\N{U+0627}\N{U+0644}\N{U+0623}\N{U+0631}\N{U+0628}\N{U+0639}\N{U+0627}\N{U+0621}",
        "\N{U+0627}\N{U+0644}\N{U+062e}\N{U+0645}\N{U+064a}\N{U+0633}",
        "\N{U+0627}\N{U+0644}\N{U+062c}\N{U+0645}\N{U+0639}\N{U+0629}",
        "\N{U+0627}\N{U+0644}\N{U+0633}\N{U+0628}\N{U+062a}",
        "\N{U+0627}\N{U+0644}\N{U+0623}\N{U+062d}\N{U+062f}",
      ],
      day_format_narrow => [
        "\N{U+0646}",
        "\N{U+062b}",
        "\N{U+0631}",
        "\N{U+062e}",
        "\N{U+062c}",
        "\N{U+0633}",
        "\N{U+062d}",
      ],
      day_format_wide => [
        "\N{U+0627}\N{U+0644}\N{U+0627}\N{U+062b}\N{U+0646}\N{U+064a}\N{U+0646}",
        "\N{U+0627}\N{U+0644}\N{U+062b}\N{U+0644}\N{U+0627}\N{U+062b}\N{U+0627}\N{U+0621}",
        "\N{U+0627}\N{U+0644}\N{U+0623}\N{U+0631}\N{U+0628}\N{U+0639}\N{U+0627}\N{U+0621}",
        "\N{U+0627}\N{U+0644}\N{U+062e}\N{U+0645}\N{U+064a}\N{U+0633}",
        "\N{U+0627}\N{U+0644}\N{U+062c}\N{U+0645}\N{U+0639}\N{U+0629}",
        "\N{U+0627}\N{U+0644}\N{U+0633}\N{U+0628}\N{U+062a}",
        "\N{U+0627}\N{U+0644}\N{U+0623}\N{U+062d}\N{U+062f}",
      ],
      day_stand_alone_abbreviated => [
        "\N{U+0627}\N{U+0644}\N{U+0627}\N{U+062b}\N{U+0646}\N{U+064a}\N{U+0646}",
        "\N{U+0627}\N{U+0644}\N{U+062b}\N{U+0644}\N{U+0627}\N{U+062b}\N{U+0627}\N{U+0621}",
        "\N{U+0627}\N{U+0644}\N{U+0623}\N{U+0631}\N{U+0628}\N{U+0639}\N{U+0627}\N{U+0621}",
        "\N{U+0627}\N{U+0644}\N{U+062e}\N{U+0645}\N{U+064a}\N{U+0633}",
        "\N{U+0627}\N{U+0644}\N{U+062c}\N{U+0645}\N{U+0639}\N{U+0629}",
        "\N{U+0627}\N{U+0644}\N{U+0633}\N{U+0628}\N{U+062a}",
        "\N{U+0627}\N{U+0644}\N{U+0623}\N{U+062d}\N{U+062f}",
      ],
      day_stand_alone_narrow => [
        "\N{U+0646}",
        "\N{U+062b}",
        "\N{U+0631}",
        "\N{U+062e}",
        "\N{U+062c}",
        "\N{U+0633}",
        "\N{U+062d}",
      ],
      day_stand_alone_wide => [
        "\N{U+0627}\N{U+0644}\N{U+0627}\N{U+062b}\N{U+0646}\N{U+064a}\N{U+0646}",
        "\N{U+0627}\N{U+0644}\N{U+062b}\N{U+0644}\N{U+0627}\N{U+062b}\N{U+0627}\N{U+0621}",
        "\N{U+0627}\N{U+0644}\N{U+0623}\N{U+0631}\N{U+0628}\N{U+0639}\N{U+0627}\N{U+0621}",
        "\N{U+0627}\N{U+0644}\N{U+062e}\N{U+0645}\N{U+064a}\N{U+0633}",
        "\N{U+0627}\N{U+0644}\N{U+062c}\N{U+0645}\N{U+0639}\N{U+0629}",
        "\N{U+0627}\N{U+0644}\N{U+0633}\N{U+0628}\N{U+062a}",
        "\N{U+0627}\N{U+0644}\N{U+0623}\N{U+062d}\N{U+062f}",
      ],
      era_abbreviated => [
        "\N{U+0642}.\N{U+0645}",
        "\N{U+0645}",
      ],
      era_narrow => [
        "\N{U+0642}.\N{U+0645}",
        "\N{U+0645}",
      ],
      era_wide => [
        "\N{U+0642}\N{U+0628}\N{U+0644} \N{U+0627}\N{U+0644}\N{U+0645}\N{U+064a}\N{U+0644}\N{U+0627}\N{U+062f}",
        "\N{U+0645}\N{U+064a}\N{U+0644}\N{U+0627}\N{U+062f}\N{U+064a}",
      ],
      first_day_of_week => 1,
      glibc_date_1_format => "%a %b %e %H:%M:%S %Z %Y",
      glibc_date_format => "%m/%d/%y",
      glibc_datetime_format => "%a %b %e %H:%M:%S %Y",
      glibc_time_12_format => "%I:%M:%S %p",
      glibc_time_format => "%H:%M:%S",
      language => "Arabic",
      month_format_abbreviated => [
        "\N{U+064a}\N{U+0646}\N{U+0627}\N{U+064a}\N{U+0631}",
        "\N{U+0641}\N{U+0628}\N{U+0631}\N{U+0627}\N{U+064a}\N{U+0631}",
        "\N{U+0645}\N{U+0627}\N{U+0631}\N{U+0633}",
        "\N{U+0623}\N{U+0628}\N{U+0631}\N{U+064a}\N{U+0644}",
        "\N{U+0645}\N{U+0627}\N{U+064a}\N{U+0648}",
        "\N{U+064a}\N{U+0648}\N{U+0646}\N{U+064a}\N{U+0648}",
        "\N{U+064a}\N{U+0648}\N{U+0644}\N{U+064a}\N{U+0648}",
        "\N{U+0623}\N{U+063a}\N{U+0633}\N{U+0637}\N{U+0633}",
        "\N{U+0633}\N{U+0628}\N{U+062a}\N{U+0645}\N{U+0628}\N{U+0631}",
        "\N{U+0623}\N{U+0643}\N{U+062a}\N{U+0648}\N{U+0628}\N{U+0631}",
        "\N{U+0646}\N{U+0648}\N{U+0641}\N{U+0645}\N{U+0628}\N{U+0631}",
        "\N{U+062f}\N{U+064a}\N{U+0633}\N{U+0645}\N{U+0628}\N{U+0631}",
      ],
      month_format_narrow => [
        "\N{U+064a}",
        "\N{U+0641}",
        "\N{U+0645}",
        "\N{U+0623}",
        "\N{U+0648}",
        "\N{U+0646}",
        "\N{U+0644}",
        "\N{U+063a}",
        "\N{U+0633}",
        "\N{U+0643}",
        "\N{U+0628}",
        "\N{U+062f}",
      ],
      month_format_wide => [
        "\N{U+064a}\N{U+0646}\N{U+0627}\N{U+064a}\N{U+0631}",
        "\N{U+0641}\N{U+0628}\N{U+0631}\N{U+0627}\N{U+064a}\N{U+0631}",
        "\N{U+0645}\N{U+0627}\N{U+0631}\N{U+0633}",
        "\N{U+0623}\N{U+0628}\N{U+0631}\N{U+064a}\N{U+0644}",
        "\N{U+0645}\N{U+0627}\N{U+064a}\N{U+0648}",
        "\N{U+064a}\N{U+0648}\N{U+0646}\N{U+064a}\N{U+0648}",
        "\N{U+064a}\N{U+0648}\N{U+0644}\N{U+064a}\N{U+0648}",
        "\N{U+0623}\N{U+063a}\N{U+0633}\N{U+0637}\N{U+0633}",
        "\N{U+0633}\N{U+0628}\N{U+062a}\N{U+0645}\N{U+0628}\N{U+0631}",
        "\N{U+0623}\N{U+0643}\N{U+062a}\N{U+0648}\N{U+0628}\N{U+0631}",
        "\N{U+0646}\N{U+0648}\N{U+0641}\N{U+0645}\N{U+0628}\N{U+0631}",
        "\N{U+062f}\N{U+064a}\N{U+0633}\N{U+0645}\N{U+0628}\N{U+0631}",
      ],
      month_stand_alone_abbreviated => [
        "\N{U+064a}\N{U+0646}\N{U+0627}\N{U+064a}\N{U+0631}",
        "\N{U+0641}\N{U+0628}\N{U+0631}\N{U+0627}\N{U+064a}\N{U+0631}",
        "\N{U+0645}\N{U+0627}\N{U+0631}\N{U+0633}",
        "\N{U+0623}\N{U+0628}\N{U+0631}\N{U+064a}\N{U+0644}",
        "\N{U+0645}\N{U+0627}\N{U+064a}\N{U+0648}",
        "\N{U+064a}\N{U+0648}\N{U+0646}\N{U+064a}\N{U+0648}",
        "\N{U+064a}\N{U+0648}\N{U+0644}\N{U+064a}\N{U+0648}",
        "\N{U+0623}\N{U+063a}\N{U+0633}\N{U+0637}\N{U+0633}",
        "\N{U+0633}\N{U+0628}\N{U+062a}\N{U+0645}\N{U+0628}\N{U+0631}",
        "\N{U+0623}\N{U+0643}\N{U+062a}\N{U+0648}\N{U+0628}\N{U+0631}",
        "\N{U+0646}\N{U+0648}\N{U+0641}\N{U+0645}\N{U+0628}\N{U+0631}",
        "\N{U+062f}\N{U+064a}\N{U+0633}\N{U+0645}\N{U+0628}\N{U+0631}",
      ],
      month_stand_alone_narrow => [
        "\N{U+064a}",
        "\N{U+0641}",
        "\N{U+0645}",
        "\N{U+0623}",
        "\N{U+0648}",
        "\N{U+0646}",
        "\N{U+0644}",
        "\N{U+063a}",
        "\N{U+0633}",
        "\N{U+0643}",
        "\N{U+0628}",
        "\N{U+062f}",
      ],
      month_stand_alone_wide => [
        "\N{U+064a}\N{U+0646}\N{U+0627}\N{U+064a}\N{U+0631}",
        "\N{U+0641}\N{U+0628}\N{U+0631}\N{U+0627}\N{U+064a}\N{U+0631}",
        "\N{U+0645}\N{U+0627}\N{U+0631}\N{U+0633}",
        "\N{U+0623}\N{U+0628}\N{U+0631}\N{U+064a}\N{U+0644}",
        "\N{U+0645}\N{U+0627}\N{U+064a}\N{U+0648}",
        "\N{U+064a}\N{U+0648}\N{U+0646}\N{U+064a}\N{U+0648}",
        "\N{U+064a}\N{U+0648}\N{U+0644}\N{U+064a}\N{U+0648}",
        "\N{U+0623}\N{U+063a}\N{U+0633}\N{U+0637}\N{U+0633}",
        "\N{U+0633}\N{U+0628}\N{U+062a}\N{U+0645}\N{U+0628}\N{U+0631}",
        "\N{U+0623}\N{U+0643}\N{U+062a}\N{U+0648}\N{U+0628}\N{U+0631}",
        "\N{U+0646}\N{U+0648}\N{U+0641}\N{U+0645}\N{U+0628}\N{U+0631}",
        "\N{U+062f}\N{U+064a}\N{U+0633}\N{U+0645}\N{U+0628}\N{U+0631}",
      ],
      name => "Arabic",
      native_language => "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629}",
      native_name => "\N{U+0627}\N{U+0644}\N{U+0639}\N{U+0631}\N{U+0628}\N{U+064a}\N{U+0629}",
      native_script => undef,
      native_territory => undef,
      native_variant => undef,
      quarter_format_abbreviated => [
        "\N{U+0627}\N{U+0644}\N{U+0631}\N{U+0628}\N{U+0639} \N{U+0627}\N{U+0644}\N{U+0623}\N{U+0648}\N{U+0644}",
        "\N{U+0627}\N{U+0644}\N{U+0631}\N{U+0628}\N{U+0639} \N{U+0627}\N{U+0644}\N{U+062b}\N{U+0627}\N{U+0646}\N{U+064a}",
        "\N{U+0627}\N{U+0644}\N{U+0631}\N{U+0628}\N{U+0639} \N{U+0627}\N{U+0644}\N{U+062b}\N{U+0627}\N{U+0644}\N{U+062b}",
        "\N{U+0627}\N{U+0644}\N{U+0631}\N{U+0628}\N{U+0639} \N{U+0627}\N{U+0644}\N{U+0631}\N{U+0627}\N{U+0628}\N{U+0639}",
      ],
      quarter_format_narrow => [
        "\N{U+0661}",
        "\N{U+0662}",
        "\N{U+0663}",
        "\N{U+0664}",
      ],
      quarter_format_wide => [
        "\N{U+0627}\N{U+0644}\N{U+0631}\N{U+0628}\N{U+0639} \N{U+0627}\N{U+0644}\N{U+0623}\N{U+0648}\N{U+0644}",
        "\N{U+0627}\N{U+0644}\N{U+0631}\N{U+0628}\N{U+0639} \N{U+0627}\N{U+0644}\N{U+062b}\N{U+0627}\N{U+0646}\N{U+064a}",
        "\N{U+0627}\N{U+0644}\N{U+0631}\N{U+0628}\N{U+0639} \N{U+0627}\N{U+0644}\N{U+062b}\N{U+0627}\N{U+0644}\N{U+062b}",
        "\N{U+0627}\N{U+0644}\N{U+0631}\N{U+0628}\N{U+0639} \N{U+0627}\N{U+0644}\N{U+0631}\N{U+0627}\N{U+0628}\N{U+0639}",
      ],
      quarter_stand_alone_abbreviated => [
        "\N{U+0627}\N{U+0644}\N{U+0631}\N{U+0628}\N{U+0639} \N{U+0627}\N{U+0644}\N{U+0623}\N{U+0648}\N{U+0644}",
        "\N{U+0627}\N{U+0644}\N{U+0631}\N{U+0628}\N{U+0639} \N{U+0627}\N{U+0644}\N{U+062b}\N{U+0627}\N{U+0646}\N{U+064a}",
        "\N{U+0627}\N{U+0644}\N{U+0631}\N{U+0628}\N{U+0639} \N{U+0627}\N{U+0644}\N{U+062b}\N{U+0627}\N{U+0644}\N{U+062b}",
        "\N{U+0627}\N{U+0644}\N{U+0631}\N{U+0628}\N{U+0639} \N{U+0627}\N{U+0644}\N{U+0631}\N{U+0627}\N{U+0628}\N{U+0639}",
      ],
      quarter_stand_alone_narrow => [
        "\N{U+0661}",
        "\N{U+0662}",
        "\N{U+0663}",
        "\N{U+0664}",
      ],
      quarter_stand_alone_wide => [
        "\N{U+0627}\N{U+0644}\N{U+0631}\N{U+0628}\N{U+0639} \N{U+0627}\N{U+0644}\N{U+0623}\N{U+0648}\N{U+0644}",
        "\N{U+0627}\N{U+0644}\N{U+0631}\N{U+0628}\N{U+0639} \N{U+0627}\N{U+0644}\N{U+062b}\N{U+0627}\N{U+0646}\N{U+064a}",
        "\N{U+0627}\N{U+0644}\N{U+0631}\N{U+0628}\N{U+0639} \N{U+0627}\N{U+0644}\N{U+062b}\N{U+0627}\N{U+0644}\N{U+062b}",
        "\N{U+0627}\N{U+0644}\N{U+0631}\N{U+0628}\N{U+0639} \N{U+0627}\N{U+0644}\N{U+0631}\N{U+0627}\N{U+0628}\N{U+0639}",
      ],
      script => undef,
      territory => undef,
      time_format_full => "h:mm:ss a zzzz",
      time_format_long => "h:mm:ss a z",
      time_format_medium => "h:mm:ss a",
      time_format_short => "h:mm a",
      variant => undef,
      version => 33,
    },
    en => {
      am_pm_abbreviated => [
        "AM",
        "PM",
      ],
      available_formats => {
        Bh => "h B",
        Bhm => "h:mm B",
        Bhms => "h:mm:ss B",
        E => "ccc",
        EBhm => "E h:mm B",
        EBhms => "E h:mm:ss B",
        EHm => "E HH:mm",
        EHms => "E HH:mm:ss",
        Ed => "d E",
        Ehm => "E h:mm a",
        Ehms => "E h:mm:ss a",
        Gy => "y G",
        GyMMM => "MMM y G",
        GyMMMEd => "E, MMM d, y G",
        GyMMMd => "MMM d, y G",
        H => "HH",
        Hm => "HH:mm",
        Hms => "HH:mm:ss",
        Hmsv => "HH:mm:ss v",
        Hmv => "HH:mm v",
        M => "L",
        MEd => "E, M/d",
        MMM => "LLL",
        MMMEd => "E, MMM d",
        "MMMMW-count-one" => "'week' W 'of' MMMM",
        "MMMMW-count-other" => "'week' W 'of' MMMM",
        MMMMd => "MMMM d",
        MMMd => "MMM d",
        Md => "M/d",
        d => "d",
        h => "h a",
        hm => "h:mm a",
        hms => "h:mm:ss a",
        hmsv => "h:mm:ss a v",
        hmv => "h:mm a v",
        ms => "mm:ss",
        y => "y",
        yM => "M/y",
        yMEd => "E, M/d/y",
        yMMM => "MMM y",
        yMMMEd => "E, MMM d, y",
        yMMMM => "MMMM y",
        yMMMd => "MMM d, y",
        yMd => "M/d/y",
        yQQQ => "QQQ y",
        yQQQQ => "QQQQ y",
        "yw-count-one" => "'week' w 'of' Y",
        "yw-count-other" => "'week' w 'of' Y",
      },
      code => "en",
      date_format_full => "EEEE, MMMM d, y",
      date_format_long => "MMMM d, y",
      date_format_medium => "MMM d, y",
      date_format_short => "M/d/yy",
      datetime_format_full => "{1} 'at' {0}",
      datetime_format_long => "{1} 'at' {0}",
      datetime_format_medium => "{1}, {0}",
      datetime_format_short => "{1}, {0}",
      day_format_abbreviated => [
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat",
        "Sun",
      ],
      day_format_narrow => [
        "M",
        "T",
        "W",
        "T",
        "F",
        "S",
        "S",
      ],
      day_format_wide => [
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
        "Sunday",
      ],
      day_stand_alone_abbreviated => [
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat",
        "Sun",
      ],
      day_stand_alone_narrow => [
        "M",
        "T",
        "W",
        "T",
        "F",
        "S",
        "S",
      ],
      day_stand_alone_wide => [
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
        "Sunday",
      ],
      era_abbreviated => [
        "BC",
        "AD",
      ],
      era_narrow => [
        "B",
        "A",
      ],
      era_wide => [
        "Before Christ",
        "Anno Domini",
      ],
      first_day_of_week => 1,
      glibc_date_1_format => "%a %b %e %H:%M:%S %Z %Y",
      glibc_date_format => "%m/%d/%y",
      glibc_datetime_format => "%a %b %e %H:%M:%S %Y",
      glibc_time_12_format => "%I:%M:%S %p",
      glibc_time_format => "%H:%M:%S",
      language => "English",
      month_format_abbreviated => [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec",
      ],
      month_format_narrow => [
        "J",
        "F",
        "M",
        "A",
        "M",
        "J",
        "J",
        "A",
        "S",
        "O",
        "N",
        "D",
      ],
      month_format_wide => [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
      ],
      month_stand_alone_abbreviated => [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec",
      ],
      month_stand_alone_narrow => [
        "J",
        "F",
        "M",
        "A",
        "M",
        "J",
        "J",
        "A",
        "S",
        "O",
        "N",
        "D",
      ],
      month_stand_alone_wide => [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
      ],
      name => "English",
      native_language => "English",
      native_name => "English",
      native_script => undef,
      native_territory => undef,
      native_variant => undef,
      quarter_format_abbreviated => [
        "Q1",
        "Q2",
        "Q3",
        "Q4",
      ],
      quarter_format_narrow => [
        1,
        2,
        3,
        4,
      ],
      quarter_format_wide => [
        "1st quarter",
        "2nd quarter",
        "3rd quarter",
        "4th quarter",
      ],
      quarter_stand_alone_abbreviated => [
        "Q1",
        "Q2",
        "Q3",
        "Q4",
      ],
      quarter_stand_alone_narrow => [
        1,
        2,
        3,
        4,
      ],
      quarter_stand_alone_wide => [
        "1st quarter",
        "2nd quarter",
        "3rd quarter",
        "4th quarter",
      ],
      script => undef,
      territory => undef,
      time_format_full => "h:mm:ss a zzzz",
      time_format_long => "h:mm:ss a z",
      time_format_medium => "h:mm:ss a",
      time_format_short => "h:mm a",
      variant => undef,
      version => 33,
    },
    "en-CA" => {
      am_pm_abbreviated => [
        "a.m.",
        "p.m.",
      ],
      available_formats => {
        Bh => "h B",
        Bhm => "h:mm B",
        Bhms => "h:mm:ss B",
        E => "ccc",
        EBhm => "E h:mm B",
        EBhms => "E h:mm:ss B",
        EHm => "E HH:mm",
        EHms => "E HH:mm:ss",
        Ed => "E d",
        Ehm => "E h:mm a",
        Ehms => "E h:mm:ss a",
        Gy => "y G",
        GyMMM => "MMM y G",
        GyMMMEd => "E, MMM d, y G",
        GyMMMd => "MMM d, y G",
        H => "HH",
        Hm => "HH:mm",
        Hms => "HH:mm:ss",
        Hmsv => "HH:mm:ss v",
        Hmv => "HH:mm v",
        M => "L",
        MEd => "E, MM-dd",
        "MEd-alt-variant" => "E, d/M",
        MMM => "LLL",
        MMMEd => "E, MMM d",
        "MMMMW-count-one" => "'week' W 'of' MMMM",
        "MMMMW-count-other" => "'week' W 'of' MMMM",
        MMMMd => "MMMM d",
        MMMd => "MMM d",
        MMdd => "MM-dd",
        "MMdd-alt-variant" => "dd/MM",
        Md => "MM-dd",
        "Md-alt-variant" => "d/M",
        d => "d",
        h => "h a",
        hm => "h:mm a",
        hms => "h:mm:ss a",
        hmsv => "h:mm:ss a v",
        hmv => "h:mm a v",
        ms => "mm:ss",
        y => "y",
        yM => "y-MM",
        "yM-alt-variant" => "M/y",
        yMEd => "E, y-MM-dd",
        "yMEd-alt-variant" => "E, d/M/y",
        yMMM => "MMM y",
        yMMMEd => "E, MMM d, y",
        yMMMM => "MMMM y",
        yMMMd => "MMM d, y",
        yMd => "y-MM-dd",
        "yMd-alt-variant" => "d/M/y",
        yQQQ => "QQQ y",
        yQQQQ => "QQQQ y",
        "yw-count-one" => "'week' w 'of' y",
        "yw-count-other" => "'week' w 'of' y",
      },
      code => "en-CA",
      date_format_full => "EEEE, MMMM d, y",
      date_format_long => "MMMM d, y",
      date_format_medium => "MMM d, y",
      date_format_short => "y-MM-dd",
      datetime_format_full => "{1} 'at' {0}",
      datetime_format_long => "{1} 'at' {0}",
      datetime_format_medium => "{1}, {0}",
      datetime_format_short => "{1}, {0}",
      day_format_abbreviated => [
        "Mon.",
        "Tue.",
        "Wed.",
        "Thu.",
        "Fri.",
        "Sat.",
        "Sun.",
      ],
      day_format_narrow => [
        "M",
        "T",
        "W",
        "T",
        "F",
        "S",
        "S",
      ],
      day_format_wide => [
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
        "Sunday",
      ],
      day_stand_alone_abbreviated => [
        "Mon.",
        "Tue.",
        "Wed.",
        "Thu.",
        "Fri.",
        "Sat.",
        "Sun.",
      ],
      day_stand_alone_narrow => [
        "M",
        "T",
        "W",
        "T",
        "F",
        "S",
        "S",
      ],
      day_stand_alone_wide => [
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
        "Sunday",
      ],
      era_abbreviated => [
        "BC",
        "AD",
      ],
      era_narrow => [
        "B",
        "A",
      ],
      era_wide => [
        "Before Christ",
        "Anno Domini",
      ],
      first_day_of_week => 7,
      glibc_date_1_format => "%a %b %e %H:%M:%S %Z %Y",
      glibc_date_format => "%Y-%m-%d",
      glibc_datetime_format => "%a %d %b %Y %r %Z",
      glibc_time_12_format => "%I:%M:%S %p",
      glibc_time_format => "%r",
      language => "English",
      month_format_abbreviated => [
        "Jan.",
        "Feb.",
        "Mar.",
        "Apr.",
        "May",
        "Jun.",
        "Jul.",
        "Aug.",
        "Sep.",
        "Oct.",
        "Nov.",
        "Dec.",
      ],
      month_format_narrow => [
        "J",
        "F",
        "M",
        "A",
        "M",
        "J",
        "J",
        "A",
        "S",
        "O",
        "N",
        "D",
      ],
      month_format_wide => [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
      ],
      month_stand_alone_abbreviated => [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec",
      ],
      month_stand_alone_narrow => [
        "J",
        "F",
        "M",
        "A",
        "M",
        "J",
        "J",
        "A",
        "S",
        "O",
        "N",
        "D",
      ],
      month_stand_alone_wide => [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
      ],
      name => "English Canada",
      native_language => "English",
      native_name => "English Canada",
      native_script => undef,
      native_territory => "Canada",
      native_variant => undef,
      quarter_format_abbreviated => [
        "Q1",
        "Q2",
        "Q3",
        "Q4",
      ],
      quarter_format_narrow => [
        1,
        2,
        3,
        4,
      ],
      quarter_format_wide => [
        "1st quarter",
        "2nd quarter",
        "3rd quarter",
        "4th quarter",
      ],
      quarter_stand_alone_abbreviated => [
        "Q1",
        "Q2",
        "Q3",
        "Q4",
      ],
      quarter_stand_alone_narrow => [
        1,
        2,
        3,
        4,
      ],
      quarter_stand_alone_wide => [
        "1st quarter",
        "2nd quarter",
        "3rd quarter",
        "4th quarter",
      ],
      script => undef,
      territory => "Canada",
      time_format_full => "h:mm:ss a zzzz",
      time_format_long => "h:mm:ss a z",
      time_format_medium => "h:mm:ss a",
      time_format_short => "h:mm a",
      variant => undef,
      version => 33,
    },
    "en-US" => {
      am_pm_abbreviated => [
        "AM",
        "PM",
      ],
      available_formats => {
        Bh => "h B",
        Bhm => "h:mm B",
        Bhms => "h:mm:ss B",
        E => "ccc",
        EBhm => "E h:mm B",
        EBhms => "E h:mm:ss B",
        EHm => "E HH:mm",
        EHms => "E HH:mm:ss",
        Ed => "d E",
        Ehm => "E h:mm a",
        Ehms => "E h:mm:ss a",
        Gy => "y G",
        GyMMM => "MMM y G",
        GyMMMEd => "E, MMM d, y G",
        GyMMMd => "MMM d, y G",
        H => "HH",
        Hm => "HH:mm",
        Hms => "HH:mm:ss",
        Hmsv => "HH:mm:ss v",
        Hmv => "HH:mm v",
        M => "L",
        MEd => "E, M/d",
        MMM => "LLL",
        MMMEd => "E, MMM d",
        "MMMMW-count-one" => "'week' W 'of' MMMM",
        "MMMMW-count-other" => "'week' W 'of' MMMM",
        MMMMd => "MMMM d",
        MMMd => "MMM d",
        Md => "M/d",
        d => "d",
        h => "h a",
        hm => "h:mm a",
        hms => "h:mm:ss a",
        hmsv => "h:mm:ss a v",
        hmv => "h:mm a v",
        ms => "mm:ss",
        y => "y",
        yM => "M/y",
        yMEd => "E, M/d/y",
        yMMM => "MMM y",
        yMMMEd => "E, MMM d, y",
        yMMMM => "MMMM y",
        yMMMd => "MMM d, y",
        yMd => "M/d/y",
        yQQQ => "QQQ y",
        yQQQQ => "QQQQ y",
        "yw-count-one" => "'week' w 'of' Y",
        "yw-count-other" => "'week' w 'of' Y",
      },
      code => "en-US",
      date_format_full => "EEEE, MMMM d, y",
      date_format_long => "MMMM d, y",
      date_format_medium => "MMM d, y",
      date_format_short => "M/d/yy",
      datetime_format_full => "{1} 'at' {0}",
      datetime_format_long => "{1} 'at' {0}",
      datetime_format_medium => "{1}, {0}",
      datetime_format_short => "{1}, {0}",
      day_format_abbreviated => [
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat",
        "Sun",
      ],
      day_format_narrow => [
        "M",
        "T",
        "W",
        "T",
        "F",
        "S",
        "S",
      ],
      day_format_wide => [
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
        "Sunday",
      ],
      day_stand_alone_abbreviated => [
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat",
        "Sun",
      ],
      day_stand_alone_narrow => [
        "M",
        "T",
        "W",
        "T",
        "F",
        "S",
        "S",
      ],
      day_stand_alone_wide => [
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
        "Sunday",
      ],
      era_abbreviated => [
        "BC",
        "AD",
      ],
      era_narrow => [
        "B",
        "A",
      ],
      era_wide => [
        "Before Christ",
        "Anno Domini",
      ],
      first_day_of_week => 7,
      glibc_date_1_format => "%a %b %e %H:%M:%S %Z %Y",
      glibc_date_format => "%m/%d/%Y",
      glibc_datetime_format => "%a %d %b %Y %r %Z",
      glibc_time_12_format => "%I:%M:%S %p",
      glibc_time_format => "%r",
      language => "English",
      month_format_abbreviated => [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec",
      ],
      month_format_narrow => [
        "J",
        "F",
        "M",
        "A",
        "M",
        "J",
        "J",
        "A",
        "S",
        "O",
        "N",
        "D",
      ],
      month_format_wide => [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
      ],
      month_stand_alone_abbreviated => [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec",
      ],
      month_stand_alone_narrow => [
        "J",
        "F",
        "M",
        "A",
        "M",
        "J",
        "J",
        "A",
        "S",
        "O",
        "N",
        "D",
      ],
      month_stand_alone_wide => [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
      ],
      name => "English United States",
      native_language => "English",
      native_name => "English United States",
      native_script => undef,
      native_territory => "United States",
      native_variant => undef,
      quarter_format_abbreviated => [
        "Q1",
        "Q2",
        "Q3",
        "Q4",
      ],
      quarter_format_narrow => [
        1,
        2,
        3,
        4,
      ],
      quarter_format_wide => [
        "1st quarter",
        "2nd quarter",
        "3rd quarter",
        "4th quarter",
      ],
      quarter_stand_alone_abbreviated => [
        "Q1",
        "Q2",
        "Q3",
        "Q4",
      ],
      quarter_stand_alone_narrow => [
        1,
        2,
        3,
        4,
      ],
      quarter_stand_alone_wide => [
        "1st quarter",
        "2nd quarter",
        "3rd quarter",
        "4th quarter",
      ],
      script => undef,
      territory => "United States",
      time_format_full => "h:mm:ss a zzzz",
      time_format_long => "h:mm:ss a z",
      time_format_medium => "h:mm:ss a",
      time_format_short => "h:mm a",
      variant => undef,
      version => 33,
    },
    es => {
      am_pm_abbreviated => [
        "a. m.",
        "p. m.",
      ],
      available_formats => {
        Bh => "h B",
        Bhm => "h:mm B",
        Bhms => "h:mm:ss B",
        E => "ccc",
        EBhm => "E h:mm B",
        EBhms => "E h:mm:ss B",
        EHm => "E, H:mm",
        EHms => "E, H:mm:ss",
        Ed => "E d",
        Ehm => "E, h:mm a",
        Ehms => "E, h:mm:ss a",
        Gy => "y G",
        GyMMM => "MMM y G",
        GyMMMEd => "E, d MMM y G",
        GyMMMM => "MMMM 'de' y G",
        GyMMMMEd => "E, d 'de' MMMM 'de' y G",
        GyMMMMd => "d 'de' MMMM 'de' y G",
        GyMMMd => "d MMM y G",
        H => "H",
        Hm => "H:mm",
        Hms => "H:mm:ss",
        Hmsv => "H:mm:ss v",
        Hmsvvvv => "H:mm:ss (vvvv)",
        Hmv => "H:mm v",
        M => "L",
        MEd => "E, d/M",
        MMM => "LLL",
        MMMEd => "E, d MMM",
        MMMMEd => "E, d 'de' MMMM",
        "MMMMW-count-one" => "'semana' W 'de' MMM",
        "MMMMW-count-other" => "'semana' W 'de' MMM",
        MMMMd => "d 'de' MMMM",
        MMMd => "d MMM",
        MMd => "d/M",
        MMdd => "d/M",
        Md => "d/M",
        d => "d",
        h => "h a",
        hm => "h:mm a",
        hms => "h:mm:ss a",
        hmsv => "h:mm:ss a v",
        hmsvvvv => "h:mm:ss a (vvvv)",
        hmv => "h:mm a v",
        ms => "mm:ss",
        y => "y",
        yM => "M/y",
        yMEd => "EEE, d/M/y",
        yMM => "M/y",
        yMMM => "MMM y",
        yMMMEd => "EEE, d MMM y",
        yMMMM => "MMMM 'de' y",
        yMMMMEd => "EEE, d 'de' MMMM 'de' y",
        yMMMMd => "d 'de' MMMM 'de' y",
        yMMMd => "d MMM y",
        yMd => "d/M/y",
        yQQQ => "QQQ y",
        yQQQQ => "QQQQ 'de' y",
        "yw-count-one" => "'semana' w 'de' y",
        "yw-count-other" => "'semana' w 'de' y",
      },
      code => "es",
      date_format_full => "EEEE, d 'de' MMMM 'de' y",
      date_format_long => "d 'de' MMMM 'de' y",
      date_format_medium => "d MMM y",
      date_format_short => "d/M/yy",
      datetime_format_full => "{1}, {0}",
      datetime_format_long => "{1}, {0}",
      datetime_format_medium => "{1} {0}",
      datetime_format_short => "{1} {0}",
      day_format_abbreviated => [
        "lun.",
        "mar.",
        "mi\N{U+00e9}.",
        "jue.",
        "vie.",
        "s\N{U+00e1}b.",
        "dom.",
      ],
      day_format_narrow => [
        "L",
        "M",
        "X",
        "J",
        "V",
        "S",
        "D",
      ],
      day_format_wide => [
        "lunes",
        "martes",
        "mi\N{U+00e9}rcoles",
        "jueves",
        "viernes",
        "s\N{U+00e1}bado",
        "domingo",
      ],
      day_stand_alone_abbreviated => [
        "lun.",
        "mar.",
        "mi\N{U+00e9}.",
        "jue.",
        "vie.",
        "s\N{U+00e1}b.",
        "dom.",
      ],
      day_stand_alone_narrow => [
        "L",
        "M",
        "X",
        "J",
        "V",
        "S",
        "D",
      ],
      day_stand_alone_wide => [
        "lunes",
        "martes",
        "mi\N{U+00e9}rcoles",
        "jueves",
        "viernes",
        "s\N{U+00e1}bado",
        "domingo",
      ],
      era_abbreviated => [
        "a. C.",
        "d. C.",
      ],
      era_narrow => [
        "a. C.",
        "d. C.",
      ],
      era_wide => [
        "antes de Cristo",
        "despu\N{U+00e9}s de Cristo",
      ],
      first_day_of_week => 1,
      glibc_date_1_format => "%a %b %e %H:%M:%S %Z %Y",
      glibc_date_format => "%m/%d/%y",
      glibc_datetime_format => "%a %b %e %H:%M:%S %Y",
      glibc_time_12_format => "%I:%M:%S %p",
      glibc_time_format => "%H:%M:%S",
      language => "Spanish",
      month_format_abbreviated => [
        "ene.",
        "feb.",
        "mar.",
        "abr.",
        "may.",
        "jun.",
        "jul.",
        "ago.",
        "sept.",
        "oct.",
        "nov.",
        "dic.",
      ],
      month_format_narrow => [
        "E",
        "F",
        "M",
        "A",
        "M",
        "J",
        "J",
        "A",
        "S",
        "O",
        "N",
        "D",
      ],
      month_format_wide => [
        "enero",
        "febrero",
        "marzo",
        "abril",
        "mayo",
        "junio",
        "julio",
        "agosto",
        "septiembre",
        "octubre",
        "noviembre",
        "diciembre",
      ],
      month_stand_alone_abbreviated => [
        "ene.",
        "feb.",
        "mar.",
        "abr.",
        "may.",
        "jun.",
        "jul.",
        "ago.",
        "sept.",
        "oct.",
        "nov.",
        "dic.",
      ],
      month_stand_alone_narrow => [
        "E",
        "F",
        "M",
        "A",
        "M",
        "J",
        "J",
        "A",
        "S",
        "O",
        "N",
        "D",
      ],
      month_stand_alone_wide => [
        "enero",
        "febrero",
        "marzo",
        "abril",
        "mayo",
        "junio",
        "julio",
        "agosto",
        "septiembre",
        "octubre",
        "noviembre",
        "diciembre",
      ],
      name => "Spanish",
      native_language => "espa\N{U+00f1}ol",
      native_name => "espa\N{U+00f1}ol",
      native_script => undef,
      native_territory => undef,
      native_variant => undef,
      quarter_format_abbreviated => [
        "T1",
        "T2",
        "T3",
        "T4",
      ],
      quarter_format_narrow => [
        1,
        2,
        3,
        4,
      ],
      quarter_format_wide => [
        "1.er trimestre",
        "2.\N{U+00ba} trimestre",
        "3.er trimestre",
        "4.\N{U+00ba} trimestre",
      ],
      quarter_stand_alone_abbreviated => [
        "T1",
        "T2",
        "T3",
        "T4",
      ],
      quarter_stand_alone_narrow => [
        1,
        2,
        3,
        4,
      ],
      quarter_stand_alone_wide => [
        "1.er trimestre",
        "2.\N{U+00ba} trimestre",
        "3.er trimestre",
        "4.\N{U+00ba} trimestre",
      ],
      script => undef,
      territory => undef,
      time_format_full => "H:mm:ss (zzzz)",
      time_format_long => "H:mm:ss z",
      time_format_medium => "H:mm:ss",
      time_format_short => "H:mm",
      variant => undef,
      version => 33,
    },
    "fr-FR" => {
      am_pm_abbreviated => [
        "AM",
        "PM",
      ],
      available_formats => {
        Bh => "h B",
        Bhm => "h:mm B",
        Bhms => "h:mm:ss B",
        E => "E",
        EBhm => "E h:mm B",
        EBhms => "E h:mm:ss B",
        EHm => "E HH:mm",
        EHms => "E HH:mm:ss",
        Ed => "E d",
        Ehm => "E h:mm a",
        Ehms => "E h:mm:ss a",
        Gy => "y G",
        GyMMM => "MMM y G",
        GyMMMEd => "E d MMM y G",
        GyMMMd => "d MMM y G",
        H => "HH 'h'",
        Hm => "HH:mm",
        Hms => "HH:mm:ss",
        Hmsv => "HH:mm:ss v",
        Hmv => "HH:mm v",
        M => "L",
        MEd => "E dd/MM",
        MMM => "LLL",
        MMMEd => "E d MMM",
        "MMMMW-count-one" => "'semaine' W (MMMM)",
        "MMMMW-count-other" => "'semaine' W (MMMM)",
        MMMMd => "d MMMM",
        MMMd => "d MMM",
        Md => "dd/MM",
        d => "d",
        h => "h a",
        hm => "h:mm a",
        hms => "h:mm:ss a",
        hmsv => "h:mm:ss a v",
        hmv => "h:mm a v",
        ms => "mm:ss",
        y => "y",
        yM => "MM/y",
        yMEd => "E dd/MM/y",
        yMMM => "MMM y",
        yMMMEd => "E d MMM y",
        yMMMM => "MMMM y",
        yMMMd => "d MMM y",
        yMd => "dd/MM/y",
        yQQQ => "QQQ y",
        yQQQQ => "QQQQ y",
        "yw-count-one" => "'semaine' w 'de' Y",
        "yw-count-other" => "'semaine' w 'de' Y",
      },
      code => "fr-FR",
      date_format_full => "EEEE d MMMM y",
      date_format_long => "d MMMM y",
      date_format_medium => "d MMM y",
      date_format_short => "dd/MM/y",
      datetime_format_full => "{1} '\N{U+00e0}' {0}",
      datetime_format_long => "{1} '\N{U+00e0}' {0}",
      datetime_format_medium => "{1} '\N{U+00e0}' {0}",
      datetime_format_short => "{1} {0}",
      day_format_abbreviated => [
        "lun.",
        "mar.",
        "mer.",
        "jeu.",
        "ven.",
        "sam.",
        "dim.",
      ],
      day_format_narrow => [
        "L",
        "M",
        "M",
        "J",
        "V",
        "S",
        "D",
      ],
      day_format_wide => [
        "lundi",
        "mardi",
        "mercredi",
        "jeudi",
        "vendredi",
        "samedi",
        "dimanche",
      ],
      day_stand_alone_abbreviated => [
        "lun.",
        "mar.",
        "mer.",
        "jeu.",
        "ven.",
        "sam.",
        "dim.",
      ],
      day_stand_alone_narrow => [
        "L",
        "M",
        "M",
        "J",
        "V",
        "S",
        "D",
      ],
      day_stand_alone_wide => [
        "lundi",
        "mardi",
        "mercredi",
        "jeudi",
        "vendredi",
        "samedi",
        "dimanche",
      ],
      era_abbreviated => [
        "av. J.-C.",
        "ap. J.-C.",
      ],
      era_narrow => [
        "av. J.-C.",
        "ap. J.-C.",
      ],
      era_wide => [
        "avant J\N{U+00e9}sus-Christ",
        "apr\N{U+00e8}s J\N{U+00e9}sus-Christ",
      ],
      first_day_of_week => 1,
      glibc_date_1_format => "%a %b %e %H:%M:%S %Z %Y",
      glibc_date_format => "%d/%m/%Y",
      glibc_datetime_format => "%a %d %b %Y %T %Z",
      glibc_time_12_format => "%I:%M:%S %p",
      glibc_time_format => "%T",
      language => "French",
      month_format_abbreviated => [
        "janv.",
        "f\N{U+00e9}vr.",
        "mars",
        "avr.",
        "mai",
        "juin",
        "juil.",
        "ao\N{U+00fb}t",
        "sept.",
        "oct.",
        "nov.",
        "d\N{U+00e9}c.",
      ],
      month_format_narrow => [
        "J",
        "F",
        "M",
        "A",
        "M",
        "J",
        "J",
        "A",
        "S",
        "O",
        "N",
        "D",
      ],
      month_format_wide => [
        "janvier",
        "f\N{U+00e9}vrier",
        "mars",
        "avril",
        "mai",
        "juin",
        "juillet",
        "ao\N{U+00fb}t",
        "septembre",
        "octobre",
        "novembre",
        "d\N{U+00e9}cembre",
      ],
      month_stand_alone_abbreviated => [
        "janv.",
        "f\N{U+00e9}vr.",
        "mars",
        "avr.",
        "mai",
        "juin",
        "juil.",
        "ao\N{U+00fb}t",
        "sept.",
        "oct.",
        "nov.",
        "d\N{U+00e9}c.",
      ],
      month_stand_alone_narrow => [
        "J",
        "F",
        "M",
        "A",
        "M",
        "J",
        "J",
        "A",
        "S",
        "O",
        "N",
        "D",
      ],
      month_stand_alone_wide => [
        "janvier",
        "f\N{U+00e9}vrier",
        "mars",
        "avril",
        "mai",
        "juin",
        "juillet",
        "ao\N{U+00fb}t",
        "septembre",
        "octobre",
        "novembre",
        "d\N{U+00e9}cembre",
      ],
      name => "French France",
      native_language => "fran\N{U+00e7}ais",
      native_name => "fran\N{U+00e7}ais France",
      native_script => undef,
      native_territory => "France",
      native_variant => undef,
      quarter_format_abbreviated => [
        "T1",
        "T2",
        "T3",
        "T4",
      ],
      quarter_format_narrow => [
        1,
        2,
        3,
        4,
      ],
      quarter_format_wide => [
        "1er trimestre",
        "2e trimestre",
        "3e trimestre",
        "4e trimestre",
      ],
      quarter_stand_alone_abbreviated => [
        "T1",
        "T2",
        "T3",
        "T4",
      ],
      quarter_stand_alone_narrow => [
        1,
        2,
        3,
        4,
      ],
      quarter_stand_alone_wide => [
        "1er trimestre",
        "2e trimestre",
        "3e trimestre",
        "4e trimestre",
      ],
      script => undef,
      territory => "France",
      time_format_full => "HH:mm:ss zzzz",
      time_format_long => "HH:mm:ss z",
      time_format_medium => "HH:mm:ss",
      time_format_short => "HH:mm",
      variant => undef,
      version => 33,
    },
    hi => {
      am_pm_abbreviated => [
        "\N{U+092a}\N{U+0942}\N{U+0930}\N{U+094d}\N{U+0935}\N{U+093e}\N{U+0939}\N{U+094d}\N{U+0928}",
        "\N{U+0905}\N{U+092a}\N{U+0930}\N{U+093e}\N{U+0939}\N{U+094d}\N{U+0928}",
      ],
      available_formats => {
        Bh => "B h",
        Bhm => "B h:mm",
        Bhms => "B h:mm:ss",
        E => "ccc",
        EBhm => "E B h:mm",
        EBhms => "E B h:mm:ss",
        EHm => "E HH:mm",
        EHms => "E HH:mm:ss",
        Ed => "E d",
        Ehm => "E h:mm a",
        Ehms => "E h:mm:ss a",
        Gy => "y G",
        GyMMM => "MMM G y",
        GyMMMEd => "E, d MMM y G",
        GyMMMd => "d MMM y G",
        H => "HH",
        Hm => "HH:mm",
        Hms => "HH:mm:ss",
        Hmsv => "HH:mm:ss v",
        Hmv => "HH:mm v",
        M => "L",
        MEd => "E, d/M",
        MMM => "LLL",
        MMMEd => "E, d MMM",
        MMMMEd => "E, d MMMM",
        "MMMMW-count-one" => "MMM \N{U+0915}\N{U+093e} \N{U+0938}\N{U+092a}\N{U+094d}\N{U+0924}\N{U+093e}\N{U+0939} W",
        "MMMMW-count-other" => "MMM \N{U+0915}\N{U+093e} \N{U+0938}\N{U+092a}\N{U+094d}\N{U+0924}\N{U+093e}\N{U+0939} W",
        MMMMd => "d MMMM",
        MMMd => "d MMM",
        MMdd => "dd/MM",
        Md => "d/M",
        d => "d",
        h => "h a",
        hm => "h:mm a",
        hms => "h:mm:ss a",
        hmsv => "h:mm:ss a v",
        hmv => "h:mm a v",
        ms => "mm:ss",
        y => "y",
        yM => "M/y",
        yMEd => "E, d/M/y",
        yMM => "MM/y",
        yMMM => "MMM y",
        yMMMEd => "E, d MMM y",
        yMMMM => "MMMM y",
        yMMMd => "d MMM y",
        yMMdd => "dd/MM/y",
        yMd => "d/M/y",
        yQQQ => "QQQ y",
        yQQQQ => "QQQQ y",
        "yw-count-one" => "Y \N{U+0915}\N{U+093e} \N{U+0938}\N{U+092a}\N{U+094d}\N{U+0924}\N{U+093e}\N{U+0939} w",
        "yw-count-other" => "Y \N{U+0915}\N{U+093e} \N{U+0938}\N{U+092a}\N{U+094d}\N{U+0924}\N{U+093e}\N{U+0939} w",
      },
      code => "hi",
      date_format_full => "EEEE, d MMMM y",
      date_format_long => "d MMMM y",
      date_format_medium => "d MMM y",
      date_format_short => "d/M/yy",
      datetime_format_full => "{1} \N{U+0915}\N{U+094b} {0}",
      datetime_format_long => "{1} \N{U+0915}\N{U+094b} {0}",
      datetime_format_medium => "{1}, {0}",
      datetime_format_short => "{1}, {0}",
      day_format_abbreviated => [
        "\N{U+0938}\N{U+094b}\N{U+092e}",
        "\N{U+092e}\N{U+0902}\N{U+0917}\N{U+0932}",
        "\N{U+092c}\N{U+0941}\N{U+0927}",
        "\N{U+0917}\N{U+0941}\N{U+0930}\N{U+0941}",
        "\N{U+0936}\N{U+0941}\N{U+0915}\N{U+094d}\N{U+0930}",
        "\N{U+0936}\N{U+0928}\N{U+093f}",
        "\N{U+0930}\N{U+0935}\N{U+093f}",
      ],
      day_format_narrow => [
        "\N{U+0938}\N{U+094b}",
        "\N{U+092e}\N{U+0902}",
        "\N{U+092c}\N{U+0941}",
        "\N{U+0917}\N{U+0941}",
        "\N{U+0936}\N{U+0941}",
        "\N{U+0936}",
        "\N{U+0930}",
      ],
      day_format_wide => [
        "\N{U+0938}\N{U+094b}\N{U+092e}\N{U+0935}\N{U+093e}\N{U+0930}",
        "\N{U+092e}\N{U+0902}\N{U+0917}\N{U+0932}\N{U+0935}\N{U+093e}\N{U+0930}",
        "\N{U+092c}\N{U+0941}\N{U+0927}\N{U+0935}\N{U+093e}\N{U+0930}",
        "\N{U+0917}\N{U+0941}\N{U+0930}\N{U+0941}\N{U+0935}\N{U+093e}\N{U+0930}",
        "\N{U+0936}\N{U+0941}\N{U+0915}\N{U+094d}\N{U+0930}\N{U+0935}\N{U+093e}\N{U+0930}",
        "\N{U+0936}\N{U+0928}\N{U+093f}\N{U+0935}\N{U+093e}\N{U+0930}",
        "\N{U+0930}\N{U+0935}\N{U+093f}\N{U+0935}\N{U+093e}\N{U+0930}",
      ],
      day_stand_alone_abbreviated => [
        "\N{U+0938}\N{U+094b}\N{U+092e}",
        "\N{U+092e}\N{U+0902}\N{U+0917}\N{U+0932}",
        "\N{U+092c}\N{U+0941}\N{U+0927}",
        "\N{U+0917}\N{U+0941}\N{U+0930}\N{U+0941}",
        "\N{U+0936}\N{U+0941}\N{U+0915}\N{U+094d}\N{U+0930}",
        "\N{U+0936}\N{U+0928}\N{U+093f}",
        "\N{U+0930}\N{U+0935}\N{U+093f}",
      ],
      day_stand_alone_narrow => [
        "\N{U+0938}\N{U+094b}",
        "\N{U+092e}\N{U+0902}",
        "\N{U+092c}\N{U+0941}",
        "\N{U+0917}\N{U+0941}",
        "\N{U+0936}\N{U+0941}",
        "\N{U+0936}",
        "\N{U+0930}",
      ],
      day_stand_alone_wide => [
        "\N{U+0938}\N{U+094b}\N{U+092e}\N{U+0935}\N{U+093e}\N{U+0930}",
        "\N{U+092e}\N{U+0902}\N{U+0917}\N{U+0932}\N{U+0935}\N{U+093e}\N{U+0930}",
        "\N{U+092c}\N{U+0941}\N{U+0927}\N{U+0935}\N{U+093e}\N{U+0930}",
        "\N{U+0917}\N{U+0941}\N{U+0930}\N{U+0941}\N{U+0935}\N{U+093e}\N{U+0930}",
        "\N{U+0936}\N{U+0941}\N{U+0915}\N{U+094d}\N{U+0930}\N{U+0935}\N{U+093e}\N{U+0930}",
        "\N{U+0936}\N{U+0928}\N{U+093f}\N{U+0935}\N{U+093e}\N{U+0930}",
        "\N{U+0930}\N{U+0935}\N{U+093f}\N{U+0935}\N{U+093e}\N{U+0930}",
      ],
      era_abbreviated => [
        "\N{U+0908}\N{U+0938}\N{U+093e}-\N{U+092a}\N{U+0942}\N{U+0930}\N{U+094d}\N{U+0935}",
        "\N{U+0908}\N{U+0938}\N{U+094d}\N{U+0935}\N{U+0940}",
      ],
      era_narrow => [
        "\N{U+0908}\N{U+0938}\N{U+093e}-\N{U+092a}\N{U+0942}\N{U+0930}\N{U+094d}\N{U+0935}",
        "\N{U+0908}\N{U+0938}\N{U+094d}\N{U+0935}\N{U+0940}",
      ],
      era_wide => [
        "\N{U+0908}\N{U+0938}\N{U+093e}-\N{U+092a}\N{U+0942}\N{U+0930}\N{U+094d}\N{U+0935}",
        "\N{U+0908}\N{U+0938}\N{U+0935}\N{U+0940} \N{U+0938}\N{U+0928}",
      ],
      first_day_of_week => 1,
      glibc_date_1_format => "%a %b %e %H:%M:%S %Z %Y",
      glibc_date_format => "%m/%d/%y",
      glibc_datetime_format => "%a %b %e %H:%M:%S %Y",
      glibc_time_12_format => "%I:%M:%S %p",
      glibc_time_format => "%H:%M:%S",
      language => "Hindi",
      month_format_abbreviated => [
        "\N{U+091c}\N{U+0928}\N{U+0970}",
        "\N{U+092b}\N{U+093c}\N{U+0930}\N{U+0970}",
        "\N{U+092e}\N{U+093e}\N{U+0930}\N{U+094d}\N{U+091a}",
        "\N{U+0905}\N{U+092a}\N{U+094d}\N{U+0930}\N{U+0948}\N{U+0932}",
        "\N{U+092e}\N{U+0908}",
        "\N{U+091c}\N{U+0942}\N{U+0928}",
        "\N{U+091c}\N{U+0941}\N{U+0932}\N{U+0970}",
        "\N{U+0905}\N{U+0917}\N{U+0970}",
        "\N{U+0938}\N{U+093f}\N{U+0924}\N{U+0970}",
        "\N{U+0905}\N{U+0915}\N{U+094d}\N{U+0924}\N{U+0942}\N{U+0970}",
        "\N{U+0928}\N{U+0935}\N{U+0970}",
        "\N{U+0926}\N{U+093f}\N{U+0938}\N{U+0970}",
      ],
      month_format_narrow => [
        "\N{U+091c}",
        "\N{U+092b}\N{U+093c}",
        "\N{U+092e}\N{U+093e}",
        "\N{U+0905}",
        "\N{U+092e}",
        "\N{U+091c}\N{U+0942}",
        "\N{U+091c}\N{U+0941}",
        "\N{U+0905}",
        "\N{U+0938}\N{U+093f}",
        "\N{U+0905}",
        "\N{U+0928}",
        "\N{U+0926}\N{U+093f}",
      ],
      month_format_wide => [
        "\N{U+091c}\N{U+0928}\N{U+0935}\N{U+0930}\N{U+0940}",
        "\N{U+092b}\N{U+093c}\N{U+0930}\N{U+0935}\N{U+0930}\N{U+0940}",
        "\N{U+092e}\N{U+093e}\N{U+0930}\N{U+094d}\N{U+091a}",
        "\N{U+0905}\N{U+092a}\N{U+094d}\N{U+0930}\N{U+0948}\N{U+0932}",
        "\N{U+092e}\N{U+0908}",
        "\N{U+091c}\N{U+0942}\N{U+0928}",
        "\N{U+091c}\N{U+0941}\N{U+0932}\N{U+093e}\N{U+0908}",
        "\N{U+0905}\N{U+0917}\N{U+0938}\N{U+094d}\N{U+0924}",
        "\N{U+0938}\N{U+093f}\N{U+0924}\N{U+0902}\N{U+092c}\N{U+0930}",
        "\N{U+0905}\N{U+0915}\N{U+094d}\N{U+0924}\N{U+0942}\N{U+092c}\N{U+0930}",
        "\N{U+0928}\N{U+0935}\N{U+0902}\N{U+092c}\N{U+0930}",
        "\N{U+0926}\N{U+093f}\N{U+0938}\N{U+0902}\N{U+092c}\N{U+0930}",
      ],
      month_stand_alone_abbreviated => [
        "\N{U+091c}\N{U+0928}\N{U+0970}",
        "\N{U+092b}\N{U+093c}\N{U+0930}\N{U+0970}",
        "\N{U+092e}\N{U+093e}\N{U+0930}\N{U+094d}\N{U+091a}",
        "\N{U+0905}\N{U+092a}\N{U+094d}\N{U+0930}\N{U+0948}\N{U+0932}",
        "\N{U+092e}\N{U+0908}",
        "\N{U+091c}\N{U+0942}\N{U+0928}",
        "\N{U+091c}\N{U+0941}\N{U+0932}\N{U+0970}",
        "\N{U+0905}\N{U+0917}\N{U+0970}",
        "\N{U+0938}\N{U+093f}\N{U+0924}\N{U+0970}",
        "\N{U+0905}\N{U+0915}\N{U+094d}\N{U+0924}\N{U+0942}\N{U+0970}",
        "\N{U+0928}\N{U+0935}\N{U+0970}",
        "\N{U+0926}\N{U+093f}\N{U+0938}\N{U+0970}",
      ],
      month_stand_alone_narrow => [
        "\N{U+091c}",
        "\N{U+092b}\N{U+093c}",
        "\N{U+092e}\N{U+093e}",
        "\N{U+0905}",
        "\N{U+092e}",
        "\N{U+091c}\N{U+0942}",
        "\N{U+091c}\N{U+0941}",
        "\N{U+0905}",
        "\N{U+0938}\N{U+093f}",
        "\N{U+0905}",
        "\N{U+0928}",
        "\N{U+0926}\N{U+093f}",
      ],
      month_stand_alone_wide => [
        "\N{U+091c}\N{U+0928}\N{U+0935}\N{U+0930}\N{U+0940}",
        "\N{U+092b}\N{U+093c}\N{U+0930}\N{U+0935}\N{U+0930}\N{U+0940}",
        "\N{U+092e}\N{U+093e}\N{U+0930}\N{U+094d}\N{U+091a}",
        "\N{U+0905}\N{U+092a}\N{U+094d}\N{U+0930}\N{U+0948}\N{U+0932}",
        "\N{U+092e}\N{U+0908}",
        "\N{U+091c}\N{U+0942}\N{U+0928}",
        "\N{U+091c}\N{U+0941}\N{U+0932}\N{U+093e}\N{U+0908}",
        "\N{U+0905}\N{U+0917}\N{U+0938}\N{U+094d}\N{U+0924}",
        "\N{U+0938}\N{U+093f}\N{U+0924}\N{U+0902}\N{U+092c}\N{U+0930}",
        "\N{U+0905}\N{U+0915}\N{U+094d}\N{U+0924}\N{U+0942}\N{U+092c}\N{U+0930}",
        "\N{U+0928}\N{U+0935}\N{U+0902}\N{U+092c}\N{U+0930}",
        "\N{U+0926}\N{U+093f}\N{U+0938}\N{U+0902}\N{U+092c}\N{U+0930}",
      ],
      name => "Hindi",
      native_language => "\N{U+0939}\N{U+093f}\N{U+0928}\N{U+094d}\N{U+0926}\N{U+0940}",
      native_name => "\N{U+0939}\N{U+093f}\N{U+0928}\N{U+094d}\N{U+0926}\N{U+0940}",
      native_script => undef,
      native_territory => undef,
      native_variant => undef,
      quarter_format_abbreviated => [
        "\N{U+0924}\N{U+093f}1",
        "\N{U+0924}\N{U+093f}2",
        "\N{U+0924}\N{U+093f}3",
        "\N{U+0924}\N{U+093f}4",
      ],
      quarter_format_narrow => [
        1,
        2,
        3,
        4,
      ],
      quarter_format_wide => [
        "\N{U+092a}\N{U+0939}\N{U+0932}\N{U+0940} \N{U+0924}\N{U+093f}\N{U+092e}\N{U+093e}\N{U+0939}\N{U+0940}",
        "\N{U+0926}\N{U+0942}\N{U+0938}\N{U+0930}\N{U+0940} \N{U+0924}\N{U+093f}\N{U+092e}\N{U+093e}\N{U+0939}\N{U+0940}",
        "\N{U+0924}\N{U+0940}\N{U+0938}\N{U+0930}\N{U+0940} \N{U+0924}\N{U+093f}\N{U+092e}\N{U+093e}\N{U+0939}\N{U+0940}",
        "\N{U+091a}\N{U+094c}\N{U+0925}\N{U+0940} \N{U+0924}\N{U+093f}\N{U+092e}\N{U+093e}\N{U+0939}\N{U+0940}",
      ],
      quarter_stand_alone_abbreviated => [
        "\N{U+0924}\N{U+093f}1",
        "\N{U+0924}\N{U+093f}2",
        "\N{U+0924}\N{U+093f}3",
        "\N{U+0924}\N{U+093f}4",
      ],
      quarter_stand_alone_narrow => [
        1,
        2,
        3,
        4,
      ],
      quarter_stand_alone_wide => [
        "\N{U+092a}\N{U+0939}\N{U+0932}\N{U+0940} \N{U+0924}\N{U+093f}\N{U+092e}\N{U+093e}\N{U+0939}\N{U+0940}",
        "\N{U+0926}\N{U+0942}\N{U+0938}\N{U+0930}\N{U+0940} \N{U+0924}\N{U+093f}\N{U+092e}\N{U+093e}\N{U+0939}\N{U+0940}",
        "\N{U+0924}\N{U+0940}\N{U+0938}\N{U+0930}\N{U+0940} \N{U+0924}\N{U+093f}\N{U+092e}\N{U+093e}\N{U+0939}\N{U+0940}",
        "\N{U+091a}\N{U+094c}\N{U+0925}\N{U+0940} \N{U+0924}\N{U+093f}\N{U+092e}\N{U+093e}\N{U+0939}\N{U+0940}",
      ],
      script => undef,
      territory => undef,
      time_format_full => "h:mm:ss a zzzz",
      time_format_long => "h:mm:ss a z",
      time_format_medium => "h:mm:ss a",
      time_format_short => "h:mm a",
      variant => undef,
      version => 33,
    },
    "ja-JP" => {
      am_pm_abbreviated => [
        "\N{U+5348}\N{U+524d}",
        "\N{U+5348}\N{U+5f8c}",
      ],
      available_formats => {
        Bh => "BK\N{U+6642}",
        Bhm => "BK:mm",
        Bhms => "BK:mm:ss",
        E => "ccc",
        EBhm => "BK:mm (E)",
        EBhms => "BK:mm:ss (E)",
        EEEEd => "d\N{U+65e5}EEEE",
        EHm => "H:mm (E)",
        EHms => "H:mm:ss (E)",
        Ed => "d\N{U+65e5}(E)",
        Ehm => "aK:mm (E)",
        Ehms => "aK:mm:ss (E)",
        Gy => "Gy\N{U+5e74}",
        GyMMM => "Gy\N{U+5e74}M\N{U+6708}",
        GyMMMEEEEd => "Gy\N{U+5e74}M\N{U+6708}d\N{U+65e5}EEEE",
        GyMMMEd => "Gy\N{U+5e74}M\N{U+6708}d\N{U+65e5}(E)",
        GyMMMd => "Gy\N{U+5e74}M\N{U+6708}d\N{U+65e5}",
        H => "H\N{U+6642}",
        Hm => "H:mm",
        Hms => "H:mm:ss",
        Hmsv => "H:mm:ss v",
        Hmv => "H:mm v",
        M => "M\N{U+6708}",
        MEEEEd => "M/dEEEE",
        MEd => "M/d(E)",
        MMM => "M\N{U+6708}",
        MMMEEEEd => "M\N{U+6708}d\N{U+65e5}EEEE",
        MMMEd => "M\N{U+6708}d\N{U+65e5}(E)",
        "MMMMW-count-other" => "M\N{U+6708}\N{U+7b2c}W\N{U+9031}",
        MMMMd => "M\N{U+6708}d\N{U+65e5}",
        MMMd => "M\N{U+6708}d\N{U+65e5}",
        Md => "M/d",
        d => "d\N{U+65e5}",
        h => "aK\N{U+6642}",
        hm => "aK:mm",
        hms => "aK:mm:ss",
        hmsv => "aK:mm:ss v",
        hmv => "aK:mm v",
        ms => "mm:ss",
        y => "y\N{U+5e74}",
        yM => "y/M",
        yMEEEEd => "y/M/dEEEE",
        yMEd => "y/M/d(E)",
        yMM => "y/MM",
        yMMM => "y\N{U+5e74}M\N{U+6708}",
        yMMMEEEEd => "y\N{U+5e74}M\N{U+6708}d\N{U+65e5}EEEE",
        yMMMEd => "y\N{U+5e74}M\N{U+6708}d\N{U+65e5}(E)",
        yMMMM => "y\N{U+5e74}M\N{U+6708}",
        yMMMd => "y\N{U+5e74}M\N{U+6708}d\N{U+65e5}",
        yMd => "y/M/d",
        yQQQ => "y/QQQ",
        yQQQQ => "y\N{U+5e74}QQQQ",
        "yw-count-other" => "Y\N{U+5e74}\N{U+7b2c}w\N{U+9031}",
      },
      code => "ja-JP",
      date_format_full => "y\N{U+5e74}M\N{U+6708}d\N{U+65e5}EEEE",
      date_format_long => "y\N{U+5e74}M\N{U+6708}d\N{U+65e5}",
      date_format_medium => "y/MM/dd",
      date_format_short => "y/MM/dd",
      datetime_format_full => "{1} {0}",
      datetime_format_long => "{1} {0}",
      datetime_format_medium => "{1} {0}",
      datetime_format_short => "{1} {0}",
      day_format_abbreviated => [
        "\N{U+6708}",
        "\N{U+706b}",
        "\N{U+6c34}",
        "\N{U+6728}",
        "\N{U+91d1}",
        "\N{U+571f}",
        "\N{U+65e5}",
      ],
      day_format_narrow => [
        "\N{U+6708}",
        "\N{U+706b}",
        "\N{U+6c34}",
        "\N{U+6728}",
        "\N{U+91d1}",
        "\N{U+571f}",
        "\N{U+65e5}",
      ],
      day_format_wide => [
        "\N{U+6708}\N{U+66dc}\N{U+65e5}",
        "\N{U+706b}\N{U+66dc}\N{U+65e5}",
        "\N{U+6c34}\N{U+66dc}\N{U+65e5}",
        "\N{U+6728}\N{U+66dc}\N{U+65e5}",
        "\N{U+91d1}\N{U+66dc}\N{U+65e5}",
        "\N{U+571f}\N{U+66dc}\N{U+65e5}",
        "\N{U+65e5}\N{U+66dc}\N{U+65e5}",
      ],
      day_stand_alone_abbreviated => [
        "\N{U+6708}",
        "\N{U+706b}",
        "\N{U+6c34}",
        "\N{U+6728}",
        "\N{U+91d1}",
        "\N{U+571f}",
        "\N{U+65e5}",
      ],
      day_stand_alone_narrow => [
        "\N{U+6708}",
        "\N{U+706b}",
        "\N{U+6c34}",
        "\N{U+6728}",
        "\N{U+91d1}",
        "\N{U+571f}",
        "\N{U+65e5}",
      ],
      day_stand_alone_wide => [
        "\N{U+6708}\N{U+66dc}\N{U+65e5}",
        "\N{U+706b}\N{U+66dc}\N{U+65e5}",
        "\N{U+6c34}\N{U+66dc}\N{U+65e5}",
        "\N{U+6728}\N{U+66dc}\N{U+65e5}",
        "\N{U+91d1}\N{U+66dc}\N{U+65e5}",
        "\N{U+571f}\N{U+66dc}\N{U+65e5}",
        "\N{U+65e5}\N{U+66dc}\N{U+65e5}",
      ],
      era_abbreviated => [
        "\N{U+7d00}\N{U+5143}\N{U+524d}",
        "\N{U+897f}\N{U+66a6}",
      ],
      era_narrow => [
        "BC",
        "AD",
      ],
      era_wide => [
        "\N{U+7d00}\N{U+5143}\N{U+524d}",
        "\N{U+897f}\N{U+66a6}",
      ],
      first_day_of_week => 7,
      glibc_date_1_format => "%Y\N{U+5e74} %b %e\N{U+65e5} %A %H:%M:%S %Z",
      glibc_date_format => "%Y\N{U+5e74}%m\N{U+6708}%d\N{U+65e5}",
      glibc_datetime_format => "%Y\N{U+5e74}%m\N{U+6708}%d\N{U+65e5} %H\N{U+6642}%M\N{U+5206}%S\N{U+79d2}",
      glibc_time_12_format => "%p%I\N{U+6642}%M\N{U+5206}%S\N{U+79d2}",
      glibc_time_format => "%H\N{U+6642}%M\N{U+5206}%S\N{U+79d2}",
      language => "Japanese",
      month_format_abbreviated => [
        "1\N{U+6708}",
        "2\N{U+6708}",
        "3\N{U+6708}",
        "4\N{U+6708}",
        "5\N{U+6708}",
        "6\N{U+6708}",
        "7\N{U+6708}",
        "8\N{U+6708}",
        "9\N{U+6708}",
        "10\N{U+6708}",
        "11\N{U+6708}",
        "12\N{U+6708}",
      ],
      month_format_narrow => [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
      ],
      month_format_wide => [
        "1\N{U+6708}",
        "2\N{U+6708}",
        "3\N{U+6708}",
        "4\N{U+6708}",
        "5\N{U+6708}",
        "6\N{U+6708}",
        "7\N{U+6708}",
        "8\N{U+6708}",
        "9\N{U+6708}",
        "10\N{U+6708}",
        "11\N{U+6708}",
        "12\N{U+6708}",
      ],
      month_stand_alone_abbreviated => [
        "1\N{U+6708}",
        "2\N{U+6708}",
        "3\N{U+6708}",
        "4\N{U+6708}",
        "5\N{U+6708}",
        "6\N{U+6708}",
        "7\N{U+6708}",
        "8\N{U+6708}",
        "9\N{U+6708}",
        "10\N{U+6708}",
        "11\N{U+6708}",
        "12\N{U+6708}",
      ],
      month_stand_alone_narrow => [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
      ],
      month_stand_alone_wide => [
        "1\N{U+6708}",
        "2\N{U+6708}",
        "3\N{U+6708}",
        "4\N{U+6708}",
        "5\N{U+6708}",
        "6\N{U+6708}",
        "7\N{U+6708}",
        "8\N{U+6708}",
        "9\N{U+6708}",
        "10\N{U+6708}",
        "11\N{U+6708}",
        "12\N{U+6708}",
      ],
      name => "Japanese Japan",
      native_language => "\N{U+65e5}\N{U+672c}\N{U+8a9e}",
      native_name => "\N{U+65e5}\N{U+672c}\N{U+8a9e} \N{U+65e5}\N{U+672c}",
      native_script => undef,
      native_territory => "\N{U+65e5}\N{U+672c}",
      native_variant => undef,
      quarter_format_abbreviated => [
        "Q1",
        "Q2",
        "Q3",
        "Q4",
      ],
      quarter_format_narrow => [
        1,
        2,
        3,
        4,
      ],
      quarter_format_wide => [
        "\N{U+7b2c}1\N{U+56db}\N{U+534a}\N{U+671f}",
        "\N{U+7b2c}2\N{U+56db}\N{U+534a}\N{U+671f}",
        "\N{U+7b2c}3\N{U+56db}\N{U+534a}\N{U+671f}",
        "\N{U+7b2c}4\N{U+56db}\N{U+534a}\N{U+671f}",
      ],
      quarter_stand_alone_abbreviated => [
        "Q1",
        "Q2",
        "Q3",
        "Q4",
      ],
      quarter_stand_alone_narrow => [
        1,
        2,
        3,
        4,
      ],
      quarter_stand_alone_wide => [
        "\N{U+7b2c}1\N{U+56db}\N{U+534a}\N{U+671f}",
        "\N{U+7b2c}2\N{U+56db}\N{U+534a}\N{U+671f}",
        "\N{U+7b2c}3\N{U+56db}\N{U+534a}\N{U+671f}",
        "\N{U+7b2c}4\N{U+56db}\N{U+534a}\N{U+671f}",
      ],
      script => undef,
      territory => "Japan",
      time_format_full => "H\N{U+6642}mm\N{U+5206}ss\N{U+79d2} zzzz",
      time_format_long => "H:mm:ss z",
      time_format_medium => "H:mm:ss",
      time_format_short => "H:mm",
      variant => undef,
      version => 33,
    },
    "pt-BR" => {
      am_pm_abbreviated => [
        "AM",
        "PM",
      ],
      available_formats => {
        Bh => "h B",
        Bhm => "h:mm B",
        Bhms => "h:mm:ss B",
        E => "ccc",
        EBhm => "E h:mm B",
        EBhms => "E h:mm:ss B",
        EHm => "E, HH:mm",
        EHms => "E, HH:mm:ss",
        Ed => "E, d",
        Ehm => "E, h:mm a",
        Ehms => "E, h:mm:ss a",
        Gy => "y G",
        GyMMM => "MMM 'de' y G",
        GyMMMEd => "E, d 'de' MMM 'de' y G",
        GyMMMd => "d 'de' MMM 'de' y G",
        H => "HH",
        Hm => "HH:mm",
        Hms => "HH:mm:ss",
        Hmsv => "HH:mm:ss v",
        Hmv => "HH:mm v",
        M => "L",
        MEd => "E, dd/MM",
        MMM => "LLL",
        MMMEd => "E, d 'de' MMM",
        MMMMEd => "E, d 'de' MMMM",
        "MMMMW-count-one" => "W'\N{U+00aa}' 'semana' 'de' MMMM",
        "MMMMW-count-other" => "W'\N{U+00aa}' 'semana' 'de' MMMM",
        MMMMd => "d 'de' MMMM",
        MMMd => "d 'de' MMM",
        MMdd => "dd/MM",
        Md => "d/M",
        d => "d",
        h => "h a",
        hm => "h:mm a",
        hms => "h:mm:ss a",
        hmsv => "h:mm:ss a v",
        hmv => "h:mm a v",
        ms => "mm:ss",
        y => "y",
        yM => "MM/y",
        yMEd => "E, dd/MM/y",
        yMM => "MM/y",
        yMMM => "MMM 'de' y",
        yMMMEd => "E, d 'de' MMM 'de' y",
        yMMMM => "MMMM 'de' y",
        yMMMMEd => "E, d 'de' MMMM 'de' y",
        yMMMMd => "d 'de' MMMM 'de' y",
        yMMMd => "d 'de' MMM 'de' y",
        yMd => "dd/MM/y",
        yQQQ => "QQQ 'de' y",
        yQQQQ => "QQQQ 'de' y",
        "yw-count-one" => "w'\N{U+00aa}' 'semana' 'de' Y",
        "yw-count-other" => "w'\N{U+00aa}' 'semana' 'de' Y",
      },
      code => "pt-BR",
      date_format_full => "EEEE, d 'de' MMMM 'de' y",
      date_format_long => "d 'de' MMMM 'de' y",
      date_format_medium => "d 'de' MMM 'de' y",
      date_format_short => "dd/MM/y",
      datetime_format_full => "{1} {0}",
      datetime_format_long => "{1} {0}",
      datetime_format_medium => "{1} {0}",
      datetime_format_short => "{1} {0}",
      day_format_abbreviated => [
        "seg",
        "ter",
        "qua",
        "qui",
        "sex",
        "s\N{U+00e1}b",
        "dom",
      ],
      day_format_narrow => [
        "S",
        "T",
        "Q",
        "Q",
        "S",
        "S",
        "D",
      ],
      day_format_wide => [
        "segunda-feira",
        "ter\N{U+00e7}a-feira",
        "quarta-feira",
        "quinta-feira",
        "sexta-feira",
        "s\N{U+00e1}bado",
        "domingo",
      ],
      day_stand_alone_abbreviated => [
        "seg",
        "ter",
        "qua",
        "qui",
        "sex",
        "s\N{U+00e1}b",
        "dom",
      ],
      day_stand_alone_narrow => [
        "S",
        "T",
        "Q",
        "Q",
        "S",
        "S",
        "D",
      ],
      day_stand_alone_wide => [
        "segunda-feira",
        "ter\N{U+00e7}a-feira",
        "quarta-feira",
        "quinta-feira",
        "sexta-feira",
        "s\N{U+00e1}bado",
        "domingo",
      ],
      era_abbreviated => [
        "a.C.",
        "d.C.",
      ],
      era_narrow => [
        "a.C.",
        "d.C.",
      ],
      era_wide => [
        "antes de Cristo",
        "depois de Cristo",
      ],
      first_day_of_week => 7,
      glibc_date_1_format => "%a %b %e %H:%M:%S %Z %Y",
      glibc_date_format => "%d-%m-%Y",
      glibc_datetime_format => "%a %d %b %Y %T %Z",
      glibc_time_12_format => "%I:%M:%S %p",
      glibc_time_format => "%T",
      language => "Portuguese",
      month_format_abbreviated => [
        "jan",
        "fev",
        "mar",
        "abr",
        "mai",
        "jun",
        "jul",
        "ago",
        "set",
        "out",
        "nov",
        "dez",
      ],
      month_format_narrow => [
        "J",
        "F",
        "M",
        "A",
        "M",
        "J",
        "J",
        "A",
        "S",
        "O",
        "N",
        "D",
      ],
      month_format_wide => [
        "janeiro",
        "fevereiro",
        "mar\N{U+00e7}o",
        "abril",
        "maio",
        "junho",
        "julho",
        "agosto",
        "setembro",
        "outubro",
        "novembro",
        "dezembro",
      ],
      month_stand_alone_abbreviated => [
        "jan",
        "fev",
        "mar",
        "abr",
        "mai",
        "jun",
        "jul",
        "ago",
        "set",
        "out",
        "nov",
        "dez",
      ],
      month_stand_alone_narrow => [
        "J",
        "F",
        "M",
        "A",
        "M",
        "J",
        "J",
        "A",
        "S",
        "O",
        "N",
        "D",
      ],
      month_stand_alone_wide => [
        "janeiro",
        "fevereiro",
        "mar\N{U+00e7}o",
        "abril",
        "maio",
        "junho",
        "julho",
        "agosto",
        "setembro",
        "outubro",
        "novembro",
        "dezembro",
      ],
      name => "Portuguese Brazil",
      native_language => "portugu\N{U+00ea}s",
      native_name => "portugu\N{U+00ea}s Brasil",
      native_script => undef,
      native_territory => "Brasil",
      native_variant => undef,
      quarter_format_abbreviated => [
        "T1",
        "T2",
        "T3",
        "T4",
      ],
      quarter_format_narrow => [
        1,
        2,
        3,
        4,
      ],
      quarter_format_wide => [
        "1\N{U+00ba} trimestre",
        "2\N{U+00ba} trimestre",
        "3\N{U+00ba} trimestre",
        "4\N{U+00ba} trimestre",
      ],
      quarter_stand_alone_abbreviated => [
        "T1",
        "T2",
        "T3",
        "T4",
      ],
      quarter_stand_alone_narrow => [
        1,
        2,
        3,
        4,
      ],
      quarter_stand_alone_wide => [
        "1\N{U+00ba} trimestre",
        "2\N{U+00ba} trimestre",
        "3\N{U+00ba} trimestre",
        "4\N{U+00ba} trimestre",
      ],
      script => undef,
      territory => "Brazil",
      time_format_full => "HH:mm:ss zzzz",
      time_format_long => "HH:mm:ss z",
      time_format_medium => "HH:mm:ss",
      time_format_short => "HH:mm",
      variant => undef,
      version => 33,
    },
    "zh-Hans-CN" => {
      am_pm_abbreviated => [
        "\N{U+4e0a}\N{U+5348}",
        "\N{U+4e0b}\N{U+5348}",
      ],
      available_formats => {
        Bh => "Bh\N{U+65f6}",
        Bhm => "Bh:mm",
        Bhms => "Bh:mm:ss",
        E => "ccc",
        EBhm => "EBh:mm",
        EBhms => "EBh:mm:ss",
        EHm => "EHH:mm",
        EHms => "EHH:mm:ss",
        Ed => "d\N{U+65e5}E",
        Ehm => "Eah:mm",
        Ehms => "Eah:mm:ss",
        Gy => "Gy\N{U+5e74}",
        GyMMM => "Gy\N{U+5e74}M\N{U+6708}",
        GyMMMEd => "Gy\N{U+5e74}M\N{U+6708}d\N{U+65e5}E",
        GyMMMd => "Gy\N{U+5e74}M\N{U+6708}d\N{U+65e5}",
        H => "H\N{U+65f6}",
        Hm => "HH:mm",
        Hms => "HH:mm:ss",
        Hmsv => "v HH:mm:ss",
        Hmv => "v HH:mm",
        M => "M\N{U+6708}",
        MEd => "M/dE",
        MMM => "LLL",
        MMMEd => "M\N{U+6708}d\N{U+65e5}E",
        "MMMMW-count-other" => "MMM\N{U+7b2c}W\N{U+5468}",
        MMMMd => "M\N{U+6708}d\N{U+65e5}",
        MMMd => "M\N{U+6708}d\N{U+65e5}",
        MMdd => "MM/dd",
        Md => "M/d",
        d => "d\N{U+65e5}",
        h => "ah\N{U+65f6}",
        hm => "ah:mm",
        hms => "ah:mm:ss",
        hmsv => "v ah:mm:ss",
        hmv => "v ah:mm",
        ms => "mm:ss",
        y => "y\N{U+5e74}",
        yM => "y\N{U+5e74}M\N{U+6708}",
        yMEd => "y/M/dE",
        yMM => "y\N{U+5e74}M\N{U+6708}",
        yMMM => "y\N{U+5e74}M\N{U+6708}",
        yMMMEd => "y\N{U+5e74}M\N{U+6708}d\N{U+65e5}E",
        yMMMM => "y\N{U+5e74}M\N{U+6708}",
        yMMMd => "y\N{U+5e74}M\N{U+6708}d\N{U+65e5}",
        yMd => "y/M/d",
        yQQQ => "y\N{U+5e74}\N{U+7b2c}Q\N{U+5b63}\N{U+5ea6}",
        yQQQQ => "y\N{U+5e74}\N{U+7b2c}Q\N{U+5b63}\N{U+5ea6}",
        "yw-count-other" => "Y\N{U+5e74}\N{U+7b2c}w\N{U+5468}",
      },
      code => "zh-Hans-CN",
      date_format_full => "y\N{U+5e74}M\N{U+6708}d\N{U+65e5}EEEE",
      date_format_long => "y\N{U+5e74}M\N{U+6708}d\N{U+65e5}",
      date_format_medium => "y\N{U+5e74}M\N{U+6708}d\N{U+65e5}",
      date_format_short => "y/M/d",
      datetime_format_full => "{1} {0}",
      datetime_format_long => "{1} {0}",
      datetime_format_medium => "{1} {0}",
      datetime_format_short => "{1} {0}",
      day_format_abbreviated => [
        "\N{U+5468}\N{U+4e00}",
        "\N{U+5468}\N{U+4e8c}",
        "\N{U+5468}\N{U+4e09}",
        "\N{U+5468}\N{U+56db}",
        "\N{U+5468}\N{U+4e94}",
        "\N{U+5468}\N{U+516d}",
        "\N{U+5468}\N{U+65e5}",
      ],
      day_format_narrow => [
        "\N{U+4e00}",
        "\N{U+4e8c}",
        "\N{U+4e09}",
        "\N{U+56db}",
        "\N{U+4e94}",
        "\N{U+516d}",
        "\N{U+65e5}",
      ],
      day_format_wide => [
        "\N{U+661f}\N{U+671f}\N{U+4e00}",
        "\N{U+661f}\N{U+671f}\N{U+4e8c}",
        "\N{U+661f}\N{U+671f}\N{U+4e09}",
        "\N{U+661f}\N{U+671f}\N{U+56db}",
        "\N{U+661f}\N{U+671f}\N{U+4e94}",
        "\N{U+661f}\N{U+671f}\N{U+516d}",
        "\N{U+661f}\N{U+671f}\N{U+65e5}",
      ],
      day_stand_alone_abbreviated => [
        "\N{U+5468}\N{U+4e00}",
        "\N{U+5468}\N{U+4e8c}",
        "\N{U+5468}\N{U+4e09}",
        "\N{U+5468}\N{U+56db}",
        "\N{U+5468}\N{U+4e94}",
        "\N{U+5468}\N{U+516d}",
        "\N{U+5468}\N{U+65e5}",
      ],
      day_stand_alone_narrow => [
        "\N{U+4e00}",
        "\N{U+4e8c}",
        "\N{U+4e09}",
        "\N{U+56db}",
        "\N{U+4e94}",
        "\N{U+516d}",
        "\N{U+65e5}",
      ],
      day_stand_alone_wide => [
        "\N{U+661f}\N{U+671f}\N{U+4e00}",
        "\N{U+661f}\N{U+671f}\N{U+4e8c}",
        "\N{U+661f}\N{U+671f}\N{U+4e09}",
        "\N{U+661f}\N{U+671f}\N{U+56db}",
        "\N{U+661f}\N{U+671f}\N{U+4e94}",
        "\N{U+661f}\N{U+671f}\N{U+516d}",
        "\N{U+661f}\N{U+671f}\N{U+65e5}",
      ],
      era_abbreviated => [
        "\N{U+516c}\N{U+5143}\N{U+524d}",
        "\N{U+516c}\N{U+5143}",
      ],
      era_narrow => [
        "\N{U+516c}\N{U+5143}\N{U+524d}",
        "\N{U+516c}\N{U+5143}",
      ],
      era_wide => [
        "\N{U+516c}\N{U+5143}\N{U+524d}",
        "\N{U+516c}\N{U+5143}",
      ],
      first_day_of_week => 7,
      glibc_date_1_format => "%a %b %e %H:%M:%S %Z %Y",
      glibc_date_format => "%m/%d/%y",
      glibc_datetime_format => "%a %b %e %H:%M:%S %Y",
      glibc_time_12_format => "%I:%M:%S %p",
      glibc_time_format => "%H:%M:%S",
      language => "Chinese",
      month_format_abbreviated => [
        "1\N{U+6708}",
        "2\N{U+6708}",
        "3\N{U+6708}",
        "4\N{U+6708}",
        "5\N{U+6708}",
        "6\N{U+6708}",
        "7\N{U+6708}",
        "8\N{U+6708}",
        "9\N{U+6708}",
        "10\N{U+6708}",
        "11\N{U+6708}",
        "12\N{U+6708}",
      ],
      month_format_narrow => [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
      ],
      month_format_wide => [
        "\N{U+4e00}\N{U+6708}",
        "\N{U+4e8c}\N{U+6708}",
        "\N{U+4e09}\N{U+6708}",
        "\N{U+56db}\N{U+6708}",
        "\N{U+4e94}\N{U+6708}",
        "\N{U+516d}\N{U+6708}",
        "\N{U+4e03}\N{U+6708}",
        "\N{U+516b}\N{U+6708}",
        "\N{U+4e5d}\N{U+6708}",
        "\N{U+5341}\N{U+6708}",
        "\N{U+5341}\N{U+4e00}\N{U+6708}",
        "\N{U+5341}\N{U+4e8c}\N{U+6708}",
      ],
      month_stand_alone_abbreviated => [
        "1\N{U+6708}",
        "2\N{U+6708}",
        "3\N{U+6708}",
        "4\N{U+6708}",
        "5\N{U+6708}",
        "6\N{U+6708}",
        "7\N{U+6708}",
        "8\N{U+6708}",
        "9\N{U+6708}",
        "10\N{U+6708}",
        "11\N{U+6708}",
        "12\N{U+6708}",
      ],
      month_stand_alone_narrow => [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
      ],
      month_stand_alone_wide => [
        "\N{U+4e00}\N{U+6708}",
        "\N{U+4e8c}\N{U+6708}",
        "\N{U+4e09}\N{U+6708}",
        "\N{U+56db}\N{U+6708}",
        "\N{U+4e94}\N{U+6708}",
        "\N{U+516d}\N{U+6708}",
        "\N{U+4e03}\N{U+6708}",
        "\N{U+516b}\N{U+6708}",
        "\N{U+4e5d}\N{U+6708}",
        "\N{U+5341}\N{U+6708}",
        "\N{U+5341}\N{U+4e00}\N{U+6708}",
        "\N{U+5341}\N{U+4e8c}\N{U+6708}",
      ],
      name => "Chinese China Simplified",
      native_language => "\N{U+4e2d}\N{U+6587}",
      native_name => "\N{U+4e2d}\N{U+6587} \N{U+4e2d}\N{U+56fd} \N{U+7b80}\N{U+4f53}",
      native_script => "\N{U+7b80}\N{U+4f53}",
      native_territory => "\N{U+4e2d}\N{U+56fd}",
      native_variant => undef,
      quarter_format_abbreviated => [
        "1\N{U+5b63}\N{U+5ea6}",
        "2\N{U+5b63}\N{U+5ea6}",
        "3\N{U+5b63}\N{U+5ea6}",
        "4\N{U+5b63}\N{U+5ea6}",
      ],
      quarter_format_narrow => [
        1,
        2,
        3,
        4,
      ],
      quarter_format_wide => [
        "\N{U+7b2c}\N{U+4e00}\N{U+5b63}\N{U+5ea6}",
        "\N{U+7b2c}\N{U+4e8c}\N{U+5b63}\N{U+5ea6}",
        "\N{U+7b2c}\N{U+4e09}\N{U+5b63}\N{U+5ea6}",
        "\N{U+7b2c}\N{U+56db}\N{U+5b63}\N{U+5ea6}",
      ],
      quarter_stand_alone_abbreviated => [
        "1\N{U+5b63}\N{U+5ea6}",
        "2\N{U+5b63}\N{U+5ea6}",
        "3\N{U+5b63}\N{U+5ea6}",
        "4\N{U+5b63}\N{U+5ea6}",
      ],
      quarter_stand_alone_narrow => [
        1,
        2,
        3,
        4,
      ],
      quarter_stand_alone_wide => [
        "\N{U+7b2c}\N{U+4e00}\N{U+5b63}\N{U+5ea6}",
        "\N{U+7b2c}\N{U+4e8c}\N{U+5b63}\N{U+5ea6}",
        "\N{U+7b2c}\N{U+4e09}\N{U+5b63}\N{U+5ea6}",
        "\N{U+7b2c}\N{U+56db}\N{U+5b63}\N{U+5ea6}",
      ],
      script => "Simplified",
      territory => "China",
      time_format_full => "zzzz ah:mm:ss",
      time_format_long => "z ah:mm:ss",
      time_format_medium => "ah:mm:ss",
      time_format_short => "ah:mm",
      variant => undef,
      version => 33,
    },
    "zh-Hant-TW" => {
      am_pm_abbreviated => [
        "\N{U+4e0a}\N{U+5348}",
        "\N{U+4e0b}\N{U+5348}",
      ],
      available_formats => {
        Bh => "Bh\N{U+6642}",
        Bhm => "Bh:mm",
        Bhms => "Bh:mm:ss",
        E => "ccc",
        EBhm => "E Bh:mm",
        EBhms => "E Bh:mm:ss",
        EHm => "E HH:mm",
        EHms => "E HH:mm:ss",
        Ed => "d E",
        Ehm => "E ah:mm",
        Ehms => "E ah:mm:ss",
        Gy => "Gy\N{U+5e74}",
        GyMMM => "Gy\N{U+5e74}M\N{U+6708}",
        GyMMMEd => "Gy\N{U+5e74}M\N{U+6708}d\N{U+65e5} E",
        GyMMMd => "Gy\N{U+5e74}M\N{U+6708}d\N{U+65e5}",
        H => "H\N{U+6642}",
        Hm => "HH:mm",
        Hms => "HH:mm:ss",
        Hmsv => "HH:mm:ss [v]",
        Hmv => "HH:mm [v]",
        M => "M\N{U+6708}",
        MEd => "M/d\N{U+ff08}E\N{U+ff09}",
        MMM => "LLL",
        MMMEd => "M\N{U+6708}d\N{U+65e5} E",
        "MMMMW-count-other" => "MMM\N{U+7684}\N{U+7b2c}W\N{U+9031}",
        MMMMd => "M\N{U+6708}d\N{U+65e5}",
        MMMd => "M\N{U+6708}d\N{U+65e5}",
        MMdd => "MM/dd",
        Md => "M/d",
        d => "d\N{U+65e5}",
        h => "ah\N{U+6642}",
        hm => "ah:mm",
        hms => "ah:mm:ss",
        hmsv => "ah:mm:ss [v]",
        hmv => "ah:mm [v]",
        ms => "mm:ss",
        y => "y\N{U+5e74}",
        yM => "y/M",
        yMEd => "y/M/d\N{U+ff08}E\N{U+ff09}",
        yMM => "y/MM",
        yMMM => "y\N{U+5e74}M\N{U+6708}",
        yMMMEd => "y\N{U+5e74}M\N{U+6708}d\N{U+65e5} E",
        yMMMM => "y\N{U+5e74}M\N{U+6708}",
        yMMMd => "y\N{U+5e74}M\N{U+6708}d\N{U+65e5}",
        yMd => "y/M/d",
        yQQQ => "y\N{U+5e74}QQQ",
        yQQQQ => "y\N{U+5e74}QQQQ",
        "yw-count-other" => "Y\N{U+5e74}\N{U+7684}\N{U+7b2c}w\N{U+9031}",
      },
      code => "zh-Hant-TW",
      date_format_full => "y\N{U+5e74}M\N{U+6708}d\N{U+65e5} EEEE",
      date_format_long => "y\N{U+5e74}M\N{U+6708}d\N{U+65e5}",
      date_format_medium => "y\N{U+5e74}M\N{U+6708}d\N{U+65e5}",
      date_format_short => "y/M/d",
      datetime_format_full => "{1} {0}",
      datetime_format_long => "{1} {0}",
      datetime_format_medium => "{1} {0}",
      datetime_format_short => "{1} {0}",
      day_format_abbreviated => [
        "\N{U+9031}\N{U+4e00}",
        "\N{U+9031}\N{U+4e8c}",
        "\N{U+9031}\N{U+4e09}",
        "\N{U+9031}\N{U+56db}",
        "\N{U+9031}\N{U+4e94}",
        "\N{U+9031}\N{U+516d}",
        "\N{U+9031}\N{U+65e5}",
      ],
      day_format_narrow => [
        "\N{U+4e00}",
        "\N{U+4e8c}",
        "\N{U+4e09}",
        "\N{U+56db}",
        "\N{U+4e94}",
        "\N{U+516d}",
        "\N{U+65e5}",
      ],
      day_format_wide => [
        "\N{U+661f}\N{U+671f}\N{U+4e00}",
        "\N{U+661f}\N{U+671f}\N{U+4e8c}",
        "\N{U+661f}\N{U+671f}\N{U+4e09}",
        "\N{U+661f}\N{U+671f}\N{U+56db}",
        "\N{U+661f}\N{U+671f}\N{U+4e94}",
        "\N{U+661f}\N{U+671f}\N{U+516d}",
        "\N{U+661f}\N{U+671f}\N{U+65e5}",
      ],
      day_stand_alone_abbreviated => [
        "\N{U+9031}\N{U+4e00}",
        "\N{U+9031}\N{U+4e8c}",
        "\N{U+9031}\N{U+4e09}",
        "\N{U+9031}\N{U+56db}",
        "\N{U+9031}\N{U+4e94}",
        "\N{U+9031}\N{U+516d}",
        "\N{U+9031}\N{U+65e5}",
      ],
      day_stand_alone_narrow => [
        "\N{U+4e00}",
        "\N{U+4e8c}",
        "\N{U+4e09}",
        "\N{U+56db}",
        "\N{U+4e94}",
        "\N{U+516d}",
        "\N{U+65e5}",
      ],
      day_stand_alone_wide => [
        "\N{U+661f}\N{U+671f}\N{U+4e00}",
        "\N{U+661f}\N{U+671f}\N{U+4e8c}",
        "\N{U+661f}\N{U+671f}\N{U+4e09}",
        "\N{U+661f}\N{U+671f}\N{U+56db}",
        "\N{U+661f}\N{U+671f}\N{U+4e94}",
        "\N{U+661f}\N{U+671f}\N{U+516d}",
        "\N{U+661f}\N{U+671f}\N{U+65e5}",
      ],
      era_abbreviated => [
        "\N{U+897f}\N{U+5143}\N{U+524d}",
        "\N{U+897f}\N{U+5143}",
      ],
      era_narrow => [
        "\N{U+897f}\N{U+5143}\N{U+524d}",
        "\N{U+897f}\N{U+5143}",
      ],
      era_wide => [
        "\N{U+897f}\N{U+5143}\N{U+524d}",
        "\N{U+897f}\N{U+5143}",
      ],
      first_day_of_week => 7,
      glibc_date_1_format => "%a %b %e %H:%M:%S %Z %Y",
      glibc_date_format => "%m/%d/%y",
      glibc_datetime_format => "%a %b %e %H:%M:%S %Y",
      glibc_time_12_format => "%I:%M:%S %p",
      glibc_time_format => "%H:%M:%S",
      language => "Chinese",
      month_format_abbreviated => [
        "1\N{U+6708}",
        "2\N{U+6708}",
        "3\N{U+6708}",
        "4\N{U+6708}",
        "5\N{U+6708}",
        "6\N{U+6708}",
        "7\N{U+6708}",
        "8\N{U+6708}",
        "9\N{U+6708}",
        "10\N{U+6708}",
        "11\N{U+6708}",
        "12\N{U+6708}",
      ],
      month_format_narrow => [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
      ],
      month_format_wide => [
        "1\N{U+6708}",
        "2\N{U+6708}",
        "3\N{U+6708}",
        "4\N{U+6708}",
        "5\N{U+6708}",
        "6\N{U+6708}",
        "7\N{U+6708}",
        "8\N{U+6708}",
        "9\N{U+6708}",
        "10\N{U+6708}",
        "11\N{U+6708}",
        "12\N{U+6708}",
      ],
      month_stand_alone_abbreviated => [
        "1\N{U+6708}",
        "2\N{U+6708}",
        "3\N{U+6708}",
        "4\N{U+6708}",
        "5\N{U+6708}",
        "6\N{U+6708}",
        "7\N{U+6708}",
        "8\N{U+6708}",
        "9\N{U+6708}",
        "10\N{U+6708}",
        "11\N{U+6708}",
        "12\N{U+6708}",
      ],
      month_stand_alone_narrow => [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
      ],
      month_stand_alone_wide => [
        "1\N{U+6708}",
        "2\N{U+6708}",
        "3\N{U+6708}",
        "4\N{U+6708}",
        "5\N{U+6708}",
        "6\N{U+6708}",
        "7\N{U+6708}",
        "8\N{U+6708}",
        "9\N{U+6708}",
        "10\N{U+6708}",
        "11\N{U+6708}",
        "12\N{U+6708}",
      ],
      name => "Chinese Taiwan Traditional",
      native_language => "\N{U+4e2d}\N{U+6587}",
      native_name => "\N{U+4e2d}\N{U+6587} \N{U+53f0}\N{U+7063} \N{U+7e41}\N{U+9ad4}",
      native_script => "\N{U+7e41}\N{U+9ad4}",
      native_territory => "\N{U+53f0}\N{U+7063}",
      native_variant => undef,
      quarter_format_abbreviated => [
        "\N{U+7b2c}1\N{U+5b63}",
        "\N{U+7b2c}2\N{U+5b63}",
        "\N{U+7b2c}3\N{U+5b63}",
        "\N{U+7b2c}4\N{U+5b63}",
      ],
      quarter_format_narrow => [
        1,
        2,
        3,
        4,
      ],
      quarter_format_wide => [
        "\N{U+7b2c}1\N{U+5b63}",
        "\N{U+7b2c}2\N{U+5b63}",
        "\N{U+7b2c}3\N{U+5b63}",
        "\N{U+7b2c}4\N{U+5b63}",
      ],
      quarter_stand_alone_abbreviated => [
        "\N{U+7b2c}1\N{U+5b63}",
        "\N{U+7b2c}2\N{U+5b63}",
        "\N{U+7b2c}3\N{U+5b63}",
        "\N{U+7b2c}4\N{U+5b63}",
      ],
      quarter_stand_alone_narrow => [
        1,
        2,
        3,
        4,
      ],
      quarter_stand_alone_wide => [
        "\N{U+7b2c}1\N{U+5b63}",
        "\N{U+7b2c}2\N{U+5b63}",
        "\N{U+7b2c}3\N{U+5b63}",
        "\N{U+7b2c}4\N{U+5b63}",
      ],
      script => "Traditional",
      territory => "Taiwan",
      time_format_full => "ah:mm:ss [zzzz]",
      time_format_long => "ah:mm:ss [z]",
      time_format_medium => "ah:mm:ss",
      time_format_short => "ah:mm",
      variant => undef,
      version => 33,
    },
  );
  ### :end LocaleData:
  #>>>
  
  sub locale_data {
      my $code = shift;
      return $LocaleData{$code} if $LocaleData{$code};
  
      my $data = _data_for($code);
  
      return $LocaleData{$code} = $data;
  }
  
  sub _data_for {
      my $code = shift;
  
      my $data = do( dist_file( 'DateTime-Locale', $code . '.pl' ) );
      die $@ if $@;
  
      return $data;
  }
  
  sub add_locale {
      my $code = shift;
      my $data = shift;
  
      die "You cannot add an existing locale - $code\n"
          if exists $Codes{$code};
      die
          qq{One of either the 'en_language' or 'language' keys is required to add a new locale\n}
          if !( exists $data->{en_language} || exists $data->{language} );
  
      my $lang
          = ( exists $data->{en_language} )
          ? $data->{en_language}
          : $data->{language};
      $Names{$lang}                            = $code;
      $Codes{$code}                            = 1;
      $NativeNames{ $data->{native_language} } = $code
          if exists $data->{native_language};
      $LocaleData{$code} = $data;
  }
  
  # ABSTRACT: Locale data generated from CLDR
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  DateTime::Locale::Data - Locale data generated from CLDR
  
  =head1 VERSION
  
  version 1.22
  
  =head1 DESCRIPTION
  
  There are no user-facing parts in this module.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/DateTime-Locale/issues>.
  
  There is a mailing list available for users of this distribution,
  L<mailto:datetime@perl.org>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for DateTime-Locale can be found at L<https://github.com/houseabsolute/DateTime-Locale>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2003 - 2018 by Dave Rolsky.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
DATETIME_LOCALE_DATA

$fatpacked{"DateTime/Locale/FromData.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATETIME_LOCALE_FROMDATA';
  package DateTime::Locale::FromData;
  
  use strict;
  use warnings;
  use namespace::autoclean;
  
  use DateTime::Locale::Util qw( parse_locale_code );
  use Params::ValidationCompiler 0.13 qw( validation_for );
  use Specio::Declare;
  
  our $VERSION = '1.22';
  
  my @FormatLengths;
  
  BEGIN {
      my @methods = qw(
          code
          name
          language
          script
          territory
          variant
          native_name
          native_language
          native_script
          native_territory
          native_variant
          am_pm_abbreviated
          date_format_full
          date_format_long
          date_format_medium
          date_format_short
          time_format_full
          time_format_long
          time_format_medium
          time_format_short
          day_format_abbreviated
          day_format_narrow
          day_format_wide
          day_stand_alone_abbreviated
          day_stand_alone_narrow
          day_stand_alone_wide
          month_format_abbreviated
          month_format_narrow
          month_format_wide
          month_stand_alone_abbreviated
          month_stand_alone_narrow
          month_stand_alone_wide
          quarter_format_abbreviated
          quarter_format_narrow
          quarter_format_wide
          quarter_stand_alone_abbreviated
          quarter_stand_alone_narrow
          quarter_stand_alone_wide
          era_abbreviated
          era_narrow
          era_wide
          default_date_format_length
          default_time_format_length
          first_day_of_week
          version
          glibc_datetime_format
          glibc_date_format
          glibc_date_1_format
          glibc_time_format
          glibc_time_12_format
      );
  
      for my $meth (@methods) {
          my $sub = sub { $_[0]->{$meth} };
          ## no critic (TestingAndDebugging::ProhibitNoStrict)
          no strict 'refs';
          *{$meth} = $sub;
      }
  
      @FormatLengths = qw( short medium long full );
  
      for my $length (@FormatLengths) {
          my $meth = 'datetime_format_' . $length;
          my $key  = 'computed_' . $meth;
  
          my $sub = sub {
              my $self = shift;
  
              return $self->{$key} if exists $self->{$key};
  
              return $self->{$key} = $self->_make_datetime_format($length);
          };
  
          ## no critic (TestingAndDebugging::ProhibitNoStrict)
          no strict 'refs';
          *{$meth} = $sub;
      }
  }
  
  sub new {
      my $class = shift;
      my $data  = shift;
  
      return bless {
          %{$data},
          default_date_format_length => 'medium',
          default_time_format_length => 'medium',
          locale_data                => $data
      }, $class;
  }
  
  sub date_format_default {
      return $_[0]->date_format_medium;
  }
  
  sub time_format_default {
      return $_[0]->time_format_medium;
  }
  
  sub datetime_format {
      return $_[0]->{datetime_format_medium};
  }
  
  sub datetime_format_default {
      return $_[0]->datetime_format_medium;
  }
  
  sub _make_datetime_format {
      my $self   = shift;
      my $length = shift;
  
      my $dt_key    = 'datetime_format_' . $length;
      my $date_meth = 'date_format_' . $length;
      my $time_meth = 'time_format_' . $length;
  
      my $dt_format = $self->{$dt_key};
      $dt_format =~ s/\{0\}/$self->$time_meth/eg;
      $dt_format =~ s/\{1\}/$self->$date_meth/eg;
  
      return $dt_format;
  }
  
  my $length = enum( values => [qw( full long medium short )] );
  my $validator = validation_for(
      name             => '_check_length_parameter',
      name_is_optional => 1,
      params           => [ { type => $length } ],
  );
  
  sub set_default_date_format_length {
      my $self = shift;
      my ($l) = $validator->(@_);
  
      $self->{default_date_format_length} = lc $l;
  }
  
  sub set_default_time_format_length {
      my $self = shift;
      my ($l) = $validator->(@_);
  
      $self->{default_time_format_length} = lc $l;
  }
  
  sub date_formats {
      my %formats;
      for my $length (@FormatLengths) {
          my $meth = 'date_format_' . $length;
          $formats{$length} = $_[0]->$meth;
      }
      return \%formats;
  }
  
  sub time_formats {
      my %formats;
      for my $length (@FormatLengths) {
          my $meth = 'time_format_' . $length;
          $formats{$length} = $_[0]->$meth;
      }
      return \%formats;
  }
  
  sub available_formats {
      my $self = shift;
  
      $self->{computed_available_formats}
          ||= [ sort keys %{ $self->_available_formats } ];
  
      return @{ $self->{computed_available_formats} };
  }
  
  sub format_for {
      my $self = shift;
      my $for  = shift;
  
      return $self->_available_formats->{$for};
  }
  
  sub _available_formats { $_[0]->{available_formats} }
  
  sub prefers_24_hour_time {
      my $self = shift;
  
      return $self->{prefers_24_hour_time}
          if exists $self->{prefers_24_hour_time};
  
      $self->{prefers_24_hour_time} = $self->time_format_short =~ /h|K/ ? 0 : 1;
  }
  
  sub language_code {
      my $self = shift;
      return ( $self->{parsed_code} ||= { parse_locale_code( $self->code ) } )
          ->{language};
  }
  
  sub script_code {
      my $self = shift;
      return ( $self->{parsed_code} ||= { parse_locale_code( $self->code ) } )
          ->{script};
  }
  
  sub territory_code {
      my $self = shift;
      return ( $self->{parsed_code} ||= { parse_locale_code( $self->code ) } )
          ->{territory};
  }
  
  sub variant_code {
      my $self = shift;
      return ( $self->{parsed_code} ||= { parse_locale_code( $self->code ) } )
          ->{variant};
  }
  
  sub id {
      $_[0]->code;
  }
  
  sub language_id {
      $_[0]->language_code;
  }
  
  sub script_id {
      $_[0]->script_code;
  }
  
  sub territory_id {
      $_[0]->territory_code;
  }
  
  sub variant_id {
      $_[0]->variant_code;
  }
  
  sub locale_data {
      return %{ $_[0]->{locale_data} };
  }
  
  sub STORABLE_freeze {
      my $self    = shift;
      my $cloning = shift;
  
      return if $cloning;
  
      return $self->code;
  }
  
  sub STORABLE_thaw {
      my $self = shift;
      shift;
      my $serialized = shift;
  
      require DateTime::Locale;
      my $obj = DateTime::Locale->load($serialized);
  
      %{$self} = %{$obj};
  
      return $self;
  }
  
  1;
  
  # ABSTRACT: Class for locale objects instantiated from pre-defined data
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  DateTime::Locale::FromData - Class for locale objects instantiated from pre-defined data
  
  =head1 VERSION
  
  version 1.22
  
  =head1 SYNOPSIS
  
    my $locale = DateTime::Locale::FromData->new(%lots_of_data)
  
  =head1 DESCRIPTION
  
  This class is used to represent locales instantiated from the data in the
  DateTime::Locale::Data module.
  
  =head1 METHODS
  
  This class provides the following methods:
  
  =head2 $locale->code
  
  The complete locale id, something like "en-US".
  
  =head2 $locale->language_code
  
  The language portion of the code, like "en".
  
  =head2 $locale->script_code
  
  The script portion of the code, like "Hant".
  
  =head2 $locale->territory_code
  
  The territory portion of the code, like "US".
  
  =head2 $locale->variant_code
  
  The variant portion of the code, like "POSIX".
  
  =head2 $locale->name
  
  The locale's complete name, which always includes at least a language
  component, plus optional territory and variant components. Something like
  "English United States". The value returned will always be in English.
  
  =head2 $locale->language
  
  =head2 $locale->script
  
  =head2 $locale->territory
  
  =head2 $locale->variant
  
  The relevant component from the locale's complete name, like "English"
  or "United States".
  
  =head2 $locale->native_name
  
  The locale's complete name in localized form as a UTF-8 string.
  
  =head2 $locale->native_language
  
  =head2 $locale->native_script
  
  =head2 $locale->native_territory
  
  =head2 $locale->native_variant
  
  The relevant component from the locale's complete native name as a UTF-8
  string.
  
  =head2 $locale->month_format_wide
  
  =head2 $locale->month_format_abbreviated
  
  =head2 $locale->month_format_narrow
  
  =head2 $locale->month_stand_alone_wide
  
  =head2 $locale->month_stand_alone_abbreviated
  
  =head2 $locale->month_stand_alone_narrow
  
  =head2 $locale->day_format_wide
  
  =head2 $locale->day_format_abbreviated
  
  =head2 $locale->day_format_narrow
  
  =head2 $locale->day_stand_alone_wide
  
  =head2 $locale->day_stand_alone_abbreviated
  
  =head2 $locale->day_stand_alone_narrow
  
  =head2 $locale->quarter_format_wide
  
  =head2 $locale->quarter_format_abbreviated
  
  =head2 $locale->quarter_format_narrow
  
  =head2 $locale->quarter_stand_alone_wide
  
  =head2 $locale->quarter_stand_alone_abbreviated
  
  =head2 $locale->quarter_stand_alone_narrow
  
  =head2 $locale->am_pm_abbreviated
  
  =head2 $locale->era_wide
  
  =head2 $locale->era_abbreviated
  
  =head2 $locale->era_narrow
  
  These methods all return an array reference containing the specified data.
  
  The methods with "format" in the name should return strings that can be used a
  part of a string, like "the month of July". The stand alone values are for use
  in things like calendars as opposed to a sentence.
  
  The narrow forms may not be unique (for example, in the day column heading for
  a calendar it's okay to have "T" for both Tuesday and Thursday).
  
  The wide name should always be the full name of thing in question. The narrow
  name should be just one or two characters.
  
  =head2 $locale->date_format_full
  
  =head2 $locale->date_format_long
  
  =head2 $locale->date_format_medium
  
  =head2 $locale->date_format_short
  
  =head2 $locale->time_format_full
  
  =head2 $locale->time_format_long
  
  =head2 $locale->time_format_medium
  
  =head2 $locale->time_format_short
  
  =head2 $locale->datetime_format_full
  
  =head2 $locale->datetime_format_long
  
  =head2 $locale->datetime_format_medium
  
  =head2 $locale->datetime_format_short
  
  These methods return strings appropriate for the C<< DateTime->format_cldr >>
  method.
  
  =head2 $locale->format_for($name)
  
  These are accessed by passing a name to C<< $locale->format_for(...)  >>,
  where the name is a CLDR-style format specifier.
  
  The return value is a string suitable for passing to C<< $dt->format_cldr >>,
  so you can do something like this:
  
    print $dt->format_cldr( $dt->locale->format_for('MMMdd') )
  
  which for the "en" locale would print out something like "08 Jul".
  
  Note that the localization may also include additional text specific to the
  locale. For example, the "MMMMd" format for the "zh" locale includes the
  Chinese characters for "day" (日) and month (月), so you get something like
  "S<8月23日>".
  
  =head2 $locale->available_formats
  
  This should return a list of all the format names that could be passed
  to C<< $locale->format_for >>.
  
  See the documentation for individual locales for details and examples of these
  formats. The format names that are available vary by locale.
  
  =head2 $locale->glibc_datetime_format
  
  =head2 $locale->glibc_date_format
  
  =head2 $locale->glibc_date_1_format
  
  =head2 $locale->glibc_time_format
  
  =head2 $locale->glibc_time_12_format
  
  These methods return strings appropriate for the C<< DateTime->strftime >>
  method. However, you are strongly encouraged to use the other format methods,
  which use the CLDR format data. They are primarily included for the benefit
  for L<DateTime::Format::Strptime>.
  
  =head2 $locale->version
  
  The CLDR version from which this locale was generated.
  
  =head2 $locale->prefers_24_hour_time
  
  Returns a boolean indicating whether or not the locale prefers 24-hour time.
  
  =head2 $locale->first_day_of_week
  
  Returns a number from 1 to 7 indicating the I<local> first day of the
  week, with Monday being 1 and Sunday being 7.
  
  =head2 $locale->locale_data
  
  Returns the original data used to create this locale as a hash. This is here
  to facilitate creating custom locale that via
  C<DateTime::Locale->register_data_locale>.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/DateTime-Locale/issues>.
  
  There is a mailing list available for users of this distribution,
  L<mailto:datetime@perl.org>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for DateTime-Locale can be found at L<https://github.com/houseabsolute/DateTime-Locale>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2003 - 2018 by Dave Rolsky.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
DATETIME_LOCALE_FROMDATA

$fatpacked{"DateTime/Locale/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATETIME_LOCALE_UTIL';
  package DateTime::Locale::Util;
  
  use strict;
  use warnings;
  use namespace::autoclean 0.19 -except => ['import'];
  
  use Exporter qw( import );
  
  our $VERSION = '1.22';
  
  our @EXPORT_OK = 'parse_locale_code';
  
  sub parse_locale_code {
      my @pieces = split /-/, $_[0];
  
      return unless @pieces;
  
      my %codes = ( language => lc shift @pieces );
      if ( @pieces == 1 ) {
          if ( length $pieces[0] == 2 || $pieces[0] =~ /^\d\d\d$/ ) {
              $codes{territory} = uc shift @pieces;
          }
          else {
              $codes{script} = _tc( shift @pieces );
          }
      }
      elsif ( @pieces == 3 ) {
          $codes{script}    = _tc( shift @pieces );
          $codes{territory} = uc shift @pieces;
          $codes{variant}   = uc shift @pieces;
      }
      elsif ( @pieces == 2 ) {
  
          # I don't think it's possible to have a script + variant without also
          # having a territory.
          if ( length $pieces[1] == 2 || $pieces[1] =~ /^\d\d\d$/ ) {
              $codes{script}    = _tc( shift @pieces );
              $codes{territory} = uc shift @pieces;
          }
          else {
              $codes{territory} = uc shift @pieces;
              $codes{variant}   = uc shift @pieces;
          }
      }
  
      return %codes;
  }
  
  sub _tc {
      return ucfirst lc $_[0];
  }
  
  1;
  
  # ABSTRACT: Utility code for DateTime::Locale
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  DateTime::Locale::Util - Utility code for DateTime::Locale
  
  =head1 VERSION
  
  version 1.22
  
  =head1 DESCRIPTION
  
  There are no user-facing parts in this module.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/DateTime-Locale/issues>.
  
  There is a mailing list available for users of this distribution,
  L<mailto:datetime@perl.org>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for DateTime-Locale can be found at L<https://github.com/houseabsolute/DateTime-Locale>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2003 - 2018 by Dave Rolsky.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
DATETIME_LOCALE_UTIL

$fatpacked{"Devel/StackTrace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_STACKTRACE';
  package Devel::StackTrace;
  
  use 5.006;
  
  use strict;
  use warnings;
  
  our $VERSION = '2.03';
  
  use Devel::StackTrace::Frame;
  use File::Spec;
  use Scalar::Util qw( blessed );
  
  use overload
      '""'     => \&as_string,
      fallback => 1;
  
  sub new {
      my $class = shift;
      my %p     = @_;
  
      $p{unsafe_ref_capture} = !delete $p{no_refs}
          if exists $p{no_refs};
  
      my $self = bless {
          index  => undef,
          frames => [],
          raw    => [],
          %p,
      }, $class;
  
      $self->_record_caller_data;
  
      return $self;
  }
  
  sub _record_caller_data {
      my $self = shift;
  
      my $filter = $self->{filter_frames_early} && $self->_make_frame_filter;
  
      # We exclude this method by starting at least one frame back.
      my $x = 1 + ( $self->{skip_frames} || 0 );
  
      while (
          my @c
          = $self->{no_args}
          ? caller( $x++ )
          : do {
              ## no critic (Modules::ProhibitMultiplePackages, Variables::ProhibitPackageVars)
              package    # the newline keeps dzil from adding a version here
                  DB;
              @DB::args = ();
              caller( $x++ );
          }
          ) {
  
          my @args;
  
          ## no critic (Variables::ProhibitPackageVars)
          @args = $self->{no_args} ? () : @DB::args;
          ## use critic
  
          my $raw = {
              caller => \@c,
              args   => \@args,
          };
  
          next if $filter && !$filter->($raw);
  
          unless ( $self->{unsafe_ref_capture} ) {
              $raw->{args} = [ map { ref $_ ? $self->_ref_to_string($_) : $_ }
                      @{ $raw->{args} } ];
          }
  
          push @{ $self->{raw} }, $raw;
      }
  }
  
  sub _ref_to_string {
      my $self = shift;
      my $ref  = shift;
  
      return overload::AddrRef($ref)
          if blessed $ref && $ref->isa('Exception::Class::Base');
  
      return overload::AddrRef($ref) unless $self->{respect_overload};
  
      ## no critic (Variables::RequireInitializationForLocalVars)
      local $@;
      local $SIG{__DIE__};
      ## use critic
  
      my $str = eval { $ref . q{} };
  
      return $@ ? overload::AddrRef($ref) : $str;
  }
  
  sub _make_frames {
      my $self = shift;
  
      my $filter = !$self->{filter_frames_early} && $self->_make_frame_filter;
  
      my $raw = delete $self->{raw};
      for my $r ( @{$raw} ) {
          next if $filter && !$filter->($r);
  
          $self->_add_frame( $r->{caller}, $r->{args} );
      }
  }
  
  my $default_filter = sub {1};
  
  sub _make_frame_filter {
      my $self = shift;
  
      my ( @i_pack_re, %i_class );
      if ( $self->{ignore_package} ) {
          ## no critic (Variables::RequireInitializationForLocalVars)
          local $@;
          local $SIG{__DIE__};
          ## use critic
  
          $self->{ignore_package} = [ $self->{ignore_package} ]
              unless eval { @{ $self->{ignore_package} } };
  
          @i_pack_re
              = map { ref $_ ? $_ : qr/^\Q$_\E$/ } @{ $self->{ignore_package} };
      }
  
      my $p = __PACKAGE__;
      push @i_pack_re, qr/^\Q$p\E$/;
  
      if ( $self->{ignore_class} ) {
          $self->{ignore_class} = [ $self->{ignore_class} ]
              unless ref $self->{ignore_class};
          %i_class = map { $_ => 1 } @{ $self->{ignore_class} };
      }
  
      my $user_filter = $self->{frame_filter};
  
      return sub {
          return 0 if grep { $_[0]{caller}[0] =~ /$_/ } @i_pack_re;
          return 0 if grep { $_[0]{caller}[0]->isa($_) } keys %i_class;
  
          if ($user_filter) {
              return $user_filter->( $_[0] );
          }
  
          return 1;
      };
  }
  
  sub _add_frame {
      my $self = shift;
      my $c    = shift;
      my $p    = shift;
  
      # eval and is_require are only returned when applicable under 5.00503.
      push @$c, ( undef, undef ) if scalar @$c == 6;
  
      push @{ $self->{frames} },
          Devel::StackTrace::Frame->new(
          $c,
          $p,
          $self->{respect_overload},
          $self->{max_arg_length},
          $self->{message},
          $self->{indent}
          );
  }
  
  sub next_frame {
      my $self = shift;
  
      # reset to top if necessary.
      $self->{index} = -1 unless defined $self->{index};
  
      my @f = $self->frames;
      if ( defined $f[ $self->{index} + 1 ] ) {
          return $f[ ++$self->{index} ];
      }
      else {
          $self->{index} = undef;
          ## no critic (Subroutines::ProhibitExplicitReturnUndef)
          return undef;
      }
  }
  
  sub prev_frame {
      my $self = shift;
  
      my @f = $self->frames;
  
      # reset to top if necessary.
      $self->{index} = scalar @f unless defined $self->{index};
  
      if ( defined $f[ $self->{index} - 1 ] && $self->{index} >= 1 ) {
          return $f[ --$self->{index} ];
      }
      else {
          ## no critic (Subroutines::ProhibitExplicitReturnUndef)
          $self->{index} = undef;
          return undef;
      }
  }
  
  sub reset_pointer {
      my $self = shift;
  
      $self->{index} = undef;
  
      return;
  }
  
  sub frames {
      my $self = shift;
  
      if (@_) {
          die
              "Devel::StackTrace->frames can only take Devel::StackTrace::Frame args\n"
              if grep { !$_->isa('Devel::StackTrace::Frame') } @_;
  
          $self->{frames} = \@_;
          delete $self->{raw};
      }
      else {
          $self->_make_frames if $self->{raw};
      }
  
      return @{ $self->{frames} };
  }
  
  sub frame {
      my $self = shift;
      my $i    = shift;
  
      return unless defined $i;
  
      return ( $self->frames )[$i];
  }
  
  sub frame_count {
      my $self = shift;
  
      return scalar( $self->frames );
  }
  
  sub message { $_[0]->{message} }
  
  sub as_string {
      my $self = shift;
      my $p    = shift;
  
      my @frames = $self->frames;
      if (@frames) {
          my $st    = q{};
          my $first = 1;
          for my $f (@frames) {
              $st .= $f->as_string( $first, $p ) . "\n";
              $first = 0;
          }
  
          return $st;
      }
  
      my $msg = $self->message;
      return $msg if defined $msg;
  
      return 'Trace begun';
  }
  
  {
      ## no critic (Modules::ProhibitMultiplePackages, ClassHierarchies::ProhibitExplicitISA)
      package    # hide from PAUSE
          Devel::StackTraceFrame;
  
      our @ISA = 'Devel::StackTrace::Frame';
  }
  
  1;
  
  # ABSTRACT: An object representing a stack trace
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Devel::StackTrace - An object representing a stack trace
  
  =head1 VERSION
  
  version 2.03
  
  =head1 SYNOPSIS
  
    use Devel::StackTrace;
  
    my $trace = Devel::StackTrace->new;
  
    print $trace->as_string; # like carp
  
    # from top (most recent) of stack to bottom.
    while ( my $frame = $trace->next_frame ) {
        print "Has args\n" if $frame->hasargs;
    }
  
    # from bottom (least recent) of stack to top.
    while ( my $frame = $trace->prev_frame ) {
        print "Sub: ", $frame->subroutine, "\n";
    }
  
  =head1 DESCRIPTION
  
  The C<Devel::StackTrace> module contains two classes, C<Devel::StackTrace> and
  L<Devel::StackTrace::Frame>. These objects encapsulate the information that
  can retrieved via Perl's C<caller> function, as well as providing a simple
  interface to this data.
  
  The C<Devel::StackTrace> object contains a set of C<Devel::StackTrace::Frame>
  objects, one for each level of the stack. The frames contain all the data
  available from C<caller>.
  
  This code was created to support my L<Exception::Class::Base> class (part of
  L<Exception::Class>) but may be useful in other contexts.
  
  =head1 'TOP' AND 'BOTTOM' OF THE STACK
  
  When describing the methods of the trace object, I use the words 'top' and
  'bottom'. In this context, the 'top' frame on the stack is the most recent
  frame and the 'bottom' is the least recent.
  
  Here's an example:
  
    foo();  # bottom frame is here
  
    sub foo {
       bar();
    }
  
    sub bar {
       Devel::StackTrace->new;  # top frame is here.
    }
  
  =head1 METHODS
  
  This class provide the following methods:
  
  =head2 Devel::StackTrace->new(%named_params)
  
  Returns a new Devel::StackTrace object.
  
  Takes the following parameters:
  
  =over 4
  
  =item * frame_filter => $sub
  
  By default, Devel::StackTrace will include all stack frames before the call to
  its constructor.
  
  However, you may want to filter out some frames with more granularity than
  'ignore_package' or 'ignore_class' allow.
  
  You can provide a subroutine which is called with the raw frame data for each
  frame. This is a hash reference with two keys, "caller", and "args", both of
  which are array references. The "caller" key is the raw data as returned by
  Perl's C<caller> function, and the "args" key are the subroutine arguments
  found in C<@DB::args>.
  
  The filter should return true if the frame should be included, or false if it
  should be skipped.
  
  =item * filter_frames_early => $boolean
  
  If this parameter is true, C<frame_filter> will be called as soon as the
  stacktrace is created, and before refs are stringified (if
  C<unsafe_ref_capture> is not set), rather than being filtered lazily when
  L<Devel::StackTrace::Frame> objects are first needed.
  
  This is useful if you want to filter based on the frame's arguments and want
  to be able to examine object properties, for example.
  
  =item * ignore_package => $package_name OR \@package_names
  
  Any frames where the package is one of these packages will not be on the
  stack.
  
  =item * ignore_class => $package_name OR \@package_names
  
  Any frames where the package is a subclass of one of these packages (or is the
  same package) will not be on the stack.
  
  Devel::StackTrace internally adds itself to the 'ignore_package' parameter,
  meaning that the Devel::StackTrace package is B<ALWAYS> ignored. However, if
  you create a subclass of Devel::StackTrace it will not be ignored.
  
  =item * skip_frames => $integer
  
  This will cause this number of stack frames to be excluded from top of the
  stack trace. This prevents the frames from being captured at all, and applies
  before the C<frame_filter>, C<ignore_package>, or C<ignore_class> options,
  even with C<filter_frames_early>.
  
  =item * unsafe_ref_capture => $boolean
  
  If this parameter is true, then Devel::StackTrace will store references
  internally when generating stacktrace frames.
  
  B<This option is very dangerous, and should never be used with exception
  objects>. Using this option will keep any objects or references alive past
  their normal lifetime, until the stack trace object goes out of scope. It can
  keep objects alive even after their C<DESTROY> sub is called, resulting it it
  being called multiple times on the same object.
  
  If not set, Devel::StackTrace replaces any references with their stringified
  representation.
  
  =item * no_args => $boolean
  
  If this parameter is true, then Devel::StackTrace will not store caller
  arguments in stack trace frames at all.
  
  =item * respect_overload => $boolean
  
  By default, Devel::StackTrace will call C<overload::AddrRef> to get the
  underlying string representation of an object, instead of respecting the
  object's stringification overloading. If you would prefer to see the
  overloaded representation of objects in stack traces, then set this parameter
  to true.
  
  =item * max_arg_length => $integer
  
  By default, Devel::StackTrace will display the entire argument for each
  subroutine call. Setting this parameter causes truncates each subroutine
  argument's string representation if it is longer than this number of
  characters.
  
  =item * message => $string
  
  By default, Devel::StackTrace will use 'Trace begun' as the message for the
  first stack frame when you call C<as_string>. You can supply an alternative
  message using this option.
  
  =item * indent => $boolean
  
  If this parameter is true, each stack frame after the first will start with a
  tab character, just like C<Carp::confess>.
  
  =back
  
  =head2 $trace->next_frame
  
  Returns the next L<Devel::StackTrace::Frame> object on the stack, going
  down. If this method hasn't been called before it returns the first frame. It
  returns C<undef> when it reaches the bottom of the stack and then resets its
  pointer so the next call to C<< $trace->next_frame >> or C<<
  $trace->prev_frame >> will work properly.
  
  =head2 $trace->prev_frame
  
  Returns the next L<Devel::StackTrace::Frame> object on the stack, going up. If
  this method hasn't been called before it returns the last frame. It returns
  undef when it reaches the top of the stack and then resets its pointer so the
  next call to C<< $trace->next_frame >> or C<< $trace->prev_frame >> will work
  properly.
  
  =head2 $trace->reset_pointer
  
  Resets the pointer so that the next call to C<< $trace->next_frame >> or C<<
  $trace->prev_frame >> will start at the top or bottom of the stack, as
  appropriate.
  
  =head2 $trace->frames
  
  When this method is called with no arguments, it returns a list of
  L<Devel::StackTrace::Frame> objects. They are returned in order from top (most
  recent) to bottom.
  
  This method can also be used to set the object's frames if you pass it a list
  of L<Devel::StackTrace::Frame> objects.
  
  This is useful if you want to filter the list of frames in ways that are more
  complex than can be handled by the C<< $trace->filter_frames >> method:
  
    $stacktrace->frames( my_filter( $stacktrace->frames ) );
  
  =head2 $trace->frame($index)
  
  Given an index, this method returns the relevant frame, or undef if there is
  no frame at that index. The index is exactly like a Perl array. The first
  frame is 0 and negative indexes are allowed.
  
  =head2 $trace->frame_count
  
  Returns the number of frames in the trace object.
  
  =head2 $trace->as_string(\%p)
  
  Calls C<< $frame->as_string >> on each frame from top to bottom, producing
  output quite similar to the Carp module's cluck/confess methods.
  
  The optional C<\%p> parameter only has one option. The C<max_arg_length>
  parameter truncates each subroutine argument's string representation if it is
  longer than this number of characters.
  
  If all the frames in a trace are skipped then this just returns the C<message>
  passed to the constructor or the string C<"Trace begun">.
  
  =head2 $trace->message
  
  Returns the message passed to the constructor. If this wasn't passed then this
  method returns C<undef>.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Devel-StackTrace/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Devel-StackTrace can be found at L<https://github.com/houseabsolute/Devel-StackTrace>.
  
  =head1 DONATIONS
  
  If you'd like to thank me for the work I've done on this module, please
  consider making a "donation" to me via PayPal. I spend a lot of free time
  creating free software, and would appreciate any support you'd care to offer.
  
  Please note that B<I am not suggesting that you must do this> in order for me
  to continue working on this particular software. I will continue to do so,
  inasmuch as I have in the past, for as long as it interests me.
  
  Similarly, a donation made in this way will probably not make me work on this
  software much more, unless I get so many donations that I can consider working
  on free software full time (let's all have a chuckle at that together).
  
  To donate, log into PayPal and send money to autarch@urth.org, or use the
  button at L<http://www.urth.org/~autarch/fs-donation.html>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Dagfinn Ilmari Mannsåker David Cantrell Graham Knop Ivan Bessarabov Mark Fowler Ricardo Signes
  
  =over 4
  
  =item *
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =item *
  
  David Cantrell <david@cantrell.org.uk>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Ivan Bessarabov <ivan@bessarabov.ru>
  
  =item *
  
  Mark Fowler <mark@twoshortplanks.com>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2000 - 2017 by David Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
DEVEL_STACKTRACE

$fatpacked{"Devel/StackTrace/Frame.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_STACKTRACE_FRAME';
  package Devel::StackTrace::Frame;
  
  use strict;
  use warnings;
  
  our $VERSION = '2.03';
  
  # Create accessor routines
  BEGIN {
      ## no critic (TestingAndDebugging::ProhibitNoStrict)
      no strict 'refs';
  
      my @attrs = qw(
          package
          filename
          line
          subroutine
          hasargs
          wantarray
          evaltext
          is_require
          hints
          bitmask
      );
  
      for my $a (@attrs) {
          *{$a} = sub { my $s = shift; return $s->{$a} };
      }
  }
  
  {
      my @args = qw(
          package
          filename
          line
          subroutine
          hasargs
          wantarray
          evaltext
          is_require
          hints
          bitmask
      );
  
      sub new {
          my $proto = shift;
          my $class = ref $proto || $proto;
  
          my $self = bless {}, $class;
  
          @{$self}{@args} = @{ shift() };
          $self->{args}             = shift;
          $self->{respect_overload} = shift;
          $self->{max_arg_length}   = shift;
          $self->{message}          = shift;
          $self->{indent}           = shift;
  
          # fixup unix-style paths on win32
          $self->{filename} = File::Spec->canonpath( $self->{filename} );
  
          return $self;
      }
  }
  
  sub args {
      my $self = shift;
  
      return @{ $self->{args} };
  }
  
  sub as_string {
      my $self  = shift;
      my $first = shift;
      my $p     = shift;
  
      my $sub = $self->subroutine;
  
      # This code stolen straight from Carp.pm and then tweaked. All
      # errors are probably my fault  -dave
      if ($first) {
          $sub
              = defined $self->{message}
              ? $self->{message}
              : 'Trace begun';
      }
      else {
  
          # Build a string, $sub, which names the sub-routine called.
          # This may also be "require ...", "eval '...' or "eval {...}"
          if ( my $eval = $self->evaltext ) {
              if ( $self->is_require ) {
                  $sub = "require $eval";
              }
              else {
                  $eval =~ s/([\\\'])/\\$1/g;
                  $sub = "eval '$eval'";
              }
          }
          elsif ( $sub eq '(eval)' ) {
              $sub = 'eval {...}';
          }
  
          # if there are any arguments in the sub-routine call, format
          # them according to the format variables defined earlier in
          # this file and join them onto the $sub sub-routine string
          #
          # We copy them because they're going to be modified.
          #
          if ( my @a = $self->args ) {
              for (@a) {
  
                  # set args to the string "undef" if undefined
                  unless ( defined $_ ) {
                      $_ = 'undef';
                      next;
                  }
  
                  # hack!
                  ## no critic (Subroutines::ProtectPrivateSubs)
                  $_ = $self->Devel::StackTrace::_ref_to_string($_)
                      if ref $_;
                  ## use critic;
  
                  ## no critic (Variables::RequireInitializationForLocalVars)
                  local $SIG{__DIE__};
                  local $@;
                  ## use critic;
  
                  ## no critic (ErrorHandling::RequireCheckingReturnValueOfEval)
                  eval {
                      my $max_arg_length
                          = exists $p->{max_arg_length}
                          ? $p->{max_arg_length}
                          : $self->{max_arg_length};
  
                      if ( $max_arg_length
                          && length $_ > $max_arg_length ) {
                          ## no critic (BuiltinFunctions::ProhibitLvalueSubstr)
                          substr( $_, $max_arg_length ) = '...';
                      }
  
                      s/'/\\'/g;
  
                      # 'quote' arg unless it looks like a number
                      $_ = "'$_'" unless /^-?[\d.]+$/;
  
                      # print control/high ASCII chars as 'M-<char>' or '^<char>'
                      s/([\200-\377])/sprintf("M-%c",ord($1)&0177)/eg;
                      s/([\0-\37\177])/sprintf("^%c",ord($1)^64)/eg;
                  };
                  ## use critic
  
                  if ( my $e = $@ ) {
                      $_ = $e =~ /malformed utf-8/i ? '(bad utf-8)' : '?';
                  }
              }
  
              # append ('all', 'the', 'arguments') to the $sub string
              $sub .= '(' . join( ', ', @a ) . ')';
              $sub .= ' called';
          }
      }
  
      # If the user opted into indentation (a la Carp::confess), pre-add a tab
      my $tab = $self->{indent} && !$first ? "\t" : q{};
  
      return "${tab}$sub at " . $self->filename . ' line ' . $self->line;
  }
  
  1;
  
  # ABSTRACT: A single frame in a stack trace
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Devel::StackTrace::Frame - A single frame in a stack trace
  
  =head1 VERSION
  
  version 2.03
  
  =head1 DESCRIPTION
  
  See L<Devel::StackTrace> for details.
  
  =for Pod::Coverage new
  
  =head1 METHODS
  
  See Perl's C<caller> documentation for more information on what these
  methods return.
  
  =head2 $frame->package
  
  =head2 $frame->filename
  
  =head2 $frame->line
  
  =head2 $frame->subroutine
  
  =head2 $frame->hasargs
  
  =head2 $frame->wantarray
  
  =head2 $frame->evaltext
  
  Returns undef if the frame was not part of an eval.
  
  =head2 $frame->is_require
  
  Returns undef if the frame was not part of a require.
  
  =head2 $frame->args
  
  Returns the arguments passed to the frame. Note that any arguments that are
  references are returned as references, not copies.
  
  =head2 $frame->hints
  
  =head2 $frame->bitmask
  
  =head2 $frame->as_string
  
  Returns a string containing a description of the frame.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Devel-StackTrace/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Devel-StackTrace can be found at L<https://github.com/houseabsolute/Devel-StackTrace>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2000 - 2017 by David Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
DEVEL_STACKTRACE_FRAME

$fatpacked{"Eval/Closure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EVAL_CLOSURE';
  package Eval::Closure;
  BEGIN {
    $Eval::Closure::AUTHORITY = 'cpan:DOY';
  }
  $Eval::Closure::VERSION = '0.14';
  use strict;
  use warnings;
  # ABSTRACT: safely and cleanly create closures via string eval
  
  use Exporter 'import';
  @Eval::Closure::EXPORT = @Eval::Closure::EXPORT_OK = 'eval_closure';
  
  use Carp;
  use overload ();
  use Scalar::Util qw(reftype);
  
  use constant HAS_LEXICAL_SUBS => $] >= 5.018;
  
  
  
  sub eval_closure {
      my (%args) = @_;
  
      # default to copying environment
      $args{alias} = 0 if !exists $args{alias};
  
      $args{source} = _canonicalize_source($args{source});
      _validate_env($args{environment} ||= {});
  
      $args{source} = _line_directive(@args{qw(line description)})
                    . $args{source}
          if defined $args{description} && !($^P & 0x10);
  
      my ($code, $e) = _clean_eval_closure(@args{qw(source environment alias)});
  
      if (!$code) {
          if ($args{terse_error}) {
              die "$e\n";
          }
          else {
              croak("Failed to compile source: $e\n\nsource:\n$args{source}")
          }
      }
  
      return $code;
  }
  
  sub _canonicalize_source {
      my ($source) = @_;
  
      if (defined($source)) {
          if (ref($source)) {
              if (reftype($source) eq 'ARRAY'
               || overload::Method($source, '@{}')) {
                  return join "\n", @$source;
              }
              elsif (overload::Method($source, '""')) {
                  return "$source";
              }
              else {
                  croak("The 'source' parameter to eval_closure must be a "
                      . "string or array reference");
              }
          }
          else {
              return $source;
          }
      }
      else {
          croak("The 'source' parameter to eval_closure is required");
      }
  }
  
  sub _validate_env {
      my ($env) = @_;
  
      croak("The 'environment' parameter must be a hashref")
          unless reftype($env) eq 'HASH';
  
      for my $var (keys %$env) {
          if (HAS_LEXICAL_SUBS) {
              croak("Environment key '$var' should start with \@, \%, \$, or \&")
                  if index('$@%&', substr($var, 0, 1)) < 0;
          }
          else {
              croak("Environment key '$var' should start with \@, \%, or \$")
                  if index('$@%', substr($var, 0, 1)) < 0;
          }
          croak("Environment values must be references, not $env->{$var}")
              unless ref($env->{$var});
      }
  }
  
  sub _line_directive {
      my ($line, $description) = @_;
  
      $line = 1 unless defined($line);
  
      return qq{#line $line "$description"\n};
  }
  
  sub _clean_eval_closure {
      my ($source, $captures, $alias) = @_;
  
      my @capture_keys = keys %$captures;
  
      if ($ENV{EVAL_CLOSURE_PRINT_SOURCE}) {
          _dump_source(_make_compiler_source($source, $alias, @capture_keys));
      }
  
      my ($compiler, $e) = _make_compiler($source, $alias, @capture_keys);
      return (undef, $e) unless defined $compiler;
  
      my $code = $compiler->(@$captures{@capture_keys});
  
      if (!defined $code) {
          return (
              undef,
              "The 'source' parameter must return a subroutine reference, "
              . "not undef"
          )
      }
      if (!ref($code) || ref($code) ne 'CODE') {
          return (
              undef,
              "The 'source' parameter must return a subroutine reference, not "
              . ref($code)
          )
      }
  
      if ($alias) {
          require Devel::LexAlias;
          Devel::LexAlias::lexalias($code, $_, $captures->{$_})
              for grep substr($_, 0, 1) ne '&', @capture_keys;
      }
  
      return ($code, $e);
  }
  
  sub _make_compiler {
      my $source = _make_compiler_source(@_);
  
      _clean_eval($source)
  }
  
  sub _clean_eval {
      local $@;
      local $SIG{__DIE__};
      my $compiler = eval $_[0];
      my $e = $@;
      ( $compiler, $e )
  }
  
  $Eval::Closure::SANDBOX_ID = 0;
  
  sub _make_compiler_source {
      my ($source, $alias, @capture_keys) = @_;
      $Eval::Closure::SANDBOX_ID++;
      my $i = 0;
      return join "\n", (
          "package Eval::Closure::Sandbox_$Eval::Closure::SANDBOX_ID;",
          'sub {',
              (map { _make_lexical_assignment($_, $i++, $alias) } @capture_keys),
              $source,
          '}',
      );
  }
  
  sub _make_lexical_assignment {
      my ($key, $index, $alias) = @_;
      my $sigil = substr($key, 0, 1);
      my $name = substr($key, 1);
      if (HAS_LEXICAL_SUBS && $sigil eq '&') {
          my $tmpname = '$__' . $name . '__' . $index;
          return 'use feature "lexical_subs"; '
               . 'no warnings "experimental::lexical_subs"; '
               . 'my ' . $tmpname . ' = $_[' . $index . ']; '
               . 'my sub ' . $name . ' { goto ' . $tmpname . ' }';
      }
      if ($alias) {
          return 'my ' . $key . ';';
      }
      else {
          return 'my ' . $key . ' = ' . $sigil . '{$_[' . $index . ']};';
      }
  }
  
  sub _dump_source {
      my ($source) = @_;
  
      my $output;
      local $@;
      if (eval { require Perl::Tidy; 1 }) {
          Perl::Tidy::perltidy(
              source      => \$source,
              destination => \$output,
              argv        => [],
          );
      }
      else {
          $output = $source;
      }
  
      warn "$output\n";
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Eval::Closure - safely and cleanly create closures via string eval
  
  =head1 VERSION
  
  version 0.14
  
  =head1 SYNOPSIS
  
    use Eval::Closure;
  
    my $code = eval_closure(
        source      => 'sub { $foo++ }',
        environment => {
            '$foo' => \1,
        },
    );
  
    warn $code->(); # 1
    warn $code->(); # 2
  
    my $code2 = eval_closure(
        source => 'sub { $code->() }',
    ); # dies, $code isn't in scope
  
  =head1 DESCRIPTION
  
  String eval is often used for dynamic code generation. For instance, C<Moose>
  uses it heavily, to generate inlined versions of accessors and constructors,
  which speeds code up at runtime by a significant amount. String eval is not
  without its issues however - it's difficult to control the scope it's used in
  (which determines which variables are in scope inside the eval), and it's easy
  to miss compilation errors, since eval catches them and sticks them in $@
  instead.
  
  This module attempts to solve these problems. It provides an C<eval_closure>
  function, which evals a string in a clean environment, other than a fixed list
  of specified variables. Compilation errors are rethrown automatically.
  
  =head1 FUNCTIONS
  
  =head2 eval_closure(%args)
  
  This function provides the main functionality of this module. It is exported by
  default. It takes a hash of parameters, with these keys being valid:
  
  =over 4
  
  =item source
  
  The string to be evaled. It should end by returning a code reference. It can
  access any variable declared in the C<environment> parameter (and only those
  variables). It can be either a string, or an arrayref of lines (which will be
  joined with newlines to produce the string).
  
  =item environment
  
  The environment to provide to the eval. This should be a hashref, mapping
  variable names (including sigils) to references of the appropriate type. For
  instance, a valid value for environment would be C<< { '@foo' => [] } >> (which
  would allow the generated function to use an array named C<@foo>). Generally,
  this is used to allow the generated function to access externally defined
  variables (so you would pass in a reference to a variable that already exists).
  
  In perl 5.18 and greater, the environment hash can contain variables with a
  sigil of C<&>. This will create a lexical sub in the evaluated code (see
  L<feature/The 'lexical_subs' feature>). Using a C<&> sigil on perl versions
  before lexical subs were available will throw an error.
  
  =item alias
  
  If set to true, the coderef returned closes over the variables referenced in
  the environment hashref. (This feature requires L<Devel::LexAlias>.) If set to
  false, the coderef closes over a I<< shallow copy >> of the variables.
  
  If this argument is omitted, Eval::Closure will currently assume false, but
  this assumption may change in a future version.
  
  =item description
  
  This lets you provide a bit more information in backtraces. Normally, when a
  function that was generated through string eval is called, that stack frame
  will show up as "(eval n)", where 'n' is a sequential identifier for every
  string eval that has happened so far in the program. Passing a C<description>
  parameter lets you override that to something more useful (for instance,
  L<Moose> overrides the description for accessors to something like "accessor
  foo at MyClass.pm, line 123").
  
  =item line
  
  This lets you override the particular line number that appears in backtraces,
  much like the C<description> option. The default is 1.
  
  =item terse_error
  
  Normally, this function appends the source code that failed to compile, and
  prepends some explanatory text. Setting this option to true suppresses that
  behavior so you get only the compilation error that Perl actually reported.
  
  =back
  
  =head1 BUGS
  
  No known bugs.
  
  Please report any bugs to GitHub Issues at
  L<https://github.com/doy/eval-closure/issues>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Class::MOP::Method::Accessor>
  
  This module is a factoring out of code that used to live here
  
  =back
  
  =head1 SUPPORT
  
  You can find this documentation for this module with the perldoc command.
  
      perldoc Eval::Closure
  
  You can also look for information at:
  
  =over 4
  
  =item * MetaCPAN
  
  L<https://metacpan.org/release/Eval-Closure>
  
  =item * Github
  
  L<https://github.com/doy/eval-closure>
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Eval-Closure>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Eval-Closure>
  
  =back
  
  =head1 NOTES
  
  Based on code from L<Class::MOP::Method::Accessor>, by Stevan Little and the
  Moose Cabal.
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy@tozt.net>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
EVAL_CLOSURE

$fatpacked{"Exception/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEPTION_CLASS';
  package Exception::Class;
  
  use 5.008001;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.44';
  
  use Exception::Class::Base;
  use Scalar::Util qw( blessed reftype );
  
  our $BASE_EXC_CLASS;
  BEGIN { $BASE_EXC_CLASS ||= 'Exception::Class::Base'; }
  
  our %CLASSES;
  
  sub import {
      my $class = shift;
  
      ## no critic (Variables::ProhibitPackageVars)
      local $Exception::Class::Caller = caller();
  
      my %c;
  
      my %needs_parent;
      while ( my $subclass = shift ) {
          my $def = ref $_[0] ? shift : {};
          $def->{isa}
              = $def->{isa}
              ? ( ref $def->{isa} ? $def->{isa} : [ $def->{isa} ] )
              : [];
  
          $c{$subclass} = $def;
      }
  
      # We need to sort by length because if we check for keys in the
      # Foo::Bar:: stash, this creates a "Bar::" key in the Foo:: stash!
  MAKE_CLASSES:
      foreach my $subclass ( sort { length $a <=> length $b } keys %c ) {
          my $def = $c{$subclass};
  
          # We already made this one.
          next if $CLASSES{$subclass};
  
          {
              ## no critic (TestingAndDebugging::ProhibitNoStrict)
              no strict 'refs';
              foreach my $parent ( @{ $def->{isa} } ) {
                  unless ( keys %{"$parent\::"} ) {
                      $needs_parent{$subclass} = {
                          parents => $def->{isa},
                          def     => $def
                      };
                      next MAKE_CLASSES;
                  }
              }
          }
  
          $class->_make_subclass(
              subclass => $subclass,
              def      => $def || {},
          );
      }
  
      foreach my $subclass ( keys %needs_parent ) {
  
          # This will be used to spot circular references.
          my %seen;
          $class->_make_parents( \%needs_parent, $subclass, \%seen );
      }
  }
  
  sub _make_parents {
      my $class    = shift;
      my $needs    = shift;
      my $subclass = shift;
      my $seen     = shift;
      my $child    = shift;    # Just for error messages.
  
      ## no critic (TestingAndDebugging::ProhibitNoStrict, TestingAndDebugging::ProhibitProlongedStrictureOverride)
      no strict 'refs';
  
      # What if someone makes a typo in specifying their 'isa' param?
      # This should catch it. Either it's been made because it didn't
      # have missing parents OR it's in our hash as needing a parent.
      # If neither of these is true then the _only_ place it is
      # mentioned is in the 'isa' param for some other class, which is
      # not a good enough reason to make a new class.
      die
          "Class $subclass appears to be a typo as it is only specified in the 'isa' param for $child\n"
          unless exists $needs->{$subclass}
          || $CLASSES{$subclass}
          || keys %{"$subclass\::"};
  
      foreach my $c ( @{ $needs->{$subclass}{parents} } ) {
  
          # It's been made
          next if $CLASSES{$c} || keys %{"$c\::"};
  
          die "There appears to be some circularity involving $subclass\n"
              if $seen->{$subclass};
  
          $seen->{$subclass} = 1;
  
          $class->_make_parents( $needs, $c, $seen, $subclass );
      }
  
      return if $CLASSES{$subclass} || keys %{"$subclass\::"};
  
      $class->_make_subclass(
          subclass => $subclass,
          def      => $needs->{$subclass}{def}
      );
  }
  
  sub _make_subclass {
      my $class = shift;
      my %p     = @_;
  
      my $subclass = $p{subclass};
      my $def      = $p{def};
  
      my $isa;
      if ( $def->{isa} ) {
          $isa = ref $def->{isa} ? join q{ }, @{ $def->{isa} } : $def->{isa};
      }
      $isa ||= $BASE_EXC_CLASS;
  
      my $version_name = 'VERSION';
  
      my $code = <<"EOPERL";
  package $subclass;
  
  use base qw($isa);
  
  our \$$version_name = '1.1';
  
  1;
  
  EOPERL
  
      if ( $def->{description} ) {
          ( my $desc = $def->{description} ) =~ s/([\\\'])/\\$1/g;
          $code .= <<"EOPERL";
  sub description
  {
      return '$desc';
  }
  EOPERL
      }
  
      my @fields;
      if ( my $fields = $def->{fields} ) {
          @fields
              = ref $fields && reftype $fields eq 'ARRAY' ? @$fields : $fields;
  
          $code
              .= 'sub Fields { return ($_[0]->SUPER::Fields, '
              . join( ', ', map {"'$_'"} @fields )
              . ") }\n\n";
  
          foreach my $field (@fields) {
              $code .= sprintf( "sub %s { \$_[0]->{%s} }\n", $field, $field );
          }
      }
  
      if ( my $alias = $def->{alias} ) {
          ## no critic (Variables::ProhibitPackageVars)
          die 'Cannot make alias without caller'
              unless defined $Exception::Class::Caller;
  
          ## no critic (TestingAndDebugging::ProhibitNoStrict)
          no strict 'refs';
          *{"$Exception::Class::Caller\::$alias"}
              = sub { $subclass->throw(@_) };
      }
  
      if ( my $defaults = $def->{defaults} ) {
          $code
              .= "sub _defaults { return shift->SUPER::_defaults, our \%_DEFAULTS }\n";
          ## no critic (TestingAndDebugging::ProhibitNoStrict)
          no strict 'refs';
          *{"$subclass\::_DEFAULTS"} = {%$defaults};
      }
  
      ## no critic (BuiltinFunctions::ProhibitStringyEval, ErrorHandling::RequireCheckingReturnValueOfEval)
      eval $code;
      die $@ if $@;
  
      ( my $filename = "$subclass.pm" ) =~ s{::}{/}g;
      $INC{$filename} = __FILE__;
  
      $CLASSES{$subclass} = 1;
  }
  
  sub caught {
      my $e = $@;
  
      return $e unless $_[1];
  
      return unless blessed($e) && $e->isa( $_[1] );
      return $e;
  }
  
  sub Classes { sort keys %Exception::Class::CLASSES }
  
  1;
  
  # ABSTRACT: A module that allows you to declare real exception classes in Perl
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Exception::Class - A module that allows you to declare real exception classes in Perl
  
  =head1 VERSION
  
  version 1.44
  
  =head1 SYNOPSIS
  
    use Exception::Class (
        'MyException',
  
        'AnotherException' => { isa => 'MyException' },
  
        'YetAnotherException' => {
            isa         => 'AnotherException',
            description => 'These exceptions are related to IPC'
        },
  
        'ExceptionWithFields' => {
            isa    => 'YetAnotherException',
            fields => [ 'grandiosity', 'quixotic' ],
            alias  => 'throw_fields',
        },
    );
    use Scalar::Util qw( blessed );
    use Try::Tiny;
  
    try {
        MyException->throw( error => 'I feel funny.' );
    }
    catch {
        die $_ unless blessed $_ && $_->can('rethrow');
  
        if ( $_->isa('Exception::Class') ) {
            warn $_->error, "\n", $_->trace->as_string, "\n";
            warn join ' ', $_->euid, $_->egid, $_->uid, $_->gid, $_->pid, $_->time;
  
            exit;
        }
        elsif ( $_->isa('ExceptionWithFields') ) {
            if ( $_->quixotic ) {
                handle_quixotic_exception();
            }
            else {
                handle_non_quixotic_exception();
            }
        }
        else {
            $_->rethrow;
        }
    };
  
    # without Try::Tiny
    eval { ... };
    if ( my $e = Exception::Class->caught ) { ... }
  
    # use an alias - without parens subroutine name is checked at
    # compile time
    throw_fields error => "No strawberry", grandiosity => "quite a bit";
  
  =head1 DESCRIPTION
  
  B<RECOMMENDATION 1>: If you are writing modern Perl code with L<Moose> or
  L<Moo> I highly recommend using L<Throwable> instead of this module.
  
  B<RECOMMENDATION 2>: Whether or not you use L<Throwable>, you should use
  L<Try::Tiny>.
  
  Exception::Class allows you to declare exception hierarchies in your modules
  in a "Java-esque" manner.
  
  It features a simple interface allowing programmers to 'declare' exception
  classes at compile time. It also has a base exception class,
  L<Exception::Class::Base>, that can be easily extended.
  
  It is designed to make structured exception handling simpler and better by
  encouraging people to use hierarchies of exceptions in their applications, as
  opposed to a single catch-all exception class.
  
  This module does not implement any try/catch syntax. Please see the "OTHER
  EXCEPTION MODULES (try/catch syntax)" section for more information on how to
  get this syntax.
  
  You will also want to look at the documentation for L<Exception::Class::Base>,
  which is the default base class for all exception objects created by this
  module.
  
  =for Pod::Coverage     Classes
      caught
  
  =head1 DECLARING EXCEPTION CLASSES
  
  Importing C<Exception::Class> allows you to automagically create
  L<Exception::Class::Base> subclasses. You can also create subclasses via the
  traditional means of defining your own subclass with C<@ISA>.  These two
  methods may be easily combined, so that you could subclass an exception class
  defined via the automagic import, if you desired this.
  
  The syntax for the magic declarations is as follows:
  
    'MANDATORY CLASS NAME' => \%optional_hashref
  
  The hashref may contain the following options:
  
  =over 4
  
  =item * isa
  
  This is the class's parent class. If this isn't provided then the class name
  in C<$Exception::Class::BASE_EXC_CLASS> is assumed to be the parent (see
  below).
  
  This parameter lets you create arbitrarily deep class hierarchies.  This can
  be any other L<Exception::Class::Base> subclass in your declaration I<or> a
  subclass loaded from a module.
  
  To change the default exception class you will need to change the value of
  C<$Exception::Class::BASE_EXC_CLASS> I<before> calling C<import>. To do this
  simply do something like this:
  
    BEGIN { $Exception::Class::BASE_EXC_CLASS = 'SomeExceptionClass'; }
  
  If anyone can come up with a more elegant way to do this please let me know.
  
  CAVEAT: If you want to automagically subclass an L<Exception::Class::Base>
  subclass loaded from a file, then you I<must> compile the class (via use or
  require or some other magic) I<before> you import C<Exception::Class> or
  you'll get a compile time error.
  
  =item * fields
  
  This allows you to define additional attributes for your exception class. Any
  field you define can be passed to the C<throw> or C<new> methods as additional
  parameters for the constructor. In addition, your exception object will have
  an accessor method for the fields you define.
  
  This parameter can be either a scalar (for a single field) or an array
  reference if you need to define multiple fields.
  
  Fields will be inherited by subclasses.
  
  =item * alias
  
  Specifying an alias causes this class to create a subroutine of the specified
  name in the I<caller's> namespace. Calling this subroutine is equivalent to
  calling C<< <class>->throw(@_) >> for the given exception class.
  
  Besides convenience, using aliases also allows for additional compile time
  checking. If the alias is called I<without parentheses>, as in C<throw_fields
  "an error occurred">, then Perl checks for the existence of the
  C<throw_fields> subroutine at compile time. If instead you do C<<
  ExceptionWithFields->throw(...) >>, then Perl checks the class name at
  runtime, meaning that typos may sneak through.
  
  =item * description
  
  Each exception class has a description method that returns a fixed
  string. This should describe the exception I<class> (as opposed to any
  particular exception object). This may be useful for debugging if you start
  catching exceptions you weren't expecting (particularly if someone forgot to
  document them) and you don't understand the error messages.
  
  =back
  
  The C<Exception::Class> magic attempts to detect circular class hierarchies
  and will die if it finds one. It also detects missing links in a chain, for
  example if you declare Bar to be a subclass of Foo and never declare Foo.
  
  =head1 L<Try::Tiny>
  
  If you are interested in adding try/catch/finally syntactic sugar to your code
  then I recommend you check out L<Try::Tiny>. This is a great module that helps
  you ignore some of the weirdness with C<eval> and C<$@>. Here's an example of
  how the two modules work together:
  
    use Exception::Class ( 'My::Exception' );
    use Scalar::Util qw( blessed );
    use Try::Tiny;
  
    try {
        might_throw();
    }
    catch {
        if ( blessed $_ && $_->isa('My::Exception') ) {
            handle_it();
        }
        else {
            die $_;
        }
    };
  
  Note that you B<cannot> use C<< Exception::Class->caught >> with L<Try::Tiny>.
  
  =head1 Catching Exceptions Without L<Try::Tiny>
  
  C<Exception::Class> provides some syntactic sugar for catching exceptions in a
  safe manner:
  
    eval {...};
  
    if ( my $e = Exception::Class->caught('My::Error') ) {
        cleanup();
        do_something_with_exception($e);
    }
  
  The C<caught> method takes a class name and returns an exception object if the
  last thrown exception is of the given class, or a subclass of that class. If
  it is not given any arguments, it simply returns C<$@>.
  
  You should B<always> make a copy of the exception object, rather than using
  C<$@> directly. This is necessary because if your C<cleanup> function uses
  C<eval>, or calls something which uses it, then C<$@> is overwritten. Copying
  the exception preserves it for the call to C<do_something_with_exception>.
  
  Exception objects also provide a caught method so you can write:
  
    if ( my $e = My::Error->caught ) {
        cleanup();
        do_something_with_exception($e);
    }
  
  =head2 Uncatchable Exceptions
  
  Internally, the C<caught> method will call C<isa> on the exception object. You
  could make an exception "uncatchable" by overriding C<isa> in that class like
  this:
  
   package Exception::Uncatchable;
  
   sub isa { shift->rethrow }
  
  Of course, this only works if you always call C<< Exception::Class->caught >>
  after an C<eval>.
  
  =head1 USAGE RECOMMENDATION
  
  If you're creating a complex system that throws lots of different types of
  exceptions, consider putting all the exception declarations in one place. For
  an app called Foo you might make a C<Foo::Exceptions> module and use that in
  all your code. This module could just contain the code to make
  C<Exception::Class> do its automagic class creation. Doing this allows you to
  more easily see what exceptions you have, and makes it easier to keep track of
  them.
  
  This might look something like this:
  
    package Foo::Bar::Exceptions;
  
    use Exception::Class (
        Foo::Bar::Exception::Senses =>
            { description => 'sense-related exception' },
  
        Foo::Bar::Exception::Smell => {
            isa         => 'Foo::Bar::Exception::Senses',
            fields      => 'odor',
            description => 'stinky!'
        },
  
        Foo::Bar::Exception::Taste => {
            isa         => 'Foo::Bar::Exception::Senses',
            fields      => [ 'taste', 'bitterness' ],
            description => 'like, gag me with a spoon!'
        },
  
        ...
    );
  
  You may want to create a real module to subclass L<Exception::Class::Base> as
  well, particularly if you want your exceptions to have more methods.
  
  =head2 Subclassing Exception::Class::Base
  
  As part of your usage of C<Exception::Class>, you may want to create your own
  base exception class which subclasses L<Exception::Class::Base>. You should
  feel free to subclass any of the methods documented above. For example, you
  may want to subclass C<new> to add additional information to your exception
  objects.
  
  =head1 Exception::Class FUNCTIONS
  
  The C<Exception::Class> method offers one function, C<Classes>, which is not
  exported. This method returns a list of the classes that have been created by
  calling the C<Exception::Class> C<import> method.  Note that this is I<all>
  the subclasses that have been created, so it may include subclasses created by
  things like CPAN modules, etc. Also note that if you simply define a subclass
  via the normal Perl method of setting C<@ISA> or C<use base>, then your
  subclass will not be included.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Exception-Class/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Exception-Class can be found at L<https://github.com/houseabsolute/Exception-Class>.
  
  =head1 DONATIONS
  
  If you'd like to thank me for the work I've done on this module, please
  consider making a "donation" to me via PayPal. I spend a lot of free time
  creating free software, and would appreciate any support you'd care to offer.
  
  Please note that B<I am not suggesting that you must do this> in order for me
  to continue working on this particular software. I will continue to do so,
  inasmuch as I have in the past, for as long as it interests me.
  
  Similarly, a donation made in this way will probably not make me work on this
  software much more, unless I get so many donations that I can consider working
  on free software full time (let's all have a chuckle at that together).
  
  To donate, log into PayPal and send money to autarch@urth.org, or use the
  button at L<http://www.urth.org/~autarch/fs-donation.html>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Alexander Batyrshin Leon Timmermans Ricardo Signes
  
  =over 4
  
  =item *
  
  Alexander Batyrshin <0x62ash@gmail.com>
  
  =item *
  
  Leon Timmermans <fawaka@gmail.com>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by Dave Rolsky.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
EXCEPTION_CLASS

$fatpacked{"Exception/Class/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEPTION_CLASS_BASE';
  package Exception::Class::Base;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.44';
  
  use Class::Data::Inheritable 0.02;
  use Devel::StackTrace 2.00;
  use Scalar::Util qw( blessed );
  
  use base qw(Class::Data::Inheritable);
  
  BEGIN {
      __PACKAGE__->mk_classdata('Trace');
      __PACKAGE__->mk_classdata('UnsafeRefCapture');
  
      __PACKAGE__->mk_classdata('NoContextInfo');
      __PACKAGE__->NoContextInfo(0);
  
      __PACKAGE__->mk_classdata('RespectOverload');
      __PACKAGE__->RespectOverload(0);
  
      __PACKAGE__->mk_classdata('MaxArgLength');
      __PACKAGE__->MaxArgLength(0);
  
      sub NoRefs {
          my $self = shift;
          if (@_) {
              my $val = shift;
              return $self->UnsafeRefCapture( !$val );
          }
          else {
              return $self->UnsafeRefCapture;
          }
      }
  
      sub Fields { () }
  }
  
  use overload
  
      # an exception is always true
      bool => sub {1}, '""' => 'as_string', fallback => 1;
  
  # Create accessor routines
  BEGIN {
      my @fields = qw( message pid uid euid gid egid time trace );
  
      foreach my $f (@fields) {
          my $sub = sub { my $s = shift; return $s->{$f}; };
  
          ## no critic (TestingAndDebugging::ProhibitNoStrict)
          no strict 'refs';
          *{$f} = $sub;
      }
      *error = \&message;
  
      my %trace_fields = (
          package => 'package',
          file    => 'filename',
          line    => 'line',
      );
  
      while ( my ( $f, $m ) = each %trace_fields ) {
          my $sub = sub {
              my $s = shift;
              return $s->{$f} if exists $s->{$f};
  
              my $frame = $s->trace->frame(0);
  
              return $s->{$f} = $frame ? $frame->$m : undef;
          };
  
          ## no critic (TestingAndDebugging::ProhibitNoStrict)
          no strict 'refs';
          *{$f} = $sub;
      }
  }
  
  sub Classes { Exception::Class::Classes() }
  
  sub throw {
      my $proto = shift;
  
      $proto->rethrow if ref $proto;
  
      die $proto->new(@_);
  }
  
  sub rethrow {
      my $self = shift;
  
      die $self;
  }
  
  sub new {
      my $proto = shift;
      my $class = ref $proto || $proto;
  
      my $self = bless {}, $class;
  
      $self->_initialize(@_);
  
      return $self;
  }
  
  sub _initialize {
      my $self = shift;
      my %p = @_ == 1 ? ( error => $_[0] ) : @_;
  
      $self->{message} = $p{message} || $p{error} || q{};
  
      $self->{show_trace} = $p{show_trace} if exists $p{show_trace};
  
      if ( $self->NoContextInfo ) {
          $self->{show_trace} = 0;
          $self->{package} = $self->{file} = $self->{line} = undef;
      }
      else {
          # CORE::time is important to fix an error with some versions of
          # Perl
          $self->{time} = CORE::time();
          $self->{pid}  = $$;
          $self->{uid}  = $<;
          $self->{euid} = $>;
          $self->{gid}  = $(;
          $self->{egid} = $);
  
          my @ignore_class   = (__PACKAGE__);
          my @ignore_package = 'Exception::Class';
  
          if ( my $i = delete $p{ignore_class} ) {
              push @ignore_class, ( ref($i) eq 'ARRAY' ? @$i : $i );
          }
  
          if ( my $i = delete $p{ignore_package} ) {
              push @ignore_package, ( ref($i) eq 'ARRAY' ? @$i : $i );
          }
  
          $self->{trace} = Devel::StackTrace->new(
              ignore_class       => \@ignore_class,
              ignore_package     => \@ignore_package,
              unsafe_ref_capture => $self->UnsafeRefCapture,
              respect_overload   => $self->RespectOverload,
              max_arg_length     => $self->MaxArgLength,
              map { $p{$_} ? ( $_ => delete $p{$_} ) : () } qw(
                  frame_filter
                  filter_frames_early
                  skip_frames
                  ),
          );
      }
  
      my %fields = map { $_ => 1 } $self->Fields;
      while ( my ( $key, $value ) = each %p ) {
          next if $key =~ /^(?:error|message|show_trace)$/;
  
          if ( $fields{$key} ) {
              $self->{$key} = $value;
          }
          else {
              Exception::Class::Base->throw(
                  error => "unknown field $key passed to constructor for class "
                      . ref $self );
          }
      }
  }
  
  sub context_hash {
      my $self = shift;
  
      return {
          time => $self->{time},
          pid  => $self->{pid},
          uid  => $self->{uid},
          euid => $self->{euid},
          gid  => $self->{gid},
          egid => $self->{egid},
      };
  }
  
  sub field_hash {
      my $self = shift;
  
      my $hash = {};
  
      for my $field ( $self->Fields ) {
          $hash->{$field} = $self->$field;
      }
  
      return $hash;
  }
  
  sub description {
      return 'Generic exception';
  }
  
  sub show_trace {
      my $self = shift;
  
      return 0 unless $self->{trace};
  
      if (@_) {
          $self->{show_trace} = shift;
      }
  
      return exists $self->{show_trace} ? $self->{show_trace} : $self->Trace;
  }
  
  sub as_string {
      my $self = shift;
  
      my $str = $self->full_message;
      unless ( defined $str && length $str ) {
          my $desc = $self->description;
          $str = defined $desc
              && length $desc ? "[$desc]" : '[Generic exception]';
      }
  
      $str .= "\n\n" . $self->trace->as_string
          if $self->show_trace;
  
      return $str;
  }
  
  sub full_message { $_[0]->message }
  
  #
  # The %seen bit protects against circular inheritance.
  #
  ## no critic (BuiltinFunctions::ProhibitStringyEval, ErrorHandling::RequireCheckingReturnValueOfEval)
  eval <<'EOF' if $] == 5.006;
  sub isa {
      my ( $inheritor, $base ) = @_;
      $inheritor = ref($inheritor) if ref($inheritor);
  
      my %seen;
  
      no strict 'refs';
      my @parents = ( $inheritor, @{"$inheritor\::ISA"} );
      while ( my $class = shift @parents ) {
          return 1 if $class eq $base;
  
          push @parents, grep { !$seen{$_}++ } @{"$class\::ISA"};
      }
      return 0;
  }
  EOF
  
  sub caught {
      my $class = shift;
  
      my $e = $@;
  
      return unless defined $e && blessed($e) && $e->isa($class);
      return $e;
  }
  
  1;
  
  # ABSTRACT: A base class for exception objects
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Exception::Class::Base - A base class for exception objects
  
  =head1 VERSION
  
  version 1.44
  
  =head1 SYNOPSIS
  
    use Exception::Class 'MyException';
  
    eval { MyException->throw( error => 'I feel funny.' ) };
  
    print $@->error;
  
  =head1 DESCRIPTION
  
  This class is the base class for all exceptions created by
  L<Exception::Class>. It provides a number of methods for getting information
  about the exception.
  
  =for Pod::Coverage     Classes
      caught
      NoRefs
  
  =head1 METHODS
  
  =head2 MyException->Trace($boolean)
  
  Each C<Exception::Class::Base> subclass can be set individually to include a
  stacktrace when the C<as_string> method is called. The default is to not
  include a stacktrace. Calling this method with a value changes this
  behavior. It always returns the current value (after any change is applied).
  
  This value is inherited by any subclasses. However, if this value is set for a
  subclass, it will thereafter be independent of the value in
  C<Exception::Class::Base>.
  
  Do not call this on the C<Exception::Class::Base> class directly or you'll
  change it for all exception classes that use L<Exception::Class>, including
  ones created in modules you don't control.
  
  This is a class method, not an object method.
  
  =head2 MyException->UnsafeRefCapture($boolean)
  
  When a C<Devel::StackTrace> object is created, it walks through the stack and
  stores the arguments which were passed to each subroutine on the stack. If any
  of these arguments are references, then that means that the
  C<Devel::StackTrace> ends up increasing the ref count of these references,
  delaying their destruction.
  
  Since C<Exception::Class::Base> uses C<Devel::StackTrace> internally, this
  method provides a way to tell C<Devel::StackTrace> not to store these
  references. Instead, C<Devel::StackTrace> replaces references with their
  stringified representation.
  
  This method defaults to false. As with C<Trace>, it is inherited by subclasses
  but setting it in a subclass makes it independent thereafter.
  
  Do not call this on the C<Exception::Class::Base> class directly or you'll
  change it for all exception classes that use L<Exception::Class>, including
  ones created in modules you don't control.
  
  =head2 MyException->RespectOverload($boolean)
  
  When a C<Devel::StackTrace> object stringifies, by default it ignores
  stringification overloading on any objects being dealt with.
  
  Since C<Exception::Class::Base> uses C<Devel::StackTrace> internally, this
  method provides a way to tell C<Devel::StackTrace> to respect overloading.
  
  This method defaults to false. As with C<Trace>, it is inherited by subclasses
  but setting it in a subclass makes it independent thereafter.
  
  Do not call this on the C<Exception::Class::Base> class directly or you'll
  change it for all exception classes that use L<Exception::Class>, including
  ones created in modules you don't control.
  
  =head2 MyException->MaxArgLength($boolean)
  
  When a C<Devel::StackTrace> object stringifies, by default it displays the
  full argument for each function. This parameter can be used to limit the
  maximum length of each argument.
  
  Since C<Exception::Class::Base> uses C<Devel::StackTrace> internally, this
  method provides a way to tell C<Devel::StackTrace> to limit the length of
  arguments.
  
  This method defaults to 0. As with C<Trace>, it is inherited by subclasses but
  setting it in a subclass makes it independent thereafter.
  
  Do not call this on the C<Exception::Class::Base> class directly or you'll
  change it for all exception classes that use L<Exception::Class>, including
  ones created in modules you don't control.
  
  =head2 MyException->Fields
  
  This method returns the extra fields defined for the given class, as a list.
  
  Do not call this on the C<Exception::Class::Base> class directly or you'll
  change it for all exception classes that use L<Exception::Class>, including
  ones created in modules you don't control.
  
  =head2 MyException->throw( $message )
  
  =head2 MyException->throw( message => $message )
  
  =head2 MyException->throw( error => $error )
  
  This method creates a new object with the given error message. If no error
  message is given, this will be an empty string. It then dies with this object
  as its argument.
  
  This method also takes a C<show_trace> parameter which indicates whether or
  not the particular exception object being created should show a stacktrace
  when its C<as_string> method is called. This overrides the value of C<Trace>
  for this class if it is given.
  
  The frames included in the trace can be controlled by the C<ignore_class> and
  C<ignore_package> parameters. These are passed directly to Devel::Stacktrace's
  constructor. See C<Devel::Stacktrace> for more details. This class B<always>
  passes C<__PACKAGE__> for C<ignore_class> and C<'Exception::Class'> for
  C<ignore_package>, in addition to any arguments you provide.
  
  If only a single value is given to the constructor it is assumed to be the
  message parameter.
  
  Additional keys corresponding to the fields defined for the particular
  exception subclass will also be accepted.
  
  =head2 MyException->new(...)
  
  This method takes the same parameters as C<throw>, but instead of dying simply
  returns a new exception object.
  
  This method is always called when constructing a new exception object via the
  C<throw> method.
  
  =head2 MyException->description
  
  Returns the description for the given C<Exception::Class::Base> subclass. The
  C<Exception::Class::Base> class's description is "Generic exception" (this may
  change in the future). This is also an object method.
  
  =head2 $exception->rethrow
  
  Simply dies with the object as its sole argument. It's just syntactic
  sugar. This does not change any of the object's attribute values.  However, it
  will cause C<caller> to report the die as coming from within the
  C<Exception::Class::Base> class rather than where rethrow was called.
  
  Of course, you always have access to the original stacktrace for the exception
  object.
  
  =head2 $exception->message
  
  =head2 $exception->error
  
  Returns the error/message associated with the exception.
  
  =head2 $exception->pid
  
  Returns the pid at the time the exception was thrown.
  
  =head2 $exception->uid
  
  Returns the real user id at the time the exception was thrown.
  
  =head2 $exception->gid
  
  Returns the real group id at the time the exception was thrown.
  
  =head2 $exception->euid
  
  Returns the effective user id at the time the exception was thrown.
  
  =head2 $exception->egid
  
  Returns the effective group id at the time the exception was thrown.
  
  =head2 $exception->time
  
  Returns the time in seconds since the epoch at the time the exception was
  thrown.
  
  =head2 $exception->package
  
  Returns the package from which the exception was thrown.
  
  =head2 $exception->file
  
  Returns the file within which the exception was thrown.
  
  =head2 $exception->line
  
  Returns the line where the exception was thrown.
  
  =head2 $exception->context_hash
  
  Returns a hash reference with the following keys:
  
  =over 4
  
  =item * time
  
  =item * pid
  
  =item * uid
  
  =item * euid
  
  =item * gid
  
  =item * egid
  
  =back
  
  =head2 $exception->field_hash
  
  Returns a hash reference where the keys are any fields defined for the
  exception class and the values are the values associated with the field in the
  given object.
  
  =head2 $exception->trace
  
  Returns the trace object associated with the object.
  
  =head2 $exception->show_trace($boolean)
  
  This method can be used to set whether or not a stack trace is included when
  the as_string method is called or the object is stringified.
  
  =head2 $exception->as_string
  
  Returns a string form of the error message (something like what you'd expect
  from die). If the class or object is set to show traces then then the full
  trace is also included. The result looks like C<Carp::confess>.
  
  =head2 $exception->full_message
  
  Called by the C<as_string> method to get the message. By default, this is the
  same as calling the C<message> method, but may be overridden by a
  subclass. See below for details.
  
  =head1 LIGHTWEIGHT EXCEPTIONS
  
  A lightweight exception is one which records no information about its context
  when it is created. This can be achieved by setting C<< $class->NoContextInfo
  >> to a true value.
  
  You can make this the default for a class of exceptions by setting it after
  creating the class:
  
    use Exception::Class (
        'LightWeight',
        'HeavyWeight',
    );
  
    LightWeight->NoContextInfo(1);
  
  A lightweight exception does have a stack trace object, nor does it record the
  time, pid, uid, euid, gid, or egid. It only has a message.
  
  =head1 OVERLOADING
  
  C<Exception::Class::Base> objects are overloaded so that stringification
  produces a normal error message. This just calls the C<< $exception->as_string
  >> method described above. This means that you can just C<print $@> after an
  C<eval> and not worry about whether or not its an actual object. It also means
  an application or module could do this:
  
    $SIG{__DIE__} = sub { Exception::Class::Base->throw( error => join '', @_ ); };
  
  and this would probably not break anything (unless someone was expecting a
  different type of exception object from C<die>).
  
  =head1 OVERRIDING THE as_string METHOD
  
  By default, the C<as_string> method simply returns the value C<message> or
  C<error> param plus a stack trace, if the class's C<Trace> method returns a
  true value or C<show_trace> was set when creating the exception.
  
  However, once you add new fields to a subclass, you may want to include those
  fields in the stringified error.
  
  Inside the C<as_string> method, the message (non-stack trace) portion of the
  error is generated by calling the C<full_message> method. This can be easily
  overridden. For example:
  
    sub full_message {
        my $self = shift;
  
        my $msg = $self->message;
  
        $msg .= " and foo was " . $self->foo;
  
        return $msg;
    }
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Exception-Class/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Exception-Class can be found at L<https://github.com/houseabsolute/Exception-Class>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by Dave Rolsky.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
EXCEPTION_CLASS_BASE

$fatpacked{"Exporter/Shiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_SHINY';
  package Exporter::Shiny;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Exporter::Tiny ();
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000000';
  
  sub import {
  	my $me     = shift;
  	my $caller = caller;
  	
  	(my $nominal_file = $caller) =~ s(::)(/)g;
  	$INC{"$nominal_file\.pm"} ||= __FILE__;
  	
  	if (@_ == 2 and $_[0] eq -setup)
  	{
  		my (undef, $opts) = @_;
  		@_ = @{ delete($opts->{exports}) || [] };
  		
  		if (%$opts) {
  			Exporter::Tiny::_croak(
  				'Unsupported Sub::Exporter-style options: %s',
  				join(q[, ], sort keys %$opts),
  			);
  		}
  	}
  	
  	ref($_) && Exporter::Tiny::_croak('Expected sub name, got ref %s', $_) for @_;
  	
  	no strict qw(refs);
  	push @{"$caller\::ISA"}, 'Exporter::Tiny';
  	push @{"$caller\::EXPORT_OK"}, @_;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Exporter::Shiny - shortcut for Exporter::Tiny
  
  =head1 SYNOPSIS
  
     use Exporter::Shiny qw( foo bar );
  
  Is a shortcut for:
  
     use base "Exporter::Tiny";
     push our(@EXPORT_OK), qw( foo bar );
  
  For compatibility with L<Sub::Exporter>, the following longer syntax is
  also supported:
  
     use Exporter::Shiny -setup => {
        exports => [qw( foo bar )],
     };
  
  =head1 DESCRIPTION
  
  This is a very small wrapper to simplify using L<Exporter::Tiny>.
  
  It does the following:
  
  =over
  
  =item * Marks your package as loaded in C<< %INC >>;
  
  =item * Pushes any function names in the import list onto your C<< @EXPORT_OK >>; and
  
  =item * Pushes C<< "Exporter::Tiny" >> onto your C<< @ISA >>.
  
  =back
  
  It doesn't set up C<< %EXPORT_TAGS >> or C<< @EXPORT >>, but there's
  nothing stopping you doing that yourself.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Exporter-Tiny>.
  
  =head1 SEE ALSO
  
  This module is just a wrapper around L<Exporter::Tiny>, so take a look
  at L<Exporter::Tiny::Manual::QuickStart> and
  L<Exporter::Tiny::Manual::Exporting> for further information on what
  features are available.
  
  Other interesting exporters: L<Sub::Exporter>, L<Exporter>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EXPORTER_SHINY

$fatpacked{"Exporter/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_TINY';
  package Exporter::Tiny;
  
  use 5.006001;
  use strict;
  use warnings; no warnings qw(void once uninitialized numeric redefine);
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000000';
  our @EXPORT_OK = qw< mkopt mkopt_hash _croak _carp >;
  
  sub _croak ($;@) { require Carp; my $fmt = shift; @_ = sprintf($fmt, @_); goto \&Carp::croak }
  sub _carp  ($;@) { require Carp; my $fmt = shift; @_ = sprintf($fmt, @_); goto \&Carp::carp }
  
  my $_process_optlist = sub
  {
  	my $class = shift;
  	my ($global_opts, $opts, $want, $not_want) = @_;
  	
  	while (@$opts)
  	{
  		my $opt = shift @{$opts};
  		my ($name, $value) = @$opt;
  		
  		($name =~ m{\A\!(/.+/[msixpodual]+)\z}) ?
  			do {
  				my @not = $class->_exporter_expand_regexp($1, $value, $global_opts);
  				++$not_want->{$_->[0]} for @not;
  			} :
  		($name =~ m{\A\!(.+)\z}) ?
  			(++$not_want->{$1}) :
  		($name =~ m{\A[:-](.+)\z}) ?
  			push(@$opts, $class->_exporter_expand_tag($1, $value, $global_opts)) :
  		($name =~ m{\A/.+/[msixpodual]+\z}) ?
  			push(@$opts, $class->_exporter_expand_regexp($name, $value, $global_opts)) :
  		# else ?
  			push(@$want, $opt);
  	}
  };
  
  sub import
  {
  	my $class = shift;
  	my $global_opts = +{ @_ && ref($_[0]) eq q(HASH) ? %{+shift} : () };
  	$global_opts->{into} = caller unless exists $global_opts->{into};
  	
  	my @want;
  	my %not_want; $global_opts->{not} = \%not_want;
  	my @args = do { no strict qw(refs); @_ ? @_ : @{"$class\::EXPORT"} };
  	my $opts = mkopt(\@args);
  	$class->$_process_optlist($global_opts, $opts, \@want, \%not_want);
  	
  	my $permitted = $class->_exporter_permitted_regexp($global_opts);
  	$class->_exporter_validate_opts($global_opts);
  	
  	for my $wanted (@want)
  	{
  		next if $not_want{$wanted->[0]};
  		
  		my %symbols = $class->_exporter_expand_sub(@$wanted, $global_opts, $permitted);
  		$class->_exporter_install_sub($_, $wanted->[1], $global_opts, $symbols{$_})
  			for keys %symbols;
  	}
  }
  
  sub unimport
  {
  	my $class = shift;
  	my $global_opts = +{ @_ && ref($_[0]) eq q(HASH) ? %{+shift} : () };
  	$global_opts->{into} = caller unless exists $global_opts->{into};
  	$global_opts->{is_unimport} = 1;
  	
  	my @want;
  	my %not_want; $global_opts->{not} = \%not_want;
  	my @args = do { our %TRACKED; @_ ? @_ : keys(%{$TRACKED{$class}{$global_opts->{into}}}) };
  	my $opts = mkopt(\@args);
  	$class->$_process_optlist($global_opts, $opts, \@want, \%not_want);
  	
  	my $permitted = $class->_exporter_permitted_regexp($global_opts);
  	$class->_exporter_validate_unimport_opts($global_opts);
  	
  	my $expando = $class->can('_exporter_expand_sub');
  	$expando = undef if $expando == \&_exporter_expand_sub;
  	
  	for my $wanted (@want)
  	{
  		next if $not_want{$wanted->[0]};
  		
  		if ($wanted->[1])
  		{
  			_carp("Passing options to unimport '%s' makes no sense", $wanted->[0])
  				unless (ref($wanted->[1]) eq 'HASH' and not keys %{$wanted->[1]});
  		}
  		
  		my %symbols = defined($expando)
  			? $class->$expando(@$wanted, $global_opts, $permitted)
  			: ($wanted->[0] => sub { "dummy" });
  		$class->_exporter_uninstall_sub($_, $wanted->[1], $global_opts)
  			for keys %symbols;
  	}
  }
  
  # Called once per import/unimport, passed the "global" import options.
  # Expected to validate the options and carp or croak if there are problems.
  # Can also take the opportunity to do other stuff if needed.
  #
  sub _exporter_validate_opts          { 1 }
  sub _exporter_validate_unimport_opts { 1 }
  
  # Called after expanding a tag or regexp to merge the tag's options with
  # any sub-specific options.
  #
  sub _exporter_merge_opts
  {
  	my $class = shift;
  	my ($tag_opts, $global_opts, @stuff) = @_;
  	
  	$tag_opts = {} unless ref($tag_opts) eq q(HASH);
  	_croak('Cannot provide an -as option for tags')
  		if exists $tag_opts->{-as} && ref $tag_opts->{-as} ne 'CODE';
  	
  	my $optlist = mkopt(\@stuff);
  	for my $export (@$optlist)
  	{
  		next if defined($export->[1]) && ref($export->[1]) ne q(HASH);
  		
  		my %sub_opts = ( %{ $export->[1] or {} }, %$tag_opts );
  		$sub_opts{-prefix} = sprintf('%s%s', $tag_opts->{-prefix}, $export->[1]{-prefix})
  			if exists($export->[1]{-prefix}) && exists($tag_opts->{-prefix});
  		$sub_opts{-suffix} = sprintf('%s%s', $export->[1]{-suffix}, $tag_opts->{-suffix})
  			if exists($export->[1]{-suffix}) && exists($tag_opts->{-suffix});
  		$export->[1] = \%sub_opts;
  	}
  	return @$optlist;
  }
  
  # Given a tag name, looks it up in %EXPORT_TAGS and returns the list of
  # associated functions. The default implementation magically handles tags
  # "all" and "default". The default implementation interprets any undefined
  # tags as being global options.
  # 
  sub _exporter_expand_tag
  {
  	no strict qw(refs);
  	
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	my $tags  = \%{"$class\::EXPORT_TAGS"};
  	
  	return $class->_exporter_merge_opts($value, $globals, $tags->{$name}->($class, @_))
  		if ref($tags->{$name}) eq q(CODE);
  	
  	return $class->_exporter_merge_opts($value, $globals, @{$tags->{$name}})
  		if exists $tags->{$name};
  	
  	return $class->_exporter_merge_opts($value, $globals, @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"})
  		if $name eq 'all';
  	
  	return $class->_exporter_merge_opts($value, $globals, @{"$class\::EXPORT"})
  		if $name eq 'default';
  	
  	$globals->{$name} = $value || 1;
  	return;
  }
  
  # Given a regexp-like string, looks it up in @EXPORT_OK and returns the
  # list of matching functions.
  # 
  sub _exporter_expand_regexp
  {
  	no strict qw(refs);
  	our %TRACKED;
  	
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	my $compiled = eval("qr$name");
  	
  	my @possible = $globals->{is_unimport}
  		? keys( %{$TRACKED{$class}{$globals->{into}}} )
  		: @{"$class\::EXPORT_OK"};
  	
  	$class->_exporter_merge_opts($value, $globals, grep /$compiled/, @possible);
  }
  
  # Helper for _exporter_expand_sub. Returns a regexp matching all subs in
  # the exporter package which are available for export.
  #
  sub _exporter_permitted_regexp
  {
  	no strict qw(refs);
  	my $class = shift;
  	my $re = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"};
  	qr{^(?:$re)$}ms;
  }
  
  # Given a sub name, returns a hash of subs to install (usually just one sub).
  # Keys are sub names, values are coderefs.
  #
  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $permitted) = @_;
  	$permitted ||= $class->_exporter_permitted_regexp($globals);
  	
  	no strict qw(refs);
  	
  	if ($name =~ $permitted)
  	{
  		my $generator = $class->can("_generate_$name");
  		return $name => $class->$generator($name, $value, $globals) if $generator;
  		
  		my $sub = $class->can($name);
  		return $name => $sub if $sub;
  	}
  	
  	$class->_exporter_fail(@_);
  }
  
  # Called by _exporter_expand_sub if it is unable to generate a key-value
  # pair for a sub.
  #
  sub _exporter_fail
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	return if $globals->{is_unimport};
  	_croak("Could not find sub '%s' exported by %s", $name, $class);
  }
  
  # Actually performs the installation of the sub into the target package. This
  # also handles renaming the sub.
  #
  sub _exporter_install_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;
  	
  	my $into      = $globals->{into};
  	my $installer = $globals->{installer} || $globals->{exporter};
  	
  	$name =
  		ref    $globals->{as} ? $globals->{as}->($name) :
  		ref    $value->{-as}  ? $value->{-as}->($name) :
  		exists $value->{-as}  ? $value->{-as} :
  		$name;
  	
  	return unless defined $name;
  	
  	unless (ref($name))
  	{
  		my ($prefix) = grep defined, $value->{-prefix}, $globals->{prefix}, q();
  		my ($suffix) = grep defined, $value->{-suffix}, $globals->{suffix}, q();
  		$name = "$prefix$name$suffix";
  	}
  	
  	return ($$name = $sym)         if ref($name) eq q(SCALAR);
  	return ($into->{$name} = $sym) if ref($into) eq q(HASH);
  	
  	no strict qw(refs);
  	
  	if (exists &{"$into\::$name"} and \&{"$into\::$name"} != $sym)
  	{
  		my ($level) = grep defined, $value->{-replace}, $globals->{replace}, q(0);
  		my $action = {
  			carp     => \&_carp,
  			0        => \&_carp,
  			''       => \&_carp,
  			warn     => \&_carp,
  			nonfatal => \&_carp,
  			croak    => \&_croak,
  			fatal    => \&_croak,
  			die      => \&_croak,
  		}->{$level} || sub {};
  		
  		$action->(
  			$action == \&_croak
  				? "Refusing to overwrite existing sub '%s::%s' with sub '%s' exported by %s"
  				: "Overwriting existing sub '%s::%s' with sub '%s' exported by %s",
  			$into,
  			$name,
  			$_[0],
  			$class,
  		);
  	}
  	
  	our %TRACKED;
  	$TRACKED{$class}{$into}{$name} = $sym;
  	
  	no warnings qw(prototype);
  	$installer
  		? $installer->($globals, [$name, $sym])
  		: (*{"$into\::$name"} = $sym);
  }
  
  sub _exporter_uninstall_sub
  {
  	our %TRACKED;
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;
  	my $into = $globals->{into};
  	ref $into and return;
  	
  	no strict qw(refs);
  	
  	# Cowardly refuse to uninstall a sub that differs from the one
  	# we installed!
  	my $our_coderef = $TRACKED{$class}{$into}{$name};
  	my $cur_coderef = exists(&{"$into\::$name"}) ? \&{"$into\::$name"} : -1;
  	return unless $our_coderef == $cur_coderef;
  	
  	my $stash     = \%{"$into\::"};
  	my $old       = delete $stash->{$name};
  	my $full_name = join('::', $into, $name);
  	foreach my $type (qw(SCALAR HASH ARRAY IO)) # everything but the CODE
  	{
  		next unless defined(*{$old}{$type});
  		*$full_name = *{$old}{$type};
  	}
  	
  	delete $TRACKED{$class}{$into}{$name};
  }
  
  sub mkopt
  {
  	my $in = shift or return [];
  	my @out;
  	
  	$in = [map(($_ => ref($in->{$_}) ? $in->{$_} : ()), sort keys %$in)]
  		if ref($in) eq q(HASH);
  	
  	for (my $i = 0; $i < @$in; $i++)
  	{
  		my $k = $in->[$i];
  		my $v;
  		
  		($i == $#$in)         ? ($v = undef) :
  		!defined($in->[$i+1]) ? (++$i, ($v = undef)) :
  		!ref($in->[$i+1])     ? ($v = undef) :
  		($v = $in->[++$i]);
  		
  		push @out, [ $k => $v ];
  	}
  	
  	\@out;
  }
  
  sub mkopt_hash
  {
  	my $in  = shift or return;
  	my %out = map +($_->[0] => $_->[1]), @{ mkopt($in) };
  	\%out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords frobnicate greps regexps
  
  =head1 NAME
  
  Exporter::Tiny - an exporter with the features of Sub::Exporter but only core dependencies
  
  =head1 SYNOPSIS
  
     package MyUtils;
     use base "Exporter::Tiny";
     our @EXPORT = qw(frobnicate);
     sub frobnicate { ... }
     1;
  
     package MyScript;
     use MyUtils "frobnicate" => { -as => "frob" };
     print frob(42);
     exit;
  
  =head1 DESCRIPTION
  
  Exporter::Tiny supports many of Sub::Exporter's external-facing features
  including renaming imported functions with the C<< -as >>, C<< -prefix >> and
  C<< -suffix >> options; explicit destinations with the C<< into >> option;
  and alternative installers with the C<< installer >> option. But it's written
  in only about 40% as many lines of code and with zero non-core dependencies.
  
  Its internal-facing interface is closer to Exporter.pm, with configuration
  done through the C<< @EXPORT >>, C<< @EXPORT_OK >> and C<< %EXPORT_TAGS >>
  package variables.
  
  If you are trying to B<write> a module that inherits from Exporter::Tiny,
  then look at:
  
  =over
  
  =item *
  
  L<Exporter::Tiny::Manual::QuickStart>
  
  =item *
  
  L<Exporter::Tiny::Manual::Exporting>
  
  =back
  
  If you are trying to B<use> a module that inherits from Exporter::Tiny,
  then look at:
  
  =over
  
  =item *
  
  L<Exporter::Tiny::Manual::Importing>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Exporter-Tiny>.
  
  =head1 SUPPORT
  
  B<< IRC: >> support is available through in the I<< #moops >> channel
  on L<irc.perl.org|http://www.irc.perl.org/channels.html>.
  
  =head1 SEE ALSO
  
  Simplified interface to this module: L<Exporter::Shiny>.
  
  Other interesting exporters: L<Sub::Exporter>, L<Exporter>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EXPORTER_TINY

$fatpacked{"File/ShareDir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SHAREDIR';
  package File::ShareDir;
  
  =pod
  
  =head1 NAME
  
  File::ShareDir - Locate per-dist and per-module shared files
  
  =begin html
  
  <a href="https://travis-ci.org/perl5-utils/File-ShareDir"><img src="https://travis-ci.org/perl5-utils/File-ShareDir.svg?branch=master" alt="Travis CI"/></a>
  <a href='https://coveralls.io/github/perl5-utils/File-ShareDir?branch=master'><img src='https://coveralls.io/repos/github/perl5-utils/File-ShareDir/badge.svg?branch=master' alt='Coverage Status' /></a>
  <a href="https://saythanks.io/to/rehsack"><img src="https://img.shields.io/badge/Say%20Thanks-!-1EAEDB.svg" alt="Say Thanks" /></a>
  
  =end html
  
  =head1 SYNOPSIS
  
    use File::ShareDir ':ALL';
    
    # Where are distribution-level shared data files kept
    $dir = dist_dir('File-ShareDir');
    
    # Where are module-level shared data files kept
    $dir = module_dir('File::ShareDir');
    
    # Find a specific file in our dist/module shared dir
    $file = dist_file(  'File-ShareDir',  'file/name.txt');
    $file = module_file('File::ShareDir', 'file/name.txt');
    
    # Like module_file, but search up the inheritance tree
    $file = class_file( 'Foo::Bar', 'file/name.txt' );
  
  =head1 DESCRIPTION
  
  The intent of L<File::ShareDir> is to provide a companion to
  L<Class::Inspector> and L<File::HomeDir>, modules that take a
  process that is well-known by advanced Perl developers but gets a
  little tricky, and make it more available to the larger Perl community.
  
  Quite often you want or need your Perl module (CPAN or otherwise)
  to have access to a large amount of read-only data that is stored
  on the file-system at run-time.
  
  On a linux-like system, this would be in a place such as /usr/share,
  however Perl runs on a wide variety of different systems, and so
  the use of any one location is unreliable.
  
  Perl provides a little-known method for doing this, but almost
  nobody is aware that it exists. As a result, module authors often
  go through some very strange ways to make the data available to
  their code.
  
  The most common of these is to dump the data out to an enormous
  Perl data structure and save it into the module itself. The
  result are enormous multi-megabyte .pm files that chew up a
  lot of memory needlessly.
  
  Another method is to put the data "file" after the __DATA__ compiler
  tag and limit yourself to access as a filehandle.
  
  The problem to solve is really quite simple.
  
    1. Write the data files to the system at install time.
    
    2. Know where you put them at run-time.
  
  Perl's install system creates an "auto" directory for both
  every distribution and for every module file.
  
  These are used by a couple of different auto-loading systems
  to store code fragments generated at install time, and various
  other modules written by the Perl "ancient masters".
  
  But the same mechanism is available to any dist or module to
  store any sort of data.
  
  =head2 Using Data in your Module
  
  C<File::ShareDir> forms one half of a two part solution.
  
  Once the files have been installed to the correct directory,
  you can use C<File::ShareDir> to find your files again after
  the installation.
  
  For the installation half of the solution, see L<File::ShareDir::Install>
  and its C<install_share> directive.
  
  Using L<File::ShareDir::Install> together with L<File::ShareDir>
  allows one to rely on the files in appropriate C<dist_dir()>
  or C<module_dir()> in development phase, too.
  
  =head1 FUNCTIONS
  
  C<File::ShareDir> provides four functions for locating files and
  directories.
  
  For greater maintainability, none of these are exported by default
  and you are expected to name the ones you want at use-time, or provide
  the C<':ALL'> tag. All of the following are equivalent.
  
    # Load but don't import, and then call directly
    use File::ShareDir;
    $dir = File::ShareDir::dist_dir('My-Dist');
    
    # Import a single function
    use File::ShareDir 'dist_dir';
    dist_dir('My-Dist');
    
    # Import all the functions
    use File::ShareDir ':ALL';
    dist_dir('My-Dist');
  
  All of the functions will check for you that the dir/file actually
  exists, and that you have read permissions, or they will throw an
  exception.
  
  =cut
  
  use 5.005;
  use strict;
  use warnings;
  
  use base ('Exporter');
  use constant IS_MACOS => !!($^O eq 'MacOS');
  use constant IS_WIN32 => !!($^O eq 'MSWin32');
  
  use Carp             ();
  use Exporter         ();
  use File::Spec       ();
  use Class::Inspector ();
  
  our %DIST_SHARE;
  our %MODULE_SHARE;
  
  our @CARP_NOT;
  our @EXPORT_OK = qw{
    dist_dir
    dist_file
    module_dir
    module_file
    class_dir
    class_file
  };
  our %EXPORT_TAGS = (
      ALL => [@EXPORT_OK],
  );
  our $VERSION = '1.116';
  
  #####################################################################
  # Interface Functions
  
  =pod
  
  =head2 dist_dir
  
    # Get a distribution's shared files directory
    my $dir = dist_dir('My-Distribution');
  
  The C<dist_dir> function takes a single parameter of the name of an
  installed (CPAN or otherwise) distribution, and locates the shared
  data directory created at install time for it.
  
  Returns the directory path as a string, or dies if it cannot be
  located or is not readable.
  
  =cut
  
  sub dist_dir
  {
      my $dist = _DIST(shift);
      my $dir;
  
      # Try the new version, then fall back to the legacy version
      $dir = _dist_dir_new($dist) || _dist_dir_old($dist);
  
      return $dir if defined $dir;
  
      # Ran out of options
      Carp::croak("Failed to find share dir for dist '$dist'");
  }
  
  sub _dist_dir_new
  {
      my $dist = shift;
  
      return $DIST_SHARE{$dist} if exists $DIST_SHARE{$dist};
  
      # Create the subpath
      my $path = File::Spec->catdir('auto', 'share', 'dist', $dist);
  
      # Find the full dir within @INC
      return _search_inc_path($path);
  }
  
  sub _dist_dir_old
  {
      my $dist = shift;
  
      # Create the subpath
      my $path = File::Spec->catdir('auto', split(/-/, $dist),);
  
      # Find the full dir within @INC
      return _search_inc_path($path);
  }
  
  =pod
  
  =head2 module_dir
  
    # Get a module's shared files directory
    my $dir = module_dir('My::Module');
  
  The C<module_dir> function takes a single parameter of the name of an
  installed (CPAN or otherwise) module, and locates the shared data
  directory created at install time for it.
  
  In order to find the directory, the module B<must> be loaded when
  calling this function.
  
  Returns the directory path as a string, or dies if it cannot be
  located or is not readable.
  
  =cut
  
  sub module_dir
  {
      my $module = _MODULE(shift);
  
      return $MODULE_SHARE{$module} if exists $MODULE_SHARE{$module};
  
      # Try the new version first, then fall back to the legacy version
      return _module_dir_new($module) || _module_dir_old($module);
  }
  
  sub _module_dir_new
  {
      my $module = shift;
  
      # Create the subpath
      my $path = File::Spec->catdir('auto', 'share', 'module', _module_subdir($module),);
  
      # Find the full dir within @INC
      return _search_inc_path($path);
  }
  
  sub _module_dir_old
  {
      my $module = shift;
      my $short  = Class::Inspector->filename($module);
      my $long   = Class::Inspector->loaded_filename($module);
      $short =~ tr{/}{:}   if IS_MACOS;
      $short =~ tr{\\} {/} if IS_WIN32;
      $long =~ tr{\\} {/}  if IS_WIN32;
      substr($short, -3, 3, '');
      $long =~ m/^(.*)\Q$short\E\.pm\z/s or Carp::croak("Failed to find base dir");
      my $dir = File::Spec->catdir("$1", 'auto', $short);
  
      -d $dir or Carp::croak("Directory '$dir': No such directory");
      -r $dir or Carp::croak("Directory '$dir': No read permission");
  
      return $dir;
  }
  
  =pod
  
  =head2 dist_file
  
    # Find a file in our distribution shared dir
    my $dir = dist_file('My-Distribution', 'file/name.txt');
  
  The C<dist_file> function takes two parameters of the distribution name
  and file name, locates the dist directory, and then finds the file within
  it, verifying that the file actually exists, and that it is readable.
  
  The filename should be a relative path in the format of your local
  filesystem. It will simply added to the directory using L<File::Spec>'s
  C<catfile> method.
  
  Returns the file path as a string, or dies if the file or the dist's
  directory cannot be located, or the file is not readable.
  
  =cut
  
  sub dist_file
  {
      my $dist = _DIST(shift);
      my $file = _FILE(shift);
  
      # Try the new version first, in doubt hand off to the legacy version
      my $path = _dist_file_new($dist, $file) || _dist_file_old($dist, $file);
      $path or Carp::croak("Failed to find shared file '$file' for dist '$dist'");
  
      -f $path or Carp::croak("File '$path': No such file");
      -r $path or Carp::croak("File '$path': No read permission");
  
      return $path;
  }
  
  sub _dist_file_new
  {
      my $dist = shift;
      my $file = shift;
  
      # If it exists, what should the path be
      my $dir = _dist_dir_new($dist);
      return undef unless defined $dir;
      my $path = File::Spec->catfile($dir, $file);
  
      # Does the file exist
      return undef unless -e $path;
  
      return $path;
  }
  
  sub _dist_file_old
  {
      my $dist = shift;
      my $file = shift;
  
      # If it exists, what should the path be
      my $dir = _dist_dir_old($dist);
      return undef unless defined $dir;
      my $path = File::Spec->catfile($dir, $file);
  
      # Does the file exist
      return undef unless -e $path;
  
      return $path;
  }
  
  =pod
  
  =head2 module_file
  
    # Find a file in our module shared dir
    my $dir = module_file('My::Module', 'file/name.txt');
  
  The C<module_file> function takes two parameters of the module name
  and file name. It locates the module directory, and then finds the file
  within it, verifying that the file actually exists, and that it is readable.
  
  In order to find the directory, the module B<must> be loaded when
  calling this function.
  
  The filename should be a relative path in the format of your local
  filesystem. It will simply added to the directory using L<File::Spec>'s
  C<catfile> method.
  
  Returns the file path as a string, or dies if the file or the dist's
  directory cannot be located, or the file is not readable.
  
  =cut
  
  sub module_file
  {
      my $module = _MODULE(shift);
      my $file   = _FILE(shift);
      my $dir    = module_dir($module);
      my $path   = File::Spec->catfile($dir, $file);
  
      -e $path or Carp::croak("File '$path' does not exist in module dir");
      -r $path or Carp::croak("File '$path': No read permission");
  
      return $path;
  }
  
  =pod
  
  =head2 class_file
  
    # Find a file in our module shared dir, or in our parent class
    my $dir = class_file('My::Module', 'file/name.txt');
  
  The C<module_file> function takes two parameters of the module name
  and file name. It locates the module directory, and then finds the file
  within it, verifying that the file actually exists, and that it is readable.
  
  In order to find the directory, the module B<must> be loaded when
  calling this function.
  
  The filename should be a relative path in the format of your local
  filesystem. It will simply added to the directory using L<File::Spec>'s
  C<catfile> method.
  
  If the file is NOT found for that module, C<class_file> will scan up
  the module's @ISA tree, looking for the file in all of the parent
  classes.
  
  This allows you to, in effect, "subclass" shared files.
  
  Returns the file path as a string, or dies if the file or the dist's
  directory cannot be located, or the file is not readable.
  
  =cut
  
  sub class_file
  {
      my $module = _MODULE(shift);
      my $file   = _FILE(shift);
  
      # Get the super path ( not including UNIVERSAL )
      # Rather than using Class::ISA, we'll use an inlined version
      # that implements the same basic algorithm.
      my @path  = ();
      my @queue = ($module);
      my %seen  = ($module => 1);
      while (my $cl = shift @queue)
      {
          push @path, $cl;
          no strict 'refs';    ## no critic (TestingAndDebugging::ProhibitNoStrict)
          unshift @queue, grep { !$seen{$_}++ }
            map { my $s = $_; $s =~ s/^::/main::/; $s =~ s/\'/::/g; $s } (@{"${cl}::ISA"});
      }
  
      # Search up the path
      foreach my $class (@path)
      {
          my $dir = eval { module_dir($class); };
          next if $@;
          my $path = File::Spec->catfile($dir, $file);
          -e $path or next;
          -r $path or Carp::croak("File '$file' cannot be read, no read permissions");
          return $path;
      }
      Carp::croak("File '$file' does not exist in class or parent shared files");
  }
  
  ## no critic (BuiltinFunctions::ProhibitStringyEval)
  if (eval "use List::MoreUtils 0.428; 1;")
  {
      List::MoreUtils->import("firstres");
  }
  else
  {
      ## no critic (ErrorHandling::RequireCheckingReturnValueOfEval)
      eval <<'END_OF_BORROWED_CODE';
  sub firstres (&@)
  {
      my $test = shift;
      foreach (@_)
      {
          my $testval = $test->();
          $testval and return $testval;
      }
      return undef;
  }
  END_OF_BORROWED_CODE
  }
  
  #####################################################################
  # Support Functions
  
  sub _search_inc_path
  {
      my $path = shift;
  
      # Find the full dir within @INC
      my $dir = firstres(
          sub {
              my $d;
              $d = File::Spec->catdir($_, $path) if defined _STRING($_);
              defined $d and -d $d ? $d : 0;
          },
          @INC
      ) or return;
  
      Carp::croak("Found directory '$dir', but no read permissions") unless -r $dir;
  
      return $dir;
  }
  
  sub _module_subdir
  {
      my $module = shift;
      $module =~ s/::/-/g;
      return $module;
  }
  
  ## no critic (BuiltinFunctions::ProhibitStringyEval)
  if (eval "use Params::Util 1.07; 1;")
  {
      Params::Util->import("_CLASS", "_STRING");
  }
  else
  {
      ## no critic (ErrorHandling::RequireCheckingReturnValueOfEval)
      eval <<'END_OF_BORROWED_CODE';
  # Inlined from Params::Util pure perl version
  sub _CLASS ($)
  {
      return (defined $_[0] and !ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  
  sub _STRING ($)
  {
      (defined $_[0] and ! ref $_[0] and length($_[0])) ? $_[0] : undef;
  }
  END_OF_BORROWED_CODE
  }
  
  # Maintainer note: The following private functions are used by
  #                  File::ShareDir::PAR. (It has to or else it would have to copy&fork)
  #                  So if you significantly change or even remove them, please
  #                  notify the File::ShareDir::PAR maintainer(s). Thank you!
  
  # Matches a valid distribution name
  ### This is a total guess at this point
  sub _DIST    ## no critic (Subroutines::RequireArgUnpacking)
  {
      defined _STRING($_[0]) and $_[0] =~ /^[a-z0-9+_-]+$/is and return $_[0];
      Carp::croak("Not a valid distribution name");
  }
  
  # A valid and loaded module name
  sub _MODULE
  {
      my $module = _CLASS(shift) or Carp::croak("Not a valid module name");
      Class::Inspector->loaded($module) and return $module;
      Carp::croak("Module '$module' is not loaded");
  }
  
  # A valid file name
  sub _FILE
  {
      my $file = shift;
      _STRING($file) or Carp::croak("Did not pass a file name");
      File::Spec->file_name_is_absolute($file) and Carp::croak("Cannot use absolute file name '$file'");
      return $file;
  }
  
  1;
  
  =pod
  
  =head1 EXTENDING
  
  =head2 Overriding Directory Resolution
  
  C<File::ShareDir> has two convenience hashes for people who have advanced usage
  requirements of C<File::ShareDir> such as using uninstalled C<share>
  directories during development.
  
    #
    # Dist-Name => /absolute/path/for/DistName/share/dir
    #
    %File::ShareDir::DIST_SHARE
  
    #
    # Module::Name => /absolute/path/for/Module/Name/share/dir
    #
    %File::ShareDir::MODULE_SHARE
  
  Setting these values any time before the corresponding calls
  
    dist_dir('Dist-Name')
    dist_file('Dist-Name','some/file');
  
    module_dir('Module::Name');
    module_file('Module::Name','some/file');
  
  Will override the base directory for resolving those calls.
  
  An example of where this would be useful is in a test for a module that
  depends on files installed into a share directory, to enable the tests
  to use the development copy without needing to install them first.
  
    use File::ShareDir;
    use Cwd qw( getcwd );
    use File::Spec::Functions qw( rel2abs catdir );
  
    $File::ShareDir::MODULE_SHARE{'Foo::Module'} = rel2abs(catfile(getcwd,'share'));
  
    use Foo::Module;
  
    # interal calls in Foo::Module to module_file('Foo::Module','bar') now resolves to
    # the source trees share/ directory instead of something in @INC
  
  =head1 SUPPORT
  
  Bugs should always be submitted via the CPAN request tracker, see below.
  
  You can find documentation for this module with the perldoc command.
  
      perldoc File::ShareDir
  
  You can also look for information at:
  
  =over 4
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=File-ShareDir>
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/File-ShareDir>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/s/File-ShareDir>
  
  =item * CPAN Search
  
  L<http://search.cpan.org/dist/File-ShareDir/>
  
  =back
  
  =head2 Where can I go for other help?
  
  If you have a bug report, a patch or a suggestion, please open a new
  report ticket at CPAN (but please check previous reports first in case
  your issue has already been addressed).
  
  Report tickets should contain a detailed description of the bug or
  enhancement request and at least an easily verifiable way of
  reproducing the issue or fix. Patches are always welcome, too.
  
  =head2 Where can I go for help with a concrete version?
  
  Bugs and feature requests are accepted against the latest version
  only. To get patches for earlier versions, you need to get an
  agreement with a developer of your choice - who may or not report the
  issue and a suggested fix upstream (depends on the license you have
  chosen).
  
  =head2 Business support and maintenance
  
  For business support you can contact the maintainer via his CPAN
  email address. Please keep in mind that business support is neither
  available for free nor are you eligible to receive any support
  based on the license distributed with this package.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head2 MAINTAINER
  
  Jens Rehsack E<lt>rehsack@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::ShareDir::Install>,
  L<File::ConfigDir>, L<File::HomeDir>,
  L<Module::Install>, L<Module::Install::Share>,
  L<File::ShareDir::PAR>, L<Dist::Zilla::Plugin::ShareDir>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy,
  Copyright 2014 - 2018 Jens Rehsack.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_SHAREDIR

$fatpacked{"Getopt/Long/Descriptive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG_DESCRIPTIVE';
  use strict;
  use warnings;
  package Getopt::Long::Descriptive;
  # ABSTRACT: Getopt::Long, but simpler and more powerful
  $Getopt::Long::Descriptive::VERSION = '0.102';
  use Carp qw(carp croak);
  use File::Basename ();
  use Getopt::Long 2.33;
  use List::Util qw(first);
  use Params::Validate 0.97 qw(:all);
  use Scalar::Util ();
  
  use Getopt::Long::Descriptive::Opts;
  use Getopt::Long::Descriptive::Usage;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   use Getopt::Long::Descriptive;
  #pod
  #pod   my ($opt, $usage) = describe_options(
  #pod     'my-program %o <some-arg>',
  #pod     [ 'server|s=s', "the server to connect to", { required => 1  } ],
  #pod     [ 'port|p=i',   "the port to connect to",   { default  => 79 } ],
  #pod     [],
  #pod     [ 'verbose|v',  "print extra stuff"            ],
  #pod     [ 'help',       "print usage message and exit", { shortcircuit => 1 } ],
  #pod   );
  #pod
  #pod   print($usage->text), exit if $opt->help;
  #pod
  #pod   Client->connect( $opt->server, $opt->port );
  #pod
  #pod   print "Connected!\n" if $opt->verbose;
  #pod
  #pod ...and running C<my-program --help> will produce:
  #pod
  #pod   my-program [-psv] [long options...] <some-arg>
  #pod     -s --server     the server to connect to
  #pod     -p --port       the port to connect to
  #pod
  #pod     -v --verbose    print extra stuff
  #pod     --help          print usage message and exit
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod Getopt::Long::Descriptive is yet another Getopt library.  It's built atop
  #pod Getopt::Long, and gets a lot of its features, but tries to avoid making you
  #pod think about its huge array of options.
  #pod
  #pod It also provides usage (help) messages, data validation, and a few other useful
  #pod features.
  #pod
  #pod =head1 FUNCTIONS
  #pod
  #pod Getopt::Long::Descriptive only exports one routine by default:
  #pod C<describe_options>.  All GLD's exports are exported by L<Sub::Exporter>.
  #pod
  #pod =head2 describe_options
  #pod
  #pod   my ($opt, $usage) = describe_options($usage_desc, @opt_spec, \%arg);
  #pod
  #pod This routine inspects C<@ARGV> for options that match the supplied spec. If all
  #pod the options are valid then it returns the options given and an object for
  #pod generating usage messages; if not then it dies with an explanation of what was
  #pod wrong and a usage message.
  #pod
  #pod The C<$opt> object will be a dynamically-generated subclass of
  #pod L<Getopt::Long::Descriptive::Opts>.  In brief, each of the options in
  #pod C<@opt_spec> becomes an accessor method on the object, using the first-given
  #pod name, with dashes converted to underscores.  For more information, see the
  #pod documentation for the Opts class.
  #pod
  #pod The C<$usage> object will be a L<Getopt::Long::Descriptive::Usage> object,
  #pod which provides a C<text> method to get the text of the usage message and C<die>
  #pod to die with it.  For more methods and options, consults the documentation for
  #pod the Usage class.
  #pod
  #pod =head3 $usage_desc
  #pod
  #pod The C<$usage_desc> parameter to C<describe_options> is a C<sprintf>-like string
  #pod that is used in generating the first line of the usage message.  It's a
  #pod one-line summary of how the command is to be invoked.  A typical usage
  #pod description might be:
  #pod
  #pod   $usage_desc = "%c %o <source> <desc>";
  #pod
  #pod C<%c> will be replaced with what Getopt::Long::Descriptive thinks is the
  #pod program name (it's computed from C<$0>, see L</prog_name>).
  #pod
  #pod C<%o> will be replaced with a list of the short options, as well as the text
  #pod "[long options...]" if any have been defined.
  #pod
  #pod The rest of the usage description can be used to summarize what arguments are
  #pod expected to follow the program's options, and is entirely free-form.
  #pod
  #pod Literal C<%> characters will need to be written as C<%%>, just like with
  #pod C<sprintf>.
  #pod
  #pod =head3 @opt_spec
  #pod
  #pod The C<@opt_spec> part of the args to C<describe_options> is used to configure
  #pod option parsing and to produce the usage message.  Each entry in the list is an
  #pod arrayref describing one option, like this:
  #pod
  #pod   @opt_spec = (
  #pod     [ "verbose|V" => "be noisy"       ],
  #pod     [ "logfile=s" => "file to log to" ],
  #pod   );
  #pod
  #pod The first value in the arrayref is a Getopt::Long-style option specification.
  #pod In brief, they work like this:  each one is a pipe-delimited list of names,
  #pod optionally followed by a type declaration.  Type declarations are '=x' or ':x',
  #pod where C<=> means a value is required and C<:> means it is optional.  I<x> may
  #pod be 's' to indicate a string is required, 'i' for an integer, or 'f' for a
  #pod number with a fractional part.  The type spec may end in C<@> to indicate that
  #pod the option may appear multiple times.
  #pod
  #pod For more information on how these work, see the L<Getopt::Long> documentation.
  #pod
  #pod The first name given should be the canonical name, as it will be used as the
  #pod accessor method on the C<$opt> object.  Dashes in the name will be converted to
  #pod underscores, and all letters will be lowercased.  For this reason, all options
  #pod should generally have a long-form name.
  #pod
  #pod The second value in the arrayref is a description of the option, for use in the
  #pod usage message.
  #pod
  #pod =head4 Special Option Specifications
  #pod
  #pod If the option specification (arrayref) is empty, it will have no effect other
  #pod than causing a blank line to appear in the usage message.
  #pod
  #pod If the option specification contains only one element, it will be printed in
  #pod the usage message with no other effect.
  #pod
  #pod If the option specification contains a third element, it adds extra constraints
  #pod or modifiers to the interpretation and validation of the value.  These are the
  #pod keys that may be present in that hashref, and how they behave:
  #pod
  #pod =over 4
  #pod
  #pod =item implies
  #pod
  #pod   implies => 'bar'
  #pod   implies => [qw(foo bar)]
  #pod   implies => { foo => 1, bar => 2 }
  #pod
  #pod If option I<A> has an "implies" entry, then if I<A> is given, other options
  #pod will be enabled.  The value may be a single option to set, an arrayref of
  #pod options to set, or a hashref of options to set to specific values.
  #pod
  #pod =item required
  #pod
  #pod   required => 1
  #pod
  #pod If an option is required, failure to provide the option will result in
  #pod C<describe_options> printing the usage message and exiting.
  #pod
  #pod =item hidden
  #pod
  #pod   hidden => 1
  #pod
  #pod This option will not show up in the usage text.
  #pod
  #pod You can achieve the same behavior by using the string "hidden" for the option's
  #pod description.
  #pod
  #pod =item one_of
  #pod
  #pod   one_of => \@subopt_specs
  #pod
  #pod This is useful for a group of options that are related.  Each option
  #pod spec is added to the list for normal parsing and validation.
  #pod
  #pod Your option name will end up with a value of the name of the
  #pod option that was chosen.  For example, given the following spec:
  #pod
  #pod   [ "mode" => hidden => { one_of => [
  #pod     [ "get|g"  => "get the value" ],
  #pod     [ "set|s"  => "set the value" ],
  #pod     [ "delete" => "delete it" ],
  #pod   ] } ],
  #pod
  #pod No usage text for 'mode' will be displayed, but text for get, set, and delete
  #pod will be displayed.
  #pod
  #pod If more than one of get, set, or delete is given, an error will be thrown.
  #pod
  #pod So, given the C<@opt_spec> above, and an C<@ARGV> of C<('--get')>, the
  #pod following would be true:
  #pod
  #pod   $opt->get == 1;
  #pod
  #pod   $opt->mode eq 'get';
  #pod
  #pod B<Note>: C<get> would not be set if C<mode> defaulted to 'get' and no arguments
  #pod were passed in.
  #pod
  #pod Even though the option sub-specs for C<one_of> are meant to be 'first
  #pod class' specs, some options don't make sense with them, e.g. C<required>.
  #pod
  #pod As a further shorthand, you may specify C<one_of> options using this form:
  #pod
  #pod   [ mode => \@option_specs, \%constraints ]
  #pod
  #pod
  #pod =item shortcircuit
  #pod
  #pod   shortcircuit => 1
  #pod
  #pod If this option is present no other options will be returned.  Other
  #pod options present will be checked for proper types, but I<not> for
  #pod constraints.  This provides a way of specifying C<--help> style options.
  #pod
  #pod =item Params::Validate
  #pod
  #pod In addition, any constraint understood by Params::Validate may be used.
  #pod
  #pod For example, to accept positive integers:
  #pod
  #pod   [ 'max-iterations=i', "maximum number of iterations",
  #pod     { callbacks => { positive => sub { shift() > 0 } } } ],
  #pod
  #pod (Internally, all constraints are translated into Params::Validate options or
  #pod callbacks.)
  #pod
  #pod =back
  #pod
  #pod =head3 %arg
  #pod
  #pod The C<%arg> to C<describe_options> is optional.  If the last parameter is a
  #pod hashref, it contains extra arguments to modify the way C<describe_options>
  #pod works.  Valid arguments are:
  #pod
  #pod   getopt_conf   - an arrayref of strings, passed to Getopt::Long::Configure
  #pod   show_defaults - a boolean which controls whether an option's default
  #pod                   value (if applicable) is shown as part of the usage message
  #pod                   (for backward compatibility this defaults to false)
  #pod
  #pod =head2 prog_name
  #pod
  #pod This routine, exported on demand, returns the basename of C<$0>, grabbed at
  #pod compile-time.  You can override this guess by calling C<prog_name($string)>
  #pod yourself.
  #pod
  #pod =head1 OTHER EXPORTS
  #pod
  #pod =head2 C<-types>
  #pod
  #pod Any of the Params::Validate type constants (C<SCALAR>, etc.) can be imported as
  #pod well.  You can get all of them at once by importing C<-types>.
  #pod
  #pod =head2 C<-all>
  #pod
  #pod This import group will import C<-type>, C<describe_options>, and C<prog_name>.
  #pod
  #pod =cut
  
  my $prog_name;
  sub prog_name { @_ ? ($prog_name = shift) : $prog_name }
  
  BEGIN {
    # grab this before someone decides to change it
    prog_name(File::Basename::basename($0));
  }
  
  use Sub::Exporter::Util ();
  use Sub::Exporter 0.972 -setup => {
    exports => [
      describe_options => \'_build_describe_options',
      q(prog_name),
      @{ $Params::Validate::EXPORT_TAGS{types} }
    ],
    groups  => [
      default => [ qw(describe_options) ],
      types   => $Params::Validate::EXPORT_TAGS{types},
    ],
  };
  
  my %CONSTRAINT = (
    implies  => \&_mk_implies,
    required => { optional => 0 },
    only_one => \&_mk_only_one,
  );
  
  our $MungeOptions = 1;
  
  sub _nohidden {
    return grep { ! $_->{constraint}->{hidden} } @_;
  }
  
  sub _expand {
    my @expanded;
  
    for my $opt (@_) {
      push @expanded, {
        spec       => $opt->[0] || '',
        desc       => @$opt > 1 ? $opt->[1] : 'spacer',
        constraint => $opt->[2] || {},
  
        # if @$_ is 0 then we got [], a spacer
        name       => @$opt ? _munge((split /[:=|!+]/, $opt->[0] || '')[0]) : '',
      };
    }
  
    return @expanded;
  }
  
  my %HIDDEN = (
    hidden => 1,
  );
  
  my $SPEC_RE = qr{(?:[:=][0-9\w\+]+[%@]?(\{[0-9]*,[0-9]*\})?|[!+])$};
  sub _strip_assignment {
    my ($self, $str) = @_;
  
    (my $copy = $str) =~ s{$SPEC_RE}{};
  
    if (wantarray) {
        my $len = length $copy;
        my $assignment = substr $str, $len;
        if (!defined($assignment)) {
            $assignment = '';
        }
        return ($copy, $assignment);
    }
    return $copy;
  }
  
  # This is here only to deal with people who were calling this fully-qualified
  # without importing.  Sucks to them!  -- rjbs, 2009-08-21
  sub describe_options {
    my $sub = __PACKAGE__->_build_describe_options(describe_options => {} => {});
    $sub->(@_);
  }
  
  sub usage_class { 'Getopt::Long::Descriptive::Usage' }
  
  sub _build_describe_options {
    my ($class) = @_;
  
    sub {
      my $format = shift;
      my $arg    = (ref $_[-1] and ref $_[-1] eq 'HASH') ? pop @_ : {};
      my @opts;
  
      my %parent_of;
  
      # special casing
      # wish we had real loop objects
      my %method_map;
      for my $opt (_expand(@_)) {
        $method_map{ $opt->{name} } = undef unless $opt->{desc} eq 'spacer';
  
        if (ref($opt->{desc}) eq 'ARRAY') {
          $opt->{constraint}->{one_of} = delete $opt->{desc};
          $opt->{desc} = 'hidden';
        }
  
        if ($HIDDEN{$opt->{desc}}) {
          $opt->{constraint}->{hidden}++;
        }
  
        if ($opt->{constraint}->{one_of}) {
          for my $one_opt (_expand(
            @{delete $opt->{constraint}->{one_of}}
          )) {
            $parent_of{$one_opt->{name}} = $opt->{name};
            $one_opt->{constraint}->{implies}
              ->{$opt->{name}} = $one_opt->{name};
            for my $wipe (qw(required default)) {
              if ($one_opt->{constraint}->{$wipe}) {
                carp "'$wipe' constraint does not make sense in sub-option";
                delete $one_opt->{constraint}->{$wipe};
              }
            }
            $one_opt->{constraint}->{one_of} = $opt->{name};
            push @opts, $one_opt;
          }
        }
  
        if ($opt->{constraint}{shortcircuit}
          && exists $opt->{constraint}{default}
        ) {
          carp('option "' . $opt->{name} . q[": 'default' does not make sense for shortcircuit options]);
        }
  
        push @opts, $opt;
      }
  
      my @go_conf = @{ $arg->{getopt_conf} || $arg->{getopt} || [] };
      if ($arg->{getopt}) {
        warn "describe_options: 'getopt' is deprecated, please use 'getopt_conf' instead\n";
      }
  
      push @go_conf, "bundling" unless grep { /bundling/i } @go_conf;
      push @go_conf, "no_auto_help"  unless grep { /no_auto_help/i } @go_conf;
      push @go_conf, "no_ignore_case"
        unless grep { /no_ignore_case/i } @go_conf;
  
      # not entirely sure that all of this (until the Usage->new) shouldn't be
      # moved into Usage -- rjbs, 2009-08-19
  
      # all specs including hidden
      my @getopt_specs =
        map  { $_->{spec} }
        grep { $_->{desc} ne 'spacer' }
        @opts;
  
      my @specs =
        map  { $_->{spec} }
        grep { $_->{desc} ne 'spacer' }
        _nohidden(@opts);
  
      my $short = join q{},
        sort  { lc $a cmp lc $b or $a cmp $b }
        grep  { /^.$/ }
        map   { split /\|/ }
        map   { scalar __PACKAGE__->_strip_assignment($_) }
        @specs;
  
      my $long = grep /\b[^|]{2,}/, @specs;
  
      my %replace = (
        "%" => "%",
        "c" => prog_name,
        "o" => join(q{ },
          ($short ? "[-$short]" : ()),
          ($long  ? "[long options...]" : ())
        ),
      );
  
      (my $str = $format) =~ s<%(.)><
        defined $replace{$1}
        ? $replace{$1}
        : Carp::croak("unknown sequence %$1 in first argument to describe_options")
      >ge;
  
      $str =~ s/[\x20\t]{2,}/ /g;
  
      my $usage = $class->usage_class->new({
        options       => [ _nohidden(@opts) ],
        leader_text   => $str,
        show_defaults => $arg->{show_defaults},
      });
  
      Getopt::Long::Configure(@go_conf);
  
      my %return;
      $usage->die unless GetOptions(\%return, grep { length } @getopt_specs);
      my @given_keys = keys %return;
  
      for my $opt (keys %return) {
        my $newopt = _munge($opt);
        next if $newopt eq $opt;
        $return{$newopt} = delete $return{$opt};
      }
  
      # ensure that shortcircuit options are handled first
      for my $copt (
        sort {     ($b->{constraint}{shortcircuit} || 0)
               <=> ($a->{constraint}{shortcircuit} || 0)
             } grep { $_->{constraint} } @opts
      ) {
        delete $copt->{constraint}->{hidden};
        my $is_shortcircuit = delete $copt->{constraint}{shortcircuit};
        my $name = $copt->{name};
        my $new  = _validate_with(
          name   => $name,
          params => \%return,
          spec   => $copt->{constraint},
          opts   => \@opts,
          usage  => $usage,
          given_keys => \@given_keys,
          parent_of  => \%parent_of,
        );
        next unless (defined($new) || exists($return{$name}));
        $return{$name} = $new;
  
        if ($is_shortcircuit) {
          %return = ($name => $return{$name});
          last;
        }
      }
  
      my $opt_obj = Getopt::Long::Descriptive::Opts->___new_opt_obj({
        values => { %method_map, %return },
        given  => { map {; $_ => 1 } @given_keys },
      });
  
      return($opt_obj, $usage);
    }
  }
  
  sub _munge {
    my ($opt) = @_;
    return $opt unless $MungeOptions;
    $opt = lc($opt);
    $opt =~ tr/-/_/;
    return $opt;
  }
  
  sub _validate_with {
    my (%arg) = validate(@_, {
      name   => 1,
      params => 1,
      spec   => 1,
      opts   => 1,
      usage  => 1,
      given_keys => 1,
      parent_of  => 1,
    });
  
    my $spec = $arg{spec};
    my %pvspec;
    for my $ct (keys %{$spec}) {
      if ($CONSTRAINT{$ct} and ref $CONSTRAINT{$ct} eq 'CODE') {
        $pvspec{callbacks} ||= {};
        $pvspec{callbacks} = {
          %{$pvspec{callbacks}},
          $CONSTRAINT{$ct}->(
            $arg{name},
            $spec->{$ct},
            $arg{params},
            $arg{opts},
          ),
        };
      } else {
        %pvspec = (
          %pvspec,
          $CONSTRAINT{$ct} ? %{$CONSTRAINT{$ct}} : ($ct => $spec->{$ct}),
        );
      }
    }
  
    $pvspec{optional} = 1 unless exists $pvspec{optional};
  
    # we need to implement 'default' by ourselves sometimes
    # because otherwise the implies won't be checked/executed
    # XXX this should be more generic -- we'll probably want
    # other callbacks to always run, too
    if (!defined($arg{params}{$arg{name}})
          && $pvspec{default}
            && $spec->{implies}) {
  
      $arg{params}{$arg{name}} = delete $pvspec{default};
    }
  
    my %p;
    my $ok = eval {
      %p = validate_with(
        params => [
          %{$arg{params}},
          '-given_keys', $arg{given_keys},
          '-parent_of',  $arg{parent_of},
        ],
        spec   => { $arg{name} => \%pvspec },
        allow_extra => 1,
        on_fail     => sub {
          my $fail_msg = shift;
          Getopt::Long::Descriptive::_PV_Error->throw($fail_msg);
        },
      );
      1;
    };
  
    if (! $ok) {
      my $error = $@;
      if (
        Scalar::Util::blessed($error)
        && $error->isa('Getopt::Long::Descriptive::_PV_Error')
      ) {
        $arg{usage}->die({ pre_text => $error->error . "\n" });
      }
  
      die $@;
    }
  
    return $p{$arg{name}};
  }
  
  # scalar:   single option = true
  # arrayref: multiple options = true
  # hashref:  single/multiple options = given values
  sub _norm_imply {
    my ($what) = @_;
  
    return { $what => 1 } unless my $ref = ref $what;
  
    return $what                      if $ref eq 'HASH';
    return { map { $_ => 1 } @$what } if $ref eq 'ARRAY';
  
    die "can't imply: $what";
  }
  
  sub _mk_implies {
    my $name = shift;
    my $what = _norm_imply(shift);
    my $param = shift;
    my $opts  = shift;
  
    for my $implied (keys %$what) {
      die("option specification for $name implies nonexistent option $implied\n")
        unless first { $_->{name} eq $implied } @$opts
    }
  
    my $whatstr = join(q{, }, map { "$_=$what->{$_}" } keys %$what);
  
    return "$name implies $whatstr" => sub {
      my ($pv_val, $rest) = @_;
  
      # negatable options will be 0 here, which is ok.
      return 1 unless defined $pv_val;
  
      while (my ($key, $val) = each %$what) {
        # Really, this should be called "-implies" and should include all implies
        # relationships, but they'll have to get handled by setting conflicts.
        my $parent   = $rest->{'-parent_of'}{$name};
        my @siblings = $parent
                     ? (grep {; defined $rest->{'-parent_of'}{$_}
                                && $rest->{'-parent_of'}{$_} eq $parent }
                        @{ $rest->{'-given_keys'} })
                     : ();
  
        if (@siblings > 1) {
          die "these options conflict; each wants to set the $parent: @siblings\n";
        }
  
        if (  exists $param->{$key}
          and $param->{$key} ne $val
          and grep {; $_ eq $key } @{ $rest->{'-given_keys'} }
        ) {
          die(
            "option specification for $name implies that $key should be "
            . "set to '$val', but it is '$param->{$key}' already\n"
          );
        }
        $param->{$key} = $val;
      }
  
      return 1;
    };
  }
  
  sub _mk_only_one {
    die "unimplemented";
  }
  
  {
    package
      Getopt::Long::Descriptive::_PV_Error;
    sub error { $_[0]->{error} }
    sub throw {
      my ($class, $error_msg) = @_;
      my $self = { error => $error_msg };
      bless $self, $class;
      die $self;
    }
  }
  
  #pod =head1 CUSTOMIZING
  #pod
  #pod Getopt::Long::Descriptive uses L<Sub::Exporter|Sub::Exporter> to build and
  #pod export the C<describe_options> routine.  By writing a new class that extends
  #pod Getopt::Long::Descriptive, the behavior of the constructed C<describe_options>
  #pod routine can be changed.
  #pod
  #pod The following methods can be overridden:
  #pod
  #pod =head2 usage_class
  #pod
  #pod   my $class = Getopt::Long::Descriptive->usage_class;
  #pod
  #pod This returns the class to be used for constructing a Usage object, and defaults
  #pod to Getopt::Long::Descriptive::Usage.
  #pod
  #pod =head1 SEE ALSO
  #pod
  #pod =for :list
  #pod * L<Getopt::Long>
  #pod * L<Params::Validate>
  #pod
  #pod =cut
  
  1; # End of Getopt::Long::Descriptive
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Getopt::Long::Descriptive - Getopt::Long, but simpler and more powerful
  
  =head1 VERSION
  
  version 0.102
  
  =head1 SYNOPSIS
  
    use Getopt::Long::Descriptive;
  
    my ($opt, $usage) = describe_options(
      'my-program %o <some-arg>',
      [ 'server|s=s', "the server to connect to", { required => 1  } ],
      [ 'port|p=i',   "the port to connect to",   { default  => 79 } ],
      [],
      [ 'verbose|v',  "print extra stuff"            ],
      [ 'help',       "print usage message and exit", { shortcircuit => 1 } ],
    );
  
    print($usage->text), exit if $opt->help;
  
    Client->connect( $opt->server, $opt->port );
  
    print "Connected!\n" if $opt->verbose;
  
  ...and running C<my-program --help> will produce:
  
    my-program [-psv] [long options...] <some-arg>
      -s --server     the server to connect to
      -p --port       the port to connect to
  
      -v --verbose    print extra stuff
      --help          print usage message and exit
  
  =head1 DESCRIPTION
  
  Getopt::Long::Descriptive is yet another Getopt library.  It's built atop
  Getopt::Long, and gets a lot of its features, but tries to avoid making you
  think about its huge array of options.
  
  It also provides usage (help) messages, data validation, and a few other useful
  features.
  
  =head1 FUNCTIONS
  
  Getopt::Long::Descriptive only exports one routine by default:
  C<describe_options>.  All GLD's exports are exported by L<Sub::Exporter>.
  
  =head2 describe_options
  
    my ($opt, $usage) = describe_options($usage_desc, @opt_spec, \%arg);
  
  This routine inspects C<@ARGV> for options that match the supplied spec. If all
  the options are valid then it returns the options given and an object for
  generating usage messages; if not then it dies with an explanation of what was
  wrong and a usage message.
  
  The C<$opt> object will be a dynamically-generated subclass of
  L<Getopt::Long::Descriptive::Opts>.  In brief, each of the options in
  C<@opt_spec> becomes an accessor method on the object, using the first-given
  name, with dashes converted to underscores.  For more information, see the
  documentation for the Opts class.
  
  The C<$usage> object will be a L<Getopt::Long::Descriptive::Usage> object,
  which provides a C<text> method to get the text of the usage message and C<die>
  to die with it.  For more methods and options, consults the documentation for
  the Usage class.
  
  =head3 $usage_desc
  
  The C<$usage_desc> parameter to C<describe_options> is a C<sprintf>-like string
  that is used in generating the first line of the usage message.  It's a
  one-line summary of how the command is to be invoked.  A typical usage
  description might be:
  
    $usage_desc = "%c %o <source> <desc>";
  
  C<%c> will be replaced with what Getopt::Long::Descriptive thinks is the
  program name (it's computed from C<$0>, see L</prog_name>).
  
  C<%o> will be replaced with a list of the short options, as well as the text
  "[long options...]" if any have been defined.
  
  The rest of the usage description can be used to summarize what arguments are
  expected to follow the program's options, and is entirely free-form.
  
  Literal C<%> characters will need to be written as C<%%>, just like with
  C<sprintf>.
  
  =head3 @opt_spec
  
  The C<@opt_spec> part of the args to C<describe_options> is used to configure
  option parsing and to produce the usage message.  Each entry in the list is an
  arrayref describing one option, like this:
  
    @opt_spec = (
      [ "verbose|V" => "be noisy"       ],
      [ "logfile=s" => "file to log to" ],
    );
  
  The first value in the arrayref is a Getopt::Long-style option specification.
  In brief, they work like this:  each one is a pipe-delimited list of names,
  optionally followed by a type declaration.  Type declarations are '=x' or ':x',
  where C<=> means a value is required and C<:> means it is optional.  I<x> may
  be 's' to indicate a string is required, 'i' for an integer, or 'f' for a
  number with a fractional part.  The type spec may end in C<@> to indicate that
  the option may appear multiple times.
  
  For more information on how these work, see the L<Getopt::Long> documentation.
  
  The first name given should be the canonical name, as it will be used as the
  accessor method on the C<$opt> object.  Dashes in the name will be converted to
  underscores, and all letters will be lowercased.  For this reason, all options
  should generally have a long-form name.
  
  The second value in the arrayref is a description of the option, for use in the
  usage message.
  
  =head4 Special Option Specifications
  
  If the option specification (arrayref) is empty, it will have no effect other
  than causing a blank line to appear in the usage message.
  
  If the option specification contains only one element, it will be printed in
  the usage message with no other effect.
  
  If the option specification contains a third element, it adds extra constraints
  or modifiers to the interpretation and validation of the value.  These are the
  keys that may be present in that hashref, and how they behave:
  
  =over 4
  
  =item implies
  
    implies => 'bar'
    implies => [qw(foo bar)]
    implies => { foo => 1, bar => 2 }
  
  If option I<A> has an "implies" entry, then if I<A> is given, other options
  will be enabled.  The value may be a single option to set, an arrayref of
  options to set, or a hashref of options to set to specific values.
  
  =item required
  
    required => 1
  
  If an option is required, failure to provide the option will result in
  C<describe_options> printing the usage message and exiting.
  
  =item hidden
  
    hidden => 1
  
  This option will not show up in the usage text.
  
  You can achieve the same behavior by using the string "hidden" for the option's
  description.
  
  =item one_of
  
    one_of => \@subopt_specs
  
  This is useful for a group of options that are related.  Each option
  spec is added to the list for normal parsing and validation.
  
  Your option name will end up with a value of the name of the
  option that was chosen.  For example, given the following spec:
  
    [ "mode" => hidden => { one_of => [
      [ "get|g"  => "get the value" ],
      [ "set|s"  => "set the value" ],
      [ "delete" => "delete it" ],
    ] } ],
  
  No usage text for 'mode' will be displayed, but text for get, set, and delete
  will be displayed.
  
  If more than one of get, set, or delete is given, an error will be thrown.
  
  So, given the C<@opt_spec> above, and an C<@ARGV> of C<('--get')>, the
  following would be true:
  
    $opt->get == 1;
  
    $opt->mode eq 'get';
  
  B<Note>: C<get> would not be set if C<mode> defaulted to 'get' and no arguments
  were passed in.
  
  Even though the option sub-specs for C<one_of> are meant to be 'first
  class' specs, some options don't make sense with them, e.g. C<required>.
  
  As a further shorthand, you may specify C<one_of> options using this form:
  
    [ mode => \@option_specs, \%constraints ]
  
  =item shortcircuit
  
    shortcircuit => 1
  
  If this option is present no other options will be returned.  Other
  options present will be checked for proper types, but I<not> for
  constraints.  This provides a way of specifying C<--help> style options.
  
  =item Params::Validate
  
  In addition, any constraint understood by Params::Validate may be used.
  
  For example, to accept positive integers:
  
    [ 'max-iterations=i', "maximum number of iterations",
      { callbacks => { positive => sub { shift() > 0 } } } ],
  
  (Internally, all constraints are translated into Params::Validate options or
  callbacks.)
  
  =back
  
  =head3 %arg
  
  The C<%arg> to C<describe_options> is optional.  If the last parameter is a
  hashref, it contains extra arguments to modify the way C<describe_options>
  works.  Valid arguments are:
  
    getopt_conf   - an arrayref of strings, passed to Getopt::Long::Configure
    show_defaults - a boolean which controls whether an option's default
                    value (if applicable) is shown as part of the usage message
                    (for backward compatibility this defaults to false)
  
  =head2 prog_name
  
  This routine, exported on demand, returns the basename of C<$0>, grabbed at
  compile-time.  You can override this guess by calling C<prog_name($string)>
  yourself.
  
  =head1 OTHER EXPORTS
  
  =head2 C<-types>
  
  Any of the Params::Validate type constants (C<SCALAR>, etc.) can be imported as
  well.  You can get all of them at once by importing C<-types>.
  
  =head2 C<-all>
  
  This import group will import C<-type>, C<describe_options>, and C<prog_name>.
  
  =head1 CUSTOMIZING
  
  Getopt::Long::Descriptive uses L<Sub::Exporter|Sub::Exporter> to build and
  export the C<describe_options> routine.  By writing a new class that extends
  Getopt::Long::Descriptive, the behavior of the constructed C<describe_options>
  routine can be changed.
  
  The following methods can be overridden:
  
  =head2 usage_class
  
    my $class = Getopt::Long::Descriptive->usage_class;
  
  This returns the class to be used for constructing a Usage object, and defaults
  to Getopt::Long::Descriptive::Usage.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<Getopt::Long>
  
  =item *
  
  L<Params::Validate>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Hans Dieter Pearcey <hdp@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Arthur Axel 'fREW' Schmidt Dave Rolsky Diab Jerius Hans Dieter Pearcey Harley Pig hdp@cpan.org Karen Etheridge Niels Thykier Olaf Alders Roman Hubacek Smylers Thomas Neumann zhouzhen1
  
  =over 4
  
  =item *
  
  Arthur Axel 'fREW' Schmidt <frioux@gmail.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Diab Jerius <djerius@cfa.harvard.edu>
  
  =item *
  
  Hans Dieter Pearcey <hdp@pobox.com>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Harley Pig <harleypig@gmail.com>
  
  =item *
  
  hdp@cpan.org <hdp@cpan.org@fc0e91e4-031c-0410-8307-be39b06d7656>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Niels Thykier <niels@thykier.net>
  
  =item *
  
  Olaf Alders <olaf@wundersolutions.com>
  
  =item *
  
  Roman Hubacek <roman.hubacek@centrum.cz>
  
  =item *
  
  Smylers <SMYLERS@cpan.fsck.com>
  
  =item *
  
  Thomas Neumann <blacky+perl@fluffbunny.de>
  
  =item *
  
  zhouzhen1 <zhouzhen1@gmail.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2005 by Hans Dieter Pearcey.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
GETOPT_LONG_DESCRIPTIVE

$fatpacked{"Getopt/Long/Descriptive/Opts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG_DESCRIPTIVE_OPTS';
  use strict;
  use warnings;
  package Getopt::Long::Descriptive::Opts;
  # ABSTRACT: object representing command line switches
  $Getopt::Long::Descriptive::Opts::VERSION = '0.102';
  use Scalar::Util qw(blessed weaken);
  
  #pod =head1 DESCRIPTION
  #pod
  #pod This class is the base class of all C<$opt> objects returned by
  #pod L<Getopt::Long::Descriptive>.  In general, you do not want to think about this
  #pod class, look at it, or alter it.  Seriously, it's pretty dumb.
  #pod
  #pod Every call to C<describe_options> will return a object of a new subclass of
  #pod this class.  It will have a method for the canonical name of each option
  #pod possible given the option specifications.
  #pod
  #pod Method names beginning with an single underscore are public, and are named that
  #pod way to avoid conflict with automatically generated methods.  Methods with
  #pod multiple underscores (in case you're reading the source) are private.
  #pod
  #pod =head1 METHODS
  #pod
  #pod B<Achtung!>  All methods beginning with an underscore are experimental as of
  #pod today, 2009-12-12.  They are likely to be formally made permanent soon.
  #pod
  #pod =head2 _specified
  #pod
  #pod This method returns true if the given name was specified on the command line.
  #pod
  #pod For example, if C<@ARGS> was "C<< --foo --bar 10 >>" and C<baz> is defined by a
  #pod default, C<_specified> will return true for foo and bar, and false for baz.
  #pod
  #pod =cut
  
  my %_CREATED_OPTS;
  my $SERIAL_NUMBER = 1;
  
  sub _specified {
    my ($self, $name) = @_;
    my $meta = $_CREATED_OPTS{ blessed $self }{meta};
    return $meta->{given}{ $name };
  }
  
  #pod =head2 _specified_opts
  #pod
  #pod This method returns an opt object in which only explicitly specified values are
  #pod defined.  Values which were set by defaults will appear undef.
  #pod
  #pod =cut
  
  sub _specified_opts {
    my ($self) = @_;
  
    my $class = blessed $self;
    my $meta = $_CREATED_OPTS{ $class  }{meta};
  
    return $meta->{specified_opts} if $meta->{specified_opts};
  
    my @keys = grep { $meta->{given}{ $_ } } (keys %{ $meta->{given} });
  
    my %opts;
    @opts{ @keys } = @$self{ @keys };
  
    $meta->{specified_opts} = \%opts;
  
    bless $meta->{specified_opts} => $class;
    weaken $meta->{specified_opts};
  
    $meta->{specified_opts};
  }
  
  #pod =head2 _complete_opts
  #pod
  #pod This method returns the opts object with all values, including those set by
  #pod defaults.  It is probably not going to be very often-used.
  #pod
  #pod =cut
  
  sub _complete_opts {
    my ($self) = @_;
  
    my $class = blessed $self;
    my $meta = $_CREATED_OPTS{ $class  }{meta};
    return $meta->{complete_opts};
  }
  
  sub ___class_for_opt {
    my ($class, $arg) = @_;
  
    my $values = $arg->{values};
    my @bad = grep { $_ !~ /^[a-z_]\w*$/ } keys %$values;
    Carp::confess("perverse option names given: @bad") if @bad;
  
    my $new_class = "$class\::__OPT__::" . $SERIAL_NUMBER++;
    $_CREATED_OPTS{ $new_class } = { meta => $arg };
  
    {
      no strict 'refs';
      ${"$new_class\::VERSION"} = $class->VERSION;
      *{"$new_class\::ISA"} = [ 'Getopt::Long::Descriptive::Opts' ];
      for my $opt (keys %$values) {
        *{"$new_class\::$opt"} = sub { $_[0]->{ $opt } };
      }
    }
  
    return $new_class;
  }
  
  sub ___new_opt_obj {
    my ($class, $arg) = @_;
  
    my $copy = { %{ $arg->{values} } };
  
    my $new_class = $class->___class_for_opt($arg);
  
    # This is stupid, but the traditional behavior was that if --foo was not
    # given, there is no $opt->{foo}; it started to show up when we "needed" all
    # the keys to generate a class, but was undef; this wasn't a problem, but
    # broke tests of things that were relying on not-exists like tests of %$opt
    # contents or MooseX::Getopt which wanted to use things as args for new --
    # undef would not pass an Int TC.  Easier to just do this. -- rjbs,
    # 2009-11-27
    delete $copy->{$_} for grep { ! defined $copy->{$_} } keys %$copy;
  
    my $self = bless $copy => $new_class;
  
    $_CREATED_OPTS{ $new_class }{meta}{complete_opts} = $self;
    # weaken $_CREATED_OPTS{ $new_class }{meta}{complete_opts};
  
    return $self;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Getopt::Long::Descriptive::Opts - object representing command line switches
  
  =head1 VERSION
  
  version 0.102
  
  =head1 DESCRIPTION
  
  This class is the base class of all C<$opt> objects returned by
  L<Getopt::Long::Descriptive>.  In general, you do not want to think about this
  class, look at it, or alter it.  Seriously, it's pretty dumb.
  
  Every call to C<describe_options> will return a object of a new subclass of
  this class.  It will have a method for the canonical name of each option
  possible given the option specifications.
  
  Method names beginning with an single underscore are public, and are named that
  way to avoid conflict with automatically generated methods.  Methods with
  multiple underscores (in case you're reading the source) are private.
  
  =head1 METHODS
  
  B<Achtung!>  All methods beginning with an underscore are experimental as of
  today, 2009-12-12.  They are likely to be formally made permanent soon.
  
  =head2 _specified
  
  This method returns true if the given name was specified on the command line.
  
  For example, if C<@ARGS> was "C<< --foo --bar 10 >>" and C<baz> is defined by a
  default, C<_specified> will return true for foo and bar, and false for baz.
  
  =head2 _specified_opts
  
  This method returns an opt object in which only explicitly specified values are
  defined.  Values which were set by defaults will appear undef.
  
  =head2 _complete_opts
  
  This method returns the opts object with all values, including those set by
  defaults.  It is probably not going to be very often-used.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Hans Dieter Pearcey <hdp@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2005 by Hans Dieter Pearcey.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
GETOPT_LONG_DESCRIPTIVE_OPTS

$fatpacked{"Getopt/Long/Descriptive/Usage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG_DESCRIPTIVE_USAGE';
  use strict;
  use warnings;
  package Getopt::Long::Descriptive::Usage;
  # ABSTRACT: the usage description for GLD
  $Getopt::Long::Descriptive::Usage::VERSION = '0.102';
  use List::Util qw(max);
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   use Getopt::Long::Descriptive;
  #pod   my ($opt, $usage) = describe_options( ... );
  #pod
  #pod   $usage->text; # complete usage message
  #pod
  #pod   $usage->die;  # die with usage message
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This document only describes the methods of the Usage object.  For information
  #pod on how to use L<Getopt::Long::Descriptive>, consult its documentation.
  #pod
  #pod =head1 METHODS
  #pod
  #pod =head2 new
  #pod
  #pod   my $usage = Getopt::Long::Descriptive::Usage->new(\%arg);
  #pod
  #pod You B<really> don't need to call this.  GLD will do it for you.
  #pod
  #pod Valid arguments are:
  #pod
  #pod   options     - an arrayref of options
  #pod   leader_text - the text that leads the usage; this may go away!
  #pod
  #pod =cut
  
  sub new {
    my ($class, $arg) = @_;
  
    my @to_copy = qw(leader_text options show_defaults);
  
    my %copy;
    @copy{ @to_copy } = @$arg{ @to_copy };
  
    bless \%copy => $class;
  }
  
  #pod =head2 text
  #pod
  #pod This returns the full text of the usage message.
  #pod
  #pod =cut
  
  sub text {
    my ($self) = @_;
  
    return join qq{\n}, $self->leader_text, $self->option_text;
  }
  
  #pod =head2 leader_text
  #pod
  #pod This returns the text that comes at the beginning of the usage message.
  #pod
  #pod =cut
  
  sub leader_text { $_[0]->{leader_text} }
  
  #pod =head2 option_text
  #pod
  #pod This returns the text describing the available options.
  #pod
  #pod =cut
  
  sub option_text {
    my ($self) = @_;
  
    my @options  = @{ $self->{options} || [] };
    my $string   = q{};
    my @specs = map { $_->{spec} } grep { $_->{desc} ne 'spacer' } @options;
    my $length   = (max(map { _option_length($_) } @specs) || 0);
    my $spec_fmt = "\t%-${length}s";
  
    while (@options) {
      my $opt  = shift @options;
      my $spec = $opt->{spec};
      my $desc = $opt->{desc};
      my $assign;
      if ($desc eq 'spacer') {
        my @lines = $self->_split_description($length, $opt->{spec});
  
        $string .= length($_) ? sprintf("$spec_fmt\n", $_) : "\n" for @lines;
        next;
      }
  
      ($spec, $assign) = Getopt::Long::Descriptive->_strip_assignment($spec);
      $assign = _parse_assignment($assign);
      $spec = join " ", reverse map { length > 1 ? "--${_}$assign" : "-${_}$assign" }
                                split /\|/, $spec;
  
      my @desc = $self->_split_description($length, $desc);
  
      # add default value if it exists
      if (exists $opt->{constraint}->{default} and $self->{show_defaults}) {
        my $dflt = $opt->{constraint}->{default};
        $dflt = ! defined $dflt ? '(undef)'
              : ! length  $dflt ? '(empty string)'
              :                   $dflt;
        push @desc, "(default value: $dflt)";
      }
  
      $string .= sprintf "$spec_fmt  %s\n", $spec, shift @desc;
      for my $line (@desc) {
          $string .= "\t";
          $string .= q{ } x ( $length + 2 );
          $string .= "$line\n";
      }
    }
  
    return $string;
  }
  
  sub _option_length {
      my ($fullspec) = @_;
      my $number_opts = 1;
      my $last_pos = 0;
      my $number_shortopts = 0;
      my ($spec, $argspec) = Getopt::Long::Descriptive->_strip_assignment($fullspec);
      my $length = length $spec;
      my $arglen = length(_parse_assignment($argspec));
  
      # Spacing rules:
      #
      # For short options we want 1 space (for '-'), for long options 2
      # spaces (for '--').  Then one space for separating the options,
      # but we here abuse that $spec has a '|' char for that.
      #
      # For options that take arguments, we want 2 spaces for mandatory
      # options ('=X') and 4 for optional arguments ('[=X]').  Note we
      # consider {N,M} cases as "single argument" atm.
  
      # Count the number of "variants" (e.g. "long|s" has two variants)
      while ($spec =~ m{\|}g) {
          $number_opts++;
          if (pos($spec) - $last_pos == 2) {
              $number_shortopts++;
          }
          $last_pos = pos($spec);
      }
  
      # Was the last option a "short" one?
      if ($length - $last_pos == 1) {
          $number_shortopts++;
      }
  
      # We got $number_opts options, each with an argument length of
      # $arglen.  Plus each option (after the first) needs 3 a char
      # spacing.  $length gives us the total length of all options and 1
      # char spacing per option (after the first).  So the result should be:
  
      my $number_longopts = $number_opts - $number_shortopts;
      my $total_arglen = $number_opts * $arglen;
      my $total_optsep = 2 * $number_longopts + $number_shortopts;
      my $total = $length + $total_optsep + $total_arglen;
      return $total;
  }
  
  sub _split_description {
    my ($self, $length, $desc) = @_;
  
    # 8 for a tab, 2 for the space between option & desc;
    my $max_length = 78 - ( $length + 8 + 2 );
  
    return $desc if length $desc <= $max_length;
  
    my @lines;
    while (length $desc > $max_length) {
      my $idx = rindex( substr( $desc, 0, $max_length ), q{ }, );
      last unless $idx >= 0;
      push @lines, substr($desc, 0, $idx);
      substr($desc, 0, $idx + 1) = q{};
    }
    push @lines, $desc;
  
    return @lines;
  }
  
  sub _parse_assignment {
      my ($assign_spec) = @_;
  
      my $result = 'STR';
      my $desttype;
      if (length($assign_spec) < 2) {
          # empty, ! or +
          return '';
      }
  
      my $optional = substr($assign_spec, 0, 1) eq ':';
      my $argument = substr $assign_spec, 1, 2;
  
      if ($argument =~ m/^[io]/ or $assign_spec =~ m/^:[+0-9]/) {
          $result = 'INT';
      } elsif ($argument =~ m/^f/) {
          $result = 'NUM';
      }
  
      if (length($assign_spec) > 2) {
          $desttype = substr($assign_spec, 2, 1);
          if ($desttype eq '@') {
              # Imply it can be repeated
              $result .= '...';
          } elsif ($desttype eq '%') {
              $result = "KEY=${result}...";
          }
      }
  
      if ($optional) {
          return "[=$result]";
      }
  
      # with leading space so it can just blindly be appended.
      return " $result";
  }
  
  #pod =head2 warn
  #pod
  #pod This warns with the usage message.
  #pod
  #pod =cut
  
  sub warn { warn shift->text }
  
  #pod =head2 die
  #pod
  #pod This throws the usage message as an exception.
  #pod
  #pod   $usage_obj->die(\%arg);
  #pod
  #pod Some arguments can be provided 
  #pod
  #pod   pre_text  - text to be prepended to the usage message
  #pod   post_text - text to be appended to the usage message
  #pod
  #pod The C<pre_text> and C<post_text> arguments are concatenated with the usage
  #pod message with no line breaks, so supply this if you need them.
  #pod
  #pod =cut
  
  sub die  {
    my $self = shift;
    my $arg  = shift || {};
  
    die(
      join q{}, grep { defined } $arg->{pre_text}, $self->text, $arg->{post_text}
    );
  }
  
  use overload (
    q{""} => "text",
  
    # This is only needed because Usage used to be a blessed coderef that worked
    # this way.  Later we can toss a warning in here. -- rjbs, 2009-08-19
    '&{}' => sub {
      my ($self) = @_;
      Carp::cluck("use of __PACKAGE__ objects as a code ref is deprecated");
      return sub { return $_[0] ? $self->text : $self->warn; };
    }
  );
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Getopt::Long::Descriptive::Usage - the usage description for GLD
  
  =head1 VERSION
  
  version 0.102
  
  =head1 SYNOPSIS
  
    use Getopt::Long::Descriptive;
    my ($opt, $usage) = describe_options( ... );
  
    $usage->text; # complete usage message
  
    $usage->die;  # die with usage message
  
  =head1 DESCRIPTION
  
  This document only describes the methods of the Usage object.  For information
  on how to use L<Getopt::Long::Descriptive>, consult its documentation.
  
  =head1 METHODS
  
  =head2 new
  
    my $usage = Getopt::Long::Descriptive::Usage->new(\%arg);
  
  You B<really> don't need to call this.  GLD will do it for you.
  
  Valid arguments are:
  
    options     - an arrayref of options
    leader_text - the text that leads the usage; this may go away!
  
  =head2 text
  
  This returns the full text of the usage message.
  
  =head2 leader_text
  
  This returns the text that comes at the beginning of the usage message.
  
  =head2 option_text
  
  This returns the text describing the available options.
  
  =head2 warn
  
  This warns with the usage message.
  
  =head2 die
  
  This throws the usage message as an exception.
  
    $usage_obj->die(\%arg);
  
  Some arguments can be provided 
  
    pre_text  - text to be prepended to the usage message
    post_text - text to be appended to the usage message
  
  The C<pre_text> and C<post_text> arguments are concatenated with the usage
  message with no line breaks, so supply this if you need them.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Hans Dieter Pearcey <hdp@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2005 by Hans Dieter Pearcey.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
GETOPT_LONG_DESCRIPTIVE_USAGE

$fatpacked{"List/MoreUtils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIST_MOREUTILS';
  package List::MoreUtils;
  
  use 5.008_001;
  use strict;
  use warnings;
  
  my $have_xs;
  our $VERSION = '0.428';
  
  BEGIN
  {
      unless (defined($have_xs))
      {
          eval { require List::MoreUtils::XS; } unless $ENV{LIST_MOREUTILS_PP};
          die $@ if $@ && defined $ENV{LIST_MOREUTILS_PP} && $ENV{LIST_MOREUTILS_PP} == 0;
          $have_xs = 0+defined( $INC{'List/MoreUtils/XS.pm'});
      }
  
      use List::MoreUtils::PP qw();
  }
  
  use Exporter::Tiny qw();
  
  my @junctions = qw(any all none notall);
  my @v0_22     = qw(
    true false
    firstidx lastidx
    insert_after insert_after_string
    apply indexes
    after after_incl before before_incl
    firstval lastval
    each_array each_arrayref
    pairwise natatime
    mesh uniq
    minmax part
    _XScompiled
  );
  my @v0_24  = qw(bsearch);
  my @v0_33  = qw(sort_by nsort_by);
  my @v0_400 = qw(one any_u all_u none_u notall_u one_u
    firstres onlyidx onlyval onlyres lastres
    singleton bsearchidx
  );
  my @v0_420 = qw(arrayify duplicates minmaxstr samples zip6 reduce_0 reduce_1 reduce_u
    listcmp frequency occurrences mode
    binsert bremove equal_range lower_bound upper_bound qsort);
  
  my @all_functions = (@junctions, @v0_22, @v0_24, @v0_33, @v0_400, @v0_420);
  
  no strict "refs";
  if ($have_xs)
  {
      my $x;
      for (@all_functions)
      {
          List::MoreUtils->can($_) or *$_ = $x if ($x = List::MoreUtils::XS->can($_));
      }
  }
  List::MoreUtils->can($_) or *$_ = List::MoreUtils::PP->can($_) for (@all_functions);
  use strict;
  
  my %alias_list = (
      v0_22 => {
          first_index => "firstidx",
          last_index  => "lastidx",
          first_value => "firstval",
          last_value  => "lastval",
          zip         => "mesh",
      },
      v0_33 => {
          distinct => "uniq",
      },
      v0_400 => {
          first_result  => "firstres",
          only_index    => "onlyidx",
          only_value    => "onlyval",
          only_result   => "onlyres",
          last_result   => "lastres",
          bsearch_index => "bsearchidx",
      },
      v0_420 => {
  	bsearch_insert => "binsert",
  	bsearch_remove => "bremove",
  	zip_unflatten  => "zip6",
      },
  );
  
  our @ISA         = qw(Exporter::Tiny);
  our @EXPORT_OK   = (@all_functions, map { keys %$_ } values %alias_list);
  our %EXPORT_TAGS = (
      all         => \@EXPORT_OK,
      'like_0.22' => [
          any_u    => {-as => 'any'},
          all_u    => {-as => 'all'},
          none_u   => {-as => 'none'},
          notall_u => {-as => 'notall'},
          @v0_22,
          keys %{$alias_list{v0_22}},
      ],
      'like_0.24' => [
          any_u    => {-as => 'any'},
          all_u    => {-as => 'all'},
          notall_u => {-as => 'notall'},
          'none',
          @v0_22,
          @v0_24,
          keys %{$alias_list{v0_22}},
      ],
      'like_0.33' => [
          @junctions,
          @v0_22,
          # v0_24 functions were omitted
          @v0_33,
          keys %{$alias_list{v0_22}},
          keys %{$alias_list{v0_33}},
      ],
  );
  
  for my $set (values %alias_list)
  {
      for my $alias (keys %$set)
      {
          no strict qw(refs);
          *$alias = __PACKAGE__->can($set->{$alias});
      }
  }
  
  =pod
  
  =head1 NAME
  
  List::MoreUtils - Provide the stuff missing in List::Util
  
  =head1 SYNOPSIS
  
      # import specific functions
  
      use List::MoreUtils qw(any uniq);
  
      if ( any { /foo/ } uniq @has_duplicates ) {
          # do stuff
      }
  
      # import everything
  
      use List::MoreUtils ':all';
  
      # import by API
  
      # has "original" any/all/none/notall behavior
      use List::MoreUtils ':like_0.22';
      # 0.22 + bsearch
      use List::MoreUtils ':like_0.24';
      # has "simplified" any/all/none/notall behavior + (n)sort_by
      use List::MoreUtils ':like_0.33';
  
  =head1 DESCRIPTION
  
  B<List::MoreUtils> provides some trivial but commonly needed functionality on
  lists which is not going to go into L<List::Util>.
  
  All of the below functions are implementable in only a couple of lines of Perl
  code. Using the functions from this module however should give slightly better
  performance as everything is implemented in C. The pure-Perl implementation of
  these functions only serves as a fallback in case the C portions of this module
  couldn't be compiled on this machine.
  
  =head1 EXPORTS
  
  =head2 Default behavior
  
  Nothing by default. To import all of this module's symbols use the C<:all> tag.
  Otherwise functions can be imported by name as usual:
  
      use List::MoreUtils ':all';
  
      use List::MoreUtils qw{ any firstidx };
  
  Because historical changes to the API might make upgrading List::MoreUtils
  difficult for some projects, the legacy API is available via special import
  tags.
  
  =head2 Like version 0.22 (last release with original API)
  
  This API was available from 2006 to 2009, returning undef for empty lists on
  C<all>/C<any>/C<none>/C<notall>:
  
      use List::MoreUtils ':like_0.22';
  
  This import tag will import all functions available as of version 0.22.
  However, it will import C<any_u> as C<any>, C<all_u> as C<all>, C<none_u> as
  C<none>, and C<notall_u> as C<notall>.
  
  =head2 Like version 0.24 (first incompatible change)
  
  This API was available from 2010 to 2011.  It changed the return value of C<none>
  and added the C<bsearch> function.
  
      use List::MoreUtils ':like_0.24';
  
  This import tag will import all functions available as of version 0.24.
  However it will import C<any_u> as C<any>, C<all_u> as C<all>, and
  C<notall_u> as C<notall>.  It will import C<none> as described in
  the documentation below (true for empty list).
  
  =head2 Like version 0.33 (second incompatible change)
  
  This API was available from 2011 to 2014. It is widely used in several CPAN
  modules and thus it's closest to the current API.  It changed the return values
  of C<any>, C<all>, and C<notall>.  It added the C<sort_by> and C<nsort_by> functions
  and the C<distinct> alias for C<uniq>.  It omitted C<bsearch>.
  
      use List::MoreUtils ':like_0.33';
  
  This import tag will import all functions available as of version 0.33.  Note:
  it will not import C<bsearch> for consistency with the 0.33 API.
  
  =head1 FUNCTIONS
  
  =head2 Junctions
  
  =head3 I<Treatment of an empty list>
  
  There are two schools of thought for how to evaluate a junction on an
  empty list:
  
  =over
  
  =item *
  
  Reduction to an identity (boolean)
  
  =item *
  
  Result is undefined (three-valued)
  
  =back
  
  In the first case, the result of the junction applied to the empty list is
  determined by a mathematical reduction to an identity depending on whether
  the underlying comparison is "or" or "and".  Conceptually:
  
                      "any are true"      "all are true"
                      --------------      --------------
      2 elements:     A || B || 0         A && B && 1
      1 element:      A || 0              A && 1
      0 elements:     0                   1
  
  In the second case, three-value logic is desired, in which a junction
  applied to an empty list returns C<undef> rather than true or false 
  
  Junctions with a C<_u> suffix implement three-valued logic.  Those
  without are boolean.
  
  =head3 all BLOCK LIST
  
  =head3 all_u BLOCK LIST
  
  Returns a true value if all items in LIST meet the criterion given through
  BLOCK. Sets C<$_> for each item in LIST in turn:
  
    print "All values are non-negative"
      if all { $_ >= 0 } ($x, $y, $z);
  
  For an empty LIST, C<all> returns true (i.e. no values failed the condition)
  and C<all_u> returns C<undef>.
  
  Thus, C<< all_u(@list) >> is equivalent to C<< @list ? all(@list) : undef >>.
  
  B<Note>: because Perl treats C<undef> as false, you must check the return value
  of C<all_u> with C<defined> or you will get the opposite result of what you
  expect.
  
  =head3 any BLOCK LIST
  
  =head3 any_u BLOCK LIST
  
  Returns a true value if any item in LIST meets the criterion given through
  BLOCK. Sets C<$_> for each item in LIST in turn:
  
    print "At least one non-negative value"
      if any { $_ >= 0 } ($x, $y, $z);
  
  For an empty LIST, C<any> returns false and C<any_u> returns C<undef>.
  
  Thus, C<< any_u(@list) >> is equivalent to C<< @list ? any(@list) : undef >>.
  
  =head3 none BLOCK LIST
  
  =head3 none_u BLOCK LIST
  
  Logically the negation of C<any>. Returns a true value if no item in LIST meets
  the criterion given through BLOCK. Sets C<$_> for each item in LIST in turn:
  
    print "No non-negative values"
      if none { $_ >= 0 } ($x, $y, $z);
  
  For an empty LIST, C<none> returns true (i.e. no values failed the condition)
  and C<none_u> returns C<undef>.
  
  Thus, C<< none_u(@list) >> is equivalent to C<< @list ? none(@list) : undef >>.
  
  B<Note>: because Perl treats C<undef> as false, you must check the return value
  of C<none_u> with C<defined> or you will get the opposite result of what you
  expect.
  
  =head3 notall BLOCK LIST
  
  =head3 notall_u BLOCK LIST
  
  Logically the negation of C<all>. Returns a true value if not all items in LIST
  meet the criterion given through BLOCK. Sets C<$_> for each item in LIST in
  turn:
  
    print "Not all values are non-negative"
      if notall { $_ >= 0 } ($x, $y, $z);
  
  For an empty LIST, C<notall> returns false and C<notall_u> returns C<undef>.
  
  Thus, C<< notall_u(@list) >> is equivalent to C<< @list ? notall(@list) : undef >>.
  
  =head3 one BLOCK LIST
  
  =head3 one_u BLOCK LIST
  
  Returns a true value if precisely one item in LIST meets the criterion
  given through BLOCK. Sets C<$_> for each item in LIST in turn:
  
      print "Precisely one value defined"
          if one { defined($_) } @list;
  
  Returns false otherwise.
  
  For an empty LIST, C<one> returns false and C<one_u> returns C<undef>.
  
  The expression C<one BLOCK LIST> is almost equivalent to
  C<1 == true BLOCK LIST>, except for short-cutting.
  Evaluation of BLOCK will immediately stop at the second true value.
  
  =head2 Transformation
  
  =head3 apply BLOCK LIST
  
  Applies BLOCK to each item in LIST and returns a list of the values after BLOCK
  has been applied. In scalar context, the last element is returned.  This
  function is similar to C<map> but will not modify the elements of the input
  list:
  
    my @list = (1 .. 4);
    my @mult = apply { $_ *= 2 } @list;
    print "\@list = @list\n";
    print "\@mult = @mult\n";
    __END__
    @list = 1 2 3 4
    @mult = 2 4 6 8
  
  Think of it as syntactic sugar for
  
    for (my @mult = @list) { $_ *= 2 }
  
  =head3 insert_after BLOCK VALUE LIST
  
  Inserts VALUE after the first item in LIST for which the criterion in BLOCK is
  true. Sets C<$_> for each item in LIST in turn.
  
    my @list = qw/This is a list/;
    insert_after { $_ eq "a" } "longer" => @list;
    print "@list";
    __END__
    This is a longer list
  
  =head3 insert_after_string STRING VALUE LIST
  
  Inserts VALUE after the first item in LIST which is equal to STRING. 
  
    my @list = qw/This is a list/;
    insert_after_string "a", "longer" => @list;
    print "@list";
    __END__
    This is a longer list
  
  =head3 pairwise BLOCK ARRAY1 ARRAY2
  
  Evaluates BLOCK for each pair of elements in ARRAY1 and ARRAY2 and returns a
  new list consisting of BLOCK's return values. The two elements are set to C<$a>
  and C<$b>.  Note that those two are aliases to the original value so changing
  them will modify the input arrays.
  
    @a = (1 .. 5);
    @b = (11 .. 15);
    @x = pairwise { $a + $b } @a, @b;     # returns 12, 14, 16, 18, 20
  
    # mesh with pairwise
    @a = qw/a b c/;
    @b = qw/1 2 3/;
    @x = pairwise { ($a, $b) } @a, @b;    # returns a, 1, b, 2, c, 3
  
  =head3 mesh ARRAY1 ARRAY2 [ ARRAY3 ... ]
  
  =head3 zip ARRAY1 ARRAY2 [ ARRAY3 ... ]
  
  Returns a list consisting of the first elements of each array, then
  the second, then the third, etc, until all arrays are exhausted.
  
  Examples:
  
    @x = qw/a b c d/;
    @y = qw/1 2 3 4/;
    @z = mesh @x, @y;         # returns a, 1, b, 2, c, 3, d, 4
  
    @a = ('x');
    @b = ('1', '2');
    @c = qw/zip zap zot/;
    @d = mesh @a, @b, @c;   # x, 1, zip, undef, 2, zap, undef, undef, zot
  
  C<zip> is an alias for C<mesh>.
  
  =head3 zip6
  
  =head3 zip_unflatten
  
  Returns a list of arrays consisting of the first elements of each array,
  then the second, then the third, etc, until all arrays are exhausted.
  
    @x = qw/a b c d/;
    @y = qw/1 2 3 4/;
    @z = zip6 @x, @y;         # returns [a, 1], [b, 2], [c, 3], [d, 4]
  
    @a = ('x');
    @b = ('1', '2');
    @c = qw/zip zap zot/;
    @d = zip6 @a, @b, @c;     # [x, 1, zip], [undef, 2, zap], [undef, undef, zot]
  
  C<zip_unflatten> is an alias for C<zip6>.
  
  =head3 listcmp ARRAY0 ARRAY1 [ ARRAY2 ... ]
  
  Returns an associative list of elements and every I<id> of the list it
  was found in. Allowes easy implementation of @a & @b, @a | @b, @a ^ @b and
  so on.
  Undefined entries in any given array are skipped.
  
    my @a = qw(one two three four five six seven eight nine ten eleven twelve thirteen);
    my @b = qw(two three five seven eleven thirteen seventeen);
    my @c = qw(one one two three five eight thirteen twentyone);
    my %cmp = listcmp @a, @b, @c; # returns (one => [0, 2], two => [0, 1, 2], three => [0, 1, 2], four => [0], ...)
  
    my @seq = (1, 2, 3);
    my @prim = (undef, 2, 3, 5);
    my @fib = (1, 1, 2);
    my $cmp = listcmp @seq, @prim, @fib;
    # returns { 1 => [0, 2], 2 => [0, 1, 2], 3 => [0, 1], 5 => [1] }
  
  =head3 arrayify LIST[,LIST[,LIST...]]
  
  Returns a list costisting of each element of given arrays. Recursive arrays
  are flattened, too.
  
    @a = (1, [[2], 3], 4, [5], 6, [7], 8, 9);
    @l = arrayify @a;         # returns 1, 2, 3, 4, 5, 6, 7, 8, 9
  
  =head3 uniq LIST
  
  =head3 distinct LIST
  
  Returns a new list by stripping duplicate values in LIST by comparing
  the values as hash keys, except that undef is considered separate from ''.
  The order of elements in the returned list is the same as in LIST. In
  scalar context, returns the number of unique elements in LIST.
  
    my @x = uniq 1, 1, 2, 2, 3, 5, 3, 4; # returns 1 2 3 5 4
    my $x = uniq 1, 1, 2, 2, 3, 5, 3, 4; # returns 5
    # returns "Mike", "Michael", "Richard", "Rick"
    my @n = distinct "Mike", "Michael", "Richard", "Rick", "Michael", "Rick"
    # returns "A8", "", undef, "A5", "S1"
    my @s = distinct "A8", "", undef, "A5", "S1", "A5", "A8"
    # returns "Giulia", "Giulietta", undef, "", 156, "GTA", "GTV", 159, "Brera", "4C"
    my @w = uniq "Giulia", "Giulietta", undef, "", 156, "GTA", "GTV", 159, "Brera", "4C", "Giulietta", "Giulia"
  
  C<distinct> is an alias for C<uniq>.
  
  B<RT#49800> can be used to give feedback about this behavior.
  
  =head3 singleton LIST
  
  Returns a new list by stripping values in LIST occurring more than once by
  comparing the values as hash keys, except that undef is considered separate
  from ''.  The order of elements in the returned list is the same as in LIST.
  In scalar context, returns the number of elements occurring only once in LIST.
  
    my @x = singleton 1,1,2,2,3,4,5 # returns 3 4 5
  
  =head3 duplicates LIST
  
  Returns a new list by stripping values in LIST occuring less than twice by
  comparing the values as hash keys, except that undef is considered separate
  from ''.  The order of elements in the returned list is the same as in LIST.
  In scalar context, returns the number of elements occurring only once in LIST.
  
    my @y = duplicates 1,1,2,4,7,2,3,4,6,9; #returns 1,2,4
  
  =head3 frequency LIST
  
  Returns an associative list of distinct values and the corresponding frequency.
  
    my @f = frequency values %radio_nrw; # returns (
    #  'Deutschlandfunk (DLF)' => 9, 'WDR 3' => 10,
    #  'WDR 4' => 11, 'WDR 5' => 14, 'WDR Eins Live' => 14,
    #  'Deutschlandradio Kultur' => 8,...)
  
  =head3 occurrences LIST
  
  Returns a new list of frequencies and the corresponding values from LIST.
  
    my @o = occurrences ((1) x 3, (2) x 4, (3) x 2, (4) x 7, (5) x 2, (6) x 4);
    #  @o = (undef, undef, [3, 5], [1], [2, 6], undef, undef, [4]);
  
  =head3 mode LIST
  
  Returns the modal value of LIST. In scalar context, just the modal value
  is returned, in list context all probes occuring I<modal> times are returned,
  too.
  
    my @m = mode ((1) x 3, (2) x 4, (3) x 2, (4) x 7, (5) x 2, (6) x 4, (7) x 3, (8) x 7);
    #  @m = (7, 4, 8) - bimodal LIST
  
  =head2 Partitioning
  
  =head3 after BLOCK LIST
  
  Returns a list of the values of LIST after (and not including) the point
  where BLOCK returns a true value. Sets C<$_> for each element in LIST in turn.
  
    @x = after { $_ % 5 == 0 } (1..9);    # returns 6, 7, 8, 9
  
  =head3 after_incl BLOCK LIST
  
  Same as C<after> but also includes the element for which BLOCK is true.
  
  =head3 before BLOCK LIST
  
  Returns a list of values of LIST up to (and not including) the point where BLOCK
  returns a true value. Sets C<$_> for each element in LIST in turn.
  
  =head3 before_incl BLOCK LIST
  
  Same as C<before> but also includes the element for which BLOCK is true.
  
  =head3 part BLOCK LIST
  
  Partitions LIST based on the return value of BLOCK which denotes into which
  partition the current value is put.
  
  Returns a list of the partitions thusly created. Each partition created is a
  reference to an array.
  
    my $i = 0;
    my @part = part { $i++ % 2 } 1 .. 8;   # returns [1, 3, 5, 7], [2, 4, 6, 8]
  
  You can have a sparse list of partitions as well where non-set partitions will
  be undef:
  
    my @part = part { 2 } 1 .. 10;            # returns undef, undef, [ 1 .. 10 ]
  
  Be careful with negative values, though:
  
    my @part = part { -1 } 1 .. 10;
    __END__
    Modification of non-creatable array value attempted, subscript -1 ...
  
  Negative values are only ok when they refer to a partition previously created:
  
    my @idx  = ( 0, 1, -1 );
    my $i    = 0;
    my @part = part { $idx[$++ % 3] } 1 .. 8; # [1, 4, 7], [2, 3, 5, 6, 8]
  
  =head3 samples COUNT LIST
  
  Returns a new list containing COUNT random samples from LIST. Is similar to
  L<List::Util/shuffle>, but stops after COUNT.
  
    @r  = samples 10, 1..10; # same as shuffle
    @r2 = samples 5, 1..10; # gives 5 values from 1..10;
  
  =head2 Iteration
  
  =head3 each_array ARRAY1 ARRAY2 ...
  
  Creates an array iterator to return the elements of the list of arrays ARRAY1,
  ARRAY2 throughout ARRAYn in turn.  That is, the first time it is called, it
  returns the first element of each array.  The next time, it returns the second
  elements.  And so on, until all elements are exhausted.
  
  This is useful for looping over more than one array at once:
  
    my $ea = each_array(@a, @b, @c);
    while ( my ($a, $b, $c) = $ea->() )   { .... }
  
  The iterator returns the empty list when it reached the end of all arrays.
  
  If the iterator is passed an argument of 'C<index>', then it returns
  the index of the last fetched set of values, as a scalar.
  
  =head3 each_arrayref LIST
  
  Like each_array, but the arguments are references to arrays, not the
  plain arrays.
  
  =head3 natatime EXPR, LIST
  
  Creates an array iterator, for looping over an array in chunks of
  C<$n> items at a time.  (n at a time, get it?).  An example is
  probably a better explanation than I could give in words.
  
  Example:
  
    my @x = ('a' .. 'g');
    my $it = natatime 3, @x;
    while (my @vals = $it->())
    {
      print "@vals\n";
    }
  
  This prints
  
    a b c
    d e f
    g
  
  =head2 Searching
  
  =head3 firstval BLOCK LIST
  
  =head3 first_value BLOCK LIST
  
  Returns the first element in LIST for which BLOCK evaluates to true. Each
  element of LIST is set to C<$_> in turn. Returns C<undef> if no such element
  has been found.
  
  C<first_value> is an alias for C<firstval>.
  
  =head3 onlyval BLOCK LIST
  
  =head3 only_value BLOCK LIST
  
  Returns the only element in LIST for which BLOCK evaluates to true. Sets
  C<$_> for each item in LIST in turn. Returns C<undef> if no such element
  has been found.
  
  C<only_value> is an alias for C<onlyval>.
  
  =head3 lastval BLOCK LIST
  
  =head3 last_value BLOCK LIST
  
  Returns the last value in LIST for which BLOCK evaluates to true. Each element
  of LIST is set to C<$_> in turn. Returns C<undef> if no such element has been
  found.
  
  C<last_value> is an alias for C<lastval>.
  
  =head3 firstres BLOCK LIST
  
  =head3 first_result BLOCK LIST
  
  Returns the result of BLOCK for the first element in LIST for which BLOCK
  evaluates to true. Each element of LIST is set to C<$_> in turn. Returns
  C<undef> if no such element has been found.
  
  C<first_result> is an alias for C<firstres>.
  
  =head3 onlyres BLOCK LIST
  
  =head3 only_result BLOCK LIST
  
  Returns the result of BLOCK for the first element in LIST for which BLOCK
  evaluates to true. Sets C<$_> for each item in LIST in turn. Returns
  C<undef> if no such element has been found.
  
  C<only_result> is an alias for C<onlyres>.
  
  =head3 lastres BLOCK LIST
  
  =head3 last_result BLOCK LIST
  
  Returns the result of BLOCK for the last element in LIST for which BLOCK
  evaluates to true. Each element of LIST is set to C<$_> in turn. Returns
  C<undef> if no such element has been found.
  
  C<last_result> is an alias for C<lastres>.
  
  =head3 indexes BLOCK LIST
  
  Evaluates BLOCK for each element in LIST (assigned to C<$_>) and returns a list
  of the indices of those elements for which BLOCK returned a true value. This is
  just like C<grep> only that it returns indices instead of values:
  
    @x = indexes { $_ % 2 == 0 } (1..10);   # returns 1, 3, 5, 7, 9
  
  =head3 firstidx BLOCK LIST
  
  =head3 first_index BLOCK LIST
  
  Returns the index of the first element in LIST for which the criterion in BLOCK
  is true. Sets C<$_> for each item in LIST in turn:
  
    my @list = (1, 4, 3, 2, 4, 6);
    printf "item with index %i in list is 4", firstidx { $_ == 4 } @list;
    __END__
    item with index 1 in list is 4
  
  Returns C<-1> if no such item could be found.
  
  C<first_index> is an alias for C<firstidx>.
  
  =head3 onlyidx BLOCK LIST
  
  =head3 only_index BLOCK LIST
  
  Returns the index of the only element in LIST for which the criterion
  in BLOCK is true. Sets C<$_> for each item in LIST in turn:
  
      my @list = (1, 3, 4, 3, 2, 4);
      printf "uniqe index of item 2 in list is %i", onlyidx { $_ == 2 } @list;
      __END__
      unique index of item 2 in list is 4
  
  Returns C<-1> if either no such item or more than one of these
  has been found.
  
  C<only_index> is an alias for C<onlyidx>.
  
  =head3 lastidx BLOCK LIST
  
  =head3 last_index BLOCK LIST
  
  Returns the index of the last element in LIST for which the criterion in BLOCK
  is true. Sets C<$_> for each item in LIST in turn:
  
    my @list = (1, 4, 3, 2, 4, 6);
    printf "item with index %i in list is 4", lastidx { $_ == 4 } @list;
    __END__
    item with index 4 in list is 4
  
  Returns C<-1> if no such item could be found.
  
  C<last_index> is an alias for C<lastidx>.
  
  =head2 Sorting
  
  =head3 sort_by BLOCK LIST
  
  Returns the list of values sorted according to the string values returned by the
  KEYFUNC block or function. A typical use of this may be to sort objects according
  to the string value of some accessor, such as
  
    sort_by { $_->name } @people
  
  The key function is called in scalar context, being passed each value in turn as
  both $_ and the only argument in the parameters, @_. The values are then sorted
  according to string comparisons on the values returned.
  This is equivalent to
  
    sort { $a->name cmp $b->name } @people
  
  except that it guarantees the name accessor will be executed only once per value.
  One interesting use-case is to sort strings which may have numbers embedded in them
  "naturally", rather than lexically.
  
    sort_by { s/(\d+)/sprintf "%09d", $1/eg; $_ } @strings
  
  This sorts strings by generating sort keys which zero-pad the embedded numbers to
  some level (9 digits in this case), helping to ensure the lexical sort puts them
  in the correct order.
  
  =head3 nsort_by BLOCK LIST
  
  Similar to sort_by but compares its key values numerically.
  
  =head3 qsort BLOCK ARRAY
  
  This sorts the given array B<in place> using the given compare code. Except for
  tiny compare code like C<< $a <=> $b >>, qsort is much faster than Perl's C<sort>
  depending on the version.
  
  Compared 5.8 and 5.26:
  
    my @rl;
    for(my $i = 0; $i < 1E6; ++$i) { push @rl, rand(1E5) }
    my $idx;
  
    sub ext_cmp { $_[0] <=> $_[1] }
  
    cmpthese( -60, {
        'qsort' => sub {
  	  my @qrl = @rl;
  	  qsort { ext_cmp($a, $b) } @qrl;
  	  $idx = bsearchidx { ext_cmp($_, $rl[0]) } @qrl
        },
        'reverse qsort' => sub {
  	  my @qrl = @rl;
  	  qsort { ext_cmp($b, $a) } @qrl;
  	  $idx = bsearchidx { ext_cmp($rl[0], $_) } @qrl
        },
        'sort' => sub {
  	  my @srl = @rl;
  	  @srl = sort { ext_cmp($a, $b) } @srl;
  	  $idx = bsearchidx { ext_cmp($_, $rl[0]) } @srl
        },
        'reverse sort' => sub {
  	  my @srl = @rl;
  	  @srl = sort { ext_cmp($b, $a) } @srl;
  	  $idx = bsearchidx { ext_cmp($rl[0], $_) } @srl
        },
    });
  
  5.8 results
  
  		  s/iter  reverse sort          sort reverse qsort         qsort
    reverse sort    6.21            --           -0%           -8%          -10%
    sort            6.19            0%            --           -7%          -10%
    reverse qsort   5.73            8%            8%            --           -2%
    qsort           5.60           11%           11%            2%            --
  
  5.26 results
  
  		s/iter  reverse sort          sort reverse qsort         qsort
    reverse sort    4.54            --           -0%          -96%          -96%
    sort            4.52            0%            --          -96%          -96%
    reverse qsort  0.203         2139%         2131%            --          -19%
    qsort          0.164         2666%         2656%           24%            --
  
  Use it where external data sources might have to be compared (think of L<Unix::Statgrab>
  "tables").
  
  C<qsort> is available from List::MoreUtils::XS only. It's insane to maintain
  a wrapper around Perl's sort nor having a pure Perl implementation. One could
  create a flip-book in same speed as PP runs a qsort.
  
  =head2 Searching in sorted Lists
  
  =head3 bsearch BLOCK LIST
  
  Performs a binary search on LIST which must be a sorted list of values. BLOCK
  must return a negative value if the current element (stored in C<$_>) is smaller,
  a positive value if it is bigger and zero if it matches.
  
  Returns a boolean value in scalar context. In list context, it returns the element
  if it was found, otherwise the empty list.
  
  =head3 bsearchidx BLOCK LIST
  
  =head3 bsearch_index BLOCK LIST
  
  Performs a binary search on LIST which must be a sorted list of values. BLOCK
  must return a negative value if the current element (stored in C<$_>) is smaller,
  a positive value if it is bigger and zero if it matches.
  
  Returns the index of found element, otherwise C<-1>.
  
  C<bsearch_index> is an alias for C<bsearchidx>.
  
  =head3 lower_bound BLOCK LIST
  
  Returns the index of the first element in LIST which does not compare
  I<less than val>. Technically it's the first element in LIST which does
  not return a value below zero when passed to BLOCK.
  
    @ids = (1, 1, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 6, 7, 7, 7, 8, 8, 9, 9, 9, 9, 9, 11, 13, 13, 13, 17);
    $lb = lower_bound { $_ <=> 2 } @ids; # returns 2
    $lb = lower_bound { $_ <=> 4 } @ids; # returns 10
  
  lower_bound has a complexity of O(log n).
  
  =head3 upper_bound BLOCK LIST
  
  Returns the index of the first element in LIST which does not compare
  I<greater than val>. Technically it's the first element in LIST which does
  not return a value below or equal to zero when passed to BLOCK.
  
    @ids = (1, 1, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 6, 7, 7, 7, 8, 8, 9, 9, 9, 9, 9, 11, 13, 13, 13, 17);
    $lb = upper_bound { $_ <=> 2 } @ids; # returns 4
    $lb = upper_bound { $_ <=> 4 } @ids; # returns 14
  
  upper_bound has a complexity of O(log n).
  
  =head3 equal_range BLOCK LIST
  
  Returns a pair of indices containing the lower_bound and the upper_bound.
  
  =head2 Operations on sorted Lists
  
  =head3 binsert BLOCK ITEM LIST
  
  =head3 bsearch_insert BLOCK ITEM LIST
  
  Performs a binary search on LIST which must be a sorted list of values. BLOCK
  must return a negative value if the current element (stored in C<$_>) is smaller,
  a positive value if it is bigger and zero if it matches.
  
  ITEM is inserted at the index where the ITEM should be placed (based on above
  search). That means, it's inserted before the next bigger element.
  
    @l = (2,3,5,7);
    binsert { $_ <=> 4 }  4, @l; # @l = (2,3,4,5,7)
    binsert { $_ <=> 6 } 42, @l; # @l = (2,3,4,42,7)
  
  You take care that the inserted element matches the compare result.
  
  =head3 bremove BLOCK LIST
  
  =head3 bsearch_remove BLOCK LIST
  
  Performs a binary search on LIST which must be a sorted list of values. BLOCK
  must return a negative value if the current element (stored in C<$_>) is smaller,
  a positive value if it is bigger and zero if it matches.
  
  The item at the found position is removed and returned.
  
    @l = (2,3,4,5,7);
    bremove { $_ <=> 4 }, @l; # @l = (2,3,5,7);
  
  =head2 Counting and calculation
  
  =head3 true BLOCK LIST
  
  Counts the number of elements in LIST for which the criterion in BLOCK is true.
  Sets C<$_> for  each item in LIST in turn:
  
    printf "%i item(s) are defined", true { defined($_) } @list;
  
  =head3 false BLOCK LIST
  
  Counts the number of elements in LIST for which the criterion in BLOCK is false.
  Sets C<$_> for each item in LIST in turn:
  
    printf "%i item(s) are not defined", false { defined($_) } @list;
  
  =head3 reduce_0 BLOCK LIST
  
  Reduce LIST by calling BLOCK in scalar context for each element of LIST.
  C<$a> contains the progressional result and is initialized with 0.
  C<$b> contains the current processed element of LIST and C<$_> contains the
  index of the element in C<$b>.
  
  The idea behind reduce_0 is B<summation> (addition of a sequence of numbers).
  
  =head3 reduce_1 BLOCK LIST
  
  Reduce LIST by calling BLOCK in scalar context for each element of LIST.
  C<$a> contains the progressional result and is initialized with 1.
  C<$b> contains the current processed element of LIST and C<$_> contains the
  index of the element in C<$b>.
  
  The idea behind reduce_1 is product of a sequence of numbers.
  
  =head3 reduce_u BLOCK LIST
  
  Reduce LIST by calling BLOCK in scalar context for each element of LIST.
  C<$a> contains the progressional result and is initialized with 1.
  C<$b> contains the current processed element of LIST and C<$_> contains the
  index of the element in C<$b>.
  
  This function has been added if one might need the extra of the index
  value but need an individual initialization.
  
  B<Use with caution>: In most cases L<List::Util/reduce> will do the
  job better.
  
  =head3 minmax LIST
  
  Calculates the minimum and maximum of LIST and returns a two element list with
  the first element being the minimum and the second the maximum. Returns the
  empty list if LIST was empty.
  
  The C<minmax> algorithm differs from a naive iteration over the list where each
  element is compared to two values being the so far calculated min and max value
  in that it only requires 3n/2 - 2 comparisons. Thus it is the most efficient
  possible algorithm.
  
  However, the Perl implementation of it has some overhead simply due to the fact
  that there are more lines of Perl code involved. Therefore, LIST needs to be
  fairly big in order for C<minmax> to win over a naive implementation. This
  limitation does not apply to the XS version.
  
  =head3 minmaxstr LIST
  
  Computes the minimum and maximum of LIST using string compare and returns a
  two element list with the first element being the minimum and the second the
  maximum. Returns the empty list if LIST was empty.
  
  The implementation is similar to C<minmax>.
  
  =head1 ENVIRONMENT
  
  When C<LIST_MOREUTILS_PP> is set, the module will always use the pure-Perl
  implementation and not the XS one. This environment variable is really just
  there for the test-suite to force testing the Perl implementation, and possibly
  for reporting of bugs. I don't see any reason to use it in a production
  environment.
  
  =head1 MAINTENANCE
  
  The maintenance goal is to preserve the documented semantics of the API;
  bug fixes that bring actual behavior in line with semantics are allowed.
  New API functions may be added over time.  If a backwards incompatible
  change is unavoidable, we will attempt to provide support for the legacy
  API using the same export tag mechanism currently in place.
  
  This module attempts to use few non-core dependencies. Non-core
  configuration and testing modules will be bundled when reasonable;
  run-time dependencies will be added only if they deliver substantial
  benefit.
  
  =head1 CONTRIBUTING
  
  While contributions are appreciated, a contribution should not cause more
  effort for the maintainer than the contribution itself saves (see
  L<Open Source Contribution Etiquette|http://tirania.org/blog/archive/2010/Dec-31.html>).
  
  To get more familiar where help could be needed - see L<List::MoreUtils::Contributing>.
  
  =head1 BUGS
  
  There is a problem with a bug in 5.6.x perls. It is a syntax error to write
  things like:
  
      my @x = apply { s/foo/bar/ } qw{ foo bar baz };
  
  It has to be written as either
  
      my @x = apply { s/foo/bar/ } 'foo', 'bar', 'baz';
  
  or
  
      my @x = apply { s/foo/bar/ } my @dummy = qw/foo bar baz/;
  
  Perl 5.5.x and Perl 5.8.x don't suffer from this limitation.
  
  If you have a functionality that you could imagine being in this module, please
  drop me a line. This module's policy will be less strict than L<List::Util>'s
  when it comes to additions as it isn't a core module.
  
  When you report bugs, it would be nice if you could additionally give me the
  output of your program with the environment variable C<LIST_MOREUTILS_PP> set
  to a true value. That way I know where to look for the problem (in XS,
  pure-Perl or possibly both).
  
  =head1 SUPPORT
  
  Bugs should always be submitted via the CPAN bug tracker.
  
  You can find documentation for this module with the perldoc command.
  
      perldoc List::MoreUtils
  
  You can also look for information at:
  
  =over 4
  
  =item * RT: CPAN's request tracker
  
  L<https://rt.cpan.org/Dist/Display.html?Name=List-MoreUtils>
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/List-MoreUtils>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/dist/List-MoreUtils>
  
  =item * MetaCPAN
  
  L<https://metacpan.org/release/List-MoreUtils>
  
  =item * CPAN Search
  
  L<http://search.cpan.org/dist/List-MoreUtils/>
  
  =item * Git Repository
  
  L<https://github.com/perl5-utils/List-MoreUtils>
  
  =back
  
  =head2 Where can I go for help?
  
  If you have a bug report, a patch or a suggestion, please open a new
  report ticket at CPAN (but please check previous reports first in case
  your issue has already been addressed) or open an issue on GitHub.
  
  Report tickets should contain a detailed description of the bug or
  enhancement request and at least an easily verifiable way of
  reproducing the issue or fix. Patches are always welcome, too - and
  it's cheap to send pull-requests on GitHub. Please keep in mind that
  code changes are more likely accepted when they're bundled with an
  approving test.
  
  If you think you've found a bug then please read
  "How to Report Bugs Effectively" by Simon Tatham:
  L<http://www.chiark.greenend.org.uk/~sgtatham/bugs.html>.
  
  =head2 Where can I go for help with a concrete version?
  
  Bugs and feature requests are accepted against the latest version
  only. To get patches for earlier versions, you need to get an
  agreement with a developer of your choice - who may or not report the
  issue and a suggested fix upstream (depends on the license you have
  chosen).
  
  =head2 Business support and maintenance
  
  Generally, in volunteered projects, there is no right for support.
  While every maintainer is happy to improve the provided software,
  spare time is limited.
  
  For those who have a use case which requires guaranteed support, one of
  the maintainers should be hired or contracted.  For business support you
  can contact Jens via his CPAN email address rehsackATcpan.org. Please
  keep in mind that business support is neither available for free nor
  are you eligible to receive any support based on the license distributed
  with this package.
  
  =head1 THANKS
  
  =head2 Tassilo von Parseval
  
  Credits go to a number of people: Steve Purkis for giving me namespace advice
  and James Keenan and Terrence Branno for their effort of keeping the CPAN
  tidier by making L<List::Utils> obsolete.
  
  Brian McCauley suggested the inclusion of apply() and provided the pure-Perl
  implementation for it.
  
  Eric J. Roode asked me to add all functions from his module C<List::MoreUtil>
  into this one. With minor modifications, the pure-Perl implementations of those
  are by him.
  
  The bunch of people who almost immediately pointed out the many problems with
  the glitchy 0.07 release (Slaven Rezic, Ron Savage, CPAN testers).
  
  A particularly nasty memory leak was spotted by Thomas A. Lowery.
  
  Lars Thegler made me aware of problems with older Perl versions.
  
  Anno Siegel de-orphaned each_arrayref().
  
  David Filmer made me aware of a problem in each_arrayref that could ultimately
  lead to a segfault.
  
  Ricardo Signes suggested the inclusion of part() and provided the
  Perl-implementation.
  
  Robin Huston kindly fixed a bug in perl's MULTICALL API to make the
  XS-implementation of part() work.
  
  =head2 Jens Rehsack
  
  Credits goes to all people contributing feedback during the v0.400
  development releases.
  
  Special thanks goes to David Golden who spent a lot of effort to develop
  a design to support current state of CPAN as well as ancient software
  somewhere in the dark. He also contributed a lot of patches to refactor
  the API frontend to welcome any user of List::MoreUtils - from ancient
  past to recently last used.
  
  Toby Inkster provided a lot of useful feedback for sane importer code
  and was a nice sounding board for API discussions.
  
  Peter Rabbitson provided a sane git repository setup containing entire
  package history.
  
  =head1 TODO
  
  A pile of requests from other people is still pending further processing in
  my mailbox. This includes:
  
  =over 4
  
  =item * delete_index
  
  =item * random_item
  
  =item * random_item_delete_index
  
  =item * list_diff_hash
  
  =item * list_diff_inboth
  
  =item * list_diff_infirst
  
  =item * list_diff_insecond
  
  These were all suggested by Dan Muey.
  
  =item * listify
  
  Always return a flat list when either a simple scalar value was passed or an
  array-reference. Suggested by Mark Summersault.
  
  =back
  
  =head1 SEE ALSO
  
  L<List::Util>, L<List::AllUtils>, L<List::UtilsBy>
  
  =head1 AUTHOR
  
  Jens Rehsack E<lt>rehsack AT cpan.orgE<gt>
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Tassilo von Parseval E<lt>tassilo.von.parseval@rwth-aachen.deE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Some parts copyright 2011 Aaron Crane.
  
  Copyright 2004 - 2010 by Tassilo von Parseval
  
  Copyright 2013 - 2017 by Jens Rehsack
  
  All code added with 0.417 or later is licensed under the Apache License,
  Version 2.0 (the "License"); you may not use this file except in compliance
  with the License. You may obtain a copy of the License at
  
   http://www.apache.org/licenses/LICENSE-2.0
  
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  
  All code until 0.416 is licensed under the same terms as Perl itself,
  either Perl version 5.8.4 or, at your option, any later version of
  Perl 5 you may have available.
  
  =cut
  
  1;
LIST_MOREUTILS

$fatpacked{"List/MoreUtils/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIST_MOREUTILS_PP';
  package List::MoreUtils::PP;
  
  use 5.008_001;
  use strict;
  use warnings;
  
  our $VERSION = '0.428';
  
  =pod
  
  =head1 NAME
  
  List::MoreUtils::PP - Provide List::MoreUtils pure Perl implementation
  
  =head1 SYNOPSIS
  
    BEGIN { $ENV{LIST_MOREUTILS_PP} = 1; }
    use List::MoreUtils qw(:all);
  
  =cut
  
  sub any (&@)
  {
      my $f = shift;
      foreach (@_)
      {
          return 1 if $f->();
      }
      return 0;
  }
  
  sub all (&@)
  {
      my $f = shift;
      foreach (@_)
      {
          return 0 unless $f->();
      }
      return 1;
  }
  
  sub none (&@)
  {
      my $f = shift;
      foreach (@_)
      {
          return 0 if $f->();
      }
      return 1;
  }
  
  sub notall (&@)
  {
      my $f = shift;
      foreach (@_)
      {
          return 1 unless $f->();
      }
      return 0;
  }
  
  sub one (&@)
  {
      my $f     = shift;
      my $found = 0;
      foreach (@_)
      {
          $f->() and $found++ and return 0;
      }
      $found;
  }
  
  sub any_u (&@)
  {
      my $f = shift;
      return if !@_;
      $f->() and return 1 foreach (@_);
      return 0;
  }
  
  sub all_u (&@)
  {
      my $f = shift;
      return if !@_;
      $f->() or return 0 foreach (@_);
      return 1;
  }
  
  sub none_u (&@)
  {
      my $f = shift;
      return if !@_;
      $f->() and return 0 foreach (@_);
      return 1;
  }
  
  sub notall_u (&@)
  {
      my $f = shift;
      return if !@_;
      $f->() or return 1 foreach (@_);
      return 0;
  }
  
  sub one_u (&@)
  {
      my $f = shift;
      return if !@_;
      my $found = 0;
      foreach (@_)
      {
          $f->() and $found++ and return 0;
      }
      $found;
  }
  
  sub reduce_u(&@)
  {
      my $code = shift;
  
      # Localise $a, $b
      my ($caller_a, $caller_b) = do
      {
          my $pkg = caller();
          no strict 'refs';
          \*{$pkg . '::a'}, \*{$pkg . '::b'};
      };
  
      local (*$caller_a, *$caller_b);
      *$caller_a = \();
      for (0 .. $#_)
      {
          *$caller_b = \$_[$_];
          *$caller_a = \($code->());
      }
  
      ${*$caller_a};
  }
  
  sub reduce_0(&@)
  {
      my $code = shift;
  
      # Localise $a, $b
      my ($caller_a, $caller_b) = do
      {
          my $pkg = caller();
          no strict 'refs';
          \*{$pkg . '::a'}, \*{$pkg . '::b'};
      };
  
      local (*$caller_a, *$caller_b);
      *$caller_a = \0;
      for (0 .. $#_)
      {
          *$caller_b = \$_[$_];
          *$caller_a = \($code->());
      }
  
      ${*$caller_a};
  }
  
  sub reduce_1(&@)
  {
      my $code = shift;
  
      # Localise $a, $b
      my ($caller_a, $caller_b) = do
      {
          my $pkg = caller();
          no strict 'refs';
          \*{$pkg . '::a'}, \*{$pkg . '::b'};
      };
  
      local (*$caller_a, *$caller_b);
      *$caller_a = \1;
      for (0 .. $#_)
      {
          *$caller_b = \$_[$_];
          *$caller_a = \($code->());
      }
  
      ${*$caller_a};
  }
  
  sub true (&@)
  {
      my $f     = shift;
      my $count = 0;
      $f->() and ++$count foreach (@_);
      return $count;
  }
  
  sub false (&@)
  {
      my $f     = shift;
      my $count = 0;
      $f->() or ++$count foreach (@_);
      return $count;
  }
  
  sub firstidx (&@)
  {
      my $f = shift;
      foreach my $i (0 .. $#_)
      {
          local *_ = \$_[$i];
          return $i if $f->();
      }
      return -1;
  }
  
  sub firstval (&@)
  {
      my $test = shift;
      foreach (@_)
      {
          return $_ if $test->();
      }
      return undef;
  }
  
  sub firstres (&@)
  {
      my $test = shift;
      foreach (@_)
      {
          my $testval = $test->();
          $testval and return $testval;
      }
      return undef;
  }
  
  sub onlyidx (&@)
  {
      my $f = shift;
      my $found;
      foreach my $i (0 .. $#_)
      {
          local *_ = \$_[$i];
          $f->() or next;
          defined $found and return -1;
          $found = $i;
      }
      return defined $found ? $found : -1;
  }
  
  sub onlyval (&@)
  {
      my $test   = shift;
      my $result = undef;
      my $found  = 0;
      foreach (@_)
      {
          $test->() or next;
          $result = $_;
          $found++ and return undef;
      }
      return $result;
  }
  
  sub onlyres (&@)
  {
      my $test   = shift;
      my $result = undef;
      my $found  = 0;
      foreach (@_)
      {
          my $rv = $test->() or next;
          $result = $rv;
          $found++ and return undef;
      }
      return $found ? $result : undef;
  }
  
  sub lastidx (&@)
  {
      my $f = shift;
      foreach my $i (reverse 0 .. $#_)
      {
          local *_ = \$_[$i];
          return $i if $f->();
      }
      return -1;
  }
  
  sub lastval (&@)
  {
      my $test = shift;
      my $ix;
      for ($ix = $#_; $ix >= 0; $ix--)
      {
          local *_ = \$_[$ix];
          my $testval = $test->();
  
          # Simulate $_ as alias
          $_[$ix] = $_;
          return $_ if $testval;
      }
      return undef;
  }
  
  sub lastres (&@)
  {
      my $test = shift;
      my $ix;
      for ($ix = $#_; $ix >= 0; $ix--)
      {
          local *_ = \$_[$ix];
          my $testval = $test->();
  
          # Simulate $_ as alias
          $_[$ix] = $_;
          return $testval if $testval;
      }
      return undef;
  }
  
  sub insert_after (&$\@)
  {
      my ($f, $val, $list) = @_;
      my $c = &firstidx($f, @$list);
      @$list = (@{$list}[0 .. $c], $val, @{$list}[$c + 1 .. $#$list],) and return 1 if $c != -1;
      return 0;
  }
  
  sub insert_after_string ($$\@)
  {
      my ($string, $val, $list) = @_;
      my $c = firstidx { defined $_ and $string eq $_ } @$list;
      @$list = (@{$list}[0 .. $c], $val, @{$list}[$c + 1 .. $#$list],) and return 1 if $c != -1;
      return 0;
  }
  
  sub apply (&@)
  {
      my $action = shift;
      &$action foreach my @values = @_;
      wantarray ? @values : $values[-1];
  }
  
  sub after (&@)
  {
      my $test = shift;
      my $started;
      my $lag;
      grep $started ||= do
      {
          my $x = $lag;
          $lag = $test->();
          $x;
      }, @_;
  }
  
  sub after_incl (&@)
  {
      my $test = shift;
      my $started;
      grep $started ||= $test->(), @_;
  }
  
  sub before (&@)
  {
      my $test = shift;
      my $more = 1;
      grep $more &&= !$test->(), @_;
  }
  
  sub before_incl (&@)
  {
      my $test = shift;
      my $more = 1;
      my $lag  = 1;
      grep $more &&= do
      {
          my $x = $lag;
          $lag = !$test->();
          $x;
      }, @_;
  }
  
  sub indexes (&@)
  {
      my $test = shift;
      grep {
          local *_ = \$_[$_];
          $test->()
      } 0 .. $#_;
  }
  
  sub pairwise (&\@\@)
  {
      my $op = shift;
  
      # Symbols for caller's input arrays
      use vars qw{ @A @B };
      local (*A, *B) = @_;
  
      # Localise $a, $b
      my ($caller_a, $caller_b) = do
      {
          my $pkg = caller();
          no strict 'refs';
          \*{$pkg . '::a'}, \*{$pkg . '::b'};
      };
  
      # Loop iteration limit
      my $limit = $#A > $#B ? $#A : $#B;
  
      # This map expression is also the return value
      local (*$caller_a, *$caller_b);
      map {
          # Assign to $a, $b as refs to caller's array elements
          (*$caller_a, *$caller_b) = \($#A < $_ ? undef : $A[$_], $#B < $_ ? undef : $B[$_]);
  
          # Perform the transformation
          $op->();
      } 0 .. $limit;
  }
  
  sub each_array (\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@)
  {
      return each_arrayref(@_);
  }
  
  sub each_arrayref
  {
      my @list  = @_;    # The list of references to the arrays
      my $index = 0;     # Which one the caller will get next
      my $max   = 0;     # Number of elements in longest array
  
      # Get the length of the longest input array
      foreach (@list)
      {
          unless (ref $_ eq 'ARRAY')
          {
              require Carp;
              Carp::croak("each_arrayref: argument is not an array reference\n");
          }
          $max = @$_ if @$_ > $max;
      }
  
      # Return the iterator as a closure wrt the above variables.
      return sub {
          if (@_)
          {
              my $method = shift;
              unless ($method eq 'index')
              {
                  require Carp;
                  Carp::croak("each_array: unknown argument '$method' passed to iterator.");
              }
  
              # Return current (last fetched) index
              return undef if $index == 0 || $index > $max;
              return $index - 1;
          }
  
          # No more elements to return
          return if $index >= $max;
          my $i = $index++;
  
          # Return ith elements
          return map $_->[$i], @list;
        }
  }
  
  sub natatime ($@)
  {
      my $n    = shift;
      my @list = @_;
      return sub {
          return splice @list, 0, $n;
        }
  }
  
  # "leaks" when lexically hidden in arrayify
  my $flatten;
  $flatten = sub {
      map { (ref $_ and ("ARRAY" eq ref $_ or overload::Method($_, '@{}'))) ? ($flatten->(@{$_})) : ($_) } @_;
  };
  
  sub arrayify
  {
      map { $flatten->($_) } @_;
  }
  
  sub mesh (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@)
  {
      my $max = -1;
      $max < $#$_ && ($max = $#$_) foreach @_;
      map {
          my $ix = $_;
          map $_->[$ix], @_;
      } 0 .. $max;
  }
  
  sub zip6 (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@)
  {
      my $max = -1;
      $max < $#$_ && ($max = $#$_) foreach @_;
      map {
          my $ix = $_;
          [map $_->[$ix], @_];
      } 0 .. $max;
  }
  
  sub listcmp (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@)
  {
      my %ret;
      for (my $i = 0; $i < scalar @_; ++$i)
      {
          my %seen;
          my $k;
          foreach my $w (grep { defined $_ and not $seen{$k = $_}++ } @{$_[$i]})
          {
              $ret{$w} ||= [];
              push @{$ret{$w}}, $i;
          }
      }
      %ret;
  }
  
  sub uniq (@)
  {
      my %seen = ();
      my $k;
      my $seen_undef;
      grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_;
  }
  
  sub singleton (@)
  {
      my %seen = ();
      my $k;
      my $seen_undef;
      grep { 1 == (defined $_ ? $seen{$k = $_} : $seen_undef) }
        grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_;
  }
  
  sub duplicates (@)
  {
      my %seen = ();
      my $k;
      my $seen_undef;
      grep { 1 < (defined $_ ? $seen{$k = $_} : $seen_undef) }
        grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_;
  }
  
  sub frequency (@)
  {
      my %seen = ();
      my $k;
      my $seen_undef;
      my %h = map { defined $_ ? ($_ => $seen{$k = $_}) : () }
        grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_;
      wantarray or return (scalar keys %h) + ($seen_undef ? 1 : 0);
      undef $k;
      (%h, $seen_undef ? (\$k => $seen_undef) : ());
  }
  
  sub occurrences (@)
  {
      my %seen = ();
      my $k;
      my $seen_undef;
      my @ret;
      foreach my $l (map { $_ } grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_)
      {
          my $n = defined $l ? $seen{$l} : $seen_undef;
          defined $ret[$n] or $ret[$n] = [];
          push @{$ret[$n]}, $l;
      }
      @ret;
  }
  
  sub mode (@)
  {
      my %seen = ();
      my ($max, $k, $seen_undef) = (1);
  
      foreach (@_) { defined $_ ? ($max < ++$seen{$k = $_} and ++$max) : ($max < ++$seen_undef and ++$max) }
      wantarray or return $max;
  
      my @ret = ($max);
      foreach my $l (grep { $seen{$_} == $max } keys %seen)
      {
          push @ret, $l;
      }
      $seen_undef and $seen_undef == $max and push @ret, undef;
      @ret;
  }
  
  sub samples ($@)
  {
      my $n = shift;
      if ($n > @_)
      {
          require Carp;
          Carp::croak(sprintf("Cannot get %d samples from %d elements", $n, scalar @_));
      }
  
      for (my $i = @_; @_ - $i > $n;)
      {
          my $idx  = @_ - $i;
          my $swp  = $idx + int(rand(--$i));
          my $xchg = $_[$swp];
          $_[$swp] = $_[$idx];
          $_[$idx] = $xchg;
      }
  
      return splice @_, 0, $n;
  }
  
  sub minmax (@)
  {
      return unless @_;
      my $min = my $max = $_[0];
  
      for (my $i = 1; $i < @_; $i += 2)
      {
          if ($_[$i - 1] <= $_[$i])
          {
              $min = $_[$i - 1] if $min > $_[$i - 1];
              $max = $_[$i]     if $max < $_[$i];
          }
          else
          {
              $min = $_[$i]     if $min > $_[$i];
              $max = $_[$i - 1] if $max < $_[$i - 1];
          }
      }
  
      if (@_ & 1)
      {
          my $i = $#_;
          if ($_[$i - 1] <= $_[$i])
          {
              $min = $_[$i - 1] if $min > $_[$i - 1];
              $max = $_[$i]     if $max < $_[$i];
          }
          else
          {
              $min = $_[$i]     if $min > $_[$i];
              $max = $_[$i - 1] if $max < $_[$i - 1];
          }
      }
  
      return ($min, $max);
  }
  
  sub minmaxstr (@)
  {
      return unless @_;
      my $min = my $max = $_[0];
  
      for (my $i = 1; $i < @_; $i += 2)
      {
          if ($_[$i - 1] le $_[$i])
          {
              $min = $_[$i - 1] if $min gt $_[$i - 1];
              $max = $_[$i]     if $max lt $_[$i];
          }
          else
          {
              $min = $_[$i]     if $min gt $_[$i];
              $max = $_[$i - 1] if $max lt $_[$i - 1];
          }
      }
  
      if (@_ & 1)
      {
          my $i = $#_;
          if ($_[$i - 1] le $_[$i])
          {
              $min = $_[$i - 1] if $min gt $_[$i - 1];
              $max = $_[$i]     if $max lt $_[$i];
          }
          else
          {
              $min = $_[$i]     if $min gt $_[$i];
              $max = $_[$i - 1] if $max lt $_[$i - 1];
          }
      }
  
      return ($min, $max);
  }
  
  sub part (&@)
  {
      my ($code, @list) = @_;
      my @parts;
      push @{$parts[$code->($_)]}, $_ foreach @list;
      return @parts;
  }
  
  sub bsearch(&@)
  {
      my $code = shift;
  
      my $rc;
      my $i = 0;
      my $j = @_;
      do
      {
          my $k = int(($i + $j) / 2);
  
          $k >= @_ and return;
  
          local *_ = \$_[$k];
          $rc = $code->();
  
          $rc == 0
            and return wantarray ? $_ : 1;
  
          if ($rc < 0)
          {
              $i = $k + 1;
          }
          else
          {
              $j = $k - 1;
          }
      } until $i > $j;
  
      return;
  }
  
  sub bsearchidx(&@)
  {
      my $code = shift;
  
      my $rc;
      my $i = 0;
      my $j = @_;
      do
      {
          my $k = int(($i + $j) / 2);
  
          $k >= @_ and return -1;
  
          local *_ = \$_[$k];
          $rc = $code->();
  
          $rc == 0 and return $k;
  
          if ($rc < 0)
          {
              $i = $k + 1;
          }
          else
          {
              $j = $k - 1;
          }
      } until $i > $j;
  
      return -1;
  }
  
  sub lower_bound(&@)
  {
      my $code  = shift;
      my $count = @_;
      my $first = 0;
      while ($count > 0)
      {
          my $step = $count >> 1;
          my $it   = $first + $step;
          local *_ = \$_[$it];
          if ($code->() < 0)
          {
              $first = ++$it;
              $count -= $step + 1;
          }
          else
          {
              $count = $step;
          }
      }
  
      $first;
  }
  
  sub upper_bound(&@)
  {
      my $code  = shift;
      my $count = @_;
      my $first = 0;
      while ($count > 0)
      {
          my $step = $count >> 1;
          my $it   = $first + $step;
          local *_ = \$_[$it];
          if ($code->() <= 0)
          {
              $first = ++$it;
              $count -= $step + 1;
          }
          else
          {
              $count = $step;
          }
      }
  
      $first;
  }
  
  sub equal_range(&@)
  {
      my $lb = &lower_bound(@_);
      my $ub = &upper_bound(@_);
      ($lb, $ub);
  }
  
  sub binsert (&$\@)
  {
      my $lb = &lower_bound($_[0], @{$_[2]});
      splice @{$_[2]}, $lb, 0, $_[1];
      $lb;
  }
  
  sub bremove (&\@)
  {
      my $lb = &lower_bound($_[0], @{$_[1]});
      splice @{$_[1]}, $lb, 1;
  }
  
  sub qsort(&\@)
  {
      require Carp;
      Carp::croak("It's insane to use a pure-perl qsort");
  }
  
  sub sort_by(&@)
  {
      my ($code, @list) = @_;
      return map { $_->[0] }
        sort     { $a->[1] cmp $b->[1] }
        map { [$_, scalar($code->())] } @list;
  }
  
  sub nsort_by(&@)
  {
      my ($code, @list) = @_;
      return map { $_->[0] }
        sort     { $a->[1] <=> $b->[1] }
        map { [$_, scalar($code->())] } @list;
  }
  
  sub _XScompiled { 0 }
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 AUTHOR
  
  Jens Rehsack E<lt>rehsack AT cpan.orgE<gt>
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Tassilo von Parseval E<lt>tassilo.von.parseval@rwth-aachen.deE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Some parts copyright 2011 Aaron Crane.
  
  Copyright 2004 - 2010 by Tassilo von Parseval
  
  Copyright 2013 - 2017 by Jens Rehsack
  
  All code added with 0.417 or later is licensed under the Apache License,
  Version 2.0 (the "License"); you may not use this file except in compliance
  with the License. You may obtain a copy of the License at
  
   http://www.apache.org/licenses/LICENSE-2.0
  
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  
  All code until 0.416 is licensed under the same terms as Perl itself,
  either Perl version 5.8.4 or, at your option, any later version of
  Perl 5 you may have available.
  
  =cut
  
  1;
LIST_MOREUTILS_PP

$fatpacked{"MRO/Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MRO_COMPAT';
  package MRO::Compat;
  use strict;
  use warnings;
  require 5.006_000;
  
  # Keep this < 1.00, so people can tell the fake
  #  mro.pm from the real one
  our $VERSION = '0.13';
  
  BEGIN {
      # Alias our private functions over to
      # the mro:: namespace and load
      # Class::C3 if Perl < 5.9.5
      if($] < 5.009_005) {
          $mro::VERSION # to fool Module::Install when generating META.yml
              = $VERSION;
          $INC{'mro.pm'} = __FILE__;
          *mro::import            = \&__import;
          *mro::get_linear_isa    = \&__get_linear_isa;
          *mro::set_mro           = \&__set_mro;
          *mro::get_mro           = \&__get_mro;
          *mro::get_isarev        = \&__get_isarev;
          *mro::is_universal      = \&__is_universal;
          *mro::method_changed_in = \&__method_changed_in;
          *mro::invalidate_all_method_caches
                                  = \&__invalidate_all_method_caches;
          require Class::C3;
          if($Class::C3::XS::VERSION && $Class::C3::XS::VERSION > 0.03) {
              *mro::get_pkg_gen   = \&__get_pkg_gen_c3xs;
          }
          else {
              *mro::get_pkg_gen   = \&__get_pkg_gen_pp;
          }
      }
  
      # Load mro.pm and provide no-op Class::C3::.*initialize() funcs for 5.9.5+
      else {
          require mro;
          no warnings 'redefine';
          *Class::C3::initialize = sub { 1 };
          *Class::C3::reinitialize = sub { 1 };
          *Class::C3::uninitialize = sub { 1 };
      }
  }
  
  =head1 NAME
  
  MRO::Compat - mro::* interface compatibility for Perls < 5.9.5
  
  =head1 SYNOPSIS
  
     package PPP;      use base qw/Exporter/;
     package X;        use base qw/PPP/;
     package Y;        use base qw/PPP/;
     package Z;        use base qw/PPP/;
  
     package FooClass; use base qw/X Y Z/;
  
     package main;
     use MRO::Compat;
     my $linear = mro::get_linear_isa('FooClass');
     print join(q{, }, @$linear);
  
     # Prints: FooClass, X, PPP, Exporter, Y, Z
  
  =head1 DESCRIPTION
  
  The "mro" namespace provides several utilities for dealing
  with method resolution order and method caching in general
  in Perl 5.9.5 and higher.
  
  This module provides those interfaces for
  earlier versions of Perl (back to 5.6.0 anyways).
  
  It is a harmless no-op to use this module on 5.9.5+.  That
  is to say, code which properly uses L<MRO::Compat> will work
  unmodified on both older Perls and 5.9.5+.
  
  If you're writing a piece of software that would like to use
  the parts of 5.9.5+'s mro:: interfaces that are supported
  here, and you want compatibility with older Perls, this
  is the module for you.
  
  Some parts of this code will work better and/or faster with
  L<Class::C3::XS> installed (which is an optional prereq
  of L<Class::C3>, which is in turn a prereq of this
  package), but it's not a requirement.
  
  This module never exports any functions.  All calls must
  be fully qualified with the C<mro::> prefix.
  
  The interface documentation here serves only as a quick
  reference of what the function basically does, and what
  differences between L<MRO::Compat> and 5.9.5+ one should
  look out for.  The main docs in 5.9.5's L<mro> are the real
  interface docs, and contain a lot of other useful information.
  
  =head1 Functions
  
  =head2 mro::get_linear_isa($classname[, $type])
  
  Returns an arrayref which is the linearized "ISA" of the given class.
  Uses whichever MRO is currently in effect for that class by default,
  or the given MRO (either C<c3> or C<dfs> if specified as C<$type>).
  
  The linearized ISA of a class is a single ordered list of all of the
  classes that would be visited in the process of resolving a method
  on the given class, starting with itself.  It does not include any
  duplicate entries.
  
  Note that C<UNIVERSAL> (and any members of C<UNIVERSAL>'s MRO) are not
  part of the MRO of a class, even though all classes implicitly inherit
  methods from C<UNIVERSAL> and its parents.
  
  =cut
  
  sub __get_linear_isa_dfs {
      no strict 'refs';
  
      my $classname = shift;
  
      my @lin = ($classname);
      my %stored;
      foreach my $parent (@{"$classname\::ISA"}) {
          my $plin = __get_linear_isa_dfs($parent);
          foreach (@$plin) {
              next if exists $stored{$_};
              push(@lin, $_);
              $stored{$_} = 1;
          }
      }
      return \@lin;
  }
  
  sub __get_linear_isa {
      my ($classname, $type) = @_;
      die "mro::get_mro requires a classname" if !defined $classname;
  
      $type ||= __get_mro($classname);
      if($type eq 'dfs') {
          return __get_linear_isa_dfs($classname);
      }
      elsif($type eq 'c3') {
          return [Class::C3::calculateMRO($classname)];
      }
      die "type argument must be 'dfs' or 'c3'";
  }
  
  =head2 mro::import
  
  This allows the C<use mro 'dfs'> and
  C<use mro 'c3'> syntaxes, providing you
  L<use MRO::Compat> first.  Please see the
  L</USING C3> section for additional details.
  
  =cut
  
  sub __import {
      if($_[1]) {
          goto &Class::C3::import if $_[1] eq 'c3';
          __set_mro(scalar(caller), $_[1]);
      }
  }
  
  =head2 mro::set_mro($classname, $type)
  
  Sets the mro of C<$classname> to one of the types
  C<dfs> or C<c3>.  Please see the L</USING C3>
  section for additional details.
  
  =cut
  
  sub __set_mro {
      my ($classname, $type) = @_;
  
      if(!defined $classname || !$type) {
          die q{Usage: mro::set_mro($classname, $type)};
      }
  
      if($type eq 'c3') {
          eval "package $classname; use Class::C3";
          die $@ if $@;
      }
      elsif($type eq 'dfs') {
          # In the dfs case, check whether we need to undo C3
          if(defined $Class::C3::MRO{$classname}) {
              Class::C3::_remove_method_dispatch_table($classname);
          }
          delete $Class::C3::MRO{$classname};
      }
      else {
          die qq{Invalid mro type "$type"};
      }
  
      return;
  }
  
  =head2 mro::get_mro($classname)
  
  Returns the MRO of the given class (either C<c3> or C<dfs>).
  
  It considers any Class::C3-using class to have C3 MRO
  even before L<Class::C3::initialize()> is called.
  
  =cut
  
  sub __get_mro {
      my $classname = shift;
      die "mro::get_mro requires a classname" if !defined $classname;
      return 'c3' if exists $Class::C3::MRO{$classname};
      return 'dfs';
  }
  
  =head2 mro::get_isarev($classname)
  
  Returns an arrayref of classes who are subclasses of the
  given classname.  In other words, classes in whose @ISA
  hierarchy we appear, no matter how indirectly.
  
  This is much slower on pre-5.9.5 Perls with MRO::Compat
  than it is on 5.9.5+, as it has to search the entire
  package namespace.
  
  =cut
  
  sub __get_all_pkgs_with_isas {
      no strict 'refs';
      no warnings 'recursion';
  
      my @retval;
  
      my $search = shift;
      my $pfx;
      my $isa;
      if(defined $search) {
          $isa = \@{"$search\::ISA"};
          $pfx = "$search\::";
      }
      else {
          $search = 'main';
          $isa = \@main::ISA;
          $pfx = '';
      }
  
      push(@retval, $search) if scalar(@$isa);
  
      foreach my $cand (keys %{"$search\::"}) {
          if($cand =~ s/::$//) {
              next if $cand eq $search; # skip self-reference (main?)
              push(@retval, @{__get_all_pkgs_with_isas($pfx . $cand)});
          }
      }
  
      return \@retval;
  }
  
  sub __get_isarev_recurse {
      no strict 'refs';
  
      my ($class, $all_isas, $level) = @_;
  
      die "Recursive inheritance detected" if $level > 100;
  
      my %retval;
  
      foreach my $cand (@$all_isas) {
          my $found_me;
          foreach (@{"$cand\::ISA"}) {
              if($_ eq $class) {
                  $found_me = 1;
                  last;
              }
          }
          if($found_me) {
              $retval{$cand} = 1;
              map { $retval{$_} = 1 }
                  @{__get_isarev_recurse($cand, $all_isas, $level+1)};
          }
      }
      return [keys %retval];
  }
  
  sub __get_isarev {
      my $classname = shift;
      die "mro::get_isarev requires a classname" if !defined $classname;
  
      __get_isarev_recurse($classname, __get_all_pkgs_with_isas(), 0);
  }
  
  =head2 mro::is_universal($classname)
  
  Returns a boolean status indicating whether or not
  the given classname is either C<UNIVERSAL> itself,
  or one of C<UNIVERSAL>'s parents by C<@ISA> inheritance.
  
  Any class for which this function returns true is
  "universal" in the sense that all classes potentially
  inherit methods from it.
  
  =cut
  
  sub __is_universal {
      my $classname = shift;
      die "mro::is_universal requires a classname" if !defined $classname;
  
      my $lin = __get_linear_isa('UNIVERSAL');
      foreach (@$lin) {
          return 1 if $classname eq $_;
      }
  
      return 0;
  }
  
  =head2 mro::invalidate_all_method_caches
  
  Increments C<PL_sub_generation>, which invalidates method
  caching in all packages.
  
  Please note that this is rarely necessary, unless you are
  dealing with a situation which is known to confuse Perl's
  method caching.
  
  =cut
  
  sub __invalidate_all_method_caches {
      # Super secret mystery code :)
      @f845a9c1ac41be33::ISA = @f845a9c1ac41be33::ISA;
      return;
  }
  
  =head2 mro::method_changed_in($classname)
  
  Invalidates the method cache of any classes dependent on the
  given class.  In L<MRO::Compat> on pre-5.9.5 Perls, this is
  an alias for C<mro::invalidate_all_method_caches> above, as
  pre-5.9.5 Perls have no other way to do this.  It will still
  enforce the requirement that you pass it a classname, for
  compatibility.
  
  Please note that this is rarely necessary, unless you are
  dealing with a situation which is known to confuse Perl's
  method caching.
  
  =cut
  
  sub __method_changed_in {
      my $classname = shift;
      die "mro::method_changed_in requires a classname" if !defined $classname;
  
      __invalidate_all_method_caches();
  }
  
  =head2 mro::get_pkg_gen($classname)
  
  Returns an integer which is incremented every time a local
  method of or the C<@ISA> of the given package changes on
  Perl 5.9.5+.  On earlier Perls with this L<MRO::Compat> module,
  it will probably increment a lot more often than necessary.
  
  =cut
  
  {
      my $__pkg_gen = 2;
      sub __get_pkg_gen_pp {
          my $classname = shift;
          die "mro::get_pkg_gen requires a classname" if !defined $classname;
          return $__pkg_gen++;
      }
  }
  
  sub __get_pkg_gen_c3xs {
      my $classname = shift;
      die "mro::get_pkg_gen requires a classname" if !defined $classname;
  
      return Class::C3::XS::_plsubgen();
  }
  
  =head1 USING C3
  
  While this module makes the 5.9.5+ syntaxes
  C<use mro 'c3'> and C<mro::set_mro("Foo", 'c3')> available
  on older Perls, it does so merely by passing off the work
  to L<Class::C3>.
  
  It does not remove the need for you to call
  C<Class::C3::initialize()>, C<Class::C3::reinitialize()>, and/or
  C<Class::C3::uninitialize()> at the appropriate times
  as documented in the L<Class::C3> docs.  These three functions
  are always provided by L<MRO::Compat>, either via L<Class::C3>
  itself on older Perls, or directly as no-ops on 5.9.5+.
  
  =head1 SEE ALSO
  
  L<Class::C3>
  
  L<mro>
  
  =head1 AUTHOR
  
  Brandon L. Black, E<lt>blblack@gmail.comE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2008 Brandon L. Black E<lt>blblack@gmail.comE<gt>
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
  1;
MRO_COMPAT

$fatpacked{"Module/Implementation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_IMPLEMENTATION';
  package Module::Implementation;
  # git description: v0.08-2-gd599347
  $Module::Implementation::VERSION = '0.09';
  
  use strict;
  use warnings;
  
  use Module::Runtime 0.012 qw( require_module );
  use Try::Tiny;
  
  # This is needed for the benefit of Test::CleanNamespaces, which in turn loads
  # Package::Stash, which in turn loads this module and expects a minimum
  # version.
  unless ( exists $Module::Implementation::{VERSION}
      && ${ $Module::Implementation::{VERSION} } ) {
  
      $Module::Implementation::{VERSION} = \42;
  }
  
  my %Implementation;
  
  sub build_loader_sub {
      my $caller = caller();
  
      return _build_loader( $caller, @_ );
  }
  
  sub _build_loader {
      my $package = shift;
      my %args    = @_;
  
      my @implementations = @{ $args{implementations} };
      my @symbols = @{ $args{symbols} || [] };
  
      my $implementation;
      my $env_var = uc $package;
      $env_var =~ s/::/_/g;
      $env_var .= '_IMPLEMENTATION';
  
      return sub {
          my ( $implementation, $loaded ) = _load_implementation(
              $package,
              $ENV{$env_var},
              \@implementations,
          );
  
          $Implementation{$package} = $implementation;
  
          _copy_symbols( $loaded, $package, \@symbols );
  
          return $loaded;
      };
  }
  
  sub implementation_for {
      my $package = shift;
  
      return $Implementation{$package};
  }
  
  sub _load_implementation {
      my $package         = shift;
      my $env_value       = shift;
      my $implementations = shift;
  
      if ($env_value) {
          die "$env_value is not a valid implementation for $package"
              unless grep { $_ eq $env_value } @{$implementations};
  
          my $requested = "${package}::$env_value";
  
          # Values from the %ENV hash are tainted. We know it's safe to untaint
          # this value because the value was one of our known implementations.
          ($requested) = $requested =~ /^(.+)$/;
  
          try {
              require_module($requested);
          }
          catch {
              require Carp;
              Carp::croak("Could not load $requested: $_");
          };
  
          return ( $env_value, $requested );
      }
      else {
          my $err;
          for my $possible ( @{$implementations} ) {
              my $try = "${package}::$possible";
  
              my $ok;
              try {
                  require_module($try);
                  $ok = 1;
              }
              catch {
                  $err .= $_ if defined $_;
              };
  
              return ( $possible, $try ) if $ok;
          }
  
          require Carp;
          if ( defined $err && length $err ) {
              Carp::croak(
                  "Could not find a suitable $package implementation: $err");
          }
          else {
              Carp::croak(
                  'Module::Runtime failed to load a module but did not throw a real error. This should never happen. Something is very broken'
              );
          }
      }
  }
  
  sub _copy_symbols {
      my $from_package = shift;
      my $to_package   = shift;
      my $symbols      = shift;
  
      for my $sym ( @{$symbols} ) {
          my $type = $sym =~ s/^([\$\@\%\&\*])// ? $1 : '&';
  
          my $from = "${from_package}::$sym";
          my $to   = "${to_package}::$sym";
  
          {
              no strict 'refs';
              no warnings 'once';
  
              # Copied from Exporter
              *{$to}
                  = $type eq '&' ? \&{$from}
                  : $type eq '$' ? \${$from}
                  : $type eq '@' ? \@{$from}
                  : $type eq '%' ? \%{$from}
                  : $type eq '*' ? *{$from}
                  : die
                  "Can't copy symbol from $from_package to $to_package: $type$sym";
          }
      }
  }
  
  1;
  
  # ABSTRACT: Loads one of several alternate underlying implementations for a module
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Module::Implementation - Loads one of several alternate underlying implementations for a module
  
  =head1 VERSION
  
  version 0.09
  
  =head1 SYNOPSIS
  
    package Foo::Bar;
  
    use Module::Implementation;
  
    BEGIN {
        my $loader = Module::Implementation::build_loader_sub(
            implementations => [ 'XS',  'PurePerl' ],
            symbols         => [ 'run', 'check' ],
        );
  
        $loader->();
    }
  
    package Consumer;
  
    # loads the first viable implementation
    use Foo::Bar;
  
  =head1 DESCRIPTION
  
  This module abstracts out the process of choosing one of several underlying
  implementations for a module. This can be used to provide XS and pure Perl
  implementations of a module, or it could be used to load an implementation for
  a given OS or any other case of needing to provide multiple implementations.
  
  This module is only useful when you know all the implementations ahead of
  time. If you want to load arbitrary implementations then you probably want
  something like a plugin system, not this module.
  
  =head1 API
  
  This module provides two subroutines, neither of which are exported.
  
  =head2 Module::Implementation::build_loader_sub(...)
  
  This subroutine takes the following arguments.
  
  =over 4
  
  =item * implementations
  
  This should be an array reference of implementation names. Each name should
  correspond to a module in the caller's namespace.
  
  In other words, using the example in the L</SYNOPSIS>, this module will look
  for the C<Foo::Bar::XS> and C<Foo::Bar::PurePerl> modules.
  
  This argument is required.
  
  =item * symbols
  
  A list of symbols to copy from the implementation package to the calling
  package.
  
  These can be prefixed with a variable type: C<$>, C<@>, C<%>, C<&>, or
  C<*)>. If no prefix is given, the symbol is assumed to be a subroutine.
  
  This argument is optional.
  
  =back
  
  This subroutine I<returns> the implementation loader as a sub reference.
  
  It is up to you to call this loader sub in your code.
  
  I recommend that you I<do not> call this loader in an C<import()> sub. If a
  caller explicitly requests no imports, your C<import()> sub will not be run at
  all, which can cause weird breakage.
  
  =head2 Module::Implementation::implementation_for($package)
  
  Given a package name, this subroutine returns the implementation that was
  loaded for the package. This is not a full package name, just the suffix that
  identifies the implementation. For the L</SYNOPSIS> example, this subroutine
  would be called as C<Module::Implementation::implementation_for('Foo::Bar')>,
  and it would return "XS" or "PurePerl".
  
  =head1 HOW THE IMPLEMENTATION LOADER WORKS
  
  The implementation loader works like this ...
  
  First, it checks for an C<%ENV> var specifying the implementation to load. The
  env var is based on the package name which loads the implementations. The
  C<::> package separator is replaced with C<_>, and made entirely
  upper-case. Finally, we append "_IMPLEMENTATION" to this name.
  
  So in our L</SYNOPSIS> example, the corresponding C<%ENV> key would be
  C<FOO_BAR_IMPLEMENTATION>.
  
  If this is set, then the loader will B<only> try to load this one
  implementation.
  
  If the env var requests an implementation which doesn't match one of the
  implementations specified when the loader was created, an error is thrown.
  
  If this one implementation fails to load then loader throws an error. This is
  useful for testing. You can request a specific implementation in a test file
  by writing something like this:
  
    BEGIN { $ENV{FOO_BAR_IMPLEMENTATION} = 'XS' }
    use Foo::Bar;
  
  If the environment variable is I<not> set, then the loader simply tries the
  implementations originally passed to C<Module::Implementation>. The
  implementations are tried in the order in which they were originally passed.
  
  The loader will use the first implementation that loads without an error. It
  will copy any requested symbols from this implementation.
  
  If none of the implementations can be loaded, then the loader throws an
  exception.
  
  The loader returns the name of the package it loaded.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
MODULE_IMPLEMENTATION

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  =head1 NAME
  
  Module::Runtime - runtime module handling
  
  =head1 SYNOPSIS
  
      use Module::Runtime qw(
  	$module_name_rx is_module_name check_module_name
  	module_notional_filename require_module);
  
      if($module_name =~ /\A$module_name_rx\z/o) { ...
      if(is_module_name($module_name)) { ...
      check_module_name($module_name);
  
      $notional_filename = module_notional_filename($module_name);
      require_module($module_name);
  
      use Module::Runtime qw(use_module use_package_optimistically);
  
      $bi = use_module("Math::BigInt", 1.31)->new("1_234");
      $widget = use_package_optimistically("Local::Widget")->new;
  
      use Module::Runtime qw(
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec check_module_spec
  	compose_module_name);
  
      if($spec =~ /\A$top_module_spec_rx\z/o) { ...
      if($spec =~ /\A$sub_module_spec_rx\z/o) { ...
      if(is_module_spec("Standard::Prefix", $spec)) { ...
      check_module_spec("Standard::Prefix", $spec);
  
      $module_name = compose_module_name("Standard::Prefix", $spec);
  
  =head1 DESCRIPTION
  
  The functions exported by this module deal with runtime handling of
  Perl modules, which are normally handled at compile time.  This module
  avoids using any other modules, so that it can be used in low-level
  infrastructure.
  
  The parts of this module that work with module names apply the same syntax
  that is used for barewords in Perl source.  In principle this syntax
  can vary between versions of Perl, and this module applies the syntax of
  the Perl on which it is running.  In practice the usable syntax hasn't
  changed yet.  There's some intent for Unicode module names to be supported
  in the future, but this hasn't yet amounted to any consistent facility.
  
  The functions of this module whose purpose is to load modules include
  workarounds for three old Perl core bugs regarding C<require>.  These
  workarounds are applied on any Perl version where the bugs exist, except
  for a case where one of the bugs cannot be adequately worked around in
  pure Perl.
  
  =head2 Module name syntax
  
  The usable module name syntax has not changed from Perl 5.000 up to
  Perl 5.19.8.  The syntax is composed entirely of ASCII characters.
  From Perl 5.6 onwards there has been some attempt to allow the use of
  non-ASCII Unicode characters in Perl source, but it was fundamentally
  broken (like the entirety of Perl 5.6's Unicode handling) and remained
  pretty much entirely unusable until it got some attention in the Perl
  5.15 series.  Although Unicode is now consistently accepted by the
  parser in some places, it remains broken for module names.  Furthermore,
  there has not yet been any work on how to map Unicode module names into
  filenames, so in that respect also Unicode module names are unusable.
  
  The module name syntax is, precisely: the string must consist of one or
  more segments separated by C<::>; each segment must consist of one or more
  identifier characters (ASCII alphanumerics plus "_"); the first character
  of the string must not be a digit.  Thus "C<IO::File>", "C<warnings>",
  and "C<foo::123::x_0>" are all valid module names, whereas "C<IO::>"
  and "C<1foo::bar>" are not.  C<'> separators are not permitted by this
  module, though they remain usable in Perl source, being translated to
  C<::> in the parser.
  
  =head2 Core bugs worked around
  
  The first bug worked around is core bug [perl #68590], which causes
  lexical state in one file to leak into another that is C<require>d/C<use>d
  from it.  This bug is present from Perl 5.6 up to Perl 5.10, and is
  fixed in Perl 5.11.0.  From Perl 5.9.4 up to Perl 5.10.0 no satisfactory
  workaround is possible in pure Perl.  The workaround means that modules
  loaded via this module don't suffer this pollution of their lexical
  state.  Modules loaded in other ways, or via this module on the Perl
  versions where the pure Perl workaround is impossible, remain vulnerable.
  The module L<Lexical::SealRequireHints> provides a complete workaround
  for this bug.
  
  The second bug worked around causes some kinds of failure in module
  loading, principally compilation errors in the loaded module, to be
  recorded in C<%INC> as if they were successful, so later attempts to load
  the same module immediately indicate success.  This bug is present up
  to Perl 5.8.9, and is fixed in Perl 5.9.0.  The workaround means that a
  compilation error in a module loaded via this module won't be cached as
  a success.  Modules loaded in other ways remain liable to produce bogus
  C<%INC> entries, and if a bogus entry exists then it will mislead this
  module if it is used to re-attempt loading.
  
  The third bug worked around causes the wrong context to be seen at
  file scope of a loaded module, if C<require> is invoked in a location
  that inherits context from a higher scope.  This bug is present up to
  Perl 5.11.2, and is fixed in Perl 5.11.3.  The workaround means that
  a module loaded via this module will always see the correct context.
  Modules loaded in other ways remain vulnerable.
  
  =cut
  
  package Module::Runtime;
  
  # Don't "use 5.006" here, because Perl 5.15.6 will load feature.pm if
  # the version check is done that way.
  BEGIN { require 5.006; }
  # Don't "use warnings" here, to avoid dependencies.  Do standardise the
  # warning status by lexical override; unfortunately the only safe bitset
  # to build in is the empty set, equivalent to "no warnings".
  BEGIN { ${^WARNING_BITS} = ""; }
  # Don't "use strict" here, to avoid dependencies.
  
  our $VERSION = "0.016";
  
  # Don't use Exporter here, to avoid dependencies.
  our @EXPORT_OK = qw(
  	$module_name_rx is_module_name is_valid_module_name check_module_name
  	module_notional_filename require_module
  	use_module use_package_optimistically
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec is_valid_module_spec check_module_spec
  	compose_module_name
  );
  my %export_ok = map { ($_ => undef) } @EXPORT_OK;
  sub import {
  	my $me = shift;
  	my $callpkg = caller(0);
  	my $errs = "";
  	foreach(@_) {
  		if(exists $export_ok{$_}) {
  			# We would need to do "no strict 'refs'" here
  			# if we had enabled strict at file scope.
  			if(/\A\$(.*)\z/s) {
  				*{$callpkg."::".$1} = \$$1;
  			} else {
  				*{$callpkg."::".$_} = \&$_;
  			}
  		} else {
  			$errs .= "\"$_\" is not exported by the $me module\n";
  		}
  	}
  	if($errs ne "") {
  		die "${errs}Can't continue after import errors ".
  			"at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n";
  	}
  }
  
  # Logic duplicated from Params::Classify.  Duplicating it here avoids
  # an extensive and potentially circular dependency graph.
  sub _is_string($) {
  	my($arg) = @_;
  	return defined($arg) && ref(\$arg) eq "SCALAR";
  }
  
  =head1 REGULAR EXPRESSIONS
  
  These regular expressions do not include any anchors, so to check
  whether an entire string matches a syntax item you must supply the
  anchors yourself.
  
  =over
  
  =item $module_name_rx
  
  Matches a valid Perl module name in bareword syntax.
  
  =cut
  
  our $module_name_rx = qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;
  
  =item $top_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where no prefix is being used.
  
  =cut
  
  my $qual_module_spec_rx =
  	qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  my $unqual_top_module_spec_rx =
  	qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $top_module_spec_rx = qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;
  
  =item $sub_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where a prefix is being used.
  
  =cut
  
  my $unqual_sub_module_spec_rx = qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $sub_module_spec_rx = qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 Basic module handling
  
  =over
  
  =item is_module_name(ARG)
  
  Returns a truth value indicating whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  
  =cut
  
  sub is_module_name($) { _is_string($_[0]) && $_[0] =~ /\A$module_name_rx\z/o }
  
  =item is_valid_module_name(ARG)
  
  Deprecated alias for L</is_module_name>.
  
  =cut
  
  *is_valid_module_name = \&is_module_name;
  
  =item check_module_name(ARG)
  
  Check whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_name($) {
  	unless(&is_module_name) {
  		die +(_is_string($_[0]) ? "`$_[0]'" : "argument").
  			" is not a module name\n";
  	}
  }
  
  =item module_notional_filename(NAME)
  
  Generates a notional relative filename for a module, which is used in
  some Perl core interfaces.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The notional filename for the named module is generated and returned.
  This filename is always in Unix style, with C</> directory separators
  and a C<.pm> suffix.  This kind of filename can be used as an argument to
  C<require>, and is the key that appears in C<%INC> to identify a module,
  regardless of actual local filename syntax.
  
  =cut
  
  sub module_notional_filename($) {
  	&check_module_name;
  	my($name) = @_;
  	$name =~ s!::!/!g;
  	return $name.".pm";
  }
  
  =item require_module(NAME)
  
  This is essentially the bareword form of C<require>, in runtime form.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The module specified by I<NAME> is loaded, if it hasn't been already,
  in the manner of the bareword form of C<require>.  That means that a
  search through C<@INC> is performed, and a byte-compiled form of the
  module will be used if available.
  
  The return value is as for C<require>.  That is, it is the value returned
  by the module itself if the module is loaded anew, or C<1> if the module
  was already loaded.
  
  =cut
  
  # Don't "use constant" here, to avoid dependencies.
  BEGIN {
  	*_WORK_AROUND_HINT_LEAKAGE =
  		"$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
  			? sub(){1} : sub(){0};
  	*_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
  }
  
  BEGIN { if(_WORK_AROUND_BROKEN_MODULE_STATE) { eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  }; die $@ if $@ ne ""; } }
  
  sub require_module($) {
  	# Localise %^H to work around [perl #68590], where the bug exists
  	# and this is a satisfactory workaround.  The bug consists of
  	# %^H state leaking into each required module, polluting the
  	# module's lexical state.
  	local %^H if _WORK_AROUND_HINT_LEAKAGE;
  	if(_WORK_AROUND_BROKEN_MODULE_STATE) {
  		my $notional_filename = &module_notional_filename;
  		my $guard = bless([ $notional_filename ],
  				"Module::Runtime::__GUARD__");
  		my $result = CORE::require($notional_filename);
  		pop @$guard;
  		return $result;
  	} else {
  		return scalar(CORE::require(&module_notional_filename));
  	}
  }
  
  =back
  
  =head2 Structured module use
  
  =over
  
  =item use_module(NAME[, VERSION])
  
  This is essentially C<use> in runtime form, but without the importing
  feature (which is fundamentally a compile-time thing).  The I<NAME> is
  handled just like in C<require_module> above: it must be a module name,
  and the named module is loaded as if by the bareword form of C<require>.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded module is
  called with the specified I<VERSION> as an argument.  This normally serves to
  ensure that the version loaded is at least the version required.  This is
  the same functionality provided by the I<VERSION> parameter of C<use>.
  
  On success, the name of the module is returned.  This is unlike
  L</require_module>, and is done so that the entire call to L</use_module>
  can be used as a class name to call a constructor, as in the example in
  the synopsis.
  
  =cut
  
  sub use_module($;$) {
  	my($name, $version) = @_;
  	require_module($name);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =item use_package_optimistically(NAME[, VERSION])
  
  This is an analogue of L</use_module> for the situation where there is
  uncertainty as to whether a package/class is defined in its own module
  or by some other means.  It attempts to arrange for the named package to
  be available, either by loading a module or by doing nothing and hoping.
  
  An attempt is made to load the named module (as if by the bareword form
  of C<require>).  If the module cannot be found then it is assumed that
  the package was actually already loaded by other means, and no error
  is signalled.  That's the optimistic bit.
  
  I<Warning:> this optional module loading is liable to cause unreliable
  behaviour, including security problems.  It interacts especially badly
  with having C<.> in C<@INC>, which was the default state of affairs in
  Perls prior to 5.25.11.  If a package is actually defined by some means
  other than a module, then applying this function to it causes a spurious
  attempt to load a module that is expected to be non-existent.  If a
  module actually exists under that name then it will be unintentionally
  loaded.  If C<.> is in C<@INC> and this code is ever run with the current
  directory being one writable by a malicious user (such as F</tmp>), then
  the malicious user can easily cause the victim to run arbitrary code, by
  creating a module file under the predictable spuriously-loaded name in the
  writable directory.  Generally, optional module loading should be avoided.
  
  This is mostly the same operation that is performed by the L<base> pragma
  to ensure that the specified base classes are available.  The behaviour
  of L<base> was simplified in version 2.18, and later improved in version
  2.20, and on both occasions this function changed to match.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded package is
  called with the specified I<VERSION> as an argument.  This normally serves
  to ensure that the version loaded is at least the version required.
  On success, the name of the package is returned.  These aspects of the
  function work just like L</use_module>.
  
  =cut
  
  sub use_package_optimistically($;$) {
  	my($name, $version) = @_;
  	my $fn = module_notional_filename($name);
  	eval { local $SIG{__DIE__}; require_module($name); };
  	die $@ if $@ ne "" &&
  		($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s ||
  		 $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =back
  
  =head2 Module name composition
  
  =over
  
  =item is_module_spec(PREFIX, SPEC)
  
  Returns a truth value indicating
  whether I<SPEC> is valid input for L</compose_module_name>.
  See below for what that entails.  Whether a I<PREFIX> is supplied affects
  the validity of I<SPEC>, but the exact value of the prefix is unimportant,
  so this function treats I<PREFIX> as a truth value.
  
  =cut
  
  sub is_module_spec($$) {
  	my($prefix, $spec) = @_;
  	return _is_string($spec) &&
  		$spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o :
  				    qr/\A$top_module_spec_rx\z/o);
  }
  
  =item is_valid_module_spec(PREFIX, SPEC)
  
  Deprecated alias for L</is_module_spec>.
  
  =cut
  
  *is_valid_module_spec = \&is_module_spec;
  
  =item check_module_spec(PREFIX, SPEC)
  
  Check whether I<SPEC> is valid input for L</compose_module_name>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_spec($$) {
  	unless(&is_module_spec) {
  		die +(_is_string($_[1]) ? "`$_[1]'" : "argument").
  			" is not a module specification\n";
  	}
  }
  
  =item compose_module_name(PREFIX, SPEC)
  
  This function is intended to make it more convenient for a user to specify
  a Perl module name at runtime.  Users have greater need for abbreviations
  and context-sensitivity than programmers, and Perl module names get a
  little unwieldy.  I<SPEC> is what the user specifies, and this function
  translates it into a module name in standard form, which it returns.
  
  I<SPEC> has syntax approximately that of a standard module name: it
  should consist of one or more name segments, each of which consists
  of one or more identifier characters.  However, C</> is permitted as a
  separator, in addition to the standard C<::>.  The two separators are
  entirely interchangeable.
  
  Additionally, if I<PREFIX> is not C<undef> then it must be a module
  name in standard form, and it is prefixed to the user-specified name.
  The user can inhibit the prefix addition by starting I<SPEC> with a
  separator (either C</> or C<::>).
  
  =cut
  
  sub compose_module_name($$) {
  	my($prefix, $spec) = @_;
  	check_module_name($prefix) if defined $prefix;
  	&check_module_spec;
  	if($spec =~ s#\A(?:/|::)##) {
  		# OK
  	} else {
  		$spec = $prefix."::".$spec if defined $prefix;
  	}
  	$spec =~ s#/#::#g;
  	return $spec;
  }
  
  =back
  
  =head1 BUGS
  
  On Perl versions 5.7.2 to 5.8.8, if C<require> is overridden by the
  C<CORE::GLOBAL> mechanism, it is likely to break the heuristics used by
  L</use_package_optimistically>, making it signal an error for a missing
  module rather than assume that it was already loaded.  From Perl 5.8.9
  onwards, and on 5.7.1 and earlier, this module can avoid being confused
  by such an override.  On the affected versions, a C<require> override
  might be installed by L<Lexical::SealRequireHints>, if something requires
  its bugfix but for some reason its XS implementation isn't available.
  
  =head1 SEE ALSO
  
  L<Lexical::SealRequireHints>,
  L<base>,
  L<perlfunc/require>,
  L<perlfunc/use>
  
  =head1 AUTHOR
  
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2004, 2006, 2007, 2009, 2010, 2011, 2012, 2014, 2017
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
MODULE_RUNTIME

$fatpacked{"Package/Stash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH';
  package Package::Stash;
  BEGIN {
    $Package::Stash::AUTHORITY = 'cpan:DOY';
  }
  $Package::Stash::VERSION = '0.37';
  use strict;
  use warnings;
  use 5.008001;
  # ABSTRACT: routines for manipulating stashes
  
  our $IMPLEMENTATION;
  
  use Module::Implementation 0.06;
  
  BEGIN {
      local $ENV{PACKAGE_STASH_IMPLEMENTATION} = $IMPLEMENTATION
        if ( $IMPLEMENTATION and not $ENV{PACKAGE_STASH_IMPLEMENTATION} );
  
      Module::Implementation::build_loader_sub(
          implementations => [ 'XS', 'PP' ],
          symbols         => [qw(
              new
              name
              namespace
              add_symbol
              remove_glob
              has_symbol
              get_symbol
              get_or_add_symbol
              remove_symbol
              list_all_symbols
              get_all_symbols
          )],
      )->();
      $IMPLEMENTATION = Module::Implementation::implementation_for(__PACKAGE__);
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Package::Stash - routines for manipulating stashes
  
  =head1 VERSION
  
  version 0.37
  
  =head1 SYNOPSIS
  
    my $stash = Package::Stash->new('Foo');
    $stash->add_symbol('%foo', {bar => 1});
    # $Foo::foo{bar} == 1
    $stash->has_symbol('$foo') # false
    my $namespace = $stash->namespace;
    *{ $namespace->{foo} }{HASH} # {bar => 1}
  
  =head1 DESCRIPTION
  
  Manipulating stashes (Perl's symbol tables) is occasionally necessary, but
  incredibly messy, and easy to get wrong. This module hides all of that behind a
  simple API.
  
  NOTE: Most methods in this class require a variable specification that includes
  a sigil. If this sigil is absent, it is assumed to represent the IO slot.
  
  Due to limitations in the typeglob API available to perl code, and to typeglob
  manipulation in perl being quite slow, this module provides two
  implementations - one in pure perl, and one using XS. The XS implementation is
  to be preferred for most usages; the pure perl one is provided for cases where
  XS modules are not a possibility. The current implementation in use can be set
  by setting C<$ENV{PACKAGE_STASH_IMPLEMENTATION}> or
  C<$Package::Stash::IMPLEMENTATION> before loading Package::Stash (with the
  environment variable taking precedence), otherwise, it will use the XS
  implementation if possible, falling back to the pure perl one.
  
  =head1 METHODS
  
  =head2 new $package_name
  
  Creates a new C<Package::Stash> object, for the package given as the only
  argument.
  
  =head2 name
  
  Returns the name of the package that this object represents.
  
  =head2 namespace
  
  Returns the raw stash itself.
  
  =head2 add_symbol $variable $value %opts
  
  Adds a new package symbol, for the symbol given as C<$variable>, and optionally
  gives it an initial value of C<$value>. C<$variable> should be the name of
  variable including the sigil, so
  
    Package::Stash->new('Foo')->add_symbol('%foo')
  
  will create C<%Foo::foo>.
  
  Valid options (all optional) are C<filename>, C<first_line_num>, and
  C<last_line_num>.
  
  C<$opts{filename}>, C<$opts{first_line_num}>, and C<$opts{last_line_num}> can
  be used to indicate where the symbol should be regarded as having been defined.
  Currently these values are only used if the symbol is a subroutine ('C<&>'
  sigil) and only if C<$^P & 0x10> is true, in which case the special C<%DB::sub>
  hash is updated to record the values of C<filename>, C<first_line_num>, and
  C<last_line_num> for the subroutine. If these are not passed, their values are
  inferred (as much as possible) from C<caller> information.
  
  This is especially useful for debuggers and profilers, which use C<%DB::sub> to
  determine where the source code for a subroutine can be found.  See
  L<http://perldoc.perl.org/perldebguts.html#Debugger-Internals> for more
  information about C<%DB::sub>.
  
  =head2 remove_glob $name
  
  Removes all package variables with the given name, regardless of sigil.
  
  =head2 has_symbol $variable
  
  Returns whether or not the given package variable (including sigil) exists.
  
  =head2 get_symbol $variable
  
  Returns the value of the given package variable (including sigil).
  
  =head2 get_or_add_symbol $variable
  
  Like C<get_symbol>, except that it will return an empty hashref or
  arrayref if the variable doesn't exist.
  
  =head2 remove_symbol $variable
  
  Removes the package variable described by C<$variable> (which includes the
  sigil); other variables with the same name but different sigils will be
  untouched.
  
  =head2 list_all_symbols $type_filter
  
  Returns a list of package variable names in the package, without sigils. If a
  C<type_filter> is passed, it is used to select package variables of a given
  type, where valid types are the slots of a typeglob ('SCALAR', 'CODE', 'HASH',
  etc). Note that if the package contained any C<BEGIN> blocks, perl will leave
  an empty typeglob in the C<BEGIN> slot, so this will show up if no filter is
  used (and similarly for C<INIT>, C<END>, etc).
  
  =head2 get_all_symbols $type_filter
  
  Returns a hashref, keyed by the variable names in the package. If
  C<$type_filter> is passed, the hash will contain every variable of that type in
  the package as values, otherwise, it will contain the typeglobs corresponding
  to the variable names (basically, a clone of the stash).
  
  =head1 WORKING WITH VARIABLES
  
  It is important to note, that when working with scalar variables, the default
  behavior is to B<copy> values.
  
    my $stash = Package::Stash->new('Some::Namespace');
    my $variable = 1;
    # $Some::Namespace::name is a copy of $variable
    $stash->add_symbol('$name', $variable);
    $variable++
    # $Some::Namespace::name == 1 , $variable == 2
  
  This will likely confuse people who expect it to work the same as typeglob
  assignment, which simply creates new references to existing variables.
  
    my $variable = 1;
    {
        no strict 'refs';
        # assign $Package::Stash::name = $variable
        *{'Package::Stash::name'} = \$variable;
    }
    $variable++ # affects both names
  
  If this behaviour is desired when working with Package::Stash, simply pass
  Package::Stash a scalar ref:
  
    my $stash = Package::Stash->new('Some::Namespace');
    my $variable = 1;
    # $Some::Namespace::name is now $variable
    $stash->add_symbol('$name', \$variable);
    $variable++
    # $Some::Namespace::name == 2 , $variable == 2
  
  This will be what you want as well if you're ever working with L<Readonly>
  variables:
  
    use Readonly;
    Readonly my $value, 'hello';
  
    $stash->add_symbol('$name', \$value); # reference
    print $Some::Namespace::name; # hello
    # Tries to modify the read-only 'hello' and dies.
    $Some::Namespace::name .= " world";
  
    $stash->add_symbol('$name', $value); # copy
    print $Some::Namespace::name; # hello
    # No problem, modifying a copy, not the original
    $Some::Namespace::name .= " world";
  
  =head1 BUGS / CAVEATS
  
  =over 4
  
  =item * Prior to perl 5.10, scalar slots are only considered to exist if they are defined
  
  This is due to a shortcoming within perl itself. See
  L<perlref/Making References> point 7 for more information.
  
  =item * GLOB and FORMAT variables are not (yet) accessible through this module.
  
  =item * Also, see the BUGS section for the specific backends (L<Package::Stash::XS> and L<Package::Stash::PP>)
  
  =back
  
  Please report any bugs to GitHub Issues at
  L<https://github.com/doy/package-stash/issues>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Class::MOP::Package>
  
  This module is a factoring out of code that used to live here
  
  =back
  
  =head1 SUPPORT
  
  You can find this documentation for this module with the perldoc command.
  
      perldoc Package::Stash
  
  You can also look for information at:
  
  =over 4
  
  =item * MetaCPAN
  
  L<https://metacpan.org/release/Package-Stash>
  
  =item * Github
  
  L<https://github.com/doy/package-stash>
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Package-Stash>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Package-Stash>
  
  =back
  
  =head1 HISTORY
  
  Based on code from L<Class::MOP::Package>, by Stevan Little and the Moose
  Cabal.
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy@tozt.net>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PACKAGE_STASH

$fatpacked{"Package/Stash/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH_CONFLICTS';
  package # hide from PAUSE
      Package::Stash::Conflicts;
  
  use strict;
  use warnings;
  
  # this module was generated with Dist::Zilla::Plugin::Conflicts 0.16
  
  use Dist::CheckConflicts
      -dist      => 'Package::Stash',
      -conflicts => {
          'Class::MOP' => '1.08',
          'MooseX::Method::Signatures' => '0.36',
          'MooseX::Role::WithOverloading' => '0.08',
          'namespace::clean' => '0.18',
      },
      -also => [ qw(
          B
          Carp
          Dist::CheckConflicts
          Getopt::Long
          Module::Implementation
          Scalar::Util
          Symbol
          constant
          strict
          warnings
      ) ],
  
  ;
  
  1;
  
  # ABSTRACT: Provide information on conflicts for Package::Stash
  # Dist::Zilla: -PodWeaver
PACKAGE_STASH_CONFLICTS

$fatpacked{"Package/Stash/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH_PP';
  package Package::Stash::PP;
  BEGIN {
    $Package::Stash::PP::AUTHORITY = 'cpan:DOY';
  }
  $Package::Stash::PP::VERSION = '0.37';
  use strict;
  use warnings;
  # ABSTRACT: pure perl implementation of the Package::Stash API
  
  use B;
  use Carp qw(confess);
  use Scalar::Util qw(blessed reftype weaken);
  use Symbol;
  # before 5.12, assigning to the ISA glob would make it lose its magical ->isa
  # powers
  use constant BROKEN_ISA_ASSIGNMENT => ($] < 5.012);
  # before 5.10, stashes don't ever seem to drop to a refcount of zero, so
  # weakening them isn't helpful
  use constant BROKEN_WEAK_STASH     => ($] < 5.010);
  # before 5.10, the scalar slot was always treated as existing if the
  # glob existed
  use constant BROKEN_SCALAR_INITIALIZATION => ($] < 5.010);
  # add_method on anon stashes triggers rt.perl #1804 otherwise
  # fixed in perl commit v5.13.3-70-g0fe688f
  use constant BROKEN_GLOB_ASSIGNMENT => ($] < 5.013004);
  # pre-5.10, ->isa lookups were cached in the ::ISA::CACHE:: slot
  use constant HAS_ISA_CACHE => ($] < 5.010);
  
  
  sub new {
      my $class = shift;
      my ($package) = @_;
  
      if (!defined($package) || (ref($package) && reftype($package) ne 'HASH')) {
          confess "Package::Stash->new must be passed the name of the "
                . "package to access";
      }
      elsif (ref($package) && reftype($package) eq 'HASH') {
          confess "The PP implementation of Package::Stash does not support "
                . "anonymous stashes before perl 5.14"
              if BROKEN_GLOB_ASSIGNMENT;
  
          return bless {
              'namespace' => $package,
          }, $class;
      }
      elsif ($package =~ /\A[0-9A-Z_a-z]+(?:::[0-9A-Z_a-z]+)*\z/) {
          return bless {
              'package' => $package,
          }, $class;
      }
      else {
          confess "$package is not a module name";
      }
  
  }
  
  sub name {
      confess "Can't call name as a class method"
          unless blessed($_[0]);
      confess "Can't get the name of an anonymous package"
          unless defined($_[0]->{package});
      return $_[0]->{package};
  }
  
  sub namespace {
      confess "Can't call namespace as a class method"
          unless blessed($_[0]);
  
      if (BROKEN_WEAK_STASH) {
          no strict 'refs';
          return \%{$_[0]->name . '::'};
      }
      else {
          return $_[0]->{namespace} if defined $_[0]->{namespace};
  
          {
              no strict 'refs';
              $_[0]->{namespace} = \%{$_[0]->name . '::'};
          }
  
          weaken($_[0]->{namespace});
  
          return $_[0]->{namespace};
      }
  }
  
  {
      my %SIGIL_MAP = (
          '$' => 'SCALAR',
          '@' => 'ARRAY',
          '%' => 'HASH',
          '&' => 'CODE',
          ''  => 'IO',
      );
  
      sub _deconstruct_variable_name {
          my ($variable) = @_;
  
          my @ret;
          if (ref($variable) eq 'HASH') {
              @ret = @{$variable}{qw[name sigil type]};
          }
          else {
              (defined $variable && length $variable)
                  || confess "You must pass a variable name";
  
              my $sigil = substr($variable, 0, 1, '');
  
              if (exists $SIGIL_MAP{$sigil}) {
                  @ret = ($variable, $sigil, $SIGIL_MAP{$sigil});
              }
              else {
                  @ret = ("${sigil}${variable}", '', $SIGIL_MAP{''});
              }
          }
  
          # XXX in pure perl, this will access things in inner packages,
          # in xs, this will segfault - probably look more into this at
          # some point
          ($ret[0] !~ /::/)
              || confess "Variable names may not contain ::";
  
          return @ret;
      }
  }
  
  sub _valid_for_type {
      my ($value, $type) = @_;
      if ($type eq 'HASH' || $type eq 'ARRAY'
       || $type eq 'IO'   || $type eq 'CODE') {
          return reftype($value) eq $type;
      }
      else {
          my $ref = reftype($value);
          return !defined($ref) || $ref eq 'SCALAR' || $ref eq 'REF' || $ref eq 'LVALUE' || $ref eq 'REGEXP' || $ref eq 'VSTRING';
      }
  }
  
  sub add_symbol {
      my ($self, $variable, $initial_value, %opts) = @_;
  
      my ($name, $sigil, $type) = _deconstruct_variable_name($variable);
  
      if (@_ > 2) {
          _valid_for_type($initial_value, $type)
              || confess "$initial_value is not of type $type";
  
          # cheap fail-fast check for PERLDBf_SUBLINE and '&'
          if ($^P and $^P & 0x10 && $sigil eq '&') {
              my $filename = $opts{filename};
              my $first_line_num = $opts{first_line_num};
  
              (undef, $filename, $first_line_num) = caller
                  if not defined $filename;
  
              my $last_line_num = $opts{last_line_num} || ($first_line_num ||= 0);
  
              # http://perldoc.perl.org/perldebguts.html#Debugger-Internals
              $DB::sub{$self->name . '::' . $name} = "$filename:$first_line_num-$last_line_num";
          }
      }
  
      if (BROKEN_GLOB_ASSIGNMENT) {
          if (@_ > 2) {
              no strict 'refs';
              no warnings 'redefine';
              *{ $self->name . '::' . $name } = ref $initial_value
                  ? $initial_value : \$initial_value;
          }
          else {
              no strict 'refs';
              if (BROKEN_ISA_ASSIGNMENT && $name eq 'ISA') {
                  *{ $self->name . '::' . $name };
              }
              else {
                  my $undef = _undef_ref_for_type($type);
                  *{ $self->name . '::' . $name } = $undef;
              }
          }
      }
      else {
          my $namespace = $self->namespace;
          {
              # using glob aliasing instead of Symbol::gensym, because otherwise,
              # magic doesn't get applied properly.
              # see <20120710063744.19360.qmail@lists-nntp.develooper.com> on p5p
              local *__ANON__:: = $namespace;
              no strict 'refs';
              no warnings 'void';
              no warnings 'once';
              *{"__ANON__::$name"};
          }
  
          if (@_ > 2) {
              no warnings 'redefine';
              *{ $namespace->{$name} } = ref $initial_value
                  ? $initial_value : \$initial_value;
          }
          else {
              return if BROKEN_ISA_ASSIGNMENT && $name eq 'ISA';
              *{ $namespace->{$name} } = _undef_ref_for_type($type);
          }
      }
  }
  
  sub _undef_ref_for_type {
      my ($type) = @_;
  
      if ($type eq 'ARRAY') {
          return [];
      }
      elsif ($type eq 'HASH') {
          return {};
      }
      elsif ($type eq 'SCALAR') {
          return \undef;
      }
      elsif ($type eq 'IO') {
          return Symbol::geniosym;
      }
      elsif ($type eq 'CODE') {
          confess "Don't know how to vivify CODE variables";
      }
      else {
          confess "Unknown type $type in vivication";
      }
  }
  
  sub remove_glob {
      my ($self, $name) = @_;
      delete $self->namespace->{$name};
  }
  
  sub has_symbol {
      my ($self, $variable) = @_;
  
      my ($name, $sigil, $type) = _deconstruct_variable_name($variable);
  
      my $namespace = $self->namespace;
  
      return unless exists $namespace->{$name};
  
      my $entry_ref = \$namespace->{$name};
      if (reftype($entry_ref) eq 'GLOB') {
          if ($type eq 'SCALAR') {
              if (BROKEN_SCALAR_INITIALIZATION) {
                  return defined ${ *{$entry_ref}{$type} };
              }
              else {
                  my $sv = B::svref_2object($entry_ref)->SV;
                  return $sv->isa('B::SV')
                      || ($sv->isa('B::SPECIAL')
                       && $B::specialsv_name[$$sv] ne 'Nullsv');
              }
          }
          else {
              return defined *{$entry_ref}{$type};
          }
      }
      else {
          # a symbol table entry can be -1 (stub), string (stub with prototype),
          # or reference (constant)
          return $type eq 'CODE';
      }
  }
  
  sub get_symbol {
      my ($self, $variable, %opts) = @_;
  
      my ($name, $sigil, $type) = _deconstruct_variable_name($variable);
  
      my $namespace = $self->namespace;
  
      if (!exists $namespace->{$name}) {
          if ($opts{vivify}) {
              $self->add_symbol($variable);
          }
          else {
              return undef;
          }
      }
  
      my $entry_ref = \$namespace->{$name};
  
      if (ref($entry_ref) eq 'GLOB') {
          return *{$entry_ref}{$type};
      }
      else {
          if ($type eq 'CODE') {
              if (BROKEN_GLOB_ASSIGNMENT || defined($self->{package})) {
                  no strict 'refs';
                  return \&{ $self->name . '::' . $name };
              }
  
              # XXX we should really be able to support arbitrary anonymous
              # stashes here... (not just via Package::Anon)
              if (blessed($namespace) && $namespace->isa('Package::Anon')) {
                  # ->can will call gv_init for us, which inflates the glob
                  # don't know how to do this in general
                  $namespace->bless(\(my $foo))->can($name);
              }
              else {
                  confess "Don't know how to inflate a " . ref($entry_ref)
                        . " into a full coderef (perhaps you could use"
                        . " Package::Anon instead of a bare stash?)"
              }
  
              return *{ $namespace->{$name} }{CODE};
          }
          else {
              return undef;
          }
      }
  }
  
  sub get_or_add_symbol {
      my $self = shift;
      $self->get_symbol(@_, vivify => 1);
  }
  
  sub remove_symbol {
      my ($self, $variable) = @_;
  
      my ($name, $sigil, $type) = _deconstruct_variable_name($variable);
  
      # FIXME:
      # no doubt this is grossly inefficient and
      # could be done much easier and faster in XS
  
      my %desc = (
          SCALAR => { sigil => '$', type => 'SCALAR', name => $name },
          ARRAY  => { sigil => '@', type => 'ARRAY',  name => $name },
          HASH   => { sigil => '%', type => 'HASH',   name => $name },
          CODE   => { sigil => '&', type => 'CODE',   name => $name },
          IO     => { sigil => '',  type => 'IO',     name => $name },
      );
      confess "This should never ever ever happen" if !$desc{$type};
  
      my @types_to_store = grep { $type ne $_ && $self->has_symbol($desc{$_}) }
                                keys %desc;
      my %values = map { $_, $self->get_symbol($desc{$_}) } @types_to_store;
  
      $values{SCALAR} = $self->get_symbol($desc{SCALAR})
        if !defined $values{SCALAR}
          && $type ne 'SCALAR'
          && BROKEN_SCALAR_INITIALIZATION;
  
      $self->remove_glob($name);
  
      $self->add_symbol($desc{$_} => $values{$_})
          for grep { defined $values{$_} } keys %values;
  }
  
  sub list_all_symbols {
      my ($self, $type_filter) = @_;
  
      my $namespace = $self->namespace;
      if (HAS_ISA_CACHE) {
          return grep { $_ ne '::ISA::CACHE::' } keys %{$namespace}
              unless defined $type_filter;
      }
      else {
          return keys %{$namespace}
              unless defined $type_filter;
      }
  
      # NOTE:
      # or we can filter based on
      # type (SCALAR|ARRAY|HASH|CODE)
      if ($type_filter eq 'CODE') {
          return grep {
              # any non-typeglob in the symbol table is a constant or stub
              ref(\$namespace->{$_}) ne 'GLOB'
                  # regular subs are stored in the CODE slot of the typeglob
                  || defined(*{$namespace->{$_}}{CODE})
          } keys %{$namespace};
      }
      elsif ($type_filter eq 'SCALAR') {
          return grep {
              !(HAS_ISA_CACHE && $_ eq '::ISA::CACHE::') &&
              (BROKEN_SCALAR_INITIALIZATION
                  ? (ref(\$namespace->{$_}) eq 'GLOB'
                        && defined(${*{$namespace->{$_}}{'SCALAR'}}))
                  : (do {
                        my $entry = \$namespace->{$_};
                        ref($entry) eq 'GLOB'
                            && B::svref_2object($entry)->SV->isa('B::SV')
                    }))
          } keys %{$namespace};
      }
      else {
          return grep {
              ref(\$namespace->{$_}) eq 'GLOB'
                  && defined(*{$namespace->{$_}}{$type_filter})
          } keys %{$namespace};
      }
  }
  
  sub get_all_symbols {
      my ($self, $type_filter) = @_;
  
      my $namespace = $self->namespace;
      return { %{$namespace} } unless defined $type_filter;
  
      return {
          map { $_ => $self->get_symbol({name => $_, type => $type_filter}) }
              $self->list_all_symbols($type_filter)
      }
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Package::Stash::PP - pure perl implementation of the Package::Stash API
  
  =head1 VERSION
  
  version 0.37
  
  =head1 SYNOPSIS
  
    use Package::Stash;
  
  =head1 DESCRIPTION
  
  This is a backend for L<Package::Stash> implemented in pure perl, for those without a compiler or who would like to use this inline in scripts.
  
  =head1 BUGS
  
  =over 4
  
  =item * remove_symbol also replaces the associated typeglob
  
  This can cause unexpected behavior when doing manipulation at compile time -
  removing subroutines will still allow them to be called from within the package
  as subroutines (although they will not be available as methods). This can be
  considered a feature in some cases (this is how L<namespace::clean> works, for
  instance), but should not be relied upon - use C<remove_glob> directly if you
  want this behavior.
  
  =item * Some minor memory leaks
  
  The pure perl implementation has a couple minor memory leaks (see the TODO
  tests in t/20-leaks.t) that I'm having a hard time tracking down - these may be
  core perl bugs, it's hard to tell.
  
  =back
  
  Please report any bugs through RT: email
  C<bug-package-stash at rt.cpan.org>, or browse to
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Package-Stash>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Class::MOP::Package>
  
  This module is a factoring out of code that used to live here
  
  =back
  
  =head1 SUPPORT
  
  You can find this documentation for this module with the perldoc command.
  
      perldoc Package::Stash
  
  You can also look for information at:
  
  =over 4
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/Package-Stash>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Package-Stash>
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Package-Stash>
  
  =item * Search CPAN
  
  L<http://search.cpan.org/dist/Package-Stash>
  
  =back
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy at tozt dot net>
  
  Mostly copied from code from L<Class::MOP::Package>, by Stevan Little and the
  Moose Cabal.
  
  =for Pod::Coverage BROKEN_ISA_ASSIGNMENT
  add_symbol
  get_all_symbols
  get_or_add_symbol
  get_symbol
  has_symbol
  list_all_symbols
  name
  namespace
  new
  remove_glob
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy@tozt.net>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PACKAGE_STASH_PP

$fatpacked{"Params/ValidationCompiler.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARAMS_VALIDATIONCOMPILER';
  package Params::ValidationCompiler;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.27';
  
  use Params::ValidationCompiler::Compiler;
  
  use Exporter qw( import );
  
  our @EXPORT_OK = qw( compile source_for validation_for );
  
  sub validation_for {
      return Params::ValidationCompiler::Compiler->new(@_)->subref;
  }
  
  ## no critic (TestingAndDebugging::ProhibitNoWarnings)
  no warnings 'once';
  *compile = \&validation_for;
  ## use critic
  
  sub source_for {
      return Params::ValidationCompiler::Compiler->new(@_)->source;
  }
  
  1;
  
  # ABSTRACT: Build an optimized subroutine parameter validator once, use it forever
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Params::ValidationCompiler - Build an optimized subroutine parameter validator once, use it forever
  
  =head1 VERSION
  
  version 0.27
  
  =head1 SYNOPSIS
  
      use Types::Standard qw( Int Str );
      use Params::ValidationCompiler qw( validation_for );
  
      {
          my $validator = validation_for(
              params => {
                  foo => { type => Int },
                  bar => {
                      type     => Str,
                      optional => 1,
                  },
                  baz => {
                      type    => Int,
                      default => 42,
                  },
              },
          );
  
          sub foo {
              my %args = $validator->(@_);
          }
      }
  
      {
          my $validator = validation_for(
              params => [
                  { type => Int },
                  {
                      type     => Str,
                      optional => 1,
                  },
              ],
          );
  
          sub bar {
              my ( $int, $str ) = $validator->(@_);
          }
      }
  
      {
          my $validator = validation_for(
              params => [
                  foo => { type => Int },
                  bar => {
                      type     => Str,
                      optional => 1,
                  },
              ],
              named_to_list => 1,
          );
  
          sub baz {
              my ( $foo, $bar ) = $validator->(@_);
          }
      }
  
  =head1 DESCRIPTION
  
  This module creates a customized, highly efficient parameter checking
  subroutine. It can handle named or positional parameters, and can return the
  parameters as key/value pairs or a list of values.
  
  In addition to type checks, it also supports parameter defaults, optional
  parameters, and extra "slurpy" parameters.
  
  =for Pod::Coverage compile
  
  =head1 EXPORTS
  
  This module has two options exports, C<validation_for> and C<source_for>. Both
  of these subs accept the same options:
  
  =over 4
  
  =item * params
  
  An arrayref or hashref containing a parameter specification.
  
  If you pass a hashref then the generated validator sub will expect named
  parameters. The C<params> value should be a hashref where the parameter names
  are keys and the specs are the values.
  
  If you pass an arrayref and C<named_to_list> is false, the validator will
  expect positional params. Each element of the C<params> arrayref should be a
  parameter spec.
  
  If you pass an arrayref and C<named_to_list> is true, the validator will
  expect named params, but will return a list of values. In this case the
  arrayref should contain a I<list> of key/value pairs, where parameter names
  are the keys and the specs are the values.
  
  Each spec can contain either a boolean or hashref. If the spec is a boolean,
  this indicates required (true) or optional (false).
  
  The spec hashref accepts the following keys:
  
  =over 8
  
  =item * type
  
  A type object. This can be a L<Moose> type (from L<Moose> or
  L<MooseX::Types>), a L<Type::Tiny> type, or a L<Specio> type.
  
  If the type has coercions, those will always be used.
  
  =item * default
  
  This can either be a simple (non-reference) scalar or a subroutine
  reference. The sub ref will be called without any arguments (for now).
  
  =item * optional
  
  A boolean indicating whether or not the parameter is optional. By default,
  parameters are required unless you provide a default.
  
  =back
  
  =item * slurpy
  
  If this is a simple true value, then the generated subroutine accepts
  additional arguments not specified in C<params>. By default, extra arguments
  cause an exception.
  
  You can also pass a type constraint here, in which case all extra arguments
  must be values of the specified type.
  
  =item * named_to_list
  
  If this is true, the generated subroutine will expect a list of key-value
  pairs or a hashref and it will return a list containing only values. The
  C<params> you pass must be a arrayref of key-value pairs. The order of these
  pairs determines the order in which values are returned.
  
  You cannot combine C<slurpy> with C<named_to_list> as there is no way to know
  how to order the extra return values.
  
  =back
  
  =head2 validation_for(...)
  
  This returns a subroutine that implements the specific parameter
  checking. This subroutine expects to be given the parameters to validate in
  C<@_>. If all the parameters are valid, it will return the validated
  parameters (with defaults as appropriate), either as a list of key-value pairs
  or as a list of just values. If any of the parameters are invalid it will
  throw an exception.
  
  For validators expected named params, the generated subroutine accepts either
  a list of key-value pairs or a single hashref. Otherwise the validator expects
  a list of values.
  
  For now, you must shift off the invocant yourself.
  
  This subroutine accepts the following additional parameters:
  
  =over 4
  
  =item * name
  
  If this is given, then the generated subroutine will be named using
  L<Sub::Util>. This is strongly recommended as it makes it possible to
  distinguish different check subroutines when profiling or in stack traces.
  
  This name will also be used in some exception messages, even if L<Sub::Util>
  is not available.
  
  Note that you must install L<Sub::Util> yourself separately, as it is not
  required by this distribution, in order to avoid requiring a compiler.
  
  =item * name_is_optional
  
  If this is true, then the name is ignored when C<Sub::Util> is not
  installed. If this is false, then passing a name when L<Sub::Util> cannot be
  loaded causes an exception.
  
  This is useful for CPAN modules where you want to set a name if you can, but
  you do not want to add a prerequisite on L<Sub::Util>.
  
  =item * debug
  
  Sets the C<EVAL_CLOSURE_PRINT_SOURCE> environment variable to true before
  calling C<Eval::Closure::eval_closure()>. This causes the source of the
  subroutine to be printed before it's C<eval>'d.
  
  =back
  
  =head2 source_for(...)
  
  This returns a two element list. The first is a string containing the source
  code for the generated sub. The second is a hashref of "environment" variables
  to be used when generating the subroutine. These are the arguments that are
  passed to L<Eval::Closure>.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Params-ValidationCompiler/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Params-ValidationCompiler can be found at L<https://github.com/houseabsolute/Params-ValidationCompiler>.
  
  =head1 DONATIONS
  
  If you'd like to thank me for the work I've done on this module, please
  consider making a "donation" to me via PayPal. I spend a lot of free time
  creating free software, and would appreciate any support you'd care to offer.
  
  Please note that B<I am not suggesting that you must do this> in order for me
  to continue working on this particular software. I will continue to do so,
  inasmuch as I have in the past, for as long as it interests me.
  
  Similarly, a donation made in this way will probably not make me work on this
  software much more, unless I get so many donations that I can consider working
  on free software full time (let's all have a chuckle at that together).
  
  To donate, log into PayPal and send money to autarch@urth.org, or use the
  button at L<http://www.urth.org/~autarch/fs-donation.html>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Gregory Oschwald Tomasz Konojacki
  
  =over 4
  
  =item *
  
  Gregory Oschwald <goschwald@maxmind.com>
  
  =item *
  
  Gregory Oschwald <oschwald@gmail.com>
  
  =item *
  
  Tomasz Konojacki <me@xenu.pl>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2016 - 2018 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
PARAMS_VALIDATIONCOMPILER

$fatpacked{"Params/ValidationCompiler/Compiler.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARAMS_VALIDATIONCOMPILER_COMPILER';
  package Params::ValidationCompiler::Compiler;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.27';
  
  use Carp qw( croak );
  use Eval::Closure qw( eval_closure );
  use List::Util 1.29 qw( pairkeys pairvalues );
  use Params::ValidationCompiler::Exceptions;
  use Scalar::Util qw( blessed looks_like_number reftype );
  use overload ();
  use B qw( perlstring );
  
  our @CARP_NOT = ( 'Params::ValidationCompiler', __PACKAGE__ );
  
  BEGIN {
      ## no critic (Variables::RequireInitializationForLocalVars)
      local $@;
      my $has_sub_util = eval {
          require Sub::Util;
          Sub::Util->VERSION(1.40);
          Sub::Util->import('set_subname');
          1;
      };
  
      sub HAS_SUB_UTIL () {$has_sub_util}
  
      unless ($has_sub_util) {
          *set_subname = sub {
              croak
                  'Cannot name a generated validation subroutine. Please install Sub::Util.';
          };
      }
  }
  
  my %known
      = map { $_ => 1 }
      qw( debug name name_is_optional params slurpy named_to_list );
  
  # I'd rather use Moo here but I want to make things relatively high on the
  # CPAN river like DateTime use this distro, so reducing deps is important.
  sub new {
      my $class = shift;
      my %p     = @_;
  
      unless ( exists $p{params} ) {
          croak
              q{You must provide a "params" parameter when creating a parameter validator};
      }
      if ( ref $p{params} eq 'HASH' ) {
          croak q{The "params" hashref must contain at least one key-value pair}
              unless %{ $p{params} };
  
          croak
              q{"named_to_list" must be used with arrayref params containing key-value pairs}
              if $p{named_to_list};
  
          $class->_validate_param_spec($_) for values %{ $p{params} };
      }
      elsif ( ref $p{params} eq 'ARRAY' ) {
          croak q{The "params" arrayref must contain at least one element}
              unless @{ $p{params} };
  
          my @specs
              = $p{named_to_list}
              ? pairvalues @{ $p{params} }
              : @{ $p{params} };
  
          $class->_validate_param_spec($_) for @specs;
      }
      else {
          my $type
              = !defined $p{params} ? 'an undef'
              : ref $p{params} ? q{a } . ( lc ref $p{params} ) . q{ref}
              :                  'a scalar';
  
          croak
              qq{The "params" parameter when creating a parameter validator must be a hashref or arrayref, you passed $type};
      }
  
      if ( $p{named_to_list} && $p{slurpy} ) {
          croak q{You cannot use "named_to_list" and "slurpy" together};
      }
  
      if ( exists $p{name} && ( !defined $p{name} || ref $p{name} ) ) {
          my $type
              = !defined $p{name}
              ? 'an undef'
              : q{a } . ( lc ref $p{name} ) . q{ref};
  
          croak
              qq{The "name" parameter when creating a parameter validator must be a scalar, you passed $type};
      }
  
      my @unknown = sort grep { !$known{$_} } keys %p;
      if (@unknown) {
          croak
              "You passed unknown parameters when creating a parameter validator: [@unknown]";
      }
  
      my $self = bless \%p, $class;
  
      $self->{_source} = [];
      $self->{_env}    = {};
  
      return $self;
  }
  
  {
      my %known_keys = (
          default  => 1,
          optional => 1,
          type     => 1,
      );
  
      sub _validate_param_spec {
          shift;
          my $spec = shift;
  
          my $ref = ref $spec;
          return unless $ref;
  
          croak
              "Specifications must be a scalar or hashref, but received a $ref"
              unless $ref eq 'HASH';
  
          my @unknown = sort grep { !$known_keys{$_} } keys %{$spec};
          if (@unknown) {
              croak "Specification contains unknown keys: [@unknown]";
          }
      }
  }
  
  sub name      { $_[0]->{name} }
  sub _has_name { exists $_[0]->{name} }
  
  sub _name_is_optional { $_[0]->{name_is_optional} }
  
  # I have no idea why critic thinks _caller isn't used.
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _caller { $_[0]->{caller} }
  ## use critic
  sub _has_caller { exists $_[0]->{caller} }
  
  sub params { $_[0]->{params} }
  
  sub slurpy { $_[0]->{slurpy} }
  
  sub _source { $_[0]->{_source} }
  
  sub _env { $_[0]->{_env} }
  
  sub named_to_list { $_[0]->{named_to_list} }
  
  sub _inlineable_name {
      return defined $_[0]->{name}
          ? $_[0]->{name}
          : 'an un-named validation subroutine';
  }
  
  sub _any_type_has_coercion {
      my $self = shift;
  
      return $self->{_has_coercion} if exists $self->{_has_coercion};
  
      for my $type ( $self->_types ) {
  
          # Specio
          if ( $type->can('has_coercions') && $type->has_coercions ) {
              return $self->{_has_coercion} = 1;
          }
  
          # Moose and Type::Tiny
          elsif ( $type->can('has_coercion') && $type->has_coercion ) {
              return $self->{_has_coercion} = 1;
          }
      }
  
      return $self->{_has_coercion} = 0;
  }
  
  sub _types {
      my $self = shift;
  
      my @types;
      if ( ref $self->params eq 'HASH' ) {
          @types = map { $_->{type} || () }
              grep { ref $_ } values %{ $self->params };
      }
      elsif ( ref $self->params eq 'ARRAY' ) {
          if ( $self->named_to_list ) {
              my %p = @{ $self->params };
              @types = map { $_->{type} || () } grep { ref $_ } values %p;
          }
          else {
              @types
                  = map { $_->{type} || () } grep { ref $_ } @{ $self->params };
          }
      }
  
      push @types, $self->slurpy if $self->slurpy && ref $self->slurpy;
  
      return @types;
  }
  
  sub subref {
      my $self = shift;
  
      $self->_compile;
  
      local $ENV{EVAL_CLOSURE_PRINT_SOURCE} = 1 if $self->{debug};
      my $sub = eval_closure(
          source => 'sub { ' . ( join "\n", @{ $self->_source } ) . ' };',
          environment => $self->_env,
      );
  
      if ( $self->_has_name ) {
          my $caller = $self->_has_caller ? $self->_caller : caller(1);
          my $name = join '::', $caller, $self->name;
  
          return $sub if $self->_name_is_optional && !HAS_SUB_UTIL;
          set_subname( $name, $sub );
      }
  
      return $sub;
  }
  
  sub source {
      my $self = shift;
  
      $self->_compile;
      return (
          ( join "\n", @{ $self->_source } ),
          $self->_env,
      );
  }
  
  sub _compile {
      my $self = shift;
  
      if ( ref $self->params eq 'HASH' ) {
          $self->_compile_named_args_check;
      }
      elsif ( ref $self->params eq 'ARRAY' ) {
          if ( $self->named_to_list ) {
              $self->_compile_named_args_list_check;
          }
          else {
              $self->_compile_positional_args_check;
          }
      }
  }
  
  sub _compile_named_args_check {
      my $self = shift;
  
      $self->_compile_named_args_check_body( $self->params );
      push @{ $self->_source }, 'return %args;';
  
      return;
  }
  
  sub _compile_named_args_list_check {
      my $self = shift;
  
      $self->_compile_named_args_check_body( { @{ $self->params } } );
  
      my @keys = map { perlstring($_) } pairkeys @{ $self->params };
  
      # If we don't handle the one-key case specially we end up getting a
      # warning like "Scalar value @args{"bar"} better written as $args{"bar"}
      # at ..."
      if ( @keys == 1 ) {
          push @{ $self->_source }, "return \$args{$keys[0]};";
      }
      else {
          my $keys_str = join q{, }, @keys;
          push @{ $self->_source }, "return \@args{$keys_str};";
      }
  
      return;
  }
  
  sub _compile_named_args_check_body {
      my $self   = shift;
      my $params = shift;
  
      push @{ $self->_source }, $self->_set_named_args_hash;
  
      for my $name ( sort keys %{$params} ) {
          my $spec = $params->{$name};
          $spec = { optional => !$spec } unless ref $spec;
  
          my $qname  = perlstring($name);
          my $access = "\$args{$qname}";
  
          # We check exists $spec->{optional} so as not to blow up on a
          # restricted hash.
          $self->_add_check_for_required_named_param( $access, $name )
              unless ( exists $spec->{optional} && $spec->{optional} )
              || exists $spec->{default};
  
          $self->_add_named_default_assignment(
              $access,
              $name,
              $spec->{default}
          ) if exists $spec->{default};
  
          # Same issue with restricted hashes here.
          $self->_add_type_check( $access, $name, $spec )
              if exists $spec->{type} && $spec->{type};
      }
  
      if ( $self->slurpy ) {
          $self->_add_check_for_extra_hash_param_types( $self->slurpy, $params )
              if ref $self->slurpy;
      }
      else {
          $self->_add_check_for_extra_hash_params($params);
      }
  
      return;
  }
  
  sub _set_named_args_hash {
      my $self = shift;
  
      push @{ $self->_source },
          sprintf( <<'EOF', ( $self->_inlineable_name ) x 4 );
  my %%args;
  if ( @_ %% 2 == 0 ) {
      %%args = @_;
  }
  elsif ( @_ == 1 ) {
      if ( ref $_[0] ) {
          if ( Scalar::Util::blessed( $_[0] ) ) {
              if ( overload::Overloaded( $_[0] )
                  && defined overload::Method( $_[0], '%%{}' ) ) {
  
                  %%args = %%{ $_[0] };
              }
              else {
                  Params::ValidationCompiler::Exception::BadArguments->throw(
                      message =>
                          'Expected a hash or hash reference but a single object argument was passed to %s',
                      show_trace => 1,
                  );
              }
          }
          elsif ( ref $_[0] eq 'HASH' ) {
              %%args = %%{ $_[0] };
          }
          else {
              Params::ValidationCompiler::Exception::BadArguments->throw(
                  message =>
                      'Expected a hash or hash reference but a single '
                      . ( ref $_[0] )
                      . ' reference argument was passed to %s',
                  show_trace => 1,
              );
          }
      }
      else {
          Params::ValidationCompiler::Exception::BadArguments->throw(
              message =>
                  'Expected a hash or hash reference but a single non-reference argument was passed to %s',
              show_trace => 1,
          );
      }
  }
  else {
      Params::ValidationCompiler::Exception::BadArguments->throw(
          message =>
              'Expected a hash or hash reference but an odd number of arguments was passed to %s',
          show_trace => 1,
      );
  }
  EOF
  
      return;
  }
  
  sub _add_check_for_required_named_param {
      my $self   = shift;
      my $access = shift;
      my $name   = shift;
  
      my $qname = perlstring($name);
      push @{ $self->_source },
          sprintf( <<'EOF', $access, $qname, $self->_inlineable_name, $qname );
  exists %s
      or Params::ValidationCompiler::Exception::Named::Required->throw(
      message    => %s . ' is a required parameter for %s',
      parameter  => %s,
      show_trace => 1,
      );
  EOF
  
      return;
  }
  
  sub _add_check_for_extra_hash_param_types {
      my $self   = shift;
      my $type   = shift;
      my $params = shift;
  
      $self->_env->{'%known'}
          = { map { $_ => 1 } keys %{$params} };
  
      # We need to set the name argument to something that won't conflict with
      # names someone would actually use for a parameter.
      my $check = join q{}, $self->_type_check(
          '$args{$key}',
          '__PCC extra parameters__',
          $type,
      );
      push @{ $self->_source }, sprintf( <<'EOF', $check );
  for my $key ( grep { !$known{$_} } keys %%args ) {
      %s;
  }
  EOF
  
      return;
  }
  
  sub _add_check_for_extra_hash_params {
      my $self   = shift;
      my $params = shift;
  
      $self->_env->{'%known'}
          = { map { $_ => 1 } keys %{$params} };
      push @{ $self->_source }, sprintf( <<'EOF', $self->_inlineable_name );
  my @extra = grep { !$known{$_} } keys %%args;
  if (@extra) {
      my $u = join ', ', sort @extra;
      Params::ValidationCompiler::Exception::Named::Extra->throw(
          message    => "Found extra parameters passed to %s: [$u]",
          parameters => \@extra,
          show_trace => 1,
      );
  }
  EOF
  
      return;
  }
  
  sub _compile_positional_args_check {
      my $self = shift;
  
      my @specs = $self->_munge_and_check_positional_params;
  
      my $first_optional_idx = -1;
      for my $i ( 0 .. $#specs ) {
          next unless $specs[$i]{optional} || exists $specs[$i]{default};
          $first_optional_idx = $i;
          last;
      }
  
      # If optional params start anywhere after the first parameter spec then we
      # must require at least one param. If there are no optional params then
      # they're all required.
      $self->_add_check_for_required_positional_params(
          $first_optional_idx == -1
          ? ( scalar @specs )
          : $first_optional_idx
      ) if $first_optional_idx != 0;
  
      $self->_add_check_for_extra_positional_params( scalar @specs )
          unless $self->slurpy;
  
      my $access_var = '$_';
      my $return_var = '@_';
      if ( $self->_any_type_has_coercion ) {
          push @{ $self->_source }, 'my @copy = @_;';
          $access_var = '$copy';
          $return_var = '@copy';
      }
  
      for my $i ( 0 .. $#specs ) {
          my $spec = $specs[$i];
  
          my $name = "Parameter $i";
          my $access = sprintf( '%s[%i]', $access_var, $i );
  
          $self->_add_positional_default_assignment(
              $i,
              $access,
              $name,
              $spec->{default}
          ) if exists $spec->{default};
  
          $self->_add_type_check( $access, $name, $spec )
              if $spec->{type};
      }
  
      if ( ref $self->slurpy ) {
          $self->_add_check_for_extra_positional_param_types(
              scalar @specs,
              $self->slurpy,
              $access_var,
          );
      }
  
      push @{ $self->_source }, sprintf( 'return %s;', $return_var );
  
      return;
  }
  
  sub _munge_and_check_positional_params {
      my $self = shift;
  
      my @specs;
      my $in_optional = 0;
  
      for my $spec ( @{ $self->params } ) {
          $spec = ref $spec ? $spec : { optional => !$spec };
          if ( $spec->{optional} || exists $spec->{default} ) {
              $in_optional = 1;
          }
          elsif ($in_optional) {
              croak
                  'Parameter list contains an optional parameter followed by a required parameter.';
          }
  
          push @specs, $spec;
      }
  
      return @specs;
  }
  
  sub _add_check_for_required_positional_params {
      my $self = shift;
      my $min  = shift;
  
      push @{ $self->_source },
          sprintf( <<'EOF', ($min) x 2, $self->_inlineable_name, $min );
  if ( @_ < %d ) {
      my $got = scalar @_;
      my $got_n = @_ == 1 ? 'parameter' : 'parameters';
      Params::ValidationCompiler::Exception::Positional::Required->throw(
          message    => "Got $got $got_n but expected at least %d for %s",
          minimum    => %d,
          got        => scalar @_,
          show_trace => 1,
      );
  }
  EOF
  
      return;
  }
  
  sub _add_check_for_extra_positional_param_types {
      my $self       = shift;
      my $max        = shift;
      my $type       = shift;
      my $access_var = shift;
  
      # We need to set the name argument to something that won't conflict with
      # names someone would actually use for a parameter.
      my $check = join q{}, $self->_type_check(
          sprintf( '%s[$i]', $access_var ),
          '__PCC extra parameters__',
          $type,
      );
      push @{ $self->_source }, sprintf( <<'EOF', $max, $max, $check );
  if ( @_ > %d ) {
      for my $i ( %d .. $#_ ) {
          %s;
      }
  }
  EOF
  
      return;
  }
  
  sub _add_check_for_extra_positional_params {
      my $self = shift;
      my $max  = shift;
  
      push @{ $self->_source },
          sprintf( <<'EOF', ($max) x 2, $self->_inlineable_name, $max );
  if ( @_ > %d ) {
      my $extra = @_ - %d;
      my $extra_n = $extra == 1 ? 'parameter' : 'parameters';
      Params::ValidationCompiler::Exception::Positional::Extra->throw(
          message    => "Got $extra extra $extra_n for %s",
          maximum    => %d,
          got        => scalar @_,
          show_trace => 1,
      );
  }
  EOF
  
      return;
  }
  
  sub _add_positional_default_assignment {
      my $self     = shift;
      my $position = shift;
      my $access   = shift;
      my $name     = shift;
      my $default  = shift;
  
      push @{ $self->_source }, "if ( \$#_ < $position ) {";
      $self->_add_shared_default_assignment( $access, $name, $default );
      push @{ $self->_source }, '}';
  
      return;
  }
  
  sub _add_named_default_assignment {
      my $self    = shift;
      my $access  = shift;
      my $name    = shift;
      my $default = shift;
  
      my $qname = perlstring($name);
      push @{ $self->_source }, "unless ( exists \$args{$qname} ) {";
      $self->_add_shared_default_assignment( $access, $name, $default );
      push @{ $self->_source }, '}';
  
      return;
  }
  
  sub _add_shared_default_assignment {
      my $self    = shift;
      my $access  = shift;
      my $name    = shift;
      my $default = shift;
  
      my $qname = perlstring($name);
  
      croak 'Default must be either a plain scalar or a subroutine reference'
          if ref $default && reftype($default) ne 'CODE';
  
      if ( ref $default ) {
          push @{ $self->_source }, "$access = \$defaults{$qname}->();";
          $self->_env->{'%defaults'}{$name} = $default;
      }
      else {
          if ( defined $default ) {
              if ( looks_like_number($default) ) {
                  push @{ $self->_source }, "$access = $default;";
              }
              else {
                  push @{ $self->_source },
                      "$access = " . perlstring($default) . ';';
              }
          }
          else {
              push @{ $self->_source }, "$access = undef;";
          }
      }
  
      return;
  }
  
  sub _add_type_check {
      my $self   = shift;
      my $access = shift;
      my $name   = shift;
      my $spec   = shift;
  
      my $type = $spec->{type};
      croak "Passed a type that is not an object for $name: $type"
          unless blessed $type;
  
      push @{ $self->_source }, sprintf( 'if ( exists %s ) {', $access )
          if $spec->{optional};
  
      push @{ $self->_source },
          $self->_type_check( $access, $name, $spec->{type} );
  
      push @{ $self->_source }, '}'
          if $spec->{optional};
  
      return;
  }
  
  sub _type_check {
      my $self   = shift;
      my $access = shift;
      my $name   = shift;
      my $type   = shift;
  
      # Specio
      return $type->can('can_inline_coercion_and_check')
          ? $self->_add_specio_check( $access, $name, $type )
  
          # Type::Tiny
          : $type->can('inline_assert')
          ? $self->_add_type_tiny_check( $access, $name, $type )
  
          # Moose
          : $type->can('can_be_inlined')
          ? $self->_add_moose_check( $access, $name, $type )
          : croak 'Unknown type object ' . ref $type;
  }
  
  # From reading through the Type::Tiny source, I can't see any cases where a
  # Type::Tiny type or coercion needs to provide any environment variables to
  # compile with.
  sub _add_type_tiny_check {
      my $self   = shift;
      my $access = shift;
      my $name   = shift;
      my $type   = shift;
  
      my $qname = perlstring($name);
  
      my @source;
      if ( $type->has_coercion ) {
          my $coercion = $type->coercion;
          if ( $coercion->can_be_inlined ) {
              push @source,
                  "$access = " . $coercion->inline_coercion($access) . ';';
          }
          else {
              $self->_env->{'%tt_coercions'}{$name}
                  = $coercion->compiled_coercion;
              push @source,
                  sprintf(
                  '%s = $tt_coercions{%s}->( %s );',
                  $access, $qname, $access,
                  );
          }
      }
  
      if ( $type->can_be_inlined ) {
          push @source,
              $type->inline_assert($access);
      }
      else {
          push @source,
              sprintf(
              '$types{%s}->assert_valid( %s );',
              $qname, $access,
              );
          $self->_env->{'%types'}{$name} = $type;
      }
  
      return @source;
  }
  
  sub _add_specio_check {
      my $self   = shift;
      my $access = shift;
      my $name   = shift;
      my $type   = shift;
  
      my $qname = perlstring($name);
  
      my @source;
  
      if ( $type->can_inline_coercion_and_check ) {
          if ( $type->has_coercions ) {
              my ( $source, $env ) = $type->inline_coercion_and_check($access);
              push @source, sprintf( '%s = %s;', $access, $source );
              $self->_add_to_environment(
                  sprintf(
                      'The inline_coercion_and_check for %s ',
                      $type->_description
                  ),
                  $env,
              );
          }
          else {
              my ( $source, $env ) = $type->inline_assert($access);
              push @source, $source . ';';
              $self->_add_to_environment(
                  sprintf(
                      'The inline_assert for %s ',
                      $type->_description
                  ),
                  $env,
              );
          }
      }
      else {
          my @coercions = $type->coercions;
          $self->_env->{'%specio_coercions'}{$name} = \@coercions;
          for my $i ( 0 .. $#coercions ) {
              my $c = $coercions[$i];
              if ( $c->can_be_inlined ) {
                  push @source,
                      sprintf(
                      '%s = %s if %s;',
                      $access,
                      $c->inline_coercion($access),
                      $c->from->inline_check($access)
                      );
                  $self->_add_to_environment(
                      sprintf(
                          'The inline_coercion for %s ',
                          $c->_description
                      ),
  
                      # This should really be public in Specio
                      $c->_inline_environment,
                  );
              }
              else {
                  push @source,
                      sprintf(
                      '%s = $specio_coercions{%s}[%s]->coerce(%s) if $specio_coercions{%s}[%s]->from->value_is_valid(%s);',
                      $access,
                      $qname,
                      $i,
                      $access,
                      $qname,
                      $i,
                      $access
                      );
              }
          }
  
          push @source,
              sprintf(
              '$types{%s}->validate_or_die(%s);',
              $qname, $access,
              );
  
          $self->_env->{'%types'}{$name} = $type;
      }
  
      return @source;
  }
  
  sub _add_moose_check {
      my $self   = shift;
      my $access = shift;
      my $name   = shift;
      my $type   = shift;
  
      my $qname = perlstring($name);
  
      my @source;
  
      if ( $type->has_coercion ) {
          $self->_env->{'%moose_coercions'}{$name} = $type->coercion;
          push @source,
              sprintf(
              '%s = $moose_coercions{%s}->coerce( %s );',
              $access, $qname, $access,
              );
      }
  
      $self->_env->{'%types'}{$name} = $type;
  
      my $code = <<'EOF';
  if ( !%s ) {
      my $type  = $types{%s};
      my $param = %s;
      my $value = %s;
      my $msg   = $param . q{ failed with: } . $type->get_message($value);
      die
          Params::ValidationCompiler::Exception::ValidationFailedForMooseTypeConstraint
          ->new(
          message   => $msg,
          parameter => $param,
          value     => $value,
          type      => $type,
          );
  }
  EOF
  
      my $check
          = $type->can_be_inlined
          ? $type->_inline_check($access)
          : sprintf( '$types{%s}->check( %s )', $qname, $access );
  
      push @source, sprintf(
          $code,
          $check,
          $qname,
          $qname,
          $access,
      );
  
      if ( $type->can_be_inlined ) {
          $self->_add_to_environment(
              sprintf( 'The %s type', $type->name ),
              $type->inline_environment,
          );
      }
  
      return @source;
  }
  
  sub _add_to_environment {
      my $self    = shift;
      my $what    = shift;
      my $new_env = shift;
  
      my $env = $self->_env;
      for my $key ( keys %{$new_env} ) {
          if ( exists $env->{$key} ) {
              croak sprintf(
                        '%s has an inline environment variable named %s'
                      . ' that conflicts with a variable already in the environment',
                  $what, $key
              );
          }
          $self->_env->{$key} = $new_env->{$key};
      }
  }
  
  1;
  
  # ABSTRACT: Object that implements the check subroutine compilation
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Params::ValidationCompiler::Compiler - Object that implements the check subroutine compilation
  
  =head1 VERSION
  
  version 0.27
  
  =for Pod::Coverage .*
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Params-ValidationCompiler/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Params-ValidationCompiler can be found at L<https://github.com/houseabsolute/Params-ValidationCompiler>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2016 - 2018 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
PARAMS_VALIDATIONCOMPILER_COMPILER

$fatpacked{"Params/ValidationCompiler/Exceptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARAMS_VALIDATIONCOMPILER_EXCEPTIONS';
  package Params::ValidationCompiler::Exceptions;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.27';
  
  use Exception::Class (
      'Params::ValidationCompiler::Exception::BadArguments',
      'Params::ValidationCompiler::Exception::Named::Extra' => {
          fields => ['parameters'],
      },
      'Params::ValidationCompiler::Exception::Named::Required' => {
          fields => ['parameter'],
      },
      'Params::ValidationCompiler::Exception::Positional::Extra' => {
          fields => [ 'got', 'maximum' ],
      },
      'Params::ValidationCompiler::Exception::Positional::Required' => {
          fields => [ 'got', 'minimum' ],
      },
      'Params::ValidationCompiler::Exception::ValidationFailedForMooseTypeConstraint'
          => {
          fields => [qw( parameter value type )],
          },
  );
  
  1;
  
  # ABSTRACT: Defines exceptions thrown by Params::ValidationCompiler
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Params::ValidationCompiler::Exceptions - Defines exceptions thrown by Params::ValidationCompiler
  
  =head1 VERSION
  
  version 0.27
  
  =head1 DESCRIPTION
  
  This module defines the following exceptions:
  
  =head2 Params::ValidationCompiler::Exception::BadArguments
  
  Exception thrown when @_ does not contain a hash or hashref.
  
  =head2 Params::ValidationCompiler::Exception::Named::Extra
  
  Exception thrown when @_ contains unexpected extra named arguments.
  
  =head2 Params::ValidationCompiler::Exception::Named::Required
  
  Exception thrown when a required named parameter is not passed.
  
  =head2 Params::ValidationCompiler::Exception::Positional::Extra
  
  Exception thrown when @_ contains unexpected extra arguments.
  
  =head2 Params::ValidationCompiler::Exception::Positional::Required
  
  Exception thrown when a required positional parameter is not passed.
  
  =head2 Params::ValidationCompiler::Exception::ValidationFailedForMooseTypeConstraint
  
  Exception thrown when a Moose type constraint check fails. This class provides
  the following methods:
  
  =head3 $e->parameter
  
  This returns a string describing the parameter, something like C<The 'foo'
  parameter> or C<Parameter #1>.
  
  =head3 $e->value
  
  This is the value that failed the type constraint check.
  
  =head3 $e->type
  
  This is the type constraint object that did not accept the value.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Params-ValidationCompiler/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Params-ValidationCompiler can be found at L<https://github.com/houseabsolute/Params-ValidationCompiler>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2016 - 2018 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
PARAMS_VALIDATIONCOMPILER_EXCEPTIONS

$fatpacked{"Role/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY';
  package Role::Tiny;
  
  sub _getglob { \*{$_[0]} }
  sub _getstash { \%{"$_[0]::"} }
  
  use strict;
  use warnings;
  
  our $VERSION = '2.000006';
  $VERSION =~ tr/_//d;
  
  our %INFO;
  our %APPLIED_TO;
  our %COMPOSED;
  our %COMPOSITE_INFO;
  our @ON_ROLE_CREATE;
  
  # Module state workaround totally stolen from Zefram's Module::Runtime.
  
  BEGIN {
    *_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
    *_WORK_AROUND_HINT_LEAKAGE
      = "$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
        ? sub(){1} : sub(){0};
    *_MRO_MODULE = "$]" < 5.010 ? sub(){"MRO/Compat.pm"} : sub(){"mro.pm"};
  }
  
  sub croak {
    require Carp;
    no warnings 'redefine';
    *croak = \&Carp::croak;
    goto &Carp::croak;
  }
  
  sub Role::Tiny::__GUARD__::DESTROY {
    delete $INC{$_[0]->[0]} if @{$_[0]};
  }
  
  sub _load_module {
    my ($module) = @_;
    (my $file = "$module.pm") =~ s{::}{/}g;
    return 1
      if $INC{$file};
  
    # can't just ->can('can') because a sub-package Foo::Bar::Baz
    # creates a 'Baz::' key in Foo::Bar's symbol table
    return 1
      if grep !/::\z/, keys %{_getstash($module)};
    my $guard = _WORK_AROUND_BROKEN_MODULE_STATE
      && bless([ $file ], 'Role::Tiny::__GUARD__');
    local %^H if _WORK_AROUND_HINT_LEAKAGE;
    require $file;
    pop @$guard if _WORK_AROUND_BROKEN_MODULE_STATE;
    return 1;
  }
  
  sub import {
    my $target = caller;
    my $me = shift;
    strict->import;
    warnings->import;
    $me->_install_subs($target);
    return if $me->is_role($target); # already exported into this package
    $INFO{$target}{is_role} = 1;
    # get symbol table reference
    my $stash = _getstash($target);
    # grab all *non-constant* (stash slot is not a scalarref) subs present
    # in the symbol table and store their refaddrs (no need to forcibly
    # inflate constant subs into real subs) with a map to the coderefs in
    # case of copying or re-use
    my @not_methods = map +(ref $_ eq 'CODE' ? $_ : ref $_ ? () : *$_{CODE}||()), values %$stash;
    @{$INFO{$target}{not_methods}={}}{@not_methods} = @not_methods;
    # a role does itself
    $APPLIED_TO{$target} = { $target => undef };
    foreach my $hook (@ON_ROLE_CREATE) {
      $hook->($target);
    }
  }
  
  sub _install_subs {
    my ($me, $target) = @_;
    return if $me->is_role($target);
    # install before/after/around subs
    foreach my $type (qw(before after around)) {
      *{_getglob "${target}::${type}"} = sub {
        push @{$INFO{$target}{modifiers}||=[]}, [ $type => @_ ];
        return;
      };
    }
    *{_getglob "${target}::requires"} = sub {
      push @{$INFO{$target}{requires}||=[]}, @_;
      return;
    };
    *{_getglob "${target}::with"} = sub {
      $me->apply_roles_to_package($target, @_);
      return;
    };
  }
  
  sub role_application_steps {
    qw(_install_methods _check_requires _install_modifiers _copy_applied_list);
  }
  
  sub apply_single_role_to_package {
    my ($me, $to, $role) = @_;
  
    _load_module($role);
  
    croak "This is apply_role_to_package" if ref($to);
    croak "${role} is not a Role::Tiny" unless $me->is_role($role);
  
    foreach my $step ($me->role_application_steps) {
      $me->$step($to, $role);
    }
  }
  
  sub _copy_applied_list {
    my ($me, $to, $role) = @_;
    # copy our role list into the target's
    @{$APPLIED_TO{$to}||={}}{keys %{$APPLIED_TO{$role}}} = ();
  }
  
  sub apply_roles_to_object {
    my ($me, $object, @roles) = @_;
    croak "No roles supplied!" unless @roles;
    my $class = ref($object);
    # on perl < 5.8.9, magic isn't copied to all ref copies. bless the parameter
    # directly, so at least the variable passed to us will get any magic applied
    bless($_[1], $me->create_class_with_roles($class, @roles));
  }
  
  my $role_suffix = 'A000';
  sub _composite_name {
    my ($me, $superclass, @roles) = @_;
  
    my $new_name = join(
      '__WITH__', $superclass, my $compose_name = join '__AND__', @roles
    );
  
    if (length($new_name) > 252) {
      $new_name = $COMPOSED{abbrev}{$new_name} ||= do {
        my $abbrev = substr $new_name, 0, 250 - length $role_suffix;
        $abbrev =~ s/(?<!:):$//;
        $abbrev.'__'.$role_suffix++;
      };
    }
    return wantarray ? ($new_name, $compose_name) : $new_name;
  }
  
  sub create_class_with_roles {
    my ($me, $superclass, @roles) = @_;
  
    croak "No roles supplied!" unless @roles;
  
    _load_module($superclass);
    {
      my %seen;
      if (my @dupes = grep 1 == $seen{$_}++, @roles) {
        croak "Duplicated roles: ".join(', ', @dupes);
      }
    }
  
    my ($new_name, $compose_name) = $me->_composite_name($superclass, @roles);
  
    return $new_name if $COMPOSED{class}{$new_name};
  
    foreach my $role (@roles) {
      _load_module($role);
      croak "${role} is not a Role::Tiny" unless $me->is_role($role);
    }
  
    require(_MRO_MODULE);
  
    my $composite_info = $me->_composite_info_for(@roles);
    my %conflicts = %{$composite_info->{conflicts}};
    if (keys %conflicts) {
      my $fail =
        join "\n",
          map {
            "Method name conflict for '$_' between roles "
            ."'".join("' and '", sort values %{$conflicts{$_}})."'"
            .", cannot apply these simultaneously to an object."
          } keys %conflicts;
      croak $fail;
    }
  
    my @composable = map $me->_composable_package_for($_), reverse @roles;
  
    # some methods may not exist in the role, but get generated by
    # _composable_package_for (Moose accessors via Moo).  filter out anything
    # provided by the composable packages, excluding the subs we generated to
    # make modifiers work.
    my @requires = grep {
      my $method = $_;
      !grep $_->can($method) && !$COMPOSED{role}{$_}{modifiers_only}{$method},
        @composable
    } @{$composite_info->{requires}};
  
    $me->_check_requires(
      $superclass, $compose_name, \@requires
    );
  
    *{_getglob("${new_name}::ISA")} = [ @composable, $superclass ];
  
    @{$APPLIED_TO{$new_name}||={}}{
      map keys %{$APPLIED_TO{$_}}, @roles
    } = ();
  
    $COMPOSED{class}{$new_name} = 1;
    return $new_name;
  }
  
  # preserved for compat, and apply_roles_to_package calls it to allow an
  # updated Role::Tiny to use a non-updated Moo::Role
  
  sub apply_role_to_package { shift->apply_single_role_to_package(@_) }
  
  sub apply_roles_to_package {
    my ($me, $to, @roles) = @_;
  
    return $me->apply_role_to_package($to, $roles[0]) if @roles == 1;
  
    my %conflicts = %{$me->_composite_info_for(@roles)->{conflicts}};
    my @have = grep $to->can($_), keys %conflicts;
    delete @conflicts{@have};
  
    if (keys %conflicts) {
      my $fail =
        join "\n",
          map {
            "Due to a method name conflict between roles "
            ."'".join(' and ', sort values %{$conflicts{$_}})."'"
            .", the method '$_' must be implemented by '${to}'"
          } keys %conflicts;
      croak $fail;
    }
  
    # conflicting methods are supposed to be treated as required by the
    # composed role. we don't have an actual composed role, but because
    # we know the target class already provides them, we can instead
    # pretend that the roles don't do for the duration of application.
    my @role_methods = map $me->_concrete_methods_of($_), @roles;
    # separate loops, since local ..., delete ... for ...; creates a scope
    local @{$_}{@have} for @role_methods;
    delete @{$_}{@have} for @role_methods;
  
    # the if guard here is essential since otherwise we accidentally create
    # a $INFO for something that isn't a Role::Tiny (or Moo::Role) because
    # autovivification hates us and wants us to die()
    if ($INFO{$to}) {
      delete $INFO{$to}{methods}; # reset since we're about to add methods
    }
  
    # backcompat: allow subclasses to use apply_single_role_to_package
    # to apply changes.  set a local var so ours does nothing.
    our %BACKCOMPAT_HACK;
    if($me ne __PACKAGE__
        and exists $BACKCOMPAT_HACK{$me} ? $BACKCOMPAT_HACK{$me} :
        $BACKCOMPAT_HACK{$me} =
          $me->can('role_application_steps')
            == \&role_application_steps
          && $me->can('apply_single_role_to_package')
            != \&apply_single_role_to_package
    ) {
      foreach my $role (@roles) {
        $me->apply_single_role_to_package($to, $role);
      }
    }
    else {
      foreach my $step ($me->role_application_steps) {
        foreach my $role (@roles) {
          $me->$step($to, $role);
        }
      }
    }
    $APPLIED_TO{$to}{join('|',@roles)} = 1;
  }
  
  sub _composite_info_for {
    my ($me, @roles) = @_;
    $COMPOSITE_INFO{join('|', sort @roles)} ||= do {
      foreach my $role (@roles) {
        _load_module($role);
      }
      my %methods;
      foreach my $role (@roles) {
        my $this_methods = $me->_concrete_methods_of($role);
        $methods{$_}{$this_methods->{$_}} = $role for keys %$this_methods;
      }
      my %requires;
      @requires{map @{$INFO{$_}{requires}||[]}, @roles} = ();
      delete $requires{$_} for keys %methods;
      delete $methods{$_} for grep keys(%{$methods{$_}}) == 1, keys %methods;
      +{ conflicts => \%methods, requires => [keys %requires] }
    };
  }
  
  sub _composable_package_for {
    my ($me, $role) = @_;
    my $composed_name = 'Role::Tiny::_COMPOSABLE::'.$role;
    return $composed_name if $COMPOSED{role}{$composed_name};
    $me->_install_methods($composed_name, $role);
    my $base_name = $composed_name.'::_BASE';
    # force stash to exist so ->can doesn't complain
    _getstash($base_name);
    # Not using _getglob, since setting @ISA via the typeglob breaks
    # inheritance on 5.10.0 if the stash has previously been accessed an
    # then a method called on the class (in that order!), which
    # ->_install_methods (with the help of ->_install_does) ends up doing.
    { no strict 'refs'; @{"${composed_name}::ISA"} = ( $base_name ); }
    my $modifiers = $INFO{$role}{modifiers}||[];
    my @mod_base;
    my @modifiers = grep !$composed_name->can($_),
      do { my %h; @h{map @{$_}[1..$#$_-1], @$modifiers} = (); keys %h };
    foreach my $modified (@modifiers) {
      push @mod_base, "sub ${modified} { shift->next::method(\@_) }";
    }
    my $e;
    {
      local $@;
      eval(my $code = join "\n", "package ${base_name};", @mod_base);
      $e = "Evaling failed: $@\nTrying to eval:\n${code}" if $@;
    }
    die $e if $e;
    $me->_install_modifiers($composed_name, $role);
    $COMPOSED{role}{$composed_name} = {
      modifiers_only => { map { $_ => 1 } @modifiers },
    };
    return $composed_name;
  }
  
  sub _check_requires {
    my ($me, $to, $name, $requires) = @_;
    return unless my @requires = @{$requires||$INFO{$name}{requires}||[]};
    if (my @requires_fail = grep !$to->can($_), @requires) {
      # role -> role, add to requires, role -> class, error out
      if (my $to_info = $INFO{$to}) {
        push @{$to_info->{requires}||=[]}, @requires_fail;
      } else {
        croak "Can't apply ${name} to ${to} - missing ".join(', ', @requires_fail);
      }
    }
  }
  
  sub _concrete_methods_of {
    my ($me, $role) = @_;
    my $info = $INFO{$role};
    # grab role symbol table
    my $stash = _getstash($role);
    # reverse so our keys become the values (captured coderefs) in case
    # they got copied or re-used since
    my $not_methods = { reverse %{$info->{not_methods}||{}} };
    $info->{methods} ||= +{
      # grab all code entries that aren't in the not_methods list
      map {;
        no strict 'refs';
        my $code = exists &{"${role}::$_"} ? \&{"${role}::$_"} : undef;
        ( ! $code or exists $not_methods->{$code} ) ? () : ($_ => $code)
      } grep +(!ref($stash->{$_}) || ref($stash->{$_}) eq 'CODE'), keys %$stash
    };
  }
  
  sub methods_provided_by {
    my ($me, $role) = @_;
    croak "${role} is not a Role::Tiny" unless $me->is_role($role);
    (keys %{$me->_concrete_methods_of($role)}, @{$INFO{$role}->{requires}||[]});
  }
  
  sub _install_methods {
    my ($me, $to, $role) = @_;
  
    my $info = $INFO{$role};
  
    my $methods = $me->_concrete_methods_of($role);
  
    # grab target symbol table
    my $stash = _getstash($to);
  
    # determine already extant methods of target
    my %has_methods;
    @has_methods{grep
      +(ref($stash->{$_}) || *{$stash->{$_}}{CODE}),
      keys %$stash
    } = ();
  
    foreach my $i (grep !exists $has_methods{$_}, keys %$methods) {
      no warnings 'once';
      my $glob = _getglob "${to}::${i}";
      *$glob = $methods->{$i};
  
      # overloads using method names have the method stored in the scalar slot
      # and &overload::nil in the code slot.
      next
        unless $i =~ /^\(/
          && ((defined &overload::nil && $methods->{$i} == \&overload::nil)
              || (defined &overload::_nil && $methods->{$i} == \&overload::_nil));
  
      my $overload = ${ *{_getglob "${role}::${i}"}{SCALAR} };
      next
        unless defined $overload;
  
      *$glob = \$overload;
    }
  
    $me->_install_does($to);
  }
  
  sub _install_modifiers {
    my ($me, $to, $name) = @_;
    return unless my $modifiers = $INFO{$name}{modifiers};
    my $info = $INFO{$to};
    my $existing = ($info ? $info->{modifiers} : $COMPOSED{modifiers}{$to}) ||= [];
    my @modifiers = grep {
      my $modifier = $_;
      !grep $_ == $modifier, @$existing;
    } @{$modifiers||[]};
    push @$existing, @modifiers;
  
    if (!$info) {
      foreach my $modifier (@modifiers) {
        $me->_install_single_modifier($to, @$modifier);
      }
    }
  }
  
  my $vcheck_error;
  
  sub _install_single_modifier {
    my ($me, @args) = @_;
    defined($vcheck_error) or $vcheck_error = do {
      local $@;
      eval {
        require Class::Method::Modifiers;
        Class::Method::Modifiers->VERSION(1.05);
        1;
      } ? 0 : $@;
    };
    $vcheck_error and die $vcheck_error;
    Class::Method::Modifiers::install_modifier(@args);
  }
  
  my $FALLBACK = sub { 0 };
  sub _install_does {
    my ($me, $to) = @_;
  
    # only add does() method to classes
    return if $me->is_role($to);
  
    my $does = $me->can('does_role');
    # add does() only if they don't have one
    *{_getglob "${to}::does"} = $does unless $to->can('does');
  
    return
      if $to->can('DOES') and $to->can('DOES') != (UNIVERSAL->can('DOES') || 0);
  
    my $existing = $to->can('DOES') || $to->can('isa') || $FALLBACK;
    my $new_sub = sub {
      my ($proto, $role) = @_;
      $proto->$does($role) or $proto->$existing($role);
    };
    no warnings 'redefine';
    return *{_getglob "${to}::DOES"} = $new_sub;
  }
  
  sub does_role {
    my ($proto, $role) = @_;
    require(_MRO_MODULE);
    foreach my $class (@{mro::get_linear_isa(ref($proto)||$proto)}) {
      return 1 if exists $APPLIED_TO{$class}{$role};
    }
    return 0;
  }
  
  sub is_role {
    my ($me, $role) = @_;
    return !!($INFO{$role} && ($INFO{$role}{is_role} || $INFO{$role}{not_methods}));
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Role::Tiny - Roles. Like a nouvelle cuisine portion size slice of Moose.
  
  =head1 SYNOPSIS
  
   package Some::Role;
  
   use Role::Tiny;
  
   sub foo { ... }
  
   sub bar { ... }
  
   around baz => sub { ... };
  
   1;
  
  elsewhere
  
   package Some::Class;
  
   use Role::Tiny::With;
  
   # bar gets imported, but not foo
   with 'Some::Role';
  
   sub foo { ... }
  
   # baz is wrapped in the around modifier by Class::Method::Modifiers
   sub baz { ... }
  
   1;
  
  If you wanted attributes as well, look at L<Moo::Role>.
  
  =head1 DESCRIPTION
  
  C<Role::Tiny> is a minimalist role composition tool.
  
  =head1 ROLE COMPOSITION
  
  Role composition can be thought of as much more clever and meaningful multiple
  inheritance.  The basics of this implementation of roles is:
  
  =over 2
  
  =item *
  
  If a method is already defined on a class, that method will not be composed in
  from the role. A method inherited by a class gets overridden by the role's
  method of the same name, though.
  
  =item *
  
  If a method that the role L</requires> to be implemented is not implemented,
  role application will fail loudly.
  
  =back
  
  Unlike L<Class::C3>, where the B<last> class inherited from "wins," role
  composition is the other way around, where the class wins. If multiple roles
  are applied in a single call (single with statement), then if any of their
  provided methods clash, an exception is raised unless the class provides
  a method since this conflict indicates a potential problem.
  
  =head1 IMPORTED SUBROUTINES
  
  =head2 requires
  
   requires qw(foo bar);
  
  Declares a list of methods that must be defined to compose role.
  
  =head2 with
  
   with 'Some::Role1';
  
   with 'Some::Role1', 'Some::Role2';
  
  Composes another role into the current role (or class via L<Role::Tiny::With>).
  
  If you have conflicts and want to resolve them in favour of Some::Role1 you
  can instead write:
  
   with 'Some::Role1';
   with 'Some::Role2';
  
  If you have conflicts and want to resolve different conflicts in favour of
  different roles, please refactor your codebase.
  
  =head2 before
  
   before foo => sub { ... };
  
  See L<< Class::Method::Modifiers/before method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head2 around
  
   around foo => sub { ... };
  
  See L<< Class::Method::Modifiers/around method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head2 after
  
   after foo => sub { ... };
  
  See L<< Class::Method::Modifiers/after method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head2 Strict and Warnings
  
  In addition to importing subroutines, using C<Role::Tiny> applies L<strict> and
  L<warnings> to the caller.
  
  =head1 SUBROUTINES
  
  =head2 does_role
  
   if (Role::Tiny::does_role($foo, 'Some::Role')) {
     ...
   }
  
  Returns true if class has been composed with role.
  
  This subroutine is also installed as ->does on any class a Role::Tiny is
  composed into unless that class already has an ->does method, so
  
    if ($foo->does('Some::Role')) {
      ...
    }
  
  will work for classes but to test a role, one must use ::does_role directly.
  
  Additionally, Role::Tiny will override the standard Perl C<DOES> method
  for your class. However, if C<any> class in your class' inheritance
  hierarchy provides C<DOES>, then Role::Tiny will not override it.
  
  =head1 METHODS
  
  =head2 apply_roles_to_package
  
   Role::Tiny->apply_roles_to_package(
     'Some::Package', 'Some::Role', 'Some::Other::Role'
   );
  
  Composes role with package.  See also L<Role::Tiny::With>.
  
  =head2 apply_roles_to_object
  
   Role::Tiny->apply_roles_to_object($foo, qw(Some::Role1 Some::Role2));
  
  Composes roles in order into object directly. Object is reblessed into the
  resulting class. Note that the object's methods get overridden by the role's
  ones with the same names.
  
  =head2 create_class_with_roles
  
   Role::Tiny->create_class_with_roles('Some::Base', qw(Some::Role1 Some::Role2));
  
  Creates a new class based on base, with the roles composed into it in order.
  New class is returned.
  
  =head2 is_role
  
   Role::Tiny->is_role('Some::Role1')
  
  Returns true if the given package is a role.
  
  =head1 CAVEATS
  
  =over 4
  
  =item * On perl 5.8.8 and earlier, applying a role to an object won't apply any
  overloads from the role to other copies of the object.
  
  =item * On perl 5.16 and earlier, applying a role to a class won't apply any
  overloads from the role to any existing instances of the class.
  
  =back
  
  =head1 SEE ALSO
  
  L<Role::Tiny> is the attribute-less subset of L<Moo::Role>; L<Moo::Role> is
  a meta-protocol-less subset of the king of role systems, L<Moose::Role>.
  
  Ovid's L<Role::Basic> provides roles with a similar scope, but without method
  modifiers, and having some extra usage restrictions.
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  hobbs - Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
  
  jnap - John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  chip - Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
  
  ajgb - Alex J. G. Burzyński (cpan:AJGB) <ajgb@cpan.org>
  
  doy - Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
  
  perigrin - Chris Prather (cpan:PERIGRIN) <chris@prather.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  ilmari - Dagfinn Ilmari Mannsåker (cpan:ILMARI) <ilmari@ilmari.org>
  
  tobyink - Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@haarg.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2012 the Role::Tiny L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
ROLE_TINY

$fatpacked{"Role/Tiny/With.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY_WITH';
  package Role::Tiny::With;
  
  use strict;
  use warnings;
  
  our $VERSION = '2.000006';
  $VERSION = eval $VERSION;
  
  use Role::Tiny ();
  
  use Exporter 'import';
  our @EXPORT = qw( with );
  
  sub with {
      my $target = caller;
      Role::Tiny->apply_roles_to_package($target, @_)
  }
  
  1;
  
  =head1 NAME
  
  Role::Tiny::With - Neat interface for consumers of Role::Tiny roles
  
  =head1 SYNOPSIS
  
   package Some::Class;
  
   use Role::Tiny::With;
  
   with 'Some::Role';
  
   # The role is now mixed in
  
  =head1 DESCRIPTION
  
  C<Role::Tiny> is a minimalist role composition tool.  C<Role::Tiny::With>
  provides a C<with> function to compose such roles.
  
  =head1 AUTHORS
  
  See L<Role::Tiny> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Role::Tiny> for the copyright and license.
  
  =cut
  
  
ROLE_TINY_WITH

$fatpacked{"Specio.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO';
  package Specio;
  
  use strict;
  use warnings;
  
  use 5.008;
  
  our $VERSION = '0.42';
  
  1;
  
  # ABSTRACT: Type constraints and coercions for Perl
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio - Type constraints and coercions for Perl
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
      package MyApp::Type::Library;
  
      use Specio::Declare;
      use Specio::Library::Builtins;
  
      declare(
          'PositiveInt',
          parent => t('Int'),
          inline => sub {
              $_[0]->parent->inline_check( $_[1] )
                  . ' && ( '
                  . $_[1]
                  . ' > 0 )';
          },
      );
  
      # or ...
  
      declare(
          'PositiveInt',
          parent => t('Int'),
          where  => sub { $_[0] > 0 },
      );
  
      declare(
          'ArrayRefOfPositiveInt',
          parent => t(
              'ArrayRef',
              of => t('PositiveInt'),
          ),
      );
  
      coerce(
          'ArrayRefOfPositiveInt',
          from  => t('PositiveInt'),
          using => sub { [ $_[0] ] },
      );
  
      any_can_type(
          'Duck',
          methods => [ 'duck_walk', 'quack' ],
      );
  
      object_isa_type('MyApp::Person');
  
  =head1 DESCRIPTION
  
  The C<Specio> distribution provides classes for representing type constraints
  and coercion, along with syntax sugar for declaring them.
  
  Note that this is not a proper type system for Perl. Nothing in this
  distribution will magically make the Perl interpreter start checking a value's
  type on assignment to a variable. In fact, there's no built-in way to apply a
  type to a variable at all.
  
  Instead, you can explicitly check a value against a type, and optionally
  coerce values to that type.
  
  My long-term goal is to replace Moose's built-in types and L<MooseX::Types>
  with this module.
  
  =head1 WHAT IS A TYPE?
  
  At it's core, a type is simply a constraint. A constraint is code that checks
  a value and returns true or false. Most constraints are represented by
  L<Specio::Constraint::Simple> objects. However, there are other type
  constraint classes for specialized kinds of constraints.
  
  Types can be named or anonymous, and each type can have a parent type. A
  type's constraint is optional because sometimes you may want to create a named
  subtype of some existing type without adding additional constraints.
  
  Constraints can be expressed either in terms of a simple subroutine reference
  or in terms of an inline generator subroutine reference. The former is easier
  to write but the latter is preferred because it allow for better optimization.
  
  A type can also have an optional message generator subroutine reference. You
  can use this to provide a more intelligent error message when a value does not
  pass the constraint, though the default message should suffice for most cases.
  
  Finally, you can associate a set of coercions with a type. A coercion is a
  subroutine reference (or inline generator, like constraints), that takes a
  value of one type and turns it into a value that matches the type the coercion
  belongs to.
  
  =head1 BUILTIN TYPES
  
  This distribution ships with a set of builtin types representing the types
  provided by the Perl interpreter itself. They are arranged in a hierarchy as
  follows:
  
    Item
        Bool
        Maybe (of `a)
        Undef
        Defined
            Value
                Str
                    Num
                        Int
                    ClassName
            Ref
                ScalarRef (of `a)
                ArrayRef (of `a)
                HashRef (of `a)
                CodeRef
                RegexpRef
                GlobRef
                FileHandle
                Object
  
  The C<Item> type accepts anything and everything.
  
  The C<Bool> type only accepts C<undef>, C<0>, or C<1>.
  
  The C<Undef> type only accepts C<undef>.
  
  The C<Defined> type accepts anything I<except> C<undef>.
  
  The C<Num> and C<Int> types are stricter about numbers than Perl
  is. Specifically, they do not allow any sort of space in the number, nor do
  they accept "Nan", "Inf", or "Infinity".
  
  The C<ClassName> type constraint checks that the name is valid I<and> that the
  class is loaded.
  
  The C<FileHandle> type accepts either a glob, a scalar filehandle, or anything
  that isa L<IO::Handle>.
  
  All types accept overloaded objects that support the required operation. See
  below for details.
  
  =head2 Overloading
  
  Perl's overloading is horribly broken and doesn't make much sense at all.
  
  However, unlike Moose, all type constraints allow overloaded objects where
  they make sense.
  
  For types where overloading makes sense, we explicitly check that the object
  provides the type overloading we expect. We I<do not> simply try to use the
  object as the type in question and hope it works. This means that these checks
  effectively ignore the C<fallback> setting for the overloaded object. In other
  words, an object that overloads stringification will not pass the C<Bool> type
  check unless it I<also> overloads boolification.
  
  Most types do not check that the overloaded method actually returns something
  that matches the constraint. This may change in the future.
  
  The C<Bool> type accepts an object that implements C<bool> overloading.
  
  The C<Str> type accepts an object that implements string (C<q{""}>)
  overloading.
  
  The C<Num> type accepts an object that implements numeric (C<'0+'}>)
  overloading. The C<Int> type does as well, but it will check that the
  overloading returns an actual integer.
  
  The C<ClassName> type will accept an object with string overloading that
  returns a class name.
  
  To make this all more confusing, the C<Value> type will I<never> accept an
  object, even though some of its subtypes will.
  
  The various reference types all accept objects which provide the appropriate
  overloading. The C<FileHandle> type accepts an object which overloads
  globification as long as the returned glob is an open filehandle.
  
  =head1 PARAMETERIZABLE TYPES
  
  Any type followed by a type parameter C<of `a> in the hierarchy above can be
  parameterized. The parameter is itself a type, so you can say you want an
  "ArrayRef of Int", or even an "ArrayRef of HashRef of ScalarRef of ClassName".
  
  When they are parameterized, the C<ScalarRef> and C<ArrayRef> types check that
  the value(s) they refer to match the type parameter. For the C<HashRef> type,
  the parameter applies to the values (keys are never checked).
  
  =head2 Maybe
  
  The C<Maybe> type is a special parameterized type. It allows for either
  C<undef> or a value. All by itself, it is meaningless, since it is equivalent
  to "Maybe of Item", which is equivalent to Item. When parameterized, it
  accepts either an C<undef> or the type of its parameter.
  
  This is useful for optional attributes or parameters. However, you're probably
  better off making your code simply not pass the parameter at all This usually
  makes for a simpler API.
  
  =head1 REGISTRIES AND IMPORTING
  
  Types are local to each package where they are used. When you "import" types
  from some other library, you are actually making a copy of that type.
  
  This means that a type named "Foo" in one package may not be the same as "Foo"
  in another package. This has potential for confusion, but it also avoids the
  magic action at a distance pollution that comes with a global type naming
  system.
  
  The registry is managed internally by the Specio distribution's modules, and is
  not exposed to your code. To access a type, you always call C<t('TypeName')>.
  
  This returns the named type or dies if no such type exists.
  
  Because types are always copied on import, it's safe to create coercions on
  any type. Your coercion from C<Str> to C<Int> will not be seen by any other
  package, unless that package explicitly imports your C<Int> type.
  
  When you import types, you import every type defined in the package you import
  from. However, you I<can> overwrite an imported type with your own type
  definition. You I<cannot> define the same type twice internally.
  
  =head1 CREATING A TYPE LIBRARY
  
  By default, all types created inside a package are invisible to other
  packages. If you want to create a type library, you need to inherit from
  L<Specio::Exporter> package:
  
    package MyApp::Type::Library;
  
    use parent 'Specio::Exporter';
  
    use Specio::Declare;
    use Specio::Library::Builtins;
  
    declare(
        'Foo',
        parent => t('Str'),
        where  => sub { $_[0] =~ /foo/i },
    );
  
  Now the MyApp::Type::Library package will export a single type named
  C<Foo>. It I<does not> re-export the types provided by
  L<Specio::Library::Builtins>.
  
  If you want to make your library re-export some other libraries types, you can
  ask for this explicitly:
  
    package MyApp::Type::Library;
  
    use parent 'Specio::Exporter';
  
    use Specio::Declare;
    use Specio::Library::Builtins -reexport;
  
    declare( 'Foo, ... );
  
  Now MyApp::Types::Library exports any types it defines, as well as all the
  types defined in L<Specio::Library::Builtins>.
  
  =head1 DECLARING TYPES
  
  Use the L<Specio::Declare> module to declare types. It exports a set of helpers
  for declaring types. See that module's documentation for more details on these
  helpers.
  
  =head1 USING SPECIO WITH L<Moose>
  
  This should just work. Use a Specio type anywhere you'd specify a type.
  
  =head1 USING SPECIO WITH L<Moo>
  
  Using Specio with Moo is easy. You can pass Specio constraint objects as
  C<isa> parameters for attributes. For coercions, simply call C<<
  $type->coercion_sub >>.
  
      package Foo;
  
      use Specio::Declare;
      use Specio::Library::Builtins;
      use Moo;
  
      my $str_type = t('Str');
      has string => (
         is  => 'ro',
         isa => $str_type,
      );
  
      my $ucstr = declare(
          'UCStr',
          parent => t('Str'),
          where  => sub { $_[0] =~ /^[A-Z]+$/ },
      );
  
      coerce(
          $ucstr,
          from  => t('Str'),
          using => sub { return uc $_[0] },
      );
  
      has ucstr => (
          is     => 'ro',
          isa    => $ucstr,
          coerce => $ucstr->coercion_sub,
      );
  
  The subs returned by Specio use L<Sub::Quote> internally and are suitable for
  inlining.
  
  =head1 USING SPECIO WITH OTHER THINGS
  
  See L<Specio::Constraint::Simple> for the API that all constraint objects
  share.
  
  =head1 L<Moose>, L<MooseX::Types>, and Specio
  
  This module aims to supplant both L<Moose>'s built-in type system (see
  L<Moose::Util::TypeConstraints> aka MUTC) and L<MooseX::Types>, which attempts
  to patch some of the holes in the Moose built-in type design.
  
  Here are some of the salient differences:
  
  =over 4
  
  =item * Types names are strings, but they're not global
  
  Unlike Moose and MooseX::Types, type names are always local to the current
  package. There is no possibility of name collision between different modules,
  so you can safely use short type names.
  
  Unlike MooseX::Types, types are strings, so there is no possibility of
  colliding with existing class or subroutine names.
  
  =item * No type auto-creation
  
  Types are always retrieved using the C<t()> subroutine. If you pass an unknown
  name to this subroutine it dies. This is different from Moose and
  MooseX::Types, which assume that unknown names are class names.
  
  =item * Anon types are explicit
  
  With L<Moose> and L<MooseX::Types>, you use the same subroutine, C<subtype()>,
  to declare both named and anonymous types. With Specio, you use C<declare()> for
  named types and C<anon()> for anonymous types.
  
  =item * Class and object types are separate
  
  Moose and MooseX::Types have C<class_type> and C<duck_type>. The former type
  requires an object, while the latter accepts a class name or object.
  
  With Specio, the distinction between accepting an object versus object or
  class is explicit. There are six declaration helpers, C<object_can_type>,
  C<object_does_type>, C<object_isa_type>, C<any_can_type>, C<any_does_type>,
  and C<any_isa_type>.
  
  =item * Overloading support is baked in
  
  Perl's overloading is quite broken but ignoring it makes Moose's type system
  frustrating to use in many cases.
  
  =item * Types can either have a constraint or inline generator, not both
  
  Moose and MooseX::Types types can be defined with a subroutine reference as
  the constraint, an inline generator subroutine, or both. This is purely for
  backwards compatibility, and it makes the internals more complicated than they
  need to be.
  
  With Specio, a constraint can have I<either> a subroutine reference or an
  inline generator, not both.
  
  =item * Coercions can be inlined
  
  I simply never got around to implementing this in Moose.
  
  =item * No crazy coercion features
  
  Moose has some bizarre (and mostly) undocumented features relating to
  coercions and parameterizable types. This is a misfeature.
  
  =back
  
  =head1 WHY THE NAME?
  
  This distro was originally called "Type", but that's an awfully generic top
  level namespace. Specio is Latin for for "look at" and "spec" is the root for
  the word "species". It's short, relatively easy to type, and not used by any
  other distro.
  
  =head1 LONG-TERM PLANS
  
  Eventually I'd like to see this distro replace Moose's internal type system,
  which would also make MooseX::Types obsolete.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 DONATIONS
  
  If you'd like to thank me for the work I've done on this module, please
  consider making a "donation" to me via PayPal. I spend a lot of free time
  creating free software, and would appreciate any support you'd care to offer.
  
  Please note that B<I am not suggesting that you must do this> in order for me
  to continue working on this particular software. I will continue to do so,
  inasmuch as I have in the past, for as long as it interests me.
  
  Similarly, a donation made in this way will probably not make me work on this
  software much more, unless I get so many donations that I can consider working
  on free software full time (let's all have a chuckle at that together).
  
  To donate, log into PayPal and send money to autarch@urth.org, or use the
  button at L<http://www.urth.org/~autarch/fs-donation.html>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords cpansprout Graham Knop Karen Etheridge
  
  =over 4
  
  =item *
  
  cpansprout <cpansprout@gmail.com>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO

$fatpacked{"Specio/Coercion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_COERCION';
  package Specio::Coercion;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use Specio::OO;
  
  use Role::Tiny::With;
  
  use Specio::Role::Inlinable;
  with 'Specio::Role::Inlinable';
  
  {
      ## no critic (Subroutines::ProtectPrivateSubs)
      my $role_attrs = Specio::Role::Inlinable::_attrs();
      ## use critic
  
      my $attrs = {
          %{$role_attrs},
          from => {
              does     => 'Specio::Constraint::Role::Interface',
              required => 1,
          },
          to => {
              does     => 'Specio::Constraint::Role::Interface',
              required => 1,
              weak_ref => 1,
          },
          _coercion => {
              isa       => 'CodeRef',
              predicate => '_has_coercion',
              init_arg  => 'coercion',
          },
          _optimized_coercion => {
              isa      => 'CodeRef',
              init_arg => undef,
              lazy     => 1,
              builder  => '_build_optimized_coercion',
          },
      };
  
      ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
      sub _attrs {
          return $attrs;
      }
  }
  
  sub BUILD {
      my $self = shift;
  
      die
          'A type coercion should have either a coercion or inline_generator parameter, not both'
          if $self->_has_coercion && $self->_has_inline_generator;
  
      die
          'A type coercion must have either a coercion or inline_generator parameter'
          unless $self->_has_coercion || $self->_has_inline_generator;
  
      return;
  }
  
  sub coerce {
      my $self  = shift;
      my $value = shift;
  
      return $self->_optimized_coercion->($value);
  }
  
  sub inline_coercion {
      my $self = shift;
  
      return $self->_inline_generator->( $self, @_ );
  }
  
  sub _build_optimized_coercion {
      my $self = shift;
  
      if ( $self->_has_inline_generator ) {
          return $self->_generated_inline_sub;
      }
      else {
          return $self->_coercion;
      }
  }
  
  sub can_be_inlined {
      my $self = shift;
  
      return $self->_has_inline_generator && $self->from->can_be_inlined;
  }
  
  sub _build_description {
      my $self = shift;
  
      my $from_name
          = defined $self->from->name ? $self->from->name : 'anonymous type';
      my $to_name
          = defined $self->to->name ? $self->to->name : 'anonymous type';
      my $desc = "coercion from $from_name to $to_name";
  
      $desc .= q{ } . $self->declared_at->description;
  
      return $desc;
  }
  
  sub clone_with_new_to {
      my $self   = shift;
      my $new_to = shift;
  
      my $from = $self->from;
  
      local $self->{from} = undef;
      local $self->{to}   = undef;
  
      my $clone = $self->clone;
  
      $clone->{from} = $from;
      $clone->{to}   = $new_to;
  
      return $clone;
  }
  
  __PACKAGE__->_ooify;
  
  1;
  
  # ABSTRACT: A class representing a coercion from one type to another
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Coercion - A class representing a coercion from one type to another
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
      my $coercion = $type->coercion_from_type('Int');
  
      my $new_value = $coercion->coerce_value(42);
  
      if ( $coercion->can_be_inlined() ) {
          my $code = $coercion->inline_coercion('$_[0]');
      }
  
  =head1 DESCRIPTION
  
  This class represents a coercion from one type to another. Internally, a
  coercion is a piece of code that takes a value of one type returns a new value
  of a new type. For example, a coercion from c<Num> to C<Int> might round a
  number to its nearest integer and return that integer.
  
  Coercions can be implemented either as a simple subroutine reference or as an
  inline generator subroutine. Using an inline generator is faster but more
  complicated.
  
  =for Pod::Coverage BUILD clone_with_new_to
  
  =head1 API
  
  This class provides the following methods.
  
  =head2 Specio::Coercion->new( ... )
  
  This method creates a new coercion object. It accepts the following named
  parameters:
  
  =over 4
  
  =item * from => $type
  
  The type this coercion is from. The type must be an object which does the
  L<Specio::Constraint::Role::Interface> interface.
  
  This parameter is required.
  
  =item * to => $type
  
  The type this coercion is to. The type must be an object which does the
  L<Specio::Constraint::Role::Interface> interface.
  
  This parameter is required.
  
  =item * coercion => sub { ... }
  
  A subroutine reference implementing the coercion. It will be called as a
  method on the object and passed a single argument, the value to coerce.
  
  It should return the new value.
  
  This parameter is mutually exclusive with C<inline_generator>.
  
  Either this parameter or the C<inline_generator> parameter is required.
  
  You can also pass this option with the key C<using> in the parameter list.
  
  =item * inline_generator => sub { ... }
  
  This should be a subroutine reference which returns a string containing a
  single term. This code should I<not> end in a semicolon. This code should
  implement the coercion.
  
  The generator will be called as a method on the coercion with a single
  argument. That argument is the name of the variable being coerced, something
  like C<'$_[0]'> or C<'$var'>.
  
  This parameter is mutually exclusive with C<coercion>.
  
  Either this parameter or the C<coercion> parameter is required.
  
  You can also pass this option with the key C<inline> in the parameter list.
  
  =item * inline_environment => {}
  
  This should be a hash reference of variable names (with sigils) and values for
  that variable. The values should be I<references> to the values of the
  variables.
  
  This environment will be used when compiling the coercion as part of a
  subroutine. The named variables will be captured as closures in the generated
  subroutine, using L<Eval::Closure>.
  
  It should be very rare to need to set this in the constructor. It's more
  likely that a special coercion subclass would need to provide values that it
  generates internally.
  
  This parameter defaults to an empty hash reference.
  
  =item * declared_at => $declared_at
  
  This parameter must be a L<Specio::DeclaredAt> object.
  
  This parameter is required.
  
  =back
  
  =head2 $coercion->from(), $coercion->to(), $coercion->declared_at()
  
  These methods are all read-only attribute accessors for the corresponding
  attribute.
  
  =head2 $coercion->description
  
  This returns a string describing the coercion. This includes the names of the
  to and from type and where the coercion was declared, so you end up with
  something like C<'coercion from Foo to Bar declared in package My::Lib
  (lib/My/Lib.pm) at line 42'>.
  
  =head2 $coercion->coerce($value)
  
  Given a value of the right "from" type, returns a new value of the "to" type.
  
  This method does not actually check that the types of given or return values.
  
  =head2 $coercion->inline_coercion($var)
  
  Given a variable name like C<'$_[0]'> this returns a string with code for the
  coercion.
  
  Note that this method will die if the coercion does not have an inline
  generator.
  
  =head2 $coercion->can_be_inlined()
  
  This returns true if the coercion has an inline generator I<and> the
  constraint it is from can be inlined. This exists primarily for the benefit of
  the C<inline_coercion_and_check()> method for type constraint object.
  
  =head2 $coercion->inline_environment()
  
  This returns a hash defining the variables that need to be closed over when
  inlining the coercion. The keys are full variable names like C<'$foo'> or
  C<'@bar'>. The values are I<references> to a variable of the matching type.
  
  =head2 $coercion->clone()
  
  Returns a clone of this object.
  
  =head2 $coercion->clone_with_new_to($new_to_type)
  
  This returns a clone of the coercion, replacing the "to" type with a new
  one. This is intended for use when the to type itself is being cloned as part
  of importing that type. We need to make sure the newly cloned coercion has the
  newly cloned type as well.
  
  =head1 ROLES
  
  This class does the L<Specio::Role::Inlinable> role.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_COERCION

$fatpacked{"Specio/Constraint/AnyCan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_CONSTRAINT_ANYCAN';
  package Specio::Constraint::AnyCan;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use B ();
  use List::Util 1.33 ();
  use Role::Tiny::With;
  use Scalar::Util ();
  use Specio::Library::Builtins;
  use Specio::OO;
  
  use Specio::Constraint::Role::CanType;
  with 'Specio::Constraint::Role::CanType';
  
  {
      my $Defined = t('Defined');
      sub _build_parent {$Defined}
  }
  
  {
      my $_inline_generator = sub {
          my $self = shift;
          my $val  = shift;
  
          my $methods = join ', ',
              map { B::perlstring($_) } @{ $self->methods };
          return sprintf( <<'EOF', $val, $methods );
  (
      do {
          # We need to assign this since if it's something like $_[0] then
          # inside the all block @_ gets redefined and we can no longer get at
          # the value.
          my $v = %s;
          (
              Scalar::Util::blessed($v) || (
                     defined($v)
                  && !ref($v)
                  && length($v)
                  && $v !~ /\A
                            \s*
                            -?[0-9]+(?:\.[0-9]+)?
                            (?:[Ee][\-+]?[0-9]+)?
                            \s*
                            \z/xs
  
                  # Passing a GLOB from (my $glob = *GLOB) gives us a very weird
                  # scalar. It's not a ref and it has a length but trying to
                  # call ->can on it throws an exception
                  && ref( \$v ) ne 'GLOB'
              )
          ) && List::Util::all { $v->can($_) } %s;
          }
      )
  EOF
      };
  
      sub _build_inline_generator {$_inline_generator}
  }
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _allow_classes {1}
  ## use critic
  
  __PACKAGE__->_ooify;
  
  1;
  
  # ABSTRACT: A class for constraints which require a class name or object with a set of methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Constraint::AnyCan - A class for constraints which require a class name or object with a set of methods
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
      my $type = Specio::Constraint::AnyCan->new(...);
      print $_, "\n" for @{ $type->methods };
  
  =head1 DESCRIPTION
  
  This is a specialized type constraint class for types which require a class
  name or object with a defined set of methods.
  
  =head1 API
  
  This class provides all of the same methods as L<Specio::Constraint::Simple>,
  with a few differences:
  
  =head2 Specio::Constraint::AnyCan->new( ... )
  
  The C<parent> parameter is ignored if it passed, as it is always set to the
  C<Defined> type.
  
  The C<inline_generator> and C<constraint> parameters are also ignored. This
  class provides its own default inline generator subroutine reference.
  
  This class overrides the C<message_generator> default if none is provided.
  
  Finally, this class requires an additional parameter, C<methods>. This must be
  an array reference of method names which the constraint requires. You can also
  pass a single string and it will be converted to an array reference
  internally.
  
  =head2 $any_can->methods
  
  Returns an array reference containing the methods this constraint requires.
  
  =head1 ROLES
  
  This class does the L<Specio::Constraint::Role::IsaType>,
  L<Specio::Constraint::Role::Interface>, and L<Specio::Role::Inlinable> roles.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_CONSTRAINT_ANYCAN

$fatpacked{"Specio/Constraint/AnyDoes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_CONSTRAINT_ANYDOES';
  package Specio::Constraint::AnyDoes;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use B ();
  use Role::Tiny::With;
  use Scalar::Util ();
  use Specio::Library::Builtins;
  use Specio::OO;
  
  use Specio::Constraint::Role::DoesType;
  with 'Specio::Constraint::Role::DoesType';
  
  {
      my $Defined = t('Defined');
      sub _build_parent {$Defined}
  }
  
  {
      my $_inline_generator = sub {
          my $self = shift;
          my $val  = shift;
  
          return sprintf( <<'EOF', ($val) x 8, B::perlstring( $self->role ) );
  (
      (
          Scalar::Util::blessed(%s) || (
                !ref(%s)
              && defined(%s)
              && length(%s)
              && %s !~ /\A
                        \s*
                        -?[0-9]+(?:\.[0-9]+)?
                        (?:[Ee][\-+]?[0-9]+)?
                        \s*
                        \z/xs
              && ref( \%s ) ne 'GLOB'
          )
      )
          && %s->can('does')
          && %s->does(%s)
      )
  EOF
      };
  
      sub _build_inline_generator {$_inline_generator}
  }
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _allow_classes {1}
  ## use critic
  
  __PACKAGE__->_ooify;
  
  1;
  
  # ABSTRACT: A class for constraints which require a class name or an object that does a specific role
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Constraint::AnyDoes - A class for constraints which require a class name or an object that does a specific role
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
      my $type = Specio::Constraint::AnyDoes->new(...);
      print $type->role;
  
  =head1 DESCRIPTION
  
  This is a specialized type constraint class for types which require a class
  name or an object that does a specific role.
  
  =head1 API
  
  This class provides all of the same methods as L<Specio::Constraint::Simple>,
  with a few differences:
  
  =head2 Specio::Constraint::AnyDoes->new( ... )
  
  The C<parent> parameter is ignored if it passed, as it is always set to the
  C<Defined> type.
  
  The C<inline_generator> and C<constraint> parameters are also ignored. This
  class provides its own default inline generator subroutine reference.
  
  This class overrides the C<message_generator> default if none is provided.
  
  Finally, this class requires an additional parameter, C<role>. This must be a
  single role name.
  
  =head2 $any_isa->role
  
  Returns the role name passed to the constructor.
  
  =head1 ROLES
  
  This class does the L<Specio::Constraint::Role::DoesType>,
  L<Specio::Constraint::Role::Interface>, L<Specio::Role::Inlinable>, and
  L<MooseX::Clone> roles.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_CONSTRAINT_ANYDOES

$fatpacked{"Specio/Constraint/AnyIsa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_CONSTRAINT_ANYISA';
  package Specio::Constraint::AnyIsa;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use B ();
  use Role::Tiny::With;
  use Scalar::Util ();
  use Specio::Library::Builtins;
  use Specio::OO;
  
  use Specio::Constraint::Role::IsaType;
  with 'Specio::Constraint::Role::IsaType';
  
  {
      my $Defined = t('Defined');
      sub _build_parent {$Defined}
  }
  
  {
      my $_inline_generator = sub {
          my $self = shift;
          my $val  = shift;
  
          return sprintf( <<'EOF', ($val) x 7, B::perlstring( $self->class ) );
  (
      (
          Scalar::Util::blessed(%s)
              || (
                 defined(%s)
              && !ref(%s)
              && length(%s)
              && %s !~ /\A
                        \s*
                        -?[0-9]+(?:\.[0-9]+)?
                        (?:[Ee][\-+]?[0-9]+)?
                        \s*
                        \z/xs
  
              # Passing a GLOB from (my $glob = *GLOB) gives us a very weird
              # scalar. It's not a ref and it has a length but trying to
              # call ->can on it throws an exception
              && ref( \%s ) ne 'GLOB'
              )
      )
          && %s->isa(%s)
      )
  EOF
      };
  
      sub _build_inline_generator {$_inline_generator}
  }
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _allow_classes {1}
  ## use critic
  
  __PACKAGE__->_ooify;
  
  1;
  
  # ABSTRACT: A class for constraints which require a class name or an object that inherit from a specific class
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Constraint::AnyIsa - A class for constraints which require a class name or an object that inherit from a specific class
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
      my $type = Specio::Constraint::AnyIsa->new(...);
      print $type->class;
  
  =head1 DESCRIPTION
  
  This is a specialized type constraint class for types which require a class
  name or an object that inherit from a specific class.
  
  =head1 API
  
  This class provides all of the same methods as L<Specio::Constraint::Simple>,
  with a few differences:
  
  =head2 Specio::Constraint::AnyIsa->new( ... )
  
  The C<parent> parameter is ignored if it passed, as it is always set to the
  C<Defined> type.
  
  The C<inline_generator> and C<constraint> parameters are also ignored. This
  class provides its own default inline generator subroutine reference.
  
  This class overrides the C<message_generator> default if none is provided.
  
  Finally, this class requires an additional parameter, C<class>. This must be a
  single class name.
  
  =head2 $any_isa->class
  
  Returns the class name passed to the constructor.
  
  =head1 ROLES
  
  This class does the L<Specio::Constraint::Role::IsaType>,
  L<Specio::Constraint::Role::Interface>, and L<Specio::Role::Inlinable> roles.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_CONSTRAINT_ANYISA

$fatpacked{"Specio/Constraint/Enum.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_CONSTRAINT_ENUM';
  package Specio::Constraint::Enum;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use B ();
  use Role::Tiny::With;
  use Scalar::Util qw( refaddr );
  use Specio::Library::Builtins;
  use Specio::OO;
  use Storable qw( dclone );
  
  use Specio::Constraint::Role::Interface;
  with 'Specio::Constraint::Role::Interface';
  
  {
      ## no critic (Subroutines::ProtectPrivateSubs)
      my $attrs = dclone( Specio::Constraint::Role::Interface::_attrs() );
      ## use critic
  
      for my $name (qw( parent _inline_generator )) {
          $attrs->{$name}{init_arg} = undef;
          $attrs->{$name}{builder}
              = $name =~ /^_/ ? '_build' . $name : '_build_' . $name;
      }
  
      $attrs->{values} = {
          isa      => 'ArrayRef',
          required => 1,
      };
  
      ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
      sub _attrs {
          return $attrs;
      }
  }
  
  {
      my $Str = t('Str');
      sub _build_parent {$Str}
  }
  
  {
      my $_inline_generator = sub {
          my $self = shift;
          my $val  = shift;
  
          return sprintf( <<'EOF', ($val) x 2, $self->_env_var_name, $val );
  ( !ref( %s ) && defined( %s ) && $%s{ %s } )
  EOF
      };
  
      sub _build_inline_generator {$_inline_generator}
  }
  
  sub _build_inline_environment {
      my $self = shift;
  
      my %values = map { $_ => 1 } @{ $self->values };
  
      return { '%' . $self->_env_var_name => \%values };
  }
  
  sub _env_var_name {
      my $self = shift;
  
      return '_Specio_Constraint_Enum_' . refaddr($self);
  }
  
  __PACKAGE__->_ooify;
  
  1;
  
  # ABSTRACT: A class for constraints which require a string matching one of a set of values
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Constraint::Enum - A class for constraints which require a string matching one of a set of values
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
      my $type = Specio::Constraint::Enum->new(...);
      print $_, "\n" for @{ $type->values };
  
  =head1 DESCRIPTION
  
  This is a specialized type constraint class for types which require a string
  that matches one of a list of values.
  
  =head1 API
  
  This class provides all of the same methods as L<Specio::Constraint::Simple>,
  with a few differences:
  
  =head2 Specio::Constraint::Enum->new( ... )
  
  The C<parent> parameter is ignored if it passed, as it is always set to the
  C<Str> type.
  
  The C<inline_generator> and C<constraint> parameters are also ignored. This
  class provides its own default inline generator subroutine reference.
  
  Finally, this class requires an additional parameter, C<values>. This must be a
  an arrayref of valid strings for the type.
  
  =head2 $enum->values
  
  Returns an array reference of valid values for the type.
  
  =head1 ROLES
  
  This class does the L<Specio::Constraint::Role::Interface> and
  L<Specio::Role::Inlinable> roles.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_CONSTRAINT_ENUM

$fatpacked{"Specio/Constraint/Intersection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_CONSTRAINT_INTERSECTION';
  package Specio::Constraint::Intersection;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use List::Util qw( all );
  use Role::Tiny::With;
  use Specio::OO;
  use Storable qw( dclone );
  
  use Specio::Constraint::Role::Interface;
  with 'Specio::Constraint::Role::Interface';
  
  {
      ## no critic (Subroutines::ProtectPrivateSubs)
      my $attrs = dclone( Specio::Constraint::Role::Interface::_attrs() );
      ## use critic
  
      for my $name (qw( _constraint _inline_generator )) {
          delete $attrs->{$name}{predicate};
          $attrs->{$name}{init_arg} = undef;
          $attrs->{$name}{lazy}     = 1;
          $attrs->{$name}{builder}
              = $name =~ /^_/ ? '_build' . $name : '_build_' . $name;
      }
  
      delete $attrs->{parent};
  
      delete $attrs->{name}{predicate};
      $attrs->{name}{lazy}    = 1;
      $attrs->{name}{builder} = '_build_name';
  
      $attrs->{of} = {
          isa      => 'ArrayRef',
          required => 1,
      };
  
      ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
      sub _attrs {
          return $attrs;
      }
  }
  
  sub parent {undef}
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _has_parent {0}
  
  sub _has_name {
      my $self = shift;
      return defined $self->name;
  }
  
  sub _build_name {
      my $self = shift;
  
      return unless all { $_->_has_name } @{ $self->of };
      return join q{ & }, map { $_->name } @{ $self->of };
  }
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _has_constraint {
      my $self = shift;
  
      return !$self->_has_inline_generator;
  }
  ## use critic
  
  sub _build_constraint {
      return $_[0]->_optimized_constraint;
  }
  
  sub _build_optimized_constraint {
      my $self = shift;
  
      ## no critic (Subroutines::ProtectPrivateSubs)
      my @c = map { $_->_optimized_constraint } @{ $self->of };
      return sub {
          return all { $_->( $_[0] ) } @c;
      };
  }
  
  sub _has_inline_generator {
      my $self = shift;
  
      ## no critic (Subroutines::ProtectPrivateSubs)
      return all { $_->_has_inline_generator } @{ $self->of };
  }
  
  sub _build_inline_generator {
      my $self = shift;
  
      return sub {
          return '(' . (
              join q{ && },
              map { sprintf( '( %s )', $_->_inline_generator->( $_, $_[1] ) ) }
                  @{ $self->of }
          ) . ')';
          }
  }
  
  sub _build_inline_environment {
      my $self = shift;
  
      my %env;
      for my $type ( @{ $self->of } ) {
          %env = (
              %env,
              %{ $type->inline_environment },
          );
      }
  
      return \%env;
  }
  
  __PACKAGE__->_ooify;
  
  1;
  
  # ABSTRACT: A class for intersection constraints
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Constraint::Intersection - A class for intersection constraints
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
      my $type = Specio::Constraint::Untion->new(...);
  
  =head1 DESCRIPTION
  
  This is a specialized type constraint class for intersections, which will
  allow a value which matches each one of several distinct types.
  
  =for Pod::Coverage parent
  
  =head1 API
  
  This class provides all of the same methods as L<Specio::Constraint::Simple>,
  with a few differences:
  
  =head2 Specio::Constraint::Intersection->new( ... )
  
  The C<parent> parameter is ignored if it passed, as it is always C<undef>
  
  The C<inline_generator> and C<constraint> parameters are also ignored. This
  class provides its own default inline generator subroutine reference.
  
  Finally, this class requires an additional parameter, C<of>. This must be an
  arrayref of type objects.
  
  =head2 $union->of
  
  Returns an array reference of the individual types which makes up this
  intersection.
  
  =head1 ROLES
  
  This class does the L<Specio::Constraint::Role::Interface> and
  L<Specio::Role::Inlinable> roles.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_CONSTRAINT_INTERSECTION

$fatpacked{"Specio/Constraint/ObjectCan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_CONSTRAINT_OBJECTCAN';
  package Specio::Constraint::ObjectCan;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use B ();
  use List::Util 1.33 ();
  use Role::Tiny::With;
  use Scalar::Util ();
  use Specio::Library::Builtins;
  use Specio::OO;
  
  use Specio::Constraint::Role::CanType;
  with 'Specio::Constraint::Role::CanType';
  
  {
      my $Object = t('Object');
      sub _build_parent {$Object}
  }
  
  {
      my $_inline_generator = sub {
          my $self = shift;
          my $val  = shift;
  
          my $methods = join ', ',
              map { B::perlstring($_) } @{ $self->methods };
          return sprintf( <<'EOF', $val, $methods );
  (
      do {
          my $v = %s;
          Scalar::Util::blessed($v)
              && List::Util::all { $v->can($_) } %s;
          }
      )
  EOF
      };
  
      sub _build_inline_generator {$_inline_generator}
  }
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _allow_classes {0}
  ## use critic
  
  __PACKAGE__->_ooify;
  
  1;
  
  # ABSTRACT: A class for constraints which require an object with a set of methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Constraint::ObjectCan - A class for constraints which require an object with a set of methods
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
      my $type = Specio::Constraint::ObjectCan->new(...);
      print $_, "\n" for @{ $type->methods };
  
  =head1 DESCRIPTION
  
  This is a specialized type constraint class for types which require an object
  with a defined set of methods.
  
  =head1 API
  
  This class provides all of the same methods as L<Specio::Constraint::Simple>,
  with a few differences:
  
  =head2 Specio::Constraint::ObjectCan->new( ... )
  
  The C<parent> parameter is ignored if it passed, as it is always set to the
  C<Object> type.
  
  The C<inline_generator> and C<constraint> parameters are also ignored. This
  class provides its own default inline generator subroutine reference.
  
  This class overrides the C<message_generator> default if none is provided.
  
  Finally, this class requires an additional parameter, C<methods>. This must be
  an array reference of method names which the constraint requires. You can also
  pass a single string and it will be converted to an array reference
  internally.
  
  =head2 $object_can->methods
  
  Returns an array reference containing the methods this constraint requires.
  
  =head1 ROLES
  
  This class does the L<Specio::Constraint::Role::CanType>,
  L<Specio::Constraint::Role::Interface>, and L<Specio::Role::Inlinable> roles.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_CONSTRAINT_OBJECTCAN

$fatpacked{"Specio/Constraint/ObjectDoes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_CONSTRAINT_OBJECTDOES';
  package Specio::Constraint::ObjectDoes;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use B ();
  use Role::Tiny::With;
  use Scalar::Util ();
  use Specio::Library::Builtins;
  use Specio::OO;
  
  use Specio::Constraint::Role::DoesType;
  with 'Specio::Constraint::Role::DoesType';
  
  {
      my $Object = t('Object');
      sub _build_parent {$Object}
  }
  
  {
      my $_inline_generator = sub {
          my $self = shift;
          my $val  = shift;
  
          return sprintf( <<'EOF', ($val) x 3, B::perlstring( $self->role ) );
  ( Scalar::Util::blessed(%s) && %s->can('does') && %s->does(%s) )
  EOF
      };
  
      sub _build_inline_generator {$_inline_generator}
  }
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _allow_classes {0}
  ## use critic
  
  __PACKAGE__->_ooify;
  
  1;
  
  # ABSTRACT: A class for constraints which require an object that does a specific role
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Constraint::ObjectDoes - A class for constraints which require an object that does a specific role
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
      my $type = Specio::Constraint::ObjectDoes->new(...);
      print $type->role;
  
  =head1 DESCRIPTION
  
  This is a specialized type constraint class for types which require an object
  that does a specific role.
  
  =head1 API
  
  This class provides all of the same methods as L<Specio::Constraint::Simple>,
  with a few differences:
  
  =head2 Specio::Constraint::ObjectDoes->new( ... )
  
  The C<parent> parameter is ignored if it passed, as it is always set to the
  C<Defined> type.
  
  The C<inline_generator> and C<constraint> parameters are also ignored. This
  class provides its own default inline generator subroutine reference.
  
  This class overrides the C<message_generator> default if none is provided.
  
  Finally, this class requires an additional parameter, C<role>. This must be a
  single role name.
  
  =head2 $object_isa->role
  
  Returns the role name passed to the constructor.
  
  =head1 ROLES
  
  This class does the L<Specio::Constraint::Role::DoesType>,
  L<Specio::Constraint::Role::Interface>, and L<Specio::Role::Inlinable> roles.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_CONSTRAINT_OBJECTDOES

$fatpacked{"Specio/Constraint/ObjectIsa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_CONSTRAINT_OBJECTISA';
  package Specio::Constraint::ObjectIsa;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use B ();
  use Role::Tiny::With;
  use Scalar::Util ();
  use Specio::Library::Builtins;
  use Specio::OO;
  
  use Specio::Constraint::Role::IsaType;
  with 'Specio::Constraint::Role::IsaType';
  
  {
      my $Object = t('Object');
      sub _build_parent {$Object}
  }
  
  {
      my $_inline_generator = sub {
          my $self = shift;
          my $val  = shift;
  
          return sprintf( <<'EOF', $val, $val, B::perlstring( $self->class ) );
  ( Scalar::Util::blessed( %s ) && %s->isa(%s) )
  EOF
      };
  
      sub _build_inline_generator {$_inline_generator}
  }
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _allow_classes {0}
  ## use critic
  
  __PACKAGE__->_ooify;
  
  1;
  
  # ABSTRACT: A class for constraints which require an object that inherits from a specific class
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Constraint::ObjectIsa - A class for constraints which require an object that inherits from a specific class
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
      my $type = Specio::Constraint::ObjectIsa->new(...);
      print $type->class;
  
  =head1 DESCRIPTION
  
  This is a specialized type constraint class for types which require an object
  that inherits from a specific class.
  
  =head1 API
  
  This class provides all of the same methods as L<Specio::Constraint::Simple>,
  with a few differences:
  
  =head2 Specio::Constraint::ObjectIsa->new( ... )
  
  The C<parent> parameter is ignored if it passed, as it is always set to the
  C<Defined> type.
  
  The C<inline_generator> and C<constraint> parameters are also ignored. This
  class provides its own default inline generator subroutine reference.
  
  This class overrides the C<message_generator> default if none is provided.
  
  Finally, this class requires an additional parameter, C<class>. This must be a
  single class name.
  
  =head2 $object_isa->class
  
  Returns the class name passed to the constructor.
  
  =head1 ROLES
  
  This class does the L<Specio::Constraint::Role::IsaType>,
  L<Specio::Constraint::Role::Interface>, and L<Specio::Role::Inlinable> roles.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_CONSTRAINT_OBJECTISA

$fatpacked{"Specio/Constraint/Parameterizable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_CONSTRAINT_PARAMETERIZABLE';
  package Specio::Constraint::Parameterizable;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use Carp qw( confess );
  use Role::Tiny::With;
  use Specio::Constraint::Parameterized;
  use Specio::DeclaredAt;
  use Specio::OO;
  use Specio::TypeChecks qw( does_role isa_class );
  
  use Specio::Constraint::Role::Interface;
  with 'Specio::Constraint::Role::Interface';
  
  {
      ## no critic (Subroutines::ProtectPrivateSubs)
      my $role_attrs = Specio::Constraint::Role::Interface::_attrs();
      ## use critic
  
      my $attrs = {
          %{$role_attrs},
          _parameterized_constraint_generator => {
              isa       => 'CodeRef',
              init_arg  => 'parameterized_constraint_generator',
              predicate => '_has_parameterized_constraint_generator',
          },
          _parameterized_inline_generator => {
              isa       => 'CodeRef',
              init_arg  => 'parameterized_inline_generator',
              predicate => '_has_parameterized_inline_generator',
          },
      };
  
      ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
      sub _attrs {
          return $attrs;
      }
  }
  
  sub BUILD {
      my $self = shift;
  
      if ( $self->_has_constraint ) {
          die
              'A parameterizable constraint with a constraint parameter must also have a parameterized_constraint_generator'
              unless $self->_has_parameterized_constraint_generator;
      }
  
      if ( $self->_has_inline_generator ) {
          die
              'A parameterizable constraint with an inline_generator parameter must also have a parameterized_inline_generator'
              unless $self->_has_parameterized_inline_generator;
      }
  
      return;
  }
  
  sub parameterize {
      my $self = shift;
      my %args = @_;
  
      my ( $parameter, $declared_at ) = @args{qw( of declared_at )};
      does_role( $parameter, 'Specio::Constraint::Role::Interface' )
          or confess
          'The "of" parameter passed to ->parameterize must be an object which does the Specio::Constraint::Role::Interface role';
  
      if ($declared_at) {
          isa_class( $declared_at, 'Specio::DeclaredAt' )
              or confess
              'The "declared_at" parameter passed to ->parameterize must be a Specio::DeclaredAt object';
      }
  
      $declared_at = Specio::DeclaredAt->new_from_caller(1)
          unless defined $declared_at;
  
      my %p = (
          parent      => $self,
          parameter   => $parameter,
          declared_at => $declared_at,
      );
  
      if ( $self->_has_parameterized_constraint_generator ) {
          $p{constraint}
              = $self->_parameterized_constraint_generator->($parameter);
      }
      else {
          confess
              'The "of" parameter passed to ->parameterize must be an inlinable constraint if the parameterizable type has an inline_generator'
              unless $parameter->can_be_inlined;
  
          my $ig = $self->_parameterized_inline_generator;
          $p{inline_generator} = sub { $ig->( shift, $parameter, @_ ) };
      }
  
      return Specio::Constraint::Parameterized->new(%p);
  }
  
  __PACKAGE__->_ooify;
  
  1;
  
  # ABSTRACT: A class which represents parameterizable constraints
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Constraint::Parameterizable - A class which represents parameterizable constraints
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
      my $arrayref = t('ArrayRef');
  
      my $arrayref_of_int = $arrayref->parameterize( of => t('Int') );
  
  =head1 DESCRIPTION
  
  This class implements the API for parameterizable types like C<ArrayRef> and
  C<Maybe>.
  
  =for Pod::Coverage BUILD
  
  =head1 API
  
  This class implements the same API as L<Specio::Constraint::Simple>, with a few
  additions.
  
  =head2 Specio::Constraint::Parameterizable->new(...)
  
  This class's constructor accepts two additional parameters:
  
  =over 4
  
  =item * parameterized_constraint_generator
  
  This is a subroutine that generates a new constraint subroutine when the type
  is parameterized.
  
  It will be called as a method on the type and will be passed a single
  argument, the type object for the type parameter.
  
  This parameter is mutually exclusive with the
  C<parameterized_inline_generator> parameter.
  
  =item * parameterized_inline_generator
  
  This is a subroutine that generates a new inline generator subroutine when the
  type is parameterized.
  
  It will be called as a method on the L<Specio::Constraint::Parameterized>
  object when that object needs to generate an inline constraint. It will
  receive the type parameter as the first argument and the variable name as a
  string as the second.
  
  This probably seems fairly confusing, so looking at the examples in the
  L<Specio::Library::Builtins> code may be helpful.
  
  This parameter is mutually exclusive with the
  C<parameterized_constraint_generator> parameter.
  
  =back
  
  =head2 $type->parameterize(...)
  
  This method takes two arguments. The C<of> argument should be an object which
  does the L<Specio::Constraint::Role::Interface> role, and is required.
  
  The other argument, C<declared_at>, is optional. If it is not given, then a
  new L<Specio::DeclaredAt> object is creating using a call stack depth of 1.
  
  This method returns a new L<Specio::Constraint::Parameterized> object.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_CONSTRAINT_PARAMETERIZABLE

$fatpacked{"Specio/Constraint/Parameterized.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_CONSTRAINT_PARAMETERIZED';
  package Specio::Constraint::Parameterized;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use Role::Tiny::With;
  use Specio::OO;
  use Storable qw( dclone );
  
  use Specio::Constraint::Role::Interface;
  with 'Specio::Constraint::Role::Interface';
  
  {
      ## no critic (Subroutines::ProtectPrivateSubs)
      my $attrs = dclone( Specio::Constraint::Role::Interface::_attrs() );
      ## use critic
  
      $attrs->{parent}{isa}      = 'Specio::Constraint::Parameterizable';
      $attrs->{parent}{required} = 1;
  
      delete $attrs->{name}{predicate};
      $attrs->{name}{lazy}    = 1;
      $attrs->{name}{builder} = '_build_name';
  
      $attrs->{parameter} = {
          does     => 'Specio::Constraint::Role::Interface',
          required => 1,
      };
  
      ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
      sub _attrs {
          return $attrs;
      }
  }
  
  sub _has_name {
      my $self = shift;
      return defined $self->name;
  }
  
  sub _build_name {
      my $self = shift;
  
      ## no critic (Subroutines::ProtectPrivateSubs)
      return unless $self->parent->_has_name && $self->parameter->_has_name;
      return $self->parent->name . '[' . $self->parameter->name . ']';
  }
  
  sub can_be_inlined {
      my $self = shift;
  
      return $self->_has_inline_generator
          && $self->parameter->can_be_inlined;
  }
  
  # Moose compatibility methods - these exist as a temporary hack to make Specio
  # work with Moose.
  
  sub type_parameter {
      shift->parameter;
  }
  
  __PACKAGE__->_ooify;
  
  1;
  
  # ABSTRACT: A class which represents parameterized constraints
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Constraint::Parameterized - A class which represents parameterized constraints
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
      my $arrayref = t('ArrayRef');
  
      my $arrayref_of_int = $arrayref->parameterize( of => t('Int') );
  
      my $parent = $arrayref_of_int->parent; # returns ArrayRef
      my $parameter = $arrayref_of_int->parameter; # returns Int
  
  =head1 DESCRIPTION
  
  This class implements the API for parameterized types.
  
  =for Pod::Coverage can_be_inlined type_parameter
  
  =head1 API
  
  This class implements the same API as L<Specio::Constraint::Simple>, with a few
  additions.
  
  =head2 Specio::Constraint::Parameterized->new(...)
  
  This class's constructor accepts two additional parameters:
  
  =over 4
  
  =item * parent
  
  This should be the L<Specio::Constraint::Parameterizable> object from which this
  object was created.
  
  This parameter is required.
  
  =item * parameter
  
  This is the type parameter for the parameterized type. This must be an object
  which does the L<Specio::Constraint::Role::Interface> role.
  
  This parameter is required.
  
  =back
  
  =head2 $type->parameter
  
  Returns the type that was passed to the constructor.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_CONSTRAINT_PARAMETERIZED

$fatpacked{"Specio/Constraint/Role/CanType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_CONSTRAINT_ROLE_CANTYPE';
  package Specio::Constraint::Role::CanType;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use Scalar::Util qw( blessed );
  use Specio::PartialDump qw( partial_dump );
  use Storable qw( dclone );
  
  use Role::Tiny;
  
  use Specio::Constraint::Role::Interface;
  with 'Specio::Constraint::Role::Interface';
  
  {
      ## no critic (Subroutines::ProtectPrivateSubs)
      my $attrs = dclone( Specio::Constraint::Role::Interface::_attrs() );
      ## use critic
  
      for my $name (qw( parent _inline_generator )) {
          $attrs->{$name}{init_arg} = undef;
          $attrs->{$name}{builder}
              = $name =~ /^_/ ? '_build' . $name : '_build_' . $name;
      }
  
      $attrs->{methods} = {
          isa      => 'ArrayRef',
          required => 1,
      };
  
      ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
      sub _attrs {
          return $attrs;
      }
  }
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _wrap_message_generator {
      my $self      = shift;
      my $generator = shift;
  
      my $type          = ( split /::/, blessed $self)[-1];
      my @methods       = @{ $self->methods };
      my $all_word_list = _word_list(@methods);
      my $allow_classes = $self->_allow_classes;
  
      unless ( defined $generator ) {
          $generator = sub {
              shift;
              my $value = shift;
  
              return
                  "An undef will never pass an $type check (wants $all_word_list)"
                  unless defined $value;
  
              my $class = blessed $value;
              if ( !defined $class ) {
  
                  # If we got here we know that blessed returned undef, so if
                  # it's a ref then it must not be blessed.
                  if ( ref $value ) {
                      my $dump = partial_dump($value);
                      return
                          "An unblessed reference ($dump) will never pass an $type check (wants $all_word_list)";
                  }
  
                  # If it's defined and not an unblessed ref it must be a
                  # string. If we allow classes (vs just objects) then it might
                  # be a valid class name.  But an empty string is never a valid
                  # class name. We cannot call q{}->can.
                  return
                      "An empty string will never pass an $type check (wants $all_word_list)"
                      unless length $value;
  
                  if ( ref \$value eq 'GLOB' ) {
                      return
                          "A glob will never pass an $type check (wants $all_word_list)";
                  }
  
                  if (
                      $value =~ /\A
                          \s*
                          -?[0-9]+(?:\.[0-9]+)?
                          (?:[Ee][\-+]?[0-9]+)?
                          \s*
                          \z/xs
                      ) {
                      return
                          "A number ($value) will never pass an $type check (wants $all_word_list)";
                  }
  
                  $class = $value if $allow_classes;
  
                  # At this point we either have undef or a non-empty string in
                  # $class.
                  unless ( defined $class ) {
                      my $dump = partial_dump($value);
                      return
                          "A plain scalar ($dump) will never pass an $type check (wants $all_word_list)";
                  }
              }
  
              my @missing = grep { !$value->can($_) } @methods;
  
              my $noun = @missing == 1 ? 'method' : 'methods';
              my $list = _word_list( map {qq['$_']} @missing );
  
              return "The $class class is missing the $list $noun";
          };
      }
  
      return sub { $generator->( undef, @_ ) };
  }
  ## use critic
  
  sub _word_list {
      my @items = sort { $a cmp $b } @_;
  
      return $items[0] if @items == 1;
      return join ' and ', @items if @items == 2;
  
      my $final = pop @items;
      my $list = join ', ', @items;
      $list .= ', and ' . $final;
  
      return $list;
  }
  
  1;
  
  # ABSTRACT: Provides a common implementation for Specio::Constraint::AnyCan and Specio::Constraint::ObjectCan
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Constraint::Role::CanType - Provides a common implementation for Specio::Constraint::AnyCan and Specio::Constraint::ObjectCan
  
  =head1 VERSION
  
  version 0.42
  
  =head1 DESCRIPTION
  
  See L<Specio::Constraint::AnyCan> and L<Specio::Constraint::ObjectCan> for details.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_CONSTRAINT_ROLE_CANTYPE

$fatpacked{"Specio/Constraint/Role/DoesType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_CONSTRAINT_ROLE_DOESTYPE';
  package Specio::Constraint::Role::DoesType;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use Role::Tiny;
  use Scalar::Util qw( blessed );
  use Specio::PartialDump qw( partial_dump );
  use Storable qw( dclone );
  
  use Specio::Constraint::Role::Interface;
  with 'Specio::Constraint::Role::Interface';
  
  {
      ## no critic (Subroutines::ProtectPrivateSubs)
      my $attrs = dclone( Specio::Constraint::Role::Interface::_attrs() );
      ## use critic
  
      for my $name (qw( parent _inline_generator )) {
          $attrs->{$name}{init_arg} = undef;
          $attrs->{$name}{builder}
              = $name =~ /^_/ ? '_build' . $name : '_build_' . $name;
      }
  
      $attrs->{role} = {
          isa      => 'Str',
          required => 1,
      };
  
      ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
      sub _attrs {
          return $attrs;
      }
  }
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _wrap_message_generator {
      my $self      = shift;
      my $generator = shift;
  
      my $type          = ( split /::/, blessed $self)[-1];
      my $role          = $self->role;
      my $allow_classes = $self->_allow_classes;
  
      unless ( defined $generator ) {
          $generator = sub {
              shift;
              my $value = shift;
  
              return "An undef will never pass an $type check (wants $role)"
                  unless defined $value;
  
              if ( ref $value && !blessed $value ) {
                  my $dump = partial_dump($value);
                  return
                      "An unblessed reference ($dump) will never pass an $type check (wants $role)";
              }
  
              if ( !blessed $value) {
                  return
                      "An empty string will never pass an $type check (wants $role)"
                      unless length $value;
  
                  if (
                      $value =~ /\A
                          \s*
                          -?[0-9]+(?:\.[0-9]+)?
                          (?:[Ee][\-+]?[0-9]+)?
                          \s*
                          \z/xs
                      ) {
                      return
                          "A number ($value) will never pass an $type check (wants $role)";
                  }
  
                  if ( !$allow_classes ) {
                      my $dump = partial_dump($value);
                      return
                          "A plain scalar ($dump) will never pass an $type check (wants $role)";
                  }
              }
  
              my $got = blessed $value;
              $got ||= $value;
  
              return "The $got class does not consume the $role role";
          };
      }
  
      return sub { $generator->( undef, @_ ) };
  }
  ## use critic
  
  1;
  
  # ABSTRACT: Provides a common implementation for Specio::Constraint::AnyDoes and Specio::Constraint::ObjectDoes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Constraint::Role::DoesType - Provides a common implementation for Specio::Constraint::AnyDoes and Specio::Constraint::ObjectDoes
  
  =head1 VERSION
  
  version 0.42
  
  =head1 DESCRIPTION
  
  See L<Specio::Constraint::AnyDoes> and L<Specio::Constraint::ObjectDoes> for
  details.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_CONSTRAINT_ROLE_DOESTYPE

$fatpacked{"Specio/Constraint/Role/Interface.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_CONSTRAINT_ROLE_INTERFACE';
  package Specio::Constraint::Role::Interface;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use Carp qw( confess );
  use Eval::Closure qw( eval_closure );
  use List::Util 1.33 qw( all any first );
  use Specio::Exception;
  use Specio::PartialDump qw( partial_dump );
  use Specio::TypeChecks qw( is_CodeRef );
  
  use Role::Tiny 1.003003;
  
  use Specio::Role::Inlinable;
  with 'Specio::Role::Inlinable';
  
  use overload(
      q{""}  => sub { $_[0] },
      '&{}'  => '_subification',
      'bool' => sub {1},
  );
  
  {
      ## no critic (Subroutines::ProtectPrivateSubs)
      my $role_attrs = Specio::Role::Inlinable::_attrs();
      ## use critic
  
      my $attrs = {
          %{$role_attrs},
          name => {
              isa       => 'Str',
              predicate => '_has_name',
          },
          parent => {
              does      => 'Specio::Constraint::Role::Interface',
              predicate => '_has_parent',
          },
          _constraint => {
              isa       => 'CodeRef',
              init_arg  => 'constraint',
              predicate => '_has_constraint',
          },
          _optimized_constraint => {
              isa      => 'CodeRef',
              init_arg => undef,
              lazy     => 1,
              builder  => '_build_optimized_constraint',
          },
          _ancestors => {
              isa      => 'ArrayRef',
              init_arg => undef,
              lazy     => 1,
              builder  => '_build_ancestors',
          },
          _message_generator => {
              isa      => 'CodeRef',
              init_arg => undef,
          },
          _coercions => {
              builder => '_build_coercions',
              clone   => '_clone_coercions',
          },
          _subification => {
              init_arg => undef,
              lazy     => 1,
              builder  => '_build_subification',
          },
  
          # Because types are cloned on import, we can't directly compare type
          # objects. Because type names can be reused between packages (no global
          # registry) we can't compare types based on name either.
          _signature => {
              isa      => 'Str',
              init_arg => undef,
              lazy     => 1,
              builder  => '_build_signature',
          },
      };
  
      ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
      sub _attrs {
          return $attrs;
      }
  }
  
  my $NullConstraint = sub {1};
  
  # See Specio::OO to see how this is used.
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _Specio_Constraint_Role_Interface_BUILD {
      my $self = shift;
      my $p    = shift;
  
      unless ( $self->_has_constraint || $self->_has_inline_generator ) {
          $self->{_constraint} = $NullConstraint;
      }
  
      die
          'A type constraint should have either a constraint or inline_generator parameter, not both'
          if $self->_has_constraint && $self->_has_inline_generator;
  
      $self->{_message_generator}
          = $self->_wrap_message_generator( $p->{message_generator} );
  
      return;
  }
  ## use critic
  
  sub _wrap_message_generator {
      my $self      = shift;
      my $generator = shift;
  
      unless ( defined $generator ) {
          $generator = sub {
              my $description = shift;
              my $value       = shift;
  
              return "Validation failed for $description with value "
                  . partial_dump($value);
          };
      }
  
      my $d = $self->description;
  
      return sub { $generator->( $d, @_ ) };
  }
  
  sub coercions               { values %{ $_[0]->{_coercions} } }
  sub coercion_from_type      { $_[0]->{_coercions}{ $_[1] } }
  sub _has_coercion_from_type { exists $_[0]->{_coercions}{ $_[1] } }
  sub _add_coercion           { $_[0]->{_coercions}{ $_[1] } = $_[2] }
  sub has_coercions           { scalar keys %{ $_[0]->{_coercions} } }
  
  sub validate_or_die {
      my $self  = shift;
      my $value = shift;
  
      return if $self->value_is_valid($value);
  
      Specio::Exception->throw(
          message => $self->_message_generator->($value),
          type    => $self,
          value   => $value,
      );
  }
  
  sub value_is_valid {
      my $self  = shift;
      my $value = shift;
  
      return $self->_optimized_constraint->($value);
  }
  
  sub _ancestors_and_self {
      my $self = shift;
  
      return ( ( reverse @{ $self->_ancestors } ), $self );
  }
  
  sub is_a_type_of {
      my $self = shift;
      my $type = shift;
  
      return any { $_->_signature eq $type->_signature }
      $self->_ancestors_and_self;
  }
  
  sub is_same_type_as {
      my $self = shift;
      my $type = shift;
  
      return $self->_signature eq $type->_signature;
  }
  
  sub is_anon {
      my $self = shift;
  
      return !$self->_has_name;
  }
  
  sub has_real_constraint {
      my $self = shift;
  
      return ( $self->_has_constraint && $self->_constraint ne $NullConstraint )
          || $self->_has_inline_generator;
  }
  
  sub can_be_inlined {
      my $self = shift;
  
      return 1 if $self->_has_inline_generator;
      return 0
          if $self->_has_constraint && $self->_constraint ne $NullConstraint;
  
      # If this type is an empty subtype of an inlinable parent, then we can
      # inline this type as well.
      return 1 if $self->_has_parent && $self->parent->can_be_inlined;
      return 0;
  }
  
  sub _build_generated_inline_sub {
      my $self = shift;
  
      my $type = $self->_self_or_first_inlinable_ancestor;
  
      my $source
          = 'sub { ' . $type->_inline_generator->( $type, '$_[0]' ) . '}';
  
      return eval_closure(
          source      => $source,
          environment => $type->inline_environment,
          description => 'inlined sub for ' . $self->description,
      );
  }
  
  sub _self_or_first_inlinable_ancestor {
      my $self = shift;
  
      my $type = first { $_->_has_inline_generator }
      reverse $self->_ancestors_and_self;
  
      # This should never happen because ->can_be_inlined should always be
      # checked before this builder is called.
      die 'Cannot generate an inline sub' unless $type;
  
      return $type;
  }
  
  sub _build_optimized_constraint {
      my $self = shift;
  
      if ( $self->can_be_inlined ) {
          return $self->_generated_inline_sub;
      }
      else {
          return $self->_constraint_with_parents;
      }
  }
  
  sub _constraint_with_parents {
      my $self = shift;
  
      my @constraints;
      for my $type ( $self->_ancestors_and_self ) {
          next unless $type->has_real_constraint;
  
          # If a type can be inlined, we can use that and discard all of the
          # ancestors we've seen so far, since we can assume that the inlined
          # constraint does all of the ancestor checks in addition to its own.
          if ( $type->can_be_inlined ) {
              @constraints = $type->_generated_inline_sub;
          }
          else {
              push @constraints, $type->_constraint;
          }
      }
  
      return $NullConstraint unless @constraints;
  
      return sub {
          all { $_->( $_[0] ) } @constraints;
      };
  }
  
  # This is only used for identifying from types as part of coercions, but I
  # want to leave open the possibility of using something other than
  # _description in the future.
  sub id {
      my $self = shift;
  
      return $self->description;
  }
  
  sub add_coercion {
      my $self     = shift;
      my $coercion = shift;
  
      my $from_id = $coercion->from->id;
  
      confess "Cannot add two coercions fom the same type: $from_id"
          if $self->_has_coercion_from_type($from_id);
  
      $self->_add_coercion( $from_id => $coercion );
  
      return;
  }
  
  sub has_coercion_from_type {
      my $self = shift;
      my $type = shift;
  
      return $self->_has_coercion_from_type( $type->id );
  }
  
  sub coerce_value {
      my $self  = shift;
      my $value = shift;
  
      for my $coercion ( $self->coercions ) {
          next unless $coercion->from->value_is_valid($value);
  
          return $coercion->coerce($value);
      }
  
      return $value;
  }
  
  sub can_inline_coercion {
      my $self = shift;
  
      return all { $_->can_be_inlined } $self->coercions;
  }
  
  sub can_inline_coercion_and_check {
      my $self = shift;
  
      return all { $_->can_be_inlined } $self, $self->coercions;
  }
  
  sub inline_coercion {
      my $self     = shift;
      my $arg_name = shift;
  
      die 'Cannot inline coercion'
          unless $self->can_inline_coercion;
  
      my $source = 'do { my $value = ' . $arg_name . ';';
  
      my ( $coerce, $env );
      ( $coerce, $arg_name, $env ) = $self->_inline_coercion($arg_name);
      $source .= $coerce . $arg_name . '};';
  
      return ( $source, $env );
  }
  
  sub inline_coercion_and_check {
      my $self     = shift;
      my $arg_name = shift;
  
      die 'Cannot inline coercion and check'
          unless $self->can_inline_coercion_and_check;
  
      my $source = 'do { my $value = ' . $arg_name . ';';
  
      my ( $coerce, $env );
      ( $coerce, $arg_name, $env ) = $self->_inline_coercion($arg_name);
      my ( $assert, $assert_env ) = $self->inline_assert($arg_name);
  
      $source .= $coerce;
      $source .= $assert;
      $source .= $arg_name . '};';
  
      return ( $source, { %{$env}, %{$assert_env} } );
  }
  
  sub _inline_coercion {
      my $self     = shift;
      my $arg_name = shift;
  
      return ( q{}, $arg_name, {} ) unless $self->has_coercions;
  
      my %env;
  
      $arg_name = '$value';
      my $source = $arg_name . ' = ';
      for my $coercion ( $self->coercions ) {
          $source
              .= '('
              . $coercion->from->inline_check($arg_name) . ') ? ('
              . $coercion->inline_coercion($arg_name) . ') : ';
  
          %env = (
              %env,
              %{ $coercion->inline_environment },
              %{ $coercion->from->inline_environment },
          );
      }
      $source .= $arg_name . ';';
  
      return ( $source, $arg_name, \%env );
  }
  
  {
      my $counter = 1;
  
      sub inline_assert {
          my $self = shift;
  
          my $type_var_name = '$_Specio_Constraint_Interface_type' . $counter;
          my $message_generator_var_name
              = '$_Specio_Constraint_Interface_message_generator' . $counter;
          my %env = (
              $type_var_name              => \$self,
              $message_generator_var_name => \( $self->_message_generator ),
              %{ $self->inline_environment },
          );
  
          my $source = $self->inline_check( $_[0] );
          $source .= ' or ';
          $source .= $self->_inline_throw_exception(
              $_[0],
              $message_generator_var_name,
              $type_var_name
          );
          $source .= ';';
  
          $counter++;
  
          return ( $source, \%env );
      }
  }
  
  sub inline_check {
      my $self = shift;
  
      die 'Cannot inline' unless $self->can_be_inlined;
  
      my $type = $self->_self_or_first_inlinable_ancestor;
      return $type->_inline_generator->( $type, @_ );
  }
  
  # For some idiotic reason I called $type->_subify directly in Code::TidyAll so
  # I'll leave this in here for now.
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _subify { $_[0]->_subification }
  ## use critic
  
  sub _build_subification {
      my $self = shift;
  
      if ( defined &Sub::Quote::quote_sub && $self->can_be_inlined ) {
          return Sub::Quote::quote_sub( $self->inline_assert('$_[0]') );
      }
      else {
          return sub { $self->validate_or_die( $_[0] ) };
      }
  }
  
  sub _inline_throw_exception {
      my $self                       = shift;
      my $value_var                  = shift;
      my $message_generator_var_name = shift;
      my $type_var_name              = shift;
  
      #<<<
      return 'Specio::Exception->throw( '
          . ' message => ' . $message_generator_var_name . '->(' . $value_var . '),'
          . ' type    => ' . $type_var_name . ','
          . ' value   => ' . $value_var . ' )';
      #>>>
  }
  
  # This exists for the benefit of Moo
  sub coercion_sub {
      my $self = shift;
  
      if ( defined &Sub::Quote::quote_sub
          && all { $_->can_be_inlined } $self->coercions ) {
  
          my $inline = q{};
          my %env;
  
          for my $coercion ( $self->coercions ) {
              $inline .= sprintf(
                  '$_[0] = %s if %s;' . "\n",
                  $coercion->inline_coercion('$_[0]'),
                  $coercion->from->inline_check('$_[0]')
              );
  
              %env = (
                  %env,
                  %{ $coercion->inline_environment },
                  %{ $coercion->from->inline_environment },
              );
          }
  
          $inline .= sprintf( "%s;\n", '$_[0]' );
  
          return Sub::Quote::quote_sub( $inline, \%env );
      }
      else {
          return sub { $self->coerce_value(shift) };
      }
  }
  
  sub _build_ancestors {
      my $self = shift;
  
      my @parents;
  
      my $type = $self;
      while ( $type = $type->parent ) {
          push @parents, $type;
      }
  
      return \@parents;
  
  }
  
  sub _build_description {
      my $self = shift;
  
      my $desc
          = $self->is_anon ? 'anonymous type' : 'type named ' . $self->name;
  
      $desc .= q{ } . $self->declared_at->description;
  
      return $desc;
  }
  
  sub _build_coercions { {} }
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _clone_coercions {
      my $self = shift;
  
      my $coercions = $self->_coercions;
      my %clones;
  
      for my $name ( keys %{$coercions} ) {
          my $coercion = $coercions->{$name};
          $clones{$name} = $coercion->clone_with_new_to($self);
      }
  
      return \%clones;
  }
  ## use critic
  
  sub _build_signature {
      my $self = shift;
  
      # This assumes that when a type is cloned, the underlying constraint or
      # generator sub is copied by _reference_, so it has the same memory
      # address and stringifies to the same value. XXX - will this break under
      # threads?
      return join "\n",
          ( $self->_has_parent ? $self->parent->_signature : () ),
          (
          defined $self->_constraint
          ? $self->_constraint
          : $self->_inline_generator
          );
  }
  
  # Moose compatibility methods - these exist as a temporary hack to make Specio
  # work with Moose.
  
  sub has_coercion {
      shift->has_coercions;
  }
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _inline_check {
      shift->inline_check(@_);
  }
  
  sub _compiled_type_constraint {
      shift->_optimized_constraint;
  }
  ## use critic;
  
  # This class implements the methods that Moose expects from coercions as well.
  sub coercion {
      return shift;
  }
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _compiled_type_coercion {
      my $self = shift;
  
      return sub {
          return $self->coerce_value(shift);
      };
  }
  ## use critic
  
  sub has_message {
      1;
  }
  
  sub message {
      shift->_message_generator;
  }
  
  sub get_message {
      my $self  = shift;
      my $value = shift;
  
      return $self->_message_generator->( $self, $value );
  }
  
  sub check {
      shift->value_is_valid(@_);
  }
  
  sub coerce {
      shift->coerce_value(@_);
  }
  
  1;
  
  # ABSTRACT: The interface all type constraints should provide
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Constraint::Role::Interface - The interface all type constraints should provide
  
  =head1 VERSION
  
  version 0.42
  
  =head1 DESCRIPTION
  
  This role defines the interface that all type constraints must provide, and
  provides most (or all) of the implementation. The L<Specio::Constraint::Simple>
  class simply consumes this role and provides no additional code. Other
  constraint classes add features or override some of this role's functionality.
  
  =for Pod::Coverage .*
  
  =head1 API
  
  See the L<Specio::Constraint::Simple> documentation for details. See the
  internals of various constraint classes to see how this role can be overridden
  or expanded upon.
  
  =head1 ROLES
  
  This role does the L<Specio::Role::Inlinable> role.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_CONSTRAINT_ROLE_INTERFACE

$fatpacked{"Specio/Constraint/Role/IsaType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_CONSTRAINT_ROLE_ISATYPE';
  package Specio::Constraint::Role::IsaType;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use Scalar::Util qw( blessed );
  use Specio::PartialDump qw( partial_dump );
  use Storable qw( dclone );
  
  use Role::Tiny;
  
  use Specio::Constraint::Role::Interface;
  with 'Specio::Constraint::Role::Interface';
  
  {
      ## no critic (Subroutines::ProtectPrivateSubs)
      my $attrs = dclone( Specio::Constraint::Role::Interface::_attrs() );
      ## use critic
  
      for my $name (qw( parent _inline_generator )) {
          $attrs->{$name}{init_arg} = undef;
          $attrs->{$name}{builder}
              = $name =~ /^_/ ? '_build' . $name : '_build_' . $name;
      }
  
      $attrs->{class} = {
          isa      => 'ClassName',
          required => 1,
      };
  
      ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
      sub _attrs {
          return $attrs;
      }
  }
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _wrap_message_generator {
      my $self      = shift;
      my $generator = shift;
  
      my $type          = ( split /::/, blessed $self)[-1];
      my $class         = $self->class;
      my $allow_classes = $self->_allow_classes;
  
      unless ( defined $generator ) {
          $generator = sub {
              shift;
              my $value = shift;
  
              return "An undef will never pass an $type check (wants $class)"
                  unless defined $value;
  
              if ( ref $value && !blessed $value) {
                  my $dump = partial_dump($value);
                  return
                      "An unblessed reference ($dump) will never pass an $type check (wants $class)";
              }
  
              if ( !blessed $value) {
                  return
                      "An empty string will never pass an $type check (wants $class)"
                      unless length $value;
  
                  if (
                      $value =~ /\A
                          \s*
                          -?[0-9]+(?:\.[0-9]+)?
                          (?:[Ee][\-+]?[0-9]+)?
                          \s*
                          \z/xs
                      ) {
                      return
                          "A number ($value) will never pass an $type check (wants $class)";
                  }
  
                  if ( !$allow_classes ) {
                      my $dump = partial_dump($value);
                      return
                          "A plain scalar ($dump) will never pass an $type check (wants $class)";
                  }
              }
  
              my $got = blessed $value;
              $got ||= $value;
  
              return "The $got class is not a subclass of the $class class";
          };
      }
  
      return sub { $generator->( undef, @_ ) };
  }
  ## use critic
  
  1;
  
  # ABSTRACT: Provides a common implementation for Specio::Constraint::AnyIsa and Specio::Constraint::ObjectIsa
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Constraint::Role::IsaType - Provides a common implementation for Specio::Constraint::AnyIsa and Specio::Constraint::ObjectIsa
  
  =head1 VERSION
  
  version 0.42
  
  =head1 DESCRIPTION
  
  See L<Specio::Constraint::AnyIsa> and L<Specio::Constraint::ObjectIsa> for details.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_CONSTRAINT_ROLE_ISATYPE

$fatpacked{"Specio/Constraint/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_CONSTRAINT_SIMPLE';
  package Specio::Constraint::Simple;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use Role::Tiny::With;
  use Specio::OO;
  
  with 'Specio::Constraint::Role::Interface';
  
  __PACKAGE__->_ooify;
  
  1;
  
  # ABSTRACT: Class for simple (non-parameterized or specialized) types
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Constraint::Simple - Class for simple (non-parameterized or specialized) types
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
      my $str = t('Str');
  
      print $str->name; # Str
  
      my $parent = $str->parent;
  
      if ( $str->value_is_valid($value) ) { ... }
  
      $str->validate_or_die($value);
  
      my $code = $str->inline_coercion_and_check('$_[0]');
  
  =head1 DESCRIPTION
  
  This class implements simple type constraints, constraints without special
  properties or parameterization.
  
  It does not actually contain any real code of its own. The entire
  implementation is provided by the L<Specio::Constraint::Role::Interface> role,
  but the primary API for type constraints is documented here.
  
  All other type constraint classes in this distribution implement this API,
  except where otherwise noted.
  
  =head1 API
  
  This class provides the following methods.
  
  =head2 Specio::Constraint::Simple->new(...)
  
  This creates a new constraint. It accepts the following named parameters:
  
  =over 4
  
  =item * name => $name
  
  This is the type's name. The name is optional, but if provided it must be a
  string.
  
  =item * parent => $type
  
  The type's parent type. This must be an object which does the
  L<Specio::Constraint::Role::Interface> role.
  
  This parameter is optional.
  
  =item * constraint => sub { ... }
  
  A subroutine reference implementing the constraint. It will be called as a
  method on the object and passed a single argument, the value to check.
  
  It should return true or false to indicate whether the value matches the
  constraint.
  
  This parameter is mutually exclusive with C<inline_generator>.
  
  You can also pass this option with the key C<where> in the parameter list.
  
  =item * inline_generator => sub { ... }
  
  This should be a subroutine reference which returns a string containing a
  single term. This code should I<not> end in a semicolon. This code should
  implement the constraint.
  
  The generator will be called as a method on the constraint with a single
  argument. That argument is the name of the variable being coerced, something
  like C<'$_[0]'> or C<'$var'>.
  
  The inline generator is expected to include code to implement both the current
  type and all its parents. Typically, the easiest way to do this is to write a
  subroutine something like this:
  
    sub {
        my $self = shift;
        my $var  = shift;
  
        return $_[0]->parent->inline_check( $_[1] )
            . ' and more checking code goes here';
    }
  
  This parameter is mutually exclusive with C<constraint>.
  
  You can also pass this option with the key C<inline> in the parameter list.
  
  =item * inline_environment => {}
  
  This should be a hash reference of variable names (with sigils) and values for
  that variable. The values should be I<references> to the values of the
  variables.
  
  This environment will be used when compiling the constraint as part of a
  subroutine. The named variables will be captured as closures in the generated
  subroutine, using L<Eval::Closure>.
  
  It should be very rare to need to set this in the constructor. It's more
  likely that a special type subclass would need to provide values that it
  generates internally.
  
  If you do set this, you are responsible for generating variable names that
  won't clash with anything else in the inlined code.
  
  This parameter defaults to an empty hash reference.
  
  =item * message_generator => sub { ... }
  
  A subroutine to generate an error message when the type check fails. The
  default message says something like "Validation failed for type named Int
  declared in package Specio::Library::Builtins
  (.../Specio/blib/lib/Specio/Library/Builtins.pm) at line 147 in sub named (eval)
  with value 1.1".
  
  You can override this to provide something more specific about the way the
  type failed.
  
  The subroutine you provide will be called as a subroutine, I<not as a method>,
  with two arguments. The first is the description of the type (the bit in the
  message above that starts with "type named Int ..." and ends with "... in sub
  named (eval)". This description says what the thing is and where it was
  defined.
  
  The second argument is the value that failed the type check, after any
  coercions that might have been applied.
  
  You can also pass this option with the key C<message> in the parameter list.
  
  =item * declared_at => $declared_at
  
  This parameter must be a L<Specio::DeclaredAt> object.
  
  This parameter is required.
  
  =back
  
  It is possible to create a type without a constraint of its own.
  
  =head2 $type->name
  
  Returns the name of the type as it was passed the constructor.
  
  =head2 $type->parent
  
  Returns the parent type passed to the constructor. If the type has no parent
  this returns C<undef>.
  
  =head2 $type->is_anon
  
  Returns false for named types, true otherwise.
  
  =head2 $type->is_a_type_of($other_type)
  
  Given a type object, this returns true if the type this method is called on is
  a descendant of that type or is that type.
  
  =head2 $type->is_same_type_as($other_type)
  
  Given a type object, this returns true if the type this method is called on is
  the same as that type.
  
  =head2 $type->coercions
  
  Returns a list of L<Specio::Coercion> objects which belong to this constraint.
  
  =head2 $type->coercion_from_type($name)
  
  Given a type name, this method returns a L<Specio::Coercion> object which
  coerces from that type, if such a coercion exists.
  
  =head2 $type->validate_or_die($value)
  
  This method does nothing if the value is valid. If it is not, it throws a
  L<Specio::Exception>.
  
  =head2 $type->value_is_valid($value)
  
  Returns true or false depending on whether the C<$value> passes the type
  constraint.
  
  =head2 $type->has_real_constraint
  
  This returns true if the type was created with a C<constraint> or
  C<inline_generator> parameter. This is used internally to skip type checks for
  types that don't actually implement a constraint.
  
  =head2 $type->description
  
  This returns a string describing the type. This includes the type's name and
  where it was declared, so you end up with something like C<'type named Foo
  declared in package My::Lib (lib/My/Lib.pm) at line 42'>. If the type is
  anonymous the name will be "anonymous type".
  
  =head2 $type->id
  
  This is a unique id for the type as a string. This is useful if you need to
  make a hash key based on a type, for example. This should be treated as an
  essentially arbitrary and opaque string, and could change at any time in the
  future. If you want something human-readable, use the C<< $type->description
  >> method.
  
  =head2 $type->add_coercion($coercion)
  
  This adds a new L<Specio::Coercion> to the type. If the type already has a
  coercion from the same type as the new coercion, it will throw an error.
  
  =head2 $type->has_coercion_from_type($other_type)
  
  This method returns true if the type can coerce from the other type.
  
  =head2 $type->coerce_value($value)
  
  This attempts to coerce a value into a new value that matches the type. It
  checks all of the type's coercions. If it finds one which has a "from" type
  that accepts the value, it runs the coercion and returns the new value.
  
  If it cannot find a matching coercion it returns the original value.
  
  =head2 $type->inline_coercion_and_check($var)
  
  Given a variable name, this returns a string of code and an environment hash
  that implements all of the type's coercions as well as the type check itself.
  
  This will throw an exception unless both the type and all of its coercions are
  inlinable.
  
  The generated code will throw a L<Specio::Exception> if the type constraint
  fails. If the constraint passes, then the generated code returns the (possibly
  coerced) value.
  
  The return value is a two-element list. The first element is the code. The
  second is a hash reference containing variables which need to be in scope for
  the code to work. This is intended to be passed to L<Eval::Closure>'s
  C<eval_closure> subroutine.
  
  The returned code is a single C<do { }> block without a terminating
  semicolon.
  
  =head2 $type->inline_assert($var)
  
  Given a variable name, this generates code that implements the constraint and
  throws an exception if the variable does not pass the constraint.
  
  The return value is a two-element list. The first element is the code. The
  second is a hash reference containing variables which need to be in scope for
  the code to work. This is intended to be passed to L<Eval::Closure>'s
  C<eval_closure> subroutine.
  
  =head2 $type->inline_check($var)
  
  Given a variable name, this returns a string of code that implements the
  constraint. If the type is not inlinable, this method throws an error.
  
  =head2 $type->inline_coercion($var)
  
  Given a variable name, this returns a string of code and an environment hash
  that implements all of the type's coercions. I<It does not check that the
  resulting value is valid.>
  
  This will throw an exception unless all of the type's coercions are inlinable.
  
  The return value is a two-element list. The first element is the code. The
  second is a hash reference containing variables which need to be in scope for
  the code to work. This is intended to be passed to L<Eval::Closure>'s
  C<eval_closure> subroutine.
  
  The returned code is a single C<do { }> block without a terminating
  semicolon.
  
  =head2 $type->inline_environment()
  
  This returns a hash defining the variables that need to be closed over when
  inlining the type. The keys are full variable names like C<'$foo'> or
  C<'@bar'>. The values are I<references> to a variable of the matching type.
  
  =head2 $type->coercion_sub
  
  This method returns a sub ref that takes a single argument and applied all
  relevant coercions to it. This sub ref will use L<Sub::Quote> if all the
  type's coercions are inlinable.
  
  This method exists primarily for the benefit of L<Moo>.
  
  =head1 OVERLOADING
  
  All constraints overloading subroutine de-referencing for the benefit of
  L<Moo>. The returned subroutine uses L<Sub::Quote> if the type constraint is
  inlinable.
  
  =head1 ROLES
  
  This role does the L<Specio::Constraint::Role::Interface> and
  L<Specio::Role::Inlinable> roles.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_CONSTRAINT_SIMPLE

$fatpacked{"Specio/Constraint/Structurable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_CONSTRAINT_STRUCTURABLE';
  package Specio::Constraint::Structurable;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use Carp qw( confess );
  use Role::Tiny::With;
  use Scalar::Util qw( blessed );
  use Specio::DeclaredAt;
  use Specio::OO;
  use Specio::Constraint::Structured;
  use Specio::TypeChecks qw( does_role isa_class );
  
  use Specio::Constraint::Role::Interface;
  with 'Specio::Constraint::Role::Interface';
  
  {
      ## no critic (Subroutines::ProtectPrivateSubs)
      my $role_attrs = Specio::Constraint::Role::Interface::_attrs();
      ## use critic
  
      my $attrs = {
          %{$role_attrs},
          _parameterization_args_builder => {
              isa      => 'CodeRef',
              init_arg => 'parameterization_args_builder',
              required => 1,
          },
          _name_builder => {
              isa      => 'CodeRef',
              init_arg => 'name_builder',
              required => 1,
          },
          _structured_constraint_generator => {
              isa       => 'CodeRef',
              init_arg  => 'structured_constraint_generator',
              predicate => '_has_structured_constraint_generator',
          },
          _structured_inline_generator => {
              isa       => 'CodeRef',
              init_arg  => 'structured_inline_generator',
              predicate => '_has_structured_inline_generator',
          },
      };
  
      ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
      sub _attrs {
          return $attrs;
      }
  }
  
  sub BUILD {
      my $self = shift;
  
      if ( $self->_has_constraint ) {
          die
              'A structurable constraint with a constraint parameter must also have a structured_constraint_generator'
              unless $self->_has_structured_constraint_generator;
      }
  
      if ( $self->_has_inline_generator ) {
          die
              'A structurable constraint with an inline_generator parameter must also have a structured_inline_generator'
              unless $self->_has_structured_inline_generator;
      }
  
      return;
  }
  
  sub parameterize {
      my $self = shift;
      my %args = @_;
  
      my $declared_at = $args{declared_at};
  
      if ($declared_at) {
          isa_class( $declared_at, 'Specio::DeclaredAt' )
              or confess
              q{The "declared_at" parameter passed to ->parameterize must be a Specio::DeclaredAt object};
      }
  
      my %parameters
          = $self->_parameterization_args_builder->( $self, $args{of} );
  
      $declared_at = Specio::DeclaredAt->new_from_caller(1)
          unless defined $declared_at;
  
      my %new_p = (
          parent      => $self,
          parameters  => \%parameters,
          declared_at => $declared_at,
          name        => $self->_name_builder->( $self, \%parameters ),
      );
  
      if ( $self->_has_structured_constraint_generator ) {
          $new_p{constraint}
              = $self->_structured_constraint_generator->(%parameters);
      }
      else {
          for my $p (
              grep {
                         blessed($_)
                      && does_role('Specio::Constraint::Role::Interface')
              } values %parameters
              ) {
  
              confess
                  q{Any type objects passed to ->parameterize must be inlinable constraints if the structurable type has an inline_generator}
                  unless $p->can_be_inlined;
          }
  
          my $ig = $self->_structured_inline_generator;
          $new_p{inline_generator}
              = sub { $ig->( shift, shift, %parameters, @_ ) };
      }
  
      return Specio::Constraint::Structured->new(%new_p);
  }
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _name_or_anon {
      return $_[1]->_has_name ? $_[1]->name : 'ANON';
  }
  ## use critic
  
  __PACKAGE__->_ooify;
  
  1;
  
  # ABSTRACT: A class which represents structurable constraints
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Constraint::Structurable - A class which represents structurable constraints
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
      my $tuple = t('Tuple');
  
      my $tuple_of_str_int = $tuple->parameterize( of => [ t('Str'), t('Int') ] );
  
  =head1 DESCRIPTION
  
  This class implements the API for structurable types like C<Dict>, C<Map>< and
  C<Tuple>.
  
  =for Pod::Coverage BUILD
  
  =head1 API
  
  This class implements the same API as L<Specio::Constraint::Simple>, with a few
  additions.
  
  =head2 Specio::Constraint::Structurable->new(...)
  
  This class's constructor accepts two additional parameters:
  
  =over 4
  
  =item * parameterization_args_builder
  
  This is a subroutine that takes the values passed to C<of> and returns a hash
  of named arguments. These arguments will then be passed into the
  C<structured_constraint_generator> or C<structured_inline_generator>.
  
  This should also do argument checking to make sure that the argument passed
  are valid. For example, the C<Tuple> type turns the arrayref passed to C<of>
  into a hash, along the way checking that the caller did not do things like
  interleave optional and required elements or mix optional and slurpy together
  in the definition.
  
  This parameter is required.
  
  =item * name_builder
  
  This is a subroutine that is called to generate a name for the structured type
  when it is created. This will be called as a method on the
  C<Specio::Constraint::Structurable> object. It will be passed the hash of
  arguments returned by the C<parameterization_args_builder>.
  
  This parameter is required.
  
  =item * structured_constraint_generator
  
  This is a subroutine that generates a new constraint subroutine when the type
  is structured.
  
  It will be called as a method on the type and will be passed the hash of
  arguments returned by the C<parameterization_args_builder>.
  
  This parameter is mutually exclusive with the C<structured_inline_generator>
  parameter.
  
  This parameter or the C<structured_inline_generator> parameter is required.
  
  =item * structured_inline_generator
  
  This is a subroutine that generates a new inline generator subroutine when the
  type is structured.
  
  It will be called as a method on the L<Specio::Constraint::Structured> object
  when that object needs to generate an inline constraint. It will receive the
  type parameter as the first argument and the variable name as a string as the
  second.
  
  The remaining arguments will be the parameter hash returned by the
  C<parameterization_args_builder>.
  
  This probably seems fairly confusing, so looking at the examples in the
  L<Specio::Library::Structured::*> code may be helpful.
  
  This parameter is mutually exclusive with the
  C<structured_constraint_generator> parameter.
  
  This parameter or the C<structured_constraint_generator> parameter is
  required.
  
  =back
  
  =head2 $type->parameterize(...)
  
  This method takes two arguments. The C<of> argument should be an object which
  does the L<Specio::Constraint::Role::Interface> role, and is required.
  
  The other argument, C<declared_at>, is optional. If it is not given, then a
  new L<Specio::DeclaredAt> object is creating using a call stack depth of 1.
  
  This method returns a new L<Specio::Constraint::Structured> object.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_CONSTRAINT_STRUCTURABLE

$fatpacked{"Specio/Constraint/Structured.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_CONSTRAINT_STRUCTURED';
  package Specio::Constraint::Structured;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use List::Util qw( all );
  use Role::Tiny::With;
  use Specio::OO;
  use Specio::TypeChecks qw( does_role );
  use Storable qw( dclone );
  
  use Specio::Constraint::Role::Interface;
  with 'Specio::Constraint::Role::Interface';
  
  {
      ## no critic (Subroutines::ProtectPrivateSubs)
      my $attrs = dclone( Specio::Constraint::Role::Interface::_attrs() );
      ## use critic
  
      $attrs->{parent}{isa}      = 'Specio::Constraint::Structurable';
      $attrs->{parent}{required} = 1;
  
      $attrs->{parameters} = {
          isa      => 'HashRef',
          required => 1,
      };
  
      ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
      sub _attrs {
          return $attrs;
      }
  }
  
  sub can_be_inlined {
      my $self = shift;
      return $self->_has_inline_generator;
  }
  
  __PACKAGE__->_ooify;
  
  1;
  
  # ABSTRACT: A class which represents structured constraints
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Constraint::Structured - A class which represents structured constraints
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
      my $tuple = t('Tuple');
  
      my $tuple_of_str_int = $tuple->parameterize( of => [ t('Str'), t('Int') ] );
  
      my $parent = $tuple_of_str_int->parent; # returns Tuple
      my $parameters = $arrayref_of_int->parameters; # returns { of => [ t('Str'), t('Int') ] }
  
  =head1 DESCRIPTION
  
  This class implements the API for structured types.
  
  =for Pod::Coverage can_be_inlined type_parameter
  
  =head1 API
  
  This class implements the same API as L<Specio::Constraint::Simple>, with a few
  additions.
  
  =head2 Specio::Constraint::Structured->new(...)
  
  This class's constructor accepts two additional parameters:
  
  =over 4
  
  =item * parent
  
  This should be the L<Specio::Constraint::Structurable> object from which this
  object was created.
  
  This parameter is required.
  
  =item * parameters
  
  This is the hashref of parameters for the structured type. These are the
  parameters returned by the C<Structurable> type's
  C<parameterization_args_builder>. The exact form of this hashref will vary for
  each structured type.
  
  This parameter is required.
  
  =back
  
  =head2 $type->parameters
  
  Returns the hashref that was passed to the constructor.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_CONSTRAINT_STRUCTURED

$fatpacked{"Specio/Constraint/Union.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_CONSTRAINT_UNION';
  package Specio::Constraint::Union;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use List::Util qw( all any );
  use Role::Tiny::With;
  use Specio::OO;
  use Storable qw( dclone );
  
  use Specio::Constraint::Role::Interface;
  with 'Specio::Constraint::Role::Interface';
  
  {
      ## no critic (Subroutines::ProtectPrivateSubs)
      my $attrs = dclone( Specio::Constraint::Role::Interface::_attrs() );
      ## use critic
  
      for my $name (qw( _constraint _inline_generator )) {
          delete $attrs->{$name}{predicate};
          $attrs->{$name}{init_arg} = undef;
          $attrs->{$name}{lazy}     = 1;
          $attrs->{$name}{builder}
              = $name =~ /^_/ ? '_build' . $name : '_build_' . $name;
      }
  
      delete $attrs->{parent};
  
      delete $attrs->{name}{predicate};
      $attrs->{name}{lazy}    = 1;
      $attrs->{name}{builder} = '_build_name';
  
      $attrs->{of} = {
          isa      => 'ArrayRef',
          required => 1,
      };
  
      ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
      sub _attrs {
          return $attrs;
      }
  }
  
  sub parent {undef}
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _has_parent {0}
  
  sub _has_name {
      my $self = shift;
      return defined $self->name;
  }
  
  sub _build_name {
      my $self = shift;
  
      return unless all { $_->_has_name } @{ $self->of };
      return join q{ | }, map { $_->name } @{ $self->of };
  }
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _has_constraint {
      my $self = shift;
  
      return !$self->_has_inline_generator;
  }
  ## use critic
  
  sub _build_constraint {
      return $_[0]->_optimized_constraint;
  }
  
  sub _build_optimized_constraint {
      my $self = shift;
  
      ## no critic (Subroutines::ProtectPrivateSubs)
      my @c = map { $_->_optimized_constraint } @{ $self->of };
      return sub {
          return any { $_->( $_[0] ) } @c;
      };
  }
  
  sub _has_inline_generator {
      my $self = shift;
  
      ## no critic (Subroutines::ProtectPrivateSubs)
      return all { $_->_has_inline_generator } @{ $self->of };
  }
  
  sub _build_inline_generator {
      my $self = shift;
  
      return sub {
          return '(' . (
              join q{ || },
              map { sprintf( '( %s )', $_->_inline_generator->( $_, $_[1] ) ) }
                  @{ $self->of }
          ) . ')';
          }
  }
  
  sub _build_inline_environment {
      my $self = shift;
  
      my %env;
      for my $type ( @{ $self->of } ) {
          %env = (
              %env,
              %{ $type->inline_environment },
          );
      }
  
      return \%env;
  }
  
  __PACKAGE__->_ooify;
  
  1;
  
  # ABSTRACT: A class for union constraints
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Constraint::Union - A class for union constraints
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
      my $type = Specio::Constraint::Untion->new(...);
  
  =head1 DESCRIPTION
  
  This is a specialized type constraint class for unions, which will allow a
  value which matches any one of several distinct types.
  
  =for Pod::Coverage parent
  
  =head1 API
  
  This class provides all of the same methods as L<Specio::Constraint::Simple>,
  with a few differences:
  
  =head2 Specio::Constraint::Union->new( ... )
  
  The C<parent> parameter is ignored if it passed, as it is always C<undef>
  
  The C<inline_generator> and C<constraint> parameters are also ignored. This
  class provides its own default inline generator subroutine reference.
  
  Finally, this class requires an additional parameter, C<of>. This must be an
  arrayref of type objects.
  
  =head2 $union->of
  
  Returns an array reference of the individual types which makes up this union.
  
  =head1 ROLES
  
  This class does the L<Specio::Constraint::Role::Interface> and
  L<Specio::Role::Inlinable> roles.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_CONSTRAINT_UNION

$fatpacked{"Specio/Declare.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_DECLARE';
  package Specio::Declare;
  
  use strict;
  use warnings;
  
  use parent 'Exporter';
  
  our $VERSION = '0.42';
  
  use Carp qw( croak );
  use Specio::Coercion;
  use Specio::Constraint::Simple;
  use Specio::DeclaredAt;
  use Specio::Helpers qw( install_t_sub _STRINGLIKE );
  use Specio::Registry qw( internal_types_for_package register );
  
  ## no critic (Modules::ProhibitAutomaticExportation)
  our @EXPORT = qw(
      anon
      any_can_type
      any_does_type
      any_isa_type
      coerce
      declare
      enum
      intersection
      object_can_type
      object_does_type
      object_isa_type
      union
  );
  ## use critic
  
  sub import {
      my $package = shift;
  
      # What the heck is this monstrosity?
      #
      # Moose version 2.0901 included a first pass at support for Specio. This
      # was based on Specio c. 0.06 when Specio itself still used
      # Moose. Unfortunately, recent changes to Specio broke this support and
      # the Moose core needs updating.
      #
      # However, stable versions of Moose have since shipped with a test that
      # attempts to test itself with Specio 0.07+. This was fine until I wanted
      # to release a non-TRIAL Specio.
      #
      # Once that's out, anyone installing Specio will cause future attempts to
      # install Moose to fail until Moose includes updated Specio support!
      # Breaking Moose is not acceptable, thus this mess.
      #
      # Note that since Moose 2.1207 this test was renamed and the Specio tests
      # actually run (and pass). We still need to leave this in here for quite
      # some time. People should be able to install Specio and then install an
      # older Moose indefinitely (or at least for a year or two).
      if (   $ENV{HARNESS_ACTIVE}
          && $0 =~ m{t[\\/]type_constraints[\\/]specio\.t$} ) {
  
          require Test::More;
          Test::More::plan( skip_all =>
                  'These tests will not pass with this version of Specio' );
          exit 0;
      }
  
      my $caller = caller();
  
      $package->export_to_level( 1, $package, @_ );
  
      install_t_sub(
          $caller,
          internal_types_for_package($caller)
      );
  
      return;
  }
  
  sub declare {
      my $name = _STRINGLIKE(shift)
          or croak 'You must provide a name for declared types';
      my %p = @_;
  
      my $tc = _make_tc( name => $name, %p );
  
      register( scalar caller(), $name, $tc, 'exportable' );
  
      return $tc;
  }
  
  sub anon {
      return _make_tc(@_);
  }
  
  sub enum {
      my $name;
      $name = shift if @_ % 2;
      my %p = @_;
  
      require Specio::Constraint::Enum;
  
      my $tc = _make_tc(
          ( defined $name ? ( name => $name ) : () ),
          values     => $p{values},
          type_class => 'Specio::Constraint::Enum',
      );
  
      register( scalar caller(), $name, $tc, 'exportable' )
          if defined $name;
  
      return $tc;
  }
  
  sub object_can_type {
      my $name;
      $name = shift if @_ % 2;
      my %p = @_;
  
      # This cannot be loaded earlier, since it loads Specio::Library::Builtins,
      # which in turn wants to load Specio::Declare (the current module).
      require Specio::Constraint::ObjectCan;
  
      my $tc = _make_tc(
          ( defined $name ? ( name => $name ) : () ),
          methods    => $p{methods},
          type_class => 'Specio::Constraint::ObjectCan',
      );
  
      register( scalar caller(), $name, $tc, 'exportable' )
          if defined $name;
  
      return $tc;
  }
  
  sub object_does_type {
      my $name;
      $name = shift if @_ % 2;
      my %p = @_;
  
      my $caller = scalar caller();
  
      # If we are being called repeatedly with a single argument, then we don't
      # want to blow up because the type has already been declared. This would
      # force the user to use t() for all calls but the first, making their code
      # pointlessly more complicated.
      unless ( keys %p ) {
          if ( my $exists = internal_types_for_package($caller)->{$name} ) {
              return $exists;
          }
      }
  
      require Specio::Constraint::ObjectDoes;
  
      my $tc = _make_tc(
          ( defined $name ? ( name => $name ) : () ),
          role => ( defined $p{role} ? $p{role} : $name ),
          type_class => 'Specio::Constraint::ObjectDoes',
      );
  
      register( scalar caller(), $name, $tc, 'exportable' )
          if defined $name;
  
      return $tc;
  }
  
  sub object_isa_type {
      my $name;
      $name = shift if @_ % 2;
      my %p = @_;
  
      my $caller = scalar caller();
      unless ( keys %p ) {
          if ( my $exists = internal_types_for_package($caller)->{$name} ) {
              return $exists;
          }
      }
  
      require Specio::Constraint::ObjectIsa;
  
      my $tc = _make_tc(
          ( defined $name ? ( name => $name ) : () ),
          class => ( defined $p{class} ? $p{class} : $name ),
          type_class => 'Specio::Constraint::ObjectIsa',
      );
  
      register( $caller, $name, $tc, 'exportable' )
          if defined $name;
  
      return $tc;
  }
  
  sub any_can_type {
      my $name;
      $name = shift if @_ % 2;
      my %p = @_;
  
      # This cannot be loaded earlier, since it loads Specio::Library::Builtins,
      # which in turn wants to load Specio::Declare (the current module).
      require Specio::Constraint::AnyCan;
  
      my $tc = _make_tc(
          ( defined $name ? ( name => $name ) : () ),
          methods    => $p{methods},
          type_class => 'Specio::Constraint::AnyCan',
      );
  
      register( scalar caller(), $name, $tc, 'exportable' )
          if defined $name;
  
      return $tc;
  }
  
  sub any_does_type {
      my $name;
      $name = shift if @_ % 2;
      my %p = @_;
  
      my $caller = scalar caller();
      unless ( keys %p ) {
          if ( my $exists = internal_types_for_package($caller)->{$name} ) {
              return $exists;
          }
      }
  
      require Specio::Constraint::AnyDoes;
  
      my $tc = _make_tc(
          ( defined $name ? ( name => $name ) : () ),
          role => ( defined $p{role} ? $p{role} : $name ),
          type_class => 'Specio::Constraint::AnyDoes',
      );
  
      register( scalar caller(), $name, $tc, 'exportable' )
          if defined $name;
  
      return $tc;
  }
  
  sub any_isa_type {
      my $name;
      $name = shift if @_ % 2;
      my %p = @_;
  
      my $caller = scalar caller();
      unless ( keys %p ) {
          if ( my $exists = internal_types_for_package($caller)->{$name} ) {
              return $exists;
          }
      }
  
      require Specio::Constraint::AnyIsa;
  
      my $tc = _make_tc(
          ( defined $name ? ( name => $name ) : () ),
          class => ( defined $p{class} ? $p{class} : $name ),
          type_class => 'Specio::Constraint::AnyIsa',
      );
  
      register( scalar caller(), $name, $tc, 'exportable' )
          if defined $name;
  
      return $tc;
  }
  
  sub intersection {
      my $name;
      $name = shift if @_ % 2;
      my %p = @_;
  
      require Specio::Constraint::Intersection;
  
      my $tc = _make_tc(
          ( defined $name ? ( name => $name ) : () ),
          %p,
          type_class => 'Specio::Constraint::Intersection',
      );
  
      register( scalar caller(), $name, $tc, 'exportable' )
          if defined $name;
  
      return $tc;
  }
  
  sub union {
      my $name;
      $name = shift if @_ % 2;
      my %p = @_;
  
      require Specio::Constraint::Union;
  
      my $tc = _make_tc(
          ( defined $name ? ( name => $name ) : () ),
          %p,
          type_class => 'Specio::Constraint::Union',
      );
  
      register( scalar caller(), $name, $tc, 'exportable' )
          if defined $name;
  
      return $tc;
  }
  
  sub _make_tc {
      my %p = @_;
  
      my $class = delete $p{type_class} || 'Specio::Constraint::Simple';
  
      $p{constraint}        = delete $p{where}   if exists $p{where};
      $p{message_generator} = delete $p{message} if exists $p{message};
      $p{inline_generator}  = delete $p{inline}  if exists $p{inline};
  
      return $class->new(
          %p,
          declared_at => Specio::DeclaredAt->new_from_caller(2),
      );
  }
  
  sub coerce {
      my $to = shift;
      my %p  = @_;
  
      $p{coercion}         = delete $p{using}  if exists $p{using};
      $p{inline_generator} = delete $p{inline} if exists $p{inline};
  
      return $to->add_coercion(
          Specio::Coercion->new(
              to => $to,
              %p,
              declared_at => Specio::DeclaredAt->new_from_caller(1),
          )
      );
  }
  
  1;
  
  # ABSTRACT: Specio declaration subroutines
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Declare - Specio declaration subroutines
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
      package MyApp::Type::Library;
  
      use parent 'Specio::Exporter';
  
      use Specio::Declare;
      use Specio::Library::Builtins;
  
      declare(
          'Foo',
          parent => t('Str'),
          where  => sub { $_[0] =~ /foo/i },
      );
  
      declare(
          'ArrayRefOfInt',
          parent => t( 'ArrayRef', of => t('Int') ),
      );
  
      my $even = anon(
          parent => t('Int'),
          inline => sub {
              my $type      = shift;
              my $value_var = shift;
  
              return $value_var . ' % 2 == 0';
          },
      );
  
      coerce(
          t('ArrayRef'),
          from  => t('Foo'),
          using => sub { [ $_[0] ] },
      );
  
      coerce(
          $even,
          from  => t('Int'),
          using => sub { $_[0] % 2 ? $_[0] + 1 : $_[0] },
      );
  
      # Specio name is DateTime
      any_isa_type('DateTime');
  
      # Specio name is DateTimeObject
      object_isa_type( 'DateTimeObject', class => 'DateTime' );
  
      any_can_type(
          'Duck',
          methods => [ 'duck_walk', 'quack' ],
      );
  
      object_can_type(
          'DuckObject',
          methods => [ 'duck_walk', 'quack' ],
      );
  
      enum(
          'Colors',
          values => [qw( blue green red )],
      );
  
      intersection(
          'HashRefAndArrayRef',
          of => [ t('HashRef'), t('ArrayRef') ],
      );
  
      union(
          'IntOrArrayRef',
          of => [ t('Int'), t('ArrayRef') ],
      );
  
  =head1 DESCRIPTION
  
  This package exports a set of type declaration helpers. Importing this package
  also causes it to create a C<t> subroutine the caller.
  
  =head1 SUBROUTINES
  
  This module exports the following subroutines.
  
  =head2 t('name')
  
  This subroutine lets you access any types you have declared so far, as well as
  any types you imported from another type library.
  
  If you pass an unknown name, it throws an exception.
  
  =head2 declare(...)
  
  This subroutine declares a named type. The first argument is the type name,
  followed by a set of key/value parameters:
  
  =over 4
  
  =item * parent => $type
  
  The parent should be another type object. Specifically, it can be anything
  which does the L<Specio::Constraint::Role::Interface> role. The parent can be a
  named or anonymous type.
  
  =item * where => sub { ... }
  
  This is a subroutine which defines the type constraint. It will be passed a
  single argument, the value to check, and it should return true or false to
  indicate whether or not the value is valid for the type.
  
  This parameter is mutually exclusive with the C<inline> parameter.
  
  =item * inline => sub { ... }
  
  This is a subroutine that is called to generate inline code to validate the
  type. Inlining can be I<much> faster than simply providing a subroutine with
  the C<where> parameter, but is often more complicated to get right.
  
  The inline generator is called as a method on the type with one argument. This
  argument is a I<string> containing the variable name to use in the generated
  code. Typically this is something like C<'$_[0]'> or C<'$value'>.
  
  The inline generator subroutine should return a I<string> of code representing
  a single term, and it I<should not> be terminated with a semicolon. This
  allows the inlined code to be safely included in an C<if> statement, for
  example. You can use C<do { }> blocks and ternaries to get everything into one
  term. Do not assign to the variable you are testing. This single term should
  evaluate to true or false.
  
  The inline generator is expected to include code to implement both the current
  type and all its parents. Typically, the easiest way to do this is to write a
  subroutine something like this:
  
    sub {
        my $self = shift;
        my $var  = shift;
  
        return $_[0]->parent->inline_check( $_[1] )
            . ' and more checking code goes here';
    }
  
  This parameter is mutually exclusive with the C<where> parameter.
  
  =item * message_generator => sub { ... }
  
  A subroutine to generate an error message when the type check fails. The
  default message says something like "Validation failed for type named Int
  declared in package Specio::Library::Builtins
  (.../Specio/blib/lib/Specio/Library/Builtins.pm) at line 147 in sub named (eval)
  with value 1.1".
  
  You can override this to provide something more specific about the way the
  type failed.
  
  The subroutine you provide will be called as a method on the type with two
  arguments. The first is the description of the type (the bit in the message
  above that starts with "type named Int ..." and ends with "... in sub named
  (eval)". This description says what the thing is and where it was defined.
  
  The second argument is the value that failed the type check, after any
  coercions that might have been applied.
  
  =back
  
  =head2 anon(...)
  
  This subroutine declares an anonymous type. It is identical to C<declare>
  except that it expects a list of key/value parameters without a type name as
  the first parameter.
  
  =head2 coerce(...)
  
  This declares a coercion from one type to another. The first argument should
  be an object which does the L<Specio::Constraint::Role::Interface> role. This
  can be either a named or anonymous type. This type is the type that the
  coercion is I<to>.
  
  The remaining arguments are key/value parameters:
  
  =over 4
  
  =item * from => $type
  
  This must be an object which does the L<Specio::Constraint::Role::Interface>
  role. This is type that we are coercing I<from>. Again, this can be either a
  named or anonymous type.
  
  =item * using => sub { ... }
  
  This is a subroutine which defines the type coercion. It will be passed a
  single argument, the value to coerce. It should return a new value of the type
  this coercion is to.
  
  This parameter is mutually exclusive with the C<inline> parameter.
  
  =item * inline => sub { ... }
  
  This is a subroutine that is called to generate inline code to perform the
  coercion.
  
  The inline generator is called as a method on the type with one argument. This
  argument is a I<string> containing the variable name to use in the generated
  code. Typically this is something like C<'$_[0]'> or C<'$value'>.
  
  The inline generator subroutine should return a I<string> of code representing
  a single term, and it I<should not> be terminated with a semicolon. This
  allows the inlined code to be safely included in an C<if> statement, for
  example. You can use C<do { }> blocks and ternaries to get everything into one
  term. This single term should evaluate to the new value.
  
  =back
  
  =head1 DECLARATION HELPERS
  
  This module also exports some helper subs for declaring certain kinds of types:
  
  =head2 any_isa_type, object_isa_type
  
  The C<any_isa_type> helper creates a type which accepts a class name or
  object of the given class. The C<object_isa_type> helper creates a type
  which only accepts an object of the given class.
  
  These subroutines take a type name as the first argument. The remaining
  arguments are key/value pairs. Currently this is just the C<class> key, which
  should be a class name. This is the class that the type requires.
  
  The type name argument can be omitted to create an anonymous type.
  
  You can also pass just a single argument, in which case that will be used as
  both the type's name and the class for the constraint to check.
  
  =head2 any_does_type, object_does_type
  
  The C<any_does_type> helper creates a type which accepts a class name or
  object which does the given role. The C<object_does_type> helper creates a
  type which only accepts an object which does the given role.
  
  These subroutines take a type name as the first argument. The remaining
  arguments are key/value pairs. Currently this is just the C<role> key, which
  should be a role name. This is the class that the type requires.
  
  This should just work (I hope) with roles created by L<Moose>, L<Mouse>, and
  L<Moo> (using L<Role::Tiny>).
  
  The type name argument can be omitted to create an anonymous type.
  
  You can also pass just a single argument, in which case that will be used as
  both the type's name and the role for the constraint to check.
  
  =head2 any_can_type, object_can_type
  
  The C<any_can_type> helper creates a type which accepts a class name or
  object with the given methods. The C<object_can_type> helper creates a type
  which only accepts an object with the given methods.
  
  These subroutines take a type name as the first argument. The remaining
  arguments are key/value pairs. Currently this is just the C<methods> key,
  which can be either a string or array reference of strings. These strings are
  the required methods for the type.
  
  The type name argument can be omitted to create an anonymous type.
  
  =head2 enum
  
  This creates a type which accepts a string matching a given list of acceptable
  values.
  
  The first argument is the type name. The remaining arguments are key/value
  pairs. Currently this is just the C<values> key. This should an array
  reference of acceptable string values.
  
  The type name argument can be omitted to create an anonymous type.
  
  =head2 intersection
  
  This creates a type which is the intersection of two or more other types. A
  union only accepts values which match all of its underlying types.
  
  The first argument is the type name. The remaining arguments are key/value
  pairs. Currently this is just the C<of> key. This should an array
  reference of types.
  
  The type name argument can be omitted to create an anonymous type.
  
  =head2 union
  
  This creates a type which is the union of two or more other types. A union
  accepts any of its underlying types.
  
  The first argument is the type name. The remaining arguments are key/value
  pairs. Currently this is just the C<of> key. This should an array
  reference of types.
  
  The type name argument can be omitted to create an anonymous type.
  
  =head1 PARAMETERIZED TYPES
  
  You can create a parameterized type by calling C<t> with additional
  parameters, like this:
  
    my $arrayref_of_int = t( 'ArrayRef', of => t('Int') );
  
    my $arrayref_of_hashref_of_int = t(
        'ArrayRef',
        of => t(
            'HashRef',
            of => t('Int'),
        ),
    );
  
  The C<t> subroutine assumes that if it receives more than one argument, it
  should look up the named type and call C<< $type->parameterize(...) >> with
  the additional arguments.
  
  If the named type cannot be parameterized, it throws an error.
  
  You can also call C<< $type->parameterize >> directly if needed. See
  L<Specio::Constraint::Parameterizable> for details.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_DECLARE

$fatpacked{"Specio/DeclaredAt.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_DECLAREDAT';
  package Specio::DeclaredAt;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use Specio::OO;
  
  {
      my $attrs = {
          package => {
              isa      => 'Str',
              required => 1,
          },
          filename => {
              isa      => 'Str',
              required => 1,
          },
          line => {
              isa      => 'Int',
              required => 1,
          },
          subroutine => {
              isa       => 'Str',
              predicate => 'has_subroutine',
          },
      };
  
      ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
      sub _attrs {
          return $attrs;
      }
  }
  
  sub new_from_caller {
      my $class = shift;
      my $depth = shift;
  
      my %p;
      @p{qw( package filename line )} = ( caller($depth) )[ 0, 1, 2 ];
  
      my $sub = ( caller( $depth + 1 ) )[3];
      $p{subroutine} = $sub if defined $sub;
  
      return $class->new(%p);
  }
  
  sub description {
      my $self = shift;
  
      my $package  = $self->package;
      my $filename = $self->filename;
      my $line     = $self->line;
  
      my $desc = "declared in package $package ($filename) at line $line";
      if ( $self->has_subroutine ) {
          $desc .= ' in sub named ' . $self->subroutine;
      }
  
      return $desc;
  }
  
  __PACKAGE__->_ooify;
  
  1;
  
  # ABSTRACT: A class to represent where a type or coercion was declared
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::DeclaredAt - A class to represent where a type or coercion was declared
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
      my $declared = Specio::DeclaredAt->new_from_caller(1);
  
      print $declared->description;
  
  =head1 DESCRIPTION
  
  This class provides a thin wrapper around some of the return values from
  Perl's C<caller> built-in. It's used internally to identify where types and
  coercions are being declared, which is useful when generating error messages.
  
  =head1 API
  
  This class provides the following methods.
  
  =head2 Specio::DeclaredAt->new_from_caller($depth)
  
  Given a call stack depth, this method returns a new C<Specio::DeclaredAt>
  object.
  
  =head2 $declared_at->package, $declared_at->filename, $declared_at->line
  
  Returns the call stack information recorded when the object was created. These
  values are always populated.
  
  =head2 $declared_at->subroutine
  
  Returns the subroutine from the call stack. This may be an C<udnef>
  
  =head2 $declared_at->has_subroutine
  
  Returns true if there is a subroutine name associated with this object.
  
  =head2 $declared_at->description
  
  Puts all the information together into a single string like "declared in
  package Foo::Bar (.../Foo/Bar.pm) at line 42 in sub named blah".
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_DECLAREDAT

$fatpacked{"Specio/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_EXCEPTION';
  package Specio::Exception;
  
  use strict;
  use warnings;
  
  use overload
      q{""}    => 'as_string',
      fallback => 1;
  
  our $VERSION = '0.42';
  
  use Devel::StackTrace;
  use Scalar::Util qw( blessed );
  use Specio::OO;
  
  {
      my $attrs = {
          message => {
              isa      => 'Str',
              required => 1,
          },
          type => {
              does     => 'Specio::Constraint::Role::Interface',
              required => 1,
          },
          value => {
              required => 1,
          },
          stack_trace => {
              init_arg => undef,
          },
      };
  
      ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
      sub _attrs {
          return $attrs;
      }
  }
  
  sub BUILD {
      my $self = shift;
  
      $self->{stack_trace}
          = Devel::StackTrace->new( ignore_package => __PACKAGE__ );
  
      return;
  }
  
  sub as_string {
      my $self = shift;
  
      my $str = $self->message;
      $str .= "\n\n" . $self->stack_trace->as_string;
  
      return $str;
  }
  
  sub throw {
      my $self = shift;
  
      die $self if blessed $self;
  
      die $self->new(@_);
  }
  
  __PACKAGE__->_ooify;
  
  1;
  
  # ABSTRACT: An exception class for type constraint failures
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Exception - An exception class for type constraint failures
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
    use Try::Tiny;
  
    try {
        $type->validate_or_die($value);
    }
    catch {
        if ( $_->isa('Specio::Exception') ) {
            print $_->message, "\n";
            print $_->type->name, "\n";
            print $_->value, "\n";
        }
    };
  
  =head1 DESCRIPTION
  
  This exception class is thrown by Specio when a type check fails. It emulates
  the L<Throwable::Error> API, but doesn't use that module to avoid adding a
  dependency on L<Moo>.
  
  =for Pod::Coverage BUILD throw
  
  =head1 API
  
  This class provides the following methods:
  
  =head2 $exception->message
  
  The error message associated with the exception.
  
  =head2 $exception->stack_trace
  
  A L<Devel::StackTrace> object for the exception.
  
  =head2 $exception->type
  
  The type constraint object against which the value failed.
  
  =head2 $exception->value
  
  The value that failed the type check.
  
  =head2 $exception->as_string
  
  The exception as a string. This includes the method and the stack trace.
  
  =head1 OVERLOADING
  
  This class overloads stringification to call the C<as_string> method.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_EXCEPTION

$fatpacked{"Specio/Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_EXPORTER';
  package Specio::Exporter;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use parent 'Exporter';
  
  use Specio::Helpers qw( install_t_sub );
  use Specio::Registry
      qw( exportable_types_for_package internal_types_for_package register );
  
  my %Exported;
  
  sub import {
      my $package  = shift;
      my $reexport = shift;
  
      my $caller = caller();
  
      return if $Exported{$caller}{$package};
  
      my $exported = exportable_types_for_package($package);
  
      while ( my ( $name, $type ) = each %{$exported} ) {
          register( $caller, $name, $type->clone, $reexport );
      }
  
      install_t_sub(
          $caller,
          internal_types_for_package($caller),
      );
  
      if ( $package->can('_also_export') ) {
          for my $sub ( $package->_also_export ) {
              ## no critic (TestingAndDebugging::ProhibitNoStrict)
              no strict 'refs';
              *{ $caller . '::' . $sub } = \&{ $package . '::' . $sub };
          }
      }
  
      $Exported{$caller}{$package} = 1;
  
      return;
  }
  
  1;
  
  # ABSTRACT: Base class for type libraries
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Exporter - Base class for type libraries
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
      package MyApp::Type::Library;
  
      use parent 'Specio::Exporter';
  
      use Specio::Declare;
  
      declare( ... );
  
      # more types here
  
      package MyApp::Foo;
  
      use MyApp::Type::Library
  
  =head1 DESCRIPTION
  
  Inheriting from this package makes your package a type exporter. By default,
  types defined in a package are never visible outside of the package. When you
  inherit from this package, all the types you define internally become
  available via exports.
  
  The exported types are available through the importing package's C<t>
  subroutine.
  
  By default, types your package imports are not re-exported:
  
    package MyApp::Type::Library;
  
    use parent 'Specio::Exporter';
  
    use Specio::Declare;
    use Specio::Library::Builtins;
  
  In this case, the types provided by L<Specio::Library::Builtins> are not
  exported to packages which C<use MyApp::Type::Library>.
  
  You can explicitly ask for types to be re-exported:
  
    package MyApp::Type::Library;
  
    use parent 'Specio::Exporter';
  
    use Specio::Declare;
    use Specio::Library::Builtins -reexport;
  
  In this case, packages which C<use MyApp::Type::Library> will get all the
  types from L<Specio::Library::Builtins> as well as any types defined in
  C<MyApp::Type::Library>.
  
  =head1 ADDITIONAL EXPORTS
  
  If you want to export some additional subroutines from a package which has
  C<Specio::Exporter> as its parent, define a sub named C<_also_export>. This
  sub should return a I<list> of subroutines defined in your package that should
  also be exported. These subs will be exported unconditionally to any package
  that uses your package.
  
  =head1 COMBINING LIBRARIES WITH L<Specio::Subs>
  
  You can combine loading libraries with subroutine generation using
  L<Specio::Subs> by using C<_also_export> and
  C<Specio::Subs::subs_installed_into>:
  
      package My::Library;
  
      use My::Library::Internal -reexport;
      use Specio::Library::Builtins -reexport;
      use Specio::Subs qw( My::Library::Internal Specio::Library::Builtins );
  
      sub _also_export {
          return Specio::Subs::subs_installed_into(__PACKAGE__);
      }
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_EXPORTER

$fatpacked{"Specio/Helpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_HELPERS';
  package Specio::Helpers;
  
  use strict;
  use warnings;
  
  use Carp qw( croak );
  use Exporter 'import';
  use overload ();
  
  our $VERSION = '0.42';
  
  use Scalar::Util qw( blessed );
  
  our @EXPORT_OK = qw( install_t_sub is_class_loaded _STRINGLIKE );
  
  sub install_t_sub {
  
      # Specio::DeclaredAt use Specio::OO, which in turn uses
      # Specio::Helpers. If we load this with "use" we get a cirular require and
      # a big mess.
      require Specio::DeclaredAt;
  
      my $caller = shift;
      my $types  = shift;
  
      # XXX - check to see if their t() is something else entirely?
      return if $caller->can('t');
  
      my $t = sub {
          my $name = shift;
  
          croak 'The t subroutine requires a single non-empty string argument'
              unless _STRINGLIKE($name);
  
          croak "There is no type named $name available for the $caller package"
              unless exists $types->{$name};
  
          my $found = $types->{$name};
  
          return $found unless @_;
  
          my %p = @_;
  
          croak 'Cannot parameterize a non-parameterizable type'
              unless $found->can('parameterize');
  
          return $found->parameterize(
              declared_at => Specio::DeclaredAt->new_from_caller(1),
              %p,
          );
      };
  
      {
          ## no critic (TestingAndDebugging::ProhibitNoStrict)
          no strict 'refs';
          no warnings 'redefine';
          *{ $caller . '::t' } = $t;
      }
  
      return;
  }
  
  ## no critic (Subroutines::ProhibitSubroutinePrototypes, Subroutines::ProhibitExplicitReturnUndef)
  sub _STRINGLIKE ($) {
      return $_[0] if _STRING( $_[0] );
  
      return $_[0]
          if blessed $_[0]
          && overload::Method( $_[0], q{""} )
          && length "$_[0]";
  
      return undef;
  }
  
  # Borrowed from Params::Util
  sub _STRING ($) {
      return defined $_[0] && !ref $_[0] && length( $_[0] ) ? $_[0] : undef;
  }
  
  # Borrowed from Types::Standard
  sub is_class_loaded {
      my $stash = do {
          ## no critic (TestingAndDebugging::ProhibitNoStrict)
          no strict 'refs';
          \%{ $_[0] . '::' };
      };
  
      return 1 if exists $stash->{ISA};
      return 1 if exists $stash->{VERSION};
  
      foreach my $globref ( values %{$stash} ) {
          return 1
              if ref \$globref eq 'GLOB'
              ? *{$globref}{CODE}
              : ref $globref;    # const or sub ref
      }
  
      return 0;
  }
  
  1;
  
  # ABSTRACT: Helper subs for the Specio distro
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Helpers - Helper subs for the Specio distro
  
  =head1 VERSION
  
  version 0.42
  
  =head1 DESCRIPTION
  
  There's nothing public here.
  
  =for Pod::Coverage .*
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_HELPERS

$fatpacked{"Specio/Library/Builtins.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_LIBRARY_BUILTINS';
  package Specio::Library::Builtins;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use parent 'Specio::Exporter';
  
  use List::Util 1.33 ();
  use overload     ();
  use re           ();
  use Scalar::Util ();
  use Specio::Constraint::Parameterizable;
  use Specio::Declare;
  use Specio::Helpers ();
  
  BEGIN {
      local $@ = undef;
      my $has_ref_util
          = eval { require Ref::Util; Ref::Util->VERSION('0.112'); 1 };
      sub _HAS_REF_UTIL () {$has_ref_util}
  }
  
  declare(
      'Item',
      inline => sub {'1'}
  );
  
  declare(
      'Undef',
      parent => t('Item'),
      inline => sub {
          '!defined(' . $_[1] . ')';
      }
  );
  
  declare(
      'Defined',
      parent => t('Item'),
      inline => sub {
          'defined(' . $_[1] . ')';
      }
  );
  
  declare(
      'Bool',
      parent => t('Item'),
      inline => sub {
          return sprintf( <<'EOF', ( $_[1] ) x 7 );
  (
      (
          !ref( %s )
          && (
                 !defined( %s )
                 || %s eq q{}
                 || %s eq '1'
                 || %s eq '0'
             )
      )
      ||
      (
          Scalar::Util::blessed( %s )
          && defined overload::Method( %s, 'bool' )
      )
  )
  EOF
      }
  );
  
  declare(
      'Value',
      parent => t('Defined'),
      inline => sub {
          $_[0]->parent->inline_check( $_[1] ) . ' && !ref(' . $_[1] . ')';
      }
  );
  
  declare(
      'Ref',
      parent => t('Defined'),
  
      # no need to call parent - ref also checks for definedness
      inline => sub { 'ref(' . $_[1] . ')' }
  );
  
  declare(
      'Str',
      parent => t('Value'),
      inline => sub {
          return sprintf( <<'EOF', ( $_[1] ) x 6 );
  (
      (
          defined( %s )
          && !ref( %s )
          && (
                 ( ref( \%s ) eq 'SCALAR' )
                 || do { ( ref( \( my $val = %s ) ) eq 'SCALAR' ) }
             )
      )
      ||
      (
          Scalar::Util::blessed( %s )
          && defined overload::Method( %s, q{""} )
      )
  )
  EOF
      }
  );
  
  my $value_type = t('Value');
  declare(
      'Num',
      parent => t('Str'),
      inline => sub {
          return sprintf( <<'EOF', ( $_[1] ) x 5 );
  (
      (
          defined( %s )
          && !ref( %s )
          && (
                 do {
                     ( my $val = %s ) =~
                         /\A
                          -?[0-9]+(?:\.[0-9]+)?
                          (?:[Ee][\-+]?[0-9]+)?
                          \z/x
                 }
             )
      )
      ||
      (
          Scalar::Util::blessed( %s )
          && defined overload::Method( %s, '0+' )
      )
  )
  EOF
      }
  );
  
  declare(
      'Int',
      parent => t('Num'),
      inline => sub {
          return sprintf( <<'EOF', ( $_[1] ) x 6 )
  (
      (
          defined( %s )
          && !ref( %s )
          && (
                 do { ( my $val1 = %s ) =~ /\A-?[0-9]+(?:[Ee]\+?[0-9]+)?\z/ }
             )
      )
      ||
      (
          Scalar::Util::blessed( %s )
          && defined overload::Method( %s, '0+' )
          && do { ( my $val2 = %s + 0 ) =~ /\A-?[0-9]+(?:[Ee]\+?[0-9]+)?\z/ }
      )
  )
  EOF
      }
  );
  
  {
      my $ref_check
          = _HAS_REF_UTIL
          ? 'Ref::Util::is_plain_coderef(%s)'
          : q{ref(%s) eq 'CODE'};
  
      declare(
          'CodeRef',
          parent => t('Ref'),
          inline => sub {
              return sprintf( <<"EOF", ( $_[1] ) x 3 );
  (
      $ref_check
      ||
      (
          Scalar::Util::blessed( %s )
          && defined overload::Method( %s, '&{}' )
      )
  )
  EOF
          }
      );
  }
  
  {
      # This is a 5.8 back-compat shim stolen from Type::Tiny's Devel::Perl58Compat
      # module.
      unless ( exists &re::is_regexp || _HAS_REF_UTIL ) {
          require B;
          *re::is_regexp = sub {
              ## no critic (ErrorHandling::RequireCheckingReturnValueOfEval)
              eval { B::svref_2object( $_[0] )->MAGIC->TYPE eq 'r' };
          };
      }
  
      my $ref_check
          = _HAS_REF_UTIL
          ? 'Ref::Util::is_regexpref(%s)'
          : 're::is_regexp(%s)';
  
      declare(
          'RegexpRef',
          parent => t('Ref'),
          inline => sub {
              return sprintf( <<"EOF", ( $_[1] ) x 3 );
  (
      $ref_check
      ||
      (
          Scalar::Util::blessed( %s )
          && defined overload::Method( %s, 'qr' )
      )
  )
  EOF
          },
      );
  }
  
  {
      my $ref_check
          = _HAS_REF_UTIL
          ? 'Ref::Util::is_plain_globref(%s)'
          : q{ref( %s ) eq 'GLOB'};
  
      declare(
          'GlobRef',
          parent => t('Ref'),
          inline => sub {
              return sprintf( <<"EOF", ( $_[1] ) x 3 );
  (
      $ref_check
      ||
      (
          Scalar::Util::blessed( %s )
          && defined overload::Method( %s, '*{}' )
      )
  )
  EOF
          }
      );
  }
  
  {
      my $ref_check
          = _HAS_REF_UTIL
          ? 'Ref::Util::is_plain_globref(%s)'
          : q{ref( %s ) eq 'GLOB'};
  
      # NOTE: scalar filehandles are GLOB refs, but a GLOB ref is not always a
      # filehandle
      declare(
          'FileHandle',
          parent => t('Ref'),
          inline => sub {
              return sprintf( <<"EOF", ( $_[1] ) x 6 );
  (
      (
          $ref_check
          && Scalar::Util::openhandle( %s )
      )
      ||
      (
          Scalar::Util::blessed( %s )
          &&
          (
              %s->isa('IO::Handle')
              ||
              (
                  defined overload::Method( %s, '*{}' )
                  && Scalar::Util::openhandle( *{ %s } )
              )
          )
      )
  )
  EOF
          }
      );
  }
  
  {
      my $ref_check
          = _HAS_REF_UTIL
          ? 'Ref::Util::is_blessed_ref(%s)'
          : 'Scalar::Util::blessed(%s)';
  
      declare(
          'Object',
          parent => t('Ref'),
          inline => sub { sprintf( $ref_check, $_[1] ) },
      );
  }
  
  declare(
      'ClassName',
      parent => t('Str'),
      inline => sub {
          return
              sprintf(
              <<'EOF', $_[0]->parent->inline_check( $_[1] ), ( $_[1] ) x 2 )
  (
      ( %s )
      && length "%s"
      && Specio::Helpers::is_class_loaded( "%s" )
  )
  EOF
      },
  );
  
  {
      my $ref_check
          = _HAS_REF_UTIL
          ? 'Ref::Util::is_plain_scalarref(%s) || Ref::Util::is_plain_refref(%s)'
          : q{ref( %s ) eq 'SCALAR' || ref( %s ) eq 'REF'};
  
      my $base_scalarref_check = sub {
          return sprintf( <<"EOF", ( $_[0] ) x 4 );
  (
      (
          $ref_check
      )
      ||
      (
          Scalar::Util::blessed( %s )
          && defined overload::Method( %s, '\${}' )
      )
  )
  EOF
      };
  
      declare(
          'ScalarRef',
          type_class => 'Specio::Constraint::Parameterizable',
          parent     => t('Ref'),
          inline     => sub { $base_scalarref_check->( $_[1] ) },
          parameterized_inline_generator => sub {
              my $self      = shift;
              my $parameter = shift;
              my $val       = shift;
  
              return sprintf(
                  '( ( %s ) && ( %s ) )',
                  $base_scalarref_check->($val),
                  $parameter->inline_check( '${' . $val . '}' ),
              );
          }
      );
  }
  
  {
      my $ref_check
          = _HAS_REF_UTIL
          ? 'Ref::Util::is_plain_arrayref(%s)'
          : q{ref( %s ) eq 'ARRAY'};
  
      my $base_arrayref_check = sub {
          return sprintf( <<"EOF", ( $_[0] ) x 3 );
  (
      $ref_check
      ||
      (
          Scalar::Util::blessed( %s )
          && defined overload::Method( %s, '\@{}' )
      )
  )
  EOF
      };
  
      declare(
          'ArrayRef',
          type_class => 'Specio::Constraint::Parameterizable',
          parent     => t('Ref'),
          inline     => sub { $base_arrayref_check->( $_[1] ) },
          parameterized_inline_generator => sub {
              my $self      = shift;
              my $parameter = shift;
              my $val       = shift;
  
              return sprintf(
                  '( ( %s ) && ( List::Util::all { %s } @{ %s } ) )',
                  $base_arrayref_check->($val),
                  $parameter->inline_check('$_'),
                  $val,
              );
          }
      );
  }
  
  {
      my $ref_check
          = _HAS_REF_UTIL
          ? 'Ref::Util::is_plain_hashref(%s)'
          : q{ref( %s ) eq 'HASH'};
  
      my $base_hashref_check = sub {
          return sprintf( <<"EOF", ( $_[0] ) x 3 );
  (
      $ref_check
      ||
      (
          Scalar::Util::blessed( %s )
          && defined overload::Method( %s, '%%{}' )
      )
  )
  EOF
      };
  
      declare(
          'HashRef',
          type_class => 'Specio::Constraint::Parameterizable',
          parent     => t('Ref'),
          inline     => sub { $base_hashref_check->( $_[1] ) },
          parameterized_inline_generator => sub {
              my $self      = shift;
              my $parameter = shift;
              my $val       = shift;
  
              return sprintf(
                  '( ( %s ) && ( List::Util::all { %s } values %%{ %s } ) )',
                  $base_hashref_check->($val),
                  $parameter->inline_check('$_'),
                  $val,
              );
          }
      );
  }
  
  declare(
      'Maybe',
      type_class                     => 'Specio::Constraint::Parameterizable',
      parent                         => t('Item'),
      inline                         => sub {'1'},
      parameterized_inline_generator => sub {
          my $self      = shift;
          my $parameter = shift;
          my $val       = shift;
  
          return sprintf( <<'EOF', $val, $parameter->inline_check($val) )
  ( !defined( %s ) || ( %s ) )
  EOF
      },
  );
  
  1;
  
  # ABSTRACT: Implements type constraint objects for Perl's built-in types
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Library::Builtins - Implements type constraint objects for Perl's built-in types
  
  =head1 VERSION
  
  version 0.42
  
  =head1 DESCRIPTION
  
  This library provides a set of types parallel to those provided by Moose.
  
  The types are in the following hierarchy
  
    Item
        Bool
        Maybe (of `a)
        Undef
        Defined
            Value
                Str
                    Num
                        Int
                    ClassName
            Ref
                ScalarRef (of `a)
                ArrayRef (of `a)
                HashRef (of `a)
                CodeRef
                RegexpRef
                GlobRef
                FileHandle
                Object
  
  =head2 Item
  
  Accepts any value
  
  =head2 Bool
  
  Accepts a non-reference that is C<undef>, an empty string, C<0>, or C<1>. It
  also accepts any object which overloads boolification.
  
  =head2 Maybe (of `a)
  
  A parameterizable type which accepts C<undef> or the type C<`a>. If not
  parameterized this type will accept any value.
  
  =head2 Undef
  
  Only accepts C<undef>.
  
  =head2 Value
  
  Accepts any non-reference value.
  
  =head2 Str
  
  Accepts any non-reference value or an object which overloads stringification.
  
  =head2 Num
  
  Accepts nearly the same values as C<Scalar::Util::looks_like_number>, but does
  not accept numbers with leading or trailing spaces, infinities, or NaN. Also
  accepts an object which overloads numification.
  
  =head2 Int
  
  Accepts any integer value, or an object which overloads numification and
  numifies to an integer.
  
  =head2 ClassName
  
  Accepts any value which passes C<Str> where the string is a loaded package.
  
  =head2 Ref
  
  Accepts any reference.
  
  =head2 ScalarRef (of `a)
  
  Accepts a scalar reference or an object which overloads scalar
  dereferencing. If parameterized, the dereferenced value must be of type C<`a>.
  
  =head2 ArrayRef (of `a)
  
  Accepts a array reference or an object which overloads array dereferencing. If
  parameterized, the values in the arrayref must be of type C<`a>.
  
  =head2 HashRef (of `a)
  
  Accepts a hash reference or an object which overloads hash dereferencing. If
  parameterized, the values in the hashref must be of type C<`a>.
  
  =head2 CodeRef
  
  Accepts a code (sub) reference or an object which overloads code
  dereferencing.
  
  =head2 RegexpRef
  
  Accepts a regex object created by C<qr//> or an object which overloads
  regex interpolation.
  
  =head2 GlobRef
  
  Accepts a glob reference or an object which overloads glob dereferencing.
  
  =head2 FileHandle
  
  Accepts a glob reference which is an open file handle, any C<IO::Handle>
  Object or subclass, or an object which overloads glob dereferencing and
  returns a glob reference which is an open file handle.
  
  =head2 Object
  
  Accepts any blessed object.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_LIBRARY_BUILTINS

$fatpacked{"Specio/Library/Numeric.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_LIBRARY_NUMERIC';
  package Specio::Library::Numeric;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use parent 'Specio::Exporter';
  
  use Specio::Declare;
  use Specio::Library::Builtins;
  
  declare(
      'PositiveNum',
      parent => t('Num'),
      inline => sub {
          return
              sprintf( <<'EOF', $_[0]->parent->inline_check( $_[1] ), $_[1] );
  (
      %s
      &&
      %s > 0
  )
  EOF
      },
  );
  
  declare(
      'PositiveOrZeroNum',
      parent => t('Num'),
      inline => sub {
          return
              sprintf( <<'EOF', $_[0]->parent->inline_check( $_[1] ), $_[1] );
  (
      %s
      &&
      %s >= 0
  )
  EOF
      },
  );
  
  declare(
      'PositiveInt',
      parent => t('Int'),
      inline => sub {
          return
              sprintf( <<'EOF', $_[0]->parent->inline_check( $_[1] ), $_[1] );
  (
      %s
      &&
      %s > 0
  )
  EOF
      },
  );
  
  declare(
      'PositiveOrZeroInt',
      parent => t('Int'),
      inline => sub {
          return
              sprintf( <<'EOF', $_[0]->parent->inline_check( $_[1] ), $_[1] );
  (
      %s
      &&
      %s >= 0
  )
  EOF
      },
  );
  
  declare(
      'NegativeNum',
      parent => t('Num'),
      inline => sub {
          return
              sprintf( <<'EOF', $_[0]->parent->inline_check( $_[1] ), $_[1] );
  (
      %s
      &&
      %s < 0
  )
  EOF
      },
  );
  
  declare(
      'NegativeOrZeroNum',
      parent => t('Num'),
      inline => sub {
          return
              sprintf( <<'EOF', $_[0]->parent->inline_check( $_[1] ), $_[1] );
  (
      %s
      &&
      %s <= 0
  )
  EOF
      },
  );
  
  declare(
      'NegativeInt',
      parent => t('Int'),
      inline => sub {
          return
              sprintf( <<'EOF', $_[0]->parent->inline_check( $_[1] ), $_[1] );
  (
      %s
      &&
      %s < 0
  )
  EOF
      },
  );
  
  declare(
      'NegativeOrZeroInt',
      parent => t('Int'),
      inline => sub {
          return
              sprintf( <<'EOF', $_[0]->parent->inline_check( $_[1] ), $_[1] );
  (
      %s
      &&
      %s <= 0
  )
  EOF
      },
  );
  
  declare(
      'SingleDigit',
      parent => t('Int'),
      inline => sub {
          return
              sprintf(
              <<'EOF', $_[0]->parent->inline_check( $_[1] ), ( $_[1] ) x 2 );
  (
      %s
      &&
      %s >= -9
      &&
      %s <= 9
  )
  EOF
      },
  );
  
  1;
  
  # ABSTRACT: Implements type constraint objects for some common numeric types
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Library::Numeric - Implements type constraint objects for some common numeric types
  
  =head1 VERSION
  
  version 0.42
  
  =head1 DESCRIPTION
  
  This library provides some additional string numeric for common cases.
  
  =head2 PositiveNum
  
  =head2 PositiveOrZeroNum
  
  =head2 PositiveInt
  
  =head2 PositiveOrZeroInt
  
  =head2 NegativeNum
  
  =head2 NegativeOrZeroNum
  
  =head2 NegativeInt
  
  =head2 NegativeOrZeroInt
  
  =head2 SingleDigit
  
  A single digit from -9 to 9.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_LIBRARY_NUMERIC

$fatpacked{"Specio/Library/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_LIBRARY_PERL';
  package Specio::Library::Perl;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use parent 'Specio::Exporter';
  
  use Specio::Library::String;
  use version 0.83 ();
  
  use Specio::Declare;
  
  my $package_inline = sub {
      return sprintf( <<'EOF', $_[0]->parent->inline_check( $_[1] ), $_[1] );
  (
      %s
      &&
      %s =~ /\A[^\W\d]\w*(?:::\w+)*\z/
  )
  EOF
  };
  
  declare(
      'PackageName',
      parent => t('NonEmptyStr'),
      inline => $package_inline,
  );
  
  declare(
      'ModuleName',
      parent => t('NonEmptyStr'),
      inline => $package_inline,
  );
  
  declare(
      'DistName',
      parent => t('NonEmptyStr'),
      inline => sub {
          return
              sprintf( <<'EOF', $_[0]->parent->inline_check( $_[1] ), $_[1] );
  (
      %s
      &&
      %s =~ /\A[^\W\d]\w*(?:-\w+)*\z/
  )
  EOF
      },
  );
  
  declare(
      'Identifier',
      parent => t('NonEmptyStr'),
      inline => sub {
          return
              sprintf( <<'EOF', $_[0]->parent->inline_check( $_[1] ), $_[1] );
  (
      %s
      &&
      %s =~ /\A[^\W\d]\w*\z/
  )
  EOF
      },
  );
  
  declare(
      'SafeIdentifier',
      parent => t('Identifier'),
      inline => sub {
          return
              sprintf( <<'EOF', $_[0]->parent->inline_check( $_[1] ), $_[1] );
  (
      %s
      &&
      %s !~ /\A[_ab]\z/
  )
  EOF
      },
  );
  
  declare(
      'LaxVersionStr',
      parent => t('NonEmptyStr'),
      inline => sub {
          return
              sprintf( <<'EOF', $_[0]->parent->inline_check( $_[1] ), $_[1] );
  (
      %s
      &&
      version::is_lax(%s)
  )
  EOF
      },
  );
  
  declare(
      'StrictVersionStr',
      parent => t('NonEmptyStr'),
      inline => sub {
          return
              sprintf( <<'EOF', $_[0]->parent->inline_check( $_[1] ), $_[1] );
  (
      %s
      &&
      version::is_strict(%s)
  )
  EOF
      },
  );
  
  1;
  
  # ABSTRACT: Implements type constraint objects for some common Perl language things
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Library::Perl - Implements type constraint objects for some common Perl language things
  
  =head1 VERSION
  
  version 0.42
  
  =head1 DESCRIPTION
  
  This library provides some additional string types for common cases.
  
  =head2 PackageName
  
  A valid package name. Unlike the C<ClassName> constraint from the
  L<Specio::Library::Builtins> library, this package does not need to be loaded.
  
  This type does allow Unicode characters.
  
  =head2 ModuleName
  
  Same as C<PackageName>.
  
  =head2 DistName
  
  A valid distribution name like C<DBD-Pg> Basically this is the same as a
  package name with the double-colons replaced by dashes. Note that there are
  some historical distribution names that don't fit this pattern, like
  C<CGI.pm>.
  
  This type does allow Unicode characters.
  
  =head2 Identifier
  
  An L<Identifier|perldata/Variable names> is something that could be used as a
  symbol name or other identifier (filehandle, directory handle, subroutine
  name, format name, or label). It's what you put after the sigil (dollar sign,
  at sign, percent sign) in a variable name. Generally, it's a bunch of
  word characters not starting with a digit.
  
  This type does allow Unicode characters.
  
  =head2 SafeIdentifier
  
  This is just like an C<Identifier> but it excludes the single-character
  variables underscore (C<_>), C<a>< and C<b>, as these are special variables to
  the Perl interpreter.
  
  =head2 LaxVersionStr and StrictVersionStr
  
  Lax and strict version strings use the L<is_lax|version/is_lax> and
  L<is_strict|version/is_strict> methods from C<version> to check if the given
  string would be a valid lax or strict version. L<version::Internals> covers
  the details but basically: lax versions are everything you may do, and strict
  omit many of the usages best avoided.
  
  =head2 CREDITS
  
  Much of the code and docs for this library comes from MooseX::Types::Perl,
  written by Ricardo SIGNES <rjbs@cpan.org>.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_LIBRARY_PERL

$fatpacked{"Specio/Library/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_LIBRARY_STRING';
  package Specio::Library::String;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use parent 'Specio::Exporter';
  
  use Specio::Declare;
  use Specio::Library::Builtins;
  
  declare(
      'NonEmptySimpleStr',
      parent => t('Str'),
      inline => sub {
          return
              sprintf(
              <<'EOF', $_[0]->parent->inline_check( $_[1] ), ( $_[1] ) x 3 );
  (
      %s
      &&
      length %s > 0
      &&
      length %s <= 255
      &&
      %s !~ /[\n\r\x{2028}\x{2029}]/
  )
  EOF
      },
  );
  
  declare(
      'NonEmptyStr',
      parent => t('Str'),
      inline => sub {
          return
              sprintf( <<'EOF', $_[0]->parent->inline_check( $_[1] ), $_[1] );
  (
      %s
      &&
      length %s
  )
  EOF
      },
  );
  
  declare(
      'SimpleStr',
      parent => t('Str'),
      inline => sub {
          return
              sprintf(
              <<'EOF', $_[0]->parent->inline_check( $_[1] ), ( $_[1] ) x 2 );
  (
      %s
      &&
      length %s <= 255
      &&
      %s !~ /[\n\r\x{2028}\x{2029}]/
  )
  EOF
      },
  );
  
  1;
  
  # ABSTRACT: Implements type constraint objects for some common string types
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Library::String - Implements type constraint objects for some common string types
  
  =head1 VERSION
  
  version 0.42
  
  =head1 DESCRIPTION
  
  This library provides some additional string types for common cases.
  
  =head2 NonEmptyStr
  
  A string which has at least one character.
  
  =head2 SimpleStr
  
  A string that is 255 characters or less with no vertical whitespace
  characters.
  
  =head2 NonEmptySimpleStr
  
  A non-empty string that is 255 characters or less with no vertical whitespace
  characters.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_LIBRARY_STRING

$fatpacked{"Specio/Library/Structured.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_LIBRARY_STRUCTURED';
  package Specio::Library::Structured;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use parent 'Specio::Exporter';
  
  use B ();
  use Carp qw( confess );
  use List::Util ();
  use Scalar::Util qw( blessed );
  use Specio::Constraint::Structurable;
  use Specio::Declare;
  use Specio::Library::Builtins;
  use Specio::Library::Structured::Dict;
  use Specio::Library::Structured::Map;
  use Specio::Library::Structured::Tuple;
  use Specio::TypeChecks qw( does_role );
  
  ## no critic (Variables::ProtectPrivateVars)
  declare(
      'Dict',
      type_class => 'Specio::Constraint::Structurable',
      parent     => Specio::Library::Structured::Dict->parent,
      inline     => \&Specio::Library::Structured::Dict::_inline,
      parameterization_args_builder =>
          \&Specio::Library::Structured::Dict::_parameterization_args_builder,
      name_builder => \&Specio::Library::Structured::Dict::_name_builder,
      structured_inline_generator =>
          \&Specio::Library::Structured::Dict::_structured_inline_generator,
  );
  
  declare(
      'Map',
      type_class => 'Specio::Constraint::Structurable',
      parent     => Specio::Library::Structured::Map->parent,
      inline     => \&Specio::Library::Structured::Map::_inline,
      parameterization_args_builder =>
          \&Specio::Library::Structured::Map::_parameterization_args_builder,
      name_builder => \&Specio::Library::Structured::Map::_name_builder,
      structured_inline_generator =>
          \&Specio::Library::Structured::Map::_structured_inline_generator,
  );
  
  declare(
      'Tuple',
      type_class => 'Specio::Constraint::Structurable',
      parent     => Specio::Library::Structured::Tuple->parent,
      inline     => \&Specio::Library::Structured::Tuple::_inline,
      parameterization_args_builder =>
          \&Specio::Library::Structured::Tuple::_parameterization_args_builder,
      name_builder => \&Specio::Library::Structured::Tuple::_name_builder,
      structured_inline_generator =>
          \&Specio::Library::Structured::Tuple::_structured_inline_generator,
  );
  ## use critic
  
  sub optional {
      return { optional => shift };
  }
  
  sub slurpy {
      return { slurpy => shift };
  }
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _also_export {qw( optional slurpy )}
  ## use critic
  
  1;
  
  # ABSTRACT: Structured types for Specio (Dict, Map, Tuple)
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Library::Structured - Structured types for Specio (Dict, Map, Tuple)
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
      use Specio::Library::Builtins;
      use Specio::Library::String;
      use Specio::Library::Structured;
  
      my $map = t(
          'Map',
          of => {
              key   => t('NonEmptyStr'),
              value => t('Int'),
          },
      );
      my $tuple = t(
          'Tuple',
          of => [ t('Str'), t('Num') ],
      );
      my $dict = t(
          'Dict',
          of => {
              kv => {
                  name => t('Str'),
                  age  => t('Int'),
              },
          },
      );
  
  =head1 DESCRIPTION
  
  B<This particular library should be considered in an alpha state. The syntax
  for defining structured types may change, as well as some of the internals of
  its implementation.>
  
  This library provides a set of structured types for Specio, C<Dict>, C<Map>,
  and C<Tuple>. This library also exports two helper subs used for some types,
  C<optional> and C<slurpy>.
  
  All structured types are parameterized by calling C<< t( 'Type Name', of =>
  ... ) >>. The arguments passed after C<of> vary for each type.
  
  =head2 Dict
  
  A C<Dict> is a hashref with a well-defined set of keys and types for those
  key.
  
  The argument passed to C<of> should be a single hashref. That hashref must
  contain a C<kv> key defining the expected keys and the types for their
  values. This C<kv> value is itself a hashref. If a key/value pair is optional,
  use C<optional> around the I<type> for that key:
  
      my $person = t(
          'Dict',
          of => {
              kv => {
                  first  => t('NonEmptyStr'),
                  middle => optional( t('NonEmptyStr') ),
                  last   => t('NonEmptyStr'),
              },
          },
      );
  
  If a key is optional, then it can be omitted entirely, but if it passed then
  it's type will be checked, so it cannot just be set to C<undef>.
  
  You can also pass a C<slurpy> key. If this is passed, then the C<Dict> will
  allow other, unknown keys, as long as they match the specified type:
  
      my $person = t(
          'Dict',
          of => {
              kv => {
                  first  => t('NonEmptyStr'),
                  middle => optional( t('NonEmptyStr') ),
                  last   => t('NonEmptyStr'),
              },
              slurpy => t('Int'),
          },
      );
  
  =head2 Map
  
  A C<Map> is a hashref with specified types for its keys and values, but no
  well-defined key names.
  
  The argument passed to C<of> should be a single hashref with two keys, C<key>
  and C<value>. The type for the C<key> will typically be some sort of key, but
  if you're using a tied hash or an object with hash overloading it could
  conceivably be any sort of value.
  
  =head2 Tuple
  
  A C<Tuple> is an arrayref with a fixed set of members in a specific order.
  
  The argument passed to C<of> should be a single arrayref consisting of
  types. You can mark a slot in the C<Tuple> as optional by wrapping the type in
  a call to C<optional>:
  
      my $record = t(
          'Tuple',
          of => [
              t('PositiveInt'),
              t('Str'),
              optional( t('Num') ),
              optional( t('Num') ),
          ],
      );
  
  You can have as many C<optional> elements as you want, but they must always
  come in sequence at the end of the tuple definition. You cannot interleave
  required and optional elements.
  
  You can also make the Tuple accept an arbitrary number of values by wrapping
  the last type in a call to C<slurpy>:
  
      my $record = t(
          'Tuple',
          of => [
              t('PositiveInt'),
              t('Str'),
              slurpy( t('Num') ),
          ],
      );
  
  In this case, the C<Tuple> will require the first two elements and then allow
  any number (including zero) of C<Num> elements.
  
  You cannot mix C<optional> and C<slurpy> in a C<Tuple> definition.
  
  =for Pod::Coverage optional slurpy
  
  =head1 LIMITATIONS
  
  Currently all structured types require that the types they are structured with
  can be inlined. This may change in the future, but inlining all your types is
  a really good idea, so you should do that anyway.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_LIBRARY_STRUCTURED

$fatpacked{"Specio/Library/Structured/Dict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_LIBRARY_STRUCTURED_DICT';
  package Specio::Library::Structured::Dict;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use Carp qw( confess );
  use List::Util ();
  use Scalar::Util qw( blessed );
  use Specio::Library::Builtins;
  use Specio::TypeChecks qw( does_role );
  
  my $hashref = t('HashRef');
  
  sub parent {$hashref}
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _inline {
      $hashref->inline_check( $_[1] );
  }
  
  sub _parameterization_args_builder {
      my $self = shift;
      my $args = shift;
  
      for my $p ( ( $args->{slurpy} || () ), values %{ $args->{kv} } ) {
          my $type;
          if ( blessed($p) ) {
              $type = $p;
          }
          else {
              if ( ref $p eq 'HASH' && $p->{optional} ) {
                  $type = $p->{optional};
              }
              else {
                  confess
                      'Can only pass types, optional types, and slurpy types when defining a Dict';
              }
          }
  
          does_role( $type, 'Specio::Constraint::Role::Interface' )
              or confess
              'All parameters passed to ->parameterize must be objects which do the Specio::Constraint::Role::Interface role';
  
          confess
              'All parameters passed to ->parameterize must be inlinable constraints'
              unless $type->can_be_inlined;
      }
  
      return %{$args};
  }
  
  sub _name_builder {
      my $self = shift;
      my $p    = shift;
  
      ## no critic (Subroutines::ProtectPrivateSubs)
      my @kv;
      for my $k ( sort keys %{ $p->{kv} } ) {
          my $v = $p->{kv}{$k};
          if ( blessed($v) ) {
              push @kv, "$k => " . $self->_name_or_anon($v);
          }
          elsif ( $v->{optional} ) {
              push @kv,
                  "$k => " . $self->_name_or_anon( $v->{optional} ) . '?';
          }
      }
  
      if ( $p->{slurpy} ) {
          push @kv, $self->_name_or_anon( $p->{slurpy} ) . '...';
      }
  
      return 'Dict{ ' . ( join ', ', @kv ) . ' }';
  }
  
  sub _structured_inline_generator {
      my $self = shift;
      my $val  = shift;
      my %args = @_;
  
      my @code = sprintf( '( %s )', $hashref->_inline_check($val) );
  
      for my $k ( sort keys %{ $args{kv} } ) {
          my $p = $args{kv}{$k};
          my $access = sprintf( '%s->{%s}', $val, B::perlstring($k) );
  
          if ( !blessed($p) ) {
              my $type = $p->{optional};
  
              push @code,
                  sprintf(
                  '( exists %s ? ( %s ) : 1 )',
                  $access, $type->_inline_check($access)
                  );
          }
          else {
              push @code, sprintf( '( %s )', $p->_inline_check($access) );
          }
      }
  
      if ( $args{slurpy} ) {
          my $check
              = '( do { my %%_____known_____ = map { $_ => 1 } ( %s ); List::Util::all { %s } grep { ! $_____known_____{$_} } sort keys %%{ %s } } )';
          push @code,
              sprintf(
              $check,
              ( join ', ', map { B::perlstring($_) } keys %{ $args{kv} } ),
              $args{slurpy}->_inline_check( sprintf( '%s->{$_}', $val ) ),
              $val,
              );
      }
  
      return '( ' . ( join ' && ', @code ) . ' )';
  }
  
  1;
  
  # ABSTRACT: Guts of Dict structured type
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Library::Structured::Dict - Guts of Dict structured type
  
  =head1 VERSION
  
  version 0.42
  
  =head1 DESCRIPTION
  
  There are no user facing parts here.
  
  =for Pod::Coverage .*
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_LIBRARY_STRUCTURED_DICT

$fatpacked{"Specio/Library/Structured/Map.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_LIBRARY_STRUCTURED_MAP';
  package Specio::Library::Structured::Map;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use Carp qw( confess );
  use List::Util ();
  use Specio::Library::Builtins;
  use Specio::TypeChecks qw( does_role );
  
  my $hashref = t('HashRef');
  
  sub parent {$hashref}
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _inline {
      $hashref->inline_check( $_[1] );
  }
  
  sub _parameterization_args_builder {
      my $self = shift;
      my $args = shift;
  
      for my $k (qw( key value )) {
          does_role(
              $args->{$k},
              'Specio::Constraint::Role::Interface'
              )
              or confess
              qq{The "$k" parameter passed to ->parameterize must be one or more objects which do the Specio::Constraint::Role::Interface role};
  
          confess
              qq{The "$k" parameter passed to ->parameterize must be an inlinable constraint}
              unless $args->{$k}->can_be_inlined;
      }
      return map { $_ => $args->{$_} } qw( key value );
  }
  
  sub _name_builder {
      my $self = shift;
      my $p    = shift;
  
      ## no critic (Subroutines::ProtectPrivateSubs)
      return
            'Map{ '
          . $self->_name_or_anon( $p->{key} ) . ' => '
          . $self->_name_or_anon( $p->{value} ) . ' }';
  }
  
  sub _structured_inline_generator {
      my $self = shift;
      my $val  = shift;
      my %args = @_;
  
      my $code = <<'EOF';
  (
      ( %s )
      && ( List::Util::all { %s } keys %%{ %s } )
      && ( List::Util::all { %s } values %%{ %s } )
  )
  EOF
  
      return sprintf(
          $code,
          $hashref->_inline_check($val),
          $args{key}->inline_check('$_'),
          $val,
          $args{value}->inline_check('$_'),
          $val,
      );
  }
  
  1;
  
  # ABSTRACT: Guts of Map structured type
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Library::Structured::Map - Guts of Map structured type
  
  =head1 VERSION
  
  version 0.42
  
  =head1 DESCRIPTION
  
  There are no user facing parts here.
  
  =for Pod::Coverage .*
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_LIBRARY_STRUCTURED_MAP

$fatpacked{"Specio/Library/Structured/Tuple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_LIBRARY_STRUCTURED_TUPLE';
  package Specio::Library::Structured::Tuple;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use Carp qw( confess );
  use List::Util ();
  use Scalar::Util qw( blessed );
  use Specio::Library::Builtins;
  use Specio::TypeChecks qw( does_role );
  
  my $arrayref = t('ArrayRef');
  
  sub parent {$arrayref}
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _inline {
      $arrayref->inline_check( $_[1] );
  }
  
  sub _parameterization_args_builder {
      my $self = shift;
      my $args = shift;
  
      my $saw_slurpy;
      my $saw_optional;
      for my $p ( @{$args} ) {
          if ($saw_slurpy) {
              confess
                  'A Tuple cannot have any parameters after a slurpy parameter';
          }
          if ( $saw_optional && blessed($p) ) {
              confess
                  'A Tuple cannot have a non-optional parameter after an optional parameter';
          }
  
          my $type;
          if ( blessed($p) ) {
              $type = $p;
          }
          else {
              if ( ref $p eq 'HASH' ) {
                  if ( $p->{optional} ) {
                      $saw_optional = 1;
                      $type         = $p->{optional};
                  }
                  if ( $p->{slurpy} ) {
                      $saw_slurpy = 1;
                      $type       = $p->{slurpy};
                  }
              }
              else {
                  confess
                      'Can only pass types, optional types, and slurpy types when defining a Tuple';
              }
          }
  
          if ( $saw_optional && $saw_slurpy ) {
              confess
                  'Cannot defined a slurpy Tuple with optional slots as well';
          }
  
          does_role( $type, 'Specio::Constraint::Role::Interface' )
              or confess
              'All parameters passed to ->parameterize must be objects which do the Specio::Constraint::Role::Interface role';
  
          confess
              'All parameters passed to ->parameterize must be inlinable constraints'
              unless $type->can_be_inlined;
      }
  
      return ( of => $args );
  }
  
  sub _name_builder {
      my $self = shift;
      my $p    = shift;
  
      my @names;
      for my $m ( @{ $p->{of} } ) {
          ## no critic (Subroutines::ProtectPrivateSubs)
          if ( blessed($m) ) {
              push @names, $self->_name_or_anon($m);
          }
          elsif ( $m->{optional} ) {
              push @names, $self->_name_or_anon( $m->{optional} ) . '?';
          }
          elsif ( $m->{slurpy} ) {
              push @names, $self->_name_or_anon( $m->{slurpy} ) . '...';
          }
      }
  
      return 'Tuple[ ' . ( join ', ', @names ) . ' ]';
  }
  
  sub _structured_inline_generator {
      my $self = shift;
      my $val  = shift;
      my %args = @_;
  
      my @of = @{ $args{of} };
  
      my $slurpy;
      $slurpy = ( pop @of )->{slurpy}
          if !blessed( $of[-1] ) && $of[-1]->{slurpy};
  
      my @code = sprintf( '( %s )', $arrayref->_inline_check($val) );
  
      unless ($slurpy) {
          my $min = 0;
          my $max = 0;
          for my $p (@of) {
  
              # Unblessed values are optional.
              if ( blessed($p) ) {
                  $min++;
                  $max++;
              }
              else {
                  $max++;
              }
          }
  
          if ($min) {
              push @code,
                  sprintf(
                  '( @{ %s } >= %d && @{ %s } <= %d  )',
                  $val, $min, $val, $max
                  );
          }
      }
  
      for my $i ( 0 .. $#of ) {
          my $p = $of[$i];
          my $access = sprintf( '%s->[%d]', $val, $i );
  
          if ( !blessed($p) ) {
              my $type = $p->{optional};
  
              push @code,
                  sprintf(
                  '( @{%s} >= %d ? ( %s ) : 1 )', $val, $i + 1,
                  $type->_inline_check($access)
                  );
          }
          else {
              push @code,
                  sprintf( '( %s )', $p->_inline_check($access) );
          }
      }
  
      if ($slurpy) {
          my $non_slurpy = scalar @of;
          my $check
              = '( @{%s} > %d ? ( List::Util::all { %s } @{%s}[%d .. $#{%s}] ) : 1 )';
          push @code,
              sprintf(
              $check,
              $val, $non_slurpy, $slurpy->_inline_check('$_'),
              $val, $non_slurpy, $val,
              );
      }
  
      return '( ' . ( join ' && ', @code ) . ' )';
  }
  
  1;
  
  # ABSTRACT: Guts of Tuple structured type
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Library::Structured::Tuple - Guts of Tuple structured type
  
  =head1 VERSION
  
  version 0.42
  
  =head1 DESCRIPTION
  
  There are no user facing parts here.
  
  =for Pod::Coverage .*
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_LIBRARY_STRUCTURED_TUPLE

$fatpacked{"Specio/OO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_OO';
  package Specio::OO;
  
  use strict;
  use warnings;
  
  use B qw( perlstring );
  use Carp qw( confess );
  use Eval::Closure qw( eval_closure );
  use List::Util qw( all );
  use MRO::Compat;
  use Role::Tiny;
  use Scalar::Util qw( blessed weaken );
  use Specio::PartialDump qw( partial_dump );
  use Specio::TypeChecks qw(
      does_role
      is_ArrayRef
      is_ClassName
      is_CodeRef
      is_HashRef
      is_Int
      is_Str
      isa_class
  );
  use Storable qw( dclone );
  
  our $VERSION = '0.42';
  
  use Exporter qw( import );
  
  ## no critic (Modules::ProhibitAutomaticExportation)
  our @EXPORT = qw(
      clone
      _ooify
  );
  ## use critic
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _ooify {
      my $class = shift;
  
      my $attrs = $class->_attrs;
      for my $name ( sort keys %{$attrs} ) {
          my $attr = $attrs->{$name};
  
          _inline_reader( $class, $name, $attr );
          _inline_predicate( $class, $name, $attr );
      }
  
      _inline_constructor($class);
  }
  ## use critic
  
  sub _inline_reader {
      my $class = shift;
      my $name  = shift;
      my $attr  = shift;
  
      my $reader;
      if ( $attr->{lazy} && ( my $builder = $attr->{builder} ) ) {
          my $source = <<'EOF';
  sub {
       unless ( exists $_[0]->{%s} ) {
           $_[0]->{%s} = $_[0]->%s;
           Scalar::Util::weaken( $_[0]->{%s} ) if %s && ref $_[0]->{%s};
       }
       $_[0]->{%s};
  }
  EOF
          $reader = sprintf(
              $source,
              $name,
              $name,
              $builder,
              $name,
              ( $attr->{weak_ref} ? 1 : 0 ),
              $name,
              $name,
          );
      }
      else {
          $reader = sprintf( 'sub { $_[0]->{%s} }', $name );
      }
  
      {
          ## no critic (TestingAndDebugging::ProhibitNoStrict)
          no strict 'refs';
          *{ $class . '::' . $name } = eval_closure(
              source      => $reader,
              description => $class . '->' . $name,
          );
      }
  }
  
  sub _inline_predicate {
      my $class = shift;
      my $name  = shift;
      my $attr  = shift;
  
      return unless $attr->{predicate};
  
      my $predicate = "sub { exists \$_[0]->{$name} }";
  
      {
          ## no critic (TestingAndDebugging::ProhibitNoStrict)
          no strict 'refs';
          *{ $class . '::' . $attr->{predicate} } = eval_closure(
              source      => $predicate,
              description => $class . '->' . $attr->{predicate},
          );
      }
  }
  
  my @RolesWithBUILD = qw( Specio::Constraint::Role::Interface );
  
  sub _inline_constructor {
      my $class = shift;
  
      my @build_subs;
      for my $parent ( @{ mro::get_linear_isa($class) } ) {
          {
              ## no critic (TestingAndDebugging::ProhibitNoStrict)
              no strict 'refs';
              push @build_subs, $parent . '::BUILD'
                  if defined &{ $parent . '::BUILD' };
          }
      }
  
      # This is all a hack to avoid needing Class::Method::Modifiers to add a
      # BUILD from a role. We can't just call the method in the role "BUILD" or
      # it will be shadowed by a class's BUILD. So we give it a wacky unique
      # name. We need to explicitly know which roles have a _X_BUILD method
      # because Role::Tiny doesn't provide a way to list all the roles applied
      # to a class.
      for my $role (@RolesWithBUILD) {
          if ( Role::Tiny::does_role( $class, $role ) ) {
              ( my $build_name = $role ) =~ s/::/_/g;
              $build_name = q{_} . $build_name . '_BUILD';
              push @build_subs, $role . '::' . $build_name;
          }
      }
  
      my $constructor = <<'EOF';
  sub {
      my $class = shift;
  
      my %p = do {
          if ( @_ == 1 ) {
              if ( ref $_[0] eq 'HASH' ) {
                  %{ shift() };
              }
              else {
                  Specio::OO::_constructor_confess(
                      Specio::OO::_bad_args_message( $class, @_ ) );
              }
          }
          else {
              Specio::OO::_constructor_confess(
                  Specio::OO::_bad_args_message( $class, @_ ) )
                  if @_ % 2;
              @_;
          }
      };
  
      my $self = bless {}, $class;
  
  EOF
  
      my $attrs = $class->_attrs;
      for my $name ( sort keys %{$attrs} ) {
          my $attr = $attrs->{$name};
          my $key_name = defined $attr->{init_arg} ? $attr->{init_arg} : $name;
  
          if ( $attr->{required} ) {
              $constructor .= <<"EOF";
      Specio::OO::_constructor_confess(
          "$class->new requires a $key_name argument.")
          unless exists \$p{$key_name};
  EOF
          }
  
          if ( $attr->{builder} && !$attr->{lazy} ) {
              my $builder = $attr->{builder};
              $constructor .= <<"EOF";
      \$p{$key_name} = $class->$builder unless exists \$p{$key_name};
  EOF
          }
  
          if ( $attr->{isa} ) {
              my $validator;
              if ( Specio::TypeChecks->can( 'is_' . $attr->{isa} ) ) {
                  $validator
                      = 'Specio::TypeChecks::is_'
                      . $attr->{isa}
                      . "( \$p{$key_name} )";
              }
              else {
                  my $quoted_class = perlstring( $attr->{isa} );
                  $validator
                      = "Specio::TypeChecks::isa_class( \$p{$key_name}, $quoted_class )";
              }
  
              $constructor .= <<"EOF";
      if ( exists \$p{$key_name} && !$validator ) {
          Carp::confess(
              Specio::OO::_bad_value_message(
                  "The value you provided to $class->new for $key_name is not a valid $attr->{isa}.",
                  \$p{$key_name},
              )
          );
      }
  EOF
          }
  
          if ( $attr->{does} ) {
              my $quoted_role = perlstring( $attr->{does} );
              $constructor .= <<"EOF";
      if ( exists \$p{$key_name} && !Specio::TypeChecks::does_role( \$p{$key_name}, $quoted_role ) ) {
          Carp::confess(
              Specio::OO::_bad_value_message(
                  "The value you provided to $class->new for $key_name does not do the $attr->{does} role.",
                  \$p{$key_name},
              )
          );
      }
  EOF
          }
  
          if ( $attr->{weak_ref} ) {
              $constructor .= "    Scalar::Util::weaken( \$p{$key_name} );\n";
          }
  
          $constructor
              .= "    \$self->{$name} = \$p{$key_name} if exists \$p{$key_name};\n";
  
          $constructor .= "\n";
      }
  
      $constructor .= '    $self->' . $_ . "(\\%p);\n" for @build_subs;
      $constructor .= <<'EOF';
  
      return $self;
  }
  EOF
  
      {
          ## no critic (TestingAndDebugging::ProhibitNoStrict)
          no strict 'refs';
          *{ $class . '::new' } = eval_closure(
              source      => $constructor,
              description => $class . '->new',
          );
      }
  }
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _constructor_confess {
      local $Carp::CarpLevel = $Carp::CarpLevel + 1;
      confess shift;
  }
  
  sub _bad_args_message {
      my $class = shift;
  
      return
          "$class->new requires either a hashref or hash as arguments. You passed "
          . partial_dump(@_);
  }
  
  sub _bad_value_message {
      my $message = shift;
      my $value   = shift;
  
      return $message . ' You passed ' . partial_dump($value);
  }
  ## use critic
  
  sub clone {
      my $self = shift;
  
      # Attributes which provide a clone method are cloned by calling that
      # method on the _clone_ (not the original). This is primarily to allow us
      # to clone the coercions contained by a type in a way that doesn't lead to
      # circular clone (type clones coercions which in turn need to clone their
      # to/from types which in turn ...).
      my $attrs = $self->_attrs;
      my %special = map { $_ => $attrs->{$_}{clone} }
          grep { $attrs->{$_}{clone} } keys %{$attrs};
  
      my $new;
      for my $key ( keys %{$self} ) {
          my $value = $self->{$key};
  
          if ( $special{$key} ) {
              $new->{$key} = $value;
              next;
          }
  
          # We need to special case arrays and hashes of Specio objects, as they
          # may contain code refs which cannot be cloned with dclone.
          if ( ( ref $value eq 'ARRAY' )
              && all { ( blessed($_) || q{} ) =~ /Specio/ } @{$value} ) {
  
              $new->{$key} = [ map { $_->clone } @{$value} ];
              next;
          }
  
          $new->{$key}
              = blessed $value           ? $value->clone
              : ( ref $value eq 'CODE' ) ? $value
              : ref $value               ? dclone($value)
              :                            $value;
      }
  
      bless $new, ( ref $self );
  
      for my $key ( keys %special ) {
          my $method = $special{$key};
          $new->{$key} = $new->$method;
      }
  
      return $new;
  }
  
  1;
  
  # ABSTRACT: A painfully poor reimplementation of Moo(se)
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::OO - A painfully poor reimplementation of Moo(se)
  
  =head1 VERSION
  
  version 0.42
  
  =head1 DESCRIPTION
  
  Specio can't depend on Moo or Moose, so this module provides a terrible
  reimplementation of a small slice of their features.
  
  =for Pod::Coverage .*
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_OO

$fatpacked{"Specio/PartialDump.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_PARTIALDUMP';
  package Specio::PartialDump;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use Scalar::Util qw( looks_like_number reftype blessed );
  
  use Exporter qw( import );
  
  our @EXPORT_OK = qw( partial_dump );
  
  my $MaxLength   = 100;
  my $MaxElements = 6;
  my $MaxDepth    = 2;
  
  sub partial_dump {
      my (@args) = @_;
  
      my $dump
          = _should_dump_as_pairs(@args)
          ? _dump_as_pairs( 1, @args )
          : _dump_as_list( 1, @args );
  
      if ( length($dump) > $MaxLength ) {
          my $max_length = $MaxLength - 3;
          $max_length = 0 if $max_length < 0;
          substr( $dump, $max_length, length($dump) - $max_length ) = '...';
      }
  
      return $dump;
  }
  
  sub _should_dump_as_pairs {
      my (@what) = @_;
  
      return if @what % 2 != 0;    # must be an even list
  
      for ( my $i = 0; $i < @what; $i += 2 ) {
          return if ref $what[$i];    # plain strings are keys
      }
  
      return 1;
  }
  
  sub _dump_as_pairs {
      my ( $depth, @what ) = @_;
  
      my $truncated;
      if ( defined $MaxElements and ( @what / 2 ) > $MaxElements ) {
          $truncated = 1;
          @what = splice( @what, 0, $MaxElements * 2 );
      }
  
      return join(
          ', ', _dump_as_pairs_recursive( $depth, @what ),
          ( $truncated ? "..." : () )
      );
  }
  
  sub _dump_as_pairs_recursive {
      my ( $depth, @what ) = @_;
  
      return unless @what;
  
      my ( $key, $value, @rest ) = @what;
  
      return (
          ( _format_key( $depth, $key ) . ': ' . _format( $depth, $value ) ),
          _dump_as_pairs_recursive( $depth, @rest ),
      );
  }
  
  sub _dump_as_list {
      my ( $depth, @what ) = @_;
  
      my $truncated;
      if ( @what > $MaxElements ) {
          $truncated = 1;
          @what = splice( @what, 0, $MaxElements );
      }
  
      return join(
          ', ', ( map { _format( $depth, $_ ) } @what ),
          ( $truncated ? "..." : () )
      );
  }
  
  sub _format {
      my ( $depth, $value ) = @_;
  
      defined($value)
          ? (
          ref($value)
          ? (
                blessed($value)
              ? _format_object( $depth, $value )
              : _format_ref( $depth, $value )
              )
          : (
                looks_like_number($value)
              ? _format_number( $depth, $value )
              : _format_string( $depth, $value )
          )
          )
          : _format_undef( $depth, $value ),
  }
  
  sub _format_key {
      my ( undef, $key ) = @_;
      return $key;
  }
  
  sub _format_ref {
      my ( $depth, $ref ) = @_;
  
      if ( $depth > $MaxDepth ) {
          return overload::StrVal($ref);
      }
      else {
          my $reftype = reftype($ref);
          $reftype = 'SCALAR'
              if $reftype eq 'REF' || $reftype eq 'LVALUE';
          my $method = "_format_" . lc $reftype;
  
          if ( my $sub = __PACKAGE__->can($method) ) {
              return $sub->( $depth, $ref );
          }
          else {
              return overload::StrVal($ref);
          }
      }
  }
  
  sub _format_array {
      my ( $depth, $array ) = @_;
  
      my $class = blessed($array) || '';
      $class .= "=" if $class;
  
      return $class . "[ " . _dump_as_list( $depth + 1, @$array ) . " ]";
  }
  
  sub _format_hash {
      my ( $depth, $hash ) = @_;
  
      my $class = blessed($hash) || '';
      $class .= "=" if $class;
  
      return $class . "{ " . _dump_as_pairs(
          $depth + 1,
          map { $_ => $hash->{$_} } sort keys %$hash
      ) . " }";
  }
  
  sub _format_scalar {
      my ( $depth, $scalar ) = @_;
  
      my $class = blessed($scalar) || '';
      $class .= "=" if $class;
  
      return $class . "\\" . _format( $depth + 1, $$scalar );
  }
  
  sub _format_object {
      my ( $depth, $object ) = @_;
  
      return _format_ref( $depth, $object );
  }
  
  sub _format_string {
      my ( undef, $str ) = @_;
  
      # FIXME use String::Escape ?
  
      # remove vertical whitespace
      $str =~ s/\n/\\n/g;
      $str =~ s/\r/\\r/g;
  
      # reformat nonprintables
      $str =~ s/(\P{IsPrint})/"\\x{" . sprintf("%x", ord($1)) . "}"/ge;
  
      _quote($str);
  }
  
  sub _quote {
      my ($str) = @_;
  
      qq{"$str"};
  }
  
  sub _format_undef {"undef"}
  
  sub _format_number {
      my ( undef, $value ) = @_;
      return "$value";
  }
  
  # ABSTRACT: A partially rear-ended copy of Devel::PartialDump without prereqs
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::PartialDump - A partially rear-ended copy of Devel::PartialDump without prereqs
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
    use Specio::PartialDump qw( partial_dump );
  
    partial_dump( { foo => 42 } );
    partial_dump(qw( a b c d e f g ));
    partial_dump( foo => 42, bar => [ 1, 2, 3 ], );
  
  =head1 DESCRIPTION
  
  This is a copy of Devel::PartialDump with all the OO bits and prereqs
  removed. You may want to use this module in your own code to generate nicely
  formatted messages when a type constraint fails.
  
  This module optionally exports one sub, C<partial_dump>. This sub accepts any
  number of arguments. If given more than one, it will assume that it's either
  been given a list of key/value pairs (to build a hash) or a list of values (to
  build an array) and dump them appropriately. Objects and references are
  stringified in a sane way.
  
  =for Pod::Coverage partial_dump
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2008 by יובל קוג'מן (Yuval Kogman).
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_PARTIALDUMP

$fatpacked{"Specio/Registry.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_REGISTRY';
  package Specio::Registry;
  
  use strict;
  use warnings;
  
  use parent 'Exporter';
  
  our $VERSION = '0.42';
  
  use Carp qw( confess croak );
  
  our @EXPORT_OK
      = qw( exportable_types_for_package internal_types_for_package register );
  
  my %Registry;
  
  sub register {
      confess
          'register requires three or four arguments (package, name, type, [exportable])'
          unless @_ == 3 || @_ == 4;
  
      my $package    = shift;
      my $name       = shift;
      my $type       = shift;
      my $exportable = shift;
  
      croak "The $package package already has a type named $name"
          if $Registry{$package}{internal}{$name};
  
      # This is structured so that we can always return a _reference_ for
      # *_types_for_package. This means that the generated t sub sees any
      # changes to the registry as they happen. This is important inside a
      # package that is declaring new types. It needs to be able to see types it
      # has declared.
      $Registry{$package}{internal}{$name}   = $type;
      $Registry{$package}{exportable}{$name} = $type
          if $exportable;
  
      return;
  }
  
  sub exportable_types_for_package {
      my $package = shift;
  
      return $Registry{$package}{exportable} ||= {};
  }
  
  sub internal_types_for_package {
      my $package = shift;
  
      return $Registry{$package}{internal} ||= {};
  }
  
  1;
  
  # ABSTRACT: Implements the per-package type registry
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Registry - Implements the per-package type registry
  
  =head1 VERSION
  
  version 0.42
  
  =head1 DESCRIPTION
  
  There's nothing public here.
  
  =for Pod::Coverage .*
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_REGISTRY

$fatpacked{"Specio/Role/Inlinable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_ROLE_INLINABLE';
  package Specio::Role::Inlinable;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use Eval::Closure qw( eval_closure );
  
  use Role::Tiny;
  
  requires '_build_description';
  
  {
      my $attrs = {
          _inline_generator => {
              is        => 'ro',
              isa       => 'CodeRef',
              predicate => '_has_inline_generator',
              init_arg  => 'inline_generator',
          },
          inline_environment => {
              is       => 'ro',
              isa      => 'HashRef',
              lazy     => 1,
              init_arg => 'inline_environment',
              builder  => '_build_inline_environment',
          },
          _generated_inline_sub => {
              is       => 'ro',
              isa      => 'CodeRef',
              init_arg => undef,
              lazy     => 1,
              builder  => '_build_generated_inline_sub',
          },
          declared_at => {
              is       => 'ro',
              isa      => 'Specio::DeclaredAt',
              required => 1,
          },
          description => {
              is       => 'ro',
              isa      => 'Str',
              init_arg => undef,
              lazy     => 1,
              builder  => '_build_description',
          },
      };
  
      ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
      sub _attrs {
          return $attrs;
      }
  }
  
  # These are here for backwards compatibility. Some other packages that I wrote
  # may call the private methods.
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _description        { $_[0]->description }
  sub _inline_environment { $_[0]->inline_environment }
  ## use critic
  
  sub can_be_inlined {
      my $self = shift;
  
      return $self->_has_inline_generator;
  }
  
  sub _build_generated_inline_sub {
      my $self = shift;
  
      my $source
          = 'sub { ' . $self->_inline_generator->( $self, '$_[0]' ) . '}';
  
      return eval_closure(
          source      => $source,
          environment => $self->inline_environment,
          description => 'inlined sub for ' . $self->description,
      );
  }
  
  sub _build_inline_environment {
      return {};
  }
  
  1;
  
  # ABSTRACT: A role for things which can be inlined (type constraints and coercions)
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Role::Inlinable - A role for things which can be inlined (type constraints and coercions)
  
  =head1 VERSION
  
  version 0.42
  
  =head1 DESCRIPTION
  
  This role implements a common API for inlinable things, type constraints and
  coercions. It is fully documented in the relevant classes.
  
  =for Pod::Coverage .*
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_ROLE_INLINABLE

$fatpacked{"Specio/Subs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_SUBS';
  package Specio::Subs;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use Carp qw( croak );
  use Eval::Closure qw( eval_closure );
  use Module::Runtime qw( use_package_optimistically );
  use Specio::Library::Perl;
  use Specio::Registry qw( exportable_types_for_package );
  
  my $counter = 0;
  
  sub import {
      shift;
      my @libs = @_;
  
      my $caller = caller();
  
      my $ident = t('Identifier');
  
      use_package_optimistically($_) for @libs;
  
      for my $types ( map { exportable_types_for_package($_) } @libs ) {
          for my $name ( keys %{$types} ) {
              croak
                  qq{Cannot use '$name' type to create a check sub. It results in an invalid Perl subroutine name}
                  unless $ident->check( 'is_' . $name );
  
              _export_subs( $name, $types->{$name}, $caller );
          }
      }
  }
  
  sub _export_subs {
      my $name   = shift;
      my $type   = shift;
      my $caller = shift;
  
      _export_validation_subs( $name, $type, $caller );
  
      return unless $type->has_coercions;
  
      _export_coercion_subs( $name, $type, $caller );
  }
  
  sub _export_validation_subs {
      my $name   = shift;
      my $type   = shift;
      my $caller = shift;
  
      my $is_name     = 'is_' . $name;
      my $assert_name = 'assert_' . $name;
      if ( $type->can_be_inlined ) {
          _make_sub(
              $caller, $is_name,
              $type->inline_check('$_[0]')
          );
          _make_sub(
              $caller, $assert_name,
              $type->inline_assert('$_[0]')
          );
      }
      else {
          _install_sub(
              $caller, $is_name,
              sub { $type->value_is_valid( $_[0] ) }
          );
          _install_sub(
              $caller, $assert_name,
              sub { $type->validate_or_die( $_[0] ) }
          );
      }
  }
  
  sub _export_coercion_subs {
      my $name   = shift;
      my $type   = shift;
      my $caller = shift;
  
      my $to_name = 'to_' . $name;
      if ( $type->can_inline_coercion ) {
          _make_sub(
              $caller, $to_name,
              $type->inline_coercion('$_[0]')
          );
      }
      else {
          _install_sub(
              $caller, $to_name,
              sub { $type->coerce_value( $_[0] ) }
          );
      }
  
      my $force_name = 'force_' . $name;
      if ( $type->can_inline_coercion_and_check ) {
          _make_sub(
              $caller, $force_name,
              $type->inline_coercion_and_check('$_[0]')
          );
      }
      else {
          _install_sub(
              $caller, $force_name,
              sub {
                  my $val = $type->coerce_value( $_[0] );
                  $type->validate_or_die($val);
                  return $val;
              }
          );
      }
  }
  
  sub _make_sub {
      my $caller   = shift;
      my $sub_name = shift;
      my $source   = shift;
      my $env      = shift;
  
      my $sub = eval_closure(
          source      => 'sub { ' . $source . ' }',
          environment => $env,
          description => $caller . '::'
              . $sub_name
              . ' generated by '
              . __PACKAGE__,
      );
  
      _install_sub( $caller, $sub_name, $sub );
  
      return;
  }
  
  my $sub_namer = do {
      eval {
          require Sub::Util;
          Sub::Util->VERSION(1.40);
          Sub::Util->can('set_subname');
      } or eval {
          require Sub::Name;
          Sub::Name->can('subname');
      }
          or sub { return $_[1] };
  };
  
  my %Installed;
  
  sub _install_sub {
      my $caller   = shift;
      my $sub_name = shift;
      my $sub      = shift;
  
      my $fq_name = $caller . '::' . $sub_name;
  
      {
          ## no critic (TestingAndDebugging::ProhibitNoStrict)
          no strict 'refs';
          *{$fq_name} = $sub_namer->( $fq_name, $sub );
      }
  
      $Installed{$caller} ||= [];
      push @{ $Installed{$caller} }, $sub_name;
  
      return;
  }
  
  sub subs_installed_into {
      my $package = shift;
  
      return @{ $Installed{$package} || [] };
  }
  
  1;
  
  # ABSTRACT: Make validation and coercion subs from Specio types
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::Subs - Make validation and coercion subs from Specio types
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
    use Specio::Subs qw( Specio::Library::Builtins Specio::Library::Perl My::Lib );
  
    if ( is_PackageName($var) ) { ... }
  
    assert_Str($var);
  
    my $person1 = to_Person($var);
    my $person2 = force_Person($var);
  
  =head1 DESCRIPTION
  
  This module generates a set of helpful validation and coercion subroutines for
  all of the types defined in one or more libraries.
  
  To use it, simply import C<Specio::Subs> passing a list of one or more library
  names. This module will load those libraries as needed.
  
  If any of the types in any libraries have names that do not work as part of a
  Perl subroutine name, this module will throw an exception.
  
  If you have L<Sub::Util> or L<Sub::Name> installed, one of those will be used
  to name the generated subroutines.
  
  =head1 "EXPORTS"
  
  The following subs are created in the importing package:
  
  =head2 is_$type($value)
  
  This subroutine returns a boolean indicating whether or not the C<$value> is
  valid for the type.
  
  =head2 assert_$type($value)
  
  This subroutine dies if the C<$value> is not valid for the type.
  
  =head2 to_$type($value)
  
  This subroutine attempts to coerce C<$value> into the given type. If it cannot
  be coerced it returns the original C<$value>.
  
  This is only created if the type has coercions.
  
  =head2 force_$type($value)
  
  This subroutine attempts to coerce C<$value> into the given type, and dies if
  it cannot do so.
  
  This is only created if the type has coercions.
  
  =head1 ADDITIONAL API
  
  =for Pod::Coverage subs_installed_into
  
  This module has a subroutine named C<subs_installed_into>. It is not exported
  but it can be called by its fully qualified name. It accepts a single
  argument, a package name. It returns a list of subs that it generated and
  installed in the given package, if any.
  
  This exists to make it easy to write a type library that combines other
  library and generates helper subs for export all at once.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_SUBS

$fatpacked{"Specio/TypeChecks.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SPECIO_TYPECHECKS';
  package Specio::TypeChecks;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use Exporter qw( import );
  use Specio::Helpers qw( is_class_loaded );
  use Scalar::Util qw( blessed );
  
  our @EXPORT_OK = qw(
      does_role
      is_ArrayRef
      is_ClassName
      is_CodeRef
      is_HashRef
      is_Int
      is_Str
      isa_class
  );
  
  sub is_ArrayRef {
      return ref $_[0] eq 'ARRAY';
  }
  
  sub is_CodeRef {
      return ref $_[0] eq 'CODE';
  }
  
  sub is_HashRef {
      return ref $_[0] eq 'HASH';
  }
  
  sub is_Str {
      defined( $_[0] ) && !ref( $_[0] ) && ref( \$_[0] ) eq 'SCALAR'
          || ref( \( my $val = $_[0] ) eq 'SCALAR' );
  }
  
  sub is_Int {
      ( defined( $_[0] ) && !ref( $_[0] ) && ref( \$_[0] ) eq 'SCALAR'
              || ref( \( my $val = $_[0] ) eq 'SCALAR' ) )
          && $_[0] =~ /^[0-9]+$/;
  }
  
  sub is_ClassName {
      is_class_loaded( $_[0] );
  }
  
  sub isa_class {
      blessed( $_[0] ) && $_[0]->isa( $_[1] );
  }
  
  sub does_role {
      blessed( $_[0] ) && $_[0]->can('does') && $_[0]->does( $_[1] );
  }
  
  1;
  
  # ABSTRACT: Type checks used internally for Specio classes (it's not self-bootstrapping (yet?))
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Specio::TypeChecks - Type checks used internally for Specio classes (it's not self-bootstrapping (yet?))
  
  =head1 VERSION
  
  version 0.42
  
  =head1 DESCRIPTION
  
  There's nothing public here.
  
  =for Pod::Coverage .*
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
SPECIO_TYPECHECKS

$fatpacked{"Sub/Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER';
  use 5.006;
  use strict;
  use warnings;
  package Sub::Exporter;
  {
    $Sub::Exporter::VERSION = '0.987';
  }
  # ABSTRACT: a sophisticated exporter for custom-built routines
  
  use Carp ();
  use Data::OptList 0.100 ();
  use Params::Util 0.14 (); # _CODELIKE
  use Sub::Install 0.92 ();
  
  
  # Given a potential import name, this returns the group name -- if it's got a
  # group prefix.
  sub _group_name {
    my ($name) = @_;
  
    return if (index q{-:}, (substr $name, 0, 1)) == -1;
    return substr $name, 1;
  }
  
  # \@groups is a canonicalized opt list of exports and groups this returns
  # another canonicalized opt list with groups replaced with relevant exports.
  # \%seen is groups we've already expanded and can ignore.
  # \%merge is merged options from the group we're descending through.
  sub _expand_groups {
    my ($class, $config, $groups, $collection, $seen, $merge) = @_;
    $seen  ||= {};
    $merge ||= {};
    my @groups = @$groups;
  
    for my $i (reverse 0 .. $#groups) {
      if (my $group_name = _group_name($groups[$i][0])) {
        my $seen = { %$seen }; # faux-dynamic scoping
  
        splice @groups, $i, 1,
          _expand_group($class, $config, $groups[$i], $collection, $seen, $merge);
      } else {
        # there's nothing to munge in this export's args
        next unless my %merge = %$merge;
  
        # we have things to merge in; do so
        my $prefix = (delete $merge{-prefix}) || '';
        my $suffix = (delete $merge{-suffix}) || '';
  
        if (
          Params::Util::_CODELIKE($groups[$i][1]) ## no critic Private
          or
          Params::Util::_SCALAR0($groups[$i][1]) ## no critic Private
        ) {
          # this entry was build by a group generator
          $groups[$i][0] = $prefix . $groups[$i][0] . $suffix;
        } else {
          my $as
            = ref $groups[$i][1]{-as} ? $groups[$i][1]{-as}
            :     $groups[$i][1]{-as} ? $prefix . $groups[$i][1]{-as} . $suffix
            :                           $prefix . $groups[$i][0]      . $suffix;
  
          $groups[$i][1] = { %{ $groups[$i][1] }, %merge, -as => $as };
        }
      }
    }
  
    return \@groups;
  }
  
  # \@group is a name/value pair from an opt list.
  sub _expand_group {
    my ($class, $config, $group, $collection, $seen, $merge) = @_;
    $merge ||= {};
  
    my ($group_name, $group_arg) = @$group;
    $group_name = _group_name($group_name);
  
    Carp::croak qq(group "$group_name" is not exported by the $class module)
      unless exists $config->{groups}{$group_name};
  
    return if $seen->{$group_name}++;
  
    if (ref $group_arg) {
      my $prefix = (delete $merge->{-prefix}||'') . ($group_arg->{-prefix}||'');
      my $suffix = ($group_arg->{-suffix}||'') . (delete $merge->{-suffix}||'');
      $merge = {
        %$merge,
        %$group_arg,
        ($prefix ? (-prefix => $prefix) : ()),
        ($suffix ? (-suffix => $suffix) : ()),
      };
    }
  
    my $exports = $config->{groups}{$group_name};
  
    if (
      Params::Util::_CODELIKE($exports) ## no critic Private
      or
      Params::Util::_SCALAR0($exports) ## no critic Private
    ) {
      # I'm not very happy with this code for hiding -prefix and -suffix, but
      # it's needed, and I'm not sure, offhand, how to make it better.
      # -- rjbs, 2006-12-05
      my $group_arg = $merge ? { %$merge } : {};
      delete $group_arg->{-prefix};
      delete $group_arg->{-suffix};
  
      my $group = Params::Util::_CODELIKE($exports) ## no critic Private
                ? $exports->($class, $group_name, $group_arg, $collection)
                : $class->$$exports($group_name, $group_arg, $collection);
  
      Carp::croak qq(group generator "$group_name" did not return a hashref)
        if ref $group ne 'HASH';
  
      my $stuff = [ map { [ $_ => $group->{$_} ] } keys %$group ];
      return @{
        _expand_groups($class, $config, $stuff, $collection, $seen, $merge)
      };
    } else {
      $exports
        = Data::OptList::mkopt($exports, "$group_name exports");
  
      return @{
        _expand_groups($class, $config, $exports, $collection, $seen, $merge)
      };
    }
  }
  
  sub _mk_collection_builder {
    my ($col, $etc) = @_;
    my ($config, $import_args, $class, $into) = @$etc;
  
    my %seen;
    sub {
      my ($collection) = @_;
      my ($name, $value) = @$collection;
  
      Carp::croak "collection $name provided multiple times in import"
        if $seen{ $name }++;
  
      if (ref(my $hook = $config->{collectors}{$name})) {
        my $arg = {
          name        => $name,
          config      => $config,
          import_args => $import_args,
          class       => $class,
          into        => $into,
        };
  
        my $error_msg = "collection $name failed validation";
        if (Params::Util::_SCALAR0($hook)) { ## no critic Private
          Carp::croak $error_msg unless $class->$$hook($value, $arg);
        } else {
          Carp::croak $error_msg unless $hook->($value, $arg);
        }
      }
  
      $col->{ $name } = $value;
    }
  }
  
  # Given a config and pre-canonicalized importer args, remove collections from
  # the args and return them.
  sub _collect_collections {
    my ($config, $import_args, $class, $into) = @_;
  
    my @collections
      = map  { splice @$import_args, $_, 1 }
        grep { exists $config->{collectors}{ $import_args->[$_][0] } }
        reverse 0 .. $#$import_args;
  
    unshift @collections, [ INIT => {} ] if $config->{collectors}{INIT};
  
    my $col = {};
    my $builder = _mk_collection_builder($col, \@_);
    for my $collection (@collections) {
      $builder->($collection)
    }
  
    return $col;
  }
  
  
  sub setup_exporter {
    my ($config)  = @_;
  
    Carp::croak 'into and into_level may not both be supplied to exporter'
      if exists $config->{into} and exists $config->{into_level};
  
    my $as   = delete $config->{as}   || 'import';
    my $into
      = exists $config->{into}       ? delete $config->{into}
      : exists $config->{into_level} ? caller(delete $config->{into_level})
      :                                caller(0);
  
    my $import = build_exporter($config);
  
    Sub::Install::reinstall_sub({
      code => $import,
      into => $into,
      as   => $as,
    });
  }
  
  
  sub _key_intersection {
    my ($x, $y) = @_;
    my %seen = map { $_ => 1 } keys %$x;
    my @names = grep { $seen{$_} } keys %$y;
  }
  
  # Given the config passed to setup_exporter, which contains sugary opt list
  # data, rewrite the opt lists into hashes, catch a few kinds of invalid
  # configurations, and set up defaults.  Since the config is a reference, it's
  # rewritten in place.
  my %valid_config_key;
  BEGIN {
    %valid_config_key =
      map { $_ => 1 }
      qw(as collectors installer generator exports groups into into_level),
      qw(exporter), # deprecated
  }
  
  sub _assert_collector_names_ok {
    my ($collectors) = @_;
  
    for my $reserved_name (grep { /\A[_A-Z]+\z/ } keys %$collectors) {
      Carp::croak "unknown reserved collector name: $reserved_name"
        if $reserved_name ne 'INIT';
    }
  }
  
  sub _rewrite_build_config {
    my ($config) = @_;
  
    if (my @keys = grep { not exists $valid_config_key{$_} } keys %$config) {
      Carp::croak "unknown options (@keys) passed to Sub::Exporter";
    }
  
    Carp::croak q(into and into_level may not both be supplied to exporter)
      if exists $config->{into} and exists $config->{into_level};
  
    # XXX: Remove after deprecation period.
    if ($config->{exporter}) {
      Carp::cluck "'exporter' argument to build_exporter is deprecated. Use 'installer' instead; the semantics are identical.";
      $config->{installer} = delete $config->{exporter};
    }
  
    Carp::croak q(into and into_level may not both be supplied to exporter)
      if exists $config->{into} and exists $config->{into_level};
  
    for (qw(exports collectors)) {
      $config->{$_} = Data::OptList::mkopt_hash(
        $config->{$_},
        $_,
        [ 'CODE', 'SCALAR' ],
      );
    }
  
    _assert_collector_names_ok($config->{collectors});
  
    if (my @names = _key_intersection(@$config{qw(exports collectors)})) {
      Carp::croak "names (@names) used in both collections and exports";
    }
  
    $config->{groups} = Data::OptList::mkopt_hash(
        $config->{groups},
        'groups',
        [
          'HASH',   # standard opt list
          'ARRAY',  # standard opt list
          'CODE',   # group generator
          'SCALAR', # name of group generation method
        ]
      );
  
    # by default, export nothing
    $config->{groups}{default} ||= [];
  
    # by default, build an all-inclusive 'all' group
    $config->{groups}{all} ||= [ keys %{ $config->{exports} } ];
  
    $config->{generator} ||= \&default_generator;
    $config->{installer} ||= \&default_installer;
  }
  
  sub build_exporter {
    my ($config) = @_;
  
    _rewrite_build_config($config);
  
    my $import = sub {
      my ($class) = shift;
  
      # XXX: clean this up -- rjbs, 2006-03-16
      my $special = (ref $_[0]) ? shift(@_) : {};
      Carp::croak q(into and into_level may not both be supplied to exporter)
        if exists $special->{into} and exists $special->{into_level};
  
      if ($special->{exporter}) {
        Carp::cluck "'exporter' special import argument is deprecated. Use 'installer' instead; the semantics are identical.";
        $special->{installer} = delete $special->{exporter};
      }
  
      my $into
        = defined $special->{into}       ? delete $special->{into}
        : defined $special->{into_level} ? caller(delete $special->{into_level})
        : defined $config->{into}        ? $config->{into}
        : defined $config->{into_level}  ? caller($config->{into_level})
        :                                  caller(0);
  
      my $generator = delete $special->{generator} || $config->{generator};
      my $installer = delete $special->{installer} || $config->{installer};
  
      # this builds a AOA, where the inner arrays are [ name => value_ref ]
      my $import_args = Data::OptList::mkopt([ @_ ]);
  
      # is this right?  defaults first or collectors first? -- rjbs, 2006-06-24
      $import_args = [ [ -default => undef ] ] unless @$import_args;
  
      my $collection = _collect_collections($config, $import_args, $class, $into);
  
      my $to_import = _expand_groups($class, $config, $import_args, $collection);
  
      # now, finally $import_arg is really the "to do" list
      _do_import(
        {
          class     => $class,
          col       => $collection,
          config    => $config,
          into      => $into,
          generator => $generator,
          installer => $installer,
        },
        $to_import,
      );
    };
  
    return $import;
  }
  
  sub _do_import {
    my ($arg, $to_import) = @_;
  
    my @todo;
  
    for my $pair (@$to_import) {
      my ($name, $import_arg) = @$pair;
  
      my ($generator, $as);
  
      if ($import_arg and Params::Util::_CODELIKE($import_arg)) { ## no critic
        # This is the case when a group generator has inserted name/code pairs.
        $generator = sub { $import_arg };
        $as = $name;
      } else {
        $import_arg = { $import_arg ? %$import_arg : () };
  
        Carp::croak qq("$name" is not exported by the $arg->{class} module)
          unless exists $arg->{config}{exports}{$name};
  
        $generator = $arg->{config}{exports}{$name};
  
        $as = exists $import_arg->{-as} ? (delete $import_arg->{-as}) : $name;
      }
  
      my $code = $arg->{generator}->(
        { 
          class     => $arg->{class},
          name      => $name,
          arg       => $import_arg,
          col       => $arg->{col},
          generator => $generator,
        }
      );
  
      push @todo, $as, $code;
    }
  
    $arg->{installer}->(
      {
        class => $arg->{class},
        into  => $arg->{into},
        col   => $arg->{col},
      },
      \@todo,
    );
  }
  
  ## Cute idea, possibly for future use: also supply an "unimport" for:
  ## no Module::Whatever qw(arg arg arg);
  # sub _unexport {
  #   my (undef, undef, undef, undef, undef, $as, $into) = @_;
  # 
  #   if (ref $as eq 'SCALAR') {
  #     undef $$as;
  #   } elsif (ref $as) {
  #     Carp::croak "invalid reference type for $as: " . ref $as;
  #   } else {
  #     no strict 'refs';
  #     delete &{$into . '::' . $as};
  #   }
  # }
  
  
  sub default_generator {
    my ($arg) = @_;
    my ($class, $name, $generator) = @$arg{qw(class name generator)};
  
    if (not defined $generator) {
      my $code = $class->can($name)
        or Carp::croak "can't locate exported subroutine $name via $class";
      return $code;
    }
  
    # I considered making this "$class->$generator(" but it seems that
    # overloading precedence would turn an overloaded-as-code generator object
    # into a string before code. -- rjbs, 2006-06-11
    return $generator->($class, $name, $arg->{arg}, $arg->{col})
      if Params::Util::_CODELIKE($generator); ## no critic Private
  
    # This "must" be a scalar reference, to a generator method name.
    # -- rjbs, 2006-12-05
    return $class->$$generator($name, $arg->{arg}, $arg->{col});
  }
  
  
  sub default_installer {
    my ($arg, $to_export) = @_;
  
    for (my $i = 0; $i < @$to_export; $i += 2) {
      my ($as, $code) = @$to_export[ $i, $i+1 ];
  
      # Allow as isa ARRAY to push onto an array?
      # Allow into isa HASH to install name=>code into hash?
  
      if (ref $as eq 'SCALAR') {
        $$as = $code;
      } elsif (ref $as) {
        Carp::croak "invalid reference type for $as: " . ref $as;
      } else {
        Sub::Install::reinstall_sub({
          code => $code,
          into => $arg->{into},
          as   => $as
        });
      }
    }
  }
  
  sub default_exporter {
    Carp::cluck "default_exporter is deprecated; call default_installer instead; the semantics are identical";
    goto &default_installer;
  }
  
  
  setup_exporter({
    exports => [
      qw(setup_exporter build_exporter),
      _import => sub { build_exporter($_[2]) },
    ],
    groups  => {
      all   => [ qw(setup_exporter build_export) ],
    },
    collectors => { -setup => \&_setup },
  });
  
  sub _setup {
    my ($value, $arg) = @_;
  
    if (ref $value eq 'HASH') {
      push @{ $arg->{import_args} }, [ _import => { -as => 'import', %$value } ];
      return 1;
    } elsif (ref $value eq 'ARRAY') {
      push @{ $arg->{import_args} },
        [ _import => { -as => 'import', exports => $value } ];
      return 1;
    }
    return;
  }
  
  
  
  "jn8:32"; # <-- magic true value
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Sub::Exporter - a sophisticated exporter for custom-built routines
  
  =head1 VERSION
  
  version 0.987
  
  =head1 SYNOPSIS
  
  Sub::Exporter must be used in two places.  First, in an exporting module:
  
    # in the exporting module:
    package Text::Tweaker;
    use Sub::Exporter -setup => {
      exports => [
        qw(squish titlecase), # always works the same way
        reformat => \&build_reformatter, # generator to build exported function
        trim     => \&build_trimmer,
        indent   => \&build_indenter,
      ],
      collectors => [ 'defaults' ],
    };
  
  Then, in an importing module:
  
    # in the importing module:
    use Text::Tweaker
      'squish',
      indent   => { margin => 5 },
      reformat => { width => 79, justify => 'full', -as => 'prettify_text' },
      defaults => { eol => 'CRLF' };
  
  With this setup, the importing module ends up with three routines: C<squish>,
  C<indent>, and C<prettify_text>.  The latter two have been built to the
  specifications of the importer -- they are not just copies of the code in the
  exporting package.
  
  =head1 DESCRIPTION
  
  B<ACHTUNG!>  If you're not familiar with Exporter or exporting, read
  L<Sub::Exporter::Tutorial> first!
  
  =head2 Why Generators?
  
  The biggest benefit of Sub::Exporter over existing exporters (including the
  ubiquitous Exporter.pm) is its ability to build new coderefs for export, rather
  than to simply export code identical to that found in the exporting package.
  
  If your module's consumers get a routine that works like this:
  
    use Data::Analyze qw(analyze);
    my $value = analyze($data, $tolerance, $passes);
  
  and they constantly pass only one or two different set of values for the
  non-C<$data> arguments, your code can benefit from Sub::Exporter.  By writing a
  simple generator, you can let them do this, instead:
  
    use Data::Analyze
      analyze => { tolerance => 0.10, passes => 10, -as => analyze10 },
      analyze => { tolerance => 0.15, passes => 50, -as => analyze50 };
  
    my $value = analyze10($data);
  
  The package with the generator for that would look something like this:
  
    package Data::Analyze;
    use Sub::Exporter -setup => {
      exports => [
        analyze => \&build_analyzer,
      ],
    };
  
    sub build_analyzer {
      my ($class, $name, $arg) = @_;
  
      return sub {
        my $data      = shift;
        my $tolerance = shift || $arg->{tolerance}; 
        my $passes    = shift || $arg->{passes}; 
  
        analyze($data, $tolerance, $passes);
      }
    }
  
  Your module's user now has to do less work to benefit from it -- and remember,
  you're often your own user!  Investing in customized subroutines is an
  investment in future laziness.
  
  This also avoids a common form of ugliness seen in many modules: package-level
  configuration.  That is, you might have seen something like the above
  implemented like so:
  
    use Data::Analyze qw(analyze);
    $Data::Analyze::default_tolerance = 0.10;
    $Data::Analyze::default_passes    = 10;
  
  This might save time, until you have multiple modules using Data::Analyze.
  Because there is only one global configuration, they step on each other's toes
  and your code begins to have mysterious errors.
  
  Generators can also allow you to export class methods to be called as
  subroutines:
  
    package Data::Methodical;
    use Sub::Exporter -setup => { exports => { some_method => \&_curry_class } };
  
    sub _curry_class {
      my ($class, $name) = @_;
      sub { $class->$name(@_); };
    }
  
  Because of the way that exporters and Sub::Exporter work, any package that
  inherits from Data::Methodical can inherit its exporter and override its
  C<some_method>.  If a user imports C<some_method> from that package, he'll
  receive a subroutine that calls the method on the subclass, rather than on
  Data::Methodical itself.
  
  =head2 Other Customizations
  
  Building custom routines with generators isn't the only way that Sub::Exporters
  allows the importing code to refine its use of the exported routines.  They may
  also be renamed to avoid naming collisions.
  
  Consider the following code:
  
    # this program determines to which circle of Hell you will be condemned
    use Morality qw(sin virtue); # for calculating viciousness
    use Math::Trig qw(:all);     # for dealing with circles
  
  The programmer has inadvertently imported two C<sin> routines.  The solution,
  in Exporter.pm-based modules, would be to import only one and then call the
  other by its fully-qualified name.  Alternately, the importer could write a
  routine that did so, or could mess about with typeglobs.
  
  How much easier to write:
  
    # this program determines to which circle of Hell you will be condemned
    use Morality qw(virtue), sin => { -as => 'offense' };
    use Math::Trig -all => { -prefix => 'trig_' };
  
  and to have at one's disposal C<offense> and C<trig_sin> -- not to mention
  C<trig_cos> and C<trig_tan>.
  
  =head1 EXPORTER CONFIGURATION
  
  You can configure an exporter for your package by using Sub::Exporter like so:
  
    package Tools;
    use Sub::Exporter
      -setup => { exports => [ qw(function1 function2 function3) ] };
  
  This is the simplest way to use the exporter, and is basically equivalent to
  this:
  
    package Tools;
    use base qw(Exporter);
    our @EXPORT_OK = qw(function1 function2 function3);
  
  Any basic use of Sub::Exporter will look like this:
  
    package Tools;
    use Sub::Exporter -setup => \%config;
  
  The following keys are valid in C<%config>:
  
    exports - a list of routines to provide for exporting; each routine may be
              followed by generator
    groups  - a list of groups to provide for exporting; each must be followed by
              either (a) a list of exports, possibly with arguments for each
              export, or (b) a generator
  
    collectors - a list of names into which values are collected for use in
                 routine generation; each name may be followed by a validator
  
  In addition to the basic options above, a few more advanced options may be
  passed:
  
    into_level - how far up the caller stack to look for a target (default 0)
    into       - an explicit target (package) into which to export routines
  
  In other words: Sub::Exporter installs a C<import> routine which, when called,
  exports routines to the calling namespace.  The C<into> and C<into_level>
  options change where those exported routines are installed.
  
    generator  - a callback used to produce the code that will be installed
                 default: Sub::Exporter::default_generator
  
    installer  - a callback used to install the code produced by the generator
                 default: Sub::Exporter::default_installer
  
  For information on how these callbacks are used, see the documentation for
  C<L</default_generator>> and C<L</default_installer>>.
  
  =head2 Export Configuration
  
  The C<exports> list may be provided as an array reference or a hash reference.
  The list is processed in such a way that the following are equivalent:
  
    { exports => [ qw(foo bar baz), quux => \&quux_generator ] }
  
    { exports =>
      { foo => undef, bar => undef, baz => undef, quux => \&quux_generator } }
  
  Generators are code that return coderefs.  They are called with four
  parameters:
  
    $class - the class whose exporter has been called (the exporting class)
    $name  - the name of the export for which the routine is being build
   \%arg   - the arguments passed for this export
   \%col   - the collections for this import
  
  Given the configuration in the L</SYNOPSIS>, the following C<use> statement:
  
    use Text::Tweaker
      reformat => { -as => 'make_narrow', width => 33 },
      defaults => { eol => 'CR' };
  
  would result in the following call to C<&build_reformatter>:
  
    my $code = build_reformatter(
      'Text::Tweaker',
      'reformat',
      { width => 33 }, # note that -as is not passed in
      { defaults => { eol => 'CR' } },
    );
  
  The returned coderef (C<$code>) would then be installed as C<make_narrow> in the
  calling package.
  
  Instead of providing a coderef in the configuration, a reference to a method
  name may be provided.  This method will then be called on the invocant of the
  C<import> method.  (In this case, we do not pass the C<$class> parameter, as it
  would be redundant.)
  
  =head2 Group Configuration
  
  The C<groups> list can be passed in the same forms as C<exports>.  Groups must
  have values to be meaningful, which may either list exports that make up the
  group (optionally with arguments) or may provide a way to build the group.
  
  The simpler case is the first: a group definition is a list of exports.  Here's
  the example that could go in exporter in the L</SYNOPSIS>.
  
    groups  => {
      default    => [ qw(reformat) ],
      shorteners => [ qw(squish trim) ],
      email_safe => [
        'indent',
        reformat => { -as => 'email_format', width => 72 }
      ],
    },
  
  Groups are imported by specifying their name prefixed be either a dash or a
  colon.  This line of code would import the C<shorteners> group:
  
    use Text::Tweaker qw(-shorteners);
  
  Arguments passed to a group when importing are merged into the groups options
  and passed to any relevant generators.  Groups can contain other groups, but
  looping group structures are ignored.
  
  The other possible value for a group definition, a coderef, allows one
  generator to build several exportable routines simultaneously.  This is useful
  when many routines must share enclosed lexical variables.  The coderef must
  return a hash reference.  The keys will be used as export names and the values
  are the subs that will be exported.
  
  This example shows a simple use of the group generator.
  
    package Data::Crypto;
    use Sub::Exporter -setup => { groups => { cipher => \&build_cipher_group } };
  
    sub build_cipher_group {
      my ($class, $group, $arg) = @_;
      my ($encode, $decode) = build_codec($arg->{secret});
      return { cipher => $encode, decipher => $decode };
    }
  
  The C<cipher> and C<decipher> routines are built in a group because they are
  built together by code which encloses their secret in their environment.
  
  =head3 Default Groups
  
  If a module that uses Sub::Exporter is C<use>d with no arguments, it will try
  to export the group named C<default>.  If that group has not been specifically
  configured, it will be empty, and nothing will happen.
  
  Another group is also created if not defined: C<all>.  The C<all> group
  contains all the exports from the exports list.
  
  =head2 Collector Configuration
  
  The C<collectors> entry in the exporter configuration gives names which, when
  found in the import call, have their values collected and passed to every
  generator.
  
  For example, the C<build_analyzer> generator that we saw above could be
  rewritten as:
  
   sub build_analyzer {
     my ($class, $name, $arg, $col) = @_;
  
     return sub {
       my $data      = shift;
       my $tolerance = shift || $arg->{tolerance} || $col->{defaults}{tolerance}; 
       my $passes    = shift || $arg->{passes}    || $col->{defaults}{passes}; 
  
       analyze($data, $tolerance, $passes);
     }
   }
  
  That would allow the importer to specify global defaults for his imports:
  
    use Data::Analyze
      'analyze',
      analyze  => { tolerance => 0.10, -as => analyze10 },
      analyze  => { tolerance => 0.15, passes => 50, -as => analyze50 },
      defaults => { passes => 10 };
  
    my $A = analyze10($data);     # equivalent to analyze($data, 0.10, 10);
    my $C = analyze50($data);     # equivalent to analyze($data, 0.15, 50);
    my $B = analyze($data, 0.20); # equivalent to analyze($data, 0.20, 10);
  
  If values are provided in the C<collectors> list during exporter setup, they
  must be code references, and are used to validate the importer's values.  The
  validator is called when the collection is found, and if it returns false, an
  exception is thrown.  We could ensure that no one tries to set a global data
  default easily:
  
    collectors => { defaults => sub { return (exists $_[0]->{data}) ? 0 : 1 } }
  
  Collector coderefs can also be used as hooks to perform arbitrary actions
  before anything is exported.
  
  When the coderef is called, it is passed the value of the collection and a
  hashref containing the following entries:
  
    name        - the name of the collector
    config      - the exporter configuration (hashref)
    import_args - the arguments passed to the exporter, sans collections (aref)
    class       - the package on which the importer was called
    into        - the package into which exports will be exported
  
  Collectors with all-caps names (that is, made up of underscore or capital A
  through Z) are reserved for special use.  The only currently implemented
  special collector is C<INIT>, whose hook (if present in the exporter
  configuration) is always run before any other hook.
  
  =head1 CALLING THE EXPORTER
  
  Arguments to the exporter (that is, the arguments after the module name in a
  C<use> statement) are parsed as follows:
  
  First, the collectors gather any collections found in the arguments.  Any
  reference type may be given as the value for a collector.  For each collection
  given in the arguments, its validator (if any) is called.  
  
  Next, groups are expanded.  If the group is implemented by a group generator,
  the generator is called.  There are two special arguments which, if given to a
  group, have special meaning:
  
    -prefix - a string to prepend to any export imported from this group
    -suffix - a string to append to any export imported from this group
  
  Finally, individual export generators are called and all subs, generated or
  otherwise, are installed in the calling package.  There is only one special
  argument for export generators:
  
    -as     - where to install the exported sub
  
  Normally, C<-as> will contain an alternate name for the routine.  It may,
  however, contain a reference to a scalar.  If that is the case, a reference the
  generated routine will be placed in the scalar referenced by C<-as>.  It will
  not be installed into the calling package.
  
  =head2 Special Exporter Arguments
  
  The generated exporter accept some special options, which may be passed as the
  first argument, in a hashref.
  
  These options are:
  
    into_level
    into
    generator
    installer
  
  These override the same-named configuration options described in L</EXPORTER
  CONFIGURATION>.
  
  =head1 SUBROUTINES
  
  =head2 setup_exporter
  
  This routine builds and installs an C<import> routine.  It is called with one
  argument, a hashref containing the exporter configuration.  Using this, it
  builds an exporter and installs it into the calling package with the name
  "import."  In addition to the normal exporter configuration, a few named
  arguments may be passed in the hashref:
  
    into       - into what package should the exporter be installed
    into_level - into what level up the stack should the exporter be installed
    as         - what name should the installed exporter be given
  
  By default the exporter is installed with the name C<import> into the immediate
  caller of C<setup_exporter>.  In other words, if your package calls
  C<setup_exporter> without providing any of the three above arguments, it will
  have an C<import> routine installed.
  
  Providing both C<into> and C<into_level> will cause an exception to be thrown.
  
  The exporter is built by C<L</build_exporter>>.
  
  =head2 build_exporter
  
  Given a standard exporter configuration, this routine builds and returns an
  exporter -- that is, a subroutine that can be installed as a class method to
  perform exporting on request.
  
  Usually, this method is called by C<L</setup_exporter>>, which then installs
  the exporter as a package's import routine.
  
  =head2 default_generator
  
  This is Sub::Exporter's default generator.  It takes bits of configuration that
  have been gathered during the import and turns them into a coderef that can be
  installed.
  
    my $code = default_generator(\%arg);
  
  Passed arguments are:
  
    class - the class on which the import method was called
    name  - the name of the export being generated
    arg   - the arguments to the generator
    col   - the collections
  
    generator - the generator to be used to build the export (code or scalar ref)
  
  =head2 default_installer
  
  This is Sub::Exporter's default installer.  It does what Sub::Exporter
  promises: it installs code into the target package.
  
    default_installer(\%arg, \@to_export);
  
  Passed arguments are:
  
    into - the package into which exports should be delivered
  
  C<@to_export> is a list of name/value pairs.  The default exporter assigns code
  (the values) to named slots (the names) in the given package.  If the name is a
  scalar reference, the scalar reference is made to point to the code reference
  instead.
  
  =head1 EXPORTS
  
  Sub::Exporter also offers its own exports: the C<setup_exporter> and
  C<build_exporter> routines described above.  It also provides a special "setup"
  collector, which will set up an exporter using the parameters passed to it.
  
  Note that the "setup" collector (seen in examples like the L</SYNOPSIS> above)
  uses C<build_exporter>, not C<setup_exporter>.  This means that the special
  arguments like "into" and "as" for C<setup_exporter> are not accepted here.
  Instead, you may write something like:
  
    use Sub::Exporter
      { into => 'Target::Package' },
      -setup => {
        -as     => 'do_import',
        exports => [ ... ],
      }
    ;
  
  Finding a good reason for wanting to do this is left as an exercise for the
  reader.
  
  =head1 COMPARISONS
  
  There are a whole mess of exporters on the CPAN.  The features included in
  Sub::Exporter set it apart from any existing Exporter.  Here's a summary of
  some other exporters and how they compare.
  
  =over
  
  =item * L<Exporter> and co.
  
  This is the standard Perl exporter.  Its interface is a little clunky, but it's
  fast and ubiquitous.  It can do some things that Sub::Exporter can't:  it can
  export things other than routines, it can import "everything in this group
  except this symbol," and some other more esoteric things.  These features seem
  to go nearly entirely unused.
  
  It always exports things exactly as they appear in the exporting module; it
  can't rename or customize routines.  Its groups ("tags") can't be nested.
  
  L<Exporter::Lite> is a whole lot like Exporter, but it does significantly less:
  it supports exporting symbols, but not groups, pattern matching, or negation.
  
  The fact that Sub::Exporter can't export symbols other than subroutines is
  a good idea, not a missing feature.
  
  For simple uses, setting up Sub::Exporter is about as easy as Exporter.  For
  complex uses, Sub::Exporter makes hard things possible, which would not be
  possible with Exporter. 
  
  When using a module that uses Sub::Exporter, users familiar with Exporter will
  probably see no difference in the basics.  These two lines do about the same
  thing in whether the exporting module uses Exporter or Sub::Exporter.
  
    use Some::Module qw(foo bar baz);
    use Some::Module qw(foo :bar baz);
  
  The definition for exporting in Exporter.pm might look like this:
  
    package Some::Module;
    use base qw(Exporter);
    our @EXPORT_OK   = qw(foo bar baz quux);
    our %EXPORT_TAGS = (bar => [ qw(bar baz) ]);
  
  Using Sub::Exporter, it would look like this:
  
    package Some::Module;
    use Sub::Exporter -setup => {
      exports => [ qw(foo bar baz quux) ],
      groups  => { bar => [ qw(bar baz) ]}
    };
  
  Sub::Exporter respects inheritance, so that a package may export inherited
  routines, and will export the most inherited version.  Exporting methods
  without currying away the invocant is a bad idea, but Sub::Exporter allows you
  to do just that -- and anyway, there are other uses for this feature, like
  packages of exported subroutines which use inheritance specifically to allow
  more specialized, but similar, packages.
  
  L<Exporter::Easy> provides a wrapper around the standard Exporter.  It makes it
  simpler to build groups, but doesn't provide any more functionality.  Because
  it is a front-end to Exporter, it will store your exporter's configuration in
  global package variables.
  
  =item * Attribute-Based Exporters
  
  Some exporters use attributes to mark variables to export.  L<Exporter::Simple>
  supports exporting any kind of symbol, and supports groups.  Using a module
  like Exporter or Sub::Exporter, it's easy to look at one place and see what is
  exported, but it's impossible to look at a variable definition and see whether
  it is exported by that alone.  Exporter::Simple makes this trade in reverse:
  each variable's declaration includes its export definition, but there is no one
  place to look to find a manifest of exports.
  
  More importantly, Exporter::Simple does not add any new features to those of
  Exporter.  In fact, like Exporter::Easy, it is just a front-end to Exporter, so
  it ends up storing its configuration in global package variables.  (This means
  that there is one place to look for your exporter's manifest, actually.  You
  can inspect the C<@EXPORT> package variables, and other related package
  variables, at runtime.)
  
  L<Perl6::Export> isn't actually attribute based, but looks similar.  Its syntax
  is borrowed from Perl 6, and implemented by a source filter.  It is a prototype
  of an interface that is still being designed.  It should probably be avoided
  for production work.  On the other hand, L<Perl6::Export::Attrs> implements
  Perl 6-like exporting, but translates it into Perl 5 by providing attributes.
  
  =item * Other Exporters
  
  L<Exporter::Renaming> wraps the standard Exporter to allow it to export symbols
  with changed names.
  
  L<Class::Exporter> performs a special kind of routine generation, giving each
  importing package an instance of your class, and then exporting the instance's
  methods as normal routines.  (Sub::Exporter, of course, can easily emulate this
  behavior, as shown above.)
  
  L<Exporter::Tidy> implements a form of renaming (using its C<_map> argument)
  and of prefixing, and implements groups.  It also avoids using package
  variables for its configuration.
  
  =back
  
  =head1 TODO
  
  =over
  
  =item * write a set of longer, more demonstrative examples
  
  =item * solidify the "custom exporter" interface (see C<&default_exporter>)
  
  =item * add an "always" group
  
  =back
  
  =head1 THANKS
  
  Hans Dieter Pearcey provided helpful advice while I was writing Sub::Exporter.
  Ian Langworth and Shawn Sorichetti asked some good questions and helped me
  improve my documentation quite a bit.  Yuval Kogman helped me find a bunch of
  little problems.
  
  Thanks, guys! 
  
  =head1 BUGS
  
  Please report any bugs or feature requests through the web interface at
  L<http://rt.cpan.org>. I will be notified, and then you'll automatically be
  notified of progress on your bug as I make changes.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2007 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_EXPORTER

$fatpacked{"Sub/Exporter/Progressive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;
  $Sub::Exporter::Progressive::VERSION = '0.001013';
  use strict;
  use warnings;
  
  # ABSTRACT: Only use Sub::Exporter if you need it
  
  sub _croak {
    require Carp;
    &Carp::croak;
  }
  
  sub import {
     my ($self, @args) = @_;
  
     my $inner_target = caller;
     my $export_data = sub_export_options($inner_target, @args);
  
     my $full_exporter;
     no strict 'refs';
     no warnings 'once';
     @{"${inner_target}::EXPORT_OK"} = @{$export_data->{exports}};
     @{"${inner_target}::EXPORT"} = @{$export_data->{defaults}};
     %{"${inner_target}::EXPORT_TAGS"} = %{$export_data->{tags}};
     *{"${inner_target}::import"} = sub {
        use strict;
        my ($self, @args) = @_;
  
        if ( grep {
           length ref $_
              or
           $_ !~ / \A [:-]? \w+ \z /xm
        } @args ) {
           _croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed'
              unless eval { require Sub::Exporter };
           $full_exporter ||= Sub::Exporter::build_exporter($export_data->{original});
  
           goto $full_exporter;
        } elsif ( defined( (my ($num) = grep { m/^\d/ } @args)[0] ) ) {
           _croak "cannot export symbols with a leading digit: '$num'";
        } else {
           require Exporter;
           s/ \A - /:/xm for @args;
           @_ = ($self, @args);
           goto \&Exporter::import;
        }
     };
     return;
  }
  
  my $too_complicated = <<'DEATH';
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
  
  sub sub_export_options {
     my ($inner_target, $setup, $options) = @_;
  
     my @exports;
     my @defaults;
     my %tags;
  
     if ( ($setup||'') eq '-setup') {
        my %options = %$options;
  
        OPTIONS:
        for my $opt (keys %options) {
           if ($opt eq 'exports') {
  
              _croak $too_complicated if ref $options{exports} ne 'ARRAY';
              @exports = @{$options{exports}};
              _croak $too_complicated if grep { length ref $_ } @exports;
  
           } elsif ($opt eq 'groups') {
              %tags = %{$options{groups}};
              for my $tagset (values %tags) {
                 _croak $too_complicated if grep {
                    length ref $_
                       or
                    $_ =~ / \A - (?! all \b ) /x
                 } @{$tagset};
              }
              @defaults = @{$tags{default} || [] };
           } else {
              _croak $too_complicated;
           }
        }
        @{$_} = map { / \A  [:-] all \z /x ? @exports : $_ } @{$_} for \@defaults, values %tags;
        $tags{all} ||= [ @exports ];
        my %exports = map { $_ => 1 } @exports;
        my @errors = grep { not $exports{$_} } @defaults;
        _croak join(', ', @errors) . " is not exported by the $inner_target module\n" if @errors;
     }
  
     return {
        exports => \@exports,
        defaults => \@defaults,
        original => $options,
        tags => \%tags,
     };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Sub::Exporter::Progressive - Only use Sub::Exporter if you need it
  
  =head1 VERSION
  
  version 0.001013
  
  =head1 SYNOPSIS
  
   package Syntax::Keyword::Gather;
  
   use Sub::Exporter::Progressive -setup => {
     exports => [qw( break gather gathered take )],
     groups => {
       default => [qw( break gather gathered take )],
     },
   };
  
   # elsewhere
  
   # uses Exporter for speed
   use Syntax::Keyword::Gather;
  
   # somewhere else
  
   # uses Sub::Exporter for features
   use Syntax::Keyword::Gather 'gather', take => { -as => 'grab' };
  
  =head1 DESCRIPTION
  
  L<Sub::Exporter> is an incredibly powerful module, but with that power comes
  great responsibility, er- as well as some runtime penalties.  This module
  is a C<Sub::Exporter> wrapper that will let your users just use L<Exporter>
  if all they are doing is picking exports, but use C<Sub::Exporter> if your
  users try to use C<Sub::Exporter>'s more advanced features, like
  renaming exports, if they try to use them.
  
  Note that this module will export C<@EXPORT>, C<@EXPORT_OK> and
  C<%EXPORT_TAGS> package variables for C<Exporter> to work.  Additionally, if
  your package uses advanced C<Sub::Exporter> features like currying, this module
  will only ever use C<Sub::Exporter>, so you might as well use it directly.
  
  =head1 CONTRIBUTORS
  
  ilmari - Dagfinn Ilmari Mannsåker (cpan:ILMARI) <ilmari@ilmari.org>
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  leont - Leon Timmermans (cpan:LEONT) <leont@cpan.org>
  
  =head1 AUTHOR
  
  Arthur Axel "fREW" Schmidt <Sub-Exporter-Progressive@afoolishmanifesto.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Arthur Axel "fREW" Schmidt.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"Sub/Exporter/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_UTIL';
  use strict;
  use warnings;
  package Sub::Exporter::Util;
  {
    $Sub::Exporter::Util::VERSION = '0.987';
  }
  # ABSTRACT: utilities to make Sub::Exporter easier
  
  use Data::OptList ();
  use Params::Util ();
  
  
  sub curry_method {
    my $override_name = shift;
    sub {
      my ($class, $name) = @_;
      $name = $override_name if defined $override_name;
      sub { $class->$name(@_); };
    }
  }
  
  BEGIN { *curry_class = \&curry_method; }
  
  
  sub curry_chain {
    # In the future, we can make \%arg an optional prepend, like the "special"
    # args to the default Sub::Exporter-generated import routine.
    my (@opt_list) = @_;
  
    my $pairs = Data::OptList::mkopt(\@opt_list, 'args', 'ARRAY');
  
    sub {
      my ($class) = @_;
  
      sub {
        my $next = $class;
  
        for my $i (0 .. $#$pairs) {
          my $pair = $pairs->[ $i ];
          
          unless (Params::Util::_INVOCANT($next)) { ## no critic Private
            my $str = defined $next ? "'$next'" : 'undef';
            Carp::croak("can't call $pair->[0] on non-invocant $str")
          }
  
          my ($method, $args) = @$pair;
  
          if ($i == $#$pairs) {
            return $next->$method($args ? @$args : ());
          } else {
            $next = $next->$method($args ? @$args : ());
          }
        }
      };
    }
  }
  
  # =head2 name_map
  # 
  # This utility returns an list to be used in specify export generators.  For
  # example, the following:
  # 
  #   exports => {
  #     name_map(
  #       '_?_gen'  => [ qw(fee fie) ],
  #       '_make_?' => [ qw(foo bar) ],
  #     ),
  #   }
  # 
  # is equivalent to:
  # 
  #   exports => {
  #     name_map(
  #       fee => \'_fee_gen',
  #       fie => \'_fie_gen',
  #       foo => \'_make_foo',
  #       bar => \'_make_bar',
  #     ),
  #   }
  # 
  # This can save a lot of typing, when providing many exports with similarly-named
  # generators.
  # 
  # =cut
  # 
  # sub name_map {
  #   my (%groups) = @_;
  # 
  #   my %map;
  # 
  #   while (my ($template, $names) = each %groups) {
  #     for my $name (@$names) {
  #       (my $export = $template) =~ s/\?/$name/
  #         or Carp::croak 'no ? found in name_map template';
  # 
  #       $map{ $name } = \$export;
  #     }
  #   }
  # 
  #   return %map;
  # }
  
  
  sub merge_col {
    my (%groups) = @_;
  
    my %merged;
  
    while (my ($default_name, $group) = each %groups) {
      while (my ($export_name, $gen) = each %$group) {
        $merged{$export_name} = sub {
          my ($class, $name, $arg, $col) = @_;
  
          my $merged_arg = exists $col->{$default_name}
                         ? { %{ $col->{$default_name} }, %$arg }
                         : $arg;
  
          if (Params::Util::_CODELIKE($gen)) { ## no critic Private
            $gen->($class, $name, $merged_arg, $col);
          } else {
            $class->$$gen($name, $merged_arg, $col);
          }
        }
      }
    }
  
    return %merged;
  }
  
  
  sub __mixin_class_for {
    my ($class, $mix_into) = @_;
    require Package::Generator;
    my $mixin_class = Package::Generator->new_package({
      base => "$class\:\:__mixin__",
    });
  
    ## no critic (ProhibitNoStrict)
    no strict 'refs';
    if (ref $mix_into) {
      unshift @{"$mixin_class" . "::ISA"}, ref $mix_into;
    } else {
      unshift @{"$mix_into" . "::ISA"}, $mixin_class;
    }
    return $mixin_class;
  }
  
  sub mixin_installer {
    sub {
      my ($arg, $to_export) = @_;
  
      my $mixin_class = __mixin_class_for($arg->{class}, $arg->{into});
      bless $arg->{into} => $mixin_class if ref $arg->{into};
  
      Sub::Exporter::default_installer(
        { %$arg, into => $mixin_class },
        $to_export,
      );
    };
  }
  
  sub mixin_exporter {
    Carp::cluck "mixin_exporter is deprecated; use mixin_installer instead; it behaves identically";
    return mixin_installer;
  }
  
  
  sub like {
    sub {
      my ($value, $arg) = @_;
      Carp::croak "no regex supplied to regex group generator" unless $value;
  
      # Oh, qr//, how you bother me!  See the p5p thread from around now about
      # fixing this problem... too bad it won't help me. -- rjbs, 2006-04-25
      my @values = eval { $value->isa('Regexp') } ? ($value, undef)
                 :                                  @$value;
  
      while (my ($re, $opt) = splice @values, 0, 2) {
        Carp::croak "given pattern for regex group generater is not a Regexp"
          unless eval { $re->isa('Regexp') };
        my @exports  = keys %{ $arg->{config}->{exports} };
        my @matching = grep { $_ =~ $re } @exports;
  
        my %merge = $opt ? %$opt : ();
        my $prefix = (delete $merge{-prefix}) || '';
        my $suffix = (delete $merge{-suffix}) || '';
  
        for my $name (@matching) {
          my $as = $prefix . $name . $suffix;
          push @{ $arg->{import_args} }, [ $name => { %merge, -as => $as } ];
        }
      }
  
      1;
    }
  }
  
  use Sub::Exporter -setup => {
    exports => [ qw(
      like
      name_map
      merge_col
      curry_method curry_class
      curry_chain
      mixin_installer mixin_exporter
    ) ]
  };
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Sub::Exporter::Util - utilities to make Sub::Exporter easier
  
  =head1 VERSION
  
  version 0.987
  
  =head1 DESCRIPTION
  
  This module provides a number of utility functions for performing common or
  useful operations when setting up a Sub::Exporter configuration.  All of the
  utilities may be exported, but none are by default.
  
  =head1 THE UTILITIES
  
  =head2 curry_method
  
    exports => {
      some_method => curry_method,
    }
  
  This utility returns a generator which will produce an invocant-curried version
  of a method.  In other words, it will export a method call with the exporting
  class built in as the invocant.
  
  A module importing the code some the above example might do this:
  
    use Some::Module qw(some_method);
  
    my $x = some_method;
  
  This would be equivalent to:
  
    use Some::Module;
  
    my $x = Some::Module->some_method;
  
  If Some::Module is subclassed and the subclass's import method is called to
  import C<some_method>, the subclass will be curried in as the invocant.
  
  If an argument is provided for C<curry_method> it is used as the name of the
  curried method to export.  This means you could export a Widget constructor
  like this:
  
    exports => { widget => curry_method('new') }
  
  This utility may also be called as C<curry_class>, for backwards compatibility.
  
  =head2 curry_chain
  
  C<curry_chain> behaves like C<L</curry_method>>, but is meant for generating
  exports that will call several methods in succession.
  
    exports => {
      reticulate => curry_chain(
        new => gather_data => analyze => [ detail => 100 ] => 'results'
      ),
    }
  
  If imported from Spliner, calling the C<reticulate> routine will be equivalent
  to:
  
    Spliner->new->gather_data->analyze(detail => 100)->results;
  
  If any method returns something on which methods may not be called, the routine
  croaks.
  
  The arguments to C<curry_chain> form an optlist.  The names are methods to be
  called and the arguments, if given, are arrayrefs to be dereferenced and passed
  as arguments to those methods.  C<curry_chain> returns a generator like those
  expected by Sub::Exporter.
  
  B<Achtung!> at present, there is no way to pass arguments from the generated
  routine to the method calls.  This will probably be solved in future revisions
  by allowing the opt list's values to be subroutines that will be called with
  the generated routine's stack.
  
  =head2 merge_col
  
    exports => {
      merge_col(defaults => {
        twiddle => \'_twiddle_gen',
        tweak   => \&_tweak_gen,
      }),
    }
  
  This utility wraps the given generator in one that will merge the named
  collection into its args before calling it.  This means that you can support a
  "default" collector in multiple exports without writing the code each time.
  
  You can specify as many pairs of collection names and generators as you like.
  
  =head2 mixin_installer
  
    use Sub::Exporter -setup => {
      installer => Sub::Exporter::Util::mixin_installer,
      exports   => [ qw(foo bar baz) ],
    };
  
  This utility returns an installer that will install into a superclass and
  adjust the ISA importing class to include the newly generated superclass.
  
  If the target of importing is an object, the hierarchy is reversed: the new
  class will be ISA the object's class, and the object will be reblessed.
  
  B<Prerequisites>: This utility requires that Package::Generator be installed.
  
  =head2 like
  
  It's a collector that adds imports for anything like given regex.
  
  If you provide this configuration:
  
    exports    => [ qw(igrep imap islurp exhausted) ],
    collectors => { -like => Sub::Exporter::Util::like },
  
  A user may import from your module like this:
  
    use Your::Iterator -like => qr/^i/; # imports igre, imap, islurp
  
  or
  
    use Your::Iterator -like => [ qr/^i/ => { -prefix => 'your_' } ];
  
  The group-like prefix and suffix arguments are respected; other arguments are
  passed on to the generators for matching exports.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2007 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_EXPORTER_UTIL

$fatpacked{"Sub/Install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_INSTALL';
  use strict;
  use warnings;
  package Sub::Install;
  # ABSTRACT: install subroutines into packages easily
  $Sub::Install::VERSION = '0.928';
  use Carp;
  use Scalar::Util ();
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   use Sub::Install;
  #pod
  #pod   Sub::Install::install_sub({
  #pod     code => sub { ... },
  #pod     into => $package,
  #pod     as   => $subname
  #pod   });
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This module makes it easy to install subroutines into packages without the
  #pod unsightly mess of C<no strict> or typeglobs lying about where just anyone can
  #pod see them.
  #pod
  #pod =func install_sub
  #pod
  #pod   Sub::Install::install_sub({
  #pod    code => \&subroutine,
  #pod    into => "Finance::Shady",
  #pod    as   => 'launder',
  #pod   });
  #pod
  #pod This routine installs a given code reference into a package as a normal
  #pod subroutine.  The above is equivalent to:
  #pod
  #pod   no strict 'refs';
  #pod   *{"Finance::Shady" . '::' . "launder"} = \&subroutine;
  #pod
  #pod If C<into> is not given, the sub is installed into the calling package.
  #pod
  #pod If C<code> is not a code reference, it is looked for as an existing sub in the
  #pod package named in the C<from> parameter.  If C<from> is not given, it will look
  #pod in the calling package.
  #pod
  #pod If C<as> is not given, and if C<code> is a name, C<as> will default to C<code>.
  #pod If C<as> is not given, but if C<code> is a code ref, Sub::Install will try to
  #pod find the name of the given code ref and use that as C<as>.
  #pod
  #pod That means that this code:
  #pod
  #pod   Sub::Install::install_sub({
  #pod     code => 'twitch',
  #pod     from => 'Person::InPain',
  #pod     into => 'Person::Teenager',
  #pod     as   => 'dance',
  #pod   });
  #pod
  #pod is the same as:
  #pod
  #pod   package Person::Teenager;
  #pod
  #pod   Sub::Install::install_sub({
  #pod     code => Person::InPain->can('twitch'),
  #pod     as   => 'dance',
  #pod   });
  #pod
  #pod =func reinstall_sub
  #pod
  #pod This routine behaves exactly like C<L</install_sub>>, but does not emit a
  #pod warning if warnings are on and the destination is already defined.
  #pod
  #pod =cut
  
  sub _name_of_code {
    my ($code) = @_;
    require B;
    my $name = B::svref_2object($code)->GV->NAME;
    return $name unless $name =~ /\A__ANON__/;
    return;
  }
  
  # See also Params::Util, to which this code was donated.
  sub _CODELIKE {
    (Scalar::Util::reftype($_[0])||'') eq 'CODE'
    || Scalar::Util::blessed($_[0])
    && (overload::Method($_[0],'&{}') ? $_[0] : undef);
  }
  
  # do the heavy lifting
  sub _build_public_installer {
    my ($installer) = @_;
  
    sub {
      my ($arg) = @_;
      my ($calling_pkg) = caller(0);
  
      # I'd rather use ||= but I'm whoring for Devel::Cover.
      for (qw(into from)) { $arg->{$_} = $calling_pkg unless $arg->{$_} }
  
      # This is the only absolutely required argument, in many cases.
      Carp::croak "named argument 'code' is not optional" unless $arg->{code};
  
      if (_CODELIKE($arg->{code})) {
        $arg->{as} ||= _name_of_code($arg->{code});
      } else {
        Carp::croak
          "couldn't find subroutine named $arg->{code} in package $arg->{from}"
          unless my $code = $arg->{from}->can($arg->{code});
  
        $arg->{as}   = $arg->{code} unless $arg->{as};
        $arg->{code} = $code;
      }
  
      Carp::croak "couldn't determine name under which to install subroutine"
        unless $arg->{as};
  
      $installer->(@$arg{qw(into as code) });
    }
  }
  
  # do the ugly work
  
  my $_misc_warn_re;
  my $_redef_warn_re;
  BEGIN {
    $_misc_warn_re = qr/
      Prototype\ mismatch:\ sub\ .+?  |
      Constant subroutine .+? redefined
    /x;
    $_redef_warn_re = qr/Subroutine\ .+?\ redefined/x;
  }
  
  my $eow_re;
  BEGIN { $eow_re = qr/ at .+? line \d+\.\Z/ };
  
  sub _do_with_warn {
    my ($arg) = @_;
    my $code = delete $arg->{code};
    my $wants_code = sub {
      my $code = shift;
      sub {
        my $warn = $SIG{__WARN__} ? $SIG{__WARN__} : sub { warn @_ }; ## no critic
        local $SIG{__WARN__} = sub {
          my ($error) = @_;
          for (@{ $arg->{suppress} }) {
              return if $error =~ $_;
          }
          for (@{ $arg->{croak} }) {
            if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
              Carp::croak $base_error;
            }
          }
          for (@{ $arg->{carp} }) {
            if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
              return $warn->(Carp::shortmess $base_error);
            }
          }
          ($arg->{default} || $warn)->($error);
        };
        $code->(@_);
      };
    };
    return $wants_code->($code) if $code;
    return $wants_code;
  }
  
  sub _installer {
    sub {
      my ($pkg, $name, $code) = @_;
      no strict 'refs'; ## no critic ProhibitNoStrict
      *{"$pkg\::$name"} = $code;
      return $code;
    }
  }
  
  BEGIN {
    *_ignore_warnings = _do_with_warn({
      carp => [ $_misc_warn_re, $_redef_warn_re ]
    });
  
    *install_sub = _build_public_installer(_ignore_warnings(_installer));
  
    *_carp_warnings =  _do_with_warn({
      carp     => [ $_misc_warn_re ],
      suppress => [ $_redef_warn_re ],
    });
  
    *reinstall_sub = _build_public_installer(_carp_warnings(_installer));
  
    *_install_fatal = _do_with_warn({
      code     => _installer,
      croak    => [ $_redef_warn_re ],
    });
  }
  
  #pod =func install_installers
  #pod
  #pod This routine is provided to allow Sub::Install compatibility with
  #pod Sub::Installer.  It installs C<install_sub> and C<reinstall_sub> methods into
  #pod the package named by its argument.
  #pod
  #pod  Sub::Install::install_installers('Code::Builder'); # just for us, please
  #pod  Code::Builder->install_sub({ name => $code_ref });
  #pod
  #pod  Sub::Install::install_installers('UNIVERSAL'); # feeling lucky, punk?
  #pod  Anything::At::All->install_sub({ name => $code_ref });
  #pod
  #pod The installed installers are similar, but not identical, to those provided by
  #pod Sub::Installer.  They accept a single hash as an argument.  The key/value pairs
  #pod are used as the C<as> and C<code> parameters to the C<install_sub> routine
  #pod detailed above.  The package name on which the method is called is used as the
  #pod C<into> parameter.
  #pod
  #pod Unlike Sub::Installer's C<install_sub> will not eval strings into code, but
  #pod will look for named code in the calling package.
  #pod
  #pod =cut
  
  sub install_installers {
    my ($into) = @_;
  
    for my $method (qw(install_sub reinstall_sub)) {
      my $code = sub {
        my ($package, $subs) = @_;
        my ($caller) = caller(0);
        my $return;
        for (my ($name, $sub) = %$subs) {
          $return = Sub::Install->can($method)->({
            code => $sub,
            from => $caller,
            into => $package,
            as   => $name
          });
        }
        return $return;
      };
      install_sub({ code => $code, into => $into, as => $method });
    }
  }
  
  #pod =head1 EXPORTS
  #pod
  #pod Sub::Install exports C<install_sub> and C<reinstall_sub> only if they are
  #pod requested.
  #pod
  #pod =head2 exporter
  #pod
  #pod Sub::Install has a never-exported subroutine called C<exporter>, which is used
  #pod to implement its C<import> routine.  It takes a hashref of named arguments,
  #pod only one of which is currently recognize: C<exports>.  This must be an arrayref
  #pod of subroutines to offer for export.
  #pod
  #pod This routine is mainly for Sub::Install's own consumption.  Instead, consider
  #pod L<Sub::Exporter>.
  #pod
  #pod =cut
  
  sub exporter {
    my ($arg) = @_;
  
    my %is_exported = map { $_ => undef } @{ $arg->{exports} };
  
    sub {
      my $class = shift;
      my $target = caller;
      for (@_) {
        Carp::croak "'$_' is not exported by $class" if !exists $is_exported{$_};
        install_sub({ code => $_, from => $class, into => $target });
      }
    }
  }
  
  BEGIN { *import = exporter({ exports => [ qw(install_sub reinstall_sub) ] }); }
  
  #pod =head1 SEE ALSO
  #pod
  #pod =over
  #pod
  #pod =item L<Sub::Installer>
  #pod
  #pod This module is (obviously) a reaction to Damian Conway's Sub::Installer, which
  #pod does the same thing, but does it by getting its greasy fingers all over
  #pod UNIVERSAL.  I was really happy about the idea of making the installation of
  #pod coderefs less ugly, but I couldn't bring myself to replace the ugliness of
  #pod typeglobs and loosened strictures with the ugliness of UNIVERSAL methods.
  #pod
  #pod =item L<Sub::Exporter>
  #pod
  #pod This is a complete Exporter.pm replacement, built atop Sub::Install.
  #pod
  #pod =back
  #pod
  #pod =head1 EXTRA CREDITS
  #pod
  #pod Several of the tests are adapted from tests that shipped with Damian Conway's
  #pod Sub-Installer distribution.
  #pod
  #pod =cut
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Sub::Install - install subroutines into packages easily
  
  =head1 VERSION
  
  version 0.928
  
  =head1 SYNOPSIS
  
    use Sub::Install;
  
    Sub::Install::install_sub({
      code => sub { ... },
      into => $package,
      as   => $subname
    });
  
  =head1 DESCRIPTION
  
  This module makes it easy to install subroutines into packages without the
  unsightly mess of C<no strict> or typeglobs lying about where just anyone can
  see them.
  
  =head1 FUNCTIONS
  
  =head2 install_sub
  
    Sub::Install::install_sub({
     code => \&subroutine,
     into => "Finance::Shady",
     as   => 'launder',
    });
  
  This routine installs a given code reference into a package as a normal
  subroutine.  The above is equivalent to:
  
    no strict 'refs';
    *{"Finance::Shady" . '::' . "launder"} = \&subroutine;
  
  If C<into> is not given, the sub is installed into the calling package.
  
  If C<code> is not a code reference, it is looked for as an existing sub in the
  package named in the C<from> parameter.  If C<from> is not given, it will look
  in the calling package.
  
  If C<as> is not given, and if C<code> is a name, C<as> will default to C<code>.
  If C<as> is not given, but if C<code> is a code ref, Sub::Install will try to
  find the name of the given code ref and use that as C<as>.
  
  That means that this code:
  
    Sub::Install::install_sub({
      code => 'twitch',
      from => 'Person::InPain',
      into => 'Person::Teenager',
      as   => 'dance',
    });
  
  is the same as:
  
    package Person::Teenager;
  
    Sub::Install::install_sub({
      code => Person::InPain->can('twitch'),
      as   => 'dance',
    });
  
  =head2 reinstall_sub
  
  This routine behaves exactly like C<L</install_sub>>, but does not emit a
  warning if warnings are on and the destination is already defined.
  
  =head2 install_installers
  
  This routine is provided to allow Sub::Install compatibility with
  Sub::Installer.  It installs C<install_sub> and C<reinstall_sub> methods into
  the package named by its argument.
  
   Sub::Install::install_installers('Code::Builder'); # just for us, please
   Code::Builder->install_sub({ name => $code_ref });
  
   Sub::Install::install_installers('UNIVERSAL'); # feeling lucky, punk?
   Anything::At::All->install_sub({ name => $code_ref });
  
  The installed installers are similar, but not identical, to those provided by
  Sub::Installer.  They accept a single hash as an argument.  The key/value pairs
  are used as the C<as> and C<code> parameters to the C<install_sub> routine
  detailed above.  The package name on which the method is called is used as the
  C<into> parameter.
  
  Unlike Sub::Installer's C<install_sub> will not eval strings into code, but
  will look for named code in the calling package.
  
  =head1 EXPORTS
  
  Sub::Install exports C<install_sub> and C<reinstall_sub> only if they are
  requested.
  
  =head2 exporter
  
  Sub::Install has a never-exported subroutine called C<exporter>, which is used
  to implement its C<import> routine.  It takes a hashref of named arguments,
  only one of which is currently recognize: C<exports>.  This must be an arrayref
  of subroutines to offer for export.
  
  This routine is mainly for Sub::Install's own consumption.  Instead, consider
  L<Sub::Exporter>.
  
  =head1 SEE ALSO
  
  =over
  
  =item L<Sub::Installer>
  
  This module is (obviously) a reaction to Damian Conway's Sub::Installer, which
  does the same thing, but does it by getting its greasy fingers all over
  UNIVERSAL.  I was really happy about the idea of making the installation of
  coderefs less ugly, but I couldn't bring myself to replace the ugliness of
  typeglobs and loosened strictures with the ugliness of UNIVERSAL methods.
  
  =item L<Sub::Exporter>
  
  This is a complete Exporter.pm replacement, built atop Sub::Install.
  
  =back
  
  =head1 EXTRA CREDITS
  
  Several of the tests are adapted from tests that shipped with Damian Conway's
  Sub-Installer distribution.
  
  =head1 AUTHOR
  
  Ricardo SIGNES <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2005 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_INSTALL

$fatpacked{"Test/Specio.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_SPECIO';
  package Test::Specio;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.42';
  
  use B ();
  use IO::File;
  use Scalar::Util qw( blessed looks_like_number openhandle );
  use Specio::Library::Builtins;
  use Specio::Library::Numeric;
  use Specio::Library::Perl;
  use Specio::Library::String;
  
  # Loading this will force subification to use Sub::Quote, which can expose
  # some bugs.
  use Sub::Quote;
  use Test::Fatal;
  use Test::More 0.96;
  use Try::Tiny;
  
  use Exporter qw( import );
  
  our $ZERO    = 0;
  our $ONE     = 1;
  our $INT     = 100;
  our $NEG_INT = -100;
  our $NUM     = 42.42;
  our $NEG_NUM = -42.42;
  
  our $EMPTY_STRING  = q{};
  our $STRING        = 'foo';
  our $NUM_IN_STRING = 'has 42 in it';
  our $INT_WITH_NL1  = "1\n";
  our $INT_WITH_NL2  = "\n1";
  
  our $SCALAR_REF = do {
      ## no critic (Variables::ProhibitUnusedVariables)
      \( my $var );
  };
  our $SCALAR_REF_REF = \$SCALAR_REF;
  our $ARRAY_REF      = [];
  our $HASH_REF       = {};
  our $CODE_REF       = sub { };
  
  our $GLOB_REF = \*GLOB;
  
  our $FH;
  ## no critic (InputOutput::RequireBriefOpen)
  open $FH, '<', $INC{'Test/Specio.pm'}
      or die "Could not open $INC{'Test/Specio.pm'} for the test";
  
  our $FH_OBJECT = IO::File->new( $INC{'Test/Specio.pm'}, 'r' )
      or die "Could not open $INC{'Test/Specio.pm'} for the test";
  
  our $REGEX      = qr/../;
  our $REGEX_OBJ  = bless qr/../, 'BlessedQR';
  our $FAKE_REGEX = bless {}, 'Regexp';
  
  our $OBJECT = bless {}, 'FakeObject';
  
  our $UNDEF = undef;
  
  ## no critic (Modules::ProhibitMultiplePackages)
  {
      package _T::Thing;
  
      sub foo { }
  }
  
  our $CLASS_NAME = '_T::Thing';
  
  {
      package _T::BoolOverload;
  
      use overload
          'bool' => sub { ${ $_[0] } },
          fallback => 0;
  
      sub new {
          my $bool = $_[1];
          bless \$bool, __PACKAGE__;
      }
  }
  
  our $BOOL_OVERLOAD_TRUE  = _T::BoolOverload->new(1);
  our $BOOL_OVERLOAD_FALSE = _T::BoolOverload->new(0);
  
  {
      package _T::StrOverload;
  
      use overload
          q{""} => sub { ${ $_[0] } },
          fallback => 0;
  
      sub new {
          my $str = $_[1];
          bless \$str, __PACKAGE__;
      }
  }
  
  our $STR_OVERLOAD_EMPTY      = _T::StrOverload->new(q{});
  our $STR_OVERLOAD_FULL       = _T::StrOverload->new('full');
  our $STR_OVERLOAD_CLASS_NAME = _T::StrOverload->new('_T::StrOverload');
  
  {
      package _T::NumOverload;
  
      use overload
          '0+' => sub { ${ $_[0] } },
          '+'  => sub { ${ $_[0] } + $_[1] },
          fallback => 0;
  
      sub new {
          my $num = $_[1];
          bless \$num, __PACKAGE__;
      }
  }
  
  our $NUM_OVERLOAD_ZERO        = _T::NumOverload->new(0);
  our $NUM_OVERLOAD_ONE         = _T::NumOverload->new(1);
  our $NUM_OVERLOAD_NEG         = _T::NumOverload->new(-42);
  our $NUM_OVERLOAD_DECIMAL     = _T::NumOverload->new(42.42);
  our $NUM_OVERLOAD_NEG_DECIMAL = _T::NumOverload->new(42.42);
  
  {
      package _T::CodeOverload;
  
      use overload
          '&{}' => sub { ${ $_[0] } },
          fallback => 0;
  
      sub new {
          my $code = $_[1];
          bless \$code, __PACKAGE__;
      }
  }
  
  our $CODE_OVERLOAD = _T::CodeOverload->new( sub { } );
  
  {
      package _T::RegexOverload;
  
      use overload
          'qr' => sub { ${ $_[0] } },
          fallback => 0;
  
      sub new {
          my $regex = $_[1];
          bless \$regex, __PACKAGE__;
      }
  }
  
  our $REGEX_OVERLOAD = _T::RegexOverload->new(qr/foo/);
  
  {
      package _T::GlobOverload;
  
      use overload
          '*{}' => sub { ${ $_[0] } },
          fallback => 0;
  
      sub new {
          my $glob = $_[1];
          bless \$glob, __PACKAGE__;
      }
  }
  
  {
      package _T::ScalarOverload;
  
      use overload
          '${}' => sub { $_[0][0] },
          fallback => 0;
  
      sub new {
          my $scalar = $_[1];
          bless [$scalar], __PACKAGE__;
      }
  }
  
  our $SCALAR_OVERLOAD = _T::ScalarOverload->new('x');
  
  {
      package _T::ArrayOverload;
  
      use overload
          '@{}' => sub { $_[0]{array} },
          fallback => 0;
  
      sub new {
          my $array = $_[1];
          bless { array => $array }, __PACKAGE__;
      }
  }
  
  our $ARRAY_OVERLOAD = _T::ArrayOverload->new( [ 1, 2, 3 ] );
  
  {
      package _T::HashOverload;
  
      use overload
          '%{}' => sub { $_[0][0] },
          fallback => 0;
  
      sub new {
          my $hash = $_[1];
  
          # We use an array-based object so we make sure we test hash
          # overloading as opposed to just treating the object as a hash.
          bless [$hash], __PACKAGE__;
      }
  }
  
  our $HASH_OVERLOAD = _T::HashOverload->new( { x => 42, y => 84 } );
  
  my @vars;
  
  BEGIN {
      open my $fh, '<', $INC{'Test/Specio.pm'} or die $!;
      while (<$fh>) {
          push @vars, $1 if /^our (\$[A-Z0-9_]+)(?: +=|;)/;
      }
  }
  
  our @EXPORT_OK = ( @vars, qw( builtins_tests describe test_constraint ) );
  our %EXPORT_TAGS = ( vars => \@vars );
  
  sub builtins_tests {
      my $GLOB             = shift;
      my $GLOB_OVERLOAD    = shift;
      my $GLOB_OVERLOAD_FH = shift;
  
      return {
          Item => {
              accept => [
                  $ZERO,
                  $ONE,
                  $BOOL_OVERLOAD_TRUE,
                  $BOOL_OVERLOAD_FALSE,
                  $INT,
                  $NEG_INT,
                  $NUM,
                  $NEG_NUM,
                  $NUM_OVERLOAD_ZERO,
                  $NUM_OVERLOAD_ONE,
                  $NUM_OVERLOAD_NEG,
                  $NUM_OVERLOAD_NEG_DECIMAL,
                  $NUM_OVERLOAD_DECIMAL,
                  $EMPTY_STRING,
                  $STRING,
                  $NUM_IN_STRING,
                  $STR_OVERLOAD_EMPTY,
                  $STR_OVERLOAD_FULL,
                  $INT_WITH_NL1,
                  $INT_WITH_NL2,
                  $SCALAR_REF,
                  $SCALAR_REF_REF,
                  $SCALAR_OVERLOAD,
                  $ARRAY_REF,
                  $ARRAY_OVERLOAD,
                  $HASH_REF,
                  $HASH_OVERLOAD,
                  $CODE_REF,
                  $CODE_OVERLOAD,
                  $GLOB,
                  $GLOB_REF,
                  $GLOB_OVERLOAD,
                  $GLOB_OVERLOAD_FH,
                  $FH,
                  $FH_OBJECT,
                  $REGEX,
                  $REGEX_OBJ,
                  $REGEX_OVERLOAD,
                  $FAKE_REGEX,
                  $OBJECT,
                  $UNDEF,
              ],
          },
          Defined => {
              accept => [
                  $ZERO,
                  $ONE,
                  $BOOL_OVERLOAD_TRUE,
                  $BOOL_OVERLOAD_FALSE,
                  $INT,
                  $NEG_INT,
                  $NUM,
                  $NEG_NUM,
                  $NUM_OVERLOAD_ZERO,
                  $NUM_OVERLOAD_ONE,
                  $NUM_OVERLOAD_NEG,
                  $NUM_OVERLOAD_NEG_DECIMAL,
                  $NUM_OVERLOAD_DECIMAL,
                  $EMPTY_STRING,
                  $STRING,
                  $NUM_IN_STRING,
                  $STR_OVERLOAD_EMPTY,
                  $STR_OVERLOAD_FULL,
                  $INT_WITH_NL1,
                  $INT_WITH_NL2,
                  $SCALAR_REF,
                  $SCALAR_REF_REF,
                  $SCALAR_OVERLOAD,
                  $ARRAY_REF,
                  $ARRAY_OVERLOAD,
                  $HASH_REF,
                  $HASH_OVERLOAD,
                  $CODE_REF,
                  $CODE_OVERLOAD,
                  $GLOB,
                  $GLOB_REF,
                  $GLOB_OVERLOAD,
                  $GLOB_OVERLOAD_FH,
                  $FH,
                  $FH_OBJECT,
                  $REGEX,
                  $REGEX_OBJ,
                  $REGEX_OVERLOAD,
                  $FAKE_REGEX,
                  $OBJECT,
              ],
              reject => [
                  $UNDEF,
              ],
          },
          Undef => {
              accept => [
                  $UNDEF,
              ],
              reject => [
                  $ZERO,
                  $ONE,
                  $BOOL_OVERLOAD_TRUE,
                  $BOOL_OVERLOAD_FALSE,
                  $INT,
                  $NEG_INT,
                  $NUM,
                  $NEG_NUM,
                  $NUM_OVERLOAD_ZERO,
                  $NUM_OVERLOAD_ONE,
                  $NUM_OVERLOAD_NEG,
                  $NUM_OVERLOAD_NEG_DECIMAL,
                  $NUM_OVERLOAD_DECIMAL,
                  $EMPTY_STRING,
                  $STRING,
                  $NUM_IN_STRING,
                  $STR_OVERLOAD_EMPTY,
                  $STR_OVERLOAD_FULL,
                  $INT_WITH_NL1,
                  $INT_WITH_NL2,
                  $SCALAR_REF,
                  $SCALAR_REF_REF,
                  $SCALAR_OVERLOAD,
                  $ARRAY_REF,
                  $ARRAY_OVERLOAD,
                  $HASH_REF,
                  $HASH_OVERLOAD,
                  $CODE_REF,
                  $CODE_OVERLOAD,
                  $GLOB,
                  $GLOB_REF,
                  $GLOB_OVERLOAD,
                  $GLOB_OVERLOAD_FH,
                  $FH,
                  $FH_OBJECT,
                  $REGEX,
                  $REGEX_OBJ,
                  $REGEX_OVERLOAD,
                  $FAKE_REGEX,
                  $OBJECT,
              ],
          },
          Bool => {
              accept => [
                  $ZERO,
                  $ONE,
                  $BOOL_OVERLOAD_TRUE,
                  $BOOL_OVERLOAD_FALSE,
                  $EMPTY_STRING,
                  $UNDEF,
              ],
              reject => [
                  $INT,
                  $NEG_INT,
                  $NUM,
                  $NEG_NUM,
                  $NUM_OVERLOAD_ZERO,
                  $NUM_OVERLOAD_ONE,
                  $NUM_OVERLOAD_NEG,
                  $NUM_OVERLOAD_NEG_DECIMAL,
                  $NUM_OVERLOAD_DECIMAL,
                  $STRING,
                  $NUM_IN_STRING,
                  $STR_OVERLOAD_EMPTY,
                  $STR_OVERLOAD_FULL,
                  $INT_WITH_NL1,
                  $INT_WITH_NL2,
                  $SCALAR_REF,
                  $SCALAR_REF_REF,
                  $SCALAR_OVERLOAD,
                  $ARRAY_REF,
                  $ARRAY_OVERLOAD,
                  $HASH_REF,
                  $HASH_OVERLOAD,
                  $CODE_REF,
                  $CODE_OVERLOAD,
                  $GLOB,
                  $GLOB_REF,
                  $GLOB_OVERLOAD,
                  $GLOB_OVERLOAD_FH,
                  $FH,
                  $FH_OBJECT,
                  $REGEX,
                  $REGEX_OBJ,
                  $REGEX_OVERLOAD,
                  $FAKE_REGEX,
                  $OBJECT,
              ],
          },
          Maybe => {
              accept => [
                  $ZERO,
                  $ONE,
                  $BOOL_OVERLOAD_TRUE,
                  $BOOL_OVERLOAD_FALSE,
                  $INT,
                  $NEG_INT,
                  $NUM,
                  $NEG_NUM,
                  $NUM_OVERLOAD_ZERO,
                  $NUM_OVERLOAD_ONE,
                  $NUM_OVERLOAD_NEG,
                  $NUM_OVERLOAD_NEG_DECIMAL,
                  $NUM_OVERLOAD_DECIMAL,
                  $EMPTY_STRING,
                  $STRING,
                  $NUM_IN_STRING,
                  $STR_OVERLOAD_EMPTY,
                  $STR_OVERLOAD_FULL,
                  $INT_WITH_NL1,
                  $INT_WITH_NL2,
                  $SCALAR_REF,
                  $SCALAR_REF_REF,
                  $SCALAR_OVERLOAD,
                  $ARRAY_REF,
                  $ARRAY_OVERLOAD,
                  $HASH_REF,
                  $HASH_OVERLOAD,
                  $CODE_REF,
                  $CODE_OVERLOAD,
                  $GLOB,
                  $GLOB_REF,
                  $GLOB_OVERLOAD,
                  $GLOB_OVERLOAD_FH,
                  $FH,
                  $FH_OBJECT,
                  $REGEX,
                  $REGEX_OBJ,
                  $REGEX_OVERLOAD,
                  $FAKE_REGEX,
                  $OBJECT,
                  $UNDEF,
              ],
          },
          Value => {
              accept => [
                  $ZERO,
                  $ONE,
                  $INT,
                  $NEG_INT,
                  $NUM,
                  $NEG_NUM,
                  $EMPTY_STRING,
                  $STRING,
                  $NUM_IN_STRING,
                  $INT_WITH_NL1,
                  $INT_WITH_NL2,
                  $GLOB,
              ],
              reject => [
                  $BOOL_OVERLOAD_TRUE,
                  $BOOL_OVERLOAD_FALSE,
                  $STR_OVERLOAD_EMPTY,
                  $STR_OVERLOAD_FULL,
                  $NUM_OVERLOAD_ZERO,
                  $NUM_OVERLOAD_ONE,
                  $NUM_OVERLOAD_NEG,
                  $NUM_OVERLOAD_NEG_DECIMAL,
                  $NUM_OVERLOAD_DECIMAL,
                  $SCALAR_REF,
                  $SCALAR_REF_REF,
                  $SCALAR_OVERLOAD,
                  $ARRAY_REF,
                  $ARRAY_OVERLOAD,
                  $HASH_REF,
                  $HASH_OVERLOAD,
                  $CODE_REF,
                  $CODE_OVERLOAD,
                  $GLOB_REF,
                  $GLOB_OVERLOAD,
                  $GLOB_OVERLOAD_FH,
                  $FH,
                  $FH_OBJECT,
                  $REGEX,
                  $REGEX_OBJ,
                  $REGEX_OVERLOAD,
                  $FAKE_REGEX,
                  $OBJECT,
                  $UNDEF,
              ],
          },
          Ref => {
              accept => [
                  $BOOL_OVERLOAD_TRUE,
                  $BOOL_OVERLOAD_FALSE,
                  $STR_OVERLOAD_EMPTY,
                  $STR_OVERLOAD_FULL,
                  $NUM_OVERLOAD_ZERO,
                  $NUM_OVERLOAD_ONE,
                  $NUM_OVERLOAD_NEG,
                  $NUM_OVERLOAD_NEG_DECIMAL,
                  $NUM_OVERLOAD_DECIMAL,
                  $SCALAR_REF,
                  $SCALAR_REF_REF,
                  $SCALAR_OVERLOAD,
                  $ARRAY_REF,
                  $ARRAY_OVERLOAD,
                  $HASH_REF,
                  $HASH_OVERLOAD,
                  $CODE_REF,
                  $CODE_OVERLOAD,
                  $GLOB_REF,
                  $GLOB_OVERLOAD,
                  $GLOB_OVERLOAD_FH,
                  $FH,
                  $FH_OBJECT,
                  $REGEX,
                  $REGEX_OBJ,
                  $REGEX_OVERLOAD,
                  $FAKE_REGEX,
                  $OBJECT,
              ],
              reject => [
                  $ZERO,
                  $ONE,
                  $INT,
                  $NEG_INT,
                  $NUM,
                  $NEG_NUM,
                  $EMPTY_STRING,
                  $STRING,
                  $NUM_IN_STRING,
                  $INT_WITH_NL1,
                  $INT_WITH_NL2,
                  $GLOB,
                  $UNDEF,
              ],
          },
          Num => {
              accept => [
                  $ZERO,
                  $ONE,
                  $INT,
                  $NEG_INT,
                  $NUM,
                  $NEG_NUM,
                  $NUM_OVERLOAD_ZERO,
                  $NUM_OVERLOAD_ONE,
                  $NUM_OVERLOAD_NEG,
                  $NUM_OVERLOAD_NEG_DECIMAL,
                  $NUM_OVERLOAD_DECIMAL,
                  qw(
                      1e10
                      1e-10
                      1.23456e10
                      1.23456e-10
                      1e10
                      1e-10
                      1.23456e10
                      1.23456e-10
                      -1e10
                      -1e-10
                      -1.23456e10
                      -1.23456e-10
                      -1e10
                      -1e-10
                      -1.23456e10
                      -1.23456e-10
                      -1e+10
                      1E10
                      ),
              ],
              reject => [
                  $BOOL_OVERLOAD_TRUE,
                  $BOOL_OVERLOAD_FALSE,
                  $EMPTY_STRING,
                  $STRING,
                  $NUM_IN_STRING,
                  $STR_OVERLOAD_EMPTY,
                  $STR_OVERLOAD_FULL,
                  $SCALAR_REF,
                  $SCALAR_REF_REF,
                  $SCALAR_OVERLOAD,
                  $ARRAY_REF,
                  $ARRAY_OVERLOAD,
                  $HASH_REF,
                  $HASH_OVERLOAD,
                  $CODE_REF,
                  $CODE_OVERLOAD,
                  $GLOB,
                  $GLOB_REF,
                  $GLOB_OVERLOAD,
                  $GLOB_OVERLOAD_FH,
                  $FH,
                  $FH_OBJECT,
                  $INT_WITH_NL1,
                  $INT_WITH_NL2,
                  $REGEX,
                  $REGEX_OBJ,
                  $REGEX_OVERLOAD,
                  $FAKE_REGEX,
                  $OBJECT,
                  $UNDEF,
              ],
          },
          Int => {
              accept => [
                  $ZERO,
                  $ONE,
                  $INT,
                  $NEG_INT,
                  $NUM_OVERLOAD_ZERO,
                  $NUM_OVERLOAD_ONE,
                  $NUM_OVERLOAD_NEG,
                  qw(
                      1e20
                      1e100
                      -1e10
                      -1e+10
                      1E20
                      ),
              ],
              reject => [
                  $BOOL_OVERLOAD_TRUE,
                  $BOOL_OVERLOAD_FALSE,
                  $NUM,
                  $NEG_NUM,
                  $NUM_OVERLOAD_NEG_DECIMAL,
                  $NUM_OVERLOAD_DECIMAL,
                  $EMPTY_STRING,
                  $STRING,
                  $NUM_IN_STRING,
                  $STR_OVERLOAD_EMPTY,
                  $STR_OVERLOAD_FULL,
                  $INT_WITH_NL1,
                  $INT_WITH_NL2,
                  $SCALAR_REF,
                  $SCALAR_REF_REF,
                  $SCALAR_OVERLOAD,
                  $ARRAY_REF,
                  $ARRAY_OVERLOAD,
                  $HASH_REF,
                  $HASH_OVERLOAD,
                  $CODE_REF,
                  $CODE_OVERLOAD,
                  $GLOB,
                  $GLOB_REF,
                  $GLOB_OVERLOAD,
                  $GLOB_OVERLOAD_FH,
                  $FH,
                  $FH_OBJECT,
                  $REGEX,
                  $REGEX_OBJ,
                  $REGEX_OVERLOAD,
                  $FAKE_REGEX,
                  $OBJECT,
                  $UNDEF,
                  qw(
                      1e-10
                      -1e-10
                      1.23456e10
                      1.23456e-10
                      -1.23456e10
                      -1.23456e-10
                      -1.23456e+10
                      ),
              ],
          },
          Str => {
              accept => [
                  $ZERO,
                  $ONE,
                  $INT,
                  $NEG_INT,
                  $NUM,
                  $NEG_NUM,
                  $EMPTY_STRING,
                  $STRING,
                  $NUM_IN_STRING,
                  $STR_OVERLOAD_EMPTY,
                  $STR_OVERLOAD_FULL,
                  $INT_WITH_NL1,
                  $INT_WITH_NL2,
              ],
              reject => [
                  $BOOL_OVERLOAD_TRUE,
                  $BOOL_OVERLOAD_FALSE,
                  $NUM_OVERLOAD_ZERO,
                  $NUM_OVERLOAD_ONE,
                  $NUM_OVERLOAD_NEG,
                  $NUM_OVERLOAD_NEG_DECIMAL,
                  $NUM_OVERLOAD_DECIMAL,
                  $SCALAR_REF,
                  $SCALAR_REF_REF,
                  $SCALAR_OVERLOAD,
                  $ARRAY_REF,
                  $ARRAY_OVERLOAD,
                  $HASH_REF,
                  $HASH_OVERLOAD,
                  $CODE_REF,
                  $CODE_OVERLOAD,
                  $GLOB,
                  $GLOB_REF,
                  $GLOB_OVERLOAD,
                  $GLOB_OVERLOAD_FH,
                  $FH,
                  $FH_OBJECT,
                  $REGEX,
                  $REGEX_OBJ,
                  $REGEX_OVERLOAD,
                  $FAKE_REGEX,
                  $OBJECT,
                  $UNDEF,
              ],
          },
          ScalarRef => {
              accept => [
                  $SCALAR_REF,
                  $SCALAR_REF_REF,
                  $SCALAR_OVERLOAD,
              ],
              reject => [
                  $ZERO,
                  $ONE,
                  $BOOL_OVERLOAD_TRUE,
                  $BOOL_OVERLOAD_FALSE,
                  $INT,
                  $NEG_INT,
                  $NUM,
                  $NEG_NUM,
                  $NUM_OVERLOAD_ZERO,
                  $NUM_OVERLOAD_ONE,
                  $NUM_OVERLOAD_NEG,
                  $NUM_OVERLOAD_NEG_DECIMAL,
                  $NUM_OVERLOAD_DECIMAL,
                  $EMPTY_STRING,
                  $STRING,
                  $NUM_IN_STRING,
                  $STR_OVERLOAD_EMPTY,
                  $STR_OVERLOAD_FULL,
                  $INT_WITH_NL1,
                  $INT_WITH_NL2,
                  $ARRAY_REF,
                  $ARRAY_OVERLOAD,
                  $HASH_REF,
                  $HASH_OVERLOAD,
                  $CODE_REF,
                  $CODE_OVERLOAD,
                  $GLOB,
                  $GLOB_REF,
                  $GLOB_OVERLOAD,
                  $GLOB_OVERLOAD_FH,
                  $FH,
                  $FH_OBJECT,
                  $REGEX,
                  $REGEX_OBJ,
                  $REGEX_OVERLOAD,
                  $FAKE_REGEX,
                  $OBJECT,
                  $UNDEF,
              ],
          },
          ArrayRef => {
              accept => [
                  $ARRAY_REF,
                  $ARRAY_OVERLOAD,
              ],
              reject => [
                  $ZERO,
                  $ONE,
                  $BOOL_OVERLOAD_TRUE,
                  $BOOL_OVERLOAD_FALSE,
                  $INT,
                  $NEG_INT,
                  $NUM,
                  $NEG_NUM,
                  $NUM_OVERLOAD_ZERO,
                  $NUM_OVERLOAD_ONE,
                  $NUM_OVERLOAD_NEG,
                  $NUM_OVERLOAD_NEG_DECIMAL,
                  $NUM_OVERLOAD_DECIMAL,
                  $EMPTY_STRING,
                  $STRING,
                  $NUM_IN_STRING,
                  $STR_OVERLOAD_EMPTY,
                  $STR_OVERLOAD_FULL,
                  $INT_WITH_NL1,
                  $INT_WITH_NL2,
                  $SCALAR_REF,
                  $SCALAR_REF_REF,
                  $SCALAR_OVERLOAD,
                  $HASH_REF,
                  $HASH_OVERLOAD,
                  $CODE_REF,
                  $CODE_OVERLOAD,
                  $GLOB,
                  $GLOB_REF,
                  $GLOB_OVERLOAD,
                  $GLOB_OVERLOAD_FH,
                  $FH,
                  $FH_OBJECT,
                  $REGEX,
                  $REGEX_OBJ,
                  $REGEX_OVERLOAD,
                  $FAKE_REGEX,
                  $OBJECT,
                  $UNDEF,
              ],
          },
          HashRef => {
              accept => [
                  $HASH_REF,
                  $HASH_OVERLOAD,
              ],
              reject => [
                  $ZERO,
                  $ONE,
                  $BOOL_OVERLOAD_TRUE,
                  $BOOL_OVERLOAD_FALSE,
                  $INT,
                  $NEG_INT,
                  $NUM,
                  $NEG_NUM,
                  $NUM_OVERLOAD_ZERO,
                  $NUM_OVERLOAD_ONE,
                  $NUM_OVERLOAD_NEG,
                  $NUM_OVERLOAD_NEG_DECIMAL,
                  $NUM_OVERLOAD_DECIMAL,
                  $EMPTY_STRING,
                  $STRING,
                  $NUM_IN_STRING,
                  $STR_OVERLOAD_EMPTY,
                  $STR_OVERLOAD_FULL,
                  $INT_WITH_NL1,
                  $INT_WITH_NL2,
                  $SCALAR_REF,
                  $SCALAR_REF_REF,
                  $SCALAR_OVERLOAD,
                  $ARRAY_REF,
                  $ARRAY_OVERLOAD,
                  $CODE_REF,
                  $CODE_OVERLOAD,
                  $GLOB,
                  $GLOB_REF,
                  $GLOB_OVERLOAD,
                  $GLOB_OVERLOAD_FH,
                  $FH,
                  $FH_OBJECT,
                  $REGEX,
                  $REGEX_OBJ,
                  $REGEX_OVERLOAD,
                  $FAKE_REGEX,
                  $OBJECT,
                  $UNDEF,
              ],
          },
          CodeRef => {
              accept => [
                  $CODE_REF,
                  $CODE_OVERLOAD,
              ],
              reject => [
                  $ZERO,
                  $ONE,
                  $BOOL_OVERLOAD_TRUE,
                  $BOOL_OVERLOAD_FALSE,
                  $INT,
                  $NEG_INT,
                  $NUM,
                  $NEG_NUM,
                  $NUM_OVERLOAD_ZERO,
                  $NUM_OVERLOAD_ONE,
                  $NUM_OVERLOAD_NEG,
                  $NUM_OVERLOAD_NEG_DECIMAL,
                  $NUM_OVERLOAD_DECIMAL,
                  $EMPTY_STRING,
                  $STRING,
                  $NUM_IN_STRING,
                  $STR_OVERLOAD_EMPTY,
                  $STR_OVERLOAD_FULL,
                  $INT_WITH_NL1,
                  $INT_WITH_NL2,
                  $SCALAR_REF,
                  $SCALAR_REF_REF,
                  $SCALAR_OVERLOAD,
                  $ARRAY_REF,
                  $ARRAY_OVERLOAD,
                  $HASH_REF,
                  $HASH_OVERLOAD,
                  $GLOB,
                  $GLOB_REF,
                  $GLOB_OVERLOAD,
                  $GLOB_OVERLOAD_FH,
                  $FH,
                  $FH_OBJECT,
                  $REGEX,
                  $REGEX_OBJ,
                  $REGEX_OVERLOAD,
                  $FAKE_REGEX,
                  $OBJECT,
                  $UNDEF,
              ],
          },
          RegexpRef => {
              accept => [
                  $REGEX,
                  $REGEX_OBJ,
                  $REGEX_OVERLOAD,
              ],
              reject => [
                  $ZERO,
                  $ONE,
                  $BOOL_OVERLOAD_TRUE,
                  $BOOL_OVERLOAD_FALSE,
                  $INT,
                  $NEG_INT,
                  $NUM,
                  $NEG_NUM,
                  $NUM_OVERLOAD_ZERO,
                  $NUM_OVERLOAD_ONE,
                  $NUM_OVERLOAD_NEG,
                  $NUM_OVERLOAD_NEG_DECIMAL,
                  $NUM_OVERLOAD_DECIMAL,
                  $EMPTY_STRING,
                  $STRING,
                  $NUM_IN_STRING,
                  $STR_OVERLOAD_EMPTY,
                  $STR_OVERLOAD_FULL,
                  $INT_WITH_NL1,
                  $INT_WITH_NL2,
                  $SCALAR_REF,
                  $SCALAR_REF_REF,
                  $SCALAR_OVERLOAD,
                  $ARRAY_REF,
                  $ARRAY_OVERLOAD,
                  $HASH_REF,
                  $HASH_OVERLOAD,
                  $CODE_REF,
                  $CODE_OVERLOAD,
                  $GLOB,
                  $GLOB_REF,
                  $GLOB_OVERLOAD,
                  $GLOB_OVERLOAD_FH,
                  $FH,
                  $FH_OBJECT,
                  $OBJECT,
                  $UNDEF,
                  $FAKE_REGEX,
              ],
          },
          GlobRef => {
              accept => [
                  $GLOB_REF,
                  $GLOB_OVERLOAD,
                  $GLOB_OVERLOAD_FH,
                  $FH,
              ],
              reject => [
                  $ZERO,
                  $ONE,
                  $BOOL_OVERLOAD_TRUE,
                  $BOOL_OVERLOAD_FALSE,
                  $INT,
                  $NEG_INT,
                  $NUM,
                  $NEG_NUM,
                  $NUM_OVERLOAD_ZERO,
                  $NUM_OVERLOAD_ONE,
                  $NUM_OVERLOAD_NEG,
                  $NUM_OVERLOAD_NEG_DECIMAL,
                  $NUM_OVERLOAD_DECIMAL,
                  $EMPTY_STRING,
                  $STRING,
                  $NUM_IN_STRING,
                  $STR_OVERLOAD_EMPTY,
                  $STR_OVERLOAD_FULL,
                  $INT_WITH_NL1,
                  $INT_WITH_NL2,
                  $SCALAR_REF,
                  $SCALAR_REF_REF,
                  $SCALAR_OVERLOAD,
                  $ARRAY_REF,
                  $ARRAY_OVERLOAD,
                  $HASH_REF,
                  $HASH_OVERLOAD,
                  $CODE_REF,
                  $CODE_OVERLOAD,
                  $GLOB,
                  $FH_OBJECT,
                  $OBJECT,
                  $REGEX,
                  $REGEX_OBJ,
                  $REGEX_OVERLOAD,
                  $FAKE_REGEX,
                  $UNDEF,
              ],
          },
          FileHandle => {
              accept => [
                  $FH,
                  $FH_OBJECT,
                  $GLOB_OVERLOAD_FH,
              ],
              reject => [
                  $ZERO,
                  $ONE,
                  $BOOL_OVERLOAD_TRUE,
                  $BOOL_OVERLOAD_FALSE,
                  $INT,
                  $NEG_INT,
                  $NUM,
                  $NEG_NUM,
                  $NUM_OVERLOAD_ZERO,
                  $NUM_OVERLOAD_ONE,
                  $NUM_OVERLOAD_NEG,
                  $NUM_OVERLOAD_NEG_DECIMAL,
                  $NUM_OVERLOAD_DECIMAL,
                  $EMPTY_STRING,
                  $STRING,
                  $NUM_IN_STRING,
                  $STR_OVERLOAD_EMPTY,
                  $STR_OVERLOAD_FULL,
                  $INT_WITH_NL1,
                  $INT_WITH_NL2,
                  $SCALAR_REF,
                  $SCALAR_REF_REF,
                  $SCALAR_OVERLOAD,
                  $ARRAY_REF,
                  $ARRAY_OVERLOAD,
                  $HASH_REF,
                  $HASH_OVERLOAD,
                  $CODE_REF,
                  $CODE_OVERLOAD,
                  $GLOB,
                  $GLOB_REF,
                  $GLOB_OVERLOAD,
                  $OBJECT,
                  $REGEX,
                  $REGEX_OBJ,
                  $REGEX_OVERLOAD,
                  $FAKE_REGEX,
                  $UNDEF,
              ],
          },
          Object => {
              accept => [
                  $BOOL_OVERLOAD_TRUE,
                  $BOOL_OVERLOAD_FALSE,
                  $STR_OVERLOAD_EMPTY,
                  $STR_OVERLOAD_FULL,
                  $NUM_OVERLOAD_ZERO,
                  $NUM_OVERLOAD_ONE,
                  $NUM_OVERLOAD_NEG,
                  $NUM_OVERLOAD_NEG_DECIMAL,
                  $NUM_OVERLOAD_DECIMAL,
                  $CODE_OVERLOAD,
                  $FH_OBJECT,
                  $REGEX,
                  $REGEX_OBJ,
                  $REGEX_OVERLOAD,
                  $FAKE_REGEX,
                  $GLOB_OVERLOAD,
                  $GLOB_OVERLOAD_FH,
                  $SCALAR_OVERLOAD,
                  $ARRAY_OVERLOAD,
                  $HASH_OVERLOAD,
                  $OBJECT,
              ],
              reject => [
                  $ZERO,
                  $ONE,
                  $INT,
                  $NEG_INT,
                  $NUM,
                  $NEG_NUM,
                  $EMPTY_STRING,
                  $STRING,
                  $NUM_IN_STRING,
                  $INT_WITH_NL1,
                  $INT_WITH_NL2,
                  $SCALAR_REF,
                  $SCALAR_REF_REF,
                  $ARRAY_REF,
                  $HASH_REF,
                  $CODE_REF,
                  $GLOB,
                  $GLOB_REF,
                  $FH,
                  $UNDEF,
              ],
          },
          ClassName => {
              accept => [
                  $CLASS_NAME,
                  $STR_OVERLOAD_CLASS_NAME,
              ],
              reject => [
                  $ZERO,
                  $ONE,
                  $BOOL_OVERLOAD_TRUE,
                  $BOOL_OVERLOAD_FALSE,
                  $INT,
                  $NEG_INT,
                  $NUM,
                  $NEG_NUM,
                  $NUM_OVERLOAD_ZERO,
                  $NUM_OVERLOAD_ONE,
                  $NUM_OVERLOAD_NEG,
                  $NUM_OVERLOAD_NEG_DECIMAL,
                  $NUM_OVERLOAD_DECIMAL,
                  $EMPTY_STRING,
                  $STRING,
                  $NUM_IN_STRING,
                  $STR_OVERLOAD_EMPTY,
                  $STR_OVERLOAD_FULL,
                  $INT_WITH_NL1,
                  $INT_WITH_NL2,
                  $SCALAR_REF,
                  $SCALAR_REF_REF,
                  $SCALAR_OVERLOAD,
                  $ARRAY_REF,
                  $ARRAY_OVERLOAD,
                  $HASH_REF,
                  $HASH_OVERLOAD,
                  $CODE_REF,
                  $CODE_OVERLOAD,
                  $GLOB,
                  $GLOB_REF,
                  $GLOB_OVERLOAD,
                  $GLOB_OVERLOAD_FH,
                  $FH,
                  $FH_OBJECT,
                  $REGEX,
                  $REGEX_OBJ,
                  $REGEX_OVERLOAD,
                  $FAKE_REGEX,
                  $OBJECT,
                  $UNDEF,
              ],
          },
      };
  }
  
  sub test_constraint {
      my $type      = shift;
      my $tests     = shift;
      my $describer = shift || \&describe;
  
      local $Test::Builder::Level = $Test::Builder::Level + 1;
  
      $type = t($type) unless blessed $type;
  
      subtest(
          ( $type->name || '<anon>' ),
          sub {
              try {
                  my $not_inlined = $type->_constraint_with_parents;
  
                  my $inlined;
                  if ( $type->can_be_inlined ) {
                      $inlined = $type->_generated_inline_sub;
                  }
  
                  for my $accept ( @{ $tests->{accept} || [] } ) {
                      my $described = $describer->($accept);
                      subtest(
                          "accepts $described",
                          sub {
                              ok(
                                  $type->value_is_valid($accept),
                                  'using ->value_is_valid'
                              );
                              is(
                                  exception { $type->($accept) },
                                  undef,
                                  'using subref overloading'
                              );
                              ok(
                                  $not_inlined->($accept),
                                  'using non-inlined constraint'
                              );
                              if ($inlined) {
                                  ok(
                                      $inlined->($accept),
                                      'using inlined constraint'
                                  );
                              }
                          }
                      );
                  }
  
                  for my $reject ( @{ $tests->{reject} || [] } ) {
                      my $described = $describer->($reject);
                      subtest(
                          "rejects $described",
                          sub {
                              ok(
                                  !$type->value_is_valid($reject),
                                  'using ->value_is_valid'
                              );
  
                              # I don't love this test, but there's no way to know the
                              # exact content of each type's validation failure
                              # exception. We can, however, reasonably assume (I think)
                              # that the exception thrown will include a trace starting
                              # with Specio::Exception.
                              like(
                                  exception { $type->($reject) },
                                  qr/\QTrace begun at Specio::Exception->new/,
                                  'using subref overloading'
                              );
                              if ($inlined) {
                                  ok(
                                      !$inlined->($reject),
                                      'using inlined constraint'
                                  );
                              }
                          }
                      );
                  }
              }
              catch {
                  fail('No exception in test_constraint');
                  diag($_);
              };
          }
      );
  }
  
  sub describe {
      my $val = shift;
  
      return 'undef' unless defined $val;
  
      if ( !ref $val ) {
          return q{''} if $val eq q{};
  
          return looks_like_number($val)
              && $val !~ /\n/ ? $val : B::perlstring($val);
      }
  
      return 'open filehandle'
          if openhandle $val && !blessed $val;
  
      if ( blessed $val ) {
          my $desc = ( ref $val ) . ' object';
          if ( $val->isa('_T::StrOverload') ) {
              $desc .= ' (' . describe("$val") . ')';
          }
          elsif ( $val->isa('_T::BoolOverload') ) {
              $desc .= ' (' . ( $val ? 'true' : 'false' ) . ')';
          }
          elsif ( $val->isa('_T::NumOverload') ) {
              $desc .= ' (' . describe( ${$val} ) . ')';
          }
  
          return $desc;
      }
      else {
          return ( ref $val ) . ' reference';
      }
  }
  
  1;
  
  # ABSTRACT: Test helpers for Specio
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test::Specio - Test helpers for Specio
  
  =head1 VERSION
  
  version 0.42
  
  =head1 SYNOPSIS
  
    use Test::Specio qw( test_constraint :vars );
  
    test_constraint(
        t('Foo'), {
            accept => [ 'foo', 'bar' ],
            reject => [ 42,    {}, $EMPTY_STRING, $HASH_REF ],
        }
    );
  
  =head1 DESCRIPTION
  
  This package provides some helper functions and variables for testing Specio
  types.
  
  =head1 EXPORTS
  
  This module provides the following exports:
  
  =head2 test_constraint( $type, $tests, [ $describer ] )
  
  This subroutine accepts two arguments. The first should be a Specio type
  object. The second is hashref which can contain the keys C<accept> and
  C<reject>. Each key should contain an arrayref of values which the type
  accepts or rejects.
  
  The third argument is optional. This is a sub reference which will be called
  to generate a description of the value being tested. This defaults to calling
  this package's C<describe> sub, but you can provide your own.
  
  =head2 describe($value)
  
  Given a value, this subroutine returns a string describing that value in a
  useful way for test output. It know about the various classes used for the
  variables exported by this package and will do something intelligent when such
  a variable.
  
  =head2 builtins_tests( $GLOB, $GLOB_OVERLOAD, $GLOB_OVERLOAD_FH )
  
  This subroutine returns a hashref containing test variables for all builtin
  types. The hashref has a form like this:
  
    {
        Bool => {
            accept => [
                $ZERO,
                $ONE,
                $BOOL_OVERLOAD_TRUE,
                $BOOL_OVERLOAD_FALSE,
                ...,
            ],
            reject => [
                $INT,
                $NEG_INT,
                $NUM,
                $NEG_NUM,
                ...,
                $OBJECT,
            ],
        },
        Maybe => {...},
    }
  
  You need to pass in a glob, an object which overloads globification, and an
  object which overloads globification to return an open filehandle. See below
  for more details on how to create these things.
  
  =head2 Variables
  
  This module also exports many variables containing values which are useful for
  testing constraints. Note that references are always empty unless stated
  otherwise. You can import these variables individually or import all of them
  with the C<:vars> import tag.
  
  =over 4
  
  =item * C<$ZERO>
  
  =item * C<$ONE>
  
  =item * C<$INT>
  
  An arbitrary positive integer.
  
  =item * C<$NEG_INT>
  
  An arbitrary negative integer.
  
  =item * C<$NUM>
  
  An arbitrary positive non-integer number.
  
  =item * C<$NEG_NUM>
  
  An arbitrary negative non-integer number.
  
  =item * C<$EMPTY_STRING>
  
  =item * C<$STRING>
  
  An arbitrary non-empty string.
  
  =item * C<$NUM_IN_STRING>
  
  An arbitrary string which contains a number.
  
  =item * C<$INT_WITH_NL1>
  
  An string containing an integer followed by a newline.
  
  =item * C<$INT_WITH_NL2>
  
  An string containing a newline followed by an integer.
  
  =item * C<$SCALAR_REF>
  
  =item * C<$SCALAR_REF_REF>
  
  A reference containing a reference to a scalar.
  
  =item * C<$ARRAY_REF>
  
  =item * C<$HASH_REF>
  
  =item * C<$CODE_REF>
  
  =item * C<$GLOB_REF>
  
  =item * C<$FH>
  
  An opened filehandle.
  
  =item * C<$FH_OBJECT>
  
  An opened L<IO::File> object.
  
  =item * C<$REGEX>
  
  A regex created with C<qr//>.
  
  =item * C<$REGEX_OBJ>
  
  A regex created with C<qr//> that was then blessed into class.
  
  =item * C<$FAKE_REGEX>
  
  A non-regex blessed into the C<Regexp> class which Perl uses internally for
  C<qr//> objects.
  
  =item * C<$OBJECT>
  
  An arbitrary object.
  
  =item * C<$UNDEF>
  
  =item * C<$CLASS_NAME>
  
  A string containing a loaded package name.
  
  =item * C<$BOOL_OVERLOAD_TRUE>
  
  An object which overloads boolification to return true.
  
  =item * C<$BOOL_OVERLOAD_FALSE>
  
  An object which overloads boolification to return false.
  
  =item * C<$STR_OVERLOAD_EMPTY>
  
  An object which overloads stringification to return an empty string.
  
  =item * C<$STR_OVERLOAD_FULL>
  
  An object which overloads stringification to return a non-empty string.
  
  =item * C<$STR_OVERLOAD_CLASS_NAME>
  
  An object which overloads stringification to return a loaded package name.
  
  =item * C<$NUM_OVERLOAD_ZERO>
  
  =item * C<$NUM_OVERLOAD_ONE>
  
  =item * C<$NUM_OVERLOAD_NEG>
  
  =item * C<$NUM_OVERLOAD_DECIMAL>
  
  =item * C<$NUM_OVERLOAD_NEG_DECIMAL>
  
  =item * C<$CODE_OVERLOAD>
  
  =item * C<$SCALAR_OVERLOAD>
  
  An object which overloads scalar dereferencing to return a non-empty string.
  
  =item * C<$ARRAY_OVERLOAD>
  
  An object which overloads array dereferencing to return a non-empty array.
  
  =item * C<$HASH_OVERLOAD>
  
  An object which overloads hash dereferencing to return a non-empty hash.
  
  =back
  
  =head2 Globs and the _T::GlobOverload package
  
  To create a glob you can pass around for tests, use this code:
  
    my $GLOB = do {
        no warnings 'once';
        *SOME_GLOB;
    };
  
  The C<_T::GlobOverload> package is defined when you load C<Test::Specio> so
  you can create your own glob overloading objects. Such objects cannot be
  exported because the glob they return does not transfer across packages
  properly.
  
  You can create such a variable like this:
  
    local *FOO;
    my $GLOB_OVERLOAD = _T::GlobOverload->new( \*FOO );
  
  If you want to create a glob overloading object that returns a filehandle, do
  this:
  
    local *BAR;
    open BAR, '<', $0 or die "Could not open $0 for the test";
    my $GLOB_OVERLOAD_FH = _T::GlobOverload->new( \*BAR );
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Specio/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Specio can be found at L<https://github.com/houseabsolute/Specio>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 - 2017 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
TEST_SPECIO

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny; # git description: v0.29-2-g3b23a06
  use 5.006;
  # ABSTRACT: Minimal try/catch with proper preservation of $@
  
  our $VERSION = '0.30';
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT = our @EXPORT_OK = qw(try catch finally);
  
  use Carp;
  $Carp::Internal{+__PACKAGE__}++;
  
  BEGIN {
    my $su = $INC{'Sub/Util.pm'} && defined &Sub::Util::set_subname;
    my $sn = $INC{'Sub/Name.pm'} && eval { Sub::Name->VERSION(0.08) };
    unless ($su || $sn) {
      $su = eval { require Sub::Util; } && defined &Sub::Util::set_subname;
      unless ($su) {
        $sn = eval { require Sub::Name; Sub::Name->VERSION(0.08) };
      }
    }
  
    *_subname = $su ? \&Sub::Util::set_subname
              : $sn ? \&Sub::Name::subname
              : sub { $_[1] };
    *_HAS_SUBNAME = ($su || $sn) ? sub(){1} : sub(){0};
  }
  
  my %_finally_guards;
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
    my ( $try, @code_refs ) = @_;
  
    # we need to save this here, the eval block will be in scalar context due
    # to $failed
    my $wantarray = wantarray;
  
    # work around perl bug by explicitly initializing these, due to the likelyhood
    # this will be used in global destruction (perl rt#119311)
    my ( $catch, @finally ) = ();
  
    # find labeled blocks in the argument list.
    # catch and finally tag the blocks by blessing a scalar reference to them.
    foreach my $code_ref (@code_refs) {
  
      if ( ref($code_ref) eq 'Try::Tiny::Catch' ) {
        croak 'A try() may not be followed by multiple catch() blocks'
          if $catch;
        $catch = ${$code_ref};
      } elsif ( ref($code_ref) eq 'Try::Tiny::Finally' ) {
        push @finally, ${$code_ref};
      } else {
        croak(
          'try() encountered an unexpected argument ('
        . ( defined $code_ref ? $code_ref : 'undef' )
        . ') - perhaps a missing semi-colon before or'
        );
      }
    }
  
    # FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
    # not perfect, but we could provide a list of additional errors for
    # $catch->();
  
    # name the blocks if we have Sub::Name installed
    _subname(caller().'::try {...} ' => $try)
      if _HAS_SUBNAME;
  
    # set up scope guards to invoke the finally blocks at the end.
    # this should really be a function scope lexical variable instead of
    # file scope + local but that causes issues with perls < 5.20 due to
    # perl rt#119311
    local $_finally_guards{guards} = [
      map { Try::Tiny::ScopeGuard->_new($_) }
      @finally
    ];
  
    # save the value of $@ so we can set $@ back to it in the beginning of the eval
    # and restore $@ after the eval finishes
    my $prev_error = $@;
  
    my ( @ret, $error );
  
    # failed will be true if the eval dies, because 1 will not be returned
    # from the eval body
    my $failed = not eval {
      $@ = $prev_error;
  
      # evaluate the try block in the correct context
      if ( $wantarray ) {
        @ret = $try->();
      } elsif ( defined $wantarray ) {
        $ret[0] = $try->();
      } else {
        $try->();
      };
  
      return 1; # properly set $failed to false
    };
  
    # preserve the current error and reset the original value of $@
    $error = $@;
    $@ = $prev_error;
  
    # at this point $failed contains a true value if the eval died, even if some
    # destructor overwrote $@ as the eval was unwinding.
    if ( $failed ) {
      # pass $error to the finally blocks
      push @$_, $error for @{$_finally_guards{guards}};
  
      # if we got an error, invoke the catch block.
      if ( $catch ) {
        # This works like given($error), but is backwards compatible and
        # sets $_ in the dynamic scope for the body of C<$catch>
        for ($error) {
          return $catch->($error);
        }
  
        # in case when() was used without an explicit return, the C<for>
        # loop will be aborted and there's no useful return value
      }
  
      return;
    } else {
      # no failure, $@ is back to what it was, everything is fine
      return $wantarray ? @ret : $ret[0];
    }
  }
  
  sub catch (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare catch()' unless wantarray;
  
    _subname(caller().'::catch {...} ' => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Catch'),
      @rest,
    );
  }
  
  sub finally (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare finally()' unless wantarray;
  
    _subname(caller().'::finally {...} ' => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Finally'),
      @rest,
    );
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    use constant UNSTABLE_DOLLARAT => ("$]" < '5.013002') ? 1 : 0;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my ($code, @args) = @{ $_[0] };
  
      local $@ if UNSTABLE_DOLLARAT;
      eval {
        $code->(@args);
        1;
      } or do {
        warn
          "Execution of finally() block $code resulted in an exception, which "
        . '*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. '
        . 'Your program will continue as if this event never took place. '
        . "Original exception text follows:\n\n"
        . (defined $@ ? $@ : '$@ left undefined...')
        . "\n"
        ;
      }
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Try::Tiny - Minimal try/catch with proper preservation of $@
  
  =head1 VERSION
  
  version 0.30
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
    # handle errors with a catch handler
    try {
      die "foo";
    } catch {
      warn "caught error: $_"; # not $@
    };
  
  You can also use it like a standalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
    # just silence errors
    try {
      die "foo";
    };
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the C<try> block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L</BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the C<try> block dies, it returns the value of the last statement executed in
  the C<catch> block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following examples all
  assign C<"bar"> to C<$x>:
  
    my $x = try { die "foo" } catch { "bar" };
    my $x = try { die "foo" } || "bar";
    my $x = (try { die "foo" }) // "bar";
  
    my $x = eval { die "foo" } || "bar";
  
  You can add C<finally> blocks, yielding the following:
  
    my $x;
    try { die 'foo' } finally { $x = 'bar' };
    try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  C<finally> blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many C<finally> blocks to a
  given C<try> block as you like.
  
  Note that adding a C<finally> block without a preceding C<catch> block
  suppresses any errors. This behaviour is consistent with using a standalone
  C<eval>, but it is not consistent with C<try>/C<finally> patterns found in
  other programming languages, such as Java, Python, Javascript or C#. If you
  learnt the C<try>/C<finally> pattern from one of these languages, watch out for
  this.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory C<try> subroutine, an optional C<catch> subroutine and C<finally>
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the C<finally> block, if given, will execute.
  
  =item catch (&;@)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
    catch { ... }
  
  Inside the C<catch> block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
    local $@ = $_;
  
  =item finally (&;@)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. C<finally> blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the C<finally> block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the C<finally> block does not
  localize C<$_> with the error, since unlike in a C<catch> block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the C<finally> block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  Furthermore B<exceptions in C<finally> blocks are not trappable and are unable
  to influence the execution of your program>. This is due to limitation of
  C<DESTROY>-based scope guards, which C<finally> is implemented on top of. This
  may change in a future version of Try::Tiny.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an C<eval> block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically,
  L<before Perl version 5.14.0|perl5140delta/"Exception Handling">
  C<$@> was clobbered at the beginning of the C<eval>, which
  also made it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (the one
  available before entering the C<try> block) in the beginning of the C<eval>
  block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an C<eval> block, C<die> behaves sort of like:
  
    sub die {
      $@ = $_[0];
      return_undef_from_eval();
    }
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
    my $error = do {
      local $@;
      eval { ... };
      $@;
    };
  
    ...
    die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
    if ( $@ ) {
      ...
    }
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode (fixed in L<Perl 5.14.0|perl5140delta/"Exception Handling">) is:
  
    sub Object::DESTROY {
      eval { ... }
    }
  
    eval {
      my $obj = Object->new;
  
      die "foo";
    };
  
    if ( $@ ) {
  
    }
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the C<eval> was aborted due to an error:
  
    my $failed = not eval {
      ...
  
      return 1;
    };
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 ALTERNATE SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements"> (but please don't,
  because that syntax has since been deprecated because there was too much
  unexpected magical behaviour).
  
  =for stopwords topicalizer
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
    try {
      require Foo;
    } catch {
      when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
      default { die $_ }
    };
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  argument list. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
    sub foo {
      my ( $self, @args ) = @_;
      try { $self->bar(@args) }
    }
  
  or
  
    sub bar_in_place {
      my $self = shift;
      my $args = \@_;
      try { $_ = $self->bar($_) for @$args }
    }
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
      try {
        die;
      }
      catch {
        return;
      };
  
      say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
      my $success = try {
        die;
        1;
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
    # OR
    sub parent_sub_with_catch {
      my $success = try {
        die;
        1;
      }
      catch {
        # do something with $_
        return undef; #see note
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
  
  Note that if you have a C<catch> block, it must return C<undef> for this to work,
  since if a C<catch> block exists, its return value is returned in place of C<undef>
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =for stopwords unhygienically
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygienically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
    my $obj = try {
      MightFail->new;
    } catch {
      ...
  
      return; # avoid returning a true value;
    };
  
    return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
    given ($foo) {
      when (...) {
        try {
          ...
        } catch {
          warn $_; # will print $foo, not the error
          warn $_[0]; # instead, get the error like this
        }
      }
    }
  
  Note that this behavior was changed once again in
  L<Perl5 version 18|https://metacpan.org/module/perldelta#given-now-aliases-the-global-_>.
  However, since the entirety of lexical C<$_> is now L<considered experimental
  |https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental>, it
  is unclear whether the new version 18 behavior is final.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul>
  
  Or read the source:
  
  L<http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Try-Tiny>
  (or L<bug-Try-Tiny@rt.cpan.org|mailto:bug-Try-Tiny@rt.cpan.org>).
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Karen Etheridge Peter Rabbitson Ricardo Signes Mark Fowler Graham Knop Lukas Mai Aristotle Pagaltzis Dagfinn Ilmari Mannsåker Paul Howarth Rudolf Leermakers anaxagoras awalker chromatic Alex cm-perl Andrew Yates David Lowe Glenn Hans Dieter Pearcey Jens Berthold Jonathan Yu Marc Mims Stosberg Pali
  
  =over 4
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Mark Fowler <mark@twoshortplanks.com>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Lukas Mai <l.mai@web.de>
  
  =item *
  
  Aristotle Pagaltzis <pagaltzis@gmx.de>
  
  =item *
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =item *
  
  Paul Howarth <paul@city-fan.org>
  
  =item *
  
  Rudolf Leermakers <rudolf@hatsuseno.org>
  
  =item *
  
  anaxagoras <walkeraj@gmail.com>
  
  =item *
  
  awalker <awalker@sourcefire.com>
  
  =item *
  
  chromatic <chromatic@wgz.org>
  
  =item *
  
  Alex <alex@koban.(none)>
  
  =item *
  
  cm-perl <cm-perl@users.noreply.github.com>
  
  =item *
  
  Andrew Yates <ayates@haddock.local>
  
  =item *
  
  David Lowe <davidl@lokku.com>
  
  =item *
  
  Glenn Fowler <cebjyre@cpan.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Jens Berthold <jens@jebecs.de>
  
  =item *
  
  Jonathan Yu <JAWNSY@cpan.org>
  
  =item *
  
  Marc Mims <marc@questright.com>
  
  =item *
  
  Mark Stosberg <mark@stosberg.com>
  
  =item *
  
  Pali <pali@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is Copyright (c) 2009 by יובל קוג'מן (Yuval Kogman).
  
  This is free software, licensed under:
  
    The MIT (X11) License
  
  =cut
TRY_TINY

$fatpacked{"namespace/autoclean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NAMESPACE_AUTOCLEAN';
  use strict;
  use warnings;
  
  package namespace::autoclean; # git description: 0.27-4-g47c7088
  # ABSTRACT: Keep imports out of your namespace
  # KEYWORDS: namespaces clean dirty imports exports subroutines methods development
  
  our $VERSION = '0.28';
  
  use B::Hooks::EndOfScope 0.12;
  use List::Util qw( first );
  use namespace::clean 0.20;
  
  #pod =head1 SYNOPSIS
  #pod
  #pod     package Foo;
  #pod     use namespace::autoclean;
  #pod     use Some::Package qw/imported_function/;
  #pod
  #pod     sub bar { imported_function('stuff') }
  #pod
  #pod     # later on:
  #pod     Foo->bar;               # works
  #pod     Foo->imported_function; # will fail. imported_function got cleaned after compilation
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod When you import a function into a Perl package, it will naturally also be
  #pod available as a method.
  #pod
  #pod The C<namespace::autoclean> pragma will remove all imported symbols at the end
  #pod of the current package's compile cycle. Functions called in the package itself
  #pod will still be bound by their name, but they won't show up as methods on your
  #pod class or instances.
  #pod
  #pod This module is very similar to L<namespace::clean|namespace::clean>, except it
  #pod will clean all imported functions, no matter if you imported them before or
  #pod after you C<use>d the pragma. It will also not touch anything that looks like a
  #pod method.
  #pod
  #pod If you're writing an exporter and you want to clean up after yourself (and your
  #pod peers), you can use the C<-cleanee> switch to specify what package to clean:
  #pod
  #pod   package My::MooseX::namespace::autoclean;
  #pod   use strict;
  #pod
  #pod   use namespace::autoclean (); # no cleanup, just load
  #pod
  #pod   sub import {
  #pod       namespace::autoclean->import(
  #pod         -cleanee => scalar(caller),
  #pod       );
  #pod   }
  #pod
  #pod =head1 WHAT IS AND ISN'T CLEANED
  #pod
  #pod C<namespace::autoclean> will leave behind anything that it deems a method.  For
  #pod L<Moose> classes, this the based on the C<get_method_list> method
  #pod on from the L<Class::MOP::Class|metaclass>.  For non-Moose classes, anything
  #pod defined within the package will be identified as a method.  This should match
  #pod Moose's definition of a method.  Additionally, the magic subs installed by
  #pod L<overload> will not be cleaned.
  #pod
  #pod =head1 PARAMETERS
  #pod
  #pod =head2 -also => [ ITEM | REGEX | SUB, .. ]
  #pod
  #pod =head2 -also => ITEM
  #pod
  #pod =head2 -also => REGEX
  #pod
  #pod =head2 -also => SUB
  #pod
  #pod Sometimes you don't want to clean imports only, but also helper functions
  #pod you're using in your methods. The C<-also> switch can be used to declare a list
  #pod of functions that should be removed additional to any imports:
  #pod
  #pod     use namespace::autoclean -also => ['some_function', 'another_function'];
  #pod
  #pod If only one function needs to be additionally cleaned the C<-also> switch also
  #pod accepts a plain string:
  #pod
  #pod     use namespace::autoclean -also => 'some_function';
  #pod
  #pod In some situations, you may wish for a more I<powerful> cleaning solution.
  #pod
  #pod The C<-also> switch can take a Regex or a CodeRef to match against local
  #pod function names to clean.
  #pod
  #pod     use namespace::autoclean -also => qr/^_/
  #pod
  #pod     use namespace::autoclean -also => sub { $_ =~ m{^_} };
  #pod
  #pod     use namespace::autoclean -also => [qr/^_/ , qr/^hidden_/ ];
  #pod
  #pod     use namespace::autoclean -also => [sub { $_ =~ m/^_/ or $_ =~ m/^hidden/ }, sub { uc($_) == $_ } ];
  #pod
  #pod =head2 -except => [ ITEM | REGEX | SUB, .. ]
  #pod
  #pod =head2 -except => ITEM
  #pod
  #pod =head2 -except => REGEX
  #pod
  #pod =head2 -except => SUB
  #pod
  #pod This takes exactly the same options as C<-also> except that anything this
  #pod matches will I<not> be cleaned.
  #pod
  #pod =head1 CAVEATS
  #pod
  #pod When used with L<Moo> classes, the heuristic used to check for methods won't
  #pod work correctly for methods from roles consumed at compile time.
  #pod
  #pod   package My::Class;
  #pod   use Moo;
  #pod   use namespace::autoclean;
  #pod
  #pod   # Bad, any consumed methods will be cleaned
  #pod   BEGIN { with 'Some::Role' }
  #pod
  #pod   # Good, methods from role will be maintained
  #pod   with 'Some::Role';
  #pod
  #pod Additionally, method detection may not work properly in L<Mouse> classes in
  #pod perls earlier than 5.10.
  #pod
  #pod =head1 SEE ALSO
  #pod
  #pod =for :list
  #pod * L<namespace::clean>
  #pod * L<B::Hooks::EndOfScope>
  #pod * L<namespace::sweep>
  #pod * L<Sub::Exporter::ForMethods>
  #pod * L<Sub::Name>
  #pod * L<Sub::Install>
  #pod * L<Test::CleanNamespaces>
  #pod * L<Dist::Zilla::Plugin::Test::CleanNamespaces>
  #pod
  #pod =cut
  
  sub import {
      my ($class, %args) = @_;
  
      my $subcast = sub {
          my $i = shift;
          return $i if ref $i eq 'CODE';
          return sub { $_ =~ $i } if ref $i eq 'Regexp';
          return sub { $_ eq $i };
      };
  
      my $runtest = sub {
          my ($code, $method_name) = @_;
          local $_ = $method_name;
          return $code->();
      };
  
      my $cleanee = exists $args{-cleanee} ? $args{-cleanee} : scalar caller;
  
      my @also = map { $subcast->($_) } (
          exists $args{-also}
          ? (ref $args{-also} eq 'ARRAY' ? @{ $args{-also} } : $args{-also})
          : ()
      );
  
      my @except = map { $subcast->($_) } (
          exists $args{-except}
          ? (ref $args{-except} eq 'ARRAY' ? @{ $args{-except} } : $args{-except})
          : ()
      );
  
      on_scope_end {
          my $subs = namespace::clean->get_functions($cleanee);
          my $method_check = _method_check($cleanee);
  
          my @clean = grep {
            my $method = $_;
            ! first { $runtest->($_, $method) } @except
              and ( !$method_check->($method)
                or first { $runtest->($_, $method) } @also)
          } keys %$subs;
  
          namespace::clean->clean_subroutines($cleanee, @clean);
      };
  }
  
  sub _method_check {
      my $package = shift;
      if (
        (defined &Class::MOP::class_of and my $meta = Class::MOP::class_of($package))
      ) {
          my %methods = map { $_ => 1 } $meta->get_method_list;
          $methods{meta} = 1
            if $meta->isa('Moose::Meta::Role') && Moose->VERSION < 0.90;
          return sub { $_[0] =~ /^\(/ || $methods{$_[0]} };
      }
      else {
          my $does = $package->can('does') ? 'does'
                   : $package->can('DOES') ? 'DOES'
                   : undef;
          require Sub::Identify;
          return sub {
              return 1 if $_[0] =~ /^\(/;
              my $coderef = do { no strict 'refs'; \&{ $package . '::' . $_[0] } };
              my $code_stash = Sub::Identify::stash_name($coderef);
              return 1 if $code_stash eq $package;
              return 1 if $code_stash eq 'constant';
              # TODO: consider if we really need this eval
              return 1 if $does && eval { $package->$does($code_stash) };
              return 0;
          };
      }
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  namespace::autoclean - Keep imports out of your namespace
  
  =head1 VERSION
  
  version 0.28
  
  =head1 SYNOPSIS
  
      package Foo;
      use namespace::autoclean;
      use Some::Package qw/imported_function/;
  
      sub bar { imported_function('stuff') }
  
      # later on:
      Foo->bar;               # works
      Foo->imported_function; # will fail. imported_function got cleaned after compilation
  
  =head1 DESCRIPTION
  
  When you import a function into a Perl package, it will naturally also be
  available as a method.
  
  The C<namespace::autoclean> pragma will remove all imported symbols at the end
  of the current package's compile cycle. Functions called in the package itself
  will still be bound by their name, but they won't show up as methods on your
  class or instances.
  
  This module is very similar to L<namespace::clean|namespace::clean>, except it
  will clean all imported functions, no matter if you imported them before or
  after you C<use>d the pragma. It will also not touch anything that looks like a
  method.
  
  If you're writing an exporter and you want to clean up after yourself (and your
  peers), you can use the C<-cleanee> switch to specify what package to clean:
  
    package My::MooseX::namespace::autoclean;
    use strict;
  
    use namespace::autoclean (); # no cleanup, just load
  
    sub import {
        namespace::autoclean->import(
          -cleanee => scalar(caller),
        );
    }
  
  =head1 WHAT IS AND ISN'T CLEANED
  
  C<namespace::autoclean> will leave behind anything that it deems a method.  For
  L<Moose> classes, this the based on the C<get_method_list> method
  on from the L<Class::MOP::Class|metaclass>.  For non-Moose classes, anything
  defined within the package will be identified as a method.  This should match
  Moose's definition of a method.  Additionally, the magic subs installed by
  L<overload> will not be cleaned.
  
  =head1 PARAMETERS
  
  =head2 -also => [ ITEM | REGEX | SUB, .. ]
  
  =head2 -also => ITEM
  
  =head2 -also => REGEX
  
  =head2 -also => SUB
  
  Sometimes you don't want to clean imports only, but also helper functions
  you're using in your methods. The C<-also> switch can be used to declare a list
  of functions that should be removed additional to any imports:
  
      use namespace::autoclean -also => ['some_function', 'another_function'];
  
  If only one function needs to be additionally cleaned the C<-also> switch also
  accepts a plain string:
  
      use namespace::autoclean -also => 'some_function';
  
  In some situations, you may wish for a more I<powerful> cleaning solution.
  
  The C<-also> switch can take a Regex or a CodeRef to match against local
  function names to clean.
  
      use namespace::autoclean -also => qr/^_/
  
      use namespace::autoclean -also => sub { $_ =~ m{^_} };
  
      use namespace::autoclean -also => [qr/^_/ , qr/^hidden_/ ];
  
      use namespace::autoclean -also => [sub { $_ =~ m/^_/ or $_ =~ m/^hidden/ }, sub { uc($_) == $_ } ];
  
  =head2 -except => [ ITEM | REGEX | SUB, .. ]
  
  =head2 -except => ITEM
  
  =head2 -except => REGEX
  
  =head2 -except => SUB
  
  This takes exactly the same options as C<-also> except that anything this
  matches will I<not> be cleaned.
  
  =head1 CAVEATS
  
  When used with L<Moo> classes, the heuristic used to check for methods won't
  work correctly for methods from roles consumed at compile time.
  
    package My::Class;
    use Moo;
    use namespace::autoclean;
  
    # Bad, any consumed methods will be cleaned
    BEGIN { with 'Some::Role' }
  
    # Good, methods from role will be maintained
    with 'Some::Role';
  
  Additionally, method detection may not work properly in L<Mouse> classes in
  perls earlier than 5.10.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<namespace::clean>
  
  =item *
  
  L<B::Hooks::EndOfScope>
  
  =item *
  
  L<namespace::sweep>
  
  =item *
  
  L<Sub::Exporter::ForMethods>
  
  =item *
  
  L<Sub::Name>
  
  =item *
  
  L<Sub::Install>
  
  =item *
  
  L<Test::CleanNamespaces>
  
  =item *
  
  L<Dist::Zilla::Plugin::Test::CleanNamespaces>
  
  =back
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=namespace-autoclean>
  (or L<bug-namespace-autoclean@rt.cpan.org|mailto:bug-namespace-autoclean@rt.cpan.org>).
  
  There is also a mailing list available for users of this distribution, at
  L<http://lists.perl.org/list/moose.html>.
  
  There is also an irc channel available for users of this distribution, at
  irc://irc.perl.org/#moose.
  
  =head1 AUTHOR
  
  Florian Ragwitz <rafl@debian.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Karen Etheridge Graham Knop Dave Rolsky Kent Fredric Tomas Doran Shawn M Moore Felix Ostmann Chris Prather Andrew Rodland
  
  =over 4
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Kent Fredric <kentfredric@gmail.com>
  
  =item *
  
  Tomas Doran <bobtfish@bobtfish.net>
  
  =item *
  
  Shawn M Moore <sartak@gmail.com>
  
  =item *
  
  Felix Ostmann <sadrak@sadrak-laptop.(none)>
  
  =item *
  
  Chris Prather <cprather@hdpublishing.com>
  
  =item *
  
  Andrew Rodland <andrew@hbslabs.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2009 by Florian Ragwitz.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
NAMESPACE_AUTOCLEAN

$fatpacked{"namespace/clean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NAMESPACE_CLEAN';
  package namespace::clean;
  
  use warnings;
  use strict;
  
  our $VERSION = '0.27';
  $VERSION = eval $VERSION if $VERSION =~ /_/; # numify for warning-free dev releases
  
  our $STORAGE_VAR = '__NAMESPACE_CLEAN_STORAGE';
  
  use B::Hooks::EndOfScope 'on_scope_end';
  
  # FIXME This is a crock of shit, needs to go away
  # currently here to work around https://rt.cpan.org/Ticket/Display.html?id=74151
  # kill with fire when PS::XS is *finally* fixed
  BEGIN {
    my $provider;
  
    if ( "$]" < 5.008007 ) {
      require Package::Stash::PP;
      $provider = 'Package::Stash::PP';
    }
    else {
      require Package::Stash;
      $provider = 'Package::Stash';
    }
    eval <<"EOS" or die $@;
  
  sub stash_for (\$) {
    $provider->new(\$_[0]);
  }
  
  1;
  
  EOS
  }
  
  use namespace::clean::_Util qw( DEBUGGER_NEEDS_CV_RENAME DEBUGGER_NEEDS_CV_PIVOT );
  
  # Built-in debugger CV-retrieval fixups necessary before perl 5.15.5:
  # since we are deleting the glob where the subroutine was originally
  # defined, the assumptions below no longer hold.
  #
  # In 5.8.9 ~ 5.13.5 (inclusive) the debugger assumes that a CV can
  # always be found under sub_fullname($sub)
  # Workaround: use sub naming to properly name the sub hidden in the package's
  # deleted-stash
  #
  # In the rest of the range ( ... ~ 5.8.8 and 5.13.6 ~ 5.15.4 ) the debugger
  # assumes the name of the glob passed to entersub can be used to find the CV
  # Workaround: realias the original glob to the deleted-stash slot
  #
  # While the errors manifest themselves inside perl5db.pl, they are caused by
  # problems inside the interpreter.  If enabled ($^P & 0x01) and existent,
  # the DB::sub sub will be called by the interpreter for any sub call rather
  # that call the sub directly.  It is provided the real sub to call in $DB::sub,
  # but the value given has the issues described above.  We only have to enable
  # the workaround if DB::sub will be used.
  #
  # Can not tie constants to the current value of $^P directly,
  # as the debugger can be enabled during runtime (kinda dubious)
  #
  
  my $RemoveSubs = sub {
      my $cleanee = shift;
      my $store   = shift;
      my $cleanee_stash = stash_for($cleanee);
      my $deleted_stash;
  
    SYMBOL:
      for my $f (@_) {
  
          # ignore already removed symbols
          next SYMBOL if $store->{exclude}{ $f };
  
          my $sub = $cleanee_stash->get_symbol("&$f")
            or next SYMBOL;
  
          my $need_debugger_fixup =
            ( DEBUGGER_NEEDS_CV_RENAME or DEBUGGER_NEEDS_CV_PIVOT )
              &&
            $^P & 0x01
              &&
            defined &DB::sub
              &&
            ref(my $globref = \$cleanee_stash->namespace->{$f}) eq 'GLOB'
              &&
           ( $deleted_stash ||= stash_for("namespace::clean::deleted::$cleanee") )
          ;
  
          # convince the Perl debugger to work
          # see the comment on top
          if ( DEBUGGER_NEEDS_CV_RENAME and $need_debugger_fixup ) {
            #
            # Note - both get_subname and set_subname are only compiled when CV_RENAME
            # is true ( the 5.8.9 ~ 5.12 range ). On other perls this entire block is
            # constant folded away, and so are the definitions in ::_Util
            #
            # Do not be surprised that they are missing without DEBUGGER_NEEDS_CV_RENAME
            #
            namespace::clean::_Util::get_subname( $sub ) eq  ( $cleanee_stash->name . "::$f" )
              and
            $deleted_stash->add_symbol(
              "&$f",
              namespace::clean::_Util::set_subname( $deleted_stash->name . "::$f", $sub ),
            );
          }
          elsif ( DEBUGGER_NEEDS_CV_PIVOT and $need_debugger_fixup ) {
            $deleted_stash->add_symbol("&$f", $sub);
          }
  
          my @symbols = map {
              my $name = $_ . $f;
              my $def = $cleanee_stash->get_symbol($name);
              defined($def) ? [$name, $def] : ()
          } '$', '@', '%', '';
  
          $cleanee_stash->remove_glob($f);
  
          # if this perl needs no renaming trick we need to
          # rename the original glob after the fact
          DEBUGGER_NEEDS_CV_PIVOT
            and
          $need_debugger_fixup
            and
          *$globref = $deleted_stash->namespace->{$f};
  
          $cleanee_stash->add_symbol(@$_) for @symbols;
      }
  };
  
  sub clean_subroutines {
      my ($nc, $cleanee, @subs) = @_;
      $RemoveSubs->($cleanee, {}, @subs);
  }
  
  sub import {
      my ($pragma, @args) = @_;
  
      my (%args, $is_explicit);
  
    ARG:
      while (@args) {
  
          if ($args[0] =~ /^\-/) {
              my $key = shift @args;
              my $value = shift @args;
              $args{ $key } = $value;
          }
          else {
              $is_explicit++;
              last ARG;
          }
      }
  
      my $cleanee = exists $args{ -cleanee } ? $args{ -cleanee } : scalar caller;
      if ($is_explicit) {
          on_scope_end {
              $RemoveSubs->($cleanee, {}, @args);
          };
      }
      else {
  
          # calling class, all current functions and our storage
          my $functions = $pragma->get_functions($cleanee);
          my $store     = $pragma->get_class_store($cleanee);
          my $stash     = stash_for($cleanee);
  
          # except parameter can be array ref or single value
          my %except = map {( $_ => 1 )} (
              $args{ -except }
              ? ( ref $args{ -except } eq 'ARRAY' ? @{ $args{ -except } } : $args{ -except } )
              : ()
          );
  
          # register symbols for removal, if they have a CODE entry
          for my $f (keys %$functions) {
              next if     $except{ $f };
              next unless $stash->has_symbol("&$f");
              $store->{remove}{ $f } = 1;
          }
  
          on_scope_end {
              $RemoveSubs->($cleanee, $store, keys %{ $store->{remove} });
          };
  
          return 1;
      }
  }
  
  sub unimport {
      my ($pragma, %args) = @_;
  
      # the calling class, the current functions and our storage
      my $cleanee   = exists $args{ -cleanee } ? $args{ -cleanee } : scalar caller;
      my $functions = $pragma->get_functions($cleanee);
      my $store     = $pragma->get_class_store($cleanee);
  
      # register all unknown previous functions as excluded
      for my $f (keys %$functions) {
          next if $store->{remove}{ $f }
               or $store->{exclude}{ $f };
          $store->{exclude}{ $f } = 1;
      }
  
      return 1;
  }
  
  sub get_class_store {
      my ($pragma, $class) = @_;
      my $stash = stash_for($class);
      my $var = "%$STORAGE_VAR";
      $stash->add_symbol($var, {})
          unless $stash->has_symbol($var);
      return $stash->get_symbol($var);
  }
  
  sub get_functions {
      my ($pragma, $class) = @_;
  
      my $stash = stash_for($class);
      return {
          map { $_ => $stash->get_symbol("&$_") }
              $stash->list_all_symbols('CODE')
      };
  }
  
  'Danger! Laws of Thermodynamics may not apply.'
  
  __END__
  
  =head1 NAME
  
  namespace::clean - Keep imports and functions out of your namespace
  
  =head1 SYNOPSIS
  
    package Foo;
    use warnings;
    use strict;
  
    use Carp qw(croak);   # 'croak' will be removed
  
    sub bar { 23 }        # 'bar' will be removed
  
    # remove all previously defined functions
    use namespace::clean;
  
    sub baz { bar() }     # 'baz' still defined, 'bar' still bound
  
    # begin to collection function names from here again
    no namespace::clean;
  
    sub quux { baz() }    # 'quux' will be removed
  
    # remove all functions defined after the 'no' unimport
    use namespace::clean;
  
    # Will print: 'No', 'No', 'Yes' and 'No'
    print +(__PACKAGE__->can('croak') ? 'Yes' : 'No'), "\n";
    print +(__PACKAGE__->can('bar')   ? 'Yes' : 'No'), "\n";
    print +(__PACKAGE__->can('baz')   ? 'Yes' : 'No'), "\n";
    print +(__PACKAGE__->can('quux')  ? 'Yes' : 'No'), "\n";
  
    1;
  
  =head1 DESCRIPTION
  
  =head2 Keeping packages clean
  
  When you define a function, or import one, into a Perl package, it will
  naturally also be available as a method. This does not per se cause
  problems, but it can complicate subclassing and, for example, plugin
  classes that are included via multiple inheritance by loading them as
  base classes.
  
  The C<namespace::clean> pragma will remove all previously declared or
  imported symbols at the end of the current package's compile cycle.
  Functions called in the package itself will still be bound by their
  name, but they won't show up as methods on your class or instances.
  
  By unimporting via C<no> you can tell C<namespace::clean> to start
  collecting functions for the next C<use namespace::clean;> specification.
  
  You can use the C<-except> flag to tell C<namespace::clean> that you
  don't want it to remove a certain function or method. A common use would
  be a module exporting an C<import> method along with some functions:
  
    use ModuleExportingImport;
    use namespace::clean -except => [qw( import )];
  
  If you just want to C<-except> a single sub, you can pass it directly.
  For more than one value you have to use an array reference.
  
  =head3 Late binding caveat
  
  Note that the L<technique used by this module|/IMPLEMENTATION DETAILS> relies
  on perl having resolved all names to actual code references during the
  compilation of a scope. While this is almost always what the interpreter does,
  there are some exceptions, notably the L<sort SUBNAME|perlfunc/sort> style of
  the C<sort> built-in invocation. The following example will not work, because
  C<sort> does not try to resolve the function name to an actual code reference
  until B<runtime>.
  
   use MyApp::Utils 'my_sorter';
   use namespace::clean;
  
   my @sorted = sort my_sorter @list;
  
  You need to work around this by forcing a compile-time resolution like so:
  
   use MyApp::Utils 'my_sorter';
   use namespace::clean;
  
   my $my_sorter_cref = \&my_sorter;
  
   my @sorted = sort $my_sorter_cref @list;
  
  =head2 Explicitly removing functions when your scope is compiled
  
  It is also possible to explicitly tell C<namespace::clean> what packages
  to remove when the surrounding scope has finished compiling. Here is an
  example:
  
    package Foo;
    use strict;
  
    # blessed NOT available
  
    sub my_class {
        use Scalar::Util qw( blessed );
        use namespace::clean qw( blessed );
  
        # blessed available
        return blessed shift;
    }
  
    # blessed NOT available
  
  =head2 Moose
  
  When using C<namespace::clean> together with L<Moose> you want to keep
  the installed C<meta> method. So your classes should look like:
  
    package Foo;
    use Moose;
    use namespace::clean -except => 'meta';
    ...
  
  Same goes for L<Moose::Role>.
  
  =head2 Cleaning other packages
  
  You can tell C<namespace::clean> that you want to clean up another package
  instead of the one importing. To do this you have to pass in the C<-cleanee>
  option like this:
  
    package My::MooseX::namespace::clean;
    use strict;
  
    use namespace::clean (); # no cleanup, just load
  
    sub import {
        namespace::clean->import(
          -cleanee => scalar(caller),
          -except  => 'meta',
        );
    }
  
  If you don't care about C<namespace::clean>s discover-and-C<-except> logic, and
  just want to remove subroutines, try L</clean_subroutines>.
  
  =head1 METHODS
  
  =head2 clean_subroutines
  
  This exposes the actual subroutine-removal logic.
  
    namespace::clean->clean_subroutines($cleanee, qw( subA subB ));
  
  will remove C<subA> and C<subB> from C<$cleanee>. Note that this will remove the
  subroutines B<immediately> and not wait for scope end. If you want to have this
  effect at a specific time (e.g. C<namespace::clean> acts on scope compile end)
  it is your responsibility to make sure it runs at that time.
  
  =head2 import
  
  Makes a snapshot of the current defined functions and installs a
  L<B::Hooks::EndOfScope> hook in the current scope to invoke the cleanups.
  
  
  =head2 unimport
  
  This method will be called when you do a
  
    no namespace::clean;
  
  It will start a new section of code that defines functions to clean up.
  
  =head2 get_class_store
  
  This returns a reference to a hash in a passed package containing
  information about function names included and excluded from removal.
  
  =head2 get_functions
  
  Takes a class as argument and returns all currently defined functions
  in it as a hash reference with the function name as key and a typeglob
  reference to the symbol as value.
  
  =head1 IMPLEMENTATION DETAILS
  
  This module works through the effect that a
  
    delete $SomePackage::{foo};
  
  will remove the C<foo> symbol from C<$SomePackage> for run time lookups
  (e.g., method calls) but will leave the entry alive to be called by
  already resolved names in the package itself. C<namespace::clean> will
  restore and therefor in effect keep all glob slots that aren't C<CODE>.
  
  A test file has been added to the perl core to ensure that this behaviour
  will be stable in future releases.
  
  Just for completeness sake, if you want to remove the symbol completely,
  use C<undef> instead.
  
  =head1 SEE ALSO
  
  L<B::Hooks::EndOfScope>
  
  =head1 THANKS
  
  Many thanks to Matt S Trout for the inspiration on the whole idea.
  
  =head1 AUTHORS
  
  =over
  
  =item *
  
  Robert 'phaylon' Sedlacek <rs@474.at>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =item *
  
  Father Chrysostomos <sprout@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by L</AUTHORS>
  
  This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.
NAMESPACE_CLEAN

$fatpacked{"namespace/clean/_Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NAMESPACE_CLEAN__UTIL';
  ###       !!!ACHTUNG!!!
  #
  # This module is to be loaded at configure time straight from the Makefile.PL
  # in order to get access to some of the constants / utils
  # None of the dependencies will be available yet at this point, so make
  # sure to never use anything beyond what the minimum supported perl came with
  # (no, relying on configure_requires is not ok)
  
  package # hide from the pauses
    namespace::clean::_Util;
  
  use warnings;
  use strict;
  
  use base 'Exporter';
  our @EXPORT_OK = qw( DEBUGGER_NEEDS_CV_RENAME DEBUGGER_NEEDS_CV_PIVOT );
  
  use constant DEBUGGER_NEEDS_CV_RENAME => ( ( "$]" > 5.008_008 ) and ( "$]" < 5.013_006 ) );
  use constant DEBUGGER_NEEDS_CV_PIVOT => ( ( ! DEBUGGER_NEEDS_CV_RENAME ) and ( "$]" < 5.015_005 ) );
  
  # FIXME - ideally this needs to be provided by some abstraction lib
  # but we don't have that yet
  BEGIN {
    #
    # Note - both get_subname and set_subname are only called by one block
    # which is compiled away unless CV_RENAME is true ( the 5.8.9 ~ 5.12 range ).
    # Hence we compile/provide the definitions here only when needed
    #
    DEBUGGER_NEEDS_CV_RENAME and ( eval <<'EOS' or die $@ );
  {
    my( $sub_name_loaded, $sub_util_loaded );
  
    sub _namer_load_error {
      return '' if $sub_util_loaded or $sub_name_loaded;
  
      # if S::N is loaded first *and* so is B - then go with that, otherwise
      # prefer Sub::Util as S::U will provide a faster get_subname and will
      # not need further require() calls
      # this is rather arbitrary but remember this code exists only perls
      # between 5.8.9 ~ 5.13.5
  
      # when changing version also change in Makefile.PL
      my $sn_ver = 0.04;
  
      local $@;
      my $err = '';
  
      (
        ! (
          $INC{"B.pm"}
            and
          $INC{"Sub/Name.pm"}
            and
          eval { Sub::Name->VERSION($sn_ver) }
        )
          and
        eval { require Sub::Util }
          and
        # see https://github.com/moose/Moo/commit/dafa5118
        defined &Sub::Util::set_subname
          and
        $sub_util_loaded = 1
      )
        or
      (
        eval { require Sub::Name and Sub::Name->VERSION($sn_ver) }
          and
        $sub_name_loaded = 1
      )
        or
      $err = "When running under -d on this perl $], namespace::clean requires either Sub::Name $sn_ver or Sub::Util to be installed"
      ;
  
      $err;
    }
  
    sub set_subname {
      if( my $err = _namer_load_error() ) {
        die $err;
      }
      elsif( $sub_name_loaded ) {
        &Sub::Name::subname;
      }
      elsif( $sub_util_loaded ) {
        &Sub::Util::set_subname;
      }
      else {
        die "How the fuck did we get here? Read source and debug please!";
      }
    }
  
    sub get_subname {
      if(
        _namer_load_error()
          or
        ! $sub_util_loaded
      ) {
        require B;
        my $gv = B::svref_2object( $_[0] )->GV;
        join '::', $gv->STASH->NAME, $gv->NAME;
      }
      else {
        &Sub::Util::subname;
      }
    }
  }
  1;
  EOS
  
  }
  
  1;
NAMESPACE_CLEAN__UTIL

$fatpacked{"x86_64-linux/DateTime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_DATETIME';
  ## no critic (Modules::ProhibitExcessMainComplexity)
  package DateTime;
  
  use 5.008004;
  
  use strict;
  use warnings;
  use warnings::register;
  use namespace::autoclean 0.19;
  
  our $VERSION = '1.49';
  
  use Carp;
  use DateTime::Duration;
  use DateTime::Helpers;
  use DateTime::Locale 1.06;
  use DateTime::TimeZone 2.02;
  use DateTime::Types;
  use POSIX qw( floor fmod );
  use Params::ValidationCompiler 0.26 qw( validation_for );
  use Scalar::Util qw( blessed );
  use Try::Tiny;
  
  ## no critic (Variables::ProhibitPackageVars)
  our $IsPurePerl;
  
  {
      my $loaded = 0;
  
      unless ( $ENV{PERL_DATETIME_PP} ) {
          try {
              require XSLoader;
              XSLoader::load(
                  __PACKAGE__,
                  exists $DateTime::{VERSION} && ${ $DateTime::{VERSION} }
                  ? ${ $DateTime::{VERSION} }
                  : 42
              );
  
              $loaded     = 1;
              $IsPurePerl = 0;
          }
          catch {
              die $_ if $_ && $_ !~ /object version|loadable object/;
          };
      }
  
      if ($loaded) {
          ## no critic (Variables::ProtectPrivateVars)
          require DateTime::PPExtra
              unless defined &DateTime::_normalize_tai_seconds;
      }
      else {
          require DateTime::PP;
      }
  }
  
  # for some reason, overloading doesn't work unless fallback is listed
  # early.
  #
  # 3rd parameter ( $_[2] ) means the parameters are 'reversed'.
  # see: "Calling conventions for binary operations" in overload docs.
  #
  use overload (
      fallback => 1,
      '<=>'    => '_compare_overload',
      'cmp'    => '_string_compare_overload',
      q{""}    => 'stringify',
      bool     => sub {1},
      '-'      => '_subtract_overload',
      '+'      => '_add_overload',
      'eq'     => '_string_equals_overload',
      'ne'     => '_string_not_equals_overload',
  );
  
  # Have to load this after overloading is defined, after BEGIN blocks
  # or else weird crashes ensue
  require DateTime::Infinite;
  
  sub MAX_NANOSECONDS () {1_000_000_000}                  # 1E9 = almost 32 bits
  sub INFINITY ()        { 100**100**100**100 }
  sub NEG_INFINITY ()    { -1 * ( 100**100**100**100 ) }
  sub NAN ()             { INFINITY - INFINITY }
  
  sub SECONDS_PER_DAY () {86400}
  
  sub duration_class () {'DateTime::Duration'}
  
  my (
      @MonthLengths,
      @LeapYearMonthLengths,
      @QuarterLengths,
      @LeapYearQuarterLengths,
  );
  
  BEGIN {
      @MonthLengths = ( 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 );
  
      @LeapYearMonthLengths = @MonthLengths;
      $LeapYearMonthLengths[1]++;
  
      @QuarterLengths = ( 90, 91, 92, 92 );
  
      @LeapYearQuarterLengths = @QuarterLengths;
      $LeapYearQuarterLengths[0]++;
  }
  
  {
  
      # I'd rather use Class::Data::Inheritable for this, but there's no
      # way to add the module-loading behavior to an accessor it
      # creates, despite what its docs say!
      my $DefaultLocale;
  
      sub DefaultLocale {
          shift;
  
          if (@_) {
              my $lang = shift;
  
              $DefaultLocale = DateTime::Locale->load($lang);
          }
  
          return $DefaultLocale;
      }
  }
  __PACKAGE__->DefaultLocale('en-US');
  
  {
      my $validator = validation_for(
          name             => '_check_new_params',
          name_is_optional => 1,
          params           => {
              year  => { type => t('Year') },
              month => {
                  type    => t('Month'),
                  default => 1,
              },
              day => {
                  type    => t('DayOfMonth'),
                  default => 1,
              },
              hour => {
                  type    => t('Hour'),
                  default => 0,
              },
              minute => {
                  type    => t('Minute'),
                  default => 0,
              },
              second => {
                  type    => t('Second'),
                  default => 0,
              },
              nanosecond => {
                  type    => t('Nanosecond'),
                  default => 0,
              },
              locale => {
                  type     => t('Locale'),
                  optional => 1,
              },
              formatter => {
                  type     => t('Formatter'),
                  optional => 1,
              },
              time_zone => {
                  type     => t('TimeZone'),
                  optional => 1,
              },
          },
      );
  
      sub new {
          my $class = shift;
          my %p     = $validator->(@_);
  
          Carp::croak(
              "Invalid day of month (day = $p{day} - month = $p{month} - year = $p{year})\n"
              )
              if $p{day} > 28
              && $p{day} > $class->_month_length( $p{year}, $p{month} );
  
          return $class->_new(%p);
      }
  }
  
  sub _new {
      my $class = shift;
      my %p     = @_;
  
      Carp::croak('Constructor called with reference, we expected a package')
          if ref $class;
  
      # If this method is called from somewhere other than new(), then some of
      # these defaults may not get applied.
      $p{month}      = 1                          unless exists $p{month};
      $p{day}        = 1                          unless exists $p{day};
      $p{hour}       = 0                          unless exists $p{hour};
      $p{minute}     = 0                          unless exists $p{minute};
      $p{second}     = 0                          unless exists $p{second};
      $p{nanosecond} = 0                          unless exists $p{nanosecond};
      $p{time_zone}  = $class->_default_time_zone unless exists $p{time_zone};
  
      my $self = bless {}, $class;
  
      $self->_set_locale( $p{locale} );
  
      $self->{tz} = (
          ref $p{time_zone}
          ? $p{time_zone}
          : DateTime::TimeZone->new( name => $p{time_zone} )
      );
  
      $self->{local_rd_days} = $class->_ymd2rd( @p{qw( year month day )} );
  
      $self->{local_rd_secs}
          = $class->_time_as_seconds( @p{qw( hour minute second )} );
  
      $self->{offset_modifier} = 0;
  
      $self->{rd_nanosecs} = $p{nanosecond};
      $self->{formatter}   = $p{formatter};
  
      $self->_normalize_nanoseconds(
          $self->{local_rd_secs},
          $self->{rd_nanosecs}
      );
  
      # Set this explicitly since it can't be calculated accurately
      # without knowing our time zone offset, and it's possible that the
      # offset can't be calculated without having at least a rough guess
      # of the datetime's year. This year need not be correct, as long
      # as its equal or greater to the correct number, so we fudge by
      # adding one to the local year given to the constructor.
      $self->{utc_year} = $p{year} + 1;
  
      $self->_maybe_future_dst_warning( $p{year}, $p{time_zone} );
  
      $self->_calc_utc_rd;
  
      $self->_handle_offset_modifier( $p{second} );
  
      $self->_calc_local_rd;
  
      if ( $p{second} > 59 ) {
          if (
              $self->{tz}->is_floating
              ||
  
              # If true, this means that the actual calculated leap
              # second does not occur in the second given to new()
              ( $self->{utc_rd_secs} - 86399 < $p{second} - 59 )
          ) {
              Carp::croak("Invalid second value ($p{second})\n");
          }
      }
  
      return $self;
  }
  
  # Warning: do not use this environment variable unless you have no choice in
  # the matter.
  sub _default_time_zone {
      return $ENV{PERL_DATETIME_DEFAULT_TZ} || 'floating';
  }
  
  sub _set_locale {
      my $self   = shift;
      my $locale = shift;
  
      if ( defined $locale && ref $locale ) {
          $self->{locale} = $locale;
      }
      else {
          $self->{locale}
              = $locale
              ? DateTime::Locale->load($locale)
              : $self->DefaultLocale();
      }
  
      return;
  }
  
  # This method exists for the benefit of internal methods which create
  # a new object based on the current object, like set() and truncate().
  sub _new_from_self {
      my $self = shift;
      my %p    = @_;
  
      my %old = map { $_ => $self->$_() } qw(
          year month day
          hour minute second
          nanosecond
          locale time_zone
      );
      $old{formatter} = $self->formatter()
          if defined $self->formatter();
  
      my $method = delete $p{_skip_validation} ? '_new' : 'new';
  
      return ( ref $self )->$method( %old, %p );
  }
  
  sub _handle_offset_modifier {
      my $self = shift;
  
      $self->{offset_modifier} = 0;
  
      return if $self->{tz}->is_floating;
  
      my $second       = shift;
      my $utc_is_valid = shift;
  
      my $utc_rd_days = $self->{utc_rd_days};
  
      my $offset
          = $utc_is_valid ? $self->offset : $self->_offset_for_local_datetime;
  
      if (   $offset >= 0
          && $self->{local_rd_secs} >= $offset ) {
          if ( $second < 60 && $offset > 0 ) {
              $self->{offset_modifier}
                  = $self->_day_length( $utc_rd_days - 1 ) - SECONDS_PER_DAY;
  
              $self->{local_rd_secs} += $self->{offset_modifier};
          }
          elsif (
              $second == 60
              && (
                  ( $self->{local_rd_secs} == $offset && $offset > 0 )
                  || (   $offset == 0
                      && $self->{local_rd_secs} > 86399 )
              )
          ) {
              my $mod
                  = $self->_day_length( $utc_rd_days - 1 ) - SECONDS_PER_DAY;
  
              unless ( $mod == 0 ) {
                  $self->{utc_rd_secs} -= $mod;
  
                  $self->_normalize_seconds;
              }
          }
      }
      elsif ($offset < 0
          && $self->{local_rd_secs} >= SECONDS_PER_DAY + $offset ) {
          if ( $second < 60 ) {
              $self->{offset_modifier}
                  = $self->_day_length( $utc_rd_days - 1 ) - SECONDS_PER_DAY;
  
              $self->{local_rd_secs} += $self->{offset_modifier};
          }
          elsif ($second == 60
              && $self->{local_rd_secs} == SECONDS_PER_DAY + $offset ) {
              my $mod
                  = $self->_day_length( $utc_rd_days - 1 ) - SECONDS_PER_DAY;
  
              unless ( $mod == 0 ) {
                  $self->{utc_rd_secs} -= $mod;
  
                  $self->_normalize_seconds;
              }
          }
      }
  }
  
  sub _calc_utc_rd {
      my $self = shift;
  
      delete $self->{utc_c};
  
      if ( $self->{tz}->is_utc || $self->{tz}->is_floating ) {
          $self->{utc_rd_days} = $self->{local_rd_days};
          $self->{utc_rd_secs} = $self->{local_rd_secs};
      }
      else {
          my $offset = $self->_offset_for_local_datetime;
  
          $offset += $self->{offset_modifier};
  
          $self->{utc_rd_days} = $self->{local_rd_days};
          $self->{utc_rd_secs} = $self->{local_rd_secs} - $offset;
      }
  
      # We account for leap seconds in the new() method and nowhere else
      # except date math.
      $self->_normalize_tai_seconds(
          $self->{utc_rd_days},
          $self->{utc_rd_secs}
      );
  }
  
  sub _normalize_seconds {
      my $self = shift;
  
      return if $self->{utc_rd_secs} >= 0 && $self->{utc_rd_secs} <= 86399;
  
      if ( $self->{tz}->is_floating ) {
          $self->_normalize_tai_seconds(
              $self->{utc_rd_days},
              $self->{utc_rd_secs}
          );
      }
      else {
          $self->_normalize_leap_seconds(
              $self->{utc_rd_days},
              $self->{utc_rd_secs}
          );
      }
  }
  
  sub _calc_local_rd {
      my $self = shift;
  
      delete $self->{local_c};
  
      # We must short circuit for UTC times or else we could end up with
      # loops between DateTime.pm and DateTime::TimeZone
      if ( $self->{tz}->is_utc || $self->{tz}->is_floating ) {
          $self->{local_rd_days} = $self->{utc_rd_days};
          $self->{local_rd_secs} = $self->{utc_rd_secs};
      }
      else {
          my $offset = $self->offset;
  
          $self->{local_rd_days} = $self->{utc_rd_days};
          $self->{local_rd_secs} = $self->{utc_rd_secs} + $offset;
  
          # intentionally ignore leap seconds here
          $self->_normalize_tai_seconds(
              $self->{local_rd_days},
              $self->{local_rd_secs}
          );
  
          $self->{local_rd_secs} += $self->{offset_modifier};
      }
  
      $self->_calc_local_components;
  }
  
  sub _calc_local_components {
      my $self = shift;
  
      @{ $self->{local_c} }{
          qw( year month day day_of_week
              day_of_year quarter day_of_quarter)
          }
          = $self->_rd2ymd( $self->{local_rd_days}, 1 );
  
      @{ $self->{local_c} }{qw( hour minute second )}
          = $self->_seconds_as_components(
          $self->{local_rd_secs},
          $self->{utc_rd_secs}, $self->{offset_modifier}
          );
  }
  
  {
      my $validator = validation_for(
          name             => '_check_from_epoch_params',
          name_is_optional => 1,
          params           => {
              epoch     => { type => t('Num') },
              formatter => {
                  type     => t('Formatter'),
                  optional => 1
              },
              locale => {
                  type     => t('Locale'),
                  optional => 1
              },
              time_zone => {
                  type     => t('TimeZone'),
                  optional => 1
              },
          },
      );
  
      sub from_epoch {
          my $class = shift;
          my %p     = $validator->(@_);
  
          my %args;
  
          # This does two things. First, if given a negative non-integer epoch,
          # it will round the epoch _down_ to the next second and then adjust
          # the nanoseconds to be positive. In other words, -0.5 corresponds to
          # a second of -1 and a nanosecond value of 500,000. Before this code
          # was implemented our handling of negative non-integer epochs was
          # quite broken, and would end up rounding some values up, so that -0.5
          # become 0.5 (which is obviously wrong!).
          #
          # Second, it rounds any decimal values to the nearest microsecond
          # (1E6). Here's what Christian Hansen, who wrote this patch, says:
          #
          #     Perl is typically compiled with NV as a double. A double with a
          #     significand precision of 53 bits can only represent a nanosecond
          #     epoch without loss of precision if the duration from zero epoch
          #     is less than ≈ ±104 days. With microseconds the duration is
          #     ±104,000 days, which is ≈ ±285 years.
          if ( int $p{epoch} != $p{epoch} ) {
              my ( $floor, $nano, $second );
  
              $floor = $nano = fmod( $p{epoch}, 1.0 );
              $second = floor( $p{epoch} - $floor );
              if ( $nano < 0 ) {
                  $nano += 1;
              }
              $p{epoch}         = $second + floor( $floor - $nano );
              $args{nanosecond} = floor( $nano * 1E6 + 0.5 ) * 1E3;
          }
  
          # Note, for very large negative values this may give a
          # blatantly wrong answer.
          @args{qw( second minute hour day month year )}
              = ( gmtime( $p{epoch} ) )[ 0 .. 5 ];
          $args{year} += 1900;
          $args{month}++;
  
          my $self = $class->_new( %p, %args, time_zone => 'UTC' );
  
          $self->_maybe_future_dst_warning( $self->year(), $p{time_zone} );
  
          $self->set_time_zone( $p{time_zone} ) if exists $p{time_zone};
  
          return $self;
      }
  }
  
  sub now {
      my $class = shift;
      return $class->from_epoch( epoch => $class->_core_time(), @_ );
  }
  
  sub _maybe_future_dst_warning {
      shift;
      my $year = shift;
      my $tz   = shift;
  
      return unless $year >= 5000 && $tz;
  
      my $tz_name = ref $tz ? $tz->name() : $tz;
      return if $tz_name eq 'floating' || $tz_name eq 'UTC';
  
      warnings::warnif(
          "You are creating a DateTime object with a far future year ($year) and a time zone ($tz_name)."
              . ' If the time zone you specified has future DST changes this will be very slow.'
      );
  }
  
  # use scalar time in case someone's loaded Time::Piece
  sub _core_time {
      return scalar time;
  }
  
  sub today { shift->now(@_)->truncate( to => 'day' ) }
  
  {
      my $validator = validation_for(
          name             => '_check_from_object_params',
          name_is_optional => 1,
          params           => {
              object => { type => t('ConvertibleObject') },
              locale => {
                  type     => t('Locale'),
                  optional => 1,
              },
              formatter => {
                  type     => t('Formatter'),
                  optional => 1,
              },
          },
      );
  
      sub from_object {
          my $class = shift;
          my %p     = $validator->(@_);
  
          my $object = delete $p{object};
  
          if ( $object->isa('DateTime::Infinite') ) {
              return $object->clone;
          }
  
          my ( $rd_days, $rd_secs, $rd_nanosecs ) = $object->utc_rd_values;
  
          # A kludge because until all calendars are updated to return all
          # three values, $rd_nanosecs could be undef
          $rd_nanosecs ||= 0;
  
          # This is a big hack to let _seconds_as_components operate naively
          # on the given value. If the object _is_ on a leap second, we'll
          # add that to the generated seconds value later.
          my $leap_seconds = 0;
          if (   $object->can('time_zone')
              && !$object->time_zone->is_floating
              && $rd_secs > 86399
              && $rd_secs <= $class->_day_length($rd_days) ) {
              $leap_seconds = $rd_secs - 86399;
              $rd_secs -= $leap_seconds;
          }
  
          my %args;
          @args{qw( year month day )} = $class->_rd2ymd($rd_days);
          @args{qw( hour minute second )}
              = $class->_seconds_as_components($rd_secs);
          $args{nanosecond} = $rd_nanosecs;
  
          $args{second} += $leap_seconds;
  
          my $new = $class->new( %p, %args, time_zone => 'UTC' );
  
          if ( $object->can('time_zone') ) {
              $new->set_time_zone( $object->time_zone );
          }
          else {
              $new->set_time_zone( $class->_default_time_zone );
          }
  
          return $new;
      }
  }
  
  {
      my $validator = validation_for(
          name             => '_check_last_day_of_month_params',
          name_is_optional => 1,
          params           => {
              year  => { type => t('Year') },
              month => { type => t('Month') },
              day   => {
                  type    => t('DayOfMonth'),
                  default => 1,
              },
              hour => {
                  type    => t('Hour'),
                  default => 0,
              },
              minute => {
                  type    => t('Minute'),
                  default => 0,
              },
              second => {
                  type    => t('Second'),
                  default => 0,
              },
              nanosecond => {
                  type    => t('Nanosecond'),
                  default => 0,
              },
              locale => {
                  type     => t('Locale'),
                  optional => 1,
              },
              formatter => {
                  type     => t('Formatter'),
                  optional => 1,
              },
              time_zone => {
                  type     => t('TimeZone'),
                  optional => 1,
              },
          },
      );
  
      sub last_day_of_month {
          my $class = shift;
          my %p     = $validator->(@_);
  
          my $day = $class->_month_length( $p{year}, $p{month} );
  
          return $class->_new( %p, day => $day );
      }
  }
  
  sub _month_length {
      return (
            $_[0]->_is_leap_year( $_[1] )
          ? $LeapYearMonthLengths[ $_[2] - 1 ]
          : $MonthLengths[ $_[2] - 1 ]
      );
  }
  
  {
      my $validator = validation_for(
          name             => '_check_from_day_of_year_params',
          name_is_optional => 1,
          params           => {
              year        => { type => t('Year') },
              day_of_year => { type => t('DayOfYear') },
              hour        => {
                  type    => t('Hour'),
                  default => 0,
              },
              minute => {
                  type    => t('Minute'),
                  default => 0,
              },
              second => {
                  type    => t('Second'),
                  default => 0,
              },
              nanosecond => {
                  type    => t('Nanosecond'),
                  default => 0,
              },
              locale => {
                  type     => t('Locale'),
                  optional => 1,
              },
              formatter => {
                  type     => t('Formatter'),
                  optional => 1,
              },
              time_zone => {
                  type     => t('TimeZone'),
                  optional => 1,
              },
          },
      );
  
      sub from_day_of_year {
          my $class = shift;
          my %p     = $validator->(@_);
  
          Carp::croak("$p{year} is not a leap year.\n")
              if $p{day_of_year} == 366 && !$class->_is_leap_year( $p{year} );
  
          my $month = 1;
          my $day   = delete $p{day_of_year};
  
          if ( $day > 31 ) {
              my $length = $class->_month_length( $p{year}, $month );
  
              while ( $day > $length ) {
                  $day -= $length;
                  $month++;
                  $length = $class->_month_length( $p{year}, $month );
              }
          }
  
          return $class->_new(
              %p,
              month => $month,
              day   => $day,
          );
      }
  }
  
  sub formatter { $_[0]->{formatter} }
  
  sub clone { bless { %{ $_[0] } }, ref $_[0] }
  
  sub year {
      Carp::carp('year() is a read-only accessor') if @_ > 1;
      return $_[0]->{local_c}{year};
  }
  
  sub ce_year {
      $_[0]->{local_c}{year} <= 0
          ? $_[0]->{local_c}{year} - 1
          : $_[0]->{local_c}{year};
  }
  
  sub era_name { $_[0]->{locale}->era_wide->[ $_[0]->_era_index() ] }
  
  sub era_abbr { $_[0]->{locale}->era_abbreviated->[ $_[0]->_era_index() ] }
  
  # deprecated
  *era = \&era_abbr;
  
  sub _era_index { $_[0]->{local_c}{year} <= 0 ? 0 : 1 }
  
  sub christian_era { $_[0]->ce_year > 0 ? 'AD' : 'BC' }
  sub secular_era   { $_[0]->ce_year > 0 ? 'CE' : 'BCE' }
  
  sub year_with_era           { ( abs $_[0]->ce_year ) . $_[0]->era_abbr }
  sub year_with_christian_era { ( abs $_[0]->ce_year ) . $_[0]->christian_era }
  sub year_with_secular_era   { ( abs $_[0]->ce_year ) . $_[0]->secular_era }
  
  sub month {
      Carp::carp('month() is a read-only accessor') if @_ > 1;
      return $_[0]->{local_c}{month};
  }
  *mon = \&month;
  
  sub month_0 { $_[0]->{local_c}{month} - 1 }
  *mon_0 = \&month_0;
  
  sub month_name { $_[0]->{locale}->month_format_wide->[ $_[0]->month_0() ] }
  
  sub month_abbr {
      $_[0]->{locale}->month_format_abbreviated->[ $_[0]->month_0() ];
  }
  
  sub day_of_month {
      Carp::carp('day_of_month() is a read-only accessor') if @_ > 1;
      $_[0]->{local_c}{day};
  }
  *day  = \&day_of_month;
  *mday = \&day_of_month;
  
  sub weekday_of_month { use integer; ( ( $_[0]->day - 1 ) / 7 ) + 1 }
  
  sub quarter { $_[0]->{local_c}{quarter} }
  
  sub quarter_name {
      $_[0]->{locale}->quarter_format_wide->[ $_[0]->quarter_0() ];
  }
  
  sub quarter_abbr {
      $_[0]->{locale}->quarter_format_abbreviated->[ $_[0]->quarter_0() ];
  }
  
  sub quarter_0 { $_[0]->{local_c}{quarter} - 1 }
  
  sub day_of_month_0 { $_[0]->{local_c}{day} - 1 }
  *day_0  = \&day_of_month_0;
  *mday_0 = \&day_of_month_0;
  
  sub day_of_week { $_[0]->{local_c}{day_of_week} }
  *wday = \&day_of_week;
  *dow  = \&day_of_week;
  
  sub day_of_week_0 { $_[0]->{local_c}{day_of_week} - 1 }
  *wday_0 = \&day_of_week_0;
  *dow_0  = \&day_of_week_0;
  
  sub local_day_of_week {
      my $self = shift;
      return 1
          + ( $self->day_of_week - $self->{locale}->first_day_of_week ) % 7;
  }
  
  sub day_name { $_[0]->{locale}->day_format_wide->[ $_[0]->day_of_week_0() ] }
  
  sub day_abbr {
      $_[0]->{locale}->day_format_abbreviated->[ $_[0]->day_of_week_0() ];
  }
  
  sub day_of_quarter { $_[0]->{local_c}{day_of_quarter} }
  *doq = \&day_of_quarter;
  
  sub day_of_quarter_0 { $_[0]->day_of_quarter - 1 }
  *doq_0 = \&day_of_quarter_0;
  
  sub day_of_year { $_[0]->{local_c}{day_of_year} }
  *doy = \&day_of_year;
  
  sub day_of_year_0 { $_[0]->{local_c}{day_of_year} - 1 }
  *doy_0 = \&day_of_year_0;
  
  sub am_or_pm {
      $_[0]->{locale}->am_pm_abbreviated->[ $_[0]->hour() < 12 ? 0 : 1 ];
  }
  
  sub ymd {
      my ( $self, $sep ) = @_;
      $sep = '-' unless defined $sep;
  
      return sprintf(
          '%0.4d%s%0.2d%s%0.2d',
          $self->year,             $sep,
          $self->{local_c}{month}, $sep,
          $self->{local_c}{day}
      );
  }
  *date = sub { shift->ymd(@_) };
  
  sub mdy {
      my ( $self, $sep ) = @_;
      $sep = '-' unless defined $sep;
  
      return sprintf(
          '%0.2d%s%0.2d%s%0.4d',
          $self->{local_c}{month}, $sep,
          $self->{local_c}{day},   $sep,
          $self->year
      );
  }
  
  sub dmy {
      my ( $self, $sep ) = @_;
      $sep = '-' unless defined $sep;
  
      return sprintf(
          '%0.2d%s%0.2d%s%0.4d',
          $self->{local_c}{day},   $sep,
          $self->{local_c}{month}, $sep,
          $self->year
      );
  }
  
  sub hour {
      Carp::carp('hour() is a read-only accessor') if @_ > 1;
      return $_[0]->{local_c}{hour};
  }
  sub hour_1 { $_[0]->{local_c}{hour} == 0 ? 24 : $_[0]->{local_c}{hour} }
  
  sub hour_12 { my $h = $_[0]->hour % 12; return $h ? $h : 12 }
  sub hour_12_0 { $_[0]->hour % 12 }
  
  sub minute {
      Carp::carp('minute() is a read-only accessor') if @_ > 1;
      return $_[0]->{local_c}{minute};
  }
  *min = \&minute;
  
  sub second {
      Carp::carp('second() is a read-only accessor') if @_ > 1;
      return $_[0]->{local_c}{second};
  }
  *sec = \&second;
  
  sub fractional_second { $_[0]->second + $_[0]->nanosecond / MAX_NANOSECONDS }
  
  sub nanosecond {
      Carp::carp('nanosecond() is a read-only accessor') if @_ > 1;
      return $_[0]->{rd_nanosecs};
  }
  
  sub millisecond { floor( $_[0]->{rd_nanosecs} / 1000000 ) }
  
  sub microsecond { floor( $_[0]->{rd_nanosecs} / 1000 ) }
  
  sub leap_seconds {
      my $self = shift;
  
      return 0 if $self->{tz}->is_floating;
  
      return $self->_accumulated_leap_seconds( $self->{utc_rd_days} );
  }
  
  sub stringify {
      my $self = shift;
  
      return $self->iso8601 unless $self->{formatter};
      return $self->{formatter}->format_datetime($self);
  }
  
  sub hms {
      my ( $self, $sep ) = @_;
      $sep = ':' unless defined $sep;
  
      return sprintf(
          '%0.2d%s%0.2d%s%0.2d',
          $self->{local_c}{hour},   $sep,
          $self->{local_c}{minute}, $sep,
          $self->{local_c}{second}
      );
  }
  
  # don't want to override CORE::time()
  *DateTime::time = sub { shift->hms(@_) };
  
  sub iso8601 { $_[0]->datetime('T') }
  
  sub datetime {
      my ( $self, $sep ) = @_;
      $sep = 'T' unless defined $sep;
      return join $sep, $self->ymd('-'), $self->hms(':');
  }
  
  sub is_leap_year { $_[0]->_is_leap_year( $_[0]->year ) }
  
  sub month_length {
      $_[0]->_month_length( $_[0]->year, $_[0]->month );
  }
  
  sub quarter_length {
      return (
            $_[0]->_is_leap_year( $_[0]->year )
          ? $LeapYearQuarterLengths[ $_[0]->quarter - 1 ]
          : $QuarterLengths[ $_[0]->quarter - 1 ]
      );
  }
  
  sub year_length {
      $_[0]->_is_leap_year( $_[0]->year ) ? 366 : 365;
  }
  
  sub is_last_day_of_month {
      $_[0]->day == $_[0]->_month_length( $_[0]->year, $_[0]->month );
  }
  
  sub is_last_day_of_quarter {
      $_[0]->day_of_quarter == $_[0]->quarter_length;
  }
  
  sub is_last_day_of_year {
      $_[0]->day_of_year == $_[0]->year_length;
  }
  
  sub week {
      my $self = shift;
  
      $self->{utc_c}{week_year} ||= $self->_week_values;
  
      return @{ $self->{utc_c}{week_year} }[ 0, 1 ];
  }
  
  # This algorithm comes from
  # https://en.wikipedia.org/wiki/ISO_week_date#Calculating_the_week_number_of_a_given_date
  sub _week_values {
      my $self = shift;
  
      my $week
          = int( ( ( $self->day_of_year - $self->day_of_week ) + 10 ) / 7 );
  
      my $year = $self->year;
      if ( $week == 0 ) {
          $year--;
          return [ $year, $self->_weeks_in_year($year) ];
      }
      elsif ( $week == 53 && $self->_weeks_in_year($year) == 52 ) {
          return [ $year + 1, 1 ];
      }
  
      return [ $year, $week ];
  }
  
  sub _weeks_in_year {
      my $self = shift;
      my $year = shift;
  
      my $dow = $self->_ymd2rd( $year, 1, 1 ) % 7;
  
      # Years starting with a Thursday and leap years starting with a Wednesday
      # have 53 weeks.
      return ( $dow == 4 || ( $dow == 3 && $self->_is_leap_year($year) ) )
          ? 53
          : 52;
  }
  
  sub week_year   { ( $_[0]->week )[0] }
  sub week_number { ( $_[0]->week )[1] }
  
  # ISO says that the first week of a year is the first week containing
  # a Thursday. Extending that says that the first week of the month is
  # the first week containing a Thursday. ICU agrees.
  sub week_of_month {
      my $self = shift;
      my $thu  = $self->day + 4 - $self->day_of_week;
      return int( ( $thu + 6 ) / 7 );
  }
  
  sub time_zone {
      Carp::carp('time_zone() is a read-only accessor') if @_ > 1;
      return $_[0]->{tz};
  }
  
  sub offset { $_[0]->{tz}->offset_for_datetime( $_[0] ) }
  
  sub _offset_for_local_datetime {
      $_[0]->{tz}->offset_for_local_datetime( $_[0] );
  }
  
  sub is_dst { $_[0]->{tz}->is_dst_for_datetime( $_[0] ) }
  
  sub time_zone_long_name  { $_[0]->{tz}->name }
  sub time_zone_short_name { $_[0]->{tz}->short_name_for_datetime( $_[0] ) }
  
  sub locale {
      Carp::carp('locale() is a read-only accessor') if @_ > 1;
      return $_[0]->{locale};
  }
  
  sub utc_rd_values {
      @{ $_[0] }{ 'utc_rd_days', 'utc_rd_secs', 'rd_nanosecs' };
  }
  
  sub local_rd_values {
      @{ $_[0] }{ 'local_rd_days', 'local_rd_secs', 'rd_nanosecs' };
  }
  
  # NOTE: no nanoseconds, no leap seconds
  sub utc_rd_as_seconds {
      ( $_[0]->{utc_rd_days} * SECONDS_PER_DAY ) + $_[0]->{utc_rd_secs};
  }
  
  # NOTE: no nanoseconds, no leap seconds
  sub local_rd_as_seconds {
      ( $_[0]->{local_rd_days} * SECONDS_PER_DAY ) + $_[0]->{local_rd_secs};
  }
  
  # RD 1 is MJD 678,576 - a simple offset
  sub mjd {
      my $self = shift;
  
      my $mjd = $self->{utc_rd_days} - 678_576;
  
      my $day_length = $self->_day_length( $self->{utc_rd_days} );
  
      return (  $mjd
              + ( $self->{utc_rd_secs} / $day_length )
              + ( $self->{rd_nanosecs} / $day_length / MAX_NANOSECONDS ) );
  }
  
  sub jd { $_[0]->mjd + 2_400_000.5 }
  
  {
      my %strftime_patterns = (
          'a' => sub { $_[0]->day_abbr },
          'A' => sub { $_[0]->day_name },
          'b' => sub { $_[0]->month_abbr },
          'B' => sub { $_[0]->month_name },
          'c' => sub {
              $_[0]->format_cldr( $_[0]->{locale}->datetime_format_default() );
          },
          'C' => sub { int( $_[0]->year / 100 ) },
          'd' => sub { sprintf( '%02d', $_[0]->day_of_month ) },
          'D' => sub { $_[0]->strftime('%m/%d/%y') },
          'e' => sub { sprintf( '%2d', $_[0]->day_of_month ) },
          'F' => sub { $_[0]->ymd('-') },
          'g' => sub { substr( $_[0]->week_year, -2 ) },
          'G' => sub { $_[0]->week_year },
          'H' => sub { sprintf( '%02d', $_[0]->hour ) },
          'I' => sub { sprintf( '%02d', $_[0]->hour_12 ) },
          'j' => sub { sprintf( '%03d', $_[0]->day_of_year ) },
          'k' => sub { sprintf( '%2d', $_[0]->hour ) },
          'l' => sub { sprintf( '%2d', $_[0]->hour_12 ) },
          'm' => sub { sprintf( '%02d', $_[0]->month ) },
          'M' => sub { sprintf( '%02d', $_[0]->minute ) },
          'n' => sub {"\n"},                     # should this be OS-sensitive?
          'N' => \&_format_nanosecs,
          'p' => sub { $_[0]->am_or_pm() },
          'P' => sub { lc $_[0]->am_or_pm() },
          'r' => sub { $_[0]->strftime('%I:%M:%S %p') },
          'R' => sub { $_[0]->strftime('%H:%M') },
          's' => sub { $_[0]->epoch },
          'S' => sub { sprintf( '%02d', $_[0]->second ) },
          't' => sub {"\t"},
          'T' => sub { $_[0]->strftime('%H:%M:%S') },
          'u' => sub { $_[0]->day_of_week },
          'U' => sub {
              my $sun = $_[0]->day_of_year - ( $_[0]->day_of_week + 7 ) % 7;
              return sprintf( '%02d', int( ( $sun + 6 ) / 7 ) );
          },
          'V' => sub { sprintf( '%02d', $_[0]->week_number ) },
          'w' => sub {
              my $dow = $_[0]->day_of_week;
              return $dow % 7;
          },
          'W' => sub {
              my $mon = $_[0]->day_of_year - ( $_[0]->day_of_week + 6 ) % 7;
              return sprintf( '%02d', int( ( $mon + 6 ) / 7 ) );
          },
          'x' => sub {
              $_[0]->format_cldr( $_[0]->{locale}->date_format_default() );
          },
          'X' => sub {
              $_[0]->format_cldr( $_[0]->{locale}->time_format_default() );
          },
          'y' => sub { sprintf( '%02d', substr( $_[0]->year, -2 ) ) },
          'Y' => sub { return $_[0]->year },
          'z' => sub { DateTime::TimeZone->offset_as_string( $_[0]->offset ) },
          'Z' => sub { $_[0]->{tz}->short_name_for_datetime( $_[0] ) },
          '%' => sub {'%'},
      );
  
      $strftime_patterns{h} = $strftime_patterns{b};
  
      sub strftime {
          my $self = shift;
  
          # make a copy or caller's scalars get munged
          my @patterns = @_;
  
          my @r;
          foreach my $p (@patterns) {
              $p =~ s/
                      (?:
                        %\{(\w+)\}       # method name like %{day_name}
                        |
                        %([%a-zA-Z])     # single character specifier like %d
                        |
                        %(\d+)N          # special case for %N
                      )
                     /
                      ( $1
                        ? ( $self->can($1) ? $self->$1() : "\%{$1}" )
                        : $2
                        ? ( $strftime_patterns{$2} ? $strftime_patterns{$2}->($self) : "\%$2" )
                        : $3
                        ? $strftime_patterns{N}->($self, $3)
                        : ''  # this won't happen
                      )
                     /sgex;
  
              return $p unless wantarray;
  
              push @r, $p;
          }
  
          return @r;
      }
  }
  
  {
  
      # It's an array because the order in which the regexes are checked
      # is important. These patterns are similar to the ones Java uses,
      # but not quite the same. See
      # http://www.unicode.org/reports/tr35/tr35-9.html#Date_Format_Patterns.
      my @patterns = (
          qr/GGGGG/ =>
              sub { $_[0]->{locale}->era_narrow->[ $_[0]->_era_index() ] },
          qr/GGGG/   => 'era_name',
          qr/G{1,3}/ => 'era_abbr',
  
          qr/(y{3,5})/ =>
              sub { $_[0]->_zero_padded_number( $1, $_[0]->year() ) },
  
          # yy is a weird special case, where it must be exactly 2 digits
          qr/yy/ => sub {
              my $year = $_[0]->year();
              my $y2 = length $year > 2 ? substr( $year, -2, 2 ) : $year;
              $y2 *= -1 if $year < 0;
              $_[0]->_zero_padded_number( 'yy', $y2 );
          },
          qr/y/    => sub { $_[0]->year() },
          qr/(u+)/ => sub { $_[0]->_zero_padded_number( $1, $_[0]->year() ) },
          qr/(Y+)/ =>
              sub { $_[0]->_zero_padded_number( $1, $_[0]->week_year() ) },
  
          qr/QQQQ/ => 'quarter_name',
          qr/QQQ/  => 'quarter_abbr',
          qr/(QQ?)/ =>
              sub { $_[0]->_zero_padded_number( $1, $_[0]->quarter() ) },
  
          qr/qqqq/ => sub {
              $_[0]->{locale}->quarter_stand_alone_wide()
                  ->[ $_[0]->quarter_0() ];
          },
          qr/qqq/ => sub {
              $_[0]->{locale}->quarter_stand_alone_abbreviated()
                  ->[ $_[0]->quarter_0() ];
          },
          qr/(qq?)/ =>
              sub { $_[0]->_zero_padded_number( $1, $_[0]->quarter() ) },
  
          qr/MMMMM/ =>
              sub { $_[0]->{locale}->month_format_narrow->[ $_[0]->month_0() ] }
          ,
          qr/MMMM/  => 'month_name',
          qr/MMM/   => 'month_abbr',
          qr/(MM?)/ => sub { $_[0]->_zero_padded_number( $1, $_[0]->month() ) },
  
          qr/LLLLL/ => sub {
              $_[0]->{locale}->month_stand_alone_narrow->[ $_[0]->month_0() ];
          },
          qr/LLLL/ => sub {
              $_[0]->{locale}->month_stand_alone_wide->[ $_[0]->month_0() ];
          },
          qr/LLL/ => sub {
              $_[0]->{locale}
                  ->month_stand_alone_abbreviated->[ $_[0]->month_0() ];
          },
          qr/(LL?)/ => sub { $_[0]->_zero_padded_number( $1, $_[0]->month() ) },
  
          qr/(ww?)/ =>
              sub { $_[0]->_zero_padded_number( $1, $_[0]->week_number() ) },
          qr/W/ => 'week_of_month',
  
          qr/(dd?)/ =>
              sub { $_[0]->_zero_padded_number( $1, $_[0]->day_of_month() ) },
          qr/(D{1,3})/ =>
              sub { $_[0]->_zero_padded_number( $1, $_[0]->day_of_year() ) },
  
          qr/F/    => 'weekday_of_month',
          qr/(g+)/ => sub { $_[0]->_zero_padded_number( $1, $_[0]->mjd() ) },
  
          qr/EEEEE/ => sub {
              $_[0]->{locale}->day_format_narrow->[ $_[0]->day_of_week_0() ];
          },
          qr/EEEE/   => 'day_name',
          qr/E{1,3}/ => 'day_abbr',
  
          qr/eeeee/ => sub {
              $_[0]->{locale}->day_format_narrow->[ $_[0]->day_of_week_0() ];
          },
          qr/eeee/  => 'day_name',
          qr/eee/   => 'day_abbr',
          qr/(ee?)/ => sub {
              $_[0]->_zero_padded_number( $1, $_[0]->local_day_of_week() );
          },
  
          qr/ccccc/ => sub {
              $_[0]->{locale}
                  ->day_stand_alone_narrow->[ $_[0]->day_of_week_0() ];
          },
          qr/cccc/ => sub {
              $_[0]->{locale}->day_stand_alone_wide->[ $_[0]->day_of_week_0() ];
          },
          qr/ccc/ => sub {
              $_[0]->{locale}
                  ->day_stand_alone_abbreviated->[ $_[0]->day_of_week_0() ];
          },
          qr/(cc?)/ =>
              sub { $_[0]->_zero_padded_number( $1, $_[0]->day_of_week() ) },
  
          qr/a/ => 'am_or_pm',
  
          qr/(hh?)/ =>
              sub { $_[0]->_zero_padded_number( $1, $_[0]->hour_12() ) },
          qr/(HH?)/ => sub { $_[0]->_zero_padded_number( $1, $_[0]->hour() ) },
          qr/(KK?)/ =>
              sub { $_[0]->_zero_padded_number( $1, $_[0]->hour_12_0() ) },
          qr/(kk?)/ =>
              sub { $_[0]->_zero_padded_number( $1, $_[0]->hour_1() ) },
          qr/(jj?)/ => sub {
              my $h
                  = $_[0]->{locale}->prefers_24_hour_time()
                  ? $_[0]->hour()
                  : $_[0]->hour_12();
              $_[0]->_zero_padded_number( $1, $h );
          },
  
          qr/(mm?)/ =>
              sub { $_[0]->_zero_padded_number( $1, $_[0]->minute() ) },
  
          qr/(ss?)/ =>
              sub { $_[0]->_zero_padded_number( $1, $_[0]->second() ) },
  
          # The LDML spec is not 100% clear on how to truncate this field, but
          # this way seems as good as anything.
          qr/(S+)/ => sub { $_[0]->_format_nanosecs( length($1) ) },
          qr/A+/ =>
              sub { ( $_[0]->{local_rd_secs} * 1000 ) + $_[0]->millisecond() },
  
          qr/zzzz/   => sub { $_[0]->time_zone_long_name() },
          qr/z{1,3}/ => sub { $_[0]->time_zone_short_name() },
          qr/ZZZZZ/  => sub {
              substr(
                  my $z
                      = DateTime::TimeZone->offset_as_string( $_[0]->offset() ),
                  -2, 0, ':'
              );
              $z;
          },
          qr/ZZZZ/ => sub {
              $_[0]->time_zone_short_name()
                  . DateTime::TimeZone->offset_as_string( $_[0]->offset() );
          },
          qr/Z{1,3}/ =>
              sub { DateTime::TimeZone->offset_as_string( $_[0]->offset() ) },
          qr/vvvv/   => sub { $_[0]->time_zone_long_name() },
          qr/v{1,3}/ => sub { $_[0]->time_zone_short_name() },
          qr/VVVV/   => sub { $_[0]->time_zone_long_name() },
          qr/V{1,3}/ => sub { $_[0]->time_zone_short_name() },
      );
  
      sub _zero_padded_number {
          my $self = shift;
          my $size = length shift;
          my $val  = shift;
  
          return sprintf( "%0${size}d", $val );
      }
  
      sub format_cldr {
          my $self = shift;
  
          # make a copy or caller's scalars get munged
          my @p = @_;
  
          my @r;
          foreach my $p (@p) {
              $p =~ s/\G
                      (?:
                        '((?:[^']|'')*)' # quote escaped bit of text
                                         # it needs to end with one
                                         # quote not followed by
                                         # another
                        |
                        (([a-zA-Z])\3*)     # could be a pattern
                        |
                        (.)                 # anything else
                      )
                     /
                      defined $1
                      ? $1
                      : defined $2
                      ? $self->_cldr_pattern($2)
                      : defined $4
                      ? $4
                      : undef # should never get here
                     /sgex;
  
              $p =~ s/\'\'/\'/g;
  
              return $p unless wantarray;
  
              push @r, $p;
          }
  
          return @r;
      }
  
      sub _cldr_pattern {
          my $self    = shift;
          my $pattern = shift;
  
          ## no critic (ControlStructures::ProhibitCStyleForLoops)
          for ( my $i = 0; $i < @patterns; $i += 2 ) {
              if ( $pattern =~ /$patterns[$i]/ ) {
                  my $sub = $patterns[ $i + 1 ];
  
                  return $self->$sub();
              }
          }
  
          return $pattern;
      }
  }
  
  sub _format_nanosecs {
      my $self = shift;
      my $precision = @_ ? shift : 9;
  
      my $divide_by = 10**( 9 - $precision );
  
      return sprintf(
          '%0' . $precision . 'u',
          floor( $self->{rd_nanosecs} / $divide_by )
      );
  }
  
  sub epoch {
      my $self = shift;
  
      return $self->{utc_c}{epoch}
          if exists $self->{utc_c}{epoch};
  
      return $self->{utc_c}{epoch}
          = ( $self->{utc_rd_days} - 719163 ) * SECONDS_PER_DAY
          + $self->{utc_rd_secs};
  }
  
  sub hires_epoch {
      my $self = shift;
  
      my $epoch = $self->epoch;
  
      return undef unless defined $epoch;
  
      my $nano = $self->{rd_nanosecs} / MAX_NANOSECONDS;
  
      return $epoch + $nano;
  }
  
  sub is_finite   {1}
  sub is_infinite {0}
  
  # added for benefit of DateTime::TimeZone
  sub utc_year { $_[0]->{utc_year} }
  
  # returns a result that is relative to the first datetime
  sub subtract_datetime {
      my $dt1 = shift;
      my $dt2 = shift;
  
      $dt2 = $dt2->clone->set_time_zone( $dt1->time_zone )
          unless $dt1->time_zone eq $dt2->time_zone;
  
      # We only want a negative duration if $dt2 > $dt1 ($self)
      my ( $bigger, $smaller, $negative ) = (
          $dt1 >= $dt2
          ? ( $dt1, $dt2, 0 )
          : ( $dt2, $dt1, 1 )
      );
  
      my $is_floating = $dt1->time_zone->is_floating
          && $dt2->time_zone->is_floating;
  
      my $minute_length = 60;
      unless ($is_floating) {
          my ( $utc_rd_days, $utc_rd_secs ) = $smaller->utc_rd_values;
  
          if ( $utc_rd_secs >= 86340 && !$is_floating ) {
  
              # If the smaller of the two datetimes occurs in the last
              # UTC minute of the UTC day, then that minute may not be
              # 60 seconds long. If we need to subtract a minute from
              # the larger datetime's minutes count in order to adjust
              # the seconds difference to be positive, we need to know
              # how long that minute was. If one of the datetimes is
              # floating, we just assume a minute is 60 seconds.
  
              $minute_length = $dt1->_day_length($utc_rd_days) - 86340;
          }
      }
  
      # This is a gross hack that basically figures out if the bigger of
      # the two datetimes is the day of a DST change. If it's a 23 hour
      # day (switching _to_ DST) then we subtract 60 minutes from the
      # local time. If it's a 25 hour day then we add 60 minutes to the
      # local time.
      #
      # This produces the most "intuitive" results, though there are
      # still reversibility problems with the resultant duration.
      #
      # However, if the two objects are on the same (local) date, and we
      # are not crossing a DST change, we don't want to invoke the hack
      # - see 38local-subtract.t
      my $bigger_min = $bigger->hour * 60 + $bigger->minute;
      if (   $bigger->time_zone->has_dst_changes
          && $bigger->is_dst != $smaller->is_dst ) {
  
          $bigger_min -= 60
  
              # it's a 23 hour (local) day
              if (
              $bigger->is_dst
              && do {
                  my $prev_day = try { $bigger->clone->subtract( days => 1 ) };
                  $prev_day && !$prev_day->is_dst ? 1 : 0;
              }
              );
  
          $bigger_min += 60
  
              # it's a 25 hour (local) day
              if (
              !$bigger->is_dst
              && do {
                  my $prev_day = try { $bigger->clone->subtract( days => 1 ) };
                  $prev_day && $prev_day->is_dst ? 1 : 0;
              }
              );
      }
  
      my ( $months, $days, $minutes, $seconds, $nanoseconds )
          = $dt1->_adjust_for_positive_difference(
          $bigger->year * 12 + $bigger->month,
          $smaller->year * 12 + $smaller->month,
  
          $bigger->day, $smaller->day,
  
          $bigger_min, $smaller->hour * 60 + $smaller->minute,
  
          $bigger->second, $smaller->second,
  
          $bigger->nanosecond, $smaller->nanosecond,
  
          $minute_length,
  
          # XXX - using the smaller as the month length is
          # somewhat arbitrary, we could also use the bigger -
          # either way we have reversibility problems
          $dt1->_month_length( $smaller->year, $smaller->month ),
          );
  
      if ($negative) {
          for ( $months, $days, $minutes, $seconds, $nanoseconds ) {
  
              # Some versions of Perl can end up with -0 if we do "0 * -1"!!
              $_ *= -1 if $_;
          }
      }
  
      return $dt1->duration_class->new(
          months      => $months,
          days        => $days,
          minutes     => $minutes,
          seconds     => $seconds,
          nanoseconds => $nanoseconds,
      );
  }
  
  sub _adjust_for_positive_difference
  {    ## no critic (Subroutines::ProhibitManyArgs)
      my (
          $self,
          $month1, $month2,
          $day1,   $day2,
          $min1,   $min2,
          $sec1,   $sec2,
          $nano1,  $nano2,
          $minute_length,
          $month_length,
      ) = @_;
  
      if ( $nano1 < $nano2 ) {
          $sec1--;
          $nano1 += MAX_NANOSECONDS;
      }
  
      if ( $sec1 < $sec2 ) {
          $min1--;
          $sec1 += $minute_length;
      }
  
      # A day always has 24 * 60 minutes, though the minutes may vary in
      # length.
      if ( $min1 < $min2 ) {
          $day1--;
          $min1 += 24 * 60;
      }
  
      if ( $day1 < $day2 ) {
          $month1--;
          $day1 += $month_length;
      }
  
      return (
          $month1 - $month2,
          $day1 - $day2,
          $min1 - $min2,
          $sec1 - $sec2,
          $nano1 - $nano2,
      );
  }
  
  sub subtract_datetime_absolute {
      my $self = shift;
      my $dt   = shift;
  
      my $utc_rd_secs1 = $self->utc_rd_as_seconds;
      $utc_rd_secs1 += $self->_accumulated_leap_seconds( $self->{utc_rd_days} )
          if !$self->time_zone->is_floating;
  
      my $utc_rd_secs2 = $dt->utc_rd_as_seconds;
      $utc_rd_secs2 += $self->_accumulated_leap_seconds( $dt->{utc_rd_days} )
          if !$dt->time_zone->is_floating;
  
      my $seconds     = $utc_rd_secs1 - $utc_rd_secs2;
      my $nanoseconds = $self->nanosecond - $dt->nanosecond;
  
      if ( $nanoseconds < 0 ) {
          $seconds--;
          $nanoseconds += MAX_NANOSECONDS;
      }
  
      return $self->duration_class->new(
          seconds     => $seconds,
          nanoseconds => $nanoseconds,
      );
  }
  
  sub delta_md {
      my $self = shift;
      my $dt   = shift;
  
      my ( $smaller, $bigger ) = sort $self, $dt;
  
      my ( $months, $days, undef, undef, undef )
          = $dt->_adjust_for_positive_difference(
          $bigger->year * 12 + $bigger->month,
          $smaller->year * 12 + $smaller->month,
  
          $bigger->day, $smaller->day,
  
          0, 0,
  
          0, 0,
  
          0, 0,
  
          60,
  
          $smaller->_month_length( $smaller->year, $smaller->month ),
          );
  
      return $self->duration_class->new(
          months => $months,
          days   => $days
      );
  }
  
  sub delta_days {
      my $self = shift;
      my $dt   = shift;
  
      my $days
          = abs( ( $self->local_rd_values )[0] - ( $dt->local_rd_values )[0] );
  
      $self->duration_class->new( days => $days );
  }
  
  sub delta_ms {
      my $self = shift;
      my $dt   = shift;
  
      my ( $smaller, $greater ) = sort $self, $dt;
  
      my $days = int( $greater->jd - $smaller->jd );
  
      my $dur = $greater->subtract_datetime($smaller);
  
      my %p;
      $p{hours}   = $dur->hours + ( $days * 24 );
      $p{minutes} = $dur->minutes;
      $p{seconds} = $dur->seconds;
  
      return $self->duration_class->new(%p);
  }
  
  sub _add_overload {
      my ( $dt, $dur, $reversed ) = @_;
  
      if ($reversed) {
          ( $dur, $dt ) = ( $dt, $dur );
      }
  
      unless ( DateTime::Helpers::isa( $dur, 'DateTime::Duration' ) ) {
          my $class     = ref $dt;
          my $dt_string = overload::StrVal($dt);
  
          Carp::croak( "Cannot add $dur to a $class object ($dt_string).\n"
                  . ' Only a DateTime::Duration object can '
                  . " be added to a $class object." );
      }
  
      return $dt->clone->add_duration($dur);
  }
  
  sub _subtract_overload {
      my ( $date1, $date2, $reversed ) = @_;
  
      if ($reversed) {
          ( $date2, $date1 ) = ( $date1, $date2 );
      }
  
      if ( DateTime::Helpers::isa( $date2, 'DateTime::Duration' ) ) {
          my $new = $date1->clone;
          $new->add_duration( $date2->inverse );
          return $new;
      }
      elsif ( DateTime::Helpers::isa( $date2, 'DateTime' ) ) {
          return $date1->subtract_datetime($date2);
      }
      else {
          my $class     = ref $date1;
          my $dt_string = overload::StrVal($date1);
  
          Carp::croak(
              "Cannot subtract $date2 from a $class object ($dt_string).\n"
                  . ' Only a DateTime::Duration or DateTime object can '
                  . " be subtracted from a $class object." );
      }
  }
  
  sub add {
      my $self = shift;
  
      return $self->add_duration( $self->_duration_object_from_args(@_) );
  }
  
  sub subtract {
      my $self = shift;
  
      my %eom;
      if ( @_ % 2 == 0 ) {
          my %p = @_;
  
          $eom{end_of_month} = delete $p{end_of_month}
              if exists $p{end_of_month};
      }
  
      my $dur = $self->_duration_object_from_args(@_)->inverse(%eom);
  
      return $self->add_duration($dur);
  }
  
  # Syntactic sugar for add and subtract: use a duration object if it's
  # supplied, otherwise build a new one from the arguments.
  
  sub _duration_object_from_args {
      my $self = shift;
  
      return $_[0]
          if @_ == 1 && blessed( $_[0] ) && $_[0]->isa( $self->duration_class );
  
      return $self->duration_class->new(@_);
  }
  
  sub subtract_duration { return $_[0]->add_duration( $_[1]->inverse ) }
  
  {
      my $validator = validation_for(
          name             => '_check_add_duration_params',
          name_is_optional => 1,
          params           => [
              { type => t('Duration') },
          ],
      );
  
      ## no critic (Subroutines::ProhibitExcessComplexity)
      sub add_duration {
          my $self = shift;
          my ($dur) = $validator->(@_);
  
          # simple optimization
          return $self if $dur->is_zero;
  
          my %deltas = $dur->deltas;
  
          # This bit isn't quite right since DateTime::Infinite::Future -
          # infinite duration should NaN
          foreach my $val ( values %deltas ) {
              my $inf;
              if ( $val == INFINITY ) {
                  $inf = DateTime::Infinite::Future->new;
              }
              elsif ( $val == NEG_INFINITY ) {
                  $inf = DateTime::Infinite::Past->new;
              }
  
              if ($inf) {
                  %$self = %$inf;
                  bless $self, ref $inf;
  
                  return $self;
              }
          }
  
          return $self if $self->is_infinite;
  
          my %orig = %{$self};
          try {
              $self->_add_duration($dur);
          }
          catch {
              %{$self} = %orig;
              die $_;
          };
      }
  }
  
  sub _add_duration {
      my $self = shift;
      my $dur  = shift;
  
      my %deltas = $dur->deltas;
  
      if ( $deltas{days} ) {
          $self->{local_rd_days} += $deltas{days};
  
          $self->{utc_year} += int( $deltas{days} / 365 ) + 1;
      }
  
      if ( $deltas{months} ) {
  
          # For preserve mode, if it is the last day of the month, make
          # it the 0th day of the following month (which then will
          # normalize back to the last day of the new month).
          my ( $y, $m, $d ) = (
                $dur->is_preserve_mode
              ? $self->_rd2ymd( $self->{local_rd_days} + 1 )
              : $self->_rd2ymd( $self->{local_rd_days} )
          );
  
          $d -= 1 if $dur->is_preserve_mode;
  
          if ( !$dur->is_wrap_mode && $d > 28 ) {
  
              # find the rd for the last day of our target month
              $self->{local_rd_days}
                  = $self->_ymd2rd( $y, $m + $deltas{months} + 1, 0 );
  
              # what day of the month is it? (discard year and month)
              my $last_day
                  = ( $self->_rd2ymd( $self->{local_rd_days} ) )[2];
  
              # if our original day was less than the last day,
              # use that instead
              $self->{local_rd_days} -= $last_day - $d if $last_day > $d;
          }
          else {
              $self->{local_rd_days}
                  = $self->_ymd2rd( $y, $m + $deltas{months}, $d );
          }
  
          $self->{utc_year} += int( $deltas{months} / 12 ) + 1;
      }
  
      if ( $deltas{days} || $deltas{months} ) {
          $self->_calc_utc_rd;
  
          $self->_handle_offset_modifier( $self->second );
      }
  
      if ( $deltas{minutes} ) {
          $self->{utc_rd_secs} += $deltas{minutes} * 60;
  
          # This intentionally ignores leap seconds
          $self->_normalize_tai_seconds(
              $self->{utc_rd_days},
              $self->{utc_rd_secs}
          );
      }
  
      if ( $deltas{seconds} || $deltas{nanoseconds} ) {
          $self->{utc_rd_secs} += $deltas{seconds};
  
          if ( $deltas{nanoseconds} ) {
              $self->{rd_nanosecs} += $deltas{nanoseconds};
              $self->_normalize_nanoseconds(
                  $self->{utc_rd_secs},
                  $self->{rd_nanosecs}
              );
          }
  
          $self->_normalize_seconds;
  
          # This might be some big number much bigger than 60, but
          # that's ok (there are tests in 19leap_second.t to confirm
          # that)
          $self->_handle_offset_modifier( $self->second + $deltas{seconds} );
      }
  
      my $new = ( ref $self )->from_object(
          object => $self,
          locale => $self->{locale},
          ( $self->{formatter} ? ( formatter => $self->{formatter} ) : () ),
      );
  
      %$self = %$new;
  
      return $self;
  }
  
  sub _compare_overload {
  
      # note: $_[1]->compare( $_[0] ) is an error when $_[1] is not a
      # DateTime (such as the INFINITY value)
  
      return undef unless defined $_[1];
  
      return $_[2] ? -$_[0]->compare( $_[1] ) : $_[0]->compare( $_[1] );
  }
  
  sub _string_compare_overload {
      my ( $dt1, $dt2, $flip ) = @_;
  
      # One is a DateTime object, one isn't. Just stringify and compare.
      if ( !DateTime::Helpers::can( $dt2, 'utc_rd_values' ) ) {
          my $sign = $flip ? -1 : 1;
          return $sign * ( "$dt1" cmp "$dt2" );
      }
      else {
          my $meth = $dt1->can('_compare_overload');
          goto $meth;
      }
  }
  
  sub compare {
      shift->_compare( @_, 0 );
  }
  
  sub compare_ignore_floating {
      shift->_compare( @_, 1 );
  }
  
  sub _compare {
      my ( undef, $dt1, $dt2, $consistent ) = ref $_[0] ? ( undef, @_ ) : @_;
  
      return undef unless defined $dt2;
  
      if ( !ref $dt2 && ( $dt2 == INFINITY || $dt2 == NEG_INFINITY ) ) {
          return $dt1->{utc_rd_days} <=> $dt2;
      }
  
      unless ( DateTime::Helpers::can( $dt1, 'utc_rd_values' )
          && DateTime::Helpers::can( $dt2, 'utc_rd_values' ) ) {
          my $dt1_string = overload::StrVal($dt1);
          my $dt2_string = overload::StrVal($dt2);
  
          Carp::croak( 'A DateTime object can only be compared to'
                  . " another DateTime object ($dt1_string, $dt2_string)." );
      }
  
      if (   !$consistent
          && DateTime::Helpers::can( $dt1, 'time_zone' )
          && DateTime::Helpers::can( $dt2, 'time_zone' ) ) {
          my $is_floating1 = $dt1->time_zone->is_floating;
          my $is_floating2 = $dt2->time_zone->is_floating;
  
          if ( $is_floating1 && !$is_floating2 ) {
              $dt1 = $dt1->clone->set_time_zone( $dt2->time_zone );
          }
          elsif ( $is_floating2 && !$is_floating1 ) {
              $dt2 = $dt2->clone->set_time_zone( $dt1->time_zone );
          }
      }
  
      my @dt1_components = $dt1->utc_rd_values;
      my @dt2_components = $dt2->utc_rd_values;
  
      foreach my $i ( 0 .. 2 ) {
          return $dt1_components[$i] <=> $dt2_components[$i]
              if $dt1_components[$i] != $dt2_components[$i];
      }
  
      return 0;
  }
  
  sub _string_equals_overload {
      my ( $class, $dt1, $dt2 ) = ref $_[0] ? ( undef, @_ ) : @_;
  
      if ( !DateTime::Helpers::can( $dt2, 'utc_rd_values' ) ) {
          return "$dt1" eq "$dt2";
      }
  
      $class ||= ref $dt1;
      return !$class->compare( $dt1, $dt2 );
  }
  
  sub _string_not_equals_overload {
      return !_string_equals_overload(@_);
  }
  
  sub _normalize_nanoseconds {
      use integer;
  
      # seconds, nanoseconds
      if ( $_[2] < 0 ) {
          my $overflow = 1 + $_[2] / MAX_NANOSECONDS;
          $_[2] += $overflow * MAX_NANOSECONDS;
          $_[1] -= $overflow;
      }
      elsif ( $_[2] >= MAX_NANOSECONDS ) {
          my $overflow = $_[2] / MAX_NANOSECONDS;
          $_[2] -= $overflow * MAX_NANOSECONDS;
          $_[1] += $overflow;
      }
  }
  
  {
      my $validator = validation_for(
          name             => '_check_set_params',
          name_is_optional => 1,
          params           => {
              year => {
                  type     => t('Year'),
                  optional => 1,
              },
              month => {
                  type     => t('Month'),
                  optional => 1,
              },
              day => {
                  type     => t('DayOfMonth'),
                  optional => 1,
              },
              hour => {
                  type     => t('Hour'),
                  optional => 1,
              },
              minute => {
                  type     => t('Minute'),
                  optional => 1,
              },
              second => {
                  type     => t('Second'),
                  optional => 1,
              },
              nanosecond => {
                  type     => t('Nanosecond'),
                  optional => 1,
              },
              locale => {
                  type     => t('Locale'),
                  optional => 1,
              },
          },
      );
  
      ## no critic (NamingConventions::ProhibitAmbiguousNames)
      sub set {
          my $self = shift;
          my %p    = $validator->(@_);
  
          if ( $p{locale} ) {
              carp 'You passed a locale to the set() method.'
                  . ' You should use set_locale() instead, as using set() may alter the local time near a DST boundary.';
          }
  
          my $new_dt = $self->_new_from_self(%p);
  
          %$self = %$new_dt;
  
          return $self;
      }
  }
  
  sub set_year       { $_[0]->set( year       => $_[1] ) }
  sub set_month      { $_[0]->set( month      => $_[1] ) }
  sub set_day        { $_[0]->set( day        => $_[1] ) }
  sub set_hour       { $_[0]->set( hour       => $_[1] ) }
  sub set_minute     { $_[0]->set( minute     => $_[1] ) }
  sub set_second     { $_[0]->set( second     => $_[1] ) }
  sub set_nanosecond { $_[0]->set( nanosecond => $_[1] ) }
  
  # These two are special cased because ... if the local time is the hour of a
  # DST change where the same local time occurs twice then passing it through
  # _new() can actually change the underlying UTC time, which is bad.
  
  {
      my $validator = validation_for(
          name             => '_check_set_locale_params',
          name_is_optional => 1,
          params           => [
              { type => t( 'Maybe', of => t('Locale') ) },
          ],
      );
  
      sub set_locale {
          my $self = shift;
          my ($locale) = $validator->(@_);
  
          $self->_set_locale($locale);
  
          return $self;
      }
  }
  
  {
      my $validator = validation_for(
          name             => '_check_set_formatter_params',
          name_is_optional => 1,
          params           => [
              { type => t( 'Maybe', of => t('Formatter') ) },
          ],
      );
  
      sub set_formatter {
          my $self = shift;
          my ($formatter) = $validator->(@_);
  
          $self->{formatter} = $formatter;
  
          return $self;
      }
  }
  
  {
      my %TruncateDefault = (
          month      => 1,
          day        => 1,
          hour       => 0,
          minute     => 0,
          second     => 0,
          nanosecond => 0,
      );
  
      my $validator = validation_for(
          name             => '_check_truncate_params',
          name_is_optional => 1,
          params           => {
              to => { type => t('TruncationLevel') },
          },
      );
  
      my $re = join '|', 'year', 'week', 'local_week', 'quarter',
          grep { $_ ne 'nanosecond' } keys %TruncateDefault;
      my $spec = { to => { regex => qr/^(?:$re)$/ } };
  
      ## no critic (Subroutines::ProhibitBuiltinHomonyms)
      sub truncate {
          my $self = shift;
          my %p    = $validator->(@_);
  
          my %new;
          if ( $p{to} eq 'week' || $p{to} eq 'local_week' ) {
              my $first_day_of_week
                  = ( $p{to} eq 'local_week' )
                  ? $self->{locale}->first_day_of_week
                  : 1;
  
              my $day_diff = ( $self->day_of_week - $first_day_of_week ) % 7;
  
              if ($day_diff) {
                  $self->add( days => -1 * $day_diff );
              }
  
              # This can fail if the truncate ends up giving us an invalid local
              # date time. If that happens we need to reverse the addition we
              # just did. See https://rt.cpan.org/Ticket/Display.html?id=93347.
              try {
                  $self->truncate( to => 'day' );
              }
              catch {
                  $self->add( days => $day_diff );
                  die $_;
              };
          }
          elsif ( $p{to} eq 'quarter' ) {
              %new = (
                  year       => $self->year,
                  month      => int( ( $self->month - 1 ) / 3 ) * 3 + 1,
                  day        => 1,
                  hour       => 0,
                  minute     => 0,
                  second     => 0,
                  nanosecond => 0,
              );
          }
          else {
              my $truncate;
              foreach my $f (qw( year month day hour minute second nanosecond ))
              {
                  $new{$f} = $truncate ? $TruncateDefault{$f} : $self->$f();
  
                  $truncate = 1 if $p{to} eq $f;
              }
          }
  
          my $new_dt = $self->_new_from_self( %new, _skip_validation => 1 );
  
          %$self = %$new_dt;
  
          return $self;
      }
  }
  
  sub set_time_zone {
      my ( $self, $tz ) = @_;
  
      if ( ref $tz ) {
  
          # This is a bit of a hack but it works because time zone objects
          # are singletons, and if it doesn't work all we lose is a little
          # bit of speed.
          return $self if $self->{tz} eq $tz;
      }
      else {
          return $self if $self->{tz}->name() eq $tz;
      }
  
      my $was_floating = $self->{tz}->is_floating;
  
      my $old_tz = $self->{tz};
      $self->{tz} = ref $tz ? $tz : DateTime::TimeZone->new( name => $tz );
  
      $self->_handle_offset_modifier( $self->second, 1 );
  
      my $e;
      try {
          # if it either was or now is floating (but not both)
          if ( $self->{tz}->is_floating xor $was_floating ) {
              $self->_calc_utc_rd;
          }
          elsif ( !$was_floating ) {
              $self->_calc_local_rd;
          }
      }
      catch {
          $e = $_;
      };
  
      # If we can't recalc the RD values then we shouldn't keep the new TZ. RT
      # #83940
      if ($e) {
          $self->{tz} = $old_tz;
          die $e;
      }
  
      return $self;
  }
  
  sub STORABLE_freeze {
      my $self = shift;
  
      my $serialized = q{};
      foreach my $key (
          qw( utc_rd_days
          utc_rd_secs
          rd_nanosecs )
      ) {
          $serialized .= "$key:$self->{$key}|";
      }
  
      # not used yet, but may be handy in the future.
      $serialized .= 'version:' . ( $DateTime::VERSION || 'git' );
  
      # Formatter needs to be returned as a reference since it may be
      # undef or a class name, and Storable will complain if extra
      # return values aren't refs
      return $serialized, $self->{locale}, $self->{tz}, \$self->{formatter};
  }
  
  sub STORABLE_thaw {
      my $self = shift;
      shift;
      my $serialized = shift;
  
      my %serialized = map { split /:/ } split /\|/, $serialized;
  
      my ( $locale, $tz, $formatter );
  
      # more recent code version
      if (@_) {
          ( $locale, $tz, $formatter ) = @_;
      }
      else {
          $tz = DateTime::TimeZone->new( name => delete $serialized{tz} );
  
          $locale = DateTime::Locale->load( delete $serialized{locale} );
      }
  
      delete $serialized{version};
  
      my $object = bless {
          utc_vals => [
              $serialized{utc_rd_days},
              $serialized{utc_rd_secs},
              $serialized{rd_nanosecs},
          ],
          tz => $tz,
          },
          'DateTime::_Thawed';
  
      my %formatter = defined $$formatter ? ( formatter => $$formatter ) : ();
      my $new = ( ref $self )->from_object(
          object => $object,
          locale => $locale,
          %formatter,
      );
  
      %$self = %$new;
  
      return $self;
  }
  
  ## no critic (Modules::ProhibitMultiplePackages)
  package    # hide from PAUSE
      DateTime::_Thawed;
  
  sub utc_rd_values { @{ $_[0]->{utc_vals} } }
  
  sub time_zone { $_[0]->{tz} }
  
  1;
  
  # ABSTRACT: A date and time object for Perl
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  DateTime - A date and time object for Perl
  
  =head1 VERSION
  
  version 1.49
  
  =head1 SYNOPSIS
  
    use DateTime;
  
    $dt = DateTime->new(
        year       => 1964,
        month      => 10,
        day        => 16,
        hour       => 16,
        minute     => 12,
        second     => 47,
        nanosecond => 500000000,
        time_zone  => 'Asia/Taipei',
    );
  
    $dt = DateTime->from_epoch( epoch => $epoch );
    $dt = DateTime->now; # same as ( epoch => time() )
  
    $year   = $dt->year;
    $month  = $dt->month;          # 1-12
  
    $day    = $dt->day;            # 1-31
  
    $dow    = $dt->day_of_week;    # 1-7 (Monday is 1)
  
    $hour   = $dt->hour;           # 0-23
    $minute = $dt->minute;         # 0-59
  
    $second = $dt->second;         # 0-61 (leap seconds!)
  
    $doy    = $dt->day_of_year;    # 1-366 (leap years)
  
    $doq    = $dt->day_of_quarter; # 1..
  
    $qtr    = $dt->quarter;        # 1-4
  
    # all of the start-at-1 methods above have corresponding start-at-0
    # methods, such as $dt->day_of_month_0, $dt->month_0 and so on
  
    $ymd    = $dt->ymd;           # 2002-12-06
    $ymd    = $dt->ymd('/');      # 2002/12/06
  
    $mdy    = $dt->mdy;           # 12-06-2002
    $mdy    = $dt->mdy('/');      # 12/06/2002
  
    $dmy    = $dt->dmy;           # 06-12-2002
    $dmy    = $dt->dmy('/');      # 06/12/2002
  
    $hms    = $dt->hms;           # 14:02:29
    $hms    = $dt->hms('!');      # 14!02!29
  
    $is_leap  = $dt->is_leap_year;
  
    # these are localizable, see Locales section
    $month_name  = $dt->month_name; # January, February, ...
    $month_abbr  = $dt->month_abbr; # Jan, Feb, ...
    $day_name    = $dt->day_name;   # Monday, Tuesday, ...
    $day_abbr    = $dt->day_abbr;   # Mon, Tue, ...
  
    # May not work for all possible datetime, see the docs on this
    # method for more details.
    $epoch_time  = $dt->epoch;
  
    $dt2 = $dt + $duration_object;
  
    $dt3 = $dt - $duration_object;
  
    $duration_object = $dt - $dt2;
  
    $dt->set( year => 1882 );
  
    $dt->set_time_zone( 'America/Chicago' );
  
    $dt->set_formatter( $formatter );
  
  =head1 DESCRIPTION
  
  DateTime is a class for the representation of date/time combinations,
  and is part of the Perl DateTime project. For details on this project
  please see L<http://datetime.perl.org/>. The DateTime site has a FAQ
  which may help answer many "how do I do X?" questions. The FAQ is at
  L<http://datetime.perl.org/wiki/datetime/page/FAQ>.
  
  It represents the Gregorian calendar, extended backwards in time
  before its creation (in 1582). This is sometimes known as the
  "proleptic Gregorian calendar". In this calendar, the first day of
  the calendar (the epoch), is the first day of year 1, which
  corresponds to the date which was (incorrectly) believed to be the
  birth of Jesus Christ.
  
  The calendar represented does have a year 0, and in that way differs
  from how dates are often written using "BCE/CE" or "BC/AD".
  
  For infinite datetimes, please see the
  L<DateTime::Infinite|DateTime::Infinite> module.
  
  =head1 USAGE
  
  =head2 0-based Versus 1-based Numbers
  
  The DateTime.pm module follows a simple logic for determining whether or not a
  given number is 0-based or 1-based.
  
  Month, day of month, day of week, and day of year are 1-based. Any
  method that is 1-based also has an equivalent 0-based method ending in
  "_0". So for example, this class provides both C<day_of_week()> and
  C<day_of_week_0()> methods.
  
  The C<day_of_week_0()> method still treats Monday as the first day of
  the week.
  
  All I<time>-related numbers such as hour, minute, and second are
  0-based.
  
  Years are neither, as they can be both positive or negative, unlike
  any other datetime component. There I<is> a year 0.
  
  There is no C<quarter_0()> method.
  
  =head2 Error Handling
  
  Some errors may cause this module to die with an error string. This
  can only happen when calling constructor methods, methods that change
  the object, such as C<set()>, or methods that take parameters.
  Methods that retrieve information about the object, such as C<year()>
  or C<epoch()>, will never die.
  
  =head2 Locales
  
  All the object methods which return names or abbreviations return data based
  on a locale. This is done by setting the locale when constructing a DateTime
  object. If this is not set, then "en-US" is used.
  
  =head2 Floating DateTimes
  
  The default time zone for new DateTime objects, except where stated
  otherwise, is the "floating" time zone. This concept comes from the
  iCal standard. A floating datetime is one which is not anchored to
  any particular time zone. In addition, floating datetimes do not
  include leap seconds, since we cannot apply them without knowing the
  datetime's time zone.
  
  The results of date math and comparison between a floating datetime
  and one with a real time zone are not really valid, because one
  includes leap seconds and the other does not. Similarly, the results
  of datetime math between two floating datetimes and two datetimes with
  time zones are not really comparable.
  
  If you are planning to use any objects with a real time zone, it is
  strongly recommended that you B<do not> mix these with floating
  datetimes.
  
  =head2 Math
  
  If you are going to be doing date math, please read the section L<How DateTime
  Math Works>.
  
  =head2 Determining the Local Time Zone Can Be Slow
  
  If C<$ENV{TZ}> is not set, it may involve reading a number of files in F</etc>
  or elsewhere. If you know that the local time zone won't change while your
  code is running, and you need to make many objects for the local time zone, it
  is strongly recommended that you retrieve the local time zone once and cache
  it:
  
    our $App::LocalTZ = DateTime::TimeZone->new( name => 'local' );
  
    ... # then everywhere else
  
    my $dt = DateTime->new( ..., time_zone => $App::LocalTZ );
  
  DateTime itself does not do this internally because local time zones can
  change, and there's no good way to determine if it's changed without doing all
  the work to look it up.
  
  Do not try to use named time zones (like "America/Chicago") with dates
  very far in the future (thousands of years). The current
  implementation of C<DateTime::TimeZone> will use a huge amount of
  memory calculating all the DST changes from now until the future
  date. Use UTC or the floating time zone and you will be safe.
  
  =head2 Globally Setting a Default Time Zone
  
  B<Warning: This is very dangerous. Do this at your own risk!>
  
  By default, C<DateTime> uses either the floating time zone or UTC for newly
  created objects, depending on the constructor.
  
  You can force C<DateTime> to use a different time zone by setting the
  C<PERL_DATETIME_DEFAULT_TZ> environment variable.
  
  As noted above, this is very dangerous, as it affects all code that creates a
  C<DateTime> object, including modules from CPAN. If those modules expect the
  normal default, then setting this can cause confusing breakage or subtly
  broken data. Before setting this variable, you are strongly encouraged to
  audit your CPAN dependencies to see how they use C<DateTime>. Try running the
  test suite for each dependency with this environment variable set before using
  this in production.
  
  =head2 Upper and Lower Bounds
  
  Internally, dates are represented the number of days before or after
  0001-01-01. This is stored as an integer, meaning that the upper and lower
  bounds are based on your Perl's integer size (C<$Config{ivsize}>).
  
  The limit on 32-bit systems is around 2^29 days, which gets you to year
  (+/-)1,469,903. On a 64-bit system you get 2^62 days,
  (+/-)12,626,367,463,883,278 (12.626 quadrillion).
  
  =head1 METHODS
  
  DateTime provide many methods. The documentation breaks them down into groups
  based on what they do (constructor, accessors, modifiers, etc.).
  
  =head2 Constructors
  
  All constructors can die when invalid parameters are given.
  
  =head3 Warnings
  
  Currently, constructors will warn if you try to create a far future DateTime
  (year >= 5000) with any time zone besides floating or UTC. This can be very
  slow if the time zone has future DST transitions that need to be
  calculated. If the date is sufficiently far in the future this can be
  I<really> slow (minutes).
  
  All warnings from DateTime use the C<DateTime> category and can be suppressed
  with:
  
      no warnings 'DateTime';
  
  This warning may be removed in the future if L<DateTime::TimeZone> is made
  much faster.
  
  =head3 DateTime->new( ... )
  
  This class method accepts parameters for each date and time component:
  "year", "month", "day", "hour", "minute", "second", "nanosecond".
  It also accepts "locale", "time_zone", and "formatter" parameters.
  
    my $dt = DateTime->new(
        year       => 1966,
        month      => 10,
        day        => 25,
        hour       => 7,
        minute     => 15,
        second     => 47,
        nanosecond => 500000000,
        time_zone  => 'America/Chicago',
    );
  
  DateTime validates the "month", "day", "hour", "minute", and "second",
  and "nanosecond" parameters. The valid values for these parameters are:
  
  =over 8
  
  =item * month
  
  An integer from 1-12.
  
  =item * day
  
  An integer from 1-31, and it must be within the valid range of days for the
  specified month.
  
  =item * hour
  
  An integer from 0-23.
  
  =item * minute
  
  An integer from 0-59.
  
  =item * second
  
  An integer from 0-61 (to allow for leap seconds). Values of 60 or 61 are only
  allowed when they match actual leap seconds.
  
  =item * nanosecond
  
  An integer >= 0. If this number is greater than 1 billion, it will be
  normalized into the second value for the DateTime object.
  
  =back
  
  Invalid parameter types (like an array reference) will cause the
  constructor to die.
  
  The value for seconds may be from 0 to 61, to account for leap
  seconds. If you give a value greater than 59, DateTime does check to
  see that it really matches a valid leap second.
  
  All of the parameters are optional except for "year". The "month" and
  "day" parameters both default to 1, while the "hour", "minute",
  "second", and "nanosecond" parameters all default to 0.
  
  The "locale" parameter should be a string containing a locale code, like
  "en-US" or "zh-Hant-TW", or an object returned by C<< DateTime::Locale->load
  >>. See the L<DateTime::Locale|DateTime::Locale> documentation for details.
  
  The "time_zone" parameter can be either a string or a C<DateTime::TimeZone>
  object. A string will simply be passed to the C<< DateTime::TimeZone->new >>
  method as its "name" parameter. This string may be an Olson DB time zone name
  ("America/Chicago"), an offset string ("+0630"), or the words "floating" or
  "local". See the C<DateTime::TimeZone> documentation for more details.
  
  The default time zone is "floating".
  
  The "formatter" can be either a scalar or an object, but the class
  specified by the scalar or the object must implement a
  C<format_datetime()> method.
  
  =head4 Parsing Dates
  
  B<This module does not parse dates!> That means there is no
  constructor to which you can pass things like "March 3, 1970 12:34".
  
  Instead, take a look at the various C<DateTime::Format::*> modules on
  CPAN. These parse all sorts of different date formats, and you're
  bound to find something that can handle your particular needs.
  
  =head4 Ambiguous Local Times
  
  Because of Daylight Saving Time, it is possible to specify a local
  time that is ambiguous. For example, in the US in 2003, the
  transition from to saving to standard time occurred on October 26, at
  02:00:00 local time. The local clock changed from 01:59:59 (saving
  time) to 01:00:00 (standard time). This means that the hour from
  01:00:00 through 01:59:59 actually occurs twice, though the UTC time
  continues to move forward.
  
  If you specify an ambiguous time, then the latest UTC time is always
  used, in effect always choosing standard time. In this case, you can
  simply subtract an hour to the object in order to move to saving time,
  for example:
  
    # This object represent 01:30:00 standard time
    my $dt = DateTime->new(
        year      => 2003,
        month     => 10,
        day       => 26,
        hour      => 1,
        minute    => 30,
        second    => 0,
        time_zone => 'America/Chicago',
    );
  
    print $dt->hms;  # prints 01:30:00
  
    # Now the object represent 01:30:00 saving time
    $dt->subtract( hours => 1 );
  
    print $dt->hms;  # still prints 01:30:00
  
  Alternately, you could create the object with the UTC time zone, and
  then call the C<set_time_zone()> method to change the time zone. This
  is a good way to ensure that the time is not ambiguous.
  
  =head4 Invalid Local Times
  
  Another problem introduced by Daylight Saving Time is that certain
  local times just do not exist. For example, in the US in 2003, the
  transition from standard to saving time occurred on April 6, at the
  change to 2:00:00 local time. The local clock changes from 01:59:59
  (standard time) to 03:00:00 (saving time). This means that there is
  no 02:00:00 through 02:59:59 on April 6!
  
  Attempting to create an invalid time currently causes a fatal error.
  This may change in future version of this module.
  
  =head3 DateTime->from_epoch( epoch => $epoch, ... )
  
  This class method can be used to construct a new DateTime object from
  an epoch time instead of components. Just as with the C<new()>
  method, it accepts "time_zone", "locale", and "formatter" parameters.
  
  If the epoch value is a floating-point value, it will be rounded to
  nearest microsecond.
  
  By default, the returned object will be in the UTC time zone.
  
  =head3 DateTime->now( ... )
  
  This class method is equivalent to calling C<from_epoch()> with the
  value returned from Perl's C<time()> function. Just as with the
  C<new()> method, it accepts "time_zone" and "locale" parameters.
  
  By default, the returned object will be in the UTC time zone.
  
  =head3 DateTime->today( ... )
  
  This class method is equivalent to:
  
    DateTime->now(@_)->truncate( to => 'day' );
  
  =head3 DateTime->from_object( object => $object, ... )
  
  This class method can be used to construct a new DateTime object from
  any object that implements the C<utc_rd_values()> method. All
  C<DateTime::Calendar> modules must implement this method in order to
  provide cross-calendar compatibility. This method accepts a
  "locale" and "formatter" parameter
  
  If the object passed to this method has a C<time_zone()> method, that
  is used to set the time zone of the newly created C<DateTime.pm>
  object.
  
  Otherwise, the returned object will be in the floating time zone.
  
  =head3 DateTime->last_day_of_month( ... )
  
  This constructor takes the same arguments as can be given to the
  C<new()> method, except for "day". Additionally, both "year" and
  "month" are required.
  
  =head3 DateTime->from_day_of_year( ... )
  
  This constructor takes the same arguments as can be given to the
  C<new()> method, except that it does not accept a "month" or "day"
  argument. Instead, it requires both "year" and "day_of_year". The
  day of year must be between 1 and 366, and 366 is only allowed for
  leap years.
  
  =head3 $dt->clone()
  
  This object method returns a new object that is replica of the object
  upon which the method is called.
  
  =head2 "Get" Methods
  
  This class has many methods for retrieving information about an
  object.
  
  =head3 $dt->year()
  
  Returns the year.
  
  =head3 $dt->ce_year()
  
  Returns the year according to the BCE/CE numbering system. The year
  before year 1 in this system is year -1, aka "1 BCE".
  
  =head3 $dt->era_name()
  
  Returns the long name of the current era, something like "Before
  Christ". See the L<Locales|/Locales> section for more details.
  
  =head3 $dt->era_abbr()
  
  Returns the abbreviated name of the current era, something like "BC".
  See the L<Locales|/Locales> section for more details.
  
  =head3 $dt->christian_era()
  
  Returns a string, either "BC" or "AD", according to the year.
  
  =head3 $dt->secular_era()
  
  Returns a string, either "BCE" or "CE", according to the year.
  
  =head3 $dt->year_with_era()
  
  Returns a string containing the year immediately followed by its era
  abbreviation. The year is the absolute value of C<ce_year()>, so that
  year 1 is "1AD" and year 0 is "1BC".
  
  =head3 $dt->year_with_christian_era()
  
  Like C<year_with_era()>, but uses the christian_era() method to get the era
  name.
  
  =head3 $dt->year_with_secular_era()
  
  Like C<year_with_era()>, but uses the secular_era() method to get the
  era name.
  
  =head3 $dt->month()
  
  Returns the month of the year, from 1..12.
  
  Also available as C<< $dt->mon() >>.
  
  =head3 $dt->month_name()
  
  Returns the name of the current month. See the
  L<Locales|/Locales> section for more details.
  
  =head3 $dt->month_abbr()
  
  Returns the abbreviated name of the current month. See the
  L<Locales|/Locales> section for more details.
  
  =head3 $dt->day()
  
  Returns the day of the month, from 1..31.
  
  Also available as C<< $dt->mday() >> and C<< $dt->day_of_month() >>.
  
  =head3 $dt->day_of_week()
  
  Returns the day of the week as a number, from 1..7, with 1 being
  Monday and 7 being Sunday.
  
  Also available as C<< $dt->wday() >> and C<< $dt->dow() >>.
  
  =head3 $dt->local_day_of_week()
  
  Returns the day of the week as a number, from 1..7. The day
  corresponding to 1 will vary based on the locale.
  
  =head3 $dt->day_name()
  
  Returns the name of the current day of the week. See the
  L<Locales|/Locales> section for more details.
  
  =head3 $dt->day_abbr()
  
  Returns the abbreviated name of the current day of the week. See the
  L<Locales|/Locales> section for more details.
  
  =head3 $dt->day_of_year()
  
  Returns the day of the year.
  
  Also available as C<< $dt->doy() >>.
  
  =head3 $dt->quarter()
  
  Returns the quarter of the year, from 1..4.
  
  =head3 $dt->quarter_name()
  
  Returns the name of the current quarter. See the
  L<Locales|/Locales> section for more details.
  
  =head3 $dt->quarter_abbr()
  
  Returns the abbreviated name of the current quarter. See the
  L<Locales|/Locales> section for more details.
  
  =head3 $dt->day_of_quarter()
  
  Returns the day of the quarter.
  
  Also available as C<< $dt->doq() >>.
  
  =head3 $dt->weekday_of_month()
  
  Returns a number from 1..5 indicating which week day of the month this
  is. For example, June 9, 2003 is the second Monday of the month, and
  so this method returns 2 for that day.
  
  =head3 $dt->ymd( $optional_separator ), $dt->mdy(...), $dt->dmy(...)
  
  Each method returns the year, month, and day, in the order indicated
  by the method name. Years are zero-padded to four digits. Months and
  days are 0-padded to two digits.
  
  By default, the values are separated by a dash (-), but this can be
  overridden by passing a value to the method.
  
  The C<< $dt->ymd() >> method is also available as C<< $dt->date() >>.
  
  =head3 $dt->hour()
  
  Returns the hour of the day, from 0..23.
  
  =head3 $dt->hour_1()
  
  Returns the hour of the day, from 1..24.
  
  =head3 $dt->hour_12()
  
  Returns the hour of the day, from 1..12.
  
  =head3 $dt->hour_12_0()
  
  Returns the hour of the day, from 0..11.
  
  =head3 $dt->am_or_pm()
  
  Returns the appropriate localized abbreviation, depending on the
  current hour.
  
  =head3 $dt->minute()
  
  Returns the minute of the hour, from 0..59.
  
  Also available as C<< $dt->min() >>.
  
  =head3 $dt->second()
  
  Returns the second, from 0..61. The values 60 and 61 are used for
  leap seconds.
  
  Also available as C<< $dt->sec() >>.
  
  =head3 $dt->fractional_second()
  
  Returns the second, as a real number from 0.0 until 61.999999999
  
  The values 60 and 61 are used for leap seconds.
  
  =head3 $dt->millisecond()
  
  Returns the fractional part of the second as milliseconds (1E-3 seconds).
  
  Half a second is 500 milliseconds.
  
  This value will always be rounded down to the nearest integer.
  
  =head3 $dt->microsecond()
  
  Returns the fractional part of the second as microseconds (1E-6
  seconds).
  
  Half a second is 500_000 microseconds.
  
  This value will always be rounded down to the nearest integer.
  
  =head3 $dt->nanosecond()
  
  Returns the fractional part of the second as nanoseconds (1E-9 seconds).
  
  Half a second is 500_000_000 nanoseconds.
  
  =head3 $dt->hms( $optional_separator )
  
  Returns the hour, minute, and second, all zero-padded to two digits.
  If no separator is specified, a colon (:) is used by default.
  
  Also available as C<< $dt->time() >>.
  
  =head3 $dt->datetime( $optional_separator )
  
  This method is equivalent to:
  
    $dt->ymd('-') . 'T' . $dt->hms(':')
  
  The C<$optional_separator> parameter allows you to override the separator
  between the date and time, for e.g. C<< $dt->datetime(q{ }) >>.
  
  This method is also available as C<< $dt->iso8601() >>, but it's not really a
  very good ISO8601 format, as it lacks a time zone.  If called as
  C<< $dt->iso8601() >> you cannot change the separator, as ISO8601 specifies
  that "T" must be used to separate them.
  
  =head3 $dt->stringify()
  
  This method returns a stringified version of the object. It is how
  stringification overloading is implemented. If the object has a formatter,
  then its C<format_datetime()> method is used to produce a string. Otherwise,
  this method calls C<< $dt->iso8601() >> to produce a string. See L<Formatters
  And Stringification> for details.
  
  =head3 $dt->is_leap_year()
  
  This method returns a true or false value indicating whether or not the
  datetime object is in a leap year.
  
  =head3 $dt->is_last_day_of_month()
  
  This method returns a true or false value indicating whether or not the
  datetime object is the last day of the month.
  
  =head3 $dt->is_last_day_of_quarter()
  
  This method returns a true or false value indicating whether or not the
  datetime object is the last day of the quarter.
  
  =head3 $dt->is_last_day_of_year()
  
  This method returns a true or false value indicating whether or not the
  datetime object is the last day of the year.
  
  =head3 $dt->month_length()
  
  This method returns the number of days in the current month.
  
  =head3 $dt->quarter_length()
  
  This method returns the number of days in the current quarter.
  
  =head3 $dt->year_length()
  
  This method returns the number of days in the current year.
  
  =head3 $dt->week()
  
   ($week_year, $week_number) = $dt->week;
  
  Returns information about the calendar week which contains this
  datetime object. The values returned by this method are also available
  separately through the week_year and week_number methods.
  
  The first week of the year is defined by ISO as the one which contains
  the fourth day of January, which is equivalent to saying that it's the
  first week to overlap the new year by at least four days.
  
  Typically the week year will be the same as the year that the object
  is in, but dates at the very beginning of a calendar year often end up
  in the last week of the prior year, and similarly, the final few days
  of the year may be placed in the first week of the next year.
  
  =head3 $dt->week_year()
  
  Returns the year of the week. See C<< $dt->week() >> for details.
  
  =head3 $dt->week_number()
  
  Returns the week of the year, from 1..53. See C<< $dt->week() >> for details.
  
  =head3 $dt->week_of_month()
  
  The week of the month, from 0..5. The first week of the month is the
  first week that contains a Thursday. This is based on the ICU
  definition of week of month, and correlates to the ISO8601 week of
  year definition. A day in the week I<before> the week with the first
  Thursday will be week 0.
  
  =head3 $dt->jd(), $dt->mjd()
  
  These return the Julian Day and Modified Julian Day, respectively.
  The value returned is a floating point number. The fractional portion
  of the number represents the time portion of the datetime.
  
  =head3 $dt->time_zone()
  
  This returns the C<DateTime::TimeZone> object for the datetime object.
  
  =head3 $dt->offset()
  
  This returns the offset from UTC, in seconds, of the datetime object
  according to the time zone.
  
  =head3 $dt->is_dst()
  
  Returns a boolean indicating whether or not the datetime object is
  currently in Daylight Saving Time or not.
  
  =head3 $dt->time_zone_long_name()
  
  This is a shortcut for C<< $dt->time_zone->name >>. It's provided so
  that one can use "%{time_zone_long_name}" as a strftime format
  specifier.
  
  =head3 $dt->time_zone_short_name()
  
  This method returns the time zone abbreviation for the current time
  zone, such as "PST" or "GMT". These names are B<not> definitive, and
  should not be used in any application intended for general use by
  users around the world.
  
  =head3 $dt->strftime( $format, ... )
  
  This method implements functionality similar to the C<strftime()>
  method in C. However, if given multiple format strings, then it will
  return multiple scalars, one for each format string.
  
  See the L<strftime Patterns> section for a list of all possible
  strftime patterns.
  
  If you give a pattern that doesn't exist, then it is simply treated as
  text.
  
  =head3 $dt->format_cldr( $format, ... )
  
  This method implements formatting based on the CLDR date patterns. If
  given multiple format strings, then it will return multiple scalars,
  one for each format string.
  
  See the L<CLDR Patterns> section for a list of all possible CLDR
  patterns.
  
  If you give a pattern that doesn't exist, then it is simply treated as
  text.
  
  =head3 $dt->epoch()
  
  Return the UTC epoch value for the datetime object. Datetimes before the start
  of the epoch will be returned as a negative number.
  
  The return value from this method is always an integer.
  
  Since the epoch does not account for leap seconds, the epoch time for
  1972-12-31T23:59:60 (UTC) is exactly the same as that for
  1973-01-01T00:00:00.
  
  =head3 $dt->hires_epoch()
  
  Returns the epoch as a floating point number. The floating point
  portion of the value represents the nanosecond value of the object.
  This method is provided for compatibility with the C<Time::HiRes>
  module.
  
  Note that this method suffers from the imprecision of floating point numbers,
  and the result may end up rounded to an arbitrary degree depending on your
  platform.
  
      my $dt = DateTime->new( year => 2012, nanosecond => 4 );
      say $dt->hires_epoch();
  
  On my system, this simply prints C<1325376000> because adding C<0.000000004>
  to C<1325376000> returns C<1325376000>.
  
  =head3 $dt->is_finite(), $dt->is_infinite()
  
  These methods allow you to distinguish normal datetime objects from
  infinite ones. Infinite datetime objects are documented in
  L<DateTime::Infinite|DateTime::Infinite>.
  
  =head3 $dt->utc_rd_values()
  
  Returns the current UTC Rata Die days, seconds, and nanoseconds as a
  three element list. This exists primarily to allow other calendar
  modules to create objects based on the values provided by this object.
  
  =head3 $dt->local_rd_values()
  
  Returns the current local Rata Die days, seconds, and nanoseconds as a
  three element list. This exists for the benefit of other modules
  which might want to use this information for date math, such as
  C<DateTime::Event::Recurrence>.
  
  =head3 $dt->leap_seconds()
  
  Returns the number of leap seconds that have happened up to the
  datetime represented by the object. For floating datetimes, this
  always returns 0.
  
  =head3 $dt->utc_rd_as_seconds()
  
  Returns the current UTC Rata Die days and seconds purely as seconds.
  This number ignores any fractional seconds stored in the object,
  as well as leap seconds.
  
  =head3 $dt->locale()
  
  Returns the current locale object.
  
  =head3 $dt->formatter()
  
  Returns current formatter object or class. See L<Formatters And
  Stringification> for details.
  
  =head2 "Set" Methods
  
  The remaining methods provided by C<DateTime.pm>, except where otherwise
  specified, return the object itself, thus making method chaining
  possible. For example:
  
    my $dt = DateTime->now->set_time_zone( 'Australia/Sydney' );
  
    my $first = DateTime
                  ->last_day_of_month( year => 2003, month => 3 )
                  ->add( days => 1 )
                  ->subtract( seconds => 1 );
  
  =head3 $dt->set( .. )
  
  This method can be used to change the local components of a date time. This
  method accepts any parameter allowed by the C<new()> method except for
  "locale" or "time_zone". Use C<set_locale()> and C<set_time_zone()> for those
  instead.
  
  This method performs parameter validation just like the C<new()> method.
  
  B<Do not use this method to do date math. Use the C<add()> and C<subtract()>
  methods instead.>
  
  =head3 $dt->set_year(), $dt->set_month(), etc.
  
  DateTime has a C<set_*> method for every item that can be passed to the
  constructor:
  
  =over 4
  
  =item * $dt->set_year()
  
  =item * $dt->set_month()
  
  =item * $dt->set_day()
  
  =item * $dt->set_hour()
  
  =item * $dt->set_minute()
  
  =item * $dt->set_second()
  
  =item * $dt->set_nanosecond()
  
  =back
  
  These are shortcuts to calling C<set()> with a single key. They all
  take a single parameter.
  
  =head3 $dt->truncate( to => ... )
  
  This method allows you to reset some of the local time components in the
  object to their "zero" values. The "to" parameter is used to specify which
  values to truncate, and it may be one of "year", "quarter", "month", "week",
  "local_week", "day", "hour", "minute", or "second".
  
  For example, if "month" is specified, then the local day becomes 1, and the
  hour, minute, and second all become 0.
  
  If "week" is given, then the datetime is set to the Monday of the week in
  which it occurs, and the time components are all set to 0. If you truncate to
  "local_week", then the first day of the week is locale-dependent. For example,
  in the C<en-US> locale, the first day of the week is Sunday.
  
  =head3 $dt->set_locale( $locale )
  
  Sets the object's locale. You can provide either a locale code like "en-US" or
  an object returned by C<< DateTime::Locale->load >>.
  
  =head3 $dt->set_time_zone( $tz )
  
  This method accepts either a time zone object or a string that can be
  passed as the "name" parameter to C<< DateTime::TimeZone->new() >>.
  If the new time zone's offset is different from the old time zone,
  then the I<local> time is adjusted accordingly.
  
  For example:
  
    my $dt = DateTime->new(
        year      => 2000,
        month     => 5,
        day       => 10,
        hour      => 15,
        minute    => 15,
        time_zone => 'America/Los_Angeles',
    );
  
    print $dt->hour; # prints 15
  
    $dt->set_time_zone( 'America/Chicago' );
  
    print $dt->hour; # prints 17
  
  If the old time zone was a floating time zone, then no adjustments to
  the local time are made, except to account for leap seconds. If the
  new time zone is floating, then the I<UTC> time is adjusted in order
  to leave the local time untouched.
  
  Fans of Tsai Ming-Liang's films will be happy to know that this does
  work:
  
    my $dt = DateTime->now( time_zone => 'Asia/Taipei' );
  
    $dt->set_time_zone( 'Europe/Paris' );
  
  Yes, now we can know "ni3 na4 bian1 ji2dian3?"
  
  =head3 $dt->set_formatter( $formatter )
  
  Set the formatter for the object. See L<Formatters And
  Stringification> for details.
  
  You can set this to C<undef> to revert to the default formatter.
  
  =head2 Math Methods
  
  Like the set methods, math related methods always return the object
  itself, to allow for chaining:
  
    $dt->add( days => 1 )->subtract( seconds => 1 );
  
  =head3 $dt->duration_class()
  
  This returns C<DateTime::Duration>, but exists so that a subclass of
  C<DateTime.pm> can provide a different value.
  
  =head3 $dt->add_duration( $duration_object )
  
  This method adds a C<DateTime::Duration> to the current datetime. See
  the L<DateTime::Duration|DateTime::Duration> docs for more details.
  
  =head3 $dt->add( parameters for DateTime::Duration )
  
  This method is syntactic sugar around the C<add_duration()> method. It
  simply creates a new C<DateTime::Duration> object using the parameters
  given, and then calls the C<add_duration()> method.
  
  =head3 $dt->add( $duration_object )
  
  A synonym of C<< $dt->add_duration( $duration_object ) >>.
  
  =head3 $dt->subtract_duration( $duration_object )
  
  When given a C<DateTime::Duration> object, this method simply calls
  C<invert()> on that object and passes that new duration to the
  C<add_duration> method.
  
  =head3 $dt->subtract( DateTime::Duration->new parameters )
  
  Like C<add()>, this is syntactic sugar for the C<subtract_duration()>
  method.
  
  =head3 $dt->subtract( $duration_object )
  
  A synonym of C<< $dt->subtract_duration( $duration_object ) >>.
  
  =head3 $dt->subtract_datetime( $datetime )
  
  This method returns a new C<DateTime::Duration> object representing
  the difference between the two dates. The duration is B<relative> to
  the object from which C<$datetime> is subtracted. For example:
  
      2003-03-15 00:00:00.00000000
   -  2003-02-15 00:00:00.00000000
   -------------------------------
   = 1 month
  
  Note that this duration is not an absolute measure of the amount of
  time between the two datetimes, because the length of a month varies,
  as well as due to the presence of leap seconds.
  
  The returned duration may have deltas for months, days, minutes,
  seconds, and nanoseconds.
  
  =head3 $dt->delta_md( $datetime )
  
  =head3 $dt->delta_days( $datetime )
  
  Each of these methods returns a new C<DateTime::Duration> object
  representing some portion of the difference between two datetimes.
  The C<delta_md()> method returns a duration which contains only the
  month and day portions of the duration is represented. The
  C<delta_days()> method returns a duration which contains only days.
  
  The C<delta_md> and C<delta_days> methods truncate the duration so
  that any fractional portion of a day is ignored. Both of these
  methods operate on the date portion of a datetime only, and so
  effectively ignore the time zone.
  
  Unlike the subtraction methods, B<these methods always return a
  positive (or zero) duration>.
  
  =head3 $dt->delta_ms( $datetime )
  
  Returns a duration which contains only minutes and seconds. Any day
  and month differences to minutes are converted to minutes and
  seconds. This method also B<always return a positive (or zero)
  duration>.
  
  =head3 $dt->subtract_datetime_absolute( $datetime )
  
  This method returns a new C<DateTime::Duration> object representing
  the difference between the two dates in seconds and nanoseconds. This
  is the only way to accurately measure the absolute amount of time
  between two datetimes, since units larger than a second do not
  represent a fixed number of seconds.
  
  Note that because of leap seconds, this may not return the same result as
  doing this math based on the value returned by C<< $dt->epoch() >>.
  
  =head2 Class Methods
  
  =head3 DateTime->DefaultLocale( $locale )
  
  This can be used to specify the default locale to be used when
  creating DateTime objects. If unset, then "en-US" is used.
  
  =head3 DateTime->compare( $dt1, $dt2 ), DateTime->compare_ignore_floating( $dt1, $dt2 )
  
    $cmp = DateTime->compare( $dt1, $dt2 );
  
    $cmp = DateTime->compare_ignore_floating( $dt1, $dt2 );
  
  Compare two DateTime objects. The semantics are compatible with Perl's
  C<sort()> function; it returns -1 if $dt1 < $dt2, 0 if $dt1 == $dt2, 1 if $dt1
  > $dt2.
  
  If one of the two DateTime objects has a floating time zone, it will
  first be converted to the time zone of the other object. This is what
  you want most of the time, but it can lead to inconsistent results
  when you compare a number of DateTime objects, some of which are
  floating, and some of which are in other time zones.
  
  If you want to have consistent results (because you want to sort a
  number of objects, for example), you can use the
  C<compare_ignore_floating()> method:
  
    @dates = sort { DateTime->compare_ignore_floating($a, $b) } @dates;
  
  In this case, objects with a floating time zone will be sorted as if
  they were UTC times.
  
  Since DateTime objects overload comparison operators, this:
  
    @dates = sort @dates;
  
  is equivalent to this:
  
    @dates = sort { DateTime->compare($a, $b) } @dates;
  
  DateTime objects can be compared to any other calendar class that
  implements the C<utc_rd_values()> method.
  
  =head2 Testing Code That Uses DateTime
  
  If you are trying to test code that calls uses DateTime, you may want to be
  able to explicitly set the value returned by Perl's C<time()> builtin. This
  builtin is called by C<< DateTime->now() >> and C<< DateTime->today() >>.
  
  You can  override C<CORE::GLOBAL::time()>, but this  will only work if  you do
  this B<before> loading  DateTime. If doing this is inconvenient,  you can also
  override C<DateTime::_core_time()>:
  
      no warnings 'redefine';
      local *DateTime::_core_time = sub { return 42 };
  
  DateTime is guaranteed to call this subroutine to get the current C<time()>
  value. You can also override the C<_core_time()> sub in a subclass of DateTime
  and use that.
  
  =head2 How DateTime Math Works
  
  It's important to have some understanding of how datetime math is
  implemented in order to effectively use this module and
  C<DateTime::Duration>.
  
  =head3 Making Things Simple
  
  If you want to simplify your life and not have to think too hard about
  the nitty-gritty of datetime math, I have several recommendations:
  
  =over 4
  
  =item * use the floating time zone
  
  If you do not care about time zones or leap seconds, use the
  "floating" timezone:
  
    my $dt = DateTime->now( time_zone => 'floating' );
  
  Math done on two objects in the floating time zone produces very
  predictable results.
  
  Note that in most cases you will want to start by creating an object in a
  specific zone and I<then> convert it to the floating time zone. When an object
  goes from a real zone to the floating zone, the time for the object remains
  the same.
  
  This means that passing the floating zone to a constructor may not do what you
  want.
  
    my $dt = DateTime->now( time_zone => 'floating' );
  
  is equivalent to
  
    my $dt = DateTime->now( time_zone => 'UTC' )->set_time_zone('floating');
  
  This might not be what you wanted. Instead, you may prefer to do this:
  
    my $dt = DateTime->now( time_zone => 'local' )->set_time_zone('floating');
  
  =item * use UTC for all calculations
  
  If you do care about time zones (particularly DST) or leap seconds,
  try to use non-UTC time zones for presentation and user input only.
  Convert to UTC immediately and convert back to the local time zone for
  presentation:
  
    my $dt = DateTime->new( %user_input, time_zone => $user_tz );
    $dt->set_time_zone('UTC');
  
    # do various operations - store it, retrieve it, add, subtract, etc.
  
    $dt->set_time_zone($user_tz);
    print $dt->datetime;
  
  =item * math on non-UTC time zones
  
  If you need to do date math on objects with non-UTC time zones, please
  read the caveats below carefully. The results C<DateTime.pm> produces are
  predictable and correct, and mostly intuitive, but datetime math gets
  very ugly when time zones are involved, and there are a few strange
  corner cases involving subtraction of two datetimes across a DST
  change.
  
  If you can always use the floating or UTC time zones, you can skip
  ahead to L<Leap Seconds and Date Math>
  
  =item * date vs datetime math
  
  If you only care about the date (calendar) portion of a datetime, you
  should use either C<delta_md()> or C<delta_days()>, not
  C<subtract_datetime()>. This will give predictable, unsurprising
  results, free from DST-related complications.
  
  =item * subtract_datetime() and add_duration()
  
  You must convert your datetime objects to the UTC time zone before
  doing date math if you want to make sure that the following formulas
  are always true:
  
    $dt2 - $dt1 = $dur
    $dt1 + $dur = $dt2
    $dt2 - $dur = $dt1
  
  Note that using C<delta_days> ensures that this formula always works,
  regardless of the timezone of the objects involved, as does using
  C<subtract_datetime_absolute()>. Other methods of subtraction are not
  always reversible.
  
  =item * never do math on two objects where only one is in the floating time zone
  
  The date math code accounts for leap seconds whenever the C<DateTime> object
  is not in the floating time zone. If you try to do math where one object is in
  the floating zone and the other isn't, the results will be confusing and
  wrong.
  
  =back
  
  =head3 Adding a Duration to a Datetime
  
  The parts of a duration can be broken down into five parts. These are
  months, days, minutes, seconds, and nanoseconds. Adding one month to
  a date is different than adding 4 weeks or 28, 29, 30, or 31 days.
  Similarly, due to DST and leap seconds, adding a day can be different
  than adding 86,400 seconds, and adding a minute is not exactly the
  same as 60 seconds.
  
  We cannot convert between these units, except for seconds and
  nanoseconds, because there is no fixed conversion between the two
  units, because of things like leap seconds, DST changes, etc.
  
  C<DateTime.pm> always adds (or subtracts) days, then months, minutes, and then
  seconds and nanoseconds. If there are any boundary overflows, these are
  normalized at each step. For the days and months the local (not UTC) values
  are used. For minutes and seconds, the local values are used. This generally
  just works.
  
  This means that adding one month and one day to February 28, 2003 will
  produce the date April 1, 2003, not March 29, 2003.
  
    my $dt = DateTime->new( year => 2003, month => 2, day => 28 );
  
    $dt->add( months => 1, days => 1 );
  
    # 2003-04-01 - the result
  
  On the other hand, if we add months first, and then separately add
  days, we end up with March 29, 2003:
  
    $dt->add( months => 1 )->add( days => 1 );
  
    # 2003-03-29
  
  We see similar strangeness when math crosses a DST boundary:
  
    my $dt = DateTime->new(
        year      => 2003,
        month     => 4,
        day       => 5,
        hour      => 1,
        minute    => 58,
        time_zone => "America/Chicago",
    );
  
    $dt->add( days => 1, minutes => 3 );
    # 2003-04-06 02:01:00
  
    $dt->add( minutes => 3 )->add( days => 1 );
    # 2003-04-06 03:01:00
  
  Note that if you converted the datetime object to UTC first you would
  get predictable results.
  
  If you want to know how many seconds a duration object represents, you
  have to add it to a datetime to find out, so you could do:
  
   my $now = DateTime->now( time_zone => 'UTC' );
   my $later = $now->clone->add_duration($duration);
  
   my $seconds_dur = $later->subtract_datetime_absolute($now);
  
  This returns a duration which only contains seconds and nanoseconds.
  
  If we were add the duration to a different datetime object we might
  get a different number of seconds.
  
  L<DateTime::Duration> supports three different end-of-month algorithms for
  adding months. This comes into play when an addition results in a day past the
  end of the month (for example, adding one month to January 30).
  
   # 2010-08-31 + 1 month = 2010-10-01
   $dt->add( months => 1, end_of_month => 'wrap' );
  
   # 2010-01-30 + 1 month = 2010-02-28
   $dt->add( months => 1, end_of_month => 'limit' );
  
   # 2010-04-30 + 1 month = 2010-05-31
   $dt->add( months => 1, end_of_month => 'preserve' );
  
  By default, it uses "wrap" for positive durations and "preserve" for negative
  durations. See L<DateTime::Duration> for a detailed explanation of these
  algorithms.
  
  If you need to do lots of work with durations, take a look at Rick
  Measham's C<DateTime::Format::Duration> module, which lets you present
  information from durations in many useful ways.
  
  There are other subtract/delta methods in DateTime.pm to generate
  different types of durations. These methods are
  C<subtract_datetime()>, C<subtract_datetime_absolute()>,
  C<delta_md()>, C<delta_days()>, and C<delta_ms()>.
  
  =head3 Datetime Subtraction
  
  Date subtraction is done solely based on the two object's local
  datetimes, with one exception to handle DST changes. Also, if the two
  datetime objects are in different time zones, one of them is converted
  to the other's time zone first before subtraction. This is best
  explained through examples:
  
  The first of these probably makes the most sense:
  
    my $dt1 = DateTime->new(
        year      => 2003,
        month     => 5,
        day       => 6,
        time_zone => 'America/Chicago',
    );
  
    # not DST
  
    my $dt2 = DateTime->new(
        year      => 2003,
        month     => 11,
        day       => 6,
        time_zone => 'America/Chicago',
    );
  
    # is DST
  
    my $dur = $dt2->subtract_datetime($dt1);
    # 6 months
  
  Nice and simple.
  
  This one is a little trickier, but still fairly logical:
  
    my $dt1 = DateTime->new(
        year      => 2003,
        month     => 4,
        day       => 5,
        hour      => 1,
        minute    => 58,
        time_zone => "America/Chicago",
    );
  
    # is DST
  
    my $dt2 = DateTime->new(
        year      => 2003,
        month     => 4,
        day       => 7,
        hour      => 2,
        minute    => 1,
        time_zone => "America/Chicago",
    );
  
    # not DST
  
    my $dur = $dt2->subtract_datetime($dt1);
  
    # 2 days and 3 minutes
  
  Which contradicts the result this one gives, even though they both
  make sense:
  
    my $dt1 = DateTime->new(
        year      => 2003,
        month     => 4,
        day       => 5,
        hour      => 1,
        minute    => 58,
        time_zone => "America/Chicago",
    );
  
    # is DST
  
    my $dt2 = DateTime->new(
        year      => 2003,
        month     => 4,
        day       => 6,
        hour      => 3,
        minute    => 1,
        time_zone => "America/Chicago",
    );
  
    # not DST
  
    my $dur = $dt2->subtract_datetime($dt1);
  
    # 1 day and 3 minutes
  
  This last example illustrates the "DST" exception mentioned earlier.
  The exception accounts for the fact 2003-04-06 only lasts 23 hours.
  
  And finally:
  
    my $dt2 = DateTime->new(
        year      => 2003,
        month     => 10,
        day       => 26,
        hour      => 1,
        time_zone => 'America/Chicago',
    );
  
    my $dt1 = $dt2->clone->subtract( hours => 1 );
  
    my $dur = $dt2->subtract_datetime($dt1);
    # 60 minutes
  
  This seems obvious until you realize that subtracting 60 minutes from
  C<$dt2> in the above example still leaves the clock time at
  "01:00:00". This time we are accounting for a 25 hour day.
  
  =head3 Reversibility
  
  Date math operations are not always reversible. This is because of
  the way that addition operations are ordered. As was discussed
  earlier, adding 1 day and 3 minutes in one call to C<add()> is not the
  same as first adding 3 minutes and 1 day in two separate calls.
  
  If we take a duration returned from C<subtract_datetime()> and then
  try to add or subtract that duration from one of the datetimes we just
  used, we sometimes get interesting results:
  
    my $dt1 = DateTime->new(
        year      => 2003,
        month     => 4,
        day       => 5,
        hour      => 1,
        minute    => 58,
        time_zone => "America/Chicago",
    );
  
    my $dt2 = DateTime->new(
        year      => 2003,
        month     => 4,
        day       => 6,
        hour      => 3,
        minute    => 1,
        time_zone => "America/Chicago",
    );
  
    my $dur = $dt2->subtract_datetime($dt1);
    # 1 day and 3 minutes
  
    $dt1->add_duration($dur);
    # gives us $dt2
  
    $dt2->subtract_duration($dur);
    # gives us 2003-04-05 02:58:00 - 1 hour later than $dt1
  
  The C<subtract_duration()> operation gives us a (perhaps) unexpected
  answer because it first subtracts one day to get 2003-04-05T03:01:00
  and then subtracts 3 minutes to get the final result.
  
  If we explicitly reverse the order we can get the original value of
  C<$dt1>. This can be facilitated by C<DateTime::Duration>'s
  C<calendar_duration()> and C<clock_duration()> methods:
  
    $dt2->subtract_duration( $dur->clock_duration )
        ->subtract_duration( $dur->calendar_duration );
  
  =head3 Leap Seconds and Date Math
  
  The presence of leap seconds can cause even more anomalies in date
  math. For example, the following is a legal datetime:
  
    my $dt = DateTime->new(
        year      => 1972,
        month     => 12,
        day       => 31,
        hour      => 23,
        minute    => 59,
        second    => 60,
        time_zone => 'UTC'
    );
  
  If we do the following:
  
   $dt->add( months => 1 );
  
  Then the datetime is now "1973-02-01 00:00:00", because there is no
  23:59:60 on 1973-01-31.
  
  Leap seconds also force us to distinguish between minutes and seconds
  during date math. Given the following datetime:
  
    my $dt = DateTime->new(
        year      => 1972,
        month     => 12,
        day       => 31,
        hour      => 23,
        minute    => 59,
        second    => 30,
        time_zone => 'UTC'
    );
  
  we will get different results when adding 1 minute than we get if we
  add 60 seconds. This is because in this case, the last minute of the
  day, beginning at 23:59:00, actually contains 61 seconds.
  
  Here are the results we get:
  
    # 1972-12-31 23:59:30 - our starting datetime
  
    $dt->clone->add( minutes => 1 );
    # 1973-01-01 00:00:30 - one minute later
  
    $dt->clone->add( seconds => 60 );
    # 1973-01-01 00:00:29 - 60 seconds later
  
    $dt->clone->add( seconds => 61 );
    # 1973-01-01 00:00:30 - 61 seconds later
  
  =head3 Local vs. UTC and 24 hours vs. 1 day
  
  When math crosses a daylight saving boundary, a single day may have
  more or less than 24 hours.
  
  For example, if you do this:
  
    my $dt = DateTime->new(
        year      => 2003,
        month     => 4,
        day       => 5,
        hour      => 2,
        time_zone => 'America/Chicago',
    );
  
    $dt->add( days => 1 );
  
  then you will produce an I<invalid> local time, and therefore an
  exception will be thrown.
  
  However, this works:
  
    my $dt = DateTime->new(
        year      => 2003,
        month     => 4,
        day       => 5,
        hour      => 2,
        time_zone => 'America/Chicago',
    );
  
    $dt->add( hours => 24 );
  
  and produces a datetime with the local time of "03:00".
  
  If all this makes your head hurt, there is a simple alternative. Just
  convert your datetime object to the "UTC" time zone before doing date
  math on it, and switch it back to the local time zone afterwards.
  This avoids the possibility of having date math throw an exception,
  and makes sure that 1 day equals 24 hours. Of course, this may not
  always be desirable, so caveat user!
  
  =head2 Overloading
  
  This module explicitly overloads the addition (+), subtraction (-),
  string and numeric comparison operators. This means that the
  following all do sensible things:
  
    my $new_dt = $dt + $duration_obj;
  
    my $new_dt = $dt - $duration_obj;
  
    my $duration_obj = $dt - $new_dt;
  
    foreach my $dt ( sort @dts ) { ... }
  
  Additionally, the fallback parameter is set to true, so other
  derivable operators (+=, -=, etc.) will work properly. Do not expect
  increment (++) or decrement (--) to do anything useful.
  
  The string comparison operators, C<eq> or C<ne>, will use the string
  value to compare with non-DateTime objects.
  
  DateTime objects do not have a numeric value, using C<==> or C<< <=>
  >> to compare a DateTime object with a non-DateTime object will result
  in an exception. To safely sort mixed DateTime and non-DateTime
  objects, use C<sort { $a cmp $b } @dates>.
  
  The module also overloads stringification using the object's
  formatter, defaulting to C<iso8601()> method. See L<Formatters And
  Stringification> for details.
  
  =head2 Formatters And Stringification
  
  You can optionally specify a "formatter", which is usually a
  DateTime::Format::* object/class, to control the stringification of
  the DateTime object.
  
  Any of the constructor methods can accept a formatter argument:
  
    my $formatter = DateTime::Format::Strptime->new(...);
    my $dt = DateTime->new(year => 2004, formatter => $formatter);
  
  Or, you can set it afterwards:
  
    $dt->set_formatter($formatter);
    $formatter = $dt->formatter();
  
  Once you set the formatter, the overloaded stringification method will
  use the formatter. If unspecified, the C<iso8601()> method is used.
  
  A formatter can be handy when you know that in your application you
  want to stringify your DateTime objects into a special format all the
  time, for example to a different language.
  
  If you provide a formatter class name or object, it must implement a
  C<format_datetime> method. This method will be called with just the
  DateTime object as its argument.
  
  =head2 CLDR Patterns
  
  The CLDR pattern language is both more powerful and more complex than
  strftime. Unlike strftime patterns, you often have to explicitly
  escape text that you do not want formatted, as the patterns are simply
  letters without any prefix.
  
  For example, "yyyy-MM-dd" is a valid CLDR pattern. If you want to
  include any lower or upper case ASCII characters as-is, you can
  surround them with single quotes ('). If you want to include a single
  quote, you must escape it as two single quotes ('').
  
    'Today is ' EEEE
    'It is now' h 'o''clock' a
  
  Spaces and any non-letter text will always be passed through as-is.
  
  Many CLDR patterns which produce numbers will pad the number with
  leading zeroes depending on the length of the format specifier. For
  example, "h" represents the current hour from 1-12. If you specify
  "hh" then the 1-9 will have a leading zero prepended.
  
  However, CLDR often uses five of a letter to represent the narrow form
  of a pattern. This inconsistency is necessary for backwards
  compatibility.
  
  CLDR often distinguishes between the "format" and "stand-alone" forms
  of a pattern. The format pattern is used when the thing in question is
  being placed into a larger string. The stand-alone form is used when
  displaying that item by itself, for example in a calendar.
  
  It also often provides three sizes for each item, wide (the full
  name), abbreviated, and narrow. The narrow form is often just a single
  character, for example "T" for "Tuesday", and may not be unique.
  
  CLDR provides a fairly complex system for localizing time zones that
  we ignore entirely. The time zone patterns just use the information
  provided by C<DateTime::TimeZone>, and I<do not follow the CLDR spec>.
  
  The output of a CLDR pattern is always localized, when applicable.
  
  CLDR provides the following patterns:
  
  =over 4
  
  =item * G{1,3}
  
  The abbreviated era (BC, AD).
  
  =item * GGGG
  
  The wide era (Before Christ, Anno Domini).
  
  =item * GGGGG
  
  The narrow era, if it exists (and it mostly doesn't).
  
  =item * y and y{3,}
  
  The year, zero-prefixed as needed. Negative years will start with a "-",
  and this will be included in the length calculation.
  
  In other, words the "yyyyy" pattern will format year -1234 as "-1234", not
  "-01234".
  
  =item * yy
  
  This is a special case. It always produces a two-digit year, so "1976" becomes
  "76". Negative years will start with a "-", making them one character longer.
  
  =item * Y{1,}
  
  The year in "week of the year" calendars, from C<< $dt->week_year() >>.
  
  =item * u{1,}
  
  Same as "y" except that "uu" is not a special case.
  
  =item * Q{1,2}
  
  The quarter as a number (1..4).
  
  =item * QQQ
  
  The abbreviated format form for the quarter.
  
  =item * QQQQ
  
  The wide format form for the quarter.
  
  =item * q{1,2}
  
  The quarter as a number (1..4).
  
  =item * qqq
  
  The abbreviated stand-alone form for the quarter.
  
  =item * qqqq
  
  The wide stand-alone form for the quarter.
  
  =item * M{1,2]
  
  The numerical month.
  
  =item * MMM
  
  The abbreviated format form for the month.
  
  =item * MMMM
  
  The wide format form for the month.
  
  =item * MMMMM
  
  The narrow format form for the month.
  
  =item * L{1,2]
  
  The numerical month.
  
  =item * LLL
  
  The abbreviated stand-alone form for the month.
  
  =item * LLLL
  
  The wide stand-alone form for the month.
  
  =item * LLLLL
  
  The narrow stand-alone form for the month.
  
  =item * w{1,2}
  
  The week of the year, from C<< $dt->week_number() >>.
  
  =item * W
  
  The week of the month, from C<< $dt->week_of_month() >>.
  
  =item * d{1,2}
  
  The numeric day of the month.
  
  =item * D{1,3}
  
  The numeric day of the year.
  
  =item * F
  
  The day of the week in the month, from C<< $dt->weekday_of_month() >>.
  
  =item * g{1,}
  
  The modified Julian day, from C<< $dt->mjd() >>.
  
  =item * E{1,3} and eee
  
  The abbreviated format form for the day of the week.
  
  =item * EEEE and eeee
  
  The wide format form for the day of the week.
  
  =item * EEEEE and eeeee
  
  The narrow format form for the day of the week.
  
  =item * e{1,2}
  
  The I<local> numeric day of the week, from 1 to 7. This number depends
  on what day is considered the first day of the week, which varies by
  locale. For example, in the US, Sunday is the first day of the week,
  so this returns 2 for Monday.
  
  =item * c
  
  The numeric day of the week from 1 to 7, treating Monday as the first
  of the week, regardless of locale.
  
  =item * ccc
  
  The abbreviated stand-alone form for the day of the week.
  
  =item * cccc
  
  The wide stand-alone form for the day of the week.
  
  =item * ccccc
  
  The narrow format form for the day of the week.
  
  =item * a
  
  The localized form of AM or PM for the time.
  
  =item * h{1,2}
  
  The hour from 1-12.
  
  =item * H{1,2}
  
  The hour from 0-23.
  
  =item * K{1,2}
  
  The hour from 0-11.
  
  =item * k{1,2}
  
  The hour from 1-24.
  
  =item * j{1,2}
  
  The hour, in 12 or 24 hour form, based on the preferred form for the
  locale. In other words, this is equivalent to either "h{1,2}" or
  "H{1,2}".
  
  =item * m{1,2}
  
  The minute.
  
  =item * s{1,2}
  
  The second.
  
  =item * S{1,}
  
  The fractional portion of the seconds, rounded based on the length of
  the specifier. This returned I<without> a leading decimal point, but
  may have leading or trailing zeroes.
  
  =item * A{1,}
  
  The millisecond of the day, based on the current time. In other words,
  if it is 12:00:00.00, this returns 43200000.
  
  =item * z{1,3}
  
  The time zone short name.
  
  =item * zzzz
  
  The time zone long name.
  
  =item * Z{1,3}
  
  The time zone offset.
  
  =item * ZZZZ
  
  The time zone short name and the offset as one string, so something
  like "CDT-0500".
  
  =item * ZZZZZ
  
  The time zone offset as a sexagesimal number, so something like "-05:00".
  (This is useful for W3C format.)
  
  =item * v{1,3}
  
  The time zone short name.
  
  =item * vvvv
  
  The time zone long name.
  
  =item * V{1,3}
  
  The time zone short name.
  
  =item * VVVV
  
  The time zone long name.
  
  =back
  
  =head3 CLDR "Available Formats"
  
  The CLDR data includes pre-defined formats for various patterns such as "month
  and day" or "time of day". Using these formats lets you render information
  about a datetime in the most natural way for users from a given locale.
  
  These formats are indexed by a key that is itself a CLDR pattern. When you
  look these up, you get back a different CLDR pattern suitable for the locale.
  
  Let's look at some example We'll use C<2008-02-05T18:30:30> as our example
  datetime value, and see how this is rendered for the C<en-US> and C<fr-FR>
  locales.
  
  =over 4
  
  =item * C<MMMd>
  
  The abbreviated month and day as number. For C<en-US>, we get the pattern
  C<MMM d>, which renders as C<Feb 5>. For C<fr-FR>, we get the pattern
  C<d MMM>, which renders as C<5 févr.>.
  
  =item * C<yQQQ>
  
  The year and abbreviated quarter of year. For C<en-US>, we get the pattern
  C<QQQ y>, which renders as C<Q1 2008>. For C<fr-FR>, we get the same pattern,
  C<QQQ y>, which renders as C<T1 2008>.
  
  =item * C<hm>
  
  The 12-hour time of day without seconds.  For C<en-US>, we get the pattern
  C<h:mm a>, which renders as C<6:30 PM>. For C<fr-FR>, we get the exact same
  pattern and rendering.
  
  =back
  
  The available formats for each locale are documented in the POD for that
  locale. To get back the format, you use the C<< $locale->format_for >>
  method. For example:
  
      say $dt->format_cldr( $dt->locale->format_for('MMMd') );
  
  =head2 strftime Patterns
  
  The following patterns are allowed in the format string given to the
  C<< $dt->strftime() >> method:
  
  =over 4
  
  =item * %a
  
  The abbreviated weekday name.
  
  =item * %A
  
  The full weekday name.
  
  =item * %b
  
  The abbreviated month name.
  
  =item * %B
  
  The full month name.
  
  =item * %c
  
  The default datetime format for the object's locale.
  
  =item * %C
  
  The century number (year/100) as a 2-digit integer.
  
  =item * %d
  
  The day of the month as a decimal number (range 01 to 31).
  
  =item * %D
  
  Equivalent to %m/%d/%y. This is not a good standard format if you
  want folks from both the United States and the rest of the world to
  understand the date!
  
  =item * %e
  
  Like %d, the day of the month as a decimal number, but a leading zero
  is replaced by a space.
  
  =item * %F
  
  Equivalent to %Y-%m-%d (the ISO 8601 date format)
  
  =item * %G
  
  The ISO 8601 year with century as a decimal number. The 4-digit year
  corresponding to the ISO week number (see %V). This has the same
  format and value as %Y, except that if the ISO week number belongs to
  the previous or next year, that year is used instead. (TZ)
  
  =item * %g
  
  Like %G, but without century, i.e., with a 2-digit year (00-99).
  
  =item * %h
  
  Equivalent to %b.
  
  =item * %H
  
  The hour as a decimal number using a 24-hour clock (range 00 to 23).
  
  =item * %I
  
  The hour as a decimal number using a 12-hour clock (range 01 to 12).
  
  =item * %j
  
  The day of the year as a decimal number (range 001 to 366).
  
  =item * %k
  
  The hour (24-hour clock) as a decimal number (range 0 to 23); single
  digits are preceded by a blank. (See also %H.)
  
  =item * %l
  
  The hour (12-hour clock) as a decimal number (range 1 to 12); single
  digits are preceded by a blank. (See also %I.)
  
  =item * %m
  
  The month as a decimal number (range 01 to 12).
  
  =item * %M
  
  The minute as a decimal number (range 00 to 59).
  
  =item * %n
  
  A newline character.
  
  =item * %N
  
  The fractional seconds digits. Default is 9 digits (nanoseconds).
  
    %3N   milliseconds (3 digits)
    %6N   microseconds (6 digits)
    %9N   nanoseconds  (9 digits)
  
  This value will always be rounded down to the nearest integer.
  
  =item * %p
  
  Either `AM' or `PM' according to the given time value, or the
  corresponding strings for the current locale. Noon is treated as `pm'
  and midnight as `am'.
  
  =item * %P
  
  Like %p but in lowercase: `am' or `pm' or a corresponding string for
  the current locale.
  
  =item * %r
  
  The time in a.m. or p.m. notation. In the POSIX locale this is
  equivalent to `%I:%M:%S %p'.
  
  =item * %R
  
  The time in 24-hour notation (%H:%M). (SU) For a version including the
  seconds, see %T below.
  
  =item * %s
  
  The number of seconds since the epoch.
  
  =item * %S
  
  The second as a decimal number (range 00 to 61).
  
  =item * %t
  
  A tab character.
  
  =item * %T
  
  The time in 24-hour notation (%H:%M:%S).
  
  =item * %u
  
  The day of the week as a decimal, range 1 to 7, Monday being 1. See
  also %w.
  
  =item * %U
  
  The week number of the current year as a decimal number, range 00 to
  53, starting with the first Sunday as the first day of week 01. See
  also %V and %W.
  
  =item * %V
  
  The ISO 8601:1988 week number of the current year as a decimal number,
  range 01 to 53, where week 1 is the first week that has at least 4
  days in the current year, and with Monday as the first day of the
  week. See also %U and %W.
  
  =item * %w
  
  The day of the week as a decimal, range 0 to 6, Sunday being 0. See
  also %u.
  
  =item * %W
  
  The week number of the current year as a decimal number, range 00 to
  53, starting with the first Monday as the first day of week 01.
  
  =item * %x
  
  The default date format for the object's locale.
  
  =item * %X
  
  The default time format for the object's locale.
  
  =item * %y
  
  The year as a decimal number without a century (range 00 to 99).
  
  =item * %Y
  
  The year as a decimal number including the century.
  
  =item * %z
  
  The time-zone as hour offset from UTC. Required to emit
  RFC822-conformant dates (using "%a, %d %b %Y %H:%M:%S %z").
  
  =item * %Z
  
  The time zone or name or abbreviation.
  
  =item * %%
  
  A literal `%' character.
  
  =item * %{method}
  
  Any method name may be specified using the format C<%{method}> name
  where "method" is a valid C<DateTime.pm> object method.
  
  =back
  
  =head2 DateTime.pm and Storable
  
  DateTime implements Storable hooks in order to reduce the size of a
  serialized DateTime object.
  
  =head1 THE DATETIME PROJECT ECOSYSTEM
  
  This module is part of a larger ecosystem of modules in the DateTime
  family.
  
  =head2 L<DateTime::Set>
  
  The L<DateTime::Set> module represents sets (including recurrences) of
  datetimes. Many modules return sets or recurrences.
  
  =head2 Format Modules
  
  The various format modules exist to parse and format datetimes. For example,
  L<DateTime::Format::HTTP> parses dates according to the RFC 1123 format:
  
    my $datetime
        = DateTime::Format::HTTP->parse_datetime('Thu Feb  3 17:03:55 GMT 1994');
  
    print DateTime::Format::HTTP->format_datetime($datetime);
  
  Most format modules are suitable for use as a C<formatter> with a DateTime
  object.
  
  All format modules start with C<DateTime::Format::>.
  
  =head2 Calendar Modules
  
  There are a number of modules on CPAN that implement non-Gregorian calendars,
  such as the Chinese, Mayan, and Julian calendars.
  
  All calendar modules start with C<DateTime::Calendar::>.
  
  =head2 Event Modules
  
  There are a number of modules that calculate the dates for events, such as
  Easter, Sunrise, etc.
  
  All event modules start with C<DateTime::Event::>.
  
  =head2 Others
  
  There are many other modules that work with DateTime, including modules in the
  C<DateTimeX> namespace, as well as others.
  
  See the L<datetime wiki|http://datetime.perl.org> and
  L<search.cpan.org|http://search.cpan.org/search?query=datetime&mode=dist> for
  more details.
  
  =head1 KNOWN BUGS
  
  The tests in F<20infinite.t> seem to fail on some machines,
  particularly on Win32. This appears to be related to Perl's internal
  handling of IEEE infinity and NaN, and seems to be highly
  platform/compiler/phase of moon dependent.
  
  If you don't plan to use infinite datetimes you can probably ignore
  this. This will be fixed (perhaps) in future versions.
  
  =head1 SEE ALSO
  
  L<A Date with
  Perl|http://www.houseabsolute.com/presentations/a-date-with-perl/> - a talk
  I've given at a few YAPCs.
  
  L<datetime@perl.org mailing list|http://lists.perl.org/list/datetime.html>
  
  L<http://datetime.perl.org/>
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/DateTime.pm/issues>.
  
  There is a mailing list available for users of this distribution,
  L<mailto:datetime@perl.org>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for DateTime can be found at L<https://github.com/houseabsolute/DateTime.pm>.
  
  =head1 DONATIONS
  
  If you'd like to thank me for the work I've done on this module, please
  consider making a "donation" to me via PayPal. I spend a lot of free time
  creating free software, and would appreciate any support you'd care to offer.
  
  Please note that B<I am not suggesting that you must do this> in order for me
  to continue working on this particular software. I will continue to do so,
  inasmuch as I have in the past, for as long as it interests me.
  
  Similarly, a donation made in this way will probably not make me work on this
  software much more, unless I get so many donations that I can consider working
  on free software full time (let's all have a chuckle at that together).
  
  To donate, log into PayPal and send money to autarch@urth.org, or use the
  button at L<http://www.urth.org/~autarch/fs-donation.html>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Ben Bennett Christian Hansen Daisuke Maki Dan Book Stewart David E. Wheeler Precious Doug Bell Flávio Soibelmann Glock Gianni Ceccarelli Gregory Oschwald Hauke D Iain Truskett Jason McIntosh Joshua Hoblitt Karen Etheridge Michael Conrad R. Davis M Somerville Nick Tonkin Olaf Alders Ovid Paul Howarth Philippe Bruhat (BooK) Ricardo Signes Richard Bowen Ron Hill Sam Kington viviparous
  
  =over 4
  
  =item *
  
  Ben Bennett <fiji@limey.net>
  
  =item *
  
  Christian Hansen <chansen@cpan.org>
  
  =item *
  
  Daisuke Maki <dmaki@cpan.org>
  
  =item *
  
  Dan Book <grinnz@gmail.com>
  
  =item *
  
  Dan Stewart <danielandrewstewart@gmail.com>
  
  =item *
  
  David E. Wheeler <david@justatheory.com>
  
  =item *
  
  David Precious <davidp@preshweb.co.uk>
  
  =item *
  
  Doug Bell <madcityzen@gmail.com>
  
  =item *
  
  Flávio Soibelmann Glock <fglock@gmail.com>
  
  =item *
  
  Gianni Ceccarelli <gianni.ceccarelli@broadbean.com>
  
  =item *
  
  Gregory Oschwald <oschwald@gmail.com>
  
  =item *
  
  Hauke D <haukex@zero-g.net>
  
  =item *
  
  Iain Truskett <deceased>
  
  =item *
  
  Jason McIntosh <jmac@jmac.org>
  
  =item *
  
  Joshua Hoblitt <jhoblitt@cpan.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Michael Conrad <mike@nrdvana.net>
  
  =item *
  
  Michael R. Davis <mrdvt92@users.noreply.github.com>
  
  =item *
  
  M Somerville <dracos@users.noreply.github.com>
  
  =item *
  
  Nick Tonkin <1nickt@users.noreply.github.com>
  
  =item *
  
  Olaf Alders <olaf@wundersolutions.com>
  
  =item *
  
  Ovid <curtis_ovid_poe@yahoo.com>
  
  =item *
  
  Paul Howarth <paul@city-fan.org>
  
  =item *
  
  Philippe Bruhat (BooK) <book@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Richard Bowen <bowen@cpan.org>
  
  =item *
  
  Ron Hill <rkhill@cpan.org>
  
  =item *
  
  Sam Kington <github@illuminated.co.uk>
  
  =item *
  
  viviparous <viviparous@prc>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2003 - 2018 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
X86_64-LINUX_DATETIME

$fatpacked{"x86_64-linux/DateTime/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_DATETIME_CONFLICTS';
  package # hide from PAUSE
      DateTime::Conflicts;
  
  use strict;
  use warnings;
  
  # this module was generated with Dist::Zilla::Plugin::Conflicts 0.19
  
  use Dist::CheckConflicts
      -dist      => 'DateTime',
      -conflicts => {
          'DateTime::Format::Mail' => '0.402',
      },
      -also => [ qw(
          Carp
          DateTime::Locale
          DateTime::TimeZone
          Dist::CheckConflicts
          POSIX
          Params::ValidationCompiler
          Scalar::Util
          Specio
          Specio::Declare
          Specio::Exporter
          Specio::Library::Builtins
          Specio::Library::Numeric
          Specio::Library::String
          Try::Tiny
          XSLoader
          base
          integer
          namespace::autoclean
          overload
          parent
          strict
          warnings
          warnings::register
      ) ],
  
  ;
  
  1;
  
  # ABSTRACT: Provide information on conflicts for DateTime
  # Dist::Zilla: -PodWeaver
X86_64-LINUX_DATETIME_CONFLICTS

$fatpacked{"x86_64-linux/DateTime/Duration.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_DATETIME_DURATION';
  package DateTime::Duration;
  
  use strict;
  use warnings;
  use namespace::autoclean;
  
  our $VERSION = '1.49';
  
  use Carp ();
  use DateTime;
  use DateTime::Helpers;
  use DateTime::Types;
  use Params::ValidationCompiler 0.26 qw( validation_for );
  use Scalar::Util qw( blessed );
  
  use overload (
      fallback => 1,
      '+'      => '_add_overload',
      '-'      => '_subtract_overload',
      '*'      => '_multiply_overload',
      '<=>'    => '_compare_overload',
      'cmp'    => '_compare_overload',
  );
  
  sub MAX_NANOSECONDS () {1_000_000_000}    # 1E9 = almost 32 bits
  
  my @all_units = qw( months days minutes seconds nanoseconds );
  
  {
      my %units = map {
          $_ => {
  
              # XXX - what we really want is to accept an integer, Inf, -Inf,
              # and NaN, but I can't figure out how to accept NaN since it never
              # compares to anything.
              type    => t('Defined'),
              default => 0,
              }
          } qw(
          years
          months
          weeks
          days
          hours
          minutes
          seconds
          nanoseconds
      );
  
      my $check = validation_for(
          name             => '_check_new_params',
          name_is_optional => 1,
          params           => {
              %units,
              end_of_month => {
                  type     => t('EndOfMonthMode'),
                  optional => 1,
              },
          },
      );
  
      sub new {
          my $class = shift;
          my %p     = $check->(@_);
  
          my $self = bless {}, $class;
  
          $self->{months} = ( $p{years} * 12 ) + $p{months};
  
          $self->{days} = ( $p{weeks} * 7 ) + $p{days};
  
          $self->{minutes} = ( $p{hours} * 60 ) + $p{minutes};
  
          $self->{seconds} = $p{seconds};
  
          if ( $p{nanoseconds} ) {
              $self->{nanoseconds} = $p{nanoseconds};
              $self->_normalize_nanoseconds;
          }
          else {
  
              # shortcut - if they don't need nanoseconds
              $self->{nanoseconds} = 0;
          }
  
          $self->{end_of_month} = (
                defined $p{end_of_month} ? $p{end_of_month}
              : $self->{months} < 0      ? 'preserve'
              :                            'wrap'
          );
  
          return $self;
      }
  }
  
  # make the signs of seconds, nanos the same; 0 < abs(nanos) < MAX_NANOS
  # NB this requires nanoseconds != 0 (callers check this already)
  sub _normalize_nanoseconds {
      my $self = shift;
  
      return
          if ( $self->{nanoseconds} == DateTime::INFINITY()
          || $self->{nanoseconds} == DateTime::NEG_INFINITY()
          || $self->{nanoseconds} eq DateTime::NAN() );
  
      my $seconds = $self->{seconds} + $self->{nanoseconds} / MAX_NANOSECONDS;
      $self->{seconds}     = int($seconds);
      $self->{nanoseconds} = $self->{nanoseconds} % MAX_NANOSECONDS;
      $self->{nanoseconds} -= MAX_NANOSECONDS if $seconds < 0;
  }
  
  sub clone { bless { %{ $_[0] } }, ref $_[0] }
  
  sub years       { abs( $_[0]->in_units('years') ) }
  sub months      { abs( $_[0]->in_units( 'months', 'years' ) ) }
  sub weeks       { abs( $_[0]->in_units('weeks') ) }
  sub days        { abs( $_[0]->in_units( 'days', 'weeks' ) ) }
  sub hours       { abs( $_[0]->in_units('hours') ) }
  sub minutes     { abs( $_[0]->in_units( 'minutes', 'hours' ) ) }
  sub seconds     { abs( $_[0]->in_units('seconds') ) }
  sub nanoseconds { abs( $_[0]->in_units( 'nanoseconds', 'seconds' ) ) }
  
  sub is_positive { $_[0]->_has_positive  && !$_[0]->_has_negative }
  sub is_negative { !$_[0]->_has_positive && $_[0]->_has_negative }
  
  sub _has_positive {
      ( grep { $_ > 0 } @{ $_[0] }{@all_units} ) ? 1 : 0;
  }
  
  sub _has_negative {
      ( grep { $_ < 0 } @{ $_[0] }{@all_units} ) ? 1 : 0;
  }
  
  sub is_zero {
      return 0 if grep { $_ != 0 } @{ $_[0] }{@all_units};
      return 1;
  }
  
  sub delta_months      { $_[0]->{months} }
  sub delta_days        { $_[0]->{days} }
  sub delta_minutes     { $_[0]->{minutes} }
  sub delta_seconds     { $_[0]->{seconds} }
  sub delta_nanoseconds { $_[0]->{nanoseconds} }
  
  sub deltas {
      map { $_ => $_[0]->{$_} } @all_units;
  }
  
  sub in_units {
      my $self  = shift;
      my @units = @_;
  
      my %units = map { $_ => 1 } @units;
  
      my %ret;
  
      my ( $months, $days, $minutes, $seconds )
          = @{$self}{qw( months days minutes seconds )};
  
      if ( $units{years} ) {
          $ret{years} = int( $months / 12 );
          $months -= $ret{years} * 12;
      }
  
      if ( $units{months} ) {
          $ret{months} = $months;
      }
  
      if ( $units{weeks} ) {
          $ret{weeks} = int( $days / 7 );
          $days -= $ret{weeks} * 7;
      }
  
      if ( $units{days} ) {
          $ret{days} = $days;
      }
  
      if ( $units{hours} ) {
          $ret{hours} = int( $minutes / 60 );
          $minutes -= $ret{hours} * 60;
      }
  
      if ( $units{minutes} ) {
          $ret{minutes} = $minutes;
      }
  
      if ( $units{seconds} ) {
          $ret{seconds} = $seconds;
          $seconds = 0;
      }
  
      if ( $units{nanoseconds} ) {
          $ret{nanoseconds} = $seconds * MAX_NANOSECONDS + $self->{nanoseconds};
      }
  
      wantarray ? @ret{@units} : $ret{ $units[0] };
  }
  
  sub is_wrap_mode     { $_[0]->{end_of_month} eq 'wrap'     ? 1 : 0 }
  sub is_limit_mode    { $_[0]->{end_of_month} eq 'limit'    ? 1 : 0 }
  sub is_preserve_mode { $_[0]->{end_of_month} eq 'preserve' ? 1 : 0 }
  
  sub end_of_month_mode { $_[0]->{end_of_month} }
  
  sub calendar_duration {
      my $self = shift;
  
      return ( ref $self )
          ->new( map { $_ => $self->{$_} } qw( months days end_of_month ) );
  }
  
  sub clock_duration {
      my $self = shift;
  
      return ( ref $self )
          ->new( map { $_ => $self->{$_} }
              qw( minutes seconds nanoseconds end_of_month ) );
  }
  
  sub inverse {
      my $self = shift;
      my %p    = @_;
  
      my %new;
      foreach my $u (@all_units) {
          $new{$u} = $self->{$u};
  
          # avoid -0 bug
          $new{$u} *= -1 if $new{$u};
      }
  
      $new{end_of_month} = $p{end_of_month}
          if exists $p{end_of_month};
  
      return ( ref $self )->new(%new);
  }
  
  sub add_duration {
      my ( $self, $dur ) = @_;
  
      foreach my $u (@all_units) {
          $self->{$u} += $dur->{$u};
      }
  
      $self->_normalize_nanoseconds if $self->{nanoseconds};
  
      return $self;
  }
  
  sub add {
      my $self = shift;
  
      return $self->add_duration( $self->_duration_object_from_args(@_) );
  }
  
  sub subtract {
      my $self = shift;
  
      return $self->subtract_duration( $self->_duration_object_from_args(@_) );
  }
  
  # Syntactic sugar for add and subtract: use a duration object if it's
  # supplied, otherwise build a new one from the arguments.
  sub _duration_object_from_args {
      my $self = shift;
  
      return $_[0]
          if @_ == 1 && blessed( $_[0] ) && $_[0]->isa(__PACKAGE__);
  
      return __PACKAGE__->new(@_);
  }
  
  sub subtract_duration { return $_[0]->add_duration( $_[1]->inverse ) }
  
  {
      my $check = validation_for(
          name             => '_check_multiply_params',
          name_is_optional => 1,
          params           => [
              { type => t('Int') },
          ],
      );
  
      sub multiply {
          my $self = shift;
          my ($multiplier) = $check->(@_);
  
          foreach my $u (@all_units) {
              $self->{$u} *= $multiplier;
          }
  
          $self->_normalize_nanoseconds if $self->{nanoseconds};
  
          return $self;
      }
  }
  
  sub compare {
      my ( undef, $dur1, $dur2, $dt ) = @_;
  
      $dt ||= DateTime->now;
  
      return DateTime->compare(
          $dt->clone->add_duration($dur1),
          $dt->clone->add_duration($dur2)
      );
  }
  
  sub _add_overload {
      my ( $d1, $d2, $rev ) = @_;
  
      ( $d1, $d2 ) = ( $d2, $d1 ) if $rev;
  
      if ( DateTime::Helpers::isa( $d2, 'DateTime' ) ) {
          $d2->add_duration($d1);
          return;
      }
  
      # will also work if $d1 is a DateTime.pm object
      return $d1->clone->add_duration($d2);
  }
  
  sub _subtract_overload {
      my ( $d1, $d2, $rev ) = @_;
  
      ( $d1, $d2 ) = ( $d2, $d1 ) if $rev;
  
      Carp::croak(
          'Cannot subtract a DateTime object from a DateTime::Duration object')
          if DateTime::Helpers::isa( $d2, 'DateTime' );
  
      return $d1->clone->subtract_duration($d2);
  }
  
  sub _multiply_overload {
      my $self = shift;
  
      my $new = $self->clone;
  
      return $new->multiply(shift);
  }
  
  sub _compare_overload {
      Carp::croak( 'DateTime::Duration does not overload comparison.'
              . '  See the documentation on the compare() method for details.'
      );
  }
  
  1;
  
  # ABSTRACT: Duration objects for date math
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  DateTime::Duration - Duration objects for date math
  
  =head1 VERSION
  
  version 1.49
  
  =head1 SYNOPSIS
  
    use DateTime::Duration;
  
    $dur = DateTime::Duration->new(
        years       => 3,
        months      => 5,
        weeks       => 1,
        days        => 1,
        hours       => 6,
        minutes     => 15,
        seconds     => 45,
        nanoseconds => 12000
    );
  
    my ( $days, $hours, $seconds ) = $dur->in_units('days', 'hours', 'seconds');
  
    # Human-readable accessors, always positive, but consider using
    # DateTime::Format::Duration instead
    $dur->years;
    $dur->months;
    $dur->weeks;
    $dur->days;
    $dur->hours;
    $dur->minutes;
    $dur->seconds;
    $dur->nanoseconds;
  
    $dur->is_wrap_mode
    $dur->is_limit_mode
    $dur->is_preserve_mode
  
    print $dur->end_of_month_mode;
  
    # Multiply all values by -1
    my $opposite = $dur->inverse;
  
    my $bigger  = $dur1 + $dur2;
    my $smaller = $dur1 - $dur2; # the result could be negative
    my $bigger  = $dur1 * 3;
  
    my $base_dt = DateTime->new( year => 2000 );
    my @sorted =
        sort { DateTime::Duration->compare( $a, $b, $base_dt ) } @durations;
  
    if ( $dur->is_positive ) { ... }
    if ( $dur->is_zero )     { ... }
    if ( $dur->is_negative ) { ... }
  
  =head1 DESCRIPTION
  
  This is a simple class for representing duration objects. These
  objects are used whenever you do date math with DateTime.pm.
  
  See the L<How DateTime Math Works|DateTime/"How DateTime Math Works"> section
  of the DateTime.pm documentation for more details. The short course: One
  cannot in general convert between seconds, minutes, days, and months, so this
  class will never do so. Instead, create the duration with the desired units to
  begin with, for example by calling the appropriate subtraction/delta method on
  a C<DateTime.pm> object.
  
  =head1 METHODS
  
  Like C<DateTime> itself, C<DateTime::Duration> returns the object from
  mutator methods in order to make method chaining possible.
  
  C<DateTime::Duration> has the following methods:
  
  =head2 DateTime::Duration->new( ... )
  
  This method takes the parameters "years", "months", "weeks", "days",
  "hours", "minutes", "seconds", "nanoseconds", and "end_of_month". All
  of these except "end_of_month" are numbers. If any of the numbers are
  negative, the entire duration is negative.
  
  All of the numbers B<must be integers>.
  
  Internally, years as just treated as 12 months. Similarly, weeks are
  treated as 7 days, and hours are converted to minutes. Seconds and
  nanoseconds are both treated separately.
  
  The "end_of_month" parameter must be either "wrap", "limit", or
  "preserve". This parameter specifies how date math that crosses the
  end of a month is handled.
  
  In "wrap" mode, adding months or years that result in days beyond the
  end of the new month will roll over into the following month. For
  instance, adding one year to Feb 29 will result in Mar 1.
  
  If you specify "end_of_month" mode as "limit", the end of the month is
  never crossed. Thus, adding one year to Feb 29, 2000 will result in
  Feb 28, 2001. If you were to then add three more years this will
  result in Feb 28, 2004.
  
  If you specify "end_of_month" mode as "preserve", the same calculation
  is done as for "limit" except that if the original date is at the end
  of the month the new date will also be. For instance, adding one
  month to Feb 29, 2000 will result in Mar 31, 2000.
  
  For positive durations, the "end_of_month" parameter defaults to wrap.
  For negative durations, the default is "preserve". This should match
  how most people "intuitively" expect datetime math to work.
  
  =head2 $dur->clone()
  
  Returns a new object with the same properties as the object on which
  this method was called.
  
  =head2 $dur->in_units( ... )
  
  Returns the length of the duration in the units (any of those that can
  be passed to C<new>) given as arguments. All lengths are integral,
  but may be negative. Smaller units are computed from what remains
  after taking away the larger units given, so for example:
  
    my $dur = DateTime::Duration->new( years => 1, months => 15 );
  
    $dur->in_units( 'years' );            # 2
    $dur->in_units( 'months' );           # 27
    $dur->in_units( 'years', 'months' );  # (2, 3)
    $dur->in_units( 'weeks', 'days' );    # (0, 0) !
  
  The last example demonstrates that there will not be any conversion
  between units which don't have a fixed conversion rate. The only
  conversions possible are:
  
  =over 8
  
  =item * years <=> months
  
  =item * weeks <=> days
  
  =item * hours <=> minutes
  
  =item * seconds <=> nanoseconds
  
  =back
  
  For the explanation of why this is the case, please see the L<How DateTime
  Math Works|DateTime/"How DateTime Math Works"> section of the DateTime.pm
  documentation
  
  Note that the numbers returned by this method may not match the values
  given to the constructor.
  
  In list context, in_units returns the lengths in the order of the units
  given. In scalar context, it returns the length in the first unit (but
  still computes in terms of all given units).
  
  If you need more flexibility in presenting information about
  durations, please take a look a C<DateTime::Format::Duration>.
  
  =head2 $dur->is_positive(), $dur->is_zero(), $dur->is_negative()
  
  Indicates whether or not the duration is positive, zero, or negative.
  
  If the duration contains both positive and negative units, then it
  will return false for B<all> of these methods.
  
  =head2 $dur->is_wrap_mode(), $dur->is_limit_mode(), $dur->is_preserve_mode()
  
  Indicates what mode is used for end of month wrapping.
  
  =head2 $dur->end_of_month_mode()
  
  Returns one of "wrap", "limit", or "preserve".
  
  =head2 $dur->calendar_duration()
  
  Returns a new object with the same I<calendar> delta (months and days
  only) and end of month mode as the current object.
  
  =head2 $dur->clock_duration()
  
  Returns a new object with the same I<clock> deltas (minutes, seconds,
  and nanoseconds) and end of month mode as the current object.
  
  =head2 $dur->inverse( ... )
  
  Returns a new object with the same deltas as the current object, but
  multiple by -1. The end of month mode for the new object will be the
  default end of month mode, which depends on whether the new duration
  is positive or negative.
  
  You can set the end of month mode in the inverted duration explicitly by
  passing "end_of_month => ..." to the C<inverse()> method.
  
  =head2 $dur->add_duration( $duration_object ), $dur->subtract_duration( $duration_object )
  
  Adds or subtracts one duration from another.
  
  =head2 $dur->add( ... ), $dur->subtract( ... )
  
  These accept either constructor parameters for a new C<DateTime::Duration>
  object or an already-constructed duration object.
  
  =head2 $dur->multiply( $number )
  
  Multiplies each unit in the by the specified integer number.
  
  =head2 DateTime::Duration->compare( $duration1, $duration2, $base_datetime )
  
  This is a class method that can be used to compare or sort durations.
  Comparison is done by adding each duration to the specified
  C<DateTime.pm> object and comparing the resulting datetimes. This is
  necessary because without a base, many durations are not comparable.
  For example, 1 month may or may not be longer than 29 days, depending
  on what datetime it is added to.
  
  If no base datetime is given, then the result of C<< DateTime->now >>
  is used instead. Using this default will give non-repeatable results
  if used to compare two duration objects containing different units.
  It will also give non-repeatable results if the durations contain
  multiple types of units, such as months and days.
  
  However, if you know that both objects only consist of one type of
  unit (months I<or> days I<or> hours, etc.), and each duration contains
  the same type of unit, then the results of the comparison will be
  repeatable.
  
  =head2 $dur->delta_months(), $dur->delta_days(), $dur->delta_minutes(), $dur->delta_seconds(), $dur->delta_nanoseconds()
  
  These methods provide the information C<DateTime.pm> needs for doing date
  math. The numbers returned may be positive or negative. This is mostly useful
  for doing date math in L<DateTime>.
  
  =head2 $dur->deltas()
  
  Returns a hash with the keys "months", "days", "minutes", "seconds", and
  "nanoseconds", containing all the delta information for the object. This is
  mostly useful for doing date math in L<DateTime>.
  
  =head2 $dur->years(), $dur->months(), $dur->weeks(), $dur->days(), $dur->hours(), $dur->minutes(), $dur->seconds(), $dur->nanoseconds()
  
  These methods return numbers indicating how many of the given unit the
  object represents, after having done a conversion to any larger units.
  For example, days are first converted to weeks, and then the remainder
  is returned. These numbers are always positive.
  
  Here's what each method returns:
  
   $dur->years()       == abs( $dur->in_units('years') )
   $dur->months()      == abs( ( $dur->in_units( 'months', 'years' ) )[0] )
   $dur->weeks()       == abs( $dur->in_units( 'weeks' ) )
   $dur->days()        == abs( ( $dur->in_units( 'days', 'weeks' ) )[0] )
   $dur->hours()       == abs( $dur->in_units( 'hours' ) )
   $dur->minutes       == abs( ( $dur->in_units( 'minutes', 'hours' ) )[0] )
   $dur->seconds       == abs( $dur->in_units( 'seconds' ) )
   $dur->nanoseconds() == abs( ( $dur->in_units( 'nanoseconds', 'seconds' ) )[0] )
  
  If this seems confusing, remember that you can always use the
  C<in_units()> method to specify exactly what you want.
  
  Better yet, if you are trying to generate output suitable for humans,
  use the C<DateTime::Format::Duration> module.
  
  =head2 Overloading
  
  This class overloads addition, subtraction, and mutiplication.
  
  Comparison is B<not> overloaded. If you attempt to compare durations
  using C<< <=> >> or C<cmp>, then an exception will be thrown!  Use the
  C<compare()> class method instead.
  
  =head1 SEE ALSO
  
  datetime@perl.org mailing list
  
  http://datetime.perl.org/
  
  =head1 SUPPORT
  
  Support for this module is provided via the datetime@perl.org email
  list. See http://lists.perl.org/ for more details.
  
  Bugs may be submitted at L<https://github.com/houseabsolute/DateTime.pm/issues>.
  
  There is a mailing list available for users of this distribution,
  L<mailto:datetime@perl.org>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for DateTime can be found at L<https://github.com/houseabsolute/DateTime.pm>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2003 - 2018 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
X86_64-LINUX_DATETIME_DURATION

$fatpacked{"x86_64-linux/DateTime/Helpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_DATETIME_HELPERS';
  package DateTime::Helpers;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.49';
  
  use Scalar::Util ();
  
  sub can {
      my $object = shift;
      my $method = shift;
  
      return unless Scalar::Util::blessed($object);
      return $object->can($method);
  }
  
  sub isa {
      my $object = shift;
      my $method = shift;
  
      return unless Scalar::Util::blessed($object);
      return $object->isa($method);
  }
  
  1;
X86_64-LINUX_DATETIME_HELPERS

$fatpacked{"x86_64-linux/DateTime/Infinite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_DATETIME_INFINITE';
  ## no critic (Modules::ProhibitMultiplePackages)
  package DateTime::Infinite;
  
  use strict;
  use warnings;
  use namespace::autoclean;
  
  our $VERSION = '1.49';
  
  use DateTime;
  use DateTime::TimeZone;
  
  use base qw(DateTime);
  
  foreach my $m (qw( set set_time_zone truncate )) {
      ## no critic (TestingAndDebugging::ProhibitNoStrict)
      no strict 'refs';
      *{"DateTime::Infinite::$m"} = sub { return $_[0] };
  }
  
  sub is_finite   {0}
  sub is_infinite {1}
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _rd2ymd {
      return $_[2] ? ( $_[1] ) x 7 : ( $_[1] ) x 3;
  }
  
  sub _seconds_as_components {
      return ( $_[1] ) x 3;
  }
  
  sub ymd {
      return $_[0]->iso8601;
  }
  
  sub mdy {
      return $_[0]->iso8601;
  }
  
  sub dmy {
      return $_[0]->iso8601;
  }
  
  sub hms {
      return $_[0]->iso8601;
  }
  
  sub hour_12 {
      return $_[0]->_infinity_string;
  }
  
  sub hour_12_0 {
      return $_[0]->_infinity_string;
  }
  
  sub datetime {
      return $_[0]->_infinity_string;
  }
  
  sub stringify {
      return $_[0]->_infinity_string;
  }
  
  sub _infinity_string {
      return $_[0]->{utc_rd_days} == DateTime::INFINITY
          ? DateTime::INFINITY . q{}
          : DateTime::NEG_INFINITY . q{};
  }
  
  sub _week_values { [ $_[0]->{utc_rd_days}, $_[0]->{utc_rd_days} ] }
  
  sub STORABLE_freeze {return}
  sub STORABLE_thaw   {return}
  
  package DateTime::Infinite::Future;
  
  use strict;
  use warnings;
  
  use base qw(DateTime::Infinite);
  
  {
      my $Pos = bless {
          utc_rd_days   => DateTime::INFINITY,
          utc_rd_secs   => DateTime::INFINITY,
          local_rd_days => DateTime::INFINITY,
          local_rd_secs => DateTime::INFINITY,
          rd_nanosecs   => DateTime::INFINITY,
          tz            => DateTime::TimeZone->new( name => 'floating' ),
          locale        => FakeLocale->instance(),
          },
          __PACKAGE__;
  
      $Pos->_calc_utc_rd;
      $Pos->_calc_local_rd;
  
      sub new {$Pos}
  }
  
  package DateTime::Infinite::Past;
  
  use strict;
  use warnings;
  
  use base qw(DateTime::Infinite);
  
  {
      my $Neg = bless {
          utc_rd_days   => DateTime::NEG_INFINITY,
          utc_rd_secs   => DateTime::NEG_INFINITY,
          local_rd_days => DateTime::NEG_INFINITY,
          local_rd_secs => DateTime::NEG_INFINITY,
          rd_nanosecs   => DateTime::NEG_INFINITY,
          tz            => DateTime::TimeZone->new( name => 'floating' ),
          locale        => FakeLocale->instance(),
          },
          __PACKAGE__;
  
      $Neg->_calc_utc_rd;
      $Neg->_calc_local_rd;
  
      sub new {$Neg}
  }
  
  package    # hide from PAUSE
      FakeLocale;
  
  use strict;
  use warnings;
  
  use DateTime::Locale;
  
  my $Instance;
  
  sub instance {
      return $Instance ||= bless { locale => DateTime::Locale->load('en_US') },
          __PACKAGE__;
  }
  
  sub id {
      return 'infinite';
  }
  
  sub language_id {
      return 'infinite';
  }
  
  sub name {
      'Fake locale for Infinite DateTime objects';
  }
  
  sub language {
      'Fake locale for Infinite DateTime objects';
  }
  
  my @methods = qw(
      script_id
      territory_id
      variant_id
      script
      territory
      variant
      native_name
      native_language
      native_script
      native_territory
      native_variant
  );
  
  for my $meth (@methods) {
      ## no critic (TestingAndDebugging::ProhibitNoStrict)
      no strict 'refs';
      *{$meth} = sub {undef};
  }
  
  # Totally arbitrary
  sub first_day_of_week {
      return 1;
  }
  
  sub prefers_24_hour_time {
      return 0;
  }
  
  our $AUTOLOAD;
  
  ## no critic (ClassHierarchies::ProhibitAutoloading)
  sub AUTOLOAD {
      my $self = shift;
  
      my ($meth) = $AUTOLOAD =~ /::(\w+)$/;
  
      if ( $meth =~ /format/ && $meth !~ /^(?:day|month|quarter)/ ) {
          return $self->{locale}->$meth(@_);
      }
  
      return [];
  }
  
  1;
  
  # ABSTRACT: Infinite past and future DateTime objects
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  DateTime::Infinite - Infinite past and future DateTime objects
  
  =head1 VERSION
  
  version 1.49
  
  =head1 SYNOPSIS
  
    my $future = DateTime::Infinite::Future->new();
    my $past   = DateTime::Infinite::Past->new();
  
  =head1 DESCRIPTION
  
  This module provides two L<DateTime.pm|DateTime> subclasses,
  C<DateTime::Infinite::Future> and C<DateTime::Infinite::Past>.
  
  The objects are in the "floating" timezone, and this cannot be
  changed.
  
  =head1 METHODS
  
  The only constructor for these two classes is the C<new()> method, as
  shown in the L<SYNOPSIS|/SYNOPSIS>. This method takes no parameters.
  
  All "get" methods in this module simply return infinity, positive or
  negative. If the method is expected to return a string, it returns the
  string representation of positive or negative infinity used by your
  system. For example, on my system calling C<year()> returns a number
  which when printed appears either "Inf" or "-Inf".
  
  This also applies to methods that are compound stringifications, which return
  the same strings even for things like C<ymd()> or C<iso8601()>
  
  The object is not mutable, so the C<set()>, C<set_time_zone()>, and
  C<truncate()> methods are all do-nothing methods that simply return
  the object they are called with.
  
  Obviously, the C<is_finite()> method returns false and the
  C<is_infinite()> method returns true.
  
  =head1 SEE ALSO
  
  datetime@perl.org mailing list
  
  http://datetime.perl.org/
  
  =head1 BUGS
  
  There seem to be lots of problems when dealing with infinite numbers
  on Win32. This may be a problem with this code, Perl, or Win32's IEEE
  math implementation. Either way, the module may not be well-behaved
  on Win32 operating systems.
  
  Bugs may be submitted at L<https://github.com/houseabsolute/DateTime.pm/issues>.
  
  There is a mailing list available for users of this distribution,
  L<mailto:datetime@perl.org>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for DateTime can be found at L<https://github.com/houseabsolute/DateTime.pm>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2003 - 2018 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
X86_64-LINUX_DATETIME_INFINITE

$fatpacked{"x86_64-linux/DateTime/LeapSecond.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_DATETIME_LEAPSECOND';
  package DateTime::LeapSecond;
  
  use strict;
  use warnings;
  use namespace::autoclean;
  
  our $VERSION = '1.49';
  
  our ( @RD, @LEAP_SECONDS, %RD_LENGTH );
  
  use DateTime;
  
  # Generates a Perl binary decision tree
  sub _make_utx {
      my ( $beg, $end, $tab, $op ) = @_;
      my $step = int( ( $end - $beg ) / 2 );
      my $tmp;
      if ( $step <= 0 ) {
          $tmp = "${tab}return $LEAP_SECONDS[$beg + 1];\n";
          return $tmp;
      }
      $tmp = "${tab}if (\$val < " . $RD[ $beg + $step ] . ") {\n";
      $tmp .= _make_utx( $beg,         $beg + $step, $tab . q{    }, $op );
      $tmp .= "${tab}}\n";
      $tmp .= "${tab}else {\n";
      $tmp .= _make_utx( $beg + $step, $end,         $tab . q{    }, $op );
      $tmp .= "${tab}}\n";
      return $tmp;
  }
  
  # Process BEGIN data and write binary tree decision table
  sub _init {
      my $value = -1;
      while (@_) {
          my ( $year, $mon, $mday, $leap_seconds )
              = ( shift, shift, shift, shift );
  
          # print "$year,$mon,$mday\n";
  
          ## no critic (Subroutines::ProtectPrivateSubs)
          my $utc_epoch
              = DateTime->_ymd2rd( $year, ( $mon =~ /Jan/i ? 1 : 7 ), $mday );
  
          $value++;
          push @LEAP_SECONDS, $value;
          push @RD,           $utc_epoch;
  
          $RD_LENGTH{ $utc_epoch - 1 } = $leap_seconds;
  
          # warn "$year,$mon,$mday = $utc_epoch +$value";
      }
  
      push @LEAP_SECONDS, ++$value;
  
      my $tmp;
  
      # write binary tree decision table
  
      $tmp = "sub leap_seconds {\n";
      $tmp .= "    my \$val = shift;\n";
      $tmp .= _make_utx( -1, 1 + $#RD, q{    }, '+' );
      $tmp .= "}; 1\n";
  
      # NOTE: uncomment the line below to see the code:
      #warn $tmp;
  
      ## no critic (BuiltinFunctions::ProhibitStringyEval)
      eval $tmp or die $@;
  }
  
  sub extra_seconds {
      exists $RD_LENGTH{ $_[0] } ? $RD_LENGTH{ $_[0] } : 0;
  }
  
  sub day_length {
      exists $RD_LENGTH{ $_[0] } ? 86400 + $RD_LENGTH{ $_[0] } : 86400;
  }
  
  sub _initialize {
  
      # There are no leap seconds before 1972, because that's the
      # year this system was implemented.
      #
      # year month day number-of-leapseconds
      #
      _init(
          qw(
              1972  Jul. 1  +1
              1973  Jan. 1  +1
              1974  Jan. 1  +1
              1975  Jan. 1  +1
              1976  Jan. 1  +1
              1977  Jan. 1  +1
              1978  Jan. 1  +1
              1979  Jan. 1  +1
              1980  Jan. 1  +1
              1981  Jul. 1  +1
              1982  Jul. 1  +1
              1983  Jul. 1  +1
              1985  Jul. 1  +1
              1988  Jan. 1  +1
              1990  Jan. 1  +1
              1991  Jan. 1  +1
              1992  Jul. 1  +1
              1993  Jul. 1  +1
              1994  Jul. 1  +1
              1996  Jan. 1  +1
              1997  Jul. 1  +1
              1999  Jan. 1  +1
              2006  Jan. 1  +1
              2009  Jan. 1  +1
              2012  Jul. 1  +1
              2015  Jul. 1  +1
              2017  Jan. 1  +1
              )
      );
  }
  
  __PACKAGE__->_initialize();
  
  1;
  
  # ABSTRACT: leap seconds table and utilities
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  DateTime::LeapSecond - leap seconds table and utilities
  
  =head1 VERSION
  
  version 1.49
  
  =head1 SYNOPSIS
  
    use DateTime;
    use DateTime::LeapSecond;
  
    print "Leap seconds between years 1990 and 2000 are ";
    print DateTime::Leapsecond::leap_seconds( $utc_rd_2000 ) -
          DateTime::Leapsecond::leap_seconds( $utc_rd_1990 );
  
  =head1 DESCRIPTION
  
  This module is used to calculate leap seconds for a given Rata Die
  day. It is used when DateTime.pm cannot compile the XS version of
  this code.
  
  This library is known to be accurate for dates until Jun 2017.
  
  There are no leap seconds before 1972, because that's the year this
  system was implemented.
  
  =over 4
  
  =item * leap_seconds( $rd )
  
  Returns the number of accumulated leap seconds for a given day.
  
  =item * extra_seconds( $rd )
  
  Returns the number of leap seconds for a given day,
  in the range -2 .. 2.
  
  =item * day_length( $rd )
  
  Returns the number of seconds for a given day,
  in the range 86398 .. 86402.
  
  =back
  
  =head1 SEE ALSO
  
  L<http://hpiers.obspm.fr/eop-pc/earthor/utc/leapsecond.html>
  
  http://datetime.perl.org
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/DateTime.pm/issues>.
  
  There is a mailing list available for users of this distribution,
  L<mailto:datetime@perl.org>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for DateTime can be found at L<https://github.com/houseabsolute/DateTime.pm>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2003 - 2018 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
X86_64-LINUX_DATETIME_LEAPSECOND

$fatpacked{"x86_64-linux/DateTime/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_DATETIME_PP';
  package DateTime::PP;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.49';
  
  ## no critic (Variables::ProhibitPackageVars)
  $DateTime::IsPurePerl = 1;
  ## use critic
  
  my @MonthLengths = ( 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 );
  
  my @LeapYearMonthLengths = @MonthLengths;
  $LeapYearMonthLengths[1]++;
  
  my @EndOfLastMonthDayOfYear;
  {
      my $x = 0;
      foreach my $length (@MonthLengths) {
          push @EndOfLastMonthDayOfYear, $x;
          $x += $length;
      }
  }
  
  my @EndOfLastMonthDayOfLeapYear = @EndOfLastMonthDayOfYear;
  $EndOfLastMonthDayOfLeapYear[$_]++ for 2 .. 11;
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _time_as_seconds {
      shift;
      my ( $hour, $min, $sec ) = @_;
  
      $hour ||= 0;
      $min  ||= 0;
      $sec  ||= 0;
  
      my $secs = $hour * 3600 + $min * 60 + $sec;
      return $secs;
  }
  
  sub _rd2ymd {
      my $class = shift;
  
      use integer;
      my $d  = shift;
      my $rd = $d;
  
      my $yadj = 0;
      my ( $c, $y, $m );
  
      # add 306 days to make relative to Mar 1, 0
      if ( ( $d += 306 ) <= 0 ) {
  
          # avoid ambiguity in C division of negatives
          $yadj = -( -$d / 146097 + 1 );
          $d -= $yadj * 146097;
      }
  
      $c = ( $d * 4 - 1 )
          / 146097;    # calc # of centuries $d is after 29 Feb of yr 0
      $d -= $c * 146097 / 4;    # (4 centuries = 146097 days)
      $y = ( $d * 4 - 1 ) / 1461;    # calc number of years into the century,
      $d -= $y * 1461 / 4;           # again March-based (4 yrs =~ 146[01] days)
      $m = ( $d * 12 + 1093 )
          / 367;    # get the month (3..14 represent March through
      $d -= ( $m * 367 - 1094 ) / 12;    # February of following year)
      $y += $c * 100 + $yadj * 400;      # get the real year, which is off by
                                         # one if month is January or February
  
      if ( $m > 12 ) {
          ++$y;
          $m -= 12;
      }
  
      if ( $_[0] ) {
          my $dow;
  
          if ( $rd < -6 ) {
              $dow = ( $rd + 6 ) % 7;
              $dow += $dow ? 8 : 1;
          }
          else {
              $dow = ( ( $rd + 6 ) % 7 ) + 1;
          }
  
          my $doy = $class->_end_of_last_month_day_of_year( $y, $m );
  
          $doy += $d;
  
          my $quarter;
          {
              no integer;
              $quarter = int( ( 1 / 3.1 ) * $m ) + 1;
          }
  
          my $qm = ( 3 * $quarter ) - 2;
  
          my $doq
              = ( $doy - $class->_end_of_last_month_day_of_year( $y, $qm ) );
  
          return ( $y, $m, $d, $dow, $doy, $quarter, $doq );
      }
  
      return ( $y, $m, $d );
  }
  
  sub _ymd2rd {
      shift;    # ignore class
  
      use integer;
      my ( $y, $m, $d ) = @_;
      my $adj;
  
      # make month in range 3..14 (treat Jan & Feb as months 13..14 of
      # prev year)
      if ( $m <= 2 ) {
          $y -= ( $adj = ( 14 - $m ) / 12 );
          $m += 12 * $adj;
      }
      elsif ( $m > 14 ) {
          $y += ( $adj = ( $m - 3 ) / 12 );
          $m -= 12 * $adj;
      }
  
      # make year positive (oh, for a use integer 'sane_div'!)
      if ( $y < 0 ) {
          $d -= 146097 * ( $adj = ( 399 - $y ) / 400 );
          $y += 400 * $adj;
      }
  
      # add: day of month, days of previous 0-11 month period that began
      # w/March, days of previous 0-399 year period that began w/March
      # of a 400-multiple year), days of any 400-year periods before
      # that, and finally subtract 306 days to adjust from Mar 1, year
      # 0-relative to Jan 1, year 1-relative (whew)
  
      $d
          += ( $m * 367 - 1094 ) / 12
          + $y % 100 * 1461 / 4
          + ( $y / 100 * 36524 + $y / 400 )
          - 306;
  }
  
  sub _seconds_as_components {
      shift;
      my $secs     = shift;
      my $utc_secs = shift;
      my $modifier = shift || 0;
  
      use integer;
  
      $secs -= $modifier;
  
      my $hour = $secs / 3600;
      $secs -= $hour * 3600;
  
      my $minute = $secs / 60;
  
      my $second = $secs - ( $minute * 60 );
  
      if ( $utc_secs && $utc_secs >= 86400 ) {
  
          # there is no such thing as +3 or more leap seconds!
          die "Invalid UTC RD seconds value: $utc_secs"
              if $utc_secs > 86401;
  
          $second += $utc_secs - 86400 + 60;
  
          $minute = 59;
  
          $hour--;
          $hour = 23 if $hour < 0;
      }
  
      return ( $hour, $minute, $second );
  }
  
  sub _end_of_last_month_day_of_year {
      my $class = shift;
  
      my ( $y, $m ) = @_;
      $m--;
      return (
            $class->_is_leap_year($y)
          ? $EndOfLastMonthDayOfLeapYear[$m]
          : $EndOfLastMonthDayOfYear[$m]
      );
  }
  
  sub _is_leap_year {
      shift;
      my $year = shift;
  
      # According to Bjorn Tackmann, this line prevents an infinite loop
      # when running the tests under Qemu. I cannot reproduce this on
      # Ubuntu or with Strawberry Perl on Win2K.
      return 0
          if $year == DateTime::INFINITY() || $year == DateTime::NEG_INFINITY();
      return 0 if $year % 4;
      return 1 if $year % 100;
      return 0 if $year % 400;
  
      return 1;
  }
  
  sub _day_length { DateTime::LeapSecond::day_length( $_[1] ) }
  
  sub _accumulated_leap_seconds { DateTime::LeapSecond::leap_seconds( $_[1] ) }
  
  my @subs = qw(
      _time_as_seconds
      _rd2ymd
      _ymd2rd
      _seconds_as_components
      _end_of_last_month_day_of_year
      _is_leap_year
      _day_length
      _accumulated_leap_seconds
  );
  
  for my $sub (@subs) {
      ## no critic (TestingAndDebugging::ProhibitNoStrict)
      no strict 'refs';
      *{ 'DateTime::' . $sub } = __PACKAGE__->can($sub);
  }
  
  # This is down here so that _ymd2rd is available when it loads,
  # because it will load DateTime::LeapSecond, which needs
  # DateTime->_ymd2rd to be available when it is loading
  require DateTime::PPExtra;
  
  1;
X86_64-LINUX_DATETIME_PP

$fatpacked{"x86_64-linux/DateTime/PPExtra.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_DATETIME_PPEXTRA';
  package DateTime::PPExtra;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.49';
  
  use DateTime::LeapSecond;
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _normalize_tai_seconds {
      return
          if
          grep { $_ == DateTime::INFINITY() || $_ == DateTime::NEG_INFINITY() }
          @_[ 1, 2 ];
  
      # This must be after checking for infinity, because it breaks in
      # presence of use integer !
      use integer;
  
      my $adj;
  
      if ( $_[2] < 0 ) {
          $adj = ( $_[2] - 86399 ) / 86400;
      }
      else {
          $adj = $_[2] / 86400;
      }
  
      $_[1] += $adj;
  
      $_[2] -= $adj * 86400;
  }
  
  sub _normalize_leap_seconds {
  
      # args: 0 => days, 1 => seconds
      my $delta_days;
  
      use integer;
  
      # rough adjust - can adjust many days
      if ( $_[2] < 0 ) {
          $delta_days = ( $_[2] - 86399 ) / 86400;
      }
      else {
          $delta_days = $_[2] / 86400;
      }
  
      my $new_day = $_[1] + $delta_days;
      my $delta_seconds
          = ( 86400 * $delta_days )
          + DateTime::LeapSecond::leap_seconds($new_day)
          - DateTime::LeapSecond::leap_seconds( $_[1] );
  
      $_[2] -= $delta_seconds;
      $_[1] = $new_day;
  
      # fine adjust - up to 1 day
      my $day_length = DateTime::LeapSecond::day_length($new_day);
      if ( $_[2] >= $day_length ) {
          $_[2] -= $day_length;
          $_[1]++;
      }
      elsif ( $_[2] < 0 ) {
          $day_length = DateTime::LeapSecond::day_length( $new_day - 1 );
          $_[2] += $day_length;
          $_[1]--;
      }
  }
  
  my @subs = qw(
      _normalize_tai_seconds
      _normalize_leap_seconds
  );
  
  for my $sub (@subs) {
      ## no critic (TestingAndDebugging::ProhibitNoStrict)
      no strict 'refs';
      *{ 'DateTime::' . $sub } = __PACKAGE__->can($sub);
  }
  
  1;
X86_64-LINUX_DATETIME_PPEXTRA

$fatpacked{"x86_64-linux/DateTime/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_DATETIME_TYPES';
  package DateTime::Types;
  
  use strict;
  use warnings;
  use namespace::autoclean;
  
  our $VERSION = '1.49';
  
  use parent 'Specio::Exporter';
  
  use Specio 0.18;
  use Specio::Declare;
  use Specio::Library::Builtins -reexport;
  use Specio::Library::Numeric -reexport;
  use Specio::Library::String;
  
  any_can_type(
      'ConvertibleObject',
      methods => ['utc_rd_values'],
  );
  
  declare(
      'DayOfMonth',
      parent => t('Int'),
      inline => sub {
          $_[0]->parent->inline_check( $_[1] )
              . " && $_[1] >= 1 && $_[1] <= 31";
      },
  );
  
  declare(
      'DayOfYear',
      parent => t('Int'),
      inline => sub {
          $_[0]->parent->inline_check( $_[1] )
              . " && $_[1] >= 1 && $_[1] <= 366";
      },
  );
  
  object_isa_type(
      'Duration',
      class => 'DateTime::Duration',
  );
  
  enum(
      'EndOfMonthMode',
      values => [qw( wrap limit preserve )],
  );
  
  any_can_type(
      'Formatter',
      methods => ['format_datetime'],
  );
  
  my $locale_object = declare(
      'LocaleObject',
      parent => t('Object'),
      inline => sub {
  
          # Can't use $_[1] directly because 5.8 gives very weird errors
          my $var = $_[1];
          <<"EOF";
  (
      $var->isa('DateTime::Locale::FromData')
      || $var->isa('DateTime::Locale::Base')
  )
  EOF
      },
  );
  
  union(
      'Locale',
      of => [ t('NonEmptySimpleStr'), $locale_object ],
  );
  
  my $time_zone_object = object_can_type(
      'TZObject',
      methods => [
          qw(
              is_floating
              is_utc
              name
              offset_for_datetime
              short_name_for_datetime
              )
      ],
  );
  
  declare(
      'TimeZone',
      of => [ t('NonEmptySimpleStr'), $time_zone_object ],
  );
  
  declare(
      'Hour',
      parent => t('PositiveOrZeroInt'),
      inline => sub {
          $_[0]->parent->inline_check( $_[1] )
              . " && $_[1] >= 0 && $_[1] <= 23";
      },
  );
  
  declare(
      'Minute',
      parent => t('PositiveOrZeroInt'),
      inline => sub {
          $_[0]->parent->inline_check( $_[1] )
              . " && $_[1] >= 0 && $_[1] <= 59";
      },
  );
  
  declare(
      'Month',
      parent => t('PositiveInt'),
      inline => sub {
          $_[0]->parent->inline_check( $_[1] )
              . " && $_[1] >= 1 && $_[1] <= 12";
      },
  );
  
  declare(
      'Nanosecond',
      parent => t('PositiveOrZeroInt'),
  );
  
  declare(
      'Second',
      parent => t('PositiveOrZeroInt'),
      inline => sub {
          $_[0]->parent->inline_check( $_[1] )
              . " && $_[1] >= 0 && $_[1] <= 61";
      },
  );
  
  enum(
      'TruncationLevel',
      values => [
          qw(
              year
              quarter
              month
              day hour
              minute
              second
              nanosecond
              week
              local_week
              )
      ],
  );
  
  declare(
      'Year',
      parent => t('Int'),
  );
  
  1;
  
  # ABSTRACT: Types used for parameter checking in DateTime
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  DateTime::Types - Types used for parameter checking in DateTime
  
  =head1 VERSION
  
  version 1.49
  
  =head1 DESCRIPTION
  
  This module has no user-facing parts.
  
  =for Pod::Coverage .*
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/DateTime.pm/issues>.
  
  There is a mailing list available for users of this distribution,
  L<mailto:datetime@perl.org>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for DateTime can be found at L<https://github.com/houseabsolute/DateTime.pm>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2003 - 2018 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
X86_64-LINUX_DATETIME_TYPES

$fatpacked{"x86_64-linux/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle uniq uniqnum uniqstr
    head tail pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.50";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first
  
        max maxstr min minstr product sum sum0
  
        pairs unpairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniq uniqnum uniqstr
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  Note also that multiple IEEE C<NaN> values are treated as duplicates of
  each other, regardless of any differences in their payloads, and despite
  the fact that C<< 0+'NaN' == 0+'NaN' >> yields false.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head2 head
  
      my @values = head $size, @list;
  
  Returns the first C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the last C<$size> elements from C<@list>.
  
      @result = head 2, qw( foo bar baz );
      # foo, bar
  
      @result = head -2, qw( foo bar baz );
      # foo
  
  =head2 tail
  
      my @values = tail $size, @list;
  
  Returns the last C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the first C<$size> elements from C<@list>.
  
      @result = tail 2, qw( foo bar baz );
      # bar, baz
  
      @result = tail -2, qw( foo bar baz );
      # baz
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
X86_64-LINUX_LIST_UTIL

$fatpacked{"x86_64-linux/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.50";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_LIST_UTIL_XS

$fatpacked{"x86_64-linux/Params/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PARAMS_UTIL';
  package Params::Util;
  
  =pod
  
  =head1 NAME
  
  Params::Util - Simple, compact and correct param-checking functions
  
  =head1 SYNOPSIS
  
    # Import some functions
    use Params::Util qw{_SCALAR _HASH _INSTANCE};
    
    # If you are lazy, or need a lot of them...
    use Params::Util ':ALL';
    
    sub foo {
        my $object  = _INSTANCE(shift, 'Foo') or return undef;
        my $image   = _SCALAR(shift)          or return undef;
        my $options = _HASH(shift)            or return undef;
        # etc...
    }
  
  =head1 DESCRIPTION
  
  C<Params::Util> provides a basic set of importable functions that makes
  checking parameters a hell of a lot easier
  
  While they can be (and are) used in other contexts, the main point
  behind this module is that the functions B<both> Do What You Mean,
  and Do The Right Thing, so they are most useful when you are getting
  params passed into your code from someone and/or somewhere else
  and you can't really trust the quality.
  
  Thus, C<Params::Util> is of most use at the edges of your API, where
  params and data are coming in from outside your code.
  
  The functions provided by C<Params::Util> check in the most strictly
  correct manner known, are documented as thoroughly as possible so their
  exact behaviour is clear, and heavily tested so make sure they are not
  fooled by weird data and Really Bad Things.
  
  To use, simply load the module providing the functions you want to use
  as arguments (as shown in the SYNOPSIS).
  
  To aid in maintainability, C<Params::Util> will B<never> export by
  default.
  
  You must explicitly name the functions you want to export, or use the
  C<:ALL> param to just have it export everything (although this is not
  recommended if you have any _FOO functions yourself with which future
  additions to C<Params::Util> may clash)
  
  =head1 FUNCTIONS
  
  =cut
  
  use 5.00503;
  use strict;
  require overload;
  require Exporter;
  require Scalar::Util;
  require DynaLoader;
  
  use vars qw{$VERSION @ISA @EXPORT_OK %EXPORT_TAGS};
  
  $VERSION   = '1.07';
  @ISA       = qw{
  	Exporter
  	DynaLoader
  };
  @EXPORT_OK = qw{
  	_STRING     _IDENTIFIER
  	_CLASS      _CLASSISA   _SUBCLASS  _DRIVER  _CLASSDOES
  	_NUMBER     _POSINT     _NONNEGINT
  	_SCALAR     _SCALAR0
  	_ARRAY      _ARRAY0     _ARRAYLIKE
  	_HASH       _HASH0      _HASHLIKE
  	_CODE       _CODELIKE
  	_INVOCANT   _REGEX      _INSTANCE  _INSTANCEDOES
  	_SET        _SET0
  	_HANDLE
  };
  %EXPORT_TAGS = ( ALL => \@EXPORT_OK );
  
  eval {
  	local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
  	bootstrap Params::Util $VERSION;
  	1;
  } unless $ENV{PERL_PARAMS_UTIL_PP};
  
  # Use a private pure-perl copy of looks_like_number if the version of
  # Scalar::Util is old (for whatever reason).
  my $SU = eval "$Scalar::Util::VERSION" || 0;
  if ( $SU >= 1.18 ) { 
  	Scalar::Util->import('looks_like_number');
  } else {
  	eval <<'END_PERL';
  sub looks_like_number {
  	local $_ = shift;
  
  	# checks from perlfaq4
  	return 0 if !defined($_);
  	if (ref($_)) {
  		return overload::Overloaded($_) ? defined(0 + $_) : 0;
  	}
  	return 1 if (/^[+-]?[0-9]+$/); # is a +/- integer
  	return 1 if (/^([+-]?)(?=[0-9]|\.[0-9])[0-9]*(\.[0-9]*)?([Ee]([+-]?[0-9]+))?$/); # a C float
  	return 1 if ($] >= 5.008 and /^(Inf(inity)?|NaN)$/i) or ($] >= 5.006001 and /^Inf$/i);
  
  	0;
  }
  END_PERL
  }
  
  
  
  
  
  #####################################################################
  # Param Checking Functions
  
  =pod
  
  =head2 _STRING $string
  
  The C<_STRING> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a normal non-false string of non-zero length.
  
  Note that this will NOT do anything magic to deal with the special
  C<'0'> false negative case, but will return it.
  
    # '0' not considered valid data
    my $name = _STRING(shift) or die "Bad name";
    
    # '0' is considered valid data
    my $string = _STRING($_[0]) ? shift : die "Bad string";
  
  Please also note that this function expects a normal string. It does
  not support overloading or other magic techniques to get a string.
  
  Returns the string as a conveince if it is a valid string, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_STRING;
  sub _STRING ($) {
  	(defined $_[0] and ! ref $_[0] and length($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _IDENTIFIER $string
  
  The C<_IDENTIFIER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl identifier.
  
  Returns the string as a convenience if it is a valid identifier, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_IDENTIFIER;
  sub _IDENTIFIER ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASS $string
  
  The C<_CLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl class.
  
  This function only checks that the format is valid, not that the
  class is actually loaded. It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASS;
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASSISA $string, $class
  
  The C<_CLASSISA> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a particularly class, or a subclass of it.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSISA;
  sub _CLASSISA ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =head2 _CLASSDOES $string, $role
  
  This routine behaves exactly like C<L</_CLASSISA>>, but checks with C<< ->DOES
  >> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
  5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
  implemented.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSDOES;
  sub _CLASSDOES ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SUBCLASS $string, $class
  
  The C<_SUBCLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a subclass of a specified class.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SUBCLASS;
  sub _SUBCLASS ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0] ne $_[1] and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NUMBER $scalar
  
  The C<_NUMBER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a number. That is, it is defined and perl thinks it's a number.
  
  This function is basically a Params::Util-style wrapper around the
  L<Scalar::Util> C<looks_like_number> function.
  
  Returns the value as a convience, or C<undef> if the value is not a
  number.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NUMBER;
  sub _NUMBER ($) {
  	( defined $_[0] and ! ref $_[0] and looks_like_number($_[0]) )
  	? $_[0]
  	: undef;
  }
  END_PERL
  
  =pod
  
  =head2 _POSINT $integer
  
  The C<_POSINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a positive integer (of any length).
  
  Returns the value as a convience, or C<undef> if the value is not a
  positive integer.
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_POSINT;
  sub _POSINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[1-9]\d*$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NONNEGINT $integer
  
  The C<_NONNEGINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a non-negative integer (of any length). That is, a positive integer,
  or zero.
  
  Returns the value as a convience, or C<undef> if the value is not a
  non-negative integer.
  
  As with other tests that may return false values, care should be taken
  to test via "defined" in boolean validy contexts.
  
    unless ( defined _NONNEGINT($value) ) {
       die "Invalid value";
    }
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NONNEGINT;
  sub _NONNEGINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^(?:0|[1-9]\d*)$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR \$scalar
  
  The C<_SCALAR> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR> reference, with content of non-zero length.
  
  For a version that allows zero length C<SCALAR> references, see
  the C<_SCALAR0> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR;
  sub _SCALAR ($) {
  	(ref $_[0] eq 'SCALAR' and defined ${$_[0]} and ${$_[0]} ne '') ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR0 \$scalar
  
  The C<_SCALAR0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR0> reference, allowing content of zero-length.
  
  For a simpler "give me some content" version that requires non-zero
  length, C<_SCALAR> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR0;
  sub _SCALAR0 ($) {
  	ref $_[0] eq 'SCALAR' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY $value
  
  The C<_ARRAY> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference containing B<at least> one element of any kind.
  
  For a more basic form that allows zero length ARRAY references, see
  the C<_ARRAY0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY;
  sub _ARRAY ($) {
  	(ref $_[0] eq 'ARRAY' and @{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY0 $value
  
  The C<_ARRAY0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference, allowing C<ARRAY> references that contain no
  elements.
  
  For a more basic "An array of something" form that also requires at
  least one element, see the C<_ARRAY> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY0;
  sub _ARRAY0 ($) {
  	ref $_[0] eq 'ARRAY' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAYLIKE $value
  
  The C<_ARRAYLIKE> function tests whether a given scalar value can respond to
  array dereferencing.  If it can, the value is returned.  If it cannot,
  C<_ARRAYLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAYLIKE;
  sub _ARRAYLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'ARRAY')
  		or
  		overload::Method($_[0], '@{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH $value
  
  The C<_HASH> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference with at least one entry.
  
  For a version of this function that allows the C<HASH> to be empty,
  see the C<_HASH0> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH;
  sub _HASH ($) {
  	(ref $_[0] eq 'HASH' and scalar %{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH0 $value
  
  The C<_HASH0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference, regardless of the C<HASH> content.
  
  For a simpler "A hash of something" version that requires at least one
  element, see the C<_HASH> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH0;
  sub _HASH0 ($) {
  	ref $_[0] eq 'HASH' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASHLIKE $value
  
  The C<_HASHLIKE> function tests whether a given scalar value can respond to
  hash dereferencing.  If it can, the value is returned.  If it cannot,
  C<_HASHLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASHLIKE;
  sub _HASHLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'HASH')
  		or
  		overload::Method($_[0], '%{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODE $value
  
  The C<_CODE> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<CODE> reference.
  
  Returns the C<CODE> reference itself as a convenience, or C<undef>
  if the value provided is not an C<CODE> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODE;
  sub _CODE ($) {
  	ref $_[0] eq 'CODE' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODELIKE $value
  
  The C<_CODELIKE> is the more generic version of C<_CODE>. Unlike C<_CODE>,
  which checks for an explicit C<CODE> reference, the C<_CODELIKE> function
  also includes things that act like them, such as blessed objects that
  overload C<'&{}'>.
  
  Please note that in the case of objects overloaded with '&{}', you will
  almost always end up also testing it in 'bool' context at some stage.
  
  For example:
  
    sub foo {
        my $code1 = _CODELIKE(shift) or die "No code param provided";
        my $code2 = _CODELIKE(shift);
        if ( $code2 ) {
             print "Got optional second code param";
        }
    }
  
  As such, you will most likely always want to make sure your class has
  at least the following to allow it to evaluate to true in boolean
  context.
  
    # Always evaluate to true in boolean context
    use overload 'bool' => sub () { 1 };
  
  Returns the callable value as a convenience, or C<undef> if the
  value provided is not callable.
  
  Note - This function was formerly known as _CALLABLE but has been renamed
  for greater symmetry with the other _XXXXLIKE functions.
  
  The use of _CALLABLE has been deprecated. It will continue to work, but
  with a warning, until end-2006, then will be removed.
  
  I apologise for any inconvenience caused.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODELIKE;
  sub _CODELIKE($) {
  	(
  		(Scalar::Util::reftype($_[0])||'') eq 'CODE'
  		or
  		Scalar::Util::blessed($_[0]) and overload::Method($_[0],'&{}')
  	)
  	? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INVOCANT $value
  
  This routine tests whether the given value is a valid method invocant.
  This can be either an instance of an object, or a class name.
  
  If so, the value itself is returned.  Otherwise, C<_INVOCANT>
  returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INVOCANT;
  sub _INVOCANT($) {
  	(defined $_[0] and
  		(defined Scalar::Util::blessed($_[0])
  		or      
  		# We used to check for stash definedness, but any class-like name is a
  		# valid invocant for UNIVERSAL methods, so we stopped. -- rjbs, 2006-07-02
  		Params::Util::_CLASS($_[0]))
  	) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INSTANCE $object, $class
  
  The C<_INSTANCE> function is intended to be imported into your package,
  and provides a convenient way to test for an object of a particular class
  in a strictly correct manner.
  
  Returns the object itself as a convenience, or C<undef> if the value
  provided is not an object of that type.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCE;
  sub _INSTANCE ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =head2 _INSTANCEDOES $object, $role
  
  This routine behaves exactly like C<L</_INSTANCE>>, but checks with C<< ->DOES
  >> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
  5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
  implemented.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCEDOES;
  sub _INSTANCEDOES ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _REGEX $value
  
  The C<_REGEX> function is intended to be imported into your package,
  and provides a convenient way to test for a regular expression.
  
  Returns the value itself as a convenience, or C<undef> if the value
  provided is not a regular expression.
  
  =cut
  
  eval <<'END_PERL' unless defined &_REGEX;
  sub _REGEX ($) {
  	(defined $_[0] and 'Regexp' eq ref($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SET \@array, $class
  
  The C<_SET> function is intended to be imported into your package,
  and provides a convenient way to test for set of at least one object of
  a particular class in a strictly correct manner.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that allows zero-length sets, see the
  C<_SET0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET;
  sub _SET ($$) {
  	my $set = shift;
  	_ARRAY($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _SET0 \@array, $class
  
  The C<_SET0> function is intended to be imported into your package,
  and provides a convenient way to test for a set of objects of a
  particular class in a strictly correct manner, allowing for zero objects.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that requires at least one object, see the
  C<_SET> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET0;
  sub _SET0 ($$) {
  	my $set = shift;
  	_ARRAY0($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _HANDLE
  
  The C<_HANDLE> function is intended to be imported into your package,
  and provides a convenient way to test whether or not a single scalar
  value is a file handle.
  
  Unfortunately, in Perl the definition of a file handle can be a little
  bit fuzzy, so this function is likely to be somewhat imperfect (at first
  anyway).
  
  That said, it is implement as well or better than the other file handle
  detectors in existance (and we stole from the best of them).
  
  =cut
  
  # We're doing this longhand for now. Once everything is perfect,
  # we'll compress this into something that compiles more efficiently.
  # Further, testing file handles is not something that is generally
  # done millions of times, so doing it slowly is not a big speed hit.
  eval <<'END_PERL' unless defined &_HANDLE;
  sub _HANDLE {
  	my $it = shift;
  
  	# It has to be defined, of course
  	unless ( defined $it ) {
  		return undef;
  	}
  
  	# Normal globs are considered to be file handles
  	if ( ref $it eq 'GLOB' ) {
  		return $it;
  	}
  
  	# Check for a normal tied filehandle
  	# Side Note: 5.5.4's tied() and can() doesn't like getting undef
  	if ( tied($it) and tied($it)->can('TIEHANDLE') ) {
  		return $it;
  	}
  
  	# There are no other non-object handles that we support
  	unless ( Scalar::Util::blessed($it) ) {
  		return undef;
  	}
  
  	# Check for a common base classes for conventional IO::Handle object
  	if ( $it->isa('IO::Handle') ) {
  		return $it;
  	}
  
  
  	# Check for tied file handles using Tie::Handle
  	if ( $it->isa('Tie::Handle') ) {
  		return $it;
  	}
  
  	# IO::Scalar is not a proper seekable, but it is valid is a
  	# regular file handle
  	if ( $it->isa('IO::Scalar') ) {
  		return $it;
  	}
  
  	# Yet another special case for IO::String, which refuses (for now
  	# anyway) to become a subclass of IO::Handle.
  	if ( $it->isa('IO::String') ) {
  		return $it;
  	}
  
  	# This is not any sort of object we know about
  	return undef;
  }
  END_PERL
  
  =pod
  
  =head2 _DRIVER $string
  
    sub foo {
      my $class = _DRIVER(shift, 'My::Driver::Base') or die "Bad driver";
      ...
    }
  
  The C<_DRIVER> function is intended to be imported into your
  package, and provides a convenient way to load and validate
  a driver class.
  
  The most common pattern when taking a driver class as a parameter
  is to check that the name is a class (i.e. check against _CLASS)
  and then to load the class (if it exists) and then ensure that
  the class returns true for the isa method on some base driver name.
  
  Return the value as a convenience, or C<undef> if the value is not
  a class name, the module does not exist, the module does not load,
  or the class fails the isa test.
  
  =cut
  
  eval <<'END_PERL' unless defined &_DRIVER;
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  END_PERL
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Add _CAN to help resolve the UNIVERSAL::can debacle
  
  - Would be even nicer if someone would demonstrate how the hell to
  build a Module::Install dist of the ::Util dual Perl/XS type. :/
  
  - Implement an assertion-like version of this module, that dies on
  error.
  
  - Implement a Test:: version of this module, for use in testing
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params-Util>
  
  For other issues, contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Params::Validate>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2012 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
X86_64-LINUX_PARAMS_UTIL

$fatpacked{"x86_64-linux/Params/Validate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PARAMS_VALIDATE';
  package Params::Validate;
  
  use 5.008001;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.29';
  
  use Exporter;
  use Module::Implementation;
  use Params::Validate::Constants;
  
  use vars qw( $NO_VALIDATION %OPTIONS $options );
  
  our @ISA = 'Exporter';
  
  my @types = qw(
      SCALAR
      ARRAYREF
      HASHREF
      CODEREF
      GLOB
      GLOBREF
      SCALARREF
      HANDLE
      BOOLEAN
      UNDEF
      OBJECT
  );
  
  our %EXPORT_TAGS = (
      'all' => [
          qw( validate validate_pos validation_options validate_with ),
          @types
      ],
      types => \@types,
  );
  
  our @EXPORT_OK = ( @{ $EXPORT_TAGS{all} }, 'set_options' );
  our @EXPORT = qw( validate validate_pos );
  
  $NO_VALIDATION = $ENV{PERL_NO_VALIDATION};
  
  {
      my $loader = Module::Implementation::build_loader_sub(
          implementations => [ 'XS', 'PP' ],
          symbols         => [
              qw(
                  validate
                  validate_pos
                  validate_with
                  validation_options
                  set_options
                  ),
          ],
      );
  
      $ENV{PARAMS_VALIDATE_IMPLEMENTATION} = 'PP' if $ENV{PV_TEST_PERL};
  
      $loader->();
  }
  
  1;
  
  # ABSTRACT: Validate method/function parameters
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Params::Validate - Validate method/function parameters
  
  =head1 VERSION
  
  version 1.29
  
  =head1 SYNOPSIS
  
      use Params::Validate qw(:all);
  
      # takes named params (hash or hashref)
      sub foo {
          validate(
              @_, {
                  foo => 1,    # mandatory
                  bar => 0,    # optional
              }
          );
      }
  
      # takes positional params
      sub bar {
          # first two are mandatory, third is optional
          validate_pos( @_, 1, 1, 0 );
      }
  
      sub foo2 {
          validate(
              @_, {
                  foo =>
                      # specify a type
                      { type => ARRAYREF },
                  bar =>
                      # specify an interface
                      { can => [ 'print', 'flush', 'frobnicate' ] },
                  baz => {
                      type      => SCALAR,     # a scalar ...
                                               # ... that is a plain integer ...
                      regex     => qr/^\d+$/,
                      callbacks => {           # ... and smaller than 90
                          'less than 90' => sub { shift() < 90 },
                      },
                  }
              }
          );
      }
  
      sub callback_with_custom_error {
          validate(
              @_,
              {
                  foo => {
                      callbacks => {
                          'is an integer' => sub {
                              return 1 if $_[0] =~ /^-?[1-9][0-9]*$/;
                              die "$_[0] is not a valid integer value";
                          },
                      },
                  }
              }
          );
      }
  
      sub with_defaults {
          my %p = validate(
              @_, {
                  # required
                  foo => 1,
                  # $p{bar} will be 99 if bar is not given. bar is now
                  # optional.
                  bar => { default => 99 }
              }
          );
      }
  
      sub pos_with_defaults {
          my @p = validate_pos( @_, 1, { default => 99 } );
      }
  
      sub sets_options_on_call {
          my %p = validate_with(
              params => \@_,
              spec   => { foo => { type => SCALAR, default => 2 } },
              normalize_keys => sub { $_[0] =~ s/^-//; lc $_[0] },
          );
      }
  
  =head1 DESCRIPTION
  
  B<< I would recommend you consider using L<Params::ValidationCompiler>
  instead. That module, despite being pure Perl, is I<significantly> faster than
  this one, at the cost of having to adopt a type system such as L<Specio>,
  L<Type::Tiny>, or the one shipped with L<Moose> >>.
  
  This module allows you to validate method or function call parameters to an
  arbitrary level of specificity. At the simplest level, it is capable of
  validating the required parameters were given and that no unspecified
  additional parameters were passed in.
  
  It is also capable of determining that a parameter is of a specific
  type, that it is an object of a certain class hierarchy, that it
  possesses certain methods, or applying validation callbacks to
  arguments.
  
  =head2 EXPORT
  
  The module always exports the C<validate()> and C<validate_pos()>
  functions.
  
  It also has an additional function available for export,
  C<validate_with>, which can be used to validate any type of
  parameters, and set various options on a per-invocation basis.
  
  In addition, it can export the following constants, which are used as
  part of the type checking. These are C<SCALAR>, C<ARRAYREF>,
  C<HASHREF>, C<CODEREF>, C<GLOB>, C<GLOBREF>, and C<SCALARREF>,
  C<UNDEF>, C<OBJECT>, C<BOOLEAN>, and C<HANDLE>. These are explained
  in the section on L<Type Validation|Params::Validate/Type Validation>.
  
  The constants are available via the export tag C<:types>. There is
  also an C<:all> tag which includes all of the constants as well as the
  C<validation_options()> function.
  
  =head1 PARAMETER VALIDATION
  
  The validation mechanisms provided by this module can handle both
  named or positional parameters. For the most part, the same features
  are available for each. The biggest difference is the way that the
  validation specification is given to the relevant subroutine. The
  other difference is in the error messages produced when validation
  checks fail.
  
  When handling named parameters, the module will accept either a hash
  or a hash reference.
  
  Subroutines expecting named parameters should call the C<validate()>
  subroutine like this:
  
      validate(
          @_, {
              parameter1 => validation spec,
              parameter2 => validation spec,
              ...
          }
      );
  
  Subroutines expecting positional parameters should call the
  C<validate_pos()> subroutine like this:
  
      validate_pos( @_, { validation spec }, { validation spec } );
  
  =head2 Mandatory/Optional Parameters
  
  If you just want to specify that some parameters are mandatory and
  others are optional, this can be done very simply.
  
  For a subroutine expecting named parameters, you would do this:
  
      validate( @_, { foo => 1, bar => 1, baz => 0 } );
  
  This says that the "foo" and "bar" parameters are mandatory and that
  the "baz" parameter is optional. The presence of any other
  parameters will cause an error.
  
  For a subroutine expecting positional parameters, you would do this:
  
      validate_pos( @_, 1, 1, 0, 0 );
  
  This says that you expect at least 2 and no more than 4 parameters.
  If you have a subroutine that has a minimum number of parameters but
  can take any maximum number, you can do this:
  
      validate_pos( @_, 1, 1, (0) x (@_ - 2) );
  
  This will always be valid as long as at least two parameters are
  given. A similar construct could be used for the more complex
  validation parameters described further on.
  
  Please note that this:
  
      validate_pos( @_, 1, 1, 0, 1, 1 );
  
  makes absolutely no sense, so don't do it. Any zeros must come at the
  end of the validation specification.
  
  In addition, if you specify that a parameter can have a default, then
  it is considered optional.
  
  =head2 Type Validation
  
  This module supports the following simple types, which can be
  L<exported as constants|/EXPORT>:
  
  =over 4
  
  =item * SCALAR
  
  A scalar which is not a reference, such as C<10> or C<'hello'>. A
  parameter that is undefined is B<not> treated as a scalar. If you
  want to allow undefined values, you will have to specify C<SCALAR |
  UNDEF>.
  
  =item * ARRAYREF
  
  An array reference such as C<[1, 2, 3]> or C<\@foo>.
  
  =item * HASHREF
  
  A hash reference such as C<< { a => 1, b => 2 } >> or C<\%bar>.
  
  =item * CODEREF
  
  A subroutine reference such as C<\&foo_sub> or C<sub { print "hello" }>.
  
  =item * GLOB
  
  This one is a bit tricky. A glob would be something like C<*FOO>, but
  not C<\*FOO>, which is a glob reference. It should be noted that this
  trick:
  
      my $fh = do { local *FH; };
  
  makes C<$fh> a glob, not a glob reference. On the other hand, the
  return value from C<Symbol::gensym> is a glob reference. Either can
  be used as a file or directory handle.
  
  =item * GLOBREF
  
  A glob reference such as C<\*FOO>. See the L<GLOB|GLOB> entry above
  for more details.
  
  =item * SCALARREF
  
  A reference to a scalar such as C<\$x>.
  
  =item * UNDEF
  
  An undefined value
  
  =item * OBJECT
  
  A blessed reference.
  
  =item * BOOLEAN
  
  This is a special option, and is just a shortcut for C<UNDEF | SCALAR>.
  
  =item * HANDLE
  
  This option is also special, and is just a shortcut for C<GLOB |
  GLOBREF>. However, it seems likely that most people interested in
  either globs or glob references are likely to really be interested in
  whether the parameter in question could be a valid file or directory
  handle.
  
  =back
  
  To specify that a parameter must be of a given type when using named
  parameters, do this:
  
      validate(
          @_, {
              foo => { type => SCALAR },
              bar => { type => HASHREF }
          }
      );
  
  If a parameter can be of more than one type, just use the bitwise or
  (C<|>) operator to combine them.
  
      validate( @_, { foo => { type => GLOB | GLOBREF } );
  
  For positional parameters, this can be specified as follows:
  
      validate_pos( @_, { type => SCALAR | ARRAYREF }, { type => CODEREF } );
  
  =head2 Interface Validation
  
  To specify that a parameter is expected to have a certain set of
  methods, we can do the following:
  
      validate(
          @_, {
              foo =>
                  # just has to be able to ->bar
                  { can => 'bar' }
          }
      );
  
   ... or ...
  
      validate(
          @_, {
              foo =>
                  # must be able to ->bar and ->print
                  { can => [qw( bar print )] }
          }
      );
  
  =head2 Class Validation
  
  A word of warning. When constructing your external interfaces, it is
  probably better to specify what methods you expect an object to
  have rather than what class it should be of (or a child of). This
  will make your API much more flexible.
  
  With that said, if you want to validate that an incoming parameter
  belongs to a class (or child class) or classes, do:
  
      validate(
          @_,
          { foo => { isa => 'My::Frobnicator' } }
      );
  
   ... or ...
  
      validate(
          @_,
          # must be both, not either!
          { foo => { isa => [qw( My::Frobnicator IO::Handle )] } }
      );
  
  =head2 Regex Validation
  
  If you want to specify that a given parameter must match a specific
  regular expression, this can be done with "regex" spec key. For
  example:
  
      validate(
          @_,
          { foo => { regex => qr/^\d+$/ } }
      );
  
  The value of the "regex" key may be either a string or a pre-compiled
  regex created via C<qr>.
  
  If the value being checked against a regex is undefined, the regex is
  explicitly checked against the empty string ('') instead, in order to
  avoid "Use of uninitialized value" warnings.
  
  The C<Regexp::Common> module on CPAN is an excellent source of regular
  expressions suitable for validating input.
  
  =head2 Callback Validation
  
  If none of the above are enough, it is possible to pass in one or more
  callbacks to validate the parameter. The callback will be given the
  B<value> of the parameter as its first argument. Its second argument
  will be all the parameters, as a reference to either a hash or array.
  Callbacks are specified as hash reference. The key is an id for the
  callback (used in error messages) and the value is a subroutine
  reference, such as:
  
      validate(
          @_,
          {
              foo => {
                  callbacks => {
                      'smaller than a breadbox' => sub { shift() < $breadbox },
                      'green or blue'           => sub {
                          return 1 if $_[0] eq 'green' || $_[0] eq 'blue';
                          die "$_[0] is not green or blue!";
                      }
                  }
              }
          }
      );
  
      validate(
          @_, {
              foo => {
                  callbacks => {
                      'bigger than baz' => sub { $_[0] > $_[1]->{baz} }
                  }
              }
          }
      );
  
  The callback should return a true value if the value is valid. If not, it can
  return false or die. If you return false, a generic error message will be
  thrown by C<Params::Validate>.
  
  If your callback dies instead you can provide a custom error message. If the
  callback dies with a plain string, this string will be appended to an
  exception message generated by C<Params::Validate>. If the callback dies with
  a reference (blessed or not), then this will be rethrown as-is by
  C<Params::Validate>.
  
  =head2 Untainting
  
  If you want values untainted, set the "untaint" key in a spec hashref
  to a true value, like this:
  
      my %p = validate(
          @_, {
              foo => { type => SCALAR, untaint => 1 },
              bar => { type => ARRAYREF }
          }
      );
  
  This will untaint the "foo" parameter if the parameters are valid.
  
  Note that untainting is only done if I<all parameters> are valid.
  Also, only the return values are untainted, not the original values
  passed into the validation function.
  
  Asking for untainting of a reference value will not do anything, as
  C<Params::Validate> will only attempt to untaint the reference itself.
  
  =head2 Mandatory/Optional Revisited
  
  If you want to specify something such as type or interface, plus the
  fact that a parameter can be optional, do this:
  
      validate(
          @_, {
              foo => { type => SCALAR },
              bar => { type => ARRAYREF, optional => 1 }
          }
      );
  
  or this for positional parameters:
  
      validate_pos(
          @_,
          { type => SCALAR },
          { type => ARRAYREF, optional => 1 }
      );
  
  By default, parameters are assumed to be mandatory unless specified as
  optional.
  
  =head2 Dependencies
  
  It also possible to specify that a given optional parameter depends on
  the presence of one or more other optional parameters.
  
      validate(
          @_, {
              cc_number => {
                  type     => SCALAR,
                  optional => 1,
                  depends  => [ 'cc_expiration', 'cc_holder_name' ],
              },
              cc_expiration  => { type => SCALAR, optional => 1 },
              cc_holder_name => { type => SCALAR, optional => 1 },
          }
      );
  
  In this case, "cc_number", "cc_expiration", and "cc_holder_name" are
  all optional. However, if "cc_number" is provided, then
  "cc_expiration" and "cc_holder_name" must be provided as well.
  
  This allows you to group together sets of parameters that all must be
  provided together.
  
  The C<validate_pos()> version of dependencies is slightly different,
  in that you can only depend on one other parameter. Also, if for
  example, the second parameter 2 depends on the fourth parameter, then
  it implies a dependency on the third parameter as well. This is
  because if the fourth parameter is required, then the user must also
  provide a third parameter so that there can be four parameters in
  total.
  
  C<Params::Validate> will die if you try to depend on a parameter not
  declared as part of your parameter specification.
  
  =head2 Specifying defaults
  
  If the C<validate()> or C<validate_pos()> functions are called in a list
  context, they will return a hash or containing the original parameters plus
  defaults as indicated by the validation spec.
  
  If the function is not called in a list context, providing a default
  in the validation spec still indicates that the parameter is optional.
  
  The hash or array returned from the function will always be a copy of
  the original parameters, in order to leave C<@_> untouched for the
  calling function.
  
  Simple examples of defaults would be:
  
      my %p = validate( @_, { foo => 1, bar => { default => 99 } } );
  
      my @p = validate_pos( @_, 1, { default => 99 } );
  
  In scalar context, a hash reference or array reference will be
  returned, as appropriate.
  
  =head1 USAGE NOTES
  
  =head2 Validation failure
  
  By default, when validation fails C<Params::Validate> calls
  C<Carp::confess()>. This can be overridden by setting the C<on_fail>
  option, which is described in the L<"GLOBAL" OPTIONS|"GLOBAL" OPTIONS>
  section.
  
  =head2 Method calls
  
  When using this module to validate the parameters passed to a method
  call, you will probably want to remove the class/object from the
  parameter list B<before> calling C<validate()> or C<validate_pos()>.
  If your method expects named parameters, then this is necessary for
  the C<validate()> function to actually work, otherwise C<@_> will not
  be usable as a hash, because it will first have your object (or
  class) B<followed> by a set of keys and values.
  
  Thus the idiomatic usage of C<validate()> in a method call will look
  something like this:
  
      sub method {
          my $self = shift;
  
          my %params = validate(
              @_, {
                  foo => 1,
                  bar => { type => ARRAYREF },
              }
          );
      }
  
  =head2 Speeding Up Validation
  
  In most cases, the validation spec will remain the same for each call to a
  subroutine. In that case, you can speed up validation by defining the
  validation spec just once, rather than on each call to the subroutine:
  
      my %spec = ( ... );
      sub foo {
          my %params = validate( @_, \%spec );
      }
  
  You can also use the C<state> feature to do this:
  
      use feature 'state';
  
      sub foo {
          state $spec = { ... };
          my %params = validate( @_, $spec );
      }
  
  =head1 "GLOBAL" OPTIONS
  
  Because the API for the C<validate()> and C<validate_pos()> functions does not
  make it possible to specify any options other than the validation spec, it is
  possible to set some options as pseudo-'globals'. These allow you to specify
  such things as whether or not the validation of named parameters should be
  case sensitive, for one example.
  
  These options are called pseudo-'globals' because these settings are
  B<only applied to calls originating from the package that set the
  options>.
  
  In other words, if I am in package C<Foo> and I call
  C<validation_options()>, those options are only in effect when I call
  C<validate()> from package C<Foo>.
  
  While this is quite different from how most other modules operate, I
  feel that this is necessary in able to make it possible for one
  module/application to use Params::Validate while still using other
  modules that also use Params::Validate, perhaps with different
  options set.
  
  The downside to this is that if you are writing an app with a standard
  calling style for all functions, and your app has ten modules, B<each
  module must include a call to C<validation_options()>>. You could of
  course write a module that all your modules use which uses various
  trickery to do this when imported.
  
  =head2 Options
  
  =over 4
  
  =item * normalize_keys => $callback
  
  This option is only relevant when dealing with named parameters.
  
  This callback will be used to transform the hash keys of both the
  parameters and the parameter spec when C<validate()> or
  C<validate_with()> are called.
  
  Any alterations made by this callback will be reflected in the
  parameter hash that is returned by the validation function. For
  example:
  
      sub foo {
          return validate_with(
              params => \@_,
              spec   => { foo => { type => SCALAR } },
              normalize_keys =>
                  sub { my $k = shift; $k =~ s/^-//; return uc $k },
          );
  
      }
  
      %p = foo( foo => 20 );
  
      # $p{FOO} is now 20
  
      %p = foo( -fOo => 50 );
  
      # $p{FOO} is now 50
  
  The callback must return a defined value.
  
  If a callback is given then the deprecated "ignore_case" and
  "strip_leading" options are ignored.
  
  =item * allow_extra => $boolean
  
  If true, then the validation routine will allow extra parameters not
  named in the validation specification. In the case of positional
  parameters, this allows an unlimited number of maximum parameters
  (though a minimum may still be set). Defaults to false.
  
  =item * on_fail => $callback
  
  If given, this callback will be called whenever a validation check
  fails. It will be called with a single parameter, which will be a
  string describing the failure. This is useful if you wish to have
  this module throw exceptions as objects rather than as strings, for
  example.
  
  This callback is expected to C<die()> internally. If it does not, the
  validation will proceed onwards, with unpredictable results.
  
  The default is to simply use the Carp module's C<confess()> function.
  
  =item * stack_skip => $number
  
  This tells Params::Validate how many stack frames to skip when finding
  a subroutine name to use in error messages. By default, it looks one
  frame back, at the immediate caller to C<validate()> or
  C<validate_pos()>. If this option is set, then the given number of
  frames are skipped instead.
  
  =item * ignore_case => $boolean
  
  DEPRECATED
  
  This is only relevant when dealing with named parameters. If it is
  true, then the validation code will ignore the case of parameter
  names. Defaults to false.
  
  =item * strip_leading => $characters
  
  DEPRECATED
  
  This too is only relevant when dealing with named parameters. If this
  is given then any parameters starting with these characters will be
  considered equivalent to parameters without them entirely. For
  example, if this is specified as '-', then C<-foo> and C<foo> would be
  considered identical.
  
  =back
  
  =head1 PER-INVOCATION OPTIONS
  
  The C<validate_with()> function can be used to set the options listed
  above on a per-invocation basis. For example:
  
      my %p = validate_with(
          params => \@_,
          spec   => {
              foo => { type    => SCALAR },
              bar => { default => 10 }
          },
          allow_extra => 1,
      );
  
  In addition to the options listed above, it is also possible to set
  the option "called", which should be a string. This string will be
  used in any error messages caused by a failure to meet the validation
  spec.
  
  This subroutine will validate named parameters as a hash if the "spec"
  parameter is a hash reference. If it is an array reference, the
  parameters are assumed to be positional.
  
      my %p = validate_with(
          params => \@_,
          spec   => {
              foo => { type    => SCALAR },
              bar => { default => 10 }
          },
          allow_extra => 1,
          called      => 'The Quux::Baz class constructor',
      );
  
      my @p = validate_with(
          params => \@_,
          spec   => [
              { type    => SCALAR },
              { default => 10 }
          ],
          allow_extra => 1,
          called      => 'The Quux::Baz class constructor',
      );
  
  =head1 DISABLING VALIDATION
  
  If the environment variable C<PERL_NO_VALIDATION> is set to something
  true, then validation is turned off. This may be useful if you only
  want to use this module during development but don't want the speed
  hit during production.
  
  The only error that will be caught will be when an odd number of
  parameters are passed into a function/method that expects a hash.
  
  If you want to selectively turn validation on and off at runtime, you
  can directly set the C<$Params::Validate::NO_VALIDATION> global
  variable. It is B<strongly> recommended that you B<localize> any
  changes to this variable, because other modules you are using may
  expect validation to be on when they execute. For example:
  
      {
          local $Params::Validate::NO_VALIDATION = 1;
  
          # no error
          foo( bar => 2 );
      }
  
      # error
      foo( bar => 2 );
  
      sub foo {
          my %p = validate( @_, { foo => 1 } );
          ...;
      }
  
  But if you want to shoot yourself in the foot and just turn it off, go
  ahead!
  
  =head1 SPECIFYING AN IMPLEMENTATION
  
  This module ships with two equivalent implementations, one in XS and one in
  pure Perl. By default, it will try to load the XS version and fall back to the
  pure Perl implementation as needed. If you want to request a specific version,
  you can set the C<PARAMS_VALIDATE_IMPLEMENTATION> environment variable to
  either C<XS> or C<PP>. If the implementation you ask for cannot be loaded,
  then this module will die when loaded.
  
  =head1 TAINT MODE
  
  The XS implementation of this module has some problems Under taint mode with
  versions of Perl before 5.14. If validation I<fails>, then instead of getting
  the expected error message you'll get a message like "Insecure dependency in
  eval_sv". This can be worked around by either untainting the arguments
  yourself, using the pure Perl implementation, or upgrading your Perl.
  
  =head1 LIMITATIONS
  
  Right now there is no way (short of a callback) to specify that
  something must be of one of a list of classes, or that it must possess
  one of a list of methods. If this is desired, it can be added in the
  future.
  
  Ideally, there would be only one validation function. If someone
  figures out how to do this, please let me know.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<http://rt.cpan.org/Public/Dist/Display.html?Name=Params-Validate> or via email to L<bug-params-validate@rt.cpan.org|mailto:bug-params-validate@rt.cpan.org>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Params-Validate can be found at L<https://github.com/houseabsolute/Params-Validate>.
  
  =head1 DONATIONS
  
  If you'd like to thank me for the work I've done on this module, please
  consider making a "donation" to me via PayPal. I spend a lot of free time
  creating free software, and would appreciate any support you'd care to offer.
  
  Please note that B<I am not suggesting that you must do this> in order for me
  to continue working on this particular software. I will continue to do so,
  inasmuch as I have in the past, for as long as it interests me.
  
  Similarly, a donation made in this way will probably not make me work on this
  software much more, unless I get so many donations that I can consider working
  on free software full time (let's all have a chuckle at that together).
  
  To donate, log into PayPal and send money to autarch@urth.org, or use the
  button at L<http://www.urth.org/~autarch/fs-donation.html>.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Ilya Martynov <ilya@martynov.org>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Andy Grundman E. Choroba Ivan Bessarabov J.R. Mash Karen Etheridge Noel Maddy Olivier Mengué Tony Cook Vincent Pit
  
  =over 4
  
  =item *
  
  Andy Grundman <andyg@activestate.com>
  
  =item *
  
  E. Choroba <choroba@matfyz.cz>
  
  =item *
  
  Ivan Bessarabov <ivan@bessarabov.ru>
  
  =item *
  
  J.R. Mash <jmash.code@gmail.com>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Noel Maddy <zhtwnpanta@gmail.com>
  
  =item *
  
  Olivier Mengué <dolmen@cpan.org>
  
  =item *
  
  Tony Cook <tony@develop-help.com>
  
  =item *
  
  Vincent Pit <perl@profvince.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2001 - 2017 by Dave Rolsky and Ilya Martynov.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
X86_64-LINUX_PARAMS_VALIDATE

$fatpacked{"x86_64-linux/Params/Validate/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PARAMS_VALIDATE_CONSTANTS';
  package Params::Validate::Constants;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.29';
  
  our @ISA = 'Exporter';
  
  our @EXPORT = qw(
      SCALAR
      ARRAYREF
      HASHREF
      CODEREF
      GLOB
      GLOBREF
      SCALARREF
      HANDLE
      BOOLEAN
      UNDEF
      OBJECT
      UNKNOWN
  );
  
  sub SCALAR ()    { 1 }
  sub ARRAYREF ()  { 2 }
  sub HASHREF ()   { 4 }
  sub CODEREF ()   { 8 }
  sub GLOB ()      { 16 }
  sub GLOBREF ()   { 32 }
  sub SCALARREF () { 64 }
  sub UNKNOWN ()   { 128 }
  sub UNDEF ()     { 256 }
  sub OBJECT ()    { 512 }
  
  sub HANDLE ()  { 16 | 32 }
  sub BOOLEAN () { 1 | 256 }
  
  1;
X86_64-LINUX_PARAMS_VALIDATE_CONSTANTS

$fatpacked{"x86_64-linux/Params/Validate/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PARAMS_VALIDATE_PP';
  package Params::Validate::PP;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.29';
  
  use Params::Validate::Constants;
  use Scalar::Util 1.10 ();
  
  our $options;
  
  # Various internals notes (for me and any future readers of this
  # monstrosity):
  #
  # - A lot of the weirdness is _intentional_, because it optimizes for
  #   the _success_ case.  It does not really matter how slow the code is
  #   after it enters a path that leads to reporting failure.  But the
  #   "success" path should be as fast as possible.
  #
  # -- We only calculate $called as needed for this reason, even though it
  #    means copying code all over.
  #
  # - All the validation routines need to be careful never to alter the
  #   references that are passed.
  #
  # -- The code assumes that _most_ callers will not be using the
  #    skip_leading or ignore_case features.  In order to not alter the
  #    references passed in, we copy them wholesale when normalizing them
  #    to make these features work.  This is slower but lets us be faster
  #    when not using them.
  
  # Matt Sergeant came up with this prototype, which slickly takes the
  # first array (which should be the caller's @_), and makes it a
  # reference.  Everything after is the parameters for validation.
  sub validate_pos (\@@) {
      return if $Params::Validate::NO_VALIDATION && !defined wantarray;
  
      my $p = shift;
  
      my @specs = @_;
  
      my @p = @$p;
      if ($Params::Validate::NO_VALIDATION) {
  
          # if the spec is bigger that's where we can start adding
          # defaults
          for ( my $x = $#p + 1; $x <= $#specs; $x++ ) {
              $p[$x] = $specs[$x]->{default}
                  if ref $specs[$x] && exists $specs[$x]->{default};
          }
  
          return wantarray ? @p : \@p;
      }
  
      # I'm too lazy to pass these around all over the place.
      local $options ||= _get_options( ( caller(0) )[0] )
          unless defined $options;
  
      my $min = 0;
  
      while (1) {
          last
              unless (
              ref $specs[$min]
              ? !( exists $specs[$min]->{default} || $specs[$min]->{optional} )
              : $specs[$min]
              );
  
          $min++;
      }
  
      my $max = scalar @specs;
  
      my $actual = scalar @p;
      unless ( $actual >= $min
          && ( $options->{allow_extra} || $actual <= $max ) ) {
          my $minmax = (
              $options->{allow_extra}
              ? "at least $min"
              : ( $min != $max ? "$min - $max" : $max )
          );
  
          my $val = $options->{allow_extra} ? $min : $max;
          $minmax .= $val != 1 ? ' were' : ' was';
  
          my $called = _get_called();
  
          $options->{on_fail}->( "$actual parameter"
                  . ( $actual != 1 ? 's'    : '' ) . " "
                  . ( $actual != 1 ? 'were' : 'was' )
                  . " passed to $called but $minmax expected\n" );
      }
  
      my $bigger = $#p > $#specs ? $#p : $#specs;
      foreach ( 0 .. $bigger ) {
          my $spec = $specs[$_];
  
          next unless ref $spec;
  
          if ( $_ <= $#p ) {
              _validate_one_param(
                  $p[$_], \@p, $spec,
                  'Parameter #' . ( $_ + 1 ) . ' (%s)'
              );
          }
  
          $p[$_] = $spec->{default} if $_ > $#p && exists $spec->{default};
      }
  
      _validate_pos_depends( \@p, \@specs );
  
      foreach (
          grep {
                     defined $p[$_]
                  && !ref $p[$_]
                  && ref $specs[$_]
                  && $specs[$_]{untaint}
          } 0 .. $bigger
          ) {
          ( $p[$_] ) = $p[$_] =~ /(.+)/;
      }
  
      return wantarray ? @p : \@p;
  }
  
  sub _validate_pos_depends {
      my ( $p, $specs ) = @_;
  
      for my $p_idx ( 0 .. $#$p ) {
          my $spec = $specs->[$p_idx];
  
          next
              unless $spec
              && UNIVERSAL::isa( $spec, 'HASH' )
              && exists $spec->{depends};
  
          my $depends = $spec->{depends};
  
          if ( ref $depends ) {
              require Carp;
              local $Carp::CarpLevel = 2;
              Carp::croak(
                  "Arguments to 'depends' for validate_pos() must be a scalar");
          }
  
          my $p_size = scalar @$p;
          if ( $p_size < $depends - 1 ) {
              my $error
                  = (   "Parameter #"
                      . ( $p_idx + 1 )
                      . " depends on parameter #"
                      . $depends
                      . ", which was not given" );
  
              $options->{on_fail}->($error);
          }
      }
      return 1;
  }
  
  sub _validate_named_depends {
      my ( $p, $specs ) = @_;
  
      foreach my $pname ( keys %$p ) {
          my $spec = $specs->{$pname};
  
          next
              unless $spec
              && UNIVERSAL::isa( $spec, 'HASH' )
              && $spec->{depends};
  
          unless ( UNIVERSAL::isa( $spec->{depends}, 'ARRAY' )
              || !ref $spec->{depends} ) {
              require Carp;
              local $Carp::CarpLevel = 2;
              Carp::croak(
                  "Arguments to 'depends' must be a scalar or arrayref");
          }
  
          foreach my $depends_name (
              ref $spec->{depends}
              ? @{ $spec->{depends} }
              : $spec->{depends}
              ) {
              unless ( exists $p->{$depends_name} ) {
                  my $error
                      = (   "Parameter '$pname' depends on parameter '"
                          . $depends_name
                          . "', which was not given" );
  
                  $options->{on_fail}->($error);
              }
          }
      }
  }
  
  sub validate (\@$) {
      return if $Params::Validate::NO_VALIDATION && !defined wantarray;
  
      my $p = $_[0];
  
      my $specs = $_[1];
      local $options = _get_options( ( caller(0) )[0] ) unless defined $options;
  
      if ( ref $p eq 'ARRAY' ) {
  
          # we were called as validate( @_, ... ) where @_ has a
          # single element, a hash reference
          if ( ref $p->[0] ) {
              $p = { %{ $p->[0] } };
          }
          elsif ( @$p % 2 ) {
              my $called = _get_called();
  
              $options->{on_fail}
                  ->(   "Odd number of parameters in call to $called "
                      . "when named parameters were expected\n" );
          }
          else {
              $p = {@$p};
          }
      }
  
      if ( $options->{normalize_keys} ) {
          $specs = _normalize_callback( $specs, $options->{normalize_keys} );
          $p     = _normalize_callback( $p,     $options->{normalize_keys} );
      }
      elsif ( $options->{ignore_case} || $options->{strip_leading} ) {
          $specs = _normalize_named($specs);
          $p     = _normalize_named($p);
      }
  
      if ($Params::Validate::NO_VALIDATION) {
          return (
              wantarray
              ? (
  
                  # this is a hash containing just the defaults
                  (
                      map { $_ => $specs->{$_}->{default} }
                          grep {
                          ref $specs->{$_}
                              && exists $specs->{$_}->{default}
                          }
                          keys %$specs
                  ),
                  (
                      ref $p eq 'ARRAY'
                      ? (
                          ref $p->[0]
                          ? %{ $p->[0] }
                          : @$p
                          )
                      : %$p
                  )
                  )
              : do {
                  my $ref = (
                      ref $p eq 'ARRAY'
                      ? (
                          ref $p->[0]
                          ? $p->[0]
                          : {@$p}
                          )
                      : $p
                  );
  
                  foreach (
                      grep {
                          ref $specs->{$_}
                              && exists $specs->{$_}->{default}
                      }
                      keys %$specs
                      ) {
                      $ref->{$_} = $specs->{$_}->{default}
                          unless exists $ref->{$_};
                  }
  
                  return $ref;
                  }
          );
      }
  
      _validate_named_depends( $p, $specs );
  
      unless ( $options->{allow_extra} ) {
          if ( my @unmentioned = grep { !exists $specs->{$_} } keys %$p ) {
              my $called = _get_called();
  
              $options->{on_fail}->( "The following parameter"
                      . ( @unmentioned > 1 ? 's were' : ' was' )
                      . " passed in the call to $called but "
                      . ( @unmentioned > 1 ? 'were' : 'was' )
                      . " not listed in the validation options: @unmentioned\n"
              );
          }
      }
  
      my @missing;
  
      # the iterator needs to be reset in case the same hashref is being
      # passed to validate() on successive calls, because we may not go
      # through all the hash's elements
      keys %$specs;
  OUTER:
      while ( my ( $key, $spec ) = each %$specs ) {
          if (
              !exists $p->{$key}
              && (
                  ref $spec
                  ? !(
                      do {
  
                          # we want to short circuit the loop here if we
                          # can assign a default, because there's no need
                          # check anything else at all.
                          if ( exists $spec->{default} ) {
                              $p->{$key} = $spec->{default};
                              next OUTER;
                          }
                      }
                      || do {
  
                          # Similarly, an optional parameter that is
                          # missing needs no additional processing.
                          next OUTER if $spec->{optional};
                      }
                  )
                  : $spec
              )
              ) {
              push @missing, $key;
          }
  
          # Can't validate a non hashref spec beyond the presence or
          # absence of the parameter.
          elsif ( ref $spec ) {
              my $value = defined $p->{$key} ? qq|"$p->{$key}"| : 'undef';
              _validate_one_param(
                  $p->{$key}, $p, $spec,
                  qq{The '$key' parameter (%s)}
              );
          }
      }
  
      if (@missing) {
          my $called = _get_called();
  
          my $missing = join ', ', map {"'$_'"} sort @missing;
          $options->{on_fail}->( "Mandatory parameter"
                  . ( @missing > 1 ? 's' : '' )
                  . " $missing missing in call to $called\n" );
      }
  
      # do untainting after we know everything passed
      foreach my $key (
          grep {
                     defined $p->{$_}
                  && !ref $p->{$_}
                  && ref $specs->{$_}
                  && $specs->{$_}{untaint}
          }
          keys %$p
          ) {
          ( $p->{$key} ) = $p->{$key} =~ /(.+)/;
      }
  
      return wantarray ? %$p : $p;
  }
  
  sub validate_with {
      return if $Params::Validate::NO_VALIDATION && !defined wantarray;
  
      my %p = @_;
  
      local $options = _get_options( ( caller(0) )[0], %p );
  
      unless ($Params::Validate::NO_VALIDATION) {
          unless ( exists $options->{called} ) {
              $options->{called} = ( caller( $options->{stack_skip} ) )[3];
          }
  
      }
  
      if ( UNIVERSAL::isa( $p{spec}, 'ARRAY' ) ) {
          return validate_pos( @{ $p{params} }, @{ $p{spec} } );
      }
      else {
  
          # intentionally ignore the prototype because this contains
          # either an array or hash reference, and validate() will
          # handle either one properly
          return &validate( $p{params}, $p{spec} );
      }
  }
  
  sub _normalize_callback {
      my ( $p, $func ) = @_;
  
      my %new;
  
      foreach my $key ( keys %$p ) {
          my $new_key = $func->($key);
  
          unless ( defined $new_key ) {
              die
                  "The normalize_keys callback did not return a defined value when normalizing the key '$key'";
          }
  
          if ( exists $new{$new_key} ) {
              die
                  "The normalize_keys callback returned a key that already exists, '$new_key', when normalizing the key '$key'";
          }
  
          $new{$new_key} = $p->{$key};
      }
  
      return \%new;
  }
  
  sub _normalize_named {
  
      # intentional copy so we don't destroy original
      my %h = ( ref $_[0] ) =~ /ARRAY/ ? @{ $_[0] } : %{ $_[0] };
  
      if ( $options->{ignore_case} ) {
          $h{ lc $_ } = delete $h{$_} for keys %h;
      }
  
      if ( $options->{strip_leading} ) {
          foreach my $key ( keys %h ) {
              my $new;
              ( $new = $key ) =~ s/^\Q$options->{strip_leading}\E//;
              $h{$new} = delete $h{$key};
          }
      }
  
      return \%h;
  }
  
  my %Valid = map { $_ => 1 }
      qw( callbacks can default depends isa optional regex type untaint  );
  
  sub _validate_one_param {
      my ( $value, $params, $spec, $id ) = @_;
  
      # for my $key ( keys %{$spec} ) {
      #     unless ( $Valid{$key} ) {
      #         $options->{on_fail}
      #             ->(qq{"$key" is not an allowed validation spec key});
      #     }
      # }
  
      if ( exists $spec->{type} ) {
          unless ( defined $spec->{type}
              && Scalar::Util::looks_like_number( $spec->{type} )
              && $spec->{type} > 0 ) {
              my $msg
                  = "$id has a type specification which is not a number. It is ";
              if ( defined $spec->{type} ) {
                  $msg .= "a string - $spec->{type}";
              }
              else {
                  $msg .= "undef";
              }
  
              $msg
                  .= ".\n Use the constants exported by Params::Validate to declare types.";
  
              $options->{on_fail}->( sprintf( $msg, _stringify($value) ) );
          }
  
          unless ( _get_type($value) & $spec->{type} ) {
              my $type = _get_type($value);
  
              my @is      = _typemask_to_strings($type);
              my @allowed = _typemask_to_strings( $spec->{type} );
              my $article = $is[0] =~ /^[aeiou]/i ? 'an' : 'a';
  
              my $called = _get_called(1);
  
              $options->{on_fail}->(
                  sprintf(
                      "$id to $called was $article '@is', which "
                          . "is not one of the allowed types: @allowed\n",
                      _stringify($value)
                  )
              );
          }
      }
  
      # short-circuit for common case
      return
          unless ( $spec->{isa}
          || $spec->{can}
          || $spec->{callbacks}
          || $spec->{regex} );
  
      if ( exists $spec->{isa} ) {
          foreach ( ref $spec->{isa} ? @{ $spec->{isa} } : $spec->{isa} ) {
              unless (
                  do {
                      local $@ = q{};
                      eval { $value->isa($_) };
                  }
                  ) {
                  my $is = ref $value ? ref $value : 'plain scalar';
                  my $article1 = $_ =~ /^[aeiou]/i  ? 'an' : 'a';
                  my $article2 = $is =~ /^[aeiou]/i ? 'an' : 'a';
  
                  my $called = _get_called(1);
  
                  $options->{on_fail}->(
                      sprintf(
                                "$id to $called was not $article1 '$_' "
                              . "(it is $article2 $is)\n", _stringify($value)
                      )
                  );
              }
          }
      }
  
      if ( exists $spec->{can} ) {
          foreach ( ref $spec->{can} ? @{ $spec->{can} } : $spec->{can} ) {
              unless (
                  do {
                      local $@ = q{};
                      eval { $value->can($_) };
                  }
                  ) {
                  my $called = _get_called(1);
  
                  $options->{on_fail}->(
                      sprintf(
                          "$id to $called does not have the method: '$_'\n",
                          _stringify($value)
                      )
                  );
              }
          }
      }
  
      if ( $spec->{callbacks} ) {
          unless ( UNIVERSAL::isa( $spec->{callbacks}, 'HASH' ) ) {
              my $called = _get_called(1);
  
              $options->{on_fail}->(
                  "'callbacks' validation parameter for $called must be a hash reference\n"
              );
          }
  
          foreach ( keys %{ $spec->{callbacks} } ) {
              unless ( UNIVERSAL::isa( $spec->{callbacks}{$_}, 'CODE' ) ) {
                  my $called = _get_called(1);
  
                  $options->{on_fail}->(
                      "callback '$_' for $called is not a subroutine reference\n"
                  );
              }
  
              my $ok;
              my $e = do {
                  local $@ = q{};
                  local $SIG{__DIE__};
                  $ok = eval { $spec->{callbacks}{$_}->( $value, $params ) };
                  $@;
              };
  
              if ( !$ok ) {
                  my $called = _get_called(1);
  
                  if ( ref $e ) {
                      $options->{on_fail}->($e);
                  }
                  else {
                      my $msg = "$id to $called did not pass the '$_' callback";
                      $msg .= ": $e" if length $e;
                      $msg .= "\n";
                      $options->{on_fail}->( sprintf( $msg, _stringify($value) ) );
                  }
              }
          }
      }
  
      if ( exists $spec->{regex} ) {
          unless ( ( defined $value ? $value : '' ) =~ /$spec->{regex}/ ) {
              my $called = _get_called(1);
  
              $options->{on_fail}->(
                  sprintf(
                      "$id to $called did not pass regex check\n",
                      _stringify($value)
                  )
              );
          }
      }
  }
  
  {
      # if it UNIVERSAL::isa the string on the left then its the type on
      # the right
      my %isas = (
          'ARRAY'  => ARRAYREF,
          'HASH'   => HASHREF,
          'CODE'   => CODEREF,
          'GLOB'   => GLOBREF,
          'SCALAR' => SCALARREF,
          'REGEXP' => SCALARREF,
      );
      my %simple_refs = map { $_ => 1 } keys %isas;
  
      sub _get_type {
          return UNDEF unless defined $_[0];
  
          my $ref = ref $_[0];
          unless ($ref) {
  
              # catches things like:  my $fh = do { local *FH; };
              return GLOB if UNIVERSAL::isa( \$_[0], 'GLOB' );
              return SCALAR;
          }
  
          return $isas{$ref} if $simple_refs{$ref};
  
          foreach ( keys %isas ) {
              return $isas{$_} | OBJECT if UNIVERSAL::isa( $_[0], $_ );
          }
  
          # I really hope this never happens.
          return UNKNOWN;
      }
  }
  
  {
      my %type_to_string = (
          SCALAR()    => 'scalar',
          ARRAYREF()  => 'arrayref',
          HASHREF()   => 'hashref',
          CODEREF()   => 'coderef',
          GLOB()      => 'glob',
          GLOBREF()   => 'globref',
          SCALARREF() => 'scalarref',
          UNDEF()     => 'undef',
          OBJECT()    => 'object',
          UNKNOWN()   => 'unknown',
      );
  
      sub _typemask_to_strings {
          my $mask = shift;
  
          my @types;
          foreach (
              SCALAR,    ARRAYREF, HASHREF, CODEREF, GLOB, GLOBREF,
              SCALARREF, UNDEF,    OBJECT,  UNKNOWN
              ) {
              push @types, $type_to_string{$_} if $mask & $_;
          }
          return @types ? @types : ('unknown');
      }
  }
  
  {
      my %defaults = (
          ignore_case   => 0,
          strip_leading => 0,
          allow_extra   => 0,
          on_fail       => sub {
              require Carp;
              Carp::croak( $_[0] );
          },
          stack_skip     => 1,
          normalize_keys => undef,
      );
  
      *set_options = \&validation_options;
  
      sub validation_options {
          my %opts = @_;
  
          my $caller = caller;
  
          foreach ( keys %defaults ) {
              $opts{$_} = $defaults{$_} unless exists $opts{$_};
          }
  
          $Params::Validate::OPTIONS{$caller} = \%opts;
      }
  
      sub _get_options {
          my $caller = shift;
  
          if (@_) {
  
              return (
                  $Params::Validate::OPTIONS{$caller}
                  ? {
                      %{ $Params::Validate::OPTIONS{$caller} },
                      @_
                      }
                  : { %defaults, @_ }
              );
          }
          else {
              return (
                  exists $Params::Validate::OPTIONS{$caller}
                  ? $Params::Validate::OPTIONS{$caller}
                  : \%defaults
              );
          }
      }
  }
  
  sub _get_called {
      my $extra_skip = $_[0] || 0;
  
      # always add one more for this sub
      $extra_skip++;
  
      my $called = (
          exists $options->{called}
          ? $options->{called}
          : ( caller( $options->{stack_skip} + $extra_skip ) )[3]
      );
  
      $called = '(unknown)' unless defined $called;
  
      return $called;
  }
  
  sub _stringify {
      return defined $_[0] ? qq{"$_[0]"} : 'undef';
  }
  
  1;
X86_64-LINUX_PARAMS_VALIDATE_PP

$fatpacked{"x86_64-linux/Params/Validate/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PARAMS_VALIDATE_XS';
  package Params::Validate::XS;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.29';
  
  use Carp;
  
  my $default_fail = sub {
      Carp::confess( $_[0] );
  };
  
  {
      my %defaults = (
          ignore_case    => 0,
          strip_leading  => 0,
          allow_extra    => 0,
          on_fail        => $default_fail,
          stack_skip     => 1,
          normalize_keys => undef,
      );
  
      *set_options = \&validation_options;
  
      sub validation_options {
          my %opts = @_;
  
          my $caller = caller;
  
          foreach ( keys %defaults ) {
              $opts{$_} = $defaults{$_} unless exists $opts{$_};
          }
  
          $Params::Validate::OPTIONS{$caller} = \%opts;
      }
  
      use XSLoader;
      XSLoader::load(
          __PACKAGE__,
          exists $Params::Validate::XS::{VERSION}
          ? ${ $Params::Validate::XS::{VERSION} }
          : (),
      );
  }
  
  sub _check_regex_from_xs {
      return ( defined $_[0] ? $_[0] : '' ) =~ /$_[1]/ ? 1 : 0;
  }
  
  1;
X86_64-LINUX_PARAMS_VALIDATE_XS

$fatpacked{"x86_64-linux/Params/ValidatePP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PARAMS_VALIDATEPP';
  package    # hide from PAUSE
      Params::Validate;
  
  our $VERSION = '1.29';
  
  BEGIN { $ENV{PARAMS_VALIDATE_IMPLEMENTATION} = 'PP' }
  use Params::Validate;
  
  1;
X86_64-LINUX_PARAMS_VALIDATEPP

$fatpacked{"x86_64-linux/Params/ValidateXS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PARAMS_VALIDATEXS';
  package # hide from PAUSE
      Params::Validate;
  
  our $VERSION = '1.29';
  
  BEGIN { $ENV{PARAMS_VALIDATE_IMPLEMENTATION} = 'XS' }
  use Params::Validate;
  
  1;
X86_64-LINUX_PARAMS_VALIDATEXS

$fatpacked{"x86_64-linux/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.50";
  $VERSION   = eval $VERSION;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be a dual-valued variable, it is
  actually implemented as a magical variable inside the interpreter:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use L</isweak> or L</weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_SCALAR_UTIL

$fatpacked{"x86_64-linux/Sub/Identify.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SUB_IDENTIFY';
  package Sub::Identify;
  
  use strict;
  use Exporter;
  
  BEGIN {
      our $VERSION = '0.14';
      our @ISA = ('Exporter');
      our %EXPORT_TAGS = (
          all => [
              our @EXPORT_OK = qw(
                  sub_name
                  stash_name
                  sub_fullname
                  get_code_info
                  get_code_location
                  is_sub_constant
              )
          ]
      );
  
      our $IsPurePerl = 1;
      unless ($ENV{PERL_SUB_IDENTIFY_PP}) {
          if (
              eval {
                  require XSLoader;
                  XSLoader::load(__PACKAGE__, $VERSION);
                  1;
              }
          ) {
              $IsPurePerl = 0;
          }
          else {
              die $@ if $@ && $@ !~ /object version|loadable object/;
          }
      }
  
      if ($IsPurePerl) {
          require B;
          *get_code_info = sub ($) {
              my ($coderef) = @_;
              ref $coderef or return;
              my $cv = B::svref_2object($coderef);
              $cv->isa('B::CV') or return;
              # bail out if GV is undefined
              $cv->GV->isa('B::SPECIAL') and return;
  
              return ($cv->GV->STASH->NAME, $cv->GV->NAME);
          };
          *get_code_location = sub ($) {
              my ($coderef) = @_;
              ref $coderef or return;
              my $cv = B::svref_2object($coderef);
              $cv->isa('B::CV') && $cv->START->isa('B::COP')
                  or return;
  
              return ($cv->START->file, $cv->START->line);
          };
      }
      if ($IsPurePerl || $] < 5.016) {
          require B;
          *is_sub_constant = sub ($) {
              my ($coderef) = @_;
              ref $coderef or return 0;
              my $cv = B::svref_2object($coderef);
              $cv->isa('B::CV') or return 0;
              my $p = prototype $coderef;
              defined $p && $p eq "" or return 0;
              return ($cv->CvFLAGS & B::CVf_CONST()) == B::CVf_CONST();
          };
      }
  }
  
  sub stash_name   ($) { (get_code_info($_[0]))[0] }
  sub sub_name     ($) { (get_code_info($_[0]))[1] }
  sub sub_fullname ($) { join '::', get_code_info($_[0]) }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Sub::Identify - Retrieve names of code references
  
  =head1 SYNOPSIS
  
      use Sub::Identify ':all';
      my $subname = sub_name( $some_coderef );
      my $packagename = stash_name( $some_coderef );
      # or, to get all at once...
      my $fully_qualified_name = sub_fullname( $some_coderef );
      defined $subname
          and say "this coderef points to sub $subname in package $packagename";
      my ($file, $line) = get_code_location( $some_coderef );
      $file
          and say "this coderef is defined at line $line in file $file";
      is_sub_constant( $some_coderef )
          and say "this coderef points to a constant subroutine";
  
  =head1 DESCRIPTION
  
  C<Sub::Identify> allows you to retrieve the real name of code references.
  
  It provides six functions, all of them taking a code reference.
  
  C<sub_name> returns the name of the code reference passed as an
  argument (or C<__ANON__> if it's an anonymous code reference),
  C<stash_name> returns its package, and C<sub_fullname> returns the
  concatenation of the two.
  
  C<get_code_info> returns a list of two elements, the package and the
  subroutine name (in case of you want both and are worried by the speed.)
  
  In case of subroutine aliasing, those functions always return the
  original name.
  
  C<get_code_location> returns a two-element list containing the file
  name and the line number where the subroutine has been defined.
  
  C<is_sub_constant> returns a boolean value indicating whether the
  subroutine is a constant or not.
  
  =head2 Pure-Perl version
  
  By default C<Sub::Identify> tries to load an XS implementation of the
  C<get_code_info>, C<get_code_location> and (on perl versions 5.16.0 and later)
  C<is_sub_constant> functions, for speed; if that fails, or if the environment
  variable C<PERL_SUB_IDENTIFY_PP> is defined to a true value, it will fall
  back to a pure perl implementation, that uses perl's introspection mechanism,
  provided by the C<B> module.
  
  =head1 SEE ALSO
  
  L<Sub::Util>, part of the module distribution L<Scalar::List::Utils>
  since version 1.40. Since this will be a core module starting with perl
  5.22.0, it is encouraged to migrate to Sub::Util when possible.
  
  L<Sub::Name>
  
  =head1 SOURCE
  
  A git repository for the sources is at L<https://github.com/rgs/Sub-Identify>.
  
  =head1 LICENSE
  
  (c) Rafael Garcia-Suarez (rgs at consttype dot org) 2005, 2008, 2012, 2014, 2015
  
  This program is free software; you may redistribute it and/or modify it under
  the same terms as Perl itself.
  
  =cut
X86_64-LINUX_SUB_IDENTIFY

$fatpacked{"x86_64-linux/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.50";
  $VERSION   = eval $VERSION;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If a name has been set using L</set_subname>, this name will
  be returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.*?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
X86_64-LINUX_SUB_UTIL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/usr/bin/env perl

use strict;
use warnings;

use Getopt::Long::Descriptive;
use DateTime;
use List::AllUtils qw/max sum/;
use Math::Round qw/round/;
use Term::Vspark qw/show_graph/;

binmode STDOUT, ':encoding(UTF-8)';
    
our $VERSION = '0.006'; # VERSION
# PODNAME: git-spark

my ($option, $usage) = describe_options(
    'usage: git vspark %o [AUTHOR]',
    ['hours|o=i'      => 'Commits from the last x hours'],
    ['days|d=i'       => 'Commits from the last x days'],
    ['weeks|w=i'      => 'Commits from the last x weeks'],
    ['months|m=i'     => 'Commits from the last x months'],
    ['years|y=i'      => 'Commits from the last x years'],
    ['scale|s=i'      => 'Set the max value of the graph. Use this option to compare this graph with other graphs.'],
    ['help|h'         => 'Show this message'],
);

my $author = $ARGV[0] || $ENV{USER};
my $scale  = $option->scale || 0;

print($usage), exit 0 if $option->help;
print($usage), exit 0 
    if (!$option->hours  && 
        !$option->days   && 
        !$option->weeks  && 
        !$option->months && 
        !$option->years);

foreach my $key (qw/hours days weeks months years/) {
    vspark($option->$key, $key, $author, $scale) if $option->$key;
}

sub vspark {
    my ($value, $units, $author, $scale) = @_;

    my @commits = countCommits(@_);
    my $total   = sum @commits;
    my $avg     = round($total / scalar @commits);
    my $max     = max @commits;

    print "Commits by $author over the last $value $units\n";
    print "total: $total   avg: $avg   max: $max\n";
    print STDOUT show_graph(
        max      => $scale ? $scale : $max,
        columns  => 20,
        values   => \@commits,
        labels   => \@commits,
    );
}

sub countCommits {
    my ($value, $units, $author) = @_;

    my @commits;
    foreach my $i (0..($value - 1)) {
        my $cmd = "git log " .
                  "--author=${author} " .
                  "--before='${i} ${units}' " . 
                  "--after='" . ($i + 1) . " ${units}' " .
                  "--format=oneline | wc -l";
        my $count = `$cmd`;
        chomp($count);
        push @commits, $count;
    }

    return @commits;
}

__END__

=pod

=encoding utf-8

=head1 NAME

git-spark

=head1 AUTHOR

Eric Johnson <cpan at iijo dot nospamthanks dot org>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2013 by Eric Johnson.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut
