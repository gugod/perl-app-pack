#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Dist/CheckConflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIST_CHECKCONFLICTS';
  package Dist::CheckConflicts;
  BEGIN {
    $Dist::CheckConflicts::AUTHORITY = 'cpan:DOY';
  }
  $Dist::CheckConflicts::VERSION = '0.11';
  use strict;
  use warnings;
  use 5.006;
  # ABSTRACT: declare version conflicts for your dist
  
  use base 'Exporter';
  our @EXPORT = our @EXPORT_OK = (
      qw(conflicts check_conflicts calculate_conflicts dist)
  );
  
  use Carp;
  use Module::Runtime 0.009 'module_notional_filename', 'require_module';
  
  
  my %CONFLICTS;
  my %HAS_CONFLICTS;
  my %DISTS;
  
  sub import {
      my $pkg = shift;
      my $for = caller;
  
      my ($conflicts, $alsos, $dist);
      ($conflicts, @_) = _strip_opt('-conflicts' => @_);
      ($alsos, @_)     = _strip_opt('-also' => @_);
      ($dist, @_)      = _strip_opt('-dist' => @_);
  
      my %conflicts = %{ $conflicts || {} };
      for my $also (@{ $alsos || [] }) {
          eval { require_module($also) } or next;
          if (!exists $CONFLICTS{$also}) {
              $also .= '::Conflicts';
              eval { require_module($also) } or next;
          }
          if (!exists $CONFLICTS{$also}) {
              next;
          }
          my %also_confs = $also->conflicts;
          for my $also_conf (keys %also_confs) {
              $conflicts{$also_conf} = $also_confs{$also_conf}
                  if !exists $conflicts{$also_conf}
                  || $conflicts{$also_conf} lt $also_confs{$also_conf};
          }
      }
  
      $CONFLICTS{$for} = \%conflicts;
      $DISTS{$for}     = $dist || $for;
  
      if (grep { $_ eq ':runtime' } @_) {
          for my $conflict (keys %conflicts) {
              $HAS_CONFLICTS{$conflict} ||= [];
              push @{ $HAS_CONFLICTS{$conflict} }, $for;
          }
  
          # warn for already loaded things...
          for my $conflict (keys %conflicts) {
              if (exists $INC{module_notional_filename($conflict)}) {
                  _check_version([$for], $conflict);
              }
          }
  
          # and warn for subsequently loaded things...
          @INC = grep {
              !(ref($_) eq 'ARRAY' && @$_ > 1 && $_->[1] == \%CONFLICTS)
          } @INC;
          unshift @INC, [
              sub {
                  my ($sub, $file) = @_;
  
                  (my $mod = $file) =~ s{\.pm$}{};
                  $mod =~ s{/}{::}g;
                  return unless $mod =~ /[\w:]+/;
  
                  return unless defined $HAS_CONFLICTS{$mod};
  
                  {
                      local $HAS_CONFLICTS{$mod};
                      require $file;
                  }
  
                  _check_version($HAS_CONFLICTS{$mod}, $mod);
  
                  # the previous require already handled it
                  my $called;
                  return sub {
                      return 0 if $called;
                      $_ = "1;";
                      $called = 1;
                      return 1;
                  };
              },
              \%CONFLICTS, # arbitrary but unique, see above
          ];
      }
  
      $pkg->export_to_level(1, @_);
  }
  
  sub _strip_opt {
      my ($opt, @args) = @_;
  
      my $val;
      for my $idx ( 0 .. $#args - 1 ) {
          if (defined $args[$idx] && $args[$idx] eq $opt) {
              $val = (splice @args, $idx, 2)[1];
              last;
          }
      }
  
      return ( $val, @args );
  }
  
  sub _check_version {
      my ($fors, $mod) = @_;
  
      for my $for (@$fors) {
          my $conflict_ver = $CONFLICTS{$for}{$mod};
          my $version = do {
              no strict 'refs';
              ${ ${ $mod . '::' }{VERSION} };
          };
  
          if ($version le $conflict_ver) {
              warn <<EOF;
  Conflict detected for $DISTS{$for}:
    $mod is version $version, but must be greater than version $conflict_ver
  EOF
              return;
          }
      }
  }
  
  
  sub conflicts {
      my $package = shift;
      return %{ $CONFLICTS{ $package } };
  }
  
  
  sub dist {
      my $package = shift;
      return $DISTS{ $package };
  }
  
  
  sub check_conflicts {
      my $package = shift;
      my $dist = $package->dist;
      my @conflicts = $package->calculate_conflicts;
      return unless @conflicts;
  
      my $err = "Conflicts detected for $dist:\n";
      for my $conflict (@conflicts) {
          $err .= "  $conflict->{package} is version "
                  . "$conflict->{installed}, but must be greater than version "
                  . "$conflict->{required}\n";
      }
      die $err;
  }
  
  
  sub calculate_conflicts {
      my $package = shift;
      my %conflicts = $package->conflicts;
  
      my @ret;
  
  
      CONFLICT:
      for my $conflict (keys %conflicts) {
          my $success = do {
              local $SIG{__WARN__} = sub {};
              eval { require_module($conflict) };
          };
          my $error = $@;
          my $file = module_notional_filename($conflict);
          next if not $success and $error =~ /Can't locate \Q$file\E in \@INC/;
  
          warn "Warning: $conflict did not compile" if not $success;
          my $installed = $success ? $conflict->VERSION : 'unknown';
          push @ret, {
              package   => $conflict,
              installed => $installed,
              required  => $conflicts{$conflict},
          } if not $success or $installed le $conflicts{$conflict};
      }
  
      return sort { $a->{package} cmp $b->{package} } @ret;
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dist::CheckConflicts - declare version conflicts for your dist
  
  =head1 VERSION
  
  version 0.11
  
  =head1 SYNOPSIS
  
      use Dist::CheckConflicts
          -dist => 'Class-MOP',
          -conflicts => {
              'Moose'                => '1.14',
              'namespace::autoclean' => '0.08',
          },
          -also => [
              'Package::Stash::Conflicts',
          ];
  
      __PACKAGE__->check_conflicts;
  
  =head1 DESCRIPTION
  
  One shortcoming of the CPAN clients that currently exist is that they have no
  way of specifying conflicting downstream dependencies of modules. This module
  attempts to work around this issue by allowing you to specify conflicting
  versions of modules separately, and deal with them after the module is done
  installing.
  
  For instance, say you have a module C<Foo>, and some other module C<Bar> uses
  C<Foo>. If C<Foo> were to change its API in a non-backwards-compatible way,
  this would cause C<Bar> to break until it is updated to use the new API. C<Foo>
  can't just depend on the fixed version of C<Bar>, because this will cause a
  circular dependency (because C<Bar> is already depending on C<Foo>), and this
  doesn't express intent properly anyway - C<Foo> doesn't use C<Bar> at all. The
  ideal solution would be for there to be a way to specify conflicting versions
  of modules in a way that would let CPAN clients update conflicting modules
  automatically after an existing module is upgraded, but until that happens,
  this module will allow users to do this manually.
  
  This module accepts a hash of options passed to its C<use> statement, with
  these keys being valid:
  
  =over 4
  
  =item -conflicts
  
  A hashref of conflict specifications, where keys are module names, and values
  are the last broken version - any version greater than the specified version
  should work.
  
  =item -also
  
  Additional modules to get conflicts from (potentially recursively). This should
  generally be a list of modules which use Dist::CheckConflicts, which correspond
  to the dists that your dist depends on. (In an ideal world, this would be
  intuited directly from your dependency list, but the dependency list isn't
  available outside of build time).
  
  =item -dist
  
  The name of the distribution, to make the error message from check_conflicts
  more user-friendly.
  
  =back
  
  The methods listed below are exported by this module into the module that uses
  it, so you should call these methods on your module, not Dist::CheckConflicts.
  
  As an example, this command line can be used to update your modules, after
  installing the C<Foo> dist (assuming that C<Foo::Conflicts> is the module in
  the C<Foo> dist which uses Dist::CheckConflicts):
  
      perl -MFoo::Conflicts -e'print "$_\n"
          for map { $_->{package} } Foo::Conflicts->calculate_conflicts' | cpanm
  
  As an added bonus, loading your conflicts module will provide warnings at
  runtime if conflicting modules are detected (regardless of whether they are
  loaded before or afterwards).
  
  =head1 METHODS
  
  =head2 conflicts
  
  Returns the conflict specification (the C<-conflicts> parameter to
  C<import()>), as a hash.
  
  =head2 dist
  
  Returns the dist name (either as specified by the C<-dist> parameter to
  C<import()>, or the package name which C<use>d this module).
  
  =head2 check_conflicts
  
  Examine the modules that are currently installed, and throw an exception with
  useful information if any modules are at versions which conflict with the dist.
  
  =head2 calculate_conflicts
  
  Examine the modules that are currently installed, and return a list of modules
  which conflict with the dist. The modules will be returned as a list of
  hashrefs, each containing C<package>, C<installed>, and C<required> keys.
  
  =head1 BUGS
  
  No known bugs.
  
  Please report any bugs to GitHub Issues at
  L<https://github.com/doy/dist-checkconflicts/issues>.
  
  =head1 SEE ALSO
  
  L<Module::Install::CheckConflicts>
  
  L<Dist::Zilla::Plugin::Conflicts>
  
  =head1 SUPPORT
  
  You can find this documentation for this module with the perldoc command.
  
      perldoc Dist::CheckConflicts
  
  You can also look for information at:
  
  =over 4
  
  =item * MetaCPAN
  
  L<https://metacpan.org/release/Dist-CheckConflicts>
  
  =item * Github
  
  L<https://github.com/doy/dist-checkconflicts>
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Dist-CheckConflicts>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Dist-CheckConflicts>
  
  =back
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy@tozt.net>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DIST_CHECKCONFLICTS

$fatpacked{"Module/Implementation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_IMPLEMENTATION';
  package Module::Implementation;
  # git description: v0.08-2-gd599347
  $Module::Implementation::VERSION = '0.09';
  
  use strict;
  use warnings;
  
  use Module::Runtime 0.012 qw( require_module );
  use Try::Tiny;
  
  # This is needed for the benefit of Test::CleanNamespaces, which in turn loads
  # Package::Stash, which in turn loads this module and expects a minimum
  # version.
  unless ( exists $Module::Implementation::{VERSION}
      && ${ $Module::Implementation::{VERSION} } ) {
  
      $Module::Implementation::{VERSION} = \42;
  }
  
  my %Implementation;
  
  sub build_loader_sub {
      my $caller = caller();
  
      return _build_loader( $caller, @_ );
  }
  
  sub _build_loader {
      my $package = shift;
      my %args    = @_;
  
      my @implementations = @{ $args{implementations} };
      my @symbols = @{ $args{symbols} || [] };
  
      my $implementation;
      my $env_var = uc $package;
      $env_var =~ s/::/_/g;
      $env_var .= '_IMPLEMENTATION';
  
      return sub {
          my ( $implementation, $loaded ) = _load_implementation(
              $package,
              $ENV{$env_var},
              \@implementations,
          );
  
          $Implementation{$package} = $implementation;
  
          _copy_symbols( $loaded, $package, \@symbols );
  
          return $loaded;
      };
  }
  
  sub implementation_for {
      my $package = shift;
  
      return $Implementation{$package};
  }
  
  sub _load_implementation {
      my $package         = shift;
      my $env_value       = shift;
      my $implementations = shift;
  
      if ($env_value) {
          die "$env_value is not a valid implementation for $package"
              unless grep { $_ eq $env_value } @{$implementations};
  
          my $requested = "${package}::$env_value";
  
          # Values from the %ENV hash are tainted. We know it's safe to untaint
          # this value because the value was one of our known implementations.
          ($requested) = $requested =~ /^(.+)$/;
  
          try {
              require_module($requested);
          }
          catch {
              require Carp;
              Carp::croak("Could not load $requested: $_");
          };
  
          return ( $env_value, $requested );
      }
      else {
          my $err;
          for my $possible ( @{$implementations} ) {
              my $try = "${package}::$possible";
  
              my $ok;
              try {
                  require_module($try);
                  $ok = 1;
              }
              catch {
                  $err .= $_ if defined $_;
              };
  
              return ( $possible, $try ) if $ok;
          }
  
          require Carp;
          if ( defined $err && length $err ) {
              Carp::croak(
                  "Could not find a suitable $package implementation: $err");
          }
          else {
              Carp::croak(
                  'Module::Runtime failed to load a module but did not throw a real error. This should never happen. Something is very broken'
              );
          }
      }
  }
  
  sub _copy_symbols {
      my $from_package = shift;
      my $to_package   = shift;
      my $symbols      = shift;
  
      for my $sym ( @{$symbols} ) {
          my $type = $sym =~ s/^([\$\@\%\&\*])// ? $1 : '&';
  
          my $from = "${from_package}::$sym";
          my $to   = "${to_package}::$sym";
  
          {
              no strict 'refs';
              no warnings 'once';
  
              # Copied from Exporter
              *{$to}
                  = $type eq '&' ? \&{$from}
                  : $type eq '$' ? \${$from}
                  : $type eq '@' ? \@{$from}
                  : $type eq '%' ? \%{$from}
                  : $type eq '*' ? *{$from}
                  : die
                  "Can't copy symbol from $from_package to $to_package: $type$sym";
          }
      }
  }
  
  1;
  
  # ABSTRACT: Loads one of several alternate underlying implementations for a module
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Module::Implementation - Loads one of several alternate underlying implementations for a module
  
  =head1 VERSION
  
  version 0.09
  
  =head1 SYNOPSIS
  
    package Foo::Bar;
  
    use Module::Implementation;
  
    BEGIN {
        my $loader = Module::Implementation::build_loader_sub(
            implementations => [ 'XS',  'PurePerl' ],
            symbols         => [ 'run', 'check' ],
        );
  
        $loader->();
    }
  
    package Consumer;
  
    # loads the first viable implementation
    use Foo::Bar;
  
  =head1 DESCRIPTION
  
  This module abstracts out the process of choosing one of several underlying
  implementations for a module. This can be used to provide XS and pure Perl
  implementations of a module, or it could be used to load an implementation for
  a given OS or any other case of needing to provide multiple implementations.
  
  This module is only useful when you know all the implementations ahead of
  time. If you want to load arbitrary implementations then you probably want
  something like a plugin system, not this module.
  
  =head1 API
  
  This module provides two subroutines, neither of which are exported.
  
  =head2 Module::Implementation::build_loader_sub(...)
  
  This subroutine takes the following arguments.
  
  =over 4
  
  =item * implementations
  
  This should be an array reference of implementation names. Each name should
  correspond to a module in the caller's namespace.
  
  In other words, using the example in the L</SYNOPSIS>, this module will look
  for the C<Foo::Bar::XS> and C<Foo::Bar::PurePerl> modules.
  
  This argument is required.
  
  =item * symbols
  
  A list of symbols to copy from the implementation package to the calling
  package.
  
  These can be prefixed with a variable type: C<$>, C<@>, C<%>, C<&>, or
  C<*)>. If no prefix is given, the symbol is assumed to be a subroutine.
  
  This argument is optional.
  
  =back
  
  This subroutine I<returns> the implementation loader as a sub reference.
  
  It is up to you to call this loader sub in your code.
  
  I recommend that you I<do not> call this loader in an C<import()> sub. If a
  caller explicitly requests no imports, your C<import()> sub will not be run at
  all, which can cause weird breakage.
  
  =head2 Module::Implementation::implementation_for($package)
  
  Given a package name, this subroutine returns the implementation that was
  loaded for the package. This is not a full package name, just the suffix that
  identifies the implementation. For the L</SYNOPSIS> example, this subroutine
  would be called as C<Module::Implementation::implementation_for('Foo::Bar')>,
  and it would return "XS" or "PurePerl".
  
  =head1 HOW THE IMPLEMENTATION LOADER WORKS
  
  The implementation loader works like this ...
  
  First, it checks for an C<%ENV> var specifying the implementation to load. The
  env var is based on the package name which loads the implementations. The
  C<::> package separator is replaced with C<_>, and made entirely
  upper-case. Finally, we append "_IMPLEMENTATION" to this name.
  
  So in our L</SYNOPSIS> example, the corresponding C<%ENV> key would be
  C<FOO_BAR_IMPLEMENTATION>.
  
  If this is set, then the loader will B<only> try to load this one
  implementation.
  
  If the env var requests an implementation which doesn't match one of the
  implementations specified when the loader was created, an error is thrown.
  
  If this one implementation fails to load then loader throws an error. This is
  useful for testing. You can request a specific implementation in a test file
  by writing something like this:
  
    BEGIN { $ENV{FOO_BAR_IMPLEMENTATION} = 'XS' }
    use Foo::Bar;
  
  If the environment variable is I<not> set, then the loader simply tries the
  implementations originally passed to C<Module::Implementation>. The
  implementations are tried in the order in which they were originally passed.
  
  The loader will use the first implementation that loads without an error. It
  will copy any requested symbols from this implementation.
  
  If none of the implementations can be loaded, then the loader throws an
  exception.
  
  The loader returns the name of the package it loaded.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
MODULE_IMPLEMENTATION

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  =head1 NAME
  
  Module::Runtime - runtime module handling
  
  =head1 SYNOPSIS
  
      use Module::Runtime qw(
  	$module_name_rx is_module_name check_module_name
  	module_notional_filename require_module);
  
      if($module_name =~ /\A$module_name_rx\z/o) { ...
      if(is_module_name($module_name)) { ...
      check_module_name($module_name);
  
      $notional_filename = module_notional_filename($module_name);
      require_module($module_name);
  
      use Module::Runtime qw(use_module use_package_optimistically);
  
      $bi = use_module("Math::BigInt", 1.31)->new("1_234");
      $widget = use_package_optimistically("Local::Widget")->new;
  
      use Module::Runtime qw(
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec check_module_spec
  	compose_module_name);
  
      if($spec =~ /\A$top_module_spec_rx\z/o) { ...
      if($spec =~ /\A$sub_module_spec_rx\z/o) { ...
      if(is_module_spec("Standard::Prefix", $spec)) { ...
      check_module_spec("Standard::Prefix", $spec);
  
      $module_name = compose_module_name("Standard::Prefix", $spec);
  
  =head1 DESCRIPTION
  
  The functions exported by this module deal with runtime handling of
  Perl modules, which are normally handled at compile time.  This module
  avoids using any other modules, so that it can be used in low-level
  infrastructure.
  
  The parts of this module that work with module names apply the same syntax
  that is used for barewords in Perl source.  In principle this syntax
  can vary between versions of Perl, and this module applies the syntax of
  the Perl on which it is running.  In practice the usable syntax hasn't
  changed yet.  There's some intent for Unicode module names to be supported
  in the future, but this hasn't yet amounted to any consistent facility.
  
  The functions of this module whose purpose is to load modules include
  workarounds for three old Perl core bugs regarding C<require>.  These
  workarounds are applied on any Perl version where the bugs exist, except
  for a case where one of the bugs cannot be adequately worked around in
  pure Perl.
  
  =head2 Module name syntax
  
  The usable module name syntax has not changed from Perl 5.000 up to
  Perl 5.19.8.  The syntax is composed entirely of ASCII characters.
  From Perl 5.6 onwards there has been some attempt to allow the use of
  non-ASCII Unicode characters in Perl source, but it was fundamentally
  broken (like the entirety of Perl 5.6's Unicode handling) and remained
  pretty much entirely unusable until it got some attention in the Perl
  5.15 series.  Although Unicode is now consistently accepted by the
  parser in some places, it remains broken for module names.  Furthermore,
  there has not yet been any work on how to map Unicode module names into
  filenames, so in that respect also Unicode module names are unusable.
  
  The module name syntax is, precisely: the string must consist of one or
  more segments separated by C<::>; each segment must consist of one or more
  identifier characters (ASCII alphanumerics plus "_"); the first character
  of the string must not be a digit.  Thus "C<IO::File>", "C<warnings>",
  and "C<foo::123::x_0>" are all valid module names, whereas "C<IO::>"
  and "C<1foo::bar>" are not.  C<'> separators are not permitted by this
  module, though they remain usable in Perl source, being translated to
  C<::> in the parser.
  
  =head2 Core bugs worked around
  
  The first bug worked around is core bug [perl #68590], which causes
  lexical state in one file to leak into another that is C<require>d/C<use>d
  from it.  This bug is present from Perl 5.6 up to Perl 5.10, and is
  fixed in Perl 5.11.0.  From Perl 5.9.4 up to Perl 5.10.0 no satisfactory
  workaround is possible in pure Perl.  The workaround means that modules
  loaded via this module don't suffer this pollution of their lexical
  state.  Modules loaded in other ways, or via this module on the Perl
  versions where the pure Perl workaround is impossible, remain vulnerable.
  The module L<Lexical::SealRequireHints> provides a complete workaround
  for this bug.
  
  The second bug worked around causes some kinds of failure in module
  loading, principally compilation errors in the loaded module, to be
  recorded in C<%INC> as if they were successful, so later attempts to load
  the same module immediately indicate success.  This bug is present up
  to Perl 5.8.9, and is fixed in Perl 5.9.0.  The workaround means that a
  compilation error in a module loaded via this module won't be cached as
  a success.  Modules loaded in other ways remain liable to produce bogus
  C<%INC> entries, and if a bogus entry exists then it will mislead this
  module if it is used to re-attempt loading.
  
  The third bug worked around causes the wrong context to be seen at
  file scope of a loaded module, if C<require> is invoked in a location
  that inherits context from a higher scope.  This bug is present up to
  Perl 5.11.2, and is fixed in Perl 5.11.3.  The workaround means that
  a module loaded via this module will always see the correct context.
  Modules loaded in other ways remain vulnerable.
  
  =cut
  
  package Module::Runtime;
  
  # Don't "use 5.006" here, because Perl 5.15.6 will load feature.pm if
  # the version check is done that way.
  BEGIN { require 5.006; }
  # Don't "use warnings" here, to avoid dependencies.  Do standardise the
  # warning status by lexical override; unfortunately the only safe bitset
  # to build in is the empty set, equivalent to "no warnings".
  BEGIN { ${^WARNING_BITS} = ""; }
  # Don't "use strict" here, to avoid dependencies.
  
  our $VERSION = "0.016";
  
  # Don't use Exporter here, to avoid dependencies.
  our @EXPORT_OK = qw(
  	$module_name_rx is_module_name is_valid_module_name check_module_name
  	module_notional_filename require_module
  	use_module use_package_optimistically
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec is_valid_module_spec check_module_spec
  	compose_module_name
  );
  my %export_ok = map { ($_ => undef) } @EXPORT_OK;
  sub import {
  	my $me = shift;
  	my $callpkg = caller(0);
  	my $errs = "";
  	foreach(@_) {
  		if(exists $export_ok{$_}) {
  			# We would need to do "no strict 'refs'" here
  			# if we had enabled strict at file scope.
  			if(/\A\$(.*)\z/s) {
  				*{$callpkg."::".$1} = \$$1;
  			} else {
  				*{$callpkg."::".$_} = \&$_;
  			}
  		} else {
  			$errs .= "\"$_\" is not exported by the $me module\n";
  		}
  	}
  	if($errs ne "") {
  		die "${errs}Can't continue after import errors ".
  			"at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n";
  	}
  }
  
  # Logic duplicated from Params::Classify.  Duplicating it here avoids
  # an extensive and potentially circular dependency graph.
  sub _is_string($) {
  	my($arg) = @_;
  	return defined($arg) && ref(\$arg) eq "SCALAR";
  }
  
  =head1 REGULAR EXPRESSIONS
  
  These regular expressions do not include any anchors, so to check
  whether an entire string matches a syntax item you must supply the
  anchors yourself.
  
  =over
  
  =item $module_name_rx
  
  Matches a valid Perl module name in bareword syntax.
  
  =cut
  
  our $module_name_rx = qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;
  
  =item $top_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where no prefix is being used.
  
  =cut
  
  my $qual_module_spec_rx =
  	qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  my $unqual_top_module_spec_rx =
  	qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $top_module_spec_rx = qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;
  
  =item $sub_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where a prefix is being used.
  
  =cut
  
  my $unqual_sub_module_spec_rx = qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $sub_module_spec_rx = qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 Basic module handling
  
  =over
  
  =item is_module_name(ARG)
  
  Returns a truth value indicating whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  
  =cut
  
  sub is_module_name($) { _is_string($_[0]) && $_[0] =~ /\A$module_name_rx\z/o }
  
  =item is_valid_module_name(ARG)
  
  Deprecated alias for L</is_module_name>.
  
  =cut
  
  *is_valid_module_name = \&is_module_name;
  
  =item check_module_name(ARG)
  
  Check whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_name($) {
  	unless(&is_module_name) {
  		die +(_is_string($_[0]) ? "`$_[0]'" : "argument").
  			" is not a module name\n";
  	}
  }
  
  =item module_notional_filename(NAME)
  
  Generates a notional relative filename for a module, which is used in
  some Perl core interfaces.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The notional filename for the named module is generated and returned.
  This filename is always in Unix style, with C</> directory separators
  and a C<.pm> suffix.  This kind of filename can be used as an argument to
  C<require>, and is the key that appears in C<%INC> to identify a module,
  regardless of actual local filename syntax.
  
  =cut
  
  sub module_notional_filename($) {
  	&check_module_name;
  	my($name) = @_;
  	$name =~ s!::!/!g;
  	return $name.".pm";
  }
  
  =item require_module(NAME)
  
  This is essentially the bareword form of C<require>, in runtime form.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The module specified by I<NAME> is loaded, if it hasn't been already,
  in the manner of the bareword form of C<require>.  That means that a
  search through C<@INC> is performed, and a byte-compiled form of the
  module will be used if available.
  
  The return value is as for C<require>.  That is, it is the value returned
  by the module itself if the module is loaded anew, or C<1> if the module
  was already loaded.
  
  =cut
  
  # Don't "use constant" here, to avoid dependencies.
  BEGIN {
  	*_WORK_AROUND_HINT_LEAKAGE =
  		"$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
  			? sub(){1} : sub(){0};
  	*_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
  }
  
  BEGIN { if(_WORK_AROUND_BROKEN_MODULE_STATE) { eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  }; die $@ if $@ ne ""; } }
  
  sub require_module($) {
  	# Localise %^H to work around [perl #68590], where the bug exists
  	# and this is a satisfactory workaround.  The bug consists of
  	# %^H state leaking into each required module, polluting the
  	# module's lexical state.
  	local %^H if _WORK_AROUND_HINT_LEAKAGE;
  	if(_WORK_AROUND_BROKEN_MODULE_STATE) {
  		my $notional_filename = &module_notional_filename;
  		my $guard = bless([ $notional_filename ],
  				"Module::Runtime::__GUARD__");
  		my $result = CORE::require($notional_filename);
  		pop @$guard;
  		return $result;
  	} else {
  		return scalar(CORE::require(&module_notional_filename));
  	}
  }
  
  =back
  
  =head2 Structured module use
  
  =over
  
  =item use_module(NAME[, VERSION])
  
  This is essentially C<use> in runtime form, but without the importing
  feature (which is fundamentally a compile-time thing).  The I<NAME> is
  handled just like in C<require_module> above: it must be a module name,
  and the named module is loaded as if by the bareword form of C<require>.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded module is
  called with the specified I<VERSION> as an argument.  This normally serves to
  ensure that the version loaded is at least the version required.  This is
  the same functionality provided by the I<VERSION> parameter of C<use>.
  
  On success, the name of the module is returned.  This is unlike
  L</require_module>, and is done so that the entire call to L</use_module>
  can be used as a class name to call a constructor, as in the example in
  the synopsis.
  
  =cut
  
  sub use_module($;$) {
  	my($name, $version) = @_;
  	require_module($name);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =item use_package_optimistically(NAME[, VERSION])
  
  This is an analogue of L</use_module> for the situation where there is
  uncertainty as to whether a package/class is defined in its own module
  or by some other means.  It attempts to arrange for the named package to
  be available, either by loading a module or by doing nothing and hoping.
  
  An attempt is made to load the named module (as if by the bareword form
  of C<require>).  If the module cannot be found then it is assumed that
  the package was actually already loaded by other means, and no error
  is signalled.  That's the optimistic bit.
  
  I<Warning:> this optional module loading is liable to cause unreliable
  behaviour, including security problems.  It interacts especially badly
  with having C<.> in C<@INC>, which was the default state of affairs in
  Perls prior to 5.25.11.  If a package is actually defined by some means
  other than a module, then applying this function to it causes a spurious
  attempt to load a module that is expected to be non-existent.  If a
  module actually exists under that name then it will be unintentionally
  loaded.  If C<.> is in C<@INC> and this code is ever run with the current
  directory being one writable by a malicious user (such as F</tmp>), then
  the malicious user can easily cause the victim to run arbitrary code, by
  creating a module file under the predictable spuriously-loaded name in the
  writable directory.  Generally, optional module loading should be avoided.
  
  This is mostly the same operation that is performed by the L<base> pragma
  to ensure that the specified base classes are available.  The behaviour
  of L<base> was simplified in version 2.18, and later improved in version
  2.20, and on both occasions this function changed to match.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded package is
  called with the specified I<VERSION> as an argument.  This normally serves
  to ensure that the version loaded is at least the version required.
  On success, the name of the package is returned.  These aspects of the
  function work just like L</use_module>.
  
  =cut
  
  sub use_package_optimistically($;$) {
  	my($name, $version) = @_;
  	my $fn = module_notional_filename($name);
  	eval { local $SIG{__DIE__}; require_module($name); };
  	die $@ if $@ ne "" &&
  		($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s ||
  		 $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =back
  
  =head2 Module name composition
  
  =over
  
  =item is_module_spec(PREFIX, SPEC)
  
  Returns a truth value indicating
  whether I<SPEC> is valid input for L</compose_module_name>.
  See below for what that entails.  Whether a I<PREFIX> is supplied affects
  the validity of I<SPEC>, but the exact value of the prefix is unimportant,
  so this function treats I<PREFIX> as a truth value.
  
  =cut
  
  sub is_module_spec($$) {
  	my($prefix, $spec) = @_;
  	return _is_string($spec) &&
  		$spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o :
  				    qr/\A$top_module_spec_rx\z/o);
  }
  
  =item is_valid_module_spec(PREFIX, SPEC)
  
  Deprecated alias for L</is_module_spec>.
  
  =cut
  
  *is_valid_module_spec = \&is_module_spec;
  
  =item check_module_spec(PREFIX, SPEC)
  
  Check whether I<SPEC> is valid input for L</compose_module_name>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_spec($$) {
  	unless(&is_module_spec) {
  		die +(_is_string($_[1]) ? "`$_[1]'" : "argument").
  			" is not a module specification\n";
  	}
  }
  
  =item compose_module_name(PREFIX, SPEC)
  
  This function is intended to make it more convenient for a user to specify
  a Perl module name at runtime.  Users have greater need for abbreviations
  and context-sensitivity than programmers, and Perl module names get a
  little unwieldy.  I<SPEC> is what the user specifies, and this function
  translates it into a module name in standard form, which it returns.
  
  I<SPEC> has syntax approximately that of a standard module name: it
  should consist of one or more name segments, each of which consists
  of one or more identifier characters.  However, C</> is permitted as a
  separator, in addition to the standard C<::>.  The two separators are
  entirely interchangeable.
  
  Additionally, if I<PREFIX> is not C<undef> then it must be a module
  name in standard form, and it is prefixed to the user-specified name.
  The user can inhibit the prefix addition by starting I<SPEC> with a
  separator (either C</> or C<::>).
  
  =cut
  
  sub compose_module_name($$) {
  	my($prefix, $spec) = @_;
  	check_module_name($prefix) if defined $prefix;
  	&check_module_spec;
  	if($spec =~ s#\A(?:/|::)##) {
  		# OK
  	} else {
  		$spec = $prefix."::".$spec if defined $prefix;
  	}
  	$spec =~ s#/#::#g;
  	return $spec;
  }
  
  =back
  
  =head1 BUGS
  
  On Perl versions 5.7.2 to 5.8.8, if C<require> is overridden by the
  C<CORE::GLOBAL> mechanism, it is likely to break the heuristics used by
  L</use_package_optimistically>, making it signal an error for a missing
  module rather than assume that it was already loaded.  From Perl 5.8.9
  onwards, and on 5.7.1 and earlier, this module can avoid being confused
  by such an override.  On the affected versions, a C<require> override
  might be installed by L<Lexical::SealRequireHints>, if something requires
  its bugfix but for some reason its XS implementation isn't available.
  
  =head1 SEE ALSO
  
  L<Lexical::SealRequireHints>,
  L<base>,
  L<perlfunc/require>,
  L<perlfunc/use>
  
  =head1 AUTHOR
  
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2004, 2006, 2007, 2009, 2010, 2011, 2012, 2014, 2017
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
MODULE_RUNTIME

$fatpacked{"Package/Stash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH';
  package Package::Stash;
  BEGIN {
    $Package::Stash::AUTHORITY = 'cpan:DOY';
  }
  $Package::Stash::VERSION = '0.37';
  use strict;
  use warnings;
  use 5.008001;
  # ABSTRACT: routines for manipulating stashes
  
  our $IMPLEMENTATION;
  
  use Module::Implementation 0.06;
  
  BEGIN {
      local $ENV{PACKAGE_STASH_IMPLEMENTATION} = $IMPLEMENTATION
        if ( $IMPLEMENTATION and not $ENV{PACKAGE_STASH_IMPLEMENTATION} );
  
      Module::Implementation::build_loader_sub(
          implementations => [ 'XS', 'PP' ],
          symbols         => [qw(
              new
              name
              namespace
              add_symbol
              remove_glob
              has_symbol
              get_symbol
              get_or_add_symbol
              remove_symbol
              list_all_symbols
              get_all_symbols
          )],
      )->();
      $IMPLEMENTATION = Module::Implementation::implementation_for(__PACKAGE__);
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Package::Stash - routines for manipulating stashes
  
  =head1 VERSION
  
  version 0.37
  
  =head1 SYNOPSIS
  
    my $stash = Package::Stash->new('Foo');
    $stash->add_symbol('%foo', {bar => 1});
    # $Foo::foo{bar} == 1
    $stash->has_symbol('$foo') # false
    my $namespace = $stash->namespace;
    *{ $namespace->{foo} }{HASH} # {bar => 1}
  
  =head1 DESCRIPTION
  
  Manipulating stashes (Perl's symbol tables) is occasionally necessary, but
  incredibly messy, and easy to get wrong. This module hides all of that behind a
  simple API.
  
  NOTE: Most methods in this class require a variable specification that includes
  a sigil. If this sigil is absent, it is assumed to represent the IO slot.
  
  Due to limitations in the typeglob API available to perl code, and to typeglob
  manipulation in perl being quite slow, this module provides two
  implementations - one in pure perl, and one using XS. The XS implementation is
  to be preferred for most usages; the pure perl one is provided for cases where
  XS modules are not a possibility. The current implementation in use can be set
  by setting C<$ENV{PACKAGE_STASH_IMPLEMENTATION}> or
  C<$Package::Stash::IMPLEMENTATION> before loading Package::Stash (with the
  environment variable taking precedence), otherwise, it will use the XS
  implementation if possible, falling back to the pure perl one.
  
  =head1 METHODS
  
  =head2 new $package_name
  
  Creates a new C<Package::Stash> object, for the package given as the only
  argument.
  
  =head2 name
  
  Returns the name of the package that this object represents.
  
  =head2 namespace
  
  Returns the raw stash itself.
  
  =head2 add_symbol $variable $value %opts
  
  Adds a new package symbol, for the symbol given as C<$variable>, and optionally
  gives it an initial value of C<$value>. C<$variable> should be the name of
  variable including the sigil, so
  
    Package::Stash->new('Foo')->add_symbol('%foo')
  
  will create C<%Foo::foo>.
  
  Valid options (all optional) are C<filename>, C<first_line_num>, and
  C<last_line_num>.
  
  C<$opts{filename}>, C<$opts{first_line_num}>, and C<$opts{last_line_num}> can
  be used to indicate where the symbol should be regarded as having been defined.
  Currently these values are only used if the symbol is a subroutine ('C<&>'
  sigil) and only if C<$^P & 0x10> is true, in which case the special C<%DB::sub>
  hash is updated to record the values of C<filename>, C<first_line_num>, and
  C<last_line_num> for the subroutine. If these are not passed, their values are
  inferred (as much as possible) from C<caller> information.
  
  This is especially useful for debuggers and profilers, which use C<%DB::sub> to
  determine where the source code for a subroutine can be found.  See
  L<http://perldoc.perl.org/perldebguts.html#Debugger-Internals> for more
  information about C<%DB::sub>.
  
  =head2 remove_glob $name
  
  Removes all package variables with the given name, regardless of sigil.
  
  =head2 has_symbol $variable
  
  Returns whether or not the given package variable (including sigil) exists.
  
  =head2 get_symbol $variable
  
  Returns the value of the given package variable (including sigil).
  
  =head2 get_or_add_symbol $variable
  
  Like C<get_symbol>, except that it will return an empty hashref or
  arrayref if the variable doesn't exist.
  
  =head2 remove_symbol $variable
  
  Removes the package variable described by C<$variable> (which includes the
  sigil); other variables with the same name but different sigils will be
  untouched.
  
  =head2 list_all_symbols $type_filter
  
  Returns a list of package variable names in the package, without sigils. If a
  C<type_filter> is passed, it is used to select package variables of a given
  type, where valid types are the slots of a typeglob ('SCALAR', 'CODE', 'HASH',
  etc). Note that if the package contained any C<BEGIN> blocks, perl will leave
  an empty typeglob in the C<BEGIN> slot, so this will show up if no filter is
  used (and similarly for C<INIT>, C<END>, etc).
  
  =head2 get_all_symbols $type_filter
  
  Returns a hashref, keyed by the variable names in the package. If
  C<$type_filter> is passed, the hash will contain every variable of that type in
  the package as values, otherwise, it will contain the typeglobs corresponding
  to the variable names (basically, a clone of the stash).
  
  =head1 WORKING WITH VARIABLES
  
  It is important to note, that when working with scalar variables, the default
  behavior is to B<copy> values.
  
    my $stash = Package::Stash->new('Some::Namespace');
    my $variable = 1;
    # $Some::Namespace::name is a copy of $variable
    $stash->add_symbol('$name', $variable);
    $variable++
    # $Some::Namespace::name == 1 , $variable == 2
  
  This will likely confuse people who expect it to work the same as typeglob
  assignment, which simply creates new references to existing variables.
  
    my $variable = 1;
    {
        no strict 'refs';
        # assign $Package::Stash::name = $variable
        *{'Package::Stash::name'} = \$variable;
    }
    $variable++ # affects both names
  
  If this behaviour is desired when working with Package::Stash, simply pass
  Package::Stash a scalar ref:
  
    my $stash = Package::Stash->new('Some::Namespace');
    my $variable = 1;
    # $Some::Namespace::name is now $variable
    $stash->add_symbol('$name', \$variable);
    $variable++
    # $Some::Namespace::name == 2 , $variable == 2
  
  This will be what you want as well if you're ever working with L<Readonly>
  variables:
  
    use Readonly;
    Readonly my $value, 'hello';
  
    $stash->add_symbol('$name', \$value); # reference
    print $Some::Namespace::name; # hello
    # Tries to modify the read-only 'hello' and dies.
    $Some::Namespace::name .= " world";
  
    $stash->add_symbol('$name', $value); # copy
    print $Some::Namespace::name; # hello
    # No problem, modifying a copy, not the original
    $Some::Namespace::name .= " world";
  
  =head1 BUGS / CAVEATS
  
  =over 4
  
  =item * Prior to perl 5.10, scalar slots are only considered to exist if they are defined
  
  This is due to a shortcoming within perl itself. See
  L<perlref/Making References> point 7 for more information.
  
  =item * GLOB and FORMAT variables are not (yet) accessible through this module.
  
  =item * Also, see the BUGS section for the specific backends (L<Package::Stash::XS> and L<Package::Stash::PP>)
  
  =back
  
  Please report any bugs to GitHub Issues at
  L<https://github.com/doy/package-stash/issues>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Class::MOP::Package>
  
  This module is a factoring out of code that used to live here
  
  =back
  
  =head1 SUPPORT
  
  You can find this documentation for this module with the perldoc command.
  
      perldoc Package::Stash
  
  You can also look for information at:
  
  =over 4
  
  =item * MetaCPAN
  
  L<https://metacpan.org/release/Package-Stash>
  
  =item * Github
  
  L<https://github.com/doy/package-stash>
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Package-Stash>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Package-Stash>
  
  =back
  
  =head1 HISTORY
  
  Based on code from L<Class::MOP::Package>, by Stevan Little and the Moose
  Cabal.
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy@tozt.net>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PACKAGE_STASH

$fatpacked{"Package/Stash/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH_CONFLICTS';
  package # hide from PAUSE
      Package::Stash::Conflicts;
  
  use strict;
  use warnings;
  
  # this module was generated with Dist::Zilla::Plugin::Conflicts 0.16
  
  use Dist::CheckConflicts
      -dist      => 'Package::Stash',
      -conflicts => {
          'Class::MOP' => '1.08',
          'MooseX::Method::Signatures' => '0.36',
          'MooseX::Role::WithOverloading' => '0.08',
          'namespace::clean' => '0.18',
      },
      -also => [ qw(
          B
          Carp
          Dist::CheckConflicts
          Getopt::Long
          Module::Implementation
          Scalar::Util
          Symbol
          constant
          strict
          warnings
      ) ],
  
  ;
  
  1;
  
  # ABSTRACT: Provide information on conflicts for Package::Stash
  # Dist::Zilla: -PodWeaver
PACKAGE_STASH_CONFLICTS

$fatpacked{"Package/Stash/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH_PP';
  package Package::Stash::PP;
  BEGIN {
    $Package::Stash::PP::AUTHORITY = 'cpan:DOY';
  }
  $Package::Stash::PP::VERSION = '0.37';
  use strict;
  use warnings;
  # ABSTRACT: pure perl implementation of the Package::Stash API
  
  use B;
  use Carp qw(confess);
  use Scalar::Util qw(blessed reftype weaken);
  use Symbol;
  # before 5.12, assigning to the ISA glob would make it lose its magical ->isa
  # powers
  use constant BROKEN_ISA_ASSIGNMENT => ($] < 5.012);
  # before 5.10, stashes don't ever seem to drop to a refcount of zero, so
  # weakening them isn't helpful
  use constant BROKEN_WEAK_STASH     => ($] < 5.010);
  # before 5.10, the scalar slot was always treated as existing if the
  # glob existed
  use constant BROKEN_SCALAR_INITIALIZATION => ($] < 5.010);
  # add_method on anon stashes triggers rt.perl #1804 otherwise
  # fixed in perl commit v5.13.3-70-g0fe688f
  use constant BROKEN_GLOB_ASSIGNMENT => ($] < 5.013004);
  # pre-5.10, ->isa lookups were cached in the ::ISA::CACHE:: slot
  use constant HAS_ISA_CACHE => ($] < 5.010);
  
  
  sub new {
      my $class = shift;
      my ($package) = @_;
  
      if (!defined($package) || (ref($package) && reftype($package) ne 'HASH')) {
          confess "Package::Stash->new must be passed the name of the "
                . "package to access";
      }
      elsif (ref($package) && reftype($package) eq 'HASH') {
          confess "The PP implementation of Package::Stash does not support "
                . "anonymous stashes before perl 5.14"
              if BROKEN_GLOB_ASSIGNMENT;
  
          return bless {
              'namespace' => $package,
          }, $class;
      }
      elsif ($package =~ /\A[0-9A-Z_a-z]+(?:::[0-9A-Z_a-z]+)*\z/) {
          return bless {
              'package' => $package,
          }, $class;
      }
      else {
          confess "$package is not a module name";
      }
  
  }
  
  sub name {
      confess "Can't call name as a class method"
          unless blessed($_[0]);
      confess "Can't get the name of an anonymous package"
          unless defined($_[0]->{package});
      return $_[0]->{package};
  }
  
  sub namespace {
      confess "Can't call namespace as a class method"
          unless blessed($_[0]);
  
      if (BROKEN_WEAK_STASH) {
          no strict 'refs';
          return \%{$_[0]->name . '::'};
      }
      else {
          return $_[0]->{namespace} if defined $_[0]->{namespace};
  
          {
              no strict 'refs';
              $_[0]->{namespace} = \%{$_[0]->name . '::'};
          }
  
          weaken($_[0]->{namespace});
  
          return $_[0]->{namespace};
      }
  }
  
  {
      my %SIGIL_MAP = (
          '$' => 'SCALAR',
          '@' => 'ARRAY',
          '%' => 'HASH',
          '&' => 'CODE',
          ''  => 'IO',
      );
  
      sub _deconstruct_variable_name {
          my ($variable) = @_;
  
          my @ret;
          if (ref($variable) eq 'HASH') {
              @ret = @{$variable}{qw[name sigil type]};
          }
          else {
              (defined $variable && length $variable)
                  || confess "You must pass a variable name";
  
              my $sigil = substr($variable, 0, 1, '');
  
              if (exists $SIGIL_MAP{$sigil}) {
                  @ret = ($variable, $sigil, $SIGIL_MAP{$sigil});
              }
              else {
                  @ret = ("${sigil}${variable}", '', $SIGIL_MAP{''});
              }
          }
  
          # XXX in pure perl, this will access things in inner packages,
          # in xs, this will segfault - probably look more into this at
          # some point
          ($ret[0] !~ /::/)
              || confess "Variable names may not contain ::";
  
          return @ret;
      }
  }
  
  sub _valid_for_type {
      my ($value, $type) = @_;
      if ($type eq 'HASH' || $type eq 'ARRAY'
       || $type eq 'IO'   || $type eq 'CODE') {
          return reftype($value) eq $type;
      }
      else {
          my $ref = reftype($value);
          return !defined($ref) || $ref eq 'SCALAR' || $ref eq 'REF' || $ref eq 'LVALUE' || $ref eq 'REGEXP' || $ref eq 'VSTRING';
      }
  }
  
  sub add_symbol {
      my ($self, $variable, $initial_value, %opts) = @_;
  
      my ($name, $sigil, $type) = _deconstruct_variable_name($variable);
  
      if (@_ > 2) {
          _valid_for_type($initial_value, $type)
              || confess "$initial_value is not of type $type";
  
          # cheap fail-fast check for PERLDBf_SUBLINE and '&'
          if ($^P and $^P & 0x10 && $sigil eq '&') {
              my $filename = $opts{filename};
              my $first_line_num = $opts{first_line_num};
  
              (undef, $filename, $first_line_num) = caller
                  if not defined $filename;
  
              my $last_line_num = $opts{last_line_num} || ($first_line_num ||= 0);
  
              # http://perldoc.perl.org/perldebguts.html#Debugger-Internals
              $DB::sub{$self->name . '::' . $name} = "$filename:$first_line_num-$last_line_num";
          }
      }
  
      if (BROKEN_GLOB_ASSIGNMENT) {
          if (@_ > 2) {
              no strict 'refs';
              no warnings 'redefine';
              *{ $self->name . '::' . $name } = ref $initial_value
                  ? $initial_value : \$initial_value;
          }
          else {
              no strict 'refs';
              if (BROKEN_ISA_ASSIGNMENT && $name eq 'ISA') {
                  *{ $self->name . '::' . $name };
              }
              else {
                  my $undef = _undef_ref_for_type($type);
                  *{ $self->name . '::' . $name } = $undef;
              }
          }
      }
      else {
          my $namespace = $self->namespace;
          {
              # using glob aliasing instead of Symbol::gensym, because otherwise,
              # magic doesn't get applied properly.
              # see <20120710063744.19360.qmail@lists-nntp.develooper.com> on p5p
              local *__ANON__:: = $namespace;
              no strict 'refs';
              no warnings 'void';
              no warnings 'once';
              *{"__ANON__::$name"};
          }
  
          if (@_ > 2) {
              no warnings 'redefine';
              *{ $namespace->{$name} } = ref $initial_value
                  ? $initial_value : \$initial_value;
          }
          else {
              return if BROKEN_ISA_ASSIGNMENT && $name eq 'ISA';
              *{ $namespace->{$name} } = _undef_ref_for_type($type);
          }
      }
  }
  
  sub _undef_ref_for_type {
      my ($type) = @_;
  
      if ($type eq 'ARRAY') {
          return [];
      }
      elsif ($type eq 'HASH') {
          return {};
      }
      elsif ($type eq 'SCALAR') {
          return \undef;
      }
      elsif ($type eq 'IO') {
          return Symbol::geniosym;
      }
      elsif ($type eq 'CODE') {
          confess "Don't know how to vivify CODE variables";
      }
      else {
          confess "Unknown type $type in vivication";
      }
  }
  
  sub remove_glob {
      my ($self, $name) = @_;
      delete $self->namespace->{$name};
  }
  
  sub has_symbol {
      my ($self, $variable) = @_;
  
      my ($name, $sigil, $type) = _deconstruct_variable_name($variable);
  
      my $namespace = $self->namespace;
  
      return unless exists $namespace->{$name};
  
      my $entry_ref = \$namespace->{$name};
      if (reftype($entry_ref) eq 'GLOB') {
          if ($type eq 'SCALAR') {
              if (BROKEN_SCALAR_INITIALIZATION) {
                  return defined ${ *{$entry_ref}{$type} };
              }
              else {
                  my $sv = B::svref_2object($entry_ref)->SV;
                  return $sv->isa('B::SV')
                      || ($sv->isa('B::SPECIAL')
                       && $B::specialsv_name[$$sv] ne 'Nullsv');
              }
          }
          else {
              return defined *{$entry_ref}{$type};
          }
      }
      else {
          # a symbol table entry can be -1 (stub), string (stub with prototype),
          # or reference (constant)
          return $type eq 'CODE';
      }
  }
  
  sub get_symbol {
      my ($self, $variable, %opts) = @_;
  
      my ($name, $sigil, $type) = _deconstruct_variable_name($variable);
  
      my $namespace = $self->namespace;
  
      if (!exists $namespace->{$name}) {
          if ($opts{vivify}) {
              $self->add_symbol($variable);
          }
          else {
              return undef;
          }
      }
  
      my $entry_ref = \$namespace->{$name};
  
      if (ref($entry_ref) eq 'GLOB') {
          return *{$entry_ref}{$type};
      }
      else {
          if ($type eq 'CODE') {
              if (BROKEN_GLOB_ASSIGNMENT || defined($self->{package})) {
                  no strict 'refs';
                  return \&{ $self->name . '::' . $name };
              }
  
              # XXX we should really be able to support arbitrary anonymous
              # stashes here... (not just via Package::Anon)
              if (blessed($namespace) && $namespace->isa('Package::Anon')) {
                  # ->can will call gv_init for us, which inflates the glob
                  # don't know how to do this in general
                  $namespace->bless(\(my $foo))->can($name);
              }
              else {
                  confess "Don't know how to inflate a " . ref($entry_ref)
                        . " into a full coderef (perhaps you could use"
                        . " Package::Anon instead of a bare stash?)"
              }
  
              return *{ $namespace->{$name} }{CODE};
          }
          else {
              return undef;
          }
      }
  }
  
  sub get_or_add_symbol {
      my $self = shift;
      $self->get_symbol(@_, vivify => 1);
  }
  
  sub remove_symbol {
      my ($self, $variable) = @_;
  
      my ($name, $sigil, $type) = _deconstruct_variable_name($variable);
  
      # FIXME:
      # no doubt this is grossly inefficient and
      # could be done much easier and faster in XS
  
      my %desc = (
          SCALAR => { sigil => '$', type => 'SCALAR', name => $name },
          ARRAY  => { sigil => '@', type => 'ARRAY',  name => $name },
          HASH   => { sigil => '%', type => 'HASH',   name => $name },
          CODE   => { sigil => '&', type => 'CODE',   name => $name },
          IO     => { sigil => '',  type => 'IO',     name => $name },
      );
      confess "This should never ever ever happen" if !$desc{$type};
  
      my @types_to_store = grep { $type ne $_ && $self->has_symbol($desc{$_}) }
                                keys %desc;
      my %values = map { $_, $self->get_symbol($desc{$_}) } @types_to_store;
  
      $values{SCALAR} = $self->get_symbol($desc{SCALAR})
        if !defined $values{SCALAR}
          && $type ne 'SCALAR'
          && BROKEN_SCALAR_INITIALIZATION;
  
      $self->remove_glob($name);
  
      $self->add_symbol($desc{$_} => $values{$_})
          for grep { defined $values{$_} } keys %values;
  }
  
  sub list_all_symbols {
      my ($self, $type_filter) = @_;
  
      my $namespace = $self->namespace;
      if (HAS_ISA_CACHE) {
          return grep { $_ ne '::ISA::CACHE::' } keys %{$namespace}
              unless defined $type_filter;
      }
      else {
          return keys %{$namespace}
              unless defined $type_filter;
      }
  
      # NOTE:
      # or we can filter based on
      # type (SCALAR|ARRAY|HASH|CODE)
      if ($type_filter eq 'CODE') {
          return grep {
              # any non-typeglob in the symbol table is a constant or stub
              ref(\$namespace->{$_}) ne 'GLOB'
                  # regular subs are stored in the CODE slot of the typeglob
                  || defined(*{$namespace->{$_}}{CODE})
          } keys %{$namespace};
      }
      elsif ($type_filter eq 'SCALAR') {
          return grep {
              !(HAS_ISA_CACHE && $_ eq '::ISA::CACHE::') &&
              (BROKEN_SCALAR_INITIALIZATION
                  ? (ref(\$namespace->{$_}) eq 'GLOB'
                        && defined(${*{$namespace->{$_}}{'SCALAR'}}))
                  : (do {
                        my $entry = \$namespace->{$_};
                        ref($entry) eq 'GLOB'
                            && B::svref_2object($entry)->SV->isa('B::SV')
                    }))
          } keys %{$namespace};
      }
      else {
          return grep {
              ref(\$namespace->{$_}) eq 'GLOB'
                  && defined(*{$namespace->{$_}}{$type_filter})
          } keys %{$namespace};
      }
  }
  
  sub get_all_symbols {
      my ($self, $type_filter) = @_;
  
      my $namespace = $self->namespace;
      return { %{$namespace} } unless defined $type_filter;
  
      return {
          map { $_ => $self->get_symbol({name => $_, type => $type_filter}) }
              $self->list_all_symbols($type_filter)
      }
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Package::Stash::PP - pure perl implementation of the Package::Stash API
  
  =head1 VERSION
  
  version 0.37
  
  =head1 SYNOPSIS
  
    use Package::Stash;
  
  =head1 DESCRIPTION
  
  This is a backend for L<Package::Stash> implemented in pure perl, for those without a compiler or who would like to use this inline in scripts.
  
  =head1 BUGS
  
  =over 4
  
  =item * remove_symbol also replaces the associated typeglob
  
  This can cause unexpected behavior when doing manipulation at compile time -
  removing subroutines will still allow them to be called from within the package
  as subroutines (although they will not be available as methods). This can be
  considered a feature in some cases (this is how L<namespace::clean> works, for
  instance), but should not be relied upon - use C<remove_glob> directly if you
  want this behavior.
  
  =item * Some minor memory leaks
  
  The pure perl implementation has a couple minor memory leaks (see the TODO
  tests in t/20-leaks.t) that I'm having a hard time tracking down - these may be
  core perl bugs, it's hard to tell.
  
  =back
  
  Please report any bugs through RT: email
  C<bug-package-stash at rt.cpan.org>, or browse to
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Package-Stash>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Class::MOP::Package>
  
  This module is a factoring out of code that used to live here
  
  =back
  
  =head1 SUPPORT
  
  You can find this documentation for this module with the perldoc command.
  
      perldoc Package::Stash
  
  You can also look for information at:
  
  =over 4
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/Package-Stash>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Package-Stash>
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Package-Stash>
  
  =item * Search CPAN
  
  L<http://search.cpan.org/dist/Package-Stash>
  
  =back
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy at tozt dot net>
  
  Mostly copied from code from L<Class::MOP::Package>, by Stevan Little and the
  Moose Cabal.
  
  =for Pod::Coverage BROKEN_ISA_ASSIGNMENT
  add_symbol
  get_all_symbols
  get_or_add_symbol
  get_symbol
  has_symbol
  list_all_symbols
  name
  namespace
  new
  remove_glob
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy@tozt.net>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PACKAGE_STASH_PP

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny; # git description: v0.29-2-g3b23a06
  use 5.006;
  # ABSTRACT: Minimal try/catch with proper preservation of $@
  
  our $VERSION = '0.30';
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT = our @EXPORT_OK = qw(try catch finally);
  
  use Carp;
  $Carp::Internal{+__PACKAGE__}++;
  
  BEGIN {
    my $su = $INC{'Sub/Util.pm'} && defined &Sub::Util::set_subname;
    my $sn = $INC{'Sub/Name.pm'} && eval { Sub::Name->VERSION(0.08) };
    unless ($su || $sn) {
      $su = eval { require Sub::Util; } && defined &Sub::Util::set_subname;
      unless ($su) {
        $sn = eval { require Sub::Name; Sub::Name->VERSION(0.08) };
      }
    }
  
    *_subname = $su ? \&Sub::Util::set_subname
              : $sn ? \&Sub::Name::subname
              : sub { $_[1] };
    *_HAS_SUBNAME = ($su || $sn) ? sub(){1} : sub(){0};
  }
  
  my %_finally_guards;
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
    my ( $try, @code_refs ) = @_;
  
    # we need to save this here, the eval block will be in scalar context due
    # to $failed
    my $wantarray = wantarray;
  
    # work around perl bug by explicitly initializing these, due to the likelyhood
    # this will be used in global destruction (perl rt#119311)
    my ( $catch, @finally ) = ();
  
    # find labeled blocks in the argument list.
    # catch and finally tag the blocks by blessing a scalar reference to them.
    foreach my $code_ref (@code_refs) {
  
      if ( ref($code_ref) eq 'Try::Tiny::Catch' ) {
        croak 'A try() may not be followed by multiple catch() blocks'
          if $catch;
        $catch = ${$code_ref};
      } elsif ( ref($code_ref) eq 'Try::Tiny::Finally' ) {
        push @finally, ${$code_ref};
      } else {
        croak(
          'try() encountered an unexpected argument ('
        . ( defined $code_ref ? $code_ref : 'undef' )
        . ') - perhaps a missing semi-colon before or'
        );
      }
    }
  
    # FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
    # not perfect, but we could provide a list of additional errors for
    # $catch->();
  
    # name the blocks if we have Sub::Name installed
    _subname(caller().'::try {...} ' => $try)
      if _HAS_SUBNAME;
  
    # set up scope guards to invoke the finally blocks at the end.
    # this should really be a function scope lexical variable instead of
    # file scope + local but that causes issues with perls < 5.20 due to
    # perl rt#119311
    local $_finally_guards{guards} = [
      map { Try::Tiny::ScopeGuard->_new($_) }
      @finally
    ];
  
    # save the value of $@ so we can set $@ back to it in the beginning of the eval
    # and restore $@ after the eval finishes
    my $prev_error = $@;
  
    my ( @ret, $error );
  
    # failed will be true if the eval dies, because 1 will not be returned
    # from the eval body
    my $failed = not eval {
      $@ = $prev_error;
  
      # evaluate the try block in the correct context
      if ( $wantarray ) {
        @ret = $try->();
      } elsif ( defined $wantarray ) {
        $ret[0] = $try->();
      } else {
        $try->();
      };
  
      return 1; # properly set $failed to false
    };
  
    # preserve the current error and reset the original value of $@
    $error = $@;
    $@ = $prev_error;
  
    # at this point $failed contains a true value if the eval died, even if some
    # destructor overwrote $@ as the eval was unwinding.
    if ( $failed ) {
      # pass $error to the finally blocks
      push @$_, $error for @{$_finally_guards{guards}};
  
      # if we got an error, invoke the catch block.
      if ( $catch ) {
        # This works like given($error), but is backwards compatible and
        # sets $_ in the dynamic scope for the body of C<$catch>
        for ($error) {
          return $catch->($error);
        }
  
        # in case when() was used without an explicit return, the C<for>
        # loop will be aborted and there's no useful return value
      }
  
      return;
    } else {
      # no failure, $@ is back to what it was, everything is fine
      return $wantarray ? @ret : $ret[0];
    }
  }
  
  sub catch (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare catch()' unless wantarray;
  
    _subname(caller().'::catch {...} ' => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Catch'),
      @rest,
    );
  }
  
  sub finally (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare finally()' unless wantarray;
  
    _subname(caller().'::finally {...} ' => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Finally'),
      @rest,
    );
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    use constant UNSTABLE_DOLLARAT => ("$]" < '5.013002') ? 1 : 0;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my ($code, @args) = @{ $_[0] };
  
      local $@ if UNSTABLE_DOLLARAT;
      eval {
        $code->(@args);
        1;
      } or do {
        warn
          "Execution of finally() block $code resulted in an exception, which "
        . '*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. '
        . 'Your program will continue as if this event never took place. '
        . "Original exception text follows:\n\n"
        . (defined $@ ? $@ : '$@ left undefined...')
        . "\n"
        ;
      }
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Try::Tiny - Minimal try/catch with proper preservation of $@
  
  =head1 VERSION
  
  version 0.30
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
    # handle errors with a catch handler
    try {
      die "foo";
    } catch {
      warn "caught error: $_"; # not $@
    };
  
  You can also use it like a standalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
    # just silence errors
    try {
      die "foo";
    };
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the C<try> block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L</BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the C<try> block dies, it returns the value of the last statement executed in
  the C<catch> block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following examples all
  assign C<"bar"> to C<$x>:
  
    my $x = try { die "foo" } catch { "bar" };
    my $x = try { die "foo" } || "bar";
    my $x = (try { die "foo" }) // "bar";
  
    my $x = eval { die "foo" } || "bar";
  
  You can add C<finally> blocks, yielding the following:
  
    my $x;
    try { die 'foo' } finally { $x = 'bar' };
    try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  C<finally> blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many C<finally> blocks to a
  given C<try> block as you like.
  
  Note that adding a C<finally> block without a preceding C<catch> block
  suppresses any errors. This behaviour is consistent with using a standalone
  C<eval>, but it is not consistent with C<try>/C<finally> patterns found in
  other programming languages, such as Java, Python, Javascript or C#. If you
  learnt the C<try>/C<finally> pattern from one of these languages, watch out for
  this.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory C<try> subroutine, an optional C<catch> subroutine and C<finally>
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the C<finally> block, if given, will execute.
  
  =item catch (&;@)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
    catch { ... }
  
  Inside the C<catch> block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
    local $@ = $_;
  
  =item finally (&;@)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. C<finally> blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the C<finally> block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the C<finally> block does not
  localize C<$_> with the error, since unlike in a C<catch> block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the C<finally> block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  Furthermore B<exceptions in C<finally> blocks are not trappable and are unable
  to influence the execution of your program>. This is due to limitation of
  C<DESTROY>-based scope guards, which C<finally> is implemented on top of. This
  may change in a future version of Try::Tiny.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an C<eval> block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically,
  L<before Perl version 5.14.0|perl5140delta/"Exception Handling">
  C<$@> was clobbered at the beginning of the C<eval>, which
  also made it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (the one
  available before entering the C<try> block) in the beginning of the C<eval>
  block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an C<eval> block, C<die> behaves sort of like:
  
    sub die {
      $@ = $_[0];
      return_undef_from_eval();
    }
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
    my $error = do {
      local $@;
      eval { ... };
      $@;
    };
  
    ...
    die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
    if ( $@ ) {
      ...
    }
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode (fixed in L<Perl 5.14.0|perl5140delta/"Exception Handling">) is:
  
    sub Object::DESTROY {
      eval { ... }
    }
  
    eval {
      my $obj = Object->new;
  
      die "foo";
    };
  
    if ( $@ ) {
  
    }
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the C<eval> was aborted due to an error:
  
    my $failed = not eval {
      ...
  
      return 1;
    };
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 ALTERNATE SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements"> (but please don't,
  because that syntax has since been deprecated because there was too much
  unexpected magical behaviour).
  
  =for stopwords topicalizer
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
    try {
      require Foo;
    } catch {
      when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
      default { die $_ }
    };
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  argument list. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
    sub foo {
      my ( $self, @args ) = @_;
      try { $self->bar(@args) }
    }
  
  or
  
    sub bar_in_place {
      my $self = shift;
      my $args = \@_;
      try { $_ = $self->bar($_) for @$args }
    }
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
      try {
        die;
      }
      catch {
        return;
      };
  
      say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
      my $success = try {
        die;
        1;
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
    # OR
    sub parent_sub_with_catch {
      my $success = try {
        die;
        1;
      }
      catch {
        # do something with $_
        return undef; #see note
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
  
  Note that if you have a C<catch> block, it must return C<undef> for this to work,
  since if a C<catch> block exists, its return value is returned in place of C<undef>
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =for stopwords unhygienically
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygienically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
    my $obj = try {
      MightFail->new;
    } catch {
      ...
  
      return; # avoid returning a true value;
    };
  
    return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
    given ($foo) {
      when (...) {
        try {
          ...
        } catch {
          warn $_; # will print $foo, not the error
          warn $_[0]; # instead, get the error like this
        }
      }
    }
  
  Note that this behavior was changed once again in
  L<Perl5 version 18|https://metacpan.org/module/perldelta#given-now-aliases-the-global-_>.
  However, since the entirety of lexical C<$_> is now L<considered experimental
  |https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental>, it
  is unclear whether the new version 18 behavior is final.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul>
  
  Or read the source:
  
  L<http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Try-Tiny>
  (or L<bug-Try-Tiny@rt.cpan.org|mailto:bug-Try-Tiny@rt.cpan.org>).
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Karen Etheridge Peter Rabbitson Ricardo Signes Mark Fowler Graham Knop Lukas Mai Aristotle Pagaltzis Dagfinn Ilmari Mannsåker Paul Howarth Rudolf Leermakers anaxagoras awalker chromatic Alex cm-perl Andrew Yates David Lowe Glenn Hans Dieter Pearcey Jens Berthold Jonathan Yu Marc Mims Stosberg Pali
  
  =over 4
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Mark Fowler <mark@twoshortplanks.com>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Lukas Mai <l.mai@web.de>
  
  =item *
  
  Aristotle Pagaltzis <pagaltzis@gmx.de>
  
  =item *
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =item *
  
  Paul Howarth <paul@city-fan.org>
  
  =item *
  
  Rudolf Leermakers <rudolf@hatsuseno.org>
  
  =item *
  
  anaxagoras <walkeraj@gmail.com>
  
  =item *
  
  awalker <awalker@sourcefire.com>
  
  =item *
  
  chromatic <chromatic@wgz.org>
  
  =item *
  
  Alex <alex@koban.(none)>
  
  =item *
  
  cm-perl <cm-perl@users.noreply.github.com>
  
  =item *
  
  Andrew Yates <ayates@haddock.local>
  
  =item *
  
  David Lowe <davidl@lokku.com>
  
  =item *
  
  Glenn Fowler <cebjyre@cpan.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Jens Berthold <jens@jebecs.de>
  
  =item *
  
  Jonathan Yu <JAWNSY@cpan.org>
  
  =item *
  
  Marc Mims <marc@questright.com>
  
  =item *
  
  Mark Stosberg <mark@stosberg.com>
  
  =item *
  
  Pali <pali@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is Copyright (c) 2009 by יובל קוג'מן (Yuval Kogman).
  
  This is free software, licensed under:
  
    The MIT (X11) License
  
  =cut
TRY_TINY

$fatpacked{"x86_64-linux/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle uniq uniqnum uniqstr
    head tail pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.50";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first
  
        max maxstr min minstr product sum sum0
  
        pairs unpairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniq uniqnum uniqstr
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  Note also that multiple IEEE C<NaN> values are treated as duplicates of
  each other, regardless of any differences in their payloads, and despite
  the fact that C<< 0+'NaN' == 0+'NaN' >> yields false.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head2 head
  
      my @values = head $size, @list;
  
  Returns the first C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the last C<$size> elements from C<@list>.
  
      @result = head 2, qw( foo bar baz );
      # foo, bar
  
      @result = head -2, qw( foo bar baz );
      # foo
  
  =head2 tail
  
      my @values = tail $size, @list;
  
  Returns the last C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the first C<$size> elements from C<@list>.
  
      @result = tail 2, qw( foo bar baz );
      # bar, baz
  
      @result = tail -2, qw( foo bar baz );
      # baz
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
X86_64-LINUX_LIST_UTIL

$fatpacked{"x86_64-linux/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.50";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_LIST_UTIL_XS

$fatpacked{"x86_64-linux/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.50";
  $VERSION   = eval $VERSION;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be a dual-valued variable, it is
  actually implemented as a magical variable inside the interpreter:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use L</isweak> or L</weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_SCALAR_UTIL

$fatpacked{"x86_64-linux/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.50";
  $VERSION   = eval $VERSION;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If a name has been set using L</set_subname>, this name will
  be returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.*?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
X86_64-LINUX_SUB_UTIL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/home/gugod/perl5/perlbrew/perls/v18/bin/perl

use strict;
use warnings;
# PODNAME: package-stash-conflicts

# this script was generated with Dist::Zilla::Plugin::Conflicts 0.16

use Getopt::Long;
use Package::Stash::Conflicts;

my $verbose;
GetOptions( 'verbose|v' => \$verbose );

if ($verbose) {
    Package::Stash::Conflicts->check_conflicts;
}
else {
    my @conflicts = Package::Stash::Conflicts->calculate_conflicts;
    print "$_\n" for map { $_->{package} } @conflicts;
    exit @conflicts;
}

__END__

=pod

=encoding UTF-8

=head1 NAME

package-stash-conflicts

=head1 VERSION

version 0.37

=head1 AUTHOR

Jesse Luehrs <doy@tozt.net>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2014 by Jesse Luehrs.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut
