#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"CPAN/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META';
  use 5.006;
  use strict;
  use warnings;
  package CPAN::Meta;
  
  our $VERSION = '2.150010';
  
  #pod =head1 SYNOPSIS
  #pod
  #pod     use v5.10;
  #pod     use strict;
  #pod     use warnings;
  #pod     use CPAN::Meta;
  #pod     use Module::Load;
  #pod
  #pod     my $meta = CPAN::Meta->load_file('META.json');
  #pod
  #pod     printf "testing requirements for %s version %s\n",
  #pod     $meta->name,
  #pod     $meta->version;
  #pod
  #pod     my $prereqs = $meta->effective_prereqs;
  #pod
  #pod     for my $phase ( qw/configure runtime build test/ ) {
  #pod         say "Requirements for $phase:";
  #pod         my $reqs = $prereqs->requirements_for($phase, "requires");
  #pod         for my $module ( sort $reqs->required_modules ) {
  #pod             my $status;
  #pod             if ( eval { load $module unless $module eq 'perl'; 1 } ) {
  #pod                 my $version = $module eq 'perl' ? $] : $module->VERSION;
  #pod                 $status = $reqs->accepts_module($module, $version)
  #pod                         ? "$version ok" : "$version not ok";
  #pod             } else {
  #pod                 $status = "missing"
  #pod             };
  #pod             say "  $module ($status)";
  #pod         }
  #pod     }
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod Software distributions released to the CPAN include a F<META.json> or, for
  #pod older distributions, F<META.yml>, which describes the distribution, its
  #pod contents, and the requirements for building and installing the distribution.
  #pod The data structure stored in the F<META.json> file is described in
  #pod L<CPAN::Meta::Spec>.
  #pod
  #pod CPAN::Meta provides a simple class to represent this distribution metadata (or
  #pod I<distmeta>), along with some helpful methods for interrogating that data.
  #pod
  #pod The documentation below is only for the methods of the CPAN::Meta object.  For
  #pod information on the meaning of individual fields, consult the spec.
  #pod
  #pod =cut
  
  use Carp qw(carp croak);
  use CPAN::Meta::Feature;
  use CPAN::Meta::Prereqs;
  use CPAN::Meta::Converter;
  use CPAN::Meta::Validator;
  use Parse::CPAN::Meta 1.4414 ();
  
  BEGIN { *_dclone = \&CPAN::Meta::Converter::_dclone }
  
  #pod =head1 STRING DATA
  #pod
  #pod The following methods return a single value, which is the value for the
  #pod corresponding entry in the distmeta structure.  Values should be either undef
  #pod or strings.
  #pod
  #pod =for :list
  #pod * abstract
  #pod * description
  #pod * dynamic_config
  #pod * generated_by
  #pod * name
  #pod * release_status
  #pod * version
  #pod
  #pod =cut
  
  BEGIN {
    my @STRING_READERS = qw(
      abstract
      description
      dynamic_config
      generated_by
      name
      release_status
      version
    );
  
    no strict 'refs';
    for my $attr (@STRING_READERS) {
      *$attr = sub { $_[0]{ $attr } };
    }
  }
  
  #pod =head1 LIST DATA
  #pod
  #pod These methods return lists of string values, which might be represented in the
  #pod distmeta structure as arrayrefs or scalars:
  #pod
  #pod =for :list
  #pod * authors
  #pod * keywords
  #pod * licenses
  #pod
  #pod The C<authors> and C<licenses> methods may also be called as C<author> and
  #pod C<license>, respectively, to match the field name in the distmeta structure.
  #pod
  #pod =cut
  
  BEGIN {
    my @LIST_READERS = qw(
      author
      keywords
      license
    );
  
    no strict 'refs';
    for my $attr (@LIST_READERS) {
      *$attr = sub {
        my $value = $_[0]{ $attr };
        croak "$attr must be called in list context"
          unless wantarray;
        return @{ _dclone($value) } if ref $value;
        return $value;
      };
    }
  }
  
  sub authors  { $_[0]->author }
  sub licenses { $_[0]->license }
  
  #pod =head1 MAP DATA
  #pod
  #pod These readers return hashrefs of arbitrary unblessed data structures, each
  #pod described more fully in the specification:
  #pod
  #pod =for :list
  #pod * meta_spec
  #pod * resources
  #pod * provides
  #pod * no_index
  #pod * prereqs
  #pod * optional_features
  #pod
  #pod =cut
  
  BEGIN {
    my @MAP_READERS = qw(
      meta-spec
      resources
      provides
      no_index
  
      prereqs
      optional_features
    );
  
    no strict 'refs';
    for my $attr (@MAP_READERS) {
      (my $subname = $attr) =~ s/-/_/;
      *$subname = sub {
        my $value = $_[0]{ $attr };
        return _dclone($value) if $value;
        return {};
      };
    }
  }
  
  #pod =head1 CUSTOM DATA
  #pod
  #pod A list of custom keys are available from the C<custom_keys> method and
  #pod particular keys may be retrieved with the C<custom> method.
  #pod
  #pod   say $meta->custom($_) for $meta->custom_keys;
  #pod
  #pod If a custom key refers to a data structure, a deep clone is returned.
  #pod
  #pod =cut
  
  sub custom_keys {
    return grep { /^x_/i } keys %{$_[0]};
  }
  
  sub custom {
    my ($self, $attr) = @_;
    my $value = $self->{$attr};
    return _dclone($value) if ref $value;
    return $value;
  }
  
  #pod =method new
  #pod
  #pod   my $meta = CPAN::Meta->new($distmeta_struct, \%options);
  #pod
  #pod Returns a valid CPAN::Meta object or dies if the supplied metadata hash
  #pod reference fails to validate.  Older-format metadata will be up-converted to
  #pod version 2 if they validate against the original stated specification.
  #pod
  #pod It takes an optional hashref of options. Valid options include:
  #pod
  #pod =over
  #pod
  #pod =item *
  #pod
  #pod lazy_validation -- if true, new will attempt to convert the given metadata
  #pod to version 2 before attempting to validate it.  This means than any
  #pod fixable errors will be handled by CPAN::Meta::Converter before validation.
  #pod (Note that this might result in invalid optional data being silently
  #pod dropped.)  The default is false.
  #pod
  #pod =back
  #pod
  #pod =cut
  
  sub _new {
    my ($class, $struct, $options) = @_;
    my $self;
  
    if ( $options->{lazy_validation} ) {
      # try to convert to a valid structure; if succeeds, then return it
      my $cmc = CPAN::Meta::Converter->new( $struct );
      $self = $cmc->convert( version => 2 ); # valid or dies
      return bless $self, $class;
    }
    else {
      # validate original struct
      my $cmv = CPAN::Meta::Validator->new( $struct );
      unless ( $cmv->is_valid) {
        die "Invalid metadata structure. Errors: "
          . join(", ", $cmv->errors) . "\n";
      }
    }
  
    # up-convert older spec versions
    my $version = $struct->{'meta-spec'}{version} || '1.0';
    if ( $version == 2 ) {
      $self = $struct;
    }
    else {
      my $cmc = CPAN::Meta::Converter->new( $struct );
      $self = $cmc->convert( version => 2 );
    }
  
    return bless $self, $class;
  }
  
  sub new {
    my ($class, $struct, $options) = @_;
    my $self = eval { $class->_new($struct, $options) };
    croak($@) if $@;
    return $self;
  }
  
  #pod =method create
  #pod
  #pod   my $meta = CPAN::Meta->create($distmeta_struct, \%options);
  #pod
  #pod This is same as C<new()>, except that C<generated_by> and C<meta-spec> fields
  #pod will be generated if not provided.  This means the metadata structure is
  #pod assumed to otherwise follow the latest L<CPAN::Meta::Spec>.
  #pod
  #pod =cut
  
  sub create {
    my ($class, $struct, $options) = @_;
    my $version = __PACKAGE__->VERSION || 2;
    $struct->{generated_by} ||= __PACKAGE__ . " version $version" ;
    $struct->{'meta-spec'}{version} ||= int($version);
    my $self = eval { $class->_new($struct, $options) };
    croak ($@) if $@;
    return $self;
  }
  
  #pod =method load_file
  #pod
  #pod   my $meta = CPAN::Meta->load_file($distmeta_file, \%options);
  #pod
  #pod Given a pathname to a file containing metadata, this deserializes the file
  #pod according to its file suffix and constructs a new C<CPAN::Meta> object, just
  #pod like C<new()>.  It will die if the deserialized version fails to validate
  #pod against its stated specification version.
  #pod
  #pod It takes the same options as C<new()> but C<lazy_validation> defaults to
  #pod true.
  #pod
  #pod =cut
  
  sub load_file {
    my ($class, $file, $options) = @_;
    $options->{lazy_validation} = 1 unless exists $options->{lazy_validation};
  
    croak "load_file() requires a valid, readable filename"
      unless -r $file;
  
    my $self;
    eval {
      my $struct = Parse::CPAN::Meta->load_file( $file );
      $self = $class->_new($struct, $options);
    };
    croak($@) if $@;
    return $self;
  }
  
  #pod =method load_yaml_string
  #pod
  #pod   my $meta = CPAN::Meta->load_yaml_string($yaml, \%options);
  #pod
  #pod This method returns a new CPAN::Meta object using the first document in the
  #pod given YAML string.  In other respects it is identical to C<load_file()>.
  #pod
  #pod =cut
  
  sub load_yaml_string {
    my ($class, $yaml, $options) = @_;
    $options->{lazy_validation} = 1 unless exists $options->{lazy_validation};
  
    my $self;
    eval {
      my ($struct) = Parse::CPAN::Meta->load_yaml_string( $yaml );
      $self = $class->_new($struct, $options);
    };
    croak($@) if $@;
    return $self;
  }
  
  #pod =method load_json_string
  #pod
  #pod   my $meta = CPAN::Meta->load_json_string($json, \%options);
  #pod
  #pod This method returns a new CPAN::Meta object using the structure represented by
  #pod the given JSON string.  In other respects it is identical to C<load_file()>.
  #pod
  #pod =cut
  
  sub load_json_string {
    my ($class, $json, $options) = @_;
    $options->{lazy_validation} = 1 unless exists $options->{lazy_validation};
  
    my $self;
    eval {
      my $struct = Parse::CPAN::Meta->load_json_string( $json );
      $self = $class->_new($struct, $options);
    };
    croak($@) if $@;
    return $self;
  }
  
  #pod =method load_string
  #pod
  #pod   my $meta = CPAN::Meta->load_string($string, \%options);
  #pod
  #pod If you don't know if a string contains YAML or JSON, this method will use
  #pod L<Parse::CPAN::Meta> to guess.  In other respects it is identical to
  #pod C<load_file()>.
  #pod
  #pod =cut
  
  sub load_string {
    my ($class, $string, $options) = @_;
    $options->{lazy_validation} = 1 unless exists $options->{lazy_validation};
  
    my $self;
    eval {
      my $struct = Parse::CPAN::Meta->load_string( $string );
      $self = $class->_new($struct, $options);
    };
    croak($@) if $@;
    return $self;
  }
  
  #pod =method save
  #pod
  #pod   $meta->save($distmeta_file, \%options);
  #pod
  #pod Serializes the object as JSON and writes it to the given file.  The only valid
  #pod option is C<version>, which defaults to '2'. On Perl 5.8.1 or later, the file
  #pod is saved with UTF-8 encoding.
  #pod
  #pod For C<version> 2 (or higher), the filename should end in '.json'.  L<JSON::PP>
  #pod is the default JSON backend. Using another JSON backend requires L<JSON> 2.5 or
  #pod later and you must set the C<$ENV{PERL_JSON_BACKEND}> to a supported alternate
  #pod backend like L<JSON::XS>.
  #pod
  #pod For C<version> less than 2, the filename should end in '.yml'.
  #pod L<CPAN::Meta::Converter> is used to generate an older metadata structure, which
  #pod is serialized to YAML.  CPAN::Meta::YAML is the default YAML backend.  You may
  #pod set the C<$ENV{PERL_YAML_BACKEND}> to a supported alternative backend, though
  #pod this is not recommended due to subtle incompatibilities between YAML parsers on
  #pod CPAN.
  #pod
  #pod =cut
  
  sub save {
    my ($self, $file, $options) = @_;
  
    my $version = $options->{version} || '2';
    my $layer = $] ge '5.008001' ? ':utf8' : '';
  
    if ( $version ge '2' ) {
      carp "'$file' should end in '.json'"
        unless $file =~ m{\.json$};
    }
    else {
      carp "'$file' should end in '.yml'"
        unless $file =~ m{\.yml$};
    }
  
    my $data = $self->as_string( $options );
    open my $fh, ">$layer", $file
      or die "Error opening '$file' for writing: $!\n";
  
    print {$fh} $data;
    close $fh
      or die "Error closing '$file': $!\n";
  
    return 1;
  }
  
  #pod =method meta_spec_version
  #pod
  #pod This method returns the version part of the C<meta_spec> entry in the distmeta
  #pod structure.  It is equivalent to:
  #pod
  #pod   $meta->meta_spec->{version};
  #pod
  #pod =cut
  
  sub meta_spec_version {
    my ($self) = @_;
    return $self->meta_spec->{version};
  }
  
  #pod =method effective_prereqs
  #pod
  #pod   my $prereqs = $meta->effective_prereqs;
  #pod
  #pod   my $prereqs = $meta->effective_prereqs( \@feature_identifiers );
  #pod
  #pod This method returns a L<CPAN::Meta::Prereqs> object describing all the
  #pod prereqs for the distribution.  If an arrayref of feature identifiers is given,
  #pod the prereqs for the identified features are merged together with the
  #pod distribution's core prereqs before the CPAN::Meta::Prereqs object is returned.
  #pod
  #pod =cut
  
  sub effective_prereqs {
    my ($self, $features) = @_;
    $features ||= [];
  
    my $prereq = CPAN::Meta::Prereqs->new($self->prereqs);
  
    return $prereq unless @$features;
  
    my @other = map {; $self->feature($_)->prereqs } @$features;
  
    return $prereq->with_merged_prereqs(\@other);
  }
  
  #pod =method should_index_file
  #pod
  #pod   ... if $meta->should_index_file( $filename );
  #pod
  #pod This method returns true if the given file should be indexed.  It decides this
  #pod by checking the C<file> and C<directory> keys in the C<no_index> property of
  #pod the distmeta structure. Note that neither the version format nor
  #pod C<release_status> are considered.
  #pod
  #pod C<$filename> should be given in unix format.
  #pod
  #pod =cut
  
  sub should_index_file {
    my ($self, $filename) = @_;
  
    for my $no_index_file (@{ $self->no_index->{file} || [] }) {
      return if $filename eq $no_index_file;
    }
  
    for my $no_index_dir (@{ $self->no_index->{directory} }) {
      $no_index_dir =~ s{$}{/} unless $no_index_dir =~ m{/\z};
      return if index($filename, $no_index_dir) == 0;
    }
  
    return 1;
  }
  
  #pod =method should_index_package
  #pod
  #pod   ... if $meta->should_index_package( $package );
  #pod
  #pod This method returns true if the given package should be indexed.  It decides
  #pod this by checking the C<package> and C<namespace> keys in the C<no_index>
  #pod property of the distmeta structure. Note that neither the version format nor
  #pod C<release_status> are considered.
  #pod
  #pod =cut
  
  sub should_index_package {
    my ($self, $package) = @_;
  
    for my $no_index_pkg (@{ $self->no_index->{package} || [] }) {
      return if $package eq $no_index_pkg;
    }
  
    for my $no_index_ns (@{ $self->no_index->{namespace} }) {
      return if index($package, "${no_index_ns}::") == 0;
    }
  
    return 1;
  }
  
  #pod =method features
  #pod
  #pod   my @feature_objects = $meta->features;
  #pod
  #pod This method returns a list of L<CPAN::Meta::Feature> objects, one for each
  #pod optional feature described by the distribution's metadata.
  #pod
  #pod =cut
  
  sub features {
    my ($self) = @_;
  
    my $opt_f = $self->optional_features;
    my @features = map {; CPAN::Meta::Feature->new($_ => $opt_f->{ $_ }) }
                   keys %$opt_f;
  
    return @features;
  }
  
  #pod =method feature
  #pod
  #pod   my $feature_object = $meta->feature( $identifier );
  #pod
  #pod This method returns a L<CPAN::Meta::Feature> object for the optional feature
  #pod with the given identifier.  If no feature with that identifier exists, an
  #pod exception will be raised.
  #pod
  #pod =cut
  
  sub feature {
    my ($self, $ident) = @_;
  
    croak "no feature named $ident"
      unless my $f = $self->optional_features->{ $ident };
  
    return CPAN::Meta::Feature->new($ident, $f);
  }
  
  #pod =method as_struct
  #pod
  #pod   my $copy = $meta->as_struct( \%options );
  #pod
  #pod This method returns a deep copy of the object's metadata as an unblessed hash
  #pod reference.  It takes an optional hashref of options.  If the hashref contains
  #pod a C<version> argument, the copied metadata will be converted to the version
  #pod of the specification and returned.  For example:
  #pod
  #pod   my $old_spec = $meta->as_struct( {version => "1.4"} );
  #pod
  #pod =cut
  
  sub as_struct {
    my ($self, $options) = @_;
    my $struct = _dclone($self);
    if ( $options->{version} ) {
      my $cmc = CPAN::Meta::Converter->new( $struct );
      $struct = $cmc->convert( version => $options->{version} );
    }
    return $struct;
  }
  
  #pod =method as_string
  #pod
  #pod   my $string = $meta->as_string( \%options );
  #pod
  #pod This method returns a serialized copy of the object's metadata as a character
  #pod string.  (The strings are B<not> UTF-8 encoded.)  It takes an optional hashref
  #pod of options.  If the hashref contains a C<version> argument, the copied metadata
  #pod will be converted to the version of the specification and returned.  For
  #pod example:
  #pod
  #pod   my $string = $meta->as_string( {version => "1.4"} );
  #pod
  #pod For C<version> greater than or equal to 2, the string will be serialized as
  #pod JSON.  For C<version> less than 2, the string will be serialized as YAML.  In
  #pod both cases, the same rules are followed as in the C<save()> method for choosing
  #pod a serialization backend.
  #pod
  #pod The serialized structure will include a C<x_serialization_backend> entry giving
  #pod the package and version used to serialize.  Any existing key in the given
  #pod C<$meta> object will be clobbered.
  #pod
  #pod =cut
  
  sub as_string {
    my ($self, $options) = @_;
  
    my $version = $options->{version} || '2';
  
    my $struct;
    if ( $self->meta_spec_version ne $version ) {
      my $cmc = CPAN::Meta::Converter->new( $self->as_struct );
      $struct = $cmc->convert( version => $version );
    }
    else {
      $struct = $self->as_struct;
    }
  
    my ($data, $backend);
    if ( $version ge '2' ) {
      $backend = Parse::CPAN::Meta->json_backend();
      local $struct->{x_serialization_backend} = sprintf '%s version %s',
        $backend, $backend->VERSION;
      $data = $backend->new->pretty->canonical->encode($struct);
    }
    else {
      $backend = Parse::CPAN::Meta->yaml_backend();
      local $struct->{x_serialization_backend} = sprintf '%s version %s',
        $backend, $backend->VERSION;
      $data = eval { no strict 'refs'; &{"$backend\::Dump"}($struct) };
      if ( $@ ) {
        croak $backend->can('errstr') ? $backend->errstr : $@
      }
    }
  
    return $data;
  }
  
  # Used by JSON::PP, etc. for "convert_blessed"
  sub TO_JSON {
    return { %{ $_[0] } };
  }
  
  1;
  
  # ABSTRACT: the distribution metadata for a CPAN dist
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  CPAN::Meta - the distribution metadata for a CPAN dist
  
  =head1 VERSION
  
  version 2.150010
  
  =head1 SYNOPSIS
  
      use v5.10;
      use strict;
      use warnings;
      use CPAN::Meta;
      use Module::Load;
  
      my $meta = CPAN::Meta->load_file('META.json');
  
      printf "testing requirements for %s version %s\n",
      $meta->name,
      $meta->version;
  
      my $prereqs = $meta->effective_prereqs;
  
      for my $phase ( qw/configure runtime build test/ ) {
          say "Requirements for $phase:";
          my $reqs = $prereqs->requirements_for($phase, "requires");
          for my $module ( sort $reqs->required_modules ) {
              my $status;
              if ( eval { load $module unless $module eq 'perl'; 1 } ) {
                  my $version = $module eq 'perl' ? $] : $module->VERSION;
                  $status = $reqs->accepts_module($module, $version)
                          ? "$version ok" : "$version not ok";
              } else {
                  $status = "missing"
              };
              say "  $module ($status)";
          }
      }
  
  =head1 DESCRIPTION
  
  Software distributions released to the CPAN include a F<META.json> or, for
  older distributions, F<META.yml>, which describes the distribution, its
  contents, and the requirements for building and installing the distribution.
  The data structure stored in the F<META.json> file is described in
  L<CPAN::Meta::Spec>.
  
  CPAN::Meta provides a simple class to represent this distribution metadata (or
  I<distmeta>), along with some helpful methods for interrogating that data.
  
  The documentation below is only for the methods of the CPAN::Meta object.  For
  information on the meaning of individual fields, consult the spec.
  
  =head1 METHODS
  
  =head2 new
  
    my $meta = CPAN::Meta->new($distmeta_struct, \%options);
  
  Returns a valid CPAN::Meta object or dies if the supplied metadata hash
  reference fails to validate.  Older-format metadata will be up-converted to
  version 2 if they validate against the original stated specification.
  
  It takes an optional hashref of options. Valid options include:
  
  =over
  
  =item *
  
  lazy_validation -- if true, new will attempt to convert the given metadata
  to version 2 before attempting to validate it.  This means than any
  fixable errors will be handled by CPAN::Meta::Converter before validation.
  (Note that this might result in invalid optional data being silently
  dropped.)  The default is false.
  
  =back
  
  =head2 create
  
    my $meta = CPAN::Meta->create($distmeta_struct, \%options);
  
  This is same as C<new()>, except that C<generated_by> and C<meta-spec> fields
  will be generated if not provided.  This means the metadata structure is
  assumed to otherwise follow the latest L<CPAN::Meta::Spec>.
  
  =head2 load_file
  
    my $meta = CPAN::Meta->load_file($distmeta_file, \%options);
  
  Given a pathname to a file containing metadata, this deserializes the file
  according to its file suffix and constructs a new C<CPAN::Meta> object, just
  like C<new()>.  It will die if the deserialized version fails to validate
  against its stated specification version.
  
  It takes the same options as C<new()> but C<lazy_validation> defaults to
  true.
  
  =head2 load_yaml_string
  
    my $meta = CPAN::Meta->load_yaml_string($yaml, \%options);
  
  This method returns a new CPAN::Meta object using the first document in the
  given YAML string.  In other respects it is identical to C<load_file()>.
  
  =head2 load_json_string
  
    my $meta = CPAN::Meta->load_json_string($json, \%options);
  
  This method returns a new CPAN::Meta object using the structure represented by
  the given JSON string.  In other respects it is identical to C<load_file()>.
  
  =head2 load_string
  
    my $meta = CPAN::Meta->load_string($string, \%options);
  
  If you don't know if a string contains YAML or JSON, this method will use
  L<Parse::CPAN::Meta> to guess.  In other respects it is identical to
  C<load_file()>.
  
  =head2 save
  
    $meta->save($distmeta_file, \%options);
  
  Serializes the object as JSON and writes it to the given file.  The only valid
  option is C<version>, which defaults to '2'. On Perl 5.8.1 or later, the file
  is saved with UTF-8 encoding.
  
  For C<version> 2 (or higher), the filename should end in '.json'.  L<JSON::PP>
  is the default JSON backend. Using another JSON backend requires L<JSON> 2.5 or
  later and you must set the C<$ENV{PERL_JSON_BACKEND}> to a supported alternate
  backend like L<JSON::XS>.
  
  For C<version> less than 2, the filename should end in '.yml'.
  L<CPAN::Meta::Converter> is used to generate an older metadata structure, which
  is serialized to YAML.  CPAN::Meta::YAML is the default YAML backend.  You may
  set the C<$ENV{PERL_YAML_BACKEND}> to a supported alternative backend, though
  this is not recommended due to subtle incompatibilities between YAML parsers on
  CPAN.
  
  =head2 meta_spec_version
  
  This method returns the version part of the C<meta_spec> entry in the distmeta
  structure.  It is equivalent to:
  
    $meta->meta_spec->{version};
  
  =head2 effective_prereqs
  
    my $prereqs = $meta->effective_prereqs;
  
    my $prereqs = $meta->effective_prereqs( \@feature_identifiers );
  
  This method returns a L<CPAN::Meta::Prereqs> object describing all the
  prereqs for the distribution.  If an arrayref of feature identifiers is given,
  the prereqs for the identified features are merged together with the
  distribution's core prereqs before the CPAN::Meta::Prereqs object is returned.
  
  =head2 should_index_file
  
    ... if $meta->should_index_file( $filename );
  
  This method returns true if the given file should be indexed.  It decides this
  by checking the C<file> and C<directory> keys in the C<no_index> property of
  the distmeta structure. Note that neither the version format nor
  C<release_status> are considered.
  
  C<$filename> should be given in unix format.
  
  =head2 should_index_package
  
    ... if $meta->should_index_package( $package );
  
  This method returns true if the given package should be indexed.  It decides
  this by checking the C<package> and C<namespace> keys in the C<no_index>
  property of the distmeta structure. Note that neither the version format nor
  C<release_status> are considered.
  
  =head2 features
  
    my @feature_objects = $meta->features;
  
  This method returns a list of L<CPAN::Meta::Feature> objects, one for each
  optional feature described by the distribution's metadata.
  
  =head2 feature
  
    my $feature_object = $meta->feature( $identifier );
  
  This method returns a L<CPAN::Meta::Feature> object for the optional feature
  with the given identifier.  If no feature with that identifier exists, an
  exception will be raised.
  
  =head2 as_struct
  
    my $copy = $meta->as_struct( \%options );
  
  This method returns a deep copy of the object's metadata as an unblessed hash
  reference.  It takes an optional hashref of options.  If the hashref contains
  a C<version> argument, the copied metadata will be converted to the version
  of the specification and returned.  For example:
  
    my $old_spec = $meta->as_struct( {version => "1.4"} );
  
  =head2 as_string
  
    my $string = $meta->as_string( \%options );
  
  This method returns a serialized copy of the object's metadata as a character
  string.  (The strings are B<not> UTF-8 encoded.)  It takes an optional hashref
  of options.  If the hashref contains a C<version> argument, the copied metadata
  will be converted to the version of the specification and returned.  For
  example:
  
    my $string = $meta->as_string( {version => "1.4"} );
  
  For C<version> greater than or equal to 2, the string will be serialized as
  JSON.  For C<version> less than 2, the string will be serialized as YAML.  In
  both cases, the same rules are followed as in the C<save()> method for choosing
  a serialization backend.
  
  The serialized structure will include a C<x_serialization_backend> entry giving
  the package and version used to serialize.  Any existing key in the given
  C<$meta> object will be clobbered.
  
  =head1 STRING DATA
  
  The following methods return a single value, which is the value for the
  corresponding entry in the distmeta structure.  Values should be either undef
  or strings.
  
  =over 4
  
  =item *
  
  abstract
  
  =item *
  
  description
  
  =item *
  
  dynamic_config
  
  =item *
  
  generated_by
  
  =item *
  
  name
  
  =item *
  
  release_status
  
  =item *
  
  version
  
  =back
  
  =head1 LIST DATA
  
  These methods return lists of string values, which might be represented in the
  distmeta structure as arrayrefs or scalars:
  
  =over 4
  
  =item *
  
  authors
  
  =item *
  
  keywords
  
  =item *
  
  licenses
  
  =back
  
  The C<authors> and C<licenses> methods may also be called as C<author> and
  C<license>, respectively, to match the field name in the distmeta structure.
  
  =head1 MAP DATA
  
  These readers return hashrefs of arbitrary unblessed data structures, each
  described more fully in the specification:
  
  =over 4
  
  =item *
  
  meta_spec
  
  =item *
  
  resources
  
  =item *
  
  provides
  
  =item *
  
  no_index
  
  =item *
  
  prereqs
  
  =item *
  
  optional_features
  
  =back
  
  =head1 CUSTOM DATA
  
  A list of custom keys are available from the C<custom_keys> method and
  particular keys may be retrieved with the C<custom> method.
  
    say $meta->custom($_) for $meta->custom_keys;
  
  If a custom key refers to a data structure, a deep clone is returned.
  
  =for Pod::Coverage TO_JSON abstract author authors custom custom_keys description dynamic_config
  generated_by keywords license licenses meta_spec name no_index
  optional_features prereqs provides release_status resources version
  
  =head1 BUGS
  
  Please report any bugs or feature using the CPAN Request Tracker.
  Bugs can be submitted through the web interface at
  L<http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta>
  
  When submitting a bug or request, please include a test-file or a patch to an
  existing test-file that illustrates the bug or desired feature.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<CPAN::Meta::Converter>
  
  =item *
  
  L<CPAN::Meta::Validator>
  
  =back
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/Perl-Toolchain-Gang/CPAN-Meta>
  
    git clone https://github.com/Perl-Toolchain-Gang/CPAN-Meta.git
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Adam Kennedy <adamk@cpan.org>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Ansgar Burchardt Avar Arnfjord Bjarmason Benjamin Noggle Christopher J. Madsen Chuck Adams Cory G Watson Damyan Ivanov David Golden Eric Wilhelm Graham Knop Gregor Hermann Karen Etheridge Kenichi Ishigaki Kent Fredric Ken Williams Lars Dieckow Leon Timmermans majensen Mark Fowler Matt S Trout Michael G. Schwern Mohammad Anwar mohawk2 moznion Niko Tyni Olaf Alders Olivier Mengué Randy Sims Tomohiro Hosaka
  
  =over 4
  
  =item *
  
  Ansgar Burchardt <ansgar@cpan.org>
  
  =item *
  
  Avar Arnfjord Bjarmason <avar@cpan.org>
  
  =item *
  
  Benjamin Noggle <agwind@users.noreply.github.com>
  
  =item *
  
  Christopher J. Madsen <cjm@cpan.org>
  
  =item *
  
  Chuck Adams <cja987@gmail.com>
  
  =item *
  
  Cory G Watson <gphat@cpan.org>
  
  =item *
  
  Damyan Ivanov <dam@cpan.org>
  
  =item *
  
  David Golden <xdg@xdg.me>
  
  =item *
  
  Eric Wilhelm <ewilhelm@cpan.org>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Gregor Hermann <gregoa@debian.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Kenichi Ishigaki <ishigaki@cpan.org>
  
  =item *
  
  Kent Fredric <kentfredric@gmail.com>
  
  =item *
  
  Ken Williams <kwilliams@cpan.org>
  
  =item *
  
  Lars Dieckow <daxim@cpan.org>
  
  =item *
  
  Leon Timmermans <leont@cpan.org>
  
  =item *
  
  majensen <maj@fortinbras.us>
  
  =item *
  
  Mark Fowler <markf@cpan.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =item *
  
  Michael G. Schwern <mschwern@cpan.org>
  
  =item *
  
  Mohammad S Anwar <mohammad.anwar@yahoo.com>
  
  =item *
  
  mohawk2 <mohawk2@users.noreply.github.com>
  
  =item *
  
  moznion <moznion@gmail.com>
  
  =item *
  
  Niko Tyni <ntyni@debian.org>
  
  =item *
  
  Olaf Alders <olaf@wundersolutions.com>
  
  =item *
  
  Olivier Mengué <dolmen@cpan.org>
  
  =item *
  
  Randy Sims <randys@thepierianspring.org>
  
  =item *
  
  Tomohiro Hosaka <bokutin@bokut.in>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by David Golden, Ricardo Signes, Adam Kennedy and Contributors.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  # vim: ts=2 sts=2 sw=2 et :
CPAN_META

$fatpacked{"CPAN/Meta/Converter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_CONVERTER';
  use 5.006;
  use strict;
  use warnings;
  package CPAN::Meta::Converter;
  
  our $VERSION = '2.150010';
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   my $struct = decode_json_file('META.json');
  #pod
  #pod   my $cmc = CPAN::Meta::Converter->new( $struct );
  #pod
  #pod   my $new_struct = $cmc->convert( version => "2" );
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This module converts CPAN Meta structures from one form to another.  The
  #pod primary use is to convert older structures to the most modern version of
  #pod the specification, but other transformations may be implemented in the
  #pod future as needed.  (E.g. stripping all custom fields or stripping all
  #pod optional fields.)
  #pod
  #pod =cut
  
  use CPAN::Meta::Validator;
  use CPAN::Meta::Requirements;
  use Parse::CPAN::Meta 1.4400 ();
  
  # To help ExtUtils::MakeMaker bootstrap CPAN::Meta::Requirements on perls
  # before 5.10, we fall back to the EUMM bundled compatibility version module if
  # that's the only thing available.  This shouldn't ever happen in a normal CPAN
  # install of CPAN::Meta::Requirements, as version.pm will be picked up from
  # prereqs and be available at runtime.
  
  BEGIN {
    eval "use version ()"; ## no critic
    if ( my $err = $@ ) {
      eval "use ExtUtils::MakeMaker::version" or die $err; ## no critic
    }
  }
  
  # Perl 5.10.0 didn't have "is_qv" in version.pm
  *_is_qv = version->can('is_qv') ? sub { $_[0]->is_qv } : sub { exists $_[0]->{qv} };
  
  # We limit cloning to a maximum depth to bail out on circular data
  # structures.  While actual cycle detection might be technically better,
  # we expect circularity in META data structures to be rare and generally
  # the result of user error.  Therefore, a depth counter is lower overhead.
  our $DCLONE_MAXDEPTH = 1024;
  our $_CLONE_DEPTH;
  
  sub _dclone {
    my ( $ref  ) = @_;
    return $ref unless my $reftype = ref $ref;
  
    local $_CLONE_DEPTH = defined $_CLONE_DEPTH ? $_CLONE_DEPTH - 1 : $DCLONE_MAXDEPTH;
    die "Depth Limit $DCLONE_MAXDEPTH Exceeded" if $_CLONE_DEPTH == 0;
  
    return [ map { _dclone( $_ ) } @{$ref} ] if 'ARRAY' eq $reftype;
    return { map { $_ => _dclone( $ref->{$_} ) } keys %{$ref} } if 'HASH' eq $reftype;
  
    if ( 'SCALAR' eq $reftype ) {
      my $new = _dclone(${$ref});
      return \$new;
    }
  
    # We can't know if TO_JSON gives us cloned data, so refs must recurse
    if ( eval { $ref->can('TO_JSON') } ) {
      my $data = $ref->TO_JSON;
      return ref $data ? _dclone( $data ) : $data;
    }
  
    # Just stringify everything else
    return "$ref";
  }
  
  my %known_specs = (
      '2'   => 'http://search.cpan.org/perldoc?CPAN::Meta::Spec',
      '1.4' => 'http://module-build.sourceforge.net/META-spec-v1.4.html',
      '1.3' => 'http://module-build.sourceforge.net/META-spec-v1.3.html',
      '1.2' => 'http://module-build.sourceforge.net/META-spec-v1.2.html',
      '1.1' => 'http://module-build.sourceforge.net/META-spec-v1.1.html',
      '1.0' => 'http://module-build.sourceforge.net/META-spec-v1.0.html'
  );
  
  my @spec_list = sort { $a <=> $b } keys %known_specs;
  my ($LOWEST, $HIGHEST) = @spec_list[0,-1];
  
  #--------------------------------------------------------------------------#
  # converters
  #
  # called as $converter->($element, $field_name, $full_meta, $to_version)
  #
  # defined return value used for field
  # undef return value means field is skipped
  #--------------------------------------------------------------------------#
  
  sub _keep { $_[0] }
  
  sub _keep_or_one { defined($_[0]) ? $_[0] : 1 }
  
  sub _keep_or_zero { defined($_[0]) ? $_[0] : 0 }
  
  sub _keep_or_unknown { defined($_[0]) && length($_[0]) ? $_[0] : "unknown" }
  
  sub _generated_by {
    my $gen = shift;
    my $sig = __PACKAGE__ . " version " . (__PACKAGE__->VERSION || "<dev>");
  
    return $sig unless defined $gen and length $gen;
    return $gen if $gen =~ /\Q$sig/;
    return "$gen, $sig";
  }
  
  sub _listify { ! defined $_[0] ? undef : ref $_[0] eq 'ARRAY' ? $_[0] : [$_[0]] }
  
  sub _prefix_custom {
    my $key = shift;
    $key =~ s/^(?!x_)   # Unless it already starts with x_
               (?:x-?)? # Remove leading x- or x (if present)
             /x_/ix;    # and prepend x_
    return $key;
  }
  
  sub _ucfirst_custom {
    my $key = shift;
    $key = ucfirst $key unless $key =~ /[A-Z]/;
    return $key;
  }
  
  sub _no_prefix_ucfirst_custom {
    my $key = shift;
    $key =~ s/^x_//;
    return _ucfirst_custom($key);
  }
  
  sub _change_meta_spec {
    my ($element, undef, undef, $version) = @_;
    return {
      version => $version,
      url => $known_specs{$version},
    };
  }
  
  my @open_source = (
    'perl',
    'gpl',
    'apache',
    'artistic',
    'artistic_2',
    'lgpl',
    'bsd',
    'gpl',
    'mit',
    'mozilla',
    'open_source',
  );
  
  my %is_open_source = map {; $_ => 1 } @open_source;
  
  my @valid_licenses_1 = (
    @open_source,
    'unrestricted',
    'restrictive',
    'unknown',
  );
  
  my %license_map_1 = (
    ( map { $_ => $_ } @valid_licenses_1 ),
    artistic2 => 'artistic_2',
  );
  
  sub _license_1 {
    my ($element) = @_;
    return 'unknown' unless defined $element;
    if ( $license_map_1{lc $element} ) {
      return $license_map_1{lc $element};
    }
    else {
      return 'unknown';
    }
  }
  
  my @valid_licenses_2 = qw(
    agpl_3
    apache_1_1
    apache_2_0
    artistic_1
    artistic_2
    bsd
    freebsd
    gfdl_1_2
    gfdl_1_3
    gpl_1
    gpl_2
    gpl_3
    lgpl_2_1
    lgpl_3_0
    mit
    mozilla_1_0
    mozilla_1_1
    openssl
    perl_5
    qpl_1_0
    ssleay
    sun
    zlib
    open_source
    restricted
    unrestricted
    unknown
  );
  
  # The "old" values were defined by Module::Build, and were often vague.  I have
  # made the decisions below based on reading Module::Build::API and how clearly
  # it specifies the version of the license.
  my %license_map_2 = (
    (map { $_ => $_ } @valid_licenses_2),
    apache      => 'apache_2_0',  # clearly stated as 2.0
    artistic    => 'artistic_1',  # clearly stated as 1
    artistic2   => 'artistic_2',  # clearly stated as 2
    gpl         => 'open_source', # we don't know which GPL; punt
    lgpl        => 'open_source', # we don't know which LGPL; punt
    mozilla     => 'open_source', # we don't know which MPL; punt
    perl        => 'perl_5',      # clearly Perl 5
    restrictive => 'restricted',
  );
  
  sub _license_2 {
    my ($element) = @_;
    return [ 'unknown' ] unless defined $element;
    $element = [ $element ] unless ref $element eq 'ARRAY';
    my @new_list;
    for my $lic ( @$element ) {
      next unless defined $lic;
      if ( my $new = $license_map_2{lc $lic} ) {
        push @new_list, $new;
      }
    }
    return @new_list ? \@new_list : [ 'unknown' ];
  }
  
  my %license_downgrade_map = qw(
    agpl_3            open_source
    apache_1_1        apache
    apache_2_0        apache
    artistic_1        artistic
    artistic_2        artistic_2
    bsd               bsd
    freebsd           open_source
    gfdl_1_2          open_source
    gfdl_1_3          open_source
    gpl_1             gpl
    gpl_2             gpl
    gpl_3             gpl
    lgpl_2_1          lgpl
    lgpl_3_0          lgpl
    mit               mit
    mozilla_1_0       mozilla
    mozilla_1_1       mozilla
    openssl           open_source
    perl_5            perl
    qpl_1_0           open_source
    ssleay            open_source
    sun               open_source
    zlib              open_source
    open_source       open_source
    restricted        restrictive
    unrestricted      unrestricted
    unknown           unknown
  );
  
  sub _downgrade_license {
    my ($element) = @_;
    if ( ! defined $element ) {
      return "unknown";
    }
    elsif( ref $element eq 'ARRAY' ) {
      if ( @$element > 1) {
        if (grep { !$is_open_source{ $license_downgrade_map{lc $_} || 'unknown' } } @$element) {
          return 'unknown';
        }
        else {
          return 'open_source';
        }
      }
      elsif ( @$element == 1 ) {
        return $license_downgrade_map{lc $element->[0]} || "unknown";
      }
    }
    elsif ( ! ref $element ) {
      return $license_downgrade_map{lc $element} || "unknown";
    }
    return "unknown";
  }
  
  my $no_index_spec_1_2 = {
    'file' => \&_listify,
    'dir' => \&_listify,
    'package' => \&_listify,
    'namespace' => \&_listify,
  };
  
  my $no_index_spec_1_3 = {
    'file' => \&_listify,
    'directory' => \&_listify,
    'package' => \&_listify,
    'namespace' => \&_listify,
  };
  
  my $no_index_spec_2 = {
    'file' => \&_listify,
    'directory' => \&_listify,
    'package' => \&_listify,
    'namespace' => \&_listify,
    ':custom'  => \&_prefix_custom,
  };
  
  sub _no_index_1_2 {
    my (undef, undef, $meta) = @_;
    my $no_index = $meta->{no_index} || $meta->{private};
    return unless $no_index;
  
    # cleanup wrong format
    if ( ! ref $no_index ) {
      my $item = $no_index;
      $no_index = { dir => [ $item ], file => [ $item ] };
    }
    elsif ( ref $no_index eq 'ARRAY' ) {
      my $list = $no_index;
      $no_index = { dir => [ @$list ], file => [ @$list ] };
    }
  
    # common mistake: files -> file
    if ( exists $no_index->{files} ) {
      $no_index->{file} = delete $no_index->{files};
    }
    # common mistake: modules -> module
    if ( exists $no_index->{modules} ) {
      $no_index->{module} = delete $no_index->{modules};
    }
    return _convert($no_index, $no_index_spec_1_2);
  }
  
  sub _no_index_directory {
    my ($element, $key, $meta, $version) = @_;
    return unless $element;
  
    # clean up wrong format
    if ( ! ref $element ) {
      my $item = $element;
      $element = { directory => [ $item ], file => [ $item ] };
    }
    elsif ( ref $element eq 'ARRAY' ) {
      my $list = $element;
      $element = { directory => [ @$list ], file => [ @$list ] };
    }
  
    if ( exists $element->{dir} ) {
      $element->{directory} = delete $element->{dir};
    }
    # common mistake: files -> file
    if ( exists $element->{files} ) {
      $element->{file} = delete $element->{files};
    }
    # common mistake: modules -> module
    if ( exists $element->{modules} ) {
      $element->{module} = delete $element->{modules};
    }
    my $spec = $version == 2 ? $no_index_spec_2 : $no_index_spec_1_3;
    return _convert($element, $spec);
  }
  
  sub _is_module_name {
    my $mod = shift;
    return unless defined $mod && length $mod;
    return $mod =~ m{^[A-Za-z][A-Za-z0-9_]*(?:::[A-Za-z0-9_]+)*$};
  }
  
  sub _clean_version {
    my ($element) = @_;
    return 0 if ! defined $element;
  
    $element =~ s{^\s*}{};
    $element =~ s{\s*$}{};
    $element =~ s{^\.}{0.};
  
    return 0 if ! length $element;
    return 0 if ( $element eq 'undef' || $element eq '<undef>' );
  
    my $v = eval { version->new($element) };
    # XXX check defined $v and not just $v because version objects leak memory
    # in boolean context -- dagolden, 2012-02-03
    if ( defined $v ) {
      return _is_qv($v) ? $v->normal : $element;
    }
    else {
      return 0;
    }
  }
  
  sub _bad_version_hook {
    my ($v) = @_;
    $v =~ s{^\s*}{};
    $v =~ s{\s*$}{};
    $v =~ s{[a-z]+$}{}; # strip trailing alphabetics
    my $vobj = eval { version->new($v) };
    return defined($vobj) ? $vobj : version->new(0); # or give up
  }
  
  sub _version_map {
    my ($element) = @_;
    return unless defined $element;
    if ( ref $element eq 'HASH' ) {
      # XXX turn this into CPAN::Meta::Requirements with bad version hook
      # and then turn it back into a hash
      my $new_map = CPAN::Meta::Requirements->new(
        { bad_version_hook => \&_bad_version_hook } # punt
      );
      while ( my ($k,$v) = each %$element ) {
        next unless _is_module_name($k);
        if ( !defined($v) || !length($v) || $v eq 'undef' || $v eq '<undef>'  ) {
          $v = 0;
        }
        # some weird, old META have bad yml with module => module
        # so check if value is like a module name and not like a version
        if ( _is_module_name($v) && ! version::is_lax($v) ) {
          $new_map->add_minimum($k => 0);
          $new_map->add_minimum($v => 0);
        }
        $new_map->add_string_requirement($k => $v);
      }
      return $new_map->as_string_hash;
    }
    elsif ( ref $element eq 'ARRAY' ) {
      my $hashref = { map { $_ => 0 } @$element };
      return _version_map($hashref); # clean up any weird stuff
    }
    elsif ( ref $element eq '' && length $element ) {
      return { $element => 0 }
    }
    return;
  }
  
  sub _prereqs_from_1 {
    my (undef, undef, $meta) = @_;
    my $prereqs = {};
    for my $phase ( qw/build configure/ ) {
      my $key = "${phase}_requires";
      $prereqs->{$phase}{requires} = _version_map($meta->{$key})
        if $meta->{$key};
    }
    for my $rel ( qw/requires recommends conflicts/ ) {
      $prereqs->{runtime}{$rel} = _version_map($meta->{$rel})
        if $meta->{$rel};
    }
    return $prereqs;
  }
  
  my $prereqs_spec = {
    configure => \&_prereqs_rel,
    build     => \&_prereqs_rel,
    test      => \&_prereqs_rel,
    runtime   => \&_prereqs_rel,
    develop   => \&_prereqs_rel,
    ':custom'  => \&_prefix_custom,
  };
  
  my $relation_spec = {
    requires   => \&_version_map,
    recommends => \&_version_map,
    suggests   => \&_version_map,
    conflicts  => \&_version_map,
    ':custom'  => \&_prefix_custom,
  };
  
  sub _cleanup_prereqs {
    my ($prereqs, $key, $meta, $to_version) = @_;
    return unless $prereqs && ref $prereqs eq 'HASH';
    return _convert( $prereqs, $prereqs_spec, $to_version );
  }
  
  sub _prereqs_rel {
    my ($relation, $key, $meta, $to_version) = @_;
    return unless $relation && ref $relation eq 'HASH';
    return _convert( $relation, $relation_spec, $to_version );
  }
  
  
  BEGIN {
    my @old_prereqs = qw(
      requires
      configure_requires
      recommends
      conflicts
    );
  
    for ( @old_prereqs ) {
      my $sub = "_get_$_";
      my ($phase,$type) = split qr/_/, $_;
      if ( ! defined $type ) {
        $type = $phase;
        $phase = 'runtime';
      }
      no strict 'refs';
      *{$sub} = sub { _extract_prereqs($_[2]->{prereqs},$phase,$type) };
    }
  }
  
  sub _get_build_requires {
    my ($data, $key, $meta) = @_;
  
    my $test_h  = _extract_prereqs($_[2]->{prereqs}, qw(test  requires)) || {};
    my $build_h = _extract_prereqs($_[2]->{prereqs}, qw(build requires)) || {};
  
    my $test_req  = CPAN::Meta::Requirements->from_string_hash($test_h);
    my $build_req = CPAN::Meta::Requirements->from_string_hash($build_h);
  
    $test_req->add_requirements($build_req)->as_string_hash;
  }
  
  sub _extract_prereqs {
    my ($prereqs, $phase, $type) = @_;
    return unless ref $prereqs eq 'HASH';
    return scalar _version_map($prereqs->{$phase}{$type});
  }
  
  sub _downgrade_optional_features {
    my (undef, undef, $meta) = @_;
    return unless exists $meta->{optional_features};
    my $origin = $meta->{optional_features};
    my $features = {};
    for my $name ( keys %$origin ) {
      $features->{$name} = {
        description => $origin->{$name}{description},
        requires => _extract_prereqs($origin->{$name}{prereqs},'runtime','requires'),
        configure_requires => _extract_prereqs($origin->{$name}{prereqs},'runtime','configure_requires'),
        build_requires => _extract_prereqs($origin->{$name}{prereqs},'runtime','build_requires'),
        recommends => _extract_prereqs($origin->{$name}{prereqs},'runtime','recommends'),
        conflicts => _extract_prereqs($origin->{$name}{prereqs},'runtime','conflicts'),
      };
      for my $k (keys %{$features->{$name}} ) {
        delete $features->{$name}{$k} unless defined $features->{$name}{$k};
      }
    }
    return $features;
  }
  
  sub _upgrade_optional_features {
    my (undef, undef, $meta) = @_;
    return unless exists $meta->{optional_features};
    my $origin = $meta->{optional_features};
    my $features = {};
    for my $name ( keys %$origin ) {
      $features->{$name} = {
        description => $origin->{$name}{description},
        prereqs => _prereqs_from_1(undef, undef, $origin->{$name}),
      };
      delete $features->{$name}{prereqs}{configure};
    }
    return $features;
  }
  
  my $optional_features_2_spec = {
    description => \&_keep,
    prereqs => \&_cleanup_prereqs,
    ':custom'  => \&_prefix_custom,
  };
  
  sub _feature_2 {
    my ($element, $key, $meta, $to_version) = @_;
    return unless $element && ref $element eq 'HASH';
    _convert( $element, $optional_features_2_spec, $to_version );
  }
  
  sub _cleanup_optional_features_2 {
    my ($element, $key, $meta, $to_version) = @_;
    return unless $element && ref $element eq 'HASH';
    my $new_data = {};
    for my $k ( keys %$element ) {
      $new_data->{$k} = _feature_2( $element->{$k}, $k, $meta, $to_version );
    }
    return unless keys %$new_data;
    return $new_data;
  }
  
  sub _optional_features_1_4 {
    my ($element) = @_;
    return unless $element;
    $element = _optional_features_as_map($element);
    for my $name ( keys %$element ) {
      for my $drop ( qw/requires_packages requires_os excluded_os/ ) {
        delete $element->{$name}{$drop};
      }
    }
    return $element;
  }
  
  sub _optional_features_as_map {
    my ($element) = @_;
    return unless $element;
    if ( ref $element eq 'ARRAY' ) {
      my %map;
      for my $feature ( @$element ) {
        my (@parts) = %$feature;
        $map{$parts[0]} = $parts[1];
      }
      $element = \%map;
    }
    return $element;
  }
  
  sub _is_urlish { defined $_[0] && $_[0] =~ m{\A[-+.a-z0-9]+:.+}i }
  
  sub _url_or_drop {
    my ($element) = @_;
    return $element if _is_urlish($element);
    return;
  }
  
  sub _url_list {
    my ($element) = @_;
    return unless $element;
    $element = _listify( $element );
    $element = [ grep { _is_urlish($_) } @$element ];
    return unless @$element;
    return $element;
  }
  
  sub _author_list {
    my ($element) = @_;
    return [ 'unknown' ] unless $element;
    $element = _listify( $element );
    $element = [ map { defined $_ && length $_ ? $_ : 'unknown' } @$element ];
    return [ 'unknown' ] unless @$element;
    return $element;
  }
  
  my $resource2_upgrade = {
    license    => sub { return _is_urlish($_[0]) ? _listify( $_[0] ) : undef },
    homepage   => \&_url_or_drop,
    bugtracker => sub {
      my ($item) = @_;
      return unless $item;
      if ( $item =~ m{^mailto:(.*)$} ) { return { mailto => $1 } }
      elsif( _is_urlish($item) ) { return { web => $item } }
      else { return }
    },
    repository => sub { return _is_urlish($_[0]) ? { url => $_[0] } : undef },
    ':custom'  => \&_prefix_custom,
  };
  
  sub _upgrade_resources_2 {
    my (undef, undef, $meta, $version) = @_;
    return unless exists $meta->{resources};
    return _convert($meta->{resources}, $resource2_upgrade);
  }
  
  my $bugtracker2_spec = {
    web => \&_url_or_drop,
    mailto => \&_keep,
    ':custom'  => \&_prefix_custom,
  };
  
  sub _repo_type {
    my ($element, $key, $meta, $to_version) = @_;
    return $element if defined $element;
    return unless exists $meta->{url};
    my $repo_url = $meta->{url};
    for my $type ( qw/git svn/ ) {
      return $type if $repo_url =~ m{\A$type};
    }
    return;
  }
  
  my $repository2_spec = {
    web => \&_url_or_drop,
    url => \&_url_or_drop,
    type => \&_repo_type,
    ':custom'  => \&_prefix_custom,
  };
  
  my $resources2_cleanup = {
    license    => \&_url_list,
    homepage   => \&_url_or_drop,
    bugtracker => sub { ref $_[0] ? _convert( $_[0], $bugtracker2_spec ) : undef },
    repository => sub { my $data = shift; ref $data ? _convert( $data, $repository2_spec ) : undef },
    ':custom'  => \&_prefix_custom,
  };
  
  sub _cleanup_resources_2 {
    my ($resources, $key, $meta, $to_version) = @_;
    return unless $resources && ref $resources eq 'HASH';
    return _convert($resources, $resources2_cleanup, $to_version);
  }
  
  my $resource1_spec = {
    license    => \&_url_or_drop,
    homepage   => \&_url_or_drop,
    bugtracker => \&_url_or_drop,
    repository => \&_url_or_drop,
    ':custom'  => \&_keep,
  };
  
  sub _resources_1_3 {
    my (undef, undef, $meta, $version) = @_;
    return unless exists $meta->{resources};
    return _convert($meta->{resources}, $resource1_spec);
  }
  
  *_resources_1_4 = *_resources_1_3;
  
  sub _resources_1_2 {
    my (undef, undef, $meta) = @_;
    my $resources = $meta->{resources} || {};
    if ( $meta->{license_url} && ! $resources->{license} ) {
      $resources->{license} = $meta->{license_url}
        if _is_urlish($meta->{license_url});
    }
    return unless keys %$resources;
    return _convert($resources, $resource1_spec);
  }
  
  my $resource_downgrade_spec = {
    license    => sub { return ref $_[0] ? $_[0]->[0] : $_[0] },
    homepage   => \&_url_or_drop,
    bugtracker => sub { return $_[0]->{web} },
    repository => sub { return $_[0]->{url} || $_[0]->{web} },
    ':custom'  => \&_no_prefix_ucfirst_custom,
  };
  
  sub _downgrade_resources {
    my (undef, undef, $meta, $version) = @_;
    return unless exists $meta->{resources};
    return _convert($meta->{resources}, $resource_downgrade_spec);
  }
  
  sub _release_status {
    my ($element, undef, $meta) = @_;
    return $element if $element && $element =~ m{\A(?:stable|testing|unstable)\z};
    return _release_status_from_version(undef, undef, $meta);
  }
  
  sub _release_status_from_version {
    my (undef, undef, $meta) = @_;
    my $version = $meta->{version} || '';
    return ( $version =~ /_/ ) ? 'testing' : 'stable';
  }
  
  my $provides_spec = {
    file => \&_keep,
    version => \&_keep,
  };
  
  my $provides_spec_2 = {
    file => \&_keep,
    version => \&_keep,
    ':custom'  => \&_prefix_custom,
  };
  
  sub _provides {
    my ($element, $key, $meta, $to_version) = @_;
    return unless defined $element && ref $element eq 'HASH';
    my $spec = $to_version == 2 ? $provides_spec_2 : $provides_spec;
    my $new_data = {};
    for my $k ( keys %$element ) {
      $new_data->{$k} = _convert($element->{$k}, $spec, $to_version);
      $new_data->{$k}{version} = _clean_version($element->{$k}{version})
        if exists $element->{$k}{version};
    }
    return $new_data;
  }
  
  sub _convert {
    my ($data, $spec, $to_version, $is_fragment) = @_;
  
    my $new_data = {};
    for my $key ( keys %$spec ) {
      next if $key eq ':custom' || $key eq ':drop';
      next unless my $fcn = $spec->{$key};
      if ( $is_fragment && $key eq 'generated_by' ) {
        $fcn = \&_keep;
      }
      die "spec for '$key' is not a coderef"
        unless ref $fcn && ref $fcn eq 'CODE';
      my $new_value = $fcn->($data->{$key}, $key, $data, $to_version);
      $new_data->{$key} = $new_value if defined $new_value;
    }
  
    my $drop_list   = $spec->{':drop'};
    my $customizer  = $spec->{':custom'} || \&_keep;
  
    for my $key ( keys %$data ) {
      next if $drop_list && grep { $key eq $_ } @$drop_list;
      next if exists $spec->{$key}; # we handled it
      $new_data->{ $customizer->($key) } = $data->{$key};
    }
  
    return $new_data;
  }
  
  #--------------------------------------------------------------------------#
  # define converters for each conversion
  #--------------------------------------------------------------------------#
  
  # each converts from prior version
  # special ":custom" field is used for keys not recognized in spec
  my %up_convert = (
    '2-from-1.4' => {
      # PRIOR MANDATORY
      'abstract'            => \&_keep_or_unknown,
      'author'              => \&_author_list,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_2,
      'meta-spec'           => \&_change_meta_spec,
      'name'                => \&_keep,
      'version'             => \&_keep,
      # CHANGED TO MANDATORY
      'dynamic_config'      => \&_keep_or_one,
      # ADDED MANDATORY
      'release_status'      => \&_release_status,
      # PRIOR OPTIONAL
      'keywords'            => \&_keep,
      'no_index'            => \&_no_index_directory,
      'optional_features'   => \&_upgrade_optional_features,
      'provides'            => \&_provides,
      'resources'           => \&_upgrade_resources_2,
      # ADDED OPTIONAL
      'description'         => \&_keep,
      'prereqs'             => \&_prereqs_from_1,
  
      # drop these deprecated fields, but only after we convert
      ':drop' => [ qw(
          build_requires
          configure_requires
          conflicts
          distribution_type
          license_url
          private
          recommends
          requires
      ) ],
  
      # other random keys need x_ prefixing
      ':custom'              => \&_prefix_custom,
    },
    '1.4-from-1.3' => {
      # PRIOR MANDATORY
      'abstract'            => \&_keep_or_unknown,
      'author'              => \&_author_list,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_1,
      'meta-spec'           => \&_change_meta_spec,
      'name'                => \&_keep,
      'version'             => \&_keep,
      # PRIOR OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'keywords'            => \&_keep,
      'no_index'            => \&_no_index_directory,
      'optional_features'   => \&_optional_features_1_4,
      'provides'            => \&_provides,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
      'resources'           => \&_resources_1_4,
      # ADDED OPTIONAL
      'configure_requires'  => \&_keep,
  
      # drop these deprecated fields, but only after we convert
      ':drop' => [ qw(
        license_url
        private
      )],
  
      # other random keys are OK if already valid
      ':custom'              => \&_keep
    },
    '1.3-from-1.2' => {
      # PRIOR MANDATORY
      'abstract'            => \&_keep_or_unknown,
      'author'              => \&_author_list,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_1,
      'meta-spec'           => \&_change_meta_spec,
      'name'                => \&_keep,
      'version'             => \&_keep,
      # PRIOR OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'keywords'            => \&_keep,
      'no_index'            => \&_no_index_directory,
      'optional_features'   => \&_optional_features_as_map,
      'provides'            => \&_provides,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
      'resources'           => \&_resources_1_3,
  
      # drop these deprecated fields, but only after we convert
      ':drop' => [ qw(
        license_url
        private
      )],
  
      # other random keys are OK if already valid
      ':custom'              => \&_keep
    },
    '1.2-from-1.1' => {
      # PRIOR MANDATORY
      'version'             => \&_keep,
      # CHANGED TO MANDATORY
      'license'             => \&_license_1,
      'name'                => \&_keep,
      'generated_by'        => \&_generated_by,
      # ADDED MANDATORY
      'abstract'            => \&_keep_or_unknown,
      'author'              => \&_author_list,
      'meta-spec'           => \&_change_meta_spec,
      # PRIOR OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
      # ADDED OPTIONAL
      'keywords'            => \&_keep,
      'no_index'            => \&_no_index_1_2,
      'optional_features'   => \&_optional_features_as_map,
      'provides'            => \&_provides,
      'resources'           => \&_resources_1_2,
  
      # drop these deprecated fields, but only after we convert
      ':drop' => [ qw(
        license_url
        private
      )],
  
      # other random keys are OK if already valid
      ':custom'              => \&_keep
    },
    '1.1-from-1.0' => {
      # CHANGED TO MANDATORY
      'version'             => \&_keep,
      # IMPLIED MANDATORY
      'name'                => \&_keep,
      # PRIOR OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_1,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
      # ADDED OPTIONAL
      'license_url'         => \&_url_or_drop,
      'private'             => \&_keep,
  
      # other random keys are OK if already valid
      ':custom'              => \&_keep
    },
  );
  
  my %down_convert = (
    '1.4-from-2' => {
      # MANDATORY
      'abstract'            => \&_keep_or_unknown,
      'author'              => \&_author_list,
      'generated_by'        => \&_generated_by,
      'license'             => \&_downgrade_license,
      'meta-spec'           => \&_change_meta_spec,
      'name'                => \&_keep,
      'version'             => \&_keep,
      # OPTIONAL
      'build_requires'      => \&_get_build_requires,
      'configure_requires'  => \&_get_configure_requires,
      'conflicts'           => \&_get_conflicts,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'keywords'            => \&_keep,
      'no_index'            => \&_no_index_directory,
      'optional_features'   => \&_downgrade_optional_features,
      'provides'            => \&_provides,
      'recommends'          => \&_get_recommends,
      'requires'            => \&_get_requires,
      'resources'           => \&_downgrade_resources,
  
      # drop these unsupported fields (after conversion)
      ':drop' => [ qw(
        description
        prereqs
        release_status
      )],
  
      # custom keys will be left unchanged
      ':custom'              => \&_keep
    },
    '1.3-from-1.4' => {
      # MANDATORY
      'abstract'            => \&_keep_or_unknown,
      'author'              => \&_author_list,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_1,
      'meta-spec'           => \&_change_meta_spec,
      'name'                => \&_keep,
      'version'             => \&_keep,
      # OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'keywords'            => \&_keep,
      'no_index'            => \&_no_index_directory,
      'optional_features'   => \&_optional_features_as_map,
      'provides'            => \&_provides,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
      'resources'           => \&_resources_1_3,
  
      # drop these unsupported fields, but only after we convert
      ':drop' => [ qw(
        configure_requires
      )],
  
      # other random keys are OK if already valid
      ':custom'              => \&_keep,
    },
    '1.2-from-1.3' => {
      # MANDATORY
      'abstract'            => \&_keep_or_unknown,
      'author'              => \&_author_list,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_1,
      'meta-spec'           => \&_change_meta_spec,
      'name'                => \&_keep,
      'version'             => \&_keep,
      # OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'keywords'            => \&_keep,
      'no_index'            => \&_no_index_1_2,
      'optional_features'   => \&_optional_features_as_map,
      'provides'            => \&_provides,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
      'resources'           => \&_resources_1_3,
  
      # other random keys are OK if already valid
      ':custom'              => \&_keep,
    },
    '1.1-from-1.2' => {
      # MANDATORY
      'version'             => \&_keep,
      # IMPLIED MANDATORY
      'name'                => \&_keep,
      'meta-spec'           => \&_change_meta_spec,
      # OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_1,
      'private'             => \&_keep,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
  
      # drop unsupported fields
      ':drop' => [ qw(
        abstract
        author
        provides
        no_index
        keywords
        resources
      )],
  
      # other random keys are OK if already valid
      ':custom'              => \&_keep,
    },
    '1.0-from-1.1' => {
      # IMPLIED MANDATORY
      'name'                => \&_keep,
      'meta-spec'           => \&_change_meta_spec,
      'version'             => \&_keep,
      # PRIOR OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_1,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
  
      # other random keys are OK if already valid
      ':custom'              => \&_keep,
    },
  );
  
  my %cleanup = (
    '2' => {
      # PRIOR MANDATORY
      'abstract'            => \&_keep_or_unknown,
      'author'              => \&_author_list,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_2,
      'meta-spec'           => \&_change_meta_spec,
      'name'                => \&_keep,
      'version'             => \&_keep,
      # CHANGED TO MANDATORY
      'dynamic_config'      => \&_keep_or_one,
      # ADDED MANDATORY
      'release_status'      => \&_release_status,
      # PRIOR OPTIONAL
      'keywords'            => \&_keep,
      'no_index'            => \&_no_index_directory,
      'optional_features'   => \&_cleanup_optional_features_2,
      'provides'            => \&_provides,
      'resources'           => \&_cleanup_resources_2,
      # ADDED OPTIONAL
      'description'         => \&_keep,
      'prereqs'             => \&_cleanup_prereqs,
  
      # drop these deprecated fields, but only after we convert
      ':drop' => [ qw(
          build_requires
          configure_requires
          conflicts
          distribution_type
          license_url
          private
          recommends
          requires
      ) ],
  
      # other random keys need x_ prefixing
      ':custom'              => \&_prefix_custom,
    },
    '1.4' => {
      # PRIOR MANDATORY
      'abstract'            => \&_keep_or_unknown,
      'author'              => \&_author_list,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_1,
      'meta-spec'           => \&_change_meta_spec,
      'name'                => \&_keep,
      'version'             => \&_keep,
      # PRIOR OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'keywords'            => \&_keep,
      'no_index'            => \&_no_index_directory,
      'optional_features'   => \&_optional_features_1_4,
      'provides'            => \&_provides,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
      'resources'           => \&_resources_1_4,
      # ADDED OPTIONAL
      'configure_requires'  => \&_keep,
  
      # other random keys are OK if already valid
      ':custom'             => \&_keep
    },
    '1.3' => {
      # PRIOR MANDATORY
      'abstract'            => \&_keep_or_unknown,
      'author'              => \&_author_list,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_1,
      'meta-spec'           => \&_change_meta_spec,
      'name'                => \&_keep,
      'version'             => \&_keep,
      # PRIOR OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'keywords'            => \&_keep,
      'no_index'            => \&_no_index_directory,
      'optional_features'   => \&_optional_features_as_map,
      'provides'            => \&_provides,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
      'resources'           => \&_resources_1_3,
  
      # other random keys are OK if already valid
      ':custom'             => \&_keep
    },
    '1.2' => {
      # PRIOR MANDATORY
      'version'             => \&_keep,
      # CHANGED TO MANDATORY
      'license'             => \&_license_1,
      'name'                => \&_keep,
      'generated_by'        => \&_generated_by,
      # ADDED MANDATORY
      'abstract'            => \&_keep_or_unknown,
      'author'              => \&_author_list,
      'meta-spec'           => \&_change_meta_spec,
      # PRIOR OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
      # ADDED OPTIONAL
      'keywords'            => \&_keep,
      'no_index'            => \&_no_index_1_2,
      'optional_features'   => \&_optional_features_as_map,
      'provides'            => \&_provides,
      'resources'           => \&_resources_1_2,
  
      # other random keys are OK if already valid
      ':custom'             => \&_keep
    },
    '1.1' => {
      # CHANGED TO MANDATORY
      'version'             => \&_keep,
      # IMPLIED MANDATORY
      'name'                => \&_keep,
      'meta-spec'           => \&_change_meta_spec,
      # PRIOR OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_1,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
      # ADDED OPTIONAL
      'license_url'         => \&_url_or_drop,
      'private'             => \&_keep,
  
      # other random keys are OK if already valid
      ':custom'             => \&_keep
    },
    '1.0' => {
      # IMPLIED MANDATORY
      'name'                => \&_keep,
      'meta-spec'           => \&_change_meta_spec,
      'version'             => \&_keep,
      # IMPLIED OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_1,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
  
      # other random keys are OK if already valid
      ':custom'             => \&_keep,
    },
  );
  
  # for a given field in a spec version, what fields will it feed
  # into in the *latest* spec (i.e. v2); meta-spec omitted because
  # we always expect a meta-spec to be generated
  my %fragments_generate = (
    '2' => {
      'abstract'            =>   'abstract',
      'author'              =>   'author',
      'generated_by'        =>   'generated_by',
      'license'             =>   'license',
      'name'                =>   'name',
      'version'             =>   'version',
      'dynamic_config'      =>   'dynamic_config',
      'release_status'      =>   'release_status',
      'keywords'            =>   'keywords',
      'no_index'            =>   'no_index',
      'optional_features'   =>   'optional_features',
      'provides'            =>   'provides',
      'resources'           =>   'resources',
      'description'         =>   'description',
      'prereqs'             =>   'prereqs',
    },
    '1.4' => {
      'abstract'            => 'abstract',
      'author'              => 'author',
      'generated_by'        => 'generated_by',
      'license'             => 'license',
      'name'                => 'name',
      'version'             => 'version',
      'build_requires'      => 'prereqs',
      'conflicts'           => 'prereqs',
      'distribution_type'   => 'distribution_type',
      'dynamic_config'      => 'dynamic_config',
      'keywords'            => 'keywords',
      'no_index'            => 'no_index',
      'optional_features'   => 'optional_features',
      'provides'            => 'provides',
      'recommends'          => 'prereqs',
      'requires'            => 'prereqs',
      'resources'           => 'resources',
      'configure_requires'  => 'prereqs',
    },
  );
  # this is not quite true but will work well enough
  # as 1.4 is a superset of earlier ones
  $fragments_generate{$_} = $fragments_generate{'1.4'} for qw/1.3 1.2 1.1 1.0/;
  
  #--------------------------------------------------------------------------#
  # Code
  #--------------------------------------------------------------------------#
  
  #pod =method new
  #pod
  #pod   my $cmc = CPAN::Meta::Converter->new( $struct );
  #pod
  #pod The constructor should be passed a valid metadata structure but invalid
  #pod structures are accepted.  If no meta-spec version is provided, version 1.0 will
  #pod be assumed.
  #pod
  #pod Optionally, you can provide a C<default_version> argument after C<$struct>:
  #pod
  #pod   my $cmc = CPAN::Meta::Converter->new( $struct, default_version => "1.4" );
  #pod
  #pod This is only needed when converting a metadata fragment that does not include a
  #pod C<meta-spec> field.
  #pod
  #pod =cut
  
  sub new {
    my ($class,$data,%args) = @_;
  
    # create an attributes hash
    my $self = {
      'data'    => $data,
      'spec'    => _extract_spec_version($data, $args{default_version}),
    };
  
    # create the object
    return bless $self, $class;
  }
  
  sub _extract_spec_version {
      my ($data, $default) = @_;
      my $spec = $data->{'meta-spec'};
  
      # is meta-spec there and valid?
      return( $default || "1.0" ) unless defined $spec && ref $spec eq 'HASH'; # before meta-spec?
  
      # does the version key look like a valid version?
      my $v = $spec->{version};
      if ( defined $v && $v =~ /^\d+(?:\.\d+)?$/ ) {
          return $v if defined $v && grep { $v eq $_ } keys %known_specs; # known spec
          return $v+0 if defined $v && grep { $v == $_ } keys %known_specs; # 2.0 => 2
      }
  
      # otherwise, use heuristics: look for 1.x vs 2.0 fields
      return "2" if exists $data->{prereqs};
      return "1.4" if exists $data->{configure_requires};
      return( $default || "1.2" ); # when meta-spec was first defined
  }
  
  #pod =method convert
  #pod
  #pod   my $new_struct = $cmc->convert( version => "2" );
  #pod
  #pod Returns a new hash reference with the metadata converted to a different form.
  #pod C<convert> will die if any conversion/standardization still results in an
  #pod invalid structure.
  #pod
  #pod Valid parameters include:
  #pod
  #pod =over
  #pod
  #pod =item *
  #pod
  #pod C<version> -- Indicates the desired specification version (e.g. "1.0", "1.1" ... "1.4", "2").
  #pod Defaults to the latest version of the CPAN Meta Spec.
  #pod
  #pod =back
  #pod
  #pod Conversion proceeds through each version in turn.  For example, a version 1.2
  #pod structure might be converted to 1.3 then 1.4 then finally to version 2. The
  #pod conversion process attempts to clean-up simple errors and standardize data.
  #pod For example, if C<author> is given as a scalar, it will converted to an array
  #pod reference containing the item. (Converting a structure to its own version will
  #pod also clean-up and standardize.)
  #pod
  #pod When data are cleaned and standardized, missing or invalid fields will be
  #pod replaced with sensible defaults when possible.  This may be lossy or imprecise.
  #pod For example, some badly structured META.yml files on CPAN have prerequisite
  #pod modules listed as both keys and values:
  #pod
  #pod   requires => { 'Foo::Bar' => 'Bam::Baz' }
  #pod
  #pod These would be split and each converted to a prerequisite with a minimum
  #pod version of zero.
  #pod
  #pod When some mandatory fields are missing or invalid, the conversion will attempt
  #pod to provide a sensible default or will fill them with a value of 'unknown'.  For
  #pod example a missing or unrecognized C<license> field will result in a C<license>
  #pod field of 'unknown'.  Fields that may get an 'unknown' include:
  #pod
  #pod =for :list
  #pod * abstract
  #pod * author
  #pod * license
  #pod
  #pod =cut
  
  sub convert {
    my ($self, %args) = @_;
    my $args = { %args };
  
    my $new_version = $args->{version} || $HIGHEST;
    my $is_fragment = $args->{is_fragment};
  
    my ($old_version) = $self->{spec};
    my $converted = _dclone($self->{data});
  
    if ( $old_version == $new_version ) {
      $converted = _convert( $converted, $cleanup{$old_version}, $old_version, $is_fragment );
      unless ( $args->{is_fragment} ) {
        my $cmv = CPAN::Meta::Validator->new( $converted );
        unless ( $cmv->is_valid ) {
          my $errs = join("\n", $cmv->errors);
          die "Failed to clean-up $old_version metadata. Errors:\n$errs\n";
        }
      }
      return $converted;
    }
    elsif ( $old_version > $new_version )  {
      my @vers = sort { $b <=> $a } keys %known_specs;
      for my $i ( 0 .. $#vers-1 ) {
        next if $vers[$i] > $old_version;
        last if $vers[$i+1] < $new_version;
        my $spec_string = "$vers[$i+1]-from-$vers[$i]";
        $converted = _convert( $converted, $down_convert{$spec_string}, $vers[$i+1], $is_fragment );
        unless ( $args->{is_fragment} ) {
          my $cmv = CPAN::Meta::Validator->new( $converted );
          unless ( $cmv->is_valid ) {
            my $errs = join("\n", $cmv->errors);
            die "Failed to downconvert metadata to $vers[$i+1]. Errors:\n$errs\n";
          }
        }
      }
      return $converted;
    }
    else {
      my @vers = sort { $a <=> $b } keys %known_specs;
      for my $i ( 0 .. $#vers-1 ) {
        next if $vers[$i] < $old_version;
        last if $vers[$i+1] > $new_version;
        my $spec_string = "$vers[$i+1]-from-$vers[$i]";
        $converted = _convert( $converted, $up_convert{$spec_string}, $vers[$i+1], $is_fragment );
        unless ( $args->{is_fragment} ) {
          my $cmv = CPAN::Meta::Validator->new( $converted );
          unless ( $cmv->is_valid ) {
            my $errs = join("\n", $cmv->errors);
            die "Failed to upconvert metadata to $vers[$i+1]. Errors:\n$errs\n";
          }
        }
      }
      return $converted;
    }
  }
  
  #pod =method upgrade_fragment
  #pod
  #pod   my $new_struct = $cmc->upgrade_fragment;
  #pod
  #pod Returns a new hash reference with the metadata converted to the latest version
  #pod of the CPAN Meta Spec.  No validation is done on the result -- you must
  #pod validate after merging fragments into a complete metadata document.
  #pod
  #pod Available since version 2.141170.
  #pod
  #pod =cut
  
  sub upgrade_fragment {
    my ($self) = @_;
    my ($old_version) = $self->{spec};
    my %expected =
      map {; $_ => 1 }
      grep { defined }
      map { $fragments_generate{$old_version}{$_} }
      keys %{ $self->{data} };
    my $converted = $self->convert( version => $HIGHEST, is_fragment => 1 );
    for my $key ( keys %$converted ) {
      next if $key =~ /^x_/i || $key eq 'meta-spec';
      delete $converted->{$key} unless $expected{$key};
    }
    return $converted;
  }
  
  1;
  
  # ABSTRACT: Convert CPAN distribution metadata structures
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  CPAN::Meta::Converter - Convert CPAN distribution metadata structures
  
  =head1 VERSION
  
  version 2.150010
  
  =head1 SYNOPSIS
  
    my $struct = decode_json_file('META.json');
  
    my $cmc = CPAN::Meta::Converter->new( $struct );
  
    my $new_struct = $cmc->convert( version => "2" );
  
  =head1 DESCRIPTION
  
  This module converts CPAN Meta structures from one form to another.  The
  primary use is to convert older structures to the most modern version of
  the specification, but other transformations may be implemented in the
  future as needed.  (E.g. stripping all custom fields or stripping all
  optional fields.)
  
  =head1 METHODS
  
  =head2 new
  
    my $cmc = CPAN::Meta::Converter->new( $struct );
  
  The constructor should be passed a valid metadata structure but invalid
  structures are accepted.  If no meta-spec version is provided, version 1.0 will
  be assumed.
  
  Optionally, you can provide a C<default_version> argument after C<$struct>:
  
    my $cmc = CPAN::Meta::Converter->new( $struct, default_version => "1.4" );
  
  This is only needed when converting a metadata fragment that does not include a
  C<meta-spec> field.
  
  =head2 convert
  
    my $new_struct = $cmc->convert( version => "2" );
  
  Returns a new hash reference with the metadata converted to a different form.
  C<convert> will die if any conversion/standardization still results in an
  invalid structure.
  
  Valid parameters include:
  
  =over
  
  =item *
  
  C<version> -- Indicates the desired specification version (e.g. "1.0", "1.1" ... "1.4", "2").
  Defaults to the latest version of the CPAN Meta Spec.
  
  =back
  
  Conversion proceeds through each version in turn.  For example, a version 1.2
  structure might be converted to 1.3 then 1.4 then finally to version 2. The
  conversion process attempts to clean-up simple errors and standardize data.
  For example, if C<author> is given as a scalar, it will converted to an array
  reference containing the item. (Converting a structure to its own version will
  also clean-up and standardize.)
  
  When data are cleaned and standardized, missing or invalid fields will be
  replaced with sensible defaults when possible.  This may be lossy or imprecise.
  For example, some badly structured META.yml files on CPAN have prerequisite
  modules listed as both keys and values:
  
    requires => { 'Foo::Bar' => 'Bam::Baz' }
  
  These would be split and each converted to a prerequisite with a minimum
  version of zero.
  
  When some mandatory fields are missing or invalid, the conversion will attempt
  to provide a sensible default or will fill them with a value of 'unknown'.  For
  example a missing or unrecognized C<license> field will result in a C<license>
  field of 'unknown'.  Fields that may get an 'unknown' include:
  
  =over 4
  
  =item *
  
  abstract
  
  =item *
  
  author
  
  =item *
  
  license
  
  =back
  
  =head2 upgrade_fragment
  
    my $new_struct = $cmc->upgrade_fragment;
  
  Returns a new hash reference with the metadata converted to the latest version
  of the CPAN Meta Spec.  No validation is done on the result -- you must
  validate after merging fragments into a complete metadata document.
  
  Available since version 2.141170.
  
  =head1 BUGS
  
  Please report any bugs or feature using the CPAN Request Tracker.
  Bugs can be submitted through the web interface at
  L<http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta>
  
  When submitting a bug or request, please include a test-file or a patch to an
  existing test-file that illustrates the bug or desired feature.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Adam Kennedy <adamk@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by David Golden, Ricardo Signes, Adam Kennedy and Contributors.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  # vim: ts=2 sts=2 sw=2 et :
CPAN_META_CONVERTER

$fatpacked{"CPAN/Meta/Feature.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_FEATURE';
  use 5.006;
  use strict;
  use warnings;
  package CPAN::Meta::Feature;
  
  our $VERSION = '2.150010';
  
  use CPAN::Meta::Prereqs;
  
  #pod =head1 DESCRIPTION
  #pod
  #pod A CPAN::Meta::Feature object describes an optional feature offered by a CPAN
  #pod distribution and specified in the distribution's F<META.json> (or F<META.yml>)
  #pod file.
  #pod
  #pod For the most part, this class will only be used when operating on the result of
  #pod the C<feature> or C<features> methods on a L<CPAN::Meta> object.
  #pod
  #pod =method new
  #pod
  #pod   my $feature = CPAN::Meta::Feature->new( $identifier => \%spec );
  #pod
  #pod This returns a new Feature object.  The C<%spec> argument to the constructor
  #pod should be the same as the value of the C<optional_feature> entry in the
  #pod distmeta.  It must contain entries for C<description> and C<prereqs>.
  #pod
  #pod =cut
  
  sub new {
    my ($class, $identifier, $spec) = @_;
  
    my %guts = (
      identifier  => $identifier,
      description => $spec->{description},
      prereqs     => CPAN::Meta::Prereqs->new($spec->{prereqs}),
    );
  
    bless \%guts => $class;
  }
  
  #pod =method identifier
  #pod
  #pod This method returns the feature's identifier.
  #pod
  #pod =cut
  
  sub identifier  { $_[0]{identifier}  }
  
  #pod =method description
  #pod
  #pod This method returns the feature's long description.
  #pod
  #pod =cut
  
  sub description { $_[0]{description} }
  
  #pod =method prereqs
  #pod
  #pod This method returns the feature's prerequisites as a L<CPAN::Meta::Prereqs>
  #pod object.
  #pod
  #pod =cut
  
  sub prereqs     { $_[0]{prereqs} }
  
  1;
  
  # ABSTRACT: an optional feature provided by a CPAN distribution
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  CPAN::Meta::Feature - an optional feature provided by a CPAN distribution
  
  =head1 VERSION
  
  version 2.150010
  
  =head1 DESCRIPTION
  
  A CPAN::Meta::Feature object describes an optional feature offered by a CPAN
  distribution and specified in the distribution's F<META.json> (or F<META.yml>)
  file.
  
  For the most part, this class will only be used when operating on the result of
  the C<feature> or C<features> methods on a L<CPAN::Meta> object.
  
  =head1 METHODS
  
  =head2 new
  
    my $feature = CPAN::Meta::Feature->new( $identifier => \%spec );
  
  This returns a new Feature object.  The C<%spec> argument to the constructor
  should be the same as the value of the C<optional_feature> entry in the
  distmeta.  It must contain entries for C<description> and C<prereqs>.
  
  =head2 identifier
  
  This method returns the feature's identifier.
  
  =head2 description
  
  This method returns the feature's long description.
  
  =head2 prereqs
  
  This method returns the feature's prerequisites as a L<CPAN::Meta::Prereqs>
  object.
  
  =head1 BUGS
  
  Please report any bugs or feature using the CPAN Request Tracker.
  Bugs can be submitted through the web interface at
  L<http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta>
  
  When submitting a bug or request, please include a test-file or a patch to an
  existing test-file that illustrates the bug or desired feature.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Adam Kennedy <adamk@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by David Golden, Ricardo Signes, Adam Kennedy and Contributors.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  # vim: ts=2 sts=2 sw=2 et :
CPAN_META_FEATURE

$fatpacked{"CPAN/Meta/History.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_HISTORY';
  # vi:tw=72
  use 5.006;
  use strict;
  use warnings;
  package CPAN::Meta::History;
  
  our $VERSION = '2.150010';
  
  1;
  
  # ABSTRACT: history of CPAN Meta Spec changes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  CPAN::Meta::History - history of CPAN Meta Spec changes
  
  =head1 VERSION
  
  version 2.150010
  
  =head1 DESCRIPTION
  
  The CPAN Meta Spec has gone through several iterations.  It was
  originally written in HTML and later revised into POD (though published
  in HTML generated from the POD).  Fields were added, removed or changed,
  sometimes by design and sometimes to reflect real-world usage after the
  fact.
  
  This document reconstructs the history of the CPAN Meta Spec based on
  change logs, repository commit messages and the published HTML files.
  In some cases, particularly prior to version 1.2, the exact version
  when certain fields were introduced or changed is inconsistent between
  sources.  When in doubt, the published HTML files for versions 1.0 to
  1.4 as they existed when version 2 was developed are used as the
  definitive source.
  
  Starting with version 2, the specification document is part of the
  CPAN-Meta distribution and will be published on CPAN as
  L<CPAN::Meta::Spec>.
  
  Going forward, specification version numbers will be integers and
  decimal portions will correspond to a release date for the CPAN::Meta
  library.
  
  =head1 HISTORY
  
  =head2 Version 2
  
  April 2010
  
  =over
  
  =item *
  
  Revised spec examples as perl data structures rather than YAML
  
  =item *
  
  Switched to JSON serialization from YAML
  
  =item *
  
  Specified allowed version number formats
  
  =item *
  
  Replaced 'requires', 'build_requires', 'configure_requires',
  'recommends' and 'conflicts' with new 'prereqs' data structure divided
  by I<phase> (configure, build, test, runtime, etc.) and I<relationship>
  (requires, recommends, suggests, conflicts)
  
  =item *
  
  Added support for 'develop' phase for requirements for maintaining
  a list of authoring tools
  
  =item *
  
  Changed 'license' to a list and revised the set of valid licenses
  
  =item *
  
  Made 'dynamic_config' mandatory to reduce confusion
  
  =item *
  
  Changed 'resources' subkey 'repository' to a hash that clarifies
  repository type, url for browsing and url for checkout
  
  =item *
  
  Changed 'resources' subkey 'bugtracker' to a hash for either web
  or mailto resource
  
  =item *
  
  Changed specification of 'optional_features':
  
  =over
  
  =item *
  
  Added formal specification and usage guide instead of just example
  
  =item *
  
  Changed to use new prereqs data structure instead of individual keys
  
  =back
  
  =item *
  
  Clarified intended use of 'author' as generalized contact list
  
  =item *
  
  Added 'release_status' field to indicate stable, testing or unstable
  status to provide hints to indexers
  
  =item *
  
  Added 'description' field for a longer description of the distribution
  
  =item *
  
  Formalized use of "x_" or "X_" for all custom keys not listed in the
  official spec
  
  =back
  
  =head2 Version 1.4
  
  June 2008
  
  =over
  
  =item *
  
  Noted explicit support for 'perl' in prerequisites
  
  =item *
  
  Added 'configure_requires' prerequisite type
  
  =item *
  
  Changed 'optional_features'
  
  =over
  
  =item *
  
  Example corrected to show map of maps instead of list of maps
  (though descriptive text said 'map' even in v1.3)
  
  =item *
  
  Removed 'requires_packages', 'requires_os' and 'excluded_os'
  as valid subkeys
  
  =back
  
  =back
  
  =head2 Version 1.3
  
  November 2006
  
  =over
  
  =item *
  
  Added 'no_index' subkey 'directory' and removed 'dir' to match actual
  usage in the wild
  
  =item *
  
  Added a 'repository' subkey to 'resources'
  
  =back
  
  =head2 Version 1.2
  
  August 2005
  
  =over
  
  =item *
  
  Re-wrote and restructured spec in POD syntax
  
  =item *
  
  Changed 'name' to be mandatory
  
  =item *
  
  Changed 'generated_by' to be mandatory
  
  =item *
  
  Changed 'license' to be mandatory
  
  =item *
  
  Added version range specifications for prerequisites
  
  =item *
  
  Added required 'abstract' field
  
  =item *
  
  Added required 'author' field
  
  =item *
  
  Added required 'meta-spec' field to define 'version' (and 'url') of the
  CPAN Meta Spec used for metadata
  
  =item *
  
  Added 'provides' field
  
  =item *
  
  Added 'no_index' field and deprecated 'private' field.  'no_index'
  subkeys include 'file', 'dir', 'package' and 'namespace'
  
  =item *
  
  Added 'keywords' field
  
  =item *
  
  Added 'resources' field with subkeys 'homepage', 'license', and
  'bugtracker'
  
  =item *
  
  Added 'optional_features' field as an alternate under 'recommends'.
  Includes 'description', 'requires', 'build_requires', 'conflicts',
  'requires_packages', 'requires_os' and 'excluded_os' as valid subkeys
  
  =item *
  
  Removed 'license_uri' field
  
  =back
  
  =head2 Version 1.1
  
  May 2003
  
  =over
  
  =item *
  
  Changed 'version' to be mandatory
  
  =item *
  
  Added 'private' field
  
  =item *
  
  Added 'license_uri' field
  
  =back
  
  =head2 Version 1.0
  
  March 2003
  
  =over
  
  =item *
  
  Original release (in HTML format only)
  
  =item *
  
  Included 'name', 'version', 'license', 'distribution_type', 'requires',
  'recommends', 'build_requires', 'conflicts', 'dynamic_config',
  'generated_by'
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Adam Kennedy <adamk@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by David Golden, Ricardo Signes, Adam Kennedy and Contributors.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
CPAN_META_HISTORY

$fatpacked{"CPAN/Meta/Merge.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_MERGE';
  use strict;
  use warnings;
  
  package CPAN::Meta::Merge;
  
  our $VERSION = '2.150010';
  
  use Carp qw/croak/;
  use Scalar::Util qw/blessed/;
  use CPAN::Meta::Converter 2.141170;
  
  sub _is_identical {
    my ($left, $right) = @_;
    return
      (not defined $left and not defined $right)
      # if either of these are references, we compare the serialized value
      || (defined $left and defined $right and $left eq $right);
  }
  
  sub _identical {
    my ($left, $right, $path) = @_;
    croak sprintf "Can't merge attribute %s: '%s' does not equal '%s'", join('.', @{$path}), $left, $right
      unless _is_identical($left, $right);
    return $left;
  }
  
  sub _merge {
    my ($current, $next, $mergers, $path) = @_;
    for my $key (keys %{$next}) {
      if (not exists $current->{$key}) {
        $current->{$key} = $next->{$key};
      }
      elsif (my $merger = $mergers->{$key}) {
        $current->{$key} = $merger->($current->{$key}, $next->{$key}, [ @{$path}, $key ]);
      }
      elsif ($merger = $mergers->{':default'}) {
        $current->{$key} = $merger->($current->{$key}, $next->{$key}, [ @{$path}, $key ]);
      }
      else {
        croak sprintf "Can't merge unknown attribute '%s'", join '.', @{$path}, $key;
      }
    }
    return $current;
  }
  
  sub _uniq {
    my %seen = ();
    return grep { not $seen{$_}++ } @_;
  }
  
  sub _set_addition {
    my ($left, $right) = @_;
    return [ +_uniq(@{$left}, @{$right}) ];
  }
  
  sub _uniq_map {
    my ($left, $right, $path) = @_;
    for my $key (keys %{$right}) {
      if (not exists $left->{$key}) {
        $left->{$key} = $right->{$key};
      }
      # identical strings or references are merged identically
      elsif (_is_identical($left->{$key}, $right->{$key})) {
        1; # do nothing - keep left
      }
      elsif (ref $left->{$key} eq 'HASH' and ref $right->{$key} eq 'HASH') {
        $left->{$key} = _uniq_map($left->{$key}, $right->{$key}, [ @{$path}, $key ]);
      }
      else {
        croak 'Duplication of element ' . join '.', @{$path}, $key;
      }
    }
    return $left;
  }
  
  sub _improvise {
    my ($left, $right, $path) = @_;
    my ($name) = reverse @{$path};
    if ($name =~ /^x_/) {
      if (ref($left) eq 'ARRAY') {
        return _set_addition($left, $right, $path);
      }
      elsif (ref($left) eq 'HASH') {
        return _uniq_map($left, $right, $path);
      }
      else {
        return _identical($left, $right, $path);
      }
    }
    croak sprintf "Can't merge '%s'", join '.', @{$path};
  }
  
  sub _optional_features {
    my ($left, $right, $path) = @_;
  
    for my $key (keys %{$right}) {
      if (not exists $left->{$key}) {
        $left->{$key} = $right->{$key};
      }
      else {
        for my $subkey (keys %{ $right->{$key} }) {
          next if $subkey eq 'prereqs';
          if (not exists $left->{$key}{$subkey}) {
            $left->{$key}{$subkey} = $right->{$key}{$subkey};
          }
          else {
            Carp::croak "Cannot merge two optional_features named '$key' with different '$subkey' values"
              if do { no warnings 'uninitialized'; $left->{$key}{$subkey} ne $right->{$key}{$subkey} };
          }
        }
  
        require CPAN::Meta::Prereqs;
        $left->{$key}{prereqs} =
          CPAN::Meta::Prereqs->new($left->{$key}{prereqs})
            ->with_merged_prereqs(CPAN::Meta::Prereqs->new($right->{$key}{prereqs}))
            ->as_string_hash;
      }
    }
    return $left;
  }
  
  
  my %default = (
    abstract       => \&_identical,
    author         => \&_set_addition,
    dynamic_config => sub {
      my ($left, $right) = @_;
      return $left || $right;
    },
    generated_by => sub {
      my ($left, $right) = @_;
      return join ', ', _uniq(split(/, /, $left), split(/, /, $right));
    },
    license     => \&_set_addition,
    'meta-spec' => {
      version => \&_identical,
      url     => \&_identical
    },
    name              => \&_identical,
    release_status    => \&_identical,
    version           => \&_identical,
    description       => \&_identical,
    keywords          => \&_set_addition,
    no_index          => { map { ($_ => \&_set_addition) } qw/file directory package namespace/ },
    optional_features => \&_optional_features,
    prereqs           => sub {
      require CPAN::Meta::Prereqs;
      my ($left, $right) = map { CPAN::Meta::Prereqs->new($_) } @_[0,1];
      return $left->with_merged_prereqs($right)->as_string_hash;
    },
    provides  => \&_uniq_map,
    resources => {
      license    => \&_set_addition,
      homepage   => \&_identical,
      bugtracker => \&_uniq_map,
      repository => \&_uniq_map,
      ':default' => \&_improvise,
    },
    ':default' => \&_improvise,
  );
  
  sub new {
    my ($class, %arguments) = @_;
    croak 'default version required' if not exists $arguments{default_version};
    my %mapping = %default;
    my %extra = %{ $arguments{extra_mappings} || {} };
    for my $key (keys %extra) {
      if (ref($mapping{$key}) eq 'HASH') {
        $mapping{$key} = { %{ $mapping{$key} }, %{ $extra{$key} } };
      }
      else {
        $mapping{$key} = $extra{$key};
      }
    }
    return bless {
      default_version => $arguments{default_version},
      mapping => _coerce_mapping(\%mapping, []),
    }, $class;
  }
  
  my %coderef_for = (
    set_addition => \&_set_addition,
    uniq_map     => \&_uniq_map,
    identical    => \&_identical,
    improvise    => \&_improvise,
    improvize    => \&_improvise, # [sic] for backwards compatibility
  );
  
  sub _coerce_mapping {
    my ($orig, $map_path) = @_;
    my %ret;
    for my $key (keys %{$orig}) {
      my $value = $orig->{$key};
      if (ref($orig->{$key}) eq 'CODE') {
        $ret{$key} = $value;
      }
      elsif (ref($value) eq 'HASH') {
        my $mapping = _coerce_mapping($value, [ @{$map_path}, $key ]);
        $ret{$key} = sub {
          my ($left, $right, $path) = @_;
          return _merge($left, $right, $mapping, [ @{$path} ]);
        };
      }
      elsif ($coderef_for{$value}) {
        $ret{$key} = $coderef_for{$value};
      }
      else {
        croak "Don't know what to do with " . join '.', @{$map_path}, $key;
      }
    }
    return \%ret;
  }
  
  sub merge {
    my ($self, @items) = @_;
    my $current = {};
    for my $next (@items) {
      if ( blessed($next) && $next->isa('CPAN::Meta') ) {
        $next = $next->as_struct;
      }
      elsif ( ref($next) eq 'HASH' ) {
        my $cmc = CPAN::Meta::Converter->new(
          $next, default_version => $self->{default_version}
        );
        $next = $cmc->upgrade_fragment;
      }
      else {
        croak "Don't know how to merge '$next'";
      }
      $current = _merge($current, $next, $self->{mapping}, []);
    }
    return $current;
  }
  
  1;
  
  # ABSTRACT: Merging CPAN Meta fragments
  
  
  # vim: ts=2 sts=2 sw=2 et :
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  CPAN::Meta::Merge - Merging CPAN Meta fragments
  
  =head1 VERSION
  
  version 2.150010
  
  =head1 SYNOPSIS
  
   my $merger = CPAN::Meta::Merge->new(default_version => "2");
   my $meta = $merger->merge($base, @additional);
  
  =head1 DESCRIPTION
  
  =head1 METHODS
  
  =head2 new
  
  This creates a CPAN::Meta::Merge object. It takes one mandatory named
  argument, C<version>, declaring the version of the meta-spec that must be
  used for the merge. It can optionally take an C<extra_mappings> argument
  that allows one to add additional merging functions for specific elements.
  
  The C<extra_mappings> arguments takes a hash ref with the same type of
  structure as described in L<CPAN::Meta::Spec>, except with its values as
  one of the L<defined merge strategies|/"MERGE STRATEGIES"> or a code ref
  to a merging function.
  
    my $merger = CPAN::Meta::Merge->new(
        default_version => '2',
        extra_mappings => {
            'optional_features' => \&custom_merge_function,
            'x_custom' => 'set_addition',
            'x_meta_meta' => {
                name => 'identical',
                tags => 'set_addition',
            }
        }
    );
  
  =head2 merge(@fragments)
  
  Merge all C<@fragments> together. It will accept both CPAN::Meta objects and
  (possibly incomplete) hashrefs of metadata.
  
  =head1 MERGE STRATEGIES
  
  C<merge> uses various strategies to combine different elements of the CPAN::Meta objects.  The following strategies can be used with the extra_mappings argument of C<new>:
  
  =over
  
  =item identical
  
  The elements must be identical
  
  =item set_addition
  
  The union of two array refs
  
    [ a, b ] U [ a, c]  = [ a, b, c ]
  
  =item uniq_map
  
  Key value pairs from the right hash are merged to the left hash.  Key
  collisions are only allowed if their values are the same.  This merge
  function will recurse into nested hash refs following the same merge
  rules.
  
  =item improvise
  
  This merge strategy will try to pick the appropriate predefined strategy
  based on what element type.  Array refs will try to use the
  C<set_addition> strategy,  Hash refs will try to use the C<uniq_map>
  strategy, and everything else will try the C<identical> strategy.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Adam Kennedy <adamk@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by David Golden, Ricardo Signes, Adam Kennedy and Contributors.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
CPAN_META_MERGE

$fatpacked{"CPAN/Meta/Prereqs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_PREREQS';
  use 5.006;
  use strict;
  use warnings;
  package CPAN::Meta::Prereqs;
  
  our $VERSION = '2.150010';
  
  #pod =head1 DESCRIPTION
  #pod
  #pod A CPAN::Meta::Prereqs object represents the prerequisites for a CPAN
  #pod distribution or one of its optional features.  Each set of prereqs is
  #pod organized by phase and type, as described in L<CPAN::Meta::Prereqs>.
  #pod
  #pod =cut
  
  use Carp qw(confess);
  use Scalar::Util qw(blessed);
  use CPAN::Meta::Requirements 2.121;
  
  #pod =method new
  #pod
  #pod   my $prereq = CPAN::Meta::Prereqs->new( \%prereq_spec );
  #pod
  #pod This method returns a new set of Prereqs.  The input should look like the
  #pod contents of the C<prereqs> field described in L<CPAN::Meta::Spec>, meaning
  #pod something more or less like this:
  #pod
  #pod   my $prereq = CPAN::Meta::Prereqs->new({
  #pod     runtime => {
  #pod       requires => {
  #pod         'Some::Module' => '1.234',
  #pod         ...,
  #pod       },
  #pod       ...,
  #pod     },
  #pod     ...,
  #pod   });
  #pod
  #pod You can also construct an empty set of prereqs with:
  #pod
  #pod   my $prereqs = CPAN::Meta::Prereqs->new;
  #pod
  #pod This empty set of prereqs is useful for accumulating new prereqs before finally
  #pod dumping the whole set into a structure or string.
  #pod
  #pod =cut
  
  # note we also accept anything matching /\Ax_/i
  sub __legal_phases { qw(configure build test runtime develop)   }
  sub __legal_types  { qw(requires recommends suggests conflicts) }
  
  # expect a prereq spec from META.json -- rjbs, 2010-04-11
  sub new {
    my ($class, $prereq_spec) = @_;
    $prereq_spec ||= {};
  
    my %is_legal_phase = map {; $_ => 1 } $class->__legal_phases;
    my %is_legal_type  = map {; $_ => 1 } $class->__legal_types;
  
    my %guts;
    PHASE: for my $phase (keys %$prereq_spec) {
      next PHASE unless $phase =~ /\Ax_/i or $is_legal_phase{$phase};
  
      my $phase_spec = $prereq_spec->{ $phase };
      next PHASE unless keys %$phase_spec;
  
      TYPE: for my $type (keys %$phase_spec) {
        next TYPE unless $type =~ /\Ax_/i or $is_legal_type{$type};
  
        my $spec = $phase_spec->{ $type };
  
        next TYPE unless keys %$spec;
  
        $guts{prereqs}{$phase}{$type} = CPAN::Meta::Requirements->from_string_hash(
          $spec
        );
      }
    }
  
    return bless \%guts => $class;
  }
  
  #pod =method requirements_for
  #pod
  #pod   my $requirements = $prereqs->requirements_for( $phase, $type );
  #pod
  #pod This method returns a L<CPAN::Meta::Requirements> object for the given
  #pod phase/type combination.  If no prerequisites are registered for that
  #pod combination, a new CPAN::Meta::Requirements object will be returned, and it may
  #pod be added to as needed.
  #pod
  #pod If C<$phase> or C<$type> are undefined or otherwise invalid, an exception will
  #pod be raised.
  #pod
  #pod =cut
  
  sub requirements_for {
    my ($self, $phase, $type) = @_;
  
    confess "requirements_for called without phase" unless defined $phase;
    confess "requirements_for called without type"  unless defined $type;
  
    unless ($phase =~ /\Ax_/i or grep { $phase eq $_ } $self->__legal_phases) {
      confess "requested requirements for unknown phase: $phase";
    }
  
    unless ($type =~ /\Ax_/i or grep { $type eq $_ } $self->__legal_types) {
      confess "requested requirements for unknown type: $type";
    }
  
    my $req = ($self->{prereqs}{$phase}{$type} ||= CPAN::Meta::Requirements->new);
  
    $req->finalize if $self->is_finalized;
  
    return $req;
  }
  
  #pod =method phases
  #pod
  #pod   my @phases = $prereqs->phases;
  #pod
  #pod This method returns the list of all phases currently populated in the prereqs
  #pod object, suitable for iterating.
  #pod
  #pod =cut
  
  sub phases {
    my ($self) = @_;
  
    my %is_legal_phase = map {; $_ => 1 } $self->__legal_phases;
    grep { /\Ax_/i or $is_legal_phase{$_} } keys %{ $self->{prereqs} };
  }
  
  #pod =method types_in
  #pod
  #pod   my @runtime_types = $prereqs->types_in('runtime');
  #pod
  #pod This method returns the list of all types currently populated in the prereqs
  #pod object for the provided phase, suitable for iterating.
  #pod
  #pod =cut
  
  sub types_in {
    my ($self, $phase) = @_;
  
    return unless $phase =~ /\Ax_/i or grep { $phase eq $_ } $self->__legal_phases;
  
    my %is_legal_type  = map {; $_ => 1 } $self->__legal_types;
    grep { /\Ax_/i or $is_legal_type{$_} } keys %{ $self->{prereqs}{$phase} };
  }
  
  #pod =method with_merged_prereqs
  #pod
  #pod   my $new_prereqs = $prereqs->with_merged_prereqs( $other_prereqs );
  #pod
  #pod   my $new_prereqs = $prereqs->with_merged_prereqs( \@other_prereqs );
  #pod
  #pod This method returns a new CPAN::Meta::Prereqs objects in which all the
  #pod other prerequisites given are merged into the current set.  This is primarily
  #pod provided for combining a distribution's core prereqs with the prereqs of one of
  #pod its optional features.
  #pod
  #pod The new prereqs object has no ties to the originals, and altering it further
  #pod will not alter them.
  #pod
  #pod =cut
  
  sub with_merged_prereqs {
    my ($self, $other) = @_;
  
    my @other = blessed($other) ? $other : @$other;
  
    my @prereq_objs = ($self, @other);
  
    my %new_arg;
  
    for my $phase (__uniq(map { $_->phases } @prereq_objs)) {
      for my $type (__uniq(map { $_->types_in($phase) } @prereq_objs)) {
  
        my $req = CPAN::Meta::Requirements->new;
  
        for my $prereq (@prereq_objs) {
          my $this_req = $prereq->requirements_for($phase, $type);
          next unless $this_req->required_modules;
  
          $req->add_requirements($this_req);
        }
  
        next unless $req->required_modules;
  
        $new_arg{ $phase }{ $type } = $req->as_string_hash;
      }
    }
  
    return (ref $self)->new(\%new_arg);
  }
  
  #pod =method merged_requirements
  #pod
  #pod     my $new_reqs = $prereqs->merged_requirements( \@phases, \@types );
  #pod     my $new_reqs = $prereqs->merged_requirements( \@phases );
  #pod     my $new_reqs = $prereqs->merged_requirements();
  #pod
  #pod This method joins together all requirements across a number of phases
  #pod and types into a new L<CPAN::Meta::Requirements> object.  If arguments
  #pod are omitted, it defaults to "runtime", "build" and "test" for phases
  #pod and "requires" and "recommends" for types.
  #pod
  #pod =cut
  
  sub merged_requirements {
    my ($self, $phases, $types) = @_;
    $phases = [qw/runtime build test/] unless defined $phases;
    $types = [qw/requires recommends/] unless defined $types;
  
    confess "merged_requirements phases argument must be an arrayref"
      unless ref $phases eq 'ARRAY';
    confess "merged_requirements types argument must be an arrayref"
      unless ref $types eq 'ARRAY';
  
    my $req = CPAN::Meta::Requirements->new;
  
    for my $phase ( @$phases ) {
      unless ($phase =~ /\Ax_/i or grep { $phase eq $_ } $self->__legal_phases) {
          confess "requested requirements for unknown phase: $phase";
      }
      for my $type ( @$types ) {
        unless ($type =~ /\Ax_/i or grep { $type eq $_ } $self->__legal_types) {
            confess "requested requirements for unknown type: $type";
        }
        $req->add_requirements( $self->requirements_for($phase, $type) );
      }
    }
  
    $req->finalize if $self->is_finalized;
  
    return $req;
  }
  
  
  #pod =method as_string_hash
  #pod
  #pod This method returns a hashref containing structures suitable for dumping into a
  #pod distmeta data structure.  It is made up of hashes and strings, only; there will
  #pod be no Prereqs, CPAN::Meta::Requirements, or C<version> objects inside it.
  #pod
  #pod =cut
  
  sub as_string_hash {
    my ($self) = @_;
  
    my %hash;
  
    for my $phase ($self->phases) {
      for my $type ($self->types_in($phase)) {
        my $req = $self->requirements_for($phase, $type);
        next unless $req->required_modules;
  
        $hash{ $phase }{ $type } = $req->as_string_hash;
      }
    }
  
    return \%hash;
  }
  
  #pod =method is_finalized
  #pod
  #pod This method returns true if the set of prereqs has been marked "finalized," and
  #pod cannot be altered.
  #pod
  #pod =cut
  
  sub is_finalized { $_[0]{finalized} }
  
  #pod =method finalize
  #pod
  #pod Calling C<finalize> on a Prereqs object will close it for further modification.
  #pod Attempting to make any changes that would actually alter the prereqs will
  #pod result in an exception being thrown.
  #pod
  #pod =cut
  
  sub finalize {
    my ($self) = @_;
  
    $self->{finalized} = 1;
  
    for my $phase (keys %{ $self->{prereqs} }) {
      $_->finalize for values %{ $self->{prereqs}{$phase} };
    }
  }
  
  #pod =method clone
  #pod
  #pod   my $cloned_prereqs = $prereqs->clone;
  #pod
  #pod This method returns a Prereqs object that is identical to the original object,
  #pod but can be altered without affecting the original object.  Finalization does
  #pod not survive cloning, meaning that you may clone a finalized set of prereqs and
  #pod then modify the clone.
  #pod
  #pod =cut
  
  sub clone {
    my ($self) = @_;
  
    my $clone = (ref $self)->new( $self->as_string_hash );
  }
  
  sub __uniq {
    my (%s, $u);
    grep { defined($_) ? !$s{$_}++ : !$u++ } @_;
  }
  
  1;
  
  # ABSTRACT: a set of distribution prerequisites by phase and type
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  CPAN::Meta::Prereqs - a set of distribution prerequisites by phase and type
  
  =head1 VERSION
  
  version 2.150010
  
  =head1 DESCRIPTION
  
  A CPAN::Meta::Prereqs object represents the prerequisites for a CPAN
  distribution or one of its optional features.  Each set of prereqs is
  organized by phase and type, as described in L<CPAN::Meta::Prereqs>.
  
  =head1 METHODS
  
  =head2 new
  
    my $prereq = CPAN::Meta::Prereqs->new( \%prereq_spec );
  
  This method returns a new set of Prereqs.  The input should look like the
  contents of the C<prereqs> field described in L<CPAN::Meta::Spec>, meaning
  something more or less like this:
  
    my $prereq = CPAN::Meta::Prereqs->new({
      runtime => {
        requires => {
          'Some::Module' => '1.234',
          ...,
        },
        ...,
      },
      ...,
    });
  
  You can also construct an empty set of prereqs with:
  
    my $prereqs = CPAN::Meta::Prereqs->new;
  
  This empty set of prereqs is useful for accumulating new prereqs before finally
  dumping the whole set into a structure or string.
  
  =head2 requirements_for
  
    my $requirements = $prereqs->requirements_for( $phase, $type );
  
  This method returns a L<CPAN::Meta::Requirements> object for the given
  phase/type combination.  If no prerequisites are registered for that
  combination, a new CPAN::Meta::Requirements object will be returned, and it may
  be added to as needed.
  
  If C<$phase> or C<$type> are undefined or otherwise invalid, an exception will
  be raised.
  
  =head2 phases
  
    my @phases = $prereqs->phases;
  
  This method returns the list of all phases currently populated in the prereqs
  object, suitable for iterating.
  
  =head2 types_in
  
    my @runtime_types = $prereqs->types_in('runtime');
  
  This method returns the list of all types currently populated in the prereqs
  object for the provided phase, suitable for iterating.
  
  =head2 with_merged_prereqs
  
    my $new_prereqs = $prereqs->with_merged_prereqs( $other_prereqs );
  
    my $new_prereqs = $prereqs->with_merged_prereqs( \@other_prereqs );
  
  This method returns a new CPAN::Meta::Prereqs objects in which all the
  other prerequisites given are merged into the current set.  This is primarily
  provided for combining a distribution's core prereqs with the prereqs of one of
  its optional features.
  
  The new prereqs object has no ties to the originals, and altering it further
  will not alter them.
  
  =head2 merged_requirements
  
      my $new_reqs = $prereqs->merged_requirements( \@phases, \@types );
      my $new_reqs = $prereqs->merged_requirements( \@phases );
      my $new_reqs = $prereqs->merged_requirements();
  
  This method joins together all requirements across a number of phases
  and types into a new L<CPAN::Meta::Requirements> object.  If arguments
  are omitted, it defaults to "runtime", "build" and "test" for phases
  and "requires" and "recommends" for types.
  
  =head2 as_string_hash
  
  This method returns a hashref containing structures suitable for dumping into a
  distmeta data structure.  It is made up of hashes and strings, only; there will
  be no Prereqs, CPAN::Meta::Requirements, or C<version> objects inside it.
  
  =head2 is_finalized
  
  This method returns true if the set of prereqs has been marked "finalized," and
  cannot be altered.
  
  =head2 finalize
  
  Calling C<finalize> on a Prereqs object will close it for further modification.
  Attempting to make any changes that would actually alter the prereqs will
  result in an exception being thrown.
  
  =head2 clone
  
    my $cloned_prereqs = $prereqs->clone;
  
  This method returns a Prereqs object that is identical to the original object,
  but can be altered without affecting the original object.  Finalization does
  not survive cloning, meaning that you may clone a finalized set of prereqs and
  then modify the clone.
  
  =head1 BUGS
  
  Please report any bugs or feature using the CPAN Request Tracker.
  Bugs can be submitted through the web interface at
  L<http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta>
  
  When submitting a bug or request, please include a test-file or a patch to an
  existing test-file that illustrates the bug or desired feature.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Adam Kennedy <adamk@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by David Golden, Ricardo Signes, Adam Kennedy and Contributors.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  # vim: ts=2 sts=2 sw=2 et :
CPAN_META_PREREQS

$fatpacked{"CPAN/Meta/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_SPEC';
  # XXX RULES FOR PATCHING THIS FILE XXX
  # Patches that fix typos or formatting are acceptable.  Patches
  # that change semantics are not acceptable without prior approval
  # by David Golden or Ricardo Signes.
  
  use 5.006;
  use strict;
  use warnings;
  package CPAN::Meta::Spec;
  
  our $VERSION = '2.150010';
  
  1;
  
  # ABSTRACT: specification for CPAN distribution metadata
  
  
  # vi:tw=72
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  CPAN::Meta::Spec - specification for CPAN distribution metadata
  
  =head1 VERSION
  
  version 2.150010
  
  =head1 SYNOPSIS
  
    my $distmeta = {
      name => 'Module-Build',
      abstract => 'Build and install Perl modules',
      description =>  "Module::Build is a system for "
        . "building, testing, and installing Perl modules. "
        . "It is meant to ... blah blah blah ...",
      version  => '0.36',
      release_status => 'stable',
      author   => [
        'Ken Williams <kwilliams@cpan.org>',
        'Module-Build List <module-build@perl.org>', # additional contact
      ],
      license  => [ 'perl_5' ],
      prereqs => {
        runtime => {
          requires => {
            'perl'   => '5.006',
            'ExtUtils::Install' => '0',
            'File::Basename' => '0',
            'File::Compare'  => '0',
            'IO::File'   => '0',
          },
          recommends => {
            'Archive::Tar' => '1.00',
            'ExtUtils::Install' => '0.3',
            'ExtUtils::ParseXS' => '2.02',
          },
        },
        build => {
          requires => {
            'Test::More' => '0',
          },
        }
      },
      resources => {
        license => ['http://dev.perl.org/licenses/'],
      },
      optional_features => {
        domination => {
          description => 'Take over the world',
          prereqs     => {
            develop => { requires => { 'Genius::Evil'     => '1.234' } },
            runtime => { requires => { 'Machine::Weather' => '2.0'   } },
          },
        },
      },
      dynamic_config => 1,
      keywords => [ qw/ toolchain cpan dual-life / ],
      'meta-spec' => {
        version => '2',
        url     => 'https://metacpan.org/pod/CPAN::Meta::Spec',
      },
      generated_by => 'Module::Build version 0.36',
    };
  
  =head1 DESCRIPTION
  
  This document describes version 2 of the CPAN distribution metadata
  specification, also known as the "CPAN Meta Spec".
  
  Revisions of this specification for typo corrections and prose
  clarifications may be issued as CPAN::Meta::Spec 2.I<x>.  These
  revisions will never change semantics or add or remove specified
  behavior.
  
  Distribution metadata describe important properties of Perl
  distributions. Distribution building tools like Module::Build,
  Module::Install, ExtUtils::MakeMaker or Dist::Zilla should create a
  metadata file in accordance with this specification and include it with
  the distribution for use by automated tools that index, examine, package
  or install Perl distributions.
  
  =head1 TERMINOLOGY
  
  =over 4
  
  =item distribution
  
  This is the primary object described by the metadata. In the context of
  this document it usually refers to a collection of modules, scripts,
  and/or documents that are distributed together for other developers to
  use.  Examples of distributions are C<Class-Container>, C<libwww-perl>,
  or C<DBI>.
  
  =item module
  
  This refers to a reusable library of code contained in a single file.
  Modules usually contain one or more packages and are often referred
  to by the name of a primary package that can be mapped to the file
  name. For example, one might refer to C<File::Spec> instead of
  F<File/Spec.pm>
  
  =item package
  
  This refers to a namespace declared with the Perl C<package> statement.
  In Perl, packages often have a version number property given by the
  C<$VERSION> variable in the namespace.
  
  =item consumer
  
  This refers to code that reads a metadata file, deserializes it into a
  data structure in memory, or interprets a data structure of metadata
  elements.
  
  =item producer
  
  This refers to code that constructs a metadata data structure,
  serializes into a bytestream and/or writes it to disk.
  
  =item must, should, may, etc.
  
  These terms are interpreted as described in IETF RFC 2119.
  
  =back
  
  =head1 DATA TYPES
  
  Fields in the L</STRUCTURE> section describe data elements, each of
  which has an associated data type as described herein.  There are four
  primitive types: Boolean, String, List and Map.  Other types are
  subtypes of primitives and define compound data structures or define
  constraints on the values of a data element.
  
  =head2 Boolean
  
  A I<Boolean> is used to provide a true or false value.  It B<must> be
  represented as a defined value that is either "1" or "0" or stringifies
  to those values.
  
  =head2 String
  
  A I<String> is data element containing a non-zero length sequence of
  Unicode characters, such as an ordinary Perl scalar that is not a
  reference.
  
  =head2 List
  
  A I<List> is an ordered collection of zero or more data elements.
  Elements of a List may be of mixed types.
  
  Producers B<must> represent List elements using a data structure which
  unambiguously indicates that multiple values are possible, such as a
  reference to a Perl array (an "arrayref").
  
  Consumers expecting a List B<must> consider a String as equivalent to a
  List of length 1.
  
  =head2 Map
  
  A I<Map> is an unordered collection of zero or more data elements
  ("values"), indexed by associated String elements ("keys").  The Map's
  value elements may be of mixed types.
  
  =head2 License String
  
  A I<License String> is a subtype of String with a restricted set of
  values.  Valid values are described in detail in the description of
  the L</license> field.
  
  =head2 URL
  
  I<URL> is a subtype of String containing a Uniform Resource Locator or
  Identifier.  [ This type is called URL and not URI for historical reasons. ]
  
  =head2 Version
  
  A I<Version> is a subtype of String containing a value that describes
  the version number of packages or distributions.  Restrictions on format
  are described in detail in the L</Version Formats> section.
  
  =head2 Version Range
  
  The I<Version Range> type is a subtype of String.  It describes a range
  of Versions that may be present or installed to fulfill prerequisites.
  It is specified in detail in the L</Version Ranges> section.
  
  =head1 STRUCTURE
  
  The metadata structure is a data element of type Map.  This section
  describes valid keys within the Map.
  
  Any keys not described in this specification document (whether top-level
  or within compound data structures described herein) are considered
  I<custom keys> and B<must> begin with an "x" or "X" and be followed by an
  underscore; i.e. they must match the pattern: C<< qr{\Ax_}i >>.  If a
  custom key refers to a compound data structure, subkeys within it do not
  need an "x_" or "X_" prefix.
  
  Consumers of metadata may ignore any or all custom keys.  All other keys
  not described herein are invalid and should be ignored by consumers.
  Producers must not generate or output invalid keys.
  
  For each key, an example is provided followed by a description.  The
  description begins with the version of spec in which the key was added
  or in which the definition was modified, whether the key is I<required>
  or I<optional> and the data type of the corresponding data element.
  These items are in parentheses, brackets and braces, respectively.
  
  If a data type is a Map or Map subtype, valid subkeys will be described
  as well.
  
  Some fields are marked I<Deprecated>.  These are shown for historical
  context and must not be produced in or consumed from any metadata structure
  of version 2 or higher.
  
  =head2 REQUIRED FIELDS
  
  =head3 abstract
  
  Example:
  
    abstract => 'Build and install Perl modules'
  
  (Spec 1.2) [required] {String}
  
  This is a short description of the purpose of the distribution.
  
  =head3 author
  
  Example:
  
    author => [ 'Ken Williams <kwilliams@cpan.org>' ]
  
  (Spec 1.2) [required] {List of one or more Strings}
  
  This List indicates the person(s) to contact concerning the
  distribution. The preferred form of the contact string is:
  
    contact-name <email-address>
  
  This field provides a general contact list independent of other
  structured fields provided within the L</resources> field, such as
  C<bugtracker>.  The addressee(s) can be contacted for any purpose
  including but not limited to (security) problems with the distribution,
  questions about the distribution or bugs in the distribution.
  
  A distribution's original author is usually the contact listed within
  this field.  Co-maintainers, successor maintainers or mailing lists
  devoted to the distribution may also be listed in addition to or instead
  of the original author.
  
  =head3 dynamic_config
  
  Example:
  
    dynamic_config => 1
  
  (Spec 2) [required] {Boolean}
  
  A boolean flag indicating whether a F<Build.PL> or F<Makefile.PL> (or
  similar) must be executed to determine prerequisites.
  
  This field should be set to a true value if the distribution performs
  some dynamic configuration (asking questions, sensing the environment,
  etc.) as part of its configuration.  This field should be set to a false
  value to indicate that prerequisites included in metadata may be
  considered final and valid for static analysis.
  
  Note: when this field is true, post-configuration prerequisites are not
  guaranteed to bear any relation whatsoever to those stated in the metadata,
  and relying on them doing so is an error. See also
  L</Prerequisites for dynamically configured distributions> in the implementors'
  notes.
  
  This field explicitly B<does not> indicate whether installation may be
  safely performed without using a Makefile or Build file, as there may be
  special files to install or custom installation targets (e.g. for
  dual-life modules that exist on CPAN as well as in the Perl core).  This
  field only defines whether or not prerequisites are exactly as given in the
  metadata.
  
  =head3 generated_by
  
  Example:
  
    generated_by => 'Module::Build version 0.36'
  
  (Spec 1.0) [required] {String}
  
  This field indicates the tool that was used to create this metadata.
  There are no defined semantics for this field, but it is traditional to
  use a string in the form "Generating::Package version 1.23" or the
  author's name, if the file was generated by hand.
  
  =head3 license
  
  Example:
  
    license => [ 'perl_5' ]
  
    license => [ 'apache_2_0', 'mozilla_1_0' ]
  
  (Spec 2) [required] {List of one or more License Strings}
  
  One or more licenses that apply to some or all of the files in the
  distribution.  If multiple licenses are listed, the distribution
  documentation should be consulted to clarify the interpretation of
  multiple licenses.
  
  The following list of license strings are valid:
  
   string          description
   -------------   -----------------------------------------------
   agpl_3          GNU Affero General Public License, Version 3
   apache_1_1      Apache Software License, Version 1.1
   apache_2_0      Apache License, Version 2.0
   artistic_1      Artistic License, (Version 1)
   artistic_2      Artistic License, Version 2.0
   bsd             BSD License (three-clause)
   freebsd         FreeBSD License (two-clause)
   gfdl_1_2        GNU Free Documentation License, Version 1.2
   gfdl_1_3        GNU Free Documentation License, Version 1.3
   gpl_1           GNU General Public License, Version 1
   gpl_2           GNU General Public License, Version 2
   gpl_3           GNU General Public License, Version 3
   lgpl_2_1        GNU Lesser General Public License, Version 2.1
   lgpl_3_0        GNU Lesser General Public License, Version 3.0
   mit             MIT (aka X11) License
   mozilla_1_0     Mozilla Public License, Version 1.0
   mozilla_1_1     Mozilla Public License, Version 1.1
   openssl         OpenSSL License
   perl_5          The Perl 5 License (Artistic 1 & GPL 1 or later)
   qpl_1_0         Q Public License, Version 1.0
   ssleay          Original SSLeay License
   sun             Sun Internet Standards Source License (SISSL)
   zlib            zlib License
  
  The following license strings are also valid and indicate other
  licensing not described above:
  
   string          description
   -------------   -----------------------------------------------
   open_source     Other Open Source Initiative (OSI) approved license
   restricted      Requires special permission from copyright holder
   unrestricted    Not an OSI approved license, but not restricted
   unknown         License not provided in metadata
  
  All other strings are invalid in the license field.
  
  =head3 meta-spec
  
  Example:
  
    'meta-spec' => {
      version => '2',
      url     => 'http://search.cpan.org/perldoc?CPAN::Meta::Spec',
    }
  
  (Spec 1.2) [required] {Map}
  
  This field indicates the version of the CPAN Meta Spec that should be
  used to interpret the metadata.  Consumers must check this key as soon
  as possible and abort further metadata processing if the meta-spec
  version is not supported by the consumer.
  
  The following keys are valid, but only C<version> is required.
  
  =over
  
  =item version
  
  This subkey gives the integer I<Version> of the CPAN Meta Spec against
  which the document was generated.
  
  =item url
  
  This is a I<URL> of the metadata specification document corresponding to
  the given version.  This is strictly for human-consumption and should
  not impact the interpretation of the document.
  
  For the version 2 spec, either of these are recommended:
  
  =over 4
  
  =item *
  
  C<https://metacpan.org/pod/CPAN::Meta::Spec>
  
  =item *
  
  C<http://search.cpan.org/perldoc?CPAN::Meta::Spec>
  
  =back
  
  =back
  
  =head3 name
  
  Example:
  
    name => 'Module-Build'
  
  (Spec 1.0) [required] {String}
  
  This field is the name of the distribution.  This is often created by
  taking the "main package" in the distribution and changing C<::> to
  C<->, but the name may be completely unrelated to the packages within
  the distribution.  For example, L<LWP::UserAgent> is distributed as part
  of the distribution name "libwww-perl".
  
  =head3 release_status
  
  Example:
  
    release_status => 'stable'
  
  (Spec 2) [required] {String}
  
  This field provides the  release status of this distribution.  If the
  C<version> field contains an underscore character, then
  C<release_status> B<must not> be "stable."
  
  The C<release_status> field B<must> have one of the following values:
  
  =over
  
  =item stable
  
  This indicates an ordinary, "final" release that should be indexed by PAUSE
  or other indexers.
  
  =item testing
  
  This indicates a "beta" release that is substantially complete, but has an
  elevated risk of bugs and requires additional testing.  The distribution
  should not be installed over a stable release without an explicit request
  or other confirmation from a user.  This release status may also be used
  for "release candidate" versions of a distribution.
  
  =item unstable
  
  This indicates an "alpha" release that is under active development, but has
  been released for early feedback or testing and may be missing features or
  may have serious bugs.  The distribution should not be installed over a
  stable release without an explicit request or other confirmation from a
  user.
  
  =back
  
  Consumers B<may> use this field to determine how to index the
  distribution for CPAN or other repositories in addition to or in
  replacement of heuristics based on version number or file name.
  
  =head3 version
  
  Example:
  
    version => '0.36'
  
  (Spec 1.0) [required] {Version}
  
  This field gives the version of the distribution to which the metadata
  structure refers.
  
  =head2 OPTIONAL FIELDS
  
  =head3 description
  
  Example:
  
      description =>  "Module::Build is a system for "
        . "building, testing, and installing Perl modules. "
        . "It is meant to ... blah blah blah ...",
  
  (Spec 2) [optional] {String}
  
  A longer, more complete description of the purpose or intended use of
  the distribution than the one provided by the C<abstract> key.
  
  =head3 keywords
  
  Example:
  
    keywords => [ qw/ toolchain cpan dual-life / ]
  
  (Spec 1.1) [optional] {List of zero or more Strings}
  
  A List of keywords that describe this distribution.  Keywords
  B<must not> include whitespace.
  
  =head3 no_index
  
  Example:
  
    no_index => {
      file      => [ 'My/Module.pm' ],
      directory => [ 'My/Private' ],
      package   => [ 'My::Module::Secret' ],
      namespace => [ 'My::Module::Sample' ],
    }
  
  (Spec 1.2) [optional] {Map}
  
  This Map describes any files, directories, packages, and namespaces that
  are private to the packaging or implementation of the distribution and
  should be ignored by indexing or search tools. Note that this is a list of
  exclusions, and the spec does not define what to I<include> - see
  L</Indexing distributions a la PAUSE> in the implementors notes for more
  information.
  
  Valid subkeys are as follows:
  
  =over
  
  =item file
  
  A I<List> of relative paths to files.  Paths B<must be> specified with
  unix conventions.
  
  =item directory
  
  A I<List> of relative paths to directories.  Paths B<must be> specified
  with unix conventions.
  
  [ Note: previous editions of the spec had C<dir> instead of C<directory> ]
  
  =item package
  
  A I<List> of package names.
  
  =item namespace
  
  A I<List> of package namespaces, where anything below the namespace
  must be ignored, but I<not> the namespace itself.
  
  In the example above for C<no_index>, C<My::Module::Sample::Foo> would
  be ignored, but C<My::Module::Sample> would not.
  
  =back
  
  =head3 optional_features
  
  Example:
  
    optional_features => {
      sqlite => {
        description => 'Provides SQLite support',
        prereqs => {
          runtime => {
            requires => {
              'DBD::SQLite' => '1.25'
            }
          }
        }
      }
    }
  
  (Spec 2) [optional] {Map}
  
  This Map describes optional features with incremental prerequisites.
  Each key of the C<optional_features> Map is a String used to identify
  the feature and each value is a Map with additional information about
  the feature.  Valid subkeys include:
  
  =over
  
  =item description
  
  This is a String describing the feature.  Every optional feature
  should provide a description
  
  =item prereqs
  
  This entry is required and has the same structure as that of the
  C<L</prereqs>> key.  It provides a list of package requirements
  that must be satisfied for the feature to be supported or enabled.
  
  There is one crucial restriction:  the prereqs of an optional feature
  B<must not> include C<configure> phase prereqs.
  
  =back
  
  Consumers B<must not> include optional features as prerequisites without
  explicit instruction from users (whether via interactive prompting,
  a function parameter or a configuration value, etc. ).
  
  If an optional feature is used by a consumer to add additional
  prerequisites, the consumer should merge the optional feature
  prerequisites into those given by the C<prereqs> key using the same
  semantics.  See L</Merging and Resolving Prerequisites> for details on
  merging prerequisites.
  
  I<Suggestion for disuse:> Because there is currently no way for a
  distribution to specify a dependency on an optional feature of another
  dependency, the use of C<optional_feature> is discouraged.  Instead,
  create a separate, installable distribution that ensures the desired
  feature is available.  For example, if C<Foo::Bar> has a C<Baz> feature,
  release a separate C<Foo-Bar-Baz> distribution that satisfies
  requirements for the feature.
  
  =head3 prereqs
  
  Example:
  
    prereqs => {
      runtime => {
        requires => {
          'perl'          => '5.006',
          'File::Spec'    => '0.86',
          'JSON'          => '2.16',
        },
        recommends => {
          'JSON::XS'      => '2.26',
        },
        suggests => {
          'Archive::Tar'  => '0',
        },
      },
      build => {
        requires => {
          'Alien::SDL'    => '1.00',
        },
      },
      test => {
        recommends => {
          'Test::Deep'    => '0.10',
        },
      }
    }
  
  (Spec 2) [optional] {Map}
  
  This is a Map that describes all the prerequisites of the distribution.
  The keys are phases of activity, such as C<configure>, C<build>, C<test>
  or C<runtime>.  Values are Maps in which the keys name the type of
  prerequisite relationship such as C<requires>, C<recommends>, or
  C<suggests> and the value provides a set of prerequisite relations.  The
  set of relations B<must> be specified as a Map of package names to
  version ranges.
  
  The full definition for this field is given in the L</Prereq Spec>
  section.
  
  =head3 provides
  
  Example:
  
    provides => {
      'Foo::Bar' => {
        file    => 'lib/Foo/Bar.pm',
        version => '0.27_02',
      },
      'Foo::Bar::Blah' => {
        file    => 'lib/Foo/Bar/Blah.pm',
      },
      'Foo::Bar::Baz' => {
        file    => 'lib/Foo/Bar/Baz.pm',
        version => '0.3',
      },
    }
  
  (Spec 1.2) [optional] {Map}
  
  This describes all packages provided by this distribution.  This
  information is used by distribution and automation mechanisms like
  PAUSE, CPAN, metacpan.org and search.cpan.org to build indexes saying in
  which distribution various packages can be found.
  
  The keys of C<provides> are package names that can be found within
  the distribution.  If a package name key is provided, it must
  have a Map with the following valid subkeys:
  
  =over
  
  =item file
  
  This field is required.  It must contain a Unix-style relative file path
  from the root of the distribution directory to a file that contains or
  generates the package.  It may be given as C<META.yml> or C<META.json>
  to claim a package for indexing without needing a C<*.pm>.
  
  =item version
  
  If it exists, this field must contains a I<Version> String for the
  package.  If the package does not have a C<$VERSION>, this field must
  be omitted.
  
  =back
  
  =head3 resources
  
  Example:
  
    resources => {
      license     => [ 'http://dev.perl.org/licenses/' ],
      homepage    => 'http://sourceforge.net/projects/module-build',
      bugtracker  => {
        web    => 'http://rt.cpan.org/Public/Dist/Display.html?Name=CPAN-Meta',
        mailto => 'meta-bugs@example.com',
      },
      repository  => {
        url  => 'git://github.com/dagolden/cpan-meta.git',
        web  => 'http://github.com/dagolden/cpan-meta',
        type => 'git',
      },
      x_twitter   => 'http://twitter.com/cpan_linked/',
    }
  
  (Spec 2) [optional] {Map}
  
  This field describes resources related to this distribution.
  
  Valid subkeys include:
  
  =over
  
  =item homepage
  
  The official home of this project on the web.
  
  =item license
  
  A List of I<URL>'s that relate to this distribution's license.  As with the
  top-level C<license> field, distribution documentation should be consulted
  to clarify the interpretation of multiple licenses provided here.
  
  =item bugtracker
  
  This entry describes the bug tracking system for this distribution.  It
  is a Map with the following valid keys:
  
    web    - a URL pointing to a web front-end for the bug tracker
    mailto - an email address to which bugs can be sent
  
  =item repository
  
  This entry describes the source control repository for this distribution.  It
  is a Map with the following valid keys:
  
    url  - a URL pointing to the repository itself
    web  - a URL pointing to a web front-end for the repository
    type - a lowercase string indicating the VCS used
  
  Because a url like C<http://myrepo.example.com/> is ambiguous as to
  type, producers should provide a C<type> whenever a C<url> key is given.
  The C<type> field should be the name of the most common program used
  to work with the repository, e.g. C<git>, C<svn>, C<cvs>, C<darcs>,
  C<bzr> or C<hg>.
  
  =back
  
  =head2 DEPRECATED FIELDS
  
  =head3 build_requires
  
  I<(Deprecated in Spec 2)> [optional] {String}
  
  Replaced by C<prereqs>
  
  =head3 configure_requires
  
  I<(Deprecated in Spec 2)> [optional] {String}
  
  Replaced by C<prereqs>
  
  =head3 conflicts
  
  I<(Deprecated in Spec 2)> [optional] {String}
  
  Replaced by C<prereqs>
  
  =head3 distribution_type
  
  I<(Deprecated in Spec 2)> [optional] {String}
  
  This field indicated 'module' or 'script' but was considered
  meaningless, since many distributions are hybrids of several kinds of
  things.
  
  =head3 license_uri
  
  I<(Deprecated in Spec 1.2)> [optional] {URL}
  
  Replaced by C<license> in C<resources>
  
  =head3 private
  
  I<(Deprecated in Spec 1.2)> [optional] {Map}
  
  This field has been renamed to L</"no_index">.
  
  =head3 recommends
  
  I<(Deprecated in Spec 2)> [optional] {String}
  
  Replaced by C<prereqs>
  
  =head3 requires
  
  I<(Deprecated in Spec 2)> [optional] {String}
  
  Replaced by C<prereqs>
  
  =head1 VERSION NUMBERS
  
  =head2 Version Formats
  
  This section defines the Version type, used by several fields in the
  CPAN Meta Spec.
  
  Version numbers must be treated as strings, not numbers.  For
  example, C<1.200> B<must not> be serialized as C<1.2>.  Version
  comparison should be delegated to the Perl L<version> module, version
  0.80 or newer.
  
  Unless otherwise specified, version numbers B<must> appear in one of two
  formats:
  
  =over
  
  =item Decimal versions
  
  Decimal versions are regular "decimal numbers", with some limitations.
  They B<must> be non-negative and B<must> begin and end with a digit.  A
  single underscore B<may> be included, but B<must> be between two digits.
  They B<must not> use exponential notation ("1.23e-2").
  
     version => '1.234'       # OK
     version => '1.23_04'     # OK
  
     version => '1.23_04_05'  # Illegal
     version => '1.'          # Illegal
     version => '.1'          # Illegal
  
  =item Dotted-integer versions
  
  Dotted-integer (also known as dotted-decimal) versions consist of
  positive integers separated by full stop characters (i.e. "dots",
  "periods" or "decimal points").  This are equivalent in format to Perl
  "v-strings", with some additional restrictions on form.  They must be
  given in "normal" form, which has a leading "v" character and at least
  three integer components.  To retain a one-to-one mapping with decimal
  versions, all components after the first B<should> be restricted to the
  range 0 to 999.  The final component B<may> be separated by an
  underscore character instead of a period.
  
     version => 'v1.2.3'      # OK
     version => 'v1.2_3'      # OK
     version => 'v1.2.3.4'    # OK
     version => 'v1.2.3_4'    # OK
     version => 'v2009.10.31' # OK
  
     version => 'v1.2'          # Illegal
     version => '1.2.3'         # Illegal
     version => 'v1.2_3_4'      # Illegal
     version => 'v1.2009.10.31' # Not recommended
  
  =back
  
  =head2 Version Ranges
  
  Some fields (prereq, optional_features) indicate the particular
  version(s) of some other module that may be required as a prerequisite.
  This section details the Version Range type used to provide this
  information.
  
  The simplest format for a Version Range is just the version
  number itself, e.g. C<2.4>.  This means that B<at least> version 2.4
  must be present.  To indicate that B<any> version of a prerequisite is
  okay, even if the prerequisite doesn't define a version at all, use
  the version C<0>.
  
  Alternatively, a version range B<may> use the operators E<lt> (less than),
  E<lt>= (less than or equal), E<gt> (greater than), E<gt>= (greater than
  or equal), == (equal), and != (not equal).  For example, the
  specification C<E<lt> 2.0> means that any version of the prerequisite
  less than 2.0 is suitable.
  
  For more complicated situations, version specifications B<may> be AND-ed
  together using commas.  The specification C<E<gt>= 1.2, != 1.5, E<lt>
  2.0> indicates a version that must be B<at least> 1.2, B<less than> 2.0,
  and B<not equal to> 1.5.
  
  =head1 PREREQUISITES
  
  =head2 Prereq Spec
  
  The C<prereqs> key in the top-level metadata and within
  C<optional_features> define the relationship between a distribution and
  other packages.  The prereq spec structure is a hierarchical data
  structure which divides prerequisites into I<Phases> of activity in the
  installation process and I<Relationships> that indicate how
  prerequisites should be resolved.
  
  For example, to specify that C<Data::Dumper> is C<required> during the
  C<test> phase, this entry would appear in the distribution metadata:
  
    prereqs => {
      test => {
        requires => {
          'Data::Dumper' => '2.00'
        }
      }
    }
  
  =head3 Phases
  
  Requirements for regular use must be listed in the C<runtime> phase.
  Other requirements should be listed in the earliest stage in which they
  are required and consumers must accumulate and satisfy requirements
  across phases before executing the activity. For example, C<build>
  requirements must also be available during the C<test> phase.
  
    before action       requirements that must be met
    ----------------    --------------------------------
    perl Build.PL       configure
    perl Makefile.PL
  
    make                configure, runtime, build
    Build
  
    make test           configure, runtime, build, test
    Build test
  
  Consumers that install the distribution must ensure that
  I<runtime> requirements are also installed and may install
  dependencies from other phases.
  
    after action        requirements that must be met
    ----------------    --------------------------------
    make install        runtime
    Build install
  
  =over
  
  =item configure
  
  The configure phase occurs before any dynamic configuration has been
  attempted.  Libraries required by the configure phase B<must> be
  available for use before the distribution building tool has been
  executed.
  
  =item build
  
  The build phase is when the distribution's source code is compiled (if
  necessary) and otherwise made ready for installation.
  
  =item test
  
  The test phase is when the distribution's automated test suite is run.
  Any library that is needed only for testing and not for subsequent use
  should be listed here.
  
  =item runtime
  
  The runtime phase refers not only to when the distribution's contents
  are installed, but also to its continued use.  Any library that is a
  prerequisite for regular use of this distribution should be indicated
  here.
  
  =item develop
  
  The develop phase's prereqs are libraries needed to work on the
  distribution's source code as its author does.  These tools might be
  needed to build a release tarball, to run author-only tests, or to
  perform other tasks related to developing new versions of the
  distribution.
  
  =back
  
  =head3 Relationships
  
  =over
  
  =item requires
  
  These dependencies B<must> be installed for proper completion of the
  phase.
  
  =item recommends
  
  Recommended dependencies are I<strongly> encouraged and should be
  satisfied except in resource constrained environments.
  
  =item suggests
  
  These dependencies are optional, but are suggested for enhanced operation
  of the described distribution.
  
  =item conflicts
  
  These libraries cannot be installed when the phase is in operation.
  This is a very rare situation, and the C<conflicts> relationship should
  be used with great caution, or not at all.
  
  =back
  
  =head2 Merging and Resolving Prerequisites
  
  Whenever metadata consumers merge prerequisites, either from different
  phases or from C<optional_features>, they should merged in a way which
  preserves the intended semantics of the prerequisite structure.  Generally,
  this means concatenating the version specifications using commas, as
  described in the L<Version Ranges> section.
  
  Another subtle error that can occur in resolving prerequisites comes from
  the way that modules in prerequisites are indexed to distribution files on
  CPAN.  When a module is deleted from a distribution, prerequisites calling
  for that module could indicate an older distribution should be installed,
  potentially overwriting files from a newer distribution.
  
  For example, as of Oct 31, 2009, the CPAN index file contained these
  module-distribution mappings:
  
    Class::MOP                   0.94  D/DR/DROLSKY/Class-MOP-0.94.tar.gz
    Class::MOP::Class            0.94  D/DR/DROLSKY/Class-MOP-0.94.tar.gz
    Class::MOP::Class::Immutable 0.04  S/ST/STEVAN/Class-MOP-0.36.tar.gz
  
  Consider the case where "Class::MOP" 0.94 is installed.  If a
  distribution specified "Class::MOP::Class::Immutable" as a prerequisite,
  it could result in Class-MOP-0.36.tar.gz being installed, overwriting
  any files from Class-MOP-0.94.tar.gz.
  
  Consumers of metadata B<should> test whether prerequisites would result
  in installed module files being "downgraded" to an older version and
  B<may> warn users or ignore the prerequisite that would cause such a
  result.
  
  =head1 SERIALIZATION
  
  Distribution metadata should be serialized (as a hashref) as
  JSON-encoded data and packaged with distributions as the file
  F<META.json>.
  
  In the past, the distribution metadata structure had been packed with
  distributions as F<META.yml>, a file in the YAML Tiny format (for which,
  see L<YAML::Tiny>).  Tools that consume distribution metadata from disk
  should be capable of loading F<META.yml>, but should prefer F<META.json>
  if both are found.
  
  =head1 NOTES FOR IMPLEMENTORS
  
  =head2 Extracting Version Numbers from Perl Modules
  
  To get the version number from a Perl module, consumers should use the
  C<< MM->parse_version($file) >> method provided by
  L<ExtUtils::MakeMaker> or L<Module::Metadata>.  For example, for the
  module given by C<$mod>, the version may be retrieved in one of the
  following ways:
  
    # via ExtUtils::MakeMaker
    my $file = MM->_installed_file_for_module($mod);
    my $version = MM->parse_version($file)
  
  The private C<_installed_file_for_module> method may be replaced with
  other methods for locating a module in C<@INC>.
  
    # via Module::Metadata
    my $info = Module::Metadata->new_from_module($mod);
    my $version = $info->version;
  
  If only a filename is available, the following approach may be used:
  
    # via Module::Build
    my $info = Module::Metadata->new_from_file($file);
    my $version = $info->version;
  
  =head2 Comparing Version Numbers
  
  The L<version> module provides the most reliable way to compare version
  numbers in all the various ways they might be provided or might exist
  within modules.  Given two strings containing version numbers, C<$v1> and
  C<$v2>, they should be converted to C<version> objects before using
  ordinary comparison operators.  For example:
  
    use version;
    if ( version->new($v1) <=> version->new($v2) ) {
      print "Versions are not equal\n";
    }
  
  If the only comparison needed is whether an installed module is of a
  sufficiently high version, a direct test may be done using the string
  form of C<eval> and the C<use> function.  For example, for module C<$mod>
  and version prerequisite C<$prereq>:
  
    if ( eval "use $mod $prereq (); 1" ) {
      print "Module $mod version is OK.\n";
    }
  
  If the values of C<$mod> and C<$prereq> have not been scrubbed, however,
  this presents security implications.
  
  =head2 Prerequisites for dynamically configured distributions
  
  When C<dynamic_config> is true, it is an error to presume that the
  prerequisites given in distribution metadata will have any relationship
  whatsoever to the actual prerequisites of the distribution.
  
  In practice, however, one can generally expect such prerequisites to be
  one of two things:
  
  =over 4
  
  =item *
  
  The minimum prerequisites for the distribution, to which dynamic configuration will only add items
  
  =item *
  
  Whatever the distribution configured with on the releaser's machine at release time
  
  =back
  
  The second case often turns out to have identical results to the first case,
  albeit only by accident.
  
  As such, consumers may use this data for informational analysis, but
  presenting it to the user as canonical or relying on it as such is
  invariably the height of folly.
  
  =head2 Indexing distributions a la PAUSE
  
  While no_index tells you what must be ignored when indexing, this spec holds
  no opinion on how you should get your initial candidate list of things to
  possibly index. For "normal" distributions you might consider simply indexing
  the contents of lib/, but there are many fascinating oddities on CPAN and
  many dists from the days when it was normal to put the main .pm file in the
  root of the distribution archive - so PAUSE currently indexes all .pm and .PL
  files that are not either (a) specifically excluded by no_index (b) in
  C<inc>, C<xt>, or C<t> directories, or common 'mistake' directories such as
  C<perl5>.
  
  Or: If you're trying to be PAUSE-like, make sure you skip C<inc>, C<xt> and
  C<t> as well as anything marked as no_index.
  
  Also remember: If the META file contains a provides field, you shouldn't be
  indexing anything in the first place - just use that.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  CPAN, L<http://www.cpan.org/>
  
  =item *
  
  JSON, L<http://json.org/>
  
  =item *
  
  YAML, L<http://www.yaml.org/>
  
  =item *
  
  L<CPAN>
  
  =item *
  
  L<CPANPLUS>
  
  =item *
  
  L<ExtUtils::MakeMaker>
  
  =item *
  
  L<Module::Build>
  
  =item *
  
  L<Module::Install>
  
  =item *
  
  L<CPAN::Meta::History::Meta_1_4>
  
  =back
  
  =head1 HISTORY
  
  Ken Williams wrote the original CPAN Meta Spec (also known as the
  "META.yml spec") in 2003 and maintained it through several revisions
  with input from various members of the community.  In 2005, Randy
  Sims redrafted it from HTML to POD for the version 1.2 release.  Ken
  continued to maintain the spec through version 1.4.
  
  In late 2009, David Golden organized the version 2 proposal review
  process.  David and Ricardo Signes drafted the final version 2 spec
  in April 2010 based on the version 1.4 spec and patches contributed
  during the proposal process.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Adam Kennedy <adamk@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by David Golden, Ricardo Signes, Adam Kennedy and Contributors.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
CPAN_META_SPEC

$fatpacked{"CPAN/Meta/Validator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_VALIDATOR';
  use 5.006;
  use strict;
  use warnings;
  package CPAN::Meta::Validator;
  
  our $VERSION = '2.150010';
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   my $struct = decode_json_file('META.json');
  #pod
  #pod   my $cmv = CPAN::Meta::Validator->new( $struct );
  #pod
  #pod   unless ( $cmv->is_valid ) {
  #pod     my $msg = "Invalid META structure.  Errors found:\n";
  #pod     $msg .= join( "\n", $cmv->errors );
  #pod     die $msg;
  #pod   }
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This module validates a CPAN Meta structure against the version of the
  #pod the specification claimed in the C<meta-spec> field of the structure.
  #pod
  #pod =cut
  
  #--------------------------------------------------------------------------#
  # This code copied and adapted from Test::CPAN::Meta
  # by Barbie, <barbie@cpan.org> for Miss Barbell Productions,
  # L<http://www.missbarbell.co.uk>
  #--------------------------------------------------------------------------#
  
  #--------------------------------------------------------------------------#
  # Specification Definitions
  #--------------------------------------------------------------------------#
  
  my %known_specs = (
      '1.4' => 'http://module-build.sourceforge.net/META-spec-v1.4.html',
      '1.3' => 'http://module-build.sourceforge.net/META-spec-v1.3.html',
      '1.2' => 'http://module-build.sourceforge.net/META-spec-v1.2.html',
      '1.1' => 'http://module-build.sourceforge.net/META-spec-v1.1.html',
      '1.0' => 'http://module-build.sourceforge.net/META-spec-v1.0.html'
  );
  my %known_urls = map {$known_specs{$_} => $_} keys %known_specs;
  
  my $module_map1 = { 'map' => { ':key' => { name => \&module, value => \&exversion } } };
  
  my $module_map2 = { 'map' => { ':key' => { name => \&module, value => \&version   } } };
  
  my $no_index_2 = {
      'map'       => { file       => { list => { value => \&string } },
                       directory  => { list => { value => \&string } },
                       'package'  => { list => { value => \&string } },
                       namespace  => { list => { value => \&string } },
                      ':key'      => { name => \&custom_2, value => \&anything },
      }
  };
  
  my $no_index_1_3 = {
      'map'       => { file       => { list => { value => \&string } },
                       directory  => { list => { value => \&string } },
                       'package'  => { list => { value => \&string } },
                       namespace  => { list => { value => \&string } },
                       ':key'     => { name => \&string, value => \&anything },
      }
  };
  
  my $no_index_1_2 = {
      'map'       => { file       => { list => { value => \&string } },
                       dir        => { list => { value => \&string } },
                       'package'  => { list => { value => \&string } },
                       namespace  => { list => { value => \&string } },
                       ':key'     => { name => \&string, value => \&anything },
      }
  };
  
  my $no_index_1_1 = {
      'map'       => { ':key'     => { name => \&string, list => { value => \&string } },
      }
  };
  
  my $prereq_map = {
    map => {
      ':key' => {
        name => \&phase,
        'map' => {
          ':key'  => {
            name => \&relation,
            %$module_map1,
          },
        },
      }
    },
  };
  
  my %definitions = (
    '2' => {
      # REQUIRED
      'abstract'            => { mandatory => 1, value => \&string  },
      'author'              => { mandatory => 1, list => { value => \&string } },
      'dynamic_config'      => { mandatory => 1, value => \&boolean },
      'generated_by'        => { mandatory => 1, value => \&string  },
      'license'             => { mandatory => 1, list => { value => \&license } },
      'meta-spec' => {
        mandatory => 1,
        'map' => {
          version => { mandatory => 1, value => \&version},
          url     => { value => \&url },
          ':key' => { name => \&custom_2, value => \&anything },
        }
      },
      'name'                => { mandatory => 1, value => \&string  },
      'release_status'      => { mandatory => 1, value => \&release_status },
      'version'             => { mandatory => 1, value => \&version },
  
      # OPTIONAL
      'description' => { value => \&string },
      'keywords'    => { list => { value => \&string } },
      'no_index'    => $no_index_2,
      'optional_features'   => {
        'map'       => {
          ':key'  => {
            name => \&string,
            'map'   => {
              description        => { value => \&string },
              prereqs => $prereq_map,
              ':key' => { name => \&custom_2, value => \&anything },
            }
          }
        }
      },
      'prereqs' => $prereq_map,
      'provides'    => {
        'map'       => {
          ':key' => {
            name  => \&module,
            'map' => {
              file    => { mandatory => 1, value => \&file },
              version => { value => \&version },
              ':key' => { name => \&custom_2, value => \&anything },
            }
          }
        }
      },
      'resources'   => {
        'map'       => {
          license    => { list => { value => \&url } },
          homepage   => { value => \&url },
          bugtracker => {
            'map' => {
              web => { value => \&url },
              mailto => { value => \&string},
              ':key' => { name => \&custom_2, value => \&anything },
            }
          },
          repository => {
            'map' => {
              web => { value => \&url },
              url => { value => \&url },
              type => { value => \&string },
              ':key' => { name => \&custom_2, value => \&anything },
            }
          },
          ':key'     => { value => \&string, name => \&custom_2 },
        }
      },
  
      # CUSTOM -- additional user defined key/value pairs
      # note we can only validate the key name, as the structure is user defined
      ':key'        => { name => \&custom_2, value => \&anything },
    },
  
  '1.4' => {
    'meta-spec'           => {
      mandatory => 1,
      'map' => {
        version => { mandatory => 1, value => \&version},
        url     => { mandatory => 1, value => \&urlspec },
        ':key'  => { name => \&string, value => \&anything },
      },
    },
  
    'name'                => { mandatory => 1, value => \&string  },
    'version'             => { mandatory => 1, value => \&version },
    'abstract'            => { mandatory => 1, value => \&string  },
    'author'              => { mandatory => 1, list  => { value => \&string } },
    'license'             => { mandatory => 1, value => \&license },
    'generated_by'        => { mandatory => 1, value => \&string  },
  
    'distribution_type'   => { value => \&string  },
    'dynamic_config'      => { value => \&boolean },
  
    'requires'            => $module_map1,
    'recommends'          => $module_map1,
    'build_requires'      => $module_map1,
    'configure_requires'  => $module_map1,
    'conflicts'           => $module_map2,
  
    'optional_features'   => {
      'map'       => {
          ':key'  => { name => \&string,
              'map'   => { description        => { value => \&string },
                           requires           => $module_map1,
                           recommends         => $module_map1,
                           build_requires     => $module_map1,
                           conflicts          => $module_map2,
                           ':key'  => { name => \&string, value => \&anything },
              }
          }
       }
    },
  
    'provides'    => {
      'map'       => {
        ':key' => { name  => \&module,
          'map' => {
            file    => { mandatory => 1, value => \&file },
            version => { value => \&version },
            ':key'  => { name => \&string, value => \&anything },
          }
        }
      }
    },
  
    'no_index'    => $no_index_1_3,
    'private'     => $no_index_1_3,
  
    'keywords'    => { list => { value => \&string } },
  
    'resources'   => {
      'map'       => { license    => { value => \&url },
                       homepage   => { value => \&url },
                       bugtracker => { value => \&url },
                       repository => { value => \&url },
                       ':key'     => { value => \&string, name => \&custom_1 },
      }
    },
  
    # additional user defined key/value pairs
    # note we can only validate the key name, as the structure is user defined
    ':key'        => { name => \&string, value => \&anything },
  },
  
  '1.3' => {
    'meta-spec'           => {
      mandatory => 1,
      'map' => {
        version => { mandatory => 1, value => \&version},
        url     => { mandatory => 1, value => \&urlspec },
        ':key'  => { name => \&string, value => \&anything },
      },
    },
  
    'name'                => { mandatory => 1, value => \&string  },
    'version'             => { mandatory => 1, value => \&version },
    'abstract'            => { mandatory => 1, value => \&string  },
    'author'              => { mandatory => 1, list  => { value => \&string } },
    'license'             => { mandatory => 1, value => \&license },
    'generated_by'        => { mandatory => 1, value => \&string  },
  
    'distribution_type'   => { value => \&string  },
    'dynamic_config'      => { value => \&boolean },
  
    'requires'            => $module_map1,
    'recommends'          => $module_map1,
    'build_requires'      => $module_map1,
    'conflicts'           => $module_map2,
  
    'optional_features'   => {
      'map'       => {
          ':key'  => { name => \&string,
              'map'   => { description        => { value => \&string },
                           requires           => $module_map1,
                           recommends         => $module_map1,
                           build_requires     => $module_map1,
                           conflicts          => $module_map2,
                           ':key'  => { name => \&string, value => \&anything },
              }
          }
       }
    },
  
    'provides'    => {
      'map'       => {
        ':key' => { name  => \&module,
          'map' => {
            file    => { mandatory => 1, value => \&file },
            version => { value => \&version },
            ':key'  => { name => \&string, value => \&anything },
          }
        }
      }
    },
  
  
    'no_index'    => $no_index_1_3,
    'private'     => $no_index_1_3,
  
    'keywords'    => { list => { value => \&string } },
  
    'resources'   => {
      'map'       => { license    => { value => \&url },
                       homepage   => { value => \&url },
                       bugtracker => { value => \&url },
                       repository => { value => \&url },
                       ':key'     => { value => \&string, name => \&custom_1 },
      }
    },
  
    # additional user defined key/value pairs
    # note we can only validate the key name, as the structure is user defined
    ':key'        => { name => \&string, value => \&anything },
  },
  
  # v1.2 is misleading, it seems to assume that a number of fields where created
  # within v1.1, when they were created within v1.2. This may have been an
  # original mistake, and that a v1.1 was retro fitted into the timeline, when
  # v1.2 was originally slated as v1.1. But I could be wrong ;)
  '1.2' => {
    'meta-spec'           => {
      mandatory => 1,
      'map' => {
        version => { mandatory => 1, value => \&version},
        url     => { mandatory => 1, value => \&urlspec },
        ':key'  => { name => \&string, value => \&anything },
      },
    },
  
  
    'name'                => { mandatory => 1, value => \&string  },
    'version'             => { mandatory => 1, value => \&version },
    'license'             => { mandatory => 1, value => \&license },
    'generated_by'        => { mandatory => 1, value => \&string  },
    'author'              => { mandatory => 1, list => { value => \&string } },
    'abstract'            => { mandatory => 1, value => \&string  },
  
    'distribution_type'   => { value => \&string  },
    'dynamic_config'      => { value => \&boolean },
  
    'keywords'            => { list => { value => \&string } },
  
    'private'             => $no_index_1_2,
    '$no_index'           => $no_index_1_2,
  
    'requires'            => $module_map1,
    'recommends'          => $module_map1,
    'build_requires'      => $module_map1,
    'conflicts'           => $module_map2,
  
    'optional_features'   => {
      'map'       => {
          ':key'  => { name => \&string,
              'map'   => { description        => { value => \&string },
                           requires           => $module_map1,
                           recommends         => $module_map1,
                           build_requires     => $module_map1,
                           conflicts          => $module_map2,
                           ':key'  => { name => \&string, value => \&anything },
              }
          }
       }
    },
  
    'provides'    => {
      'map'       => {
        ':key' => { name  => \&module,
          'map' => {
            file    => { mandatory => 1, value => \&file },
            version => { value => \&version },
            ':key'  => { name => \&string, value => \&anything },
          }
        }
      }
    },
  
    'resources'   => {
      'map'       => { license    => { value => \&url },
                       homepage   => { value => \&url },
                       bugtracker => { value => \&url },
                       repository => { value => \&url },
                       ':key'     => { value => \&string, name => \&custom_1 },
      }
    },
  
    # additional user defined key/value pairs
    # note we can only validate the key name, as the structure is user defined
    ':key'        => { name => \&string, value => \&anything },
  },
  
  # note that the 1.1 spec only specifies 'version' as mandatory
  '1.1' => {
    'name'                => { value => \&string  },
    'version'             => { mandatory => 1, value => \&version },
    'license'             => { value => \&license },
    'generated_by'        => { value => \&string  },
  
    'license_uri'         => { value => \&url },
    'distribution_type'   => { value => \&string  },
    'dynamic_config'      => { value => \&boolean },
  
    'private'             => $no_index_1_1,
  
    'requires'            => $module_map1,
    'recommends'          => $module_map1,
    'build_requires'      => $module_map1,
    'conflicts'           => $module_map2,
  
    # additional user defined key/value pairs
    # note we can only validate the key name, as the structure is user defined
    ':key'        => { name => \&string, value => \&anything },
  },
  
  # note that the 1.0 spec doesn't specify optional or mandatory fields
  # but we will treat version as mandatory since otherwise META 1.0 is
  # completely arbitrary and pointless
  '1.0' => {
    'name'                => { value => \&string  },
    'version'             => { mandatory => 1, value => \&version },
    'license'             => { value => \&license },
    'generated_by'        => { value => \&string  },
  
    'license_uri'         => { value => \&url },
    'distribution_type'   => { value => \&string  },
    'dynamic_config'      => { value => \&boolean },
  
    'requires'            => $module_map1,
    'recommends'          => $module_map1,
    'build_requires'      => $module_map1,
    'conflicts'           => $module_map2,
  
    # additional user defined key/value pairs
    # note we can only validate the key name, as the structure is user defined
    ':key'        => { name => \&string, value => \&anything },
  },
  );
  
  #--------------------------------------------------------------------------#
  # Code
  #--------------------------------------------------------------------------#
  
  #pod =method new
  #pod
  #pod   my $cmv = CPAN::Meta::Validator->new( $struct )
  #pod
  #pod The constructor must be passed a metadata structure.
  #pod
  #pod =cut
  
  sub new {
    my ($class,$data) = @_;
  
    # create an attributes hash
    my $self = {
      'data'    => $data,
      'spec'    => eval { $data->{'meta-spec'}{'version'} } || "1.0",
      'errors'  => undef,
    };
  
    # create the object
    return bless $self, $class;
  }
  
  #pod =method is_valid
  #pod
  #pod   if ( $cmv->is_valid ) {
  #pod     ...
  #pod   }
  #pod
  #pod Returns a boolean value indicating whether the metadata provided
  #pod is valid.
  #pod
  #pod =cut
  
  sub is_valid {
      my $self = shift;
      my $data = $self->{data};
      my $spec_version = $self->{spec};
      $self->check_map($definitions{$spec_version},$data);
      return ! $self->errors;
  }
  
  #pod =method errors
  #pod
  #pod   warn( join "\n", $cmv->errors );
  #pod
  #pod Returns a list of errors seen during validation.
  #pod
  #pod =cut
  
  sub errors {
      my $self = shift;
      return ()   unless(defined $self->{errors});
      return @{$self->{errors}};
  }
  
  #pod =begin :internals
  #pod
  #pod =head2 Check Methods
  #pod
  #pod =over
  #pod
  #pod =item *
  #pod
  #pod check_map($spec,$data)
  #pod
  #pod Checks whether a map (or hash) part of the data structure conforms to the
  #pod appropriate specification definition.
  #pod
  #pod =item *
  #pod
  #pod check_list($spec,$data)
  #pod
  #pod Checks whether a list (or array) part of the data structure conforms to
  #pod the appropriate specification definition.
  #pod
  #pod =item *
  #pod
  #pod =back
  #pod
  #pod =cut
  
  my $spec_error = "Missing validation action in specification. "
    . "Must be one of 'map', 'list', or 'value'";
  
  sub check_map {
      my ($self,$spec,$data) = @_;
  
      if(ref($spec) ne 'HASH') {
          $self->_error( "Unknown META specification, cannot validate." );
          return;
      }
  
      if(ref($data) ne 'HASH') {
          $self->_error( "Expected a map structure from string or file." );
          return;
      }
  
      for my $key (keys %$spec) {
          next    unless($spec->{$key}->{mandatory});
          next    if(defined $data->{$key});
          push @{$self->{stack}}, $key;
          $self->_error( "Missing mandatory field, '$key'" );
          pop @{$self->{stack}};
      }
  
      for my $key (keys %$data) {
          push @{$self->{stack}}, $key;
          if($spec->{$key}) {
              if($spec->{$key}{value}) {
                  $spec->{$key}{value}->($self,$key,$data->{$key});
              } elsif($spec->{$key}{'map'}) {
                  $self->check_map($spec->{$key}{'map'},$data->{$key});
              } elsif($spec->{$key}{'list'}) {
                  $self->check_list($spec->{$key}{'list'},$data->{$key});
              } else {
                  $self->_error( "$spec_error for '$key'" );
              }
  
          } elsif ($spec->{':key'}) {
              $spec->{':key'}{name}->($self,$key,$key);
              if($spec->{':key'}{value}) {
                  $spec->{':key'}{value}->($self,$key,$data->{$key});
              } elsif($spec->{':key'}{'map'}) {
                  $self->check_map($spec->{':key'}{'map'},$data->{$key});
              } elsif($spec->{':key'}{'list'}) {
                  $self->check_list($spec->{':key'}{'list'},$data->{$key});
              } else {
                  $self->_error( "$spec_error for ':key'" );
              }
  
  
          } else {
              $self->_error( "Unknown key, '$key', found in map structure" );
          }
          pop @{$self->{stack}};
      }
  }
  
  sub check_list {
      my ($self,$spec,$data) = @_;
  
      if(ref($data) ne 'ARRAY') {
          $self->_error( "Expected a list structure" );
          return;
      }
  
      if(defined $spec->{mandatory}) {
          if(!defined $data->[0]) {
              $self->_error( "Missing entries from mandatory list" );
          }
      }
  
      for my $value (@$data) {
          push @{$self->{stack}}, $value || "<undef>";
          if(defined $spec->{value}) {
              $spec->{value}->($self,'list',$value);
          } elsif(defined $spec->{'map'}) {
              $self->check_map($spec->{'map'},$value);
          } elsif(defined $spec->{'list'}) {
              $self->check_list($spec->{'list'},$value);
          } elsif ($spec->{':key'}) {
              $self->check_map($spec,$value);
          } else {
            $self->_error( "$spec_error associated with '$self->{stack}[-2]'" );
          }
          pop @{$self->{stack}};
      }
  }
  
  #pod =head2 Validator Methods
  #pod
  #pod =over
  #pod
  #pod =item *
  #pod
  #pod header($self,$key,$value)
  #pod
  #pod Validates that the header is valid.
  #pod
  #pod Note: No longer used as we now read the data structure, not the file.
  #pod
  #pod =item *
  #pod
  #pod url($self,$key,$value)
  #pod
  #pod Validates that a given value is in an acceptable URL format
  #pod
  #pod =item *
  #pod
  #pod urlspec($self,$key,$value)
  #pod
  #pod Validates that the URL to a META specification is a known one.
  #pod
  #pod =item *
  #pod
  #pod string_or_undef($self,$key,$value)
  #pod
  #pod Validates that the value is either a string or an undef value. Bit of a
  #pod catchall function for parts of the data structure that are completely user
  #pod defined.
  #pod
  #pod =item *
  #pod
  #pod string($self,$key,$value)
  #pod
  #pod Validates that a string exists for the given key.
  #pod
  #pod =item *
  #pod
  #pod file($self,$key,$value)
  #pod
  #pod Validate that a file is passed for the given key. This may be made more
  #pod thorough in the future. For now it acts like \&string.
  #pod
  #pod =item *
  #pod
  #pod exversion($self,$key,$value)
  #pod
  #pod Validates a list of versions, e.g. '<= 5, >=2, ==3, !=4, >1, <6, 0'.
  #pod
  #pod =item *
  #pod
  #pod version($self,$key,$value)
  #pod
  #pod Validates a single version string. Versions of the type '5.8.8' and '0.00_00'
  #pod are both valid. A leading 'v' like 'v1.2.3' is also valid.
  #pod
  #pod =item *
  #pod
  #pod boolean($self,$key,$value)
  #pod
  #pod Validates for a boolean value: a defined value that is either "1" or "0" or
  #pod stringifies to those values.
  #pod
  #pod =item *
  #pod
  #pod license($self,$key,$value)
  #pod
  #pod Validates that a value is given for the license. Returns 1 if an known license
  #pod type, or 2 if a value is given but the license type is not a recommended one.
  #pod
  #pod =item *
  #pod
  #pod custom_1($self,$key,$value)
  #pod
  #pod Validates that the given key is in CamelCase, to indicate a user defined
  #pod keyword and only has characters in the class [-_a-zA-Z].  In version 1.X
  #pod of the spec, this was only explicitly stated for 'resources'.
  #pod
  #pod =item *
  #pod
  #pod custom_2($self,$key,$value)
  #pod
  #pod Validates that the given key begins with 'x_' or 'X_', to indicate a user
  #pod defined keyword and only has characters in the class [-_a-zA-Z]
  #pod
  #pod =item *
  #pod
  #pod identifier($self,$key,$value)
  #pod
  #pod Validates that key is in an acceptable format for the META specification,
  #pod for an identifier, i.e. any that matches the regular expression
  #pod qr/[a-z][a-z_]/i.
  #pod
  #pod =item *
  #pod
  #pod module($self,$key,$value)
  #pod
  #pod Validates that a given key is in an acceptable module name format, e.g.
  #pod 'Test::CPAN::Meta::Version'.
  #pod
  #pod =back
  #pod
  #pod =end :internals
  #pod
  #pod =cut
  
  sub header {
      my ($self,$key,$value) = @_;
      if(defined $value) {
          return 1    if($value && $value =~ /^--- #YAML:1.0/);
      }
      $self->_error( "file does not have a valid YAML header." );
      return 0;
  }
  
  sub release_status {
    my ($self,$key,$value) = @_;
    if(defined $value) {
      my $version = $self->{data}{version} || '';
      if ( $version =~ /_/ ) {
        return 1 if ( $value =~ /\A(?:testing|unstable)\z/ );
        $self->_error( "'$value' for '$key' is invalid for version '$version'" );
      }
      else {
        return 1 if ( $value =~ /\A(?:stable|testing|unstable)\z/ );
        $self->_error( "'$value' for '$key' is invalid" );
      }
    }
    else {
      $self->_error( "'$key' is not defined" );
    }
    return 0;
  }
  
  # _uri_split taken from URI::Split by Gisle Aas, Copyright 2003
  sub _uri_split {
       return $_[0] =~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,;
  }
  
  sub url {
      my ($self,$key,$value) = @_;
      if(defined $value) {
        my ($scheme, $auth, $path, $query, $frag) = _uri_split($value);
        unless ( defined $scheme && length $scheme ) {
          $self->_error( "'$value' for '$key' does not have a URL scheme" );
          return 0;
        }
        unless ( defined $auth && length $auth ) {
          $self->_error( "'$value' for '$key' does not have a URL authority" );
          return 0;
        }
        return 1;
      }
      $value ||= '';
      $self->_error( "'$value' for '$key' is not a valid URL." );
      return 0;
  }
  
  sub urlspec {
      my ($self,$key,$value) = @_;
      if(defined $value) {
          return 1    if($value && $known_specs{$self->{spec}} eq $value);
          if($value && $known_urls{$value}) {
              $self->_error( 'META specification URL does not match version' );
              return 0;
          }
      }
      $self->_error( 'Unknown META specification' );
      return 0;
  }
  
  sub anything { return 1 }
  
  sub string {
      my ($self,$key,$value) = @_;
      if(defined $value) {
          return 1    if($value || $value =~ /^0$/);
      }
      $self->_error( "value is an undefined string" );
      return 0;
  }
  
  sub string_or_undef {
      my ($self,$key,$value) = @_;
      return 1    unless(defined $value);
      return 1    if($value || $value =~ /^0$/);
      $self->_error( "No string defined for '$key'" );
      return 0;
  }
  
  sub file {
      my ($self,$key,$value) = @_;
      return 1    if(defined $value);
      $self->_error( "No file defined for '$key'" );
      return 0;
  }
  
  sub exversion {
      my ($self,$key,$value) = @_;
      if(defined $value && ($value || $value =~ /0/)) {
          my $pass = 1;
          for(split(",",$value)) { $self->version($key,$_) or ($pass = 0); }
          return $pass;
      }
      $value = '<undef>'  unless(defined $value);
      $self->_error( "'$value' for '$key' is not a valid version." );
      return 0;
  }
  
  sub version {
      my ($self,$key,$value) = @_;
      if(defined $value) {
          return 0    unless($value || $value =~ /0/);
          return 1    if($value =~ /^\s*((<|<=|>=|>|!=|==)\s*)?v?\d+((\.\d+((_|\.)\d+)?)?)/);
      } else {
          $value = '<undef>';
      }
      $self->_error( "'$value' for '$key' is not a valid version." );
      return 0;
  }
  
  sub boolean {
      my ($self,$key,$value) = @_;
      if(defined $value) {
          return 1    if($value =~ /^(0|1)$/);
      } else {
          $value = '<undef>';
      }
      $self->_error( "'$value' for '$key' is not a boolean value." );
      return 0;
  }
  
  my %v1_licenses = (
      'perl'         => 'http://dev.perl.org/licenses/',
      'gpl'          => 'http://www.opensource.org/licenses/gpl-license.php',
      'apache'       => 'http://apache.org/licenses/LICENSE-2.0',
      'artistic'     => 'http://opensource.org/licenses/artistic-license.php',
      'artistic_2'   => 'http://opensource.org/licenses/artistic-license-2.0.php',
      'lgpl'         => 'http://www.opensource.org/licenses/lgpl-license.php',
      'bsd'          => 'http://www.opensource.org/licenses/bsd-license.php',
      'gpl'          => 'http://www.opensource.org/licenses/gpl-license.php',
      'mit'          => 'http://opensource.org/licenses/mit-license.php',
      'mozilla'      => 'http://opensource.org/licenses/mozilla1.1.php',
      'open_source'  => undef,
      'unrestricted' => undef,
      'restrictive'  => undef,
      'unknown'      => undef,
  );
  
  my %v2_licenses = map { $_ => 1 } qw(
    agpl_3
    apache_1_1
    apache_2_0
    artistic_1
    artistic_2
    bsd
    freebsd
    gfdl_1_2
    gfdl_1_3
    gpl_1
    gpl_2
    gpl_3
    lgpl_2_1
    lgpl_3_0
    mit
    mozilla_1_0
    mozilla_1_1
    openssl
    perl_5
    qpl_1_0
    ssleay
    sun
    zlib
    open_source
    restricted
    unrestricted
    unknown
  );
  
  sub license {
      my ($self,$key,$value) = @_;
      my $licenses = $self->{spec} < 2 ? \%v1_licenses : \%v2_licenses;
      if(defined $value) {
          return 1    if($value && exists $licenses->{$value});
      } else {
          $value = '<undef>';
      }
      $self->_error( "License '$value' is invalid" );
      return 0;
  }
  
  sub custom_1 {
      my ($self,$key) = @_;
      if(defined $key) {
          # a valid user defined key should be alphabetic
          # and contain at least one capital case letter.
          return 1    if($key && $key =~ /^[_a-z]+$/i && $key =~ /[A-Z]/);
      } else {
          $key = '<undef>';
      }
      $self->_error( "Custom resource '$key' must be in CamelCase." );
      return 0;
  }
  
  sub custom_2 {
      my ($self,$key) = @_;
      if(defined $key) {
          return 1    if($key && $key =~ /^x_/i);  # user defined
      } else {
          $key = '<undef>';
      }
      $self->_error( "Custom key '$key' must begin with 'x_' or 'X_'." );
      return 0;
  }
  
  sub identifier {
      my ($self,$key) = @_;
      if(defined $key) {
          return 1    if($key && $key =~ /^([a-z][_a-z]+)$/i);    # spec 2.0 defined
      } else {
          $key = '<undef>';
      }
      $self->_error( "Key '$key' is not a legal identifier." );
      return 0;
  }
  
  sub module {
      my ($self,$key) = @_;
      if(defined $key) {
          return 1    if($key && $key =~ /^[A-Za-z0-9_]+(::[A-Za-z0-9_]+)*$/);
      } else {
          $key = '<undef>';
      }
      $self->_error( "Key '$key' is not a legal module name." );
      return 0;
  }
  
  my @valid_phases = qw/ configure build test runtime develop /;
  sub phase {
      my ($self,$key) = @_;
      if(defined $key) {
          return 1 if( length $key && grep { $key eq $_ } @valid_phases );
          return 1 if $key =~ /x_/i;
      } else {
          $key = '<undef>';
      }
      $self->_error( "Key '$key' is not a legal phase." );
      return 0;
  }
  
  my @valid_relations = qw/ requires recommends suggests conflicts /;
  sub relation {
      my ($self,$key) = @_;
      if(defined $key) {
          return 1 if( length $key && grep { $key eq $_ } @valid_relations );
          return 1 if $key =~ /x_/i;
      } else {
          $key = '<undef>';
      }
      $self->_error( "Key '$key' is not a legal prereq relationship." );
      return 0;
  }
  
  sub _error {
      my $self = shift;
      my $mess = shift;
  
      $mess .= ' ('.join(' -> ',@{$self->{stack}}).')'  if($self->{stack});
      $mess .= " [Validation: $self->{spec}]";
  
      push @{$self->{errors}}, $mess;
  }
  
  1;
  
  # ABSTRACT: validate CPAN distribution metadata structures
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  CPAN::Meta::Validator - validate CPAN distribution metadata structures
  
  =head1 VERSION
  
  version 2.150010
  
  =head1 SYNOPSIS
  
    my $struct = decode_json_file('META.json');
  
    my $cmv = CPAN::Meta::Validator->new( $struct );
  
    unless ( $cmv->is_valid ) {
      my $msg = "Invalid META structure.  Errors found:\n";
      $msg .= join( "\n", $cmv->errors );
      die $msg;
    }
  
  =head1 DESCRIPTION
  
  This module validates a CPAN Meta structure against the version of the
  the specification claimed in the C<meta-spec> field of the structure.
  
  =head1 METHODS
  
  =head2 new
  
    my $cmv = CPAN::Meta::Validator->new( $struct )
  
  The constructor must be passed a metadata structure.
  
  =head2 is_valid
  
    if ( $cmv->is_valid ) {
      ...
    }
  
  Returns a boolean value indicating whether the metadata provided
  is valid.
  
  =head2 errors
  
    warn( join "\n", $cmv->errors );
  
  Returns a list of errors seen during validation.
  
  =begin :internals
  
  =head2 Check Methods
  
  =over
  
  =item *
  
  check_map($spec,$data)
  
  Checks whether a map (or hash) part of the data structure conforms to the
  appropriate specification definition.
  
  =item *
  
  check_list($spec,$data)
  
  Checks whether a list (or array) part of the data structure conforms to
  the appropriate specification definition.
  
  =item *
  
  =back
  
  =head2 Validator Methods
  
  =over
  
  =item *
  
  header($self,$key,$value)
  
  Validates that the header is valid.
  
  Note: No longer used as we now read the data structure, not the file.
  
  =item *
  
  url($self,$key,$value)
  
  Validates that a given value is in an acceptable URL format
  
  =item *
  
  urlspec($self,$key,$value)
  
  Validates that the URL to a META specification is a known one.
  
  =item *
  
  string_or_undef($self,$key,$value)
  
  Validates that the value is either a string or an undef value. Bit of a
  catchall function for parts of the data structure that are completely user
  defined.
  
  =item *
  
  string($self,$key,$value)
  
  Validates that a string exists for the given key.
  
  =item *
  
  file($self,$key,$value)
  
  Validate that a file is passed for the given key. This may be made more
  thorough in the future. For now it acts like \&string.
  
  =item *
  
  exversion($self,$key,$value)
  
  Validates a list of versions, e.g. '<= 5, >=2, ==3, !=4, >1, <6, 0'.
  
  =item *
  
  version($self,$key,$value)
  
  Validates a single version string. Versions of the type '5.8.8' and '0.00_00'
  are both valid. A leading 'v' like 'v1.2.3' is also valid.
  
  =item *
  
  boolean($self,$key,$value)
  
  Validates for a boolean value: a defined value that is either "1" or "0" or
  stringifies to those values.
  
  =item *
  
  license($self,$key,$value)
  
  Validates that a value is given for the license. Returns 1 if an known license
  type, or 2 if a value is given but the license type is not a recommended one.
  
  =item *
  
  custom_1($self,$key,$value)
  
  Validates that the given key is in CamelCase, to indicate a user defined
  keyword and only has characters in the class [-_a-zA-Z].  In version 1.X
  of the spec, this was only explicitly stated for 'resources'.
  
  =item *
  
  custom_2($self,$key,$value)
  
  Validates that the given key begins with 'x_' or 'X_', to indicate a user
  defined keyword and only has characters in the class [-_a-zA-Z]
  
  =item *
  
  identifier($self,$key,$value)
  
  Validates that key is in an acceptable format for the META specification,
  for an identifier, i.e. any that matches the regular expression
  qr/[a-z][a-z_]/i.
  
  =item *
  
  module($self,$key,$value)
  
  Validates that a given key is in an acceptable module name format, e.g.
  'Test::CPAN::Meta::Version'.
  
  =back
  
  =end :internals
  
  =for Pod::Coverage anything boolean check_list custom_1 custom_2 exversion file
  identifier license module phase relation release_status string string_or_undef
  url urlspec version header check_map
  
  =head1 BUGS
  
  Please report any bugs or feature using the CPAN Request Tracker.
  Bugs can be submitted through the web interface at
  L<http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta>
  
  When submitting a bug or request, please include a test-file or a patch to an
  existing test-file that illustrates the bug or desired feature.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Adam Kennedy <adamk@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by David Golden, Ricardo Signes, Adam Kennedy and Contributors.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  __END__
  
  
  # vim: ts=2 sts=2 sw=2 et :
CPAN_META_VALIDATOR

$fatpacked{"Exporter/Shiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_SHINY';
  package Exporter::Shiny;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Exporter::Tiny ();
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000000';
  
  sub import {
  	my $me     = shift;
  	my $caller = caller;
  	
  	(my $nominal_file = $caller) =~ s(::)(/)g;
  	$INC{"$nominal_file\.pm"} ||= __FILE__;
  	
  	if (@_ == 2 and $_[0] eq -setup)
  	{
  		my (undef, $opts) = @_;
  		@_ = @{ delete($opts->{exports}) || [] };
  		
  		if (%$opts) {
  			Exporter::Tiny::_croak(
  				'Unsupported Sub::Exporter-style options: %s',
  				join(q[, ], sort keys %$opts),
  			);
  		}
  	}
  	
  	ref($_) && Exporter::Tiny::_croak('Expected sub name, got ref %s', $_) for @_;
  	
  	no strict qw(refs);
  	push @{"$caller\::ISA"}, 'Exporter::Tiny';
  	push @{"$caller\::EXPORT_OK"}, @_;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Exporter::Shiny - shortcut for Exporter::Tiny
  
  =head1 SYNOPSIS
  
     use Exporter::Shiny qw( foo bar );
  
  Is a shortcut for:
  
     use base "Exporter::Tiny";
     push our(@EXPORT_OK), qw( foo bar );
  
  For compatibility with L<Sub::Exporter>, the following longer syntax is
  also supported:
  
     use Exporter::Shiny -setup => {
        exports => [qw( foo bar )],
     };
  
  =head1 DESCRIPTION
  
  This is a very small wrapper to simplify using L<Exporter::Tiny>.
  
  It does the following:
  
  =over
  
  =item * Marks your package as loaded in C<< %INC >>;
  
  =item * Pushes any function names in the import list onto your C<< @EXPORT_OK >>; and
  
  =item * Pushes C<< "Exporter::Tiny" >> onto your C<< @ISA >>.
  
  =back
  
  It doesn't set up C<< %EXPORT_TAGS >> or C<< @EXPORT >>, but there's
  nothing stopping you doing that yourself.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Exporter-Tiny>.
  
  =head1 SEE ALSO
  
  This module is just a wrapper around L<Exporter::Tiny>, so take a look
  at L<Exporter::Tiny::Manual::QuickStart> and
  L<Exporter::Tiny::Manual::Exporting> for further information on what
  features are available.
  
  Other interesting exporters: L<Sub::Exporter>, L<Exporter>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EXPORTER_SHINY

$fatpacked{"Exporter/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_TINY';
  package Exporter::Tiny;
  
  use 5.006001;
  use strict;
  use warnings; no warnings qw(void once uninitialized numeric redefine);
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000000';
  our @EXPORT_OK = qw< mkopt mkopt_hash _croak _carp >;
  
  sub _croak ($;@) { require Carp; my $fmt = shift; @_ = sprintf($fmt, @_); goto \&Carp::croak }
  sub _carp  ($;@) { require Carp; my $fmt = shift; @_ = sprintf($fmt, @_); goto \&Carp::carp }
  
  my $_process_optlist = sub
  {
  	my $class = shift;
  	my ($global_opts, $opts, $want, $not_want) = @_;
  	
  	while (@$opts)
  	{
  		my $opt = shift @{$opts};
  		my ($name, $value) = @$opt;
  		
  		($name =~ m{\A\!(/.+/[msixpodual]+)\z}) ?
  			do {
  				my @not = $class->_exporter_expand_regexp($1, $value, $global_opts);
  				++$not_want->{$_->[0]} for @not;
  			} :
  		($name =~ m{\A\!(.+)\z}) ?
  			(++$not_want->{$1}) :
  		($name =~ m{\A[:-](.+)\z}) ?
  			push(@$opts, $class->_exporter_expand_tag($1, $value, $global_opts)) :
  		($name =~ m{\A/.+/[msixpodual]+\z}) ?
  			push(@$opts, $class->_exporter_expand_regexp($name, $value, $global_opts)) :
  		# else ?
  			push(@$want, $opt);
  	}
  };
  
  sub import
  {
  	my $class = shift;
  	my $global_opts = +{ @_ && ref($_[0]) eq q(HASH) ? %{+shift} : () };
  	$global_opts->{into} = caller unless exists $global_opts->{into};
  	
  	my @want;
  	my %not_want; $global_opts->{not} = \%not_want;
  	my @args = do { no strict qw(refs); @_ ? @_ : @{"$class\::EXPORT"} };
  	my $opts = mkopt(\@args);
  	$class->$_process_optlist($global_opts, $opts, \@want, \%not_want);
  	
  	my $permitted = $class->_exporter_permitted_regexp($global_opts);
  	$class->_exporter_validate_opts($global_opts);
  	
  	for my $wanted (@want)
  	{
  		next if $not_want{$wanted->[0]};
  		
  		my %symbols = $class->_exporter_expand_sub(@$wanted, $global_opts, $permitted);
  		$class->_exporter_install_sub($_, $wanted->[1], $global_opts, $symbols{$_})
  			for keys %symbols;
  	}
  }
  
  sub unimport
  {
  	my $class = shift;
  	my $global_opts = +{ @_ && ref($_[0]) eq q(HASH) ? %{+shift} : () };
  	$global_opts->{into} = caller unless exists $global_opts->{into};
  	$global_opts->{is_unimport} = 1;
  	
  	my @want;
  	my %not_want; $global_opts->{not} = \%not_want;
  	my @args = do { our %TRACKED; @_ ? @_ : keys(%{$TRACKED{$class}{$global_opts->{into}}}) };
  	my $opts = mkopt(\@args);
  	$class->$_process_optlist($global_opts, $opts, \@want, \%not_want);
  	
  	my $permitted = $class->_exporter_permitted_regexp($global_opts);
  	$class->_exporter_validate_unimport_opts($global_opts);
  	
  	my $expando = $class->can('_exporter_expand_sub');
  	$expando = undef if $expando == \&_exporter_expand_sub;
  	
  	for my $wanted (@want)
  	{
  		next if $not_want{$wanted->[0]};
  		
  		if ($wanted->[1])
  		{
  			_carp("Passing options to unimport '%s' makes no sense", $wanted->[0])
  				unless (ref($wanted->[1]) eq 'HASH' and not keys %{$wanted->[1]});
  		}
  		
  		my %symbols = defined($expando)
  			? $class->$expando(@$wanted, $global_opts, $permitted)
  			: ($wanted->[0] => sub { "dummy" });
  		$class->_exporter_uninstall_sub($_, $wanted->[1], $global_opts)
  			for keys %symbols;
  	}
  }
  
  # Called once per import/unimport, passed the "global" import options.
  # Expected to validate the options and carp or croak if there are problems.
  # Can also take the opportunity to do other stuff if needed.
  #
  sub _exporter_validate_opts          { 1 }
  sub _exporter_validate_unimport_opts { 1 }
  
  # Called after expanding a tag or regexp to merge the tag's options with
  # any sub-specific options.
  #
  sub _exporter_merge_opts
  {
  	my $class = shift;
  	my ($tag_opts, $global_opts, @stuff) = @_;
  	
  	$tag_opts = {} unless ref($tag_opts) eq q(HASH);
  	_croak('Cannot provide an -as option for tags')
  		if exists $tag_opts->{-as} && ref $tag_opts->{-as} ne 'CODE';
  	
  	my $optlist = mkopt(\@stuff);
  	for my $export (@$optlist)
  	{
  		next if defined($export->[1]) && ref($export->[1]) ne q(HASH);
  		
  		my %sub_opts = ( %{ $export->[1] or {} }, %$tag_opts );
  		$sub_opts{-prefix} = sprintf('%s%s', $tag_opts->{-prefix}, $export->[1]{-prefix})
  			if exists($export->[1]{-prefix}) && exists($tag_opts->{-prefix});
  		$sub_opts{-suffix} = sprintf('%s%s', $export->[1]{-suffix}, $tag_opts->{-suffix})
  			if exists($export->[1]{-suffix}) && exists($tag_opts->{-suffix});
  		$export->[1] = \%sub_opts;
  	}
  	return @$optlist;
  }
  
  # Given a tag name, looks it up in %EXPORT_TAGS and returns the list of
  # associated functions. The default implementation magically handles tags
  # "all" and "default". The default implementation interprets any undefined
  # tags as being global options.
  # 
  sub _exporter_expand_tag
  {
  	no strict qw(refs);
  	
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	my $tags  = \%{"$class\::EXPORT_TAGS"};
  	
  	return $class->_exporter_merge_opts($value, $globals, $tags->{$name}->($class, @_))
  		if ref($tags->{$name}) eq q(CODE);
  	
  	return $class->_exporter_merge_opts($value, $globals, @{$tags->{$name}})
  		if exists $tags->{$name};
  	
  	return $class->_exporter_merge_opts($value, $globals, @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"})
  		if $name eq 'all';
  	
  	return $class->_exporter_merge_opts($value, $globals, @{"$class\::EXPORT"})
  		if $name eq 'default';
  	
  	$globals->{$name} = $value || 1;
  	return;
  }
  
  # Given a regexp-like string, looks it up in @EXPORT_OK and returns the
  # list of matching functions.
  # 
  sub _exporter_expand_regexp
  {
  	no strict qw(refs);
  	our %TRACKED;
  	
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	my $compiled = eval("qr$name");
  	
  	my @possible = $globals->{is_unimport}
  		? keys( %{$TRACKED{$class}{$globals->{into}}} )
  		: @{"$class\::EXPORT_OK"};
  	
  	$class->_exporter_merge_opts($value, $globals, grep /$compiled/, @possible);
  }
  
  # Helper for _exporter_expand_sub. Returns a regexp matching all subs in
  # the exporter package which are available for export.
  #
  sub _exporter_permitted_regexp
  {
  	no strict qw(refs);
  	my $class = shift;
  	my $re = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"};
  	qr{^(?:$re)$}ms;
  }
  
  # Given a sub name, returns a hash of subs to install (usually just one sub).
  # Keys are sub names, values are coderefs.
  #
  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $permitted) = @_;
  	$permitted ||= $class->_exporter_permitted_regexp($globals);
  	
  	no strict qw(refs);
  	
  	if ($name =~ $permitted)
  	{
  		my $generator = $class->can("_generate_$name");
  		return $name => $class->$generator($name, $value, $globals) if $generator;
  		
  		my $sub = $class->can($name);
  		return $name => $sub if $sub;
  	}
  	
  	$class->_exporter_fail(@_);
  }
  
  # Called by _exporter_expand_sub if it is unable to generate a key-value
  # pair for a sub.
  #
  sub _exporter_fail
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	return if $globals->{is_unimport};
  	_croak("Could not find sub '%s' exported by %s", $name, $class);
  }
  
  # Actually performs the installation of the sub into the target package. This
  # also handles renaming the sub.
  #
  sub _exporter_install_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;
  	
  	my $into      = $globals->{into};
  	my $installer = $globals->{installer} || $globals->{exporter};
  	
  	$name =
  		ref    $globals->{as} ? $globals->{as}->($name) :
  		ref    $value->{-as}  ? $value->{-as}->($name) :
  		exists $value->{-as}  ? $value->{-as} :
  		$name;
  	
  	return unless defined $name;
  	
  	unless (ref($name))
  	{
  		my ($prefix) = grep defined, $value->{-prefix}, $globals->{prefix}, q();
  		my ($suffix) = grep defined, $value->{-suffix}, $globals->{suffix}, q();
  		$name = "$prefix$name$suffix";
  	}
  	
  	return ($$name = $sym)         if ref($name) eq q(SCALAR);
  	return ($into->{$name} = $sym) if ref($into) eq q(HASH);
  	
  	no strict qw(refs);
  	
  	if (exists &{"$into\::$name"} and \&{"$into\::$name"} != $sym)
  	{
  		my ($level) = grep defined, $value->{-replace}, $globals->{replace}, q(0);
  		my $action = {
  			carp     => \&_carp,
  			0        => \&_carp,
  			''       => \&_carp,
  			warn     => \&_carp,
  			nonfatal => \&_carp,
  			croak    => \&_croak,
  			fatal    => \&_croak,
  			die      => \&_croak,
  		}->{$level} || sub {};
  		
  		$action->(
  			$action == \&_croak
  				? "Refusing to overwrite existing sub '%s::%s' with sub '%s' exported by %s"
  				: "Overwriting existing sub '%s::%s' with sub '%s' exported by %s",
  			$into,
  			$name,
  			$_[0],
  			$class,
  		);
  	}
  	
  	our %TRACKED;
  	$TRACKED{$class}{$into}{$name} = $sym;
  	
  	no warnings qw(prototype);
  	$installer
  		? $installer->($globals, [$name, $sym])
  		: (*{"$into\::$name"} = $sym);
  }
  
  sub _exporter_uninstall_sub
  {
  	our %TRACKED;
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;
  	my $into = $globals->{into};
  	ref $into and return;
  	
  	no strict qw(refs);
  	
  	# Cowardly refuse to uninstall a sub that differs from the one
  	# we installed!
  	my $our_coderef = $TRACKED{$class}{$into}{$name};
  	my $cur_coderef = exists(&{"$into\::$name"}) ? \&{"$into\::$name"} : -1;
  	return unless $our_coderef == $cur_coderef;
  	
  	my $stash     = \%{"$into\::"};
  	my $old       = delete $stash->{$name};
  	my $full_name = join('::', $into, $name);
  	foreach my $type (qw(SCALAR HASH ARRAY IO)) # everything but the CODE
  	{
  		next unless defined(*{$old}{$type});
  		*$full_name = *{$old}{$type};
  	}
  	
  	delete $TRACKED{$class}{$into}{$name};
  }
  
  sub mkopt
  {
  	my $in = shift or return [];
  	my @out;
  	
  	$in = [map(($_ => ref($in->{$_}) ? $in->{$_} : ()), sort keys %$in)]
  		if ref($in) eq q(HASH);
  	
  	for (my $i = 0; $i < @$in; $i++)
  	{
  		my $k = $in->[$i];
  		my $v;
  		
  		($i == $#$in)         ? ($v = undef) :
  		!defined($in->[$i+1]) ? (++$i, ($v = undef)) :
  		!ref($in->[$i+1])     ? ($v = undef) :
  		($v = $in->[++$i]);
  		
  		push @out, [ $k => $v ];
  	}
  	
  	\@out;
  }
  
  sub mkopt_hash
  {
  	my $in  = shift or return;
  	my %out = map +($_->[0] => $_->[1]), @{ mkopt($in) };
  	\%out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords frobnicate greps regexps
  
  =head1 NAME
  
  Exporter::Tiny - an exporter with the features of Sub::Exporter but only core dependencies
  
  =head1 SYNOPSIS
  
     package MyUtils;
     use base "Exporter::Tiny";
     our @EXPORT = qw(frobnicate);
     sub frobnicate { ... }
     1;
  
     package MyScript;
     use MyUtils "frobnicate" => { -as => "frob" };
     print frob(42);
     exit;
  
  =head1 DESCRIPTION
  
  Exporter::Tiny supports many of Sub::Exporter's external-facing features
  including renaming imported functions with the C<< -as >>, C<< -prefix >> and
  C<< -suffix >> options; explicit destinations with the C<< into >> option;
  and alternative installers with the C<< installer >> option. But it's written
  in only about 40% as many lines of code and with zero non-core dependencies.
  
  Its internal-facing interface is closer to Exporter.pm, with configuration
  done through the C<< @EXPORT >>, C<< @EXPORT_OK >> and C<< %EXPORT_TAGS >>
  package variables.
  
  If you are trying to B<write> a module that inherits from Exporter::Tiny,
  then look at:
  
  =over
  
  =item *
  
  L<Exporter::Tiny::Manual::QuickStart>
  
  =item *
  
  L<Exporter::Tiny::Manual::Exporting>
  
  =back
  
  If you are trying to B<use> a module that inherits from Exporter::Tiny,
  then look at:
  
  =over
  
  =item *
  
  L<Exporter::Tiny::Manual::Importing>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Exporter-Tiny>.
  
  =head1 SUPPORT
  
  B<< IRC: >> support is available through in the I<< #moops >> channel
  on L<irc.perl.org|http://www.irc.perl.org/channels.html>.
  
  =head1 SEE ALSO
  
  Simplified interface to this module: L<Exporter::Shiny>.
  
  Other interesting exporters: L<Sub::Exporter>, L<Exporter>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EXPORTER_TINY

$fatpacked{"File/Find/Rule.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_FIND_RULE';
  #       $Id$
  
  package File::Find::Rule;
  use strict;
  use File::Spec;
  use Text::Glob 'glob_to_regex';
  use Number::Compare;
  use Carp qw/croak/;
  use File::Find (); # we're only wrapping for now
  
  our $VERSION = '0.34';
  
  # we'd just inherit from Exporter, but I want the colon
  sub import {
      my $pkg = shift;
      my $to  = caller;
      for my $sym ( qw( find rule ) ) {
          no strict 'refs';
          *{"$to\::$sym"} = \&{$sym};
      }
      for (grep /^:/, @_) {
          my ($extension) = /^:(.*)/;
          eval "require File::Find::Rule::$extension";
          croak "couldn't bootstrap File::Find::Rule::$extension: $@" if $@;
      }
  }
  
  =head1 NAME
  
  File::Find::Rule - Alternative interface to File::Find
  
  =head1 SYNOPSIS
  
    use File::Find::Rule;
    # find all the subdirectories of a given directory
    my @subdirs = File::Find::Rule->directory->in( $directory );
  
    # find all the .pm files in @INC
    my @files = File::Find::Rule->file()
                                ->name( '*.pm' )
                                ->in( @INC );
  
    # as above, but without method chaining
    my $rule =  File::Find::Rule->new;
    $rule->file;
    $rule->name( '*.pm' );
    my @files = $rule->in( @INC );
  
  =head1 DESCRIPTION
  
  File::Find::Rule is a friendlier interface to File::Find.  It allows
  you to build rules which specify the desired files and directories.
  
  =cut
  
  # the procedural shim
  
  *rule = \&find;
  sub find {
      my $object = __PACKAGE__->new();
      my $not = 0;
  
      while (@_) {
          my $method = shift;
          my @args;
  
          if ($method =~ s/^\!//) {
              # jinkies, we're really negating this
              unshift @_, $method;
              $not = 1;
              next;
          }
          unless (defined prototype $method) {
              my $args = shift;
              @args = ref $args eq 'ARRAY' ? @$args : $args;
          }
          if ($not) {
              $not = 0;
              @args = $object->new->$method(@args);
              $method = "not";
          }
  
          my @return = $object->$method(@args);
          return @return if $method eq 'in';
      }
      $object;
  }
  
  
  =head1 METHODS
  
  =over
  
  =item C<new>
  
  A constructor.  You need not invoke C<new> manually unless you wish
  to, as each of the rule-making methods will auto-create a suitable
  object if called as class methods.
  
  =cut
  
  sub new {
      my $referent = shift;
      my $class = ref $referent || $referent;
      bless {
          rules    => [],
          subs     => {},
          iterator => [],
          extras   => {},
          maxdepth => undef,
          mindepth => undef,
      }, $class;
  }
  
  sub _force_object {
      my $object = shift;
      $object = $object->new()
        unless ref $object;
      $object;
  }
  
  =back
  
  =head2 Matching Rules
  
  =over
  
  =item C<name( @patterns )>
  
  Specifies names that should match.  May be globs or regular
  expressions.
  
   $set->name( '*.mp3', '*.ogg' ); # mp3s or oggs
   $set->name( qr/\.(mp3|ogg)$/ ); # the same as a regex
   $set->name( 'foo.bar' );        # just things named foo.bar
  
  =cut
  
  sub _flatten {
      my @flat;
      while (@_) {
          my $item = shift;
          ref $item eq 'ARRAY' ? push @_, @{ $item } : push @flat, $item;
      }
      return @flat;
  }
  
  sub name {
      my $self = _force_object shift;
      my @names = map { ref $_ eq "Regexp" ? $_ : glob_to_regex $_ } _flatten( @_ );
  
      push @{ $self->{rules} }, {
          rule => 'name',
          code => join( ' || ', map { "m{$_}" } @names ),
          args => \@_,
      };
  
      $self;
  }
  
  =item -X tests
  
  Synonyms are provided for each of the -X tests. See L<perlfunc/-X> for
  details.  None of these methods take arguments.
  
    Test | Method               Test |  Method
   ------|-------------        ------|----------------
     -r  |  readable             -R  |  r_readable
     -w  |  writeable            -W  |  r_writeable
     -w  |  writable             -W  |  r_writable
     -x  |  executable           -X  |  r_executable
     -o  |  owned                -O  |  r_owned
         |                           |
     -e  |  exists               -f  |  file
     -z  |  empty                -d  |  directory
     -s  |  nonempty             -l  |  symlink
         |                       -p  |  fifo
     -u  |  setuid               -S  |  socket
     -g  |  setgid               -b  |  block
     -k  |  sticky               -c  |  character
         |                       -t  |  tty
     -M  |  modified                 |
     -A  |  accessed             -T  |  ascii
     -C  |  changed              -B  |  binary
  
  Though some tests are fairly meaningless as binary flags (C<modified>,
  C<accessed>, C<changed>), they have been included for completeness.
  
   # find nonempty files
   $rule->file,
        ->nonempty;
  
  =cut
  
  use vars qw( %X_tests );
  %X_tests = (
      -r  =>  readable           =>  -R  =>  r_readable      =>
      -w  =>  writeable          =>  -W  =>  r_writeable     =>
      -w  =>  writable           =>  -W  =>  r_writable      =>
      -x  =>  executable         =>  -X  =>  r_executable    =>
      -o  =>  owned              =>  -O  =>  r_owned         =>
  
      -e  =>  exists             =>  -f  =>  file            =>
      -z  =>  empty              =>  -d  =>  directory       =>
      -s  =>  nonempty           =>  -l  =>  symlink         =>
                                 =>  -p  =>  fifo            =>
      -u  =>  setuid             =>  -S  =>  socket          =>
      -g  =>  setgid             =>  -b  =>  block           =>
      -k  =>  sticky             =>  -c  =>  character       =>
                                 =>  -t  =>  tty             =>
      -M  =>  modified                                       =>
      -A  =>  accessed           =>  -T  =>  ascii           =>
      -C  =>  changed            =>  -B  =>  binary          =>
     );
  
  for my $test (keys %X_tests) {
      my $sub = eval 'sub () {
          my $self = _force_object shift;
          push @{ $self->{rules} }, {
              code => "' . $test . ' \$_",
              rule => "'.$X_tests{$test}.'",
          };
          $self;
      } ';
      no strict 'refs';
      *{ $X_tests{$test} } = $sub;
  }
  
  
  =item stat tests
  
  The following C<stat> based methods are provided: C<dev>, C<ino>,
  C<mode>, C<nlink>, C<uid>, C<gid>, C<rdev>, C<size>, C<atime>,
  C<mtime>, C<ctime>, C<blksize>, and C<blocks>.  See L<perlfunc/stat>
  for details.
  
  Each of these can take a number of targets, which will follow
  L<Number::Compare> semantics.
  
   $rule->size( 7 );         # exactly 7
   $rule->size( ">7Ki" );    # larger than 7 * 1024 * 1024 bytes
   $rule->size( ">=7" )
        ->size( "<=90" );    # between 7 and 90, inclusive
   $rule->size( 7, 9, 42 );  # 7, 9 or 42
  
  =cut
  
  use vars qw( @stat_tests );
  @stat_tests = qw( dev ino mode nlink uid gid rdev
                    size atime mtime ctime blksize blocks );
  {
      my $i = 0;
      for my $test (@stat_tests) {
          my $index = $i++; # to close over
          my $sub = sub {
              my $self = _force_object shift;
  
              my @tests = map { Number::Compare->parse_to_perl($_) } @_;
  
              push @{ $self->{rules} }, {
                  rule => $test,
                  args => \@_,
                  code => 'do { my $val = (stat $_)['.$index.'] || 0;'.
                    join ('||', map { "(\$val $_)" } @tests ).' }',
              };
              $self;
          };
          no strict 'refs';
          *$test = $sub;
      }
  }
  
  =item C<any( @rules )>
  
  =item C<or( @rules )>
  
  Allows shortcircuiting boolean evaluation as an alternative to the
  default and-like nature of combined rules.  C<any> and C<or> are
  interchangeable.
  
   # find avis, movs, things over 200M and empty files
   $rule->any( File::Find::Rule->name( '*.avi', '*.mov' ),
               File::Find::Rule->size( '>200M' ),
               File::Find::Rule->file->empty,
             );
  
  =cut
  
  sub any {
      my $self = _force_object shift;
      # compile all the subrules to code fragments
      push @{ $self->{rules} }, {
          rule => "any",
          code => '(' . join( ' || ', map '( ' . $_->_compile . ' )', @_ ). ')',
          args => \@_,
      };
  
      # merge all the subs hashes of the kids into ourself
      %{ $self->{subs} } = map { %{ $_->{subs} } } $self, @_;
      $self;
  }
  
  *or = \&any;
  
  =item C<none( @rules )>
  
  =item C<not( @rules )>
  
  Negates a rule.  (The inverse of C<any>.)  C<none> and C<not> are
  interchangeable.
  
    # files that aren't 8.3 safe
    $rule->file
         ->not( $rule->new->name( qr/^[^.]{1,8}(\.[^.]{0,3})?$/ ) );
  
  =cut
  
  sub not {
      my $self = _force_object shift;
  
      push @{ $self->{rules} }, {
          rule => 'not',
          args => \@_,
          code => '(' . join ( ' && ', map { "!(". $_->_compile . ")" } @_ ) . ")",
      };
  
      # merge all the subs hashes into us
      %{ $self->{subs} } = map { %{ $_->{subs} } } $self, @_;
      $self;
  }
  
  *none = \&not;
  
  =item C<prune>
  
  Traverse no further.  This rule always matches.
  
  =cut
  
  sub prune () {
      my $self = _force_object shift;
  
      push @{ $self->{rules} },
        {
         rule => 'prune',
         code => '$File::Find::prune = 1'
        };
      $self;
  }
  
  =item C<discard>
  
  Don't keep this file.  This rule always matches.
  
  =cut
  
  sub discard () {
      my $self = _force_object shift;
  
      push @{ $self->{rules} }, {
          rule => 'discard',
          code => '$discarded = 1',
      };
      $self;
  }
  
  =item C<exec( \&subroutine( $shortname, $path, $fullname ) )>
  
  Allows user-defined rules.  Your subroutine will be invoked with C<$_>
  set to the current short name, and with parameters of the name, the
  path you're in, and the full relative filename.
  
  Return a true value if your rule matched.
  
   # get things with long names
   $rules->exec( sub { length > 20 } );
  
  =cut
  
  sub exec {
      my $self = _force_object shift;
      my $code = shift;
  
      push @{ $self->{rules} }, {
          rule => 'exec',
          code => $code,
      };
      $self;
  }
  
  =item C<grep( @specifiers )>
  
  Opens a file and tests it each line at a time.
  
  For each line it evaluates each of the specifiers, stopping at the
  first successful match.  A specifier may be a regular expression or a
  subroutine.  The subroutine will be invoked with the same parameters
  as an ->exec subroutine.
  
  It is possible to provide a set of negative specifiers by enclosing
  them in anonymous arrays.  Should a negative specifier match the
  iteration is aborted and the clause is failed.  For example:
  
   $rule->grep( qr/^#!.*\bperl/, [ sub { 1 } ] );
  
  Is a passing clause if the first line of a file looks like a perl
  shebang line.
  
  =cut
  
  sub grep {
      my $self = _force_object shift;
      my @pattern = map {
          ref $_
            ? ref $_ eq 'ARRAY'
              ? map { [ ( ref $_ ? $_ : qr/$_/ ) => 0 ] } @$_
              : [ $_ => 1 ]
            : [ qr/$_/ => 1 ]
        } @_;
  
      $self->exec( sub {
          local *FILE;
          open FILE, $_ or return;
          local ($_, $.);
          while (<FILE>) {
              for my $p (@pattern) {
                  my ($rule, $ret) = @$p;
                  return $ret
                    if ref $rule eq 'Regexp'
                      ? /$rule/
                        : $rule->(@_);
              }
          }
          return;
      } );
  }
  
  =item C<maxdepth( $level )>
  
  Descend at most C<$level> (a non-negative integer) levels of directories
  below the starting point.
  
  May be invoked many times per rule, but only the most recent value is
  used.
  
  =item C<mindepth( $level )>
  
  Do not apply any tests at levels less than C<$level> (a non-negative
  integer).
  
  =item C<extras( \%extras )>
  
  Specifies extra values to pass through to C<File::File::find> as part
  of the options hash.
  
  For example this allows you to specify following of symlinks like so:
  
   my $rule = File::Find::Rule->extras({ follow => 1 });
  
  May be invoked many times per rule, but only the most recent value is
  used.
  
  =cut
  
  for my $setter (qw( maxdepth mindepth extras )) {
      my $sub = sub {
          my $self = _force_object shift;
          $self->{$setter} = shift;
          $self;
      };
      no strict 'refs';
      *$setter = $sub;
  }
  
  
  =item C<relative>
  
  Trim the leading portion of any path found
  
  =cut
  
  sub relative () {
      my $self = _force_object shift;
      $self->{relative} = 1;
      $self;
  }
  
  =item C<canonpath>
  
  Normalize paths found using C<File::Spec->canonpath>. This will return paths
  with a file-seperator that is native to your OS (as determined by L<File::Spec>),
   instead of the default C</>.
  
  For example, this will return C<tmp/foobar> on Unix-ish OSes
  and C<tmp\foobar> on Win32.
  
  =cut
  
  sub canonpath () {
      my $self = _force_object shift;
      $self->{canonpath} = 1;
      $self;
  }
  
  =item C<not_*>
  
  Negated version of the rule.  An effective shortand related to ! in
  the procedural interface.
  
   $foo->not_name('*.pl');
  
   $foo->not( $foo->new->name('*.pl' ) );
  
  =cut
  
  sub DESTROY {}
  sub AUTOLOAD {
      our $AUTOLOAD;
      $AUTOLOAD =~ /::not_([^:]*)$/
        or croak "Can't locate method $AUTOLOAD";
      my $method = $1;
  
      my $sub = sub {
          my $self = _force_object shift;
          $self->not( $self->new->$method(@_) );
      };
      {
          no strict 'refs';
          *$AUTOLOAD = $sub;
      }
      &$sub;
  }
  
  =back
  
  =head2 Query Methods
  
  =over
  
  =item C<in( @directories )>
  
  Evaluates the rule, returns a list of paths to matching files and
  directories.
  
  =cut
  
  sub in {
      my $self = _force_object shift;
  
      my @found;
      my $fragment = $self->_compile;
      my %subs = %{ $self->{subs} };
  
      warn "relative mode handed multiple paths - that's a bit silly\n"
        if $self->{relative} && @_ > 1;
  
      my $topdir;
      my $code = 'sub {
          (my $path = $File::Find::name)  =~ s#^(?:\./+)+##;
          my @args = ($_, $File::Find::dir, $path);
          my $maxdepth = $self->{maxdepth};
          my $mindepth = $self->{mindepth};
          my $relative = $self->{relative};
          my $canonpath = $self->{canonpath};
  
          # figure out the relative path and depth
          my $relpath = $File::Find::name;
          $relpath =~ s{^\Q$topdir\E/?}{};
          my $depth = scalar File::Spec->splitdir($relpath);
          #print "name: \'$File::Find::name\' ";
          #print "relpath: \'$relpath\' depth: $depth relative: $relative\n";
  
          defined $maxdepth && $depth >= $maxdepth
             and $File::Find::prune = 1;
  
          defined $mindepth && $depth < $mindepth
             and return;
  
          #print "Testing \'$_\'\n";
  
          my $discarded;
          return unless ' . $fragment . ';
          return if $discarded;
          if ($relative) {
              if ($relpath ne "") {
                  push @found, $canonpath ? File::Spec->canonpath($relpath) : $relpath;
              }
          }
          else {
              push @found, $canonpath ? File::Spec->canonpath($path) : $path;
          }
      }';
  
      #use Data::Dumper;
      #print Dumper \%subs;
      #warn "Compiled sub: '$code'\n";
  
      my $sub = eval "$code" or die "compile error '$code' $@";
      for my $path (@_) {
          # $topdir is used for relative and maxdepth
          $topdir = $path;
          # slice off the trailing slash if there is one (the
          # maxdepth/mindepth code is fussy)
          $topdir =~ s{/?$}{}
            unless $topdir eq '/';
          $self->_call_find( { %{ $self->{extras} }, wanted => $sub }, $path );
      }
  
      return @found;
  }
  
  sub _call_find {
      my $self = shift;
      File::Find::find( @_ );
  }
  
  sub _compile {
      my $self = shift;
  
      return '1' unless @{ $self->{rules} };
      my $code = join " && ", map {
          if (ref $_->{code}) {
              my $key = "$_->{code}";
              $self->{subs}{$key} = $_->{code};
              "\$subs{'$key'}->(\@args) # $_->{rule}\n";
          }
          else {
              "( $_->{code} ) # $_->{rule}\n";
          }
      } @{ $self->{rules} };
  
      #warn $code;
      return $code;
  }
  
  =item C<start( @directories )>
  
  Starts a find across the specified directories.  Matching items may
  then be queried using L</match>.  This allows you to use a rule as an
  iterator.
  
   my $rule = File::Find::Rule->file->name("*.jpeg")->start( "/web" );
   while ( defined ( my $image = $rule->match ) ) {
       ...
   }
  
  =cut
  
  sub start {
      my $self = _force_object shift;
  
      $self->{iterator} = [ $self->in( @_ ) ];
      $self;
  }
  
  =item C<match>
  
  Returns the next file which matches, false if there are no more.
  
  =cut
  
  sub match {
      my $self = _force_object shift;
  
      return shift @{ $self->{iterator} };
  }
  
  1;
  
  __END__
  
  =back
  
  =head2 Extensions
  
  Extension modules are available from CPAN in the File::Find::Rule
  namespace.  In order to use these extensions either use them directly:
  
   use File::Find::Rule::ImageSize;
   use File::Find::Rule::MMagic;
  
   # now your rules can use the clauses supplied by the ImageSize and
   # MMagic extension
  
  or, specify that File::Find::Rule should load them for you:
  
   use File::Find::Rule qw( :ImageSize :MMagic );
  
  For notes on implementing your own extensions, consult
  L<File::Find::Rule::Extending>
  
  =head2 Further examples
  
  =over
  
  =item Finding perl scripts
  
   my $finder = File::Find::Rule->or
    (
     File::Find::Rule->name( '*.pl' ),
     File::Find::Rule->exec(
                            sub {
                                if (open my $fh, $_) {
                                    my $shebang = <$fh>;
                                    close $fh;
                                    return $shebang =~ /^#!.*\bperl/;
                                }
                                return 0;
                            } ),
    );
  
  Based upon this message http://use.perl.org/comments.pl?sid=7052&cid=10842
  
  =item ignore CVS directories
  
   my $rule = File::Find::Rule->new;
   $rule->or($rule->new
                  ->directory
                  ->name('CVS')
                  ->prune
                  ->discard,
             $rule->new);
  
  Note here the use of a null rule.  Null rules match anything they see,
  so the effect is to match (and discard) directories called 'CVS' or to
  match anything.
  
  =back
  
  =head1 TWO FOR THE PRICE OF ONE
  
  File::Find::Rule also gives you a procedural interface.  This is
  documented in L<File::Find::Rule::Procedural>
  
  =head1 EXPORTS
  
  L</find>, L</rule>
  
  =head1 TAINT MODE INTERACTION
  
  As of 0.32 File::Find::Rule doesn't capture the current working directory in
  a taint-unsafe manner.  File::Find itself still does operations that the taint
  system will flag as insecure but you can use the L</extras> feature to ask
  L<File::Find> to internally C<untaint> file paths with a regex like so:
  
      my $rule = File::Find::Rule->extras({ untaint => 1 });
  
  Please consult L<File::Find>'s documentation for C<untaint>,
  C<untaint_pattern>, and C<untaint_skip> for more information.
  
  =head1 BUGS
  
  The code makes use of the C<our> keyword and as such requires perl version
  5.6.0 or newer.
  
  Currently it isn't possible to remove a clause from a rule object.  If
  this becomes a significant issue it will be addressed.
  
  =head1 AUTHOR
  
  Richard Clamp <richardc@unixbeard.net> with input gained from this
  use.perl discussion: http://use.perl.org/~richardc/journal/6467
  
  Additional proofreading and input provided by Kake, Greg McCarroll,
  and Andy Lester andy@petdance.com.
  
  =head1 COPYRIGHT
  
  Copyright (C) 2002, 2003, 2004, 2006, 2009, 2011 Richard Clamp.  All Rights Reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<File::Find>, L<Text::Glob>, L<Number::Compare>, find(1)
  
  If you want to know about the procedural interface, see
  L<File::Find::Rule::Procedural>, and if you have an idea for a neat
  extension L<File::Find::Rule::Extending>
  
  =cut
  
  Implementation notes:
  
  $self->rules is an array of hashrefs.  it may be a code fragment or a call
  to a subroutine.
  
  Anonymous subroutines are stored in the $self->subs hashref keyed on the
  stringfied version of the coderef.
  
  When one File::Find::Rule object is combined with another, such as in the any
  and not operations, this entire hash is merged.
  
  The _compile method walks the rules element and simply glues the code
  fragments together so they can be compiled into an anyonymous File::Find
  match sub for speed
  
  
  [*] There's probably a win to be made with the current model in making
  stat calls use C<_>.  For
  
    find( file => size => "> 20M" => size => "< 400M" );
  
  up to 3 stats will happen for each candidate.  Adding a priming _
  would be a bit blind if the first operation was C< name => 'foo' >,
  since that can be tested by a single regex.  Simply checking what the
  next type of operation doesn't work since any arbritary exec sub may
  or may not stat.  Potentially worse, they could stat something else
  like so:
  
    # extract from the worlds stupidest make(1)
    find( exec => sub { my $f = $_; $f =~ s/\.c$/.o/ && !-e $f } );
  
  Maybe the best way is to treat C<_> as invalid after calling an exec,
  and doc that C<_> will only be meaningful after stat and -X tests if
  they're wanted in exec blocks.
FILE_FIND_RULE

$fatpacked{"File/Find/Rule/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_FIND_RULE_PERL';
  package File::Find::Rule::Perl;
  
  =pod
  
  =head1 NAME
  
  File::Find::Rule::Perl - Common rules for searching for Perl things
  
  =head1 SYNOPSIS
  
    use File::Find::Rule       ();
    use File::Find::Rule::Perl ();
    
    # Find all Perl files smaller than 10k
    my @files = File::Find::Rule->perl_file
                                ->size('<10Ki')
                                ->in('dir');
    
    # Locate all the modules that PAUSE will index
    my @mod = File::Find::Rule->no_index
                              ->perl_module
                              ->in('My-Distribution');
  
  =head1 DESCRIPTION
  
  I write a lot of things that muck with Perl files. And it always annoyed
  me that finding "perl files" requires a moderately complex
  L<File::Find::Rule> pattern.
  
  B<File::Find::Rule::Perl> provides methods for finding various
  types Perl-related files, or replicating search queries run on a
  distribution in various parts of the CPAN ecosystem.
  
  =head1 METHODS
  
  =cut
  
  use 5.006;
  use strict;
  use warnings;
  use Carp;
  use File::Spec        0.82 ();
  use File::Spec::Unix       ();
  use File::Find::Rule  0.20 ();
  use Params::Util      0.38 ();
  use Parse::CPAN::Meta 1.38 ();
  
  our $VERSION = '1.15';
  use base 'File::Find::Rule';
  our @EXPORT  = @File::Find::Rule::EXPORT;
  
  use constant FFR => 'File::Find::Rule';
  
  
  
  
  
  #####################################################################
  # File::Find::Rule Method Addition
  
  =pod
  
  =head2 perl_module
  
  The C<perl_module> rule locates perl modules. That is, files that
  are named C<*.pm>.
  
  This rule is equivalent to C<-E<gt>>file-E<gt>name( '*.pm' )> and is
  included primarily for completeness.
  
  =cut
  
  sub File::Find::Rule::perl_module {
  	my $find = $_[0]->_force_object;
  	return $find->name('*.pm')->file;
  }
  
  =pod
  
  =head2 perl_test
  
  The C<perl_test> rule locates perl test scripts. That is, files that
  are named C<*.t>.
  
  This rule is equivalent to C<-E<gt>>file-E<gt>name( '*.t' )> and is
  included primarily for completeness.
  
  =cut
  
  sub File::Find::Rule::perl_test {
  	my $find = $_[0]->_force_object;
  	return $find->name('*.t')->file;
  }
  
  =pod
  
  =head2 perl_installer
  
  The C<perl_installer> rule locates perl distribution installers. That is,
  it locates C<Makefile.PL> and C<Build.PL> files.
  
  =cut
  
  sub File::Find::Rule::perl_installer {
  	my $self = shift()->_force_object;
  	return $self->file->name( 'Makefile.PL', 'Build.PL' );
  }
  
  =pod
  
  =head2 perl_script
  
  The C<perl_script> rule locates perl scripts.
  
  This is any file that ends in F<.pl>, or any files without extensions
  that have a perl "hash-bang" line.
  
  =cut
  
  sub File::Find::Rule::perl_script {
  	my $self = shift()->_force_object;
  	$self->or(
  		FFR->name( '*.pl' )->file,
  		FFR->name( qr/^[^.]+$/ )->file
  		   ->exec( \&File::Find::Rule::Perl::_shebang ),
  	);
  }
  
  sub File::Find::Rule::Perl::_shebang {
  	local *SEARCHFILE;
  	open SEARCHFILE, $_ or return !1;
  	my $first_line = <SEARCHFILE>;
  	close SEARCHFILE;
  	return !1 unless defined $first_line;
  	return $first_line =~ /^#!.*\bperl\b/;
  }
  
  =pod
  
  =head2 perl_file
  
  The C<perl_file> rule locates all files containing Perl code.
  
  This includes all the files matching the above C<perl_module>,
  C<perl_test>, C<perl_installer> and C<perl_script> rules.
  
  =cut
  
  sub File::Find::Rule::perl_file {
  	my $self = shift()->_force_object;
  	$self->or(
  		FFR->name('*.pm', '*.t', '*.pl', 'Makefile.PL', 'Build.PL')->file,
  		FFR->name( qr/^[^.]+$/ )->file
  		   ->exec( \&File::Find::Rule::Perl::_shebang ),
  	);
  }
  
  =pod
  
  =head2 no_index
  
    # Provide the rules directly
    $rule->no_index(
        directory => [ 'inc', 't', 'examples' ],
        file      => [ 'Foo.pm', 'lib/Foo.pm' ],
    );
    
    # Provide a META.yml to use
    $rule->no_index( 'META.yml' );
    
    # Provide a dist root directory to look for a META.yml in
    $rule->no_index( 'My-Distribution' );
    
    # Automatically pick up a META.yml from the target directory
    $rule->no_index->in( 'My-Distribution' );
  
  The C<no_index> method applies a set of rules as per the no_index section
  in a C<META.yml> file.
  
  =cut
  
  # There's probably some bugs in this process somewhere,
  sub File::Find::Rule::no_index {
  	my $find  = shift()->_force_object;
  
  	# Variables we'll need in the closure
  	my $rule = undef;
  	my $root = undef;
  
  	# Handle the various param options
  	if ( @_ == 0 ) {
  		# No params means we auto-calculate
  		$rule = undef;
  
  	} elsif ( Params::Util::_HASHLIKE($_[0]) ) {
  		$rule = _no_index($_[0]);
  
  	} elsif ( defined Params::Util::_STRING($_[0]) ) {
  		my $path = shift;
  		if ( -d $path ) {
  			# This is probably a dist directory
  			my $meta = File::Spec->catfile($path, 'META.yml');
  			$path = $meta if -f $meta;
  		}
  		if ( -f $path ) {
  			# This is a META.yml file
  			my $meta = Parse::CPAN::Meta::LoadFile($path);
  
  			# Shortcut if there's nothing to do
  			my $no_index = $meta->{no_index};
  			if ( $no_index ) {
  				$rule = _no_index($no_index);
  			}
  		}
  	} else {
  		Carp::croak("Invalid or unsupported parameter type");
  	}
  
  	# Generate the subroutine in advance
  	my $function = sub {
  		my $shortname = $_[0];
  		my $fullname  = $_[2];
  
  		# In the automated case the first time we are
  		# called we are passed the META.yml-relative root.
  		unless ( defined $root ) {
  			if ( File::Spec->file_name_is_absolute($fullname) ) {
  				$root = $fullname;
  			} else {
  				$root = File::Spec->rel2abs(
  					File::Spec->curdir
  				);
  			}
  		}
  		unless ( defined $rule ) {
  			$rule = '';
  			my $meta = File::Spec->catfile( $root, 'META.yml' );
  			if ( -f $meta ) {
  				my $yaml = Parse::CPAN::Meta::LoadFile($meta);
  				if ( $yaml and $yaml->{no_index} ) {
  					$rule = _no_index( $yaml->{no_index} );
  				}
  			}
  		}
  
  		# Shortcut when there is no META.yml
  		return 0 unless $rule;
  
  		# Derive the META.yml-relative unix path
  		my $absname = File::Spec->file_name_is_absolute($fullname)
  			? $fullname
  			: File::Spec->rel2abs($shortname);
  		my $relpath = File::Spec->abs2rel($absname, $root);
  
  		# Attempt to match a META.yml entry
  		if ( ($rule->{directory}->{$relpath} or $rule->{directory}->{$absname} ) and -d $absname ) {
  			return 1;
  		}
  		if ( ( $rule->{file}->{$relpath} or $rule->{file}->{$absname} ) and -f $absname ) {
  			return 1;
  		}
  		return 0;
  	};
  
  	# Generate the rule
  	return $find->or(
  		FFR->exec( $function )->prune->discard,
  		FFR->new,
  	);
  }
  
  sub _no_index {
  	my $param = shift;
  
  	# Index the directory and file entries for faster access
  	my %file = $param->{file} ? (
  		map { $_ => 1 } @{$param->{file}}
  	) : ();
  	my %directory = $param->{directory} ? (
  		map { $_ => 1 } @{$param->{directory}}
  	) : ();
  
  	return {
  		file      => \%file,
  		directory => \%directory,
  	};
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  Bugs should always be submitted via the CPAN bug tracker
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=File-Find-Rule-Perl>
  
  For other issues, contact the maintainer
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<http://ali.as/>, L<File::Find::Rule>, L<File::Find::Rule::PPI>
  
  =head1 COPYRIGHT
  
  Copyright 2006 - 2012 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_FIND_RULE_PERL

$fatpacked{"Getopt/Long.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG';
  #! perl
  
  # Getopt::Long.pm -- Universal options parsing
  # Author          : Johan Vromans
  # Created On      : Tue Sep 11 15:00:12 1990
  # Last Modified By: Johan Vromans
  # Last Modified On: Sat May 27 12:11:39 2017
  # Update Count    : 1715
  # Status          : Released
  
  ################ Module Preamble ################
  
  use 5.004;
  
  use strict;
  use warnings;
  
  package Getopt::Long;
  
  use vars qw($VERSION);
  $VERSION        =  2.50;
  # For testing versions only.
  use vars qw($VERSION_STRING);
  $VERSION_STRING = "2.50";
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  # Exported subroutines.
  sub GetOptions(@);		# always
  sub GetOptionsFromArray(@);	# on demand
  sub GetOptionsFromString(@);	# on demand
  sub Configure(@);		# on demand
  sub HelpMessage(@);		# on demand
  sub VersionMessage(@);		# in demand
  
  BEGIN {
      # Init immediately so their contents can be used in the 'use vars' below.
      @EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
      @EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
  		    &GetOptionsFromArray &GetOptionsFromString);
  }
  
  # User visible variables.
  use vars @EXPORT, @EXPORT_OK;
  use vars qw($error $debug $major_version $minor_version);
  # Deprecated visible variables.
  use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
  	    $passthrough);
  # Official invisible variables.
  use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
  
  # Really invisible variables.
  my $bundling_values;
  
  # Public subroutines.
  sub config(@);			# deprecated name
  
  # Private subroutines.
  sub ConfigDefaults();
  sub ParseOptionSpec($$);
  sub OptCtl($);
  sub FindOption($$$$$);
  sub ValidValue ($$$$$);
  
  ################ Local Variables ################
  
  # $requested_version holds the version that was mentioned in the 'use'
  # or 'require', if any. It can be used to enable or disable specific
  # features.
  my $requested_version = 0;
  
  ################ Resident subroutines ################
  
  sub ConfigDefaults() {
      # Handle POSIX compliancy.
      if ( defined $ENV{"POSIXLY_CORRECT"} ) {
  	$genprefix = "(--|-)";
  	$autoabbrev = 0;		# no automatic abbrev of options
  	$bundling = 0;			# no bundling of single letter switches
  	$getopt_compat = 0;		# disallow '+' to start options
  	$order = $REQUIRE_ORDER;
      }
      else {
  	$genprefix = "(--|-|\\+)";
  	$autoabbrev = 1;		# automatic abbrev of options
  	$bundling = 0;			# bundling off by default
  	$getopt_compat = 1;		# allow '+' to start options
  	$order = $PERMUTE;
      }
      # Other configurable settings.
      $debug = 0;			# for debugging
      $error = 0;			# error tally
      $ignorecase = 1;		# ignore case when matching options
      $passthrough = 0;		# leave unrecognized options alone
      $gnu_compat = 0;		# require --opt=val if value is optional
      $longprefix = "(--)";       # what does a long prefix look like
      $bundling_values = 0;	# no bundling of values
  }
  
  # Override import.
  sub import {
      my $pkg = shift;		# package
      my @syms = ();		# symbols to import
      my @config = ();		# configuration
      my $dest = \@syms;		# symbols first
      for ( @_ ) {
  	if ( $_ eq ':config' ) {
  	    $dest = \@config;	# config next
  	    next;
  	}
  	push(@$dest, $_);	# push
      }
      # Hide one level and call super.
      local $Exporter::ExportLevel = 1;
      push(@syms, qw(&GetOptions)) if @syms; # always export GetOptions
      $requested_version = 0;
      $pkg->SUPER::import(@syms);
      # And configure.
      Configure(@config) if @config;
  }
  
  ################ Initialization ################
  
  # Values for $order. See GNU getopt.c for details.
  ($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
  # Version major/minor numbers.
  ($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;
  
  ConfigDefaults();
  
  ################ OO Interface ################
  
  package Getopt::Long::Parser;
  
  # Store a copy of the default configuration. Since ConfigDefaults has
  # just been called, what we get from Configure is the default.
  my $default_config = do {
      Getopt::Long::Configure ()
  };
  
  sub new {
      my $that = shift;
      my $class = ref($that) || $that;
      my %atts = @_;
  
      # Register the callers package.
      my $self = { caller_pkg => (caller)[0] };
  
      bless ($self, $class);
  
      # Process config attributes.
      if ( defined $atts{config} ) {
  	my $save = Getopt::Long::Configure ($default_config, @{$atts{config}});
  	$self->{settings} = Getopt::Long::Configure ($save);
  	delete ($atts{config});
      }
      # Else use default config.
      else {
  	$self->{settings} = $default_config;
      }
  
      if ( %atts ) {		# Oops
  	die(__PACKAGE__.": unhandled attributes: ".
  	    join(" ", sort(keys(%atts)))."\n");
      }
  
      $self;
  }
  
  sub configure {
      my ($self) = shift;
  
      # Restore settings, merge new settings in.
      my $save = Getopt::Long::Configure ($self->{settings}, @_);
  
      # Restore orig config and save the new config.
      $self->{settings} = Getopt::Long::Configure ($save);
  }
  
  sub getoptions {
      my ($self) = shift;
  
      return $self->getoptionsfromarray(\@ARGV, @_);
  }
  
  sub getoptionsfromarray {
      my ($self) = shift;
  
      # Restore config settings.
      my $save = Getopt::Long::Configure ($self->{settings});
  
      # Call main routine.
      my $ret = 0;
      $Getopt::Long::caller = $self->{caller_pkg};
  
      eval {
  	# Locally set exception handler to default, otherwise it will
  	# be called implicitly here, and again explicitly when we try
  	# to deliver the messages.
  	local ($SIG{__DIE__}) = 'DEFAULT';
  	$ret = Getopt::Long::GetOptionsFromArray (@_);
      };
  
      # Restore saved settings.
      Getopt::Long::Configure ($save);
  
      # Handle errors and return value.
      die ($@) if $@;
      return $ret;
  }
  
  package Getopt::Long;
  
  ################ Back to Normal ################
  
  # Indices in option control info.
  # Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
  use constant CTL_TYPE    => 0;
  #use constant   CTL_TYPE_FLAG   => '';
  #use constant   CTL_TYPE_NEG    => '!';
  #use constant   CTL_TYPE_INCR   => '+';
  #use constant   CTL_TYPE_INT    => 'i';
  #use constant   CTL_TYPE_INTINC => 'I';
  #use constant   CTL_TYPE_XINT   => 'o';
  #use constant   CTL_TYPE_FLOAT  => 'f';
  #use constant   CTL_TYPE_STRING => 's';
  
  use constant CTL_CNAME   => 1;
  
  use constant CTL_DEFAULT => 2;
  
  use constant CTL_DEST    => 3;
   use constant   CTL_DEST_SCALAR => 0;
   use constant   CTL_DEST_ARRAY  => 1;
   use constant   CTL_DEST_HASH   => 2;
   use constant   CTL_DEST_CODE   => 3;
  
  use constant CTL_AMIN    => 4;
  use constant CTL_AMAX    => 5;
  
  # FFU.
  #use constant CTL_RANGE   => ;
  #use constant CTL_REPEAT  => ;
  
  # Rather liberal patterns to match numbers.
  use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
  use constant PAT_XINT  =>
    "(?:".
  	  "[-+]?_*[1-9][0-9_]*".
    "|".
  	  "0x_*[0-9a-f][0-9a-f_]*".
    "|".
  	  "0b_*[01][01_]*".
    "|".
  	  "0[0-7_]*".
    ")";
  use constant PAT_FLOAT =>
    "[-+]?".			# optional sign
    "(?=[0-9.])".			# must start with digit or dec.point
    "[0-9_]*".			# digits before the dec.point
    "(\.[0-9_]+)?".		# optional fraction
    "([eE][-+]?[0-9_]+)?";	# optional exponent
  
  sub GetOptions(@) {
      # Shift in default array.
      unshift(@_, \@ARGV);
      # Try to keep caller() and Carp consistent.
      goto &GetOptionsFromArray;
  }
  
  sub GetOptionsFromString(@) {
      my ($string) = shift;
      require Text::ParseWords;
      my $args = [ Text::ParseWords::shellwords($string) ];
      $caller ||= (caller)[0];	# current context
      my $ret = GetOptionsFromArray($args, @_);
      return ( $ret, $args ) if wantarray;
      if ( @$args ) {
  	$ret = 0;
  	warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n");
      }
      $ret;
  }
  
  sub GetOptionsFromArray(@) {
  
      my ($argv, @optionlist) = @_;	# local copy of the option descriptions
      my $argend = '--';		# option list terminator
      my %opctl = ();		# table of option specs
      my $pkg = $caller || (caller)[0];	# current context
  				# Needed if linkage is omitted.
      my @ret = ();		# accum for non-options
      my %linkage;		# linkage
      my $userlinkage;		# user supplied HASH
      my $opt;			# current option
      my $prefix = $genprefix;	# current prefix
  
      $error = '';
  
      if ( $debug ) {
  	# Avoid some warnings if debugging.
  	local ($^W) = 0;
  	print STDERR
  	  ("Getopt::Long $Getopt::Long::VERSION ",
  	   "called from package \"$pkg\".",
  	   "\n  ",
  	   "argv: ",
  	   defined($argv)
  	   ? UNIVERSAL::isa( $argv, 'ARRAY' ) ? "(@$argv)" : $argv
  	   : "<undef>",
  	   "\n  ",
  	   "autoabbrev=$autoabbrev,".
  	   "bundling=$bundling,",
  	   "bundling_values=$bundling_values,",
  	   "getopt_compat=$getopt_compat,",
  	   "gnu_compat=$gnu_compat,",
  	   "order=$order,",
  	   "\n  ",
  	   "ignorecase=$ignorecase,",
  	   "requested_version=$requested_version,",
  	   "passthrough=$passthrough,",
  	   "genprefix=\"$genprefix\",",
  	   "longprefix=\"$longprefix\".",
  	   "\n");
      }
  
      # Check for ref HASH as first argument.
      # First argument may be an object. It's OK to use this as long
      # as it is really a hash underneath.
      $userlinkage = undef;
      if ( @optionlist && ref($optionlist[0]) and
  	 UNIVERSAL::isa($optionlist[0],'HASH') ) {
  	$userlinkage = shift (@optionlist);
  	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
      }
  
      # See if the first element of the optionlist contains option
      # starter characters.
      # Be careful not to interpret '<>' as option starters.
      if ( @optionlist && $optionlist[0] =~ /^\W+$/
  	 && !($optionlist[0] eq '<>'
  	      && @optionlist > 0
  	      && ref($optionlist[1])) ) {
  	$prefix = shift (@optionlist);
  	# Turn into regexp. Needs to be parenthesized!
  	$prefix =~ s/(\W)/\\$1/g;
  	$prefix = "([" . $prefix . "])";
  	print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
      }
  
      # Verify correctness of optionlist.
      %opctl = ();
      while ( @optionlist ) {
  	my $opt = shift (@optionlist);
  
  	unless ( defined($opt) ) {
  	    $error .= "Undefined argument in option spec\n";
  	    next;
  	}
  
  	# Strip leading prefix so people can specify "--foo=i" if they like.
  	$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  
  	if ( $opt eq '<>' ) {
  	    if ( (defined $userlinkage)
  		&& !(@optionlist > 0 && ref($optionlist[0]))
  		&& (exists $userlinkage->{$opt})
  		&& ref($userlinkage->{$opt}) ) {
  		unshift (@optionlist, $userlinkage->{$opt});
  	    }
  	    unless ( @optionlist > 0
  		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
  		$error .= "Option spec <> requires a reference to a subroutine\n";
  		# Kill the linkage (to avoid another error).
  		shift (@optionlist)
  		  if @optionlist && ref($optionlist[0]);
  		next;
  	    }
  	    $linkage{'<>'} = shift (@optionlist);
  	    next;
  	}
  
  	# Parse option spec.
  	my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  	unless ( defined $name ) {
  	    # Failed. $orig contains the error message. Sorry for the abuse.
  	    $error .= $orig;
  	    # Kill the linkage (to avoid another error).
  	    shift (@optionlist)
  	      if @optionlist && ref($optionlist[0]);
  	    next;
  	}
  
  	# If no linkage is supplied in the @optionlist, copy it from
  	# the userlinkage if available.
  	if ( defined $userlinkage ) {
  	    unless ( @optionlist > 0 && ref($optionlist[0]) ) {
  		if ( exists $userlinkage->{$orig} &&
  		     ref($userlinkage->{$orig}) ) {
  		    print STDERR ("=> found userlinkage for \"$orig\": ",
  				  "$userlinkage->{$orig}\n")
  			if $debug;
  		    unshift (@optionlist, $userlinkage->{$orig});
  		}
  		else {
  		    # Do nothing. Being undefined will be handled later.
  		    next;
  		}
  	    }
  	}
  
  	# Copy the linkage. If omitted, link to global variable.
  	if ( @optionlist > 0 && ref($optionlist[0]) ) {
  	    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  		if $debug;
  	    my $rl = ref($linkage{$orig} = shift (@optionlist));
  
  	    if ( $rl eq "ARRAY" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  	    }
  	    elsif ( $rl eq "HASH" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
  	    }
  	    elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
  #		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  #		    my $t = $linkage{$orig};
  #		    $$t = $linkage{$orig} = [];
  #		}
  #		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  #		}
  #		else {
  		    # Ok.
  #		}
  	    }
  	    elsif ( $rl eq "CODE" ) {
  		# Ok.
  	    }
  	    else {
  		$error .= "Invalid option linkage for \"$opt\"\n";
  	    }
  	}
  	else {
  	    # Link to global $opt_XXX variable.
  	    # Make sure a valid perl identifier results.
  	    my $ov = $orig;
  	    $ov =~ s/\W/_/g;
  	    if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  		print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;");
  	    }
  	    elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  		print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
  	    }
  	    else {
  		print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
  	    }
  	}
  
  	if ( $opctl{$name}[CTL_TYPE] eq 'I'
  	     && ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY
  		  || $opctl{$name}[CTL_DEST] == CTL_DEST_HASH )
  	   ) {
  	    $error .= "Invalid option linkage for \"$opt\"\n";
  	}
  
      }
  
      $error .= "GetOptionsFromArray: 1st parameter is not an array reference\n"
        unless $argv && UNIVERSAL::isa( $argv, 'ARRAY' );
  
      # Bail out if errors found.
      die ($error) if $error;
      $error = 0;
  
      # Supply --version and --help support, if needed and allowed.
      if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{version}) ) {
  	    $opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
  	    $linkage{version} = \&VersionMessage;
  	}
  	$auto_version = 1;
      }
      if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
  	    $opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
  	    $linkage{help} = \&HelpMessage;
  	}
  	$auto_help = 1;
      }
  
      # Show the options tables if debugging.
      if ( $debug ) {
  	my ($arrow, $k, $v);
  	$arrow = "=> ";
  	while ( ($k,$v) = each(%opctl) ) {
  	    print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
  	    $arrow = "   ";
  	}
      }
  
      # Process argument list
      my $goon = 1;
      while ( $goon && @$argv > 0 ) {
  
  	# Get next argument.
  	$opt = shift (@$argv);
  	print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  
  	# Double dash is option list terminator.
  	if ( defined($opt) && $opt eq $argend ) {
  	  push (@ret, $argend) if $passthrough;
  	  last;
  	}
  
  	# Look it up.
  	my $tryopt = $opt;
  	my $found;		# success status
  	my $key;		# key (if hash type)
  	my $arg;		# option argument
  	my $ctl;		# the opctl entry
  
  	($found, $opt, $ctl, $arg, $key) =
  	  FindOption ($argv, $prefix, $argend, $opt, \%opctl);
  
  	if ( $found ) {
  
  	    # FindOption undefines $opt in case of errors.
  	    next unless defined $opt;
  
  	    my $argcnt = 0;
  	    while ( defined $arg ) {
  
  		# Get the canonical name.
  		print STDERR ("=> cname for \"$opt\" is ") if $debug;
  		$opt = $ctl->[CTL_CNAME];
  		print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  
  		if ( defined $linkage{$opt} ) {
  		    print STDERR ("=> ref(\$L{$opt}) -> ",
  				  ref($linkage{$opt}), "\n") if $debug;
  
  		    if ( ref($linkage{$opt}) eq 'SCALAR'
  			 || ref($linkage{$opt}) eq 'REF' ) {
  			if ( $ctl->[CTL_TYPE] eq '+' ) {
  			    print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
  			      if $debug;
  			    if ( defined ${$linkage{$opt}} ) {
  			        ${$linkage{$opt}} += $arg;
  			    }
  		            else {
  			        ${$linkage{$opt}} = $arg;
  			    }
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to ARRAY\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = [];
  			    print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			      if $debug;
  			    push (@{$linkage{$opt}}, $arg);
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to HASH\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = {};
  			    print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			      if $debug;
  			    $linkage{$opt}->{$key} = $arg;
  			}
  			else {
  			    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  			      if $debug;
  			    ${$linkage{$opt}} = $arg;
  		        }
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
  			print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			    if $debug;
  			push (@{$linkage{$opt}}, $arg);
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
  			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$linkage{$opt}->{$key} = $arg;
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
  			print STDERR ("=> &L{$opt}(\"$opt\"",
  				      $ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
  				      ", \"$arg\")\n")
  			    if $debug;
  			my $eval_error = do {
  			    local $@;
  			    local $SIG{__DIE__}  = 'DEFAULT';
  			    eval {
  				&{$linkage{$opt}}
  				  (Getopt::Long::CallBack->new
  				   (name    => $opt,
  				    ctl     => $ctl,
  				    opctl   => \%opctl,
  				    linkage => \%linkage,
  				    prefix  => $prefix,
  				   ),
  				   $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
  				   $arg);
  			    };
  			    $@;
  			};
  			print STDERR ("=> die($eval_error)\n")
  			  if $debug && $eval_error ne '';
  			if ( $eval_error =~ /^!/ ) {
  			    if ( $eval_error =~ /^!FINISH\b/ ) {
  				$goon = 0;
  			    }
  			}
  			elsif ( $eval_error ne '' ) {
  			    warn ($eval_error);
  			    $error++;
  			}
  		    }
  		    else {
  			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
  				      "\" in linkage\n");
  			die("Getopt::Long -- internal error!\n");
  		    }
  		}
  		# No entry in linkage means entry in userlinkage.
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")
  			    if $debug;
  			push (@{$userlinkage->{$opt}}, $arg);
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
  			    if $debug;
  			$userlinkage->{$opt} = [$arg];
  		    }
  		}
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$userlinkage->{$opt}->{$key} = $arg;
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
  			    if $debug;
  			$userlinkage->{$opt} = {$key => $arg};
  		    }
  		}
  		else {
  		    if ( $ctl->[CTL_TYPE] eq '+' ) {
  			print STDERR ("=> \$L{$opt} += \"$arg\"\n")
  			  if $debug;
  			if ( defined $userlinkage->{$opt} ) {
  			    $userlinkage->{$opt} += $arg;
  			}
  			else {
  			    $userlinkage->{$opt} = $arg;
  			}
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
  			$userlinkage->{$opt} = $arg;
  		    }
  		}
  
  		$argcnt++;
  		last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  		undef($arg);
  
  		# Need more args?
  		if ( $argcnt < $ctl->[CTL_AMIN] ) {
  		    if ( @$argv ) {
  			if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
  			    $arg = shift(@$argv);
  			    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  				$arg =~ tr/_//d;
  				$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  				  ? oct($arg)
  				  : 0+$arg
  			    }
  			    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  			      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  			    next;
  			}
  			warn("Value \"$$argv[0]\" invalid for option $opt\n");
  			$error++;
  		    }
  		    else {
  			warn("Insufficient arguments for option $opt\n");
  			$error++;
  		    }
  		}
  
  		# Any more args?
  		if ( @$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
  		    $arg = shift(@$argv);
  		    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  			$arg =~ tr/_//d;
  			$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  			  ? oct($arg)
  			  : 0+$arg
  		    }
  		    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  		      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  		    next;
  		}
  	    }
  	}
  
  	# Not an option. Save it if we $PERMUTE and don't have a <>.
  	elsif ( $order == $PERMUTE ) {
  	    # Try non-options call-back.
  	    my $cb;
  	    if ( defined ($cb = $linkage{'<>'}) ) {
  		print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
  		  if $debug;
  		my $eval_error = do {
  		    local $@;
  		    local $SIG{__DIE__}  = 'DEFAULT';
  		    eval {
  			# The arg to <> cannot be the CallBack object
  			# since it may be passed to other modules that
  			# get confused (e.g., Archive::Tar). Well,
  			# it's not relevant for this callback anyway.
  			&$cb($tryopt);
  		    };
  		    $@;
  		};
  		print STDERR ("=> die($eval_error)\n")
  		  if $debug && $eval_error ne '';
  		if ( $eval_error =~ /^!/ ) {
  		    if ( $eval_error =~ /^!FINISH\b/ ) {
  			$goon = 0;
  		    }
  		}
  		elsif ( $eval_error ne '' ) {
  		    warn ($eval_error);
  		    $error++;
  		}
  	    }
  	    else {
  		print STDERR ("=> saving \"$tryopt\" ",
  			      "(not an option, may permute)\n") if $debug;
  		push (@ret, $tryopt);
  	    }
  	    next;
  	}
  
  	# ...otherwise, terminate.
  	else {
  	    # Push this one back and exit.
  	    unshift (@$argv, $tryopt);
  	    return ($error == 0);
  	}
  
      }
  
      # Finish.
      if ( @ret && $order == $PERMUTE ) {
  	#  Push back accumulated arguments
  	print STDERR ("=> restoring \"", join('" "', @ret), "\"\n")
  	    if $debug;
  	unshift (@$argv, @ret);
      }
  
      return ($error == 0);
  }
  
  # A readable representation of what's in an optbl.
  sub OptCtl ($) {
      my ($v) = @_;
      my @v = map { defined($_) ? ($_) : ("<undef>") } @$v;
      "[".
        join(",",
  	   "\"$v[CTL_TYPE]\"",
  	   "\"$v[CTL_CNAME]\"",
  	   "\"$v[CTL_DEFAULT]\"",
  	   ("\$","\@","\%","\&")[$v[CTL_DEST] || 0],
  	   $v[CTL_AMIN] || '',
  	   $v[CTL_AMAX] || '',
  #	   $v[CTL_RANGE] || '',
  #	   $v[CTL_REPEAT] || '',
  	  ). "]";
  }
  
  # Parse an option specification and fill the tables.
  sub ParseOptionSpec ($$) {
      my ($opt, $opctl) = @_;
  
      # Match option spec.
      if ( $opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Alias names, or "?"
  		     (?: \| (?: \? | \w[-\w]* ) )*
  		     # Aliases
  		     (?: \| (?: [^-|!+=:][^|!+=:]* )? )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x ) {
  	return (undef, "Error in option spec: \"$opt\"\n");
      }
  
      my ($names, $spec) = ($1, $2);
      $spec = '' unless defined $spec;
  
      # $orig keeps track of the primary name the user specified.
      # This name will be used for the internal or external linkage.
      # In other words, if the user specifies "FoO|BaR", it will
      # match any case combinations of 'foo' and 'bar', but if a global
      # variable needs to be set, it will be $opt_FoO in the exact case
      # as specified.
      my $orig;
  
      my @names;
      if ( defined $names ) {
  	@names =  split (/\|/, $names);
  	$orig = $names[0];
      }
      else {
  	@names = ('');
  	$orig = '';
      }
  
      # Construct the opctl entries.
      my $entry;
      if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
  	# Fields are hard-wired here.
  	$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
      }
      elsif ( $spec =~ /^:(-?\d+|\+)([@%])?$/ ) {
  	my $def = $1;
  	my $dest = $2;
  	my $type = $def eq '+' ? 'I' : 'i';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,$def eq '+' ? undef : $def,
  		  $dest,0,1];
      }
      else {
  	my ($mand, $type, $dest) =
  	  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
  	return (undef, "Cannot repeat while bundling: \"$opt\"\n")
  	  if $bundling && defined($4);
  	my ($mi, $cm, $ma) = ($5, $6, $7);
  	return (undef, "{0} is useless in option spec: \"$opt\"\n")
  	  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
  
  	$type = 'i' if $type eq 'n';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Default minargs to 1/0 depending on mand status.
  	$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
  	# Adjust mand status according to minargs.
  	$mand = $mi ? '=' : ':';
  	# Adjust maxargs.
  	$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
  	return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
  	  if defined($ma) && !$ma;
  	return (undef, "Max less than min in option spec: \"$opt\"\n")
  	  if defined($ma) && $ma < $mi;
  
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
      }
  
      # Process all names. First is canonical, the rest are aliases.
      my $dups = '';
      foreach ( @names ) {
  
  	$_ = lc ($_)
  	  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
  
  	if ( exists $opctl->{$_} ) {
  	    $dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
  	}
  
  	if ( $spec eq '!' ) {
  	    $opctl->{"no$_"} = $entry;
  	    $opctl->{"no-$_"} = $entry;
  	    $opctl->{$_} = [@$entry];
  	    $opctl->{$_}->[CTL_TYPE] = '';
  	}
  	else {
  	    $opctl->{$_} = $entry;
  	}
      }
  
      if ( $dups && $^W ) {
  	foreach ( split(/\n+/, $dups) ) {
  	    warn($_."\n");
  	}
      }
      ($names[0], $orig);
  }
  
  # Option lookup.
  sub FindOption ($$$$$) {
  
      # returns (1, $opt, $ctl, $arg, $key) if okay,
      # returns (1, undef) if option in error,
      # returns (0) otherwise.
  
      my ($argv, $prefix, $argend, $opt, $opctl) = @_;
  
      print STDERR ("=> find \"$opt\"\n") if $debug;
  
      return (0) unless defined($opt);
      return (0) unless $opt =~ /^($prefix)(.*)$/s;
      return (0) if $opt eq "-" && !defined $opctl->{''};
  
      $opt = substr( $opt, length($1) ); # retain taintedness
      my $starter = $1;
  
      print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
  
      my $optarg;			# value supplied with --opt=value
      my $rest;			# remainder from unbundling
  
      # If it is a long option, it may include the value.
      # With getopt_compat, only if not bundling.
      if ( ($starter=~/^$longprefix$/
  	  || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
  	 && (my $oppos = index($opt, '=', 1)) > 0) {
  	my $optorg = $opt;
  	$opt = substr($optorg, 0, $oppos);
  	$optarg = substr($optorg, $oppos + 1); # retain tainedness
  	print STDERR ("=> option \"", $opt,
  		      "\", optarg = \"$optarg\"\n") if $debug;
      }
  
      #### Look it up ###
  
      my $tryopt = $opt;		# option to try
  
      if ( ( $bundling || $bundling_values ) && $starter eq '-' ) {
  
  	# To try overrides, obey case ignore.
  	$tryopt = $ignorecase ? lc($opt) : $opt;
  
  	# If bundling == 2, long options can override bundles.
  	if ( $bundling == 2 && length($tryopt) > 1
  	     && defined ($opctl->{$tryopt}) ) {
  	    print STDERR ("=> $starter$tryopt overrides unbundling\n")
  	      if $debug;
  	}
  
  	# If bundling_values, option may be followed by the value.
  	elsif ( $bundling_values ) {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    # Whatever remains may not be considered an option.
  	    $optarg = $rest eq '' ? undef : $rest;
  	    $rest = undef;
  	}
  
  	# Split off a single letter and leave the rest for
  	# further processing.
  	else {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    $rest = undef unless $rest ne '';
  	}
      }
  
      # Try auto-abbreviation.
      elsif ( $autoabbrev && $opt ne "" ) {
  	# Sort the possible long option names.
  	my @names = sort(keys (%$opctl));
  	# Downcase if allowed.
  	$opt = lc ($opt) if $ignorecase;
  	$tryopt = $opt;
  	# Turn option name into pattern.
  	my $pat = quotemeta ($opt);
  	# Look up in option names.
  	my @hits = grep (/^$pat/, @names);
  	print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
  		      "out of ", scalar(@names), "\n") if $debug;
  
  	# Check for ambiguous results.
  	unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
  	    # See if all matches are for the same option.
  	    my %hit;
  	    foreach ( @hits ) {
  		my $hit = $opctl->{$_}->[CTL_CNAME]
  		  if defined $opctl->{$_}->[CTL_CNAME];
  		$hit = "no" . $hit if $opctl->{$_}->[CTL_TYPE] eq '!';
  		$hit{$hit} = 1;
  	    }
  	    # Remove auto-supplied options (version, help).
  	    if ( keys(%hit) == 2 ) {
  		if ( $auto_version && exists($hit{version}) ) {
  		    delete $hit{version};
  		}
  		elsif ( $auto_help && exists($hit{help}) ) {
  		    delete $hit{help};
  		}
  	    }
  	    # Now see if it really is ambiguous.
  	    unless ( keys(%hit) == 1 ) {
  		return (0) if $passthrough;
  		warn ("Option ", $opt, " is ambiguous (",
  		      join(", ", @hits), ")\n");
  		$error++;
  		return (1, undef);
  	    }
  	    @hits = keys(%hit);
  	}
  
  	# Complete the option name, if appropriate.
  	if ( @hits == 1 && $hits[0] ne $opt ) {
  	    $tryopt = $hits[0];
  	    $tryopt = lc ($tryopt)
  	      if $ignorecase > (($bundling && length($tryopt) == 1) ? 1 : 0);
  	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
  		if $debug;
  	}
      }
  
      # Map to all lowercase if ignoring case.
      elsif ( $ignorecase ) {
  	$tryopt = lc ($opt);
      }
  
      # Check validity by fetching the info.
      my $ctl = $opctl->{$tryopt};
      unless  ( defined $ctl ) {
  	return (0) if $passthrough;
  	# Pretend one char when bundling.
  	if ( $bundling == 1 && length($starter) == 1 ) {
  	    $opt = substr($opt,0,1);
              unshift (@$argv, $starter.$rest) if defined $rest;
  	}
  	if ( $opt eq "" ) {
  	    warn ("Missing option after ", $starter, "\n");
  	}
  	else {
  	    warn ("Unknown option: ", $opt, "\n");
  	}
  	$error++;
  	return (1, undef);
      }
      # Apparently valid.
      $opt = $tryopt;
      print STDERR ("=> found ", OptCtl($ctl),
  		  " for \"", $opt, "\"\n") if $debug;
  
      #### Determine argument status ####
  
      # If it is an option w/o argument, we're almost finished with it.
      my $type = $ctl->[CTL_TYPE];
      my $arg;
  
      if ( $type eq '' || $type eq '!' || $type eq '+' ) {
  	if ( defined $optarg ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " does not take an argument\n");
  	    $error++;
  	    undef $opt;
  	    undef $optarg if $bundling_values;
  	}
  	elsif ( $type eq '' || $type eq '+' ) {
  	    # Supply explicit value.
  	    $arg = 1;
  	}
  	else {
  	    $opt =~ s/^no-?//i;	# strip NO prefix
  	    $arg = 0;		# supply explicit value
  	}
  	unshift (@$argv, $starter.$rest) if defined $rest;
  	return (1, $opt, $ctl, $arg);
      }
  
      # Get mandatory status and type info.
      my $mand = $ctl->[CTL_AMIN];
  
      # Check if there is an option argument available.
      if ( $gnu_compat ) {
  	my $optargtype = 0; # none, 1 = empty, 2 = nonempty, 3 = aux
  	if ( defined($optarg) ) {
  	    $optargtype = (length($optarg) == 0) ? 1 : 2;
  	}
  	elsif ( defined $rest || @$argv > 0 ) {
  	    # GNU getopt_long() does not accept the (optional)
  	    # argument to be passed to the option without = sign.
  	    # We do, since not doing so breaks existing scripts.
  	    $optargtype = 3;
  	}
  	if(($optargtype == 0) && !$mand) {
  	    my $val
  	      = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT]
  	      : $type eq 's'                 ? ''
  	      :                                0;
  	    return (1, $opt, $ctl, $val);
  	}
  	return (1, $opt, $ctl, $type eq 's' ? '' : 0)
  	  if $optargtype == 1;  # --foo=  -> return nothing
      }
  
      # Check if there is an option argument available.
      if ( defined $optarg
  	 ? ($optarg eq '')
  	 : !(defined $rest || @$argv > 0) ) {
  	# Complain if this option needs an argument.
  #	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
  	if ( $mand ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " requires an argument\n");
  	    $error++;
  	    return (1, undef);
  	}
  	if ( $type eq 'I' ) {
  	    # Fake incremental type.
  	    my @c = @$ctl;
  	    $c[CTL_TYPE] = '+';
  	    return (1, $opt, \@c, 1);
  	}
  	return (1, $opt, $ctl,
  		defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  		$type eq 's' ? '' : 0);
      }
  
      # Get (possibly optional) argument.
      $arg = (defined $rest ? $rest
  	    : (defined $optarg ? $optarg : shift (@$argv)));
  
      # Get key if this is a "name=value" pair for a hash option.
      my $key;
      if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
  	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
  	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  	     ($mand ? undef : ($type eq 's' ? "" : 1)));
  	if (! defined $arg) {
  	    warn ("Option $opt, key \"$key\", requires a value\n");
  	    $error++;
  	    # Push back.
  	    unshift (@$argv, $starter.$rest) if defined $rest;
  	    return (1, undef);
  	}
      }
  
      #### Check if the argument is valid for this option ####
  
      my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1, $opt, $ctl, $arg, $key) if $mand;
  
  	# Same for optional string as a hash value
  	return (1, $opt, $ctl, $arg, $key)
  	  if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  
  	# An optional string takes almost anything.
  	return (1, $opt, $ctl, $arg, $key)
  	  if defined $optarg || defined $rest;
  	return (1, $opt, $ctl, $arg, $key) if $arg eq "-"; # ??
  
  	# Check for option or option list terminator.
  	if ($arg eq $argend ||
  	    $arg =~ /^$prefix.+/) {
  	    # Push back.
  	    unshift (@$argv, $arg);
  	    # Supply empty value.
  	    $arg = '';
  	}
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  
  	if ( $bundling && defined $rest
  	     && $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/si ) {
  	    $arg =~ tr/_//d;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (",
  		      $type eq 'o' ? "extended " : '',
  		      "number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		if ( $type eq 'I' ) {
  		    # Fake incremental type.
  		    my @c = @$ctl;
  		    $c[CTL_TYPE] = '+';
  		    return (1, $opt, \@c, 1);
  		}
  		# Supply default value.
  		$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
  	    }
  	}
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	if ( $bundling && defined $rest &&
  	     $rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
  	    $arg =~ tr/_//d;
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/ ) {
  	    $arg =~ tr/_//d;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (real number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		# Supply default value.
  		$arg = 0.0;
  	    }
  	}
      }
      else {
  	die("Getopt::Long internal error (Can't happen)\n");
      }
      return (1, $opt, $ctl, $arg, $key);
  }
  
  sub ValidValue ($$$$$) {
      my ($ctl, $arg, $mand, $argend, $prefix) = @_;
  
      if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  	return 0 unless $arg =~ /[^=]+=(.*)/;
  	$arg = $1;
      }
  
      my $type = $ctl->[CTL_TYPE];
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1) if $mand;
  
  	return (1) if $arg eq "-";
  
  	# Check for option or option list terminator.
  	return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
  	return 1;
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  	return $arg =~ /^$o_valid$/si;
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	return $arg =~ /^$o_valid$/;
      }
      die("ValidValue: Cannot happen\n");
  }
  
  # Getopt::Long Configuration.
  sub Configure (@) {
      my (@options) = @_;
  
      my $prevconfig =
        [ $error, $debug, $major_version, $minor_version, $caller,
  	$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	$longprefix, $bundling_values ];
  
      if ( ref($options[0]) eq 'ARRAY' ) {
  	( $error, $debug, $major_version, $minor_version, $caller,
  	  $autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	  $longprefix, $bundling_values ) = @{shift(@options)};
      }
  
      my $opt;
      foreach $opt ( @options ) {
  	my $try = lc ($opt);
  	my $action = 1;
  	if ( $try =~ /^no_?(.*)$/s ) {
  	    $action = 0;
  	    $try = $+;
  	}
  	if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
  	    ConfigDefaults ();
  	}
  	elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
  	    local $ENV{POSIXLY_CORRECT};
  	    $ENV{POSIXLY_CORRECT} = 1 if $action;
  	    ConfigDefaults ();
  	}
  	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
  	    $autoabbrev = $action;
  	}
  	elsif ( $try eq 'getopt_compat' ) {
  	    $getopt_compat = $action;
              $genprefix = $action ? "(--|-|\\+)" : "(--|-)";
  	}
  	elsif ( $try eq 'gnu_getopt' ) {
  	    if ( $action ) {
  		$gnu_compat = 1;
  		$bundling = 1;
  		$getopt_compat = 0;
                  $genprefix = "(--|-)";
  		$order = $PERMUTE;
  		$bundling_values = 0;
  	    }
  	}
  	elsif ( $try eq 'gnu_compat' ) {
  	    $gnu_compat = $action;
  	    $bundling = 0;
  	    $bundling_values = 1;
  	}
  	elsif ( $try =~ /^(auto_?)?version$/ ) {
  	    $auto_version = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?help$/ ) {
  	    $auto_help = $action;
  	}
  	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
  	    $ignorecase = $action;
  	}
  	elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
  	    $ignorecase = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'bundling' ) {
  	    $bundling = $action;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_override' ) {
  	    $bundling = $action ? 2 : 0;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_values' ) {
  	    $bundling_values = $action;
  	    $bundling = 0 if $action;
  	}
  	elsif ( $try eq 'require_order' ) {
  	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
  	}
  	elsif ( $try eq 'permute' ) {
  	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
  	}
  	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
  	    $passthrough = $action;
  	}
  	elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Turn into regexp. Needs to be parenthesized!
  	    $genprefix = "(" . quotemeta($genprefix) . ")";
  	    eval { '' =~ /$genprefix/; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Parenthesize if needed.
  	    $genprefix = "(" . $genprefix . ")"
  	      unless $genprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$genprefix"; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
  	    $longprefix = $1;
  	    # Parenthesize if needed.
  	    $longprefix = "(" . $longprefix . ")"
  	      unless $longprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$longprefix"; };
  	    die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n") if $@;
  	}
  	elsif ( $try eq 'debug' ) {
  	    $debug = $action;
  	}
  	else {
  	    die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")
  	}
      }
      $prevconfig;
  }
  
  # Deprecated name.
  sub config (@) {
      Configure (@_);
  }
  
  # Issue a standard message for --version.
  #
  # The arguments are mostly the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub VersionMessage(@) {
      # Massage args.
      my $pa = setup_pa_args("version", @_);
  
      my $v = $main::VERSION;
      my $fh = $pa->{-output} ||
        ( ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR );
  
      print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
  	       $0, defined $v ? " version $v" : (),
  	       "\n",
  	       "(", __PACKAGE__, "::", "GetOptions",
  	       " version ",
  	       defined($Getopt::Long::VERSION_STRING)
  	         ? $Getopt::Long::VERSION_STRING : $VERSION, ";",
  	       " Perl version ",
  	       $] >= 5.006 ? sprintf("%vd", $^V) : $],
  	       ")\n");
      exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
  }
  
  # Issue a standard message for --help.
  #
  # The arguments are the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub HelpMessage(@) {
      eval {
  	require Pod::Usage;
  	import Pod::Usage;
  	1;
      } || die("Cannot provide help: cannot load Pod::Usage\n");
  
      # Note that pod2usage will issue a warning if -exitval => NOEXIT.
      pod2usage(setup_pa_args("help", @_));
  
  }
  
  # Helper routine to set up a normalized hash ref to be used as
  # argument to pod2usage.
  sub setup_pa_args($@) {
      my $tag = shift;		# who's calling
  
      # If called by direct binding to an option, it will get the option
      # name and value as arguments. Remove these, if so.
      @_ = () if @_ == 2 && $_[0] eq $tag;
  
      my $pa;
      if ( @_ > 1 ) {
  	$pa = { @_ };
      }
      else {
  	$pa = shift || {};
      }
  
      # At this point, $pa can be a number (exit value), string
      # (message) or hash with options.
  
      if ( UNIVERSAL::isa($pa, 'HASH') ) {
  	# Get rid of -msg vs. -message ambiguity.
  	$pa->{-message} = $pa->{-msg};
  	delete($pa->{-msg});
      }
      elsif ( $pa =~ /^-?\d+$/ ) {
  	$pa = { -exitval => $pa };
      }
      else {
  	$pa = { -message => $pa };
      }
  
      # These are _our_ defaults.
      $pa->{-verbose} = 0 unless exists($pa->{-verbose});
      $pa->{-exitval} = 0 unless exists($pa->{-exitval});
      $pa;
  }
  
  # Sneak way to know what version the user requested.
  sub VERSION {
      $requested_version = $_[1];
      shift->SUPER::VERSION(@_);
  }
  
  package Getopt::Long::CallBack;
  
  sub new {
      my ($pkg, %atts) = @_;
      bless { %atts }, $pkg;
  }
  
  sub name {
      my $self = shift;
      ''.$self->{name};
  }
  
  use overload
    # Treat this object as an ordinary string for legacy API.
    '""'	   => \&name,
    fallback => 1;
  
  1;
  
  ################ Documentation ################
  
  =head1 NAME
  
  Getopt::Long - Extended processing of command line options
  
  =head1 SYNOPSIS
  
    use Getopt::Long;
    my $data   = "file.dat";
    my $length = 24;
    my $verbose;
    GetOptions ("length=i" => \$length,    # numeric
                "file=s"   => \$data,      # string
                "verbose"  => \$verbose)   # flag
    or die("Error in command line arguments\n");
  
  =head1 DESCRIPTION
  
  The Getopt::Long module implements an extended getopt function called
  GetOptions(). It parses the command line from C<@ARGV>, recognizing
  and removing specified options and their possible values.
  
  This function adheres to the POSIX syntax for command
  line options, with GNU extensions. In general, this means that options
  have long names instead of single letters, and are introduced with a
  double dash "--". Support for bundling of command line options, as was
  the case with the more traditional single-letter approach, is provided
  but not enabled by default.
  
  =head1 Command Line Options, an Introduction
  
  Command line operated programs traditionally take their arguments from
  the command line, for example filenames or other information that the
  program needs to know. Besides arguments, these programs often take
  command line I<options> as well. Options are not necessary for the
  program to work, hence the name 'option', but are used to modify its
  default behaviour. For example, a program could do its job quietly,
  but with a suitable option it could provide verbose information about
  what it did.
  
  Command line options come in several flavours. Historically, they are
  preceded by a single dash C<->, and consist of a single letter.
  
      -l -a -c
  
  Usually, these single-character options can be bundled:
  
      -lac
  
  Options can have values, the value is placed after the option
  character. Sometimes with whitespace in between, sometimes not:
  
      -s 24 -s24
  
  Due to the very cryptic nature of these options, another style was
  developed that used long names. So instead of a cryptic C<-l> one
  could use the more descriptive C<--long>. To distinguish between a
  bundle of single-character options and a long one, two dashes are used
  to precede the option name. Early implementations of long options used
  a plus C<+> instead. Also, option values could be specified either
  like
  
      --size=24
  
  or
  
      --size 24
  
  The C<+> form is now obsolete and strongly deprecated.
  
  =head1 Getting Started with Getopt::Long
  
  Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was the
  first Perl module that provided support for handling the new style of
  command line options, in particular long option names, hence the Perl5
  name Getopt::Long. This module also supports single-character options
  and bundling.
  
  To use Getopt::Long from a Perl program, you must include the
  following line in your Perl program:
  
      use Getopt::Long;
  
  This will load the core of the Getopt::Long module and prepare your
  program for using it. Most of the actual Getopt::Long code is not
  loaded until you really call one of its functions.
  
  In the default configuration, options names may be abbreviated to
  uniqueness, case does not matter, and a single dash is sufficient,
  even for long option names. Also, options may be placed between
  non-option arguments. See L<Configuring Getopt::Long> for more
  details on how to configure Getopt::Long.
  
  =head2 Simple options
  
  The most simple options are the ones that take no values. Their mere
  presence on the command line enables the option. Popular examples are:
  
      --all --verbose --quiet --debug
  
  Handling simple options is straightforward:
  
      my $verbose = '';	# option variable with default value (false)
      my $all = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose, 'all' => \$all);
  
  The call to GetOptions() parses the command line arguments that are
  present in C<@ARGV> and sets the option variable to the value C<1> if
  the option did occur on the command line. Otherwise, the option
  variable is not touched. Setting the option value to true is often
  called I<enabling> the option.
  
  The option name as specified to the GetOptions() function is called
  the option I<specification>. Later we'll see that this specification
  can contain more than just the option name. The reference to the
  variable is called the option I<destination>.
  
  GetOptions() will return a true value if the command line could be
  processed successfully. Otherwise, it will write error messages using
  die() and warn(), and return a false result.
  
  =head2 A little bit less simple options
  
  Getopt::Long supports two useful variants of simple options:
  I<negatable> options and I<incremental> options.
  
  A negatable option is specified with an exclamation mark C<!> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose!' => \$verbose);
  
  Now, using C<--verbose> on the command line will enable C<$verbose>,
  as expected. But it is also allowed to use C<--noverbose>, which will
  disable C<$verbose> by setting its value to C<0>. Using a suitable
  default value, the program can find out whether C<$verbose> is false
  by default, or disabled by using C<--noverbose>.
  
  An incremental option is specified with a plus C<+> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose+' => \$verbose);
  
  Using C<--verbose> on the command line will increment the value of
  C<$verbose>. This way the program can keep track of how many times the
  option occurred on the command line. For example, each occurrence of
  C<--verbose> could increase the verbosity level of the program.
  
  =head2 Mixing command line option with other arguments
  
  Usually programs take command line options as well as other arguments,
  for example, file names. It is good practice to always specify the
  options first, and the other arguments last. Getopt::Long will,
  however, allow the options and arguments to be mixed and 'filter out'
  all the options before passing the rest of the arguments to the
  program. To stop Getopt::Long from processing further arguments,
  insert a double dash C<--> on the command line:
  
      --size 24 -- --all
  
  In this example, C<--all> will I<not> be treated as an option, but
  passed to the program unharmed, in C<@ARGV>.
  
  =head2 Options with values
  
  For options that take values it must be specified whether the option
  value is required or not, and what kind of value the option expects.
  
  Three kinds of values are supported: integer numbers, floating point
  numbers, and strings.
  
  If the option value is required, Getopt::Long will take the
  command line argument that follows the option and assign this to the
  option variable. If, however, the option value is specified as
  optional, this will only be done if that value does not look like a
  valid command line option itself.
  
      my $tag = '';	# option variable with default value
      GetOptions ('tag=s' => \$tag);
  
  In the option specification, the option name is followed by an equals
  sign C<=> and the letter C<s>. The equals sign indicates that this
  option requires a value. The letter C<s> indicates that this value is
  an arbitrary string. Other possible value types are C<i> for integer
  values, and C<f> for floating point values. Using a colon C<:> instead
  of the equals sign indicates that the option value is optional. In
  this case, if no suitable value is supplied, string valued options get
  an empty string C<''> assigned, while numeric options are set to C<0>.
  
  =head2 Options with multiple values
  
  Options sometimes take several values. For example, a program could
  use multiple directories to search for library files:
  
      --library lib/stdlib --library lib/extlib
  
  To accomplish this behaviour, simply specify an array reference as the
  destination for the option:
  
      GetOptions ("library=s" => \@libfiles);
  
  Alternatively, you can specify that the option can have multiple
  values by adding a "@", and pass a reference to a scalar as the
  destination:
  
      GetOptions ("library=s@" => \$libfiles);
  
  Used with the example above, C<@libfiles> c.q. C<@$libfiles> would
  contain two strings upon completion: C<"lib/stdlib"> and
  C<"lib/extlib">, in that order. It is also possible to specify that
  only integer or floating point numbers are acceptable values.
  
  Often it is useful to allow comma-separated lists of values as well as
  multiple occurrences of the options. This is easy using Perl's split()
  and join() operators:
  
      GetOptions ("library=s" => \@libfiles);
      @libfiles = split(/,/,join(',',@libfiles));
  
  Of course, it is important to choose the right separator string for
  each purpose.
  
  Warning: What follows is an experimental feature.
  
  Options can take multiple values at once, for example
  
      --coordinates 52.2 16.4 --rgbcolor 255 255 149
  
  This can be accomplished by adding a repeat specifier to the option
  specification. Repeat specifiers are very similar to the C<{...}>
  repeat specifiers that can be used with regular expression patterns.
  For example, the above command line would be handled as follows:
  
      GetOptions('coordinates=f{2}' => \@coor, 'rgbcolor=i{3}' => \@color);
  
  The destination for the option must be an array or array reference.
  
  It is also possible to specify the minimal and maximal number of
  arguments an option takes. C<foo=s{2,4}> indicates an option that
  takes at least two and at most 4 arguments. C<foo=s{1,}> indicates one
  or more values; C<foo:s{,}> indicates zero or more option values.
  
  =head2 Options with hash values
  
  If the option destination is a reference to a hash, the option will
  take, as value, strings of the form I<key>C<=>I<value>. The value will
  be stored with the specified key in the hash.
  
      GetOptions ("define=s" => \%defines);
  
  Alternatively you can use:
  
      GetOptions ("define=s%" => \$defines);
  
  When used with command line options:
  
      --define os=linux --define vendor=redhat
  
  the hash C<%defines> (or C<%$defines>) will contain two keys, C<"os">
  with value C<"linux"> and C<"vendor"> with value C<"redhat">. It is
  also possible to specify that only integer or floating point numbers
  are acceptable values. The keys are always taken to be strings.
  
  =head2 User-defined subroutines to handle options
  
  Ultimate control over what should be done when (actually: each time)
  an option is encountered on the command line can be achieved by
  designating a reference to a subroutine (or an anonymous subroutine)
  as the option destination. When GetOptions() encounters the option, it
  will call the subroutine with two or three arguments. The first
  argument is the name of the option. (Actually, it is an object that
  stringifies to the name of the option.) For a scalar or array destination,
  the second argument is the value to be stored. For a hash destination,
  the second argument is the key to the hash, and the third argument
  the value to be stored. It is up to the subroutine to store the value,
  or do whatever it thinks is appropriate.
  
  A trivial application of this mechanism is to implement options that
  are related to each other. For example:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose,
  	        'quiet'   => sub { $verbose = 0 });
  
  Here C<--verbose> and C<--quiet> control the same variable
  C<$verbose>, but with opposite values.
  
  If the subroutine needs to signal an error, it should call die() with
  the desired error message as its argument. GetOptions() will catch the
  die(), issue the error message, and record that an error result must
  be returned upon completion.
  
  If the text of the error message starts with an exclamation mark C<!>
  it is interpreted specially by GetOptions(). There is currently one
  special command implemented: C<die("!FINISH")> will cause GetOptions()
  to stop processing options, as if it encountered a double dash C<-->.
  
  In version 2.37 the first argument to the callback function was
  changed from string to object. This was done to make room for
  extensions and more detailed control. The object stringifies to the
  option name so this change should not introduce compatibility
  problems.
  
  Here is an example of how to access the option name and value from within
  a subroutine:
  
      GetOptions ('opt=i' => \&handler);
      sub handler {
          my ($opt_name, $opt_value) = @_;
          print("Option name is $opt_name and value is $opt_value\n");
      }
  
  =head2 Options with multiple names
  
  Often it is user friendly to supply alternate mnemonic names for
  options. For example C<--height> could be an alternate name for
  C<--length>. Alternate names can be included in the option
  specification, separated by vertical bar C<|> characters. To implement
  the above example:
  
      GetOptions ('length|height=f' => \$length);
  
  The first name is called the I<primary> name, the other names are
  called I<aliases>. When using a hash to store options, the key will
  always be the primary name.
  
  Multiple alternate names are possible.
  
  =head2 Case and abbreviations
  
  Without additional configuration, GetOptions() will ignore the case of
  option names, and allow the options to be abbreviated to uniqueness.
  
      GetOptions ('length|height=f' => \$length, "head" => \$head);
  
  This call will allow C<--l> and C<--L> for the length option, but
  requires a least C<--hea> and C<--hei> for the head and height options.
  
  =head2 Summary of Option Specifications
  
  Each option specifier consists of two parts: the name specification
  and the argument specification.
  
  The name specification contains the name of the option, optionally
  followed by a list of alternative names separated by vertical bar
  characters.
  
      length	      option name is "length"
      length|size|l     name is "length", aliases are "size" and "l"
  
  The argument specification is optional. If omitted, the option is
  considered boolean, a value of 1 will be assigned when the option is
  used on the command line.
  
  The argument specification can be
  
  =over 4
  
  =item !
  
  The option does not take an argument and may be negated by prefixing
  it with "no" or "no-". E.g. C<"foo!"> will allow C<--foo> (a value of
  1 will be assigned) as well as C<--nofoo> and C<--no-foo> (a value of
  0 will be assigned). If the option has aliases, this applies to the
  aliases as well.
  
  Using negation on a single letter option when bundling is in effect is
  pointless and will result in a warning.
  
  =item +
  
  The option does not take an argument and will be incremented by 1
  every time it appears on the command line. E.g. C<"more+">, when used
  with C<--more --more --more>, will increment the value three times,
  resulting in a value of 3 (provided it was 0 or undefined at first).
  
  The C<+> specifier is ignored if the option destination is not a scalar.
  
  =item = I<type> [ I<desttype> ] [ I<repeat> ]
  
  The option requires an argument of the given type. Supported types
  are:
  
  =over 4
  
  =item s
  
  String. An arbitrary sequence of characters. It is valid for the
  argument to start with C<-> or C<-->.
  
  =item i
  
  Integer. An optional leading plus or minus sign, followed by a
  sequence of digits.
  
  =item o
  
  Extended integer, Perl style. This can be either an optional leading
  plus or minus sign, followed by a sequence of digits, or an octal
  string (a zero, optionally followed by '0', '1', .. '7'), or a
  hexadecimal string (C<0x> followed by '0' .. '9', 'a' .. 'f', case
  insensitive), or a binary string (C<0b> followed by a series of '0'
  and '1').
  
  =item f
  
  Real number. For example C<3.14>, C<-6.23E24> and so on.
  
  =back
  
  The I<desttype> can be C<@> or C<%> to specify that the option is
  list or a hash valued. This is only needed when the destination for
  the option value is not otherwise specified. It should be omitted when
  not needed.
  
  The I<repeat> specifies the number of values this option takes per
  occurrence on the command line. It has the format C<{> [ I<min> ] [ C<,> [ I<max> ] ] C<}>.
  
  I<min> denotes the minimal number of arguments. It defaults to 1 for
  options with C<=> and to 0 for options with C<:>, see below. Note that
  I<min> overrules the C<=> / C<:> semantics.
  
  I<max> denotes the maximum number of arguments. It must be at least
  I<min>. If I<max> is omitted, I<but the comma is not>, there is no
  upper bound to the number of argument values taken.
  
  =item : I<type> [ I<desttype> ]
  
  Like C<=>, but designates the argument as optional.
  If omitted, an empty string will be assigned to string values options,
  and the value zero to numeric options.
  
  Note that if a string argument starts with C<-> or C<-->, it will be
  considered an option on itself.
  
  =item : I<number> [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the I<number> will be assigned.
  
  =item : + [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the current value for the
  option will be incremented.
  
  =back
  
  =head1 Advanced Possibilities
  
  =head2 Object oriented interface
  
  Getopt::Long can be used in an object oriented way as well:
  
      use Getopt::Long;
      $p = Getopt::Long::Parser->new;
      $p->configure(...configuration options...);
      if ($p->getoptions(...options descriptions...)) ...
      if ($p->getoptionsfromarray( \@array, ...options descriptions...)) ...
  
  Configuration options can be passed to the constructor:
  
      $p = new Getopt::Long::Parser
               config => [...configuration options...];
  
  =head2 Thread Safety
  
  Getopt::Long is thread safe when using ithreads as of Perl 5.8.  It is
  I<not> thread safe when using the older (experimental and now
  obsolete) threads implementation that was added to Perl 5.005.
  
  =head2 Documentation and help texts
  
  Getopt::Long encourages the use of Pod::Usage to produce help
  messages. For example:
  
      use Getopt::Long;
      use Pod::Usage;
  
      my $man = 0;
      my $help = 0;
  
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-exitval => 0, -verbose => 2) if $man;
  
      __END__
  
      =head1 NAME
  
      sample - Using Getopt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 8
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  See L<Pod::Usage> for details.
  
  =head2 Parsing options from an arbitrary array
  
  By default, GetOptions parses the options that are present in the
  global array C<@ARGV>. A special entry C<GetOptionsFromArray> can be
  used to parse options from an arbitrary array.
  
      use Getopt::Long qw(GetOptionsFromArray);
      $ret = GetOptionsFromArray(\@myopts, ...);
  
  When used like this, options and their possible values are removed
  from C<@myopts>, the global C<@ARGV> is not touched at all.
  
  The following two calls behave identically:
  
      $ret = GetOptions( ... );
      $ret = GetOptionsFromArray(\@ARGV, ... );
  
  This also means that a first argument hash reference now becomes the
  second argument:
  
      $ret = GetOptions(\%opts, ... );
      $ret = GetOptionsFromArray(\@ARGV, \%opts, ... );
  
  =head2 Parsing options from an arbitrary string
  
  A special entry C<GetOptionsFromString> can be used to parse options
  from an arbitrary string.
  
      use Getopt::Long qw(GetOptionsFromString);
      $ret = GetOptionsFromString($string, ...);
  
  The contents of the string are split into arguments using a call to
  C<Text::ParseWords::shellwords>. As with C<GetOptionsFromArray>, the
  global C<@ARGV> is not touched.
  
  It is possible that, upon completion, not all arguments in the string
  have been processed. C<GetOptionsFromString> will, when called in list
  context, return both the return status and an array reference to any
  remaining arguments:
  
      ($ret, $args) = GetOptionsFromString($string, ... );
  
  If any arguments remain, and C<GetOptionsFromString> was not called in
  list context, a message will be given and C<GetOptionsFromString> will
  return failure.
  
  As with GetOptionsFromArray, a first argument hash reference now
  becomes the second argument.
  
  =head2 Storing options values in a hash
  
  Sometimes, for example when there are a lot of options, having a
  separate variable for each of them can be cumbersome. GetOptions()
  supports, as an alternative mechanism, storing options values in a
  hash.
  
  To obtain this, a reference to a hash must be passed I<as the first
  argument> to GetOptions(). For each option that is specified on the
  command line, the option value will be stored in the hash with the
  option name as key. Options that are not actually used on the command
  line will not be put in the hash, on other words,
  C<exists($h{option})> (or defined()) can be used to test if an option
  was used. The drawback is that warnings will be issued if the program
  runs under C<use strict> and uses C<$h{option}> without testing with
  exists() or defined() first.
  
      my %h = ();
      GetOptions (\%h, 'length=i');	# will store in $h{length}
  
  For options that take list or hash values, it is necessary to indicate
  this by appending an C<@> or C<%> sign after the type:
  
      GetOptions (\%h, 'colours=s@');	# will push to @{$h{colours}}
  
  To make things more complicated, the hash may contain references to
  the actual destinations, for example:
  
      my $len = 0;
      my %h = ('length' => \$len);
      GetOptions (\%h, 'length=i');	# will store in $len
  
  This example is fully equivalent with:
  
      my $len = 0;
      GetOptions ('length=i' => \$len);	# will store in $len
  
  Any mixture is possible. For example, the most frequently used options
  could be stored in variables while all other options get stored in the
  hash:
  
      my $verbose = 0;			# frequently referred
      my $debug = 0;			# frequently referred
      my %h = ('verbose' => \$verbose, 'debug' => \$debug);
      GetOptions (\%h, 'verbose', 'debug', 'filter', 'size=i');
      if ( $verbose ) { ... }
      if ( exists $h{filter} ) { ... option 'filter' was specified ... }
  
  =head2 Bundling
  
  With bundling it is possible to set several single-character options
  at once. For example if C<a>, C<v> and C<x> are all valid options,
  
      -vax
  
  will set all three.
  
  Getopt::Long supports three styles of bundling. To enable bundling, a
  call to Getopt::Long::Configure is required.
  
  The simplest style of bundling can be enabled with:
  
      Getopt::Long::Configure ("bundling");
  
  Configured this way, single-character options can be bundled but long
  options B<must> always start with a double dash C<--> to avoid
  ambiguity. For example, when C<vax>, C<a>, C<v> and C<x> are all valid
  options,
  
      -vax
  
  will set C<a>, C<v> and C<x>, but
  
      --vax
  
  will set C<vax>.
  
  The second style of bundling lifts this restriction. It can be enabled
  with:
  
      Getopt::Long::Configure ("bundling_override");
  
  Now, C<-vax> will set the option C<vax>.
  
  In all of the above cases, option values may be inserted in the
  bundle. For example:
  
      -h24w80
  
  is equivalent to
  
      -h 24 -w 80
  
  A third style of bundling allows only values to be bundled with
  options. It can be enabled with:
  
      Getopt::Long::Configure ("bundling_values");
  
  Now, C<-h24> will set the option C<h> to C<24>, but option bundles
  like C<-vxa> and C<-h24w80> are flagged as errors.
  
  Enabling C<bundling_values> will disable the other two styles of
  bundling.
  
  When configured for bundling, single-character options are matched
  case sensitive while long options are matched case insensitive. To
  have the single-character options matched case insensitive as well,
  use:
  
      Getopt::Long::Configure ("bundling", "ignorecase_always");
  
  It goes without saying that bundling can be quite confusing.
  
  =head2 The lonesome dash
  
  Normally, a lone dash C<-> on the command line will not be considered
  an option. Option processing will terminate (unless "permute" is
  configured) and the dash will be left in C<@ARGV>.
  
  It is possible to get special treatment for a lone dash. This can be
  achieved by adding an option specification with an empty name, for
  example:
  
      GetOptions ('' => \$stdio);
  
  A lone dash on the command line will now be a legal option, and using
  it will set variable C<$stdio>.
  
  =head2 Argument callback
  
  A special option 'name' C<< <> >> can be used to designate a subroutine
  to handle non-option arguments. When GetOptions() encounters an
  argument that does not look like an option, it will immediately call this
  subroutine and passes it one parameter: the argument name. Well, actually
  it is an object that stringifies to the argument name.
  
  For example:
  
      my $width = 80;
      sub process { ... }
      GetOptions ('width=i' => \$width, '<>' => \&process);
  
  When applied to the following command line:
  
      arg1 --width=72 arg2 --width=60 arg3
  
  This will call
  C<process("arg1")> while C<$width> is C<80>,
  C<process("arg2")> while C<$width> is C<72>, and
  C<process("arg3")> while C<$width> is C<60>.
  
  This feature requires configuration option B<permute>, see section
  L<Configuring Getopt::Long>.
  
  =head1 Configuring Getopt::Long
  
  Getopt::Long can be configured by calling subroutine
  Getopt::Long::Configure(). This subroutine takes a list of quoted
  strings, each specifying a configuration option to be enabled, e.g.
  C<ignore_case>, or disabled, e.g. C<no_ignore_case>. Case does not
  matter. Multiple calls to Configure() are possible.
  
  Alternatively, as of version 2.24, the configuration options may be
  passed together with the C<use> statement:
  
      use Getopt::Long qw(:config no_ignore_case bundling);
  
  The following options are available:
  
  =over 12
  
  =item default
  
  This option causes all configuration options to be reset to their
  default values.
  
  =item posix_default
  
  This option causes all configuration options to be reset to their
  default values as if the environment variable POSIXLY_CORRECT had
  been set.
  
  =item auto_abbrev
  
  Allow option names to be abbreviated to uniqueness.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is disabled.
  
  =item getopt_compat
  
  Allow C<+> to start options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<getopt_compat> is disabled.
  
  =item gnu_compat
  
  C<gnu_compat> controls whether C<--opt=> is allowed, and what it should
  do. Without C<gnu_compat>, C<--opt=> gives an error. With C<gnu_compat>,
  C<--opt=> will give option C<opt> and empty value.
  This is the way GNU getopt_long() does it.
  
  Note that C<--opt value> is still accepted, even though GNU
  getopt_long() doesn't.
  
  =item gnu_getopt
  
  This is a short way of setting C<gnu_compat> C<bundling> C<permute>
  C<no_getopt_compat>. With C<gnu_getopt>, command line handling should be
  reasonably compatible with GNU getopt_long().
  
  =item require_order
  
  Whether command line arguments are allowed to be mixed with options.
  Default is disabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<require_order> is enabled.
  
  See also C<permute>, which is the opposite of C<require_order>.
  
  =item permute
  
  Whether command line arguments are allowed to be mixed with options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<permute> is disabled.
  Note that C<permute> is the opposite of C<require_order>.
  
  If C<permute> is enabled, this means that
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo --bar arg1 arg2 arg3
  
  If an argument callback routine is specified, C<@ARGV> will always be
  empty upon successful return of GetOptions() since all options have been
  processed. The only exception is when C<--> is used:
  
      --foo arg1 --bar arg2 -- arg3
  
  This will call the callback routine for arg1 and arg2, and then
  terminate GetOptions() leaving C<"arg3"> in C<@ARGV>.
  
  If C<require_order> is enabled, options processing
  terminates when the first non-option is encountered.
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo -- arg1 --bar arg2 arg3
  
  If C<pass_through> is also enabled, options processing will terminate
  at the first unrecognized option, or non-option, whichever comes
  first.
  
  =item bundling (default: disabled)
  
  Enabling this option will allow single-character options to be
  bundled. To distinguish bundles from long option names, long options
  I<must> be introduced with C<--> and bundles with C<->.
  
  Note that, if you have options C<a>, C<l> and C<all>, and
  auto_abbrev enabled, possible arguments and option settings are:
  
      using argument               sets option(s)
      ------------------------------------------
      -a, --a                      a
      -l, --l                      l
      -al, -la, -ala, -all,...     a, l
      --al, --all                  all
  
  The surprising part is that C<--a> sets option C<a> (due to auto
  completion), not C<all>.
  
  Note: disabling C<bundling> also disables C<bundling_override>.
  
  =item bundling_override (default: disabled)
  
  If C<bundling_override> is enabled, bundling is enabled as with
  C<bundling> but now long option names override option bundles.
  
  Note: disabling C<bundling_override> also disables C<bundling>.
  
  B<Note:> Using option bundling can easily lead to unexpected results,
  especially when mixing long options and bundles. Caveat emptor.
  
  =item ignore_case  (default: enabled)
  
  If enabled, case is ignored when matching option names. If, however,
  bundling is enabled as well, single character options will be treated
  case-sensitive.
  
  With C<ignore_case>, option specifications for options that only
  differ in case, e.g., C<"foo"> and C<"Foo">, will be flagged as
  duplicates.
  
  Note: disabling C<ignore_case> also disables C<ignore_case_always>.
  
  =item ignore_case_always (default: disabled)
  
  When bundling is in effect, case is ignored on single-character
  options also.
  
  Note: disabling C<ignore_case_always> also disables C<ignore_case>.
  
  =item auto_version (default:disabled)
  
  Automatically provide support for the B<--version> option if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a standard version message that includes the
  program name, its version (if $main::VERSION is defined), and the
  versions of Getopt::Long and Perl. The message will be written to
  standard output and processing will terminate.
  
  C<auto_version> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item auto_help (default:disabled)
  
  Automatically provide support for the B<--help> and B<-?> options if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a help message using module L<Pod::Usage>. The
  message, derived from the SYNOPSIS POD section, will be written to
  standard output and processing will terminate.
  
  C<auto_help> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item pass_through (default: disabled)
  
  With C<pass_through> anything that is unknown, ambiguous or supplied with
  an invalid option will not be flagged as an error. Instead the unknown
  option(s) will be passed to the catchall C<< <> >> if present, otherwise
  through to C<@ARGV>. This makes it possible to write wrapper scripts that
  process only part of the user supplied command line arguments, and pass the
  remaining options to some other program.
  
  If C<require_order> is enabled, options processing will terminate at the
  first unrecognized option, or non-option, whichever comes first and all
  remaining arguments are passed to C<@ARGV> instead of the catchall
  C<< <> >> if present.  However, if C<permute> is enabled instead, results
  can become confusing.
  
  Note that the options terminator (default C<-->), if present, will
  also be passed through in C<@ARGV>.
  
  =item prefix
  
  The string that starts options. If a constant string is not
  sufficient, see C<prefix_pattern>.
  
  =item prefix_pattern
  
  A Perl pattern that identifies the strings that introduce options.
  Default is C<--|-|\+> unless environment variable
  POSIXLY_CORRECT has been set, in which case it is C<--|->.
  
  =item long_prefix_pattern
  
  A Perl pattern that allows the disambiguation of long and short
  prefixes. Default is C<-->.
  
  Typically you only need to set this if you are using nonstandard
  prefixes and want some or all of them to have the same semantics as
  '--' does under normal circumstances.
  
  For example, setting prefix_pattern to C<--|-|\+|\/> and
  long_prefix_pattern to C<--|\/> would add Win32 style argument
  handling.
  
  =item debug (default: disabled)
  
  Enable debugging output.
  
  =back
  
  =head1 Exportable Methods
  
  =over
  
  =item VersionMessage
  
  This subroutine provides a standard version message. Its argument can be:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the standard message.
  
  =item *
  
  A numeric value corresponding to the desired exit status.
  
  =item *
  
  A reference to a hash.
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message>
  
  =item C<-msg>
  
  The text of a message to print immediately prior to printing the
  program's usage message.
  
  =item C<-exitval>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string "NOEXIT" to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-output>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =back
  
  You cannot tie this routine directly to an option, e.g.:
  
      GetOptions("version" => \&VersionMessage);
  
  Use this instead:
  
      GetOptions("version" => sub { VersionMessage() });
  
  =item HelpMessage
  
  This subroutine produces a standard help message, derived from the
  program's POD section SYNOPSIS using L<Pod::Usage>. It takes the same
  arguments as VersionMessage(). In particular, you cannot tie it
  directly to an option, e.g.:
  
      GetOptions("help" => \&HelpMessage);
  
  Use this instead:
  
      GetOptions("help" => sub { HelpMessage() });
  
  =back
  
  =head1 Return values and Errors
  
  Configuration errors and errors in the option definitions are
  signalled using die() and will terminate the calling program unless
  the call to Getopt::Long::GetOptions() was embedded in C<eval { ...
  }>, or die() was trapped using C<$SIG{__DIE__}>.
  
  GetOptions returns true to indicate success.
  It returns false when the function detected one or more errors during
  option parsing. These errors are signalled using warn() and can be
  trapped with C<$SIG{__WARN__}>.
  
  =head1 Legacy
  
  The earliest development of C<newgetopt.pl> started in 1990, with Perl
  version 4. As a result, its development, and the development of
  Getopt::Long, has gone through several stages. Since backward
  compatibility has always been extremely important, the current version
  of Getopt::Long still supports a lot of constructs that nowadays are
  no longer necessary or otherwise unwanted. This section describes
  briefly some of these 'features'.
  
  =head2 Default destinations
  
  When no destination is specified for an option, GetOptions will store
  the resultant value in a global variable named C<opt_>I<XXX>, where
  I<XXX> is the primary name of this option. When a program executes
  under C<use strict> (recommended), these variables must be
  pre-declared with our() or C<use vars>.
  
      our $opt_length = 0;
      GetOptions ('length=i');	# will store in $opt_length
  
  To yield a usable Perl variable, characters that are not part of the
  syntax for variables are translated to underscores. For example,
  C<--fpp-struct-return> will set the variable
  C<$opt_fpp_struct_return>. Note that this variable resides in the
  namespace of the calling program, not necessarily C<main>. For
  example:
  
      GetOptions ("size=i", "sizes=i@");
  
  with command line "-size 10 -sizes 24 -sizes 48" will perform the
  equivalent of the assignments
  
      $opt_size = 10;
      @opt_sizes = (24, 48);
  
  =head2 Alternative option starters
  
  A string of alternative option starter characters may be passed as the
  first argument (or the first argument after a leading hash reference
  argument).
  
      my $len = 0;
      GetOptions ('/', 'length=i' => $len);
  
  Now the command line may look like:
  
      /length 24 -- arg
  
  Note that to terminate options processing still requires a double dash
  C<-->.
  
  GetOptions() will not interpret a leading C<< "<>" >> as option starters
  if the next argument is a reference. To force C<< "<" >> and C<< ">" >> as
  option starters, use C<< "><" >>. Confusing? Well, B<using a starter
  argument is strongly deprecated> anyway.
  
  =head2 Configuration variables
  
  Previous versions of Getopt::Long used variables for the purpose of
  configuring. Although manipulating these variables still work, it is
  strongly encouraged to use the C<Configure> routine that was introduced
  in version 2.17. Besides, it is much easier.
  
  =head1 Tips and Techniques
  
  =head2 Pushing multiple values in a hash option
  
  Sometimes you want to combine the best of hashes and arrays. For
  example, the command line:
  
    --list add=first --list add=second --list add=third
  
  where each successive 'list add' option will push the value of add
  into array ref $list->{'add'}. The result would be like
  
    $list->{add} = [qw(first second third)];
  
  This can be accomplished with a destination routine:
  
    GetOptions('list=s%' =>
                 sub { push(@{$list{$_[1]}}, $_[2]) });
  
  =head1 Troubleshooting
  
  =head2 GetOptions does not return a false result when an option is not supplied
  
  That's why they're called 'options'.
  
  =head2 GetOptions does not split the command line correctly
  
  The command line is not split by GetOptions, but by the command line
  interpreter (CLI). On Unix, this is the shell. On Windows, it is
  COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.
  
  It is important to know that these CLIs may behave different when the
  command line contains special characters, in particular quotes or
  backslashes. For example, with Unix shells you can use single quotes
  (C<'>) and double quotes (C<">) to group words together. The following
  alternatives are equivalent on Unix:
  
      "two words"
      'two words'
      two\ words
  
  In case of doubt, insert the following statement in front of your Perl
  program:
  
      print STDERR (join("|",@ARGV),"\n");
  
  to verify how your CLI passes the arguments to the program.
  
  =head2 Undefined subroutine &main::GetOptions called
  
  Are you running Windows, and did you write
  
      use GetOpt::Long;
  
  (note the capital 'O')?
  
  =head2 How do I put a "-?" option into a Getopt::Long?
  
  You can only obtain this using an alias, and Getopt::Long of at least
  version 2.13.
  
      use Getopt::Long;
      GetOptions ("help|?");    # -help and -? will both set $opt_help
  
  Other characters that can't appear in Perl identifiers are also supported
  as aliases with Getopt::Long of at least version 2.39.
  
  As of version 2.32 Getopt::Long provides auto-help, a quick and easy way
  to add the options --help and -? to your program, and handle them.
  
  See C<auto_help> in section L<Configuring Getopt::Long>.
  
  =head1 AUTHOR
  
  Johan Vromans <jvromans@squirrel.nl>
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  This program is Copyright 1990,2015 by Johan Vromans.
  This program is free software; you can redistribute it and/or
  modify it under the terms of the Perl Artistic License or the
  GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any
  later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  If you do not have a copy of the GNU General Public License write to
  the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
  MA 02139, USA.
  
  =cut
  
GETOPT_LONG

$fatpacked{"IO/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_STRING';
  package IO::String;
  
  # Copyright 1998-2005 Gisle Aas.
  #
  # This library is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  require 5.005_03;
  use strict;
  use vars qw($VERSION $DEBUG $IO_CONSTANTS);
  $VERSION = "1.08";  # $Date: 2005/12/05 12:00:47 $
  
  use Symbol ();
  
  sub new
  {
      my $class = shift;
      my $self = bless Symbol::gensym(), ref($class) || $class;
      tie *$self, $self;
      $self->open(@_);
      return $self;
  }
  
  sub open
  {
      my $self = shift;
      return $self->new(@_) unless ref($self);
  
      if (@_) {
  	my $bufref = ref($_[0]) ? $_[0] : \$_[0];
  	$$bufref = "" unless defined $$bufref;
  	*$self->{buf} = $bufref;
      }
      else {
  	my $buf = "";
  	*$self->{buf} = \$buf;
      }
      *$self->{pos} = 0;
      *$self->{lno} = 0;
      return $self;
  }
  
  sub pad
  {
      my $self = shift;
      my $old = *$self->{pad};
      *$self->{pad} = substr($_[0], 0, 1) if @_;
      return "\0" unless defined($old) && length($old);
      return $old;
  }
  
  sub dump
  {
      require Data::Dumper;
      my $self = shift;
      print Data::Dumper->Dump([$self], ['*self']);
      print Data::Dumper->Dump([*$self{HASH}], ['$self{HASH}']);
      return;
  }
  
  sub TIEHANDLE
  {
      print "TIEHANDLE @_\n" if $DEBUG;
      return $_[0] if ref($_[0]);
      my $class = shift;
      my $self = bless Symbol::gensym(), $class;
      $self->open(@_);
      return $self;
  }
  
  sub DESTROY
  {
      print "DESTROY @_\n" if $DEBUG;
  }
  
  sub close
  {
      my $self = shift;
      delete *$self->{buf};
      delete *$self->{pos};
      delete *$self->{lno};
      undef *$self if $] eq "5.008";  # workaround for some bug
      return 1;
  }
  
  sub opened
  {
      my $self = shift;
      return defined *$self->{buf};
  }
  
  sub binmode
  {
      my $self = shift;
      return 1 unless @_;
      # XXX don't know much about layers yet :-(
      return 0;
  }
  
  sub getc
  {
      my $self = shift;
      my $buf;
      return $buf if $self->read($buf, 1);
      return undef;
  }
  
  sub ungetc
  {
      my $self = shift;
      $self->setpos($self->getpos() - 1);
      return 1;
  }
  
  sub eof
  {
      my $self = shift;
      return length(${*$self->{buf}}) <= *$self->{pos};
  }
  
  sub print
  {
      my $self = shift;
      if (defined $\) {
  	if (defined $,) {
  	    $self->write(join($,, @_).$\);
  	}
  	else {
  	    $self->write(join("",@_).$\);
  	}
      }
      else {
  	if (defined $,) {
  	    $self->write(join($,, @_));
  	}
  	else {
  	    $self->write(join("",@_));
  	}
      }
      return 1;
  }
  *printflush = \*print;
  
  sub printf
  {
      my $self = shift;
      print "PRINTF(@_)\n" if $DEBUG;
      my $fmt = shift;
      $self->write(sprintf($fmt, @_));
      return 1;
  }
  
  
  my($SEEK_SET, $SEEK_CUR, $SEEK_END);
  
  sub _init_seek_constants
  {
      if ($IO_CONSTANTS) {
  	require IO::Handle;
  	$SEEK_SET = &IO::Handle::SEEK_SET;
  	$SEEK_CUR = &IO::Handle::SEEK_CUR;
  	$SEEK_END = &IO::Handle::SEEK_END;
      }
      else {
  	$SEEK_SET = 0;
  	$SEEK_CUR = 1;
  	$SEEK_END = 2;
      }
  }
  
  
  sub seek
  {
      my($self,$off,$whence) = @_;
      my $buf = *$self->{buf} || return 0;
      my $len = length($$buf);
      my $pos = *$self->{pos};
  
      _init_seek_constants() unless defined $SEEK_SET;
  
      if    ($whence == $SEEK_SET) { $pos = $off }
      elsif ($whence == $SEEK_CUR) { $pos += $off }
      elsif ($whence == $SEEK_END) { $pos = $len + $off }
      else                         { die "Bad whence ($whence)" }
      print "SEEK(POS=$pos,OFF=$off,LEN=$len)\n" if $DEBUG;
  
      $pos = 0 if $pos < 0;
      $self->truncate($pos) if $pos > $len;  # extend file
      *$self->{pos} = $pos;
      return 1;
  }
  
  sub pos
  {
      my $self = shift;
      my $old = *$self->{pos};
      if (@_) {
  	my $pos = shift || 0;
  	my $buf = *$self->{buf};
  	my $len = $buf ? length($$buf) : 0;
  	$pos = $len if $pos > $len;
  	*$self->{pos} = $pos;
      }
      return $old;
  }
  
  sub getpos { shift->pos; }
  
  *sysseek = \&seek;
  *setpos  = \&pos;
  *tell    = \&getpos;
  
  
  
  sub getline
  {
      my $self = shift;
      my $buf  = *$self->{buf} || return;
      my $len  = length($$buf);
      my $pos  = *$self->{pos};
      return if $pos >= $len;
  
      unless (defined $/) {  # slurp
  	*$self->{pos} = $len;
  	return substr($$buf, $pos);
      }
  
      unless (length $/) {  # paragraph mode
  	# XXX slow&lazy implementation using getc()
  	my $para = "";
  	my $eol = 0;
  	my $c;
  	while (defined($c = $self->getc)) {
  	    if ($c eq "\n") {
  		$eol++;
  		next if $eol > 2;
  	    }
  	    elsif ($eol > 1) {
  		$self->ungetc($c);
  		last;
  	    }
  	    else {
  		$eol = 0;
  	    }
  	    $para .= $c;
  	}
  	return $para;   # XXX wantarray
      }
  
      my $idx = index($$buf,$/,$pos);
      if ($idx < 0) {
  	# return rest of it
  	*$self->{pos} = $len;
  	$. = ++ *$self->{lno};
  	return substr($$buf, $pos);
      }
      $len = $idx - $pos + length($/);
      *$self->{pos} += $len;
      $. = ++ *$self->{lno};
      return substr($$buf, $pos, $len);
  }
  
  sub getlines
  {
      die "getlines() called in scalar context\n" unless wantarray;
      my $self = shift;
      my($line, @lines);
      push(@lines, $line) while defined($line = $self->getline);
      return @lines;
  }
  
  sub READLINE
  {
      goto &getlines if wantarray;
      goto &getline;
  }
  
  sub input_line_number
  {
      my $self = shift;
      my $old = *$self->{lno};
      *$self->{lno} = shift if @_;
      return $old;
  }
  
  sub truncate
  {
      my $self = shift;
      my $len = shift || 0;
      my $buf = *$self->{buf};
      if (length($$buf) >= $len) {
  	substr($$buf, $len) = '';
  	*$self->{pos} = $len if $len < *$self->{pos};
      }
      else {
  	$$buf .= ($self->pad x ($len - length($$buf)));
      }
      return 1;
  }
  
  sub read
  {
      my $self = shift;
      my $buf = *$self->{buf};
      return undef unless $buf;
  
      my $pos = *$self->{pos};
      my $rem = length($$buf) - $pos;
      my $len = $_[1];
      $len = $rem if $len > $rem;
      return undef if $len < 0;
      if (@_ > 2) { # read offset
  	substr($_[0],$_[2]) = substr($$buf, $pos, $len);
      }
      else {
  	$_[0] = substr($$buf, $pos, $len);
      }
      *$self->{pos} += $len;
      return $len;
  }
  
  sub write
  {
      my $self = shift;
      my $buf = *$self->{buf};
      return unless $buf;
  
      my $pos = *$self->{pos};
      my $slen = length($_[0]);
      my $len = $slen;
      my $off = 0;
      if (@_ > 1) {
  	$len = $_[1] if $_[1] < $len;
  	if (@_ > 2) {
  	    $off = $_[2] || 0;
  	    die "Offset outside string" if $off > $slen;
  	    if ($off < 0) {
  		$off += $slen;
  		die "Offset outside string" if $off < 0;
  	    }
  	    my $rem = $slen - $off;
  	    $len = $rem if $rem < $len;
  	}
      }
      substr($$buf, $pos, $len) = substr($_[0], $off, $len);
      *$self->{pos} += $len;
      return $len;
  }
  
  *sysread = \&read;
  *syswrite = \&write;
  
  sub stat
  {
      my $self = shift;
      return unless $self->opened;
      return 1 unless wantarray;
      my $len = length ${*$self->{buf}};
  
      return (
       undef, undef,  # dev, ino
       0666,          # filemode
       1,             # links
       $>,            # user id
       $),            # group id
       undef,         # device id
       $len,          # size
       undef,         # atime
       undef,         # mtime
       undef,         # ctime
       512,           # blksize
       int(($len+511)/512)  # blocks
      );
  }
  
  sub FILENO {
      return undef;   # XXX perlfunc says this means the file is closed
  }
  
  sub blocking {
      my $self = shift;
      my $old = *$self->{blocking} || 0;
      *$self->{blocking} = shift if @_;
      return $old;
  }
  
  my $notmuch = sub { return };
  
  *fileno    = $notmuch;
  *error     = $notmuch;
  *clearerr  = $notmuch; 
  *sync      = $notmuch;
  *flush     = $notmuch;
  *setbuf    = $notmuch;
  *setvbuf   = $notmuch;
  
  *untaint   = $notmuch;
  *autoflush = $notmuch;
  *fcntl     = $notmuch;
  *ioctl     = $notmuch;
  
  *GETC   = \&getc;
  *PRINT  = \&print;
  *PRINTF = \&printf;
  *READ   = \&read;
  *WRITE  = \&write;
  *SEEK   = \&seek;
  *TELL   = \&getpos;
  *EOF    = \&eof;
  *CLOSE  = \&close;
  *BINMODE = \&binmode;
  
  
  sub string_ref
  {
      my $self = shift;
      return *$self->{buf};
  }
  *sref = \&string_ref;
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::String - Emulate file interface for in-core strings
  
  =head1 SYNOPSIS
  
   use IO::String;
   $io = IO::String->new;
   $io = IO::String->new($var);
   tie *IO, 'IO::String';
  
   # read data
   <$io>;
   $io->getline;
   read($io, $buf, 100);
  
   # write data
   print $io "string\n";
   $io->print(@data);
   syswrite($io, $buf, 100);
  
   select $io;
   printf "Some text %s\n", $str;
  
   # seek
   $pos = $io->getpos;
   $io->setpos(0);        # rewind
   $io->seek(-30, -1);
   seek($io, 0, 0);
  
  =head1 DESCRIPTION
  
  The C<IO::String> module provides the C<IO::File> interface for in-core
  strings.  An C<IO::String> object can be attached to a string, and
  makes it possible to use the normal file operations for reading or
  writing data, as well as for seeking to various locations of the string.
  This is useful when you want to use a library module that only
  provides an interface to file handles on data that you have in a string
  variable.
  
  Note that perl-5.8 and better has built-in support for "in memory"
  files, which are set up by passing a reference instead of a filename
  to the open() call. The reason for using this module is that it
  makes the code backwards compatible with older versions of Perl.
  
  The C<IO::String> module provides an interface compatible with
  C<IO::File> as distributed with F<IO-1.20>, but the following methods
  are not available: new_from_fd, fdopen, format_write,
  format_page_number, format_lines_per_page, format_lines_left,
  format_name, format_top_name.
  
  The following methods are specific to the C<IO::String> class:
  
  =over 4
  
  =item $io = IO::String->new
  
  =item $io = IO::String->new( $string )
  
  The constructor returns a newly-created C<IO::String> object.  It
  takes an optional argument, which is the string to read from or write
  into.  If no $string argument is given, then an internal buffer
  (initially empty) is allocated.
  
  The C<IO::String> object returned is tied to itself.  This means
  that you can use most Perl I/O built-ins on it too: readline, <>, getc,
  print, printf, syswrite, sysread, close.
  
  =item $io->open
  
  =item $io->open( $string )
  
  Attaches an existing IO::String object to some other $string, or
  allocates a new internal buffer (if no argument is given).  The
  position is reset to 0.
  
  =item $io->string_ref
  
  Returns a reference to the string that is attached to
  the C<IO::String> object.  Most useful when you let the C<IO::String>
  create an internal buffer to write into.
  
  =item $io->pad
  
  =item $io->pad( $char )
  
  Specifies the padding to use if
  the string is extended by either the seek() or truncate() methods.  It
  is a single character and defaults to "\0".
  
  =item $io->pos
  
  =item $io->pos( $newpos )
  
  Yet another interface for reading and setting the current read/write
  position within the string (the normal getpos/setpos/tell/seek
  methods are also available).  The pos() method always returns the
  old position, and if you pass it an argument it sets the new
  position.
  
  There is (deliberately) a difference between the setpos() and seek()
  methods in that seek() extends the string (with the specified
  padding) if you go to a location past the end, whereas setpos()
  just snaps back to the end.  If truncate() is used to extend the string,
  then it works as seek().
  
  =back
  
  =head1 BUGS
  
  In Perl versions < 5.6, the TIEHANDLE interface was incomplete.
  If you use such a Perl, then seek(), tell(), eof(), fileno(), binmode() will
  not do anything on an C<IO::String> handle.  See L<perltie> for
  details.
  
  =head1 SEE ALSO
  
  L<IO::File>, L<IO::Stringy>, L<perlfunc/open>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2005 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
IO_STRING

$fatpacked{"List/MoreUtils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIST_MOREUTILS';
  package List::MoreUtils;
  
  use 5.008_001;
  use strict;
  use warnings;
  
  my $have_xs;
  our $VERSION = '0.428';
  
  BEGIN
  {
      unless (defined($have_xs))
      {
          eval { require List::MoreUtils::XS; } unless $ENV{LIST_MOREUTILS_PP};
          die $@ if $@ && defined $ENV{LIST_MOREUTILS_PP} && $ENV{LIST_MOREUTILS_PP} == 0;
          $have_xs = 0+defined( $INC{'List/MoreUtils/XS.pm'});
      }
  
      use List::MoreUtils::PP qw();
  }
  
  use Exporter::Tiny qw();
  
  my @junctions = qw(any all none notall);
  my @v0_22     = qw(
    true false
    firstidx lastidx
    insert_after insert_after_string
    apply indexes
    after after_incl before before_incl
    firstval lastval
    each_array each_arrayref
    pairwise natatime
    mesh uniq
    minmax part
    _XScompiled
  );
  my @v0_24  = qw(bsearch);
  my @v0_33  = qw(sort_by nsort_by);
  my @v0_400 = qw(one any_u all_u none_u notall_u one_u
    firstres onlyidx onlyval onlyres lastres
    singleton bsearchidx
  );
  my @v0_420 = qw(arrayify duplicates minmaxstr samples zip6 reduce_0 reduce_1 reduce_u
    listcmp frequency occurrences mode
    binsert bremove equal_range lower_bound upper_bound qsort);
  
  my @all_functions = (@junctions, @v0_22, @v0_24, @v0_33, @v0_400, @v0_420);
  
  no strict "refs";
  if ($have_xs)
  {
      my $x;
      for (@all_functions)
      {
          List::MoreUtils->can($_) or *$_ = $x if ($x = List::MoreUtils::XS->can($_));
      }
  }
  List::MoreUtils->can($_) or *$_ = List::MoreUtils::PP->can($_) for (@all_functions);
  use strict;
  
  my %alias_list = (
      v0_22 => {
          first_index => "firstidx",
          last_index  => "lastidx",
          first_value => "firstval",
          last_value  => "lastval",
          zip         => "mesh",
      },
      v0_33 => {
          distinct => "uniq",
      },
      v0_400 => {
          first_result  => "firstres",
          only_index    => "onlyidx",
          only_value    => "onlyval",
          only_result   => "onlyres",
          last_result   => "lastres",
          bsearch_index => "bsearchidx",
      },
      v0_420 => {
  	bsearch_insert => "binsert",
  	bsearch_remove => "bremove",
  	zip_unflatten  => "zip6",
      },
  );
  
  our @ISA         = qw(Exporter::Tiny);
  our @EXPORT_OK   = (@all_functions, map { keys %$_ } values %alias_list);
  our %EXPORT_TAGS = (
      all         => \@EXPORT_OK,
      'like_0.22' => [
          any_u    => {-as => 'any'},
          all_u    => {-as => 'all'},
          none_u   => {-as => 'none'},
          notall_u => {-as => 'notall'},
          @v0_22,
          keys %{$alias_list{v0_22}},
      ],
      'like_0.24' => [
          any_u    => {-as => 'any'},
          all_u    => {-as => 'all'},
          notall_u => {-as => 'notall'},
          'none',
          @v0_22,
          @v0_24,
          keys %{$alias_list{v0_22}},
      ],
      'like_0.33' => [
          @junctions,
          @v0_22,
          # v0_24 functions were omitted
          @v0_33,
          keys %{$alias_list{v0_22}},
          keys %{$alias_list{v0_33}},
      ],
  );
  
  for my $set (values %alias_list)
  {
      for my $alias (keys %$set)
      {
          no strict qw(refs);
          *$alias = __PACKAGE__->can($set->{$alias});
      }
  }
  
  =pod
  
  =head1 NAME
  
  List::MoreUtils - Provide the stuff missing in List::Util
  
  =head1 SYNOPSIS
  
      # import specific functions
  
      use List::MoreUtils qw(any uniq);
  
      if ( any { /foo/ } uniq @has_duplicates ) {
          # do stuff
      }
  
      # import everything
  
      use List::MoreUtils ':all';
  
      # import by API
  
      # has "original" any/all/none/notall behavior
      use List::MoreUtils ':like_0.22';
      # 0.22 + bsearch
      use List::MoreUtils ':like_0.24';
      # has "simplified" any/all/none/notall behavior + (n)sort_by
      use List::MoreUtils ':like_0.33';
  
  =head1 DESCRIPTION
  
  B<List::MoreUtils> provides some trivial but commonly needed functionality on
  lists which is not going to go into L<List::Util>.
  
  All of the below functions are implementable in only a couple of lines of Perl
  code. Using the functions from this module however should give slightly better
  performance as everything is implemented in C. The pure-Perl implementation of
  these functions only serves as a fallback in case the C portions of this module
  couldn't be compiled on this machine.
  
  =head1 EXPORTS
  
  =head2 Default behavior
  
  Nothing by default. To import all of this module's symbols use the C<:all> tag.
  Otherwise functions can be imported by name as usual:
  
      use List::MoreUtils ':all';
  
      use List::MoreUtils qw{ any firstidx };
  
  Because historical changes to the API might make upgrading List::MoreUtils
  difficult for some projects, the legacy API is available via special import
  tags.
  
  =head2 Like version 0.22 (last release with original API)
  
  This API was available from 2006 to 2009, returning undef for empty lists on
  C<all>/C<any>/C<none>/C<notall>:
  
      use List::MoreUtils ':like_0.22';
  
  This import tag will import all functions available as of version 0.22.
  However, it will import C<any_u> as C<any>, C<all_u> as C<all>, C<none_u> as
  C<none>, and C<notall_u> as C<notall>.
  
  =head2 Like version 0.24 (first incompatible change)
  
  This API was available from 2010 to 2011.  It changed the return value of C<none>
  and added the C<bsearch> function.
  
      use List::MoreUtils ':like_0.24';
  
  This import tag will import all functions available as of version 0.24.
  However it will import C<any_u> as C<any>, C<all_u> as C<all>, and
  C<notall_u> as C<notall>.  It will import C<none> as described in
  the documentation below (true for empty list).
  
  =head2 Like version 0.33 (second incompatible change)
  
  This API was available from 2011 to 2014. It is widely used in several CPAN
  modules and thus it's closest to the current API.  It changed the return values
  of C<any>, C<all>, and C<notall>.  It added the C<sort_by> and C<nsort_by> functions
  and the C<distinct> alias for C<uniq>.  It omitted C<bsearch>.
  
      use List::MoreUtils ':like_0.33';
  
  This import tag will import all functions available as of version 0.33.  Note:
  it will not import C<bsearch> for consistency with the 0.33 API.
  
  =head1 FUNCTIONS
  
  =head2 Junctions
  
  =head3 I<Treatment of an empty list>
  
  There are two schools of thought for how to evaluate a junction on an
  empty list:
  
  =over
  
  =item *
  
  Reduction to an identity (boolean)
  
  =item *
  
  Result is undefined (three-valued)
  
  =back
  
  In the first case, the result of the junction applied to the empty list is
  determined by a mathematical reduction to an identity depending on whether
  the underlying comparison is "or" or "and".  Conceptually:
  
                      "any are true"      "all are true"
                      --------------      --------------
      2 elements:     A || B || 0         A && B && 1
      1 element:      A || 0              A && 1
      0 elements:     0                   1
  
  In the second case, three-value logic is desired, in which a junction
  applied to an empty list returns C<undef> rather than true or false 
  
  Junctions with a C<_u> suffix implement three-valued logic.  Those
  without are boolean.
  
  =head3 all BLOCK LIST
  
  =head3 all_u BLOCK LIST
  
  Returns a true value if all items in LIST meet the criterion given through
  BLOCK. Sets C<$_> for each item in LIST in turn:
  
    print "All values are non-negative"
      if all { $_ >= 0 } ($x, $y, $z);
  
  For an empty LIST, C<all> returns true (i.e. no values failed the condition)
  and C<all_u> returns C<undef>.
  
  Thus, C<< all_u(@list) >> is equivalent to C<< @list ? all(@list) : undef >>.
  
  B<Note>: because Perl treats C<undef> as false, you must check the return value
  of C<all_u> with C<defined> or you will get the opposite result of what you
  expect.
  
  =head3 any BLOCK LIST
  
  =head3 any_u BLOCK LIST
  
  Returns a true value if any item in LIST meets the criterion given through
  BLOCK. Sets C<$_> for each item in LIST in turn:
  
    print "At least one non-negative value"
      if any { $_ >= 0 } ($x, $y, $z);
  
  For an empty LIST, C<any> returns false and C<any_u> returns C<undef>.
  
  Thus, C<< any_u(@list) >> is equivalent to C<< @list ? any(@list) : undef >>.
  
  =head3 none BLOCK LIST
  
  =head3 none_u BLOCK LIST
  
  Logically the negation of C<any>. Returns a true value if no item in LIST meets
  the criterion given through BLOCK. Sets C<$_> for each item in LIST in turn:
  
    print "No non-negative values"
      if none { $_ >= 0 } ($x, $y, $z);
  
  For an empty LIST, C<none> returns true (i.e. no values failed the condition)
  and C<none_u> returns C<undef>.
  
  Thus, C<< none_u(@list) >> is equivalent to C<< @list ? none(@list) : undef >>.
  
  B<Note>: because Perl treats C<undef> as false, you must check the return value
  of C<none_u> with C<defined> or you will get the opposite result of what you
  expect.
  
  =head3 notall BLOCK LIST
  
  =head3 notall_u BLOCK LIST
  
  Logically the negation of C<all>. Returns a true value if not all items in LIST
  meet the criterion given through BLOCK. Sets C<$_> for each item in LIST in
  turn:
  
    print "Not all values are non-negative"
      if notall { $_ >= 0 } ($x, $y, $z);
  
  For an empty LIST, C<notall> returns false and C<notall_u> returns C<undef>.
  
  Thus, C<< notall_u(@list) >> is equivalent to C<< @list ? notall(@list) : undef >>.
  
  =head3 one BLOCK LIST
  
  =head3 one_u BLOCK LIST
  
  Returns a true value if precisely one item in LIST meets the criterion
  given through BLOCK. Sets C<$_> for each item in LIST in turn:
  
      print "Precisely one value defined"
          if one { defined($_) } @list;
  
  Returns false otherwise.
  
  For an empty LIST, C<one> returns false and C<one_u> returns C<undef>.
  
  The expression C<one BLOCK LIST> is almost equivalent to
  C<1 == true BLOCK LIST>, except for short-cutting.
  Evaluation of BLOCK will immediately stop at the second true value.
  
  =head2 Transformation
  
  =head3 apply BLOCK LIST
  
  Applies BLOCK to each item in LIST and returns a list of the values after BLOCK
  has been applied. In scalar context, the last element is returned.  This
  function is similar to C<map> but will not modify the elements of the input
  list:
  
    my @list = (1 .. 4);
    my @mult = apply { $_ *= 2 } @list;
    print "\@list = @list\n";
    print "\@mult = @mult\n";
    __END__
    @list = 1 2 3 4
    @mult = 2 4 6 8
  
  Think of it as syntactic sugar for
  
    for (my @mult = @list) { $_ *= 2 }
  
  =head3 insert_after BLOCK VALUE LIST
  
  Inserts VALUE after the first item in LIST for which the criterion in BLOCK is
  true. Sets C<$_> for each item in LIST in turn.
  
    my @list = qw/This is a list/;
    insert_after { $_ eq "a" } "longer" => @list;
    print "@list";
    __END__
    This is a longer list
  
  =head3 insert_after_string STRING VALUE LIST
  
  Inserts VALUE after the first item in LIST which is equal to STRING. 
  
    my @list = qw/This is a list/;
    insert_after_string "a", "longer" => @list;
    print "@list";
    __END__
    This is a longer list
  
  =head3 pairwise BLOCK ARRAY1 ARRAY2
  
  Evaluates BLOCK for each pair of elements in ARRAY1 and ARRAY2 and returns a
  new list consisting of BLOCK's return values. The two elements are set to C<$a>
  and C<$b>.  Note that those two are aliases to the original value so changing
  them will modify the input arrays.
  
    @a = (1 .. 5);
    @b = (11 .. 15);
    @x = pairwise { $a + $b } @a, @b;     # returns 12, 14, 16, 18, 20
  
    # mesh with pairwise
    @a = qw/a b c/;
    @b = qw/1 2 3/;
    @x = pairwise { ($a, $b) } @a, @b;    # returns a, 1, b, 2, c, 3
  
  =head3 mesh ARRAY1 ARRAY2 [ ARRAY3 ... ]
  
  =head3 zip ARRAY1 ARRAY2 [ ARRAY3 ... ]
  
  Returns a list consisting of the first elements of each array, then
  the second, then the third, etc, until all arrays are exhausted.
  
  Examples:
  
    @x = qw/a b c d/;
    @y = qw/1 2 3 4/;
    @z = mesh @x, @y;         # returns a, 1, b, 2, c, 3, d, 4
  
    @a = ('x');
    @b = ('1', '2');
    @c = qw/zip zap zot/;
    @d = mesh @a, @b, @c;   # x, 1, zip, undef, 2, zap, undef, undef, zot
  
  C<zip> is an alias for C<mesh>.
  
  =head3 zip6
  
  =head3 zip_unflatten
  
  Returns a list of arrays consisting of the first elements of each array,
  then the second, then the third, etc, until all arrays are exhausted.
  
    @x = qw/a b c d/;
    @y = qw/1 2 3 4/;
    @z = zip6 @x, @y;         # returns [a, 1], [b, 2], [c, 3], [d, 4]
  
    @a = ('x');
    @b = ('1', '2');
    @c = qw/zip zap zot/;
    @d = zip6 @a, @b, @c;     # [x, 1, zip], [undef, 2, zap], [undef, undef, zot]
  
  C<zip_unflatten> is an alias for C<zip6>.
  
  =head3 listcmp ARRAY0 ARRAY1 [ ARRAY2 ... ]
  
  Returns an associative list of elements and every I<id> of the list it
  was found in. Allowes easy implementation of @a & @b, @a | @b, @a ^ @b and
  so on.
  Undefined entries in any given array are skipped.
  
    my @a = qw(one two three four five six seven eight nine ten eleven twelve thirteen);
    my @b = qw(two three five seven eleven thirteen seventeen);
    my @c = qw(one one two three five eight thirteen twentyone);
    my %cmp = listcmp @a, @b, @c; # returns (one => [0, 2], two => [0, 1, 2], three => [0, 1, 2], four => [0], ...)
  
    my @seq = (1, 2, 3);
    my @prim = (undef, 2, 3, 5);
    my @fib = (1, 1, 2);
    my $cmp = listcmp @seq, @prim, @fib;
    # returns { 1 => [0, 2], 2 => [0, 1, 2], 3 => [0, 1], 5 => [1] }
  
  =head3 arrayify LIST[,LIST[,LIST...]]
  
  Returns a list costisting of each element of given arrays. Recursive arrays
  are flattened, too.
  
    @a = (1, [[2], 3], 4, [5], 6, [7], 8, 9);
    @l = arrayify @a;         # returns 1, 2, 3, 4, 5, 6, 7, 8, 9
  
  =head3 uniq LIST
  
  =head3 distinct LIST
  
  Returns a new list by stripping duplicate values in LIST by comparing
  the values as hash keys, except that undef is considered separate from ''.
  The order of elements in the returned list is the same as in LIST. In
  scalar context, returns the number of unique elements in LIST.
  
    my @x = uniq 1, 1, 2, 2, 3, 5, 3, 4; # returns 1 2 3 5 4
    my $x = uniq 1, 1, 2, 2, 3, 5, 3, 4; # returns 5
    # returns "Mike", "Michael", "Richard", "Rick"
    my @n = distinct "Mike", "Michael", "Richard", "Rick", "Michael", "Rick"
    # returns "A8", "", undef, "A5", "S1"
    my @s = distinct "A8", "", undef, "A5", "S1", "A5", "A8"
    # returns "Giulia", "Giulietta", undef, "", 156, "GTA", "GTV", 159, "Brera", "4C"
    my @w = uniq "Giulia", "Giulietta", undef, "", 156, "GTA", "GTV", 159, "Brera", "4C", "Giulietta", "Giulia"
  
  C<distinct> is an alias for C<uniq>.
  
  B<RT#49800> can be used to give feedback about this behavior.
  
  =head3 singleton LIST
  
  Returns a new list by stripping values in LIST occurring more than once by
  comparing the values as hash keys, except that undef is considered separate
  from ''.  The order of elements in the returned list is the same as in LIST.
  In scalar context, returns the number of elements occurring only once in LIST.
  
    my @x = singleton 1,1,2,2,3,4,5 # returns 3 4 5
  
  =head3 duplicates LIST
  
  Returns a new list by stripping values in LIST occuring less than twice by
  comparing the values as hash keys, except that undef is considered separate
  from ''.  The order of elements in the returned list is the same as in LIST.
  In scalar context, returns the number of elements occurring only once in LIST.
  
    my @y = duplicates 1,1,2,4,7,2,3,4,6,9; #returns 1,2,4
  
  =head3 frequency LIST
  
  Returns an associative list of distinct values and the corresponding frequency.
  
    my @f = frequency values %radio_nrw; # returns (
    #  'Deutschlandfunk (DLF)' => 9, 'WDR 3' => 10,
    #  'WDR 4' => 11, 'WDR 5' => 14, 'WDR Eins Live' => 14,
    #  'Deutschlandradio Kultur' => 8,...)
  
  =head3 occurrences LIST
  
  Returns a new list of frequencies and the corresponding values from LIST.
  
    my @o = occurrences ((1) x 3, (2) x 4, (3) x 2, (4) x 7, (5) x 2, (6) x 4);
    #  @o = (undef, undef, [3, 5], [1], [2, 6], undef, undef, [4]);
  
  =head3 mode LIST
  
  Returns the modal value of LIST. In scalar context, just the modal value
  is returned, in list context all probes occuring I<modal> times are returned,
  too.
  
    my @m = mode ((1) x 3, (2) x 4, (3) x 2, (4) x 7, (5) x 2, (6) x 4, (7) x 3, (8) x 7);
    #  @m = (7, 4, 8) - bimodal LIST
  
  =head2 Partitioning
  
  =head3 after BLOCK LIST
  
  Returns a list of the values of LIST after (and not including) the point
  where BLOCK returns a true value. Sets C<$_> for each element in LIST in turn.
  
    @x = after { $_ % 5 == 0 } (1..9);    # returns 6, 7, 8, 9
  
  =head3 after_incl BLOCK LIST
  
  Same as C<after> but also includes the element for which BLOCK is true.
  
  =head3 before BLOCK LIST
  
  Returns a list of values of LIST up to (and not including) the point where BLOCK
  returns a true value. Sets C<$_> for each element in LIST in turn.
  
  =head3 before_incl BLOCK LIST
  
  Same as C<before> but also includes the element for which BLOCK is true.
  
  =head3 part BLOCK LIST
  
  Partitions LIST based on the return value of BLOCK which denotes into which
  partition the current value is put.
  
  Returns a list of the partitions thusly created. Each partition created is a
  reference to an array.
  
    my $i = 0;
    my @part = part { $i++ % 2 } 1 .. 8;   # returns [1, 3, 5, 7], [2, 4, 6, 8]
  
  You can have a sparse list of partitions as well where non-set partitions will
  be undef:
  
    my @part = part { 2 } 1 .. 10;            # returns undef, undef, [ 1 .. 10 ]
  
  Be careful with negative values, though:
  
    my @part = part { -1 } 1 .. 10;
    __END__
    Modification of non-creatable array value attempted, subscript -1 ...
  
  Negative values are only ok when they refer to a partition previously created:
  
    my @idx  = ( 0, 1, -1 );
    my $i    = 0;
    my @part = part { $idx[$++ % 3] } 1 .. 8; # [1, 4, 7], [2, 3, 5, 6, 8]
  
  =head3 samples COUNT LIST
  
  Returns a new list containing COUNT random samples from LIST. Is similar to
  L<List::Util/shuffle>, but stops after COUNT.
  
    @r  = samples 10, 1..10; # same as shuffle
    @r2 = samples 5, 1..10; # gives 5 values from 1..10;
  
  =head2 Iteration
  
  =head3 each_array ARRAY1 ARRAY2 ...
  
  Creates an array iterator to return the elements of the list of arrays ARRAY1,
  ARRAY2 throughout ARRAYn in turn.  That is, the first time it is called, it
  returns the first element of each array.  The next time, it returns the second
  elements.  And so on, until all elements are exhausted.
  
  This is useful for looping over more than one array at once:
  
    my $ea = each_array(@a, @b, @c);
    while ( my ($a, $b, $c) = $ea->() )   { .... }
  
  The iterator returns the empty list when it reached the end of all arrays.
  
  If the iterator is passed an argument of 'C<index>', then it returns
  the index of the last fetched set of values, as a scalar.
  
  =head3 each_arrayref LIST
  
  Like each_array, but the arguments are references to arrays, not the
  plain arrays.
  
  =head3 natatime EXPR, LIST
  
  Creates an array iterator, for looping over an array in chunks of
  C<$n> items at a time.  (n at a time, get it?).  An example is
  probably a better explanation than I could give in words.
  
  Example:
  
    my @x = ('a' .. 'g');
    my $it = natatime 3, @x;
    while (my @vals = $it->())
    {
      print "@vals\n";
    }
  
  This prints
  
    a b c
    d e f
    g
  
  =head2 Searching
  
  =head3 firstval BLOCK LIST
  
  =head3 first_value BLOCK LIST
  
  Returns the first element in LIST for which BLOCK evaluates to true. Each
  element of LIST is set to C<$_> in turn. Returns C<undef> if no such element
  has been found.
  
  C<first_value> is an alias for C<firstval>.
  
  =head3 onlyval BLOCK LIST
  
  =head3 only_value BLOCK LIST
  
  Returns the only element in LIST for which BLOCK evaluates to true. Sets
  C<$_> for each item in LIST in turn. Returns C<undef> if no such element
  has been found.
  
  C<only_value> is an alias for C<onlyval>.
  
  =head3 lastval BLOCK LIST
  
  =head3 last_value BLOCK LIST
  
  Returns the last value in LIST for which BLOCK evaluates to true. Each element
  of LIST is set to C<$_> in turn. Returns C<undef> if no such element has been
  found.
  
  C<last_value> is an alias for C<lastval>.
  
  =head3 firstres BLOCK LIST
  
  =head3 first_result BLOCK LIST
  
  Returns the result of BLOCK for the first element in LIST for which BLOCK
  evaluates to true. Each element of LIST is set to C<$_> in turn. Returns
  C<undef> if no such element has been found.
  
  C<first_result> is an alias for C<firstres>.
  
  =head3 onlyres BLOCK LIST
  
  =head3 only_result BLOCK LIST
  
  Returns the result of BLOCK for the first element in LIST for which BLOCK
  evaluates to true. Sets C<$_> for each item in LIST in turn. Returns
  C<undef> if no such element has been found.
  
  C<only_result> is an alias for C<onlyres>.
  
  =head3 lastres BLOCK LIST
  
  =head3 last_result BLOCK LIST
  
  Returns the result of BLOCK for the last element in LIST for which BLOCK
  evaluates to true. Each element of LIST is set to C<$_> in turn. Returns
  C<undef> if no such element has been found.
  
  C<last_result> is an alias for C<lastres>.
  
  =head3 indexes BLOCK LIST
  
  Evaluates BLOCK for each element in LIST (assigned to C<$_>) and returns a list
  of the indices of those elements for which BLOCK returned a true value. This is
  just like C<grep> only that it returns indices instead of values:
  
    @x = indexes { $_ % 2 == 0 } (1..10);   # returns 1, 3, 5, 7, 9
  
  =head3 firstidx BLOCK LIST
  
  =head3 first_index BLOCK LIST
  
  Returns the index of the first element in LIST for which the criterion in BLOCK
  is true. Sets C<$_> for each item in LIST in turn:
  
    my @list = (1, 4, 3, 2, 4, 6);
    printf "item with index %i in list is 4", firstidx { $_ == 4 } @list;
    __END__
    item with index 1 in list is 4
  
  Returns C<-1> if no such item could be found.
  
  C<first_index> is an alias for C<firstidx>.
  
  =head3 onlyidx BLOCK LIST
  
  =head3 only_index BLOCK LIST
  
  Returns the index of the only element in LIST for which the criterion
  in BLOCK is true. Sets C<$_> for each item in LIST in turn:
  
      my @list = (1, 3, 4, 3, 2, 4);
      printf "uniqe index of item 2 in list is %i", onlyidx { $_ == 2 } @list;
      __END__
      unique index of item 2 in list is 4
  
  Returns C<-1> if either no such item or more than one of these
  has been found.
  
  C<only_index> is an alias for C<onlyidx>.
  
  =head3 lastidx BLOCK LIST
  
  =head3 last_index BLOCK LIST
  
  Returns the index of the last element in LIST for which the criterion in BLOCK
  is true. Sets C<$_> for each item in LIST in turn:
  
    my @list = (1, 4, 3, 2, 4, 6);
    printf "item with index %i in list is 4", lastidx { $_ == 4 } @list;
    __END__
    item with index 4 in list is 4
  
  Returns C<-1> if no such item could be found.
  
  C<last_index> is an alias for C<lastidx>.
  
  =head2 Sorting
  
  =head3 sort_by BLOCK LIST
  
  Returns the list of values sorted according to the string values returned by the
  KEYFUNC block or function. A typical use of this may be to sort objects according
  to the string value of some accessor, such as
  
    sort_by { $_->name } @people
  
  The key function is called in scalar context, being passed each value in turn as
  both $_ and the only argument in the parameters, @_. The values are then sorted
  according to string comparisons on the values returned.
  This is equivalent to
  
    sort { $a->name cmp $b->name } @people
  
  except that it guarantees the name accessor will be executed only once per value.
  One interesting use-case is to sort strings which may have numbers embedded in them
  "naturally", rather than lexically.
  
    sort_by { s/(\d+)/sprintf "%09d", $1/eg; $_ } @strings
  
  This sorts strings by generating sort keys which zero-pad the embedded numbers to
  some level (9 digits in this case), helping to ensure the lexical sort puts them
  in the correct order.
  
  =head3 nsort_by BLOCK LIST
  
  Similar to sort_by but compares its key values numerically.
  
  =head3 qsort BLOCK ARRAY
  
  This sorts the given array B<in place> using the given compare code. Except for
  tiny compare code like C<< $a <=> $b >>, qsort is much faster than Perl's C<sort>
  depending on the version.
  
  Compared 5.8 and 5.26:
  
    my @rl;
    for(my $i = 0; $i < 1E6; ++$i) { push @rl, rand(1E5) }
    my $idx;
  
    sub ext_cmp { $_[0] <=> $_[1] }
  
    cmpthese( -60, {
        'qsort' => sub {
  	  my @qrl = @rl;
  	  qsort { ext_cmp($a, $b) } @qrl;
  	  $idx = bsearchidx { ext_cmp($_, $rl[0]) } @qrl
        },
        'reverse qsort' => sub {
  	  my @qrl = @rl;
  	  qsort { ext_cmp($b, $a) } @qrl;
  	  $idx = bsearchidx { ext_cmp($rl[0], $_) } @qrl
        },
        'sort' => sub {
  	  my @srl = @rl;
  	  @srl = sort { ext_cmp($a, $b) } @srl;
  	  $idx = bsearchidx { ext_cmp($_, $rl[0]) } @srl
        },
        'reverse sort' => sub {
  	  my @srl = @rl;
  	  @srl = sort { ext_cmp($b, $a) } @srl;
  	  $idx = bsearchidx { ext_cmp($rl[0], $_) } @srl
        },
    });
  
  5.8 results
  
  		  s/iter  reverse sort          sort reverse qsort         qsort
    reverse sort    6.21            --           -0%           -8%          -10%
    sort            6.19            0%            --           -7%          -10%
    reverse qsort   5.73            8%            8%            --           -2%
    qsort           5.60           11%           11%            2%            --
  
  5.26 results
  
  		s/iter  reverse sort          sort reverse qsort         qsort
    reverse sort    4.54            --           -0%          -96%          -96%
    sort            4.52            0%            --          -96%          -96%
    reverse qsort  0.203         2139%         2131%            --          -19%
    qsort          0.164         2666%         2656%           24%            --
  
  Use it where external data sources might have to be compared (think of L<Unix::Statgrab>
  "tables").
  
  C<qsort> is available from List::MoreUtils::XS only. It's insane to maintain
  a wrapper around Perl's sort nor having a pure Perl implementation. One could
  create a flip-book in same speed as PP runs a qsort.
  
  =head2 Searching in sorted Lists
  
  =head3 bsearch BLOCK LIST
  
  Performs a binary search on LIST which must be a sorted list of values. BLOCK
  must return a negative value if the current element (stored in C<$_>) is smaller,
  a positive value if it is bigger and zero if it matches.
  
  Returns a boolean value in scalar context. In list context, it returns the element
  if it was found, otherwise the empty list.
  
  =head3 bsearchidx BLOCK LIST
  
  =head3 bsearch_index BLOCK LIST
  
  Performs a binary search on LIST which must be a sorted list of values. BLOCK
  must return a negative value if the current element (stored in C<$_>) is smaller,
  a positive value if it is bigger and zero if it matches.
  
  Returns the index of found element, otherwise C<-1>.
  
  C<bsearch_index> is an alias for C<bsearchidx>.
  
  =head3 lower_bound BLOCK LIST
  
  Returns the index of the first element in LIST which does not compare
  I<less than val>. Technically it's the first element in LIST which does
  not return a value below zero when passed to BLOCK.
  
    @ids = (1, 1, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 6, 7, 7, 7, 8, 8, 9, 9, 9, 9, 9, 11, 13, 13, 13, 17);
    $lb = lower_bound { $_ <=> 2 } @ids; # returns 2
    $lb = lower_bound { $_ <=> 4 } @ids; # returns 10
  
  lower_bound has a complexity of O(log n).
  
  =head3 upper_bound BLOCK LIST
  
  Returns the index of the first element in LIST which does not compare
  I<greater than val>. Technically it's the first element in LIST which does
  not return a value below or equal to zero when passed to BLOCK.
  
    @ids = (1, 1, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 6, 7, 7, 7, 8, 8, 9, 9, 9, 9, 9, 11, 13, 13, 13, 17);
    $lb = upper_bound { $_ <=> 2 } @ids; # returns 4
    $lb = upper_bound { $_ <=> 4 } @ids; # returns 14
  
  upper_bound has a complexity of O(log n).
  
  =head3 equal_range BLOCK LIST
  
  Returns a pair of indices containing the lower_bound and the upper_bound.
  
  =head2 Operations on sorted Lists
  
  =head3 binsert BLOCK ITEM LIST
  
  =head3 bsearch_insert BLOCK ITEM LIST
  
  Performs a binary search on LIST which must be a sorted list of values. BLOCK
  must return a negative value if the current element (stored in C<$_>) is smaller,
  a positive value if it is bigger and zero if it matches.
  
  ITEM is inserted at the index where the ITEM should be placed (based on above
  search). That means, it's inserted before the next bigger element.
  
    @l = (2,3,5,7);
    binsert { $_ <=> 4 }  4, @l; # @l = (2,3,4,5,7)
    binsert { $_ <=> 6 } 42, @l; # @l = (2,3,4,42,7)
  
  You take care that the inserted element matches the compare result.
  
  =head3 bremove BLOCK LIST
  
  =head3 bsearch_remove BLOCK LIST
  
  Performs a binary search on LIST which must be a sorted list of values. BLOCK
  must return a negative value if the current element (stored in C<$_>) is smaller,
  a positive value if it is bigger and zero if it matches.
  
  The item at the found position is removed and returned.
  
    @l = (2,3,4,5,7);
    bremove { $_ <=> 4 }, @l; # @l = (2,3,5,7);
  
  =head2 Counting and calculation
  
  =head3 true BLOCK LIST
  
  Counts the number of elements in LIST for which the criterion in BLOCK is true.
  Sets C<$_> for  each item in LIST in turn:
  
    printf "%i item(s) are defined", true { defined($_) } @list;
  
  =head3 false BLOCK LIST
  
  Counts the number of elements in LIST for which the criterion in BLOCK is false.
  Sets C<$_> for each item in LIST in turn:
  
    printf "%i item(s) are not defined", false { defined($_) } @list;
  
  =head3 reduce_0 BLOCK LIST
  
  Reduce LIST by calling BLOCK in scalar context for each element of LIST.
  C<$a> contains the progressional result and is initialized with 0.
  C<$b> contains the current processed element of LIST and C<$_> contains the
  index of the element in C<$b>.
  
  The idea behind reduce_0 is B<summation> (addition of a sequence of numbers).
  
  =head3 reduce_1 BLOCK LIST
  
  Reduce LIST by calling BLOCK in scalar context for each element of LIST.
  C<$a> contains the progressional result and is initialized with 1.
  C<$b> contains the current processed element of LIST and C<$_> contains the
  index of the element in C<$b>.
  
  The idea behind reduce_1 is product of a sequence of numbers.
  
  =head3 reduce_u BLOCK LIST
  
  Reduce LIST by calling BLOCK in scalar context for each element of LIST.
  C<$a> contains the progressional result and is initialized with 1.
  C<$b> contains the current processed element of LIST and C<$_> contains the
  index of the element in C<$b>.
  
  This function has been added if one might need the extra of the index
  value but need an individual initialization.
  
  B<Use with caution>: In most cases L<List::Util/reduce> will do the
  job better.
  
  =head3 minmax LIST
  
  Calculates the minimum and maximum of LIST and returns a two element list with
  the first element being the minimum and the second the maximum. Returns the
  empty list if LIST was empty.
  
  The C<minmax> algorithm differs from a naive iteration over the list where each
  element is compared to two values being the so far calculated min and max value
  in that it only requires 3n/2 - 2 comparisons. Thus it is the most efficient
  possible algorithm.
  
  However, the Perl implementation of it has some overhead simply due to the fact
  that there are more lines of Perl code involved. Therefore, LIST needs to be
  fairly big in order for C<minmax> to win over a naive implementation. This
  limitation does not apply to the XS version.
  
  =head3 minmaxstr LIST
  
  Computes the minimum and maximum of LIST using string compare and returns a
  two element list with the first element being the minimum and the second the
  maximum. Returns the empty list if LIST was empty.
  
  The implementation is similar to C<minmax>.
  
  =head1 ENVIRONMENT
  
  When C<LIST_MOREUTILS_PP> is set, the module will always use the pure-Perl
  implementation and not the XS one. This environment variable is really just
  there for the test-suite to force testing the Perl implementation, and possibly
  for reporting of bugs. I don't see any reason to use it in a production
  environment.
  
  =head1 MAINTENANCE
  
  The maintenance goal is to preserve the documented semantics of the API;
  bug fixes that bring actual behavior in line with semantics are allowed.
  New API functions may be added over time.  If a backwards incompatible
  change is unavoidable, we will attempt to provide support for the legacy
  API using the same export tag mechanism currently in place.
  
  This module attempts to use few non-core dependencies. Non-core
  configuration and testing modules will be bundled when reasonable;
  run-time dependencies will be added only if they deliver substantial
  benefit.
  
  =head1 CONTRIBUTING
  
  While contributions are appreciated, a contribution should not cause more
  effort for the maintainer than the contribution itself saves (see
  L<Open Source Contribution Etiquette|http://tirania.org/blog/archive/2010/Dec-31.html>).
  
  To get more familiar where help could be needed - see L<List::MoreUtils::Contributing>.
  
  =head1 BUGS
  
  There is a problem with a bug in 5.6.x perls. It is a syntax error to write
  things like:
  
      my @x = apply { s/foo/bar/ } qw{ foo bar baz };
  
  It has to be written as either
  
      my @x = apply { s/foo/bar/ } 'foo', 'bar', 'baz';
  
  or
  
      my @x = apply { s/foo/bar/ } my @dummy = qw/foo bar baz/;
  
  Perl 5.5.x and Perl 5.8.x don't suffer from this limitation.
  
  If you have a functionality that you could imagine being in this module, please
  drop me a line. This module's policy will be less strict than L<List::Util>'s
  when it comes to additions as it isn't a core module.
  
  When you report bugs, it would be nice if you could additionally give me the
  output of your program with the environment variable C<LIST_MOREUTILS_PP> set
  to a true value. That way I know where to look for the problem (in XS,
  pure-Perl or possibly both).
  
  =head1 SUPPORT
  
  Bugs should always be submitted via the CPAN bug tracker.
  
  You can find documentation for this module with the perldoc command.
  
      perldoc List::MoreUtils
  
  You can also look for information at:
  
  =over 4
  
  =item * RT: CPAN's request tracker
  
  L<https://rt.cpan.org/Dist/Display.html?Name=List-MoreUtils>
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/List-MoreUtils>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/dist/List-MoreUtils>
  
  =item * MetaCPAN
  
  L<https://metacpan.org/release/List-MoreUtils>
  
  =item * CPAN Search
  
  L<http://search.cpan.org/dist/List-MoreUtils/>
  
  =item * Git Repository
  
  L<https://github.com/perl5-utils/List-MoreUtils>
  
  =back
  
  =head2 Where can I go for help?
  
  If you have a bug report, a patch or a suggestion, please open a new
  report ticket at CPAN (but please check previous reports first in case
  your issue has already been addressed) or open an issue on GitHub.
  
  Report tickets should contain a detailed description of the bug or
  enhancement request and at least an easily verifiable way of
  reproducing the issue or fix. Patches are always welcome, too - and
  it's cheap to send pull-requests on GitHub. Please keep in mind that
  code changes are more likely accepted when they're bundled with an
  approving test.
  
  If you think you've found a bug then please read
  "How to Report Bugs Effectively" by Simon Tatham:
  L<http://www.chiark.greenend.org.uk/~sgtatham/bugs.html>.
  
  =head2 Where can I go for help with a concrete version?
  
  Bugs and feature requests are accepted against the latest version
  only. To get patches for earlier versions, you need to get an
  agreement with a developer of your choice - who may or not report the
  issue and a suggested fix upstream (depends on the license you have
  chosen).
  
  =head2 Business support and maintenance
  
  Generally, in volunteered projects, there is no right for support.
  While every maintainer is happy to improve the provided software,
  spare time is limited.
  
  For those who have a use case which requires guaranteed support, one of
  the maintainers should be hired or contracted.  For business support you
  can contact Jens via his CPAN email address rehsackATcpan.org. Please
  keep in mind that business support is neither available for free nor
  are you eligible to receive any support based on the license distributed
  with this package.
  
  =head1 THANKS
  
  =head2 Tassilo von Parseval
  
  Credits go to a number of people: Steve Purkis for giving me namespace advice
  and James Keenan and Terrence Branno for their effort of keeping the CPAN
  tidier by making L<List::Utils> obsolete.
  
  Brian McCauley suggested the inclusion of apply() and provided the pure-Perl
  implementation for it.
  
  Eric J. Roode asked me to add all functions from his module C<List::MoreUtil>
  into this one. With minor modifications, the pure-Perl implementations of those
  are by him.
  
  The bunch of people who almost immediately pointed out the many problems with
  the glitchy 0.07 release (Slaven Rezic, Ron Savage, CPAN testers).
  
  A particularly nasty memory leak was spotted by Thomas A. Lowery.
  
  Lars Thegler made me aware of problems with older Perl versions.
  
  Anno Siegel de-orphaned each_arrayref().
  
  David Filmer made me aware of a problem in each_arrayref that could ultimately
  lead to a segfault.
  
  Ricardo Signes suggested the inclusion of part() and provided the
  Perl-implementation.
  
  Robin Huston kindly fixed a bug in perl's MULTICALL API to make the
  XS-implementation of part() work.
  
  =head2 Jens Rehsack
  
  Credits goes to all people contributing feedback during the v0.400
  development releases.
  
  Special thanks goes to David Golden who spent a lot of effort to develop
  a design to support current state of CPAN as well as ancient software
  somewhere in the dark. He also contributed a lot of patches to refactor
  the API frontend to welcome any user of List::MoreUtils - from ancient
  past to recently last used.
  
  Toby Inkster provided a lot of useful feedback for sane importer code
  and was a nice sounding board for API discussions.
  
  Peter Rabbitson provided a sane git repository setup containing entire
  package history.
  
  =head1 TODO
  
  A pile of requests from other people is still pending further processing in
  my mailbox. This includes:
  
  =over 4
  
  =item * delete_index
  
  =item * random_item
  
  =item * random_item_delete_index
  
  =item * list_diff_hash
  
  =item * list_diff_inboth
  
  =item * list_diff_infirst
  
  =item * list_diff_insecond
  
  These were all suggested by Dan Muey.
  
  =item * listify
  
  Always return a flat list when either a simple scalar value was passed or an
  array-reference. Suggested by Mark Summersault.
  
  =back
  
  =head1 SEE ALSO
  
  L<List::Util>, L<List::AllUtils>, L<List::UtilsBy>
  
  =head1 AUTHOR
  
  Jens Rehsack E<lt>rehsack AT cpan.orgE<gt>
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Tassilo von Parseval E<lt>tassilo.von.parseval@rwth-aachen.deE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Some parts copyright 2011 Aaron Crane.
  
  Copyright 2004 - 2010 by Tassilo von Parseval
  
  Copyright 2013 - 2017 by Jens Rehsack
  
  All code added with 0.417 or later is licensed under the Apache License,
  Version 2.0 (the "License"); you may not use this file except in compliance
  with the License. You may obtain a copy of the License at
  
   http://www.apache.org/licenses/LICENSE-2.0
  
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  
  All code until 0.416 is licensed under the same terms as Perl itself,
  either Perl version 5.8.4 or, at your option, any later version of
  Perl 5 you may have available.
  
  =cut
  
  1;
LIST_MOREUTILS

$fatpacked{"List/MoreUtils/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIST_MOREUTILS_PP';
  package List::MoreUtils::PP;
  
  use 5.008_001;
  use strict;
  use warnings;
  
  our $VERSION = '0.428';
  
  =pod
  
  =head1 NAME
  
  List::MoreUtils::PP - Provide List::MoreUtils pure Perl implementation
  
  =head1 SYNOPSIS
  
    BEGIN { $ENV{LIST_MOREUTILS_PP} = 1; }
    use List::MoreUtils qw(:all);
  
  =cut
  
  sub any (&@)
  {
      my $f = shift;
      foreach (@_)
      {
          return 1 if $f->();
      }
      return 0;
  }
  
  sub all (&@)
  {
      my $f = shift;
      foreach (@_)
      {
          return 0 unless $f->();
      }
      return 1;
  }
  
  sub none (&@)
  {
      my $f = shift;
      foreach (@_)
      {
          return 0 if $f->();
      }
      return 1;
  }
  
  sub notall (&@)
  {
      my $f = shift;
      foreach (@_)
      {
          return 1 unless $f->();
      }
      return 0;
  }
  
  sub one (&@)
  {
      my $f     = shift;
      my $found = 0;
      foreach (@_)
      {
          $f->() and $found++ and return 0;
      }
      $found;
  }
  
  sub any_u (&@)
  {
      my $f = shift;
      return if !@_;
      $f->() and return 1 foreach (@_);
      return 0;
  }
  
  sub all_u (&@)
  {
      my $f = shift;
      return if !@_;
      $f->() or return 0 foreach (@_);
      return 1;
  }
  
  sub none_u (&@)
  {
      my $f = shift;
      return if !@_;
      $f->() and return 0 foreach (@_);
      return 1;
  }
  
  sub notall_u (&@)
  {
      my $f = shift;
      return if !@_;
      $f->() or return 1 foreach (@_);
      return 0;
  }
  
  sub one_u (&@)
  {
      my $f = shift;
      return if !@_;
      my $found = 0;
      foreach (@_)
      {
          $f->() and $found++ and return 0;
      }
      $found;
  }
  
  sub reduce_u(&@)
  {
      my $code = shift;
  
      # Localise $a, $b
      my ($caller_a, $caller_b) = do
      {
          my $pkg = caller();
          no strict 'refs';
          \*{$pkg . '::a'}, \*{$pkg . '::b'};
      };
  
      local (*$caller_a, *$caller_b);
      *$caller_a = \();
      for (0 .. $#_)
      {
          *$caller_b = \$_[$_];
          *$caller_a = \($code->());
      }
  
      ${*$caller_a};
  }
  
  sub reduce_0(&@)
  {
      my $code = shift;
  
      # Localise $a, $b
      my ($caller_a, $caller_b) = do
      {
          my $pkg = caller();
          no strict 'refs';
          \*{$pkg . '::a'}, \*{$pkg . '::b'};
      };
  
      local (*$caller_a, *$caller_b);
      *$caller_a = \0;
      for (0 .. $#_)
      {
          *$caller_b = \$_[$_];
          *$caller_a = \($code->());
      }
  
      ${*$caller_a};
  }
  
  sub reduce_1(&@)
  {
      my $code = shift;
  
      # Localise $a, $b
      my ($caller_a, $caller_b) = do
      {
          my $pkg = caller();
          no strict 'refs';
          \*{$pkg . '::a'}, \*{$pkg . '::b'};
      };
  
      local (*$caller_a, *$caller_b);
      *$caller_a = \1;
      for (0 .. $#_)
      {
          *$caller_b = \$_[$_];
          *$caller_a = \($code->());
      }
  
      ${*$caller_a};
  }
  
  sub true (&@)
  {
      my $f     = shift;
      my $count = 0;
      $f->() and ++$count foreach (@_);
      return $count;
  }
  
  sub false (&@)
  {
      my $f     = shift;
      my $count = 0;
      $f->() or ++$count foreach (@_);
      return $count;
  }
  
  sub firstidx (&@)
  {
      my $f = shift;
      foreach my $i (0 .. $#_)
      {
          local *_ = \$_[$i];
          return $i if $f->();
      }
      return -1;
  }
  
  sub firstval (&@)
  {
      my $test = shift;
      foreach (@_)
      {
          return $_ if $test->();
      }
      return undef;
  }
  
  sub firstres (&@)
  {
      my $test = shift;
      foreach (@_)
      {
          my $testval = $test->();
          $testval and return $testval;
      }
      return undef;
  }
  
  sub onlyidx (&@)
  {
      my $f = shift;
      my $found;
      foreach my $i (0 .. $#_)
      {
          local *_ = \$_[$i];
          $f->() or next;
          defined $found and return -1;
          $found = $i;
      }
      return defined $found ? $found : -1;
  }
  
  sub onlyval (&@)
  {
      my $test   = shift;
      my $result = undef;
      my $found  = 0;
      foreach (@_)
      {
          $test->() or next;
          $result = $_;
          $found++ and return undef;
      }
      return $result;
  }
  
  sub onlyres (&@)
  {
      my $test   = shift;
      my $result = undef;
      my $found  = 0;
      foreach (@_)
      {
          my $rv = $test->() or next;
          $result = $rv;
          $found++ and return undef;
      }
      return $found ? $result : undef;
  }
  
  sub lastidx (&@)
  {
      my $f = shift;
      foreach my $i (reverse 0 .. $#_)
      {
          local *_ = \$_[$i];
          return $i if $f->();
      }
      return -1;
  }
  
  sub lastval (&@)
  {
      my $test = shift;
      my $ix;
      for ($ix = $#_; $ix >= 0; $ix--)
      {
          local *_ = \$_[$ix];
          my $testval = $test->();
  
          # Simulate $_ as alias
          $_[$ix] = $_;
          return $_ if $testval;
      }
      return undef;
  }
  
  sub lastres (&@)
  {
      my $test = shift;
      my $ix;
      for ($ix = $#_; $ix >= 0; $ix--)
      {
          local *_ = \$_[$ix];
          my $testval = $test->();
  
          # Simulate $_ as alias
          $_[$ix] = $_;
          return $testval if $testval;
      }
      return undef;
  }
  
  sub insert_after (&$\@)
  {
      my ($f, $val, $list) = @_;
      my $c = &firstidx($f, @$list);
      @$list = (@{$list}[0 .. $c], $val, @{$list}[$c + 1 .. $#$list],) and return 1 if $c != -1;
      return 0;
  }
  
  sub insert_after_string ($$\@)
  {
      my ($string, $val, $list) = @_;
      my $c = firstidx { defined $_ and $string eq $_ } @$list;
      @$list = (@{$list}[0 .. $c], $val, @{$list}[$c + 1 .. $#$list],) and return 1 if $c != -1;
      return 0;
  }
  
  sub apply (&@)
  {
      my $action = shift;
      &$action foreach my @values = @_;
      wantarray ? @values : $values[-1];
  }
  
  sub after (&@)
  {
      my $test = shift;
      my $started;
      my $lag;
      grep $started ||= do
      {
          my $x = $lag;
          $lag = $test->();
          $x;
      }, @_;
  }
  
  sub after_incl (&@)
  {
      my $test = shift;
      my $started;
      grep $started ||= $test->(), @_;
  }
  
  sub before (&@)
  {
      my $test = shift;
      my $more = 1;
      grep $more &&= !$test->(), @_;
  }
  
  sub before_incl (&@)
  {
      my $test = shift;
      my $more = 1;
      my $lag  = 1;
      grep $more &&= do
      {
          my $x = $lag;
          $lag = !$test->();
          $x;
      }, @_;
  }
  
  sub indexes (&@)
  {
      my $test = shift;
      grep {
          local *_ = \$_[$_];
          $test->()
      } 0 .. $#_;
  }
  
  sub pairwise (&\@\@)
  {
      my $op = shift;
  
      # Symbols for caller's input arrays
      use vars qw{ @A @B };
      local (*A, *B) = @_;
  
      # Localise $a, $b
      my ($caller_a, $caller_b) = do
      {
          my $pkg = caller();
          no strict 'refs';
          \*{$pkg . '::a'}, \*{$pkg . '::b'};
      };
  
      # Loop iteration limit
      my $limit = $#A > $#B ? $#A : $#B;
  
      # This map expression is also the return value
      local (*$caller_a, *$caller_b);
      map {
          # Assign to $a, $b as refs to caller's array elements
          (*$caller_a, *$caller_b) = \($#A < $_ ? undef : $A[$_], $#B < $_ ? undef : $B[$_]);
  
          # Perform the transformation
          $op->();
      } 0 .. $limit;
  }
  
  sub each_array (\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@)
  {
      return each_arrayref(@_);
  }
  
  sub each_arrayref
  {
      my @list  = @_;    # The list of references to the arrays
      my $index = 0;     # Which one the caller will get next
      my $max   = 0;     # Number of elements in longest array
  
      # Get the length of the longest input array
      foreach (@list)
      {
          unless (ref $_ eq 'ARRAY')
          {
              require Carp;
              Carp::croak("each_arrayref: argument is not an array reference\n");
          }
          $max = @$_ if @$_ > $max;
      }
  
      # Return the iterator as a closure wrt the above variables.
      return sub {
          if (@_)
          {
              my $method = shift;
              unless ($method eq 'index')
              {
                  require Carp;
                  Carp::croak("each_array: unknown argument '$method' passed to iterator.");
              }
  
              # Return current (last fetched) index
              return undef if $index == 0 || $index > $max;
              return $index - 1;
          }
  
          # No more elements to return
          return if $index >= $max;
          my $i = $index++;
  
          # Return ith elements
          return map $_->[$i], @list;
        }
  }
  
  sub natatime ($@)
  {
      my $n    = shift;
      my @list = @_;
      return sub {
          return splice @list, 0, $n;
        }
  }
  
  # "leaks" when lexically hidden in arrayify
  my $flatten;
  $flatten = sub {
      map { (ref $_ and ("ARRAY" eq ref $_ or overload::Method($_, '@{}'))) ? ($flatten->(@{$_})) : ($_) } @_;
  };
  
  sub arrayify
  {
      map { $flatten->($_) } @_;
  }
  
  sub mesh (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@)
  {
      my $max = -1;
      $max < $#$_ && ($max = $#$_) foreach @_;
      map {
          my $ix = $_;
          map $_->[$ix], @_;
      } 0 .. $max;
  }
  
  sub zip6 (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@)
  {
      my $max = -1;
      $max < $#$_ && ($max = $#$_) foreach @_;
      map {
          my $ix = $_;
          [map $_->[$ix], @_];
      } 0 .. $max;
  }
  
  sub listcmp (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@)
  {
      my %ret;
      for (my $i = 0; $i < scalar @_; ++$i)
      {
          my %seen;
          my $k;
          foreach my $w (grep { defined $_ and not $seen{$k = $_}++ } @{$_[$i]})
          {
              $ret{$w} ||= [];
              push @{$ret{$w}}, $i;
          }
      }
      %ret;
  }
  
  sub uniq (@)
  {
      my %seen = ();
      my $k;
      my $seen_undef;
      grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_;
  }
  
  sub singleton (@)
  {
      my %seen = ();
      my $k;
      my $seen_undef;
      grep { 1 == (defined $_ ? $seen{$k = $_} : $seen_undef) }
        grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_;
  }
  
  sub duplicates (@)
  {
      my %seen = ();
      my $k;
      my $seen_undef;
      grep { 1 < (defined $_ ? $seen{$k = $_} : $seen_undef) }
        grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_;
  }
  
  sub frequency (@)
  {
      my %seen = ();
      my $k;
      my $seen_undef;
      my %h = map { defined $_ ? ($_ => $seen{$k = $_}) : () }
        grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_;
      wantarray or return (scalar keys %h) + ($seen_undef ? 1 : 0);
      undef $k;
      (%h, $seen_undef ? (\$k => $seen_undef) : ());
  }
  
  sub occurrences (@)
  {
      my %seen = ();
      my $k;
      my $seen_undef;
      my @ret;
      foreach my $l (map { $_ } grep { defined $_ ? not $seen{$k = $_}++ : not $seen_undef++ } @_)
      {
          my $n = defined $l ? $seen{$l} : $seen_undef;
          defined $ret[$n] or $ret[$n] = [];
          push @{$ret[$n]}, $l;
      }
      @ret;
  }
  
  sub mode (@)
  {
      my %seen = ();
      my ($max, $k, $seen_undef) = (1);
  
      foreach (@_) { defined $_ ? ($max < ++$seen{$k = $_} and ++$max) : ($max < ++$seen_undef and ++$max) }
      wantarray or return $max;
  
      my @ret = ($max);
      foreach my $l (grep { $seen{$_} == $max } keys %seen)
      {
          push @ret, $l;
      }
      $seen_undef and $seen_undef == $max and push @ret, undef;
      @ret;
  }
  
  sub samples ($@)
  {
      my $n = shift;
      if ($n > @_)
      {
          require Carp;
          Carp::croak(sprintf("Cannot get %d samples from %d elements", $n, scalar @_));
      }
  
      for (my $i = @_; @_ - $i > $n;)
      {
          my $idx  = @_ - $i;
          my $swp  = $idx + int(rand(--$i));
          my $xchg = $_[$swp];
          $_[$swp] = $_[$idx];
          $_[$idx] = $xchg;
      }
  
      return splice @_, 0, $n;
  }
  
  sub minmax (@)
  {
      return unless @_;
      my $min = my $max = $_[0];
  
      for (my $i = 1; $i < @_; $i += 2)
      {
          if ($_[$i - 1] <= $_[$i])
          {
              $min = $_[$i - 1] if $min > $_[$i - 1];
              $max = $_[$i]     if $max < $_[$i];
          }
          else
          {
              $min = $_[$i]     if $min > $_[$i];
              $max = $_[$i - 1] if $max < $_[$i - 1];
          }
      }
  
      if (@_ & 1)
      {
          my $i = $#_;
          if ($_[$i - 1] <= $_[$i])
          {
              $min = $_[$i - 1] if $min > $_[$i - 1];
              $max = $_[$i]     if $max < $_[$i];
          }
          else
          {
              $min = $_[$i]     if $min > $_[$i];
              $max = $_[$i - 1] if $max < $_[$i - 1];
          }
      }
  
      return ($min, $max);
  }
  
  sub minmaxstr (@)
  {
      return unless @_;
      my $min = my $max = $_[0];
  
      for (my $i = 1; $i < @_; $i += 2)
      {
          if ($_[$i - 1] le $_[$i])
          {
              $min = $_[$i - 1] if $min gt $_[$i - 1];
              $max = $_[$i]     if $max lt $_[$i];
          }
          else
          {
              $min = $_[$i]     if $min gt $_[$i];
              $max = $_[$i - 1] if $max lt $_[$i - 1];
          }
      }
  
      if (@_ & 1)
      {
          my $i = $#_;
          if ($_[$i - 1] le $_[$i])
          {
              $min = $_[$i - 1] if $min gt $_[$i - 1];
              $max = $_[$i]     if $max lt $_[$i];
          }
          else
          {
              $min = $_[$i]     if $min gt $_[$i];
              $max = $_[$i - 1] if $max lt $_[$i - 1];
          }
      }
  
      return ($min, $max);
  }
  
  sub part (&@)
  {
      my ($code, @list) = @_;
      my @parts;
      push @{$parts[$code->($_)]}, $_ foreach @list;
      return @parts;
  }
  
  sub bsearch(&@)
  {
      my $code = shift;
  
      my $rc;
      my $i = 0;
      my $j = @_;
      do
      {
          my $k = int(($i + $j) / 2);
  
          $k >= @_ and return;
  
          local *_ = \$_[$k];
          $rc = $code->();
  
          $rc == 0
            and return wantarray ? $_ : 1;
  
          if ($rc < 0)
          {
              $i = $k + 1;
          }
          else
          {
              $j = $k - 1;
          }
      } until $i > $j;
  
      return;
  }
  
  sub bsearchidx(&@)
  {
      my $code = shift;
  
      my $rc;
      my $i = 0;
      my $j = @_;
      do
      {
          my $k = int(($i + $j) / 2);
  
          $k >= @_ and return -1;
  
          local *_ = \$_[$k];
          $rc = $code->();
  
          $rc == 0 and return $k;
  
          if ($rc < 0)
          {
              $i = $k + 1;
          }
          else
          {
              $j = $k - 1;
          }
      } until $i > $j;
  
      return -1;
  }
  
  sub lower_bound(&@)
  {
      my $code  = shift;
      my $count = @_;
      my $first = 0;
      while ($count > 0)
      {
          my $step = $count >> 1;
          my $it   = $first + $step;
          local *_ = \$_[$it];
          if ($code->() < 0)
          {
              $first = ++$it;
              $count -= $step + 1;
          }
          else
          {
              $count = $step;
          }
      }
  
      $first;
  }
  
  sub upper_bound(&@)
  {
      my $code  = shift;
      my $count = @_;
      my $first = 0;
      while ($count > 0)
      {
          my $step = $count >> 1;
          my $it   = $first + $step;
          local *_ = \$_[$it];
          if ($code->() <= 0)
          {
              $first = ++$it;
              $count -= $step + 1;
          }
          else
          {
              $count = $step;
          }
      }
  
      $first;
  }
  
  sub equal_range(&@)
  {
      my $lb = &lower_bound(@_);
      my $ub = &upper_bound(@_);
      ($lb, $ub);
  }
  
  sub binsert (&$\@)
  {
      my $lb = &lower_bound($_[0], @{$_[2]});
      splice @{$_[2]}, $lb, 0, $_[1];
      $lb;
  }
  
  sub bremove (&\@)
  {
      my $lb = &lower_bound($_[0], @{$_[1]});
      splice @{$_[1]}, $lb, 1;
  }
  
  sub qsort(&\@)
  {
      require Carp;
      Carp::croak("It's insane to use a pure-perl qsort");
  }
  
  sub sort_by(&@)
  {
      my ($code, @list) = @_;
      return map { $_->[0] }
        sort     { $a->[1] cmp $b->[1] }
        map { [$_, scalar($code->())] } @list;
  }
  
  sub nsort_by(&@)
  {
      my ($code, @list) = @_;
      return map { $_->[0] }
        sort     { $a->[1] <=> $b->[1] }
        map { [$_, scalar($code->())] } @list;
  }
  
  sub _XScompiled { 0 }
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 AUTHOR
  
  Jens Rehsack E<lt>rehsack AT cpan.orgE<gt>
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Tassilo von Parseval E<lt>tassilo.von.parseval@rwth-aachen.deE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Some parts copyright 2011 Aaron Crane.
  
  Copyright 2004 - 2010 by Tassilo von Parseval
  
  Copyright 2013 - 2017 by Jens Rehsack
  
  All code added with 0.417 or later is licensed under the Apache License,
  Version 2.0 (the "License"); you may not use this file except in compliance
  with the License. You may obtain a copy of the License at
  
   http://www.apache.org/licenses/LICENSE-2.0
  
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  
  All code until 0.416 is licensed under the same terms as Perl itself,
  either Perl version 5.8.4 or, at your option, any later version of
  Perl 5 you may have available.
  
  =cut
  
  1;
LIST_MOREUTILS_PP

$fatpacked{"Number/Compare.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NUMBER_COMPARE';
  package Number::Compare;
  use strict;
  use Carp qw(croak);
  use vars qw/$VERSION/;
  $VERSION = '0.03';
  
  sub new  {
      my $referent = shift;
      my $class = ref $referent || $referent;
      my $expr = $class->parse_to_perl( shift );
  
      bless eval "sub { \$_[0] $expr }", $class;
  }
  
  sub parse_to_perl {
      shift;
      my $test = shift;
  
      $test =~ m{^
                 ([<>]=?)?   # comparison
                 (.*?)       # value
                 ([kmg]i?)?  # magnitude
                $}ix
         or croak "don't understand '$test' as a test";
  
      my $comparison = $1 || '==';
      my $target     = $2;
      my $magnitude  = $3 || '';
      $target *=           1000 if lc $magnitude eq 'k';
      $target *=           1024 if lc $magnitude eq 'ki';
      $target *=        1000000 if lc $magnitude eq 'm';
      $target *=      1024*1024 if lc $magnitude eq 'mi';
      $target *=     1000000000 if lc $magnitude eq 'g';
      $target *= 1024*1024*1024 if lc $magnitude eq 'gi';
  
      return "$comparison $target";
  }
  
  sub test { $_[0]->( $_[1] ) }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Number::Compare - numeric comparisons
  
  =head1 SYNOPSIS
  
   Number::Compare->new(">1Ki")->test(1025); # is 1025 > 1024
  
   my $c = Number::Compare->new(">1M");
   $c->(1_200_000);                          # slightly terser invocation
  
  =head1 DESCRIPTION
  
  Number::Compare compiles a simple comparison to an anonymous
  subroutine, which you can call with a value to be tested again.
  
  Now this would be very pointless, if Number::Compare didn't understand
  magnitudes.
  
  The target value may use magnitudes of kilobytes (C<k>, C<ki>),
  megabytes (C<m>, C<mi>), or gigabytes (C<g>, C<gi>).  Those suffixed
  with an C<i> use the appropriate 2**n version in accordance with the
  IEC standard: http://physics.nist.gov/cuu/Units/binary.html
  
  =head1 METHODS
  
  =head2 ->new( $test )
  
  Returns a new object that compares the specified test.
  
  =head2 ->test( $value )
  
  A longhanded version of $compare->( $value ).  Predates blessed
  subroutine reference implementation.
  
  =head2 ->parse_to_perl( $test )
  
  Returns a perl code fragment equivalent to the test.
  
  =head1 AUTHOR
  
  Richard Clamp <richardc@unixbeard.net>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2002,2011 Richard Clamp.  All Rights Reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  http://physics.nist.gov/cuu/Units/binary.html
  
  =cut
NUMBER_COMPARE

$fatpacked{"PPI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI';
  package PPI;
  
  # See POD at end for documentation
  
  use 5.006;
  use strict;
  
  # Set the version for CPAN
  use vars qw{$VERSION $XS_COMPATIBLE @XS_EXCLUDE};
  BEGIN {
  	$VERSION       = '1.236';
  	$XS_COMPATIBLE = '0.845';
  	@XS_EXCLUDE    = ();
  }
  
  # Load everything
  use PPI::Util                 ();
  use PPI::Exception            ();
  use PPI::Element              ();
  use PPI::Token                ();
  use PPI::Statement            ();
  use PPI::Structure            ();
  use PPI::Document             ();
  use PPI::Document::File       ();
  use PPI::Document::Fragment   ();
  use PPI::Document::Normalized ();
  use PPI::Normal               ();
  use PPI::Tokenizer            ();
  use PPI::Lexer                ();
  
  # If it is installed, load in PPI::XS
  die
    if !$PPI::XS_DISABLE
    and !eval { require PPI::XS; 1 }
    and $@ !~ /^Can't locate .*? at /;    # ignore failure to load if not installed
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  PPI - Parse, Analyze and Manipulate Perl (without perl)
  
  =head1 SYNOPSIS
  
    use PPI;
    
    # Create a new empty document
    my $Document = PPI::Document->new;
    
    # Create a document from source
    $Document = PPI::Document->new(\'print "Hello World!\n"');
    
    # Load a Document from a file
    $Document = PPI::Document->new('Module.pm');
    
    # Does it contain any POD?
    if ( $Document->find_any('PPI::Token::Pod') ) {
        print "Module contains POD\n";
    }
    
    # Get the name of the main package
    $pkg = $Document->find_first('PPI::Statement::Package')->namespace;
    
    # Remove all that nasty documentation
    $Document->prune('PPI::Token::Pod');
    $Document->prune('PPI::Token::Comment');
    
    # Save the file
    $Document->save('Module.pm.stripped');
  
  =head1 DESCRIPTION
  
  =head2 About this Document
  
  This is the PPI manual. It describes its reason for existing, its general
  structure, its use, an overview of the API, and provides a few
  implementation samples.
  
  =head2 Background
  
  The ability to read, and manipulate Perl (the language) programmatically
  other than with perl (the application) was one that caused difficulty
  for a long time.
  
  The cause of this problem was Perl's complex and dynamic grammar.
  Although there is typically not a huge diversity in the grammar of most
  Perl code, certain issues cause large problems when it comes to parsing.
  
  Indeed, quite early in Perl's history Tom Christiansen introduced the Perl
  community to the quote I<"Nothing but perl can parse Perl">, or as it is
  more often stated now as a truism:
  
  B<"Only perl can parse Perl">
  
  One example of the sorts of things the prevent Perl being easily parsed are
  function signatures, as demonstrated by the following.
  
    @result = (dothis $foo, $bar);
    
    # Which of the following is it equivalent to?
    @result = (dothis($foo), $bar);
    @result = dothis($foo, $bar);
  
  The first line above can be interpreted in two different ways, depending
  on whether the C<&dothis> function is expecting one argument, or two,
  or several.
  
  A "code parser" (something that parses for the purpose of execution) such
  as perl needs information that is not found in the immediate vicinity of
  the statement being parsed.
  
  The information might not just be elsewhere in the file, it might not even be
  in the same file at all. It might also not be able to determine this
  information without the prior execution of a C<BEGIN {}> block, or the
  loading and execution of one or more external modules. Or worse the &dothis
  function may not even have been written yet.
  
  B<When parsing Perl as code, you must also execute it>
  
  Even perl itself never really fully understands the structure of the source
  code after and indeed B<as> it processes it, and in that sense doesn't
  "parse" Perl source into anything remotely like a structured document.
  This makes it of no real use for any task that needs to treat the source
  code as a document, and do so reliably and robustly.
  
  For more information on why it is impossible to parse perl, see Randal
  Schwartz's seminal response to the question of "Why can't you parse Perl".
  
  L<http://www.perlmonks.org/index.pl?node_id=44722>
  
  The purpose of PPI is B<not> to parse Perl I<Code>, but to parse Perl
  I<Documents>. By treating the problem this way, we are able to parse a
  single file containing Perl source code "isolated" from any other
  resources, such as libraries upon which the code may depend, and
  without needing to run an instance of perl alongside or inside the parser.
  
  Historically, using an embedded perl parser was widely considered to be
  the most likely avenue for finding a solution to parsing Perl. It has been
  investigated from time to time, but attempts have generally failed or
  suffered from sufficiently bad corner cases that they were abandoned.
  
  =head2 What Does PPI Stand For?
  
  C<PPI> is an acronym for the longer original module name
  C<Parse::Perl::Isolated>. And in the spirit or the silly acronym games
  played by certain unnamed Open Source projects you may have I<hurd> of,
  it also a reverse backronym of "I Parse Perl".
  
  Of course, I could just be lying and have just made that second bit up
  10 minutes before the release of PPI 1.000. Besides, B<all> the cool
  Perl packages have TLAs (Three Letter Acronyms). It's a rule or something.
  
  Why don't you just think of it as the B<Perl Parsing Interface> for simplicity.
  
  The original name was shortened to prevent the author (and you the users)
  from contracting RSI by having to type crazy things like
  C<Parse::Perl::Isolated::Token::QuoteLike::Backtick> 100 times a day.
  
  In acknowledgment that someone may some day come up with a valid solution
  for the grammar problem it was decided at the commencement of the project
  to leave the C<Parse::Perl> namespace free for any such effort.
  
  Since that time I've been able to prove to my own satisfaction that it
  B<is> truly impossible to accurately parse Perl as both code and document
  at once. For the academics, parsing Perl suffers from the "Halting Problem".
  
  =head2 Why Parse Perl?
  
  Once you can accept that we will never be able to parse Perl well enough
  to meet the standards of things that treat Perl as code, it is worth
  re-examining C<why> we want to "parse" Perl at all.
  
  What are the things that people might want a "Perl parser" for.
  
  =over 4
  
  =item Documentation
  
  Analyzing the contents of a Perl document to automatically generate
  documentation, in parallel to, or as a replacement for, POD documentation.
  
  Allow an indexer to locate and process all the comments and
  documentation from code for "full text search" applications.
  
  =item Structural and Quality Analysis
  
  Determine quality or other metrics across a body of code, and identify
  situations relating to particular phrases, techniques or locations.
  
  Index functions, variables and packages within Perl code, and doing search
  and graph (in the node/edge sense) analysis of large code bases.
  
  L<Perl::Critic>, based on PPI, is a large, thriving tool for bug detection
  and style analysis of Perl code.
  
  =item Refactoring
  
  Make structural, syntax, or other changes to code in an automated manner,
  either independently or in assistance to an editor. This sort of task list
  includes backporting, forward porting, partial evaluation, "improving" code,
  or whatever. All the sort of things you'd want from a L<Perl::Editor>.
  
  =item Layout
  
  Change the layout of code without changing its meaning. This includes
  techniques such as tidying (like L<perltidy>), obfuscation, compressing and
  "squishing", or to implement formatting preferences or policies.
  
  =item Presentation
  
  This includes methods of improving the presentation of code, without changing
  the content of the code. Modify, improve, syntax colour etc the presentation
  of a Perl document. Generating "IntelliText"-like functions.
  
  =back
  
  If we treat this as a baseline for the sort of things we are going to have
  to build on top of Perl, then it becomes possible to identify a standard
  for how good a Perl parser needs to be.
  
  =head2 How good is Good Enough(TM)
  
  PPI seeks to be good enough to achieve all of the above tasks, or to provide
  a sufficiently good API on which to allow others to implement modules in
  these and related areas.
  
  However, there are going to be limits to this process. Because PPI cannot
  adapt to changing grammars, any code written using source filters should not
  be assumed to be parsable.
  
  At one extreme, this includes anything munged by L<Acme::Bleach>, as well
  as (arguably) more common cases like L<Switch>. We do not pretend to be
  able to always parse code using these modules, although as long as it still
  follows a format that looks like Perl syntax, it may be possible to extend
  the lexer to handle them.
  
  The ability to extend PPI to handle lexical additions to the language is on
  the drawing board to be done some time post-1.0
  
  The goal for success was originally to be able to successfully parse 99% of
  all Perl documents contained in CPAN. This means the entire file in each
  case.
  
  PPI has succeeded in this goal far beyond the expectations of even the
  author. At time of writing there are only 28 non-Acme Perl modules in CPAN
  that PPI is incapable of parsing. Most of these are so badly broken they
  do not compile as Perl code anyway.
  
  So unless you are actively going out of your way to break PPI, you should
  expect that it will handle your code just fine.
  
  =head2 Internationalisation
  
  PPI provides partial support for internationalisation and localisation.
  
  Specifically, it allows the use characters from the Latin-1 character
  set to be used in quotes, comments, and POD. Primarily, this covers
  languages from Europe and South America.
  
  PPI does B<not> currently provide support for Unicode.
  If you need Unicode support and would like to help,
  contact the author. (contact details below)
  
  =head2 Round Trip Safe
  
  When PPI parses a file it builds B<everything> into the model, including
  whitespace. This is needed in order to make the Document fully "Round Trip"
  safe.
  
  The general concept behind a "Round Trip" parser is that it knows what it
  is parsing is somewhat uncertain, and so B<expects> to get things wrong
  from time to time. In the cases where it parses code wrongly the tree
  will serialize back out to the same string of code that was read in,
  repairing the parser's mistake as it heads back out to the file.
  
  The end result is that if you parse in a file and serialize it back out
  without changing the tree, you are guaranteed to get the same file you
  started with. PPI does this correctly and reliably for 100% of all known
  cases.
  
  B<What goes in, will come out. Every time.>
  
  The one minor exception at this time is that if the newlines for your file
  are wrong (meaning not matching the platform newline format), PPI will
  localise them for you. (It isn't to be convenient, supporting
  arbitrary newlines would make some of the code more complicated)
  
  Better control of the newline type is on the wish list though, and
  anyone wanting to help out is encouraged to contact the author.
  
  =head1 IMPLEMENTATION
  
  =head2 General Layout
  
  PPI is built upon two primary "parsing" components, L<PPI::Tokenizer>
  and L<PPI::Lexer>, and a large tree of about 50 classes which implement
  the various the I<Perl Document Object Model> (PDOM).
  
  The PDOM is conceptually similar in style and intent to the regular DOM or
  other code Abstract Syntax Trees (ASTs), but contains some differences
  to handle perl-specific cases, and to assist in treating the code as a
  document. Please note that it is B<not> an implementation of the official
  Document Object Model specification, only somewhat similar to it.
  
  On top of the Tokenizer, Lexer and the classes of the PDOM, sit a number
  of classes intended to make life a little easier when dealing with PDOM
  trees.
  
  Both the major parsing components were hand-coded from scratch with only
  plain Perl code and a few small utility modules. There are no grammar or
  patterns mini-languages, no YACC or LEX style tools and only a small number
  of regular expressions.
  
  This is primarily because of the sheer volume of accumulated cruft that
  exists in Perl. Not even perl itself is capable of parsing Perl documents
  (remember, it just parses and executes it as code).
  
  As a result, PPI needed to be cruftier than perl itself. Feel free to
  shudder at this point, and hope you never have to understand the Tokenizer
  codebase. Speaking of which...
  
  =head2 The Tokenizer
  
  The Tokenizer takes source code and converts it into a series of tokens. It
  does this using a slow but thorough character by character manual process,
  rather than using a pattern system or complex regexes.
  
  Or at least it does so conceptually. If you were to actually trace the code
  you would find it's not truly character by character due to a number of
  regexps and optimisations throughout the code. This lets the Tokenizer
  "skip ahead" when it can find shortcuts, so it tends to jump around a line
  a bit wildly at times.
  
  In practice, the number of times the Tokenizer will B<actually> move the
  character cursor itself is only about 5% - 10% higher than the number of
  tokens contained in the file. This makes it about as optimal as it can be
  made without implementing it in something other than Perl.
  
  In 2001 when PPI was started, this structure made PPI quite slow, and not
  really suitable for interactive tasks. This situation has improved greatly
  with multi-gigahertz processors, but can still be painful when working with
  very large files.
  
  The target parsing rate for PPI is about 5000 lines per gigacycle. It is
  currently believed to be at about 1500, and main avenue for making it to
  the target speed has now become L<PPI::XS>, a drop-in XS accelerator for
  PPI.
  
  Since L<PPI::XS> has only just gotten off the ground and is currently only
  at proof-of-concept stage, this may take a little while. Anyone interested
  in helping out with L<PPI::XS> is B<highly> encouraged to contact the
  author. In fact, the design of L<PPI::XS> means it's possible to port
  one function at a time safely and reliably. So every little bit will help.
  
  =head2 The Lexer
  
  The Lexer takes a token stream, and converts it to a lexical tree. Because
  we are parsing Perl B<documents> this includes whitespace, comments, and
  all number of weird things that have no relevance when code is actually
  executed.
  
  An instantiated L<PPI::Lexer> consumes L<PPI::Tokenizer> objects and
  produces L<PPI::Document> objects. However you should probably never be
  working with the Lexer directly. You should just be able to create
  L<PPI::Document> objects and work with them directly.
  
  =head2 The Perl Document Object Model
  
  The PDOM is a structured collection of data classes that together provide
  a correct and scalable model for documents that follow the standard Perl
  syntax.
  
  =head2 The PDOM Class Tree
  
  The following lists all of the 67 current PDOM classes, listing with indentation
  based on inheritance.
  
     PPI::Element
        PPI::Node
           PPI::Document
              PPI::Document::Fragment
           PPI::Statement
              PPI::Statement::Package
              PPI::Statement::Include
              PPI::Statement::Sub
                 PPI::Statement::Scheduled
              PPI::Statement::Compound
              PPI::Statement::Break
              PPI::Statement::Given
              PPI::Statement::When
              PPI::Statement::Data
              PPI::Statement::End
              PPI::Statement::Expression
                 PPI::Statement::Variable
              PPI::Statement::Null
              PPI::Statement::UnmatchedBrace
              PPI::Statement::Unknown
           PPI::Structure
              PPI::Structure::Block
              PPI::Structure::Subscript
              PPI::Structure::Constructor
              PPI::Structure::Condition
              PPI::Structure::List
              PPI::Structure::For
              PPI::Structure::Given
              PPI::Structure::When
              PPI::Structure::Unknown
        PPI::Token
           PPI::Token::Whitespace
           PPI::Token::Comment
           PPI::Token::Pod
           PPI::Token::Number
              PPI::Token::Number::Binary
              PPI::Token::Number::Octal
              PPI::Token::Number::Hex
              PPI::Token::Number::Float
                 PPI::Token::Number::Exp
              PPI::Token::Number::Version
           PPI::Token::Word
           PPI::Token::DashedWord
           PPI::Token::Symbol
              PPI::Token::Magic
           PPI::Token::ArrayIndex
           PPI::Token::Operator
           PPI::Token::Quote
              PPI::Token::Quote::Single
              PPI::Token::Quote::Double
              PPI::Token::Quote::Literal
              PPI::Token::Quote::Interpolate
           PPI::Token::QuoteLike
              PPI::Token::QuoteLike::Backtick
              PPI::Token::QuoteLike::Command
              PPI::Token::QuoteLike::Regexp
              PPI::Token::QuoteLike::Words
              PPI::Token::QuoteLike::Readline
           PPI::Token::Regexp
              PPI::Token::Regexp::Match
              PPI::Token::Regexp::Substitute
              PPI::Token::Regexp::Transliterate
           PPI::Token::HereDoc
           PPI::Token::Cast
           PPI::Token::Structure
           PPI::Token::Label
           PPI::Token::Separator
           PPI::Token::Data
           PPI::Token::End
           PPI::Token::Prototype
           PPI::Token::Attribute
           PPI::Token::Unknown
  
  To summarize the above layout, all PDOM objects inherit from the
  L<PPI::Element> class.
  
  Under this are L<PPI::Token>, strings of content with a known type,
  and L<PPI::Node>, syntactically significant containers that hold other
  Elements.
  
  The three most important of these are the L<PPI::Document>, the
  L<PPI::Statement> and the L<PPI::Structure> classes.
  
  =head2 The Document, Statement and Structure
  
  At the top of all complete PDOM trees is a L<PPI::Document> object. It
  represents a complete file of Perl source code as you might find it on
  disk.
  
  There are some specialised types of document, such as L<PPI::Document::File>
  and L<PPI::Document::Normalized> but for the purposes of the PDOM they are
  all just considered to be the same thing.
  
  Each Document will contain a number of B<Statements>, B<Structures> and
  B<Tokens>.
  
  A L<PPI::Statement> is any series of Tokens and Structures that are treated
  as a single contiguous statement by perl itself. You should note that a
  Statement is as close as PPI can get to "parsing" the code in the sense that
  perl-itself parses Perl code when it is building the op-tree.
  
  Because of the isolation and Perl's syntax, it is provably impossible for
  PPI to accurately determine precedence of operators or which tokens are
  implicit arguments to a sub call.
  
  So rather than lead you on with a bad guess that has a strong chance of
  being wrong, PPI does not attempt to determine precedence or sub parameters
  at all.
  
  At a fundamental level, it only knows that this series of elements
  represents a single Statement as perl sees it, but it can do so with
  enough certainty that it can be trusted.
  
  However, for specific Statement types the PDOM is able to derive additional
  useful information about their meaning. For the best, most useful, and most
  heavily used example, see L<PPI::Statement::Include>.
  
  A L<PPI::Structure> is any series of tokens contained within matching braces.
  This includes code blocks, conditions, function argument braces, anonymous
  array and hash constructors, lists, scoping braces and all other syntactic
  structures represented by a matching pair of braces, including (although it
  may not seem obvious at first) C<E<lt>READLINEE<gt>> braces.
  
  Each Structure contains none, one, or many Tokens and Structures (the rules
  for which vary for the different Structure subclasses)
  
  Under the PDOM structure rules, a Statement can B<never> directly contain
  another child Statement, a Structure can B<never> directly contain another
  child Structure, and a Document can B<never> contain another Document
  anywhere in the tree.
  
  Aside from these three rules, the PDOM tree is extremely flexible.
  
  =head2 The PDOM at Work
  
  To demonstrate the PDOM in use lets start with an example showing how the
  tree might look for the following chunk of simple Perl code.
  
    #!/usr/bin/perl
  
    print( "Hello World!" );
  
    exit();
  
  Translated into a PDOM tree it would have the following structure (as shown
  via the included L<PPI::Dumper>).
  
    PPI::Document
      PPI::Token::Comment                '#!/usr/bin/perl\n'
      PPI::Token::Whitespace             '\n'
      PPI::Statement
        PPI::Token::Word                 'print'
        PPI::Structure::List             ( ... )
          PPI::Token::Whitespace         ' '
          PPI::Statement::Expression
            PPI::Token::Quote::Double    '"Hello World!"'
          PPI::Token::Whitespace         ' '
        PPI::Token::Structure            ';'
      PPI::Token::Whitespace             '\n'
      PPI::Token::Whitespace             '\n'
      PPI::Statement
        PPI::Token::Word                 'exit'
        PPI::Structure::List             ( ... )
        PPI::Token::Structure            ';'
      PPI::Token::Whitespace             '\n'
  
  Please note that in this example, strings are only listed for the
  B<actual> L<PPI::Token> that contains that string. Structures are listed
  with the type of brace characters it represents noted.
  
  The L<PPI::Dumper> module can be used to generate similar trees yourself.
  
  We can make that PDOM dump a little easier to read if we strip out all the
  whitespace. Here it is again, sans the distracting whitespace tokens.
  
    PPI::Document
      PPI::Token::Comment                '#!/usr/bin/perl\n'
      PPI::Statement
        PPI::Token::Word                 'print'
        PPI::Structure::List             ( ... )
          PPI::Statement::Expression
            PPI::Token::Quote::Double    '"Hello World!"'
        PPI::Token::Structure            ';'
      PPI::Statement
        PPI::Token::Word                 'exit'
        PPI::Structure::List             ( ... )
        PPI::Token::Structure            ';'
  
  As you can see, the tree can get fairly deep at time, especially when every
  isolated token in a bracket becomes its own statement. This is needed to
  allow anything inside the tree the ability to grow. It also makes the
  search and analysis algorithms much more flexible.
  
  Because of the depth and complexity of PDOM trees, a vast number of very easy
  to use methods have been added wherever possible to help people working with
  PDOM trees do normal tasks relatively quickly and efficiently.
  
  =head2 Overview of the Primary Classes
  
  The main PPI classes, and links to their own documentation, are listed
  here in alphabetical order.
  
  =over 4
  
  =item L<PPI::Document>
  
  The Document object, the root of the PDOM.
  
  =item L<PPI::Document::Fragment>
  
  A cohesive fragment of a larger Document. Although not of any real current
  use, it is needed for use in certain internal tree manipulation
  algorithms.
  
  For example, doing things like cut/copy/paste etc. Very similar to a
  L<PPI::Document>, but has some additional methods and does not represent
  a lexical scope boundary.
  
  A document fragment is also non-serializable, and so cannot be written out
  to a file.
  
  =item L<PPI::Dumper>
  
  A simple class for dumping readable debugging versions of PDOM structures,
  such as in the demonstration above.
  
  =item L<PPI::Element>
  
  The Element class is the abstract base class for all objects within the PDOM
  
  =item L<PPI::Find>
  
  Implements an instantiable object form of a PDOM tree search.
  
  =item L<PPI::Lexer>
  
  The PPI Lexer. Converts Token streams into PDOM trees.
  
  =item L<PPI::Node>
  
  The Node object, the abstract base class for all PDOM objects that can
  contain other Elements, such as the Document, Statement and Structure
  objects.
  
  =item L<PPI::Statement>
  
  The base class for all Perl statements. Generic "evaluate for side-effects"
  statements are of this actual type. Other more interesting statement types
  belong to one of its children.
  
  See its own documentation for a longer description and list of all of the
  different statement types and sub-classes.
  
  =item L<PPI::Structure>
  
  The abstract base class for all structures. A Structure is a language
  construct consisting of matching braces containing a set of other elements.
  
  See the L<PPI::Structure> documentation for a description and
  list of all of the different structure types and sub-classes.
  
  =item L<PPI::Token>
  
  A token is the basic unit of content. At its most basic, a Token is just
  a string tagged with metadata (its class, and some additional flags in
  some cases).
  
  =item L<PPI::Token::_QuoteEngine>
  
  The L<PPI::Token::Quote> and L<PPI::Token::QuoteLike> classes provide
  abstract base classes for the many and varied types of quote and
  quote-like things in Perl. However, much of the actual quote login is
  implemented in a separate quote engine, based at
  L<PPI::Token::_QuoteEngine>.
  
  Classes that inherit from L<PPI::Token::Quote>, L<PPI::Token::QuoteLike>
  and L<PPI::Token::Regexp> are generally parsed only by the Quote Engine.
  
  =item L<PPI::Tokenizer>
  
  The PPI Tokenizer. One Tokenizer consumes a chunk of text and provides
  access to a stream of L<PPI::Token> objects.
  
  The Tokenizer is very very complicated, to the point where even the author
  treads carefully when working with it.
  
  Most of the complication is the result of optimizations which have tripled
  the tokenization speed, at the expense of maintainability. We cope with the
  spaghetti by heavily commenting everything.
  
  =item L<PPI::Transform>
  
  The Perl Document Transformation API. Provides a standard interface and
  abstract base class for objects and classes that manipulate Documents.
  
  =back
  
  =head1 INSTALLING
  
  The core PPI distribution is pure Perl and has been kept as tight as
  possible and with as few dependencies as possible.
  
  It should download and install normally on any platform from within
  the CPAN and CPANPLUS applications, or directly using the distribution
  tarball. If installing by hand, you may need to install a few small
  utility modules first. The exact ones will depend on your version of
  perl.
  
  There are no special install instructions for PPI, and the normal
  C<Perl Makefile.PL>, C<make>, C<make test>, C<make install> instructions
  apply.
  
  =head1 EXTENDING
  
  The PPI namespace itself is reserved for use by PPI itself.
  You are recommended to use the PPIx:: namespace for PPI-specific
  modifications or prototypes thereof, or Perl:: for modules which provide
  a general Perl language-related functions.
  
  If what you wish to implement looks like it fits into the PPIx:: namespace,
  you should consider contacting the PPI maintainers on GitHub first, as what
  you want may already be in progress, or you may wish to consider contributing
  to PPI itself.
  
  =head1 TO DO
  
  - Many more analysis and utility methods for PDOM classes
  
  - Creation of a PPI::Tutorial document
  
  - Add many more key functions to PPI::XS
  
  - We can B<always> write more and better unit tests
  
  - Complete the full implementation of -E<gt>literal (1.200)
  
  - Full understanding of scoping (due 1.300)
  
  =head1 SUPPORT
  
  The most recent version of PPI is available at the following address.
  
  L<http://search.cpan.org/~mithaldu/PPI/>
  
  PPI source is maintained in a GitHub repository at the following address.
  
  L<https://github.com/adamkennedy/PPI>
  
  Contributions via GitHub pull request are welcome.
  
  Bug fixes in the form of pull requests or bug reports with
  new (failing) unit tests have the best chance of being addressed
  by busy maintainers, and are B<strongly> encouraged.
  
  If you cannot provide a test or fix, or don't have time to do so,
  then regular bug reports are still accepted and appreciated via the
  GitHub bug tracker.
  
  L<https://github.com/adamkennedy/PPI/issues>
  
  The C<ppidump> utility that is part of the L<Perl::Critic> distribution
  is a useful tool for demonstrating how PPI is parsing (or misparsing)
  small code snippets, and for providing information for bug reports.
  
  For other issues, questions, or commercial or media-related enquiries,
  contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 ACKNOWLEDGMENTS
  
  A huge thank you to Phase N Australia (L<http://phase-n.com/>) for
  permitting the original open sourcing and release of this distribution
  from what was originally several thousand hours of commercial work.
  
  Another big thank you to The Perl Foundation
  (L<http://www.perlfoundation.org/>) for funding for the final big
  refactoring and completion run.
  
  Also, to the various co-maintainers that have contributed both large and
  small with tests and patches and especially to those rare few who have
  deep-dived into the guts to (gasp) add a feature.
  
    - Dan Brook       : PPIx::XPath, Acme::PerlML
    - Audrey Tang     : "Line Noise" Testing
    - Arjen Laarhoven : Three-element ->location support
    - Elliot Shank    : Perl 5.10 support, five-element ->location
  
  And finally, thanks to those brave ( and foolish :) ) souls willing to dive
  in and use, test drive and provide feedback on PPI before version 1.000,
  in some cases before it made it to beta quality, and still did extremely
  distasteful things (like eating 50 meg of RAM a second).
  
  I owe you all a beer. Corner me somewhere and collect at your convenience.
  If I missed someone who wasn't in my email history, thank you too :)
  
    # In approximate order of appearance
    - Claes Jacobsson
    - Michael Schwern
    - Jeff T. Parsons
    - CPAN Author "CHOCOLATEBOY"
    - Robert Rotherberg
    - CPAN Author "PODMASTER"
    - Richard Soderberg
    - Nadim ibn Hamouda el Khemir
    - Graciliano M. P.
    - Leon Brocard
    - Jody Belka
    - Curtis Ovid
    - Yuval Kogman
    - Michael Schilli
    - Slaven Rezic
    - Lars Thegler
    - Tony Stubblebine
    - Tatsuhiko Miyagawa
    - CPAN Author "CHROMATIC"
    - Matisse Enzer
    - Roy Fulbright
    - Dan Brook
    - Johnny Lee
    - Johan Lindstrom
  
  And to single one person out, thanks go to Randal Schwartz who
  spent a great number of hours in IRC over a critical 6 month period
  explaining why Perl is impossibly unparsable and constantly shoving evil
  and ugly corner cases in my face. He remained a tireless devil's advocate,
  and without his support this project genuinely could never have been
  completed.
  
  So for my schooling in the Deep Magiks, you have my deepest gratitude Randal.
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI

$fatpacked{"PPI/Cache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_CACHE';
  package PPI::Cache;
  
  =pod
  
  =head1 NAME
  
  PPI::Cache - The PPI Document Caching Layer
  
  =head1 SYNOPSIS
  
    # Set the cache
    use PPI::Cache path => '/var/cache/ppi-cache';
    
    # Manually create a cache
    my $Cache = PPI::Cache->new(
        path     => '/var/cache/perl/class-PPI',
        readonly => 1,
    );
  
  =head1 DESCRIPTION
  
  C<PPI::Cache> provides the default caching functionality for L<PPI>.
  
  It integrates automatically with L<PPI> itself. Once enabled, any attempt
  to load a document from the filesystem will be cached via cache.
  
  Please note that creating a L<PPI::Document> from raw source or something
  other object will B<not> be cached.
  
  =head2 Using PPI::Cache
  
  The most common way of using C<PPI::Cache> is to provide parameters to
  the C<use> statement at the beginning of your program.
  
    # Load the class but do not set a cache
    use PPI::Cache;
    
    # Use a fairly normal cache location
    use PPI::Cache path => '/var/cache/ppi-cache';
  
  Any of the arguments that can be provided to the C<new> constructor can
  also be provided to C<use>.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Carp          ();
  use File::Spec    ();
  use File::Path    ();
  use Storable      ();
  use Digest::MD5   ();
  use Params::Util  qw{_INSTANCE _SCALAR};
  use PPI::Document ();
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.236';
  }
  
  use constant VMS => !! ( $^O eq 'VMS' );
  
  sub import {
  	my $class = ref $_[0] ? ref shift : shift;
  	return 1 unless @_;
  
  	# Create a cache from the params provided
  	my $cache = $class->new(@_);
  
  	# Make PPI::Document use it
  	unless ( PPI::Document->set_cache( $cache ) ) {
  		Carp::croak("Failed to set cache in PPI::Document");
  	}
  
  	1;
  }
  
  
  
  
  
  #####################################################################
  # Constructor and Accessors
  
  =pod
  
  =head2 new param => $value, ...
  
  The C<new> constructor creates a new standalone cache object.
  
  It takes a number of parameters to control the cache.
  
  =over
  
  =item path
  
  The C<path> param sets the base directory for the cache. It must already
  exist, and must be writable.
  
  =item readonly
  
  The C<readonly> param is a true/false flag that allows the use of an
  existing cache by a less-privileged user (such as the web user).
  
  Existing documents will be retrieved from the cache, but new documents
  will not be written to it.
  
  =back
  
  Returns a new C<PPI::Cache> object, or dies on error.
  
  =cut
  
  sub new {
  	my $class  = shift;
  	my %params = @_;
  
  	# Path should exist and be usable
  	my $path = $params{path}
  		or Carp::croak("Cannot create PPI::Cache, no path provided");
  	unless ( -d $path ) {
  		Carp::croak("Cannot create PPI::Cache, path does not exist");
  	}
  	unless ( -r $path and -x $path ) {
  		Carp::croak("Cannot create PPI::Cache, no read permissions for path");
  	}
  	if ( ! $params{readonly} and ! -w $path ) {
  		Carp::croak("Cannot create PPI::Cache, no write permissions for path");
  	}
  
  	# Create the basic object
  	my $self = bless {
  		path     => $path,
  		readonly => !! $params{readonly},
  	}, $class;
  
  	$self;
  }
  
  =pod
  
  =head2 path
  
  The C<path> accessor returns the path on the local filesystem that is the
  root of the cache.
  
  =cut
  
  sub path { $_[0]->{path} }
  
  =pod
  
  =head2 readonly
  
  The C<readonly> accessor returns true if documents should not be written
  to the cache.
  
  =cut
  
  sub readonly { $_[0]->{readonly} }
  
  
  
  
  
  #####################################################################
  # PPI::Cache Methods
  
  =pod
  
  =head2 get_document $md5sum | \$source
  
  The C<get_document> method checks to see if a Document is stored in the
  cache and retrieves it if so.
  
  =cut
  
  sub get_document {
  	my $self = ref $_[0]
  		? shift
  		: Carp::croak('PPI::Cache::get_document called as static method');
  	my $md5hex = $self->_md5hex(shift) or return undef;
  	$self->_load($md5hex);
  }
  
  =pod
  
  =head2 store_document $Document
  
  The C<store_document> method takes a L<PPI::Document> as argument and
  explicitly adds it to the cache.
  
  Returns true if saved, or C<undef> (or dies) on error.
  
  FIXME (make this return either one or the other, not both)
  
  =cut
  
  sub store_document {
  	my $self     = shift;
  	my $Document = _INSTANCE(shift, 'PPI::Document') or return undef;
  
  	# Shortcut if we are readonly
  	return 1 if $self->readonly;
  
  	# Find the filename to save to
  	my $md5hex = $Document->hex_id or return undef;
  
  	# Store the file
  	$self->_store( $md5hex, $Document );
  }
  
  
  
  
  
  #####################################################################
  # Support Methods
  
  # Store an arbitrary PPI::Document object (using Storable) to a particular
  # path within the cache filesystem.
  sub _store {
  	my ($self, $md5hex, $object) = @_;
  	my ($dir, $file) = $self->_paths($md5hex);
  
  	# Save the file
  	File::Path::mkpath( $dir, 0, 0755 ) unless -d $dir;
  	if ( VMS ) {
  		Storable::lock_nstore( $object, $file );
  	} else {
  		Storable::nstore( $object, $file );
  	}
  }
  
  # Load an arbitrary object (using Storable) from a particular
  # path within the cache filesystem.
  sub _load {
  	my ($self, $md5hex) = @_;
  	my (undef, $file) = $self->_paths($md5hex);
  
  	# Load the file
  	return '' unless -f $file;
  	my $object = VMS
  		? Storable::retrieve( $file )
  		: Storable::lock_retrieve( $file );
  
  	# Security check
  	unless ( _INSTANCE($object, 'PPI::Document') ) {
  		Carp::croak("Security Violation: Object in '$file' is not a PPI::Document");
  	}
  
  	$object;
  }
  
  # Convert a md5 to a dir and file name
  sub _paths {
  	my $self   = shift;
  	my $md5hex = lc shift;
  	my $dir    = File::Spec->catdir( $self->path, substr($md5hex, 0, 1), substr($md5hex, 0, 2) );
  	my $file   = File::Spec->catfile( $dir, $md5hex . '.ppi' );
  	return ($dir, $file);
  }
  
  # Check a md5hex param
  sub _md5hex {
  	my $either = shift;
  	my $it     = _SCALAR($_[0])
  		? PPI::Util::md5hex(${$_[0]})
  		: $_[0];
  	return (defined $it and ! ref $it and $it =~ /^[[:xdigit:]]{32}\z/s)
  		? lc $it
  		: undef;
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Finish the basic functionality
  
  - Add support for use PPI::Cache auto-setting $PPI::Document::CACHE
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_CACHE

$fatpacked{"PPI/Document.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT';
  package PPI::Document;
  
  =pod
  
  =head1 NAME
  
  PPI::Document - Object representation of a Perl document
  
  =head1 INHERITANCE
  
    PPI::Document
    isa PPI::Node
        isa PPI::Element
  
  =head1 SYNOPSIS
  
    use PPI;
    
    # Load a document from a file
    my $Document = PPI::Document->new('My/Module.pm');
    
    # Strip out comments
    $Document->prune('PPI::Token::Comment');
    
    # Find all the named subroutines
    my $sub_nodes = $Document->find( 
    	sub { $_[1]->isa('PPI::Statement::Sub') and $_[1]->name }
    );
    my @sub_names = map { $_->name } @$sub_nodes;
    
    # Save the file
    $Document->save('My/Module.pm.stripped');
  
  =head1 DESCRIPTION
  
  The C<PPI::Document> class represents a single Perl "document". A
  C<PPI::Document> object acts as a root L<PPI::Node>, with some
  additional methods for loading and saving, and working with
  the line/column locations of Elements within a file.
  
  The exemption to its L<PPI::Node>-like behavior this is that a
  C<PPI::Document> object can NEVER have a parent node, and is always
  the root node in a tree.
  
  =head2 Storable Support
  
  C<PPI::Document> implements the necessary C<STORABLE_freeze> and
  C<STORABLE_thaw> hooks to provide native support for L<Storable>,
  if you have it installed.
  
  However if you want to clone a Document, you are highly recommended
  to use the C<$Document-E<gt>clone> method rather than Storable's
  C<dclone> function (although C<dclone> should still work).
  
  =head1 METHODS
  
  Most of the things you are likely to want to do with a Document are
  probably going to involve the methods from L<PPI::Node> class, of which
  this is a subclass.
  
  The methods listed here are the remaining few methods that are truly
  Document-specific.
  
  =cut
  
  use strict;
  use Carp                          ();
  use List::Util 1.33               ();
  use Params::Util                  qw{_SCALAR0 _ARRAY0 _INSTANCE};
  use Digest::MD5                   ();
  use PPI::Util                     ();
  use PPI                           ();
  use PPI::Node                     ();
  
  use overload 'bool' => \&PPI::Util::TRUE;
  use overload '""'   => 'content';
  
  use vars qw{$VERSION @ISA $errstr};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Node';
  	$errstr  = '';
  }
  
  use PPI::Document::Fragment ();
  
  # Document cache
  my $CACHE;
  
  # Convenience constants related to constants
  use constant LOCATION_LINE         => 0;
  use constant LOCATION_CHARACTER    => 1;
  use constant LOCATION_COLUMN       => 2;
  use constant LOCATION_LOGICAL_LINE => 3;
  use constant LOCATION_LOGICAL_FILE => 4;
  
  
  
  
  
  #####################################################################
  # Constructor and Static Methods
  
  =pod
  
  =head2 new
  
    # Simple construction
    $doc = PPI::Document->new( $filename );
    $doc = PPI::Document->new( \$source  );
    
    # With the readonly attribute set
    $doc = PPI::Document->new( $filename,
            readonly => 1,
    );
  
  The C<new> constructor takes as argument a variety of different sources of
  Perl code, and creates a single cohesive Perl C<PPI::Document>
  for it.
  
  If passed a file name as a normal string, it will attempt to load the
  document from the file.
  
  If passed a reference to a C<SCALAR>, this is taken to be source code and
  parsed directly to create the document.
  
  If passed zero arguments, a "blank" document will be created that contains
  no content at all.
  
  In all cases, the document is considered to be "anonymous" and not tied back
  to where it was created from. Specifically, if you create a PPI::Document from
  a filename, the document will B<not> remember where it was created from.
  
  The constructor also takes attribute flags.
  
  At this time, the only available attribute is the C<readonly> flag.
  
  Setting C<readonly> to true will allow various systems to provide
  additional optimisations and caching. Note that because C<readonly> is an
  optimisation flag, it is off by default and you will need to explicitly
  enable it.
  
  Returns a C<PPI::Document> object, or C<undef> if parsing fails.
  L<PPI::Exception> objects can also be thrown if there are parsing problems.
  
  =cut
  
  sub new {
  	local $_; # An extra one, just in case
  	my $class = ref $_[0] ? ref shift : shift;
  
  	unless ( @_ ) {
  		my $self = $class->SUPER::new;
  		$self->{readonly}  = ! 1;
  		$self->{tab_width} = 1;
  		return $self;
  	}
  
  	# Check constructor attributes
  	my $source  = shift;
  	my %attr    = @_;
  
  	# Check the data source
  	if ( ! defined $source ) {
  		$class->_error("An undefined value was passed to PPI::Document::new");
  
  	} elsif ( ! ref $source ) {
  		# Catch people using the old API
  		if ( $source =~ /(?:\012|\015)/ ) {
  			Carp::croak("API CHANGE: Source code should only be passed to PPI::Document->new as a SCALAR reference");
  		}
  
  		# When loading from a filename, use the caching layer if it exists.
  		if ( $CACHE ) {
  			my $file_contents = PPI::Util::_slurp( $source );
  
  			# Errors returned as plain string
  			return $class->_error($file_contents) if !ref $file_contents;
  
  			# Retrieve the document from the cache
  			my $document = $CACHE->get_document($file_contents);
  			return $class->_setattr( $document, %attr ) if $document;
  
  			$document = PPI::Lexer->lex_source( $$file_contents );
  			if ( $document ) {
  				# Save in the cache
  				$CACHE->store_document( $document );
  				return $class->_setattr( $document, %attr );
  			}
  		} else {
  			my $document = PPI::Lexer->lex_file( $source );
  			return $class->_setattr( $document, %attr ) if $document;
  		}
  
  	} elsif ( _SCALAR0($source) ) {
  		my $document = PPI::Lexer->lex_source( $$source );
  		return $class->_setattr( $document, %attr ) if $document;
  
  	} elsif ( _ARRAY0($source) ) {
  		$source = join '', map { "$_\n" } @$source;
  		my $document = PPI::Lexer->lex_source( $source );
  		return $class->_setattr( $document, %attr ) if $document;
  
  	} else {
  		$class->_error("Unknown object or reference was passed to PPI::Document::new");
  	}
  
  	# Pull and store the error from the lexer
  	my $errstr;
  	if ( _INSTANCE($@, 'PPI::Exception') ) {
  		$errstr = $@->message;
  	} elsif ( $@ ) {
  		$errstr = $@;
  		$errstr =~ s/\sat line\s.+$//;
  	} elsif ( PPI::Lexer->errstr ) {
  		$errstr = PPI::Lexer->errstr;
  	} else {
  		$errstr = "Unknown error parsing Perl document";
  	}
  	PPI::Lexer->_clear;
  	$class->_error( $errstr );
  }
  
  sub load {
  	Carp::croak("API CHANGE: File names should now be passed to PPI::Document->new to load a file");
  }
  
  sub _setattr {
  	my ($class, $document, %attr) = @_;
  	$document->{readonly} = !! $attr{readonly};
  	return $document;
  }
  
  =pod
  
  =head2 set_cache $cache
  
  As of L<PPI> 1.100, C<PPI::Document> supports parser caching.
  
  The default cache class L<PPI::Cache> provides a L<Storable>-based
  caching or the parsed document based on the MD5 hash of the document as
  a string.
  
  The static C<set_cache> method is used to set the cache object for
  C<PPI::Document> to use when loading documents. It takes as argument
  a L<PPI::Cache> object (or something that C<isa> the same).
  
  If passed C<undef>, this method will stop using the current cache, if any.
  
  For more information on caching, see L<PPI::Cache>.
  
  Returns true on success, or C<undef> if not passed a valid param.
  
  =cut
  
  sub set_cache {
  	my $class  = ref $_[0] ? ref shift : shift;
  
  	if ( defined $_[0] ) {
  		# Enable the cache
  		my $object = _INSTANCE(shift, 'PPI::Cache') or return undef;
  		$CACHE = $object;
  	} else {
  		# Disable the cache
  		$CACHE = undef;
  	}
  
  	1;
  }
  
  =pod
  
  =head2 get_cache
  
  If a document cache is currently set, the C<get_cache> method will
  return it.
  
  Returns a L<PPI::Cache> object, or C<undef> if there is no cache
  currently set for C<PPI::Document>.
  
  =cut
  
  sub get_cache {
  	$CACHE;	
  }
  
  
  
  
  
  #####################################################################
  # PPI::Document Instance Methods
  
  =pod
  
  =head2 readonly
  
  The C<readonly> attribute indicates if the document is intended to be
  read-only, and will never be modified. This is an advisory flag, that
  writers of L<PPI>-related systems may or may not use to enable
  optimisations and caches for your document.
  
  Returns true if the document is read-only or false if not.
  
  =cut
  
  sub readonly {
  	$_[0]->{readonly};
  }
  
  =pod
  
  =head2 tab_width [ $width ]
  
  In order to handle support for C<location> correctly, C<Documents>
  need to understand the concept of tabs and tab width. The C<tab_width>
  method is used to get and set the size of the tab width.
  
  At the present time, PPI only supports "naive" (width 1) tabs, but we do
  plan on supporting arbitrary, default and auto-sensing tab widths later.
  
  Returns the tab width as an integer, or C<die>s if you attempt to set the
  tab width.
  
  =cut
  
  sub tab_width {
  	my $self = shift;
  	return $self->{tab_width} unless @_;
  	$self->{tab_width} = shift;
  }
  
  =pod
  
  =head2 save
  
    $document->save( $file )
   
  The C<save> method serializes the C<PPI::Document> object and saves the
  resulting Perl document to a file. Returns C<undef> on failure to open
  or write to the file.
  
  =cut
  
  sub save {
  	my $self = shift;
  	local *FILE;
  	open( FILE, '>', $_[0] )    or return undef;
  	binmode FILE;
  	print FILE $self->serialize or return undef;
  	close FILE                  or return undef;
  	return 1;
  }
  
  =pod
  
  =head2 serialize
  
  Unlike the C<content> method, which shows only the immediate content
  within an element, Document objects also have to be able to be written
  out to a file again.
  
  When doing this we need to take into account some additional factors.
  
  Primarily, we need to handle here-docs correctly, so that are written
  to the file in the expected place.
  
  The C<serialize> method generates the actual file content for a given
  Document object. The resulting string can be written straight to a file.
  
  Returns the serialized document as a string.
  
  =cut
  
  sub serialize {
  	my $self   = shift;
  	my @tokens = $self->tokens;
  
  	# The here-doc content buffer
  	my $heredoc = '';
  
  	# Start the main loop
  	my $output = '';
  	foreach my $i ( 0 .. $#tokens ) {
  		my $Token = $tokens[$i];
  
  		# Handle normal tokens
  		unless ( $Token->isa('PPI::Token::HereDoc') ) {
  			my $content = $Token->content;
  
  			# Handle the trivial cases
  			unless ( $heredoc ne '' and $content =~ /\n/ ) {
  				$output .= $content;
  				next;
  			}
  
  			# We have pending here-doc content that needs to be
  			# inserted just after the first newline in the content.
  			if ( $content eq "\n" ) {
  				# Shortcut the most common case for speed
  				$output .= $content . $heredoc;
  			} else {
  				# Slower and more general version
  				$content =~ s/\n/\n$heredoc/;
  				$output .= $content;
  			}
  
  			$heredoc = '';
  			next;
  		}
  
  		# This token is a HereDoc.
  		# First, add the token content as normal, which in this
  		# case will definitely not contain a newline.
  		$output .= $Token->content;
  
  		# Now add all of the here-doc content to the heredoc buffer.
  		foreach my $line ( $Token->heredoc ) {
  			$heredoc .= $line;
  		}
  
  		if ( $Token->{_damaged} ) {
  			# Special Case:
  			# There are a couple of warning/bug situations
  			# that can occur when a HereDoc content was read in
  			# from the end of a file that we silently allow.
  			#
  			# When writing back out to the file we have to
  			# auto-repair these problems if we aren't going back
  			# on to the end of the file.
  
  			# When calculating $last_line, ignore the final token if
  			# and only if it has a single newline at the end.
  			my $last_index = $#tokens;
  			if ( $tokens[$last_index]->{content} =~ /^[^\n]*\n$/ ) {
  				$last_index--;
  			}
  
  			# This is a two part test.
  			# First, are we on the last line of the
  			# content part of the file
  			my $last_line = List::Util::none {
  				$tokens[$_] and $tokens[$_]->{content} =~ /\n/
  				} (($i + 1) .. $last_index);
  			if ( ! defined $last_line ) {
  				# Handles the null list case
  				$last_line = 1;
  			}
  
  			# Secondly, are their any more here-docs after us,
  			# (with content or a terminator)
  			my $any_after = List::Util::any {
  				$tokens[$_]->isa('PPI::Token::HereDoc')
  				and (
  					scalar(@{$tokens[$_]->{_heredoc}})
  					or
  					defined $tokens[$_]->{_terminator_line}
  					)
  				} (($i + 1) .. $#tokens);
  			if ( ! defined $any_after ) {
  				# Handles the null list case
  				$any_after = '';
  			}
  
  			# We don't need to repair the last here-doc on the
  			# last line. But we do need to repair anything else.
  			unless ( $last_line and ! $any_after ) {
  				# Add a terminating string if it didn't have one
  				unless ( defined $Token->{_terminator_line} ) {
  					$Token->{_terminator_line} = $Token->{_terminator};
  				}
  
  				# Add a trailing newline to the terminating
  				# string if it didn't have one.
  				unless ( $Token->{_terminator_line} =~ /\n$/ ) {
  					$Token->{_terminator_line} .= "\n";
  				}
  			}
  		}
  
  		# Now add the termination line to the heredoc buffer
  		if ( defined $Token->{_terminator_line} ) {
  			$heredoc .= $Token->{_terminator_line};
  		}
  	}
  
  	# End of tokens
  
  	if ( $heredoc ne '' ) {
  		# If the file doesn't end in a newline, we need to add one
  		# so that the here-doc content starts on the next line.
  		unless ( $output =~ /\n$/ ) {
  			$output .= "\n";
  		}
  
  		# Now we add the remaining here-doc content
  		# to the end of the file.
  		$output .= $heredoc;
  	}
  
  	$output;
  }
  
  =pod
  
  =head2 hex_id
  
  The C<hex_id> method generates an unique identifier for the Perl document.
  
  This identifier is basically just the serialized document, with
  Unix-specific newlines, passed through MD5 to produce a hexadecimal string.
  
  This identifier is used by a variety of systems (such as L<PPI::Cache>
  and L<Perl::Metrics>) as a unique key against which to store or cache
  information about a document (or indeed, to cache the document itself).
  
  Returns a 32 character hexadecimal string.
  
  =cut
  
  sub hex_id {
  	PPI::Util::md5hex($_[0]->serialize);
  }
  
  =pod
  
  =head2 index_locations
  
  Within a document, all L<PPI::Element> objects can be considered to have a
  "location", a line/column position within the document when considered as a
  file. This position is primarily useful for debugging type activities.
  
  The method for finding the position of a single Element is a bit laborious,
  and very slow if you need to do it a lot. So the C<index_locations> method
  will index and save the locations of every Element within the Document in
  advance, making future calls to <PPI::Element::location> virtually free.
  
  Please note that this index should always be cleared using C<flush_locations>
  once you are finished with the locations. If content is added to or removed
  from the file, these indexed locations will be B<wrong>.
  
  =cut
  
  sub index_locations {
  	my $self   = shift;
  	my @tokens = $self->tokens;
  
  	# Whenever we hit a heredoc we will need to increment by
  	# the number of lines in it's content section when we
  	# encounter the next token with a newline in it.
  	my $heredoc = 0;
  
  	# Find the first Token without a location
  	my ($first, $location) = ();
  	foreach ( 0 .. $#tokens ) {
  		my $Token = $tokens[$_];
  		next if $Token->{_location};
  
  		# Found the first Token without a location
  		# Calculate the new location if needed.
  		if ($_) {
  			$location =
  				$self->_add_location( $location, $tokens[$_ - 1], \$heredoc );
  		} else {
  			my $logical_file =
  				$self->can('filename') ? $self->filename : undef;
  			$location = [ 1, 1, 1, 1, $logical_file ];
  		}
  		$first = $_;
  		last;
  	}
  
  	# Calculate locations for the rest
  	if ( defined $first ) {
  		foreach ( $first .. $#tokens ) {
  			my $Token = $tokens[$_];
  			$Token->{_location} = $location;
  			$location = $self->_add_location( $location, $Token, \$heredoc );
  
  			# Add any here-doc lines to the counter
  			if ( $Token->isa('PPI::Token::HereDoc') ) {
  				$heredoc += $Token->heredoc + 1;
  			}
  		}
  	}
  
  	1;
  }
  
  sub _add_location {
  	my ($self, $start, $Token, $heredoc) = @_;
  	my $content = $Token->{content};
  
  	# Does the content contain any newlines
  	my $newlines =()= $content =~ /\n/g;
  	my ($logical_line, $logical_file) =
  		$self->_logical_line_and_file($start, $Token, $newlines);
  
  	unless ( $newlines ) {
  		# Handle the simple case
  		return [
  			$start->[LOCATION_LINE],
  			$start->[LOCATION_CHARACTER] + length($content),
  			$start->[LOCATION_COLUMN]
  				+ $self->_visual_length(
  					$content,
  					$start->[LOCATION_COLUMN]
  				),
  			$logical_line,
  			$logical_file,
  		];
  	}
  
  	# This is the more complex case where we hit or
  	# span a newline boundary.
  	my $physical_line = $start->[LOCATION_LINE] + $newlines;
  	my $location = [ $physical_line, 1, 1, $logical_line, $logical_file ];
  	if ( $heredoc and $$heredoc ) {
  		$location->[LOCATION_LINE]         += $$heredoc;
  		$location->[LOCATION_LOGICAL_LINE] += $$heredoc;
  		$$heredoc = 0;
  	}
  
  	# Does the token have additional characters
  	# after their last newline.
  	if ( $content =~ /\n([^\n]+?)\z/ ) {
  		$location->[LOCATION_CHARACTER] += length($1);
  		$location->[LOCATION_COLUMN] +=
  			$self->_visual_length(
  				$1, $location->[LOCATION_COLUMN],
  			);
  	}
  
  	$location;
  }
  
  sub _logical_line_and_file {
  	my ($self, $start, $Token, $newlines) = @_;
  
  	# Regex taken from perlsyn, with the correction that there's no space
  	# required between the line number and the file name.
  	if ($start->[LOCATION_CHARACTER] == 1) {
  		if ( $Token->isa('PPI::Token::Comment') ) {
  			if (
  				$Token->content =~ m<
  					\A
  					\#      \s*
  					line    \s+
  					(\d+)   \s*
  					(?: (\"?) ([^\"]* [^\s\"]) \2 )?
  					\s*
  					\z
  				>xms
  			) {
  				return $1, ($3 || $start->[LOCATION_LOGICAL_FILE]);
  			}
  		}
  		elsif ( $Token->isa('PPI::Token::Pod') ) {
  			my $content = $Token->content;
  			my $line;
  			my $file = $start->[LOCATION_LOGICAL_FILE];
  			my $end_of_directive;
  			while (
  				$content =~ m<
  					^
  					\#      \s*?
  					line    \s+?
  					(\d+)   (?: (?! \n) \s)*
  					(?: (\"?) ([^\"]*? [^\s\"]) \2 )??
  					\s*?
  					$
  				>xmsg
  			) {
  				($line, $file) = ($1, ( $3 || $file ) );
  				$end_of_directive = pos $content;
  			}
  
  			if (defined $line) {
  				pos $content = $end_of_directive;
  				my $post_directive_newlines =()= $content =~ m< \G [^\n]* \n >xmsg;
  				return $line + $post_directive_newlines - 1, $file;
  			}
  		}
  	}
  
  	return
  		$start->[LOCATION_LOGICAL_LINE] + $newlines,
  		$start->[LOCATION_LOGICAL_FILE];
  }
  
  sub _visual_length {
  	my ($self, $content, $pos) = @_;
  
  	my $tab_width = $self->tab_width;
  	my ($length, $vis_inc);
  
  	return length $content if $content !~ /\t/;
  
  	# Split the content in tab and non-tab parts and calculate the
  	# "visual increase" of each part.
  	for my $part ( split(/(\t)/, $content) ) {
  		if ($part eq "\t") {
  			$vis_inc = $tab_width - ($pos-1) % $tab_width;
  		}
  		else {
  			$vis_inc = length $part;
  		}
  		$length += $vis_inc;
  		$pos    += $vis_inc;
  	}
  
  	$length;
  }
  
  =pod
  
  =head2 flush_locations
  
  When no longer needed, the C<flush_locations> method clears all location data
  from the tokens.
  
  =cut
  
  sub flush_locations {
  	shift->_flush_locations(@_);
  }
  
  =pod
  
  =head2 normalized
  
  The C<normalized> method is used to generate a "Layer 1"
  L<PPI::Document::Normalized> object for the current Document.
  
  A "normalized" Perl Document is an arbitrary structure that removes any
  irrelevant parts of the document and refactors out variations in style,
  to attempt to approach something that is closer to the "true meaning"
  of the Document.
  
  See L<PPI::Normal> for more information on document normalization and
  the tasks for which it is useful.
  
  Returns a L<PPI::Document::Normalized> object, or C<undef> on error.
  
  =cut
  
  sub normalized {
  	# The normalization process will utterly destroy and mangle
  	# anything passed to it, so we are going to only give it a
  	# clone of ourselves.
  	PPI::Normal->process( $_[0]->clone );
  }
  
  =pod
  
  =head1 complete
  
  The C<complete> method is used to determine if a document is cleanly
  structured, all braces are closed, the final statement is
  fully terminated and all heredocs are fully entered.
  
  Returns true if the document is complete or false if not.
  
  =cut
  
  sub complete {
  	my $self = shift;
  
  	# Every structure has to be complete
  	$self->find_any( sub {
  		$_[1]->isa('PPI::Structure')
  		and
  		! $_[1]->complete
  	} )
  	and return '';
  
  	# Strip anything that isn't a statement off the end
  	my @child = $self->children;
  	while ( @child and not $child[-1]->isa('PPI::Statement') ) {
  		pop @child;
  	}
  
  	# We must have at least one statement
  	return '' unless @child;
  
  	# Check the completeness of the last statement
  	return $child[-1]->_complete;
  }
  
  
  
  
  
  #####################################################################
  # PPI::Node Methods
  
  # We are a scope boundary
  ### XS -> PPI/XS.xs:_PPI_Document__scope 0.903+
  sub scope() { 1 }
  
  
  
  
  
  #####################################################################
  # PPI::Element Methods
  
  sub insert_before {
  	return undef;
  	# die "Cannot insert_before a PPI::Document";
  }
  
  sub insert_after {
  	return undef;
  	# die "Cannot insert_after a PPI::Document";
  }
  
  sub replace {
  	return undef;
  	# die "Cannot replace a PPI::Document";
  }
  
  
  
  
  
  #####################################################################
  # Error Handling
  
  # Set the error message
  sub _error {
  	$errstr = $_[1];
  	undef;
  }
  
  # Clear the error message.
  # Returns the object as a convenience.
  sub _clear {
  	$errstr = '';
  	$_[0];
  }
  
  =pod
  
  =head2 errstr
  
  For error that occur when loading and saving documents, you can use
  C<errstr>, as either a static or object method, to access the error message.
  
  If a Document loads or saves without error, C<errstr> will return false.
  
  =cut
  
  sub errstr {
  	$errstr;
  }
  
  
  
  
  
  #####################################################################
  # Native Storable Support
  
  sub STORABLE_freeze {
  	my $self  = shift;
  	my $class = ref $self;
  	my %hash  = %$self;
  	return ($class, \%hash);
  }
  
  sub STORABLE_thaw {
  	my ($self, undef, $class, $hash) = @_;
  	bless $self, $class;
  	foreach ( keys %$hash ) {
  		$self->{$_} = delete $hash->{$_};
  	}
  	$self->__link_children;
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - May need to overload some methods to forcefully prevent Document
  objects becoming children of another Node.
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<PPI>, L<http://ali.as/>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_DOCUMENT

$fatpacked{"PPI/Document/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT_FILE';
  package PPI::Document::File;
  
  =pod
  
  =head1 NAME
  
  PPI::Document::File - A Perl Document located in a specific file
  
  =head1 DESCRIPTION
  
  B<WARNING: This class is experimental, and may change without notice>
  
  B<PPI::Document::File> provides a L<PPI::Document> subclass that represents
  a Perl document stored in a specific named file.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Carp          ();
  use Params::Util  qw{_STRING _INSTANCE};
  use PPI::Document ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Document';
  }
  
  
  
  
  
  #####################################################################
  # Constructor and Accessors
  
  =pod
  
  =head2 new
  
    my $file = PPI::Document::File->new( 'Module.pm' );
  
  The C<new> constructor works the same as for the regular one, except
  that the only params allowed is a file name. You cannot create an
  "anonymous" PPI::Document::File object, not can you create an empty one.
  
  Returns a new PPI::Document::File object, or C<undef> on error.
  
  =cut
  
  sub new {
  	my $class    = shift;
  	my $filename = _STRING(shift);
  	unless ( defined $filename ) {
  		# Perl::Critic got a complaint about not handling a file
  		# named "0".
  		return $class->_error("Did not provide a file name to load");
  	}
  
  	# Load the Document
  	my $self = $class->SUPER::new( $filename, @_ ) or return undef;
  
  	# Unlike a normal inheritance situation, due to our need to stay
  	# compatible with caching magic, this actually returns a regular
  	# anonymous document. We need to rebless if
  	if ( _INSTANCE($self, 'PPI::Document') ) {
  		bless $self, 'PPI::Document::File';
  	} else {
  		die "PPI::Document::File SUPER call returned an object of the wrong type";
  	}
  
  	# Save the filename
  	$self->{filename} = $filename;
  
  	$self;
  }
  
  =head2 filename
  
  The C<filename> accessor returns the name of the file in which the document
  is stored.
  
  =cut
  
  sub filename {
  	$_[0]->{filename};
  }
  
  =pod
  
  =head2 save
  
    # Save to the file we were loaded from
    $file->save;
    
    # Save a copy to somewhere else
    $file->save( 'Module2.pm' );
  
  The C<save> method works similarly to the one in the parent L<PPI::Document>
  class, saving a copy of the document to a file.
  
  The difference with this subclass is that if C<save> is not passed any
  filename, it will save it back to the file it was loaded from.
  
  Note: When saving to a different file, it is considered to be saving a
  B<copy> and so the value returned by the C<filename> accessor will stay
  the same, and not change to the new filename.
  
  =cut
  
  sub save {
  	my $self = shift;
  
  	# Save to where?
  	my $filename = shift;
  	unless ( defined $filename ) {
  		$filename = $self->filename;
  	}
  
  	# Hand off to main save method
  	$self->SUPER::save( $filename, @_ );
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - May need to overload some methods to forcefully prevent Document
  objects becoming children of another Node.
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_DOCUMENT_FILE

$fatpacked{"PPI/Document/Fragment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT_FRAGMENT';
  package PPI::Document::Fragment;
  
  =pod
  
  =head1 NAME
  
  PPI::Document::Fragment - A fragment of a Perl Document
  
  =head1 DESCRIPTION
  
  In some situations you might want to work with a fragment of a larger
  document. C<PPI::Document::Fragment> is a class intended for this purpose.
  It is functionally almost identical to a normal L<PPI::Document>, except
  that it is not possible to get line/column positions for the elements
  within it, and it does not represent a scope.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Document ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Document';
  }
  
  
  
  
  
  #####################################################################
  # PPI::Document Methods
  
  =pod
  
  =head2 index_locations
  
  Unlike when called on a PPI::Document object, you should not be attempting
  to find locations of things within a PPI::Document::Fragment, and thus any
  call to the C<index_locations> will print a warning and return C<undef>
  instead of attempting to index the locations of the Elements.
  
  =cut
  
  # There's no point indexing a fragment
  sub index_locations {
  	warn "Useless attempt to index the locations of a document fragment";
  	undef;
  }
  
  
  
  
  
  #####################################################################
  # PPI::Element Methods
  
  # We are not a scope boundary
  ### XS -> PPI/XS.xs:_PPI_Document_Fragment__scope 0.903+
  sub scope() { '' }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  Integrate this into the rest of PPI so it has actual practical uses. The most
  obvious would be to implement arbitrary cut/copy/paste more easily.
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_DOCUMENT_FRAGMENT

$fatpacked{"PPI/Document/Normalized.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DOCUMENT_NORMALIZED';
  package PPI::Document::Normalized;
  
  =pod
  
  =head1 NAME
  
  PPI::Document::Normalized - A normalized Perl Document
  
  =head1 DESCRIPTION
  
  A C<Normalized Document> object is the result of the normalization process
  contained in the L<PPI::Normal> class. See the documentation for
  L<PPI::Normal> for more information.
  
  The object contains a version stamp and function list for the version
  of L<PPI::Normal> used to create it, and a processed and delinked
  L<PPI::Document> object.
  
  Typically, the Document object will have been mangled by the normalization
  process in a way that would make it fatal to try to actually DO anything
  with it.
  
  Put simply, B<never> use the Document object after normalization.
  B<YOU HAVE BEEN WARNED!>
  
  The object is designed the way it is to provide a bias towards false
  negatives. A comparison between two ::Normalized object will only return
  true if they were produced by the same version of PPI::Normal, with the
  same set of normalization functions (in the same order).
  
  You may get false negatives if you are caching objects across an upgrade.
  
  Please note that this is done for security purposes, as there are many
  cases in which low layer normalization is likely to be done as part of
  a code security process, and false positives could be highly dangerous.
  
  =head1 METHODS
  
  =cut
  
  # For convenience (and since this isn't really a public class), import
  # the methods we will need from Scalar::Util.
  use strict;
  use Scalar::Util qw{refaddr reftype blessed};
  use Params::Util qw{_INSTANCE _ARRAY};
  use PPI::Util    ();
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.236';
  }
  
  use overload 'bool' => \&PPI::Util::TRUE;
  use overload '=='   => 'equal';
  
  
  
  
  
  
  #####################################################################
  # Constructor and Accessors
  
  =pod
  
  =head2 new
  
  The C<new> method is intended for use only by the L<PPI::Normal> class,
  and to get ::Normalized objects, you are highly recommended to use
  either that module, or the C<normalized> method of the L<PPI::Document>
  object itself.
  
  =cut
  
  sub new {
  	my $class = shift;
  	my %args  = @_;
  
  	# Check the required params
  	my $Document  = _INSTANCE($args{Document}, 'PPI::Document') or return undef;
  	my $version   = $args{version} or return undef;
  	my $functions = _ARRAY($args{functions}) or return undef;
  
  	# Create the object
  	my $self = bless {
  		Document  => $Document,
  		version   => $version,
  		functions => $functions,
  		}, $class;
  
  	$self;
  }
  
  sub _Document { $_[0]->{Document}  }
  
  =pod
  
  =head2 version
  
  The C<version> accessor returns the L<PPI::Normal> version used to create
  the object.
  
  =cut
  
  sub version   { $_[0]->{version}   }
  
  =pod
  
  =head2 functions
  
  The C<functions> accessor returns a reference to an array of the
  normalization functions (in order) that were called when creating
  the object.
  
  =cut
  
  sub functions { $_[0]->{functions} }
  
  
  
  
  
  #####################################################################
  # Comparison Methods
  
  =pod
  
  =head2 equal $Normalized
  
  The C<equal> method is the primary comparison method, taking another
  PPI::Document::Normalized object, and checking for equivalence to it.
  
  The C<==> operator is also overload to this method, so that you can
  do something like the following:
  
    my $first  = PPI::Document->load('first.pl');
    my $second = PPI::Document->load('second.pl');
    
    if ( $first->normalized == $second->normalized ) {
    	print "The two documents are equivalent";
    }
  
  Returns true if the normalized documents are equivalent, false if not,
  or C<undef> if there is an error.
  
  =cut
  
  sub equal {
  	my $self  = shift;
  	my $other = _INSTANCE(shift, 'PPI::Document::Normalized') or return undef;
  
  	# Prevent multiple concurrent runs
  	return undef if $self->{processing};
  
  	# Check the version and function list first
  	return '' unless $self->version eq $other->version;
  	$self->_equal_ARRAY( $self->functions, $other->functions ) or return '';
  
  	# Do the main comparison run
  	$self->{seen} = {};
  	my $rv = $self->_equal_blessed( $self->_Document, $other->_Document );
  	delete $self->{seen};
  
  	$rv;
  }
  
  # Check that two objects are matched
  sub _equal_blessed {
  	my ($self, $this, $that) = @_;
  	my ($bthis, $bthat) = (blessed $this, blessed $that);
  	$bthis and $bthat and $bthis eq $bthat or return '';
  
  	# Check the object as a reference
  	$self->_equal_reference( $this, $that );
  }
  
  # Check that two references match their types
  sub _equal_reference {
  	my ($self, $this, $that) = @_;
  	my ($rthis, $rthat) = (refaddr $this, refaddr $that);
  	$rthis and $rthat or return undef;
  
  	# If we have seen this before, are the pointing
  	# is it the same one we saw in both sides
  	my $seen = $self->{seen}->{$rthis};
  	if ( $seen and $seen ne $rthat ) {
  		return '';
  	}
  
  	# Check the reference types
  	my ($tthis, $tthat) = (reftype $this, reftype $that);
  	$tthis and $tthat and $tthis eq $tthat or return undef;
  
  	# Check the children of the reference type
  	$self->{seen}->{$rthis} = $rthat;
  	my $method = "_equal_$tthat";
  	my $rv = $self->$method( $this, $that );
  	delete $self->{seen}->{$rthis};
  	$rv;
  }
  
  # Compare the children of two SCALAR references
  sub _equal_SCALAR {
  	my ($self, $this, $that) = @_;
  	my ($cthis, $cthat) = ($$this, $$that);
  	return $self->_equal_blessed( $cthis, $cthat )   if blessed $cthis;
  	return $self->_equal_reference( $cthis, $cthat ) if ref $cthis;
  	return (defined $cthat and $cthis eq $cthat)     if defined $cthis;
  	! defined $cthat;
  }
  
  # For completeness sake, lets just treat REF as a specialist SCALAR case
  sub _equal_REF { shift->_equal_SCALAR(@_) }
  
  # Compare the children of two ARRAY references
  sub _equal_ARRAY {
  	my ($self, $this, $that) = @_;
  
  	# Compare the number of elements
  	scalar(@$this) == scalar(@$that) or return '';
  
  	# Check each element in the array.
  	# Descend depth-first.
  	foreach my $i ( 0 .. scalar(@$this) ) {
  		my ($cthis, $cthat) = ($this->[$i], $that->[$i]);
  		if ( blessed $cthis ) {
  			return '' unless $self->_equal_blessed( $cthis, $cthat );
  		} elsif ( ref $cthis ) {
  			return '' unless $self->_equal_reference( $cthis, $cthat );
  		} elsif ( defined $cthis ) {
  			return '' unless (defined $cthat and $cthis eq $cthat);
  		} else {
  			return '' if defined $cthat;
  		}
  	}
  
  	1;
  }
  
  # Compare the children of a HASH reference
  sub _equal_HASH {
  	my ($self, $this, $that) = @_;
  
  	# Compare the number of keys
  	return '' unless scalar(keys %$this) == scalar(keys %$that);
  
  	# Compare each key, descending depth-first.
  	foreach my $k ( keys %$this ) {
  		return '' unless exists $that->{$k};
  		my ($cthis, $cthat) = ($this->{$k}, $that->{$k});
  		if ( blessed $cthis ) {
  			return '' unless $self->_equal_blessed( $cthis, $cthat );
  		} elsif ( ref $cthis ) {
  			return '' unless $self->_equal_reference( $cthis, $cthat );
  		} elsif ( defined $cthis ) {
  			return '' unless (defined $cthat and $cthis eq $cthat);
  		} else {
  			return '' if defined $cthat;
  		}
  	}
  
  	1;
  }		
  
  # We do not support GLOB comparisons
  sub _equal_GLOB {
  	my ($self, $this, $that) = @_;
  	warn('GLOB comparisons are not supported');
  	'';
  }
  
  # We do not support CODE comparisons
  sub _equal_CODE {
  	my ($self, $this, $that) = @_;
  	refaddr $this == refaddr $that;
  }
  
  # We don't support IO comparisons
  sub _equal_IO {
  	my ($self, $this, $that) = @_;
  	warn('IO comparisons are not supported');
  	'';
  }
  
  sub DESTROY {
  	# Take the screw up Document with us
  	if ( $_[0]->{Document} ) {
  		$_[0]->{Document}->DESTROY;
  		delete $_[0]->{Document};
  	}
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
  	
PPI_DOCUMENT_NORMALIZED

$fatpacked{"PPI/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_DUMPER';
  package PPI::Dumper;
  
  =pod
  
  =head1 NAME
  
  PPI::Dumper - Dumping of PDOM trees
  
  =head1 SYNOPSIS
  
    # Load a document
    my $Module = PPI::Document->new( 'MyModule.pm' );
    
    # Create the dumper
    my $Dumper = PPI::Dumper->new( $Module );
    
    # Dump the document
    $Dumper->print;
  
  =head1 DESCRIPTION
  
  The PDOM trees in PPI are quite complex, and getting a dump of their
  structure for development and debugging purposes is important.
  
  This module provides that functionality.
  
  The process is relatively simple. Create a dumper object with a
  particular set of options, and then call one of the dump methods to
  generate the dump content itself.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Params::Util qw{_INSTANCE};
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.236';
  }
  
  
  
  
  
  #####################################################################
  # Constructor
  
  =pod
  
  =head2 new $Element, param => value, ...
  
  The C<new> constructor creates a dumper, and takes as argument a single
  L<PPI::Element> object of any type to serve as the root of the tree to
  be dumped, and a number of key-E<gt>value parameters to control the output
  format of the Dumper. Details of the parameters are listed below.
  
  Returns a new C<PPI::Dumper> object, or C<undef> if the constructor
  is not passed a correct L<PPI::Element> root object.
  
  =over
  
  =item memaddr
  
  Should the dumper print the memory addresses of each PDOM element.
  True/false value, off by default.
  
  =item indent
  
  Should the structures being dumped be indented. This value is numeric,
  with the number representing the number of spaces to use when indenting
  the dumper output. Set to '2' by default.
  
  =item class
  
  Should the dumper print the full class for each element.
  True/false value, on by default.
  
  =item content
  
  Should the dumper show the content of each element. True/false value,
  on by default.
  
  =item whitespace
  
  Should the dumper show whitespace tokens. By not showing the copious
  numbers of whitespace tokens the structure of the code can often be
  made much clearer. True/false value, on by default.
  
  =item comments
  
  Should the dumper show comment tokens. In situations where you have
  a lot of comments, the code can often be made clearer by ignoring
  comment tokens. True/false value, on by default.
  
  =item locations
  
  Should the dumper show the location of each token. The values shown are
  [ line, rowchar, column ]. See L<PPI::Element/"location"> for a description of
  what these values really are. True/false value, off by default.
  
  =back
  
  =cut
  
  sub new {
  	my $class   = shift;
  	my $Element = _INSTANCE(shift, 'PPI::Element') or return undef;
  
  	# Create the object
  	my $self = bless {
  		root    => $Element,
  		display => {
  			memaddr    => '', # Show the refaddr of the item
  			indent     => 2,  # Indent the structures
  			class      => 1,  # Show the object class
  			content    => 1,  # Show the object contents
  			whitespace => 1,  # Show whitespace tokens
  			comments   => 1,  # Show comment tokens
  			locations  => 0,  # Show token locations
  			},
  		}, $class;
  
  	# Handle the options
  	my @options = map { lc $_ } @_; # strict hashpairs # https://github.com/adamkennedy/PPI/issues/201
  	my %options = @options;
  	foreach ( keys %{$self->{display}} ) {
  		if ( exists $options{$_} ) {
  			if ( $_ eq 'indent' ) {
  				$self->{display}->{indent} = $options{$_};
  			} else {
  				$self->{display}->{$_} = !! $options{$_};
  			}
  		}
  	}
  
  	$self->{indent_string} = join '', (' ' x $self->{display}->{indent});
  
  	$self;
  }
  
  
  
  
  
  #####################################################################
  # Main Interface Methods
  
  =pod
  
  =head2 print
  
  The C<print> method generates the dump and prints it to STDOUT.
  
  Returns as for the internal print function.
  
  =cut
  
  sub print {
  	CORE::print(shift->string);
  }
  
  =pod
  
  =head2 string
  
  The C<string> method generates the dump and provides it as a
  single string.
  
  Returns a string or undef if there is an error while generating the dump. 
  
  =cut
  
  sub string {
  	my $array_ref = shift->_dump or return undef;
  	join '', map { "$_\n" } @$array_ref;
  }
  
  =pod
  
  =head2 list
  
  The C<list> method generates the dump and provides it as a raw
  list, without trailing newlines.
  
  Returns a list or the null list if there is an error while generating
  the dump.
  
  =cut
  
  sub list {
  	my $array_ref = shift->_dump or return ();
  	@$array_ref;
  }
  
  
  
  
  
  #####################################################################
  # Generation Support Methods
  
  sub _dump {
  	my $self    = ref $_[0] ? shift : shift->new(shift);
  	my $Element = _INSTANCE($_[0], 'PPI::Element') ? shift : $self->{root};
  	my $indent  = shift || '';
  	my $output  = shift || [];
  
  	# Print the element if needed
  	my $show = 1;
  	if ( $Element->isa('PPI::Token::Whitespace') ) {
  		$show = 0 unless $self->{display}->{whitespace};
  	} elsif ( $Element->isa('PPI::Token::Comment') ) {
  		$show = 0 unless $self->{display}->{comments};
  	}
  	push @$output, $self->_element_string( $Element, $indent ) if $show;
  
  	# Recurse into our children
  	if ( $Element->isa('PPI::Node') ) {
  		my $child_indent = $indent . $self->{indent_string};
  		foreach my $child ( @{$Element->{children}} ) {
  			$self->_dump( $child, $child_indent, $output );
  		}
  	}
  
  	$output;
  }
  
  sub _element_string {
  	my $self    = ref $_[0] ? shift : shift->new(shift);
  	my $Element = _INSTANCE($_[0], 'PPI::Element') ? shift : $self->{root};
  	my $indent  = shift || '';
  	my $string  = '';
  
  	# Add the memory location
  	if ( $self->{display}->{memaddr} ) {
  		$string .= $Element->refaddr . '  ';
  	}
          
          # Add the location if such exists
  	if ( $self->{display}->{locations} ) {
  		my $loc_string;
  		if ( $Element->isa('PPI::Token') ) {
  			my $location = $Element->location;
  			if ($location) {
  				$loc_string = sprintf("[ % 4d, % 3d, % 3d ] ", @$location);
  			}
  		}
  		# Output location or pad with 20 spaces
  		$string .= $loc_string || " " x 20;
  	}
          
  	# Add the indent
  	if ( $self->{display}->{indent} ) {
  		$string .= $indent;
  	}
  
  	# Add the class name
  	if ( $self->{display}->{class} ) {
  		$string .= ref $Element;
  	}
  
  	if ( $Element->isa('PPI::Token') ) {
  		# Add the content
  		if ( $self->{display}->{content} ) {
  			my $content = $Element->content;
  			$content =~ s/\n/\\n/g;
  			$content =~ s/\t/\\t/g;
  			$content =~ s/\f/\\f/g;
  			$string .= "  \t'$content'";
  		}
  
  	} elsif ( $Element->isa('PPI::Structure') ) {
  		# Add the content
  		if ( $self->{display}->{content} ) {
  			my $start = $Element->start
  				? $Element->start->content
  				: '???';
  			my $finish = $Element->finish
  				? $Element->finish->content
  				: '???';
  			$string .= "  \t$start ... $finish";
  		}
  	}
  	
  	$string;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_DUMPER

$fatpacked{"PPI/Element.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_ELEMENT';
  package PPI::Element;
  
  =pod
  
  =head1 NAME
  
  PPI::Element - The abstract Element class, a base for all source objects
  
  =head1 INHERITANCE
  
    PPI::Element is the root of the PDOM tree
  
  =head1 DESCRIPTION
  
  The abstract C<PPI::Element> serves as a base class for all source-related
  objects, from a single whitespace token to an entire document. It provides
  a basic set of methods to provide a common interface and basic
  implementations.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Clone           ();
  use Scalar::Util    qw{refaddr};
  use Params::Util    qw{_INSTANCE _ARRAY};
  use List::MoreUtils ();
  use PPI::Util       ();
  use PPI::Node       ();
  
  use vars qw{$VERSION $errstr %_PARENT};
  BEGIN {
  	$VERSION = '1.236';
  	$errstr  = '';
  
  	# Master Child -> Parent index
  	%_PARENT = ();
  }
  
  use overload 'bool' => \&PPI::Util::TRUE;
  use overload '""'   => 'content';
  use overload '=='   => '__equals';
  use overload '!='   => '__nequals';
  use overload 'eq'   => '__eq';
  use overload 'ne'   => '__ne';
  
  
  
  
  
  #####################################################################
  # General Properties
  
  =pod
  
  =head2 significant
  
  Because we treat whitespace and other non-code items as Tokens (in order to
  be able to "round trip" the L<PPI::Document> back to a file) the
  C<significant> method allows us to distinguish between tokens that form a
  part of the code, and tokens that aren't significant, such as whitespace,
  POD, or the portion of a file after (and including) the C<__END__> token.
  
  Returns true if the Element is significant, or false it not.
  
  =cut
  
  ### XS -> PPI/XS.xs:_PPI_Element__significant 0.845+
  sub significant() { 1 }
  
  =pod
  
  =head2 class
  
  The C<class> method is provided as a convenience, and really does nothing
  more than returning C<ref($self)>. However, some people have found that
  they appreciate the laziness of C<$Foo-E<gt>class eq 'whatever'>, so I
  have caved to popular demand and included it.
  
  Returns the class of the Element as a string
  
  =cut
  
  sub class { ref($_[0]) }
  
  =pod
  
  =head2 tokens
  
  The C<tokens> method returns a list of L<PPI::Token> objects for the
  Element, essentially getting back that part of the document as if it had
  not been lexed.
  
  This also means there are no Statements and no Structures in the list,
  just the Token classes.
  
  =cut
  
  sub tokens { $_[0] }
  
  =pod
  
  =head2 content
  
  For B<any> C<PPI::Element>, the C<content> method will reconstitute the
  base code for it as a single string. This method is also the method used
  for overloading stringification. When an Element is used in a double-quoted
  string for example, this is the method that is called.
  
  B<WARNING:>
  
  You should be aware that because of the way that here-docs are handled, any
  here-doc content is not included in C<content>, and as such you should
  B<not> eval or execute the result if it contains any L<PPI::Token::HereDoc>.
  
  The L<PPI::Document> method C<serialize> should be used to stringify a PDOM
  document into something that can be executed as expected.
  
  Returns the basic code as a string (excluding here-doc content).
  
  =cut
  
  ### XS -> PPI/XS.xs:_PPI_Element__content 0.900+
  sub content() { '' }
  
  
  
  
  
  #####################################################################
  # Navigation Methods
  
  =pod
  
  =head2 parent
  
  Elements themselves are not intended to contain other Elements, that is
  left to the L<PPI::Node> abstract class, a subclass of C<PPI::Element>.
  However, all Elements can be contained B<within> a parent Node.
  
  If an Element is within a parent Node, the C<parent> method returns the
  Node.
  
  =cut
  
  sub parent { $_PARENT{refaddr $_[0]} }
  
  =pod
  
  =head2 descendant_of $element
  
  Answers whether a C<PPI::Element> is contained within another one.
  
  C<PPI::Element>s are considered to be descendants of themselves.
  
  =cut
  
  sub descendant_of {
  	my $cursor = shift;
  	my $parent = shift or return undef;
  	while ( refaddr $cursor != refaddr $parent ) {
  		$cursor = $_PARENT{refaddr $cursor} or return '';
  	}
  	return 1;
  }
  
  =pod
  
  =head2 ancestor_of $element
  
  Answers whether a C<PPI::Element> is contains another one.
  
  C<PPI::Element>s are considered to be ancestors of themselves.
  
  =cut
  
  sub ancestor_of {
  	my $self   = shift;
  	my $cursor = shift or return undef;
  	while ( refaddr $cursor != refaddr $self ) {
  		$cursor = $_PARENT{refaddr $cursor} or return '';
  	}
  	return 1;
  }
  
  =pod
  
  =head2 statement
  
  For a C<PPI::Element> that is contained (at some depth) within a
  L<PPI::Statement>, the C<statement> method will return the first parent
  Statement object lexically 'above' the Element.
  
  Returns a L<PPI::Statement> object, which may be the same Element if the
  Element is itself a L<PPI::Statement> object.
  
  Returns false if the Element is not within a Statement and is not itself
  a Statement.
  
  =cut
  
  sub statement {
  	my $cursor = shift;
  	while ( ! _INSTANCE($cursor, 'PPI::Statement') ) {
  		$cursor = $_PARENT{refaddr $cursor} or return '';
  	}
  	$cursor;
  }
  
  =pod
  
  =head2 top
  
  For a C<PPI::Element> that is contained within a PDOM tree, the C<top> method
  will return the top-level Node in the tree. Most of the time this should be
  a L<PPI::Document> object, however this will not always be so. For example,
  if a subroutine has been removed from its Document, to be moved to another
  Document.
  
  Returns the top-most PDOM object, which may be the same Element, if it is
  not within any parent PDOM object.
  
  =cut
  
  sub top {
  	my $cursor = shift;
  	while ( my $parent = $_PARENT{refaddr $cursor} ) {
  		$cursor = $parent;
  	}
  	$cursor;
  }
  
  =pod
  
  =head2 document
  
  For an Element that is contained within a L<PPI::Document> object,
  the C<document> method will return the top-level Document for the Element.
  
  Returns the L<PPI::Document> for this Element, or false if the Element is not
  contained within a Document.
  
  =cut
  
  sub document {
  	my $top = shift->top;
  	_INSTANCE($top, 'PPI::Document') and $top;
  }
  
  =pod
  
  =head2 next_sibling
  
  All L<PPI::Node> objects (specifically, our parent Node) contain a number of
  C<PPI::Element> objects. The C<next_sibling> method returns the C<PPI::Element>
  immediately after the current one, or false if there is no next sibling.
  
  =cut
  
  sub next_sibling {
  	my $self     = shift;
  	my $parent   = $_PARENT{refaddr $self} or return '';
  	my $key      = refaddr $self;
  	my $elements = $parent->{children};
  	my $position = List::MoreUtils::firstidx {
  		refaddr $_ == $key
  		} @$elements;
  	$elements->[$position + 1] || '';
  }
  
  =pod
  
  =head2 snext_sibling
  
  As per the other 's' methods, the C<snext_sibling> method returns the next
  B<significant> sibling of the C<PPI::Element> object.
  
  Returns a C<PPI::Element> object, or false if there is no 'next' significant
  sibling.
  
  =cut
  
  sub snext_sibling {
  	my $self     = shift;
  	my $parent   = $_PARENT{refaddr $self} or return '';
  	my $key      = refaddr $self;
  	my $elements = $parent->{children};
  	my $position = List::MoreUtils::firstidx {
  		refaddr $_ == $key
  		} @$elements;
  	while ( defined(my $it = $elements->[++$position]) ) {
  		return $it if $it->significant;
  	}
  	'';
  }
  
  =pod
  
  =head2 previous_sibling
  
  All L<PPI::Node> objects (specifically, our parent Node) contain a number of
  C<PPI::Element> objects. The C<previous_sibling> method returns the Element
  immediately before the current one, or false if there is no 'previous'
  C<PPI::Element> object.
  
  =cut
  
  sub previous_sibling {
  	my $self     = shift;
  	my $parent   = $_PARENT{refaddr $self} or return '';
  	my $key      = refaddr $self;
  	my $elements = $parent->{children};
  	my $position = List::MoreUtils::firstidx {
  		refaddr $_ == $key
  		} @$elements;
  	$position and $elements->[$position - 1] or '';
  }
  
  =pod
  
  =head2 sprevious_sibling
  
  As per the other 's' methods, the C<sprevious_sibling> method returns
  the previous B<significant> sibling of the C<PPI::Element> object.
  
  Returns a C<PPI::Element> object, or false if there is no 'previous' significant
  sibling.
  
  =cut
  
  sub sprevious_sibling {
  	my $self     = shift;
  	my $parent   = $_PARENT{refaddr $self} or return '';
  	my $key      = refaddr $self;
  	my $elements = $parent->{children};
  	my $position = List::MoreUtils::firstidx {
  		refaddr $_ == $key
  		} @$elements;
  	while ( $position-- and defined(my $it = $elements->[$position]) ) {
  		return $it if $it->significant;
  	}
  	'';
  }
  
  =pod
  
  =head2 first_token
  
  As a support method for higher-order algorithms that deal specifically with
  tokens and actual Perl content, the C<first_token> method finds the first
  PPI::Token object within or equal to this one.
  
  That is, if called on a L<PPI::Node> subclass, it will descend until it
  finds a L<PPI::Token>. If called on a L<PPI::Token> object, it will return
  the same object.
  
  Returns a L<PPI::Token> object, or dies on error (which should be extremely
  rare and only occur if an illegal empty L<PPI::Statement> exists below the
  current Element somewhere.)
  
  =cut
  
  sub first_token {
  	my $cursor = shift;
  	while ( $cursor->isa('PPI::Node') ) {
  		$cursor = $cursor->first_element
  		or die "Found empty PPI::Node while getting first token";
  	}
  	$cursor;
  }
  
  
  =pod
  
  =head2 last_token
  
  As a support method for higher-order algorithms that deal specifically with
  tokens and actual Perl content, the C<last_token> method finds the last
  PPI::Token object within or equal to this one.
  
  That is, if called on a L<PPI::Node> subclass, it will descend until it
  finds a L<PPI::Token>. If called on a L<PPI::Token> object, it will return
  the itself.
  
  Returns a L<PPI::Token> object, or dies on error (which should be extremely
  rare and only occur if an illegal empty L<PPI::Statement> exists below the
  current Element somewhere.)
  
  =cut
  
  sub last_token {
  	my $cursor = shift;
  	while ( $cursor->isa('PPI::Node') ) {
  		$cursor = $cursor->last_element
  		or die "Found empty PPI::Node while getting first token";
  	}
  	$cursor;
  }
  
  =pod
  
  =head2 next_token
  
  As a support method for higher-order algorithms that deal specifically with
  tokens and actual Perl content, the C<next_token> method finds the
  L<PPI::Token> object that is immediately after the current Element, even if
  it is not within the same parent L<PPI::Node> as the one for which the
  method is being called.
  
  Note that this is B<not> defined as a L<PPI::Token>-specific method,
  because it can be useful to find the next token that is after, say, a
  L<PPI::Statement>, although obviously it would be useless to want the
  next token after a L<PPI::Document>.
  
  Returns a L<PPI::Token> object, or false if there are no more tokens after
  the Element.
  
  =cut
  
  sub next_token {
  	my $cursor = shift;
  
  	# Find the next element, going upwards as needed
  	while ( 1 ) {
  		my $element = $cursor->next_sibling;
  		if ( $element ) {
  			return $element if $element->isa('PPI::Token');
  			return $element->first_token;
  		}
  		$cursor = $cursor->parent or return '';
  		if ( $cursor->isa('PPI::Structure') and $cursor->finish ) {
  			return $cursor->finish;
  		}
  	}
  }
  
  =pod
  
  =head2 previous_token
  
  As a support method for higher-order algorithms that deal specifically with
  tokens and actual Perl content, the C<previous_token> method finds the
  L<PPI::Token> object that is immediately before the current Element, even
  if it is not within the same parent L<PPI::Node> as this one.
  
  Note that this is not defined as a L<PPI::Token>-only method, because it can
  be useful to find the token is before, say, a L<PPI::Statement>, although
  obviously it would be useless to want the next token before a
  L<PPI::Document>.
  
  Returns a L<PPI::Token> object, or false if there are no more tokens before
  the C<Element>.
  
  =cut
  
  sub previous_token {
  	my $cursor = shift;
  
  	# Find the previous element, going upwards as needed
  	while ( 1 ) {
  		my $element = $cursor->previous_sibling;
  		if ( $element ) {
  			return $element if $element->isa('PPI::Token');
  			return $element->last_token;
  		}
  		$cursor = $cursor->parent or return '';
  		if ( $cursor->isa('PPI::Structure') and $cursor->start ) {
  			return $cursor->start;
  		}
  	}
  }
  
  
  
  
  
  #####################################################################
  # Manipulation
  
  =pod
  
  =head2 clone
  
  As per the L<Clone> module, the C<clone> method makes a perfect copy of
  an Element object. In the generic case, the implementation is done using
  the L<Clone> module's mechanism itself. In higher-order cases, such as for
  Nodes, there is more work involved to keep the parent-child links intact.
  
  =cut
  
  sub clone {
  	Clone::clone(shift);
  }
  
  =pod
  
  =head2 insert_before @Elements
  
  The C<insert_before> method allows you to insert lexical perl content, in
  the form of C<PPI::Element> objects, before the calling C<Element>. You
  need to be very careful when modifying perl code, as it's easy to break
  things.
  
  In its initial incarnation, this method allows you to insert a single
  Element, and will perform some basic checking to prevent you inserting
  something that would be structurally wrong (in PDOM terms).
  
  In future, this method may be enhanced to allow the insertion of multiple
  Elements, inline-parsed code strings or L<PPI::Document::Fragment> objects.
  
  Returns true if the Element was inserted, false if it can not be inserted,
  or C<undef> if you do not provide a C<PPI::Element> object as a parameter.
  
  =cut
  
  sub __insert_before {
  	my $self = shift;
  	$self->parent->__insert_before_child( $self, @_ );
  }
  
  =pod
  
  =head2 insert_after @Elements
  
  The C<insert_after> method allows you to insert lexical perl content, in
  the form of C<PPI::Element> objects, after the calling C<Element>. You need
  to be very careful when modifying perl code, as it's easy to break things.
  
  In its initial incarnation, this method allows you to insert a single
  Element, and will perform some basic checking to prevent you inserting
  something that would be structurally wrong (in PDOM terms).
  
  In future, this method may be enhanced to allow the insertion of multiple
  Elements, inline-parsed code strings or L<PPI::Document::Fragment> objects.
  
  Returns true if the Element was inserted, false if it can not be inserted,
  or C<undef> if you do not provide a C<PPI::Element> object as a parameter.
  
  =cut
  
  sub __insert_after {
  	my $self = shift;
  	$self->parent->__insert_after_child( $self, @_ );
  }
  
  =pod
  
  =head2 remove
  
  For a given C<PPI::Element>, the C<remove> method will remove it from its
  parent B<intact>, along with all of its children.
  
  Returns the C<Element> itself as a convenience, or C<undef> if an error
  occurs while trying to remove the C<Element>.
  
  =cut
  
  sub remove {
  	my $self   = shift;
  	my $parent = $self->parent or return $self;
  	$parent->remove_child( $self );
  }
  
  =pod
  
  =head2 delete
  
  For a given C<PPI::Element>, the C<delete> method will remove it from its
  parent, immediately deleting the C<Element> and all of its children (if it
  has any).
  
  Returns true if the C<Element> was successfully deleted, or C<undef> if
  an error occurs while trying to remove the C<Element>.
  
  =cut
  
  sub delete {
  	$_[0]->remove or return undef;
  	$_[0]->DESTROY;
  	1;
  }
  
  =pod
  
  =head2 replace $Element
  
  Although some higher level class support more exotic forms of replace,
  at the basic level the C<replace> method takes a single C<Element> as
  an argument and replaces the current C<Element> with it.
  
  To prevent accidental damage to code, in this initial implementation the
  replacement element B<must> be of the same class (or a subclass) as the
  one being replaced.
  
  =cut
  
  sub replace {
  	my $self    = ref $_[0] ? shift : return undef;
  	_INSTANCE(shift, ref $self) or return undef;
  	die "The ->replace method has not yet been implemented";
  }
  
  =pod
  
  =head2 location
  
  If the Element exists within a L<PPI::Document> that has
  indexed the Element locations using C<PPI::Document::index_locations>, the
  C<location> method will return the location of the first character of the
  Element within the Document.
  
  Returns the location as a reference to a five-element array in the form C<[
  $line, $rowchar, $col, $logical_line, $logical_file_name ]>. The values are in
  a human format, with the first character of the file located at C<[ 1, 1, 1, ?,
  'something' ]>.
  
  The second and third numbers are similar, except that the second is the
  literal horizontal character, and the third is the visual column, taking
  into account tabbing (see L<PPI::Document/"tab_width [ $width ]">).
  
  The fourth number is the line number, taking into account any C<#line>
  directives.  The fifth element is the name of the file that the element was
  found in, if available, taking into account any C<#line> directives.
  
  Returns C<undef> on error, or if the L<PPI::Document> object has not been
  indexed.
  
  =cut
  
  sub location {
  	my $self = shift;
  
  	$self->_ensure_location_present or return undef;
  
  	# Return a copy, not the original
  	return [ @{$self->{_location}} ];
  }
  
  =pod
  
  =head2 line_number
  
  If the Element exists within a L<PPI::Document> that has indexed the Element
  locations using C<PPI::Document::index_locations>, the C<line_number> method
  will return the line number of the first character of the Element within the
  Document.
  
  Returns C<undef> on error, or if the L<PPI::Document> object has not been
  indexed.
  
  =cut
  
  sub line_number {
  	my $self = shift;
  
  	my $location = $self->location() or return undef;
  	return $location->[0];
  }
  
  =pod
  
  =head2 column_number
  
  If the Element exists within a L<PPI::Document> that has indexed the Element
  locations using C<PPI::Document::index_locations>, the C<column_number> method
  will return the column number of the first character of the Element within the
  Document.
  
  Returns C<undef> on error, or if the L<PPI::Document> object has not been
  indexed.
  
  =cut
  
  sub column_number {
  	my $self = shift;
  
  	my $location = $self->location() or return undef;
  	return $location->[1];
  }
  
  =pod
  
  =head2 visual_column_number
  
  If the Element exists within a L<PPI::Document> that has indexed the Element
  locations using C<PPI::Document::index_locations>, the C<visual_column_number>
  method will return the visual column number of the first character of the
  Element within the Document, according to the value of
  L<PPI::Document/"tab_width [ $width ]">.
  
  Returns C<undef> on error, or if the L<PPI::Document> object has not been
  indexed.
  
  =cut
  
  sub visual_column_number {
  	my $self = shift;
  
  	my $location = $self->location() or return undef;
  	return $location->[2];
  }
  
  =pod
  
  =head2 logical_line_number
  
  If the Element exists within a L<PPI::Document> that has indexed the Element
  locations using C<PPI::Document::index_locations>, the C<logical_line_number>
  method will return the line number of the first character of the Element within
  the Document, taking into account any C<#line> directives.
  
  Returns C<undef> on error, or if the L<PPI::Document> object has not been
  indexed.
  
  =cut
  
  sub logical_line_number {
  	my $self = shift;
  
  	return $self->location()->[3];
  }
  
  =pod
  
  =head2 logical_filename
  
  If the Element exists within a L<PPI::Document> that has indexed the Element
  locations using C<PPI::Document::index_locations>, the C<logical_filename>
  method will return the logical file name containing the first character of the
  Element within the Document, taking into account any C<#line> directives.
  
  Returns C<undef> on error, or if the L<PPI::Document> object has not been
  indexed.
  
  =cut
  
  sub logical_filename {
  	my $self = shift;
  
  	my $location = $self->location() or return undef;
  	return $location->[4];
  }
  
  sub _ensure_location_present {
  	my $self = shift;
  
  	unless ( exists $self->{_location} ) {
  		# Are we inside a normal document?
  		my $Document = $self->document or return undef;
  		if ( $Document->isa('PPI::Document::Fragment') ) {
  			# Because they can't be serialized, document fragments
  			# do not support the concept of location.
  			return undef;
  		}
  
  		# Generate the locations. If they need one location, then
  		# the chances are they'll want more, and it's better that
  		# everything is already pre-generated.
  		$Document->index_locations or return undef;
  		unless ( exists $self->{_location} ) {
  			# erm... something went very wrong here
  			return undef;
  		}
  	}
  
  	return 1;
  }
  
  # Although flush_locations is only publically a Document-level method,
  # we are able to implement it at an Element level, allowing us to
  # selectively flush only the part of the document that occurs after the
  # element for which the flush is called.
  sub _flush_locations {
  	my $self  = shift;
  	unless ( $self == $self->top ) {
  		return $self->top->_flush_locations( $self );
  	}
  
  	# Get the full list of all Tokens
  	my @Tokens = $self->tokens;
  
  	# Optionally allow starting from an arbitrary element (or rather,
  	# the first Token equal-to-or-within an arbitrary element)
  	if ( _INSTANCE($_[0], 'PPI::Element') ) {
  		my $start = shift->first_token;
  		while ( my $Token = shift @Tokens ) {
  			return 1 unless $Token->{_location};
  			next unless refaddr($Token) == refaddr($start);
  
  			# Found the start. Flush it's location
  			delete $$Token->{_location};
  			last;
  		}
  	}
  
  	# Iterate over any remaining Tokens and flush their location
  	foreach my $Token ( @Tokens ) {
  		delete $Token->{_location};
  	}
  
  	1;
  }
  
  
  
  
  
  #####################################################################
  # XML Compatibility Methods
  
  sub _xml_name {
  	my $class = ref $_[0] || $_[0];
  	my $name  = lc join( '_', split /::/, $class );
  	substr($name, 4);
  }
  
  sub _xml_attr {
  	return {};
  }
  
  sub _xml_content {
  	defined $_[0]->{content} ? $_[0]->{content} : '';
  }
  
  
  
  
  
  #####################################################################
  # Internals
  
  # Set the error string
  sub _error {
  	$errstr = $_[1];
  	undef;
  }
  
  # Clear the error string
  sub _clear {
  	$errstr = '';
  	$_[0];
  }
  
  # Being DESTROYed in this manner, rather than by an explicit
  # ->delete means our reference count has probably fallen to zero.
  # Therefore we don't need to remove ourselves from our parent,
  # just the index ( just in case ).
  ### XS -> PPI/XS.xs:_PPI_Element__DESTROY 0.900+
  sub DESTROY { delete $_PARENT{refaddr $_[0]} }
  
  # Operator overloads
  sub __equals  { ref $_[1] and refaddr($_[0]) == refaddr($_[1]) }
  sub __nequals { !__equals(@_) }
  sub __eq {
  	my $self  = _INSTANCE($_[0], 'PPI::Element') ? $_[0]->content : $_[0];
  	my $other = _INSTANCE($_[1], 'PPI::Element') ? $_[1]->content : $_[1];
  	$self eq $other;
  }
  sub __ne { !__eq(@_) }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  It would be nice if C<location> could be used in an ad-hoc manner. That is,
  if called on an Element within a Document that has not been indexed, it will
  do a one-off calculation to find the location. It might be very painful if
  someone started using it a lot, without remembering to index the document,
  but it would be handy for things that are only likely to use it once, such
  as error handlers.
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_ELEMENT

$fatpacked{"PPI/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_EXCEPTION';
  package PPI::Exception;
  
  =head1 NAME
  
  PPI::Exception - The PPI exception base class
  
  =head1 SYNOPSIS
  
    use PPI::Exception;
    
    my $e = PPI::Exception->new( 'something happened' );
    $e->throw;
  
    PPI::Exception->new( message => 'something happened' )->throw;
    PPI::Exception->throw( message => 'something happened' );
  
  =head1 DESCRIPTION
  
  All exceptions thrown from within PPI will be instances or derivations
  of this class.
  
  =cut
  
  use strict;
  use Params::Util qw{_INSTANCE};
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.236';
  }
  
  
  =head1 METHODS
  
  =head2 new $message | message => $message, ...
  
  Constructs and returns a new C<PPI::Exception> object.
  
  A message for the exception can be passed, either as a string
  or as C<< message => $message >>. The message is available via the
  C<message> method.
  
  =cut
  
  sub new {
  	my $class = shift;
  	return bless { @_ }, $class if @_ > 1;
  	return bless { message => $_[0] }, $class if @_;
  	return bless { message => 'Unknown Exception' }, $class;
  }
  
  
  =head2 throw
  
  If called on a C<PPI::Exception> object, throws the object.
  If called on the class name, uses the arguments to construct a
  C<PPI::Exception> and then throw it.
  
  Each time the object is thrown, information from the Perl <caller(0)>
  call is saved and made available via the C<callers> method.
  
  This method never returns.
  
  =cut
  
  sub throw {
  	my $it = shift;
  	if ( _INSTANCE($it, 'PPI::Exception') ) {
  		if ( $it->{callers} ) {
  			push @{ $it->{callers} }, [ caller(0) ];
  		} else {
  			$it->{callers} ||= [];
  		}
  	} else {
  		my $message = $_[0] || 'Unknown Exception';
  		$it = $it->new(
  			message => $message,
  			callers => [
  				[ caller(0) ],
  			],
  		);
  	}
  	die $it;
  }
  
  
  =head2 message
  
  Returns the exception message passed to the object's constructor,
  or a default message.
  
  =cut
  
  sub message {
  	$_[0]->{message};
  }
  
  
  =head2 callers
  
  Returns a listref, each element of which is a listref of C<caller(0)>
  information.  The returned listref can be empty.
  
  =cut
  
  sub callers {
  	@{ $_[0]->{callers} || [] };
  }
  
  
  1;
PPI_EXCEPTION

$fatpacked{"PPI/Exception/ParserRejection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_EXCEPTION_PARSERREJECTION';
  package PPI::Exception::ParserRejection;
  
  use strict;
  use PPI::Exception ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Exception';
  }
  
  1;
PPI_EXCEPTION_PARSERREJECTION

$fatpacked{"PPI/Find.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_FIND';
  package PPI::Find;
  
  =pod
  
  =head1 NAME
  
  PPI::Find - Object version of the Element->find method
  
  =head1 SYNOPSIS
  
    # Create the Find object
    my $Find = PPI::Find->new( \&wanted );
    
    # Return all matching Elements as a list
    my @found = $Find->in( $Document );
    
    # Can we find any matching Elements
    if ( $Find->any_matches($Document) ) {
    	print "Found at least one matching Element";
    }
    
    # Use the object as an iterator
    $Find->start($Document) or die "Failed to execute search";
    while ( my $token = $Find->match ) {
    	...
    }
  
  =head1 DESCRIPTION
  
  PPI::Find is the primary PDOM searching class in the core PPI package.
  
  =head2 History
  
  It became quite obvious during the development of PPI that many of the
  modules that would be built on top of it were going to need large numbers
  of saved, storable or easily creatable search objects that could be
  reused a number of times.
  
  Although the internal ->find method provides a basic ability to search,
  it is by no means thorough. PPI::Find attempts to resolve this problem.
  
  =head2 Structure and Style
  
  PPI::Find provides a similar API to the popular L<File::Find::Rule>
  module for file searching, but without the ability to assemble queries.
  
  The implementation of a separate PPI::Find::Rule sub-class that does
  provide this ability is left as an exercise for the reader.
  
  =head2 The &wanted function
  
  At the core of each PPI::Find object is a "wanted" function that is
  passed a number of arguments and returns a value which controls the
  flow of the search.
  
  As the search executes, each Element will be passed to the wanted function
  in depth-first order.
  
  It will be provided with two arguments. The current Element to test as $_[0],
  and the top-level Element of the search as $_[1].
  
  The &wanted function is expected to return 1 (positive) if the Element
  matches the condition, 0 (false) if it does not, and undef (undefined) if
  the condition does not match, and the Find search should not descend to
  any of the current Element's children.
  
  Errors should be reported from the &wanted function via die, which will be
  caught by the Find object and returned as an error.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Params::Util qw{_INSTANCE};
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.236';
  }
  
  
  
  
  
  #####################################################################
  # Constructor
  
  =pod
  
  =head2 new &wanted
  
  The C<new> constructor takes a single argument of the &wanted function,
  as described above and creates a new search.
  
  Returns a new PPI::Find object, or C<undef> if not passed a CODE reference.
  
  =cut
  
  sub new {
  	my $class  = ref $_[0] ? ref shift : shift;
  	my $wanted = ref $_[0] eq 'CODE' ? shift : return undef;
  
  	# Create the object
  	my $self = bless {
  		wanted => $wanted,
  	}, $class;
  
  	$self;
  }
  
  =pod
  
  =head2 clone
  
  The C<clone> method creates another instance of the same Find object.
  
  The cloning is done safely, so if your existing Find object is in the
  middle of an iteration, the cloned Find object will not also be in the
  iteration and can be safely used independently.
  
  Returns a duplicate PPI::Find object.
  
  =cut
  
  sub clone {
  	my $self = ref $_[0] ? shift
  		: die "->clone can only be called as an object method";
  	my $class = ref $self;
  
  	# Create the object
  	my $clone = bless {
  		wanted => $self->{wanted},
  	}, $class;
  
  	$clone;
  }
  
  
  
  
  
  ####################################################################
  # Search Execution Methods
  
  =pod
  
  =head2 in $Document [, array_ref => 1 ]
  
  The C<in> method starts and completes a full run of the search.
  
  It takes as argument a single L<PPI::Element> object which will
  serve as the top of the search process.
  
  Returns a list of PPI::Element objects that match the condition
  described by the &wanted function, or the null list on error.
  
  You should check the ->errstr method for any errors if you are
  returned the null list, which may also mean simply that no Elements
  were found that matched the condition.
  
  Because of this need to explicitly check for errors, an alternative
  return value mechanism is provide. If you pass the C<< array_ref => 1 >>
  parameter to the method, it will return the list of matched Elements
  as a reference to an ARRAY. The method will return false if no elements
  were matched, or C<undef> on error.
  
  The ->errstr method can still be used to get the error message as normal.
  
  =cut
  
  sub in {
  	my $self    = shift;
  	my $Element = shift;
  	my %params  = @_;
  	delete $self->{errstr};
   
  	# Are we already acting as an iterator
  	if ( $self->{in} ) {
  		return $self->_error('->in called while another search is in progress', %params);
  	}
  
  	# Get the root element for the search
  	unless ( _INSTANCE($Element, 'PPI::Element') ) {
  		return $self->_error('->in was not passed a PPI::Element object', %params);
  	}
  
  	# Prepare the search
  	$self->{in}      = $Element;
  	$self->{matches} = [];
  
  	# Execute the search
  	if ( !eval { $self->_execute; 1 } ) {
  		my $errstr = $@;
  		$errstr =~ s/\s+at\s+line\s+.+$//;
  		return $self->_error("Error while searching: $errstr", %params);
  	}
  
  	# Clean up and return
  	delete $self->{in};
  	if ( $params{array_ref} ) {
  		if ( @{$self->{matches}} ) {
  			return delete $self->{matches};
  		}
  		delete $self->{matches};
  		return '';
  	}
  
  	# Return as a list
  	my $matches = delete $self->{matches};
  	@$matches;
  }
  
  =pod
  
  =head2 start $Element
  
  The C<start> method lets the Find object act as an iterator. The method
  is passed the parent PPI::Element object as for the C<in> method, but does
  not accept any parameters.
  
  To simplify error handling, the entire search is done at once, with the
  results cached and provided as-requested.
  
  Returns true if the search completes, and false on error.
  
  =cut
  
  sub start {
  	my $self    = shift;
  	my $Element = shift;
  	delete $self->{errstr};
  
  	# Are we already acting as an iterator
  	if ( $self->{in} ) {
  		return $self->_error('->in called while another search is in progress');
  	}
  
  	# Get the root element for the search
  	unless ( _INSTANCE($Element, 'PPI::Element') ) {
  		return $self->_error('->in was not passed a PPI::Element object');
  	}
  
  	# Prepare the search
  	$self->{in}      = $Element;
  	$self->{matches} = [];
  
  	# Execute the search
  	if ( !eval { $self->_execute; 1 } ) {
  		my $errstr = $@;
  		$errstr =~ s/\s+at\s+line\s+.+$//;
  		$self->_error("Error while searching: $errstr");
  		return undef;
  	}
  
  	1;
  }
  
  =pod
  
  =head2 match
  
  The C<match> method returns the next matching Element in the iteration.
  
  Returns a PPI::Element object, or C<undef> if there are no remaining
  Elements to be returned.
  
  =cut
  
  sub match {
  	my $self = shift;
  	return undef unless $self->{matches};
  
  	# Fetch and return the next match
  	my $match = shift @{$self->{matches}};
  	return $match if $match;
  
  	$self->finish;
  	undef;
  }
  
  =pod
  
  =head2 finish
  
  The C<finish> method provides a mechanism to end iteration if you wish to
  stop the iteration prematurely. It resets the Find object and allows it to
  be safely reused.
  
  A Find object will be automatically finished when C<match> returns false.
  This means you should only need to call C<finish> when you stop
  iterating early.
  
  You may safely call this method even when not iterating and it will return
  without failure.
  
  Always returns true
  
  =cut
  
  sub finish {
  	my $self = shift;
  	delete $self->{in};
  	delete $self->{matches};
  	delete $self->{errstr};
  	1;
  }
  
  
  
  
  
  #####################################################################
  # Support Methods and Error Handling
  
  sub _execute {
  	my $self   = shift;
  	my $wanted = $self->{wanted};
  	my @queue  = ( $self->{in} );
  
  	# Pull entries off the queue and hand them off to the wanted function
  	while ( my $Element = shift @queue ) {
  		my $rv = &$wanted( $Element, $self->{in} );
  
  		# Add to the matches if returns true
  		push @{$self->{matches}}, $Element if $rv;
  
  		# Continue and don't descend if it returned undef
  		# or if it doesn't have children
  		next unless defined $rv;
  		next unless $Element->isa('PPI::Node');
  
  		# Add the children to the head of the queue
  		if ( $Element->isa('PPI::Structure') ) {
  			unshift @queue, $Element->finish if $Element->finish;
  			unshift @queue, $Element->children;
  			unshift @queue, $Element->start if $Element->start;
  		} else {
  			unshift @queue, $Element->children;
  		}
  	}
  
  	1;
  }
  
  =pod
  
  =head2 errstr
  
  The C<errstr> method returns the error messages when a given PPI::Find
  object fails any action.
  
  Returns a string, or C<undef> if there is no error.
  
  =cut
  
  sub errstr {
  	shift->{errstr};
  }
  
  sub _error {
  	my $self = shift;
  	$self->{errstr} = shift;
  	my %params = @_;
  	$params{array_ref} ? undef : ();
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Implement the L<PPI::Find::Rule> class
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_FIND

$fatpacked{"PPI/Lexer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_LEXER';
  package PPI::Lexer;
  
  =pod
  
  =head1 NAME
  
  PPI::Lexer - The PPI Lexer
  
  =head1 SYNOPSIS
  
    use PPI;
    
    # Create a new Lexer
    my $Lexer = PPI::Lexer->new;
    
    # Build a PPI::Document object from a Token stream
    my $Tokenizer = PPI::Tokenizer->load('My/Module.pm');
    my $Document = $Lexer->lex_tokenizer($Tokenizer);
    
    # Build a PPI::Document object for some raw source
    my $source = "print 'Hello World!'; kill(Humans->all);";
    $Document = $Lexer->lex_source($source);
    
    # Build a PPI::Document object for a particular file name
    $Document = $Lexer->lex_file('My/Module.pm');
  
  =head1 DESCRIPTION
  
  The is the L<PPI> Lexer. In the larger scheme of things, its job is to take
  token streams, in a variety of forms, and "lex" them into nested structures.
  
  Pretty much everything in this module happens behind the scenes at this
  point. In fact, at the moment you don't really need to instantiate the lexer
  at all, the three main methods will auto-instantiate themselves a
  C<PPI::Lexer> object as needed.
  
  All methods do a one-shot "lex this and give me a L<PPI::Document> object".
  
  In fact, if you are reading this, what you B<probably> want to do is to
  just "load a document", in which case you can do this in a much more
  direct and concise manner with one of the following.
  
    use PPI;
    
    $Document = PPI::Document->load( $filename );
    $Document = PPI::Document->new( $string );
  
  See L<PPI::Document> for more details.
  
  For more unusual tasks, by all means forge onwards.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Scalar::Util    ();
  use Params::Util    qw{_STRING _INSTANCE};
  use List::MoreUtils ();
  use PPI             ();
  use PPI::Exception  ();
  
  use vars qw{$VERSION $errstr *_PARENT %ROUND %RESOLVE};
  BEGIN {
  	$VERSION = '1.236';
  	$errstr  = '';
  
  	# Faster than having another method call just
  	# to set the structure finish token.
  	*_PARENT = *PPI::Element::_PARENT;
  
  	# Keyword -> Structure class maps
  	%ROUND = (
  		# Conditions
  		'if'     => 'PPI::Structure::Condition',
  		'elsif'  => 'PPI::Structure::Condition',
  		'unless' => 'PPI::Structure::Condition',
  		'while'  => 'PPI::Structure::Condition',
  		'until'  => 'PPI::Structure::Condition',
  
  		# For(each)
  		'for'     => 'PPI::Structure::For',
  		'foreach' => 'PPI::Structure::For',
  	);
  
  	# Opening brace to refining method
  	%RESOLVE = (
  		'(' => '_round',
  		'[' => '_square',
  		'{' => '_curly',
  	);
  
  }
  
  # Allows for experimental overriding of the tokenizer
  use vars qw{ $X_TOKENIZER };
  BEGIN {
  	$X_TOKENIZER ||= 'PPI::Tokenizer';
  }
  use constant X_TOKENIZER => $X_TOKENIZER;
  
  
  
  
  
  #####################################################################
  # Constructor
  
  =pod
  
  =head2 new
  
  The C<new> constructor creates a new C<PPI::Lexer> object. The object itself
  is merely used to hold various buffers and state data during the lexing
  process, and holds no significant data between -E<gt>lex_xxxxx calls.
  
  Returns a new C<PPI::Lexer> object
  
  =cut
  
  sub new {
  	my $class = shift->_clear;
  	bless {
  		Tokenizer => undef, # Where we store the tokenizer for a run
  		buffer    => [],    # The input token buffer
  		delayed   => [],    # The "delayed insignificant tokens" buffer
  	}, $class;
  }
  
  
  
  
  
  #####################################################################
  # Main Lexing Methods
  
  =pod
  
  =head2 lex_file $filename
  
  The C<lex_file> method takes a filename as argument. It then loads the file,
  creates a L<PPI::Tokenizer> for the content and lexes the token stream
  produced by the tokenizer. Basically, a sort of all-in-one method for
  getting a L<PPI::Document> object from a file name.
  
  Returns a L<PPI::Document> object, or C<undef> on error.
  
  =cut
  
  sub lex_file {
  	my $self = ref $_[0] ? shift : shift->new;
  	my $file = _STRING(shift);
  	unless ( defined $file ) {
  		return $self->_error("Did not pass a filename to PPI::Lexer::lex_file");
  	}
  
  	# Create the Tokenizer
  	my $Tokenizer = eval {
  		X_TOKENIZER->new($file);
  	};
  	if ( _INSTANCE($@, 'PPI::Exception') ) {
  		return $self->_error( $@->message );
  	} elsif ( $@ ) {
  		return $self->_error( $errstr );
  	}
  
  	$self->lex_tokenizer( $Tokenizer );
  }
  
  =pod
  
  =head2 lex_source $string
  
  The C<lex_source> method takes a normal scalar string as argument. It
  creates a L<PPI::Tokenizer> object for the string, and then lexes the
  resulting token stream.
  
  Returns a L<PPI::Document> object, or C<undef> on error.
  
  =cut
  
  sub lex_source {
  	my $self   = ref $_[0] ? shift : shift->new;
  	my $source = shift;
  	unless ( defined $source and not ref $source ) {
  		return $self->_error("Did not pass a string to PPI::Lexer::lex_source");
  	}
  
  	# Create the Tokenizer and hand off to the next method
  	my $Tokenizer = eval {
  		X_TOKENIZER->new(\$source);
  	};
  	if ( _INSTANCE($@, 'PPI::Exception') ) {
  		return $self->_error( $@->message );
  	} elsif ( $@ ) {
  		return $self->_error( $errstr );
  	}
  
  	$self->lex_tokenizer( $Tokenizer );
  }
  
  =pod
  
  =head2 lex_tokenizer $Tokenizer
  
  The C<lex_tokenizer> takes as argument a L<PPI::Tokenizer> object. It
  lexes the token stream from the tokenizer into a L<PPI::Document> object.
  
  Returns a L<PPI::Document> object, or C<undef> on error.
  
  =cut
  
  sub lex_tokenizer {
  	my $self      = ref $_[0] ? shift : shift->new;
  	my $Tokenizer = _INSTANCE(shift, 'PPI::Tokenizer');
  	return $self->_error(
  		"Did not pass a PPI::Tokenizer object to PPI::Lexer::lex_tokenizer"
  	) unless $Tokenizer;
  
  	# Create the empty document
  	my $Document = PPI::Document->new;
  
  	# Lex the token stream into the document
  	$self->{Tokenizer} = $Tokenizer;
  	if ( !eval { $self->_lex_document($Document); 1 } ) {
  		# If an error occurs DESTROY the partially built document.
  		undef $Document;
  		if ( _INSTANCE($@, 'PPI::Exception') ) {
  			return $self->_error( $@->message );
  		} else {
  			return $self->_error( $errstr );
  		}
  	}
  
  	return $Document;
  }
  
  
  
  
  
  #####################################################################
  # Lex Methods - Document Object
  
  sub _lex_document {
  	my ($self, $Document) = @_;
  	# my $self     = shift;
  	# my $Document = _INSTANCE(shift, 'PPI::Document') or return undef;
  
  	# Start the processing loop
  	my $Token;
  	while ( ref($Token = $self->_get_token) ) {
  		# Add insignificant tokens directly beneath us
  		unless ( $Token->significant ) {
  			$self->_add_element( $Document, $Token );
  			next;
  		}
  
  		if ( $Token->content eq ';' ) {
  			# It's a semi-colon on it's own.
  			# We call this a null statement.
  			$self->_add_element(
  				$Document,
  				PPI::Statement::Null->new($Token),
  			);
  			next;
  		}
  
  		# Handle anything other than a structural element
  		unless ( ref $Token eq 'PPI::Token::Structure' ) {
  			# Determine the class for the Statement, and create it
  			my $Statement = $self->_statement($Document, $Token)->new($Token);
  
  			# Move the lexing down into the statement
  			$self->_add_delayed( $Document );
  			$self->_add_element( $Document, $Statement );
  			$self->_lex_statement( $Statement );
  
  			next;
  		}
  
  		# Is this the opening of a structure?
  		if ( $Token->__LEXER__opens ) {
  			# This should actually have a Statement instead
  			$self->_rollback( $Token );
  			my $Statement = PPI::Statement->new;
  			$self->_add_element( $Document, $Statement );
  			$self->_lex_statement( $Statement );
  			next;
  		}
  
  		# Is this the close of a structure.
  		if ( $Token->__LEXER__closes ) {
  			# Because we are at the top of the tree, this is an error.
  			# This means either a mis-parsing, or a mistake in the code.
  			# To handle this, we create a "Naked Close" statement
  			$self->_add_element( $Document,
  				PPI::Statement::UnmatchedBrace->new($Token)
  			);
  			next;
  		}
  
  		# Shouldn't be able to get here
  		PPI::Exception->throw('Lexer reached an illegal state');
  	}
  
  	# Did we leave the main loop because of a Tokenizer error?
  	unless ( defined $Token ) {
  		my $errstr = $self->{Tokenizer} ? $self->{Tokenizer}->errstr : '';
  		$errstr ||= 'Unknown Tokenizer Error';
  		PPI::Exception->throw($errstr);
  	}
  
  	# No error, it's just the end of file.
  	# Add any insignificant trailing tokens.
  	$self->_add_delayed( $Document );
  
  	# If the Tokenizer has any v6 blocks to attach, do so now.
  	# Checking once at the end is faster than adding a special
  	# case check for every statement parsed.
  	my $perl6 = $self->{Tokenizer}->{'perl6'};
  	if ( @$perl6 ) {
  		my $includes = $Document->find( 'PPI::Statement::Include::Perl6' );
  		foreach my $include ( @$includes ) {
  			unless ( @$perl6 ) {
  				PPI::Exception->throw('Failed to find a perl6 section');
  			}
  			$include->{perl6} = shift @$perl6;
  		}
  	}
  
  	return 1;
  }
  
  
  
  
  
  #####################################################################
  # Lex Methods - Statement Object
  
  use vars qw{%STATEMENT_CLASSES};
  BEGIN {
  	# Keyword -> Statement Subclass
  	%STATEMENT_CLASSES = (
  		# Things that affect the timing of execution
  		'BEGIN'     => 'PPI::Statement::Scheduled',
  		'CHECK'     => 'PPI::Statement::Scheduled',
  		'UNITCHECK' => 'PPI::Statement::Scheduled',
  		'INIT'      => 'PPI::Statement::Scheduled',
  		'END'       => 'PPI::Statement::Scheduled',
  
  		# Special subroutines for which 'sub' is optional
  		'AUTOLOAD'  => 'PPI::Statement::Sub',
  		'DESTROY'   => 'PPI::Statement::Sub',
  
  		# Loading and context statement
  		'package'   => 'PPI::Statement::Package',
  		# 'use'       => 'PPI::Statement::Include',
  		'no'        => 'PPI::Statement::Include',
  		'require'   => 'PPI::Statement::Include',
  
  		# Various declarations
  		'my'        => 'PPI::Statement::Variable',
  		'local'     => 'PPI::Statement::Variable',
  		'our'       => 'PPI::Statement::Variable',
  		'state'     => 'PPI::Statement::Variable',
  		# Statements starting with 'sub' could be any one of...
  		# 'sub'     => 'PPI::Statement::Sub',
  		# 'sub'     => 'PPI::Statement::Scheduled',
  		# 'sub'     => 'PPI::Statement',
  
  		# Compound statement
  		'if'        => 'PPI::Statement::Compound',
  		'unless'    => 'PPI::Statement::Compound',
  		'for'       => 'PPI::Statement::Compound',
  		'foreach'   => 'PPI::Statement::Compound',
  		'while'     => 'PPI::Statement::Compound',
  		'until'     => 'PPI::Statement::Compound',
  
  		# Switch statement
  		'given'     => 'PPI::Statement::Given',
  		'when'      => 'PPI::Statement::When',
  		'default'   => 'PPI::Statement::When',
  
  		# Various ways of breaking out of scope
  		'redo'      => 'PPI::Statement::Break',
  		'next'      => 'PPI::Statement::Break',
  		'last'      => 'PPI::Statement::Break',
  		'return'    => 'PPI::Statement::Break',
  		'goto'      => 'PPI::Statement::Break',
  
  		# Special sections of the file
  		'__DATA__'  => 'PPI::Statement::Data',
  		'__END__'   => 'PPI::Statement::End',
  	);
  }
  
  sub _statement {
  	my ($self, $Parent, $Token) = @_;
  	# my $self   = shift;
  	# my $Parent = _INSTANCE(shift, 'PPI::Node')  or die "Bad param 1";
  	# my $Token  = _INSTANCE(shift, 'PPI::Token') or die "Bad param 2";
  
  	# Check for things like ( parent => ... )
  	if (
  		$Parent->isa('PPI::Structure::List')
  		or
  		$Parent->isa('PPI::Structure::Constructor')
  	) {
  		if ( $Token->isa('PPI::Token::Word') ) {
  			# Is the next significant token a =>
  			# Read ahead to the next significant token
  			my $Next;
  			while ( $Next = $self->_get_token ) {
  				unless ( $Next->significant ) {
  					push @{$self->{delayed}}, $Next;
  					# $self->_delay_element( $Next );
  					next;
  				}
  
  				# Got the next token
  				if (
  					$Next->isa('PPI::Token::Operator')
  					and
  					$Next->content eq '=>'
  				) {
  					# Is an ordinary expression
  					$self->_rollback( $Next );
  					return 'PPI::Statement::Expression';
  				} else {
  					last;
  				}
  			}
  
  			# Rollback and continue
  			$self->_rollback( $Next );
  		}
  	}
  
  	# Is it a token in our known classes list
  	my $class = $STATEMENT_CLASSES{$Token->content};
  	if ( $class ) {
  		# Is the next significant token a =>
  		# Read ahead to the next significant token
  		my $Next;
  		while ( $Next = $self->_get_token ) {
  			if ( !$Next->significant ) {
  				push @{$self->{delayed}}, $Next;
  				next;
  			}
  
  			last if
  				!$Next->isa( 'PPI::Token::Operator' ) or $Next->content ne '=>';
  
  			# Got the next token
  			# Is an ordinary expression
  			$self->_rollback( $Next );
  			return 'PPI::Statement';
  		}
  
  		# Rollback and continue
  		$self->_rollback( $Next );
  	}
  
  	# Handle potential barewords for subscripts
  	if ( $Parent->isa('PPI::Structure::Subscript') ) {
  		# Fast obvious case, just an expression
  		unless ( $class and $class->isa('PPI::Statement::Expression') ) {
  			return 'PPI::Statement::Expression';
  		}
  
  		# This is something like "my" or "our" etc... more subtle.
  		# Check if the next token is a closing curly brace.
  		# This means we are something like $h{my}
  		my $Next;
  		while ( $Next = $self->_get_token ) {
  			unless ( $Next->significant ) {
  				push @{$self->{delayed}}, $Next;
  				# $self->_delay_element( $Next );
  				next;
  			}
  
  			# Found the next significant token.
  			# Is it a closing curly brace?
  			if ( $Next->content eq '}' ) {
  				$self->_rollback( $Next );
  				return 'PPI::Statement::Expression';
  			} else {
  				$self->_rollback( $Next );
  				return $class;
  			}
  		}
  
  		# End of file... this means it is something like $h{our
  		# which is probably going to be $h{our} ... I think
  		$self->_rollback( $Next );
  		return 'PPI::Statement::Expression';
  	}
  
  	# If it's a token in our list, use that class
  	return $class if $class;
  
  	# Handle the more in-depth sub detection
  	if ( $Token->content eq 'sub' ) {
  		# Read ahead to the next significant token
  		my $Next;
  		while ( $Next = $self->_get_token ) {
  			unless ( $Next->significant ) {
  				push @{$self->{delayed}}, $Next;
  				# $self->_delay_element( $Next );
  				next;
  			}
  
  			# Got the next significant token
  			my $sclass = $STATEMENT_CLASSES{$Next->content};
  			if ( $sclass and $sclass eq 'PPI::Statement::Scheduled' ) {
  				$self->_rollback( $Next );
  				return 'PPI::Statement::Scheduled';
  			}
  			if ( $Next->isa('PPI::Token::Word') ) {
  				$self->_rollback( $Next );
  				return 'PPI::Statement::Sub';
  			}
  
  			### Comment out these two, as they would return PPI::Statement anyway
  			# if ( $content eq '{' ) {
  			#	Anonymous sub at start of statement
  			#	return 'PPI::Statement';
  			# }
  			#
  			# if ( $Next->isa('PPI::Token::Prototype') ) {
  			#	Anonymous sub at start of statement
  			#	return 'PPI::Statement';
  			# }
  
  			# PPI::Statement is the safest fall-through
  			$self->_rollback( $Next );
  			return 'PPI::Statement';
  		}
  
  		# End of file... PPI::Statement::Sub is the most likely
  		$self->_rollback( $Next );
  		return 'PPI::Statement::Sub';
  	}
  
  	if ( $Token->content eq 'use' ) {
  		# Add a special case for "use v6" lines.
  		my $Next;
  		while ( $Next = $self->_get_token ) {
  			unless ( $Next->significant ) {
  				push @{$self->{delayed}}, $Next;
  				# $self->_delay_element( $Next );
  				next;
  			}
  
  			# Found the next significant token.
  			if (
  				$Next->isa('PPI::Token::Operator')
  				and
  				$Next->content eq '=>'
  			) {
  				# Is an ordinary expression
  				$self->_rollback( $Next );
  				return 'PPI::Statement';
  			# Is it a v6 use?
  			} elsif ( $Next->content eq 'v6' ) {
  				$self->_rollback( $Next );
  				return 'PPI::Statement::Include::Perl6';
  			} else {
  				$self->_rollback( $Next );
  				return 'PPI::Statement::Include';
  			}
  		}
  
  		# End of file... this means it is an incomplete use
  		# line, just treat it as a normal include.
  		$self->_rollback( $Next );
  		return 'PPI::Statement::Include';
  	}
  
  	# If our parent is a Condition, we are an Expression
  	if ( $Parent->isa('PPI::Structure::Condition') ) {
  		return 'PPI::Statement::Expression';
  	}
  
  	# If our parent is a List, we are also an expression
  	if ( $Parent->isa('PPI::Structure::List') ) {
  		return 'PPI::Statement::Expression';
  	}
  
  	# Switch statements use expressions, as well.
  	if (
  		$Parent->isa('PPI::Structure::Given')
  		or
  		$Parent->isa('PPI::Structure::When')
  	) {
  		return 'PPI::Statement::Expression';
  	}
  
  	if ( _INSTANCE($Token, 'PPI::Token::Label') ) {
  		return 'PPI::Statement::Compound';
  	}
  
  	# Beyond that, I have no idea for the moment.
  	# Just keep adding more conditions above this.
  	return 'PPI::Statement';
  }
  
  sub _lex_statement {
  	my ($self, $Statement) = @_;
  	# my $self      = shift;
  	# my $Statement = _INSTANCE(shift, 'PPI::Statement') or die "Bad param 1";
  
  	# Handle some special statements
  	if ( $Statement->isa('PPI::Statement::End') ) {
  		return $self->_lex_end( $Statement );
  	}
  
  	# Begin processing tokens
  	my $Token;
  	while ( ref( $Token = $self->_get_token ) ) {
  		# Delay whitespace and comment tokens
  		unless ( $Token->significant ) {
  			push @{$self->{delayed}}, $Token;
  			# $self->_delay_element( $Token );
  			next;
  		}
  
  		# Structual closes, and __DATA__ and __END__ tags implicitly
  		# end every type of statement
  		if (
  			$Token->__LEXER__closes
  			or
  			$Token->isa('PPI::Token::Separator')
  		) {
  			# Rollback and end the statement
  			return $self->_rollback( $Token );
  		}
  
  		# Normal statements never implicitly end
  		unless ( $Statement->__LEXER__normal ) {
  			# Have we hit an implicit end to the statement
  			unless ( $self->_continues( $Statement, $Token ) ) {
  				# Rollback and finish the statement
  				return $self->_rollback( $Token );
  			}
  		}
  
  		# Any normal character just gets added
  		unless ( $Token->isa('PPI::Token::Structure') ) {
  			$self->_add_element( $Statement, $Token );
  			next;
  		}
  
  		# Handle normal statement terminators
  		if ( $Token->content eq ';' ) {
  			$self->_add_element( $Statement, $Token );
  			return 1;
  		}
  
  		# Which leaves us with a new structure
  
  		# Determine the class for the structure and create it
  		my $method    = $RESOLVE{$Token->content};
  		my $Structure = $self->$method($Statement)->new($Token);
  
  		# Move the lexing down into the Structure
  		$self->_add_delayed( $Statement );
  		$self->_add_element( $Statement, $Structure );
  		$self->_lex_structure( $Structure );
  	}
  
  	# Was it an error in the tokenizer?
  	unless ( defined $Token ) {
  		PPI::Exception->throw;
  	}
  
  	# No, it's just the end of the file...
  	# Roll back any insignificant tokens, they'll get added at the Document level
  	$self->_rollback;
  }
  
  sub _lex_end {
  	my ($self, $Statement) = @_;
  	# my $self      = shift;
  	# my $Statement = _INSTANCE(shift, 'PPI::Statement::End') or die "Bad param 1";
  
  	# End of the file, EVERYTHING is ours
  	my $Token;
  	while ( $Token = $self->_get_token ) {
  		# Inlined $Statement->__add_element($Token);
  		Scalar::Util::weaken(
  			$_PARENT{Scalar::Util::refaddr $Token} = $Statement
  		);
  		push @{$Statement->{children}}, $Token;
  	}
  
  	# Was it an error in the tokenizer?
  	unless ( defined $Token ) {
  		PPI::Exception->throw;
  	}
  
  	# No, it's just the end of the file...
  	# Roll back any insignificant tokens, they get added at the Document level
  	$self->_rollback;
  }
  
  # For many statements, it can be difficult to determine the end-point.
  # This method takes a statement and the next significant token, and attempts
  # to determine if the there is a statement boundary between the two, or if
  # the statement can continue with the token.
  sub _continues {
  	my ($self, $Statement, $Token) = @_;
  	# my $self      = shift;
  	# my $Statement = _INSTANCE(shift, 'PPI::Statement') or die "Bad param 1";
  	# my $Token     = _INSTANCE(shift, 'PPI::Token')     or die "Bad param 2";
  
  	# Handle the simple block case
  	# { print 1; }
  	if (
  		$Statement->schildren == 1
  		and
  		$Statement->schild(0)->isa('PPI::Structure::Block')
  	) {
  		return '';
  	}
  
  	# Alrighty then, there are six implied-end statement types:
  	# ::Scheduled blocks, ::Sub declarations, ::Compound, ::Given, ::When,
  	# and ::Package statements.
  	return 1
  		if ref $Statement !~ /\b(?:Scheduled|Sub|Compound|Given|When|Package)$/;
  
  	# Of these six, ::Scheduled, ::Sub, ::Given, and ::When follow the same
  	# simple rule and can be handled first.  The block form of ::Package
  	# follows the rule, too.  (The non-block form of ::Package
  	# requires a statement terminator, and thus doesn't need to have
  	# an implied end detected.)
  	my @part      = $Statement->schildren;
  	my $LastChild = $part[-1];
  	# If the last significant element of the statement is a block,
  	# then an implied-end statement is done, no questions asked.
  	return !$LastChild->isa('PPI::Structure::Block')
  		if !$Statement->isa('PPI::Statement::Compound');
  
  	# Now we get to compound statements, which kind of suck (to lex).
  	# However, of them all, the 'if' type, which includes unless, are
  	# relatively easy to handle compared to the others.
  	my $type = $Statement->type;
  	if ( $type eq 'if' ) {
  		# This should be one of the following
  		# if (EXPR) BLOCK
  		# if (EXPR) BLOCK else BLOCK
  		# if (EXPR) BLOCK elsif (EXPR) BLOCK ... else BLOCK
  
  		# We only implicitly end on a block
  		unless ( $LastChild->isa('PPI::Structure::Block') ) {
  			# if (EXPR) ...
  			# if (EXPR) BLOCK else ...
  			# if (EXPR) BLOCK elsif (EXPR) BLOCK ...
  			return 1;
  		}
  
  		# If the token before the block is an 'else',
  		# it's over, no matter what.
  		my $NextLast = $Statement->schild(-2);
  		if (
  			$NextLast
  			and
  			$NextLast->isa('PPI::Token')
  			and
  			$NextLast->isa('PPI::Token::Word')
  			and
  			$NextLast->content eq 'else'
  		) {
  			return '';
  		}
  
  		# Otherwise, we continue for 'elsif' or 'else' only.
  		if (
  			$Token->isa('PPI::Token::Word')
  			and (
  				$Token->content eq 'else'
  				or
  				$Token->content eq 'elsif'
  			)
  		) {
  			return 1;
  		}
  
  		return '';
  	}
  
  	if ( $type eq 'label' ) {
  		# We only have the label so far, could be any of
  		# LABEL while (EXPR) BLOCK
  		# LABEL while (EXPR) BLOCK continue BLOCK
  		# LABEL for (EXPR; EXPR; EXPR) BLOCK
  		# LABEL foreach VAR (LIST) BLOCK
  		# LABEL foreach VAR (LIST) BLOCK continue BLOCK
  		# LABEL BLOCK continue BLOCK
  
  		# Handle cases with a word after the label
  		if (
  			$Token->isa('PPI::Token::Word')
  			and
  			$Token->content =~ /^(?:while|until|for|foreach)$/
  		) {
  			return 1;
  		}
  
  		# Handle labelled blocks
  		if ( $Token->isa('PPI::Token::Structure') && $Token->content eq '{' ) {
  			return 1;
  		}
  
  		return '';
  	}
  
  	# Handle the common "after round braces" case
  	if ( $LastChild->isa('PPI::Structure') and $LastChild->braces eq '()' ) {
  		# LABEL while (EXPR) ...
  		# LABEL while (EXPR) ...
  		# LABEL for (EXPR; EXPR; EXPR) ...
  		# LABEL for VAR (LIST) ...
  		# LABEL foreach VAR (LIST) ...
  		# Only a block will do
  		return $Token->isa('PPI::Token::Structure') && $Token->content eq '{';
  	}
  
  	if ( $type eq 'for' ) {
  		# LABEL for (EXPR; EXPR; EXPR) BLOCK
  		if (
  			$LastChild->isa('PPI::Token::Word')
  			and
  			$LastChild->content =~ /^for(?:each)?\z/
  		) {
  			# LABEL for ...
  			if (
  				(
  					$Token->isa('PPI::Token::Structure')
  					and
  					$Token->content eq '('
  				)
  				or
  				$Token->isa('PPI::Token::QuoteLike::Words')
  			) {
  				return 1;
  			}
  
  			if ( $LastChild->isa('PPI::Token::QuoteLike::Words') ) {
  				# LABEL for VAR QW{} ...
  				# LABEL foreach VAR QW{} ...
  				# Only a block will do
  				return $Token->isa('PPI::Token::Structure') && $Token->content eq '{';
  			}
  
  			# In this case, we can also behave like a foreach
  			$type = 'foreach';
  
  		} elsif ( $LastChild->isa('PPI::Structure::Block') ) {
  			# LABEL for (EXPR; EXPR; EXPR) BLOCK
  			# That's it, nothing can continue
  			return '';
  
  		} elsif ( $LastChild->isa('PPI::Token::QuoteLike::Words') ) {
  			# LABEL for VAR QW{} ...
  			# LABEL foreach VAR QW{} ...
  			# Only a block will do
  			return $Token->isa('PPI::Token::Structure') && $Token->content eq '{';
  		}
  	}
  
  	# Handle the common continue case
  	if ( $LastChild->isa('PPI::Token::Word') and $LastChild->content eq 'continue' ) {
  		# LABEL while (EXPR) BLOCK continue ...
  		# LABEL foreach VAR (LIST) BLOCK continue ...
  		# LABEL BLOCK continue ...
  		# Only a block will do
  		return $Token->isa('PPI::Token::Structure') && $Token->content eq '{';
  	}
  
  	# Handle the common continuable block case
  	if ( $LastChild->isa('PPI::Structure::Block') ) {
  		# LABEL while (EXPR) BLOCK
  		# LABEL while (EXPR) BLOCK ...
  		# LABEL for (EXPR; EXPR; EXPR) BLOCK
  		# LABEL foreach VAR (LIST) BLOCK
  		# LABEL foreach VAR (LIST) BLOCK ...
  		# LABEL BLOCK ...
  		# Is this the block for a continue?
  		if ( _INSTANCE($part[-2], 'PPI::Token::Word') and $part[-2]->content eq 'continue' ) {
  			# LABEL while (EXPR) BLOCK continue BLOCK
  			# LABEL foreach VAR (LIST) BLOCK continue BLOCK
  			# LABEL BLOCK continue BLOCK
  			# That's it, nothing can continue this
  			return '';
  		}
  
  		# Only a continue will do
  		return $Token->isa('PPI::Token::Word') && $Token->content eq 'continue';
  	}
  
  	if ( $type eq 'block' ) {
  		# LABEL BLOCK continue BLOCK
  		# Every possible case is covered in the common cases above
  	}
  
  	if ( $type eq 'while' ) {
  		# LABEL while (EXPR) BLOCK
  		# LABEL while (EXPR) BLOCK continue BLOCK
  		# LABEL until (EXPR) BLOCK
  		# LABEL until (EXPR) BLOCK continue BLOCK
  		# The only case not covered is the while ...
  		if (
  			$LastChild->isa('PPI::Token::Word')
  			and (
  				$LastChild->content eq 'while'
  				or
  				$LastChild->content eq 'until'
  			)
  		) {
  			# LABEL while ...
  			# LABEL until ...
  			# Only a condition structure will do
  			return $Token->isa('PPI::Token::Structure') && $Token->content eq '(';
  		}
  	}
  
  	if ( $type eq 'foreach' ) {
  		# LABEL foreach VAR (LIST) BLOCK
  		# LABEL foreach VAR (LIST) BLOCK continue BLOCK
  		# The only two cases that have not been covered already are
  		# 'foreach ...' and 'foreach VAR ...'
  
  		if ( $LastChild->isa('PPI::Token::Symbol') ) {
  			# LABEL foreach my $scalar ...
  			# Open round brace, or a quotewords
  			return 1 if $Token->isa('PPI::Token::Structure') && $Token->content eq '(';
  			return 1 if $Token->isa('PPI::Token::QuoteLike::Words');
  			return '';
  		}
  
  		if ( $LastChild->content eq 'foreach' or $LastChild->content eq 'for' ) {
  			# There are three possibilities here
  			if (
  				$Token->isa('PPI::Token::Word')
  				and (
  					($STATEMENT_CLASSES{ $Token->content } || '')
  					eq
  					'PPI::Statement::Variable'
  				)
  			) {
  				# VAR == 'my ...'
  				return 1;
  			} elsif ( $Token->content =~ /^\$/ ) {
  				# VAR == '$scalar'
  				return 1;
  			} elsif ( $Token->isa('PPI::Token::Structure') and $Token->content eq '(' ) {
  				return 1;
  			} elsif ( $Token->isa('PPI::Token::QuoteLike::Words') ) {
  				return 1;
  			} else {
  				return '';
  			}
  		}
  
  		if (
  			($STATEMENT_CLASSES{ $LastChild->content } || '')
  			eq
  			'PPI::Statement::Variable'
  		) {
  			# LABEL foreach my ...
  			# Only a scalar will do
  			return $Token->content =~ /^\$/;
  		}
  
  		# Handle the rare for my $foo qw{bar} ... case
  		if ( $LastChild->isa('PPI::Token::QuoteLike::Words') ) {
  			# LABEL for VAR QW ...
  			# LABEL foreach VAR QW ...
  			# Only a block will do
  			return $Token->isa('PPI::Token::Structure') && $Token->content eq '{';
  		}
  	}
  
  	# Something we don't know about... what could it be
  	PPI::Exception->throw("Illegal state in '$type' compound statement");
  }
  
  
  
  
  
  #####################################################################
  # Lex Methods - Structure Object
  
  # Given a parent element, and a ( token to open a structure, determine
  # the class that the structure should be.
  sub _round {
  	my ($self, $Parent) = @_;
  	# my $self   = shift;
  	# my $Parent = _INSTANCE(shift, 'PPI::Node') or die "Bad param 1";
  
  	# Get the last significant element in the parent
  	my $Element = $Parent->schild(-1);
  	if ( _INSTANCE($Element, 'PPI::Token::Word') ) {
  		# Can it be determined because it is a keyword?
  		my $rclass = $ROUND{$Element->content};
  		return $rclass if $rclass;
  	}
  
  	# If we are part of a for or foreach statement, we are a ForLoop
  	if ( $Parent->isa('PPI::Statement::Compound') ) {
  		if ( $Parent->type =~ /^for(?:each)?$/ ) {
  			return 'PPI::Structure::For';
  		}
  	} elsif ( $Parent->isa('PPI::Statement::Given') ) {
  		return 'PPI::Structure::Given';
  	} elsif ( $Parent->isa('PPI::Statement::When') ) {
  		return 'PPI::Structure::When';
  	}
  
  	# Otherwise, it must be a list
  
  	# If the previous element is -> then we mark it as a dereference
  	if ( _INSTANCE($Element, 'PPI::Token::Operator') and $Element->content eq '->' ) {
  		$Element->{_dereference} = 1;
  	}
  
  	'PPI::Structure::List'
  }
  
  # Given a parent element, and a [ token to open a structure, determine
  # the class that the structure should be.
  sub _square {
  	my ($self, $Parent) = @_;
  	# my $self   = shift;
  	# my $Parent = _INSTANCE(shift, 'PPI::Node') or die "Bad param 1";
  
  	# Get the last significant element in the parent
  	my $Element = $Parent->schild(-1);
  
  	# Is this a subscript, like $foo[1] or $foo{expr}
  	
  	if ( $Element ) {
  		if ( $Element->isa('PPI::Token::Operator') and $Element->content eq '->' ) {
  			# $foo->[]
  			$Element->{_dereference} = 1;
  			return 'PPI::Structure::Subscript';
  		}
  		if ( $Element->isa('PPI::Structure::Subscript') ) {
  			# $foo{}[]
  			return 'PPI::Structure::Subscript';
  		}
  		if ( $Element->isa('PPI::Token::Symbol') and $Element->content =~ /^(?:\$|\@)/ ) {
  			# $foo[], @foo[]
  			return 'PPI::Structure::Subscript';
  		}
  		# FIXME - More cases to catch
  	}
  
  	# Otherwise, we assume that it's an anonymous arrayref constructor
  	'PPI::Structure::Constructor';
  }
  
  use vars qw{%CURLY_CLASSES @CURLY_LOOKAHEAD_CLASSES};
  BEGIN {
  	# Keyword -> Structure class maps
  	%CURLY_CLASSES = (
  		# Blocks
  		'sub'  => 'PPI::Structure::Block',
  		'grep' => 'PPI::Structure::Block',
  		'map'  => 'PPI::Structure::Block',
  		'sort' => 'PPI::Structure::Block',
  		'do'   => 'PPI::Structure::Block',
  		# rely on 'continue' + block being handled elsewhere
  		# rely on 'eval' + block being handled elsewhere
  
  		# Hash constructors
  		'scalar' => 'PPI::Structure::Constructor',
  		'='      => 'PPI::Structure::Constructor',
  		'||='    => 'PPI::Structure::Constructor',
  		'&&='    => 'PPI::Structure::Constructor',
  		'//='    => 'PPI::Structure::Constructor',
  		'||'     => 'PPI::Structure::Constructor',
  		'&&'     => 'PPI::Structure::Constructor',
  		'//'     => 'PPI::Structure::Constructor',
  		'?'      => 'PPI::Structure::Constructor',
  		':'      => 'PPI::Structure::Constructor',
  		','      => 'PPI::Structure::Constructor',
  		'=>'     => 'PPI::Structure::Constructor',
  		'+'      => 'PPI::Structure::Constructor', # per perlref
  		'return' => 'PPI::Structure::Constructor', # per perlref
  		'bless'  => 'PPI::Structure::Constructor', # pragmatic --
  		            # perlfunc says first arg is a reference, and
  			    # bless {; ... } fails to compile.
  	);
  
  	@CURLY_LOOKAHEAD_CLASSES = (
  	    {},	# not used
  	    {
  		';'    => 'PPI::Structure::Block', # per perlref
  		'}'    => 'PPI::Structure::Constructor',
  	    },
  	    {
  		'=>'   => 'PPI::Structure::Constructor',
  	    },
  	);
  }
  
  
  # Given a parent element, and a { token to open a structure, determine
  # the class that the structure should be.
  sub _curly {
  	my ($self, $Parent) = @_;
  	# my $self   = shift;
  	# my $Parent = _INSTANCE(shift, 'PPI::Node') or die "Bad param 1";
  
  	# Get the last significant element in the parent
  	my $Element = $Parent->schild(-1);
  	my $content = $Element ? $Element->content : '';
  
  	# Is this a subscript, like $foo[1] or $foo{expr}
  	if ( $Element ) {
  		if ( $content eq '->' and $Element->isa('PPI::Token::Operator') ) {
  			# $foo->{}
  			$Element->{_dereference} = 1;
  			return 'PPI::Structure::Subscript';
  		}
  		if ( $Element->isa('PPI::Structure::Subscript') ) {
  			# $foo[]{}
  			return 'PPI::Structure::Subscript';
  		}
  		if ( $content =~ /^(?:\$|\@)/ and $Element->isa('PPI::Token::Symbol') ) {
  			# $foo{}, @foo{}
  			return 'PPI::Structure::Subscript';
  		}
  		if ( $Element->isa('PPI::Structure::Block') ) {
  			# deference - ${$hash_ref}{foo}
  			#     or even ${burfle}{foo}
  			# hash slice - @{$hash_ref}{'foo', 'bar'}
  			if ( my $prior = $Parent->schild(-2) ) {
  				my $prior_content = $prior->content();
  				$prior->isa( 'PPI::Token::Cast' )
  					and ( $prior_content eq '@' ||
  						$prior_content eq '$' )
  					and return 'PPI::Structure::Subscript';
  			}
  		}
  
  		# Are we the last argument of sub?
  		# E.g.: 'sub foo {}', 'sub foo ($) {}'
  		return 'PPI::Structure::Block' if $Parent->isa('PPI::Statement::Sub');
  
  		# Are we the second or third argument of package?
  		# E.g.: 'package Foo {}' or 'package Foo v1.2.3 {}'
  		return 'PPI::Structure::Block'
  			if $Parent->isa('PPI::Statement::Package');
  
  		if ( $CURLY_CLASSES{$content} ) {
  			# Known type
  			return $CURLY_CLASSES{$content};
  		}
  	}
  
  	# Are we in a compound statement
  	if ( $Parent->isa('PPI::Statement::Compound') ) {
  		# We will only encounter blocks in compound statements
  		return 'PPI::Structure::Block';
  	}
  
  	# Are we the second or third argument of use
  	if ( $Parent->isa('PPI::Statement::Include') ) {
  		if ( $Parent->schildren == 2 ||
  		    $Parent->schildren == 3 &&
  			$Parent->schild(2)->isa('PPI::Token::Number')
  		) {
  			# This is something like use constant { ... };
  			return 'PPI::Structure::Constructor';
  		}
  	}
  
  	# Unless we are at the start of the statement, everything else should be a block
  	### FIXME This is possibly a bad choice, but will have to do for now.
  	return 'PPI::Structure::Block' if $Element;
  
  	# Special case: Are we the param of a core function
  	# i.e. map({ $_ => 1 } @foo)
  	if (
  		$Parent->isa('PPI::Statement')
  		and
  		_INSTANCE($Parent->parent, 'PPI::Structure::List')
  	) {
  		my $function = $Parent->parent->parent->schild(-2);
  		if ( $function and $function->content =~ /^(?:map|grep|sort)$/ ) {
  			return 'PPI::Structure::Block';
  		}
  	}
  
  	# We need to scan ahead.
  	my $Next;
  	my $position = 0;
  	my @delayed;
  	while ( $Next = $self->_get_token ) {
  		unless ( $Next->significant ) {
  			push @delayed, $Next;
  			next;
  		}
  
  		# If we are off the end of the lookahead array,
  		if ( ++$position >= @CURLY_LOOKAHEAD_CLASSES ) {
  			# default to block.
  			$self->_buffer( splice(@delayed), $Next );
  			last;
  		# If the content at this position is known
  		} elsif ( my $class = $CURLY_LOOKAHEAD_CLASSES[$position]
  			{$Next->content} ) {
  			# return the associated class.
  			$self->_buffer( splice(@delayed), $Next );
  			return $class;
  		}
  
  		# Delay and continue
  		push @delayed, $Next;
  	}
  
  	# Hit the end of the document, or bailed out, go with block
  	$self->_buffer( splice(@delayed) );
  	if ( ref $Parent eq 'PPI::Statement' ) {
  		bless $Parent, 'PPI::Statement::Compound';
  	}
  	return 'PPI::Structure::Block';
  }
  
  
  sub _lex_structure {
  	my ($self, $Structure) = @_;
  	# my $self      = shift;
  	# my $Structure = _INSTANCE(shift, 'PPI::Structure') or die "Bad param 1";
  
  	# Start the processing loop
  	my $Token;
  	while ( ref($Token = $self->_get_token) ) {
  		# Is this a direct type token
  		unless ( $Token->significant ) {
  			push @{$self->{delayed}}, $Token;
  			# $self->_delay_element( $Token );
  			next;
  		}
  
  		# Anything other than a Structure starts a Statement
  		unless ( $Token->isa('PPI::Token::Structure') ) {
  			# Because _statement may well delay and rollback itself,
  			# we need to add the delayed tokens early
  			$self->_add_delayed( $Structure );
  
  			# Determine the class for the Statement and create it
  			my $Statement = $self->_statement($Structure, $Token)->new($Token);
  
  			# Move the lexing down into the Statement
  			$self->_add_element( $Structure, $Statement );
  			$self->_lex_statement( $Statement );
  
  			next;
  		}
  
  		# Is this the opening of another structure directly inside us?
  		if ( $Token->__LEXER__opens ) {
  			# Rollback the Token, and recurse into the statement
  			$self->_rollback( $Token );
  			my $Statement = PPI::Statement->new;
  			$self->_add_element( $Structure, $Statement );
  			$self->_lex_statement( $Statement );
  			next;
  		}
  
  		# Is this the close of a structure ( which would be an error )
  		if ( $Token->__LEXER__closes ) {
  			# Is this OUR closing structure
  			if ( $Token->content eq $Structure->start->__LEXER__opposite ) {
  				# Add any delayed tokens, and the finishing token (the ugly way)
  				$self->_add_delayed( $Structure );
  				$Structure->{finish} = $Token;
  				Scalar::Util::weaken(
  					$_PARENT{Scalar::Util::refaddr $Token} = $Structure
  				);
  
  				# Confirm that ForLoop structures are actually so, and
  				# aren't really a list.
  				if ( $Structure->isa('PPI::Structure::For') ) {
  					if ( 2 > scalar grep {
  						$_->isa('PPI::Statement')
  					} $Structure->children ) {
  						bless($Structure, 'PPI::Structure::List');
  					}
  				}
  				return 1;
  			}
  
  			# Unmatched closing brace.
  			# Either they typed the wrong thing, or haven't put
  			# one at all. Either way it's an error we need to
  			# somehow handle gracefully. For now, we'll treat it
  			# as implicitly ending the structure. This causes the
  			# least damage across the various reasons why this
  			# might have happened.
  			return $self->_rollback( $Token );
  		}
  
  		# It's a semi-colon on it's own, just inside the block.
  		# This is a null statement.
  		$self->_add_element(
  			$Structure,
  			PPI::Statement::Null->new($Token),
  		);
  	}
  
  	# Is this an error
  	unless ( defined $Token ) {
  		PPI::Exception->throw;
  	}
  
  	# No, it's just the end of file.
  	# Add any insignificant trailing tokens.
  	$self->_add_delayed( $Structure );
  }
  
  
  
  
  
  #####################################################################
  # Support Methods
  
  # Get the next token for processing, handling buffering
  sub _get_token {
  	shift(@{$_[0]->{buffer}}) or $_[0]->{Tokenizer}->get_token;
  }
  
  # Old long version of the above
  # my $self = shift;
  #     # First from the buffer
  #     if ( @{$self->{buffer}} ) {
  #         return shift @{$self->{buffer}};
  #     }
  #
  #     # Then from the Tokenizer
  #     $self->{Tokenizer}->get_token;
  # }
  
  # Delay the addition of insignificant elements.
  # This ended up being inlined.
  # sub _delay_element {
  #     my $self    = shift;
  #     my $Element = _INSTANCE(shift, 'PPI::Element') or die "Bad param 1";
  #     push @{ $_[0]->{delayed} }, $_[1];
  # }
  
  # Add an Element to a Node, including any delayed Elements
  sub _add_element {
  	my ($self, $Parent, $Element) = @_;
  	# my $self    = shift;
  	# my $Parent  = _INSTANCE(shift, 'PPI::Node')    or die "Bad param 1";
  	# my $Element = _INSTANCE(shift, 'PPI::Element') or die "Bad param 2";
  
  	# Handle a special case, where a statement is not fully resolved
  	if ( ref $Parent eq 'PPI::Statement'
  		   and my $first = $Parent->schild(0) ) {
  		if ( $first->isa('PPI::Token::Label')
  			   and !(my $second = $Parent->schild(1)) ) {
  			my $new_class = $STATEMENT_CLASSES{$second->content};
  			# It's a labelled statement
  			bless $Parent, $new_class if $new_class;
  		}
  	}
  
  	# Add first the delayed, from the front, then the passed element
  	foreach my $el ( @{$self->{delayed}} ) {
  		Scalar::Util::weaken(
  			$_PARENT{Scalar::Util::refaddr $el} = $Parent
  		);
  		# Inlined $Parent->__add_element($el);
  	}
  	Scalar::Util::weaken(
  		$_PARENT{Scalar::Util::refaddr $Element} = $Parent
  	);
  	push @{$Parent->{children}}, @{$self->{delayed}}, $Element;
  
  	# Clear the delayed elements
  	$self->{delayed} = [];
  }
  
  # Specifically just add any delayed tokens, if any.
  sub _add_delayed {
  	my ($self, $Parent) = @_;
  	# my $self   = shift;
  	# my $Parent = _INSTANCE(shift, 'PPI::Node') or die "Bad param 1";
  
  	# Add any delayed
  	foreach my $el ( @{$self->{delayed}} ) {
  		Scalar::Util::weaken(
  			$_PARENT{Scalar::Util::refaddr $el} = $Parent
  		);
  		# Inlined $Parent->__add_element($el);
  	}
  	push @{$Parent->{children}}, @{$self->{delayed}};
  
  	# Clear the delayed elements
  	$self->{delayed} = [];
  }
  
  # Rollback the delayed tokens, plus any passed. Once all the tokens
  # have been moved back on to the buffer, the order should be.
  # <--- @{$self->{delayed}}, @_, @{$self->{buffer}} <----
  sub _rollback {
  	my $self = shift;
  
  	# First, put any passed objects back
  	if ( @_ ) {
  		unshift @{$self->{buffer}}, splice @_;
  	}
  
  	# Then, put back anything delayed
  	if ( @{$self->{delayed}} ) {
  		unshift @{$self->{buffer}}, splice @{$self->{delayed}};
  	}
  
  	1;
  }
  
  # Partial rollback, just return a single list to the buffer
  sub _buffer {
  	my $self = shift;
  
  	# Put any passed objects back
  	if ( @_ ) {
  		unshift @{$self->{buffer}}, splice @_;
  	}
  
  	1;
  }
  
  
  
  
  
  #####################################################################
  # Error Handling
  
  # Set the error message
  sub _error {
  	$errstr = $_[1];
  	undef;
  }
  
  # Clear the error message.
  # Returns the object as a convenience.
  sub _clear {
  	$errstr = '';
  	$_[0];
  }
  
  =pod
  
  =head2 errstr
  
  For any error that occurs, you can use the C<errstr>, as either
  a static or object method, to access the error message.
  
  If no error occurs for any particular action, C<errstr> will return false.
  
  =cut
  
  sub errstr {
  	$errstr;
  }
  
  
  
  
  
  #####################################################################
  # PDOM Extensions
  #
  # This is something of a future expansion... ignore it for now :)
  #
  # use PPI::Statement::Sub ();
  #
  # sub PPI::Statement::Sub::__LEXER__normal { '' }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Add optional support for some of the more common source filters
  
  - Some additional checks for blessing things into various Statement
  and Structure subclasses.
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_LEXER

$fatpacked{"PPI/Node.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_NODE';
  package PPI::Node;
  
  =pod
  
  =head1 NAME
  
  PPI::Node - Abstract PPI Node class, an Element that can contain other Elements
  
  =head1 INHERITANCE
  
    PPI::Node
    isa PPI::Element
  
  =head1 SYNOPSIS
  
    # Create a typical node (a Document in this case)
    my $Node = PPI::Document->new;
    
    # Add an element to the node( in this case, a token )
    my $Token = PPI::Token::Word->new('my');
    $Node->add_element( $Token );
    
    # Get the elements for the Node
    my @elements = $Node->children;
    
    # Find all the barewords within a Node
    my $barewords = $Node->find( 'PPI::Token::Word' );
    
    # Find by more complex criteria
    my $my_tokens = $Node->find( sub { $_[1]->content eq 'my' } );
    
    # Remove all the whitespace
    $Node->prune( 'PPI::Token::Whitespace' );
    
    # Remove by more complex criteria
    $Node->prune( sub { $_[1]->content eq 'my' } );
  
  =head1 DESCRIPTION
  
  The C<PPI::Node> class provides an abstract base class for the Element
  classes that are able to contain other elements L<PPI::Document>,
  L<PPI::Statement>, and L<PPI::Structure>.
  
  As well as those listed below, all of the methods that apply to
  L<PPI::Element> objects also apply to C<PPI::Node> objects.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Carp            ();
  use Scalar::Util    qw{refaddr};
  use List::MoreUtils ();
  use Params::Util    qw{_INSTANCE _CLASS _CODELIKE _NUMBER};
  use PPI::Element    ();
  
  use vars qw{$VERSION @ISA *_PARENT};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Element';
  	*_PARENT = *PPI::Element::_PARENT;
  }
  
  
  
  
  
  #####################################################################
  # The basic constructor
  
  sub new {
  	my $class = ref $_[0] || $_[0];
  	bless { children => [] }, $class;
  }
  
  
  
  
  
  #####################################################################
  # PDOM Methods
  
  =pod
  
  =head2 scope
  
  The C<scope> method returns true if the node represents a lexical scope
  boundary, or false if it does not.
  
  =cut
  
  ### XS -> PPI/XS.xs:_PPI_Node__scope 0.903+
  sub scope() { '' }
  
  =pod
  
  =head2 add_element $Element
  
  The C<add_element> method adds a L<PPI::Element> object to the end of a
  C<PPI::Node>. Because Elements maintain links to their parent, an
  Element can only be added to a single Node.
  
  Returns true if the L<PPI::Element> was added. Returns C<undef> if the
  Element was already within another Node, or the method is not passed 
  a L<PPI::Element> object.
  
  =cut
  
  sub add_element {
  	my $self = shift;
  
  	# Check the element
  	my $Element = _INSTANCE(shift, 'PPI::Element') or return undef;
  	$_PARENT{refaddr $Element} and return undef;
  
  	# Add the argument to the elements
  	push @{$self->{children}}, $Element;
  	Scalar::Util::weaken(
  		$_PARENT{refaddr $Element} = $self
  	);
  
  	1;
  }
  
  # In a typical run profile, add_element is the number 1 resource drain.
  # This is a highly optimised unsafe version, for internal use only.
  sub __add_element {
  	Scalar::Util::weaken(
  		$_PARENT{refaddr $_[1]} = $_[0]
  	);
  	push @{$_[0]->{children}}, $_[1];
  }
  
  =pod
  
  =head2 elements
  
  The C<elements> method accesses all child elements B<structurally> within
  the C<PPI::Node> object. Note that in the base of the L<PPI::Structure>
  classes, this C<DOES> include the brace tokens at either end of the
  structure.
  
  Returns a list of zero or more L<PPI::Element> objects.
  
  Alternatively, if called in the scalar context, the C<elements> method
  returns a count of the number of elements.
  
  =cut
  
  sub elements {
  	if ( wantarray ) {
  		return @{$_[0]->{children}};
  	} else {
  		return scalar @{$_[0]->{children}};
  	}
  }
  
  =pod
  
  =head2 first_element
  
  The C<first_element> method accesses the first element structurally within
  the C<PPI::Node> object. As for the C<elements> method, this does include
  the brace tokens for L<PPI::Structure> objects.
  
  Returns a L<PPI::Element> object, or C<undef> if for some reason the
  C<PPI::Node> object does not contain any elements.
  
  =cut
  
  # Normally the first element is also the first child
  sub first_element {
  	$_[0]->{children}->[0];
  }
  
  =pod
  
  =head2 last_element
  
  The C<last_element> method accesses the last element structurally within
  the C<PPI::Node> object. As for the C<elements> method, this does include
  the brace tokens for L<PPI::Structure> objects.
  
  Returns a L<PPI::Element> object, or C<undef> if for some reason the
  C<PPI::Node> object does not contain any elements.
  
  =cut
  
  # Normally the last element is also the last child
  sub last_element {
  	$_[0]->{children}->[-1];
  }
  
  =pod
  
  =head2 children
  
  The C<children> method accesses all child elements lexically within the
  C<PPI::Node> object. Note that in the case of the L<PPI::Structure>
  classes, this does B<NOT> include the brace tokens at either end of the
  structure.
  
  Returns a list of zero of more L<PPI::Element> objects.
  
  Alternatively, if called in the scalar context, the C<children> method
  returns a count of the number of lexical children.
  
  =cut
  
  # In the default case, this is the same as for the elements method
  sub children {
  	wantarray ? @{$_[0]->{children}} : scalar @{$_[0]->{children}};
  }
  
  =pod
  
  =head2 schildren
  
  The C<schildren> method is really just a convenience, the significant-only
  variation of the normal C<children> method.
  
  In list context, returns a list of significant children. In scalar context,
  returns the number of significant children.
  
  =cut
  
  sub schildren {
  	return grep { $_->significant } @{$_[0]->{children}} if wantarray;
  	my $count = 0;
  	foreach ( @{$_[0]->{children}} ) {
  		$count++ if $_->significant;
  	}
  	return $count;
  }
  
  =pod
  
  =head2 child $index
  
  The C<child> method accesses a child L<PPI::Element> object by its
  position within the Node.
  
  Returns a L<PPI::Element> object, or C<undef> if there is no child
  element at that node.
  
  =cut
  
  sub child {
  	my ( $self, $index ) = @_;
  	PPI::Exception->throw( "method child() needs an index" )
  	  if not defined _NUMBER $index;
  	$self->{children}->[$index];
  }
  
  =pod
  
  =head2 schild $index
  
  The lexical structure of the Perl language ignores 'insignificant' items,
  such as whitespace and comments, while L<PPI> treats these items as valid
  tokens so that it can reassemble the file at any time. Because of this,
  in many situations there is a need to find an Element within a Node by
  index, only counting lexically significant Elements.
  
  The C<schild> method returns a child Element by index, ignoring
  insignificant Elements. The index of a child Element is specified in the
  same way as for a normal array, with the first Element at index 0, and
  negative indexes used to identify a "from the end" position.
  
  =cut
  
  sub schild {
  	my $self = shift;
  	my $idx  = 0 + shift;
  	my $el   = $self->{children};
  	if ( $idx < 0 ) {
  		my $cursor = 0;
  		while ( exists $el->[--$cursor] ) {
  			return $el->[$cursor] if $el->[$cursor]->significant and ++$idx >= 0;
  		}
  	} else {
  		my $cursor = -1;
  		while ( exists $el->[++$cursor] ) {
  			return $el->[$cursor] if $el->[$cursor]->significant and --$idx < 0;
  		}
  	}
  	undef;
  }
  
  =pod
  
  =head2 contains $Element
  
  The C<contains> method is used to determine if another L<PPI::Element>
  object is logically "within" a C<PPI::Node>. For the special case of the
  brace tokens at either side of a L<PPI::Structure> object, they are
  generally considered "within" a L<PPI::Structure> object, even if they are
  not actually in the elements for the L<PPI::Structure>.
  
  Returns true if the L<PPI::Element> is within us, false if not, or C<undef>
  on error.
  
  =cut
  
  sub contains {
  	my $self    = shift;
  	my $Element = _INSTANCE(shift, 'PPI::Element') or return undef;
  
  	# Iterate up the Element's parent chain until we either run out
  	# of parents, or get to ourself.
  	while ( $Element = $Element->parent ) {
  		return 1 if refaddr($self) == refaddr($Element);
  	}
  
  	'';
  }
  
  =pod
  
  =head2 find $class | \&wanted
  
  The C<find> method is used to search within a code tree for
  L<PPI::Element> objects that meet a particular condition.
  
  To specify the condition, the method can be provided with either a simple
  class name (full or shortened), or a C<CODE>/function reference.
  
    # Find all single quotes in a Document (which is a Node)
    $Document->find('PPI::Quote::Single');
    
    # The same thing with a shortened class name
    $Document->find('Quote::Single');
    
    # Anything more elaborate, we go with the sub
    $Document->find( sub {
    	# At the top level of the file...
    	$_[1]->parent == $_[0]
    	and (
    		# ...find all comments and POD
    		$_[1]->isa('PPI::Token::Pod')
    		or
    		$_[1]->isa('PPI::Token::Comment')
    	)
    } );
  
  The function will be passed two arguments, the top-level C<PPI::Node>
  you are searching in and the current L<PPI::Element> that the condition
  is testing.
  
  The anonymous function should return one of three values. Returning true
  indicates a condition match, defined-false (C<0> or C<''>) indicates
  no-match, and C<undef> indicates no-match and no-descend.
  
  In the last case, the tree walker will skip over anything below the
  C<undef>-returning element and move on to the next element at the same
  level.
  
  To halt the entire search and return C<undef> immediately, a condition
  function should throw an exception (i.e. C<die>).
  
  Note that this same wanted logic is used for all methods documented to
  have a C<\&wanted> parameter, as this one does.
  
  The C<find> method returns a reference to an array of L<PPI::Element>
  objects that match the condition, false (but defined) if no Elements match
  the condition, or C<undef> if you provide a bad condition, or an error
  occurs during the search process.
  
  In the case of a bad condition, a warning will be emitted as well.
  
  =cut
  
  sub find {
  	my $self   = shift;
  	my $wanted = $self->_wanted(shift) or return undef;
  
  	# Use a queue based search, rather than a recursive one
  	my @found;
  	my @queue = @{$self->{children}};
  	my $ok = eval {
  		while ( @queue ) {
  			my $Element = shift @queue;
  			my $rv      = &$wanted( $self, $Element );
  			push @found, $Element if $rv;
  
  			# Support "don't descend on undef return"
  			next unless defined $rv;
  
  			# Skip if the Element doesn't have any children
  			next unless $Element->isa('PPI::Node');
  
  			# Depth-first keeps the queue size down and provides a
  			# better logical order.
  			if ( $Element->isa('PPI::Structure') ) {
  				unshift @queue, $Element->finish if $Element->finish;
  				unshift @queue, @{$Element->{children}};
  				unshift @queue, $Element->start if $Element->start;
  			} else {
  				unshift @queue, @{$Element->{children}};
  			}
  		}
  		1;
  	};
  	if ( !$ok ) {
  		# Caught exception thrown from the wanted function
  		return undef;
  	}
  
  	@found ? \@found : '';
  }
  
  =pod
  
  =head2 find_first $class | \&wanted
  
  If the normal C<find> method is like a grep, then C<find_first> is
  equivalent to the L<List::Util> C<first> function.
  
  Given an element class or a wanted function, it will search depth-first
  through a tree until it finds something that matches the condition,
  returning the first Element that it encounters.
  
  See the C<find> method for details on the format of the search condition.
  
  Returns the first L<PPI::Element> object that matches the condition, false
  if nothing matches the condition, or C<undef> if given an invalid condition,
  or an error occurs.
  
  =cut
  
  sub find_first {
  	my $self   = shift;
  	my $wanted = $self->_wanted(shift) or return undef;
  
  	# Use the same queue-based search as for ->find
  	my @queue = @{$self->{children}};
  	my $rv;
  	my $ok = eval {
  		# The defined() here prevents a ton of calls to PPI::Util::TRUE
  		while ( @queue ) {
  			my $Element = shift @queue;
  			my $element_rv = $wanted->( $self, $Element );
  			if ( $element_rv ) {
  				$rv = $Element;
  				last;
  			}
  
  			# Support "don't descend on undef return"
  			next if !defined $element_rv;
  
  			# Skip if the Element doesn't have any children
  			next if !$Element->isa('PPI::Node');
  
  			# Depth-first keeps the queue size down and provides a
  			# better logical order.
  			if ( $Element->isa('PPI::Structure') ) {
  				unshift @queue, $Element->finish if defined($Element->finish);
  				unshift @queue, @{$Element->{children}};
  				unshift @queue, $Element->start  if defined($Element->start);
  			} else {
  				unshift @queue, @{$Element->{children}};
  			}
  		}
  		1;
  	};
  	if ( !$ok ) {
  		# Caught exception thrown from the wanted function
  		return undef;
  	}
  
  	$rv or '';
  }
  
  =pod
  
  =head2 find_any $class | \&wanted
  
  The C<find_any> method is a short-circuiting true/false method that behaves
  like the normal C<find> method, but returns true as soon as it finds any
  Elements that match the search condition.
  
  See the C<find> method for details on the format of the search condition.
  
  Returns true if any Elements that match the condition can be found, false if
  not, or C<undef> if given an invalid condition, or an error occurs.
  
  =cut
  
  sub find_any {
  	my $self = shift;
  	my $rv   = $self->find_first(@_);
  	$rv ? 1 : $rv; # false or undef
  }
  
  =pod
  
  =head2 remove_child $Element
  
  If passed a L<PPI::Element> object that is a direct child of the Node,
  the C<remove_element> method will remove the C<Element> intact, along
  with any of its children. As such, this method acts essentially as a
  'cut' function.
  
  If successful, returns the removed element.  Otherwise, returns C<undef>.
  
  =cut
  
  sub remove_child {
  	my $self  = shift;
  	my $child = _INSTANCE(shift, 'PPI::Element') or return undef;
  
  	# Find the position of the child
  	my $key = refaddr $child;
  	my $p   = List::MoreUtils::firstidx {
  		refaddr $_ == $key
  	} @{$self->{children}};
  	return undef if $p == -1;
  
  	# Splice it out, and remove the child's parent entry
  	splice( @{$self->{children}}, $p, 1 );
  	delete $_PARENT{refaddr $child};
  
  	$child;
  }
  
  =pod
  
  =head2 prune $class | \&wanted
  
  The C<prune> method is used to strip L<PPI::Element> objects out of a code
  tree. The argument is the same as for the C<find> method, either a class
  name, or an anonymous subroutine which returns true/false. Any Element
  that matches the class|wanted will be deleted from the code tree, along
  with any of its children.
  
  The C<prune> method returns the number of C<Element> objects that matched
  and were removed, B<non-recursively>. This might also be zero, so avoid a
  simple true/false test on the return false of the C<prune> method. It
  returns C<undef> on error, which you probably B<should> test for.
  
  =cut
  
  sub prune {
  	my $self   = shift;
  	my $wanted = $self->_wanted(shift) or return undef;
  
  	# Use a depth-first queue search
  	my $pruned = 0;
  	my @queue  = $self->children;
  	my $ok = eval {
  		while ( my $element = shift @queue ) {
  			my $rv = &$wanted( $self, $element );
  			if ( $rv ) {
  				# Delete the child
  				$element->delete or return undef;
  				$pruned++;
  				next;
  			}
  
  			# Support the undef == "don't descend"
  			next unless defined $rv;
  
  			if ( _INSTANCE($element, 'PPI::Node') ) {
  				# Depth-first keeps the queue size down
  				unshift @queue, $element->children;
  			}
  		}
  		1;
  	};
  	if ( !$ok ) {
  		# Caught exception thrown from the wanted function
  		return undef;		
  	}
  
  	$pruned;
  }
  
  # This method is likely to be very heavily used, so take
  # it slowly and carefully.
  ### NOTE: Renaming this function or changing either to self will probably
  ###       break File::Find::Rule::PPI
  sub _wanted {
  	my $either = shift;
  	my $it     = defined($_[0]) ? shift : do {
  		Carp::carp('Undefined value passed as search condition') if $^W;
  		return undef;
  	};
  
  	# Has the caller provided a wanted function directly
  	return $it if _CODELIKE($it);
  	if ( ref $it ) {
  		# No other ref types are supported
  		Carp::carp('Illegal non-CODE reference passed as search condition') if $^W;
  		return undef;
  	}
  
  	# The first argument should be an Element class, possibly in shorthand
  	$it = "PPI::$it" unless substr($it, 0, 5) eq 'PPI::';
  	unless ( _CLASS($it) and $it->isa('PPI::Element') ) {
  		# We got something, but it isn't an element
  		Carp::carp("Cannot create search condition for '$it': Not a PPI::Element") if $^W;
  		return undef;
  	}
  
  	# Create the class part of the wanted function
  	my $wanted_class = "\n\treturn '' unless \$_[1]->isa('$it');";
  
  	# Have we been given a second argument to check the content
  	my $wanted_content = '';
  	if ( defined $_[0] ) {
  		my $content = shift;
  		if ( ref $content eq 'Regexp' ) {
  			$content = "$content";
  		} elsif ( ref $content ) {
  			# No other ref types are supported
  			Carp::carp("Cannot create search condition for '$it': Not a PPI::Element") if $^W;
  			return undef;
  		} else {
  			$content = quotemeta $content;
  		}
  
  		# Complete the content part of the wanted function
  		$wanted_content .= "\n\treturn '' unless defined \$_[1]->{content};";
  		$wanted_content .= "\n\treturn '' unless \$_[1]->{content} =~ /$content/;";
  	}
  
  	# Create the complete wanted function
  	my $code = "sub {"
  		. $wanted_class
  		. $wanted_content
  		. "\n\t1;"
  		. "\n}";
  
  	# Compile the wanted function
  	$code = eval $code;
  	(ref $code eq 'CODE') ? $code : undef;
  }
  
  
  
  
  
  ####################################################################
  # PPI::Element overloaded methods
  
  sub tokens {
  	map { $_->tokens } @{$_[0]->{children}};
  }
  
  ### XS -> PPI/XS.xs:_PPI_Element__content 0.900+
  sub content {
  	join '', map { $_->content } @{$_[0]->{children}};
  }
  
  # Clone as normal, but then go down and relink all the _PARENT entries
  sub clone {
  	my $self  = shift;
  	my $clone = $self->SUPER::clone;
  	$clone->__link_children;
  	$clone;
  }
  
  sub location {
  	my $self  = shift;
  	my $first = $self->{children}->[0] or return undef;
  	$first->location;
  }
  
  
  
  
  
  #####################################################################
  # Internal Methods
  
  sub DESTROY {
  	local $_;
  	if ( $_[0]->{children} ) {
  		my @queue = $_[0];
  		while ( defined($_ = shift @queue) ) {
  			unshift @queue, @{delete $_->{children}} if $_->{children};
  
  			# Remove all internal/private weird crosslinking so that
  			# the cascading DESTROY calls will get called properly.
  			%$_ = ();
  		}
  	}
  
  	# Remove us from our parent node as normal
  	delete $_PARENT{refaddr $_[0]};
  }
  
  # Find the position of a child
  sub __position {
  	my $key = refaddr $_[1];
  	List::MoreUtils::firstidx { refaddr $_ == $key } @{$_[0]->{children}};
  }
  
  # Insert one or more elements before a child
  sub __insert_before_child {
  	my $self = shift;
  	my $key  = refaddr shift;
  	my $p    = List::MoreUtils::firstidx {
  	         refaddr $_ == $key
  	         } @{$self->{children}};
  	foreach ( @_ ) {
  		Scalar::Util::weaken(
  			$_PARENT{refaddr $_} = $self
  			);
  	}
  	splice( @{$self->{children}}, $p, 0, @_ );
  	1;
  }
  
  # Insert one or more elements after a child
  sub __insert_after_child {
  	my $self = shift;
  	my $key  = refaddr shift;
  	my $p    = List::MoreUtils::firstidx {
  	         refaddr $_ == $key
  	         } @{$self->{children}};
  	foreach ( @_ ) {
  		Scalar::Util::weaken(
  			$_PARENT{refaddr $_} = $self
  			);
  	}
  	splice( @{$self->{children}}, $p + 1, 0, @_ );
  	1;
  }
  
  # Replace a child
  sub __replace_child {
  	my $self = shift;
  	my $key  = refaddr shift;
  	my $p    = List::MoreUtils::firstidx {
  	         refaddr $_ == $key
  	         } @{$self->{children}};
  	foreach ( @_ ) {
  		Scalar::Util::weaken(
  			$_PARENT{refaddr $_} = $self
  			);
  	}
  	splice( @{$self->{children}}, $p, 1, @_ );
  	1;
  }
  
  # Create PARENT links for an entire tree.
  # Used when cloning or thawing.
  sub __link_children {
  	my $self = shift;
  
  	# Relink all our children ( depth first )
  	my @queue = ( $self );
  	while ( my $Node = shift @queue ) {
  		# Link our immediate children
  		foreach my $Element ( @{$Node->{children}} ) {
  			Scalar::Util::weaken(
  				$_PARENT{refaddr($Element)} = $Node
  				);
  			unshift @queue, $Element if $Element->isa('PPI::Node');
  		}
  
  		# If it's a structure, relink the open/close braces
  		next unless $Node->isa('PPI::Structure');
  		Scalar::Util::weaken(
  			$_PARENT{refaddr($Node->start)}  = $Node
  			) if $Node->start;
  		Scalar::Util::weaken(
  			$_PARENT{refaddr($Node->finish)} = $Node
  			) if $Node->finish;
  	}
  
  	1;
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Move as much as possible to L<PPI::XS>
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_NODE

$fatpacked{"PPI/Normal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_NORMAL';
  package PPI::Normal;
  
  =pod
  
  =head1 NAME
  
  PPI::Normal - Normalize Perl Documents
  
  =head2 DESCRIPTION
  
  Perl Documents, as created by PPI, are typically filled with all sorts of
  mess such as whitespace and comments and other things that don't effect
  the actual meaning of the code.
  
  In addition, because there is more than one way to do most things, and the
  syntax of Perl itself is quite flexible, there are many ways in which the
  "same" code can look quite different.
  
  PPI::Normal attempts to resolve this by providing a variety of mechanisms
  and algorithms to "normalize" Perl Documents, and determine a sort of base
  form for them (although this base form will be a memory structure, and
  not something that can be turned back into Perl source code).
  
  The process itself is quite complex, and so for convenience and
  extensibility it has been separated into a number of layers. At a later
  point, it will be possible to write Plugin classes to insert additional
  normalization steps into the various different layers.
  
  In addition, you can choose to do the normalization only as deep as a
  particular layer, depending on aggressively you want the normalization
  process to be.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Carp                      ();
  use List::Util 1.33           ();
  use PPI::Util                 '_Document';
  use PPI::Document::Normalized ();
  
  use vars qw{$VERSION %LAYER};
  BEGIN {
  	$VERSION = '1.236';
  
  	# Registered function store
  	%LAYER = (
  		1 => [],
  		2 => [],
  	);
  }
  
  
  
  
  
  #####################################################################
  # Configuration
  
  =pod
  
  =head2 register $function => $layer, ...
  
  The C<register> method is used by normalization method providers to
  tell the normalization engines which functions need to be run, and
  in which layer they apply.
  
  Provide a set of key/value pairs, where the key is the full name of the
  function (in string form), and the value is the layer (see description
  of the layers above) in which it should be run.
  
  Returns true if all functions are registered, or C<undef> on error.
  
  =cut
  
  sub register {
  	my $class = shift;
  	while ( @_ ) {
  		# Check the function
  		my $function = shift;
  		SCOPE: {
  			no strict 'refs';
  			defined $function and defined &{"$function"}
  				or Carp::croak("Bad function name provided to PPI::Normal");
  		}
  
  		# Has it already been added?
  		if ( List::Util::any { $_ eq $function } map @{$_}, values %LAYER ) {
  			return 1;
  		}
  
  		# Check the layer to add it to
  		my $layer = shift;
  		defined $layer and $layer =~ /^(?:1|2)$/
  			or Carp::croak("Bad layer provided to PPI::Normal");
  
  		# Add to the layer data store
  		push @{ $LAYER{$layer} }, $function;
  	}
  
  	1;
  }
  
  # With the registration mechanism in place, load in the main set of
  # normalization methods to initialize the store.
  use PPI::Normal::Standard;
  
  
  
  
  
  #####################################################################
  # Constructor and Accessors
  
  =pod
  
  =head2 new
  
    my $level_1 = PPI::Normal->new;
    my $level_2 = PPI::Normal->new(2);
  
  Creates a new normalization object, to which Document objects
  can be passed to be normalized.
  
  Of course, what you probably REALLY want is just to call
  L<PPI::Document>'s C<normalize> method.
  
  Takes an optional single parameter of the normalisation layer
  to use, which at this time can be either "1" or "2".
  
  Returns a new C<PPI::Normal> object, or C<undef> on error.
  
  =cut
  
  sub new {
  	my $class = shift;
  	my $layer = @_ ?
  		(defined $_[0] and ! ref $_[0] and $_[0] =~ /^[12]$/) ? shift : return undef
  		: 1;
  
  	# Create the object
  	my $object = bless {
  		layer => $layer,
  		}, $class;
  
  	$object;
  }
  
  =pod
  
  =head1 layer
  
  The C<layer> accessor returns the normalisation layer of the object.
  
  =cut
  
  sub layer { $_[0]->{layer} }
  
  
  
  
  
  #####################################################################
  # Main Methods
  
  =pod
  
  =head2 process
  
  The C<process> method takes anything that can be converted to a
  L<PPI::Document> (object, SCALAR ref, filename), loads it and
  applies the normalisation process to the document.
  
  Returns a L<PPI::Document::Normalized> object, or C<undef> on error.
  
  =cut
  
  sub process {
  	my $self = ref $_[0] ? shift : shift->new;
  
  	# PPI::Normal objects are reusable, but not re-entrant
  	return undef if $self->{Document};
  
  	# Get or create the document
  	$self->{Document} = _Document(shift) or return undef;
  
  	# Work out what functions we need to call
  	my @functions = map { @{ $LAYER{$_} } } ( 1 .. $self->layer );
  
  	# Execute each function
  	foreach my $function ( @functions ) {
  		no strict 'refs';
  		&{"$function"}( $self->{Document} );
  	}
  
  	# Create the normalized Document object
  	my $Normalized = PPI::Document::Normalized->new(
  		Document  => $self->{Document},
  		version   => $VERSION,
  		functions => \@functions,
  	) or return undef;
  
  	# Done, clean up
  	delete $self->{Document};
  	return $Normalized;
  }
  
  1;
  
  =pod
  
  =head1 NOTES
  
  The following normalisation layers are implemented. When writing
  plugins, you should register each transformation function with the
  appropriate layer.
  
  =head2 Layer 1 - Insignificant Data Removal
  
  The basic step common to all normalization, layer 1 scans through the
  Document and removes all whitespace, comments, POD, and anything else
  that returns false for its C<significant> method.
  
  It also checks each Element and removes known-useless sub-element
  metadata such as the Element's physical position in the file.
  
  =head2 Layer 2 - Significant Element Removal
  
  After the removal of the insignificant data, Layer 2 removed larger, more
  complex, and superficially "significant" elements, that can be removed
  for the purposes of normalisation.
  
  Examples from this layer include pragmas, now-useless statement
  separators (since the PDOM tree is holding statement elements), and
  several other minor bits and pieces.
  
  =head2 Layer 3 - TO BE COMPLETED
  
  This version of the forward-port of the Perl::Compare functionality
  to the 0.900+ API of PPI only implements Layer 1 and 2 at this time.
  
  =head1 TO DO
  
  - Write the other 4-5 layers :)
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_NORMAL

$fatpacked{"PPI/Normal/Standard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_NORMAL_STANDARD';
  package PPI::Normal::Standard;
  
  =pod
  
  =head1 NAME
  
  PPI::Normal::Standard - Provides standard document normalization functions
  
  =head1 DESCRIPTION
  
  This module provides the default normalization methods for L<PPI::Normal>.
  
  There is no reason for you to need to load this yourself.
  
  B<Move along, nothing to see here>.
  
  =cut
  
  use strict;
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.236';
  }
  
  
  
  
  
  #####################################################################
  # Configuration and Registration
  
  my @METHODS = (
  	remove_insignificant_elements => 1,
  	remove_useless_attributes     => 1,
  	remove_useless_pragma         => 2,
  	remove_statement_separator    => 2,
  	remove_useless_return         => 2,
  );
  
  sub import {
  	PPI::Normal->register(
  		map { /\D/ ? "PPI::Normal::Standard::$_" : $_ } @METHODS
  	) or die "Failed to register PPI::Normal::Standard transforms";
  }
  
  
  
  
  
  #####################################################################
  # Level 1 Transforms
  
  # Remove all insignificant elements
  sub remove_insignificant_elements {
  	my $Document = shift;
  	$Document->prune( sub { ! $_[1]->significant } );
  }
  
  # Remove custom attributes that are not relevant to normalization
  sub remove_useless_attributes {
  	my $Document = shift;
  	delete $Document->{tab_width};
  
  	### FIXME - Add support for more things
  }
  
  
  
  
  
  #####################################################################
  # Level 2 Transforms
  
  # Remove version dependencies and pragma
  my $remove_pragma = map { $_ => 1 } qw{
  	strict warnings diagnostics	less
  	};
  sub remove_useless_pragma {
  	my $Document = shift;
  	$Document->prune( sub {
  		return '' unless $_[1]->isa('PPI::Statement::Include');
  		return 1  if     $_[1]->version;
  		return 1  if     $remove_pragma->{$_[1]->pragma};
  		'';
  	} );
  }
  
  # Remove all semi-colons at the end of statements
  sub remove_statement_separator {
  	my $Document = shift;
  	$Document->prune( sub {
  		$_[1]->isa('PPI::Token::Structure') or return '';
  		$_[1]->content eq ';'               or return '';
  		my $stmt = $_[1]->parent            or return '';
  		$stmt->isa('PPI::Statement')        or return '';
  		$_[1]->next_sibling                and return '';
  		1;
  	} );
  }
  
  # In any block, the "return" in the last statement is not
  # needed if there is only one and only one thing after the
  # return.
  sub remove_useless_return {
  	my $Document = shift;
  	$Document->prune( sub {
  		$_[1]->isa('PPI::Token::Word')       or return '';
  		$_[1]->content eq 'return'           or return '';
  		my $stmt = $_[1]->parent             or return '';
  		$stmt->isa('PPI::Statement::Break')  or return '';
  		$stmt->children == 2                 or return '';
  		$stmt->next_sibling                 and return '';
  		my $block = $stmt->parent            or return '';
  		$block->isa('PPI::Structure::Block') or return '';
  		1;
  	} );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_NORMAL_STANDARD

$fatpacked{"PPI/Statement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT';
  package PPI::Statement;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement - The base class for Perl statements
  
  =head1 INHERITANCE
  
    PPI::Statement
    isa PPI::Node
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  PPI::Statement is the root class for all Perl statements. This includes (from
  L<perlsyn>) "Declarations", "Simple Statements" and "Compound Statements".
  
  The class PPI::Statement itself represents a "Simple Statement" as defined
  in the L<perlsyn> manpage.
  
  =head1 STATEMENT CLASSES
  
  Please note that unless documented themselves, these classes are yet to be
  frozen/finalised. Names may change slightly or be added or removed.
  
  =head2 L<PPI::Statement::Scheduled>
  
  This covers all "scheduled" blocks, chunks of code that are executed separately
  from the main body of the code, at a particular time. This includes all
  C<BEGIN>, C<CHECK>, C<UNITCHECK>, C<INIT> and C<END> blocks.
  
  =head2 L<PPI::Statement::Package>
  
  A package declaration, as defined in L<perlfunc|perlfunc/package>.
  
  =head2 L<PPI::Statement::Include>
  
  A statement that loads or unloads another module.
  
  This includes 'use', 'no', and 'require' statements.
  
  =head2 L<PPI::Statement::Sub>
  
  A named subroutine declaration, or forward declaration
  
  =head2 L<PPI::Statement::Variable>
  
  A variable declaration statement. This could be either a straight
  declaration or also be an expression.
  
  This includes all 'my', 'state', 'local' and 'our' statements.
  
  =head2 L<PPI::Statement::Compound>
  
  This covers the whole family of 'compound' statements, as described in
  L<perlsyn|perlsyn>.
  
  This includes all statements starting with 'if', 'unless', 'for', 'foreach'
  and 'while'. Note that this does NOT include 'do', as it is treated
  differently.
  
  All compound statements have implicit ends. That is, they do not end with
  a ';' statement terminator.
  
  =head2 L<PPI::Statement::Break>
  
  A statement that breaks out of a structure.
  
  This includes all of 'redo', 'goto', 'next', 'last' and 'return' statements.
  
  =head2 L<PPI::Statement::Given>
  
  The kind of statement introduced in Perl 5.10 that starts with 'given'.  This
  has an implicit end.
  
  =head2 L<PPI::Statement::When>
  
  The kind of statement introduced in Perl 5.10 that starts with 'when' or
  'default'.  This also has an implicit end.
  
  =head2 L<PPI::Statement::Data>
  
  A special statement which encompasses an entire C<__DATA__> block, including
  the initial C<'__DATA__'> token itself and the entire contents.
  
  =head2 L<PPI::Statement::End>
  
  A special statement which encompasses an entire __END__ block, including
  the initial '__END__' token itself and the entire contents, including any
  parsed PPI::Token::POD that may occur in it.
  
  =head2 L<PPI::Statement::Expression>
  
  L<PPI::Statement::Expression> is a little more speculative, and is intended
  to help represent the special rules relating to "expressions" such as in:
  
    # Several examples of expression statements
    
    # Boolean conditions
    if ( expression ) { ... }
    
    # Lists, such as for arguments
    Foo->bar( expression )
  
  =head2 L<PPI::Statement::Null>
  
  A null statement is a special case for where we encounter two consecutive
  statement terminators. ( ;; )
  
  The second terminator is given an entire statement of its own, but one
  that serves no purpose. Hence a 'null' statement.
  
  Theoretically, assuming a correct parsing of a perl file, all null statements
  are superfluous and should be able to be removed without damage to the file.
  
  But don't do that, in case PPI has parsed something wrong.
  
  =head2 L<PPI::Statement::UnmatchedBrace>
  
  Because L<PPI> is intended for use when parsing incorrect or incomplete code,
  the problem arises of what to do with a stray closing brace.
  
  Rather than die, it is allocated its own "unmatched brace" statement,
  which really means "unmatched closing brace". An unmatched open brace at the
  end of a file would become a structure with no contents and no closing brace.
  
  If the document loaded is intended to be correct and valid, finding a
  L<PPI::Statement::UnmatchedBrace> in the PDOM is generally indicative of a
  misparse.
  
  =head2 L<PPI::Statement::Unknown>
  
  This is used temporarily mid-parsing to hold statements for which the lexer
  cannot yet determine what class it should be, usually because there are
  insufficient clues, or it might be more than one thing.
  
  You should never encounter these in a fully parsed PDOM tree.
  
  =head1 METHODS
  
  C<PPI::Statement> itself has very few methods. Most of the time, you will be
  working with the more generic L<PPI::Element> or L<PPI::Node> methods, or one
  of the methods that are subclass-specific.
  
  =cut
  
  use strict;
  use Scalar::Util   ();
  use Params::Util   qw{_INSTANCE};
  use PPI::Node      ();
  use PPI::Exception ();
  
  use vars qw{$VERSION @ISA *_PARENT};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Node';
  	*_PARENT = *PPI::Element::_PARENT;
  }
  
  use PPI::Statement::Break          ();
  use PPI::Statement::Compound       ();
  use PPI::Statement::Data           ();
  use PPI::Statement::End            ();
  use PPI::Statement::Expression     ();
  use PPI::Statement::Include        ();
  use PPI::Statement::Null           ();
  use PPI::Statement::Package        ();
  use PPI::Statement::Scheduled      ();
  use PPI::Statement::Sub            ();
  use PPI::Statement::Given         ();
  use PPI::Statement::UnmatchedBrace ();
  use PPI::Statement::Unknown        ();
  use PPI::Statement::Variable       ();
  use PPI::Statement::When           ();
  
  # "Normal" statements end at a statement terminator ;
  # Some are not, and need the more rigorous _continues to see
  # if we are at an implicit statement boundary.
  sub __LEXER__normal() { 1 }
  
  
  
  
  
  #####################################################################
  # Constructor
  
  sub new {
  	my $class = shift;
  	if ( ref $class ) {
  		PPI::Exception->throw;
  	}
  
  	# Create the object
  	my $self = bless { 
  		children => [],
  	}, $class;
  
  	# If we have been passed what should be an initial token, add it
  	my $token = shift;
  	if ( _INSTANCE($token, 'PPI::Token') ) {
  		# Inlined $self->__add_element(shift);
  		Scalar::Util::weaken(
  			$_PARENT{Scalar::Util::refaddr $token} = $self
  		);
  		push @{$self->{children}}, $token;
  	}
  
  	$self;
  }
  
  =pod
  
  =head2 label
  
  One factor common to most statements is their ability to be labeled.
  
  The C<label> method returns the label for a statement, if one has been
  defined, but without the trailing colon. Take the following example
  
    MYLABEL: while ( 1 .. 10 ) { last MYLABEL if $_ > 5 }
  
  For the above statement, the C<label> method would return 'MYLABEL'.
  
  Returns false if the statement does not have a label.
  
  =cut
  
  sub label {
  	my $first = shift->schild(1) or return '';
  	$first->isa('PPI::Token::Label')
  		? substr($first, 0, length($first) - 1)
  		: '';
  }
  
  =pod
  
  =head2 specialized
  
  Answer whether this is a plain statement or one that has more
  significance.
  
  Returns true if the statement is a subclass of this one, false
  otherwise.
  
  =cut
  
  # Yes, this is doing precisely what it's intending to prevent
  # client code from doing.  However, since it's here, if the
  # implementation changes, code outside PPI doesn't care.
  sub specialized {
  	__PACKAGE__ ne ref $_[0];
  }
  
  =pod
  
  =head2 stable
  
  Much like the L<PPI::Document> method of the same name, the ->stable
  method converts a statement to source and back again, to determine if
  a modified statement is still legal, and won't be interpreted in a
  different way.
  
  Returns true if the statement is stable, false if not, or C<undef> on
  error.
  
  =cut
  
  sub stable {
  	die "The ->stable method has not yet been implemented";	
  }
  
  
  
  
  
  #####################################################################
  # PPI::Element Methods
  
  # Is the statement complete.
  # By default for a statement, we need a semi-colon at the end.
  sub _complete {
  	my $self = shift;
  	my $semi = $self->schild(-1);
  	return !! (
  		defined $semi
  		and
  		$semi->isa('PPI::Token::Structure')
  		and
  		$semi->content eq ';'
  	);
  }
  
  # You can insert either a statement or a non-significant token.
  sub insert_before {
  	my $self    = shift;
  	my $Element = _INSTANCE(shift, 'PPI::Element') or return undef;
  	if ( $Element->isa('PPI::Statement') ) {
  		return $self->__insert_before($Element);
  	} elsif ( $Element->isa('PPI::Token') and ! $Element->significant ) {
  		return $self->__insert_before($Element);
  	}
  	'';
  }
  
  # As above, you can insert a statement, or a non-significant token
  sub insert_after {
  	my $self    = shift;
  	my $Element = _INSTANCE(shift, 'PPI::Element') or return undef;
  	if ( $Element->isa('PPI::Statement') ) {
  		return $self->__insert_after($Element);
  	} elsif ( $Element->isa('PPI::Token') and ! $Element->significant ) {
  		return $self->__insert_after($Element);
  	}
  	'';
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Complete, freeze and document the remaining classes
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT

$fatpacked{"PPI/Statement/Break.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_BREAK';
  package PPI::Statement::Break;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Break - Statements which break out of normal statement flow
  
  =head1 SYNOPSIS
  
    last;
    goto FOO;
    next if condition();
    return $foo;
    redo;
  
  =head1 INHERITANCE
  
    PPI::Statement::Break
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Statement::Break> is intended to represent statements that break
  out of the normal statement flow control. This covers the basic
  types C<'redo'>, C<'goto'>, C<'next'>, C<'last'> and C<'return'>.
  
  =head1 METHODS
  
  C<PPI::Statement::Break> has no additional methods beyond the default ones
  provided by L<PPI::Statement>, L<PPI::Node> and L<PPI::Element>.
  
  However, it is expected to gain methods for identifying the line to break
  to, or the structure to break out of.
  
  =cut
  
  use strict;
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Add the methods to identify the break target
  
  - Add some proper unit testing
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_BREAK

$fatpacked{"PPI/Statement/Compound.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_COMPOUND';
  package PPI::Statement::Compound;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Compound - Describes all compound statements
  
  =head1 SYNOPSIS
  
    # A compound if statement
    if ( foo ) {
        bar();
    } else {
        baz();
    }
  
    # A compound loop statement
    foreach ( @list ) {
        bar($_);
    }
  
  =head1 INHERITANCE
  
    PPI::Statement::Compound
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Statement::Compound> objects are used to describe all current forms
  of compound statements, as described in L<perlsyn>.
  
  This covers blocks using C<if>, C<unless>, C<for>, C<foreach>, C<while>,
  and C<continue>. Please note this does B<not> cover "simple" statements
  with trailing conditions. Please note also that "do" is also not part of
  a compound statement.
  
    # This is NOT a compound statement
    my $foo = 1 if $condition;
  
    # This is also not a compound statement
    do { ... } until $condition;
  
  =head1 METHODS
  
  C<PPI::Statement::Compound> has a number of methods in addition to the
  standard L<PPI::Statement>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA %TYPES};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  
  	# Keyword type map
  	%TYPES = (
  		'if'      => 'if',
  		'unless'  => 'if',
  		'while'   => 'while',
  		'until'   => 'while',
  		'for'     => 'for',
  		'foreach' => 'foreach',
  	);
  }
  
  # Lexer clues
  sub __LEXER__normal() { '' }
  
  
  
  
  
  #####################################################################
  # PPI::Statement::Compound analysis methods
  
  =pod
  
  =head2 type
  
  The C<type> method returns the syntactic type of the compound statement.
  
  There are four basic compound statement types.
  
  The C<'if'> type includes all variations of the if and unless statements,
  including any C<'elsif'> or C<'else'> parts of the compound statement.
  
  The C<'while'> type describes the standard while and until statements, but
  again does B<not> describes simple statements with a trailing while.
  
  The C<'for'> type covers the C-style for loops, regardless of whether they
  were declared using C<'for'> or C<'foreach'>.
  
  The C<'foreach'> type covers loops that iterate over collections,
  regardless of whether they were declared using C<'for'> or C<'foreach'>.
  
  All of the compounds are a variation on one of these four.
  
  Returns the simple string C<'if'>, C<'for'>, C<'foreach'> or C<'while'>,
  or C<undef> if the type cannot be determined.
  
  =cut
  
  sub type {
  	my $self    = shift;
  	my $p       = 0; # Child position
  	my $Element = $self->schild($p) or return undef;
  
  	# A labelled statement
  	if ( $Element->isa('PPI::Token::Label') ) {
  		$Element = $self->schild(++$p) or return 'label';
  	}
  
  	# Most simple cases
  	my $content = $Element->content;
  	if ( $content =~ /^for(?:each)?\z/ ) {
  		$Element = $self->schild(++$p) or return $content;
  		if ( $Element->isa('PPI::Token') ) {
  			return 'foreach' if $Element->content =~ /^my|our|state\z/;
  			return 'foreach' if $Element->isa('PPI::Token::Symbol');
  			return 'foreach' if $Element->isa('PPI::Token::QuoteLike::Words');
  		}
  		if ( $Element->isa('PPI::Structure::List') ) {
  			return 'foreach';
  		}
  		return 'for';
  	}
  	return $TYPES{$content} if $Element->isa('PPI::Token::Word');
  	return 'continue'       if $Element->isa('PPI::Structure::Block');
  
  	# Unknown (shouldn't exist?)
  	undef;
  }
  
  
  
  
  
  #####################################################################
  # PPI::Node Methods
  
  sub scope() { 1 }
  
  
  
  
  
  #####################################################################
  # PPI::Element Methods
  
  sub _complete {
  	my $self = shift;
  	my $type = $self->type or die "Illegal compound statement type";
  
  	# Check the different types of compound statements
  	if ( $type eq 'if' ) {
  		# Unless the last significant child is a complete
  		# block, it must be incomplete.
  		my $child = $self->schild(-1) or return '';
  		$child->isa('PPI::Structure') or return '';
  		$child->braces eq '{}'        or return '';
  		$child->_complete             or return '';
  
  		# It can STILL be
  	} elsif ( $type eq 'while' ) {
  		die "CODE INCOMPLETE";
  	} else {
  		die "CODE INCOMPLETE";
  	}
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Write unit tests for this package
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_COMPOUND

$fatpacked{"PPI/Statement/Data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_DATA';
  package PPI::Statement::Data;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Data - The __DATA__ section of a file
  
  =head1 SYNOPSIS
  
    # Normal content
    
    __DATA__
    This: data
    is: part
    of: the
    PPI::Statement::Data: object
  
  =head1 INHERITANCE
  
    PPI::Statement::Compound
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Statement::Data> is a utility class designed to hold content in
  the __DATA__ section of a file. It provides a single statement to hold
  B<all> of the data.
  
  =head1 METHODS
  
  C<PPI::Statement::Data> has no additional methods beyond the default ones
  provided by L<PPI::Statement>, L<PPI::Node> and L<PPI::Element>.
  
  However, it is expected to gain methods for accessing the data directly,
  (as a filehandle for example) just as you would access the data in the
  Perl code itself.
  
  =cut
  
  use strict;
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  # Data is never complete
  sub _complete () { '' }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Add the methods to read in the data
  
  - Add some proper unit testing
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_DATA

$fatpacked{"PPI/Statement/End.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_END';
  package PPI::Statement::End;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::End - Content after the __END__ of a module
  
  =head1 SYNOPSIS
  
    # This is normal content
    
    __END__
    
    This is part of a PPI::Statement::End statement
    
    =pod
    
    This is not part of the ::End statement, it's POD
    
    =cut
    
    This is another PPI::Statement::End statement
  
  =head1 INHERITANCE
  
    PPI::Statement::End
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Statement::End> is a utility class designed to serve as a contained
  for all of the content after the __END__ tag in a file.
  
  It doesn't cover the ENTIRE of the __END__ section, and can be interspersed
  with L<PPI::Token::Pod> tokens.
  
  =head1 METHODS
  
  C<PPI::Statement::End> has no additional methods beyond the default ones
  provided by L<PPI::Statement>, L<PPI::Node> and L<PPI::Element>.
  
  =cut
  
  use strict;
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  # Once we have an __END__ we're done
  sub _complete () { 1 }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_END

$fatpacked{"PPI/Statement/Expression.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_EXPRESSION';
  package PPI::Statement::Expression;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Expression - A generic and non-specialised statement
  
  =head1 SYNOPSIS
  
    $foo = bar;
    ("Hello World!");
    do_this();
  
  =head1 INHERITANCE
  
    PPI::Statement::Expression
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  A C<PPI::Statement::Expression> is a normal statement that is evaluated,
  may or may not assign, may or may not have side effects, and has no special
  or redeeming features whatsoever.
  
  It provides a default for all statements that don't fit into any other
  classes.
  
  =head1 METHODS
  
  C<PPI::Statement::Expression> has no additional methods beyond the default ones
  provided by L<PPI::Statement>, L<PPI::Node> and L<PPI::Element>.
  
  =cut
  
  use strict;
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_EXPRESSION

$fatpacked{"PPI/Statement/Given.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_GIVEN';
  package PPI::Statement::Given;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Given - A given-when statement
  
  =head1 SYNOPSIS
  
    given ( foo ) {
        say $_;
    }
  
  =head1 INHERITANCE
  
    PPI::Statement::Given
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Statement::Given> objects are used to describe switch statements, as
  described in L<perlsyn>.
  
  =head1 METHODS
  
  C<PPI::Statement::Given> has no methods beyond those provided by the
  standard L<PPI::Structure>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  # Lexer clues
  sub __LEXER__normal() { '' }
  
  sub _complete {
  	my $child = $_[0]->schild(-1);
  	return !! (
  		defined $child
  		and
  		$child->isa('PPI::Structure::Block')
  		and
  		$child->complete
  	);
  }
  
  
  
  
  
  #####################################################################
  # PPI::Node Methods
  
  sub scope() { 1 }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Write unit tests for this package
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_GIVEN

$fatpacked{"PPI/Statement/Include.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_INCLUDE';
  package PPI::Statement::Include;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Include - Statements that include other code
  
  =head1 SYNOPSIS
  
    # The following are all includes
    use 5.006;
    use strict;
    use My::Module;
    use constant FOO => 'Foo';
    require Foo::Bar;
    require "Foo/Bar.pm";
    require $foo if 1;
    no strict 'refs';
  
  =head1 INHERITANCE
  
    PPI::Statement::Include
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  Despite its name, the C<PPI::Statement::Include> class covers a number
  of different types of statement that cover all statements starting with
  C<use>, C<no> and C<require>.
  
  But basically, they cover three situations.
  
  Firstly, a dependency on a particular version of perl (for which the
  C<version> method returns true), a pragma (for which the C<pragma> method
  returns true), or the loading (and unloading via no) of modules.
  
  =head1 METHODS
  
  C<PPI::Statement::Include> has a number of methods in addition to the standard
  L<PPI::Statement>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Statement                 ();
  use PPI::Statement::Include::Perl6 ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  =pod
  
  =head2 type
  
  The C<type> method returns the general type of statement (C<'use'>, C<'no'>
  or C<'require'>).
  
  Returns the type as a string, or C<undef> if the type cannot be detected.
  
  =cut
  
  sub type {
  	my $self    = shift;
  	my $keyword = $self->schild(0) or return undef;
  	$keyword->isa('PPI::Token::Word') and $keyword->content;
  }
  
  =pod
  
  =head2 module
  
  The C<module> method returns the module name specified in any include
  statement. This C<includes> pragma names, because pragma are implemented
  as modules. (And lets face it, the definition of a pragma can be fuzzy
  at the best of times in any case)
  
  This covers all of these...
  
    use strict;
    use My::Module;
    no strict;
    require My::Module;
  
  ...but does not cover any of these...
  
    use 5.006;
    require 5.005;
    require "explicit/file/name.pl";
  
  Returns the module name as a string, or C<undef> if the include does
  not specify a module name.
  
  =cut
  
  sub module {
  	my $self = shift;
  	my $module = $self->schild(1) or return undef;
  	$module->isa('PPI::Token::Word') and $module->content;
  }
  
  =pod
  
  =head2 module_version
  
  The C<module_version> method returns the minimum version of the module
  required by the statement, if there is one.
  
  =cut
  
  sub module_version {
  	my $self     = shift;
  	my $argument = $self->schild(3);
  	if ( $argument and $argument->isa('PPI::Token::Operator') ) {
  		return undef;
  	}
  
  	my $version = $self->schild(2) or return undef;
  	return undef unless $version->isa('PPI::Token::Number');
  
  	return $version;
  }
  
  =pod
  
  =head2 pragma
  
  The C<pragma> method checks for an include statement's use as a
  pragma, and returns it if so.
  
  Or at least, it claims to. In practice it's a lot harder to say exactly
  what is or isn't a pragma, because the definition is fuzzy.
  
  The C<intent> of a pragma is to modify the way in which the parser works.
  This is done though the use of modules that do various types of internals
  magic.
  
  For now, PPI assumes that any "module name" that is only a set of
  lowercase letters (and perhaps numbers, like C<use utf8;>). This
  behaviour is expected to change, most likely to something that knows
  the specific names of the various "pragmas".
  
  Returns the name of the pragma, or false ('') if the include is not a
  pragma.
  
  =cut
  
  sub pragma {
  	my $self   = shift;
  	my $module = $self->module or return '';
  	$module =~ /^[a-z][a-z\d]*$/ ? $module : '';
  }
  
  =pod
  
  =head2 version
  
  The C<version> method checks for an include statement that introduces a
  dependency on the version of C<perl> the code is compatible with.
  
  This covers two specific statements.
  
    use 5.006;
    require 5.006;
  
  Currently the version is returned as a string, although in future the version
  may be returned as a L<version> object.  If you want a numeric representation,
  use C<version_literal()>.  Returns false if the statement is not a version
  dependency.
  
  =cut
  
  sub version {
  	my $self    = shift;
  	my $version = $self->schild(1) or return undef;
  	$version->isa('PPI::Token::Number') ? $version->content : '';
  }
  
  =pod
  
  =head2 version_literal
  
  The C<version_literal> method has the same behavior as C<version()>, but the
  version is returned as a numeric literal.  Returns false if the statement is
  not a version dependency.
  
  =cut
  
  sub version_literal {
  	my $self    = shift;
  	my $version = $self->schild(1) or return undef;
  	$version->isa('PPI::Token::Number') ? $version->literal : '';
  }
  
  =pod
  
  =head2 arguments
  
  The C<arguments> method gives you the rest of the statement after the
  module/pragma and module version, i.e. the stuff that will be used to
  construct what gets passed to the module's C<import()> subroutine.  This does
  include the comma, etc. operators, but doesn't include non-significant direct
  children or any final semicolon.
  
  =cut
  
  sub arguments {
  	my $self = shift;
  	my @args = $self->schildren;
  
  	# Remove the "use", "no" or "require"
  	shift @args;
  
  	# Remove the statement terminator
  	if (
  		$args[-1]->isa('PPI::Token::Structure')
  		and
  		$args[-1]->content eq ';'
  	) {
  		pop @args;
  	}
  
  	# Remove the module or perl version.
  	shift @args;  
  
  	return unless @args;
  
  	if ( $args[0]->isa('PPI::Token::Number') ) {
  		my $after = $args[1] or return;
  		$after->isa('PPI::Token::Operator') or shift @args;
  	}
  
  	return @args;
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Write specific unit tests for this package
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_INCLUDE

$fatpacked{"PPI/Statement/Include/Perl6.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_INCLUDE_PERL6';
  package PPI::Statement::Include::Perl6;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Include::Perl6 - Inline Perl 6 file section
  
  =head1 SYNOPSIS
  
    use v6-alpha;
    
    grammar My::Grammar {
        ...
    }
  
  =head1 INHERITANCE
  
    PPI::Statement::Include::Perl6
    isa PPI::Statement::Include
        isa PPI::Statement
            isa PPI::Node
                isa PPI::Element
  
  =head1 DESCRIPTION
  
  A C<PPI::Statement::Include::Perl6> is a special include statement that
  indicates the start of a section of Perl 6 code inlined into a regular
  Perl 5 code file.
  
  The primary purpose of the class is to allow L<PPI> to provide at least
  basic support for "6 in 5" modules like v6.pm;
  
  Currently, PPI only supports starting a Perl 6 block. It does not
  currently support changing back to Perl 5 again. Additionally all POD
  and __DATA__ blocks and __END__ blocks will be included in the Perl 6
  string and will not be parsed by PPI.
  
  =cut
  
  use strict;
  use PPI::Statement::Include ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement::Include';
  }
  
  =pod
  
  =head2 perl6
  
  The C<perl6> method returns the block of Perl 6 code that is attached to
  the "use v6...;" command.
  
  =cut
  
  sub perl6 {
  	$_[0]->{perl6};
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Write specific unit tests for this package
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_INCLUDE_PERL6

$fatpacked{"PPI/Statement/Null.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_NULL';
  package PPI::Statement::Null;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Null - A useless null statement
  
  =head1 SYNOPSIS
  
    my $foo = 1;
    
    ; # <-- Null statement
    
    my $bar = 1;
  
  =head1 INHERITANCE
  
    PPI::Statement::Null
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Statement::Null> is a utility class designed to handle situations
  where PPI encounters a naked statement separator.
  
  Although strictly speaking, the semicolon is a statement B<separator>
  and not a statement B<terminator>, PPI considers a semicolon to be a
  statement terminator under most circumstances.
  
  In any case, the null statement has no purpose, and can be safely deleted
  with no ill effect.
  
  =head1 METHODS
  
  C<PPI::Statement::Null> has no additional methods beyond the default ones
  provided by L<PPI::Statement>, L<PPI::Node> and L<PPI::Element>.
  
  =cut
  
  use strict;
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  # A null statement is not significant
  sub significant() { '' }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_NULL

$fatpacked{"PPI/Statement/Package.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_PACKAGE';
  package PPI::Statement::Package;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Package - A package statement
  
  =head1 INHERITANCE
  
    PPI::Statement::Package
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  Most L<PPI::Statement> subclasses are assigned based on the value of the
  first token or word found in the statement. When PPI encounters a statement
  starting with 'package', it converts it to a C<PPI::Statement::Package>
  object.
  
  When working with package statements, please remember that packages only
  exist within their scope, and proper support for scoping has yet to be
  completed in PPI.
  
  However, if the immediate parent of the package statement is the
  top level L<PPI::Document> object, then it can be considered to define
  everything found until the next top-level "file scoped" package statement.
  
  A file may, however, contain nested temporary package, in which case you
  are mostly on your own :)
  
  =head1 METHODS
  
  C<PPI::Statement::Package> has a number of methods in addition to the standard
  L<PPI::Statement>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  # Lexer clues
  sub __LEXER__normal() { '' }
  
  =pod
  
  =head2 namespace
  
  Most package declarations are simple, and just look something like
  
    package Foo::Bar;
  
  The C<namespace> method returns the name of the declared package, in the
  above case 'Foo::Bar'. It returns this exactly as written and does not
  attempt to clean up or resolve things like ::Foo to main::Foo.
  
  If the package statement is done any different way, it returns false.
  
  =cut
  
  sub namespace {
  	my $self = shift;
  	my $namespace = $self->schild(1) or return '';
  	$namespace->isa('PPI::Token::Word')
  		? $namespace->content
  		: '';
  }
  
  =pod
  
  =head2 version
  
  Some package declarations may include a version:
  
    package Foo::Bar 1.23;
    package Baz v1.23;
  
  The C<version> method returns the stringified version as seen in the
  document (if any), otherwise the empty string.
  
  =cut
  
  sub version {
  	my $self = shift;
  	my $version = $self->schild(2) or return '';
  	$version->isa('PPI::Token::Structure')
  		? ''
  		: $version->content;
  }
  
  =pod
  
  =head2 file_scoped
  
  Regardless of whether it is named or not, the C<file_scoped> method will
  test to see if the package declaration is a top level "file scoped"
  statement or not, based on its location.
  
  In general, returns true if it is a "file scoped" package declaration with
  an immediate parent of the top level Document, or false if not.
  
  Note that if the PPI DOM tree B<does not> have a PPI::Document object at
  as the root element, this will return false. Likewise, it will also return
  false if the root element is a L<PPI::Document::Fragment>, as a fragment of
  a file does not represent a scope.
  
  =cut
  
  sub file_scoped {
  	my $self     = shift;
  	my ($Parent, $Document) = ($self->parent, $self->top);
  	$Parent and $Document and $Parent == $Document
  	and $Document->isa('PPI::Document')
  	and ! $Document->isa('PPI::Document::Fragment');
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_PACKAGE

$fatpacked{"PPI/Statement/Scheduled.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_SCHEDULED';
  package PPI::Statement::Scheduled;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Scheduled - A scheduled code block
  
  =head1 INHERITANCE
  
    PPI::Statement::Scheduled
    isa PPI::Statement::Sub
        isa PPI::Statement
            isa PPI::Node
                isa PPI::Element
  
  =head1 DESCRIPTION
  
  A scheduled code block is one that is intended to be run at a specific
  time during the loading process.
  
  There are five types of scheduled block:
  
    BEGIN {
    	# Executes as soon as this block is fully defined
    	...
    }
  
    CHECK {
    	# Executes after overall compile-phase in reverse order
    	...
    }
  
    UNITCHECK {
    	# Executes after compile-phase of individual module in reverse order
    	...
    }
  
    INIT {
    	# Executes just before run-time
    	...
    }
  
    END {
    	# Executes as late as possible in reverse order
    	...
    }
  
  Technically these scheduled blocks are actually subroutines, and in fact
  may have 'sub' in front of them.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Statement::Sub ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement::Sub';
  }
  
  sub __LEXER__normal() { '' }
  
  sub _complete {
  	my $child = $_[0]->schild(-1);
  	return !! (
  		defined $child
  		and
  		$child->isa('PPI::Structure::Block')
  		and
  		$child->complete
  	);
  }
  
  =pod
  
  =head2 type
  
  The C<type> method returns the type of scheduled block, which should always be
  one of C<'BEGIN'>, C<'CHECK'>, C<'UNITCHECK'>, C<'INIT'> or C<'END'>.
  
  =cut
  
  sub type {
  	my $self     = shift;
  	my @children = $self->schildren or return undef;
  	$children[0]->content eq 'sub'
  		? $children[1]->content
  		: $children[0]->content;
  }
  
  # This is actually the same as Sub->name
  sub name {
  	shift->type(@_);
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Write unit tests for this package
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_SCHEDULED

$fatpacked{"PPI/Statement/Sub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_SUB';
  package PPI::Statement::Sub;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Sub - Subroutine declaration
  
  =head1 INHERITANCE
  
    PPI::Statement::Sub
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  Except for the special BEGIN, CHECK, UNITCHECK, INIT, and END subroutines
  (which are part of L<PPI::Statement::Scheduled>) all subroutine declarations
  are lexed as a PPI::Statement::Sub object.
  
  Primarily, this means all of the various C<sub foo {}> statements, but also
  forward declarations such as C<sub foo;> or C<sub foo($);>. It B<does not>
  include anonymous subroutines, as these are merely part of a normal statement.
  
  =head1 METHODS
  
  C<PPI::Statement::Sub> has a number of methods in addition to the standard
  L<PPI::Statement>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use List::Util     ();
  use Params::Util   qw{_INSTANCE};
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  # Lexer clue
  sub __LEXER__normal() { '' }
  
  sub _complete {
  	my $child = $_[0]->schild(-1);
  	return !! (
  		defined $child
  		and
  		$child->isa('PPI::Structure::Block')
  		and
  		$child->complete
  	);
  }
  
  
  
  
  
  #####################################################################
  # PPI::Statement::Sub Methods
  
  =pod
  
  =head2 name
  
  The C<name> method returns the name of the subroutine being declared.
  
  In some rare cases such as a naked C<sub> at the end of the file, this may return
  false.
  
  =cut
  
  sub name {
  	my ($self) = @_;
  
  	# Usually the second token is the name.
  	my $token = $self->schild(1);
  	return $token->content
  	  if defined $token and $token->isa('PPI::Token::Word');
  
  	# In the case of special subs whose 'sub' can be omitted (AUTOLOAD
  	# or DESTROY), the name will be the first token.
  	$token = $self->schild(0);
  	return $token->content
  	  if defined $token and $token->isa('PPI::Token::Word');
  	return '';
  }
  
  =pod
  
  =head2 prototype
  
  If it has one, the C<prototype> method returns the subroutine's prototype.
  It is returned in the same format as L<PPI::Token::Prototype/prototype>,
  cleaned and removed from its brackets.
  
  Returns the subroutine's prototype, or undef if the subroutine does not
  define one. Note that when the sub has an empty prototype (C<()>) the
  return is an empty string.
  
  =cut
  
  sub prototype {
  	my $self      = shift;
  	my $Prototype = List::Util::first {
  		_INSTANCE($_, 'PPI::Token::Prototype')
  	} $self->children;
  	defined($Prototype) ? $Prototype->prototype : undef;
  }
  
  =pod
  
  =head2 block
  
  With its name and implementation shared with L<PPI::Statement::Scheduled>,
  the C<block> method finds and returns the actual Structure object of the
  code block for this subroutine.
  
  Returns false if this is a forward declaration, or otherwise does not have a
  code block.
  
  =cut
  
  sub block {
  	my $self = shift;
  	my $lastchild = $self->schild(-1) or return '';
  	$lastchild->isa('PPI::Structure::Block') and $lastchild;
  }
  
  =pod
  
  =head2 forward
  
  The C<forward> method returns true if the subroutine declaration is a
  forward declaration.
  
  That is, it returns false if the subroutine has a code block, or true
  if it does not.
  
  =cut
  
  sub forward {
  	! shift->block;
  }
  
  =pod
  
  =head2 reserved
  
  The C<reserved> method provides a convenience method for checking to see
  if this is a special reserved subroutine. It does not check against any
  particular list of reserved sub names, but just returns true if the name
  is all uppercase, as defined in L<perlsub>.
  
  Note that in the case of BEGIN, CHECK, UNITCHECK, INIT and END, these will be
  defined as L<PPI::Statement::Scheduled> objects, not subroutines.
  
  Returns true if it is a special reserved subroutine, or false if not.
  
  =cut
  
  sub reserved {
  	my $self = shift;
  	my $name = $self->name or return '';
  	# perlsub is silent on whether reserveds can contain:
  	# - underscores;
  	# we allow them due to existing practice like CLONE_SKIP and __SUB__.
  	# - numbers; we allow them by PPI tradition.
  	$name eq uc $name;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_SUB

$fatpacked{"PPI/Statement/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_UNKNOWN';
  package PPI::Statement::Unknown;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Unknown - An unknown or transient statement
  
  =head1 INHERITANCE
  
    PPI::Statement::Unknown
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Statement::Unknown> class is used primarily during the lexing
  process to hold elements that are known to be statement, but for which
  the exact C<type> of statement is as yet unknown, and requires further
  tokens in order to resolve the correct type.
  
  They should not exist in a fully parse B<valid> document, and if any
  exists they indicate either a problem in Document, or possibly (by
  allowing it to get through unresolved) a bug in L<PPI::Lexer>.
  
  =head1 METHODS
  
  C<PPI::Statement::Unknown> has no additional methods beyond the
  default ones provided by L<PPI::Statement>, L<PPI::Node> and
  L<PPI::Element>.
  
  =cut
  
  use strict;
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  # If one of these ends up in the final document,
  # we're pretty much screwed. Just call it a day.
  sub _complete () { 1 }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_UNKNOWN

$fatpacked{"PPI/Statement/UnmatchedBrace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_UNMATCHEDBRACE';
  package PPI::Statement::UnmatchedBrace;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::UnmatchedBrace - Isolated unmatched brace
  
  =head1 SYNOPSIS
  
    sub foo {
        1;
    }
    
    } # <--- This is an unmatched brace
  
  =head1 INHERITANCE
  
    PPI::Statement::UnmatchedBrace
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Statement::UnmatchedBrace> class is a miscellaneous utility
  class. Objects of this type should be rare, or not exist at all in normal
  valid L<PPI::Document> objects.
  
  It can be either a round ')', square ']' or curly '}' brace, this class
  does not distinguish. Objects of this type are only allocated at a
  structural level, not a lexical level (as they are lexically invalid
  anyway).
  
  The presence of a C<PPI::Statement::UnmatchedBrace> indicated a broken
  or invalid document. Or maybe a bug in PPI, but B<far> more likely a
  broken Document. :)
  
  =head1 METHODS
  
  C<PPI::Statement::UnmatchedBrace> has no additional methods beyond the
  default ones provided by L<PPI::Statement>, L<PPI::Node> and
  L<PPI::Element>.
  
  =cut
  
  use strict;
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  # Once we've hit a naked unmatched brace we can never truly be complete.
  # So instead we always just call it a day...
  sub _complete () { 1 }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_UNMATCHEDBRACE

$fatpacked{"PPI/Statement/Variable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_VARIABLE';
  package PPI::Statement::Variable;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::Variable - Variable declaration statements
  
  =head1 SYNOPSIS
  
    # All of the following are variable declarations
    my $foo = 1;
    my ($foo, $bar) = (1, 2);
    our $foo = 1;
    local $foo;
    local $foo = 1;
    LABEL: my $foo = 1;
  
  =head1 INHERITANCE
  
    PPI::Statement::Variable
    isa PPI::Statement::Expression
        isa PPI::Statement
            isa PPI::Node
                isa PPI::Element
  
  =head1 DESCRIPTION
  
  The main intent of the C<PPI::Statement::Variable> class is to describe
  simple statements that explicitly declare new local or global variables.
  
  Note that this does not make it exclusively the only place where variables
  are defined, and later on you should expect that the C<variables> method
  will migrate deeper down the tree to either L<PPI::Statement> or
  L<PPI::Node> to recognise this fact, but for now it stays here.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Params::Util               qw{_INSTANCE};
  use PPI::Statement::Expression ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement::Expression';
  }
  
  =pod
  
  =head2 type
  
  The C<type> method checks and returns the declaration type of the statement,
  which will be one of 'my', 'local', 'our', or 'state'.
  
  Returns a string of the type, or C<undef> if the type cannot be detected
  (which is probably a bug).
  
  =cut
  
  sub type {
  	my $self = shift;
  
  	# Get the first significant child
  	my @schild = grep { $_->significant } $self->children;
  
  	# Ignore labels
  	shift @schild if _INSTANCE($schild[0], 'PPI::Token::Label');
  
  	# Get the type
  	(_INSTANCE($schild[0], 'PPI::Token::Word') and $schild[0]->content =~ /^(my|local|our|state)$/)
  		? $schild[0]->content
  		: undef;
  }
  
  =pod
  
  =head2 variables
  
  As for several other PDOM Element types that can declare variables, the
  C<variables> method returns a list of the canonical forms of the variables
  defined by the statement.
  
  Returns a list of the canonical string forms of variables, or the null list
  if it is unable to find any variables.
  
  =cut
  
  sub variables {
  	map { $_->canonical } $_[0]->symbols;
  }
  
  =pod
  
  =head2 symbols
  
  Returns a list of the variables defined by the statement, as
  L<PPI::Token::Symbol>s.
  
  =cut
  
  sub symbols {
  	my $self = shift;
  
  	# Get the children we care about
  	my @schild = grep { $_->significant } $self->children;
  	shift @schild if _INSTANCE($schild[0], 'PPI::Token::Label');
  
  	# If the second child is a symbol, return its name
  	if ( _INSTANCE($schild[1], 'PPI::Token::Symbol') ) {
  		return $schild[1];
  	}
  
  	# If it's a list, return as a list
  	if ( _INSTANCE($schild[1], 'PPI::Structure::List') ) {
  		my $Expression = $schild[1]->schild(0);
  		$Expression and
  		$Expression->isa('PPI::Statement::Expression') or return ();
  
  		# my and our are simpler than local
  		if (
  			$self->type eq 'my'
  			or
  			$self->type eq 'our'
  			or
  			$self->type eq 'state'
  		) {
  			return grep {
  				$_->isa('PPI::Token::Symbol')
  			} $Expression->schildren;
  		}
  
  		# Local is much more icky (potentially).
  		# Not that we are actually going to deal with it now,
  		# but having this separate is likely going to be needed
  		# for future bug reports about local() things.
  
  		# This is a slightly better way to check.
  		return grep {
  			$self->_local_variable($_)
  		} grep {
  			$_->isa('PPI::Token::Symbol')
  		} $Expression->schildren;
  	}
  
  	# erm... this is unexpected
  	();
  }
  
  sub _local_variable {
  	my ($self, $el) = @_;
  
  	# The last symbol should be a variable
  	my $n = $el->snext_sibling or return 1;
  	my $p = $el->sprevious_sibling;
  	if ( ! $p or $p eq ',' ) {
  		# In the middle of a list
  		return 1 if $n eq ',';
  
  		# The first half of an assignment
  		return 1 if $n eq '=';
  	}
  
  	# Lets say no for know... additional work
  	# should go here.
  	return '';
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Write unit tests for this
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_VARIABLE

$fatpacked{"PPI/Statement/When.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STATEMENT_WHEN';
  package PPI::Statement::When;
  
  =pod
  
  =head1 NAME
  
  PPI::Statement::When - A when statement
  
  =head1 SYNOPSIS
  
    foreach ( qw/ foo bar baz / ) {
        when ( m/b/ ) {
            boing($_);
        }
        when ( m/f/ ) {
            boom($_);
        }
        default {
            tchak($_);
        }
    }
  
  =head1 INHERITANCE
  
    PPI::Statement::When
    isa PPI::Statement
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Statement::When> objects are used to describe when and default
  statements, as described in L<perlsyn>.
  
  =head1 METHODS
  
  C<PPI::Structure::When> has no methods beyond those provided by the
  standard L<PPI::Structure>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Statement ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Statement';
  }
  
  # Lexer clues
  sub __LEXER__normal() { '' }
  
  sub _complete {
  	my $child = $_[0]->schild(-1);
  	return !! (
  		defined $child
  		and
  		$child->isa('PPI::Structure::Block')
  		and
  		$child->complete
  	);
  }
  
  
  
  
  
  #####################################################################
  # PPI::Node Methods
  
  sub scope() {
  	1;
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Write unit tests for this package
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STATEMENT_WHEN

$fatpacked{"PPI/Structure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE';
  package PPI::Structure;
  
  =pod
  
  =head1 NAME
  
  PPI::Structure - The base class for Perl braced structures
  
  =head1 INHERITANCE
  
    PPI::Structure
    isa PPI::Node
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  PPI::Structure is the root class for all Perl bracing structures. This
  covers all forms of C< [ ... ] >, C< { ... } >, and C< ( ... ) > brace
  types, and includes cases where only one half of the pair exist.
  
  The class PPI::Structure itself is full abstract and no objects of that
  type should actually exist in the tree.
  
  =head2 Elements vs Children
  
  A B<PPI::Structure> has an unusual existence. Unlike a L<PPI::Document>
  or L<PPI::Statement>, which both simply contain other elements, a
  structure B<both> contains and consists of content.
  
  That is, the brace tokens are B<not> considered to be "children" of the
  structure, but are part of it.
  
  In practice, this will mean that while the -E<gt>elements and -E<gt>tokens
  methods (and related) B<will> return a list with the brace tokens at either
  end, the -E<gt>children method explicitly will B<not> return the brace.
  
  =head1 STRUCTURE CLASSES
  
  Excluding the transient L<PPI::Structure::Unknown> that exists briefly
  inside the parser, there are eight types of structure.
  
  =head2 L<PPI::Structure::List>
  
  This covers all round braces used for function arguments, in C<foreach>
  loops, literal lists, and braces used for precedence-ordering purposes.
  
  =head2 L<PPI::Structure::For>
  
  Although B<not> used for the C<foreach> loop list, this B<is> used for
  the special case of the round-brace three-part semicolon-separated C<for>
  loop expression (the traditional C style for loop).
  
  =head2 L<PPI::Structure::Given>
  
  This is for the expression being matched in switch statements.
  
  =head2 L<PPI::Structure::When>
  
  This is for the matching expression in "when" statements.
  
  =head2 L<PPI::Structure::Condition>
  
  This round-brace structure covers boolean conditional braces, such as
  for C<if> and C<while> blocks.
  
  =head2 L<PPI::Structure::Block>
  
  This curly-brace and common structure is used for all form of code
  blocks. This includes those for C<if>, C<do> and similar, as well
  as C<grep>, C<map>, C<sort>, C<sub> and (labelled or anonymous) 
  scoping blocks.
  
  =head2 L<PPI::Structure::Constructor>
  
  This class covers brace structures used for the construction of
  anonymous C<ARRAY> and C<HASH> references.
  
  =head2 L<PPI::Structure::Subscript>
  
  This class covers square-braces and curly-braces used after a
  -E<gt> pointer to access the subscript of an C<ARRAY> or C<HASH>.
  
  =head1 METHODS
  
  C<PPI::Structure> itself has very few methods. Most of the time, you will be
  working with the more generic L<PPI::Element> or L<PPI::Node> methods, or one
  of the methods that are subclass-specific.
  
  =cut
  
  use strict;
  use Scalar::Util   ();
  use Params::Util   qw{_INSTANCE};
  use PPI::Node      ();
  use PPI::Exception ();
  
  use vars qw{$VERSION @ISA *_PARENT};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Node';
  	*_PARENT = *PPI::Element::_PARENT;
  }
  
  use PPI::Structure::Block       ();
  use PPI::Structure::Condition   ();
  use PPI::Structure::Constructor ();
  use PPI::Structure::For         ();
  use PPI::Structure::Given       ();
  use PPI::Structure::List        ();
  use PPI::Structure::Subscript   ();
  use PPI::Structure::Unknown     ();
  use PPI::Structure::When        ();
  
  
  
  
  
  #####################################################################
  # Constructor
  
  sub new {
  	my $class = shift;
  	my $Token = PPI::Token::__LEXER__opens($_[0]) ? shift : return undef;
  
  	# Create the object
  	my $self = bless {
  		children => [],
  		start    => $Token,
  		}, $class;
  
  	# Set the start braces parent link
  	Scalar::Util::weaken(
  		$_PARENT{Scalar::Util::refaddr $Token} = $self
  	);
  
  	$self;
  }
  
  
  
  
  
  #####################################################################
  # PPI::Structure API methods
  
  =pod
  
  =head2 start
  
  For lack of better terminology (like "open" and "close") that has not
  already in use for some other more important purpose, the two individual
  braces for the structure are known within PPI as the "start" and "finish"
  braces (at least for method purposes).
  
  The C<start> method returns the start brace for the structure (i.e. the
  opening brace).
  
  Returns the brace as a L<PPI::Token::Structure> or C<undef> if the
  structure does not have a starting brace.
  
  Under normal parsing circumstances this should never occur, but may happen
  due to manipulation of the PDOM tree.
  
  =cut
  
  sub start  { $_[0]->{start}  }
  
  =pod
  
  =head2 finish
  
  The C<finish> method returns the finish brace for the structure (i.e. the
  closing brace).
  
  Returns the brace as a L<PPI::Token::Structure> or C<undef> if the
  structure does not have a finishing brace. This can be quite common if
  the document is not complete (for example, from an editor where the user
  may be halfway through typeing a subroutine).
  
  =cut
  
  sub finish { $_[0]->{finish} }
  
  =pod
  
  =head2 braces
  
  The C<braces> method is a utility method which returns the brace type,
  regardless of whether both or just one of the braces is defined.
  
  Returns one of the three strings C<'[]'>, C<'{}'>, or C<'()'>, or C<undef>
  on error (primarily not having a start brace, as mentioned above).
  
  =cut
  
  sub braces {
  	my $self = $_[0]->{start} ? shift : return undef;
  	return {
  		'[' => '[]',
  		'(' => '()',
  		'{' => '{}',
  	}->{ $self->{start}->{content} };
  }
  
  =pod
  
  =head1 complete
  
  The C<complete> method is a convenience method that returns true if
  the both braces are defined for the structure, or false if only one
  brace is defined.
  
  Unlike the top level C<complete> method which checks for completeness
  in depth, the structure complete method ONLY confirms completeness
  for the braces, and does not recurse downwards.
  
  =cut
  
  sub complete {
  	!! ($_[0]->{start} and $_[0]->{finish});
  }
  
  
  
  
  
  #####################################################################
  # PPI::Node overloaded methods
  
  # For us, the "elements" concept includes the brace tokens
  sub elements {
  	my $self = shift;
  
  	if ( wantarray ) {
  		# Return a list in array context
  		return ( $self->{start} || (), @{$self->{children}}, $self->{finish} || () );
  	} else {
  		# Return the number of elements in scalar context.
  		# This is memory-cheaper than creating another big array
  		return scalar(@{$self->{children}})
  			+ ($self->{start}  ? 1 : 0)
  			+ ($self->{finish} ? 1 : 0);
  	}
  }
  
  # For us, the first element is probably the opening brace
  sub first_element {
  	# Technically, if we have no children and no opening brace,
  	# then the first element is the closing brace.
  	$_[0]->{start} or $_[0]->{children}->[0] or $_[0]->{finish};
  }
  
  # For us, the last element is probably the closing brace
  sub last_element {
  	# Technically, if we have no children and no closing brace,
  	# then the last element is the opening brace
  	$_[0]->{finish} or $_[0]->{children}->[-1] or $_[0]->{start};
  }
  
  # Location is same as the start token, if any
  sub location {
  	my $self  = shift;
  	my $first = $self->first_element or return undef;
  	$first->location;
  }
  
  
  
  
  
  #####################################################################
  # PPI::Element overloaded methods
  
  # Get the full set of tokens, including start and finish
  sub tokens {
  	my $self = shift;
  	my @tokens = (
  		$self->{start}  || (),
  		$self->SUPER::tokens(@_),
  		$self->{finish} || (),
  		);
  	@tokens;
  }
  
  # Like the token method ->content, get our merged contents.
  # This will recurse downwards through everything
  ### Reimplement this using List::Utils stuff
  sub content {
  	my $self = shift;
  	my $content = $self->{start} ? $self->{start}->content : '';
  	foreach my $child ( @{$self->{children}} ) {
  		$content .= $child->content;
  	}
  	$content .= $self->{finish}->content if $self->{finish};
  	$content;
  }
  
  # Is the structure completed
  sub _complete {
  	!! ( defined $_[0]->{finish} );
  }
  
  # You can insert either another structure, or a token
  sub insert_before {
  	my $self    = shift;
  	my $Element = _INSTANCE(shift, 'PPI::Element') or return undef;
  	if ( $Element->isa('PPI::Structure') ) {
  		return $self->__insert_before($Element);
  	} elsif ( $Element->isa('PPI::Token') ) {
  		return $self->__insert_before($Element);
  	}
  	'';
  }
  
  # As above, you can insert either another structure, or a token
  sub insert_after {
  	my $self    = shift;
  	my $Element = _INSTANCE(shift, 'PPI::Element') or return undef;
  	if ( $Element->isa('PPI::Structure') ) {
  		return $self->__insert_after($Element);
  	} elsif ( $Element->isa('PPI::Token') ) {
  		return $self->__insert_after($Element);
  	}
  	'';
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STRUCTURE

$fatpacked{"PPI/Structure/Block.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_BLOCK';
  package PPI::Structure::Block;
  
  =pod
  
  =head1 NAME
  
  PPI::Structure::Block - Curly braces representing a code block
  
  =head1 SYNOPSIS
  
    sub foo { ... }
    
    grep { ... } @list;
    
    if ( condition ) {
        ...
    }
    
    LABEL: {
        ...
    }
  
  =head1 INHERITANCE
  
    PPI::Structure::Block
    isa PPI::Structure
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Structure::Block> is the class used for all curly braces that
  represent code blocks. This includes subroutines, compound statements
  and any other block braces.
  
  =head1 METHODS
  
  C<PPI::Structure::Block> has no methods beyond those provided by the
  standard L<PPI::Structure>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Structure ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Structure';
  }
  
  
  
  
  
  #####################################################################
  # PPI::Element Methods
  
  # This is a scope boundary
  sub scope() { 1 }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STRUCTURE_BLOCK

$fatpacked{"PPI/Structure/Condition.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_CONDITION';
  package PPI::Structure::Condition;
  
  =pod
  
  =head1 NAME
  
  PPI::Structure::Condition - Round braces for boolean context conditions
  
  =head1 SYNOPSIS
  
    if ( condition ) {
        ...
    }
    
    while ( condition ) {
        ...
    }
  
  =head1 INHERITANCE
  
    PPI::Structure::Condition
    isa PPI::Structure
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Structure::Condition> is the class used for all round braces
  that represent boolean contexts used in various conditions.
  
  =head1 METHODS
  
  C<PPI::Structure::Condition> has no methods beyond those provided by
  the standard L<PPI::Structure>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Structure ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Structure';
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STRUCTURE_CONDITION

$fatpacked{"PPI/Structure/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_CONSTRUCTOR';
  package PPI::Structure::Constructor;
  
  =pod
  
  =head1 NAME
  
  PPI::Structure::Constructor - Anonymous hash or array constructor
  
  =head1 SYNOPSIS
  
    my $array = [ 'foo', 'bar' ];
    my $hash  = { foo => 'bar' };
  
  =head1 INHERITANCE
  
    PPI::Structure::Constructor
    isa PPI::Structure
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Structure::Constructor> is the class used for anonymous C<ARRAY>
  reference of C<HASH> reference constructors.
  
  =head1 METHODS
  
  C<PPI::Structure::Constructor> has no methods beyond those provided by
  the standard L<PPI::Structure>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Structure ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Structure';
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STRUCTURE_CONSTRUCTOR

$fatpacked{"PPI/Structure/For.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_FOR';
  package PPI::Structure::For;
  
  =pod
  
  =head1 NAME
  
  PPI::Structure::For - Circular braces for a for expression
  
  =head1 SYNOPSIS
  
    for ( var $i = 0; $i < $max; $i++ ) {
        ...
    }
  
  =head1 INHERITANCE
  
    PPI::Structure::For
    isa PPI::Structure
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Structure::For> is the class used for circular braces that
  contain the three part C<for> expression.
  
  =head1 METHODS
  
  C<PPI::Structure::For> has no methods beyond those provided by the
  standard L<PPI::Structure>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Structure ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Structure';
  }
  
  # Highly special custom isa method that will continue to respond
  # positively to ->isa('PPI::Structure::ForLoop') but warns.
  my $has_warned = 0;
  sub isa {
  	if ( $_[1] and $_[1] eq 'PPI::Structure::ForLoop' ) {
  		unless ( $has_warned ) {
  			warn("PPI::Structure::ForLoop has been deprecated");
  			$has_warned = 1;
  		}
  		return 1;
  	}
  	return shift->SUPER::isa(@_);
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STRUCTURE_FOR

$fatpacked{"PPI/Structure/Given.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_GIVEN';
  package PPI::Structure::Given;
  
  =pod
  
  =head1 NAME
  
  PPI::Structure::Given - Circular braces for a switch statement
  
  =head1 SYNOPSIS
  
    given ( something ) {
        ...
    }
  
  =head1 INHERITANCE
  
    PPI::Structure::Given
    isa PPI::Structure
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Structure::Given> is the class used for circular braces that
  contain the thing to be matched in a switch statement.
  
  =head1 METHODS
  
  C<PPI::Structure::Given> has no methods beyond those provided by the
  standard L<PPI::Structure>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Structure ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Structure';
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STRUCTURE_GIVEN

$fatpacked{"PPI/Structure/List.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_LIST';
  package PPI::Structure::List;
  
  =pod
  
  =head1 NAME
  
  PPI::Structure::List - Explicit list or precedence ordering braces
  
  =head1 SYNOPSIS
  
    # A list used for params
    function( 'param', 'param' );
    
    # Explicit list
    return ( 'foo', 'bar' );
  
  =head1 INHERITANCE
  
    PPI::Structure::List
    isa PPI::Structure
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Structure::List> is the class used for circular braces that
  represent lists, and related.
  
  =head1 METHODS
  
  C<PPI::Structure::List> has no methods beyond those provided by the
  standard L<PPI::Structure>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use Carp           ();
  use PPI::Structure ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Structure';
  }
  
  # Highly special custom isa method that will continue to respond
  # positively to ->isa('PPI::Structure::ForLoop') but warns.
  my $has_warned = 0;
  sub isa {
  	if ( $_[1] and $_[1] eq 'PPI::Structure::ForLoop' ) {
  		if (
  			$_[0]->parent->isa('PPI::Statement::Compound')
  			and
  			$_[0]->parent->type =~ /^for/
  		) {
  			unless ( $has_warned ) {
  				local $Carp::CarpLevel = $Carp::CarpLevel + 1;
  				Carp::carp("PPI::Structure::ForLoop has been deprecated");
  				$has_warned = 1;
  			}
  			return 1;
  		}
  	}
  	return shift->SUPER::isa(@_);
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STRUCTURE_LIST

$fatpacked{"PPI/Structure/Subscript.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_SUBSCRIPT';
  package PPI::Structure::Subscript;
  
  =pod
  
  =head1 NAME
  
  PPI::Structure::Subscript - Braces that represent an array or hash subscript
  
  =head1 SYNOPSIS
  
    # The end braces for all of the following are subscripts
    $foo->[...]
    $foo[...]
    $foo{...}[...]
    $foo->{...}
    $foo{...}
    $foo[]{...}
  
  =head1 INHERITANCE
  
    PPI::Structure::Subscript
    isa PPI::Structure
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Structure::Subscript> is the class used for square and curly
  braces that specify one element of an array or hash (or a slice/subset
  of an array or hash)
  
  =head1 METHODS
  
  C<PPI::Structure::Subscript> has no methods beyond those provided by the
  standard L<PPI::Structure>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Structure ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Structure';
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STRUCTURE_SUBSCRIPT

$fatpacked{"PPI/Structure/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_UNKNOWN';
  package PPI::Structure::Unknown;
  
  =pod
  
  =head1 NAME
  
  PPI::Structure::Unknown - An unknown or unresolved brace structure
  
  =head1 INHERITANCE
  
    PPI::Structure::Unknown
    isa PPI::Structure
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Structure::Unknown> is class for braces whose type is unknown, or
  temporarily unknown.
  
  It primarily exists temporarily inside the lexer. Although some types of
  braces can be determined immediately at opening, there are a number of
  different brace types that can only be correctly identified after the
  braces are closed.
  
  A structure is typed as unknown during this period it is indeterminate.
  
  A C<PPI::Structure::Unknown> object should not B<ever> make it out of the
  lexer without being converted to it's final type. Any time you encounter
  this class in a PDOM tree it should be considered a bug and reported
  accordingly.
  
  =head1 METHODS
  
  C<PPI::Structure::Unknown> has no methods beyond those provided by the
  standard L<PPI::Structure>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Structure ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Structure';
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STRUCTURE_UNKNOWN

$fatpacked{"PPI/Structure/When.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_STRUCTURE_WHEN';
  package PPI::Structure::When;
  
  =pod
  
  =head1 NAME
  
  PPI::Structure::When - Circular braces for a when statement
  
  =head1 SYNOPSIS
  
    when ( something ) {
        ...
    }
  
  =head1 INHERITANCE
  
    PPI::Structure::When
    isa PPI::Structure
        isa PPI::Node
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Structure::When> is the class used for circular braces that
  contain the thing to be matched in a when statement.
  
  =head1 METHODS
  
  C<PPI::Structure::When> has no methods beyond those provided by the
  standard L<PPI::Structure>, L<PPI::Node> and L<PPI::Element> methods.
  
  =cut
  
  use strict;
  use PPI::Structure ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Structure';
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_STRUCTURE_WHEN

$fatpacked{"PPI/Token.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN';
  package PPI::Token;
  
  =pod
  
  =head1 NAME
  
  PPI::Token - A single token of Perl source code
  
  =head1 INHERITANCE
  
    PPI::Token
    isa PPI::Element
  
  =head1 DESCRIPTION
  
  C<PPI::Token> is the abstract base class for all Tokens. In PPI terms, a "Token" is
  a L<PPI::Element> that directly represents bytes of source code.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Params::Util   qw{_INSTANCE};
  use PPI::Element   ();
  use PPI::Exception ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Element';
  }
  
  # We don't load the abstracts, they are loaded
  # as part of the inheritance process.
  
  # Load the token classes
  use PPI::Token::BOM                   ();
  use PPI::Token::Whitespace            ();
  use PPI::Token::Comment               ();
  use PPI::Token::Pod                   ();
  use PPI::Token::Number                ();
  use PPI::Token::Number::Binary        ();
  use PPI::Token::Number::Octal         ();
  use PPI::Token::Number::Hex           ();
  use PPI::Token::Number::Float         ();
  use PPI::Token::Number::Exp           ();
  use PPI::Token::Number::Version       ();
  use PPI::Token::Word                  ();
  use PPI::Token::DashedWord            ();
  use PPI::Token::Symbol                ();
  use PPI::Token::ArrayIndex            ();
  use PPI::Token::Magic                 ();
  use PPI::Token::Quote::Single         ();
  use PPI::Token::Quote::Double         ();
  use PPI::Token::Quote::Literal        ();
  use PPI::Token::Quote::Interpolate    ();
  use PPI::Token::QuoteLike::Backtick   ();
  use PPI::Token::QuoteLike::Command    ();
  use PPI::Token::QuoteLike::Regexp     ();
  use PPI::Token::QuoteLike::Words      ();
  use PPI::Token::QuoteLike::Readline   ();
  use PPI::Token::Regexp::Match         ();
  use PPI::Token::Regexp::Substitute    ();
  use PPI::Token::Regexp::Transliterate ();
  use PPI::Token::Operator              ();
  use PPI::Token::Cast                  ();
  use PPI::Token::Structure             ();
  use PPI::Token::Label                 ();
  use PPI::Token::HereDoc               ();
  use PPI::Token::Separator             ();
  use PPI::Token::Data                  ();
  use PPI::Token::End                   ();
  use PPI::Token::Prototype             ();
  use PPI::Token::Attribute             ();
  use PPI::Token::Unknown               ();
  
  
  
  
  
  #####################################################################
  # Constructor and Related
  
  sub new {
  	bless { content => (defined $_[1] ? "$_[1]" : '') }, $_[0];
  }
  
  sub set_class {
  	my $self  = shift;
  	# @_ or throw Exception("No arguments to set_class");
  	my $class = substr( $_[0], 0, 12 ) eq 'PPI::Token::' ? shift : 'PPI::Token::' . shift;
  
  	# Find out if the current and new classes are complex
  	my $old_quote = (ref($self) =~ /\b(?:Quote|Regex)\b/o) ? 1 : 0;
  	my $new_quote = ($class =~ /\b(?:Quote|Regex)\b/o)     ? 1 : 0;
  
  	# No matter what happens, we will have to rebless
  	bless $self, $class;
  
  	# If we are changing to or from a Quote style token, we
  	# can't just rebless and need to do some extra thing
  	# Otherwise, we have done enough
  	return $class if ($old_quote - $new_quote) == 0;
  
  	# Make a new token from the old content, and overwrite the current
  	# token's attributes with the new token's attributes.
  	my $token = $class->new( $self->{content} );
  	%$self = %$token;
  
  	# Return the class as a convenience
  	return $class;
  }
  
  
  
  
  
  #####################################################################
  # PPI::Token Methods
  
  =pod
  
  =head2 set_content $string
  
  The C<set_content> method allows you to set/change the string that the
  C<PPI::Token> object represents.
  
  Returns the string you set the Token to
  
  =cut
  
  sub set_content {
  	$_[0]->{content} = $_[1];
  }
  
  =pod
  
  =head2 add_content $string
  
  The C<add_content> method allows you to add additional bytes of code
  to the end of the Token.
  
  Returns the new full string after the bytes have been added.
  
  =cut
  
  sub add_content { $_[0]->{content} .= $_[1] }
  
  =pod
  
  =head2 length
  
  The C<length> method returns the length of the string in a Token.
  
  =cut
  
  sub length { CORE::length($_[0]->{content}) }
  
  
  
  
  
  #####################################################################
  # Overloaded PPI::Element methods
  
  sub content {
  	$_[0]->{content};
  }
  
  # You can insert either a statement, or a non-significant token.
  sub insert_before {
  	my $self    = shift;
  	my $Element = _INSTANCE(shift, 'PPI::Element')  or return undef;
  	if ( $Element->isa('PPI::Structure') ) {
  		return $self->__insert_before($Element);
  	} elsif ( $Element->isa('PPI::Token') ) {
  		return $self->__insert_before($Element);
  	}
  	'';
  }
  
  # As above, you can insert a statement, or a non-significant token
  sub insert_after {
  	my $self    = shift;
  	my $Element = _INSTANCE(shift, 'PPI::Element') or return undef;
  	if ( $Element->isa('PPI::Structure') ) {
  		return $self->__insert_after($Element);
  	} elsif ( $Element->isa('PPI::Token') ) {
  		return $self->__insert_after($Element);
  	}
  	'';
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_line_start() { 1 }
  sub __TOKENIZER__on_line_end()   { 1 }
  sub __TOKENIZER__on_char()       { 'Unknown' }
  
  
  
  
  
  #####################################################################
  # Lexer Methods
  
  sub __LEXER__opens {
  	ref($_[0]) eq 'PPI::Token::Structure'
  	and
  	$_[0]->{content} =~ /(?:\(|\[|\{)/
  }
  
  sub __LEXER__closes {
  	ref($_[0]) eq 'PPI::Token::Structure'
  	and
  	$_[0]->{content} =~ /(?:\)|\]|\})/
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN

$fatpacked{"PPI/Token/ArrayIndex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_ARRAYINDEX';
  package PPI::Token::ArrayIndex;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::ArrayIndex - Token getting the last index for an array
  
  =head1 INHERITANCE
  
    PPI::Token::ArrayIndex
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::ArrayIndex> token represents an attempt to get the
  last index of an array, such as C<$#array>.
  
  =head1 METHODS
  
  There are no additional methods beyond those provided by the parent
  L<PPI::Token> and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $t = $_[1];
  
  	# Suck in till the end of the arrayindex
  	pos $t->{line} = $t->{line_cursor};
  	if ( $t->{line} =~ m/\G([\w:']+)/gc ) {
  		$t->{token}->{content} .= $1;
  		$t->{line_cursor} += length $1;
  	}
  
  	# End of token
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_ARRAYINDEX

$fatpacked{"PPI/Token/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_ATTRIBUTE';
  package PPI::Token::Attribute;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Attribute - A token for a subroutine attribute
  
  =head1 INHERITANCE
  
    PPI::Token::Attribute
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  In Perl, attributes are a relatively recent addition to the language.
  
  Given the code C< sub foo : bar(something) {} >, the C<bar(something)>
  part is the attribute.
  
  A C<PPI::Token::Attribute> token represents the entire of the attribute,
  as the braces and its contents are not parsed into the tree, and are
  treated by Perl (and thus by us) as a single string.
  
  =head1 METHODS
  
  This class provides some additional methods beyond those provided by its
  L<PPI::Token> and L<PPI::Element> parent classes.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  
  
  
  #####################################################################
  # PPI::Token::Attribute Methods
  
  =pod
  
  =head2 identifier
  
  The C<identifier> attribute returns the identifier part of the attribute.
  
  That is, for the attribute C<foo(bar)>, the C<identifier> method would
  return C<"foo">.
  
  =cut
  
  sub identifier {
  	my $self = shift;
  	$self->{content} =~ /^(.+?)\(/ ? $1 : $self->{content};
  }
  
  =pod
  
  =head2 parameters
  
  The C<parameters> method returns the parameter string for the attribute.
  
  That is, for the attribute C<foo(bar)>, the C<parameters> method would
  return C<"bar">.
  
  Returns the parameters as a string (including the null string C<''> for
  the case of an attribute such as C<foo()>.)
  
  Returns C<undef> if the attribute does not have parameters.
  
  =cut
  
  sub parameters {
  	my $self = shift;
  	$self->{content} =~ /\((.*)\)$/ ? $1 : undef;
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $class = shift;
  	my $t     = shift;
  	my $char  = substr( $t->{line}, $t->{line_cursor}, 1 );
  
  	# Unless this is a '(', we are finished.
  	unless ( $char eq '(' ) {
  		# Finalise and recheck
  		return $t->_finalize_token->__TOKENIZER__on_char( $t );
  	}
  
  	# This is a bar(...) style attribute.
  	# We are currently on the ( so scan in until the end.
  	# We finish on the character AFTER our end
  	my $string = $class->__TOKENIZER__scan_for_end( $t );
  	if ( ref $string ) {
  		# EOF
  		$t->{token}->{content} .= $$string;
  		$t->_finalize_token;
  		return 0;
  	}
  
  	# Found the end of the attribute
  	$t->{token}->{content} .= $string;
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  # Scan for a close braced, and take into account both escaping,
  # and open close bracket pairs in the string. When complete, the
  # method leaves the line cursor on the LAST character found.
  sub __TOKENIZER__scan_for_end {
  	my $t = $_[1];
  
  	# Loop as long as we can get new lines
  	my $string = '';
  	my $depth = 0;
  	while ( exists $t->{line} ) {
  		# Get the search area
  		pos $t->{line} = $t->{line_cursor};
  
  		# Look for a match
  		unless ( $t->{line} =~ /\G((?:\\.|[^()])*?[()])/gc ) {
  			# Load in the next line and push to first character
  			$string .= substr( $t->{line}, $t->{line_cursor} );
  			$t->_fill_line(1) or return \$string;
  			$t->{line_cursor} = 0;
  			next;
  		}
  
  		# Add to the string
  		$string .= $1;
  		$t->{line_cursor} += length $1;
  
  		# Alter the depth and continue if we aren't at the end
  		$depth += ($1 =~ /\($/) ? 1 : -1 and next;
  
  		# Found the end
  		return $string;
  	}
  
  	# Returning the string as a reference indicates EOF
  	\$string;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_ATTRIBUTE

$fatpacked{"PPI/Token/BOM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_BOM';
  package PPI::Token::BOM;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::BOM - Tokens representing Unicode byte order marks
  
  =head1 INHERITANCE
  
    PPI::Token::BOM
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  This is a special token in that it can only occur at the beginning of
  documents.  If a BOM byte mark occurs elsewhere in a file, it should
  be treated as L<PPI::Token::Whitespace>.  We recognize the byte order
  marks identified at this URL:
  L<http://www.unicode.org/faq/utf_bom.html#BOM>
  
      UTF-32, big-endian     00 00 FE FF
      UTF-32, little-endian  FF FE 00 00
      UTF-16, big-endian     FE FF
      UTF-16, little-endian  FF FE
      UTF-8                  EF BB BF
  
  Note that as of this writing, PPI only has support for UTF-8
  (namely, in POD and strings) and no support for UTF-16 or UTF-32.  We
  support the BOMs of the latter two for completeness only.
  
  The BOM is considered non-significant, like white space.
  
  =head1 METHODS
  
  There are no additional methods beyond those provided by the parent
  L<PPI::Token> and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  sub significant() { '' }
  
  
  
  
  
  #####################################################################
  # Parsing Methods
  
  my %bom_types = (
     "\x00\x00\xfe\xff" => 'UTF-32',
     "\xff\xfe\x00\x00" => 'UTF-32',
     "\xfe\xff"         => 'UTF-16',
     "\xff\xfe"         => 'UTF-16',
     "\xef\xbb\xbf"     => 'UTF-8',
  );
  
  sub __TOKENIZER__on_line_start {
  	my $t = $_[1];
  	$_ = $t->{line};
  
  	if (m/^(\x00\x00\xfe\xff |  # UTF-32, big-endian
  		\xff\xfe\x00\x00 |  # UTF-32, little-endian
  		\xfe\xff         |  # UTF-16, big-endian
  		\xff\xfe         |  # UTF-16, little-endian
  		\xef\xbb\xbf)       # UTF-8
  	    /xs) {
  	   my $bom = $1;
  
  	   if ($bom_types{$bom} ne 'UTF-8') {
  	      return $t->_error("$bom_types{$bom} is not supported");
  	   }
  
  	   $t->_new_token('BOM', $bom) or return undef;
  	   $t->{line_cursor} += length $bom;
  	}
  
  	# Continue just as if there was no BOM
  	$t->{class} = 'PPI::Token::Whitespace';
  	return $t->{class}->__TOKENIZER__on_line_start($t);
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module
  
  =head1 AUTHOR
  
  Chris Dolan E<lt>cdolan@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_BOM

$fatpacked{"PPI/Token/Cast.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_CAST';
  package PPI::Token::Cast;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Cast - A prefix which forces a value into a different context
  
  =head1 INHERITANCE
  
    PPI::Token::Cast
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  A "cast" in PPI terms is one of more characters used as a prefix which force
  a value into a different class or context.
  
  This includes referencing, dereferencing, and a few other minor cases.
  
  For expressions such as C<@$foo> or C<@{ $foo{bar} }> the C<@> in both cases
  represents a cast. In this case, an array dereference.
  
  =head1 METHODS
  
  There are no additional methods beyond those provided by the parent
  L<PPI::Token> and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  # A cast is either % @ $ or $#
  sub __TOKENIZER__on_char {
  	$_[1]->_finalize_token->__TOKENIZER__on_char( $_[1] );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_CAST

$fatpacked{"PPI/Token/Comment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_COMMENT';
  package PPI::Token::Comment;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Comment - A comment in Perl source code
  
  =head1 INHERITANCE
  
    PPI::Token::Comment
    isa PPI::Token
        isa PPI::Element
  
  =head1 SYNOPSIS
  
    # This is a PPI::Token::Comment
    
    print "Hello World!"; # So it this
    
    $string =~ s/ foo  # This, unfortunately, is not :(
          bar
    	/w;
  
  =head1 DESCRIPTION
  
  In PPI, comments are represented by C<PPI::Token::Comment> objects.
  
  These come in two flavours, line comment and inline comments.
  
  A C<line comment> is a comment that stands on its own line. These comments
  hold their own newline and whitespace (both leading and trailing) as part
  of the one C<PPI::Token::Comment> object.
  
  An inline comment is a comment that appears after some code, and
  continues to the end of the line. This does B<not> include whitespace,
  and the terminating newlines is considered a separate
  L<PPI::Token::Whitespace> token.
  
  This is largely a convenience, simplifying a lot of normal code relating
  to the common things people do with comments.
  
  Most commonly, it means when you C<prune> or C<delete> a comment, a line
  comment disappears taking the entire line with it, and an inline comment
  is removed from the inside of the line, allowing the newline to drop
  back onto the end of the code, as you would expect.
  
  It also means you can move comments around in blocks much more easily.
  
  For now, this is a suitably handy way to do things. However, I do reserve
  the right to change my mind on this one if it gets dangerously
  anachronistic somewhere down the line.
  
  =head1 METHODS
  
  Only very limited methods are available, beyond those provided by our
  parent L<PPI::Token> and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  ### XS -> PPI/XS.xs:_PPI_Token_Comment__significant 0.900+
  sub significant() { '' }
  
  # Most stuff goes through __TOKENIZER__commit.
  # This is such a rare case, do char at a time to keep the code small
  sub __TOKENIZER__on_char {
  	my $t = $_[1];
  
  	# Make sure not to include the trailing newline
  	if ( substr( $t->{line}, $t->{line_cursor}, 1 ) eq "\n" ) {
  		return $t->_finalize_token->__TOKENIZER__on_char( $t );
  	}
  
  	1;
  }
  
  sub __TOKENIZER__commit {
  	my $t = $_[1];
  
  	# Get the rest of the line
  	my $rest = substr( $t->{line}, $t->{line_cursor} );
  	if ( chomp $rest ) { # Include the newline separately
  		# Add the current token, and the newline
  		$t->_new_token('Comment', $rest);
  		$t->_new_token('Whitespace', "\n");
  	} else {
  		# Add this token only
  		$t->_new_token('Comment', $rest);
  	}
  
  	# Advance the line cursor to the end
  	$t->{line_cursor} = $t->{line_length} - 1;
  
  	0;
  }
  
  # Comments end at the end of the line
  sub __TOKENIZER__on_line_end {
  	$_[1]->_finalize_token if $_[1]->{token};
  	1;
  }
  
  =pod
  
  =head2 line
  
  The C<line> accessor returns true if the C<PPI::Token::Comment> is a
  line comment, or false if it is an inline comment.
  
  =cut
  
  sub line {
  	# Entire line comments have a newline at the end
  	$_[0]->{content} =~ /\n$/ ? 1 : 0;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_COMMENT

$fatpacked{"PPI/Token/DashedWord.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_DASHEDWORD';
  package PPI::Token::DashedWord;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::DashedWord - A dashed bareword token
  
  =head1 INHERITANCE
  
    PPI::Token::DashedWord
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  The "dashed bareword" token represents literal values like C<-foo>.
  
  NOTE: this class is currently unused.  All tokens that should be
  PPI::Token::DashedWords are just normal PPI::Token::Word instead.
  That actually makes sense, since there really is nothing special about
  this class except that dashed words cannot be subroutine names or
  keywords.  As such, this class may be removed from PPI in the future.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  =pod
  
  =head2 literal
  
  Returns the value of the dashed word as a string.  This differs from
  C<content> because C<-Foo'Bar> expands to C<-Foo::Bar>.
  
  =cut
  
  *literal = *PPI::Token::Word::literal;
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $t = $_[1];
  
  	# Suck to the end of the dashed bareword
  	pos $t->{line} = $t->{line_cursor};
  	if ( $t->{line} =~ m/\G(\w+)/gc ) {
  		$t->{token}->{content} .= $1;
  		$t->{line_cursor} += length $1;
  	}
  
  	# Are we a file test operator?
  	if ( $t->{token}->{content} =~ /^\-[rwxoRWXOezsfdlpSbctugkTBMAC]$/ ) {
  		# File test operator
  		$t->{class} = $t->{token}->set_class( 'Operator' );
  	} else {
  		# No, normal dashed bareword
  		$t->{class} = $t->{token}->set_class( 'Word' );
  	}
  
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_DASHEDWORD

$fatpacked{"PPI/Token/Data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_DATA';
  package PPI::Token::Data;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Data - The actual data in the __DATA__ section of a file
  
  =head1 INHERITANCE
  
    PPI::Token::Data
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Data> class is used to represent the actual data inside
  a file's C<__DATA__> section.
  
  One C<PPI::Token::Data> object is used to represent the entire of the data,
  primarily so that it can provide a convenient handle directly to the data.
  
  =head1 METHODS
  
  C<PPI::Token::Data> provides one method in addition to those provided by
  our parent L<PPI::Token> and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use IO::String ();
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  
  
  
  
  #####################################################################
  # Methods
  
  =pod
  
  =head2 handle
  
  The C<handle> method returns a L<IO::String> handle that allows you
  to do all the normal handle-y things to the contents of the __DATA__
  section of the file.
  
  Unlike in perl itself, this means you can also do things like C<print>
  new data onto the end of the __DATA__ section, or modify it with
  any other process that can accept an L<IO::Handle> as input or output.
  
  Returns an L<IO::String> object.
  
  =cut
  
  sub handle {
  	my $self = shift;
  	IO::String->new( \$self->{content} );
  }
  
  sub __TOKENIZER__on_line_start {
  	my ( $self, $t ) = @_;
  
  	# Add the line
  	if ( defined $t->{token} ) {
  		$t->{token}->{content} .= $t->{line};
  	}
  	else {
  		defined( $t->{token} = $t->{class}->new( $t->{line} ) ) or return undef;
  	}
  
  	return 0;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_DATA

$fatpacked{"PPI/Token/End.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_END';
  package PPI::Token::End;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::End - Completely useless content after the __END__ tag
  
  =head1 INHERITANCE
  
    PPI::Token::End
    isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  If you've read L<PPI::Token::Whitespace>, you should understand by now
  the concept of documents "floating in a sea of PPI::Token::Whitespace".
  
  Well it doesn't after the __END__ tag.
  
  Once you __END__, it's all over. Anything after that tag isn't even fit
  to be called whitespace. It just simply doesn't exist as far as perl
  (the interpreter) is concerned.
  
  That's not to say there isn't useful content. Most often people use
  the __END__ tag to hide POD content, so that perl never has to see it,
  and presumably providing some small speed up.
  
  That's fine. PPI likes POD. Any POD after the __END__ tag is parsed
  into valid L<PPI::Token::Pod> tags as normal. B<This> class, on the
  other hand, is for "what's after __END__ when it isn't POD". 
  
  Basically, the completely worthless bits of the file :)
  
  =head1 METHODS
  
  This class has no method beyond what is provided by its L<PPI::Token> and
  L<PPI::Element> parent classes.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  ### XS -> PPI/XS.xs:_PPI_Token_End__significant 0.900+
  sub significant() { '' }
  
  sub __TOKENIZER__on_char() { 1 }
  
  sub __TOKENIZER__on_line_start {
  	my $t = $_[1];
  
  	# Can we classify the entire line in one go
  	if ( $t->{line} =~ /^=(\w+)/ ) {
  		# A Pod tag... change to pod mode
  		$t->_new_token( 'Pod', $t->{line} );
  		unless ( $1 eq 'cut' ) {
  			# Normal start to pod
  			$t->{class} = 'PPI::Token::Pod';
  		}
  
  		# This is an error, but one we'll ignore
  		# Don't go into Pod mode, since =cut normally
  		# signals the end of Pod mode
  	} else {
  		if ( defined $t->{token} ) {
  			# Add to existing token
  			$t->{token}->{content} .= $t->{line};
  		} else {
  			$t->_new_token( 'End', $t->{line} );
  		}
  	}
  
  	0;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_END

$fatpacked{"PPI/Token/HereDoc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_HEREDOC';
  package PPI::Token::HereDoc;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::HereDoc - Token class for the here-doc
  
  =head1 INHERITANCE
  
    PPI::Token::HereDoc
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  Here-docs are incredibly handy when writing Perl, but incredibly tricky
  when parsing it, primarily because they don't follow the general flow of
  input.
  
  They jump ahead and nab lines directly off the input buffer. Whitespace
  and newlines may not matter in most Perl code, but they matter in here-docs.
  
  They are also tricky to store as an object. They look sort of like an
  operator and a string, but they don't act like it. And they have a second
  section that should be something like a separate token, but isn't because a
  string can span from above the here-doc content to below it.
  
  So when parsing, this is what we do.
  
  Firstly, the PPI::Token::HereDoc object, does not represent the C<<< << >>>
  operator, or the "END_FLAG", or the content, or even the terminator.
  
  It represents all of them at once.
  
  The token itself has only the declaration part as its "content".
  
    # This is what the content of a HereDoc token is
    <<FOO
    
    # Or this
    <<"FOO"
    
    # Or even this
    <<      'FOO'
  
  That is, the "operator", any whitespace separator, and the quoted or bare
  terminator. So when you call the C<content> method on a HereDoc token, you
  get '<< "FOO"'.
  
  As for the content and the terminator, when treated purely in "content" terms
  they do not exist.
  
  The content is made available with the C<heredoc> method, and the name of
  the terminator with the C<terminator> method.
  
  To make things work in the way you expect, PPI has to play some games
  when doing line/column location calculation for tokens, and also during
  the content parsing and generation processes.
  
  Documents cannot simply by recreated by stitching together the token
  contents, and involve a somewhat more expensive procedure, but the extra
  expense should be relatively negligible unless you are doing huge
  quantities of them.
  
  Please note that due to the immature nature of PPI in general, we expect
  C<HereDocs> to be a rich (bad) source of corner-case bugs for quite a while,
  but for the most part they should more or less DWYM.
  
  =head2 Comparison to other string types
  
  Although technically it can be considered a quote, for the time being
  C<HereDocs> are being treated as a completely separate C<Token> subclass,
  and will not be found in a search for L<PPI::Token::Quote> or
  L<PPI::Token::QuoteLike objects>.
  
  This may change in the future, with it most likely to end up under
  QuoteLike.
  
  =head1 METHODS
  
  Although it has the standard set of C<Token> methods, C<HereDoc> objects
  have a relatively large number of unique methods all of their own.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  
  
  
  
  #####################################################################
  # PPI::Token::HereDoc Methods
  
  =pod
  
  =head2 heredoc
  
  The C<heredoc> method is the authoritative method for accessing the contents
  of the C<HereDoc> object.
  
  It returns the contents of the here-doc as a list of newline-terminated
  strings. If called in scalar context, it returns the number of lines in
  the here-doc, B<excluding> the terminator line.
  
  =cut
  
  sub heredoc {
  	wantarray
  		? @{shift->{_heredoc}}
  		: scalar @{shift->{_heredoc}};
  }
  
  =pod
  
  =head2 terminator
  
  The C<terminator> method returns the name of the terminating string for the
  here-doc.
  
  Returns the terminating string as an unescaped string (in the rare case
  the terminator has an escaped quote in it).
  
  =cut
  
  sub terminator {
  	shift->{_terminator};
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  # Parse in the entire here-doc in one call
  sub __TOKENIZER__on_char {
  	my $t     = $_[1];
  
  	# We are currently located on the first char after the <<
  
  	# Handle the most common form first for simplicity and speed reasons
  	### FIXME - This regex, and this method in general, do not yet allow
  	### for the null here-doc, which terminates at the first
  	### empty line.
  	pos $t->{line} = $t->{line_cursor};
  	if ( $t->{line} !~ m/\G( \s* (?: "[^"]*" | '[^']*' | `[^`]*` | \\?\w+ ) )/gcx ) {
  		# Degenerate to a left-shift operation
  		$t->{token}->set_class('Operator');
  		return $t->_finalize_token->__TOKENIZER__on_char( $t );
  	}
  
  	# Add the rest of the token, work out what type it is,
  	# and suck in the content until the end.
  	my $token = $t->{token};
  	$token->{content} .= $1;
  	$t->{line_cursor} += length $1;
  
  	# Find the terminator, clean it up and determine
  	# the type of here-doc we are dealing with.
  	my $content = $token->{content};
  	if ( $content =~ /^\<\<(\w+)$/ ) {
  		# Bareword
  		$token->{_mode}       = 'interpolate';
  		$token->{_terminator} = $1;
  
  	} elsif ( $content =~ /^\<\<\s*\'(.*)\'$/ ) {
  		# ''-quoted literal
  		$token->{_mode}       = 'literal';
  		$token->{_terminator} = $1;
  		$token->{_terminator} =~ s/\\'/'/g;
  
  	} elsif ( $content =~ /^\<\<\s*\"(.*)\"$/ ) {
  		# ""-quoted literal
  		$token->{_mode}       = 'interpolate';
  		$token->{_terminator} = $1;
  		$token->{_terminator} =~ s/\\"/"/g;
  
  	} elsif ( $content =~ /^\<\<\s*\`(.*)\`$/ ) {
  		# ``-quoted command
  		$token->{_mode}       = 'command';
  		$token->{_terminator} = $1;
  		$token->{_terminator} =~ s/\\`/`/g;
  
  	} elsif ( $content =~ /^\<\<\\(\w+)$/ ) {
  		# Legacy forward-slashed bareword
  		$token->{_mode}       = 'literal';
  		$token->{_terminator} = $1;
  
  	} else {
  		# WTF?
  		return undef;
  	}
  
  	# Suck in the HEREDOC
  	$token->{_heredoc} = \my @heredoc;
  	my $terminator = $token->{_terminator} . "\n";
  	while ( defined( my $line = $t->_get_line ) ) {
  		if ( $line eq $terminator ) {
  			# Keep the actual termination line for consistency
  			# when we are re-assembling the file
  			$token->{_terminator_line} = $line;
  
  			# The HereDoc is now fully parsed
  			return $t->_finalize_token->__TOKENIZER__on_char( $t );
  		}
  
  		# Add the line
  		push @heredoc, $line;
  	}
  
  	# End of file.
  	# Error: Didn't reach end of here-doc before end of file.
  
  	# If the here-doc block is not empty, look at the last line to determine if
  	# the here-doc terminator is missing a newline (which Perl would fail to
  	# compile but is easy to detect) or if the here-doc block was just not
  	# terminated at all (which Perl would fail to compile as well).
  	$token->{_terminator_line} = undef;
  	if ( @heredoc and defined $heredoc[-1] ) {
  		# See PPI::Tokenizer, the algorithm there adds a space at the end of the
  		# document that we need to make sure we remove.
  		if ( $t->{source_eof_chop} ) {
  			chop $heredoc[-1];
  			$t->{source_eof_chop} = '';
  		}
  
  		# Check if the last line of the file matches the terminator without
  		# newline at the end. If so, remove it from the content and set it as
  		# the terminator line.
  		$token->{_terminator_line} = pop @heredoc
  		  if $heredoc[-1] eq $token->{_terminator};
  	}
  
  	# Set a hint for PPI::Document->serialize so it can
  	# inexpensively repair it if needed when writing back out.
  	$token->{_damaged} = 1;
  
  	# The HereDoc is not fully parsed
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Implement PPI::Token::Quote interface compatibility
  
  - Check CPAN for any use of the null here-doc or here-doc-in-s///e
  
  - Add support for the null here-doc
  
  - Add support for here-doc in s///e
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_HEREDOC

$fatpacked{"PPI/Token/Label.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_LABEL';
  package PPI::Token::Label;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Label - Token class for a statement label
  
  =head1 INHERITANCE
  
    PPI::Token::Label
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  A label is an identifier attached to a line or statements, to allow for
  various types of flow control. For example, a loop might have a label
  attached so that a C<last> or C<next> flow control statement can be used
  from multiple levels below to reference the loop directly.
  
  =head1 METHODS
  
  There are no additional methods beyond those provided by the parent
  L<PPI::Token> and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_LABEL

$fatpacked{"PPI/Token/Magic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_MAGIC';
  package PPI::Token::Magic;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Magic - Tokens representing magic variables
  
  =head1 INHERITANCE
  
    PPI::Token::Magic
    isa PPI::Token::Symbol
        isa PPI::Token
            isa PPI::Element
  
  =head1 SYNOPSIS
  
    # When we say magic variables, we mean these...
    $1   $2   $3   $4   $5   $6   $7   $8   $9
    $_   $&   $`   $'   $+   @+   %+   $*   $.    $/    $|
    $\   $"   $;   $%   $=   $-   @-   %-   $)    $#
    $~   $^   $:   $?   $!   %!   $@   $$   $<    $>
    $(   $0   $[   $]   @_   @*   $}   $,   $#+   $#-
    $^L  $^A  $^E  $^C  $^D  $^F  $^H
    $^I  $^M  $^N  $^O  $^P  $^R  $^S
    $^T  $^V  $^W  $^X  %^H
  
  =head1 DESCRIPTION
  
  C<PPI::Token::Magic> is a sub-class of L<PPI::Token::Symbol> which
  identifies the token as "magic variable", one of the strange and
  unusual variables that are connected to "things" behind the scenes.
  
  Some are extremely common, like C<$_>, and others you will quite
  probably never encounter in your Perl career.
  
  =head1 METHODS
  
  The class provides no additional methods, beyond those provided by
  L<PPI::Token::Symbol>, L<PPI::Token> and L<PPI::Element>.
  
  =cut
  
  use strict;
  use PPI::Token::Symbol ();
  use PPI::Token::Unknown ();
  
  use vars qw{$VERSION @ISA %magic};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token::Symbol';
  
  	# Magic variables taken from perlvar.
  	# Several things added separately to avoid warnings.
  	foreach ( qw{
  		$1 $2 $3 $4 $5 $6 $7 $8 $9
  		$_ $& $` $' $+ @+ %+ $* $. $/ $|
  		$\\ $" $; $% $= $- @- %- $)
  		$~ $^ $: $? $! %! $@ $$ $< $>
  		$( $0 $[ $] @_ @*
  
  		$^L $^A $^E $^C $^D $^F $^H
  		$^I $^M $^N $^O $^P $^R $^S
  		$^T $^V $^W $^X %^H
  
  		$::|
  	}, '$}', '$,', '$#', '$#+', '$#-' ) {
  		$magic{$_} = 1;
  	}
  }
  
  
  sub __TOKENIZER__on_char {
  	my $t = $_[1];
  
  	# $c is the candidate new content
  	my $c = $t->{token}->{content} . substr( $t->{line}, $t->{line_cursor}, 1 );
  
  	# Do a quick first test so we don't have to do more than this one.
  	# All of the tests below match this one, so it should provide a
  	# small speed up. This regex should be updated to match the inside
  	# tests if they are changed.
  	if ( $c =~ /^  \$  .*  [  \w  :  \$  \{  ]  $/x ) {
  
  		if ( $c =~ /^(\$(?:\_[\w:]|::))/ or $c =~ /^\$\'[\w]/ ) {
  			# If and only if we have $'\d, it is not a
  			# symbol. (this was apparently a conscious choice)
  			# Note that $::0 on the other hand is legal
  			if ( $c =~ /^\$\'\d$/ ) {
  				# In this case, we have a magic plus a digit.
  				# Save the CURRENT token, and rerun the on_char
  				return $t->_finalize_token->__TOKENIZER__on_char( $t );
  			}
  
  			# A symbol in the style $_foo or $::foo or $'foo.
  			# Overwrite the current token
  			$t->{class} = $t->{token}->set_class('Symbol');
  			return PPI::Token::Symbol->__TOKENIZER__on_char( $t );
  		}
  
  		if ( $c =~ /^\$\$\w/ ) {
  			# This is really a scalar dereference. ( $$foo )
  			# Add the current token as the cast...
  			$t->{token} = PPI::Token::Cast->new( '$' );
  			$t->_finalize_token;
  
  			# ... and create a new token for the symbol
  			return $t->_new_token( 'Symbol', '$' );
  		}
  
  		if ( $c eq '$${' ) {
  			# This _might_ be a dereference of one of the
  			# control-character symbols.
  			pos $t->{line} = $t->{line_cursor} + 1;
  			if ( $t->{line} =~ m/$PPI::Token::Unknown::CURLY_SYMBOL/gc ) {
  				# This is really a dereference. ( $${^_foo} )
  				# Add the current token as the cast...
  				$t->{token} = PPI::Token::Cast->new( '$' );
  				$t->_finalize_token;
  
  				# ... and create a new token for the symbol
  				return $t->_new_token( 'Magic', '$' );
  			}
  		}
  
  		if ( $c eq '$#$' or $c eq '$#{' ) {
  			# This is really an index dereferencing cast, although
  			# it has the same two chars as the magic variable $#.
  			$t->{class} = $t->{token}->set_class('Cast');
  			return $t->_finalize_token->__TOKENIZER__on_char( $t );
  		}
  
  		if ( $c =~ /^(\$\#)\w/ ) {
  			# This is really an array index thingy ( $#array )
  			$t->{token} = PPI::Token::ArrayIndex->new( "$1" );
  			return PPI::Token::ArrayIndex->__TOKENIZER__on_char( $t );
  		}
  
  		if ( $c =~ /^\$\^\w+$/o ) {
  			# It's an escaped char magic... maybe ( like $^M )
  			my $next = substr( $t->{line}, $t->{line_cursor}+1, 1 ); # Peek ahead
  			if ($magic{$c} && (!$next || $next !~ /\w/)) {
  				$t->{token}->{content} = $c;
  				$t->{line_cursor}++;
  			} else {
  				# Maybe it's a long magic variable like $^WIDE_SYSTEM_CALLS
  				return 1;
  			}
  		}
  
  		if ( $c =~ /^\$\#\{/ ) {
  			# The $# is actually a cast, and { is its block
  			# Add the current token as the cast...
  			$t->{token} = PPI::Token::Cast->new( '$#' );
  			$t->_finalize_token;
  
  			# ... and create a new token for the block
  			return $t->_new_token( 'Structure', '{' );
  		}
  	} elsif ($c =~ /^%\^/) {
  		return 1 if $c eq '%^';
  		# It's an escaped char magic... maybe ( like %^H )
  		if ($magic{$c}) {
  			$t->{token}->{content} = $c;
  			$t->{line_cursor}++;
  		} else {
  			# Back off, treat '%' as an operator
  			chop $t->{token}->{content};
  			bless $t->{token}, $t->{class} = 'PPI::Token::Operator';
  			$t->{line_cursor}--;
  		}
  	}
  
  	if ( $magic{$c} ) {
  		# $#+ and $#-
  		$t->{line_cursor} += length( $c ) - length( $t->{token}->{content} );
  		$t->{token}->{content} = $c;
  	} else {
  		pos $t->{line} = $t->{line_cursor};
  		if ( $t->{line} =~ m/($PPI::Token::Unknown::CURLY_SYMBOL)/gc ) {
  			# control character symbol (e.g. ${^MATCH})
  			$t->{token}->{content} .= $1;
  			$t->{line_cursor}      += length $1;
  		} elsif ( $c =~ /^\$\d+$/ and $t->{line} =~ /\G(\d+)/gc ) {
  			# Grab trailing digits of regex capture variables.
  			$t->{token}{content} .= $1;
  			$t->{line_cursor} += length $1;
  		}
  	}
  
  	# End the current magic token, and recheck
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  # Our version of canonical is plain simple
  sub canonical { $_[0]->content }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_MAGIC

$fatpacked{"PPI/Token/Number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER';
  package PPI::Token::Number;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Number - Token class for a number
  
  =head1 SYNOPSIS
  
    $n = 1234;       # decimal integer
    $n = 0b1110011;  # binary integer
    $n = 01234;      # octal integer
    $n = 0x1234;     # hexadecimal integer
    $n = 12.34e-56;  # exponential notation ( currently not working )
  
  =head1 INHERITANCE
  
    PPI::Token::Number
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Number> class is used for tokens that represent numbers,
  in the various types that Perl supports.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  =pod
  
  =head2 base
  
  The C<base> method is provided by all of the ::Number subclasses.
  This is 10 for decimal, 16 for hexadecimal, 2 for binary, etc.
  
  =cut
  
  sub base() { 10 }
  
  =pod
  
  =head2 literal
  
  Return the numeric value of this token.
  
  =cut
  
  sub literal {
  	return 0 + $_[0]->_literal;
  }
  
  sub _literal {
  	# De-sugar the string representation
  	my $self   = shift;
  	my $string = $self->content;
  	$string =~ s/^\+//;
  	$string =~ s/_//g;
  	return $string;
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $class = shift;
  	my $t     = shift;
  	my $char  = substr( $t->{line}, $t->{line_cursor}, 1 );
  
  	# Allow underscores straight through
  	return 1 if $char eq '_';
  
  	# Handle the conversion from an unknown to known type.
  	# The regex covers "potential" hex/bin/octal number.
  	my $token = $t->{token};
  	if ( $token->{content} =~ /^-?0_*$/ ) {
  		# This could be special
  		if ( $char eq 'x' || $char eq 'X' ) {
  			$t->{class} = $t->{token}->set_class( 'Number::Hex' );
  			return 1;
  		} elsif ( $char eq 'b' || $char eq 'B' ) {
  			$t->{class} = $t->{token}->set_class( 'Number::Binary' );
  			return 1;
  		} elsif ( $char =~ /\d/ ) {
  			# You cannot have 8s and 9s on octals
  			if ( $char eq '8' or $char eq '9' ) {
  				$token->{_error} = "Illegal character in octal number '$char'";
  			}
  			$t->{class} = $t->{token}->set_class( 'Number::Octal' );
  			return 1;
  		}
  	}
  
  	# Handle the easy case, integer or real.
  	return 1 if $char =~ /\d/o;
  
  	if ( $char eq '.' ) {
  		$t->{class} = $t->{token}->set_class( 'Number::Float' );
  		return 1;
  	}
  	if ( $char eq 'e' || $char eq 'E' ) {
  		$t->{class} = $t->{token}->set_class( 'Number::Exp' );
  		return 1;
  	}
  
  	# Doesn't fit a special case, or is after the end of the token
  	# End of token.
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  1;
  
  =pod
  
  =head1 CAVEATS
  
  Compared to Perl, the number tokenizer is too liberal about allowing
  underscores anywhere.  For example, the following is a syntax error in
  Perl, but is allowed in PPI:
  
     0_b10
  
  =head1 TO DO
  
  - Treat v-strings as binary strings or barewords, not as "base-256"
    numbers
  
  - Break out decimal integers into their own subclass?
  
  - Implement literal()
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_NUMBER

$fatpacked{"PPI/Token/Number/Binary.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_BINARY';
  package PPI::Token::Number::Binary;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Number::Binary - Token class for a binary number
  
  =head1 SYNOPSIS
  
    $n = 0b1110011;  # binary integer
  
  =head1 INHERITANCE
  
    PPI::Token::Number::Binary
    isa PPI::Token::Number
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Number::Binary> class is used for tokens that
  represent base-2 numbers.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Token::Number ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token::Number';
  }
  
  =pod
  
  =head2 base
  
  Returns the base for the number: 2.
  
  =cut
  
  sub base() { 2 }
  
  =pod
  
  =head2 literal
  
  Return the numeric value of this token.
  
  =cut
  
  sub literal {
  	my $self = shift;
  	return if $self->{_error};
  	my $str = $self->_literal;
  	my $neg = $str =~ s/^\-//;
  	$str =~ s/^0[bB]//;
  	my $val = 0;
  	for my $bit ( $str =~ m/(.)/g ) {
  		$val = $val * 2 + $bit;
  	}
  	return $neg ? -$val : $val;
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $class = shift;
  	my $t     = shift;
  	my $char  = substr( $t->{line}, $t->{line_cursor}, 1 );
  
  	# Allow underscores straight through
  	return 1 if $char eq '_';
  
  	if ( $char =~ /[\w\d]/ ) {
  		unless ( $char eq '1' or $char eq '0' ) {
  			# Add a warning if it contains non-binary chars
  			$t->{token}->{_error} = "Illegal character in binary number '$char'";
  		}
  		return 1;
  	}
  
  	# Doesn't fit a special case, or is after the end of the token
  	# End of token.
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Chris Dolan E<lt>cdolan@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2006 Chris Dolan.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_NUMBER_BINARY

$fatpacked{"PPI/Token/Number/Exp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_EXP';
  package PPI::Token::Number::Exp;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Number::Exp - Token class for an exponential notation number
  
  =head1 SYNOPSIS
  
    $n = 1.0e-2;
    $n = 1e+2;
  
  =head1 INHERITANCE
  
    PPI::Token::Number::Exp
    isa PPI::Token::Number::Float
        isa PPI::Token::Number
            isa PPI::Token
                isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Number::Exp> class is used for tokens that
  represent floating point numbers with exponential notation.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Token::Number::Float ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token::Number::Float';
  }
  
  =pod
  
  =head2 literal
  
  Return the numeric value of this token.
  
  =cut
  
  sub literal {
  	my $self = shift;
  	return if $self->{_error};
  	my ($mantissa, $exponent) = split m/e/i, $self->_literal;
  	my $neg = $mantissa =~ s/^\-//;
  	$mantissa =~ s/^\./0./;
  	$exponent =~ s/^\+//;
  
  	# This algorithm is reasonably close to the S_mulexp10()
  	# algorithm from the Perl source code, so it should arrive
  	# at the same answer as Perl most of the time.
  	my $negpow = 0;
  	if ($exponent < 0) {
  		$negpow = 1;
  		$exponent *= -1;
  	}
  
  	my $result = 1;
  	my $power = 10;
  	for (my $bit = 1; $exponent; $bit = $bit << 1) {
  		if ($exponent & $bit) {
  			$exponent = $exponent ^ $bit;
  			$result *= $power;
  		}
  		$power *= $power;
  	}
  
  	my $val = $neg ? 0 - $mantissa : $mantissa;
  	return $negpow ? $val / $result : $val * $result;
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $class = shift;
  	my $t     = shift;
  	my $char  = substr( $t->{line}, $t->{line_cursor}, 1 );
  
          # To get here, the token must have already encountered an 'E'
  
  	# Allow underscores straight through
  	return 1 if $char eq '_';
  
  	# Allow digits
  	return 1 if $char =~ /\d/o;
  
  	# Start of exponent is special
  	if ( $t->{token}->{content} =~ /e$/i ) {
  		# Allow leading +/- in exponent
  		return 1 if $char eq '-' || $char eq '+';
  
  		# Invalid character in exponent.  Recover
  		if ( $t->{token}->{content} =~ s/\.(e)$//i ) {
  			my $word = $1;
  			$t->{class} = $t->{token}->set_class('Number');
  			$t->_new_token('Operator', '.');
  			$t->_new_token('Word', $word);
  			return $t->{class}->__TOKENIZER__on_char( $t );
  		}
  		else {
  			$t->{token}->{_error} = "Illegal character in exponent '$char'";
  		}
  	}
  
  	# Doesn't fit a special case, or is after the end of the token
  	# End of token.
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Chris Dolan E<lt>cdolan@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2006 Chris Dolan.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_NUMBER_EXP

$fatpacked{"PPI/Token/Number/Float.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_FLOAT';
  package PPI::Token::Number::Float;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Number::Float - Token class for a floating-point number
  
  =head1 SYNOPSIS
  
    $n = 1.234;
  
  =head1 INHERITANCE
  
    PPI::Token::Number::Float
    isa PPI::Token::Number
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Number::Float> class is used for tokens that
  represent floating point numbers.  A float is identified by n decimal
  point.  Exponential notation (the C<e> or C<E>) is handled by the
  PPI::Token::Number::Exp class.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Token::Number ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token::Number';
  }
  
  =pod
  
  =head2 base
  
  Returns the base for the number: 10.
  
  =cut
  
  sub base() { 10 }
  
  =pod
  
  =head2 literal
  
  Return the numeric value of this token.
  
  =cut
  
  sub literal {
  	my $self = shift;
  	my $str = $self->_literal;
  	my $neg = $str =~ s/^\-//;
  	$str =~ s/^\./0./;
  	my $val = 0+$str;
  	return $neg ? -$val : $val;
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $class = shift;
  	my $t     = shift;
  	my $char  = substr( $t->{line}, $t->{line_cursor}, 1 );
  
  	# Allow underscores straight through
  	return 1 if $char eq '_';
  
  	# Allow digits
  	return 1 if $char =~ /\d/o;
  
  	# Is there a second decimal point?  Then version string or '..' operator
  	if ( $char eq '.' ) {
  		if ( $t->{token}->{content} =~ /\.$/ ) {
  			# We have a .., which is an operator.
  			# Take the . off the end of the token..
  			# and finish it, then make the .. operator.
  			chop $t->{token}->{content};
                          $t->{class} = $t->{token}->set_class( 'Number' );
  			$t->_new_token('Operator', '..');
  			return 0;
  		} elsif ( $t->{token}->{content} !~ /_/ ) {
  			# Underscore means not a Version, fall through to end token
  			$t->{class} = $t->{token}->set_class( 'Number::Version' );
  			return 1;
  		}
  	}
  
  	# perl seems to regard pretty much anything that's not strictly an exp num
  	# as float + stuff
  	my $char2 = substr $t->{line}, $t->{line_cursor}+1, 1;
  	if ("$char$char2" =~ /[eE][0-9+-]/) {
  		$t->{class} = $t->{token}->set_class( 'Number::Exp' );
  		return 1;
  	}
  
  	# Doesn't fit a special case, or is after the end of the token
  	# End of token.
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Chris Dolan E<lt>cdolan@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2006 Chris Dolan.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_NUMBER_FLOAT

$fatpacked{"PPI/Token/Number/Hex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_HEX';
  package PPI::Token::Number::Hex;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Number::Hex - Token class for a binary number
  
  =head1 SYNOPSIS
  
    $n = 0x1234;     # hexadecimal integer
  
  =head1 INHERITANCE
  
    PPI::Token::Number::Hex
    isa PPI::Token::Number
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Number::Hex> class is used for tokens that
  represent base-16 numbers.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Token::Number ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token::Number';
  }
  
  =pod
  
  =head2 base
  
  Returns the base for the number: 16.
  
  =cut
  
  sub base() { 16 }
  
  =pod
  
  =head2 literal
  
  Return the numeric value of this token.
  
  =cut
  
  sub literal {
  	my $self = shift;
  	my $str = $self->_literal;
  	my $neg = $str =~ s/^\-//;
  	my $val = hex lc( $str ); # lc for compatibility with perls before 5.14
  	return $neg ? -$val : $val;
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $class = shift;
  	my $t     = shift;
  	my $char  = substr( $t->{line}, $t->{line_cursor}, 1 );
  
  	# Allow underscores straight through
  	return 1 if $char eq '_';
  
  	if ( $char =~ /[[:xdigit:]]/ ) {
  		return 1;
  	}
  
  	# Doesn't fit a special case, or is after the end of the token
  	# End of token.
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Chris Dolan E<lt>cdolan@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2006 Chris Dolan.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_NUMBER_HEX

$fatpacked{"PPI/Token/Number/Octal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_OCTAL';
  package PPI::Token::Number::Octal;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Number::Octal - Token class for a binary number
  
  =head1 SYNOPSIS
  
    $n = 0777;      # octal integer
  
  =head1 INHERITANCE
  
    PPI::Token::Number::Octal
    isa PPI::Token::Number
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Number::Octal> class is used for tokens that
  represent base-8 numbers.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Token::Number ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token::Number';
  }
  
  =pod
  
  =head2 base
  
  Returns the base for the number: 8.
  
  =cut
  
  sub base() { 8 }
  
  =pod
  
  =head2 literal
  
  Return the numeric value of this token.
  
  =cut
  
  sub literal {
  	my $self = shift;
  	return if $self->{_error};
  	my $str = $self->_literal;
  	my $neg = $str =~ s/^\-//;
  	my $val = oct $str;
  	return $neg ? -$val : $val;
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $class = shift;
  	my $t     = shift;
  	my $char  = substr( $t->{line}, $t->{line_cursor}, 1 );
  
  	# Allow underscores straight through
  	return 1 if $char eq '_';
  
  	if ( $char =~ /\d/ ) {
  		# You cannot have 8s and 9s on octals
  		if ( $char eq '8' or $char eq '9' ) {
  			$t->{token}->{_error} = "Illegal character in octal number '$char'";
  		}
  		return 1;
  	}
  
  	# Doesn't fit a special case, or is after the end of the token
  	# End of token.
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Chris Dolan E<lt>cdolan@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2006 Chris Dolan.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_NUMBER_OCTAL

$fatpacked{"PPI/Token/Number/Version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_NUMBER_VERSION';
  package PPI::Token::Number::Version;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Number::Version - Token class for a byte-packed number
  
  =head1 SYNOPSIS
  
    $n = 1.1.0;
    $n = 127.0.0.1;
    $n = 10_000.10_000.10_000;
    $n = v1.2.3.4
  
  =head1 INHERITANCE
  
    PPI::Token::Number::Version
    isa PPI::Token::Number
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Number::Version> class is used for tokens that have
  multiple decimal points.  In truth, these aren't treated like numbers
  at all by Perl, but they look like numbers to a parser.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Token::Number ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token::Number';
  }
  
  =pod
  
  =head2 base
  
  Returns the base for the number: 256.
  
  =cut
  
  sub base() { 256 }
  
  =pod
  
  =head2 literal
  
  Return the numeric value of this token.
  
  =cut
  
  sub literal {
  	my $self    = shift;
  	my $content = $self->{content};
  	$content =~ s/^v//;
  	return join '', map { chr $_ } ( split /\./, $content );
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $class = shift;
  	my $t     = shift;
  	my $char  = substr( $t->{line}, $t->{line_cursor}, 1 );
  
  	# Allow digits
  	return 1 if $char =~ /\d/o;
  
  	# Is this a second decimal point in a row?  Then the '..' operator
  	if ( $char eq '.' ) {
  		if ( $t->{token}->{content} =~ /\.$/ ) {
  			# We have a .., which is an operator.
  			# Take the . off the end of the token..
  			# and finish it, then make the .. operator.
  			chop $t->{token}->{content};
  			$t->{class} = $t->{token}->set_class( 'Number::Float' );
  			$t->_new_token('Operator', '..');
  			return 0;
  		} else {
  			return 1;
  		}
  	}
  
  	# Doesn't fit a special case, or is after the end of the token
  	# End of token.
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  sub __TOKENIZER__commit {
  	my $t = $_[1];
  
  	# Capture the rest of the token
  	pos $t->{line} = $t->{line_cursor};
  	if ( $t->{line} !~ m/\G(v\d+(?:\.\d+)+|v\d+\b)/gc ) {
  		# This was not a v-string after all (it's a word)
  		return PPI::Token::Word->__TOKENIZER__commit($t);
  	}
  
  	my $content = $1;
  
  	# If there are no periods this could be a word starting with v\d
  	# Forced to be a word. Done.
  	return PPI::Token::Word->__TOKENIZER__commit($t)
  		if $content !~ /\./ and $t->__current_token_is_forced_word($content);
  
  	# This is a v-string
  	$t->{line_cursor} += length $content;
  	$t->_new_token( 'Number::Version', $content );
  	$t->_finalize_token->__TOKENIZER__on_char($t);
  }
  
  1;
  
  =pod
  
  =head1 BUGS
  
  - Does not handle leading minus sign correctly. Should translate to a DashedWord.
  See L<http://perlmonks.org/?node_id=574573>
  
    -95.0.1.0  --> "-_\000\cA\000"
    -96.0.1.0  --> Argument "`\0^A\0" isn't numeric in negation (-)
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Chris Dolan E<lt>cdolan@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2006 Chris Dolan.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_NUMBER_VERSION

$fatpacked{"PPI/Token/Operator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_OPERATOR';
  package PPI::Token::Operator;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Operator - Token class for operators
  
  =head1 INHERITANCE
  
    PPI::Token::Operator
    isa PPI::Token
        isa PPI::Element
  
  =head1 SYNOPSIS
  
    # This is the list of valid operators
    ++   --   **   !    ~    +    -
    =~   !~   *    /    %    x
    <<   >>   lt   gt   le   ge   cmp  ~~
    ==   !=   <=>  .    ..   ...  ,
    &    |    ^    &&   ||   //
    ?    :    **=  +=   -=   .=   *=   /=
    %=   x=   &=   |=   ^=   <<=  >>=  &&=
    ||=  //=  <    >    <=   >=   <>   =>   ->
    and  or   xor  not  eq   ne
  
  
  =head1 DESCRIPTION
  
  All operators in PPI are created as C<PPI::Token::Operator> objects,
  including the ones that may superficially look like a L<PPI::Token::Word>
  object.
  
  =head1 METHODS
  
  There are no additional methods beyond those provided by the parent
  L<PPI::Token> and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA %OPERATOR};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  
  	# Build the operator index
  	### NOTE - This is accessed several times explicitly
  	###        in PPI::Token::Word. Do not rename this
  	###        without also correcting them.
  	%OPERATOR = map { $_ => 1 } (
  		qw{
  		-> ++ -- ** ! ~ + -
  		=~ !~ * / % x . << >>
  		< > <= >= lt gt le ge
  		== != <=> eq ne cmp ~~
  		& | ^ && || // .. ...
  		? :
  		= **= += -= .= *= /= %= x= &= |= ^= <<= >>= &&= ||= //=
  		=> <>
  		and or xor not
  		}, ',' 	# Avoids "comma in qw{}" warning
  		);
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $t    = $_[1];
  	my $char = substr( $t->{line}, $t->{line_cursor}, 1 );
  
  	# Are we still an operator if we add the next character
  	my $content = $t->{token}->{content};
  	return 1 if $OPERATOR{ $content . $char };
  
  	# Handle the special case of a .1234 decimal number
  	if ( $content eq '.' ) {
  		if ( $char =~ /^[0-9]$/ ) {
  			# This is a decimal number
  			$t->{class} = $t->{token}->set_class('Number::Float');
  			return $t->{class}->__TOKENIZER__on_char( $t );
  		}
  	}
  
  	# Handle the special case if we might be a here-doc
  	if ( $content eq '<<' ) {
  		pos $t->{line} = $t->{line_cursor};
  		# Either <<FOO or << 'FOO' or <<\FOO
  		### Is the zero-width look-ahead assertion really
  		### supposed to be there?
  		if ( $t->{line} =~ m/\G(?: (?!\d)\w | \s*['"`] | \\\w ) /gcx ) {
  			# This is a here-doc.
  			# Change the class and move to the HereDoc's own __TOKENIZER__on_char method.
  			$t->{class} = $t->{token}->set_class('HereDoc');
  			return $t->{class}->__TOKENIZER__on_char( $t );
  		}
  	}
  
  	# Handle the special case of the null Readline
  	if ( $content eq '<>' ) {
  		$t->{class} = $t->{token}->set_class('QuoteLike::Readline');
  	}
  
  	# Finalize normally
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_OPERATOR

$fatpacked{"PPI/Token/Pod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_POD';
  package PPI::Token::Pod;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Pod - Sections of POD in Perl documents
  
  =head1 INHERITANCE
  
    PPI::Token::Pod
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  A single C<PPI::Token::Pod> object represents a complete section of POD
  documentation within a Perl document.
  
  =head1 METHODS
  
  This class provides some additional methods beyond those provided by its
  L<PPI::Token> and L<PPI::Element> parent classes.
  
  =cut
  
  use strict;
  use Params::Util qw{_INSTANCE};
  use PPI::Token   ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  
  
  
  
  #####################################################################
  # PPI::Token::Pod Methods
  
  =pod
  
  =head2 merge @podtokens
  
  The C<merge> constructor takes a number of C<PPI::Token::Pod> objects,
  and returns a new object that represents one combined POD block with
  the content of all of them.
  
  Returns a new C<PPI::Token::Pod> object, or C<undef> on error.
  
  =cut
  
  sub merge {
  	my $class = (! ref $_[0]) ? shift : return undef;
  
  	# Check there are no bad arguments
  	if ( grep { ! _INSTANCE($_, 'PPI::Token::Pod') } @_ ) {
  		return undef;
  	}
  
  	# Get the tokens, and extract the lines
  	my @content = ( map { [ $_->lines ] } @_ ) or return undef;
  
  	# Remove the leading =pod tags, trailing =cut tags, and any empty lines
  	# between them and the pod contents.
  	foreach my $pod ( @content ) {
  		# Leading =pod tag
  		if ( @$pod and $pod->[0] =~ /^=pod\b/o ) {
  			shift @$pod;
  		}
  
  		# Trailing =cut tag
  		if ( @$pod and $pod->[-1] =~ /^=cut\b/o ) {
  			pop @$pod;
  		}
  
  		# Leading and trailing empty lines
  		while ( @$pod and $pod->[0]  eq '' ) { shift @$pod }
  		while ( @$pod and $pod->[-1] eq '' ) { pop @$pod   }
  	}
  
  	# Remove any empty pod sections, and add the =pod and =cut tags
  	# for the merged pod back to it.
  	@content = ( [ '=pod' ], grep { @$_ } @content, [ '=cut' ] );
  
  	# Create the new object
  	$class->new( join "\n", map { join( "\n", @$_ ) . "\n" } @content );
  }
  
  =pod
  
  =head2 lines
  
  The C<lines> method takes the string of POD and breaks it into lines,
  returning them as a list.
  
  =cut
  
  sub lines {
  	split /(?:\015{1,2}\012|\015|\012)/, $_[0]->{content};
  }
  
  
  
  
  
  
  #####################################################################
  # PPI::Element Methods
  
  ### XS -> PPI/XS.xs:_PPI_Token_Pod__significant 0.900+
  sub significant() { '' }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_line_start {
  	my $t = $_[1];
  
  	# Add the line to the token first
  	$t->{token}->{content} .= $t->{line};
  
  	# Check the line to see if it is a =cut line
  	if ( $t->{line} =~ /^=(\w+)/ ) {
  		# End of the token
  		$t->_finalize_token if $1 eq 'cut';
  	}
  
  	0;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_POD

$fatpacked{"PPI/Token/Prototype.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_PROTOTYPE';
  package PPI::Token::Prototype;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Prototype - A subroutine prototype descriptor
  
  =head1 INHERITANCE
  
    PPI::Token::End
    isa PPI::Token
        isa PPI::Element
  
  =head1 SYNOPSIS
  
    sub ($@) prototype;
  
  =head1 DESCRIPTION
  
  Although it sort of looks like a list or condition, a subroutine
  prototype is a lot more like a string. Its job is to provide hints
  to the perl compiler on what type of arguments a particular subroutine
  expects, which the compiler uses to validate parameters at compile-time,
  and allows programmers to use the functions without explicit parameter
  parens.
  
  Due to the rise of OO Perl coding, which ignores these prototypes, they
  are most often used to allow for constant-like things, and to "extend"
  the language and create things that act like keywords and core functions.
  
    # Create something that acts like a constant
    sub MYCONSTANT () { 10 }
    
    # Create the "any" core-looking function
    sub any (&@) { ... }
    
    if ( any { $_->cute } @babies ) {
    	...
    }
  
  =head1 METHODS
  
  This class provides one additional method beyond those defined by the
  L<PPI::Token> and L<PPI::Element> parent classes.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  sub __TOKENIZER__on_char {
  	my $class = shift;
  	my $t     = shift;
  
  	# Suck in until we find the closing paren (or the end of line)
  	pos $t->{line} = $t->{line_cursor};
  	die "regex should always match" if $t->{line} !~ m/\G(.*?(?:\)|$))/gc;
  	$t->{token}->{content} .= $1;
  	$t->{line_cursor} += length $1;
  
  	# Shortcut if end of line
  	return 0 unless $1 =~ /\)$/;
  
  	# Found the closing paren
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  =pod
  
  =head2 prototype
  
  The C<prototype> accessor returns the actual prototype pattern, stripped
  of flanking parens and of all whitespace. This mirrors the behavior of
  the Perl C<prototype> builtin function.
  
  Note that stripping parens and whitespace means that the return of
  C<prototype> can be an empty string.
  
  =cut
  
  sub prototype {
  	my $self  = shift;
  	my $proto = $self->content;
  	$proto =~ s/(^\(|\)$|\s+)//g;
  	$proto;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_PROTOTYPE

$fatpacked{"PPI/Token/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE';
  package PPI::Token::Quote;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Quote - String quote abstract base class
  
  =head1 INHERITANCE
  
    PPI::Token::Quote
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Quote> class is never instantiated, and simply
  provides a common abstract base class for the four quote classes.
  In PPI, a "quote" is limited to only the quote-like things that
  themselves directly represent a string. (although this includes
  double quotes with interpolated elements inside them).
  
  The subclasses of C<PPI::Token::Quote> are:
  
  =over 2
  
  =item C<''> - L<PPI::Token::Quote::Single>
  
  =item C<q{}> - L<PPI::Token::Quote::Literal>
  
  =item C<""> - L<PPI::Token::Quote::Double>
  
  =item C<qq{}> - L<PPI::Token::Quote::Interpolate>
  
  =back
  
  The names are hopefully obvious enough not to have to explain what
  each class is here. See their respective pages for more details.
  
  Please note that although the here-doc B<does> represent a literal
  string, it is such a nasty piece of work that in L<PPI> it is given the
  honor of its own token class (L<PPI::Token::HereDoc>).
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  
  
  
  
  #####################################################################
  # PPI::Token::Quote Methods
  
  =pod
  
  =head2 string
  
  The C<string> method is provided by all four ::Quote classes. It won't
  get you the actual literal Perl value, but it will strip off the wrapping
  of the quotes.
  
    # The following all return foo from the ->string method
    'foo'
    "foo"
    q{foo}
    qq <foo>
  
  =cut
  
  #sub string {
  #	my $class = ref $_[0] || $_[0];
  #	die "$class does not implement method ->string";
  #}
  
  =pod
  
  =head2 literal
  
  The C<literal> method is provided by ::Quote::Literal and
  ::Quote::Single.  This returns the value of the string as Perl sees
  it: without the quote marks and with C<\\> and C<\'> resolved to C<\>
  and C<'>.
  
  The C<literal> method is not implemented by ::Quote::Double or
  ::Quote::Interpolate yet.
  
  =cut
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_QUOTE

$fatpacked{"PPI/Token/Quote/Double.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_DOUBLE';
  package PPI::Token::Quote::Double;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Quote::Double - A standard "double quote" token
  
  =head1 INHERITANCE
  
    PPI::Token::Quote::Double
    isa PPI::Token::Quote
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::Quote::Double> object represents a double-quoted
  interpolating string.
  
  The string is treated as a single entity, L<PPI> will not try to
  understand what is in the string during the parsing process.
  
  =head1 METHODS
  
  There are several methods available for C<PPI::Token::Quote::Double>, beyond
  those provided by the parent L<PPI::Token::Quote>, L<PPI::Token> and
  L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use Params::Util                     qw{_INSTANCE};
  use PPI::Token::Quote                ();
  use PPI::Token::_QuoteEngine::Simple ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Simple
  		PPI::Token::Quote
  	};
  }
  
  
  
  
  
  #####################################################################
  # PPI::Token::Quote::Double Methods
  
  =pod
  
  =head2 interpolations
  
  The interpolations method checks to see if the double quote actually
  contains any interpolated variables.
  
  Returns true if the string contains interpolations, or false if not.
  
  =cut
  
  # Upgrade: Return the interpolated substrings.
  # Upgrade: Returns parsed expressions.
  sub interpolations {
  	# Are there any unescaped $things in the string
  	!! ($_[0]->content =~ /(?<!\\)(?:\\\\)*[\$\@]/);
  }
  
  =pod
  
  =head2 simplify
  
  For various reasons, some people find themselves compelled to have
  their code in the simplest form possible.
  
  The C<simplify> method will, if possible, modify a simple double-quoted
  string token in place, turning it into the equivalent single-quoted
  string. If the token is modified, it is reblessed into the
  L<PPI::Token::Quote::Single> package.
  
  Because the length of the content is not changed, there is no need
  to call the document's C<flush_locations> method.
  
  The object itself is returned as a convenience.
  
  =cut
  
  sub simplify {
  	# This only works on EXACTLY this class
  	my $self = _INSTANCE(shift, 'PPI::Token::Quote::Double') or return undef;
  
  	# Don't bother if there are characters that could complicate things
  	my $content = $self->content;
  	my $value   = substr($content, 1, length($content) - 2);
  	return $self if $value =~ /[\\\$@\'\"]/;
  
  	# Change the token to a single string
  	$self->{content} = "'$value'";
  	bless $self, 'PPI::Token::Quote::Single';
  }
  
  
  
  
  
  
  
  #####################################################################
  # PPI::Token::Quote Methods
  
  sub string {
  	my $str = $_[0]->{content};
  	substr( $str, 1, length($str) - 2 );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_QUOTE_DOUBLE

$fatpacked{"PPI/Token/Quote/Interpolate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_INTERPOLATE';
  package PPI::Token::Quote::Interpolate;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Quote::Interpolate - The interpolation quote-like operator
  
  =head1 INHERITANCE
  
    PPI::Token::Quote::Interpolate
    isa PPI::Token::Quote
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::Quote::Interpolate> object represents a single
  interpolation quote-like operator, such as C<qq{$foo bar $baz}>.
  
  =head1 METHODS
  
  There are no methods available for C<PPI::Token::Quote::Interpolate>
  beyond those provided by the parent L<PPI::Token::Quote>, L<PPI::Token> and
  L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token::Quote ();
  use PPI::Token::_QuoteEngine::Full ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Full
  		PPI::Token::Quote
  	};
  }
  
  
  
  
  
  #####################################################################
  # PPI::Token::Quote Methods
  
  sub string {
  	my $self     = shift;
  	my @sections = $self->_sections;
  	my $str      = $sections[0];
  	substr( $self->{content}, $str->{position}, $str->{size} );	
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_QUOTE_INTERPOLATE

$fatpacked{"PPI/Token/Quote/Literal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_LITERAL';
  package PPI::Token::Quote::Literal;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Quote::Literal - The literal quote-like operator
  
  =head1 INHERITANCE
  
    PPI::Token::Quote::Literal
    isa PPI::Token::Quote
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::Quote::Literal> object represents a single literal
  quote-like operator, such as C<q{foo bar}>.
  
  =head1 METHODS
  
  There are no methods available for C<PPI::Token::Quote::Literal> beyond
  those provided by the parent L<PPI::Token::Quote>, L<PPI::Token> and
  L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token::Quote              ();
  use PPI::Token::_QuoteEngine::Full ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Full
  		PPI::Token::Quote
  	};
  }
  
  
  
  
  
  #####################################################################
  # PPI::Token::Quote Methods
  
  sub string {
  	my $self     = shift;
  	my @sections = $self->_sections;
  	my $str      = $sections[0];
  	substr( $self->{content}, $str->{position}, $str->{size} );	
  }
  
  
  # Use the same implementation as another module
  *literal = *PPI::Token::Quote::Single::literal;
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_QUOTE_LITERAL

$fatpacked{"PPI/Token/Quote/Single.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTE_SINGLE';
  package PPI::Token::Quote::Single;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Quote::Single - A 'single quote' token
  
  =head1 INHERITANCE
  
    PPI::Token::Quote::Single
    isa PPI::Token::Quote
        isa PPI::Token
            isa PPI::Element
  
  =head1 SYNOPSIS
  
    'This is a single quote'
    
    q{This is a literal, but NOT a single quote}
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::Quote::Single> object represents a single quoted string
  literal. 
  
  =head1 METHODS
  
  There are no methods available for C<PPI::Token::Quote::Single> beyond
  those provided by the parent L<PPI::Token::Quote>, L<PPI::Token> and
  L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token::Quote ();
  use PPI::Token::_QuoteEngine::Simple ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Simple
  		PPI::Token::Quote
  	};
  }
  
  
  
  
  
  #####################################################################
  # PPI::Token::Quote Methods
  
  sub string {
  	my $str = $_[0]->{content};
  	substr( $str, 1, length($str) - 2 );
  }
  
  
  my %UNESCAPE = (
  	"\\'"  => "'",
  	"\\\\" => "\\",
  );
  
  sub literal {
  	# Unescape \\ and \' ONLY
  	my $str = $_[0]->string;
  	$str =~ s/(\\.)/$UNESCAPE{$1} || $1/ge;
  	return $str;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_QUOTE_SINGLE

$fatpacked{"PPI/Token/QuoteLike.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE';
  package PPI::Token::QuoteLike;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::QuoteLike - Quote-like operator abstract base class
  
  =head1 INHERITANCE
  
    PPI::Token::QuoteLike
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::QuoteLike> class is never instantiated, and simply
  provides a common abstract base class for the five quote-like operator
  classes. In PPI, a "quote-like" is the set of quote-like things that
  exclude the string quotes and regular expressions.
  
  The subclasses of C<PPI::Token::QuoteLike> are:
  
  =over 2
  
  =item qw{} - L<PPI::Token::QuoteLike::Words>
  
  =item `` - L<PPI::Token::QuoteLike::Backtick>
  
  =item qx{} - L<PPI::Token::QuoteLike::Command>
  
  =item qr// - L<PPI::Token::QuoteLike::Regexp>
  
  =item <FOO> - L<PPI::Token::QuoteLike::Readline>
  
  =back
  
  The names are hopefully obvious enough not to have to explain what
  each class is. See their pages for more details.
  
  You may note that the backtick and command quote-like are treated
  separately, even though they do the same thing. This is intentional,
  as the inherit from and are processed by two different parts of the
  PPI's quote engine.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_QUOTELIKE

$fatpacked{"PPI/Token/QuoteLike/Backtick.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_BACKTICK';
  package PPI::Token::QuoteLike::Backtick;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::QuoteLike::Backtick - A `backticks` command token
  
  =head1 INHERITANCE
  
    PPI::Token::QuoteLike::Backtick
    isa PPI::Token::QuoteLike
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::QuoteLike::Backtick> object represents a command output
  capturing quote.
  
  =head1 METHODS
  
  There are no methods available for C<PPI::Token::QuoteLike::Backtick>
  beyond those provided by the parent L<PPI::Token::QuoteLike>, L<PPI::Token>
  and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token::QuoteLike            ();
  use PPI::Token::_QuoteEngine::Simple ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Simple
  		PPI::Token::QuoteLike
  	};
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_QUOTELIKE_BACKTICK

$fatpacked{"PPI/Token/QuoteLike/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_COMMAND';
  package PPI::Token::QuoteLike::Command;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::QuoteLike::Command - The command quote-like operator
  
  =head1 INHERITANCE
  
    PPI::Token::QuoteLike::Command
    isa PPI::Token::QuoteLike
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::QuoteLike::Command> object represents a command output
  capturing quote-like operator.
  
  =head1 METHODS
  
  There are no methods available for C<PPI::Token::QuoteLike::Command>
  beyond those provided by the parent L<PPI::Token::QuoteLike>, L<PPI::Token>
  and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token::QuoteLike          ();
  use PPI::Token::_QuoteEngine::Full ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Full
  		PPI::Token::QuoteLike
  	};
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_QUOTELIKE_COMMAND

$fatpacked{"PPI/Token/QuoteLike/Readline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_READLINE';
  package PPI::Token::QuoteLike::Readline;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::QuoteLike::Readline - The readline quote-like operator
  
  =head1 INHERITANCE
  
    PPI::Token::QuoteLike::Readline
    isa PPI::Token::QuoteLike
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<readline> quote-like operator is used to read either a single
  line from a file, or all the lines from a file, as follows.
  
    # Read in a single line
    $line = <FILE>;
    
    # From a scalar handle
    $line = <$filehandle>;
    
    # Read all the lines
    @lines = <FILE>;
  
  =head1 METHODS
  
  There are no methods available for C<PPI::Token::QuoteLike::Readline>
  beyond those provided by the parent L<PPI::Token::QuoteLike>, L<PPI::Token>
  and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token::QuoteLike          ();
  use PPI::Token::_QuoteEngine::Full ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Full
  		PPI::Token::QuoteLike
  	};
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_QUOTELIKE_READLINE

$fatpacked{"PPI/Token/QuoteLike/Regexp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_REGEXP';
  package PPI::Token::QuoteLike::Regexp;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::QuoteLike::Regexp - Regexp constructor quote-like operator
  
  =head1 INHERITANCE
  
    PPI::Token::QuoteLike::Regexp
    isa PPI::Token::QuoteLike
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::QuoteLike::Regexp> object represents the quote-like
  operator used to construct anonymous L<Regexp> objects, as follows.
  
    # Create a Regexp object for a module filename
    my $module = qr/\.pm$/;
  
  =head1 METHODS
  
  The following methods are provided by this class,
  beyond those provided by the parent L<PPI::Token::QuoteLike>,
  L<PPI::Token> and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token::QuoteLike          ();
  use PPI::Token::_QuoteEngine::Full ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Full
  		PPI::Token::QuoteLike
  	};
  }
  
  
  
  
  
  #####################################################################
  # PPI::Token::QuoteLike::Regexp Methods
  
  =pod
  
  =head2 get_match_string
  
  The C<get_match_string> method returns the portion of the string that
  will be compiled into the match portion of the regexp.
  
  =cut
  
  sub get_match_string {
  	return $_[0]->_section_content( 0 );
  }
  
  =pod
  
  =head2 get_substitute_string
  
  The C<get_substitute_string> method always returns C<undef>, since
  the C<qr{}> construction provides no substitution string. This method
  is provided for orthogonality with C<PPI::Token::Regexp>.
  
  =cut
  
  sub get_substitute_string {
  	return undef;
  }
  
  =pod
  
  =head2 get_modifiers
  
  The C<get_modifiers> method returns the modifiers that will be
  compiled into the regexp.
  
  =cut
  
  sub get_modifiers {
  	return $_[0]->_modifiers();
  }
  
  =pod
  
  =head2 get_delimiters
  
  The C<get_delimiters> method returns the delimiters of the string as an
  array. The first and only element is the delimiters of the string to be
  compiled into a match string.
  
  =cut
  
  sub get_delimiters {
  	return $_[0]->_delimiters();
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_QUOTELIKE_REGEXP

$fatpacked{"PPI/Token/QuoteLike/Words.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_QUOTELIKE_WORDS';
  package PPI::Token::QuoteLike::Words;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::QuoteLike::Words - Word list constructor quote-like operator
  
  =head1 INHERITANCE
  
    PPI::Token::QuoteLike::Words
    isa PPI::Token::QuoteLike
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::QuoteLike::Words> object represents a quote-like operator
  that acts as a constructor for a list of words.
  
    # Create a list for a significant chunk of the alphabet
    my @list = qw{a b c d e f g h i j k l};
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use PPI::Token::QuoteLike          ();
  use PPI::Token::_QuoteEngine::Full ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Full
  		PPI::Token::QuoteLike
  	};
  }
  
  =pod
  
  =head2 literal
  
  Returns the words contained as a list.  Note that this method does not check the
  context that the token is in; it always returns the list and not merely
  the last element if the token is in scalar context.
  
  =cut
  
  sub literal {
  	my ( $self ) = @_;
  
  	my $content = $self->_section_content(0);
  	return if !defined $content;
  
  	# Undo backslash escaping of '\', the left delimiter,
  	# and the right delimiter.  The right delimiter will
  	# only exist with paired delimiters: qw() qw[] qw<> qw{}.
  	my ( $left, $right ) = ( $self->_delimiters, '', '' );
  	$content =~ s/\\([\Q$left$right\\\E])/$1/g;
  
  	my @words = split ' ', $content;
  
  	return @words;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_QUOTELIKE_WORDS

$fatpacked{"PPI/Token/Regexp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP';
  package PPI::Token::Regexp;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Regexp - Regular expression abstract base class
  
  =head1 INHERITANCE
  
    PPI::Token::Regexp
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Regexp> class is never instantiated, and simply
  provides a common abstract base class for the three regular expression
  classes. These being:
  
  =over 2
  
  =item m// - L<PPI::Token::Regexp::Match>
  
  =item s/// - L<PPI::Token::Regexp::Substitute>
  
  =item tr/// - L<PPI::Token::Regexp::Transliterate>
  
  =back
  
  The names are hopefully obvious enough not to have to explain what
  each class is. See their pages for more details.
  
  To save some confusion, it's worth pointing out here that C<qr//> is
  B<not> a regular expression (which PPI takes to mean something that
  will actually examine or modify a string), but rather a quote-like
  operator that acts as a constructor for compiled L<Regexp> objects. 
  
  =head1 METHODS
  
  The following methods are inherited by this class' offspring:
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  
  
  
  
  #####################################################################
  # PPI::Token::Regexp Methods
  
  =pod
  
  =head2 get_match_string
  
  The C<get_match_string> method returns the portion of the regexp that
  performs the match.
  
  =cut
  
  sub get_match_string {
  	return $_[0]->_section_content( 0 );
  }
  
  =pod
  
  =head2 get_substitute_string
  
  The C<get_substitute_string> method returns the portion of the regexp
  that is substituted for the match, if any.  If the regexp does not
  substitute, C<undef> is returned.
  
  =cut
  
  sub get_substitute_string {
  	return $_[0]->_section_content( 1 );
  }
  
  =pod
  
  =head2 get_modifiers
  
  The C<get_modifiers> method returns the modifiers of the regexp.
  
  =cut
  
  sub get_modifiers {
  	return $_[0]->_modifiers();
  }
  
  =pod
  
  =head2 get_delimiters
  
  The C<get_delimiters> method returns the delimiters of the regexp as
  an array. The first element is the delimiters of the match string, and
  the second element (if any) is the delimiters of the substitute string
  (if any).
  
  =cut
  
  sub get_delimiters {
  	return $_[0]->_delimiters();
  }
  
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_REGEXP

$fatpacked{"PPI/Token/Regexp/Match.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP_MATCH';
  package PPI::Token::Regexp::Match;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Regexp::Match - A standard pattern match regex
  
  =head1 INHERITANCE
  
    PPI::Token::Regexp::Match
    isa PPI::Token::Regexp
        isa PPI::Token
            isa PPI::Element
  
  =head1 SYNOPSIS
  
    $text =~ m/match regexp/;
    $text =~ /match regexp/;
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::Regexp::Match> object represents a single match regular
  expression. Just to be doubly clear, here are things that are and
  B<aren't> considered a match regexp.
  
    # Is a match regexp
    /This is a match regexp/;
    m/Old McDonald had a farm/eieio;
    
    # These are NOT match regexp
    qr/This is a regexp quote-like operator/;
    s/This is a/replace regexp/;
  
  =head1 METHODS
  
  There are no methods available for C<PPI::Token::Regexp::Match> beyond
  those provided by the parent L<PPI::Token::Regexp>, L<PPI::Token> and
  L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token::Regexp             ();
  use PPI::Token::_QuoteEngine::Full ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Full
  		PPI::Token::Regexp
  	};
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_REGEXP_MATCH

$fatpacked{"PPI/Token/Regexp/Substitute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP_SUBSTITUTE';
  package PPI::Token::Regexp::Substitute;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Regexp::Substitute - A match and replace regular expression token
  
  =head1 INHERITANCE
  
    PPI::Token::Regexp::Substitute
    isa PPI::Token::Regexp
        isa PPI::Token
            isa PPI::Element
  
  =head1 SYNOPSIS
  
    $text =~ s/find/$replace/;
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::Regexp::Substitute> object represents a single substitution
  regular expression.
  
  =head1 METHODS
  
  There are no methods available for C<PPI::Token::Regexp::Substitute>
  beyond those provided by the parent L<PPI::Token::Regexp>, L<PPI::Token>
  and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token::Regexp             ();
  use PPI::Token::_QuoteEngine::Full ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Full
  		PPI::Token::Regexp
  	};
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_REGEXP_SUBSTITUTE

$fatpacked{"PPI/Token/Regexp/Transliterate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_REGEXP_TRANSLITERATE';
  package PPI::Token::Regexp::Transliterate;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Regexp::Transliterate - A transliteration regular expression token
  
  =head1 INHERITANCE
  
    PPI::Token::Regexp::Transliterate
    isa PPI::Token::Regexp
        isa PPI::Token
            isa PPI::Element
  
  =head1 SYNOPSIS
  
    $text =~ tr/abc/xyz/;
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::Regexp::Transliterate> object represents a single
  transliteration regular expression.
  
  I'm afraid you'll have to excuse the ridiculously long class name, but
  when push came to shove I ended up going for pedantically correct
  names for things (practically cut and paste from the various docs).
  
  =head1 METHODS
  
  There are no methods available for C<PPI::Token::Regexp::Transliterate>
  beyond those provided by the parent L<PPI::Token::Regexp>, L<PPI::Token>
  and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use PPI::Token::Regexp             ();
  use PPI::Token::_QuoteEngine::Full ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = qw{
  		PPI::Token::_QuoteEngine::Full
  		PPI::Token::Regexp
  	};
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_REGEXP_TRANSLITERATE

$fatpacked{"PPI/Token/Separator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_SEPARATOR';
  package PPI::Token::Separator;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Separator - The __DATA__ and __END__ tags
  
  =head1 INHERITANCE
  
    PPI::Token::Separator
    isa PPI::Token::Word
        isa PPI::Token
            isa PPI::Element
  
  =head1 DESCRIPTION
  
  Although superficially looking like a normal L<PPI::Token::Word> object,
  when the C<__DATA__> and C<__END__> compiler tags appear at the beginning of
  a line (on supposedly) their own line, these tags become file section
  separators.
  
  The indicate that the time for Perl code is over, and the rest of the
  file is dedicated to something else (data in the case of C<__DATA__>) or
  to nothing at all (in the case of C<__END__>).
  
  =head1 METHODS
  
  This class has no methods beyond what is provided by its
  L<PPI::Token::Word>, L<PPI::Token> and L<PPI::Element>
  parent classes.
  
  =cut
  
  use strict;
  use PPI::Token::Word ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token::Word';
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_SEPARATOR

$fatpacked{"PPI/Token/Structure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_STRUCTURE';
  package PPI::Token::Structure;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Structure - Token class for characters that define code structure
  
  =head1 INHERITANCE
  
    PPI::Token::Structure
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Structure> class is used for tokens that control the
  general tree structure or code.
  
  This consists of seven characters. These are the six brace characters from
  the "round", "curly" and "square" pairs, plus the semi-colon statement
  separator C<;>.
  
  =head1 METHODS
  
  This class has no methods beyond what is provided by its
  L<PPI::Token> and L<PPI::Element> parent classes.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  # Set the matching braces, done as an array
  # for slightly faster lookups.
  use vars qw{@MATCH @OPENS @CLOSES};
  BEGIN {
  	$MATCH[ord '{']  = '}';
  	$MATCH[ord '}']  = '{';
  	$MATCH[ord '[']  = ']';
  	$MATCH[ord ']']  = '[';
  	$MATCH[ord '(']  = ')';
  	$MATCH[ord ')']  = '(';
  
  	$OPENS[ord '{']  = 1;
  	$OPENS[ord '[']  = 1;
  	$OPENS[ord '(']  = 1;
  
  	$CLOSES[ord '}'] = 1;
  	$CLOSES[ord ']'] = 1;
  	$CLOSES[ord ')'] = 1;
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	# Structures are one character long, always.
  	# Finalize and process again.
  	$_[1]->_finalize_token->__TOKENIZER__on_char( $_[1] );
  }
  
  sub __TOKENIZER__commit {
  	my $t = $_[1];
  	$t->_new_token( 'Structure', substr( $t->{line}, $t->{line_cursor}, 1 ) );
  	$t->_finalize_token;
  	0;
  }
  
  
  
  
  
  #####################################################################
  # Lexer Methods
  
  # For a given brace, find its opposing pair
  sub __LEXER__opposite {
  	$MATCH[ord $_[0]->{content} ];
  }
  
  
  
  
  
  #####################################################################
  # PPI::Element Methods
  
  # There is a unusual situation in regards to "siblings".
  #
  # As an Element, braces sit outside the normal tree structure, and in
  # this context they NEVER have siblings.
  #
  # However, as tokens they DO have siblings.
  #
  # As such, we need special versions of _all_ of the sibling methods to
  # handle this.
  #
  # Statement terminators do not have these problems, and for them sibling
  # calls work as normal, and so they can just be passed upwards.
  
  sub next_sibling {
  	return $_[0]->SUPER::next_sibling if $_[0]->{content} eq ';';
  	return '';
  }
  
  sub snext_sibling {
  	return $_[0]->SUPER::snext_sibling if $_[0]->{content} eq ';';
  	return '';
  }
  
  sub previous_sibling {
  	return $_[0]->SUPER::previous_sibling if $_[0]->{content} eq ';';
  	return '';
  }
  
  sub sprevious_sibling {
  	return $_[0]->SUPER::sprevious_sibling if $_[0]->{content} eq ';';
  	return '';
  }
  
  sub next_token {
  	my $self = shift;
  	return $self->SUPER::next_token if $self->{content} eq ';';
  	my $structure = $self->parent or return '';
  
  	# If this is an opening brace, descend down into our parent
  	# structure, if it has children.
  	if ( $OPENS[ ord $self->{content} ] ) {
  		my $child = $structure->child(0);
  		if ( $child ) {
  			# Decend deeper, or return if it is a token
  			return $child->isa('PPI::Token') ? $child : $child->first_token;
  		} elsif ( $structure->finish ) {
  			# Empty structure, so next is closing brace
  			return $structure->finish;
  		}
  
  		# Anything that slips through to here is a structure
  		# with an opening brace, but no closing brace, so we
  		# just have to go with it, and continue as we would
  		# if we started with a closing brace.
  	}
  
  	# We can use the default implement, if we call it from the
  	# parent structure of the closing brace.
  	$structure->next_token;
  }
  
  sub previous_token {
  	my $self = shift;
  	return $self->SUPER::previous_token if $self->{content} eq ';';
  	my $structure = $self->parent or return '';
  
  	# If this is a closing brace, descend down into our parent
  	# structure, if it has children.
  	if ( $CLOSES[ ord $self->{content} ] ) {
  		my $child = $structure->child(-1);
  		if ( $child ) {
  			# Decend deeper, or return if it is a token
  			return $child->isa('PPI::Token') ? $child : $child->last_token;
  		} elsif ( $structure->start ) {
  			# Empty structure, so next is closing brace
  			return $structure->start;
  		}
  
  		# Anything that slips through to here is a structure
  		# with a closing brace, but no opening brace, so we
  		# just have to go with it, and continue as we would
  		# if we started with an opening brace.
  	}
  
  	# We can use the default implement, if we call it from the
  	# parent structure of the closing brace.
  	$structure->previous_token;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_STRUCTURE

$fatpacked{"PPI/Token/Symbol.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_SYMBOL';
  package PPI::Token::Symbol;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Symbol - A token class for variables and other symbols
  
  =head1 INHERITANCE
  
    PPI::Token::Symbol
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::Symbol> class is used to cover all tokens that represent
  variables and other things that start with a sigil.
  
  =head1 METHODS
  
  This class has several methods beyond what is provided by its
  L<PPI::Token> and L<PPI::Element> parent classes.
  
  Most methods are provided to help work out what the object is actually
  pointing at, rather than what it might appear to be pointing at.
  
  =cut
   
  use strict;
  use Params::Util qw{_INSTANCE};
  use PPI::Token   ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  
  
  
  
  #####################################################################
  # PPI::Token::Symbol Methods
  
  =pod
  
  =head2 canonical
  
  The C<canonical> method returns a normalized, canonical version of the
  symbol.
  
  For example, it converts C<$ ::foo'bar::baz> to C<$main::foo::bar::baz>.
  
  This does not fully resolve the symbol, but merely removes syntax
  variations.
  
  =cut
  
  sub canonical {
  	my $symbol = shift->content;
  	$symbol =~ s/\s+//;
  	$symbol =~ s/\'/::/g;
  	$symbol =~ s/(?<=[\$\@\%\&\*])::/main::/;
  	$symbol;
  }
  
  =pod
  
  =head2 symbol
  
  The C<symbol> method returns the ACTUAL symbol this token refers to.
  
  A token of C<$foo> might actually be referring to C<@foo>, if it is found
  in the form C<$foo[1]>.
  
  This method attempts to resolve these issues to determine the actual
  symbol.
  
  Returns the symbol as a string.
  
  =cut
  
  my %cast_which_trumps_braces = map { $_ => 1 } qw{ $ @ };
  
  sub symbol {
  	my $self   = shift;
  	my $symbol = $self->canonical;
  
  	# Immediately return the cases where it can't be anything else
  	my $type = substr( $symbol, 0, 1 );
  	return $symbol if $type eq '%';
  	return $symbol if $type eq '&';
  
  	# Unless the next significant Element is a structure, it's correct.
  	my $after  = $self->snext_sibling;
  	return $symbol unless _INSTANCE($after, 'PPI::Structure');
  
  	# Process the rest for cases where it might actually be something else
  	my $braces = $after->braces;
  	return $symbol unless defined $braces;
  	if ( $type eq '$' ) {
  
  		# If it is cast to '$' or '@', that trumps any braces
  		my $before = $self->sprevious_sibling;
  		return $symbol if $before &&
  			$before->isa( 'PPI::Token::Cast' ) &&
  			$cast_which_trumps_braces{ $before->content };
  
  		# Otherwise the braces rule
  		substr( $symbol, 0, 1, '@' ) if $braces eq '[]';
  		substr( $symbol, 0, 1, '%' ) if $braces eq '{}';
  
  	} elsif ( $type eq '@' ) {
  		substr( $symbol, 0, 1, '%' ) if $braces eq '{}';
  
  	}
  
  	$symbol;
  }
  
  =pod
  
  =head2 raw_type
  
  The C<raw_type> method returns the B<apparent> type of the symbol in the
  form of its sigil.
  
  Returns the sigil as a string.
  
  =cut
  
  sub raw_type {
  	substr( $_[0]->content, 0, 1 );
  }
  
  =pod
  
  =head2 symbol_type
  
  The C<symbol_type> method returns the B<actual> type of the symbol in the
  form of its sigil.
  
  Returns the sigil as a string.
  
  =cut
  
  sub symbol_type {
  	substr( $_[0]->symbol, 0, 1 );
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my $t = $_[1];
  
  	# Suck in till the end of the symbol
  	pos $t->{line} = $t->{line_cursor};
  	if ( $t->{line} =~ m/\G([\w:\']+)/gc ) {
  		$t->{token}->{content} .= $1;
  		$t->{line_cursor}      += length $1;
  	}
  
  	# Handle magic things
  	my $content = $t->{token}->{content};	
  	if ( $content eq '@_' or $content eq '$_' ) {
  		$t->{class} = $t->{token}->set_class( 'Magic' );
  		return $t->_finalize_token->__TOKENIZER__on_char( $t );
  	}
  
  	# Shortcut for most of the X:: symbols
  	if ( $content eq '$::' ) {
  		# May well be an alternate form of a Magic
  		my $nextchar = substr( $t->{line}, $t->{line_cursor}, 1 );
  		if ( $nextchar eq '|' ) {
  			$t->{token}->{content} .= $nextchar;
  			$t->{line_cursor}++;
  			$t->{class} = $t->{token}->set_class( 'Magic' );
  		}
  		return $t->_finalize_token->__TOKENIZER__on_char( $t );
  	}
  	if ( $content =~ /^[\$%*@&]::(?:[^\w]|$)/ ) {
  		my $current = substr( $content, 0, 3, '' );
  		$t->{token}->{content} = $current;
  		$t->{line_cursor} -= length( $content );
  		return $t->_finalize_token->__TOKENIZER__on_char( $t );
  	}
  	if ( $content =~ /^(?:\$|\@)\d+/ ) {
  		$t->{class} = $t->{token}->set_class( 'Magic' );
  		return $t->_finalize_token->__TOKENIZER__on_char( $t );
  	}
  
  	# Trim off anything we oversucked...
  	$content =~ /^(
  		[\$@%&*]
  		(?: : (?!:) | # Allow single-colon non-magic vars
  			(?: \w+ | \' (?!\d) \w+ | \:: \w+ )
  			(?:
  				# Allow both :: and ' in namespace separators
  				(?: \' (?!\d) \w+ | \:: \w+ )
  			)*
  			(?: :: )? # Technically a compiler-magic hash, but keep it here
  		)
  	)/x or return undef;
  	unless ( length $1 eq length $content ) {
  		$t->{line_cursor} += length($1) - length($content);
  		$t->{token}->{content} = $1;
  	}
  
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_SYMBOL

$fatpacked{"PPI/Token/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_UNKNOWN';
  package PPI::Token::Unknown;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Unknown - Token of unknown or as-yet undetermined type
  
  =head1 INHERITANCE
  
    PPI::Token::Unknown
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  Object of the type C<PPI::Token::Unknown> exist primarily inside the
  tokenizer, where they are temporarily brought into existing for a very
  short time to represent a token that could be one of a number of types.
  
  Generally, they only exist for a character or two, after which they are
  resolved and converted into the correct type. For an object of this type
  to survive the parsing process is considered a major bug.
  
  Please report any C<PPI::Token::Unknown> you encounter in a L<PPI::Document>
  object as a bug.
  
  =cut
  
  use strict;
  use PPI::Token     ();
  use PPI::Exception ();
  
  use vars qw{$VERSION @ISA $CURLY_SYMBOL};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  	$CURLY_SYMBOL = qr{\G\^[[:upper:]_]\w+\}};
  }
  
  
  
  
  
  #####################################################################
  # Tokenizer Methods
  
  sub __TOKENIZER__on_char {
  	my ( $self, $t ) = @_;                                 # Self and Tokenizer
  	my $c    = $t->{token}->{content};                     # Current token
  	my $char = substr( $t->{line}, $t->{line_cursor}, 1 ); # Current character
  
  	# Now, we split on the different values of the current content
  	if ( $c eq '*' ) {
  		# Is it a number?
  		if ( $char =~ /\d/ ) {
  			# bitwise operator
  			$t->{class} = $t->{token}->set_class( 'Operator' );
  			return $t->_finalize_token->__TOKENIZER__on_char( $t );
  		}
  
  		if ( $char =~ /[\w:]/ ) {
  			# Symbol (unless the thing before it is a number
  			my ( $prev ) = $t->_previous_significant_tokens(1);
  			if ( not $prev or not $prev->isa('PPI::Token::Number') ) {
  				$t->{class} = $t->{token}->set_class( 'Symbol' );
  				return 1;
  			}
  		}
  
  		if ( $char eq '{' ) {
  			# Get rest of line
  			pos $t->{line} = $t->{line_cursor} + 1;
  			if ( $t->{line} =~ m/$CURLY_SYMBOL/gc ) {
  				# control-character symbol (e.g. *{^_Foo})
  				$t->{class} = $t->{token}->set_class( 'Magic' );
  				return 1;
  			}
  		}
  
  		if ( $char eq '*' || $char eq '=' ) {
  			# Power operator '**' or mult-assign '*='
  			$t->{class} = $t->{token}->set_class( 'Operator' );
  			return 1;
  		}
  
  		return $self->_as_cast_or_op($t) if $self->_is_cast_or_op($char);
  
  		$t->{class} = $t->{token}->set_class( 'Operator' );
  		return $t->_finalize_token->__TOKENIZER__on_char( $t );
  
  
  
  	} elsif ( $c eq '$' ) {
  		if ( $char =~ /[a-z_]/i ) {
  			# Symbol
  			$t->{class} = $t->{token}->set_class( 'Symbol' );
  			return 1;
  		}
  
  		if ( $PPI::Token::Magic::magic{ $c . $char } ) {
  			# Magic variable
  			$t->{class} = $t->{token}->set_class( 'Magic' );
  			return 1;
  		}
  
  		if ( $char eq '{' ) {
  			# Get rest of line
  			pos $t->{line} = $t->{line_cursor} + 1;
  			if ( $t->{line} =~ m/$CURLY_SYMBOL/gc ) {
  				# control-character symbol (e.g. ${^MATCH})
  				$t->{class} = $t->{token}->set_class( 'Magic' );
  				return 1;
  			}
  		}
  
  		# Must be a cast
  		$t->{class} = $t->{token}->set_class( 'Cast' );
  		return $t->_finalize_token->__TOKENIZER__on_char( $t );
  
  
  
  	} elsif ( $c eq '@' ) {
  		if ( $char =~ /[\w:]/ ) {
  			# Symbol
  			$t->{class} = $t->{token}->set_class( 'Symbol' );
  			return 1;
  		}
  
  		if ( $PPI::Token::Magic::magic{ $c . $char } ) {
  			# Magic variable
  			$t->{class} = $t->{token}->set_class( 'Magic' );
  			return 1;
  		}
  
  		if ( $char eq '{' ) {
  			# Get rest of line
  			pos $t->{line} = $t->{line_cursor} + 1;
  			if ( $t->{line} =~ m/$CURLY_SYMBOL/gc ) {
  				# control-character symbol (e.g. @{^_Foo})
  				$t->{class} = $t->{token}->set_class( 'Magic' );
  				return 1;
  			}
  		}
  
  		# Must be a cast
  		$t->{class} = $t->{token}->set_class( 'Cast' );
  		return $t->_finalize_token->__TOKENIZER__on_char( $t );
  
  
  
  	} elsif ( $c eq '%' ) {
  		# Is it a number?
  		if ( $char =~ /\d/ ) {
  			# bitwise operator
  			$t->{class} = $t->{token}->set_class( 'Operator' );
  			return $t->_finalize_token->__TOKENIZER__on_char( $t );
  		}
  
  		# Is it a magic variable?
  		if ( $char eq '^' || $PPI::Token::Magic::magic{ $c . $char } ) {
  			$t->{class} = $t->{token}->set_class( 'Magic' );
  			return 1;
  		}
  
  		if ( $char =~ /[\w:]/ ) {
  			# Symbol (unless the thing before it is a number
  			my ( $prev ) = $t->_previous_significant_tokens(1);
  			if ( not $prev or not $prev->isa('PPI::Token::Number') ) {
  				$t->{class} = $t->{token}->set_class( 'Symbol' );
  				return 1;
  			}
  		}
  
  		if ( $char eq '{' ) {
  			# Get rest of line
  			pos $t->{line} = $t->{line_cursor} + 1;
  			if ( $t->{line} =~ m/$CURLY_SYMBOL/gc ) {
  				# control-character symbol (e.g. %{^_Foo})
  				$t->{class} = $t->{token}->set_class( 'Magic' );
  				return 1;
  			}
  		}
  
  		return $self->_as_cast_or_op($t) if $self->_is_cast_or_op($char);
  
  		# Probably the mod operator
  		$t->{class} = $t->{token}->set_class( 'Operator' );
  		return $t->{class}->__TOKENIZER__on_char( $t );
  
  
  
  	} elsif ( $c eq '&' ) {
  		# Is it a number?
  		if ( $char =~ /\d/ ) {
  			# bitwise operator
  			$t->{class} = $t->{token}->set_class( 'Operator' );
  			return $t->_finalize_token->__TOKENIZER__on_char( $t );
  		}
  
  		if ( $char =~ /[\w:]/ ) {
  			# Symbol (unless the thing before it is a number
  			my ( $prev ) = $t->_previous_significant_tokens(1);
  			if ( not $prev or not $prev->isa('PPI::Token::Number') ) {
  				$t->{class} = $t->{token}->set_class( 'Symbol' );
  				return 1;
  			}
  		}
  
  		return $self->_as_cast_or_op($t) if $self->_is_cast_or_op($char);
  
  		# Probably the binary and operator
  		$t->{class} = $t->{token}->set_class( 'Operator' );
  		return $t->{class}->__TOKENIZER__on_char( $t );
  
  
  
  	} elsif ( $c eq '-' ) {
  		if ( $char =~ /\d/o ) {
  			# Number
  			$t->{class} = $t->{token}->set_class( 'Number' );
  			return 1;
  		}
  
  		if ( $char eq '.' ) {
  			# Number::Float
  			$t->{class} = $t->{token}->set_class( 'Number::Float' );
  			return 1;
  		}
  
  		if ( $char =~ /[a-zA-Z]/ ) {
  			$t->{class} = $t->{token}->set_class( 'DashedWord' );
  			return 1;
  		}
  
  		# The numeric negative operator
  		$t->{class} = $t->{token}->set_class( 'Operator' );
  		return $t->{class}->__TOKENIZER__on_char( $t );
  
  
  
  	} elsif ( $c eq ':' ) {
  		if ( $char eq ':' ) {
  			# ::foo style bareword
  			$t->{class} = $t->{token}->set_class( 'Word' );
  			return 1;
  		}
  
  		# Now, : acts very very differently in different contexts.
  		# Mainly, we need to find out if this is a subroutine attribute.
  		# We'll leave a hint in the token to indicate that, if it is.
  		if ( $self->__TOKENIZER__is_an_attribute( $t ) ) {
  			# This : is an attribute indicator
  			$t->{class} = $t->{token}->set_class( 'Operator' );
  			$t->{token}->{_attribute} = 1;
  			return $t->_finalize_token->__TOKENIZER__on_char( $t );
  		}
  
  		# It MIGHT be a label, but it's probably the ?: trinary operator
  		$t->{class} = $t->{token}->set_class( 'Operator' );
  		return $t->{class}->__TOKENIZER__on_char( $t );
  	}
  
  	# erm...
  	PPI::Exception->throw('Unknown value in PPI::Token::Unknown token');
  }
  
  sub _is_cast_or_op {
  	my ( $self, $char ) = @_;
  	return 1 if $char eq '$';
  	return 1 if $char eq '@';
  	return 1 if $char eq '%';
  	return 1 if $char eq '*';
  	return 1 if $char eq '{';
  	return;
  }
  
  sub _as_cast_or_op {
  	my ( $self, $t ) = @_;
  	my $class = _cast_or_op( $t );
  	$t->{class} = $t->{token}->set_class( $class );
  	return $t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  sub _prev_significant_w_cursor {
  	my ( $tokens, $cursor, $extra_check ) = @_;
  	while ( $cursor >= 0 ) {
  		my $token = $tokens->[ $cursor-- ];
  		next if !$token->significant;
  		next if $extra_check and !$extra_check->($token);
  		return ( $token, $cursor );
  	}
  	return ( undef, $cursor );
  }
  
  # Operator/operand-sensitive, multiple or GLOB cast
  sub _cast_or_op {
  	my ( $t ) = @_;
  
  	my $tokens = $t->{tokens};
  	my $cursor = scalar( @$tokens ) - 1;
  	my $token;
  
  	( $token, $cursor ) = _prev_significant_w_cursor( $tokens, $cursor );
  	return 'Cast' if !$token;    # token was first in the document
  
  	if ( $token->isa( 'PPI::Token::Structure' ) and $token->content eq '}' ) {
  
  		# Scan the token stream backwards an arbitrarily long way,
  		# looking for the matching opening curly brace.
  		my $structure_depth = 1;
  		( $token, $cursor ) = _prev_significant_w_cursor(
  			$tokens, $cursor,
  			sub {
  				my ( $token ) = @_;
  				return if !$token->isa( 'PPI::Token::Structure' );
  				if ( $token eq '}' ) {
  					$structure_depth++;
  					return;
  				}
  				if ( $token eq '{' ) {
  					$structure_depth--;
  					return if $structure_depth;
  				}
  				return 1;
  			}
  		);
  		return 'Operator' if !$token;    # no matching '{', probably an unbalanced '}'
  
  		# Scan past any whitespace
  		( $token, $cursor ) = _prev_significant_w_cursor( $tokens, $cursor );
  		return 'Operator' if !$token;                             # Document began with what must be a hash constructor.
  		return 'Operator' if $token->isa( 'PPI::Token::Symbol' ); # subscript
  
  		my %meth_or_subscript_end = map { $_ => 1 } qw@ -> } ] @;
  		return 'Operator' if $meth_or_subscript_end{ $token->content };    # subscript
  
  		my $content = $token->content;
  		my $produces_or_wants_value =
  		  ( $token->isa( 'PPI::Token::Word' ) and ( $content eq 'do' or $content eq 'eval' ) );
  		return $produces_or_wants_value ? 'Operator' : 'Cast';
  	}
  
  	my %list_start_or_term_end = map { $_ => 1 } qw@ ; ( { [ @;
  	return 'Cast'
  	  if $token->isa( 'PPI::Token::Structure' ) and $list_start_or_term_end{ $token->content }
  	  or $token->isa( 'PPI::Token::Cast' )
  	  or $token->isa( 'PPI::Token::Operator' )
  	  or $token->isa( 'PPI::Token::Label' );
  
  	return 'Operator' if !$token->isa( 'PPI::Token::Word' );
  
  	( $token, $cursor ) = _prev_significant_w_cursor( $tokens, $cursor );
  	return 'Cast' if !$token || $token->content ne '->';
  
  	return 'Operator';
  }
  
  # Are we at a location where a ':' would indicate a subroutine attribute
  sub __TOKENIZER__is_an_attribute {
  	my $t      = $_[1]; # Tokenizer object
  	my @tokens = $t->_previous_significant_tokens(3);
  	my $p0     = $tokens[0];
  	return '' if not $p0;
  
  	# If we just had another attribute, we are also an attribute
  	return 1 if $p0->isa('PPI::Token::Attribute');
  
  	# If we just had a prototype, then we are an attribute
  	return 1 if $p0->isa('PPI::Token::Prototype');
  
  	# Other than that, we would need to have had a bareword
  	return '' unless $p0->isa('PPI::Token::Word');
  
  	# We could be an anonymous subroutine
  	if ( $p0->isa('PPI::Token::Word') and $p0->content eq 'sub' ) {
  		return 1;
  	}
  
  	# Or, we could be a named subroutine
  	my $p1 = $tokens[1];
  	my $p2 = $tokens[2];
  	if (
  		$p1
  		and
  		$p1->isa('PPI::Token::Word')
  		and
  		$p1->content eq 'sub'
  		and (
  			not $p2
  			or
  			$p2->isa('PPI::Token::Structure')
  			or (
  				$p2->isa('PPI::Token::Whitespace')
  				and
  				$p2->content eq ''
  			)
  		)
  	) {
  		return 1;
  	}
  
  	# We aren't an attribute
  	'';	
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_UNKNOWN

$fatpacked{"PPI/Token/Whitespace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_WHITESPACE';
  package PPI::Token::Whitespace;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Whitespace - Tokens representing ordinary white space
  
  =head1 INHERITANCE
  
    PPI::Token::Whitespace
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  As a full "round-trip" parser, PPI records every last byte in a
  file and ensure that it is included in the L<PPI::Document> object.
  
  This even includes whitespace. In fact, Perl documents are seen
  as "floating in a sea of whitespace", and thus any document will
  contain vast quantities of C<PPI::Token::Whitespace> objects.
  
  For the most part, you shouldn't notice them. Or at least, you
  shouldn't B<have> to notice them.
  
  This means doing things like consistently using the "S for significant"
  series of L<PPI::Node> and L<PPI::Element> methods to do things.
  
  If you want the nth child element, you should be using C<schild> rather
  than C<child>, and likewise C<snext_sibling>, C<sprevious_sibling>, and
  so on and so forth.
  
  =head1 METHODS
  
  Again, for the most part you should really B<not> need to do anything
  very significant with whitespace.
  
  But there are a couple of convenience methods provided, beyond those
  provided by the parent L<PPI::Token> and L<PPI::Element> classes.
  
  =cut
  
  use strict;
  use Clone      ();
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  }
  
  =pod
  
  =head2 null
  
  Because L<PPI> sees documents as sitting on a sort of substrate made of
  whitespace, there are a couple of corner cases that get particularly
  nasty if they don't find whitespace in certain places.
  
  Imagine walking down the beach to go into the ocean, and then quite
  unexpectedly falling off the side of the planet. Well it's somewhat
  equivalent to that, including the whole screaming death bit.
  
  The C<null> method is a convenience provided to get some internals
  out of some of these corner cases.
  
  Specifically it create a whitespace token that represents nothing,
  or at least the null string C<''>. It's a handy way to have some
  "whitespace" right where you need it, without having to have any
  actual characters.
  
  =cut
  
  my $null;
  
  sub null {
  	$null ||= $_[0]->new('');
  	Clone::clone($null);
  }
  
  ### XS -> PPI/XS.xs:_PPI_Token_Whitespace__significant 0.900+
  sub significant() { '' }
  
  =pod
  
  =head2 tidy
  
  C<tidy> is a convenience method for removing unneeded whitespace.
  
  Specifically, it removes any whitespace from the end of a line.
  
  Note that this B<doesn't> include POD, where you may well need
  to keep certain types of whitespace. The entire POD chunk lives
  in its own L<PPI::Token::Pod> object.
  
  =cut
  
  sub tidy {
  	$_[0]->{content} =~ s/^\s+?(?>\n)//;
  	1;
  }
  
  
  
  
  
  #####################################################################
  # Parsing Methods
  
  # Build the class and commit maps
  use vars qw{ @CLASSMAP @COMMITMAP %MATCHWORD };
  BEGIN {
  	@CLASSMAP  = ();
  	@COMMITMAP = ();
  	foreach (
  		'a' .. 'u', 'w', 'y', 'z', 'A' .. 'Z', '_'
  	) {
  		$COMMITMAP[ord $_] = 'PPI::Token::Word';
  	}
  	foreach ( qw!; [ ] { } )! )       { $COMMITMAP[ord $_] = 'PPI::Token::Structure' }
  	foreach ( 0 .. 9 )                { $CLASSMAP[ord $_]  = 'Number'   }
  	foreach ( qw{= ? | + > . ! ~ ^} ) { $CLASSMAP[ord $_]  = 'Operator' }
  	foreach ( qw{* $ @ & : %} )       { $CLASSMAP[ord $_]  = 'Unknown'  }
  
  	# Miscellaneous remainder
  	$COMMITMAP[ord '#'] = 'PPI::Token::Comment';
  	$COMMITMAP[ord 'v'] = 'PPI::Token::Number::Version';
  	$CLASSMAP[ord ',']  = 'PPI::Token::Operator';
  	$CLASSMAP[ord "'"]  = 'Quote::Single';
  	$CLASSMAP[ord '"']  = 'Quote::Double';
  	$CLASSMAP[ord '`']  = 'QuoteLike::Backtick';
  	$CLASSMAP[ord '\\'] = 'Cast';
  	$CLASSMAP[ord '_']  = 'Word';
  	$CLASSMAP[9]        = 'Whitespace'; # A horizontal tab
  	$CLASSMAP[10]       = 'Whitespace'; # A newline
  	$CLASSMAP[12]       = 'Whitespace'; # A form feed
  	$CLASSMAP[13]       = 'Whitespace'; # A carriage return
  	$CLASSMAP[32]       = 'Whitespace'; # A normal space
  
  	# Words (functions and keywords) after which a following / is
  	# almost certainly going to be a regex
  	%MATCHWORD = map { $_ => 1 } qw{
  		return
  		split
  		if
  		unless
  		grep
  		map
  	};
  }
  
  
  sub __TOKENIZER__on_line_start {
  	my $t    = $_[1];
  	my $line = $t->{line};
  
  	# Can we classify the entire line in one go
  	if ( $line =~ /^\s*$/ ) {
  		# A whitespace line
  		$t->_new_token( 'Whitespace', $line );
  		return 0;
  
  	} elsif ( $line =~ /^\s*#/ ) {
  		# A comment line
  		$t->_new_token( 'Comment', $line );
  		$t->_finalize_token;
  		return 0;
  
  	} elsif ( $line =~ /^=(\w+)/ ) {
  		# A Pod tag... change to pod mode
  		$t->_new_token( 'Pod', $line );
  		if ( $1 eq 'cut' ) {
  			# This is an error, but one we'll ignore
  			# Don't go into Pod mode, since =cut normally
  			# signals the end of Pod mode
  		} else {
  			$t->{class} = 'PPI::Token::Pod';
  		}
  		return 0;
  
  	} elsif ( $line =~ /^use v6\-alpha\;/ ) {
  		# Indicates a Perl 6 block. Make the initial
  		# implementation just suck in the entire rest of the
  		# file.
  		my @perl6;
  		while ( 1 ) {
  			my $line6 = $t->_get_line;
  			last unless defined $line6;
  			push @perl6, $line6;
  		}
  		push @{ $t->{perl6} }, join '', @perl6;
  
  		# We only sucked in the block, we don't actually do
  		# anything to the "use v6..." line. So return as if
  		# we didn't find anything at all.
  		return 1;
  	}
  
  	1;
  }
  
  sub __TOKENIZER__on_char {
  	my $t    = $_[1];
  	my $c = substr $t->{line}, $t->{line_cursor}, 1;
  	my $char = ord $c;
  
  	# Do we definitely know what something is?
  	return $COMMITMAP[$char]->__TOKENIZER__commit($t) if $COMMITMAP[$char];
  
  	# Handle the simple option first
  	return $CLASSMAP[$char] if $CLASSMAP[$char];
  
  	if ( $char == 40 ) {  # $char eq '('
  		# Finalise any whitespace token...
  		$t->_finalize_token if $t->{token};
  
  		# Is this the beginning of a sub prototype?
  		# We are a sub prototype IF
  		# 1. The previous significant token is a bareword.
  		# 2. The one before that is the word 'sub'.
  		# 3. The one before that is a 'structure'
  
  		# Get the three previous significant tokens
  		my @tokens = $t->_previous_significant_tokens(3);
  
  		# A normal subroutine declaration
  		my $p1 = $tokens[1];
  		my $p2 = $tokens[2];
  		if (
  			$tokens[0]
  			and
  			$tokens[0]->isa('PPI::Token::Word')
  			and
  			$p1
  			and
  			$p1->isa('PPI::Token::Word')
  			and
  			$p1->content eq 'sub'
  			and (
  				not $p2
  				or
  				$p2->isa('PPI::Token::Structure')
  				or (
  					$p2->isa('PPI::Token::Whitespace')
  					and
  					$p2->content eq ''
  				)
  			)
  		) {
  			# This is a sub prototype
  			return 'Prototype';
  		}
  
  		# A prototyped anonymous subroutine
  		my $p0 = $tokens[0];
  		if ( $p0 and $p0->isa('PPI::Token::Word') and $p0->content eq 'sub'
  			# Maybe it's invoking a method named 'sub'
  			and not ( $p1 and $p1->isa('PPI::Token::Operator') and $p1->content eq '->')
  		) {
  			return 'Prototype';
  		}
  
  		# This is a normal open bracket
  		return 'Structure';
  
  	} elsif ( $char == 60 ) { # $char eq '<'
  		# Finalise any whitespace token...
  		$t->_finalize_token if $t->{token};
  
  		# This is either "less than" or "readline quote-like"
  		# Do some context stuff to guess which.
  		my $prev = $t->_last_significant_token;
  
  		# The most common group of less-thans are used like
  		# $foo < $bar
  		# 1 < $bar
  		# $#foo < $bar
  		return 'Operator' if $prev and $prev->isa('PPI::Token::Symbol');
  		return 'Operator' if $prev and $prev->isa('PPI::Token::Magic');
  		return 'Operator' if $prev and $prev->isa('PPI::Token::Number');
  		return 'Operator' if $prev and $prev->isa('PPI::Token::ArrayIndex');
  
  		# If it is <<... it's a here-doc instead
  		my $next_char = substr( $t->{line}, $t->{line_cursor} + 1, 1 );
  		if ( $next_char eq '<' ) {
  			return 'Operator';
  		}
  
  		return 'Operator' if not $prev;
  
  		# The most common group of readlines are used like
  		# while ( <...> )
  		# while <>;
  		my $prec = $prev->content;
  		if ( $prev->isa('PPI::Token::Structure') and $prec eq '(' ) {
  			return 'QuoteLike::Readline';
  		}
  		if ( $prev->isa('PPI::Token::Word') and $prec eq 'while' ) {
  			return 'QuoteLike::Readline';
  		}
  		if ( $prev->isa('PPI::Token::Operator') and $prec eq '=' ) {
  			return 'QuoteLike::Readline';
  		}
  		if ( $prev->isa('PPI::Token::Operator') and $prec eq ',' ) {
  			return 'QuoteLike::Readline';
  		}
  
  		if ( $prev->isa('PPI::Token::Structure') and $prec eq '}' ) {
  			# Could go either way... do a regex check
  			# $foo->{bar} < 2;
  			# grep { .. } <foo>;
  			pos $t->{line} = $t->{line_cursor};
  			if ( $t->{line} =~ m/\G<(?!\d)\w+>/gc ) {
  				# Almost definitely readline
  				return 'QuoteLike::Readline';
  			}
  		}
  
  		# Otherwise, we guess operator, which has been the default up
  		# until this more comprehensive section was created.
  		return 'Operator';
  
  	} elsif ( $char == 47 ) { #  $char eq '/'
  		# Finalise any whitespace token...
  		$t->_finalize_token if $t->{token};
  
  		# This is either a "divided by" or a "start regex"
  		# Do some context stuff to guess ( ack ) which.
  		# Hopefully the guess will be good enough.
  		my $prev = $t->_last_significant_token;
  
  		# Or as the very first thing in a file
  		return 'Regexp::Match' if not $prev;
  
  		my $prec = $prev->content;
  
  		# Most times following an operator, we are a regex.
  		# This includes cases such as:
  		# ,  - As an argument in a list 
  		# .. - The second condition in a flip flop
  		# =~ - A bound regex
  		# !~ - Ditto
  		return 'Regexp::Match' if $prev->isa('PPI::Token::Operator');
  
  		# After a symbol
  		return 'Operator' if $prev->isa('PPI::Token::Symbol');
  		if ( $prec eq ']' and $prev->isa('PPI::Token::Structure') ) {
  			return 'Operator';
  		}
  
  		# After another number
  		return 'Operator' if $prev->isa('PPI::Token::Number');
  
  		# After going into scope/brackets
  		if (
  			$prev->isa('PPI::Token::Structure')
  			and (
  				$prec eq '('
  				or
  				$prec eq '{'
  				or
  				$prec eq ';'
  			)
  		) {
  			return 'Regexp::Match';
  		}
  
  		# Functions and keywords
  		if (
  			$MATCHWORD{$prec}
  			and
  			$prev->isa('PPI::Token::Word')
  		) {
  			return 'Regexp::Match';
  		}
  
  		# What about the char after the slash? There's some things
  		# that would be highly illogical to see if it's an operator.
  		my $next_char = substr $t->{line}, $t->{line_cursor} + 1, 1;
  		if ( defined $next_char and length $next_char ) {
  			if ( $next_char =~ /(?:\^|\[|\\)/ ) {
  				return 'Regexp::Match';
  			}
  		}
  
  		# Otherwise... erm... assume operator?
  		# Add more tests here as potential cases come to light
  		return 'Operator';
  
  	} elsif ( $char == 120 ) { # $char eq 'x'
  		# Could be a word, the x= operator, the x operator
  		# followed by whitespace, or the x operator without any
  		# space between itself and its operand, e.g.: '$a x3',
  		# which is the same as '$a x 3'.  _current_x_is_operator
  		# assumes we have a complete 'x' token, but we don't
  		# yet.  We may need to split this x character apart from
  		# what follows it.
  		if ( $t->_current_x_is_operator ) {
  			pos $t->{line} = $t->{line_cursor} + 1;
  			return 'Operator' if $t->{line} =~ m/\G(?:
  				\d  # x op with no whitespace e.g. 'x3'
  				|
  				(?!(  # negative lookahead
  					=>  # not on left of fat comma
  					|
  					\w  # not a word like "xyzzy"
  					|
  					\s  # not x op plus whitespace
  				))
  			)/gcx;
  		}
  
  		# Otherwise, commit like a normal bareword, including x
  		# operator followed by whitespace.
  		return PPI::Token::Word->__TOKENIZER__commit($t);
  
  	} elsif ( $char == 45 ) { # $char eq '-'
  		# Look for an obvious operator operand context
  		my $context = $t->_opcontext;
  		if ( $context eq 'operator' ) {
  			return 'Operator';
  		} else {
  			# More logic needed
  			return 'Unknown';
  		}
  
  	} elsif ( $char >= 128 ) { # Outside ASCII
  		return 'PPI::Token::Word'->__TOKENIZER__commit($t) if $c =~ /\w/;
  		return 'Whitespace' if $c =~ /\s/;
  	}
  
  
  	# All the whitespaces are covered, so what to do
  	### For now, die
  	PPI::Exception->throw("Encountered unexpected character '$char'");
  }
  
  sub __TOKENIZER__on_line_end {
  	$_[1]->_finalize_token if $_[1]->{token};
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_WHITESPACE

$fatpacked{"PPI/Token/Word.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN_WORD';
  package PPI::Token::Word;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::Word - The generic "word" Token
  
  =head1 INHERITANCE
  
    PPI::Token::Word
    isa PPI::Token
        isa PPI::Element
  
  =head1 DESCRIPTION
  
  A C<PPI::Token::Word> object is a PPI-specific representation of several
  different types of word-like things, and is one of the most common Token
  classes found in typical documents.
  
  Specifically, it includes not only barewords, but also any other valid
  Perl identifier including non-operator keywords and core functions, and
  any include C<::> separators inside it, as long as it fits the
  format of a class, function, etc.
  
  =head1 METHODS
  
  There are no methods available for C<PPI::Token::Word> beyond those
  provided by its L<PPI::Token> and L<PPI::Element> parent
  classes.
  
  We expect to add additional methods to help further resolve a Word as
  a function, method, etc over time.  If you need such a thing right
  now, look at L<Perl::Critic::Utils>.
  
  =cut
  
  use strict;
  use PPI::Token ();
  
  use vars qw{$VERSION @ISA %OPERATOR %QUOTELIKE %KEYWORDS};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token';
  
  	# Copy in OPERATOR from PPI::Token::Operator
  	*OPERATOR  = *PPI::Token::Operator::OPERATOR;
  
  	%QUOTELIKE = (
  		'q'  => 'Quote::Literal',
  		'qq' => 'Quote::Interpolate',
  		'qx' => 'QuoteLike::Command',
  		'qw' => 'QuoteLike::Words',
  		'qr' => 'QuoteLike::Regexp',
  		'm'  => 'Regexp::Match',
  		's'  => 'Regexp::Substitute',
  		'tr' => 'Regexp::Transliterate',
  		'y'  => 'Regexp::Transliterate',
  	);
  
  	# List of keywords is from regen/keywords.pl in the perl source.
  	%KEYWORDS = map { $_ => 1 } qw{
  		abs accept alarm and atan2 bind binmode bless break caller chdir chmod
  		chomp chop chown chr chroot close closedir cmp connect continue cos
  		crypt dbmclose dbmopen default defined delete die do dump each else
  		elsif endgrent endhostent endnetent endprotoent endpwent endservent
  		eof eq eval evalbytes exec exists exit exp fc fcntl fileno flock for
  		foreach fork format formline ge getc getgrent getgrgid getgrnam
  		gethostbyaddr gethostbyname gethostent getlogin getnetbyaddr
  		getnetbyname getnetent getpeername getpgrp getppid getpriority
  		getprotobyname getprotobynumber getprotoent getpwent getpwnam
  		getpwuid getservbyname getservbyport getservent getsockname
  		getsockopt given glob gmtime goto grep gt hex if index int ioctl join
  		keys kill last lc lcfirst le length link listen local localtime lock
  		log lstat lt m map mkdir msgctl msgget msgrcv msgsnd my ne next no
  		not oct open opendir or ord our pack package pipe pop pos print
  		printf prototype push q qq qr quotemeta qw qx rand read readdir
  		readline readlink readpipe recv redo ref rename require reset return
  		reverse rewinddir rindex rmdir s say scalar seek seekdir select semctl
  		semget semop send setgrent sethostent setnetent setpgrp
  		setpriority setprotoent setpwent setservent setsockopt shift shmctl
  		shmget shmread shmwrite shutdown sin sleep socket socketpair sort
  		splice split sprintf sqrt srand stat state study sub substr symlink
  		syscall sysopen sysread sysseek system syswrite tell telldir tie tied
  		time times tr truncate uc ucfirst umask undef unless unlink unpack
  		unshift untie until use utime values vec wait waitpid wantarray warn
  		when while write x xor y
  	};
  }
  
  =pod
  
  =head2 literal
  
  Returns the value of the Word as a string.  This assumes (often
  incorrectly) that the Word is a bareword and not a function, method,
  keyword, etc.  This differs from C<content> because C<Foo'Bar> expands
  to C<Foo::Bar>.
  
  =cut
  
  sub literal {
  	my $self = shift;
  	my $word = $self->content;
  
  	# Expand Foo'Bar to Foo::Bar
  	$word =~ s/\'/::/g;
  
  	return $word;
  }
  
  =pod
  
  =head2 method_call
  
  Answers whether this is the name of a method in a method call. Returns true if
  yes, false if no, and nothing if unknown.
  
  =cut
  
  sub method_call {
  	my $self = shift;
  
  	my $previous = $self->sprevious_sibling;
  	if (
  		$previous
  		and
  		$previous->isa('PPI::Token::Operator')
  		and
  		$previous->content eq '->'
  	) {
  		return 1;
  	}
  
  	my $snext = $self->snext_sibling;
  	return 0 unless $snext;
  
  	if (
  		$snext->isa('PPI::Structure::List')
  		or
  		$snext->isa('PPI::Token::Structure')
  		or
  		$snext->isa('PPI::Token::Operator')
  		and (
  			$snext->content eq ','
  			or
  			$snext->content eq '=>'
  		)
  	) {
  		return 0;
  	}
  
  	if (
  		$snext->isa('PPI::Token::Word')
  		and
  		$snext->content =~ m< \w :: \z >xms
  	) {
  		return 1;
  	}
  
  	return;
  }
  
  
  sub __TOKENIZER__on_char {
  	my $class = shift;
  	my $t     = shift;
  
  	# Suck in till the end of the bareword
  	pos $t->{line} = $t->{line_cursor};
  	if ( $t->{line} =~ m/\G(\w+(?:(?:\'|::)\w+)*(?:::)?)/gc ) {
  		my $word = $1;
  		# Special Case: If we accidentally treat eq'foo' like
  		# the word "eq'foo", then just make 'eq' (or whatever
  		# else is in the %KEYWORDS hash.
  		if ( $word =~ /^(\w+)'/ && $KEYWORDS{$1} ) {
  		    $word = $1;
  		}
  		$t->{token}->{content} .= $word;
  		$t->{line_cursor} += length $word;
  
  	}
  
  	# We might be a subroutine attribute.
  	if ( __current_token_is_attribute($t) ) {
  		$t->{class} = $t->{token}->set_class( 'Attribute' );
  		return $t->{class}->__TOKENIZER__commit( $t );
  	}
  
  	my $word = $t->{token}->{content};
  	if ( $KEYWORDS{$word} ) {
  		# Check for a Perl keyword that is forced to be a normal word instead
  		if ( $t->__current_token_is_forced_word ) {
  			$t->{class} = $t->{token}->set_class( 'Word' );
  			return $t->{class}->__TOKENIZER__on_char( $t );
  		}
  
  		# Check for a quote like operator. %QUOTELIKE must be subset of %KEYWORDS
  		if ( $QUOTELIKE{$word} ) {
  			$t->{class} = $t->{token}->set_class( $QUOTELIKE{$word} );
  			return $t->{class}->__TOKENIZER__on_char( $t );
  		}
  
  		# Or one of the word operators. %OPERATOR must be subset of %KEYWORDS
  		if ( $OPERATOR{$word} ) {
  			$t->{class} = $t->{token}->set_class( 'Operator' );
  			return $t->_finalize_token->__TOKENIZER__on_char( $t );
  		}
  	}
  
  	# Unless this is a simple identifier, at this point
  	# it has to be a normal bareword
  	if ( $word =~ /\:/ ) {
  		return $t->_finalize_token->__TOKENIZER__on_char( $t );
  	}
  
  	# If the NEXT character in the line is a colon, this
  	# is a label.
  	my $char = substr( $t->{line}, $t->{line_cursor}, 1 );
  	if ( $char eq ':' ) {
  		$t->{token}->{content} .= ':';
  		$t->{line_cursor}++;
  		$t->{class} = $t->{token}->set_class( 'Label' );
  
  	# If not a label, '_' on its own is the magic filehandle
  	} elsif ( $word eq '_' ) {
  		$t->{class} = $t->{token}->set_class( 'Magic' );
  
  	}
  
  	# Finalise and process the character again
  	$t->_finalize_token->__TOKENIZER__on_char( $t );
  }
  
  
  
  # We are committed to being a bareword.
  # Or so we would like to believe.
  sub __TOKENIZER__commit {
  	my ($class, $t) = @_;
  
  	# Our current position is the first character of the bareword.
  	# Capture the bareword.
  	pos $t->{line} = $t->{line_cursor};
  	unless ( $t->{line} =~ m/\G((?!\d)\w+(?:(?:\'|::)\w+)*(?:::)?)/gc ) {
  		# Programmer error
  		die sprintf "Fatal error... regex failed to match in '%s' when expected", substr $t->{line}, $t->{line_cursor};
  	}
  
  	# Special Case: If we accidentally treat eq'foo' like the word "eq'foo",
  	# then unwind it and just make it 'eq' (or the other stringy comparitors)
  	my $word = $1;
  	if ( $word =~ /^(\w+)'/ && $KEYWORDS{$1} ) {
  	    $word = $1;
  	}
  
  	# Advance the position one after the end of the bareword
  	$t->{line_cursor} += length $word;
  
  	# We might be a subroutine attribute.
  	if ( __current_token_is_attribute($t) ) {
  		$t->_new_token( 'Attribute', $word );
  		return ($t->{line_cursor} >= $t->{line_length}) ? 0
  			: $t->{class}->__TOKENIZER__on_char($t);
  	}
  
  	# Check for the end of the file
  	if ( $word eq '__END__' ) {
  		# Create the token for the __END__ itself
  		$t->_new_token( 'Separator', $1 );
  		$t->_finalize_token;
  
  		# Move into the End zone (heh)
  		$t->{zone} = 'PPI::Token::End';
  
  		# Add the rest of the line as a comment, and a whitespace newline
  		# Anything after the __END__ on the line is "ignored". So we must
  		# also ignore it, by turning it into a comment.
  		my $end_rest = substr( $t->{line}, $t->{line_cursor} );
  		$t->{line_cursor} = length $t->{line};
  		if ( $end_rest =~ /\n$/ ) {
  			chomp $end_rest;
  			$t->_new_token( 'Comment', $end_rest ) if length $end_rest;
  			$t->_new_token( 'Whitespace', "\n" );
  		} else {
  			$t->_new_token( 'Comment', $end_rest ) if length $end_rest;
  		}
  		$t->_finalize_token;
  
  		return 0;
  	}
  
  	# Check for the data section
  	if ( $word eq '__DATA__' ) {
  		# Create the token for the __DATA__ itself
  		$t->_new_token( 'Separator', "$1" );
  		$t->_finalize_token;
  
  		# Move into the Data zone
  		$t->{zone} = 'PPI::Token::Data';
  
  		# Add the rest of the line as the Data token
  		my $data_rest = substr( $t->{line}, $t->{line_cursor} );
  		$t->{line_cursor} = length $t->{line};
  		if ( $data_rest =~ /\n$/ ) {
  			chomp $data_rest;
  			$t->_new_token( 'Comment', $data_rest ) if length $data_rest;
  			$t->_new_token( 'Whitespace', "\n" );
  		} else {
  			$t->_new_token( 'Comment', $data_rest ) if length $data_rest;
  		}
  		$t->_finalize_token;
  
  		return 0;
  	}
  
  	my $token_class;
  	if ( $word =~ /\:/ ) {
  		# Since it's not a simple identifier...
  		$token_class = 'Word';
  
  	} elsif ( $KEYWORDS{$word} and $t->__current_token_is_forced_word ) {
  		$token_class = 'Word';
  
  	} elsif ( $QUOTELIKE{$word} ) {
  		# Special Case: A Quote-like operator
  		$t->_new_token( $QUOTELIKE{$word}, $word );
  		return ($t->{line_cursor} >= $t->{line_length}) ? 0
  			: $t->{class}->__TOKENIZER__on_char( $t );
  
  	} elsif ( $OPERATOR{$word} && ($word ne 'x' || $t->_current_x_is_operator) ) {
  		# Word operator
  		$token_class = 'Operator';
  
  	} else {
  		# Get tokens early to be sure to not disturb state set up by pos and m//gc.
  		my @tokens = $t->_previous_significant_tokens(1);
  
  		# If the next character is a ':' then it's a label...
  		pos $t->{line} = $t->{line_cursor};
  		if ( $t->{line} =~ m/\G(\s*:)(?!:)/gc ) {
  			if ( $tokens[0] and $tokens[0]->{content} eq 'sub' ) {
  				# ... UNLESS it's after 'sub' in which
  				# case it is a sub name and an attribute
  				# operator.
  				# We COULD have checked this at the top
  				# level of checks, but this would impose
  				# an additional performance per-word
  				# penalty, and every other case where the
  				# attribute operator doesn't directly
  				# touch the object name already works.
  				$token_class = 'Word';
  			} else {
  				$word .= $1;
  				$t->{line_cursor} += length($1);
  				$token_class = 'Label';
  			}
  		} elsif ( $word eq '_' ) {
  			$token_class = 'Magic';
  		} else {
  			$token_class = 'Word';
  		}
  	}
  
  	# Create the new token and finalise
  	$t->_new_token( $token_class, $word );
  	if ( $t->{line_cursor} >= $t->{line_length} ) {
  		# End of the line
  		$t->_finalize_token;
  		return 0;
  	}
  	$t->_finalize_token->__TOKENIZER__on_char($t);
  }
  
  
  
  # Is the current Word really a subroutine attribute?
  sub __current_token_is_attribute {
  	my ( $t ) = @_;
  	my @tokens = $t->_previous_significant_tokens(1);
  	return (
  		$tokens[0]
  		and (
  			# hint from tokenizer
  			$tokens[0]->{_attribute}
  			# nothing between attribute and us except whitespace
  			or $tokens[0]->isa('PPI::Token::Attribute')
  		)
  	);
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Add C<function>, C<method> etc detector methods
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN_WORD

$fatpacked{"PPI/Token/_QuoteEngine.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN__QUOTEENGINE';
  package PPI::Token::_QuoteEngine;
  
  =pod
  
  =head1 NAME
  
  PPI::Token::_QuoteEngine - The PPI Quote Engine
  
  =head1 DESCRIPTION
  
  The C<PPI::Token::_QuoteEngine> package is designed hold functionality
  for processing quotes and quote like operators, including regexes.
  These have special requirements in parsing.
  
  The C<PPI::Token::_QuoteEngine> package itself provides various parsing
  methods, which the L<PPI::Token::Quote>, L<PPI::Token::QuoteLike> and
  L<PPI::Token::Regexp> can inherit from. In this sense, it serves
  as a base class.
  
  =head2 Using this class
  
  I<(Refers only to internal uses. This class does not provide a
  public interface)>
  
  To use these, you should initialize them as normal C<'$Class-E<gt>new'>,
  and then call the 'fill' method, which will cause the specialised
  parser to scan forwards and parse the quote to its end point.
  
  If -E<gt>fill returns true, finalise the token.
  
  =cut
  
  use strict;
  use Carp ();
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.236';
  }
  
  
  
  
  
  # Hook for the __TOKENIZER__on_char token call
  sub __TOKENIZER__on_char {
  	my $class = shift;
  	my $t     = $_[0]->{token} ? shift : return undef;
  
  	# Call the fill method to process the quote
  	my $rv = $t->{token}->_fill( $t );
  	return undef unless defined $rv;
  
  	## Doesn't support "end of file" indicator
  
  	# Finalize the token and return 0 to tell the tokenizer
  	# to go to the next character.
  	$t->_finalize_token;
  
  	0;
  }
  
  
  
  
  
  #####################################################################
  # Optimised character processors, used for quotes
  # and quote like stuff, and accessible to the child classes
  
  # An outright scan, raw and fast.
  # Searches for a particular character, not escaped, loading in new
  # lines as needed.
  # When called, we start at the current position.
  # When leaving, the position should be set to the position
  # of the character, NOT the one after it.
  sub _scan_for_unescaped_character {
  	my $class = shift;
  	my $t     = shift;
  	my $char  = (length $_[0] == 1) ? quotemeta shift : return undef;
  
  	# Create the search regex.
  	# Same as above but with a negative look-behind assertion.
  	my $search = qr/(.*?(?<!\\)(?:\\\\)*$char)/;
  
  	my $string = '';
  	while ( exists $t->{line} ) {
  		# Get the search area for the current line
  		pos $t->{line} = $t->{line_cursor};
  
  		# Can we find a match on this line
  		if ( $t->{line} =~ m/\G$search/gc ) {
  			# Found the character on this line
  			$t->{line_cursor} += length($1) - 1;
  			return $string . $1;
  		}
  
  		# Load in the next line
  		$string .= substr $t->{line}, $t->{line_cursor};
  		my $rv = $t->_fill_line('inscan');
  		if ( $rv ) {
  			# Push to first character
  			$t->{line_cursor} = 0;
  		} elsif ( defined $rv ) {
  			# We hit the End of File
  			return \$string;
  		} else {
  			# Unexpected error
  			return undef;
  		}
  	}
  
  	# We shouldn't be able to get here
  	return undef;
  }
  
  # Scan for a close braced, and take into account both escaping,
  # and open close bracket pairs in the string. When complete, the
  # method leaves the line cursor on the LAST character found.
  sub _scan_for_brace_character {
  	my $class       = shift;
  	my $t           = shift;
  	my $close_brace = $_[0] =~ /^(?:\>|\)|\}|\])$/ ? shift : Carp::confess(''); # return undef;
  	my $open_brace  = $close_brace;
  	$open_brace =~ tr/\>\)\}\]/\<\(\{\[/;
  
  	# Create the search string
  	$close_brace = quotemeta $close_brace;
  	$open_brace = quotemeta $open_brace;
  	my $search = qr/\G(.*?(?<!\\)(?:\\\\)*(?:$open_brace|$close_brace))/;
  
  	# Loop as long as we can get new lines
  	my $string = '';
  	my $depth = 1;
  	while ( exists $t->{line} ) {
  		# Get the search area
  		pos $t->{line} = $t->{line_cursor};
  
  		# Look for a match
  		unless ( $t->{line} =~ /$search/gc ) {
  			# Load in the next line
  			$string .= substr( $t->{line}, $t->{line_cursor} );
  			my $rv = $t->_fill_line('inscan');
  			if ( $rv ) {
  				# Push to first character
  				$t->{line_cursor} = 0;
  				next;
  			}
  			if ( defined $rv ) {
  				# We hit the End of File
  				return \$string;
  			}
  
  			# Unexpected error
  			return undef;
  		}
  
  		# Add to the string
  		$string .= $1;
  		$t->{line_cursor} += length $1;
  
  		# Alter the depth and continue if we aren't at the end
  		$depth += ($1 =~ /$open_brace$/) ? 1 : -1 and next;
  
  		# Rewind the cursor by one character ( cludgy hack )
  		$t->{line_cursor} -= 1;
  		return $string;
  	}
  
  	# Returning the string as a reference indicates EOF
  	\$string;
  }
  
  # Find all spaces and comments, up to, but not including
  # the first non-whitespace character.
  #
  # Although it doesn't return it, it leaves the cursor
  # on the character following the gap
  sub _scan_quote_like_operator_gap {
  	my $t = $_[1];
  
  	my $string = '';
  	while ( exists $t->{line} ) {
  		# Get the search area for the current line
  		pos $t->{line} = $t->{line_cursor};
  
  		# Since this regex can match zero characters, it should always match
  		$t->{line} =~ /\G(\s*(?:\#.*)?)/gc or return undef;
  
  		# Add the chars found to the string
  		$string .= $1;
  
  		# Did we match the entire line?
  		unless ( $t->{line_cursor} + length $1 == length $t->{line} ) {
  			# Partial line match, which means we are at
  			# the end of the gap. Fix the cursor and return
  			# the string.
  			$t->{line_cursor} += length $1;
  			return $string;
  		}
  
  		# Load in the next line.
  		# If we reach the EOF, $t->{line} gets deleted,
  		# which is caught by the while.
  		my $rv = $t->_fill_line('inscan');
  		if ( $rv ) {
  			# Set the cursor to the first character
  			$t->{line_cursor} = 0;
  		} elsif ( defined $rv ) {
  			# Returning the string as a reference indicates EOF
  			return \$string;
  		} else {
  			return undef;
  		}
  	}
  
  	# Shouldn't be able to get here
  	return undef;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN__QUOTEENGINE

$fatpacked{"PPI/Token/_QuoteEngine/Full.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN__QUOTEENGINE_FULL';
  package PPI::Token::_QuoteEngine::Full;
  
  # Full quote engine
  
  use strict;
  use Clone                    ();
  use Carp                     ();
  use PPI::Token::_QuoteEngine ();
  
  use vars qw{$VERSION @ISA %quotes %sections};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token::_QuoteEngine';
  
  	# Prototypes for the different braced sections
  	%sections = (
  		'(' => { type => '()', _close => ')' },
  		'<' => { type => '<>', _close => '>' },
  		'[' => { type => '[]', _close => ']' },
  		'{' => { type => '{}', _close => '}' },
  	);
  
  	# For each quote type, the extra fields that should be set.
  	# This should give us faster initialization.
  	%quotes = (
  		'q'   => { operator => 'q',   braced => undef, separator => undef, _sections => 1 },
  		'qq'  => { operator => 'qq',  braced => undef, separator => undef, _sections => 1 },
  		'qx'  => { operator => 'qx',  braced => undef, separator => undef, _sections => 1 },
  		'qw'  => { operator => 'qw',  braced => undef, separator => undef, _sections => 1 },
  		'qr'  => { operator => 'qr',  braced => undef, separator => undef, _sections => 1, modifiers => 1 },
  		'm'   => { operator => 'm',   braced => undef, separator => undef, _sections => 1, modifiers => 1 },
  		's'   => { operator => 's',   braced => undef, separator => undef, _sections => 2, modifiers => 1 },
  		'tr'  => { operator => 'tr',  braced => undef, separator => undef, _sections => 2, modifiers => 1 },
  
  		# Y is the little-used variant of tr
  		'y'   => { operator => 'y',   braced => undef, separator => undef, _sections => 2, modifiers => 1 },
  
  		'/'   => { operator => undef, braced => 0,     separator => '/',   _sections => 1, modifiers => 1 },
  
  		# Angle brackets quotes mean "readline(*FILEHANDLE)"
  		'<'   => { operator => undef, braced => 1,     separator => undef, _sections => 1, },
  
  		# The final ( and kind of depreciated ) "first match only" one is not
  		# used yet, since I'm not sure on the context differences between
  		# this and the trinary operator, but it's here for completeness.
  		'?'   => { operator => undef, braced => 0,     separator => '?',   _sections => 1, modifiers => 1 },
  	);
  }
  
  
  sub new {
  	my $class = shift;
  	my $init  = defined $_[0]
  		? shift
  		: Carp::croak("::Full->new called without init string");
  
  	# Create the token
  	### This manual SUPER'ing ONLY works because none of
  	### Token::Quote, Token::QuoteLike and Token::Regexp
  	### implement a new function of their own.
  	my $self = PPI::Token::new( $class, $init ) or return undef;
  
  	# Do we have a prototype for the initializer? If so, add the extra fields
  	my $options = $quotes{$init} or return $self->_error(
  		"Unknown quote type '$init'"
  	);
  	foreach ( keys %$options ) {
  		$self->{$_} = $options->{$_};
  	}
  
  	# Set up the modifiers hash if needed
  	$self->{modifiers} = {} if $self->{modifiers};
  
  	# Handle the special < base
  	if ( $init eq '<' ) {
  		$self->{sections}->[0] = Clone::clone( $sections{'<'} );
  	}
  
  	$self;
  }
  
  sub _fill {
  	my $class = shift;
  	my $t     = shift;
  	my $self  = $t->{token}
  		or Carp::croak("::Full->_fill called without current token");
  
  	# Load in the operator stuff if needed
  	if ( $self->{operator} ) {
  		# In an operator based quote-like, handle the gap between the
  		# operator and the opening separator.
  		if ( substr( $t->{line}, $t->{line_cursor}, 1 ) =~ /\s/ ) {
  			# Go past the gap
  			my $gap = $self->_scan_quote_like_operator_gap( $t );
  			return undef unless defined $gap;
  			if ( ref $gap ) {
  				# End of file
  				$self->{content} .= $$gap;
  				return 0;
  			}
  			$self->{content} .= $gap;
  		}
  
  		# The character we are now on is the separator. Capture,
  		# and advance into the first section.
  		my $sep = substr( $t->{line}, $t->{line_cursor}++, 1 );
  		$self->{content} .= $sep;
  
  		# Determine if these are normal or braced type sections
  		if ( my $section = $sections{$sep} ) {
  			$self->{braced}        = 1;
  			$self->{sections}->[0] = Clone::clone($section);
  		} else {
  			$self->{braced}        = 0;
  			$self->{separator}     = $sep;
  		}
  	}
  
  	# Parse different based on whether we are normal or braced
  	my $rv = $self->{braced}
  		? $self->_fill_braced($t)
   		: $self->_fill_normal($t);
  	return $rv if !$rv;
  
  	# Return now unless it has modifiers ( i.e. s/foo//eieio )
  	return 1 unless $self->{modifiers};
  
  	# Check for modifiers
  	my $char;
  	my $len = 0;
  	while ( ($char = substr( $t->{line}, $t->{line_cursor} + 1, 1 )) =~ /[^\W\d_]/ ) {
  		$len++;
  		$self->{content} .= $char;
  		$self->{modifiers}->{lc $char} = 1;
  		$t->{line_cursor}++;
  	}
  }
  
  # Handle the content parsing path for normally separated
  sub _fill_normal {
  	my $self = shift;
  	my $t    = shift;
  
  	# Get the content up to the next separator
  	my $string = $self->_scan_for_unescaped_character( $t, $self->{separator} );
  	return undef unless defined $string;
  	if ( ref $string ) {
  		# End of file
  		if ( length($$string) > 1 )  {
  			# Complete the properties for the first section
  			my $str = $$string;
  			chop $str;
  			$self->{sections}->[0] = {
  				position => length($self->{content}),
  				size     => length($$string) - 1,
  				type     => "$self->{separator}$self->{separator}",
  			};
  			$self->{_sections} = 1;
  		} else {
  			# No sections at all
  			$self->{sections}  = [ ];
  			$self->{_sections} = 0;
  		}
  		$self->{content} .= $$string;
  		return 0;
  	}
  
  	# Complete the properties of the first section
  	$self->{sections}->[0] = {
  		position => length $self->{content},
  		size     => length($string) - 1,
  		type     => "$self->{separator}$self->{separator}",
  	};
  	$self->{content} .= $string;
  
  	# We are done if there is only one section
  	return 1 if $self->{_sections} == 1;
  
  	# There are two sections.
  
  	# Advance into the next section
  	$t->{line_cursor}++;
  
  	# Get the content up to the end separator
  	$string = $self->_scan_for_unescaped_character( $t, $self->{separator} );
  	return undef unless defined $string;
  	if ( ref $string ) {
  		# End of file
  		if ( length($$string) > 1 )  {
  			# Complete the properties for the second section
  			my $str = $$string;
  			chop $str;
  			$self->{sections}->[1] = {
  				position => length($self->{content}),
  				size     => length($$string) - 1,
  				type     => "$self->{separator}$self->{separator}",
  			};
  		} else {
  			# No sections at all
  			$self->{_sections} = 1;
  		}
  		$self->{content} .= $$string;
  		return 0;
  	}
  
  	# Complete the properties of the second section
  	$self->{sections}->[1] = {
  		position => length($self->{content}),
  		size     => length($string) - 1
  	};
  	$self->{content} .= $string;
  
  	1;
  }
  
  # Handle content parsing for matching brace separated
  sub _fill_braced {
  	my $self = shift;
  	my $t    = shift;
  
  	# Get the content up to the close character
  	my $section   = $self->{sections}->[0];
  	my $brace_str = $self->_scan_for_brace_character( $t, $section->{_close} );
  	return undef unless defined $brace_str;
  	if ( ref $brace_str ) {
  		# End of file
  		if ( length($$brace_str) > 1 )  {
  			# Complete the properties for the first section
  			my $str = $$brace_str;
  			chop $str;
  			$self->{sections}->[0] = {
  				position => length($self->{content}),
  				size     => length($$brace_str) - 1,
  				type     => $section->{type},
  			};
  			$self->{_sections} = 1;
  		} else {
  			# No sections at all
  			$self->{sections}  = [ ];
  			$self->{_sections} = 0;
  		}
  		$self->{content} .= $$brace_str;
  		return 0;
  	}
  
  	# Complete the properties of the first section
  	$section->{position} = length $self->{content};
  	$section->{size}     = length($brace_str) - 1;
  	$self->{content} .= $brace_str;
  	delete $section->{_close};
  
  	# We are done if there is only one section
  	return 1 if $self->{_sections} == 1;
  
  	# There are two sections.
  
  	# Is there a gap between the sections.
  	my $char = substr( $t->{line}, ++$t->{line_cursor}, 1 );
  	if ( $char =~ /\s/ ) {
  		# Go past the gap
  		my $gap_str = $self->_scan_quote_like_operator_gap( $t );
  		return undef unless defined $gap_str;
  		if ( ref $gap_str ) {
  			# End of file
  			$self->{content} .= $$gap_str;
  			return 0;
  		}
  		$self->{content} .= $gap_str;
  		$char = substr( $t->{line}, $t->{line_cursor}, 1 );
  	}
  
  	$section = $sections{$char};
  
  	if ( $section ) {
  		# It's a brace
  
  		# Initialize the second section
  		$self->{content} .= $char;
  		$section = { %$section };
  
  		# Advance into the second section
  		$t->{line_cursor}++;
  
  		# Get the content up to the close character
  		$brace_str = $self->_scan_for_brace_character( $t, $section->{_close} );
  		return undef unless defined $brace_str;
  		if ( ref $brace_str ) {
  			# End of file
  			if ( length($$brace_str) > 1 )  {
  				# Complete the properties for the second section
  				my $str = $$brace_str;
  				chop $str;
  				$self->{sections}->[1] = {
  					position => length($self->{content}),
  					size     => length($$brace_str) - 1,
  					type     => $section->{type},
  				};
  				$self->{_sections} = 2;
  			} else {
  				# No sections at all
  				$self->{_sections} = 1;
  			}
  			$self->{content} .= $$brace_str;
  			return 0;
  		} else {
  			# Complete the properties for the second section
  			$self->{sections}->[1] = {
  				position => length($self->{content}),
  				size     => length($brace_str) - 1,
  				type     => $section->{type},
  			};
  			$self->{content} .= $brace_str;
  		}
  	} elsif ( $char =~ m/ \A [^\w\s] \z /smx ) {
  		# It is some other delimiter (weird, but possible)
  
  		# Add the delimiter to the content.
  		$self->{content} .= $char;
  
  		# Advance into the next section
  		$t->{line_cursor}++;
  
  		# Get the content up to the end separator
  		my $string = $self->_scan_for_unescaped_character( $t, $char );
  		return undef unless defined $string;
  		if ( ref $string ) {
  			# End of file
  			if ( length($$string) > 1 )  {
  				# Complete the properties for the second section
  				my $str = $$string;
  				chop $str;
  				$self->{sections}->[1] = {
  					position => length($self->{content}),
  					size     => length($$string) - 1,
  					type     => "$char$char",
  				};
  			} else {
  				# Only the one section
  				$self->{_sections} = 1;
  			}
  			$self->{content} .= $$string;
  			return 0;
  		}
  
  		# Complete the properties of the second section
  		$self->{sections}->[1] = {
  			position => length($self->{content}),
  			size     => length($string) - 1,
  			type     => "$char$char", 
  		};
  		$self->{content} .= $string;
  
  	} else {
  
  		# Error, it has to be a delimiter of some sort.
  		# Although this will result in a REALLY illegal regexp,
  		# we allow it anyway.
  
  		# Create a null second section
  		$self->{sections}->[1] = {
  			position => length($self->{content}),
  			size     => 0,
  			type     => '',
  		};
  
  		# Attach an error to the token and move on
  		$self->{_error} = "No second section of regexp, or does not start with a balanced character";
  
  		# Roll back the cursor one char and return signalling end of regexp
  		$t->{line_cursor}--;
  		return 0;
  	}
  
  	1;
  }
  
  
  
  
  
  #####################################################################
  # Additional methods to find out about the quote
  
  # In a scalar context, get the number of sections
  # In an array context, get the section information
  sub _sections {
  	wantarray ? @{$_[0]->{sections}} : scalar @{$_[0]->{sections}}
  }
  
  # Get a section's content
  sub _section_content {
  	my $self = shift;
  	my $i    = shift;
  	$self->{sections} or return;
  	my $section = $self->{sections}->[$i] or return;
  	return substr( $self->content, $section->{position}, $section->{size} );
  }
  
  # Get the modifiers if any.
  # In list context, return the modifier hash.
  # In scalar context, clone the hash and return a reference to it.
  # If there are no modifiers, simply return.
  sub _modifiers {
  	my $self = shift;
  	$self->{modifiers} or return;
  	wantarray and return %{ $self->{modifiers} };
  	return +{ %{ $self->{modifiers} } };
  }
  
  # Get the delimiters, or at least give it a good try to get them.
  sub _delimiters {
  	my $self = shift;
  	$self->{sections} or return;
  	my @delims;
  	foreach my $sect ( @{ $self->{sections} } ) {
  		if ( exists $sect->{type} ) {
  			push @delims, $sect->{type};
  		} else {
  			my $content = $self->content;
  			push @delims,
  			substr( $content, $sect->{position} - 1, 1 ) .
  			substr( $content, $sect->{position} + $sect->{size}, 1 );
  		}
  	}
  	return @delims;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN__QUOTEENGINE_FULL

$fatpacked{"PPI/Token/_QuoteEngine/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKEN__QUOTEENGINE_SIMPLE';
  package PPI::Token::_QuoteEngine::Simple;
  
  # Simple quote engine
  
  use strict;
  use PPI::Token::_QuoteEngine ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.236';
  	@ISA     = 'PPI::Token::_QuoteEngine';
  }
  
  sub new {
  	my $class     = shift;
  	my $separator = shift or return undef;
  
  	# Create a new token containing the separator
  	### This manual SUPER'ing ONLY works because none of
  	### Token::Quote, Token::QuoteLike and Token::Regexp
  	### implement a new function of their own.
  	my $self = PPI::Token::new( $class, $separator ) or return undef;
  	$self->{separator} = $separator;
  
  	$self;
  }
  
  sub _fill {
  	my $class = shift;
  	my $t     = shift;
  	my $self  = $t->{token} or return undef;
  
  	# Scan for the end separator
  	my $string = $self->_scan_for_unescaped_character( $t, $self->{separator} );
  	return undef unless defined $string;
  	if ( ref $string ) {
  		# End of file
  		$self->{content} .= $$string;
  		return 0;
  	} else {
  		# End of string
  		$self->{content} .= $string;
  		return $self;
  	}
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKEN__QUOTEENGINE_SIMPLE

$fatpacked{"PPI/Tokenizer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TOKENIZER';
  package PPI::Tokenizer;
  
  =pod
  
  =head1 NAME
  
  PPI::Tokenizer - The Perl Document Tokenizer
  
  =head1 SYNOPSIS
  
    # Create a tokenizer for a file, array or string
    $Tokenizer = PPI::Tokenizer->new( 'filename.pl' );
    $Tokenizer = PPI::Tokenizer->new( \@lines       );
    $Tokenizer = PPI::Tokenizer->new( \$source      );
    
    # Return all the tokens for the document
    my $tokens = $Tokenizer->all_tokens;
    
    # Or we can use it as an iterator
    while ( my $Token = $Tokenizer->get_token ) {
    	print "Found token '$Token'\n";
    }
    
    # If we REALLY need to manually nudge the cursor, you
    # can do that to (The lexer needs this ability to do rollbacks)
    $is_incremented = $Tokenizer->increment_cursor;
    $is_decremented = $Tokenizer->decrement_cursor;
  
  =head1 DESCRIPTION
  
  PPI::Tokenizer is the class that provides Tokenizer objects for use in
  breaking strings of Perl source code into Tokens.
  
  By the time you are reading this, you probably need to know a little
  about the difference between how perl parses Perl "code" and how PPI
  parsers Perl "documents".
  
  "perl" itself (the interpreter) uses a heavily modified lex specification
  to specify its parsing logic, maintains several types of state as it
  goes, and incrementally tokenizes, lexes AND EXECUTES at the same time.
  
  In fact, it is provably impossible to use perl's parsing method without
  simultaneously executing code. A formal mathematical proof has been
  published demonstrating the method.
  
  This is where the truism "Only perl can parse Perl" comes from.
  
  PPI uses a completely different approach by abandoning the (impossible)
  ability to parse Perl the same way that the interpreter does, and instead
  parsing the source as a document, using a document structure independently
  derived from the Perl documentation and approximating the perl interpreter
  interpretation as closely as possible.
  
  It was touch and go for a long time whether we could get it close enough,
  but in the end it turned out that it could be done.
  
  In this approach, the tokenizer C<PPI::Tokenizer> is implemented separately
  from the lexer L<PPI::Lexer>.
  
  The job of C<PPI::Tokenizer> is to take pure source as a string and break it
  up into a stream/set of tokens, and contains most of the "black magic" used
  in PPI. By comparison, the lexer implements a relatively straight forward
  tree structure, and has an implementation that is uncomplicated (compared
  to the insanity in the tokenizer at least).
  
  The Tokenizer uses an immense amount of heuristics, guessing and cruft,
  supported by a very B<VERY> flexible internal API, but fortunately it was
  possible to largely encapsulate the black magic, so there is not a lot that
  gets exposed to people using the C<PPI::Tokenizer> itself.
  
  =head1 METHODS
  
  Despite the incredible complexity, the Tokenizer itself only exposes a
  relatively small number of methods, with most of the complexity implemented
  in private methods.
  
  =cut
  
  # Make sure everything we need is loaded so
  # we don't have to go and load all of PPI.
  use strict;
  use Params::Util    qw{_INSTANCE _SCALAR0 _ARRAY0};
  use List::Util 1.33 ();
  use PPI::Util       ();
  use PPI::Element    ();
  use PPI::Token      ();
  use PPI::Exception  ();
  use PPI::Exception::ParserRejection ();
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.236';
  }
  
  # The x operator cannot follow most Perl operators, implying that
  # anything beginning with x following an operator is a word.
  # These are the exceptions.
  my %X_CAN_FOLLOW_OPERATOR = map { $_ => 1 } qw( -- ++ );
  
  # The x operator cannot follow most structure elements, implying that
  # anything beginning with x following a structure element is a word.
  # These are the exceptions.
  my %X_CAN_FOLLOW_STRUCTURE = map { $_ => 1 } qw( } ] \) );
  
  # Something that looks like the x operator but follows a word
  # is usually that word's argument.
  # These are the exceptions.
  # chop, chomp, dump are ambiguous because they can have either parms
  # or no parms.
  my %X_CAN_FOLLOW_WORD = map { $_ => 1 } qw(
  		endgrent
  		endhostent
  		endnetent
  		endprotoent
  		endpwent
  		endservent
  		fork
  		getgrent
  		gethostent
  		getlogin
  		getnetent
  		getppid
  		getprotoent
  		getpwent
  		getservent
  		setgrent
  		setpwent
  		time
  		times
  		wait
  		wantarray
  		__SUB__
  );
  
  
  
  #####################################################################
  # Creation and Initialization
  
  =pod
  
  =head2 new $file | \@lines | \$source
  
  The main C<new> constructor creates a new Tokenizer object. These
  objects have no configuration parameters, and can only be used once,
  to tokenize a single perl source file.
  
  It takes as argument either a normal scalar containing source code,
  a reference to a scalar containing source code, or a reference to an
  ARRAY containing newline-terminated lines of source code.
  
  Returns a new C<PPI::Tokenizer> object on success, or throws a
  L<PPI::Exception> exception on error.
  
  =cut
  
  sub new {
  	my $class = ref($_[0]) || $_[0];
  
  	# Create the empty tokenizer struct
  	my $self = bless {
  		# Source code
  		source       => undef,
  		source_bytes => undef,
  
  		# Line buffer
  		line         => undef,
  		line_length  => undef,
  		line_cursor  => undef,
  		line_count   => 0,
  
  		# Parse state
  		token        => undef,
  		class        => 'PPI::Token::BOM',
  		zone         => 'PPI::Token::Whitespace',
  
  		# Output token buffer
  		tokens       => [],
  		token_cursor => 0,
  		token_eof    => 0,
  
  		# Perl 6 blocks
  		perl6        => [],
  	}, $class;
  
  	if ( ! defined $_[1] ) {
  		# We weren't given anything
  		PPI::Exception->throw("No source provided to Tokenizer");
  
  	} elsif ( ! ref $_[1] ) {
  		my $source = PPI::Util::_slurp($_[1]);
  		if ( ref $source ) {
  			# Content returned by reference
  			$self->{source} = $$source;
  		} else {
  			# Errors returned as a string
  			return( $source );
  		}
  
  	} elsif ( _SCALAR0($_[1]) ) {
  		$self->{source} = ${$_[1]};
  
  	} elsif ( _ARRAY0($_[1]) ) {
  		$self->{source} = join '', map { "\n" } @{$_[1]};
  
  	} else {
  		# We don't support whatever this is
  		PPI::Exception->throw(ref($_[1]) . " is not supported as a source provider");
  	}
  
  	# We can't handle a null string
  	$self->{source_bytes} = length $self->{source};
  	if ( $self->{source_bytes} ) {
  		# Split on local newlines
  		$self->{source} =~ s/(?:\015{1,2}\012|\015|\012)/\n/g;
  		$self->{source} = [ split /(?<=\n)/, $self->{source} ];
  
  	} else {
  		$self->{source} = [ ];
  	}
  
  	### EVIL
  	# I'm explaining this earlier than I should so you can understand
  	# why I'm about to do something that looks very strange. There's
  	# a problem with the Tokenizer, in that tokens tend to change
  	# classes as each letter is added, but they don't get allocated
  	# their definite final class until the "end" of the token, the
  	# detection of which occurs in about a hundred different places,
  	# all through various crufty code (that triples the speed).
  	#
  	# However, in general, this does not apply to tokens in which a
  	# whitespace character is valid, such as comments, whitespace and
  	# big strings.
  	#
  	# So what we do is add a space to the end of the source. This
  	# triggers normal "end of token" functionality for all cases. Then,
  	# once the tokenizer hits end of file, it examines the last token to
  	# manually either remove the ' ' token, or chop it off the end of
  	# a longer one in which the space would be valid.
  	if ( List::Util::any { /^__(?:DATA|END)__\s*$/ } @{$self->{source}} ) {
  		$self->{source_eof_chop} = '';
  	} elsif ( ! defined $self->{source}->[0] ) {
  		$self->{source_eof_chop} = '';
  	} elsif ( $self->{source}->[-1] =~ /\s$/ ) {
  		$self->{source_eof_chop} = '';
  	} else {
  		$self->{source_eof_chop} = 1;
  		$self->{source}->[-1] .= ' ';
  	}
  
  	$self;
  }
  
  
  
  
  
  #####################################################################
  # Main Public Methods
  
  =pod
  
  =head2 get_token
  
  When using the PPI::Tokenizer object as an iterator, the C<get_token>
  method is the primary method that is used. It increments the cursor
  and returns the next Token in the output array.
  
  The actual parsing of the file is done only as-needed, and a line at
  a time. When C<get_token> hits the end of the token array, it will
  cause the parser to pull in the next line and parse it, continuing
  as needed until there are more tokens on the output array that
  get_token can then return.
  
  This means that a number of Tokenizer objects can be created, and
  won't consume significant CPU until you actually begin to pull tokens
  from it.
  
  Return a L<PPI::Token> object on success, C<0> if the Tokenizer had
  reached the end of the file, or C<undef> on error.
  
  =cut
  
  sub get_token {
  	my $self = shift;
  
  	# Shortcut for EOF
  	if ( $self->{token_eof}
  	 and $self->{token_cursor} > scalar @{$self->{tokens}}
  	) {
  		return 0;
  	}
  
  	# Return the next token if we can
  	if ( my $token = $self->{tokens}->[ $self->{token_cursor} ] ) {
  		$self->{token_cursor}++;
  		return $token;
  	}
  
  	my $line_rv;
  
  	# Catch exceptions and return undef, so that we
  	# can start to convert code to exception-based code.
  	my $rv = eval {
  		# No token, we need to get some more
  		while ( $line_rv = $self->_process_next_line ) {
  			# If there is something in the buffer, return it
  			# The defined() prevents a ton of calls to PPI::Util::TRUE
  			if ( defined( my $token = $self->{tokens}->[ $self->{token_cursor} ] ) ) {
  				$self->{token_cursor}++;
  				return $token;
  			}
  		}
  		return undef;
  	};
  	if ( $@ ) {
  		if ( _INSTANCE($@, 'PPI::Exception') ) {
  			$@->throw;
  		} else {
  			my $errstr = $@;
  			$errstr =~ s/^(.*) at line .+$/$1/;
  			PPI::Exception->throw( $errstr );
  		}
  	} elsif ( $rv ) {
  		return $rv;
  	}
  
  	if ( defined $line_rv ) {
  		# End of file, but we can still return things from the buffer
  		if ( my $token = $self->{tokens}->[ $self->{token_cursor} ] ) {
  			$self->{token_cursor}++;
  			return $token;
  		}
  
  		# Set our token end of file flag
  		$self->{token_eof} = 1;
  		return 0;
  	}
  
  	# Error, pass it up to our caller
  	undef;
  }
  
  =pod
  
  =head2 all_tokens
  
  When not being used as an iterator, the C<all_tokens> method tells
  the Tokenizer to parse the entire file and return all of the tokens
  in a single ARRAY reference.
  
  It should be noted that C<all_tokens> does B<NOT> interfere with the
  use of the Tokenizer object as an iterator (does not modify the token
  cursor) and use of the two different mechanisms can be mixed safely.
  
  Returns a reference to an ARRAY of L<PPI::Token> objects on success
  or throws an exception on error.
  
  =cut
  
  sub all_tokens {
  	my $self = shift;
  
  	# Catch exceptions and return undef, so that we
  	# can start to convert code to exception-based code.
  	my $ok = eval {
  		# Process lines until we get EOF
  		unless ( $self->{token_eof} ) {
  			my $rv;
  			while ( $rv = $self->_process_next_line ) {}
  			unless ( defined $rv ) {
  				PPI::Exception->throw("Error while processing source");
  			}
  
  			# Clean up the end of the tokenizer
  			$self->_clean_eof;
  		}
  		1;
  	};
  	if ( !$ok ) {
  		my $errstr = $@;
  		$errstr =~ s/^(.*) at line .+$/$1/;
  		PPI::Exception->throw( $errstr );
  	}
  
  	# End of file, return a copy of the token array.
  	return [ @{$self->{tokens}} ];
  }
  
  =pod
  
  =head2 increment_cursor
  
  Although exposed as a public method, C<increment_cursor> is implemented
  for expert use only, when writing lexers or other components that work
  directly on token streams.
  
  It manually increments the token cursor forward through the file, in effect
  "skipping" the next token.
  
  Return true if the cursor is incremented, C<0> if already at the end of
  the file, or C<undef> on error.
  
  =cut
  
  sub increment_cursor {
  	# Do this via the get_token method, which makes sure there
  	# is actually a token there to move to.
  	$_[0]->get_token and 1;
  }
  
  =pod
  
  =head2 decrement_cursor
  
  Although exposed as a public method, C<decrement_cursor> is implemented
  for expert use only, when writing lexers or other components that work
  directly on token streams.
  
  It manually decrements the token cursor backwards through the file, in
  effect "rolling back" the token stream. And indeed that is what it is
  primarily intended for, when the component that is consuming the token
  stream needs to implement some sort of "roll back" feature in its use
  of the token stream.
  
  Return true if the cursor is decremented, C<0> if already at the
  beginning of the file, or C<undef> on error.
  
  =cut
  
  sub decrement_cursor {
  	my $self = shift;
  
  	# Check for the beginning of the file
  	return 0 unless $self->{token_cursor};
  
  	# Decrement the token cursor
  	$self->{token_eof} = 0;
  	--$self->{token_cursor};
  }
  
  
  
  
  
  #####################################################################
  # Working With Source
  
  # Fetches the next line from the input line buffer
  # Returns undef at EOF.
  sub _get_line {
  	my $self = shift;
  	return undef unless $self->{source}; # EOF hit previously
  
  	# Pull off the next line
  	my $line = shift @{$self->{source}};
  
  	# Flag EOF if we hit it
  	$self->{source} = undef unless defined $line;
  
  	# Return the line (or EOF flag)
  	return $line; # string or undef
  }
  
  # Fetches the next line, ready to process
  # Returns 1 on success
  # Returns 0 on EOF
  sub _fill_line {
  	my $self   = shift;
  	my $inscan = shift;
  
  	# Get the next line
  	my $line = $self->_get_line;
  	unless ( defined $line ) {
  		# End of file
  		unless ( $inscan ) {
  			delete $self->{line};
  			delete $self->{line_cursor};
  			delete $self->{line_length};
  			return 0;
  		}
  
  		# In the scan version, just set the cursor to the end
  		# of the line, and the rest should just cascade out.
  		$self->{line_cursor} = $self->{line_length};
  		return 0;
  	}
  
  	# Populate the appropriate variables
  	$self->{line}        = $line;
  	$self->{line_cursor} = -1;
  	$self->{line_length} = length $line;
  	$self->{line_count}++;
  
  	1;
  }
  
  # Get the current character
  sub _char {
  	my $self = shift;
  	substr( $self->{line}, $self->{line_cursor}, 1 );
  }
  
  
  
  
  
  ####################################################################
  # Per line processing methods
  
  # Processes the next line
  # Returns 1 on success completion
  # Returns 0 if EOF
  # Returns undef on error
  sub _process_next_line {
  	my $self = shift;
  
  	# Fill the line buffer
  	my $rv;
  	unless ( $rv = $self->_fill_line ) {
  		return undef unless defined $rv;
  
  		# End of file, finalize last token
  		$self->_finalize_token;
  		return 0;
  	}
  
  	# Run the __TOKENIZER__on_line_start
  	$rv = $self->{class}->__TOKENIZER__on_line_start( $self );
  	unless ( $rv ) {
  		# If there are no more source lines, then clean up
  		if ( ref $self->{source} eq 'ARRAY' and ! @{$self->{source}} ) {
  			$self->_clean_eof;
  		}
  
  		# Defined but false means next line
  		return 1 if defined $rv;
  		PPI::Exception->throw("Error at line $self->{line_count}");
  	}
  
  	# If we can't deal with the entire line, process char by char
  	while ( $rv = $self->_process_next_char ) {}
  	unless ( defined $rv ) {
  		PPI::Exception->throw("Error at line $self->{line_count}, character $self->{line_cursor}");
  	}
  
  	# Trigger any action that needs to happen at the end of a line
  	$self->{class}->__TOKENIZER__on_line_end( $self );
  
  	# If there are no more source lines, then clean up
  	unless ( ref($self->{source}) eq 'ARRAY' and @{$self->{source}} ) {
  		return $self->_clean_eof;
  	}
  
  	return 1;
  }
  
  
  
  
  
  #####################################################################
  # Per-character processing methods
  
  # Process on a per-character basis.
  # Note that due the high number of times this gets
  # called, it has been fairly heavily in-lined, so the code
  # might look a bit ugly and duplicated.
  sub _process_next_char {
  	my $self = shift;
  
  	### FIXME - This checks for a screwed up condition that triggers
  	###         several warnings, amongst other things.
  	if ( ! defined $self->{line_cursor} or ! defined $self->{line_length} ) {
  		# $DB::single = 1;
  		return undef;
  	}
  
  	# Increment the counter and check for end of line
  	return 0 if ++$self->{line_cursor} >= $self->{line_length};
  
  	# Pass control to the token class
  	my $result;
  	unless ( $result = $self->{class}->__TOKENIZER__on_char( $self ) ) {
  		# undef is error. 0 is "Did stuff ourself, you don't have to do anything"
  		return defined $result ? 1 : undef;
  	}
  
  	# We will need the value of the current character
  	my $char = substr( $self->{line}, $self->{line_cursor}, 1 );
  	if ( $result eq '1' ) {
  		# If __TOKENIZER__on_char returns 1, it is signaling that it thinks that
  		# the character is part of it.
  
  		# Add the character
  		if ( defined $self->{token} ) {
  			$self->{token}->{content} .= $char;
  		} else {
  			defined($self->{token} = $self->{class}->new($char)) or return undef;
  		}
  
  		return 1;
  	}
  
  	# We have been provided with the name of a class
  	if ( $self->{class} ne "PPI::Token::$result" ) {
  		# New class
  		$self->_new_token( $result, $char );
  	} elsif ( defined $self->{token} ) {
  		# Same class as current
  		$self->{token}->{content} .= $char;
  	} else {
  		# Same class, but no current
  		defined($self->{token} = $self->{class}->new($char)) or return undef;
  	}
  
  	1;
  }
  
  
  
  
  
  #####################################################################
  # Altering Tokens in Tokenizer
  
  # Finish the end of a token.
  # Returns the resulting parse class as a convenience.
  sub _finalize_token {
  	my $self = shift;
  	return $self->{class} unless defined $self->{token};
  
  	# Add the token to the token buffer
  	push @{ $self->{tokens} }, $self->{token};
  	$self->{token} = undef;
  
  	# Return the parse class to that of the zone we are in
  	$self->{class} = $self->{zone};
  }
  
  # Creates a new token and sets it in the tokenizer
  # The defined() in here prevent a ton of calls to PPI::Util::TRUE
  sub _new_token {
  	my $self = shift;
  	# throw PPI::Exception() unless @_;
  	my $class = substr( $_[0], 0, 12 ) eq 'PPI::Token::'
  		? shift : 'PPI::Token::' . shift;
  
  	# Finalize any existing token
  	$self->_finalize_token if defined $self->{token};
  
  	# Create the new token and update the parse class
  	defined($self->{token} = $class->new($_[0])) or PPI::Exception->throw;
  	$self->{class} = $class;
  
  	1;
  }
  
  # At the end of the file, we need to clean up the results of the erroneous
  # space that we inserted at the beginning of the process.
  sub _clean_eof {
  	my $self = shift;
  
  	# Finish any partially completed token
  	$self->_finalize_token if $self->{token};
  
  	# Find the last token, and if it has no content, kill it.
  	# There appears to be some evidence that such "null tokens" are
  	# somehow getting created accidentally.
  	my $last_token = $self->{tokens}->[ -1 ];
  	unless ( length $last_token->{content} ) {
  		pop @{$self->{tokens}};
  	}
  
  	# Now, if the last character of the last token is a space we added,
  	# chop it off, deleting the token if there's nothing else left.
  	if ( $self->{source_eof_chop} ) {
  		$last_token = $self->{tokens}->[ -1 ];
  		$last_token->{content} =~ s/ $//;
  		unless ( length $last_token->{content} ) {
  			# Popping token
  			pop @{$self->{tokens}};
  		}
  
  		# The hack involving adding an extra space is now reversed, and
  		# now nobody will ever know. The perfect crime!
  		$self->{source_eof_chop} = '';
  	}
  
  	1;
  }
  
  
  
  
  
  #####################################################################
  # Utility Methods
  
  # Context
  sub _last_token {
  	$_[0]->{tokens}->[-1];
  }
  
  sub _last_significant_token {
  	my $self   = shift;
  	my $cursor = $#{ $self->{tokens} };
  	while ( $cursor >= 0 ) {
  		my $token = $self->{tokens}->[$cursor--];
  		return $token if $token->significant;
  	}
  	return;
  }
  
  # Get an array ref of previous significant tokens.
  # Like _last_significant_token except it gets more than just one token
  # Returns array with 0 to x entries
  sub _previous_significant_tokens {
  	my $self   = shift;
  	my $count  = shift || 1;
  	my $cursor = $#{ $self->{tokens} };
  
  	my @tokens;
  	while ( $cursor >= 0 ) {
  		my $token = $self->{tokens}->[$cursor--];
  		next if not $token->significant;
  		push @tokens, $token;
  		last if @tokens >= $count;
  	}
  
  	return @tokens;
  }
  
  my %OBVIOUS_CLASS = (
  	'PPI::Token::Symbol'              => 'operator',
  	'PPI::Token::Magic'               => 'operator',
  	'PPI::Token::Number'              => 'operator',
  	'PPI::Token::ArrayIndex'          => 'operator',
  	'PPI::Token::Quote::Double'       => 'operator',
  	'PPI::Token::Quote::Interpolate'  => 'operator',
  	'PPI::Token::Quote::Literal'      => 'operator',
  	'PPI::Token::Quote::Single'       => 'operator',
  	'PPI::Token::QuoteLike::Backtick' => 'operator',
  	'PPI::Token::QuoteLike::Command'  => 'operator',
  	'PPI::Token::QuoteLike::Readline' => 'operator',
  	'PPI::Token::QuoteLike::Regexp'   => 'operator',
  	'PPI::Token::QuoteLike::Words'    => 'operator',
  );
  
  my %OBVIOUS_CONTENT = (
  	'(' => 'operand',
  	'{' => 'operand',
  	'[' => 'operand',
  	';' => 'operand',
  	'}' => 'operator',
  );
  
  
  my %USUALLY_FORCES = map { $_ => 1 } qw( sub package use no );
  
  # Try to determine operator/operand context, if possible.
  # Returns "operator", "operand", or "" if unknown.
  sub _opcontext {
  	my $self   = shift;
  	my @tokens = $self->_previous_significant_tokens(1);
  	my $p0     = $tokens[0];
  	return '' if not $p0;
  	my $c0     = ref $p0;
  
  	# Map the obvious cases
  	return $OBVIOUS_CLASS{$c0}   if defined $OBVIOUS_CLASS{$c0};
  	return $OBVIOUS_CONTENT{$p0} if defined $OBVIOUS_CONTENT{$p0};
  
  	# Most of the time after an operator, we are an operand
  	return 'operand' if $p0->isa('PPI::Token::Operator');
  
  	# If there's NOTHING, it's operand
  	return 'operand' if $p0->content eq '';
  
  	# Otherwise, we don't know
  	return ''
  }
  
  # Assuming we are currently parsing the word 'x', return true
  # if previous tokens imply the x is an operator, false otherwise.
  sub _current_x_is_operator {
  	my ( $self ) = @_;
  	return if !@{$self->{tokens}};
  
  	my ($prev, $prevprev) = $self->_previous_significant_tokens(2);
  	return if !$prev;
  
  	return !$self->__current_token_is_forced_word if $prev->isa('PPI::Token::Word');
  
  	return (!$prev->isa('PPI::Token::Operator') || $X_CAN_FOLLOW_OPERATOR{$prev})
  		&& (!$prev->isa('PPI::Token::Structure') || $X_CAN_FOLLOW_STRUCTURE{$prev})
  		&& !$prev->isa('PPI::Token::Label')
  	;
  }
  
  
  # Assuming we are at the end of parsing the current token that could be a word,
  # a wordlike operator, or a version string, try to determine whether context
  # before or after it forces it to be a bareword. This method is only useful
  # during tokenization.
  sub __current_token_is_forced_word {
  	my ( $t, $word ) = @_;
  
  	# Check if forced by preceding tokens.
  
  	my ( $prev, $prevprev ) = $t->_previous_significant_tokens(2);
  	if ( !$prev ) {
  		pos $t->{line} = $t->{line_cursor};
  	}
  	else {
  		my $content = $prev->{content};
  
  		# We are forced if we are a method name.
  		# '->' will always be an operator, so we don't check its type.
  		return 1 if $content eq '->';
  
  		# If we are contained in a pair of curly braces, we are probably a
  		# forced bareword hash key. '{' is never a word or operator, so we
  		# don't check its type.
  		pos $t->{line} = $t->{line_cursor};
  		return 1 if $content eq '{' and $t->{line} =~ /\G\s*\}/gc;
  
  		# sub, package, use, and no all indicate that what immediately follows
  		# is a word not an operator or (in the case of sub and package) a
  		# version string.  However, we don't want to be fooled by 'package
  		# package v10' or 'use no v10'. We're a forced package unless we're
  		# preceded by 'package sub', in which case we're a version string.
  		# We also have to make sure that the sub/package/etc doing the forcing
  		# is not a method call.
  		if( $USUALLY_FORCES{$content}) {
  			return if defined $word and $word =~ /^v[0-9]+$/ and ( $content eq "use" or $content eq "no" );
  			return 1 if not $prevprev;
  			return 1 if not $USUALLY_FORCES{$prevprev->content} and $prevprev->content ne '->';
  			return;
  		}
  	}
  	# pos on $t->{line} is guaranteed to be set at this point.
  
  	# Check if forced by following tokens.
  
  	# If the word is followed by => it is probably a word, not a regex.
  	return 1 if $t->{line} =~ /\G\s*=>/gc;
  
  	# Otherwise we probably aren't forced
  	return '';
  }
  
  1;
  
  =pod
  
  =head1 NOTES
  
  =head2 How the Tokenizer Works
  
  Understanding the Tokenizer is not for the faint-hearted. It is by far
  the most complex and twisty piece of perl I've ever written that is actually
  still built properly and isn't a terrible spaghetti-like mess. In fact, you
  probably want to skip this section.
  
  But if you really want to understand, well then here goes.
  
  =head2 Source Input and Clean Up
  
  The Tokenizer starts by taking source in a variety of forms, sucking it
  all in and merging into one big string, and doing our own internal line
  split, using a "universal line separator" which allows the Tokenizer to
  take source for any platform (and even supports a few known types of
  broken newlines caused by mixed mac/pc/*nix editor screw ups).
  
  The resulting array of lines is used to feed the tokenizer, and is also
  accessed directly by the heredoc-logic to do the line-oriented part of
  here-doc support.
  
  =head2 Doing Things the Old Fashioned Way
  
  Due to the complexity of perl, and after 2 previously aborted parser
  attempts, in the end the tokenizer was fashioned around a line-buffered
  character-by-character method.
  
  That is, the Tokenizer pulls and holds a line at a time into a line buffer,
  and then iterates a cursor along it. At each cursor position, a method is
  called in whatever token class we are currently in, which will examine the
  character at the current position, and handle it.
  
  As the handler methods in the various token classes are called, they
  build up an output token array for the source code.
  
  Various parts of the Tokenizer use look-ahead, arbitrary-distance
  look-behind (although currently the maximum is three significant tokens),
  or both, and various other heuristic guesses.
  
  I've been told it is officially termed a I<"backtracking parser
  with infinite lookaheads">.
  
  =head2 State Variables
  
  Aside from the current line and the character cursor, the Tokenizer
  maintains a number of different state variables.
  
  =over
  
  =item Current Class
  
  The Tokenizer maintains the current token class at all times. Much of the
  time is just going to be the "Whitespace" class, which is what the base of
  a document is. As the tokenizer executes the various character handlers,
  the class changes a lot as it moves a long. In fact, in some instances,
  the character handler may not handle the character directly itself, but
  rather change the "current class" and then hand off to the character
  handler for the new class.
  
  Because of this, and some other things I'll deal with later, the number of
  times the character handlers are called does not in fact have a direct
  relationship to the number of actual characters in the document.
  
  =item Current Zone
  
  Rather than create a class stack to allow for infinitely nested layers of
  classes, the Tokenizer recognises just a single layer.
  
  To put it a different way, in various parts of the file, the Tokenizer will
  recognise different "base" or "substrate" classes. When a Token such as a
  comment or a number is finalised by the tokenizer, it "falls back" to the
  base state.
  
  This allows proper tokenization of special areas such as __DATA__
  and __END__ blocks, which also contain things like comments and POD,
  without allowing the creation of any significant Tokens inside these areas.
  
  For the main part of a document we use L<PPI::Token::Whitespace> for this,
  with the idea being that code is "floating in a sea of whitespace".
  
  =item Current Token
  
  The final main state variable is the "current token". This is the Token
  that is currently being built by the Tokenizer. For certain types, it
  can be manipulated and morphed and change class quite a bit while being
  assembled, as the Tokenizer's understanding of the token content changes.
  
  When the Tokenizer is confident that it has seen the end of the Token, it
  will be "finalized", which adds it to the output token array and resets
  the current class to that of the zone that we are currently in.
  
  I should also note at this point that the "current token" variable is
  optional. The Tokenizer is capable of knowing what class it is currently
  set to, without actually having accumulated any characters in the Token.
  
  =back
  
  =head2 Making It Faster
  
  As I'm sure you can imagine, calling several different methods for each
  character and running regexes and other complex heuristics made the first
  fully working version of the tokenizer extremely slow.
  
  During testing, I created a metric to measure parsing speed called
  LPGC, or "lines per gigacycle" . A gigacycle is simple a billion CPU
  cycles on a typical single-core CPU, and so a Tokenizer running at
  "1000 lines per gigacycle" should generate around 1200 lines of tokenized
  code when running on a 1200 MHz processor.
  
  The first working version of the tokenizer ran at only 350 LPGC, so to
  tokenize a typical large module such as L<ExtUtils::MakeMaker> took
  10-15 seconds. This sluggishness made it unpractical for many uses.
  
  So in the current parser, there are multiple layers of optimisation
  very carefully built in to the basic. This has brought the tokenizer
  up to a more reasonable 1000 LPGC, at the expense of making the code
  quite a bit twistier.
  
  =head2 Making It Faster - Whole Line Classification
  
  The first step in the optimisation process was to add a hew handler to
  enable several of the more basic classes (whitespace, comments) to be
  able to be parsed a line at a time. At the start of each line, a
  special optional handler (only supported by a few classes) is called to
  check and see if the entire line can be parsed in one go.
  
  This is used mainly to handle things like POD, comments, empty lines,
  and a few other minor special cases.
  
  =head2 Making It Faster - Inlining
  
  The second stage of the optimisation involved inlining a small
  number of critical methods that were repeated an extremely high number
  of times. Profiling suggested that there were about 1,000,000 individual
  method calls per gigacycle, and by cutting these by two thirds a significant
  speed improvement was gained, in the order of about 50%.
  
  You may notice that many methods in the C<PPI::Tokenizer> code look
  very nested and long hand. This is primarily due to this inlining.
  
  At around this time, some statistics code that existed in the early
  versions of the parser was also removed, as it was determined that
  it was consuming around 15% of the CPU for the entire parser, while
  making the core more complicated.
  
  A judgment call was made that with the difficulties likely to be
  encountered with future planned enhancements, and given the relatively
  high cost involved, the statistics features would be removed from the
  Tokenizer.
  
  =head2 Making It Faster - Quote Engine
  
  Once inlining had reached diminishing returns, it became obvious from
  the profiling results that a huge amount of time was being spent
  stepping a char at a time though long, simple and "syntactically boring"
  code such as comments and strings.
  
  The existing regex engine was expanded to also encompass quotes and
  other quote-like things, and a special abstract base class was added
  that provided a number of specialised parsing methods that would "scan
  ahead", looking out ahead to find the end of a string, and updating
  the cursor to leave it in a valid position for the next call.
  
  This is also the point at which the number of character handler calls began
  to greatly differ from the number of characters. But it has been done
  in a way that allows the parser to retain the power of the original
  version at the critical points, while skipping through the "boring bits"
  as needed for additional speed.
  
  The addition of this feature allowed the tokenizer to exceed 1000 LPGC
  for the first time.
  
  =head2 Making It Faster - The "Complete" Mechanism
  
  As it became evident that great speed increases were available by using
  this "skipping ahead" mechanism, a new handler method was added that
  explicitly handles the parsing of an entire token, where the structure
  of the token is relatively simple. Tokens such as symbols fit this case,
  as once we are passed the initial sigil and word char, we know that we
  can skip ahead and "complete" the rest of the token much more easily.
  
  A number of these have been added for most or possibly all of the common
  cases, with most of these "complete" handlers implemented using regular
  expressions.
  
  In fact, so many have been added that at this point, you could arguably
  reclassify the tokenizer as a "hybrid regex, char-by=char heuristic
  tokenizer". More tokens are now consumed in "complete" methods in a
  typical program than are handled by the normal char-by-char methods.
  
  Many of the these complete-handlers were implemented during the writing
  of the Lexer, and this has allowed the full parser to maintain around
  1000 LPGC despite the increasing weight of the Lexer.
  
  =head2 Making It Faster - Porting To C (In Progress)
  
  While it would be extraordinarily difficult to port all of the Tokenizer
  to C, work has started on a L<PPI::XS> "accelerator" package which acts as
  a separate and automatically-detected add-on to the main PPI package.
  
  L<PPI::XS> implements faster versions of a variety of functions scattered
  over the entire PPI codebase, from the Tokenizer Core, Quote Engine, and
  various other places, and implements them identically in XS/C.
  
  In particular, the skip-ahead methods from the Quote Engine would appear
  to be extremely amenable to being done in C, and a number of other
  functions could be cherry-picked one at a time and implemented in C.
  
  Each method is heavily tested to ensure that the functionality is
  identical, and a versioning mechanism is included to ensure that if a
  function gets out of sync, L<PPI::XS> will degrade gracefully and just
  not replace that single method.
  
  =head1 TO DO
  
  - Add an option to reset or seek the token stream...
  
  - Implement more Tokenizer functions in L<PPI::XS>
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TOKENIZER

$fatpacked{"PPI/Transform.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TRANSFORM';
  package PPI::Transform;
  
  =pod
  
  =head1 NAME
  
  PPI::Transform - Abstract base class for document transformation classes
  
  =head1 DESCRIPTION
  
  C<PPI::Transform> provides an API for the creation of classes and objects
  that modify or transform PPI documents.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Carp          ();
  use List::Util    ();
  use PPI::Document ();
  use Params::Util  qw{_INSTANCE _CLASS _CODE _SCALAR0};
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.236';
  }
  
  
  
  
  
  #####################################################################
  # Apply Handler Registration
  
  my %HANDLER;
  my @ORDER;
  
  # Yes, you can use this yourself.
  # I'm just leaving it undocumented for now.
  sub register_apply_handler {
  	my $class   = shift;
  	my $handler = _CLASS(shift) or Carp::croak("Invalid PPI::Transform->register_apply_handler param");
  	my $get     = _CODE(shift)  or Carp::croak("Invalid PPI::Transform->register_apply_handler param");
  	my $set     = _CODE(shift)  or Carp::croak("Invalid PPI::Transform->register_apply_handler param");
  	if ( $HANDLER{$handler} ) {
  		Carp::croak("PPI::Transform->apply handler '$handler' already exists");
  	}
  
  	# Register the handler
  	$HANDLER{$handler} = [ $get, $set ];
  	unshift @ORDER, $handler;
  }
  
  # Register the default handlers
  __PACKAGE__->register_apply_handler( 'SCALAR', \&_SCALAR_get, \&_SCALAR_set );
  __PACKAGE__->register_apply_handler( 'PPI::Document', sub { $_[0] }, sub() { 1 } );
  
  
  
  
  
  #####################################################################
  # Constructor
  
  =pod
  
  =head2 new
  
    my $transform = PPI::Transform->new(
        param1 => 'value1',
        param2 => 'value2',
    );
  
  The C<new> constructor creates a new object for your C<PPI::Transform>
  subclass. A default constructor is provided for you which takes no params
  and creates a basic, empty, object.
  
  If you wish to have your transform constructor take params, these B<must>
  be in the form of a list of key/value pairs.
  
  Returns a new C<PPI::Transform>-compatible object, or returns
  C<undef> on error.
  
  =cut
  
  sub new {
  	my $class = shift;
  	bless { @_ }, $class;
  }
  
  =pod
  
  =head2 document
  
  The C<document> method should be implemented by each subclass, and
  takes a single argument of a L<PPI::Document> object, modifying it
  B<in place> as appropriate for the particular transform class.
  
  That's right, this method B<will not clone> and B<should not clone>
  the document object. If you do not want the original to be modified,
  you need to clone it yourself before passing it in.
  
  Returns the numbers of changes made to the document. If the transform
  is unable to track the quantity (including the situation where it cannot
  tell B<IF> it made a change) it should return 1. Returns zero if no
  changes were made to the document, or C<undef> if an error occurs.
  
  By default this error is likely to only mean that you passed in something
  that wasn't a L<PPI::Document>, but may include additional errors
  depending on the subclass.
  
  =cut
  
  sub document {
  	my $class = shift;
  	die "$class does not implement the required ->document method";
  }
  
  =pod
  
  =head2 apply
  
  The C<apply> method is used to apply the transform to something. The
  argument must be a L<PPI::Document>, or something which can be turned
  into one and then be written back to again.
  
  Currently, this list is limited to a C<SCALAR> reference, although a
  handler registration process is available for you to add support for
  additional types of object should you wish (see the source for this module).
  
  Returns true if the transform was applied, false if there is an error in the
  transform process, or may die if there is a critical error in the apply
  handler.
  
  =cut
  
  sub apply {
  	my $self = _SELF(shift);
  	my $it   = defined $_[0] ? shift : return undef;
  
  	# Try to find an apply handler
  	my $class = _SCALAR0($it) ? 'SCALAR'
  		: List::Util::first { _INSTANCE($it, $_) } @ORDER
  		or return undef;
  	my $handler = $HANDLER{$class}
  		or die("->apply handler for $class missing! Panic");
  
  	# Get, change, set
  	my $Document = _INSTANCE($handler->[0]->($it), 'PPI::Document')
  		or Carp::croak("->apply handler for $class failed to get a PPI::Document");
  	$self->document( $Document ) or return undef;
  	$handler->[1]->($it, $Document)
  		or Carp::croak("->apply handler for $class failed to save the changed document");
  	1;		
  }
  
  =pod
  
  =head2 file
  
    # Read from one file and write to another
    $transform->file( 'Input.pm' => 'Output.pm' );
    
    # Change a file in place
    $transform->file( 'Change.pm' );
  
  The C<file> method modifies a Perl document by filename. If passed a single
  parameter, it modifies the file in-place. If provided a second parameter,
  it will attempt to save the modified file to the alternative filename.
  
  Returns true on success, or C<undef> on error.
  
  =cut
  
  sub file {
  	my $self = _SELF(shift);
  
  	# Where do we read from and write to
  	my $input  = defined $_[0] ? shift : return undef;
  	my $output = @_ ? defined $_[0] ? "$_[0]" : undef : $input or return undef;
  
  	# Process the file
  	my $Document = PPI::Document->new( "$input" ) or return undef;
  	$self->document( $Document )                  or return undef;
  	$Document->save( $output );
  }
  
  
  
  
  
  #####################################################################
  # Apply Hander Methods
  
  sub _SCALAR_get {
  	PPI::Document->new( $_[0] );
  }
  
  sub _SCALAR_set {
  	my $it = shift;
  	$$it = $_[0]->serialize;
  	1;
  }
  
  
  
  
  
  #####################################################################
  # Support Functions
  
  sub _SELF {
  	return shift if ref $_[0];
  	my $self = $_[0]->new or Carp::croak(
  		"Failed to auto-instantiate new $_[0] object"
  	);
  	$self;
  }
  
  1;
  
  =pod
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2001 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TRANSFORM

$fatpacked{"PPI/Transform/UpdateCopyright.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_TRANSFORM_UPDATECOPYRIGHT';
  package PPI::Transform::UpdateCopyright;
  
  =pod
  
  =head1 NAME
  
  PPI::Transform::UpdateCopyright - Demonstration PPI::Transform class
  
  =head1 SYNOPSIS
  
    my $transform = PPI::Transform::UpdateCopyright->new(
        name => 'Adam Kennedy'
    );
    
    $transform->file('Module.pm');
  
  =head1 DESCRIPTION
  
  B<PPI::Transform::UpdateCopyright> provides a demonstration of a typical
  L<PPI::Transform> class.
  
  This class implements a document transform that will take the name of an
  author and update the copyright statement to refer to the current year,
  if it does not already do so.
  
  =head1 METHODS
  
  =cut
  
  use strict;
  use Params::Util   qw{_STRING};
  use PPI::Transform ();
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.236';
  }
  
  
  
  
  
  #####################################################################
  # Constructor and Accessors
  
  =pod
  
  =head2 new
  
    my $transform = PPI::Transform::UpdateCopyright->new(
        name => 'Adam Kennedy'
    );
  
  The C<new> constructor creates a new transform object for a specific
  author. It takes a single C<name> parameter that should be the name
  (or longer string) for the author.
  
  Specifying the name is required to allow the changing of a subset of
  copyright statements that refer to you from a larger set in a file.
  
  =cut
  
  sub new {
  	my $self = shift->SUPER::new(@_);
  
  	# Must provide a name
  	unless ( defined _STRING($self->name) ) {
  		PPI::Exception->throw("Did not provide a valid name param");
  	}
  
  	return $self;
  }
  
  =pod
  
  =head2 name
  
  The C<name> accessor returns the author name that the transform will be
  searching for copyright statements of.
  
  =cut
  
  sub name {
  	$_[0]->{name};
  }
  
  
  
  
  
  #####################################################################
  # Transform
  
  sub document {
  	my $self     = shift;
  	my $document = _INSTANCE(shift, 'PPI::Document') or return undef;
  
  	# Find things to transform
  	my $name     = quotemeta $self->name;
  	my $regexp   = qr/\bcopyright\b.*$name/m;
  	my $elements = $document->find( sub {
  		$_[1]->isa('PPI::Token::Pod') or return '';
  		$_[1]->content =~ $regexp     or return '';
  		return 1;
  	} );
  	return undef unless defined $elements;
  	return 0 unless $elements;
  
  	# Try to transform any elements
  	my $changes = 0;
  	my $change  = sub {
  		my $copyright = shift;
  		my $thisyear  = (localtime time)[5] + 1900;
  		my @year      = $copyright =~ m/(\d{4})/g;
  
  		if ( @year == 1 ) {
  			# Handle the single year format
  			if ( $year[0] == $thisyear ) {
  				# No change
  				return $copyright;
  			} else {
  				# Convert from single year to multiple year
  				$changes++;
  				$copyright =~ s/(\d{4})/$1 - $thisyear/;
  				return $copyright;
  			}
  		}
  
  		if ( @year == 2 ) {
  			# Handle the range format
  			if ( $year[1] == $thisyear ) {
  				# No change
  				return $copyright;
  			} else {
  				# Change the second year to the current one
  				$changes++;
  				$copyright =~ s/$year[1]/$thisyear/;
  				return $copyright;
  			}
  		}
  
  		# huh?
  		die "Invalid or unknown copyright line '$copyright'";
  	};
  
  	# Attempt to transform each element
  	my $pattern = qr/\b(copyright.*\d)({4}(?:\s*-\s*\d{4})?)(.*$name)/mi;
  	foreach my $element ( @$elements ) {
  		$element =~ s/$pattern/$1 . $change->($2) . $2/eg;
  	}
  
  	return $changes;
  }
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - May need to overload some methods to forcefully prevent Document
  objects becoming children of another Node.
  
  =head1 SUPPORT
  
  See the L<support section|PPI/SUPPORT> in the main module.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2009 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
PPI_TRANSFORM_UPDATECOPYRIGHT

$fatpacked{"PPI/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_UTIL';
  package PPI::Util;
  
  # Provides some common utility functions that can be imported
  
  use strict;
  use Exporter     ();
  use Digest::MD5  ();
  use Params::Util qw{_INSTANCE _SCALAR0 _ARRAY0};
  
  use vars qw{$VERSION @ISA @EXPORT_OK};
  BEGIN {
  	$VERSION   = '1.236';
  	@ISA       = 'Exporter';
  	@EXPORT_OK = qw{_Document _slurp};
  }
  
  # 5.8.7 was the first version to resolve the notorious
  # "unicode length caching" bug.
  use constant HAVE_UNICODE => !! ( $] >= 5.008007 );
  
  # Common reusable true and false functions
  # This makes it easy to upgrade many places in PPI::XS
  sub TRUE  () { 1  }
  sub FALSE () { '' }
  
  
  
  
  
  #####################################################################
  # Functions
  
  # Allows a sub that takes a L<PPI::Document> to handle the full range
  # of different things, including file names, SCALAR source, etc.
  sub _Document {
  	shift if @_ > 1;
  	return undef unless defined $_[0];
  	require PPI::Document;
  	return PPI::Document->new(shift) unless ref $_[0];
  	return PPI::Document->new(shift) if _SCALAR0($_[0]);
  	return PPI::Document->new(shift) if _ARRAY0($_[0]);
  	return shift if _INSTANCE($_[0], 'PPI::Document');
  	return undef;
  }
  
  # Provide a simple _slurp implementation
  sub _slurp {
  	my $file = shift;
  	local $/ = undef;
  	local *FILE;
  	open( FILE, '<', $file ) or return "open($file) failed: $!";
  	my $source = <FILE>;
  	close( FILE ) or return "close($file) failed: $!";
  	return \$source;
  }
  
  # Provides a version of Digest::MD5's md5hex that explicitly
  # works on the unix-newlined version of the content.
  sub md5hex {
  	my $string = shift;
  	$string =~ s/(?:\015{1,2}\012|\015|\012)/\015/gs;
  	Digest::MD5::md5_hex($string);
  }
  
  # As above but slurps and calculates the id for a file by name
  sub md5hex_file {
  	my $file    = shift;
  	my $content = _slurp($file);
  	return undef unless ref $content;
  	$$content =~ s/(?:\015{1,2}\012|\015|\012)/\n/gs;
  	md5hex($$content);
  }
  
  1;
PPI_UTIL

$fatpacked{"PPI/XSAccessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PPI_XSACCESSOR';
  package PPI::XSAccessor;
  
  # This is an experimental prototype, use at your own risk.
  # Provides optional enhancement of PPI with Class::XSAccessor (if installed)
  
  use 5.006;
  use strict;
  use PPI ();
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.236';
  }
  
  
  
  
  
  ######################################################################
  # Replacement Methods
  
  # Packages are implemented here in alphabetical order
  
  package #hide from indexer
  	PPI::Document;
  
  use Class::XSAccessor
  	replace => 1,
  	getters => {
  		readonly => 'readonly',
  	},
  	true    => [
  		'scope'
  	];
  
  package #hide from indexer
  	PPI::Document::File;
  
  use Class::XSAccessor
  	replace => 1,
  	getters => {
  		filename => 'filename',
  	};
  
  package #hide from indexer
  	PPI::Document::Fragment;
  
  use Class::XSAccessor
  	replace => 1,
  	false   => [
  		'scope',
  	];
  
  package #hide from indexer
  	PPI::Document::Normalized;
  
  use Class::XSAccessor
  	replace => 1,
  	getters => {
  		'_Document' => 'Document',
  		'version'   => 'version',
  		'functions' => 'functions',
  	};
  
  package #hide from indexer
  	PPI::Element;
  
  use Class::XSAccessor
  	replace => 1,
  	true    => [
  		'significant',
  	];
  
  package #hide from indexer
  	PPI::Exception;
  
  use Class::XSAccessor
  	replace => 1,
  	getters => {
  		message => 'message',
  	};
  
  package #hide from indexer
  	PPI::Node;
  
  use Class::XSAccessor
  	replace => 1,
  	false   => [
  		'scope',
  	];
  
  package #hide from indexer
  	PPI::Normal;
  
  use Class::XSAccessor
  	replace => 1,
  	getters => {
  		'layer' => 'layer',
  	};
  
  package #hide from indexer
  	PPI::Statement;
  
  use Class::XSAccessor
  	replace => 1,
  	true    => [
  		'__LEXER__normal',
  	];
  
  package #hide from indexer
  	PPI::Statement::Compound;
  
  use Class::XSAccessor
  	replace => 1,
  	true    => [
  		'scope',
  	],
  	false   => [
  		'__LEXER__normal',
  	];
  
  package #hide from indexer
  	PPI::Statement::Data;
  
  use Class::XSAccessor
  	replace => 1,
  	false   => [
  		'_complete',
  	];
  
  package #hide from indexer
  	PPI::Statement::End;
  
  use Class::XSAccessor
  	replace => 1,
  	true    => [
  		'_complete',
  	];
  
  package #hide from indexer
  	PPI::Statement::Given;
  
  use Class::XSAccessor
  	replace => 1,
  	true    => [
  		'scope',
  	],
  	false   => [
  		'__LEXER__normal',
  	];
  
  package #hide from indexer
  	PPI::Token;
  
  use Class::XSAccessor
  	replace => 1,
  	getters => {
  		content => 'content',
  	},
  	setters => {
  		set_content => 'content',
  	},
  	true => [
  		'__TOKENIZER__on_line_start',
  		'__TOKENIZER__on_line_end',
  	];
  
  1;
PPI_XSACCESSOR

$fatpacked{"Parse/CPAN/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARSE_CPAN_META';
  use 5.008001;
  use strict;
  use warnings;
  package Parse::CPAN::Meta;
  # ABSTRACT: Parse META.yml and META.json CPAN metadata files
  
  our $VERSION = '2.150010';
  
  use Exporter;
  use Carp 'croak';
  
  our @ISA = qw/Exporter/;
  our @EXPORT_OK = qw/Load LoadFile/;
  
  sub load_file {
    my ($class, $filename) = @_;
  
    my $meta = _slurp($filename);
  
    if ($filename =~ /\.ya?ml$/) {
      return $class->load_yaml_string($meta);
    }
    elsif ($filename =~ /\.json$/) {
      return $class->load_json_string($meta);
    }
    else {
      $class->load_string($meta); # try to detect yaml/json
    }
  }
  
  sub load_string {
    my ($class, $string) = @_;
    if ( $string =~ /^---/ ) { # looks like YAML
      return $class->load_yaml_string($string);
    }
    elsif ( $string =~ /^\s*\{/ ) { # looks like JSON
      return $class->load_json_string($string);
    }
    else { # maybe doc-marker-free YAML
      return $class->load_yaml_string($string);
    }
  }
  
  sub load_yaml_string {
    my ($class, $string) = @_;
    my $backend = $class->yaml_backend();
    my $data = eval { no strict 'refs'; &{"$backend\::Load"}($string) };
    croak $@ if $@;
    return $data || {}; # in case document was valid but empty
  }
  
  sub load_json_string {
    my ($class, $string) = @_;
    require Encode;
    # load_json_string takes characters, decode_json expects bytes
    my $encoded = Encode::encode('UTF-8', $string, Encode::PERLQQ());
    my $data = eval { $class->json_decoder()->can('decode_json')->($encoded) };
    croak $@ if $@;
    return $data || {};
  }
  
  sub yaml_backend {
    if ($ENV{PERL_CORE} or not defined $ENV{PERL_YAML_BACKEND} ) {
      _can_load( 'CPAN::Meta::YAML', 0.011 )
        or croak "CPAN::Meta::YAML 0.011 is not available\n";
      return "CPAN::Meta::YAML";
    }
    else {
      my $backend = $ENV{PERL_YAML_BACKEND};
      _can_load( $backend )
        or croak "Could not load PERL_YAML_BACKEND '$backend'\n";
      $backend->can("Load")
        or croak "PERL_YAML_BACKEND '$backend' does not implement Load()\n";
      return $backend;
    }
  }
  
  sub json_decoder {
    if ($ENV{PERL_CORE}) {
      _can_load( 'JSON::PP' => 2.27300 )
        or croak "JSON::PP 2.27300 is not available\n";
      return 'JSON::PP';
    }
    if (my $decoder = $ENV{CPAN_META_JSON_DECODER}) {
      _can_load( $decoder )
        or croak "Could not load CPAN_META_JSON_DECODER '$decoder'\n";
      $decoder->can('decode_json')
        or croak "No decode_json sub provided by CPAN_META_JSON_DECODER '$decoder'\n";
      return $decoder;
    }
    return $_[0]->json_backend;
  }
  
  sub json_backend {
    if ($ENV{PERL_CORE}) {
      _can_load( 'JSON::PP' => 2.27300 )
        or croak "JSON::PP 2.27300 is not available\n";
      return 'JSON::PP';
    }
    if (my $backend = $ENV{CPAN_META_JSON_BACKEND}) {
      _can_load( $backend )
        or croak "Could not load CPAN_META_JSON_BACKEND '$backend'\n";
      $backend->can('new')
        or croak "No constructor provided by CPAN_META_JSON_BACKEND '$backend'\n";
      return $backend;
    }
    if (! $ENV{PERL_JSON_BACKEND} or $ENV{PERL_JSON_BACKEND} eq 'JSON::PP') {
      _can_load( 'JSON::PP' => 2.27300 )
        or croak "JSON::PP 2.27300 is not available\n";
      return 'JSON::PP';
    }
    else {
      _can_load( 'JSON' => 2.5 )
        or croak  "JSON 2.5 is required for " .
                  "\$ENV{PERL_JSON_BACKEND} = '$ENV{PERL_JSON_BACKEND}'\n";
      return "JSON";
    }
  }
  
  sub _slurp {
    require Encode;
    open my $fh, "<:raw", "$_[0]" ## no critic
      or die "can't open $_[0] for reading: $!";
    my $content = do { local $/; <$fh> };
    $content = Encode::decode('UTF-8', $content, Encode::PERLQQ());
    return $content;
  }
  
  sub _can_load {
    my ($module, $version) = @_;
    (my $file = $module) =~ s{::}{/}g;
    $file .= ".pm";
    return 1 if $INC{$file};
    return 0 if exists $INC{$file}; # prior load failed
    eval { require $file; 1 }
      or return 0;
    if ( defined $version ) {
      eval { $module->VERSION($version); 1 }
        or return 0;
    }
    return 1;
  }
  
  # Kept for backwards compatibility only
  # Create an object from a file
  sub LoadFile ($) { ## no critic
    return Load(_slurp(shift));
  }
  
  # Parse a document from a string.
  sub Load ($) { ## no critic
    require CPAN::Meta::YAML;
    my $object = eval { CPAN::Meta::YAML::Load(shift) };
    croak $@ if $@;
    return $object;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Parse::CPAN::Meta - Parse META.yml and META.json CPAN metadata files
  
  =head1 VERSION
  
  version 2.150010
  
  =head1 SYNOPSIS
  
      #############################################
      # In your file
  
      ---
      name: My-Distribution
      version: 1.23
      resources:
        homepage: "http://example.com/dist/My-Distribution"
  
  
      #############################################
      # In your program
  
      use Parse::CPAN::Meta;
  
      my $distmeta = Parse::CPAN::Meta->load_file('META.yml');
  
      # Reading properties
      my $name     = $distmeta->{name};
      my $version  = $distmeta->{version};
      my $homepage = $distmeta->{resources}{homepage};
  
  =head1 DESCRIPTION
  
  B<Parse::CPAN::Meta> is a parser for F<META.json> and F<META.yml> files, using
  L<JSON::PP> and/or L<CPAN::Meta::YAML>.
  
  B<Parse::CPAN::Meta> provides three methods: C<load_file>, C<load_json_string>,
  and C<load_yaml_string>.  These will read and deserialize CPAN metafiles, and
  are described below in detail.
  
  B<Parse::CPAN::Meta> provides a legacy API of only two functions,
  based on the YAML functions of the same name. Wherever possible,
  identical calling semantics are used.  These may only be used with YAML sources.
  
  All error reporting is done with exceptions (die'ing).
  
  Note that META files are expected to be in UTF-8 encoding, only.  When
  converted string data, it must first be decoded from UTF-8.
  
  =begin Pod::Coverage
  
  
  
  
  =end Pod::Coverage
  
  =head1 METHODS
  
  =head2 load_file
  
    my $metadata_structure = Parse::CPAN::Meta->load_file('META.json');
  
    my $metadata_structure = Parse::CPAN::Meta->load_file('META.yml');
  
  This method will read the named file and deserialize it to a data structure,
  determining whether it should be JSON or YAML based on the filename.
  The file will be read using the ":utf8" IO layer.
  
  =head2 load_yaml_string
  
    my $metadata_structure = Parse::CPAN::Meta->load_yaml_string($yaml_string);
  
  This method deserializes the given string of YAML and returns the first
  document in it.  (CPAN metadata files should always have only one document.)
  If the source was UTF-8 encoded, the string must be decoded before calling
  C<load_yaml_string>.
  
  =head2 load_json_string
  
    my $metadata_structure = Parse::CPAN::Meta->load_json_string($json_string);
  
  This method deserializes the given string of JSON and the result.
  If the source was UTF-8 encoded, the string must be decoded before calling
  C<load_json_string>.
  
  =head2 load_string
  
    my $metadata_structure = Parse::CPAN::Meta->load_string($some_string);
  
  If you don't know whether a string contains YAML or JSON data, this method
  will use some heuristics and guess.  If it can't tell, it assumes YAML.
  
  =head2 yaml_backend
  
    my $backend = Parse::CPAN::Meta->yaml_backend;
  
  Returns the module name of the YAML serializer. See L</ENVIRONMENT>
  for details.
  
  =head2 json_backend
  
    my $backend = Parse::CPAN::Meta->json_backend;
  
  Returns the module name of the JSON serializer.  If C<CPAN_META_JSON_BACKEND>
  is set, this will be whatever that's set to.  If not, this will either
  be L<JSON::PP> or L<JSON>.  If C<PERL_JSON_BACKEND> is set,
  this will return L<JSON> as further delegation is handled by
  the L<JSON> module.  See L</ENVIRONMENT> for details.
  
  =head2 json_decoder
  
    my $decoder = Parse::CPAN::Meta->json_decoder;
  
  Returns the module name of the JSON decoder.  Unlike L</json_backend>, this
  is not necessarily a full L<JSON>-style module, but only something that will
  provide a C<decode_json> subroutine.  If C<CPAN_META_JSON_DECODER> is set,
  this will be whatever that's set to.  If not, this will be whatever has
  been selected as L</json_backend>.  See L</ENVIRONMENT> for more notes.
  
  =head1 FUNCTIONS
  
  For maintenance clarity, no functions are exported by default.  These functions
  are available for backwards compatibility only and are best avoided in favor of
  C<load_file>.
  
  =head2 Load
  
    my @yaml = Parse::CPAN::Meta::Load( $string );
  
  Parses a string containing a valid YAML stream into a list of Perl data
  structures.
  
  =head2 LoadFile
  
    my @yaml = Parse::CPAN::Meta::LoadFile( 'META.yml' );
  
  Reads the YAML stream from a file instead of a string.
  
  =head1 ENVIRONMENT
  
  =head2 CPAN_META_JSON_DECODER
  
  By default, L<JSON::PP> will be used for deserializing JSON data.  If the
  C<CPAN_META_JSON_DECODER> environment variable exists, this is expected to
  be the name of a loadable module that provides a C<decode_json> subroutine,
  which will then be used for deserialization.  Relying only on the existence
  of said subroutine allows for maximum compatibility, since this API is
  provided by all of L<JSON::PP>, L<JSON::XS>, L<Cpanel::JSON::XS>,
  L<JSON::MaybeXS>, L<JSON::Tiny>, and L<Mojo::JSON>.
  
  =head2 CPAN_META_JSON_BACKEND
  
  By default, L<JSON::PP> will be used for deserializing JSON data.  If the
  C<CPAN_META_JSON_BACKEND> environment variable exists, this is expected to
  be the name of a loadable module that provides the L<JSON> API, since
  downstream code expects to be able to call C<new> on this class.  As such,
  while L<JSON::PP>, L<JSON::XS>, L<Cpanel::JSON::XS> and L<JSON::MaybeXS> will
  work for this, to use L<Mojo::JSON> or L<JSON::Tiny> for decoding requires
  setting L</CPAN_META_JSON_DECODER>.
  
  =head2 PERL_JSON_BACKEND
  
  If the C<CPAN_META_JSON_BACKEND> environment variable does not exist, and if
  C<PERL_JSON_BACKEND> environment variable exists, is true and is not
  "JSON::PP", then the L<JSON> module (version 2.5 or greater) will be loaded and
  used to interpret C<PERL_JSON_BACKEND>.  If L<JSON> is not installed or is too
  old, an exception will be thrown.  Note that at the time of writing, the only
  useful values are 1, which will tell L<JSON> to guess, or L<JSON::XS> - if
  you want to use a newer JSON module, see L</CPAN_META_JSON_BACKEND>.
  
  =head2 PERL_YAML_BACKEND
  
  By default, L<CPAN::Meta::YAML> will be used for deserializing YAML data. If
  the C<PERL_YAML_BACKEND> environment variable is defined, then it is interpreted
  as a module to use for deserialization.  The given module must be installed,
  must load correctly and must implement the C<Load()> function or an exception
  will be thrown.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Adam Kennedy <adamk@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by David Golden, Ricardo Signes, Adam Kennedy and Contributors.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PARSE_CPAN_META

$fatpacked{"Text/Glob.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_GLOB';
  package Text::Glob;
  use strict;
  use Exporter;
  use vars qw/$VERSION @ISA @EXPORT_OK
              $strict_leading_dot $strict_wildcard_slash/;
  $VERSION = '0.11';
  @ISA = 'Exporter';
  @EXPORT_OK = qw( glob_to_regex glob_to_regex_string match_glob );
  
  $strict_leading_dot    = 1;
  $strict_wildcard_slash = 1;
  
  use constant debug => 0;
  
  sub glob_to_regex {
      my $glob = shift;
      my $regex = glob_to_regex_string($glob);
      return qr/^$regex$/;
  }
  
  sub glob_to_regex_string
  {
      my $glob = shift;
  
      my $seperator = $Text::Glob::seperator;
      $seperator = "/" unless defined $seperator;
      $seperator = quotemeta($seperator);
  
      my ($regex, $in_curlies, $escaping);
      local $_;
      my $first_byte = 1;
      for ($glob =~ m/(.)/gs) {
          if ($first_byte) {
              if ($strict_leading_dot) {
                  $regex .= '(?=[^\.])' unless $_ eq '.';
              }
              $first_byte = 0;
          }
          if ($_ eq '/') {
              $first_byte = 1;
          }
          if ($_ eq '.' || $_ eq '(' || $_ eq ')' || $_ eq '|' ||
              $_ eq '+' || $_ eq '^' || $_ eq '$' || $_ eq '@' || $_ eq '%' ) {
              $regex .= "\\$_";
          }
          elsif ($_ eq '*') {
              $regex .= $escaping ? "\\*" :
                $strict_wildcard_slash ? "(?:(?!$seperator).)*" : ".*";
          }
          elsif ($_ eq '?') {
              $regex .= $escaping ? "\\?" :
                $strict_wildcard_slash ? "(?!$seperator)." : ".";
          }
          elsif ($_ eq '{') {
              $regex .= $escaping ? "\\{" : "(";
              ++$in_curlies unless $escaping;
          }
          elsif ($_ eq '}' && $in_curlies) {
              $regex .= $escaping ? "}" : ")";
              --$in_curlies unless $escaping;
          }
          elsif ($_ eq ',' && $in_curlies) {
              $regex .= $escaping ? "," : "|";
          }
          elsif ($_ eq "\\") {
              if ($escaping) {
                  $regex .= "\\\\";
                  $escaping = 0;
              }
              else {
                  $escaping = 1;
              }
              next;
          }
          else {
              $regex .= $_;
              $escaping = 0;
          }
          $escaping = 0;
      }
      print "# $glob $regex\n" if debug;
  
      return $regex;
  }
  
  sub match_glob {
      print "# ", join(', ', map { "'$_'" } @_), "\n" if debug;
      my $glob = shift;
      my $regex = glob_to_regex $glob;
      local $_;
      grep { $_ =~ $regex } @_;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Text::Glob - match globbing patterns against text
  
  =head1 SYNOPSIS
  
   use Text::Glob qw( match_glob glob_to_regex );
  
   print "matched\n" if match_glob( "foo.*", "foo.bar" );
  
   # prints foo.bar and foo.baz
   my $regex = glob_to_regex( "foo.*" );
   for ( qw( foo.bar foo.baz foo bar ) ) {
       print "matched: $_\n" if /$regex/;
   }
  
  =head1 DESCRIPTION
  
  Text::Glob implements glob(3) style matching that can be used to match
  against text, rather than fetching names from a filesystem.  If you
  want to do full file globbing use the File::Glob module instead.
  
  =head2 Routines
  
  =over
  
  =item match_glob( $glob, @things_to_test )
  
  Returns the list of things which match the glob from the source list.
  
  =item glob_to_regex( $glob )
  
  Returns a compiled regex which is the equivalent of the globbing
  pattern.
  
  =item glob_to_regex_string( $glob )
  
  Returns a regex string which is the equivalent of the globbing
  pattern.
  
  =back
  
  =head1 SYNTAX
  
  The following metacharacters and rules are respected.
  
  =over
  
  =item C<*> - match zero or more characters
  
  C<a*> matches C<a>, C<aa>, C<aaaa> and many many more.
  
  =item C<?> - match exactly one character
  
  C<a?> matches C<aa>, but not C<a>, or C<aaa>
  
  =item Character sets/ranges
  
  C<example.[ch]> matches C<example.c> and C<example.h>
  
  C<demo.[a-c]> matches C<demo.a>, C<demo.b>, and C<demo.c>
  
  =item alternation
  
  C<example.{foo,bar,baz}> matches C<example.foo>, C<example.bar>, and
  C<example.baz>
  
  =item leading . must be explicitly matched
  
  C<*.foo> does not match C<.bar.foo>.  For this you must either specify
  the leading . in the glob pattern (C<.*.foo>), or set
  C<$Text::Glob::strict_leading_dot> to a false value while compiling
  the regex.
  
  =item C<*> and C<?> do not match the seperator (i.e. do not match C</>)
  
  C<*.foo> does not match C<bar/baz.foo>.  For this you must either
  explicitly match the / in the glob (C<*/*.foo>), or set
  C<$Text::Glob::strict_wildcard_slash> to a false value while compiling
  the regex, or change the seperator that Text::Glob uses by setting
  C<$Text::Glob::seperator> to an alternative value while compiling the
  the regex.
  
  =back
  
  =head1 BUGS
  
  The code uses qr// to produce compiled regexes, therefore this module
  requires perl version 5.005_03 or newer.
  
  =head1 AUTHOR
  
  Richard Clamp <richardc@unixbeard.net>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2002, 2003, 2006, 2007 Richard Clamp.  All Rights Reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<File::Glob>, glob(3)
  
  =cut
TEXT_GLOB

$fatpacked{"darwin-2level/Clone.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CLONE';
  package Clone;
  
  use strict;
  use vars qw($VERSION @ISA @EXPORT @EXPORT_OK $AUTOLOAD);
  
  require Exporter;
  require DynaLoader;
  require AutoLoader;
  
  @ISA       = qw(Exporter DynaLoader);
  @EXPORT    = qw();
  @EXPORT_OK = qw( clone );
  
  $VERSION = '0.39';
  
  bootstrap Clone $VERSION;
  
  1;
  __END__
  
  =head1 NAME
  
  Clone - recursively copy Perl datatypes
  
  =for html
  <a href="https://travis-ci.org/garu/Clone"><img src="https://travis-ci.org/garu/Clone.png?branch=master" alt="Build Status"></a>
  <a href="https://coveralls.io/r/garu/Clone?branch=master"><img src="https://coveralls.io/repos/garu/Clone/badge.png?branch=master" alt="Coverage Status"></a>
  <a href="https://metacpan.org/pod/Clone"><img src="https://badge.fury.io/pl/Clone.svg" alt="CPAN version"></a>
  
  =head1 SYNOPSIS
  
      use Clone 'clone';
  
      my $data = {
         set => [ 1 .. 50 ],
         foo => {
             answer => 42,
             object => SomeObject->new,
         },
      };
  
      my $cloned_data = clone($data);
  
      $cloned_data->{foo}{answer} = 1;
      print $cloned_data->{foo}{answer};  # '1'
      print $data->{foo}{answer};         # '42'
  
  You can also add it to your class:
  
      package Foo;
      use parent 'Clone';
      sub new { bless {}, shift }
  
      package main;
  
      my $obj = Foo->new;
      my $copy = $obj->clone;
  
  =head1 DESCRIPTION
  
  This module provides a C<clone()> method which makes recursive
  copies of nested hash, array, scalar and reference types,
  including tied variables and objects.
  
  C<clone()> takes a scalar argument and duplicates it. To duplicate lists,
  arrays or hashes, pass them in by reference, e.g.
  
      my $copy = clone (\@array);
  
      # or
  
      my %copy = %{ clone (\%hash) };
  
  =head1 SEE ALSO
  
  L<Storable>'s C<dclone()> is a flexible solution for cloning variables,
  albeit slower for average-sized data structures. Simple
  and naive benchmarks show that Clone is faster for data structures
  with 3 or fewer levels, while C<dclone()> can be faster for structures
  4 or more levels deep.
  
  =head1 COPYRIGHT
  
  Copyright 2001-2017 Ray Finch. All Rights Reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Ray Finch C<< <rdf@cpan.org> >>
  
  Breno G. de Oliveira C<< <garu@cpan.org> >> and
  Florian Ragwitz C<< <rafl@debian.org> >> perform routine maintenance
  releases since 2012.
  
  =cut
DARWIN-2LEVEL_CLONE

$fatpacked{"darwin-2level/Params/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_PARAMS_UTIL';
  package Params::Util;
  
  =pod
  
  =head1 NAME
  
  Params::Util - Simple, compact and correct param-checking functions
  
  =head1 SYNOPSIS
  
    # Import some functions
    use Params::Util qw{_SCALAR _HASH _INSTANCE};
    
    # If you are lazy, or need a lot of them...
    use Params::Util ':ALL';
    
    sub foo {
        my $object  = _INSTANCE(shift, 'Foo') or return undef;
        my $image   = _SCALAR(shift)          or return undef;
        my $options = _HASH(shift)            or return undef;
        # etc...
    }
  
  =head1 DESCRIPTION
  
  C<Params::Util> provides a basic set of importable functions that makes
  checking parameters a hell of a lot easier
  
  While they can be (and are) used in other contexts, the main point
  behind this module is that the functions B<both> Do What You Mean,
  and Do The Right Thing, so they are most useful when you are getting
  params passed into your code from someone and/or somewhere else
  and you can't really trust the quality.
  
  Thus, C<Params::Util> is of most use at the edges of your API, where
  params and data are coming in from outside your code.
  
  The functions provided by C<Params::Util> check in the most strictly
  correct manner known, are documented as thoroughly as possible so their
  exact behaviour is clear, and heavily tested so make sure they are not
  fooled by weird data and Really Bad Things.
  
  To use, simply load the module providing the functions you want to use
  as arguments (as shown in the SYNOPSIS).
  
  To aid in maintainability, C<Params::Util> will B<never> export by
  default.
  
  You must explicitly name the functions you want to export, or use the
  C<:ALL> param to just have it export everything (although this is not
  recommended if you have any _FOO functions yourself with which future
  additions to C<Params::Util> may clash)
  
  =head1 FUNCTIONS
  
  =cut
  
  use 5.00503;
  use strict;
  require overload;
  require Exporter;
  require Scalar::Util;
  require DynaLoader;
  
  use vars qw{$VERSION @ISA @EXPORT_OK %EXPORT_TAGS};
  
  $VERSION   = '1.07';
  @ISA       = qw{
  	Exporter
  	DynaLoader
  };
  @EXPORT_OK = qw{
  	_STRING     _IDENTIFIER
  	_CLASS      _CLASSISA   _SUBCLASS  _DRIVER  _CLASSDOES
  	_NUMBER     _POSINT     _NONNEGINT
  	_SCALAR     _SCALAR0
  	_ARRAY      _ARRAY0     _ARRAYLIKE
  	_HASH       _HASH0      _HASHLIKE
  	_CODE       _CODELIKE
  	_INVOCANT   _REGEX      _INSTANCE  _INSTANCEDOES
  	_SET        _SET0
  	_HANDLE
  };
  %EXPORT_TAGS = ( ALL => \@EXPORT_OK );
  
  eval {
  	local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
  	bootstrap Params::Util $VERSION;
  	1;
  } unless $ENV{PERL_PARAMS_UTIL_PP};
  
  # Use a private pure-perl copy of looks_like_number if the version of
  # Scalar::Util is old (for whatever reason).
  my $SU = eval "$Scalar::Util::VERSION" || 0;
  if ( $SU >= 1.18 ) { 
  	Scalar::Util->import('looks_like_number');
  } else {
  	eval <<'END_PERL';
  sub looks_like_number {
  	local $_ = shift;
  
  	# checks from perlfaq4
  	return 0 if !defined($_);
  	if (ref($_)) {
  		return overload::Overloaded($_) ? defined(0 + $_) : 0;
  	}
  	return 1 if (/^[+-]?[0-9]+$/); # is a +/- integer
  	return 1 if (/^([+-]?)(?=[0-9]|\.[0-9])[0-9]*(\.[0-9]*)?([Ee]([+-]?[0-9]+))?$/); # a C float
  	return 1 if ($] >= 5.008 and /^(Inf(inity)?|NaN)$/i) or ($] >= 5.006001 and /^Inf$/i);
  
  	0;
  }
  END_PERL
  }
  
  
  
  
  
  #####################################################################
  # Param Checking Functions
  
  =pod
  
  =head2 _STRING $string
  
  The C<_STRING> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a normal non-false string of non-zero length.
  
  Note that this will NOT do anything magic to deal with the special
  C<'0'> false negative case, but will return it.
  
    # '0' not considered valid data
    my $name = _STRING(shift) or die "Bad name";
    
    # '0' is considered valid data
    my $string = _STRING($_[0]) ? shift : die "Bad string";
  
  Please also note that this function expects a normal string. It does
  not support overloading or other magic techniques to get a string.
  
  Returns the string as a conveince if it is a valid string, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_STRING;
  sub _STRING ($) {
  	(defined $_[0] and ! ref $_[0] and length($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _IDENTIFIER $string
  
  The C<_IDENTIFIER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl identifier.
  
  Returns the string as a convenience if it is a valid identifier, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_IDENTIFIER;
  sub _IDENTIFIER ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASS $string
  
  The C<_CLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl class.
  
  This function only checks that the format is valid, not that the
  class is actually loaded. It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASS;
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASSISA $string, $class
  
  The C<_CLASSISA> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a particularly class, or a subclass of it.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSISA;
  sub _CLASSISA ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =head2 _CLASSDOES $string, $role
  
  This routine behaves exactly like C<L</_CLASSISA>>, but checks with C<< ->DOES
  >> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
  5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
  implemented.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSDOES;
  sub _CLASSDOES ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SUBCLASS $string, $class
  
  The C<_SUBCLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a subclass of a specified class.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SUBCLASS;
  sub _SUBCLASS ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0] ne $_[1] and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NUMBER $scalar
  
  The C<_NUMBER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a number. That is, it is defined and perl thinks it's a number.
  
  This function is basically a Params::Util-style wrapper around the
  L<Scalar::Util> C<looks_like_number> function.
  
  Returns the value as a convience, or C<undef> if the value is not a
  number.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NUMBER;
  sub _NUMBER ($) {
  	( defined $_[0] and ! ref $_[0] and looks_like_number($_[0]) )
  	? $_[0]
  	: undef;
  }
  END_PERL
  
  =pod
  
  =head2 _POSINT $integer
  
  The C<_POSINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a positive integer (of any length).
  
  Returns the value as a convience, or C<undef> if the value is not a
  positive integer.
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_POSINT;
  sub _POSINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[1-9]\d*$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NONNEGINT $integer
  
  The C<_NONNEGINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a non-negative integer (of any length). That is, a positive integer,
  or zero.
  
  Returns the value as a convience, or C<undef> if the value is not a
  non-negative integer.
  
  As with other tests that may return false values, care should be taken
  to test via "defined" in boolean validy contexts.
  
    unless ( defined _NONNEGINT($value) ) {
       die "Invalid value";
    }
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NONNEGINT;
  sub _NONNEGINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^(?:0|[1-9]\d*)$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR \$scalar
  
  The C<_SCALAR> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR> reference, with content of non-zero length.
  
  For a version that allows zero length C<SCALAR> references, see
  the C<_SCALAR0> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR;
  sub _SCALAR ($) {
  	(ref $_[0] eq 'SCALAR' and defined ${$_[0]} and ${$_[0]} ne '') ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR0 \$scalar
  
  The C<_SCALAR0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR0> reference, allowing content of zero-length.
  
  For a simpler "give me some content" version that requires non-zero
  length, C<_SCALAR> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR0;
  sub _SCALAR0 ($) {
  	ref $_[0] eq 'SCALAR' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY $value
  
  The C<_ARRAY> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference containing B<at least> one element of any kind.
  
  For a more basic form that allows zero length ARRAY references, see
  the C<_ARRAY0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY;
  sub _ARRAY ($) {
  	(ref $_[0] eq 'ARRAY' and @{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY0 $value
  
  The C<_ARRAY0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference, allowing C<ARRAY> references that contain no
  elements.
  
  For a more basic "An array of something" form that also requires at
  least one element, see the C<_ARRAY> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY0;
  sub _ARRAY0 ($) {
  	ref $_[0] eq 'ARRAY' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAYLIKE $value
  
  The C<_ARRAYLIKE> function tests whether a given scalar value can respond to
  array dereferencing.  If it can, the value is returned.  If it cannot,
  C<_ARRAYLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAYLIKE;
  sub _ARRAYLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'ARRAY')
  		or
  		overload::Method($_[0], '@{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH $value
  
  The C<_HASH> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference with at least one entry.
  
  For a version of this function that allows the C<HASH> to be empty,
  see the C<_HASH0> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH;
  sub _HASH ($) {
  	(ref $_[0] eq 'HASH' and scalar %{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH0 $value
  
  The C<_HASH0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference, regardless of the C<HASH> content.
  
  For a simpler "A hash of something" version that requires at least one
  element, see the C<_HASH> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH0;
  sub _HASH0 ($) {
  	ref $_[0] eq 'HASH' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASHLIKE $value
  
  The C<_HASHLIKE> function tests whether a given scalar value can respond to
  hash dereferencing.  If it can, the value is returned.  If it cannot,
  C<_HASHLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASHLIKE;
  sub _HASHLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'HASH')
  		or
  		overload::Method($_[0], '%{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODE $value
  
  The C<_CODE> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<CODE> reference.
  
  Returns the C<CODE> reference itself as a convenience, or C<undef>
  if the value provided is not an C<CODE> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODE;
  sub _CODE ($) {
  	ref $_[0] eq 'CODE' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODELIKE $value
  
  The C<_CODELIKE> is the more generic version of C<_CODE>. Unlike C<_CODE>,
  which checks for an explicit C<CODE> reference, the C<_CODELIKE> function
  also includes things that act like them, such as blessed objects that
  overload C<'&{}'>.
  
  Please note that in the case of objects overloaded with '&{}', you will
  almost always end up also testing it in 'bool' context at some stage.
  
  For example:
  
    sub foo {
        my $code1 = _CODELIKE(shift) or die "No code param provided";
        my $code2 = _CODELIKE(shift);
        if ( $code2 ) {
             print "Got optional second code param";
        }
    }
  
  As such, you will most likely always want to make sure your class has
  at least the following to allow it to evaluate to true in boolean
  context.
  
    # Always evaluate to true in boolean context
    use overload 'bool' => sub () { 1 };
  
  Returns the callable value as a convenience, or C<undef> if the
  value provided is not callable.
  
  Note - This function was formerly known as _CALLABLE but has been renamed
  for greater symmetry with the other _XXXXLIKE functions.
  
  The use of _CALLABLE has been deprecated. It will continue to work, but
  with a warning, until end-2006, then will be removed.
  
  I apologise for any inconvenience caused.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODELIKE;
  sub _CODELIKE($) {
  	(
  		(Scalar::Util::reftype($_[0])||'') eq 'CODE'
  		or
  		Scalar::Util::blessed($_[0]) and overload::Method($_[0],'&{}')
  	)
  	? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INVOCANT $value
  
  This routine tests whether the given value is a valid method invocant.
  This can be either an instance of an object, or a class name.
  
  If so, the value itself is returned.  Otherwise, C<_INVOCANT>
  returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INVOCANT;
  sub _INVOCANT($) {
  	(defined $_[0] and
  		(defined Scalar::Util::blessed($_[0])
  		or      
  		# We used to check for stash definedness, but any class-like name is a
  		# valid invocant for UNIVERSAL methods, so we stopped. -- rjbs, 2006-07-02
  		Params::Util::_CLASS($_[0]))
  	) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INSTANCE $object, $class
  
  The C<_INSTANCE> function is intended to be imported into your package,
  and provides a convenient way to test for an object of a particular class
  in a strictly correct manner.
  
  Returns the object itself as a convenience, or C<undef> if the value
  provided is not an object of that type.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCE;
  sub _INSTANCE ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =head2 _INSTANCEDOES $object, $role
  
  This routine behaves exactly like C<L</_INSTANCE>>, but checks with C<< ->DOES
  >> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
  5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
  implemented.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCEDOES;
  sub _INSTANCEDOES ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _REGEX $value
  
  The C<_REGEX> function is intended to be imported into your package,
  and provides a convenient way to test for a regular expression.
  
  Returns the value itself as a convenience, or C<undef> if the value
  provided is not a regular expression.
  
  =cut
  
  eval <<'END_PERL' unless defined &_REGEX;
  sub _REGEX ($) {
  	(defined $_[0] and 'Regexp' eq ref($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SET \@array, $class
  
  The C<_SET> function is intended to be imported into your package,
  and provides a convenient way to test for set of at least one object of
  a particular class in a strictly correct manner.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that allows zero-length sets, see the
  C<_SET0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET;
  sub _SET ($$) {
  	my $set = shift;
  	_ARRAY($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _SET0 \@array, $class
  
  The C<_SET0> function is intended to be imported into your package,
  and provides a convenient way to test for a set of objects of a
  particular class in a strictly correct manner, allowing for zero objects.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that requires at least one object, see the
  C<_SET> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET0;
  sub _SET0 ($$) {
  	my $set = shift;
  	_ARRAY0($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _HANDLE
  
  The C<_HANDLE> function is intended to be imported into your package,
  and provides a convenient way to test whether or not a single scalar
  value is a file handle.
  
  Unfortunately, in Perl the definition of a file handle can be a little
  bit fuzzy, so this function is likely to be somewhat imperfect (at first
  anyway).
  
  That said, it is implement as well or better than the other file handle
  detectors in existance (and we stole from the best of them).
  
  =cut
  
  # We're doing this longhand for now. Once everything is perfect,
  # we'll compress this into something that compiles more efficiently.
  # Further, testing file handles is not something that is generally
  # done millions of times, so doing it slowly is not a big speed hit.
  eval <<'END_PERL' unless defined &_HANDLE;
  sub _HANDLE {
  	my $it = shift;
  
  	# It has to be defined, of course
  	unless ( defined $it ) {
  		return undef;
  	}
  
  	# Normal globs are considered to be file handles
  	if ( ref $it eq 'GLOB' ) {
  		return $it;
  	}
  
  	# Check for a normal tied filehandle
  	# Side Note: 5.5.4's tied() and can() doesn't like getting undef
  	if ( tied($it) and tied($it)->can('TIEHANDLE') ) {
  		return $it;
  	}
  
  	# There are no other non-object handles that we support
  	unless ( Scalar::Util::blessed($it) ) {
  		return undef;
  	}
  
  	# Check for a common base classes for conventional IO::Handle object
  	if ( $it->isa('IO::Handle') ) {
  		return $it;
  	}
  
  
  	# Check for tied file handles using Tie::Handle
  	if ( $it->isa('Tie::Handle') ) {
  		return $it;
  	}
  
  	# IO::Scalar is not a proper seekable, but it is valid is a
  	# regular file handle
  	if ( $it->isa('IO::Scalar') ) {
  		return $it;
  	}
  
  	# Yet another special case for IO::String, which refuses (for now
  	# anyway) to become a subclass of IO::Handle.
  	if ( $it->isa('IO::String') ) {
  		return $it;
  	}
  
  	# This is not any sort of object we know about
  	return undef;
  }
  END_PERL
  
  =pod
  
  =head2 _DRIVER $string
  
    sub foo {
      my $class = _DRIVER(shift, 'My::Driver::Base') or die "Bad driver";
      ...
    }
  
  The C<_DRIVER> function is intended to be imported into your
  package, and provides a convenient way to load and validate
  a driver class.
  
  The most common pattern when taking a driver class as a parameter
  is to check that the name is a class (i.e. check against _CLASS)
  and then to load the class (if it exists) and then ensure that
  the class returns true for the isa method on some base driver name.
  
  Return the value as a convenience, or C<undef> if the value is not
  a class name, the module does not exist, the module does not load,
  or the class fails the isa test.
  
  =cut
  
  eval <<'END_PERL' unless defined &_DRIVER;
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  END_PERL
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Add _CAN to help resolve the UNIVERSAL::can debacle
  
  - Would be even nicer if someone would demonstrate how the hell to
  build a Module::Install dist of the ::Util dual Perl/XS type. :/
  
  - Implement an assertion-like version of this module, that dies on
  error.
  
  - Implement a Test:: version of this module, for use in testing
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params-Util>
  
  For other issues, contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Params::Validate>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2012 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
DARWIN-2LEVEL_PARAMS_UTIL

$fatpacked{"darwin-2level/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_VERSION';
  #!perl -w
  package version;
  
  use 5.006002;
  use strict;
  use warnings::register;
  if ($] >= 5.015) {
      warnings::register_categories(qw/version/);
  }
  
  our $VERSION = 0.9924;
  our $CLASS = 'version';
  our (@ISA, $STRICT, $LAX);
  
  # !!!!Delete this next block completely when adding to Perl core!!!!
  {
      local $SIG{'__DIE__'};
      eval "use version::vxs $VERSION";
      if ( $@ ) { # don't have the XS version installed
  	eval "use version::vpp $VERSION"; # don't tempt fate
  	die "$@" if ( $@ );
  	push @ISA, "version::vpp";
  	local $^W;
  	*version::qv = \&version::vpp::qv;
  	*version::declare = \&version::vpp::declare;
  	*version::_VERSION = \&version::vpp::_VERSION;
  	*version::vcmp = \&version::vpp::vcmp;
  	*version::new = \&version::vpp::new;
  	*version::numify = \&version::vpp::numify;
  	*version::normal = \&version::vpp::normal;
  	if ($] >= 5.009000) {
  	    no strict 'refs';
  	    *version::stringify = \&version::vpp::stringify;
  	    *{'version::(""'} = \&version::vpp::stringify;
  	    *{'version::(<=>'} = \&version::vpp::vcmp;
  	    *{'version::(cmp'} = \&version::vpp::vcmp;
  	    *version::parse = \&version::vpp::parse;
  	}
      }
      else { # use XS module
  	push @ISA, "version::vxs";
  	local $^W;
  	*version::declare = \&version::vxs::declare;
  	*version::qv = \&version::vxs::qv;
  	*version::_VERSION = \&version::vxs::_VERSION;
  	*version::vcmp = \&version::vxs::VCMP;
  	*version::new = \&version::vxs::new;
  	*version::numify = \&version::vxs::numify;
  	*version::normal = \&version::vxs::normal;
  	if ($] >= 5.009000) {
  	    no strict 'refs';
  	    *version::stringify = \&version::vxs::stringify;
  	    *{'version::(""'} = \&version::vxs::stringify;
  	    *{'version::(<=>'} = \&version::vxs::VCMP;
  	    *{'version::(cmp'} = \&version::vxs::VCMP;
  	    *version::parse = \&version::vxs::parse;
  	}
      }
  }
  
  # avoid using Exporter
  require version::regex;
  *version::is_lax = \&version::regex::is_lax;
  *version::is_strict = \&version::regex::is_strict;
  *LAX = \$version::regex::LAX;
  *LAX_DECIMAL_VERSION = \$version::regex::LAX_DECIMAL_VERSION;
  *LAX_DOTTED_DECIMAL_VERSION = \$version::regex::LAX_DOTTED_DECIMAL_VERSION;
  *STRICT = \$version::regex::STRICT;
  *STRICT_DECIMAL_VERSION = \$version::regex::STRICT_DECIMAL_VERSION;
  *STRICT_DOTTED_DECIMAL_VERSION = \$version::regex::STRICT_DOTTED_DECIMAL_VERSION;
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	local $^W;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  
  1;
DARWIN-2LEVEL_VERSION

$fatpacked{"darwin-2level/version/regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_VERSION_REGEX';
  package version::regex;
  
  use strict;
  
  our $VERSION = 0.9924;
  
  #--------------------------------------------------------------------------#
  # Version regexp components
  #--------------------------------------------------------------------------#
  
  # Fraction part of a decimal version number.  This is a common part of
  # both strict and lax decimal versions
  
  my $FRACTION_PART = qr/\.[0-9]+/;
  
  # First part of either decimal or dotted-decimal strict version number.
  # Unsigned integer with no leading zeroes (except for zero itself) to
  # avoid confusion with octal.
  
  my $STRICT_INTEGER_PART = qr/0|[1-9][0-9]*/;
  
  # First part of either decimal or dotted-decimal lax version number.
  # Unsigned integer, but allowing leading zeros.  Always interpreted
  # as decimal.  However, some forms of the resulting syntax give odd
  # results if used as ordinary Perl expressions, due to how perl treats
  # octals.  E.g.
  #   version->new("010" ) == 10
  #   version->new( 010  ) == 8
  #   version->new( 010.2) == 82  # "8" . "2"
  
  my $LAX_INTEGER_PART = qr/[0-9]+/;
  
  # Second and subsequent part of a strict dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.
  # Limited to three digits to avoid overflow when converting to decimal
  # form and also avoid problematic style with excessive leading zeroes.
  
  my $STRICT_DOTTED_DECIMAL_PART = qr/\.[0-9]{1,3}/;
  
  # Second and subsequent part of a lax dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.  No
  # limit on the numerical value or number of digits, so there is the
  # possibility of overflow when converting to decimal form.
  
  my $LAX_DOTTED_DECIMAL_PART = qr/\.[0-9]+/;
  
  # Alpha suffix part of lax version number syntax.  Acts like a
  # dotted-decimal part.
  
  my $LAX_ALPHA_PART = qr/_[0-9]+/;
  
  #--------------------------------------------------------------------------#
  # Strict version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Strict decimal version number.
  
  our $STRICT_DECIMAL_VERSION =
      qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;
  
  # Strict dotted-decimal version number.  Must have both leading "v" and
  # at least three parts, to avoid confusion with decimal syntax.
  
  our $STRICT_DOTTED_DECIMAL_VERSION =
      qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;
  
  # Complete strict version number syntax -- should generally be used
  # anchored: qr/ \A $STRICT \z /x
  
  our $STRICT =
      qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  # Lax version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Lax decimal version number.  Just like the strict one except for
  # allowing an alpha suffix or allowing a leading or trailing
  # decimal-point
  
  our $LAX_DECIMAL_VERSION =
      qr/ $LAX_INTEGER_PART (?: $FRACTION_PART | \. )? $LAX_ALPHA_PART?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;
  
  # Lax dotted-decimal version number.  Distinguished by having either
  # leading "v" or at least three non-alpha parts.  Alpha part is only
  # permitted if there are at least two non-alpha parts. Strangely
  # enough, without the leading "v", Perl takes .1.2 to mean v0.1.2,
  # so when there is no "v", the leading part is optional
  
  our $LAX_DOTTED_DECIMAL_VERSION =
      qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;
  
  # Complete lax version number syntax -- should generally be used
  # anchored: qr/ \A $LAX \z /x
  #
  # The string 'undef' is a special case to make for easier handling
  # of return values from ExtUtils::MM->parse_version
  
  our $LAX =
      qr/ undef | $LAX_DOTTED_DECIMAL_VERSION | $LAX_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  
  # Preloaded methods go here.
  sub is_strict	{ defined $_[0] && $_[0] =~ qr/ \A $STRICT \z /x }
  sub is_lax	{ defined $_[0] && $_[0] =~ qr/ \A $LAX \z /x }
  
  1;
DARWIN-2LEVEL_VERSION_REGEX

$fatpacked{"darwin-2level/version/vpp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_VERSION_VPP';
  package charstar;
  # a little helper class to emulate C char* semantics in Perl
  # so that prescan_version can use the same code as in C
  
  use overload (
      '""'	=> \&thischar,
      '0+'	=> \&thischar,
      '++'	=> \&increment,
      '--'	=> \&decrement,
      '+'		=> \&plus,
      '-'		=> \&minus,
      '*'		=> \&multiply,
      'cmp'	=> \&cmp,
      '<=>'	=> \&spaceship,
      'bool'	=> \&thischar,
      '='		=> \&clone,
  );
  
  sub new {
      my ($self, $string) = @_;
      my $class = ref($self) || $self;
  
      my $obj = {
  	string  => [split(//,$string)],
  	current => 0,
      };
      return bless $obj, $class;
  }
  
  sub thischar {
      my ($self) = @_;
      my $last = $#{$self->{string}};
      my $curr = $self->{current};
      if ($curr >= 0 && $curr <= $last) {
  	return $self->{string}->[$curr];
      }
      else {
  	return '';
      }
  }
  
  sub increment {
      my ($self) = @_;
      $self->{current}++;
  }
  
  sub decrement {
      my ($self) = @_;
      $self->{current}--;
  }
  
  sub plus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} += $offset;
      return $rself;
  }
  
  sub minus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} -= $offset;
      return $rself;
  }
  
  sub multiply {
      my ($left, $right, $swapped) = @_;
      my $char = $left->thischar();
      return $char * $right;
  }
  
  sub spaceship {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	$right = $left->new($right);
      }
      return $left->{current} <=> $right->{current};
  }
  
  sub cmp {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	if (length($right) == 1) { # comparing single character only
  	    return $left->thischar cmp $right;
  	}
  	$right = $left->new($right);
      }
      return $left->currstr cmp $right->currstr;
  }
  
  sub bool {
      my ($self) = @_;
      my $char = $self->thischar;
      return ($char ne '');
  }
  
  sub clone {
      my ($left, $right, $swapped) = @_;
      $right = {
  	string  => [@{$left->{string}}],
  	current => $left->{current},
      };
      return bless $right, ref($left);
  }
  
  sub currstr {
      my ($self, $s) = @_;
      my $curr = $self->{current};
      my $last = $#{$self->{string}};
      if (defined($s) && $s->{current} < $last) {
  	$last = $s->{current};
      }
  
      my $string = join('', @{$self->{string}}[$curr..$last]);
      return $string;
  }
  
  package version::vpp;
  
  use 5.006002;
  use strict;
  use warnings::register;
  
  use Config;
  
  our $VERSION = 0.9924;
  our $CLASS = 'version::vpp';
  our ($LAX, $STRICT, $WARN_CATEGORY);
  
  if ($] > 5.015) {
      warnings::register_categories(qw/version/);
      $WARN_CATEGORY = 'version';
  } else {
      $WARN_CATEGORY = 'numeric';
  }
  
  require version::regex;
  *version::vpp::is_strict = \&version::regex::is_strict;
  *version::vpp::is_lax = \&version::regex::is_lax;
  *LAX = \$version::regex::LAX;
  *STRICT = \$version::regex::STRICT;
  
  use overload (
      '""'       => \&stringify,
      '0+'       => \&numify,
      'cmp'      => \&vcmp,
      '<=>'      => \&vcmp,
      'bool'     => \&vbool,
      '+'        => \&vnoop,
      '-'        => \&vnoop,
      '*'        => \&vnoop,
      '/'        => \&vnoop,
      '+='        => \&vnoop,
      '-='        => \&vnoop,
      '*='        => \&vnoop,
      '/='        => \&vnoop,
      'abs'      => \&vnoop,
  );
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	no warnings qw/redefine/;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  my $VERSION_MAX = 0x7FFFFFFF;
  
  # implement prescan_version as closely to the C version as possible
  use constant TRUE  => 1;
  use constant FALSE => 0;
  
  sub isDIGIT {
      my ($char) = shift->thischar();
      return ($char =~ /\d/);
  }
  
  sub isALPHA {
      my ($char) = shift->thischar();
      return ($char =~ /[a-zA-Z]/);
  }
  
  sub isSPACE {
      my ($char) = shift->thischar();
      return ($char =~ /\s/);
  }
  
  sub BADVERSION {
      my ($s, $errstr, $error) = @_;
      if ($errstr) {
  	$$errstr = $error;
      }
      return $s;
  }
  
  sub prescan_version {
      my ($s, $strict, $errstr, $sqv, $ssaw_decimal, $swidth, $salpha) = @_;
      my $qv          = defined $sqv          ? $$sqv          : FALSE;
      my $saw_decimal = defined $ssaw_decimal ? $$ssaw_decimal : 0;
      my $width       = defined $swidth       ? $$swidth       : 3;
      my $alpha       = defined $salpha       ? $$salpha       : FALSE;
  
      my $d = $s;
  
      if ($qv && isDIGIT($d)) {
  	goto dotted_decimal_version;
      }
  
      if ($d eq 'v') { # explicit v-string
  	$d++;
  	if (isDIGIT($d)) {
  	    $qv = TRUE;
  	}
  	else { # degenerate v-string
  	    # requires v1.2.3
  	    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	}
  
  dotted_decimal_version:
  	if ($strict && $d eq '0' && isDIGIT($d+1)) {
  	    # no leading zeros allowed
  	    return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	}
  
  	while (isDIGIT($d)) { 	# integer part
  	    $d++;
  	}
  
  	if ($d eq '.')
  	{
  	    $saw_decimal++;
  	    $d++; 		# decimal point
  	}
  	else
  	{
  	    if ($strict) {
  		# require v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	    else {
  		goto version_prescan_finish;
  	    }
  	}
  
  	{
  	    my $i = 0;
  	    my $j = 0;
  	    while (isDIGIT($d)) {	# just keep reading
  		$i++;
  		while (isDIGIT($d)) {
  		    $d++; $j++;
  		    # maximum 3 digits between decimal
  		    if ($strict && $j > 3) {
  			return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)");
  		    }
  		}
  		if ($d eq '_') {
  		    if ($strict) {
  			return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		    }
  		    if ( $alpha ) {
  			return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		    }
  		    $d++;
  		    $alpha = TRUE;
  		}
  		elsif ($d eq '.') {
  		    if ($alpha) {
  			return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		    }
  		    $saw_decimal++;
  		    $d++;
  		}
  		elsif (!isDIGIT($d)) {
  		    last;
  		}
  		$j = 0;
  	    }
  
  	    if ($strict && $i < 2) {
  		# requires v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	}
      } 					# end if dotted-decimal
      else
      {					# decimal versions
  	my $j = 0;
  	# special $strict case for leading '.' or '0'
  	if ($strict) {
  	    if ($d eq '.') {
  		return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)");
  	    }
  	    if ($d eq '0' && isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	    }
  	}
  
  	# and we never support negative version numbers
  	if ($d eq '-') {
  	    return BADVERSION($s,$errstr,"Invalid version format (negative version number)");
  	}
  
  	# consume all of the integer part
  	while (isDIGIT($d)) {
  	    $d++;
  	}
  
  	# look for a fractional part
  	if ($d eq '.') {
  	    # we found it, so consume it
  	    $saw_decimal++;
  	    $d++;
  	}
  	elsif (!$d || $d eq ';' || isSPACE($d) || $d eq '}') {
  	    if ( $d == $s ) {
  		# found nothing
  		return BADVERSION($s,$errstr,"Invalid version format (version required)");
  	    }
  	    # found just an integer
  	    goto version_prescan_finish;
  	}
  	elsif ( $d == $s ) {
  	    # didn't find either integer or period
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  	elsif ($d eq '_') {
  	    # underscore can't come after integer part
  	    if ($strict) {
  		return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  	    }
  	    elsif (isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)");
  	    }
  	    else {
  		return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  	    }
  	}
  	elsif ($d) {
  	    # anything else after integer part is just invalid data
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  
  	# scan the fractional part after the decimal point
  	if ($d && !isDIGIT($d) && ($strict || ! ($d eq ';' || isSPACE($d) || $d eq '}') )) {
  		# $strict or lax-but-not-the-end
  		return BADVERSION($s,$errstr,"Invalid version format (fractional part required)");
  	}
  
  	while (isDIGIT($d)) {
  	    $d++; $j++;
  	    if ($d eq '.' && isDIGIT($d-1)) {
  		if ($alpha) {
  		    return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		}
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')");
  		}
  		$d = $s; # start all over again
  		$qv = TRUE;
  		goto dotted_decimal_version;
  	    }
  	    if ($d eq '_') {
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		}
  		if ( $alpha ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		}
  		if ( ! isDIGIT($d+1) ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  		}
  		$width = $j;
  		$d++;
  		$alpha = TRUE;
  	    }
  	}
      }
  
  version_prescan_finish:
      while (isSPACE($d)) {
  	$d++;
      }
  
      if ($d && !isDIGIT($d) && (! ($d eq ';' || $d eq '}') )) {
  	# trailing non-numeric data
  	return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
      }
      if ($saw_decimal > 1 && ($d-1) eq '.') {
  	# no trailing period allowed
  	return BADVERSION($s,$errstr,"Invalid version format (trailing decimal)");
      }
  
      if (defined $sqv) {
  	$$sqv = $qv;
      }
      if (defined $swidth) {
  	$$swidth = $width;
      }
      if (defined $ssaw_decimal) {
  	$$ssaw_decimal = $saw_decimal;
      }
      if (defined $salpha) {
  	$$salpha = $alpha;
      }
      return $d;
  }
  
  sub scan_version {
      my ($s, $rv, $qv) = @_;
      my $start;
      my $pos;
      my $last;
      my $errstr;
      my $saw_decimal = 0;
      my $width = 3;
      my $alpha = FALSE;
      my $vinf = FALSE;
      my @av;
  
      $s = new charstar $s;
  
      while (isSPACE($s)) { # leading whitespace is OK
  	$s++;
      }
  
      $last = prescan_version($s, FALSE, \$errstr, \$qv, \$saw_decimal,
  	\$width, \$alpha);
  
      if ($errstr) {
  	# 'undef' is a special case and not an error
  	if ( $s ne 'undef') {
  	    require Carp;
  	    Carp::croak($errstr);
  	}
      }
  
      $start = $s;
      if ($s eq 'v') {
  	$s++;
      }
      $pos = $s;
  
      if ( $qv ) {
  	$$rv->{qv} = $qv;
      }
      if ( $alpha ) {
  	$$rv->{alpha} = $alpha;
      }
      if ( !$qv && $width < 3 ) {
  	$$rv->{width} = $width;
      }
  
      while (isDIGIT($pos) || $pos eq '_') {
  	$pos++;
      }
      if (!isALPHA($pos)) {
  	my $rev;
  
  	for (;;) {
  	    $rev = 0;
  	    {
    		# this is atoi() that delimits on underscores
    		my $end = $pos;
    		my $mult = 1;
  		my $orev;
  
  		#  the following if() will only be true after the decimal
  		#  point of a version originally created with a bare
  		#  floating point number, i.e. not quoted in any way
  		#
   		if ( !$qv && $s > $start && $saw_decimal == 1 ) {
  		    $mult *= 100;
   		    while ( $s < $end ) {
  			next if $s eq '_';
  			$orev = $rev;
   			$rev += $s * $mult;
   			$mult /= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version %d",
  					   $VERSION_MAX);
  			    $s = $end - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   			$s++;
  			if ( $s eq '_' ) {
  			    $s++;
  			}
   		    }
    		}
   		else {
   		    while (--$end >= $s) {
  			next if $end eq '_';
  			$orev = $rev;
   			$rev += $end * $mult;
   			$mult *= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version");
  			    $end = $s - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   		    }
   		}
    	    }
  
    	    # Append revision
  	    push @av, $rev;
  	    if ( $vinf ) {
  		$s = $last;
  		last;
  	    }
  	    elsif ( $pos eq '.' ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq '_' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq ',' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( isDIGIT($pos) ) {
  		$s = $pos;
  	    }
  	    else {
  		$s = $pos;
  		last;
  	    }
  	    if ( $qv ) {
  		while ( isDIGIT($pos) || $pos eq '_') {
  		    $pos++;
  		}
  	    }
  	    else {
  		my $digits = 0;
  		while ( ( isDIGIT($pos) || $pos eq '_' ) && $digits < 3 ) {
  		    if ( $pos ne '_' ) {
  			$digits++;
  		    }
  		    $pos++;
  		}
  	    }
  	}
      }
      if ( $qv ) { # quoted versions always get at least three terms
  	my $len = $#av;
  	#  This for loop appears to trigger a compiler bug on OS X, as it
  	#  loops infinitely. Yes, len is negative. No, it makes no sense.
  	#  Compiler in question is:
  	#  gcc version 3.3 20030304 (Apple Computer, Inc. build 1640)
  	#  for ( len = 2 - len; len > 0; len-- )
  	#  av_push(MUTABLE_AV(sv), newSViv(0));
  	#
  	$len = 2 - $len;
  	while ($len-- > 0) {
  	    push @av, 0;
  	}
      }
  
      # need to save off the current version string for later
      if ( $vinf ) {
  	$$rv->{original} = "v.Inf";
  	$$rv->{vinf} = 1;
      }
      elsif ( $s > $start ) {
  	$$rv->{original} = $start->currstr($s);
  	if ( $qv && $saw_decimal == 1 && $start ne 'v' ) {
  	    # need to insert a v to be consistent
  	    $$rv->{original} = 'v' . $$rv->{original};
  	}
      }
      else {
  	$$rv->{original} = '0';
  	push(@av, 0);
      }
  
      # And finally, store the AV in the hash
      $$rv->{version} = \@av;
  
      # fix RT#19517 - special case 'undef' as string
      if ($s eq 'undef') {
  	$s += 5;
      }
  
      return $s;
  }
  
  sub new {
      my $class = shift;
      unless (defined $class or $#_ > 1) {
  	require Carp;
  	Carp::croak('Usage: version::new(class, version)');
      }
  
      my $self = bless ({}, ref ($class) || $class);
      my $qv = FALSE;
  
      if ( $#_ == 1 ) { # must be CVS-style
  	$qv = TRUE;
      }
      my $value = pop; # always going to be the last element
  
      if ( ref($value) && eval('$value->isa("version")') ) {
  	# Can copy the elements directly
  	$self->{version} = [ @{$value->{version} } ];
  	$self->{qv} = 1 if $value->{qv};
  	$self->{alpha} = 1 if $value->{alpha};
  	$self->{original} = ''.$value->{original};
  	return $self;
      }
  
      if ( not defined $value or $value =~ /^undef$/ ) {
  	# RT #19517 - special case for undef comparison
  	# or someone forgot to pass a value
  	push @{$self->{version}}, 0;
  	$self->{original} = "0";
  	return ($self);
      }
  
  
      if (ref($value) =~ m/ARRAY|HASH/) {
  	require Carp;
  	Carp::croak("Invalid version format (non-numeric data)");
      }
  
      $value = _un_vstring($value);
  
      if ($Config{d_setlocale}) {
  	use POSIX qw/locale_h/;
  	use if $Config{d_setlocale}, 'locale';
  	my $currlocale = setlocale(LC_ALL);
  
  	# if the current locale uses commas for decimal points, we
  	# just replace commas with decimal places, rather than changing
  	# locales
  	if ( localeconv()->{decimal_point} eq ',' ) {
  	    $value =~ tr/,/./;
  	}
      }
  
      # exponential notation
      if ( $value =~ /\d+.?\d*e[-+]?\d+/ ) {
  	$value = sprintf("%.9f",$value);
  	$value =~ s/(0+)$//; # trim trailing zeros
      }
  
      my $s = scan_version($value, \$self, $qv);
  
      if ($s) { # must be something left over
  	warn(sprintf "Version string '%s' contains invalid data; "
  		   ."ignoring: '%s'", $value, $s);
      }
  
      return ($self);
  }
  
  *parse = \&new;
  
  sub numify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      my $alpha = $self->{alpha} || "";
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("%d.", $digit );
  
      if ($alpha and warnings::enabled()) {
  	warnings::warn($WARN_CATEGORY, 'alpha->numify() is lossy');
      }
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf("%03d", $digit);
      }
  
      if ( $len == 0 ) {
  	$string .= sprintf("000");
      }
  
      return $string;
  }
  
  sub normal {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
  
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("v%d", $digit );
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf(".%d", $digit);
      }
  
      if ( $len <= 2 ) {
  	for ( $len = 2 - $len; $len != 0; $len-- ) {
  	    $string .= sprintf(".%0d", 0);
  	}
      }
  
      return $string;
  }
  
  sub stringify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      return exists $self->{original}
      	? $self->{original}
  	: exists $self->{qv}
  	    ? $self->normal
  	    : $self->numify;
  }
  
  sub vcmp {
      my ($left,$right,$swap) = @_;
      my $class = ref($left);
      unless ( UNIVERSAL::isa($right, $class) ) {
  	$right = $class->new($right);
      }
  
      if ( $swap ) {
  	($left, $right) = ($right, $left);
      }
      unless (_verify($left)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      unless (_verify($right)) {
  	require Carp;
  	Carp::croak("Invalid version format");
      }
      my $l = $#{$left->{version}};
      my $r = $#{$right->{version}};
      my $m = $l < $r ? $l : $r;
      my $lalpha = $left->is_alpha;
      my $ralpha = $right->is_alpha;
      my $retval = 0;
      my $i = 0;
      while ( $i <= $m && $retval == 0 ) {
  	$retval = $left->{version}[$i] <=> $right->{version}[$i];
  	$i++;
      }
  
      # possible match except for trailing 0's
      if ( $retval == 0 && $l != $r ) {
  	if ( $l < $r ) {
  	    while ( $i <= $r && $retval == 0 ) {
  		if ( $right->{version}[$i] != 0 ) {
  		    $retval = -1; # not a match after all
  		}
  		$i++;
  	    }
  	}
  	else {
  	    while ( $i <= $l && $retval == 0 ) {
  		if ( $left->{version}[$i] != 0 ) {
  		    $retval = +1; # not a match after all
  		}
  		$i++;
  	    }
  	}
      }
  
      return $retval;
  }
  
  sub vbool {
      my ($self) = @_;
      return vcmp($self,$self->new("0"),1);
  }
  
  sub vnoop {
      require Carp;
      Carp::croak("operation not supported with version object");
  }
  
  sub is_alpha {
      my ($self) = @_;
      return (exists $self->{alpha});
  }
  
  sub qv {
      my $value = shift;
      my $class = $CLASS;
      if (@_) {
  	$class = ref($value) || $value;
  	$value = shift;
      }
  
      $value = _un_vstring($value);
      $value = 'v'.$value unless $value =~ /(^v|\d+\.\d+\.\d)/;
      my $obj = $CLASS->new($value);
      return bless $obj, $class;
  }
  
  *declare = \&qv;
  
  sub is_qv {
      my ($self) = @_;
      return (exists $self->{qv});
  }
  
  
  sub _verify {
      my ($self) = @_;
      if ( ref($self)
  	&& eval { exists $self->{version} }
  	&& ref($self->{version}) eq 'ARRAY'
  	) {
  	return 1;
      }
      else {
  	return 0;
      }
  }
  
  sub _is_non_alphanumeric {
      my $s = shift;
      $s = new charstar $s;
      while ($s) {
  	return 0 if isSPACE($s); # early out
  	return 1 unless (isALPHA($s) || isDIGIT($s) || $s =~ /[.-]/);
  	$s++;
      }
      return 0;
  }
  
  sub _un_vstring {
      my $value = shift;
      # may be a v-string
      if ( length($value) >= 1 && $value !~ /[,._]/
  	&& _is_non_alphanumeric($value)) {
  	my $tvalue;
  	if ( $] >= 5.008_001 ) {
  	    $tvalue = _find_magic_vstring($value);
  	    $value = $tvalue if length $tvalue;
  	}
  	elsif ( $] >= 5.006_000 ) {
  	    $tvalue = sprintf("v%vd",$value);
  	    if ( $tvalue =~ /^v\d+(\.\d+)*$/ ) {
  		# must be a v-string
  		$value = $tvalue;
  	    }
  	}
      }
      return $value;
  }
  
  sub _find_magic_vstring {
      my $value = shift;
      my $tvalue = '';
      require B;
      my $sv = B::svref_2object(\$value);
      my $magic = ref($sv) eq 'B::PVMG' ? $sv->MAGIC : undef;
      while ( $magic ) {
  	if ( $magic->TYPE eq 'V' ) {
  	    $tvalue = $magic->PTR;
  	    $tvalue =~ s/^v?(.+)$/v$1/;
  	    last;
  	}
  	else {
  	    $magic = $magic->MOREMAGIC;
  	}
      }
      $tvalue =~ tr/_//d;
      return $tvalue;
  }
  
  sub _VERSION {
      my ($obj, $req) = @_;
      my $class = ref($obj) || $obj;
  
      no strict 'refs';
      if ( exists $INC{"$class.pm"} and not %{"$class\::"} and $] >= 5.008) {
  	 # file but no package
  	require Carp;
  	Carp::croak( "$class defines neither package nor VERSION"
  	    ."--version check failed");
      }
  
      my $version = eval "\$$class\::VERSION";
      if ( defined $version ) {
  	local $^W if $] <= 5.008;
  	$version = version::vpp->new($version);
      }
  
      if ( defined $req ) {
  	unless ( defined $version ) {
  	    require Carp;
  	    my $msg =  $] < 5.006
  	    ? "$class version $req required--this is only version "
  	    : "$class does not define \$$class\::VERSION"
  	      ."--version check failed";
  
  	    if ( $ENV{VERSION_DEBUG} ) {
  		Carp::confess($msg);
  	    }
  	    else {
  		Carp::croak($msg);
  	    }
  	}
  
  	$req = version::vpp->new($req);
  
  	if ( $req > $version ) {
  	    require Carp;
  	    if ( $req->is_qv ) {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->normal, $version->normal)
  		);
  	    }
  	    else {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->stringify, $version->stringify)
  		);
  	    }
  	}
      }
  
      return defined $version ? $version->stringify : undef;
  }
  
  1; #this line is important and will help the module return a true value
DARWIN-2LEVEL_VERSION_VPP

$fatpacked{"darwin-2level/version/vxs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_VERSION_VXS';
  #!perl -w
  package version::vxs;
  
  use v5.10;
  use strict;
  
  our $VERSION = 0.9924;
  our $CLASS = 'version::vxs';
  our @ISA;
  
  eval {
      require XSLoader;
      local $^W; # shut up the 'redefined' warning for UNIVERSAL::VERSION
      XSLoader::load('version::vxs', $VERSION);
      1;
  } or do {
      require DynaLoader;
      push @ISA, 'DynaLoader'; 
      local $^W; # shut up the 'redefined' warning for UNIVERSAL::VERSION
      bootstrap version::vxs $VERSION;
  };
  
  # Preloaded methods go here.
  
  1;
DARWIN-2LEVEL_VERSION_VXS

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


package perlver;
$perlver::VERSION = '1.38';
=pod

=head1 NAME

perlver - The Perl Minimum Version Analyzer

=head1 SYNOPSIS

  adam@red:~$ perlver Perl-MinimumVersion
  Found directory '.'
  Searching for Perl files... found 3 file(s)
  Scanning lib/Perl/MinimumVersion.pm... done
  Scanning t/01_compile.t... done
  Scanning t/02_main.t... done

      ---------------------------------------------------------
    | file                       | explicit | syntax | external |
    | --------------------------------------------------------- |
    | lib/Perl/MinimumVersion.pm | 5.005    | ~      | n/a      |
    | t/01_compile.t             | ~        | ~      | n/a      |
    | t/02_main.t                | ~        | ~      | n/a      |
      ---------------------------------------------------------

  Minimum version of Perl required: ...

  adam@red:~$

=head1 DESCRIPTION

C<perlver> is a console script created to provide convenient access to the
functionality provided by L<Perl::MinimumVersion>.

--blame option shows code which requires this version of perl

The synopsis above pretty much covers all you need to know at this point.

=cut

use 5.005;
use strict;
use version                'qv';
use File::Spec             ();
use Getopt::Long           'GetOptions';
use Params::Util           '_INSTANCE';
use File::Find::Rule       ();
use File::Find::Rule::Perl ();
use Perl::MinimumVersion   'PMV';

# Define prototypes
sub verbose        ($);
sub message        ($);
sub error          (@);
sub format_version ($);
sub dist           ($);

use vars qw{$VERBOSE $BLAME $EXPLAIN};
BEGIN {

	# Configuration globals
	$VERBOSE = '';
	$BLAME   = '';
	$EXPLAIN = '';

	# Unbuffer output
	$| = 1;
}





#####################################################################
# Configuration

GetOptions(
	verbose => \$VERBOSE,
	blame   => \$BLAME,
	explain => \$EXPLAIN,
);

# Get the target
my $target = shift @ARGV;
unless ( $target ) {
	error("You did not provide a file or directory to check");
}

print "\n";
if ( $BLAME ) {
	blame($target);
} else {
	summary($target);
}

exit(0);





#####################################################################
# Regular Mode

sub summary {
	my $target = shift;
	my @files  = ();
	if ( -d $target ) {
		verbose "Found directory '$target'\n";
		verbose "Searching for Perl files... ";
		@files = find($target);
		verbose "found " . scalar(@files) . " file(s)\n";
	} elsif ( -f $target ) {
		verbose "Found file '$target'\n";
		@files = $target;
	} else {
		error "File or directory '$target' does not exist";
	}

	# Scan the files
	verbose "Processing files...\n";
	my @results  = ();
	my $file_len = 12 + List::Util::max map { length $_ } @files;
	foreach my $file ( @files ) {
		# Set up the results data
		verbose sprintf("%-${file_len}s", "Scanning $file...");
		my $result  = [ $file, undef, undef ];
		push @results, $result;

		# Load the document standalone first so we store the file name
		my $document = PPI::Document::File->new(
			$file,
			readonly => 1,
		);
		unless ( $document ) {
			verbose "[error]\n";
			next;
		}

		# Create the version checker
		my $pmv = PMV->new( $document );
		unless ( $pmv ) {
			verbose "[error]\n";
			next;
		}

		# Check the explicit version
		$result->[1] = $pmv->minimum_explicit_version;

		# Check the syntax version
		$result->[2] = $pmv->minimum_syntax_version;

		$result->[4] = $pmv->{syntax_check_failed} if exists $pmv->{syntax_check_failed};

		verbose "[ok]\n";
	}

	# Calculate the minimum explicit, syntax and total versions
	verbose "Compiling results...\n";
	my $pmv_explicit = PMV->_max( map { $_->[1] } @results   );
	my $pmv_syntax   = PMV->_max( map { $_->[2] } @results   );
	my $pmv_bug      = !! ($pmv_explicit and $pmv_syntax and $pmv_syntax > $pmv_explicit);
	my $pmv_total    = PMV->_max( $pmv_explicit, $pmv_syntax );

	# Generate the output values
	my @outputs = ( [ 'file', 'explicit', 'syntax', 'external' ] );
	foreach my $result ( @results ) {
		my $output = [];
		$output->[0] = $result->[0];
		$output->[1] = format_version($result->[1]);
		$output->[2] = format_version($result->[2]);
		# $output->[3] = format_version($result->[3]);
		$output->[3] = 'n/a';
		$output->[4] = $result->[4] || '' if ($EXPLAIN);
		push @outputs, $output;
	}

	# Complete the output preperation work
	$pmv_explicit     = format_version( $pmv_explicit );
	$pmv_syntax       = format_version( $pmv_syntax   );
	$pmv_total        = format_version( $pmv_total    );
	if ( $pmv_total eq '~' ) {
		$pmv_total = format_version( qv(5.004) ) . ' (default)';
	}
	my $len0          = List::Util::max map { length $_->[0] } @outputs;
	my $len1          = List::Util::max map { length $_->[1] } @outputs;
	my $len2          = List::Util::max map { length $_->[2] } @outputs;
	my $len3          = List::Util::max map { length $_->[3] } @outputs;
	my $len_all       = $len0 + $len1 + $len2 + $len3 + 9;
	my $len_totals    = $len1 + $len2 + $len3 + 6;
	my $line_format   = " | %-${len0}s | %-${len1}s | %-${len2}s | %-${len3}s |\n";
	if ($EXPLAIN) {
	  chomp($line_format);
	  $line_format.="  (%s)\n";
	}
	my $spacer        = '-' x $len_all;
	my $error_message = "ERROR DETECTED : ACTUAL DEPENDENCY HIGHER THAN SPECIFIED";
	my $error_length  = length $error_message;
	if ( $error_length > $len_all ) {
		my $diff = $error_length - $len_all;
		$len_all += $diff;
		$len0    += $diff;
	}

	# Prepare formatting parts
	my $divider = " | $spacer |\n";
	my $capline = "   $spacer  \n";
	my $rowline = " | %-${len_all}s |\n";

	# Print the results
	print "\n";
	print $capline;
	printf( $line_format, @{shift(@outputs)} );
	print $divider;
	foreach my $result ( @outputs ) {
		printf( $line_format, @$result );
	}
	print $divider;
	printf( $rowline, "Minimum explicit version : $pmv_explicit" );
	printf( $rowline, "Minimum syntax version   : $pmv_syntax"   );
	printf( $rowline, "Minimum version of perl  : $pmv_total"    );
	if ( $pmv_bug ) {
		print $divider;
		printf( $rowline, "ERROR   : ACTUAL DEPENDENCY HIGHER THAN SPECIFIED" );
		printf( $rowline, "DETAILS : perlver --blame $target" );
	}
	print $capline;
	print "\n";
}

sub blame {
	my $target = shift;
	my @files  = ();
	if ( -d $target ) {
		verbose "Found directory '$target'\n";
		verbose "Searching for Perl files... ";
		@files = find($target);
		verbose "found " . scalar(@files) . " file(s)\n";
	} elsif ( -f $target ) {
		verbose "Found file '$target'\n";
		@files = $target;
	} else {
		error "File or directory '$target' does not exist";
	}

	# Scan the files
	verbose "Processing files...\n";
	my $maximum  = undef;
	my $blame    = undef;
	my $file_len = 12 + List::Util::max map { length $_ } @files;
	my $max      = undef;
	my $maxpmv   = undef;
	foreach my $file ( @files ) {
		# Set up the results data
		verbose sprintf("%-${file_len}s", "Scanning $file...");

		# Load the document standalone first so we store the file name
		my $document = PPI::Document::File->new(
			$file,
			readonly => 1,
		);
		unless ( $document ) {
			verbose "[error]\n";
			next;
		}

		# Create the version checker
		my $pmv = PMV->new( $document );
		unless ( $pmv ) {
			verbose "[error]\n";
			next;
		}

		# Check the syntax version
		my $reason = $pmv->minimum_syntax_reason( $max ? $max->version : undef );
		if ( $reason ) {
			verbose $reason->version . "\n";
		} else {
			verbose "~\n";
			next;
		}

		# Handle the first successful case
		if ( ! $max or $reason->version > $max->version ) {
			$max    = $reason;
			$maxpmv = $pmv;
			next;
		}
	}

	# Anything?
	unless ( $max ) {
		print "Nothing obvious to blame\n";
		exit(0);
	}

	# Index and prepare
	my $element  = $max->element or die "Reason element unknown";
	my $document = $element->top or die "Reason document unknown";
	$document->index_locations;

	# Generate the location message
	my $file    = $document->filename;
	my $line    = $element->line_number;
	my $char    = $element->column_number;
	my $content = $element->content;
	my $rule    = $max->rule;
	my $version = $max->version;
	print " ------------------------------------------------------------\n";
	print " File    : $file\n";
	print " Line    : $line\n";
	print " Char    : $char\n";
	print " Rule    : $rule\n";
	print " Version : $version\n";
	print " ------------------------------------------------------------\n";
	print " $content\n";
	print " ------------------------------------------------------------\n";
}

sub find {
	my $dir   = shift;
	my $perl  = File::Find::Rule->perl_file;
	my $build = File::Find::Rule->name('blib', '_build')->directory;
	return dist($dir)
		? File::Find::Rule->any(
				$build->prune->discard,
				$perl,
		  )->in( $dir )
		: $perl->in( $dir );
}





#####################################################################
# Support Functions

sub verbose ($) {
	return 1 unless $VERBOSE;
	print ' ' . $_[0];
}

sub message ($) {
	print ' ' . $_[0];
}

sub error (@) {
	print ' ' . join '', map { "$_\n" } ('', @_, '');
	exit(255);
}

sub format_version ($) {
	my $version = shift;
	if ( _INSTANCE($version, 'Perl::MinimumVersion::Reason') ) {
		$version = $version->version->normal;
	} elsif ( _INSTANCE($version, 'version') ) {
		return $version->normal;
	} elsif ( $version ) {
		return "$version";
	} elsif ( defined $version ) {
		return '~';
	} else {
		return 'undef';
	}
}

sub format_reason ($) {
	my $reason = shift;

	# Index the document of the worse offender
	my $element  = $reason->element;
	my $document = $element->top;
	$document->index_locations;

	$DB::single = 1;

	1;
}

sub dist ($) {
	my $dir = shift;
	if ( -f File::Spec->catfile($dir, 'Makefile.PL') ) {
		return 1;
	}
	if ( -f File::Spec->catfile($dir, 'Build.PL') ) {
		return 1;
	}
	return '';
}

=pod

=head1 TO DO

- Add PPI::Cache integration

- Add PPI::Metrics integration (once it exists)

- Add some sort of parseable output

=head1 SUPPORT

All bugs should be filed via the bug tracker at

L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Perl-MinimumVersion>

For other issues, or commercial enhancement and support, contact the author

=head1 AUTHORS

Adam Kennedy <adamk@cpan.org>

=head1 SEE ALSO

L<PPI>, L<Perl::MinimumVersion>

=head1 COPYRIGHT

Copyright 2005 - 2012 Adam Kennedy.

This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.

The full text of the license can be found in the
LICENSE file included with this module.

=cut
