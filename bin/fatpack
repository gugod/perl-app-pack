Try `perldoc fatpack` for how to use me
#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/FatPacker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_FATPACKER';
  package App::FatPacker;
  
  use strict;
  use warnings FATAL => 'all';
  use 5.008001;
  use Getopt::Long;
  use Cwd qw(cwd);
  use File::Find qw(find);
  use File::Spec::Functions qw(
    catdir splitpath splitdir catpath rel2abs abs2rel
  );
  use File::Spec::Unix;
  use File::Copy qw(copy);
  use File::Path qw(mkpath rmtree);
  use B qw(perlstring);
  
  our $VERSION = '0.010007'; # 0.10.7
  
  $VERSION = eval $VERSION;
  
  sub call_parser {
    my $self = shift;
    my ($args, $options) = @_;
  
    local *ARGV = [ @{$args} ];
    $self->{option_parser}->getoptions(@$options);
  
    return [ @ARGV ];
  }
  
  sub lines_of {
    map +(chomp,$_)[1], do { local @ARGV = ($_[0]); <> };
  }
  
  sub stripspace {
    my ($text) = @_;
    $text =~ /^(\s+)/ && $text =~ s/^$1//mg;
    $text;
  }
  
  sub import {
    $_[1] && $_[1] eq '-run_script'
      and return shift->new->run_script;
  }
  
  sub new {
    bless {
      option_parser => Getopt::Long::Parser->new(
        config => [ qw(require_order pass_through bundling no_auto_abbrev) ]
      ),
    }, $_[0];
  }
  
  sub run_script {
    my ($self, $args) = @_;
    my @args = $args ? @$args : @ARGV;
    (my $cmd = shift @args || 'help') =~ s/-/_/g;
  
    if (my $meth = $self->can("script_command_${cmd}")) {
      $self->$meth(\@args);
    } else {
      die "No such command ${cmd}";
    }
  }
  
  sub script_command_help {
    print "Try `perldoc fatpack` for how to use me\n";
  }
  
  sub script_command_pack {
    my ($self, $args) = @_;
  
    my @modules = split /\r?\n/, $self->trace(args => $args);
    my @packlists = $self->packlists_containing(\@modules);
  
    my $base = catdir(cwd, 'fatlib');
    $self->packlists_to_tree($base, \@packlists);
  
    my $file = shift @$args;
    print $self->fatpack_file($file);
  }
  
  sub script_command_trace {
    my ($self, $args) = @_;
  
    $args = $self->call_parser($args => [
      'to=s' => \my $file,
      'to-stderr' => \my $to_stderr,
      'use=s' => \my @additional_use
    ]);
  
    die "Can't use to and to-stderr on same call" if $file && $to_stderr;
  
    $file ||= 'fatpacker.trace';
  
    if (!$to_stderr and -e $file) {
      unlink $file or die "Couldn't remove old trace file: $!";
    }
    my $arg = do {
      if ($to_stderr) {
        ">&STDERR"
      } elsif ($file) {
        ">>${file}"
      }
    };
  
    $self->trace(
      use => \@additional_use,
      args => $args,
      output => $arg,
    );
  }
  
  sub trace {
    my ($self, %opts) = @_;
  
    my $output = $opts{output};
    my $trace_opts = join ',', $output||'>&STDOUT', @{$opts{use}||[]};
  
    local $ENV{PERL5OPT} = join ' ',
      ($ENV{PERL5OPT}||()), '-MApp::FatPacker::Trace='.$trace_opts;
  
    my @args = @{$opts{args}||[]};
  
    if ($output) {
      # user specified output target, JFDI
      system $^X, @args;
      return;
    } else {
      # no output target specified, slurp
      open my $out_fh, "$^X @args |";
      return do { local $/; <$out_fh> };
    }
  }
  
  sub script_command_packlists_for {
    my ($self, $args) = @_;
    foreach my $pl ($self->packlists_containing($args)) {
      print "${pl}\n";
    }
  }
  
  sub packlists_containing {
    my ($self, $targets) = @_;
    my @targets;
    {
      local @INC = ('lib', @INC);
      foreach my $t (@$targets) {
        unless (eval { require $t; 1}) {
          warn "Failed to load ${t}: $@\n"
              ."Make sure you're not missing a packlist as a result\n";
          next;
        }
        push @targets, $t;
      }
    }
    my @search = grep -d $_, map catdir($_, 'auto'), @INC;
    my %pack_rev;
    find({
      no_chdir => 1,
      wanted => sub {
        return unless /[\\\/]\.packlist$/ && -f $_;
        $pack_rev{$_} = $File::Find::name for lines_of $File::Find::name;
      },
    }, @search);
    my %found; @found{map +($pack_rev{Cwd::abs_path($INC{$_})}||()), @targets} = ();
    sort keys %found;
  }
  
  sub script_command_tree {
    my ($self, $args) = @_;
    my $base = catdir(cwd,'fatlib');
    $self->packlists_to_tree($base, $args);
  }
  
  sub packlists_to_tree {
    my ($self, $where, $packlists) = @_;
    rmtree $where;
    mkpath $where;
    foreach my $pl (@$packlists) {
      my ($vol, $dirs, $file) = splitpath $pl;
      my @dir_parts = splitdir $dirs;
      my $pack_base;
      PART: foreach my $p (0 .. $#dir_parts) {
        if ($dir_parts[$p] eq 'auto') {
          # $p-2 normally since it's <wanted path>/$Config{archname}/auto but
          # if the last bit is a number it's $Config{archname}/$version/auto
          # so use $p-3 in that case
          my $version_lib = 0+!!($dir_parts[$p-1] =~ /^[0-9.]+$/);
          $pack_base = catpath $vol, catdir @dir_parts[0..$p-(2+$version_lib)];
          last PART;
        }
      }
      die "Couldn't figure out base path of packlist ${pl}" unless $pack_base;
      foreach my $source (lines_of $pl) {
        # there is presumably a better way to do "is this under this base?"
        # but if so, it's not obvious to me in File::Spec
        next unless substr($source,0,length $pack_base) eq $pack_base;
        my $target = rel2abs( abs2rel($source, $pack_base), $where );
        my $target_dir = catpath((splitpath $target)[0,1]);
        mkpath $target_dir;
        copy $source => $target;
      }
    }
  }
  
  sub script_command_file {
    my ($self, $args) = @_;
    my $file = shift @$args;
    print $self->fatpack_file($file);
  }
  
  sub fatpack_file {
    my ($self, $file) = @_;
  
    my $shebang = "";
    my $script = "";
    if ( defined $file and -r $file ) {
      ($shebang, $script) = $self->load_main_script($file);
    }
  
    my @dirs = $self->collect_dirs();
    my %files;
    $self->collect_files($_, \%files) for @dirs;
  
    return join "\n", $shebang, $self->fatpack_code(\%files), $script;
  }
  
  # This method can be overload in sub classes
  # For example to skip POD
  sub load_file {
    my ($self, $file) = @_;
    my $content = do {
      local (@ARGV, $/) = ($file);
      <>
    };
    close ARGV;
    return $content;
  }
  
  sub collect_dirs {
    my ($self) = @_;
    my $cwd = cwd;
    return grep -d, map rel2abs($_, $cwd), ('lib','fatlib');
  }
  
  sub collect_files {
    my ($self, $dir, $files) = @_;
    find(sub {
      return unless -f $_;
      !/\.pm$/ and warn "File ${File::Find::name} isn't a .pm file - can't pack this -- if you hoped we were going to, things may not be what you expected later\n" and return;
      $files->{File::Spec::Unix->abs2rel($File::Find::name,$dir)} =
        $self->load_file($File::Find::name);
    }, $dir);
  }
  
  sub load_main_script {
    my ($self, $file) = @_;
    open my $fh, "<", $file or die("Can't read $file: $!");
    my $shebang = <$fh>;
    my $script = join "", <$fh>;
    close $fh;
    unless ( index($shebang, '#!') == 0 ) {
      $script = $shebang . $script;
      $shebang = "";
    }
    return ($shebang, $script);
  }
  
  sub fatpack_start {
    return stripspace <<'  END_START';
      # This chunk of stuff was generated by App::FatPacker. To find the original
      # file's code, look for the end of this BEGIN block or the string 'FATPACK'
      BEGIN {
      my %fatpacked;
    END_START
  }
  
  sub fatpack_end {
    return stripspace <<'  END_END';
      s/^  //mg for values %fatpacked;
  
      my $class = 'FatPacked::'.(0+\%fatpacked);
      no strict 'refs';
      *{"${class}::files"} = sub { keys %{$_[0]} };
  
      if ($] < 5.008) {
        *{"${class}::INC"} = sub {
          if (my $fat = $_[0]{$_[1]}) {
            my $pos = 0;
            my $last = length $fat;
            return (sub {
              return 0 if $pos == $last;
              my $next = (1 + index $fat, "\n", $pos) || $last;
              $_ .= substr $fat, $pos, $next - $pos;
              $pos = $next;
              return 1;
            });
          }
        };
      }
  
      else {
        *{"${class}::INC"} = sub {
          if (my $fat = $_[0]{$_[1]}) {
            open my $fh, '<', \$fat
              or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
            return $fh;
          }
          return;
        };
      }
  
      unshift @INC, bless \%fatpacked, $class;
    } # END OF FATPACK CODE
    END_END
  }
  
  sub fatpack_code {
    my ($self, $files) = @_;
    my @segments = map {
      (my $stub = $_) =~ s/\.pm$//;
      my $name = uc join '_', split '/', $stub;
      my $data = $files->{$_}; $data =~ s/^/  /mg; $data =~ s/(?<!\n)\z/\n/;
      '$fatpacked{'.perlstring($_).qq!} = '#line '.(1+__LINE__).' "'.__FILE__."\\"\\n".<<'${name}';\n!
      .qq!${data}${name}\n!;
    } sort keys %$files;
  
    return join "\n", $self->fatpack_start, @segments, $self->fatpack_end;
  }
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::FatPacker - pack your dependencies onto your script file
  
  =head1 SYNOPSIS
  
    $ fatpack pack myscript.pl >myscript.packed.pl
  
  Or, with more step-by-step control:
  
    $ fatpack trace myscript.pl
    $ fatpack packlists-for `cat fatpacker.trace` >packlists
    $ fatpack tree `cat packlists`
    $ fatpack file myscript.pl >myscript.packed.pl
  
  See the documentation for the L<fatpack> script itself for more information.
  
  The programmatic API for this code is not yet fully decided, hence the 0.x
  release version. Expect that to be cleaned up for 1.0.
  
  =head1 SEE ALSO
  
  L<article for Perl Advent 2012|http://www.perladvent.org/2012/2012-12-14.html>
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=App-FatPacker>
  (or L<bug-App-FatPacker@rt.cpan.org|mailto:bug-App-FatPacker@rt.cpan.org>).
  
  You can normally also obtain assistance on irc, in #toolchain on irc.perl.org.
  
  =head1 AUTHOR
  
  Matt S. Trout (mst) <mst@shadowcat.co.uk>
  
  =head2 CONTRIBUTORS
  
  miyagawa - Tatsuhiko Miyagawa (cpan:MIYAGAWA) <miyagawa@bulknews.net>
  
  tokuhirom - MATSUNO★Tokuhiro (cpan:TOKUHIROM) <tokuhirom@gmail.com>
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  gugod - 劉康民 (cpan:GUGOD) <gugod@cpan.org>
  
  t0m - Tomas Doran (cpan:BOBTFISH) <bobtfish@bobtfish.net>
  
  sawyer - Sawyer X (cpan:XSAWYERX) <xsawyerx@cpan.org>
  
  ether - Karen Etheridge (cpan:ETHER) <ether@cpan.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  dolmen - Olivier Mengué (cpan:DOLMEN) <dolmen@cpan.org>
  
  djerius - Diab Jerius (cpan:DJERIUS) <djerius@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG> <haarg@haarg.org>
  
  Many more people are probably owed thanks for ideas. Yet
  another doc nit to fix.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010 the App::FatPacker L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
  
  1;
  
APP_FATPACKER

$fatpacked{"App/FatPacker/Trace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_FATPACKER_TRACE';
  package App::FatPacker::Trace;
  
  use strict;
  use warnings FATAL => 'all';
  use B ();
  
  my $trace_file;
  my %initial_inc;
  
  sub import {
    my (undef, $file, @extras) = @_;
  
    $trace_file = $file || '>>fatpacker.trace';
    # For filtering out our own deps later.
    # (Not strictly required as these are core only and won't have packlists, but 
    # looks neater.)
    %initial_inc = %INC;
  
    # Use any extra modules specified
    eval "use $_" for @extras;
  
    B::minus_c;
  }
  
  CHECK {
    return unless $trace_file; # not imported
  
    open my $trace, $trace_file
        or die "Couldn't open $trace_file to trace to: $!";
  
    for my $inc (keys %INC) {
      next if exists $initial_inc{$inc};
      next unless defined($INC{$inc}) and $INC{$inc} =~ /\Q${inc}\E\Z/;
      print $trace "$inc\n";
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  App::FatPacker::Trace - Tracing module usage using compilation checking
  
  =head1 SYNOPSIS
  
      # open STDERR for writing
      # will be like: open my $fh, '>', '&STDERR'...
      perl -MApp::FatPacker::Trace=>&STDERR myscript.pl
  
      # open a file for writing
      # will be like: open my $fh, '>>', 'fatpacker.trace'
      perl -MApp::FatPacker::Trace=>>fatpacker.trace myscript.pl
  
  =head1 DESCRIPTION
  
  This module allows tracing the modules being used by your code. It does that
  using clever trickery using the C<import> method, the C<CHECK> block and
  L<B>'s C<minus_c> function.
  
  When App::FatPacker::Trace is being used, the import() method will call
  C<B::minus_c> in order to set up the global compilation-only flag perl
  (the interpreter) has. This will prevent any other code from being run.
  
  Then in the C<CHECK> block which is reached at the end of the compilation
  phase (see L<perlmod>), it will gather all modules that have been loaded,
  using C<%INC>, and will write it to a file or to STDERR, determined by
  parameters sent to the C<import> method.
  
  =head1 METHODS
  
  =head2 import
  
  This method gets run when you just load L<App::FatPacker::Trace>. It will
  note the current C<%INC> and will set up the output to be written to, and
  raise the compilation-only flag, which will prevent anything from being
  run past that point. This flag cannot be unset, so this is most easily run
  from the command line as such:
  
      perl -MApp::FatPacker::Trace [...]
  
  You can control the parameters to the import using an equal sign, as such:
  
      # send the parameter "hello"
      perl -MApp::FatPacker::Trace=hello [...]
  
      # send the parameter ">&STDERR"
      perl -MApp::FatPacker::Trace=>&STDERR [...]
  
  The import method accepts a first parameter telling it which output to open
  and how. These are both sent in a single parameter.
  
      # append to mytrace.txt
      perl -MApp::FatPacker::Trace=>>mytrace.txt myscript.pl
  
      # write to STDERR
      perl -MApp::FatPacker::Trace=>&STDERR myscript.pl
  
  The import method accepts additional parameters of extra modules to load.
  It will then add these modules to the trace. This is helpful if you want
  to explicitly indicate additional modules to trace, even if they aren't
  used in your script. Perhaps you're conditionally using them, perhaps
  they're for additional features, perhaps they're loaded lazily, whatever
  the reason.
  
      # Add Moo to the trace, even if you don't trace it in myscript.pl
      perl -MApp::FatPacker::Trace=>&STDERR,Moo myscript.pl
  
APP_FATPACKER_TRACE

$fatpacked{"x86_64-linux/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle uniq uniqnum uniqstr
    head tail pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.50";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first
  
        max maxstr min minstr product sum sum0
  
        pairs unpairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniq uniqnum uniqstr
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  Note also that multiple IEEE C<NaN> values are treated as duplicates of
  each other, regardless of any differences in their payloads, and despite
  the fact that C<< 0+'NaN' == 0+'NaN' >> yields false.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head2 head
  
      my @values = head $size, @list;
  
  Returns the first C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the last C<$size> elements from C<@list>.
  
      @result = head 2, qw( foo bar baz );
      # foo, bar
  
      @result = head -2, qw( foo bar baz );
      # foo
  
  =head2 tail
  
      my @values = tail $size, @list;
  
  Returns the last C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the first C<$size> elements from C<@list>.
  
      @result = tail 2, qw( foo bar baz );
      # bar, baz
  
      @result = tail -2, qw( foo bar baz );
      # baz
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
X86_64-LINUX_LIST_UTIL

$fatpacked{"x86_64-linux/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.50";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_LIST_UTIL_XS

$fatpacked{"x86_64-linux/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.50";
  $VERSION   = eval $VERSION;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be a dual-valued variable, it is
  actually implemented as a magical variable inside the interpreter:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use L</isweak> or L</weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_SCALAR_UTIL

$fatpacked{"x86_64-linux/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.50";
  $VERSION   = eval $VERSION;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If a name has been set using L</set_subname>, this name will
  be returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.*?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
X86_64-LINUX_SUB_UTIL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/usr/bin/env perl

use App::FatPacker -run_script;

=head1 NAME

fatpack - Command line frontend for App::FatPacker

=head1 COMMANDS

=head2 pack

  $ fatpack pack myscript.pl > myscript.packed.pl

A shortcut to do all the work of tracing, collecting packlists,
extracting modules in fatlib, then concatenating into a packed script
- in one shot. If you need more detailed controls for additional
modules, use the following commands separately (see L</RECIPES>).

=head2 trace

  $ fatpack trace [--to=trace-file|--to-stderr] [--use=MODULE]
      myscript.pl

Compiles myscript.pl (as in "perl -c") and writes out a trace file containing
every module require()d during the compilation.

The trace file is called 'fatpacker.trace' by default; the --to option
overrides this.

If you pass --to-stderr fatpack writes the trace to STDERR instead.

You cannot pass both --to and --to-stderr.

If the --use option specifies a module (or modules, if used multiple
times) those modules will be additionally included in the trace output.

=head2 packlists-for

  $ fatpack packlists-for Module1 Module2 Module3

Searches your perl's @INC for .packlist files containing the .pm files for
the modules requested and emits a list of unique packlist files to STDOUT.

These packlists will, in a pure cpan-installation environment, be all non-core
distributions required for those modules.

Unfortunately most vendors strip the .packlist files so if you installed
modules via e.g. apt-get you may be missing those modules; installing your
dependencies into a L<local::lib|local::lib> first is the preferred workaround.

=head2 tree

  $ fatpack tree fatlib packlist1 packlist2 packlist3

Takes a list of packlist files and copies their contents into a tree at the
requested location.

This tree should be sufficient to 'use lib' to make available all modules
provided by the distributions whose packlists were specified.

=head2 file

  $ fatpack file

Recurses into the 'lib' and 'fatlib' directories and bundles all .pm files
found into a BEGIN block which adds a virtual @INC entry to load these files
from the bundled code rather than disk.

=head1 RECIPES

Current basic recipe for packing:

  $ fatpack trace myscript.pl
  $ fatpack packlists-for `cat fatpacker.trace` >packlists
  $ fatpack tree `cat packlists`
  $ fatpack file myscript.pl >myscript.packed.pl

=head1 COPYRIGHT, LICENSE, AUTHOR

See the corresponding sections in L<App::FatPacker>.

=cut
