#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/perlfind.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PERLFIND';
  package App::perlfind;
  use strict;
  use warnings;
  use Class::Trigger;
  use Module::Pluggable require => 1;
  __PACKAGE__->plugins;    # 'require' them
  use parent qw(Pod::Cpandoc);
  our $VERSION = '2.07';
  
  # separate function so it's testable
  sub find_matches {
      my $word = shift;
      my @matches;
      __PACKAGE__->call_trigger('matches.add', \$word, \@matches);
      return ($word, @matches);
  }
  
  sub grand_search_init {
      my ($self, $pages, @found) = @_;
      my (@new_pages, $done_opt_f, $done_opt_v);
      for my $page (@$pages) {
  
          # $page is a search term, see Pod::Perldoc
          my @matches;
          ($page, @matches) = find_matches($page);
  
          # If perlfunc or perlvar are indicated, set options as though
          # -f or -v were given, respectively, so Pod::Perldoc will only
          # show the relevant part of that document.
          if (grep { $_ eq 'perlfunc' } @matches) {
              $self->opt_f_with($page) unless $done_opt_v++;
          }
          if (grep { $_ eq 'perlvar' } @matches) {
              $self->opt_v_with($page) unless $done_opt_f++;
          }
          if (@matches) {
              push @new_pages, @matches;
          } else {
  
              # pass through; maybe someone higher up knows what to do
              # with it
              push @new_pages, $page;
          }
      }
      $self->SUPER::grand_search_init(\@new_pages, @found);
  }
  
  sub opt_V {
      my $self = shift;
      print "perlfind v$VERSION, ";
      $self->SUPER::opt_V(@_);
  }
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  App::perlfind - A more knowledgeable perldoc
  
  =head1 SYNOPSIS
  
      # perlfind UNIVERSAL::isa
      # (runs `perldoc perlobj`)
  
      # Include features of cpandoc and perldoc:
  
      # perlfind File::Find
      # perlfind -m Acme::BadExample | grep system
      # vim `perlfind -l Web::Scraper`
      # perlfind -q FAQ Keyword
  
  =head1 DESCRIPTION
  
  C<perlfind> is like C<cpandoc> and therefore also like C<perldoc>
  except it knows about more things. Try these:
  
      perlfind xor
      perlfind foreach
      perlfind isa
      perlfind AUTOLOAD
      perlfind TIEARRAY
      perlfind INPUT_RECORD_SEPARATOR
      perlfind '$^F'
      perlfind '\Q'
      perlfind PERL5OPT
      perlfind :mmap
      perlfind __WARN__
      perlfind __PACKAGE__
      perlfind head4
      perlfind UNITCHECK
  
  If C<perlfind> doesn't know about a search term, it will delegate the
  search to L<Pod::Cpandoc> and ultimately C<Pod::Perldoc>.
  
  =head1 FUNCTIONS
  
  =head2 find_matches
  
  Takes a word and returns the matches for that word. It's in a separate
  function to separate logic from presentation so other programs can use
  this module as well.
  
  =head1 AUTHORS
  
  The following persons are the authors of all the files provided in
  this distribution unless explicitly noted otherwise.
  
  Marcel Gruenauer <marcel@cpan.org>, L<http://perlservices.at>
  
  Lars Dieckow <daxim@cpan.org>
  
  Leo Lapworth <LLAP@cuckoo.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  The following copyright notice applies to all the files provided in
  this distribution, including binary files, unless explicitly noted
  otherwise.
  
  This software is copyright (c) 2011-2015 by Marcel Gruenauer.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =begin Pod::Coverage
  
    grand_search_init
    opt_V
  
  =end Pod::Coverage
  
APP_PERLFIND

$fatpacked{"App/perlfind/Plugin/FoundIn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PERLFIND_PLUGIN_FOUNDIN';
  package App::perlfind::Plugin::FoundIn;
  use strict;
  use warnings;
  use App::perlfind;
  our $VERSION = '2.07';
  
  # Specify like this because it's easier. We compute the reverse later (i.e.,
  # it should be easier on the hacker than on the computer).
  #
  # Note: 'for' is a keyword for perlpod as well ('=for'), but is listed for
  # perlsyn here, as that's more likely to be the intended meaning.
  our %found_in = (
      perlop => [
          qw(lt gt le ge eq ne cmp not and or xor
            q qq qr qx qw \l \u \L \U \Q \E)
      ],
      perlsyn => [qw(if else elsif unless while until for foreach)],
      perlobj => [qw(isa ISA can VERSION)],
      perlsub => [qw(AUTOLOAD DESTROY)],
      perlmod => [qw(BEGIN UNITCHECK CHECK INIT END)],
      perltie => [
          qw(TIESCALAR TIEARRAY TIEHASH TIEHANDLE FETCH STORE UNTIE
            FETCHSIZE STORESIZE POP PUSH SHIFT UNSHIFT SPLICE DELETE EXISTS
            EXTEND CLEAR FIRSTKEY NEXTKEY WRITE PRINT PRINTF READ READLINE GETC
            CLOSE)
      ],
      perlrun => [
          qw(HOME LOGDIR PATH PERL5LIB PERL5OPT PERLIO PERLIO_DEBUG PERLLIB
            PERL5DB PERL5DB_THREADED PERL5SHELL PERL_ALLOW_NON_IFS_LSP
            PERL_DEBUG_MSTATS PERL_DESTRUCT_LEVEL PERL_DL_NONLAZY PERL_ENCODING
            PERL_HASH_SEED PERL_HASH_SEED_DEBUG PERL_ROOT PERL_SIGNALS
            PERL_UNICODE)
      ],
      perlpod => [ map { ($_, "=$_") }
          qw(head1 head2 head3 head4 over item back cut pod begin end)
      ],
      perldata => [qw(__DATA__ __END__)],
  
      # We could also list common functions and methods provided by some
      # commonly used modules, like:
      Moose => [
          qw(has before after around super override inner augment confessed
            extends with)
      ],
      Error        => [qw(try catch except otherwise finally record)],
      Storable     => [qw(freeze thaw)],
      Carp         => [qw(carp cluck croak confess shortmess longmess)],
      'Test::More' => [
          qw(plan use_ok require_ok ok is isnt like unlike cmp_ok
            is_deeply diag can_ok isa_ok pass fail eq_array eq_hash eq_set skip
            todo_skip builder SKIP: TODO:)
      ],
      'Getopt::Long' => [qw(GetOptions)],
      'File::Find'   => [qw(find finddepth)],
      'File::Path'   => [qw(mkpath rmtree)],
      'File::Spec'   => [
          qw(canonpath catdir catfile curdir devnull rootdir
            tmpdir updir no_upwards case_tolerant file_name_is_absolute path
            splitpath splitdir catpath abs2rel rel2abs)
      ],
      'File::Basename' => [
          qw(fileparse fileparse_set_fstype basename
            dirname)
      ],
      'File::Temp' => [
          qw(tempfile tempdir tmpnam tmpfile mkstemp mkstemps
            mkdtemp mktemp unlink0 safe_level)
      ],
      'File::Copy' => [qw(copy move cp mv rmscopy)],
      'PerlIO' =>
        [qw(:bytes :crlf :mmap :perlio :pop :raw :stdio :unix :utf8 :win32)],
  );
  
  App::perlfind->add_trigger(
      'matches.add' => sub {
          my ($class, $word, $matches) = @_;
          while (my ($file, $words) = each our %found_in) {
              for (@$words) {
                  push @$matches, $file if $_ eq $$word;
              }
          }
      }
  );
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  App::perlfind::Plugin::FoundIn - Plugin to find documentation for syntax and concepts
  
  =head1 SYNOPSIS
  
      # perlfind elsif
      # (runs `perldoc perlsyn`)
  
  =head1 DESCRIPTION
  
  This plugin for L<App::perlfind> knows where to find documentation for syntax
  and built-in Perl concepts. It knows about things like
  
      elsif
      VERSION
      END
      head3
      =head3
      :utf8
  
APP_PERLFIND_PLUGIN_FOUNDIN

$fatpacked{"App/perlfind/Plugin/Functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PERLFIND_PLUGIN_FUNCTIONS';
  package App::perlfind::Plugin::Functions;
  use strict;
  use warnings;
  use App::perlfind;
  use Pod::Functions;
  our $VERSION = '2.07';
  
  # Use a look-up hash, so duplicates that appear more than once in
  # %Kinds are deduped; also add cleaned versions of functions found in
  # %Kinds. For example, for "qw/STRING/" also add "qw"; for "y///" also
  # add "y"; for "-X" also add "X".
  
  my %is_function;
  for my $function (map { @$_ } values %Kinds) {
      $is_function{$function}++;
      (my $cleaned = $function) =~ s!/STRING/!!;
      $cleaned =~ s/[^a-z]//g;
      $is_function{$cleaned}++;
  }
  App::perlfind->add_trigger(
      'matches.add' => sub {
          my ($class, $word, $matches) = @_;
          if ($is_function{$$word}) {
              # Add perlop as well because some thing are found there:
              # "s", "m", "tr" etc.; see Pod::Perldoc
  
              push @$matches, qw(perlfunc perlop);
          } elsif ($$word =~ /-[rwxoRWXOeszfdlpSbctugkTBMAC]/) {
              $$word = '-X';
              push @$matches, qw(perlfunc perlop);
          } elsif ($$word eq 'PROPAGATE') {
              $$word = 'die';
              push @$matches, qw(perlfunc perlop);
          }
      }
  );
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  App::perlfind::Plugin::Functions - Easier access to docs for built-in function
  
  =head1 SYNOPSIS
  
      # perlfind splice
      # (is the same as "perlfind -f splice")
  
      # perlfind -- -r
      # shows the -X entry in perlfunc
  
  =head1 DESCRIPTION
  
  This plugin for L<App::perlfind> checks whether the search term looks like a
  built-in function and if so, adds C<perlfunc> to the match results.
  
APP_PERLFIND_PLUGIN_FUNCTIONS

$fatpacked{"App/perlfind/Plugin/Label.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PERLFIND_PLUGIN_LABEL';
  package App::perlfind::Plugin::Label;
  use strict;
  use warnings;
  use App::perlfind;
  our $VERSION = '2.07';
  
  App::perlfind->add_trigger(
      'matches.add' => sub {
          my ($class, $word, $matches) = @_;
  
       # Is it a label (ends with ':')? Do this after %found_in, because there are
       # special labels such as 'SKIP:' and 'TODO:' that map to Test::More
          if ($$word =~ /^\w+:$/) { push @$matches, 'perlsyn' }
      }
  );
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  App::perlfind::Plugin::Label - Plugin for labels
  
  =head1 SYNOPSIS
  
      # perlfind FOO:
      # (runs `perldoc perlsyn`)
  
  =head1 DESCRIPTION
  
  This plugin for L<App::perlfind> checks whether the search term looks like a
  label and if so, adds C<perlsyn> to the match results.
  
APP_PERLFIND_PLUGIN_LABEL

$fatpacked{"App/perlfind/Plugin/Perlvar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PERLFIND_PLUGIN_PERLVAR';
  package App::perlfind::Plugin::Perlvar;
  use strict;
  use warnings;
  use App::perlfind;
  our $VERSION = '2.07';
  
  # Generate %is_var with "util/perlvar-extract.pl". The value is what
  # the query key gets rewritten as.
  
  # TODO generate this hash at runtime just like perlvar-extract does.
  # Needs to find perlvar.pod; at the moment I use "perldoc -l perlvar"
  # for that, but it seems bad to call perldoc more or less within
  # itself. Pod::Perldoc doesn't provide a method just to find the POD
  # file, though.
  
  my %is_var = (
              '%+' => '%+',
              'INPUT_LINE_NUMBER' => '$INPUT_LINE_NUMBER',
              '$ERRNO' => '$ERRNO',
              '$OSNAME' => '$OSNAME',
              '$b' => '$b',
              'ERRNO' => '%ERRNO',
              'SIG' => '%SIG',
              '$OUTPUT_FIELD_SEPARATOR' => '$OUTPUT_FIELD_SEPARATOR',
              '@_' => '@_',
              'UNICODE' => '${^UNICODE}',
              'LAST_SUBMATCH_RESULT' => '$LAST_SUBMATCH_RESULT',
              '$COMPILING' => '$COMPILING',
              '%ERRNO' => '%ERRNO',
              '$OUTPUT_RECORD_SEPARATOR' => '$OUTPUT_RECORD_SEPARATOR',
              '$FORMAT_NAME' => '$FORMAT_NAME',
              '${^RE_DEBUG_FLAGS}' => '${^RE_DEBUG_FLAGS}',
              '$EUID' => '$EUID',
              'OPEN' => '${^OPEN}',
              'EXECUTABLE_NAME' => '$EXECUTABLE_NAME',
              'EFFECTIVE_USER_ID' => '$EFFECTIVE_USER_ID',
              '$OS_ERROR' => '$OS_ERROR',
              'CHILD_ERROR_NATIVE' => '$^CHILD_ERROR_NATIVE',
              'ENCODING' => '${^ENCODING}',
              '$`' => '$`',
              '$~' => '$~',
              '$^T' => '$^T',
              'PROCESS_ID' => '$PROCESS_ID',
              'WARNING' => '$WARNING',
              '$EXCEPTIONS_BEING_CAUGHT' => '$EXCEPTIONS_BEING_CAUGHT',
              '$)' => '$)',
              '$2' => '$2',
              '$ORS' => '$ORS',
              '$^A' => '$^A',
              'LIST_SEPARATOR' => '$LIST_SEPARATOR',
              '${^UTF8CACHE}' => '${^UTF8CACHE}',
              '$OFS' => '$OFS',
              '%SIG' => '%SIG',
              '$EFFECTIVE_GROUP_ID' => '$EFFECTIVE_GROUP_ID',
              '$ARGV' => '$ARGV',
              '$^O' => '$^O',
              'DEBUGGING' => '$DEBUGGING',
              'EGID' => '$EGID',
              'MATCH' => '${^MATCH}',
              '$GID' => '$GID',
              'TAINT' => '${^TAINT}',
              '$MATCH' => '$MATCH',
              '${^WARNING_BITS}' => '${^WARNING_BITS}',
              '$^W' => '$^W',
              '$^E' => '$^E',
              '${^GLOBAL_PHASE}' => '${^GLOBAL_PHASE}',
              'PERLDB' => '$PERLDB',
              '$ARG' => '$ARG',
              '$:' => '$:',
              '$+' => '$+',
              '$RS' => '$RS',
              'UID' => '$UID',
              '@LAST_MATCH_START' => '@LAST_MATCH_START',
              'FORMAT_LINES_LEFT' => '$FORMAT_LINES_LEFT',
              'PERL_VERSION' => '$PERL_VERSION',
              '$/' => '$/',
              '2' => '$2',
              '$LAST_SUBMATCH_RESULT' => '$LAST_SUBMATCH_RESULT',
              'NR' => '$NR',
              'OUTPUT_FIELD_SEPARATOR' => '$OUTPUT_FIELD_SEPARATOR',
              '${^RE_TRIE_MAXBUF}' => '${^RE_TRIE_MAXBUF}',
              '$0' => '$0',
              'RE_TRIE_MAXBUF' => '${^RE_TRIE_MAXBUF}',
              '$^X' => '$^X',
              'OFS' => '$OFS',
              '$WARNING' => '$WARNING',
              'FORMAT_NAME' => '$FORMAT_NAME',
              '$=' => '$=',
              'ARGV' => '@ARGV',
              'INC' => '%INC',
              '${^UTF8LOCALE}' => '${^UTF8LOCALE}',
              '@INC' => '@INC',
              '${^PREMATCH}' => '${^PREMATCH}',
              '$FORMAT_FORMFEED' => '$FORMAT_FORMFEED',
              '$PERL_VERSION' => '$PERL_VERSION',
              '$[' => '$[',
              '$CHILD_ERROR' => '$CHILD_ERROR',
              '%-' => '%-',
              '$$' => '$$',
              '$FORMAT_TOP_NAME' => '$FORMAT_TOP_NAME',
              '$^V' => '$^V',
              '$EVAL_ERROR' => '$EVAL_ERROR',
              '$-' => '$-',
              '$ACCUMULATOR' => '$ACCUMULATOR',
              '$^I' => '$^I',
              '$^R' => '$^R',
              '%ENV' => '%ENV',
              '$&' => '$&',
              'OUTPUT_RECORD_SEPARATOR' => '$OUTPUT_RECORD_SEPARATOR',
              'ARRAY_BASE' => '$ARRAY_BASE',
              'EXCEPTIONS_BEING_CAUGHT' => '$EXCEPTIONS_BEING_CAUGHT',
              '$]' => '$]',
              '$LAST_PAREN_MATCH' => '$LAST_PAREN_MATCH',
              'PROGRAM_NAME' => '$PROGRAM_NAME',
              '$BASETIME' => '$BASETIME',
              '0' => '$0',
              '$UID' => '$UID',
              '${^WIN32_SLOPPY_STAT}' => '${^WIN32_SLOPPY_STAT}',
              '$^P' => '$^P',
              '$^N' => '$^N',
              'FORMAT_PAGE_NUMBER' => '$FORMAT_PAGE_NUMBER',
              'OSNAME' => '$OSNAME',
              'ARG' => '@ARG',
              '8' => '$8',
              'LAST_MATCH_END' => '@LAST_MATCH_END',
              '%!' => '%!',
              'LAST_PAREN_MATCH' => '%LAST_PAREN_MATCH',
              'OS_ERROR' => '%OS_ERROR',
              '$"' => '$"',
              '$EFFECTIVE_USER_ID' => '$EFFECTIVE_USER_ID',
              '$_' => '$_',
              '5' => '$5',
              'SUBSEP' => '$SUBSEP',
              '7' => '$7',
              '$EXTENDED_OS_ERROR' => '$EXTENDED_OS_ERROR',
              '${^MATCH}' => '${^MATCH}',
              '$PREMATCH' => '$PREMATCH',
              '$OFMT' => '$OFMT',
              'GID' => '$GID',
              '$a' => '$a',
              '$*' => '$*',
              '$PID' => '$PID',
              'OUTPUT_AUTOFLUSH' => '$OUTPUT_AUTOFLUSH',
              'PREMATCH' => '$PREMATCH',
              '%LAST_PAREN_MATCH' => '%LAST_PAREN_MATCH',
              '$FORMAT_LINES_LEFT' => '$FORMAT_LINES_LEFT',
              'GLOBAL_PHASE' => '${^GLOBAL_PHASE}',
              '$EXECUTABLE_NAME' => '$EXECUTABLE_NAME',
              '$POSTMATCH' => '$POSTMATCH',
              'INPUT_RECORD_SEPARATOR' => '$INPUT_RECORD_SEPARATOR',
              '${^UNICODE}' => '${^UNICODE}',
              '$^CHILD_ERROR_NATIVE' => '$^CHILD_ERROR_NATIVE',
              'FORMAT_LINES_PER_PAGE' => '$FORMAT_LINES_PER_PAGE',
              'OFMT' => '$OFMT',
              '$FORMAT_LINES_PER_PAGE' => '$FORMAT_LINES_PER_PAGE',
              'FORMAT_TOP_NAME' => '$FORMAT_TOP_NAME',
              '$EGID' => '$EGID',
              '$OUTPUT_AUTOFLUSH' => '$OUTPUT_AUTOFLUSH',
              '$3' => '$3',
              '$REAL_GROUP_ID' => '$REAL_GROUP_ID',
              '$;' => '$;',
              '$^L' => '$^L',
              'OLD_PERL_VERSION' => '$OLD_PERL_VERSION',
              '$SYSTEM_FD_MAX' => '$SYSTEM_FD_MAX',
              'POSTMATCH' => '${^POSTMATCH}',
              '$INPUT_LINE_NUMBER' => '$INPUT_LINE_NUMBER',
              '_' => '$_',
              '@LAST_MATCH_END' => '@LAST_MATCH_END',
              '$^S' => '$^S',
              '$LAST_REGEXP_CODE_RESULT' => '$LAST_REGEXP_CODE_RESULT',
              '${^OPEN}' => '${^OPEN}',
              '$1' => '$1',
              '@-' => '@-',
              'EFFECTIVE_GROUP_ID' => '$EFFECTIVE_GROUP_ID',
              '$|' => '$|',
              '%OS_ERROR' => '%OS_ERROR',
              '$^H' => '$^H',
              '%^H' => '%^H',
              '$.' => '$.',
              'WIN32_SLOPPY_STAT' => '${^WIN32_SLOPPY_STAT}',
              '$^D' => '$^D',
              '1' => '$1',
              'RS' => '$RS',
              '%INC' => '%INC',
              '$LIST_SEPARATOR' => '$LIST_SEPARATOR',
              'WARNING_BITS' => '${^WARNING_BITS}',
              '$(' => '$(',
              '$#' => '$#',
              '$@' => '$@',
              'EXTENDED_OS_ERROR' => '$EXTENDED_OS_ERROR',
              'CHILD_ERROR' => '$CHILD_ERROR',
              'EUID' => '$EUID',
              '$,' => '$,',
              'ENV' => '%ENV',
              '$DEBUGGING' => '$DEBUGGING',
              '$INPUT_RECORD_SEPARATOR' => '$INPUT_RECORD_SEPARATOR',
              '$?' => '$?',
              '$REAL_USER_ID' => '$REAL_USER_ID',
              '$NR' => '$NR',
              '$^M' => '$^M',
              '${^TAINT}' => '${^TAINT}',
              'REAL_GROUP_ID' => '$REAL_GROUP_ID',
              '@ARGV' => '@ARGV',
              'LAST_REGEXP_CODE_RESULT' => '$LAST_REGEXP_CODE_RESULT',
              'UTF8CACHE' => '${^UTF8CACHE}',
              'FORMAT_FORMFEED' => '$FORMAT_FORMFEED',
              'ORS' => '$ORS',
              '$^F' => '$^F',
              '$%' => '$%',
              '$OLD_PERL_VERSION' => '$OLD_PERL_VERSION',
              '$ARRAY_BASE' => '$ARRAY_BASE',
              '${^POSTMATCH}' => '${^POSTMATCH}',
              'RE_DEBUG_FLAGS' => '${^RE_DEBUG_FLAGS}',
              '$SUBSEP' => '$SUBSEP',
              '$!' => '$!',
              '@ARG' => '@ARG',
              '$PROGRAM_NAME' => '$PROGRAM_NAME',
              '$FORMAT_PAGE_NUMBER' => '$FORMAT_PAGE_NUMBER',
              '6' => '$6',
              'PID' => '$PID',
              '$^C' => '$^C',
              '3' => '$3',
              'ACCUMULATOR' => '$ACCUMULATOR',
              '$INPLACE_EDIT' => '$INPLACE_EDIT',
              '@F' => '@F',
              '9' => '$9',
              'LAST_MATCH_START' => '%LAST_MATCH_START',
              '$\\' => '$\\',
              '${^ENCODING}' => '${^ENCODING}',
              '4' => '$4',
              'REAL_USER_ID' => '$REAL_USER_ID',
              '$^' => '$^',
              'BASETIME' => '$BASETIME',
              'COMPILING' => '$COMPILING',
              '@+' => '@+',
              '$PROCESS_ID' => '$PROCESS_ID',
              '$PERLDB' => '$PERLDB',
              'INPLACE_EDIT' => '$INPLACE_EDIT',
              'EVAL_ERROR' => '$EVAL_ERROR',
              'SYSTEM_FD_MAX' => '$SYSTEM_FD_MAX',
              'UTF8LOCALE' => '${^UTF8LOCALE}',
              '$\'' => '$\'',
              '%LAST_MATCH_START' => '%LAST_MATCH_START'
            );
  
  # find __WARN__, INT etc. as %SIG.
  $is_var{$_} = '%SIG' for qw(__WARN__ __DIE__ INT QUIT PIPE), keys %SIG;
  
  App::perlfind->add_trigger(
      'matches.add' => sub {
          my ($class, $word, $matches) = @_;
          if (my $rewrite = $is_var{$$word}) {
              $$word = $rewrite;
              push @$matches, 'perlvar';
          }
      }
  );
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  App::perlfind::Plugin::Perlvar - Plugin to find documentation for predefined variables
  
  =head1 SYNOPSIS
  
      # all of the following run "perldoc -v %SIG":
      # perlfind %SIG
      # perlfind SIG
      # perlfind QUIT
      # perlfind __WARN__
      # perlfind WARN
  
  =head1 DESCRIPTION
  
  This plugin for L<App::perlfind> knows where to find documentation for
  predefined variables and signals. It knows about things like
  
      OUTPUT_RECORD_SEPARATOR
      $^R
      __WARN__
      WARN
      QUIT
  
APP_PERLFIND_PLUGIN_PERLVAR

$fatpacked{"App/perlfind/Plugin/SpecialPackages.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PERLFIND_PLUGIN_SPECIALPACKAGES';
  package App::perlfind::Plugin::SpecialPackages;
  use strict;
  use warnings;
  use App::perlfind;
  our $VERSION = '2.07';
  
  App::perlfind->add_trigger(
      'matches.add' => sub {
          my ($class, $word, $matches) = @_;
          $$word =~ /^UNIVERSAL::/ && push @$matches, 'perlobj';
          $$word =~ /^CORE::/      && push @$matches, 'perlsub';
      }
  );
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  App::perlfind::Plugin::SpecialPackages - Plugin to find documentation for special Perl packages
  
  =head1 SYNOPSIS
  
      # perlfind UNIVERSAL::isa
      # (runs `perldoc perlobj`)
  
  =head1 DESCRIPTION
  
  This plugin for L<App::perlfind> knows where special Perl packages like
  C<UNIVERSAL::> and C<CORE::> are documented.
  
APP_PERLFIND_PLUGIN_SPECIALPACKAGES

$fatpacked{"App/perlfind/Plugin/UseModule.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PERLFIND_PLUGIN_USEMODULE';
  package App::perlfind::Plugin::UseModule;
  use strict;
  use warnings;
  use App::perlfind;
  our $VERSION = '2.07';
  
  App::perlfind->add_trigger(
      'matches.add' => sub {
          my ($class, $word, $matches) = @_;
          # does it look like a package name?
          return unless $$word =~ /^\w+(::\w+)*$/;
          my $try_module = sub {
              my $module = shift;
              eval "use $module;";
              return 0 if $@;
              push @$matches, $module;
              return 1;
          };
  
          # try it as a module
          return if $try_module->($$word);
  
          if ($$word =~ /::[A-Z]\w*$/) {
              push @$matches, $$word;
          } elsif ($$word =~ s/::\w+$//) {
              $try_module->($$word);
          }
      }
  );
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  App::perlfind::Plugin::UseModule - Try the search word as a module name
  
  =head1 SYNOPSIS
  
      # perlfind Getopt::Long
  
  =head1 DESCRIPTION
  
  This plugin for L<App::perlfind> tries to use the search term as a module name.
  If the module can be loaded, it is added to the match results.
  
  If it contains '::', it might be a fully qualified function name such as
  C<Foo::Bar::some_function> or a module that's not installed but whose
  namespace-parent might be installed. For example, if C<Foo::Bar> is installed
  but C<Foo::Bar::Baz> isn't, we don't want think that there is a function
  C<Baz()> in the package C<Foo::Bar>; rather we want to show the docs for
  C<Foo::Bar::Baz>. To distinguish between a function and a module, use a simple
  heuristic, which means it's a guess and won't always work: if the final symbol
  starts with an uppercase character, we assume it's a package, otherwise we
  assume it's a function.
APP_PERLFIND_PLUGIN_USEMODULE

$fatpacked{"App/perlfind/Plugin/VersionSpecific.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PERLFIND_PLUGIN_VERSIONSPECIFIC';
  package App::perlfind::Plugin::VersionSpecific;
  use strict;
  use warnings;
  use App::perlfind;
  our $VERSION = '2.07';
  
  App::perlfind->add_trigger(
      'matches.add' => sub {
          my ($class, $word, $matches) = @_;
          if ($$word =~ /^__(PACKAGE|LINE|FILE)__$/ && $] =~ /^5\.0(08|10|12|14)/) {
              push @$matches, qw(perldata);
          }
      }
  );
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  App::perlfind::Plugin::Legacy - Version-specific mappings
  
  =head1 SYNOPSIS
  
      # perlfind __PACKAGE__
      # behaves differently in 5.8.9 and 5.18.2, for example
  
  =head1 DESCRIPTION
  
  This plugin for L<App::perlfind> provides version-specific mappings. It does so
  in a very rudimentary way; it would be better if the whole architecture of
  C<perlfind> would take perl versions into account.
APP_PERLFIND_PLUGIN_VERSIONSPECIFIC

$fatpacked{"App/perlzonji.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PERLZONJI';
  package App::perlzonji;
  use strict;
  use warnings;
  our $VERSION = '2.07';
  
  1;
  
  # This package just exists so users who already have App::perlzonji
  # installed from before it was renamed to "perlfind" can upgrade it,
  # and they'll get the new bin/perlzonji, which will tell them that it
  # is deprecated and direct them to bin/perlfind, but it will continue
  # to work. In the unlikely case that someone is using App::perlzonji
  # directly, they have to rename it to App::perlfind.
APP_PERLZONJI

$fatpacked{"Class/Trigger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_TRIGGER';
  package Class::Trigger;
  use 5.008_001;
  use strict;
  use vars qw($VERSION);
  $VERSION = "0.14";
  
  use Carp ();
  
  my (%Triggers, %TriggerPoints);
  my %Fetch_All_Triggers_Cache;
  
  sub import {
      my $class = shift;
      my $pkg = caller(0);
  
      $TriggerPoints{$pkg} = { map { $_ => 1 } @_ } if @_;
  
      # export mixin methods
      no strict 'refs';
      my @methods = qw(add_trigger call_trigger last_trigger_results);
      *{"$pkg\::$_"} = \&{$_} for @methods;
  }
  
  sub add_trigger {
      my $proto = shift;
  
      my $triggers = __fetch_triggers($proto);
  
      my %params = @_;
      my @values = values %params;
      if (@_ > 2 && (grep { ref && ref eq 'CODE' } @values) == @values) {
          Carp::croak "mutiple trigger registration in one add_trigger() call is deprecated.";
      }
  
      if ($#_ == 1 && ref($_[1]) eq 'CODE') {
          @_ = (name => $_[0], callback => $_[1]);
      }
  
      my %args = ( name => undef, callback => undef, abortable => undef, @_ );
      my $when = $args{'name'};
      my $code = $args{'callback'};
      my $abortable = $args{'abortable'};
      __validate_triggerpoint( $proto, $when );
      Carp::croak('add_trigger() needs coderef') unless ref($code) eq 'CODE';
      push @{ $triggers->{$when} }, [ $code, $abortable ];
  
      # Clear the cache when class triggers are added.  Because triggers are 
      # inherited adding a trigger to one class may effect others.  Simplest
      # thing to do is to clear the whole thing.
      %Fetch_All_Triggers_Cache = () unless ref $proto;
  
      1;
  }
  
  
  sub last_trigger_results {
      my $self = shift;
      my $result_store = ref($self) ? $self : ${Class::Trigger::_trigger_results}->{$self};
      return $result_store->{'_class_trigger_results'};
  }
  
  sub call_trigger {
      my $self = shift;
      my $when = shift;
  
      my @return;
  
      my $result_store = ref($self) ? $self : ${Class::Trigger::_trigger_results}->{$self};
  
      $result_store->{'_class_trigger_results'} = [];
  
      if (my @triggers = __fetch_all_triggers($self, $when)) { # any triggers?
          for my $trigger (@triggers) {
              my @return = $trigger->[0]->($self, @_);
              push @{$result_store->{'_class_trigger_results'}}, \@return;
              return undef if ($trigger->[1] and not $return[0]); # only abort on false values.
          }
      }
      else {
          # if validation is enabled we can only add valid trigger points
          # so we only need to check in call_trigger() if there's no
          # trigger with the requested name.
          __validate_triggerpoint($self, $when);
      }
  
      return scalar @{$result_store->{'_class_trigger_results'}};
  }
  
  sub __fetch_all_triggers {
      my ($obj, $when, $list, $order, $nocache) = @_;
      $nocache = 0 unless defined $nocache;
      my $class = ref $obj || $obj;
      my $return;
      my $when_key = defined $when ? $when : '';
      
      unless ($nocache) {
          return __cached_triggers($obj, $when)
              if $Fetch_All_Triggers_Cache{$class}{$when_key};
      }
      
      unless ($list) {
          # Absence of the $list parameter conditions the creation of
          # the unrolled list of triggers. These keep track of the unique
          # set of triggers being collected for each class and the order
          # in which to return them (based on hierarchy; base class
          # triggers are returned ahead of descendant class triggers).
          $list = {};
          $order = [];
          $return = 1;
      }
      no strict 'refs';
      my @classes = @{$class . '::ISA'};
      push @classes, $class;
      foreach my $c (@classes) {
          next if $list->{$c};
  #        if (UNIVERSAL::can($c, 'call_trigger')) {
          if ($c->can('call_trigger')) {
              $list->{$c} = [];
              __fetch_all_triggers($c, $when, $list, $order, 1)
                  unless $c eq $class;
              if (defined $when && $Triggers{$c}{$when}) {
                  push @$order, $c;
                  $list->{$c} = $Triggers{$c}{$when};
              }
          }
      }
      if ($return) {
          my @triggers;
          foreach my $class (@$order) {
              push @triggers, @{ $list->{$class} };
          }
  
          # Only cache the class triggers, object triggers would
          # necessitate a much larger cache and they're cheap to
          # get anyway.
          $Fetch_All_Triggers_Cache{$class}{$when_key} = \@triggers;
  
          return __cached_triggers($obj, $when);
      }
  }
  
  
  sub __cached_triggers {
      my($proto, $when) = @_;
      my $class = ref $proto || $proto;
      
      return @{ $Fetch_All_Triggers_Cache{$class}{$when || ''} },
             @{ __object_triggers($proto, $when) };
  }
  
  
  sub __object_triggers {
      my($obj, $when) = @_;
      
      return [] unless ref $obj && defined $when;
      return $obj->{__triggers}{$when} || [];
  }
  
  
  sub __validate_triggerpoint {
      return unless my $points = $TriggerPoints{ref $_[0] || $_[0]};
      my ($self, $when) = @_;
      Carp::croak("$when is not valid triggerpoint for ".(ref($self) ? ref($self) : $self))
          unless $points->{$when};
  }
  
  sub __fetch_triggers {
      my ($obj, $proto) = @_;
      # check object based triggers first
      return ref $obj ? $obj->{__triggers} ||= {} : $Triggers{$obj} ||= {};
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Class::Trigger - Mixin to add / call inheritable triggers
  
  =head1 SYNOPSIS
  
    package Foo;
    use Class::Trigger;
  
    sub foo {
        my $self = shift;
        $self->call_trigger('before_foo');
        # some code ...
        $self->call_trigger('middle_of_foo');
        # some code ...
        $self->call_trigger('after_foo');
    }
  
    package main;
    Foo->add_trigger(before_foo => \&sub1);
    Foo->add_trigger(after_foo => \&sub2);
  
    my $foo = Foo->new;
    $foo->foo;            # then sub1, sub2 called
  
    # triggers are inheritable
    package Bar;
    use base qw(Foo);
  
    Bar->add_trigger(before_foo => \&sub);
  
    # triggers can be object based
    $foo->add_trigger(after_foo => \&sub3);
    $foo->foo;            # sub3 would appply only to this object
  
  =head1 DESCRIPTION
  
  Class::Trigger is a mixin class to add / call triggers (or hooks)
  that get called at some points you specify.
  
  =head1 METHODS
  
  By using this module, your class is capable of following methods.
  
  =over 4
  
  =item add_trigger
  
    Foo->add_trigger($triggerpoint => $sub);
    $foo->add_trigger($triggerpoint => $sub);
  
  
    Foo->add_trigger( name => $triggerpoint,
                      callback => sub {return undef},
                      abortable => 1); 
  
    # no further triggers will be called. Undef will be returned.
  
  
  Adds triggers for trigger point. You can have any number of triggers
  for each point. Each coderef will be passed a reference to the calling object, 
  as well as arguments passed in via L<call_trigger>. Return values will be
  captured in I<list context>.
  
  If add_trigger is called with named parameters and the C<abortable>
  parameter is passed a true value, a false return value from trigger
  code will stop processing of this trigger point and return a C<false>
  value to the calling code.
  
  If C<add_trigger> is called without the C<abortable> flag, return
  values will be captured by call_trigger, but failures will be ignored.
  
  If C<add_trigger> is called as object method, whole current trigger
  table will be copied onto the object and the new trigger added to
  that. (The object must be implemented as hash.)
  
    my $foo = Foo->new;
  
    # this trigger ($sub_foo) would apply only to $foo object
    $foo->add_trigger($triggerpoint => $sub_foo);
    $foo->foo;
  
    # And not to another $bar object
    my $bar = Foo->new;
    $bar->foo;
  
  =item call_trigger
  
    $foo->call_trigger($triggerpoint, @args);
  
  Calls triggers for trigger point, which were added via C<add_trigger>
  method. Each triggers will be passed a copy of the object as the first argument.
  Remaining arguments passed to C<call_trigger> will be passed on to each trigger.
  Triggers are invoked in the same order they were defined.
  
  If there are no C<abortable> triggers or no C<abortable> trigger point returns 
  a false value, C<call_trigger> will return the number of triggers processed.
  
  
  If an C<abortable> trigger returns a false value, call trigger will stop execution
  of the trigger point and return undef.
  
  =item last_trigger_results
  
      my @results = @{ $foo->last_trigger_results };
  
  Returns a reference to an array of the return values of all triggers called
  for the last trigger point. Results are ordered in the same order the triggers
  were run.
  
  
  =back
  
  =head1 TRIGGER POINTS
  
  By default you can make any number of trigger points, but if you want
  to declare names of trigger points explicitly, you can do it via
  C<import>.
  
    package Foo;
    use Class::Trigger qw(foo bar baz);
  
    package main;
    Foo->add_trigger(foo  => \&sub1); # okay
    Foo->add_trigger(hoge => \&sub2); # exception
  
  =head1 FAQ
  
  B<Acknowledgement:> Thanks to everyone at POOP mailing-list
  (http://poop.sourceforge.net/).
  
  =over 4
  
  =item Q.
  
  This module lets me add subs to be run before/after a specific
  subroutine is run.  Yes?
  
  =item A.
  
  You put various call_trigger() method in your class.  Then your class
  users can call add_trigger() method to add subs to be run in points
  just you specify (exactly where you put call_trigger()).
  
  =item Q.
  
  Are you aware of the perl-aspects project and the Aspect module?  Very
  similar to Class::Trigger by the look of it, but its not nearly as
  explicit.  Its not necessary for foo() to actually say "triggers go
  *here*", you just add them.
  
  =item A.
  
  Yep ;)
  
  But the difference with Aspect would be that Class::Trigger is so
  simple that it's easy to learn, and doesn't require 5.6 or over.
  
  =item Q.
  
  How does this compare to Sub::Versive, or Hook::LexWrap?
  
  =item A.
  
  Very similar. But the difference with Class::Trigger would be the
  explicitness of trigger points.
  
  In addition, you can put hooks in any point, rather than pre or post
  of a method.
  
  =item Q.
  
  It looks interesting, but I just can't think of a practical example of
  its use...
  
  =item A.
  
  (by Tony Bowden)
  
  I originally added code like this to Class::DBI to cope with one
  particular case: auto-upkeep of full-text search indices.
  
  So I added functionality in Class::DBI to be able to trigger an
  arbitary subroutine every time something happened - then it was a
  simple matter of setting up triggers on INSERT and UPDATE to reindex
  that row, and on DELETE to remove that index row.
  
  See L<Class::DBI::mysql::FullTextSearch> and its source code to see it
  in action.
  
  =back
  
  =head1 AUTHORS
  
  Original idea by Tony Bowden E<lt>tony@kasei.comE<gt> in Class::DBI.
  
  Code by Tatsuhiko Miyagawa E<lt>miyagawa@bulknews.netE<gt>.
  
  Jesse Vincent added a code to get return values from triggers and
  abortable flag.
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Class::DBI>
  
  =cut
  
CLASS_TRIGGER

$fatpacked{"Devel/InnerPackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_INNERPACKAGE';
  package Devel::InnerPackage;
  
  use strict;
  use Exporter 5.57 'import';
  use vars qw($VERSION @EXPORT_OK);
  
  use if $] > 5.017, 'deprecate';
  
  $VERSION = '0.4';
  @EXPORT_OK = qw(list_packages);
  
  =pod
  
  =head1 NAME
  
  Devel::InnerPackage - find all the inner packages of a package
  
  =head1 SYNOPSIS
  
      use Foo::Bar;
      use Devel::InnerPackage qw(list_packages);
  
      my @inner_packages = list_packages('Foo::Bar');
  
  
  =head1 DESCRIPTION
  
  
  Given a file like this
  
  
      package Foo::Bar;
  
      sub foo {}
  
  
      package Foo::Bar::Quux;
  
      sub quux {}
  
      package Foo::Bar::Quirka;
  
      sub quirka {}
  
      1;
  
  then
  
      list_packages('Foo::Bar');
  
  will return
  
      Foo::Bar::Quux
      Foo::Bar::Quirka
  
  =head1 METHODS
  
  =head2 list_packages <package name>
  
  Return a list of all inner packages of that package.
  
  =cut
  
  sub list_packages {
              my $pack = shift; $pack .= "::" unless $pack =~ m!::$!;
  
              no strict 'refs';
              my @packs;
              my @stuff = grep !/^(main|)::$/, keys %{$pack};
              for my $cand (grep /::$/, @stuff)
              {
                  $cand =~ s!::$!!;
                  my @children = list_packages($pack.$cand);
      
                  push @packs, "$pack$cand" unless $cand =~ /^::/ ||
                      !__PACKAGE__->_loaded($pack.$cand); # or @children;
                  push @packs, @children;
              }
              return grep {$_ !~ /::(::ISA::CACHE|SUPER)/} @packs;
  }
  
  ### XXX this is an inlining of the Class-Inspector->loaded()
  ### method, but inlined to remove the dependency.
  sub _loaded {
         my ($class, $name) = @_;
  
          no strict 'refs';
  
         # Handle by far the two most common cases
         # This is very fast and handles 99% of cases.
         return 1 if defined ${"${name}::VERSION"};
         return 1 if @{"${name}::ISA"};
  
         # Are there any symbol table entries other than other namespaces
         foreach ( keys %{"${name}::"} ) {
                 next if substr($_, -2, 2) eq '::';
                 return 1 if defined &{"${name}::$_"};
         }
  
         # No functions, and it doesn't have a version, and isn't anything.
         # As an absolute last resort, check for an entry in %INC
         my $filename = join( '/', split /(?:'|::)/, $name ) . '.pm';
         return 1 if defined $INC{$filename};
  
         '';
  }
  
  
  =head1 AUTHOR
  
  Simon Wistow <simon@thegestalt.org>
  
  =head1 COPYING
  
  Copyright, 2005 Simon Wistow
  
  Distributed under the same terms as Perl itself.
  
  =head1 BUGS
  
  None known.
  
  =cut 
  
  
  
  
  
  1;
DEVEL_INNERPACKAGE

$fatpacked{"Module/Pluggable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_PLUGGABLE';
  package Module::Pluggable;
  
  use strict;
  use vars qw($VERSION $FORCE_SEARCH_ALL_PATHS);
  use Module::Pluggable::Object;
  
  use if $] > 5.017, 'deprecate';
  
  # ObQuote:
  # Bob Porter: Looks like you've been missing a lot of work lately.
  # Peter Gibbons: I wouldn't say I've been missing it, Bob!
  
  
  $VERSION = '5.2';
  $FORCE_SEARCH_ALL_PATHS = 0;
  
  sub import {
      my $class        = shift;
      my %opts         = @_;
  
      my ($pkg, $file) = caller;
      # the default name for the method is 'plugins'
      my $sub          = $opts{'sub_name'}  || 'plugins';
      # get our package
      my ($package)    = $opts{'package'} || $pkg;
      $opts{filename}  = $file;
      $opts{package}   = $package;
      $opts{force_search_all_paths} = $FORCE_SEARCH_ALL_PATHS unless exists $opts{force_search_all_paths};
  
  
      my $finder       = Module::Pluggable::Object->new(%opts);
      my $subroutine   = sub { my $self = shift; return $finder->plugins(@_) };
  
      my $searchsub = sub {
                my $self = shift;
                my ($action,@paths) = @_;
  
                $finder->{'search_path'} = ["${package}::Plugin"] if ($action eq 'add'  and not   $finder->{'search_path'} );
                push @{$finder->{'search_path'}}, @paths      if ($action eq 'add');
                $finder->{'search_path'}       = \@paths      if ($action eq 'new');
                return $finder->{'search_path'};
      };
  
  
      my $onlysub = sub {
          my ($self, $only) = @_;
  
          if (defined $only) {
              $finder->{'only'} = $only;
          };
  
          return $finder->{'only'};
      };
  
      my $exceptsub = sub {
          my ($self, $except) = @_;
  
          if (defined $except) {
              $finder->{'except'} = $except;
          };
  
          return $finder->{'except'};
      };
  
  
      no strict 'refs';
      no warnings qw(redefine prototype);
  
      *{"$package\::$sub"}        = $subroutine;
      *{"$package\::search_path"} = $searchsub;
      *{"$package\::only"}        = $onlysub;
      *{"$package\::except"}      = $exceptsub;
  
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  Module::Pluggable - automatically give your module the ability to have plugins
  
  =head1 SYNOPSIS
  
  
  Simple use Module::Pluggable -
  
      package MyClass;
      use Module::Pluggable;
  
  
  and then later ...
  
      use MyClass;
      my $mc = MyClass->new();
      # returns the names of all plugins installed under MyClass::Plugin::*
      my @plugins = $mc->plugins();
  
  =head1 EXAMPLE
  
  Why would you want to do this? Say you have something that wants to pass an
  object to a number of different plugins in turn. For example you may
  want to extract meta-data from every email you get sent and do something
  with it. Plugins make sense here because then you can keep adding new
  meta data parsers and all the logic and docs for each one will be
  self contained and new handlers are easy to add without changing the
  core code. For that, you might do something like ...
  
      package Email::Examiner;
  
      use strict;
      use Email::Simple;
      use Module::Pluggable require => 1;
  
      sub handle_email {
          my $self  = shift;
          my $email = shift;
  
          foreach my $plugin ($self->plugins) {
              $plugin->examine($email);
          }
  
          return 1;
      }
  
  
  
  .. and all the plugins will get a chance in turn to look at it.
  
  This can be trivially extended so that plugins could save the email
  somewhere and then no other plugin should try and do that.
  Simply have it so that the C<examine> method returns C<1> if
  it has saved the email somewhere. You might also want to be paranoid
  and check to see if the plugin has an C<examine> method.
  
          foreach my $plugin ($self->plugins) {
              next unless $plugin->can('examine');
              last if     $plugin->examine($email);
          }
  
  
  And so on. The sky's the limit.
  
  
  =head1 DESCRIPTION
  
  Provides a simple but, hopefully, extensible way of having 'plugins' for
  your module. Obviously this isn't going to be the be all and end all of
  solutions but it works for me.
  
  Essentially all it does is export a method into your namespace that
  looks through a search path for .pm files and turn those into class names.
  
  Optionally it instantiates those classes for you.
  
  =head1 ADVANCED USAGE
  
  Alternatively, if you don't want to use 'plugins' as the method ...
  
      package MyClass;
      use Module::Pluggable sub_name => 'foo';
  
  
  and then later ...
  
      my @plugins = $mc->foo();
  
  
  Or if you want to look in another namespace
  
      package MyClass;
      use Module::Pluggable search_path => ['Acme::MyClass::Plugin', 'MyClass::Extend'];
  
  or directory
  
      use Module::Pluggable search_dirs => ['mylibs/Foo'];
  
  
  Or if you want to instantiate each plugin rather than just return the name
  
      package MyClass;
      use Module::Pluggable instantiate => 'new';
  
  and then
  
      # whatever is passed to 'plugins' will be passed
      # to 'new' for each plugin
      my @plugins = $mc->plugins(@options);
  
  
  alternatively you can just require the module without instantiating it
  
      package MyClass;
      use Module::Pluggable require => 1;
  
  since requiring automatically searches inner packages, which may not be desirable, you can turn this off
  
  
      package MyClass;
      use Module::Pluggable require => 1, inner => 0;
  
  
  You can limit the plugins loaded using the except option, either as a string,
  array ref or regex
  
      package MyClass;
      use Module::Pluggable except => 'MyClass::Plugin::Foo';
  
  or
  
      package MyClass;
      use Module::Pluggable except => ['MyClass::Plugin::Foo', 'MyClass::Plugin::Bar'];
  
  or
  
      package MyClass;
      use Module::Pluggable except => qr/^MyClass::Plugin::(Foo|Bar)$/;
  
  
  and similarly for only which will only load plugins which match.
  
  Remember you can use the module more than once
  
      package MyClass;
      use Module::Pluggable search_path => 'MyClass::Filters' sub_name => 'filters';
      use Module::Pluggable search_path => 'MyClass::Plugins' sub_name => 'plugins';
  
  and then later ...
  
      my @filters = $self->filters;
      my @plugins = $self->plugins;
  
  =head1 PLUGIN SEARCHING
  
  Every time you call 'plugins' the whole search path is walked again. This allows
  for dynamically loading plugins even at run time. However this can get expensive
  and so if you don't expect to want to add new plugins at run time you could do
  
  
    package Foo;
    use strict;
    use Module::Pluggable sub_name => '_plugins';
  
    our @PLUGINS;
    sub plugins { @PLUGINS ||= shift->_plugins }
    1;
  
  =head1 INNER PACKAGES
  
  If you have, for example, a file B<lib/Something/Plugin/Foo.pm> that
  contains package definitions for both C<Something::Plugin::Foo> and
  C<Something::Plugin::Bar> then as long as you either have either
  the B<require> or B<instantiate> option set then we'll also find
  C<Something::Plugin::Bar>. Nifty!
  
  =head1 OPTIONS
  
  You can pass a hash of options when importing this module.
  
  The options can be ...
  
  =head2 sub_name
  
  The name of the subroutine to create in your namespace.
  
  By default this is 'plugins'
  
  =head2 search_path
  
  An array ref of namespaces to look in.
  
  =head2 search_dirs
  
  An array ref of directories to look in before @INC.
  
  =head2 instantiate
  
  Call this method on the class. In general this will probably be 'new'
  but it can be whatever you want. Whatever arguments are passed to 'plugins'
  will be passed to the method.
  
  The default is 'undef' i.e just return the class name.
  
  =head2 require
  
  Just require the class, don't instantiate (overrides 'instantiate');
  
  =head2 inner
  
  If set to 0 will B<not> search inner packages.
  If set to 1 will override C<require>.
  
  =head2 only
  
  Takes a string, array ref or regex describing the names of the only plugins to
  return. Whilst this may seem perverse ... well, it is. But it also
  makes sense. Trust me.
  
  =head2 except
  
  Similar to C<only> it takes a description of plugins to exclude
  from returning. This is slightly less perverse.
  
  =head2 package
  
  This is for use by extension modules which build on C<Module::Pluggable>:
  passing a C<package> option allows you to place the plugin method in a
  different package other than your own.
  
  =head2 file_regex
  
  By default C<Module::Pluggable> only looks for I<.pm> files.
  
  By supplying a new C<file_regex> then you can change this behaviour e.g
  
      file_regex => qr/\.plugin$/
  
  =head2 include_editor_junk
  
  By default C<Module::Pluggable> ignores files that look like they were
  left behind by editors. Currently this means files ending in F<~> (~),
  the extensions F<.swp> or F<.swo>, or files beginning with F<.#>.
  
  Setting C<include_editor_junk> changes C<Module::Pluggable> so it does
  not ignore any files it finds.
  
  =head2 follow_symlinks
  
  Whether, when searching directories, to follow symlinks.
  
  Defaults to 1 i.e do follow symlinks.
  
  =head2 min_depth, max_depth
  
  This will allow you to set what 'depth' of plugin will be allowed.
  
  So, for example, C<MyClass::Plugin::Foo> will have a depth of 3 and
  C<MyClass::Plugin::Foo::Bar> will have a depth of 4 so to only get the former
  (i.e C<MyClass::Plugin::Foo>) do
  
          package MyClass;
          use Module::Pluggable max_depth => 3;
  
  and to only get the latter (i.e C<MyClass::Plugin::Foo::Bar>)
  
          package MyClass;
          use Module::Pluggable min_depth => 4;
  
  
  =head1 TRIGGERS
  
  Various triggers can also be passed in to the options.
  
  If any of these triggers return 0 then the plugin will not be returned.
  
  =head2 before_require <plugin>
  
  Gets passed the plugin name.
  
  If 0 is returned then this plugin will not be required either.
  
  =head2 on_require_error <plugin> <err>
  
  Gets called when there's an error on requiring the plugin.
  
  Gets passed the plugin name and the error.
  
  The default on_require_error handler is to C<carp> the error and return 0.
  
  =head2 on_instantiate_error <plugin> <err>
  
  Gets called when there's an error on instantiating the plugin.
  
  Gets passed the plugin name and the error.
  
  The default on_instantiate_error handler is to C<carp> the error and return 0.
  
  =head2 after_require <plugin>
  
  Gets passed the plugin name.
  
  If 0 is returned then this plugin will be required but not returned as a plugin.
  
  =head1 METHODs
  
  =head2 search_path
  
  The method C<search_path> is exported into you namespace as well.
  You can call that at any time to change or replace the
  search_path.
  
      $self->search_path( add => "New::Path" ); # add
      $self->search_path( new => "New::Path" ); # replace
  
  =head1 BEHAVIOUR UNDER TEST ENVIRONMENT
  
  In order to make testing reliable we exclude anything not from blib if blib.pm is
  in %INC.
  
  However if the module being tested used another module that itself used C<Module::Pluggable>
  then the second module would fail. This was fixed by checking to see if the caller
  had (^|/)blib/ in their filename.
  
  There's an argument that this is the wrong behaviour and that modules should explicitly
  trigger this behaviour but that particular code has been around for 7 years now and I'm
  reluctant to change the default behaviour.
  
  You can now (as of version 4.1) force Module::Pluggable to look outside blib in a test environment by doing either
  
          require Module::Pluggable;
          $Module::Pluggable::FORCE_SEARCH_ALL_PATHS = 1;
          import Module::Pluggable;
  
  or
  
          use Module::Pluggable force_search_all_paths => 1;
  
  =head1 @INC hooks and App::FatPacker
  
  If a module's @INC has a hook and that hook is an object which has a C<files()> method then we will
  try and require those files too. See C<t/26inc_hook.t> for an example.
  
  This has allowed L<App::FatPacker> (as of version 0.10.0) to provide support for Module::Pluggable.
  
  This should also, theoretically, allow someone to modify PAR to do the same thing.
  
  =head1 Module::Require recommended
  
  Up until version 5.2 L<Module::Pluggable> used a string C<eval> to require plugins.
  
  This has now been changed to optionally use L<Module::Runtime> and it's C<require_module> method when
  available and fall back to using a path based C<require> when not.
  
  It's recommended, but not required, that you install Module::Runtime.
  
  =head1 FUTURE PLANS
  
  This does everything I need and I can't really think of any other
  features I want to add. Famous last words of course (not least
  because we're up to version 5.0 at the time of writing).
  
  However suggestions (and patches) are always welcome.
  
  =head1 DEVELOPMENT
  
  The master repo for this module is at
  
  https://github.com/simonwistow/Module-Pluggable
  
  =head1 AUTHOR
  
  Simon Wistow <simon@thegestalt.org>
  
  =head1 COPYING
  
  Copyright, 2006 Simon Wistow
  
  Distributed under the same terms as Perl itself.
  
  =head1 BUGS
  
  None known.
  
  =head1 SEE ALSO
  
  L<File::Spec>, L<File::Find>, L<File::Basename>, L<Class::Factory::Util>, L<Module::Pluggable::Ordered>
  
  =cut
  
  
MODULE_PLUGGABLE

$fatpacked{"Module/Pluggable/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_PLUGGABLE_OBJECT';
  package Module::Pluggable::Object;
  
  use strict;
  use File::Find ();
  use File::Basename;
  use File::Spec::Functions qw(splitdir catdir curdir catfile abs2rel);
  use Carp qw(croak carp confess);
  use Devel::InnerPackage;
  use vars qw($VERSION $MR);
  
  use if $] > 5.017, 'deprecate';
  
  $VERSION = '5.2';
  
  BEGIN {
      eval {  require Module::Runtime };
      unless ($@) {
          Module::Runtime->import('require_module');
      } else {
          *require_module = sub {
              my $module = shift;
              my $path   = $module . ".pm";
              $path =~ s{::}{/}g;
              require $path;
          };
      }
  }
  
  
  sub new {
      my $class = shift;
      my %opts  = @_;
  
      return bless \%opts, $class;
  
  }
  
  ### Eugggh, this code smells 
  ### This is what happens when you keep adding patches
  ### *sigh*
  
  
  sub plugins {
      my $self = shift;
      my @args = @_;
  
      # override 'require'
      $self->{'require'} = 1 if $self->{'inner'};
  
      my $filename   = $self->{'filename'};
      my $pkg        = $self->{'package'};
  
      # Get the exception params instantiated
      $self->_setup_exceptions;
  
      # automatically turn a scalar search path or namespace into a arrayref
      for (qw(search_path search_dirs)) {
          $self->{$_} = [ $self->{$_} ] if exists $self->{$_} && !ref($self->{$_});
      }
  
      # default search path is '<Module>::<Name>::Plugin'
      $self->{'search_path'} ||= ["${pkg}::Plugin"]; 
  
      # default error handler
      $self->{'on_require_error'} ||= sub { my ($plugin, $err) = @_; carp "Couldn't require $plugin : $err"; return 0 };
      $self->{'on_instantiate_error'} ||= sub { my ($plugin, $err) = @_; carp "Couldn't instantiate $plugin: $err"; return 0 };
  
      # default whether to follow symlinks
      $self->{'follow_symlinks'} = 1 unless exists $self->{'follow_symlinks'};
  
      # check to see if we're running under test
      my @SEARCHDIR = exists $INC{"blib.pm"} && defined $filename && $filename =~ m!(^|/)blib/! && !$self->{'force_search_all_paths'} ? grep {/blib/} @INC : @INC;
  
      # add any search_dir params
      unshift @SEARCHDIR, @{$self->{'search_dirs'}} if defined $self->{'search_dirs'};
  
      # set our @INC up to include and prefer our search_dirs if necessary
      my @tmp = @INC;
      unshift @tmp, @{$self->{'search_dirs'} || []};
      local @INC = @tmp if defined $self->{'search_dirs'};
  
      my @plugins = $self->search_directories(@SEARCHDIR);
      push(@plugins, $self->handle_inc_hooks($_, @SEARCHDIR)) for @{$self->{'search_path'}};
      push(@plugins, $self->handle_innerpackages($_)) for @{$self->{'search_path'}};
      
      # return blank unless we've found anything
      return () unless @plugins;
  
      # remove duplicates
      # probably not necessary but hey ho
      my %plugins;
      for(@plugins) {
          next unless $self->_is_legit($_);
          $plugins{$_} = 1;
      }
  
      # are we instantiating or requiring?
      if (defined $self->{'instantiate'}) {
          my $method = $self->{'instantiate'};
          my @objs   = ();
          foreach my $package (sort keys %plugins) {
              next unless $package->can($method);
              my $obj = eval { $package->$method(@_) };
              $self->{'on_instantiate_error'}->($package, $@) if $@;
              push @objs, $obj if $obj;           
          }
          return @objs;
      } else { 
          # no? just return the names
          my @objs= sort keys %plugins;
          return @objs;
      }
  }
  
  sub _setup_exceptions {
      my $self = shift;
  
      my %only;   
      my %except; 
      my $only;
      my $except;
  
      if (defined $self->{'only'}) {
          if (ref($self->{'only'}) eq 'ARRAY') {
              %only   = map { $_ => 1 } @{$self->{'only'}};
          } elsif (ref($self->{'only'}) eq 'Regexp') {
              $only = $self->{'only'}
          } elsif (ref($self->{'only'}) eq '') {
              $only{$self->{'only'}} = 1;
          }
      }
          
  
      if (defined $self->{'except'}) {
          if (ref($self->{'except'}) eq 'ARRAY') {
              %except   = map { $_ => 1 } @{$self->{'except'}};
          } elsif (ref($self->{'except'}) eq 'Regexp') {
              $except = $self->{'except'}
          } elsif (ref($self->{'except'}) eq '') {
              $except{$self->{'except'}} = 1;
          }
      }
      $self->{_exceptions}->{only_hash}   = \%only;
      $self->{_exceptions}->{only}        = $only;
      $self->{_exceptions}->{except_hash} = \%except;
      $self->{_exceptions}->{except}      = $except;
          
  }
  
  sub _is_legit {
      my $self   = shift;
      my $plugin = shift;
      my %only   = %{$self->{_exceptions}->{only_hash}||{}};
      my %except = %{$self->{_exceptions}->{except_hash}||{}};
      my $only   = $self->{_exceptions}->{only};
      my $except = $self->{_exceptions}->{except};
      my $depth  = () = split '::', $plugin, -1;
  
      return 0 if     (keys %only   && !$only{$plugin}     );
      return 0 unless (!defined $only || $plugin =~ m!$only!     );
  
      return 0 if     (keys %except &&  $except{$plugin}   );
      return 0 if     (defined $except &&  $plugin =~ m!$except! );
      
      return 0 if     defined $self->{max_depth} && $depth>$self->{max_depth};
      return 0 if     defined $self->{min_depth} && $depth<$self->{min_depth};
  
      return 1;
  }
  
  sub search_directories {
      my $self      = shift;
      my @SEARCHDIR = @_;
  
      my @plugins;
      # go through our @INC
      foreach my $dir (@SEARCHDIR) {
          push @plugins, $self->search_paths($dir);
      }
      return @plugins;
  }
  
  
  sub search_paths {
      my $self = shift;
      my $dir  = shift;
      my @plugins;
  
      my $file_regex = $self->{'file_regex'} || qr/\.pm$/;
  
  
      # and each directory in our search path
      foreach my $searchpath (@{$self->{'search_path'}}) {
          # create the search directory in a cross platform goodness way
          my $sp = catdir($dir, (split /::/, $searchpath));
  
          # if it doesn't exist or it's not a dir then skip it
          next unless ( -e $sp && -d _ ); # Use the cached stat the second time
  
          my @files = $self->find_files($sp);
  
          # foreach one we've found 
          foreach my $file (@files) {
              # untaint the file; accept .pm only
              next unless ($file) = ($file =~ /(.*$file_regex)$/); 
              # parse the file to get the name
              my ($name, $directory, $suffix) = fileparse($file, $file_regex);
  
              next if (!$self->{include_editor_junk} && $self->_is_editor_junk($name));
  
              $directory = abs2rel($directory, $sp);
  
              # If we have a mixed-case package name, assume case has been preserved
              # correctly.  Otherwise, root through the file to locate the case-preserved
              # version of the package name.
              my @pkg_dirs = ();
              if ( $name eq lc($name) || $name eq uc($name) ) {
                  my $pkg_file = catfile($sp, $directory, "$name$suffix");
                  open PKGFILE, "<$pkg_file" or die "search_paths: Can't open $pkg_file: $!";
                  my $in_pod = 0;
                  while ( my $line = <PKGFILE> ) {
                      $in_pod = 1 if $line =~ m/^=\w/;
                      $in_pod = 0 if $line =~ /^=cut/;
                      next if ($in_pod || $line =~ /^=cut/);  # skip pod text
                      next if $line =~ /^\s*#/;               # and comments
                      if ( $line =~ m/^\s*package\s+(.*::)?($name)\s*;/i ) {
                          @pkg_dirs = split /::/, $1 if defined $1;;
                          $name = $2;
                          last;
                      }
                  }
                  close PKGFILE;
              }
  
              # then create the class name in a cross platform way
              $directory =~ s/^[a-z]://i if($^O =~ /MSWin32|dos/);       # remove volume
              my @dirs = ();
              if ($directory) {
                  ($directory) = ($directory =~ /(.*)/);
                  @dirs = grep(length($_), splitdir($directory)) 
                      unless $directory eq curdir();
                  for my $d (reverse @dirs) {
                      my $pkg_dir = pop @pkg_dirs; 
                      last unless defined $pkg_dir;
                      $d =~ s/\Q$pkg_dir\E/$pkg_dir/i;  # Correct case
                  }
              } else {
                  $directory = "";
              }
              my $plugin = join '::', $searchpath, @dirs, $name;
  
              next unless $plugin =~ m!(?:[a-z\d]+)[a-z\d]*!i;
  
              $self->handle_finding_plugin($plugin, \@plugins)
          }
  
          # now add stuff that may have been in package
          # NOTE we should probably use all the stuff we've been given already
          # but then we can't unload it :(
          push @plugins, $self->handle_innerpackages($searchpath);
      } # foreach $searchpath
  
      return @plugins;
  }
  
  sub _is_editor_junk {
      my $self = shift;
      my $name = shift;
  
      # Emacs (and other Unix-y editors) leave temp files ending in a
      # tilde as a backup.
      return 1 if $name =~ /~$/;
      # Emacs makes these files while a buffer is edited but not yet
      # saved.
      return 1 if $name =~ /^\.#/;
      # Vim can leave these files behind if it crashes.
      return 1 if $name =~ /\.sw[po]$/;
  
      return 0;
  }
  
  sub handle_finding_plugin {
      my $self    = shift;
      my $plugin  = shift;
      my $plugins = shift;
      my $no_req  = shift || 0;
      
      return unless $self->_is_legit($plugin);
      unless (defined $self->{'instantiate'} || $self->{'require'}) {
          push @$plugins, $plugin;
          return;
      } 
  
      $self->{before_require}->($plugin) || return if defined $self->{before_require};
      unless ($no_req) {
          my $tmp = $@;
          my $res = eval { require_module($plugin) };
          my $err = $@;
          $@      = $tmp;
          if ($err) {
              if (defined $self->{on_require_error}) {
                  $self->{on_require_error}->($plugin, $err) || return; 
              } else {
                  return;
              }
          }
      }
      $self->{after_require}->($plugin) || return if defined $self->{after_require};
      push @$plugins, $plugin;
  }
  
  sub find_files {
      my $self         = shift;
      my $search_path  = shift;
      my $file_regex   = $self->{'file_regex'} || qr/\.pm$/;
  
  
      # find all the .pm files in it
      # this isn't perfect and won't find multiple plugins per file
      #my $cwd = Cwd::getcwd;
      my @files = ();
      { # for the benefit of perl 5.6.1's Find, localize topic
          local $_;
          File::Find::find( { no_chdir => 1, 
                              follow   => $self->{'follow_symlinks'}, 
                              wanted   => sub { 
                               # Inlined from File::Find::Rule C< name => '*.pm' >
                               return unless $File::Find::name =~ /$file_regex/;
                               (my $path = $File::Find::name) =~ s#^\\./##;
                               push @files, $path;
                             }
                        }, $search_path );
      }
      #chdir $cwd;
      return @files;
  
  }
  
  sub handle_inc_hooks {
      my $self      = shift;
      my $path      = shift;
      my @SEARCHDIR = @_;
  
      my @plugins;
      for my $dir ( @SEARCHDIR ) {
          next unless ref $dir && eval { $dir->can( 'files' ) };
  
          foreach my $plugin ( $dir->files ) {
              $plugin =~ s/\.pm$//;
              $plugin =~ s{/}{::}g;
              next unless $plugin =~ m!^${path}::!;
              $self->handle_finding_plugin( $plugin, \@plugins );
          }
      }
      return @plugins;
  }
  
  sub handle_innerpackages {
      my $self = shift;
      return () if (exists $self->{inner} && !$self->{inner});
  
      my $path = shift;
      my @plugins;
  
      foreach my $plugin (Devel::InnerPackage::list_packages($path)) {
          $self->handle_finding_plugin($plugin, \@plugins, 1);
      }
      return @plugins;
  
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  Module::Pluggable::Object - automatically give your module the ability to have plugins
  
  =head1 SYNOPSIS
  
  
  Simple use Module::Pluggable -
  
      package MyClass;
      use Module::Pluggable::Object;
      
      my $finder = Module::Pluggable::Object->new(%opts);
      print "My plugins are: ".join(", ", $finder->plugins)."\n";
  
  =head1 DESCRIPTION
  
  Provides a simple but, hopefully, extensible way of having 'plugins' for 
  your module. Obviously this isn't going to be the be all and end all of
  solutions but it works for me.
  
  Essentially all it does is export a method into your namespace that 
  looks through a search path for .pm files and turn those into class names. 
  
  Optionally it instantiates those classes for you.
  
  This object is wrapped by C<Module::Pluggable>. If you want to do something
  odd or add non-general special features you're probably best to wrap this
  and produce your own subclass.
  
  =head1 OPTIONS
  
  See the C<Module::Pluggable> docs.
  
  =head1 AUTHOR
  
  Simon Wistow <simon@thegestalt.org>
  
  =head1 COPYING
  
  Copyright, 2006 Simon Wistow
  
  Distributed under the same terms as Perl itself.
  
  =head1 BUGS
  
  None known.
  
  =head1 SEE ALSO
  
  L<Module::Pluggable>
  
  =cut 
  
MODULE_PLUGGABLE_OBJECT

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  =head1 NAME
  
  Module::Runtime - runtime module handling
  
  =head1 SYNOPSIS
  
  	use Module::Runtime qw(
  		$module_name_rx is_module_name check_module_name
  		module_notional_filename require_module
  	);
  
  	if($module_name =~ /\A$module_name_rx\z/o) { ...
  	if(is_module_name($module_name)) { ...
  	check_module_name($module_name);
  
  	$notional_filename = module_notional_filename($module_name);
  	require_module($module_name);
  
  	use Module::Runtime qw(use_module use_package_optimistically);
  
  	$bi = use_module("Math::BigInt", 1.31)->new("1_234");
  	$widget = use_package_optimistically("Local::Widget")->new;
  
  	use Module::Runtime qw(
  		$top_module_spec_rx $sub_module_spec_rx
  		is_module_spec check_module_spec
  		compose_module_name
  	);
  
  	if($spec =~ /\A$top_module_spec_rx\z/o) { ...
  	if($spec =~ /\A$sub_module_spec_rx\z/o) { ...
  	if(is_module_spec("Standard::Prefix", $spec)) { ...
  	check_module_spec("Standard::Prefix", $spec);
  
  	$module_name =
  		compose_module_name("Standard::Prefix", $spec);
  
  =head1 DESCRIPTION
  
  The functions exported by this module deal with runtime handling of
  Perl modules, which are normally handled at compile time.  This module
  avoids using any other modules, so that it can be used in low-level
  infrastructure.
  
  The parts of this module that work with module names apply the same syntax
  that is used for barewords in Perl source.  In principle this syntax
  can vary between versions of Perl, and this module applies the syntax of
  the Perl on which it is running.  In practice the usable syntax hasn't
  changed yet.  There's some intent for Unicode module names to be supported
  in the future, but this hasn't yet amounted to any consistent facility.
  
  The functions of this module whose purpose is to load modules include
  workarounds for three old Perl core bugs regarding C<require>.  These
  workarounds are applied on any Perl version where the bugs exist, except
  for a case where one of the bugs cannot be adequately worked around in
  pure Perl.
  
  =head2 Module name syntax
  
  The usable module name syntax has not changed from Perl 5.000 up to
  Perl 5.19.8.  The syntax is composed entirely of ASCII characters.
  From Perl 5.6 onwards there has been some attempt to allow the use of
  non-ASCII Unicode characters in Perl source, but it was fundamentally
  broken (like the entirety of Perl 5.6's Unicode handling) and remained
  pretty much entirely unusable until it got some attention in the Perl
  5.15 series.  Although Unicode is now consistently accepted by the
  parser in some places, it remains broken for module names.  Furthermore,
  there has not yet been any work on how to map Unicode module names into
  filenames, so in that respect also Unicode module names are unusable.
  
  The module name syntax is, precisely: the string must consist of one or
  more segments separated by C<::>; each segment must consist of one or more
  identifier characters (ASCII alphanumerics plus "_"); the first character
  of the string must not be a digit.  Thus "C<IO::File>", "C<warnings>",
  and "C<foo::123::x_0>" are all valid module names, whereas "C<IO::>"
  and "C<1foo::bar>" are not.  C<'> separators are not permitted by this
  module, though they remain usable in Perl source, being translated to
  C<::> in the parser.
  
  =head2 Core bugs worked around
  
  The first bug worked around is core bug [perl #68590], which causes
  lexical state in one file to leak into another that is C<require>d/C<use>d
  from it.  This bug is present from Perl 5.6 up to Perl 5.10, and is
  fixed in Perl 5.11.0.  From Perl 5.9.4 up to Perl 5.10.0 no satisfactory
  workaround is possible in pure Perl.  The workaround means that modules
  loaded via this module don't suffer this pollution of their lexical
  state.  Modules loaded in other ways, or via this module on the Perl
  versions where the pure Perl workaround is impossible, remain vulnerable.
  The module L<Lexical::SealRequireHints> provides a complete workaround
  for this bug.
  
  The second bug worked around causes some kinds of failure in module
  loading, principally compilation errors in the loaded module, to be
  recorded in C<%INC> as if they were successful, so later attempts to load
  the same module immediately indicate success.  This bug is present up
  to Perl 5.8.9, and is fixed in Perl 5.9.0.  The workaround means that a
  compilation error in a module loaded via this module won't be cached as
  a success.  Modules loaded in other ways remain liable to produce bogus
  C<%INC> entries, and if a bogus entry exists then it will mislead this
  module if it is used to re-attempt loading.
  
  The third bug worked around causes the wrong context to be seen at
  file scope of a loaded module, if C<require> is invoked in a location
  that inherits context from a higher scope.  This bug is present up to
  Perl 5.11.2, and is fixed in Perl 5.11.3.  The workaround means that
  a module loaded via this module will always see the correct context.
  Modules loaded in other ways remain vulnerable.
  
  =cut
  
  package Module::Runtime;
  
  # Don't "use 5.006" here, because Perl 5.15.6 will load feature.pm if
  # the version check is done that way.
  BEGIN { require 5.006; }
  # Don't "use warnings" here, to avoid dependencies.  Do standardise the
  # warning status by lexical override; unfortunately the only safe bitset
  # to build in is the empty set, equivalent to "no warnings".
  BEGIN { ${^WARNING_BITS} = ""; }
  # Don't "use strict" here, to avoid dependencies.
  
  our $VERSION = "0.014";
  
  # Don't use Exporter here, to avoid dependencies.
  our @EXPORT_OK = qw(
  	$module_name_rx is_module_name is_valid_module_name check_module_name
  	module_notional_filename require_module
  	use_module use_package_optimistically
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec is_valid_module_spec check_module_spec
  	compose_module_name
  );
  my %export_ok = map { ($_ => undef) } @EXPORT_OK;
  sub import {
  	my $me = shift;
  	my $callpkg = caller(0);
  	my $errs = "";
  	foreach(@_) {
  		if(exists $export_ok{$_}) {
  			# We would need to do "no strict 'refs'" here
  			# if we had enabled strict at file scope.
  			if(/\A\$(.*)\z/s) {
  				*{$callpkg."::".$1} = \$$1;
  			} else {
  				*{$callpkg."::".$_} = \&$_;
  			}
  		} else {
  			$errs .= "\"$_\" is not exported by the $me module\n";
  		}
  	}
  	if($errs ne "") {
  		die "${errs}Can't continue after import errors ".
  			"at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n";
  	}
  }
  
  # Logic duplicated from Params::Classify.  Duplicating it here avoids
  # an extensive and potentially circular dependency graph.
  sub _is_string($) {
  	my($arg) = @_;
  	return defined($arg) && ref(\$arg) eq "SCALAR";
  }
  
  =head1 REGULAR EXPRESSIONS
  
  These regular expressions do not include any anchors, so to check
  whether an entire string matches a syntax item you must supply the
  anchors yourself.
  
  =over
  
  =item $module_name_rx
  
  Matches a valid Perl module name in bareword syntax.
  
  =cut
  
  our $module_name_rx = qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;
  
  =item $top_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where no prefix is being used.
  
  =cut
  
  my $qual_module_spec_rx =
  	qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  my $unqual_top_module_spec_rx =
  	qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $top_module_spec_rx = qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;
  
  =item $sub_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where a prefix is being used.
  
  =cut
  
  my $unqual_sub_module_spec_rx = qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $sub_module_spec_rx = qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 Basic module handling
  
  =over
  
  =item is_module_name(ARG)
  
  Returns a truth value indicating whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  
  =cut
  
  sub is_module_name($) { _is_string($_[0]) && $_[0] =~ /\A$module_name_rx\z/o }
  
  =item is_valid_module_name(ARG)
  
  Deprecated alias for L</is_module_name>.
  
  =cut
  
  *is_valid_module_name = \&is_module_name;
  
  =item check_module_name(ARG)
  
  Check whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_name($) {
  	unless(&is_module_name) {
  		die +(_is_string($_[0]) ? "`$_[0]'" : "argument").
  			" is not a module name\n";
  	}
  }
  
  =item module_notional_filename(NAME)
  
  Generates a notional relative filename for a module, which is used in
  some Perl core interfaces.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The notional filename for the named module is generated and returned.
  This filename is always in Unix style, with C</> directory separators
  and a C<.pm> suffix.  This kind of filename can be used as an argument to
  C<require>, and is the key that appears in C<%INC> to identify a module,
  regardless of actual local filename syntax.
  
  =cut
  
  sub module_notional_filename($) {
  	&check_module_name;
  	my($name) = @_;
  	$name =~ s!::!/!g;
  	return $name.".pm";
  }
  
  =item require_module(NAME)
  
  This is essentially the bareword form of C<require>, in runtime form.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The module specified by I<NAME> is loaded, if it hasn't been already,
  in the manner of the bareword form of C<require>.  That means that a
  search through C<@INC> is performed, and a byte-compiled form of the
  module will be used if available.
  
  The return value is as for C<require>.  That is, it is the value returned
  by the module itself if the module is loaded anew, or C<1> if the module
  was already loaded.
  
  =cut
  
  # Don't "use constant" here, to avoid dependencies.
  BEGIN {
  	*_WORK_AROUND_HINT_LEAKAGE =
  		"$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
  			? sub(){1} : sub(){0};
  	*_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
  }
  
  BEGIN { if(_WORK_AROUND_BROKEN_MODULE_STATE) { eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  }; die $@ if $@ ne ""; } }
  
  sub require_module($) {
  	# Localise %^H to work around [perl #68590], where the bug exists
  	# and this is a satisfactory workaround.  The bug consists of
  	# %^H state leaking into each required module, polluting the
  	# module's lexical state.
  	local %^H if _WORK_AROUND_HINT_LEAKAGE;
  	if(_WORK_AROUND_BROKEN_MODULE_STATE) {
  		my $notional_filename = &module_notional_filename;
  		my $guard = bless([ $notional_filename ],
  				"Module::Runtime::__GUARD__");
  		my $result = CORE::require($notional_filename);
  		pop @$guard;
  		return $result;
  	} else {
  		return scalar(CORE::require(&module_notional_filename));
  	}
  }
  
  =back
  
  =head2 Structured module use
  
  =over
  
  =item use_module(NAME[, VERSION])
  
  This is essentially C<use> in runtime form, but without the importing
  feature (which is fundamentally a compile-time thing).  The I<NAME> is
  handled just like in C<require_module> above: it must be a module name,
  and the named module is loaded as if by the bareword form of C<require>.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded module is
  called with the specified I<VERSION> as an argument.  This normally serves to
  ensure that the version loaded is at least the version required.  This is
  the same functionality provided by the I<VERSION> parameter of C<use>.
  
  On success, the name of the module is returned.  This is unlike
  L</require_module>, and is done so that the entire call to L</use_module>
  can be used as a class name to call a constructor, as in the example in
  the synopsis.
  
  =cut
  
  sub use_module($;$) {
  	my($name, $version) = @_;
  	require_module($name);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =item use_package_optimistically(NAME[, VERSION])
  
  This is an analogue of L</use_module> for the situation where there is
  uncertainty as to whether a package/class is defined in its own module
  or by some other means.  It attempts to arrange for the named package to
  be available, either by loading a module or by doing nothing and hoping.
  
  An attempt is made to load the named module (as if by the bareword form
  of C<require>).  If the module cannot be found then it is assumed that
  the package was actually already loaded by other means, and no error
  is signalled.  That's the optimistic bit.
  
  This is mostly the same operation that is performed by the L<base> pragma
  to ensure that the specified base classes are available.  The behaviour
  of L<base> was simplified in version 2.18, and later improved in version
  2.20, and on both occasions this function changed to match.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded package is
  called with the specified I<VERSION> as an argument.  This normally serves
  to ensure that the version loaded is at least the version required.
  On success, the name of the package is returned.  These aspects of the
  function work just like L</use_module>.
  
  =cut
  
  sub use_package_optimistically($;$) {
  	my($name, $version) = @_;
  	my $fn = module_notional_filename($name);
  	eval { local $SIG{__DIE__}; require_module($name); };
  	die $@ if $@ ne "" &&
  		($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s ||
  		 $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =back
  
  =head2 Module name composition
  
  =over
  
  =item is_module_spec(PREFIX, SPEC)
  
  Returns a truth value indicating
  whether I<SPEC> is valid input for L</compose_module_name>.
  See below for what that entails.  Whether a I<PREFIX> is supplied affects
  the validity of I<SPEC>, but the exact value of the prefix is unimportant,
  so this function treats I<PREFIX> as a truth value.
  
  =cut
  
  sub is_module_spec($$) {
  	my($prefix, $spec) = @_;
  	return _is_string($spec) &&
  		$spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o :
  				    qr/\A$top_module_spec_rx\z/o);
  }
  
  =item is_valid_module_spec(PREFIX, SPEC)
  
  Deprecated alias for L</is_module_spec>.
  
  =cut
  
  *is_valid_module_spec = \&is_module_spec;
  
  =item check_module_spec(PREFIX, SPEC)
  
  Check whether I<SPEC> is valid input for L</compose_module_name>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_spec($$) {
  	unless(&is_module_spec) {
  		die +(_is_string($_[1]) ? "`$_[1]'" : "argument").
  			" is not a module specification\n";
  	}
  }
  
  =item compose_module_name(PREFIX, SPEC)
  
  This function is intended to make it more convenient for a user to specify
  a Perl module name at runtime.  Users have greater need for abbreviations
  and context-sensitivity than programmers, and Perl module names get a
  little unwieldy.  I<SPEC> is what the user specifies, and this function
  translates it into a module name in standard form, which it returns.
  
  I<SPEC> has syntax approximately that of a standard module name: it
  should consist of one or more name segments, each of which consists
  of one or more identifier characters.  However, C</> is permitted as a
  separator, in addition to the standard C<::>.  The two separators are
  entirely interchangeable.
  
  Additionally, if I<PREFIX> is not C<undef> then it must be a module
  name in standard form, and it is prefixed to the user-specified name.
  The user can inhibit the prefix addition by starting I<SPEC> with a
  separator (either C</> or C<::>).
  
  =cut
  
  sub compose_module_name($$) {
  	my($prefix, $spec) = @_;
  	check_module_name($prefix) if defined $prefix;
  	&check_module_spec;
  	if($spec =~ s#\A(?:/|::)##) {
  		# OK
  	} else {
  		$spec = $prefix."::".$spec if defined $prefix;
  	}
  	$spec =~ s#/#::#g;
  	return $spec;
  }
  
  =back
  
  =head1 BUGS
  
  On Perl versions 5.7.2 to 5.8.8, if C<require> is overridden by the
  C<CORE::GLOBAL> mechanism, it is likely to break the heuristics used by
  L</use_package_optimistically>, making it signal an error for a missing
  module rather than assume that it was already loaded.  From Perl 5.8.9
  onwards, and on 5.7.1 and earlier, this module can avoid being confused
  by such an override.  On the affected versions, a C<require> override
  might be installed by L<Lexical::SealRequireHints>, if something requires
  its bugfix but for some reason its XS implementation isn't available.
  
  =head1 SEE ALSO
  
  L<Lexical::SealRequireHints>,
  L<base>,
  L<perlfunc/require>,
  L<perlfunc/use>
  
  =head1 AUTHOR
  
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2004, 2006, 2007, 2009, 2010, 2011, 2012, 2014
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
MODULE_RUNTIME

$fatpacked{"Pod/Cpandoc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_CPANDOC';
  package Pod::Cpandoc;
  use 5.8.1;
  use strict;
  use warnings;
  use base 'Pod::Perldoc';
  use HTTP::Tiny;
  use File::Temp 'tempfile';
  use JSON::PP ();
  
  our $VERSION = '0.15';
  
  sub opt_c { shift->_elem('opt_c', @_) }
  
  sub live_cpan_url {
      my $self   = shift;
      my $module = shift;
  
      if ($self->opt_c) {
          my $module_json = $self->fetch_url("http://api.metacpan.org/v0/module/$module?fields=distribution");
          if (!$module_json) {
              die "Unable to fetch changes for $module";
          }
          my $module_details = JSON::PP::decode_json($module_json);
          my $dist = $module_details->{distribution};
          return "http://api.metacpan.org/v0/changes/$dist?fields=content";
      }
      elsif ($self->opt_m) {
          return "http://api.metacpan.org/v0/source/$module";
      }
      else {
          return "http://api.metacpan.org/v0/pod/$module?content-type=text/x-pod";
      }
  }
  
  sub unlink_tempfiles {
      my $self = shift;
      return $self->opt_l ? 0 : 1;
  }
  
  sub fetch_url {
      my $self = shift;
      my $url  = shift;
  
      $self->aside("Going to query $url\n");
  
      if ($ENV{CPANDOC_FETCH}) {
          print STDERR "Fetching $url\n";
      }
  
      my $ua = HTTP::Tiny->new(
          agent => "cpandoc/$VERSION",
      );
  
      my $response = $ua->get($url);
  
      if (!$response->{success}) {
          $self->aside("Got a $response->{status} error from the server\n");
          return;
      }
  
      $self->aside("Successfully received " . length($response->{content}) . " bytes\n");
      return $response->{content};
  }
  
  sub query_live_cpan_for {
      my $self   = shift;
      my $module = shift;
  
      my $url = $self->live_cpan_url($module);
      my $content = $self->fetch_url($url);
  
      if ($self->opt_c) {
          $content = JSON::PP::decode_json($content)->{content};
          $content = "=pod\n\n$content";
      }
  
      return $content;
  }
  
  sub scrape_documentation_for {
      my $self   = shift;
      my $module = shift;
  
      my $content;
      if ($module =~ m{^https?://}) {
          die "Can't use -c on arbitrary URLs, only module names"
              if $self->opt_c;
          $content = $self->fetch_url($module);
      }
      else {
          $content = $self->query_live_cpan_for($module);
      }
      return if !defined($content);
  
      $module =~ s{.*/}{}; # directories and/or URLs with slashes anger File::Temp
      $module =~ s/::/-/g;
      my ($fh, $fn) = tempfile(
          "${module}-XXXX",
          SUFFIX => ($self->opt_c ? ".txt" : ".pm"),
          UNLINK => $self->unlink_tempfiles,
          TMPDIR => 1,
      );
      print { $fh } $content;
      close $fh;
  
      return $fn;
  }
  
  our $QUERY_CPAN;
  sub grand_search_init {
      my $self = shift;
  
      if ($self->opt_c) {
          return $self->scrape_documentation_for($_[0][0]);
      }
  
      local $QUERY_CPAN = 1;
      return $self->SUPER::grand_search_init(@_);
  }
  
  sub searchfor {
      my $self = shift;
      my ($recurse,$s,@dirs) = @_;
  
      my @found = $self->SUPER::searchfor(@_);
  
      if (@found == 0 && $QUERY_CPAN) {
          $QUERY_CPAN = 0;
          return $self->scrape_documentation_for($s);
      }
  
      return @found;
  }
  
  sub opt_V {
      my $self = shift;
  
      print "Cpandoc v$VERSION, ";
  
      return $self->SUPER::opt_V(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Pod::Cpandoc - perldoc that works for modules you don't have installed
  
  =head1 SYNOPSIS
  
      cpandoc File::Find
          -- shows the documentation of your installed File::Find
  
      cpandoc Acme::BadExample
          -- works even if you don't have Acme::BadExample installed!
  
      cpandoc -c Text::Xslate
          -- shows the changelog file for Text::Xslate
  
      cpandoc -v '$?'
          -- passes everything through to regular perldoc
  
      cpandoc -m Acme::BadExample | grep system
          -- options are respected even if the module was scraped
  
      vim `cpandoc -l Web::Scraper`
          -- getting the idea yet?
  
      cpandoc http://darkpan.org/Eval::WithLexicals::AndGlobals
          -- URLs work too!
  
  =head1 DESCRIPTION
  
  C<cpandoc> is a perl script that acts like C<perldoc> except that
  if it would have bailed out with
  C<No documentation found for "Uninstalled::Module">, it will instead
  scrape a CPAN index for the module's documentation.
  
  One important feature of C<cpandoc> is that it I<only> scrapes the
  live index if you do not have the module installed. So if you use
  C<cpandoc> on a module you already have installed, then it will
  just read the already-installed documentation. This means that the
  version of the documentation matches up with the version of the
  code you have. As a fringe benefit, C<cpandoc> will be fast for
  modules you've installed. :)
  
  All this means that you should be able to drop in C<cpandoc> in
  place of C<perldoc> and have everything keep working. See
  L</SNEAKY INSTALL> for how to do this.
  
  If you set the environment variable C<CPANDOC_FETCH> to a true value,
  then we will print a message to STDERR telling you that C<cpandoc> is
  going to make a request against the live CPAN index.
  
  =head1 TRANSLATIONS
  
  =over 4
  
  =item Japanese
  
      Japanese documentation can be found at
      L<http://perldoc.jp/docs/modules/Pod-Cpandoc-0.09/Cpandoc.pod>,
      contributed by @bayashi.
  
  =back
  
  =head1 SNEAKY INSTALL
  
      cpanm Pod::Cpandoc
  
      then: alias perldoc=cpandoc
      or:   function perldoc () { cpandoc "$@" }
  
      Now `perldoc Acme::BadExample` works!
  
  C<perldoc> should continue to work for everything that you're used
  to, since C<cpandoc> passes all options through to it. C<cpandoc>
  is merely a subclass that falls back to scraping a CPAN index when
  it fails to find your queried file in C<@INC>.
  
  =head1 SEE ALSO
  
  The sneaky install was inspired by L<https://github.com/defunkt/hub>.
  
  L<http://tech.bayashi.jp/archives/entry/perl-module/2011/003305.html>
  
  L<http://perladvent.org/2011/2011-12-15.html>
  
  L<http://sartak.org/talks/yapc-na-2011/cpandoc/>
  
  =head1 AUTHOR
  
  Shawn M Moore C<code@sartak.org>
  
  =head1 COPYRIGHT
  
  Copyright 2011-2013 Shawn M Moore.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
POD_CPANDOC

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/usr/bin/env perl
use strict;
use warnings;
use App::perlfind;
exit( App::perlfind->run );

__END__

=head1 NAME

perlfind

=head1 DESCRIPTION

See L<App::perlfind>, L<Pod::Cpandoc> and L<Pod::Perldoc>.

=cut

