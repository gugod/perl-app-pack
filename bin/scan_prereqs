#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Class/Load.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_LOAD';
  use strict;
  use warnings;
  package Class::Load; # git description: v0.24-5-g22a44fd
  # ABSTRACT: A working (require "Class::Name") and more
  # KEYWORDS: class module load require use runtime
  
  our $VERSION = '0.25';
  
  use base 'Exporter';
  use Data::OptList 0.110 ();
  use Module::Implementation 0.04;
  use Module::Runtime 0.012 ();
  use Try::Tiny;
  
  {
      my $loader = Module::Implementation::build_loader_sub(
          implementations => [ 'XS', 'PP' ],
          symbols         => ['is_class_loaded'],
      );
  
      $loader->();
  }
  
  our @EXPORT_OK = qw/load_class load_optional_class try_load_class is_class_loaded load_first_existing_class/;
  our %EXPORT_TAGS = (
      all => \@EXPORT_OK,
  );
  
  our $ERROR;
  
  sub load_class {
      my $class   = shift;
      my $options = shift;
  
      my ($res, $e) = try_load_class($class, $options);
      return $class if $res;
  
      _croak($e);
  }
  
  sub load_first_existing_class {
      my $classes = Data::OptList::mkopt(\@_)
          or return;
  
      foreach my $class (@{$classes}) {
          Module::Runtime::check_module_name($class->[0]);
      }
  
      for my $class (@{$classes}) {
          my ($name, $options) = @{$class};
  
          # We need to be careful not to pass an undef $options to this sub,
          # since the XS version will blow up if that happens.
          return $name if is_class_loaded($name, ($options ? $options : ()));
  
          my ($res, $e) = try_load_class($name, $options);
  
          return $name if $res;
  
          my $file = Module::Runtime::module_notional_filename($name);
  
          next if $e =~ /^Can't locate \Q$file\E in \@INC/;
          next
              if $options
                  && defined $options->{-version}
                  && $e =~ _version_fail_re($name, $options->{-version});
  
          _croak("Couldn't load class ($name) because: $e");
      }
  
      my @list = map {
          $_->[0]
              . ( $_->[1] && defined $_->[1]{-version}
              ? " (version >= $_->[1]{-version})"
              : q{} )
      } @{$classes};
  
      my $err
          .= q{Can't locate }
          . _or_list(@list)
          . " in \@INC (\@INC contains: @INC).";
      _croak($err);
  }
  
  sub _version_fail_re {
      my $name = shift;
      my $vers = shift;
  
      return qr/\Q$name\E version \Q$vers\E required--this is only version/;
  }
  
  sub _nonexistent_fail_re {
      my $name = shift;
  
      my $file = Module::Runtime::module_notional_filename($name);
      return qr/Can't locate \Q$file\E in \@INC/;
  }
  
  sub _or_list {
      return $_[0] if @_ == 1;
  
      return join ' or ', @_ if @_ ==2;
  
      my $last = pop;
  
      my $list = join ', ', @_;
      $list .= ', or ' . $last;
  
      return $list;
  }
  
  sub load_optional_class {
      my $class   = shift;
      my $options = shift;
  
      Module::Runtime::check_module_name($class);
  
      my ($res, $e) = try_load_class($class, $options);
      return 1 if $res;
  
      return 0
          if $options
              && defined $options->{-version}
              && $e =~ _version_fail_re($class, $options->{-version});
  
      return 0
          if $e =~ _nonexistent_fail_re($class);
  
      _croak($e);
  }
  
  sub try_load_class {
      my $class   = shift;
      my $options = shift;
  
      Module::Runtime::check_module_name($class);
  
      local $@;
      undef $ERROR;
  
      if (is_class_loaded($class)) {
          # We need to check this here rather than in is_class_loaded() because
          # we want to return the error message for a failed version check, but
          # is_class_loaded just returns true/false.
          return 1 unless $options && defined $options->{-version};
          return try {
              $class->VERSION($options->{-version});
              1;
          }
          catch {
              _error($_);
          };
      }
  
      my $file = Module::Runtime::module_notional_filename($class);
      # This says "our diagnostics of the package
      # say perl's INC status about the file being loaded are
      # wrong", so we delete it from %INC, so when we call require(),
      # perl will *actually* try reloading the file.
      #
      # If the file is already in %INC, it won't retry,
      # And on 5.8, it won't fail either!
      #
      # The extra benefit of this trick, is it helps even on
      # 5.10, as instead of dying with "Compilation failed",
      # it will die with the actual error, and that's a win-win.
      delete $INC{$file};
      return try {
          local $SIG{__DIE__} = 'DEFAULT';
          if ($options && defined $options->{-version}) {
              Module::Runtime::use_module($class, $options->{-version});
          }
          else {
              Module::Runtime::require_module($class);
          }
          1;
      }
      catch {
          _error($_);
      };
  }
  
  sub _error {
      my $e = shift;
  
      $e =~ s/ at .+?Runtime\.pm line [0-9]+\.$//;
      chomp $e;
  
      $ERROR = $e;
      return 0 unless wantarray;
      return 0, $ERROR;
  }
  
  sub _croak {
      require Carp;
      local $Carp::CarpLevel = $Carp::CarpLevel + 2;
      Carp::croak(shift);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::Load - A working (require "Class::Name") and more
  
  =head1 VERSION
  
  version 0.25
  
  =head1 SYNOPSIS
  
      use Class::Load ':all';
  
      try_load_class('Class::Name')
          or plan skip_all => "Class::Name required to run these tests";
  
      load_class('Class::Name');
  
      is_class_loaded('Class::Name');
  
      my $baseclass = load_optional_class('Class::Name::MightExist')
          ? 'Class::Name::MightExist'
          : 'Class::Name::Default';
  
  =head1 DESCRIPTION
  
  C<require EXPR> only accepts C<Class/Name.pm> style module names, not
  C<Class::Name>. How frustrating! For that, we provide
  C<load_class 'Class::Name'>.
  
  It's often useful to test whether a module can be loaded, instead of throwing
  an error when it's not available. For that, we provide
  C<try_load_class 'Class::Name'>.
  
  Finally, sometimes we need to know whether a particular class has been loaded.
  Asking C<%INC> is an option, but that will miss inner packages and any class
  for which the filename does not correspond to the package name. For that, we
  provide C<is_class_loaded 'Class::Name'>.
  
  =head1 FUNCTIONS
  
  =head2 load_class Class::Name, \%options
  
  C<load_class> will load C<Class::Name> or throw an error, much like C<require>.
  
  If C<Class::Name> is already loaded (checked with C<is_class_loaded>) then it
  will not try to load the class. This is useful when you have inner packages
  which C<require> does not check.
  
  The C<%options> hash currently accepts one key, C<-version>. If you specify a
  version, then this subroutine will call C<< Class::Name->VERSION(
  $options{-version} ) >> internally, which will throw an error if the class's
  version is not equal to or greater than the version you requested.
  
  This method will return the name of the class on success.
  
  =head2 try_load_class Class::Name, \%options -> (0|1, error message)
  
  Returns 1 if the class was loaded, 0 if it was not. If the class was not
  loaded, the error will be returned as a second return value in list context.
  
  Again, if C<Class::Name> is already loaded (checked with C<is_class_loaded>)
  then it will not try to load the class. This is useful when you have inner
  packages which C<require> does not check.
  
  Like C<load_class>, you can pass a C<-version> in C<%options>. If the version
  is not sufficient, then this subroutine will return false.
  
  =head2 is_class_loaded Class::Name, \%options -> 0|1
  
  This uses a number of heuristics to determine if the class C<Class::Name> is
  loaded. There heuristics were taken from L<Class::MOP>'s old pure-perl
  implementation.
  
  Like C<load_class>, you can pass a C<-version> in C<%options>. If the version
  is not sufficient, then this subroutine will return false.
  
  =head2 load_first_existing_class Class::Name, \%options, ...
  
  This attempts to load the first loadable class in the list of classes
  given. Each class name can be followed by an options hash reference.
  
  If any one of the classes loads and passes the optional version check, that
  class name will be returned. If I<none> of the classes can be loaded (or none
  pass their version check), then an error will be thrown.
  
  If, when attempting to load a class, it fails to load because of a syntax
  error, then an error will be thrown immediately.
  
  =head2 load_optional_class Class::Name, \%options -> 0|1
  
  C<load_optional_class> is a lot like C<try_load_class>, but also a lot like
  C<load_class>.
  
  If the class exists, and it works, then it will return 1. If you specify a
  version in C<%options>, then the version check must succeed or it will return
  0.
  
  If the class doesn't exist, and it appears to not exist on disk either, it
  will return 0.
  
  If the class exists on disk, but loading from disk results in an error
  (e.g.: a syntax error), then it will C<croak> with that error.
  
  This is useful for using if you want a fallback module system, i.e.:
  
      my $class = load_optional_class($foo) ? $foo : $default;
  
  That way, if $foo does exist, but can't be loaded due to error, you won't
  get the behaviour of it simply not existing.
  
  =head1 CAVEATS
  
  Because of some of the heuristics that this module uses to infer whether a
  module has been loaded, some false positives may occur in C<is_class_loaded>
  checks (which are also performed internally in other interfaces) -- if a class
  has started to be loaded but then dies, it may appear that it has already been
  loaded, which can cause other things to make the wrong decision.
  L<Module::Runtime> doesn't have this issue, but it also doesn't do some things
  that this module does -- for example gracefully handle packages that have been
  defined inline in the same file as another package.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<http://blog.fox.geek.nz/2010/11/searching-design-spec-for-ultimate.html>
  
  This blog post is a good overview of the current state of the existing modules
  for loading other modules in various ways.
  
  =item L<http://blog.fox.geek.nz/2010/11/handling-optional-requirements-with.html>
  
  This blog post describes how to handle optional modules with L<Class::Load>.
  
  =item L<http://d.hatena.ne.jp/tokuhirom/20110202/1296598578>
  
  This Japanese blog post describes why L<DBIx::Skinny> now uses L<Class::Load>
  over its competitors.
  
  =item L<Moose>, L<Jifty>, L<Prophet>, etc
  
  This module was designed to be used anywhere you have
  C<if (eval "require $module"; 1)>, which occurs in many large projects.
  
  =item L<Module::Runtime>
  
  A leaner approach to loading modules
  
  =back
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Class-Load>
  (or L<bug-Class-Load@rt.cpan.org|mailto:bug-Class-Load@rt.cpan.org>).
  
  There is also a mailing list available for users of this distribution, at
  L<http://lists.perl.org/list/moose.html>.
  
  There is also an irc channel available for users of this distribution, at
  L<C<#moose> on C<irc.perl.org>|irc://irc.perl.org/#moose>.
  
  =head1 AUTHOR
  
  Shawn M Moore <sartak at bestpractical.com>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Dave Rolsky Karen Etheridge Shawn Moore Jesse Luehrs Kent Fredric Paul Howarth Olivier Mengué Caleb Cushing
  
  =over 4
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Shawn Moore <sartak@bestpractical.com>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Kent Fredric <kentfredric@gmail.com>
  
  =item *
  
  Paul Howarth <paul@city-fan.org>
  
  =item *
  
  Olivier Mengué <dolmen@cpan.org>
  
  =item *
  
  Caleb Cushing <xenoterracide@gmail.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2008 by Shawn M Moore.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
CLASS_LOAD

$fatpacked{"Class/Load/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_LOAD_PP';
  use strict;
  use warnings;
  package Class::Load::PP;
  
  our $VERSION = '0.25';
  
  use Module::Runtime ();
  use Package::Stash 0.14;
  use Scalar::Util ();
  use Try::Tiny;
  
  sub is_class_loaded {
      my $class   = shift;
      my $options = shift;
  
      my $loaded = _is_class_loaded($class);
  
      return $loaded if ! $loaded;
      return $loaded unless $options && $options->{-version};
  
      return try {
          $class->VERSION($options->{-version});
          1;
      }
      catch {
          0;
      };
  }
  
  sub _is_class_loaded {
      my $class = shift;
  
      return 0 unless Module::Runtime::is_module_name($class);
  
      my $stash = Package::Stash->new($class);
  
      if ($stash->has_symbol('$VERSION')) {
          my $version = ${ $stash->get_symbol('$VERSION') };
          if (defined $version) {
              return 1 if ! ref $version;
              # Sometimes $VERSION ends up as a reference to undef (weird)
              return 1 if ref $version && Scalar::Util::reftype $version eq 'SCALAR' && defined ${$version};
              # a version object
              return 1 if Scalar::Util::blessed $version;
          }
      }
  
      if ($stash->has_symbol('@ISA')) {
          return 1 if @{ $stash->get_symbol('@ISA') };
      }
  
      # check for any method
      return 1 if $stash->list_all_symbols('CODE');
  
      # fail
      return 0;
  }
  
  1;
CLASS_LOAD_PP

$fatpacked{"Data/OptList.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_OPTLIST';
  use strict;
  use warnings;
  package Data::OptList;
  # ABSTRACT: parse and validate simple name/value option pairs
  $Data::OptList::VERSION = '0.110';
  use List::Util ();
  use Params::Util ();
  use Sub::Install 0.921 ();
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   use Data::OptList;
  #pod
  #pod   my $options = Data::OptList::mkopt([
  #pod     qw(key1 key2 key3 key4),
  #pod     key5 => { ... },
  #pod     key6 => [ ... ],
  #pod     key7 => sub { ... },
  #pod     key8 => { ... },
  #pod     key8 => [ ... ],
  #pod   ]);
  #pod
  #pod ...is the same thing, more or less, as:
  #pod
  #pod   my $options = [
  #pod     [ key1 => undef,        ],
  #pod     [ key2 => undef,        ],
  #pod     [ key3 => undef,        ],
  #pod     [ key4 => undef,        ],
  #pod     [ key5 => { ... },      ],
  #pod     [ key6 => [ ... ],      ],
  #pod     [ key7 => sub { ... },  ],
  #pod     [ key8 => { ... },      ],
  #pod     [ key8 => [ ... ],      ],
  #pod   ]);
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod Hashes are great for storing named data, but if you want more than one entry
  #pod for a name, you have to use a list of pairs.  Even then, this is really boring
  #pod to write:
  #pod
  #pod   $values = [
  #pod     foo => undef,
  #pod     bar => undef,
  #pod     baz => undef,
  #pod     xyz => { ... },
  #pod   ];
  #pod
  #pod Just look at all those undefs!  Don't worry, we can get rid of those:
  #pod
  #pod   $values = [
  #pod     map { $_ => undef } qw(foo bar baz),
  #pod     xyz => { ... },
  #pod   ];
  #pod
  #pod Aaaauuugh!  We've saved a little typing, but now it requires thought to read,
  #pod and thinking is even worse than typing... and it's got a bug!  It looked right,
  #pod didn't it?  Well, the C<< xyz => { ... } >> gets consumed by the map, and we
  #pod don't get the data we wanted.
  #pod
  #pod With Data::OptList, you can do this instead:
  #pod
  #pod   $values = Data::OptList::mkopt([
  #pod     qw(foo bar baz),
  #pod     xyz => { ... },
  #pod   ]);
  #pod
  #pod This works by assuming that any defined scalar is a name and any reference
  #pod following a name is its value.
  #pod
  #pod =func mkopt
  #pod
  #pod   my $opt_list = Data::OptList::mkopt($input, \%arg);
  #pod
  #pod Valid arguments are:
  #pod
  #pod   moniker        - a word used in errors to describe the opt list; encouraged
  #pod   require_unique - if true, no name may appear more than once
  #pod   must_be        - types to which opt list values are limited (described below)
  #pod   name_test      - a coderef used to test whether a value can be a name
  #pod                    (described below, but you probably don't want this)
  #pod
  #pod This produces an array of arrays; the inner arrays are name/value pairs.
  #pod Values will be either "undef" or a reference.
  #pod
  #pod Positional parameters may be used for compatibility with the old C<mkopt>
  #pod interface:
  #pod
  #pod   my $opt_list = Data::OptList::mkopt($input, $moniker, $req_uni, $must_be);
  #pod
  #pod Valid values for C<$input>:
  #pod
  #pod  undef    -> []
  #pod  hashref  -> [ [ key1 => value1 ] ... ] # non-ref values become undef
  #pod  arrayref -> every name followed by a non-name becomes a pair: [ name => ref ]
  #pod              every name followed by undef becomes a pair: [ name => undef ]
  #pod              otherwise, it becomes [ name => undef ] like so:
  #pod              [ "a", "b", [ 1, 2 ] ] -> [ [ a => undef ], [ b => [ 1, 2 ] ] ]
  #pod
  #pod By default, a I<name> is any defined non-reference.  The C<name_test> parameter
  #pod can be a code ref that tests whether the argument passed it is a name or not.
  #pod This should be used rarely.  Interactions between C<require_unique> and
  #pod C<name_test> are not yet particularly elegant, as C<require_unique> just tests
  #pod string equality.  B<This may change.>
  #pod
  #pod The C<must_be> parameter is either a scalar or array of scalars; it defines
  #pod what kind(s) of refs may be values.  If an invalid value is found, an exception
  #pod is thrown.  If no value is passed for this argument, any reference is valid.
  #pod If C<must_be> specifies that values must be CODE, HASH, ARRAY, or SCALAR, then
  #pod Params::Util is used to check whether the given value can provide that
  #pod interface.  Otherwise, it checks that the given value is an object of the kind.
  #pod
  #pod In other words:
  #pod
  #pod   [ qw(SCALAR HASH Object::Known) ]
  #pod
  #pod Means:
  #pod
  #pod   _SCALAR0($value) or _HASH($value) or _INSTANCE($value, 'Object::Known')
  #pod
  #pod =cut
  
  my %test_for;
  BEGIN {
    %test_for = (
      CODE   => \&Params::Util::_CODELIKE,  ## no critic
      HASH   => \&Params::Util::_HASHLIKE,  ## no critic
      ARRAY  => \&Params::Util::_ARRAYLIKE, ## no critic
      SCALAR => \&Params::Util::_SCALAR0,   ## no critic
    );
  }
  
  sub mkopt {
    my ($opt_list) = shift;
  
    my ($moniker, $require_unique, $must_be); # the old positional args
    my ($name_test, $is_a);
  
    if (@_) {
      if (@_ == 1 and Params::Util::_HASHLIKE($_[0])) {
        ($moniker, $require_unique, $must_be, $name_test)
          = @{$_[0]}{ qw(moniker require_unique must_be name_test) };
      } else {
        ($moniker, $require_unique, $must_be) = @_;
      }
  
      # Transform the $must_be specification into a closure $is_a
      # that will check if a value matches the spec
  
      if (defined $must_be) {
        $must_be = [ $must_be ] unless ref $must_be;
        my @checks = map {
            my $class = $_;
            $test_for{$_}
            || sub { $_[1] = $class; goto \&Params::Util::_INSTANCE }
        } @$must_be;
  
        $is_a = (@checks == 1)
              ? $checks[0]
              : sub {
                  my $value = $_[0];
                  List::Util::first { defined($_->($value)) } @checks
                };
  
        $moniker = 'unnamed' unless defined $moniker;
      }
    }
  
    return [] unless $opt_list;
  
    $name_test ||= sub { ! ref $_[0] };
  
    $opt_list = [
      map { $_ => (ref $opt_list->{$_} ? $opt_list->{$_} : ()) } keys %$opt_list
    ] if ref $opt_list eq 'HASH';
  
    my @return;
    my %seen;
  
    for (my $i = 0; $i < @$opt_list; $i++) { ## no critic
      my $name = $opt_list->[$i];
  
      if ($require_unique) {
        Carp::croak "multiple definitions provided for $name" if $seen{$name}++;
      }
  
      my $value;
  
      if ($i < $#$opt_list) {
        if (not defined $opt_list->[$i+1]) {
          $i++
        } elsif (! $name_test->($opt_list->[$i+1])) {
          $value = $opt_list->[++$i];
          if ($is_a && !$is_a->($value)) {
            my $ref = ref $value;
            Carp::croak "$ref-ref values are not valid in $moniker opt list";
          }
        }
      }
  
      push @return, [ $name => $value ];
    }
  
    return \@return;
  }
  
  #pod =func mkopt_hash
  #pod
  #pod   my $opt_hash = Data::OptList::mkopt_hash($input, $moniker, $must_be);
  #pod
  #pod Given valid C<L</mkopt>> input, this routine returns a reference to a hash.  It
  #pod will throw an exception if any name has more than one value.
  #pod
  #pod =cut
  
  sub mkopt_hash {
    my ($opt_list, $moniker, $must_be) = @_;
    return {} unless $opt_list;
  
    $opt_list = mkopt($opt_list, $moniker, 1, $must_be);
    my %hash = map { $_->[0] => $_->[1] } @$opt_list;
    return \%hash;
  }
  
  #pod =head1 EXPORTS
  #pod
  #pod Both C<mkopt> and C<mkopt_hash> may be exported on request.
  #pod
  #pod =cut
  
  BEGIN {
    *import = Sub::Install::exporter {
      exports => [qw(mkopt mkopt_hash)],
    };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Data::OptList - parse and validate simple name/value option pairs
  
  =head1 VERSION
  
  version 0.110
  
  =head1 SYNOPSIS
  
    use Data::OptList;
  
    my $options = Data::OptList::mkopt([
      qw(key1 key2 key3 key4),
      key5 => { ... },
      key6 => [ ... ],
      key7 => sub { ... },
      key8 => { ... },
      key8 => [ ... ],
    ]);
  
  ...is the same thing, more or less, as:
  
    my $options = [
      [ key1 => undef,        ],
      [ key2 => undef,        ],
      [ key3 => undef,        ],
      [ key4 => undef,        ],
      [ key5 => { ... },      ],
      [ key6 => [ ... ],      ],
      [ key7 => sub { ... },  ],
      [ key8 => { ... },      ],
      [ key8 => [ ... ],      ],
    ]);
  
  =head1 DESCRIPTION
  
  Hashes are great for storing named data, but if you want more than one entry
  for a name, you have to use a list of pairs.  Even then, this is really boring
  to write:
  
    $values = [
      foo => undef,
      bar => undef,
      baz => undef,
      xyz => { ... },
    ];
  
  Just look at all those undefs!  Don't worry, we can get rid of those:
  
    $values = [
      map { $_ => undef } qw(foo bar baz),
      xyz => { ... },
    ];
  
  Aaaauuugh!  We've saved a little typing, but now it requires thought to read,
  and thinking is even worse than typing... and it's got a bug!  It looked right,
  didn't it?  Well, the C<< xyz => { ... } >> gets consumed by the map, and we
  don't get the data we wanted.
  
  With Data::OptList, you can do this instead:
  
    $values = Data::OptList::mkopt([
      qw(foo bar baz),
      xyz => { ... },
    ]);
  
  This works by assuming that any defined scalar is a name and any reference
  following a name is its value.
  
  =head1 FUNCTIONS
  
  =head2 mkopt
  
    my $opt_list = Data::OptList::mkopt($input, \%arg);
  
  Valid arguments are:
  
    moniker        - a word used in errors to describe the opt list; encouraged
    require_unique - if true, no name may appear more than once
    must_be        - types to which opt list values are limited (described below)
    name_test      - a coderef used to test whether a value can be a name
                     (described below, but you probably don't want this)
  
  This produces an array of arrays; the inner arrays are name/value pairs.
  Values will be either "undef" or a reference.
  
  Positional parameters may be used for compatibility with the old C<mkopt>
  interface:
  
    my $opt_list = Data::OptList::mkopt($input, $moniker, $req_uni, $must_be);
  
  Valid values for C<$input>:
  
   undef    -> []
   hashref  -> [ [ key1 => value1 ] ... ] # non-ref values become undef
   arrayref -> every name followed by a non-name becomes a pair: [ name => ref ]
               every name followed by undef becomes a pair: [ name => undef ]
               otherwise, it becomes [ name => undef ] like so:
               [ "a", "b", [ 1, 2 ] ] -> [ [ a => undef ], [ b => [ 1, 2 ] ] ]
  
  By default, a I<name> is any defined non-reference.  The C<name_test> parameter
  can be a code ref that tests whether the argument passed it is a name or not.
  This should be used rarely.  Interactions between C<require_unique> and
  C<name_test> are not yet particularly elegant, as C<require_unique> just tests
  string equality.  B<This may change.>
  
  The C<must_be> parameter is either a scalar or array of scalars; it defines
  what kind(s) of refs may be values.  If an invalid value is found, an exception
  is thrown.  If no value is passed for this argument, any reference is valid.
  If C<must_be> specifies that values must be CODE, HASH, ARRAY, or SCALAR, then
  Params::Util is used to check whether the given value can provide that
  interface.  Otherwise, it checks that the given value is an object of the kind.
  
  In other words:
  
    [ qw(SCALAR HASH Object::Known) ]
  
  Means:
  
    _SCALAR0($value) or _HASH($value) or _INSTANCE($value, 'Object::Known')
  
  =head2 mkopt_hash
  
    my $opt_hash = Data::OptList::mkopt_hash($input, $moniker, $must_be);
  
  Given valid C<L</mkopt>> input, this routine returns a reference to a hash.  It
  will throw an exception if any name has more than one value.
  
  =head1 EXPORTS
  
  Both C<mkopt> and C<mkopt_hash> may be exported on request.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Olivier Mengué Ricardo SIGNES
  
  =over 4
  
  =item *
  
  Olivier Mengué <dolmen@cpan.org>
  
  =item *
  
  Ricardo SIGNES <rjbs@codesimply.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DATA_OPTLIST

$fatpacked{"Module/Implementation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_IMPLEMENTATION';
  package Module::Implementation;
  # git description: v0.08-2-gd599347
  $Module::Implementation::VERSION = '0.09';
  
  use strict;
  use warnings;
  
  use Module::Runtime 0.012 qw( require_module );
  use Try::Tiny;
  
  # This is needed for the benefit of Test::CleanNamespaces, which in turn loads
  # Package::Stash, which in turn loads this module and expects a minimum
  # version.
  unless ( exists $Module::Implementation::{VERSION}
      && ${ $Module::Implementation::{VERSION} } ) {
  
      $Module::Implementation::{VERSION} = \42;
  }
  
  my %Implementation;
  
  sub build_loader_sub {
      my $caller = caller();
  
      return _build_loader( $caller, @_ );
  }
  
  sub _build_loader {
      my $package = shift;
      my %args    = @_;
  
      my @implementations = @{ $args{implementations} };
      my @symbols = @{ $args{symbols} || [] };
  
      my $implementation;
      my $env_var = uc $package;
      $env_var =~ s/::/_/g;
      $env_var .= '_IMPLEMENTATION';
  
      return sub {
          my ( $implementation, $loaded ) = _load_implementation(
              $package,
              $ENV{$env_var},
              \@implementations,
          );
  
          $Implementation{$package} = $implementation;
  
          _copy_symbols( $loaded, $package, \@symbols );
  
          return $loaded;
      };
  }
  
  sub implementation_for {
      my $package = shift;
  
      return $Implementation{$package};
  }
  
  sub _load_implementation {
      my $package         = shift;
      my $env_value       = shift;
      my $implementations = shift;
  
      if ($env_value) {
          die "$env_value is not a valid implementation for $package"
              unless grep { $_ eq $env_value } @{$implementations};
  
          my $requested = "${package}::$env_value";
  
          # Values from the %ENV hash are tainted. We know it's safe to untaint
          # this value because the value was one of our known implementations.
          ($requested) = $requested =~ /^(.+)$/;
  
          try {
              require_module($requested);
          }
          catch {
              require Carp;
              Carp::croak("Could not load $requested: $_");
          };
  
          return ( $env_value, $requested );
      }
      else {
          my $err;
          for my $possible ( @{$implementations} ) {
              my $try = "${package}::$possible";
  
              my $ok;
              try {
                  require_module($try);
                  $ok = 1;
              }
              catch {
                  $err .= $_ if defined $_;
              };
  
              return ( $possible, $try ) if $ok;
          }
  
          require Carp;
          if ( defined $err && length $err ) {
              Carp::croak(
                  "Could not find a suitable $package implementation: $err");
          }
          else {
              Carp::croak(
                  'Module::Runtime failed to load a module but did not throw a real error. This should never happen. Something is very broken'
              );
          }
      }
  }
  
  sub _copy_symbols {
      my $from_package = shift;
      my $to_package   = shift;
      my $symbols      = shift;
  
      for my $sym ( @{$symbols} ) {
          my $type = $sym =~ s/^([\$\@\%\&\*])// ? $1 : '&';
  
          my $from = "${from_package}::$sym";
          my $to   = "${to_package}::$sym";
  
          {
              no strict 'refs';
              no warnings 'once';
  
              # Copied from Exporter
              *{$to}
                  = $type eq '&' ? \&{$from}
                  : $type eq '$' ? \${$from}
                  : $type eq '@' ? \@{$from}
                  : $type eq '%' ? \%{$from}
                  : $type eq '*' ? *{$from}
                  : die
                  "Can't copy symbol from $from_package to $to_package: $type$sym";
          }
      }
  }
  
  1;
  
  # ABSTRACT: Loads one of several alternate underlying implementations for a module
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Module::Implementation - Loads one of several alternate underlying implementations for a module
  
  =head1 VERSION
  
  version 0.09
  
  =head1 SYNOPSIS
  
    package Foo::Bar;
  
    use Module::Implementation;
  
    BEGIN {
        my $loader = Module::Implementation::build_loader_sub(
            implementations => [ 'XS',  'PurePerl' ],
            symbols         => [ 'run', 'check' ],
        );
  
        $loader->();
    }
  
    package Consumer;
  
    # loads the first viable implementation
    use Foo::Bar;
  
  =head1 DESCRIPTION
  
  This module abstracts out the process of choosing one of several underlying
  implementations for a module. This can be used to provide XS and pure Perl
  implementations of a module, or it could be used to load an implementation for
  a given OS or any other case of needing to provide multiple implementations.
  
  This module is only useful when you know all the implementations ahead of
  time. If you want to load arbitrary implementations then you probably want
  something like a plugin system, not this module.
  
  =head1 API
  
  This module provides two subroutines, neither of which are exported.
  
  =head2 Module::Implementation::build_loader_sub(...)
  
  This subroutine takes the following arguments.
  
  =over 4
  
  =item * implementations
  
  This should be an array reference of implementation names. Each name should
  correspond to a module in the caller's namespace.
  
  In other words, using the example in the L</SYNOPSIS>, this module will look
  for the C<Foo::Bar::XS> and C<Foo::Bar::PurePerl> modules.
  
  This argument is required.
  
  =item * symbols
  
  A list of symbols to copy from the implementation package to the calling
  package.
  
  These can be prefixed with a variable type: C<$>, C<@>, C<%>, C<&>, or
  C<*)>. If no prefix is given, the symbol is assumed to be a subroutine.
  
  This argument is optional.
  
  =back
  
  This subroutine I<returns> the implementation loader as a sub reference.
  
  It is up to you to call this loader sub in your code.
  
  I recommend that you I<do not> call this loader in an C<import()> sub. If a
  caller explicitly requests no imports, your C<import()> sub will not be run at
  all, which can cause weird breakage.
  
  =head2 Module::Implementation::implementation_for($package)
  
  Given a package name, this subroutine returns the implementation that was
  loaded for the package. This is not a full package name, just the suffix that
  identifies the implementation. For the L</SYNOPSIS> example, this subroutine
  would be called as C<Module::Implementation::implementation_for('Foo::Bar')>,
  and it would return "XS" or "PurePerl".
  
  =head1 HOW THE IMPLEMENTATION LOADER WORKS
  
  The implementation loader works like this ...
  
  First, it checks for an C<%ENV> var specifying the implementation to load. The
  env var is based on the package name which loads the implementations. The
  C<::> package separator is replaced with C<_>, and made entirely
  upper-case. Finally, we append "_IMPLEMENTATION" to this name.
  
  So in our L</SYNOPSIS> example, the corresponding C<%ENV> key would be
  C<FOO_BAR_IMPLEMENTATION>.
  
  If this is set, then the loader will B<only> try to load this one
  implementation.
  
  If the env var requests an implementation which doesn't match one of the
  implementations specified when the loader was created, an error is thrown.
  
  If this one implementation fails to load then loader throws an error. This is
  useful for testing. You can request a specific implementation in a test file
  by writing something like this:
  
    BEGIN { $ENV{FOO_BAR_IMPLEMENTATION} = 'XS' }
    use Foo::Bar;
  
  If the environment variable is I<not> set, then the loader simply tries the
  implementations originally passed to C<Module::Implementation>. The
  implementations are tried in the order in which they were originally passed.
  
  The loader will use the first implementation that loads without an error. It
  will copy any requested symbols from this implementation.
  
  If none of the implementations can be loaded, then the loader throws an
  exception.
  
  The loader returns the name of the package it loaded.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
MODULE_IMPLEMENTATION

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  =head1 NAME
  
  Module::Runtime - runtime module handling
  
  =head1 SYNOPSIS
  
      use Module::Runtime qw(
  	$module_name_rx is_module_name check_module_name
  	module_notional_filename require_module);
  
      if($module_name =~ /\A$module_name_rx\z/o) { ...
      if(is_module_name($module_name)) { ...
      check_module_name($module_name);
  
      $notional_filename = module_notional_filename($module_name);
      require_module($module_name);
  
      use Module::Runtime qw(use_module use_package_optimistically);
  
      $bi = use_module("Math::BigInt", 1.31)->new("1_234");
      $widget = use_package_optimistically("Local::Widget")->new;
  
      use Module::Runtime qw(
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec check_module_spec
  	compose_module_name);
  
      if($spec =~ /\A$top_module_spec_rx\z/o) { ...
      if($spec =~ /\A$sub_module_spec_rx\z/o) { ...
      if(is_module_spec("Standard::Prefix", $spec)) { ...
      check_module_spec("Standard::Prefix", $spec);
  
      $module_name = compose_module_name("Standard::Prefix", $spec);
  
  =head1 DESCRIPTION
  
  The functions exported by this module deal with runtime handling of
  Perl modules, which are normally handled at compile time.  This module
  avoids using any other modules, so that it can be used in low-level
  infrastructure.
  
  The parts of this module that work with module names apply the same syntax
  that is used for barewords in Perl source.  In principle this syntax
  can vary between versions of Perl, and this module applies the syntax of
  the Perl on which it is running.  In practice the usable syntax hasn't
  changed yet.  There's some intent for Unicode module names to be supported
  in the future, but this hasn't yet amounted to any consistent facility.
  
  The functions of this module whose purpose is to load modules include
  workarounds for three old Perl core bugs regarding C<require>.  These
  workarounds are applied on any Perl version where the bugs exist, except
  for a case where one of the bugs cannot be adequately worked around in
  pure Perl.
  
  =head2 Module name syntax
  
  The usable module name syntax has not changed from Perl 5.000 up to
  Perl 5.19.8.  The syntax is composed entirely of ASCII characters.
  From Perl 5.6 onwards there has been some attempt to allow the use of
  non-ASCII Unicode characters in Perl source, but it was fundamentally
  broken (like the entirety of Perl 5.6's Unicode handling) and remained
  pretty much entirely unusable until it got some attention in the Perl
  5.15 series.  Although Unicode is now consistently accepted by the
  parser in some places, it remains broken for module names.  Furthermore,
  there has not yet been any work on how to map Unicode module names into
  filenames, so in that respect also Unicode module names are unusable.
  
  The module name syntax is, precisely: the string must consist of one or
  more segments separated by C<::>; each segment must consist of one or more
  identifier characters (ASCII alphanumerics plus "_"); the first character
  of the string must not be a digit.  Thus "C<IO::File>", "C<warnings>",
  and "C<foo::123::x_0>" are all valid module names, whereas "C<IO::>"
  and "C<1foo::bar>" are not.  C<'> separators are not permitted by this
  module, though they remain usable in Perl source, being translated to
  C<::> in the parser.
  
  =head2 Core bugs worked around
  
  The first bug worked around is core bug [perl #68590], which causes
  lexical state in one file to leak into another that is C<require>d/C<use>d
  from it.  This bug is present from Perl 5.6 up to Perl 5.10, and is
  fixed in Perl 5.11.0.  From Perl 5.9.4 up to Perl 5.10.0 no satisfactory
  workaround is possible in pure Perl.  The workaround means that modules
  loaded via this module don't suffer this pollution of their lexical
  state.  Modules loaded in other ways, or via this module on the Perl
  versions where the pure Perl workaround is impossible, remain vulnerable.
  The module L<Lexical::SealRequireHints> provides a complete workaround
  for this bug.
  
  The second bug worked around causes some kinds of failure in module
  loading, principally compilation errors in the loaded module, to be
  recorded in C<%INC> as if they were successful, so later attempts to load
  the same module immediately indicate success.  This bug is present up
  to Perl 5.8.9, and is fixed in Perl 5.9.0.  The workaround means that a
  compilation error in a module loaded via this module won't be cached as
  a success.  Modules loaded in other ways remain liable to produce bogus
  C<%INC> entries, and if a bogus entry exists then it will mislead this
  module if it is used to re-attempt loading.
  
  The third bug worked around causes the wrong context to be seen at
  file scope of a loaded module, if C<require> is invoked in a location
  that inherits context from a higher scope.  This bug is present up to
  Perl 5.11.2, and is fixed in Perl 5.11.3.  The workaround means that
  a module loaded via this module will always see the correct context.
  Modules loaded in other ways remain vulnerable.
  
  =cut
  
  package Module::Runtime;
  
  # Don't "use 5.006" here, because Perl 5.15.6 will load feature.pm if
  # the version check is done that way.
  BEGIN { require 5.006; }
  # Don't "use warnings" here, to avoid dependencies.  Do standardise the
  # warning status by lexical override; unfortunately the only safe bitset
  # to build in is the empty set, equivalent to "no warnings".
  BEGIN { ${^WARNING_BITS} = ""; }
  # Don't "use strict" here, to avoid dependencies.
  
  our $VERSION = "0.016";
  
  # Don't use Exporter here, to avoid dependencies.
  our @EXPORT_OK = qw(
  	$module_name_rx is_module_name is_valid_module_name check_module_name
  	module_notional_filename require_module
  	use_module use_package_optimistically
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec is_valid_module_spec check_module_spec
  	compose_module_name
  );
  my %export_ok = map { ($_ => undef) } @EXPORT_OK;
  sub import {
  	my $me = shift;
  	my $callpkg = caller(0);
  	my $errs = "";
  	foreach(@_) {
  		if(exists $export_ok{$_}) {
  			# We would need to do "no strict 'refs'" here
  			# if we had enabled strict at file scope.
  			if(/\A\$(.*)\z/s) {
  				*{$callpkg."::".$1} = \$$1;
  			} else {
  				*{$callpkg."::".$_} = \&$_;
  			}
  		} else {
  			$errs .= "\"$_\" is not exported by the $me module\n";
  		}
  	}
  	if($errs ne "") {
  		die "${errs}Can't continue after import errors ".
  			"at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n";
  	}
  }
  
  # Logic duplicated from Params::Classify.  Duplicating it here avoids
  # an extensive and potentially circular dependency graph.
  sub _is_string($) {
  	my($arg) = @_;
  	return defined($arg) && ref(\$arg) eq "SCALAR";
  }
  
  =head1 REGULAR EXPRESSIONS
  
  These regular expressions do not include any anchors, so to check
  whether an entire string matches a syntax item you must supply the
  anchors yourself.
  
  =over
  
  =item $module_name_rx
  
  Matches a valid Perl module name in bareword syntax.
  
  =cut
  
  our $module_name_rx = qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;
  
  =item $top_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where no prefix is being used.
  
  =cut
  
  my $qual_module_spec_rx =
  	qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  my $unqual_top_module_spec_rx =
  	qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $top_module_spec_rx = qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;
  
  =item $sub_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where a prefix is being used.
  
  =cut
  
  my $unqual_sub_module_spec_rx = qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $sub_module_spec_rx = qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 Basic module handling
  
  =over
  
  =item is_module_name(ARG)
  
  Returns a truth value indicating whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  
  =cut
  
  sub is_module_name($) { _is_string($_[0]) && $_[0] =~ /\A$module_name_rx\z/o }
  
  =item is_valid_module_name(ARG)
  
  Deprecated alias for L</is_module_name>.
  
  =cut
  
  *is_valid_module_name = \&is_module_name;
  
  =item check_module_name(ARG)
  
  Check whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_name($) {
  	unless(&is_module_name) {
  		die +(_is_string($_[0]) ? "`$_[0]'" : "argument").
  			" is not a module name\n";
  	}
  }
  
  =item module_notional_filename(NAME)
  
  Generates a notional relative filename for a module, which is used in
  some Perl core interfaces.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The notional filename for the named module is generated and returned.
  This filename is always in Unix style, with C</> directory separators
  and a C<.pm> suffix.  This kind of filename can be used as an argument to
  C<require>, and is the key that appears in C<%INC> to identify a module,
  regardless of actual local filename syntax.
  
  =cut
  
  sub module_notional_filename($) {
  	&check_module_name;
  	my($name) = @_;
  	$name =~ s!::!/!g;
  	return $name.".pm";
  }
  
  =item require_module(NAME)
  
  This is essentially the bareword form of C<require>, in runtime form.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The module specified by I<NAME> is loaded, if it hasn't been already,
  in the manner of the bareword form of C<require>.  That means that a
  search through C<@INC> is performed, and a byte-compiled form of the
  module will be used if available.
  
  The return value is as for C<require>.  That is, it is the value returned
  by the module itself if the module is loaded anew, or C<1> if the module
  was already loaded.
  
  =cut
  
  # Don't "use constant" here, to avoid dependencies.
  BEGIN {
  	*_WORK_AROUND_HINT_LEAKAGE =
  		"$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
  			? sub(){1} : sub(){0};
  	*_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
  }
  
  BEGIN { if(_WORK_AROUND_BROKEN_MODULE_STATE) { eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  }; die $@ if $@ ne ""; } }
  
  sub require_module($) {
  	# Localise %^H to work around [perl #68590], where the bug exists
  	# and this is a satisfactory workaround.  The bug consists of
  	# %^H state leaking into each required module, polluting the
  	# module's lexical state.
  	local %^H if _WORK_AROUND_HINT_LEAKAGE;
  	if(_WORK_AROUND_BROKEN_MODULE_STATE) {
  		my $notional_filename = &module_notional_filename;
  		my $guard = bless([ $notional_filename ],
  				"Module::Runtime::__GUARD__");
  		my $result = CORE::require($notional_filename);
  		pop @$guard;
  		return $result;
  	} else {
  		return scalar(CORE::require(&module_notional_filename));
  	}
  }
  
  =back
  
  =head2 Structured module use
  
  =over
  
  =item use_module(NAME[, VERSION])
  
  This is essentially C<use> in runtime form, but without the importing
  feature (which is fundamentally a compile-time thing).  The I<NAME> is
  handled just like in C<require_module> above: it must be a module name,
  and the named module is loaded as if by the bareword form of C<require>.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded module is
  called with the specified I<VERSION> as an argument.  This normally serves to
  ensure that the version loaded is at least the version required.  This is
  the same functionality provided by the I<VERSION> parameter of C<use>.
  
  On success, the name of the module is returned.  This is unlike
  L</require_module>, and is done so that the entire call to L</use_module>
  can be used as a class name to call a constructor, as in the example in
  the synopsis.
  
  =cut
  
  sub use_module($;$) {
  	my($name, $version) = @_;
  	require_module($name);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =item use_package_optimistically(NAME[, VERSION])
  
  This is an analogue of L</use_module> for the situation where there is
  uncertainty as to whether a package/class is defined in its own module
  or by some other means.  It attempts to arrange for the named package to
  be available, either by loading a module or by doing nothing and hoping.
  
  An attempt is made to load the named module (as if by the bareword form
  of C<require>).  If the module cannot be found then it is assumed that
  the package was actually already loaded by other means, and no error
  is signalled.  That's the optimistic bit.
  
  I<Warning:> this optional module loading is liable to cause unreliable
  behaviour, including security problems.  It interacts especially badly
  with having C<.> in C<@INC>, which was the default state of affairs in
  Perls prior to 5.25.11.  If a package is actually defined by some means
  other than a module, then applying this function to it causes a spurious
  attempt to load a module that is expected to be non-existent.  If a
  module actually exists under that name then it will be unintentionally
  loaded.  If C<.> is in C<@INC> and this code is ever run with the current
  directory being one writable by a malicious user (such as F</tmp>), then
  the malicious user can easily cause the victim to run arbitrary code, by
  creating a module file under the predictable spuriously-loaded name in the
  writable directory.  Generally, optional module loading should be avoided.
  
  This is mostly the same operation that is performed by the L<base> pragma
  to ensure that the specified base classes are available.  The behaviour
  of L<base> was simplified in version 2.18, and later improved in version
  2.20, and on both occasions this function changed to match.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded package is
  called with the specified I<VERSION> as an argument.  This normally serves
  to ensure that the version loaded is at least the version required.
  On success, the name of the package is returned.  These aspects of the
  function work just like L</use_module>.
  
  =cut
  
  sub use_package_optimistically($;$) {
  	my($name, $version) = @_;
  	my $fn = module_notional_filename($name);
  	eval { local $SIG{__DIE__}; require_module($name); };
  	die $@ if $@ ne "" &&
  		($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s ||
  		 $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =back
  
  =head2 Module name composition
  
  =over
  
  =item is_module_spec(PREFIX, SPEC)
  
  Returns a truth value indicating
  whether I<SPEC> is valid input for L</compose_module_name>.
  See below for what that entails.  Whether a I<PREFIX> is supplied affects
  the validity of I<SPEC>, but the exact value of the prefix is unimportant,
  so this function treats I<PREFIX> as a truth value.
  
  =cut
  
  sub is_module_spec($$) {
  	my($prefix, $spec) = @_;
  	return _is_string($spec) &&
  		$spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o :
  				    qr/\A$top_module_spec_rx\z/o);
  }
  
  =item is_valid_module_spec(PREFIX, SPEC)
  
  Deprecated alias for L</is_module_spec>.
  
  =cut
  
  *is_valid_module_spec = \&is_module_spec;
  
  =item check_module_spec(PREFIX, SPEC)
  
  Check whether I<SPEC> is valid input for L</compose_module_name>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_spec($$) {
  	unless(&is_module_spec) {
  		die +(_is_string($_[1]) ? "`$_[1]'" : "argument").
  			" is not a module specification\n";
  	}
  }
  
  =item compose_module_name(PREFIX, SPEC)
  
  This function is intended to make it more convenient for a user to specify
  a Perl module name at runtime.  Users have greater need for abbreviations
  and context-sensitivity than programmers, and Perl module names get a
  little unwieldy.  I<SPEC> is what the user specifies, and this function
  translates it into a module name in standard form, which it returns.
  
  I<SPEC> has syntax approximately that of a standard module name: it
  should consist of one or more name segments, each of which consists
  of one or more identifier characters.  However, C</> is permitted as a
  separator, in addition to the standard C<::>.  The two separators are
  entirely interchangeable.
  
  Additionally, if I<PREFIX> is not C<undef> then it must be a module
  name in standard form, and it is prefixed to the user-specified name.
  The user can inhibit the prefix addition by starting I<SPEC> with a
  separator (either C</> or C<::>).
  
  =cut
  
  sub compose_module_name($$) {
  	my($prefix, $spec) = @_;
  	check_module_name($prefix) if defined $prefix;
  	&check_module_spec;
  	if($spec =~ s#\A(?:/|::)##) {
  		# OK
  	} else {
  		$spec = $prefix."::".$spec if defined $prefix;
  	}
  	$spec =~ s#/#::#g;
  	return $spec;
  }
  
  =back
  
  =head1 BUGS
  
  On Perl versions 5.7.2 to 5.8.8, if C<require> is overridden by the
  C<CORE::GLOBAL> mechanism, it is likely to break the heuristics used by
  L</use_package_optimistically>, making it signal an error for a missing
  module rather than assume that it was already loaded.  From Perl 5.8.9
  onwards, and on 5.7.1 and earlier, this module can avoid being confused
  by such an override.  On the affected versions, a C<require> override
  might be installed by L<Lexical::SealRequireHints>, if something requires
  its bugfix but for some reason its XS implementation isn't available.
  
  =head1 SEE ALSO
  
  L<Lexical::SealRequireHints>,
  L<base>,
  L<perlfunc/require>,
  L<perlfunc/use>
  
  =head1 AUTHOR
  
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2004, 2006, 2007, 2009, 2010, 2011, 2012, 2014, 2017
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
MODULE_RUNTIME

$fatpacked{"Package/Stash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH';
  package Package::Stash;
  BEGIN {
    $Package::Stash::AUTHORITY = 'cpan:DOY';
  }
  $Package::Stash::VERSION = '0.37';
  use strict;
  use warnings;
  use 5.008001;
  # ABSTRACT: routines for manipulating stashes
  
  our $IMPLEMENTATION;
  
  use Module::Implementation 0.06;
  
  BEGIN {
      local $ENV{PACKAGE_STASH_IMPLEMENTATION} = $IMPLEMENTATION
        if ( $IMPLEMENTATION and not $ENV{PACKAGE_STASH_IMPLEMENTATION} );
  
      Module::Implementation::build_loader_sub(
          implementations => [ 'XS', 'PP' ],
          symbols         => [qw(
              new
              name
              namespace
              add_symbol
              remove_glob
              has_symbol
              get_symbol
              get_or_add_symbol
              remove_symbol
              list_all_symbols
              get_all_symbols
          )],
      )->();
      $IMPLEMENTATION = Module::Implementation::implementation_for(__PACKAGE__);
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Package::Stash - routines for manipulating stashes
  
  =head1 VERSION
  
  version 0.37
  
  =head1 SYNOPSIS
  
    my $stash = Package::Stash->new('Foo');
    $stash->add_symbol('%foo', {bar => 1});
    # $Foo::foo{bar} == 1
    $stash->has_symbol('$foo') # false
    my $namespace = $stash->namespace;
    *{ $namespace->{foo} }{HASH} # {bar => 1}
  
  =head1 DESCRIPTION
  
  Manipulating stashes (Perl's symbol tables) is occasionally necessary, but
  incredibly messy, and easy to get wrong. This module hides all of that behind a
  simple API.
  
  NOTE: Most methods in this class require a variable specification that includes
  a sigil. If this sigil is absent, it is assumed to represent the IO slot.
  
  Due to limitations in the typeglob API available to perl code, and to typeglob
  manipulation in perl being quite slow, this module provides two
  implementations - one in pure perl, and one using XS. The XS implementation is
  to be preferred for most usages; the pure perl one is provided for cases where
  XS modules are not a possibility. The current implementation in use can be set
  by setting C<$ENV{PACKAGE_STASH_IMPLEMENTATION}> or
  C<$Package::Stash::IMPLEMENTATION> before loading Package::Stash (with the
  environment variable taking precedence), otherwise, it will use the XS
  implementation if possible, falling back to the pure perl one.
  
  =head1 METHODS
  
  =head2 new $package_name
  
  Creates a new C<Package::Stash> object, for the package given as the only
  argument.
  
  =head2 name
  
  Returns the name of the package that this object represents.
  
  =head2 namespace
  
  Returns the raw stash itself.
  
  =head2 add_symbol $variable $value %opts
  
  Adds a new package symbol, for the symbol given as C<$variable>, and optionally
  gives it an initial value of C<$value>. C<$variable> should be the name of
  variable including the sigil, so
  
    Package::Stash->new('Foo')->add_symbol('%foo')
  
  will create C<%Foo::foo>.
  
  Valid options (all optional) are C<filename>, C<first_line_num>, and
  C<last_line_num>.
  
  C<$opts{filename}>, C<$opts{first_line_num}>, and C<$opts{last_line_num}> can
  be used to indicate where the symbol should be regarded as having been defined.
  Currently these values are only used if the symbol is a subroutine ('C<&>'
  sigil) and only if C<$^P & 0x10> is true, in which case the special C<%DB::sub>
  hash is updated to record the values of C<filename>, C<first_line_num>, and
  C<last_line_num> for the subroutine. If these are not passed, their values are
  inferred (as much as possible) from C<caller> information.
  
  This is especially useful for debuggers and profilers, which use C<%DB::sub> to
  determine where the source code for a subroutine can be found.  See
  L<http://perldoc.perl.org/perldebguts.html#Debugger-Internals> for more
  information about C<%DB::sub>.
  
  =head2 remove_glob $name
  
  Removes all package variables with the given name, regardless of sigil.
  
  =head2 has_symbol $variable
  
  Returns whether or not the given package variable (including sigil) exists.
  
  =head2 get_symbol $variable
  
  Returns the value of the given package variable (including sigil).
  
  =head2 get_or_add_symbol $variable
  
  Like C<get_symbol>, except that it will return an empty hashref or
  arrayref if the variable doesn't exist.
  
  =head2 remove_symbol $variable
  
  Removes the package variable described by C<$variable> (which includes the
  sigil); other variables with the same name but different sigils will be
  untouched.
  
  =head2 list_all_symbols $type_filter
  
  Returns a list of package variable names in the package, without sigils. If a
  C<type_filter> is passed, it is used to select package variables of a given
  type, where valid types are the slots of a typeglob ('SCALAR', 'CODE', 'HASH',
  etc). Note that if the package contained any C<BEGIN> blocks, perl will leave
  an empty typeglob in the C<BEGIN> slot, so this will show up if no filter is
  used (and similarly for C<INIT>, C<END>, etc).
  
  =head2 get_all_symbols $type_filter
  
  Returns a hashref, keyed by the variable names in the package. If
  C<$type_filter> is passed, the hash will contain every variable of that type in
  the package as values, otherwise, it will contain the typeglobs corresponding
  to the variable names (basically, a clone of the stash).
  
  =head1 WORKING WITH VARIABLES
  
  It is important to note, that when working with scalar variables, the default
  behavior is to B<copy> values.
  
    my $stash = Package::Stash->new('Some::Namespace');
    my $variable = 1;
    # $Some::Namespace::name is a copy of $variable
    $stash->add_symbol('$name', $variable);
    $variable++
    # $Some::Namespace::name == 1 , $variable == 2
  
  This will likely confuse people who expect it to work the same as typeglob
  assignment, which simply creates new references to existing variables.
  
    my $variable = 1;
    {
        no strict 'refs';
        # assign $Package::Stash::name = $variable
        *{'Package::Stash::name'} = \$variable;
    }
    $variable++ # affects both names
  
  If this behaviour is desired when working with Package::Stash, simply pass
  Package::Stash a scalar ref:
  
    my $stash = Package::Stash->new('Some::Namespace');
    my $variable = 1;
    # $Some::Namespace::name is now $variable
    $stash->add_symbol('$name', \$variable);
    $variable++
    # $Some::Namespace::name == 2 , $variable == 2
  
  This will be what you want as well if you're ever working with L<Readonly>
  variables:
  
    use Readonly;
    Readonly my $value, 'hello';
  
    $stash->add_symbol('$name', \$value); # reference
    print $Some::Namespace::name; # hello
    # Tries to modify the read-only 'hello' and dies.
    $Some::Namespace::name .= " world";
  
    $stash->add_symbol('$name', $value); # copy
    print $Some::Namespace::name; # hello
    # No problem, modifying a copy, not the original
    $Some::Namespace::name .= " world";
  
  =head1 BUGS / CAVEATS
  
  =over 4
  
  =item * Prior to perl 5.10, scalar slots are only considered to exist if they are defined
  
  This is due to a shortcoming within perl itself. See
  L<perlref/Making References> point 7 for more information.
  
  =item * GLOB and FORMAT variables are not (yet) accessible through this module.
  
  =item * Also, see the BUGS section for the specific backends (L<Package::Stash::XS> and L<Package::Stash::PP>)
  
  =back
  
  Please report any bugs to GitHub Issues at
  L<https://github.com/doy/package-stash/issues>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Class::MOP::Package>
  
  This module is a factoring out of code that used to live here
  
  =back
  
  =head1 SUPPORT
  
  You can find this documentation for this module with the perldoc command.
  
      perldoc Package::Stash
  
  You can also look for information at:
  
  =over 4
  
  =item * MetaCPAN
  
  L<https://metacpan.org/release/Package-Stash>
  
  =item * Github
  
  L<https://github.com/doy/package-stash>
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Package-Stash>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Package-Stash>
  
  =back
  
  =head1 HISTORY
  
  Based on code from L<Class::MOP::Package>, by Stevan Little and the Moose
  Cabal.
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy@tozt.net>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PACKAGE_STASH

$fatpacked{"Package/Stash/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH_CONFLICTS';
  package # hide from PAUSE
      Package::Stash::Conflicts;
  
  use strict;
  use warnings;
  
  # this module was generated with Dist::Zilla::Plugin::Conflicts 0.16
  
  use Dist::CheckConflicts
      -dist      => 'Package::Stash',
      -conflicts => {
          'Class::MOP' => '1.08',
          'MooseX::Method::Signatures' => '0.36',
          'MooseX::Role::WithOverloading' => '0.08',
          'namespace::clean' => '0.18',
      },
      -also => [ qw(
          B
          Carp
          Dist::CheckConflicts
          Getopt::Long
          Module::Implementation
          Scalar::Util
          Symbol
          constant
          strict
          warnings
      ) ],
  
  ;
  
  1;
  
  # ABSTRACT: Provide information on conflicts for Package::Stash
  # Dist::Zilla: -PodWeaver
PACKAGE_STASH_CONFLICTS

$fatpacked{"Package/Stash/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PACKAGE_STASH_PP';
  package Package::Stash::PP;
  BEGIN {
    $Package::Stash::PP::AUTHORITY = 'cpan:DOY';
  }
  $Package::Stash::PP::VERSION = '0.37';
  use strict;
  use warnings;
  # ABSTRACT: pure perl implementation of the Package::Stash API
  
  use B;
  use Carp qw(confess);
  use Scalar::Util qw(blessed reftype weaken);
  use Symbol;
  # before 5.12, assigning to the ISA glob would make it lose its magical ->isa
  # powers
  use constant BROKEN_ISA_ASSIGNMENT => ($] < 5.012);
  # before 5.10, stashes don't ever seem to drop to a refcount of zero, so
  # weakening them isn't helpful
  use constant BROKEN_WEAK_STASH     => ($] < 5.010);
  # before 5.10, the scalar slot was always treated as existing if the
  # glob existed
  use constant BROKEN_SCALAR_INITIALIZATION => ($] < 5.010);
  # add_method on anon stashes triggers rt.perl #1804 otherwise
  # fixed in perl commit v5.13.3-70-g0fe688f
  use constant BROKEN_GLOB_ASSIGNMENT => ($] < 5.013004);
  # pre-5.10, ->isa lookups were cached in the ::ISA::CACHE:: slot
  use constant HAS_ISA_CACHE => ($] < 5.010);
  
  
  sub new {
      my $class = shift;
      my ($package) = @_;
  
      if (!defined($package) || (ref($package) && reftype($package) ne 'HASH')) {
          confess "Package::Stash->new must be passed the name of the "
                . "package to access";
      }
      elsif (ref($package) && reftype($package) eq 'HASH') {
          confess "The PP implementation of Package::Stash does not support "
                . "anonymous stashes before perl 5.14"
              if BROKEN_GLOB_ASSIGNMENT;
  
          return bless {
              'namespace' => $package,
          }, $class;
      }
      elsif ($package =~ /\A[0-9A-Z_a-z]+(?:::[0-9A-Z_a-z]+)*\z/) {
          return bless {
              'package' => $package,
          }, $class;
      }
      else {
          confess "$package is not a module name";
      }
  
  }
  
  sub name {
      confess "Can't call name as a class method"
          unless blessed($_[0]);
      confess "Can't get the name of an anonymous package"
          unless defined($_[0]->{package});
      return $_[0]->{package};
  }
  
  sub namespace {
      confess "Can't call namespace as a class method"
          unless blessed($_[0]);
  
      if (BROKEN_WEAK_STASH) {
          no strict 'refs';
          return \%{$_[0]->name . '::'};
      }
      else {
          return $_[0]->{namespace} if defined $_[0]->{namespace};
  
          {
              no strict 'refs';
              $_[0]->{namespace} = \%{$_[0]->name . '::'};
          }
  
          weaken($_[0]->{namespace});
  
          return $_[0]->{namespace};
      }
  }
  
  {
      my %SIGIL_MAP = (
          '$' => 'SCALAR',
          '@' => 'ARRAY',
          '%' => 'HASH',
          '&' => 'CODE',
          ''  => 'IO',
      );
  
      sub _deconstruct_variable_name {
          my ($variable) = @_;
  
          my @ret;
          if (ref($variable) eq 'HASH') {
              @ret = @{$variable}{qw[name sigil type]};
          }
          else {
              (defined $variable && length $variable)
                  || confess "You must pass a variable name";
  
              my $sigil = substr($variable, 0, 1, '');
  
              if (exists $SIGIL_MAP{$sigil}) {
                  @ret = ($variable, $sigil, $SIGIL_MAP{$sigil});
              }
              else {
                  @ret = ("${sigil}${variable}", '', $SIGIL_MAP{''});
              }
          }
  
          # XXX in pure perl, this will access things in inner packages,
          # in xs, this will segfault - probably look more into this at
          # some point
          ($ret[0] !~ /::/)
              || confess "Variable names may not contain ::";
  
          return @ret;
      }
  }
  
  sub _valid_for_type {
      my ($value, $type) = @_;
      if ($type eq 'HASH' || $type eq 'ARRAY'
       || $type eq 'IO'   || $type eq 'CODE') {
          return reftype($value) eq $type;
      }
      else {
          my $ref = reftype($value);
          return !defined($ref) || $ref eq 'SCALAR' || $ref eq 'REF' || $ref eq 'LVALUE' || $ref eq 'REGEXP' || $ref eq 'VSTRING';
      }
  }
  
  sub add_symbol {
      my ($self, $variable, $initial_value, %opts) = @_;
  
      my ($name, $sigil, $type) = _deconstruct_variable_name($variable);
  
      if (@_ > 2) {
          _valid_for_type($initial_value, $type)
              || confess "$initial_value is not of type $type";
  
          # cheap fail-fast check for PERLDBf_SUBLINE and '&'
          if ($^P and $^P & 0x10 && $sigil eq '&') {
              my $filename = $opts{filename};
              my $first_line_num = $opts{first_line_num};
  
              (undef, $filename, $first_line_num) = caller
                  if not defined $filename;
  
              my $last_line_num = $opts{last_line_num} || ($first_line_num ||= 0);
  
              # http://perldoc.perl.org/perldebguts.html#Debugger-Internals
              $DB::sub{$self->name . '::' . $name} = "$filename:$first_line_num-$last_line_num";
          }
      }
  
      if (BROKEN_GLOB_ASSIGNMENT) {
          if (@_ > 2) {
              no strict 'refs';
              no warnings 'redefine';
              *{ $self->name . '::' . $name } = ref $initial_value
                  ? $initial_value : \$initial_value;
          }
          else {
              no strict 'refs';
              if (BROKEN_ISA_ASSIGNMENT && $name eq 'ISA') {
                  *{ $self->name . '::' . $name };
              }
              else {
                  my $undef = _undef_ref_for_type($type);
                  *{ $self->name . '::' . $name } = $undef;
              }
          }
      }
      else {
          my $namespace = $self->namespace;
          {
              # using glob aliasing instead of Symbol::gensym, because otherwise,
              # magic doesn't get applied properly.
              # see <20120710063744.19360.qmail@lists-nntp.develooper.com> on p5p
              local *__ANON__:: = $namespace;
              no strict 'refs';
              no warnings 'void';
              no warnings 'once';
              *{"__ANON__::$name"};
          }
  
          if (@_ > 2) {
              no warnings 'redefine';
              *{ $namespace->{$name} } = ref $initial_value
                  ? $initial_value : \$initial_value;
          }
          else {
              return if BROKEN_ISA_ASSIGNMENT && $name eq 'ISA';
              *{ $namespace->{$name} } = _undef_ref_for_type($type);
          }
      }
  }
  
  sub _undef_ref_for_type {
      my ($type) = @_;
  
      if ($type eq 'ARRAY') {
          return [];
      }
      elsif ($type eq 'HASH') {
          return {};
      }
      elsif ($type eq 'SCALAR') {
          return \undef;
      }
      elsif ($type eq 'IO') {
          return Symbol::geniosym;
      }
      elsif ($type eq 'CODE') {
          confess "Don't know how to vivify CODE variables";
      }
      else {
          confess "Unknown type $type in vivication";
      }
  }
  
  sub remove_glob {
      my ($self, $name) = @_;
      delete $self->namespace->{$name};
  }
  
  sub has_symbol {
      my ($self, $variable) = @_;
  
      my ($name, $sigil, $type) = _deconstruct_variable_name($variable);
  
      my $namespace = $self->namespace;
  
      return unless exists $namespace->{$name};
  
      my $entry_ref = \$namespace->{$name};
      if (reftype($entry_ref) eq 'GLOB') {
          if ($type eq 'SCALAR') {
              if (BROKEN_SCALAR_INITIALIZATION) {
                  return defined ${ *{$entry_ref}{$type} };
              }
              else {
                  my $sv = B::svref_2object($entry_ref)->SV;
                  return $sv->isa('B::SV')
                      || ($sv->isa('B::SPECIAL')
                       && $B::specialsv_name[$$sv] ne 'Nullsv');
              }
          }
          else {
              return defined *{$entry_ref}{$type};
          }
      }
      else {
          # a symbol table entry can be -1 (stub), string (stub with prototype),
          # or reference (constant)
          return $type eq 'CODE';
      }
  }
  
  sub get_symbol {
      my ($self, $variable, %opts) = @_;
  
      my ($name, $sigil, $type) = _deconstruct_variable_name($variable);
  
      my $namespace = $self->namespace;
  
      if (!exists $namespace->{$name}) {
          if ($opts{vivify}) {
              $self->add_symbol($variable);
          }
          else {
              return undef;
          }
      }
  
      my $entry_ref = \$namespace->{$name};
  
      if (ref($entry_ref) eq 'GLOB') {
          return *{$entry_ref}{$type};
      }
      else {
          if ($type eq 'CODE') {
              if (BROKEN_GLOB_ASSIGNMENT || defined($self->{package})) {
                  no strict 'refs';
                  return \&{ $self->name . '::' . $name };
              }
  
              # XXX we should really be able to support arbitrary anonymous
              # stashes here... (not just via Package::Anon)
              if (blessed($namespace) && $namespace->isa('Package::Anon')) {
                  # ->can will call gv_init for us, which inflates the glob
                  # don't know how to do this in general
                  $namespace->bless(\(my $foo))->can($name);
              }
              else {
                  confess "Don't know how to inflate a " . ref($entry_ref)
                        . " into a full coderef (perhaps you could use"
                        . " Package::Anon instead of a bare stash?)"
              }
  
              return *{ $namespace->{$name} }{CODE};
          }
          else {
              return undef;
          }
      }
  }
  
  sub get_or_add_symbol {
      my $self = shift;
      $self->get_symbol(@_, vivify => 1);
  }
  
  sub remove_symbol {
      my ($self, $variable) = @_;
  
      my ($name, $sigil, $type) = _deconstruct_variable_name($variable);
  
      # FIXME:
      # no doubt this is grossly inefficient and
      # could be done much easier and faster in XS
  
      my %desc = (
          SCALAR => { sigil => '$', type => 'SCALAR', name => $name },
          ARRAY  => { sigil => '@', type => 'ARRAY',  name => $name },
          HASH   => { sigil => '%', type => 'HASH',   name => $name },
          CODE   => { sigil => '&', type => 'CODE',   name => $name },
          IO     => { sigil => '',  type => 'IO',     name => $name },
      );
      confess "This should never ever ever happen" if !$desc{$type};
  
      my @types_to_store = grep { $type ne $_ && $self->has_symbol($desc{$_}) }
                                keys %desc;
      my %values = map { $_, $self->get_symbol($desc{$_}) } @types_to_store;
  
      $values{SCALAR} = $self->get_symbol($desc{SCALAR})
        if !defined $values{SCALAR}
          && $type ne 'SCALAR'
          && BROKEN_SCALAR_INITIALIZATION;
  
      $self->remove_glob($name);
  
      $self->add_symbol($desc{$_} => $values{$_})
          for grep { defined $values{$_} } keys %values;
  }
  
  sub list_all_symbols {
      my ($self, $type_filter) = @_;
  
      my $namespace = $self->namespace;
      if (HAS_ISA_CACHE) {
          return grep { $_ ne '::ISA::CACHE::' } keys %{$namespace}
              unless defined $type_filter;
      }
      else {
          return keys %{$namespace}
              unless defined $type_filter;
      }
  
      # NOTE:
      # or we can filter based on
      # type (SCALAR|ARRAY|HASH|CODE)
      if ($type_filter eq 'CODE') {
          return grep {
              # any non-typeglob in the symbol table is a constant or stub
              ref(\$namespace->{$_}) ne 'GLOB'
                  # regular subs are stored in the CODE slot of the typeglob
                  || defined(*{$namespace->{$_}}{CODE})
          } keys %{$namespace};
      }
      elsif ($type_filter eq 'SCALAR') {
          return grep {
              !(HAS_ISA_CACHE && $_ eq '::ISA::CACHE::') &&
              (BROKEN_SCALAR_INITIALIZATION
                  ? (ref(\$namespace->{$_}) eq 'GLOB'
                        && defined(${*{$namespace->{$_}}{'SCALAR'}}))
                  : (do {
                        my $entry = \$namespace->{$_};
                        ref($entry) eq 'GLOB'
                            && B::svref_2object($entry)->SV->isa('B::SV')
                    }))
          } keys %{$namespace};
      }
      else {
          return grep {
              ref(\$namespace->{$_}) eq 'GLOB'
                  && defined(*{$namespace->{$_}}{$type_filter})
          } keys %{$namespace};
      }
  }
  
  sub get_all_symbols {
      my ($self, $type_filter) = @_;
  
      my $namespace = $self->namespace;
      return { %{$namespace} } unless defined $type_filter;
  
      return {
          map { $_ => $self->get_symbol({name => $_, type => $type_filter}) }
              $self->list_all_symbols($type_filter)
      }
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Package::Stash::PP - pure perl implementation of the Package::Stash API
  
  =head1 VERSION
  
  version 0.37
  
  =head1 SYNOPSIS
  
    use Package::Stash;
  
  =head1 DESCRIPTION
  
  This is a backend for L<Package::Stash> implemented in pure perl, for those without a compiler or who would like to use this inline in scripts.
  
  =head1 BUGS
  
  =over 4
  
  =item * remove_symbol also replaces the associated typeglob
  
  This can cause unexpected behavior when doing manipulation at compile time -
  removing subroutines will still allow them to be called from within the package
  as subroutines (although they will not be available as methods). This can be
  considered a feature in some cases (this is how L<namespace::clean> works, for
  instance), but should not be relied upon - use C<remove_glob> directly if you
  want this behavior.
  
  =item * Some minor memory leaks
  
  The pure perl implementation has a couple minor memory leaks (see the TODO
  tests in t/20-leaks.t) that I'm having a hard time tracking down - these may be
  core perl bugs, it's hard to tell.
  
  =back
  
  Please report any bugs through RT: email
  C<bug-package-stash at rt.cpan.org>, or browse to
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Package-Stash>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Class::MOP::Package>
  
  This module is a factoring out of code that used to live here
  
  =back
  
  =head1 SUPPORT
  
  You can find this documentation for this module with the perldoc command.
  
      perldoc Package::Stash
  
  You can also look for information at:
  
  =over 4
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/Package-Stash>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Package-Stash>
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Package-Stash>
  
  =item * Search CPAN
  
  L<http://search.cpan.org/dist/Package-Stash>
  
  =back
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy at tozt dot net>
  
  Mostly copied from code from L<Class::MOP::Package>, by Stevan Little and the
  Moose Cabal.
  
  =for Pod::Coverage BROKEN_ISA_ASSIGNMENT
  add_symbol
  get_all_symbols
  get_or_add_symbol
  get_symbol
  has_symbol
  list_all_symbols
  name
  namespace
  new
  remove_glob
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy@tozt.net>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PACKAGE_STASH_PP

$fatpacked{"Sub/Install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_INSTALL';
  use strict;
  use warnings;
  package Sub::Install;
  # ABSTRACT: install subroutines into packages easily
  $Sub::Install::VERSION = '0.928';
  use Carp;
  use Scalar::Util ();
  
  #pod =head1 SYNOPSIS
  #pod
  #pod   use Sub::Install;
  #pod
  #pod   Sub::Install::install_sub({
  #pod     code => sub { ... },
  #pod     into => $package,
  #pod     as   => $subname
  #pod   });
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This module makes it easy to install subroutines into packages without the
  #pod unsightly mess of C<no strict> or typeglobs lying about where just anyone can
  #pod see them.
  #pod
  #pod =func install_sub
  #pod
  #pod   Sub::Install::install_sub({
  #pod    code => \&subroutine,
  #pod    into => "Finance::Shady",
  #pod    as   => 'launder',
  #pod   });
  #pod
  #pod This routine installs a given code reference into a package as a normal
  #pod subroutine.  The above is equivalent to:
  #pod
  #pod   no strict 'refs';
  #pod   *{"Finance::Shady" . '::' . "launder"} = \&subroutine;
  #pod
  #pod If C<into> is not given, the sub is installed into the calling package.
  #pod
  #pod If C<code> is not a code reference, it is looked for as an existing sub in the
  #pod package named in the C<from> parameter.  If C<from> is not given, it will look
  #pod in the calling package.
  #pod
  #pod If C<as> is not given, and if C<code> is a name, C<as> will default to C<code>.
  #pod If C<as> is not given, but if C<code> is a code ref, Sub::Install will try to
  #pod find the name of the given code ref and use that as C<as>.
  #pod
  #pod That means that this code:
  #pod
  #pod   Sub::Install::install_sub({
  #pod     code => 'twitch',
  #pod     from => 'Person::InPain',
  #pod     into => 'Person::Teenager',
  #pod     as   => 'dance',
  #pod   });
  #pod
  #pod is the same as:
  #pod
  #pod   package Person::Teenager;
  #pod
  #pod   Sub::Install::install_sub({
  #pod     code => Person::InPain->can('twitch'),
  #pod     as   => 'dance',
  #pod   });
  #pod
  #pod =func reinstall_sub
  #pod
  #pod This routine behaves exactly like C<L</install_sub>>, but does not emit a
  #pod warning if warnings are on and the destination is already defined.
  #pod
  #pod =cut
  
  sub _name_of_code {
    my ($code) = @_;
    require B;
    my $name = B::svref_2object($code)->GV->NAME;
    return $name unless $name =~ /\A__ANON__/;
    return;
  }
  
  # See also Params::Util, to which this code was donated.
  sub _CODELIKE {
    (Scalar::Util::reftype($_[0])||'') eq 'CODE'
    || Scalar::Util::blessed($_[0])
    && (overload::Method($_[0],'&{}') ? $_[0] : undef);
  }
  
  # do the heavy lifting
  sub _build_public_installer {
    my ($installer) = @_;
  
    sub {
      my ($arg) = @_;
      my ($calling_pkg) = caller(0);
  
      # I'd rather use ||= but I'm whoring for Devel::Cover.
      for (qw(into from)) { $arg->{$_} = $calling_pkg unless $arg->{$_} }
  
      # This is the only absolutely required argument, in many cases.
      Carp::croak "named argument 'code' is not optional" unless $arg->{code};
  
      if (_CODELIKE($arg->{code})) {
        $arg->{as} ||= _name_of_code($arg->{code});
      } else {
        Carp::croak
          "couldn't find subroutine named $arg->{code} in package $arg->{from}"
          unless my $code = $arg->{from}->can($arg->{code});
  
        $arg->{as}   = $arg->{code} unless $arg->{as};
        $arg->{code} = $code;
      }
  
      Carp::croak "couldn't determine name under which to install subroutine"
        unless $arg->{as};
  
      $installer->(@$arg{qw(into as code) });
    }
  }
  
  # do the ugly work
  
  my $_misc_warn_re;
  my $_redef_warn_re;
  BEGIN {
    $_misc_warn_re = qr/
      Prototype\ mismatch:\ sub\ .+?  |
      Constant subroutine .+? redefined
    /x;
    $_redef_warn_re = qr/Subroutine\ .+?\ redefined/x;
  }
  
  my $eow_re;
  BEGIN { $eow_re = qr/ at .+? line \d+\.\Z/ };
  
  sub _do_with_warn {
    my ($arg) = @_;
    my $code = delete $arg->{code};
    my $wants_code = sub {
      my $code = shift;
      sub {
        my $warn = $SIG{__WARN__} ? $SIG{__WARN__} : sub { warn @_ }; ## no critic
        local $SIG{__WARN__} = sub {
          my ($error) = @_;
          for (@{ $arg->{suppress} }) {
              return if $error =~ $_;
          }
          for (@{ $arg->{croak} }) {
            if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
              Carp::croak $base_error;
            }
          }
          for (@{ $arg->{carp} }) {
            if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
              return $warn->(Carp::shortmess $base_error);
            }
          }
          ($arg->{default} || $warn)->($error);
        };
        $code->(@_);
      };
    };
    return $wants_code->($code) if $code;
    return $wants_code;
  }
  
  sub _installer {
    sub {
      my ($pkg, $name, $code) = @_;
      no strict 'refs'; ## no critic ProhibitNoStrict
      *{"$pkg\::$name"} = $code;
      return $code;
    }
  }
  
  BEGIN {
    *_ignore_warnings = _do_with_warn({
      carp => [ $_misc_warn_re, $_redef_warn_re ]
    });
  
    *install_sub = _build_public_installer(_ignore_warnings(_installer));
  
    *_carp_warnings =  _do_with_warn({
      carp     => [ $_misc_warn_re ],
      suppress => [ $_redef_warn_re ],
    });
  
    *reinstall_sub = _build_public_installer(_carp_warnings(_installer));
  
    *_install_fatal = _do_with_warn({
      code     => _installer,
      croak    => [ $_redef_warn_re ],
    });
  }
  
  #pod =func install_installers
  #pod
  #pod This routine is provided to allow Sub::Install compatibility with
  #pod Sub::Installer.  It installs C<install_sub> and C<reinstall_sub> methods into
  #pod the package named by its argument.
  #pod
  #pod  Sub::Install::install_installers('Code::Builder'); # just for us, please
  #pod  Code::Builder->install_sub({ name => $code_ref });
  #pod
  #pod  Sub::Install::install_installers('UNIVERSAL'); # feeling lucky, punk?
  #pod  Anything::At::All->install_sub({ name => $code_ref });
  #pod
  #pod The installed installers are similar, but not identical, to those provided by
  #pod Sub::Installer.  They accept a single hash as an argument.  The key/value pairs
  #pod are used as the C<as> and C<code> parameters to the C<install_sub> routine
  #pod detailed above.  The package name on which the method is called is used as the
  #pod C<into> parameter.
  #pod
  #pod Unlike Sub::Installer's C<install_sub> will not eval strings into code, but
  #pod will look for named code in the calling package.
  #pod
  #pod =cut
  
  sub install_installers {
    my ($into) = @_;
  
    for my $method (qw(install_sub reinstall_sub)) {
      my $code = sub {
        my ($package, $subs) = @_;
        my ($caller) = caller(0);
        my $return;
        for (my ($name, $sub) = %$subs) {
          $return = Sub::Install->can($method)->({
            code => $sub,
            from => $caller,
            into => $package,
            as   => $name
          });
        }
        return $return;
      };
      install_sub({ code => $code, into => $into, as => $method });
    }
  }
  
  #pod =head1 EXPORTS
  #pod
  #pod Sub::Install exports C<install_sub> and C<reinstall_sub> only if they are
  #pod requested.
  #pod
  #pod =head2 exporter
  #pod
  #pod Sub::Install has a never-exported subroutine called C<exporter>, which is used
  #pod to implement its C<import> routine.  It takes a hashref of named arguments,
  #pod only one of which is currently recognize: C<exports>.  This must be an arrayref
  #pod of subroutines to offer for export.
  #pod
  #pod This routine is mainly for Sub::Install's own consumption.  Instead, consider
  #pod L<Sub::Exporter>.
  #pod
  #pod =cut
  
  sub exporter {
    my ($arg) = @_;
  
    my %is_exported = map { $_ => undef } @{ $arg->{exports} };
  
    sub {
      my $class = shift;
      my $target = caller;
      for (@_) {
        Carp::croak "'$_' is not exported by $class" if !exists $is_exported{$_};
        install_sub({ code => $_, from => $class, into => $target });
      }
    }
  }
  
  BEGIN { *import = exporter({ exports => [ qw(install_sub reinstall_sub) ] }); }
  
  #pod =head1 SEE ALSO
  #pod
  #pod =over
  #pod
  #pod =item L<Sub::Installer>
  #pod
  #pod This module is (obviously) a reaction to Damian Conway's Sub::Installer, which
  #pod does the same thing, but does it by getting its greasy fingers all over
  #pod UNIVERSAL.  I was really happy about the idea of making the installation of
  #pod coderefs less ugly, but I couldn't bring myself to replace the ugliness of
  #pod typeglobs and loosened strictures with the ugliness of UNIVERSAL methods.
  #pod
  #pod =item L<Sub::Exporter>
  #pod
  #pod This is a complete Exporter.pm replacement, built atop Sub::Install.
  #pod
  #pod =back
  #pod
  #pod =head1 EXTRA CREDITS
  #pod
  #pod Several of the tests are adapted from tests that shipped with Damian Conway's
  #pod Sub-Installer distribution.
  #pod
  #pod =cut
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Sub::Install - install subroutines into packages easily
  
  =head1 VERSION
  
  version 0.928
  
  =head1 SYNOPSIS
  
    use Sub::Install;
  
    Sub::Install::install_sub({
      code => sub { ... },
      into => $package,
      as   => $subname
    });
  
  =head1 DESCRIPTION
  
  This module makes it easy to install subroutines into packages without the
  unsightly mess of C<no strict> or typeglobs lying about where just anyone can
  see them.
  
  =head1 FUNCTIONS
  
  =head2 install_sub
  
    Sub::Install::install_sub({
     code => \&subroutine,
     into => "Finance::Shady",
     as   => 'launder',
    });
  
  This routine installs a given code reference into a package as a normal
  subroutine.  The above is equivalent to:
  
    no strict 'refs';
    *{"Finance::Shady" . '::' . "launder"} = \&subroutine;
  
  If C<into> is not given, the sub is installed into the calling package.
  
  If C<code> is not a code reference, it is looked for as an existing sub in the
  package named in the C<from> parameter.  If C<from> is not given, it will look
  in the calling package.
  
  If C<as> is not given, and if C<code> is a name, C<as> will default to C<code>.
  If C<as> is not given, but if C<code> is a code ref, Sub::Install will try to
  find the name of the given code ref and use that as C<as>.
  
  That means that this code:
  
    Sub::Install::install_sub({
      code => 'twitch',
      from => 'Person::InPain',
      into => 'Person::Teenager',
      as   => 'dance',
    });
  
  is the same as:
  
    package Person::Teenager;
  
    Sub::Install::install_sub({
      code => Person::InPain->can('twitch'),
      as   => 'dance',
    });
  
  =head2 reinstall_sub
  
  This routine behaves exactly like C<L</install_sub>>, but does not emit a
  warning if warnings are on and the destination is already defined.
  
  =head2 install_installers
  
  This routine is provided to allow Sub::Install compatibility with
  Sub::Installer.  It installs C<install_sub> and C<reinstall_sub> methods into
  the package named by its argument.
  
   Sub::Install::install_installers('Code::Builder'); # just for us, please
   Code::Builder->install_sub({ name => $code_ref });
  
   Sub::Install::install_installers('UNIVERSAL'); # feeling lucky, punk?
   Anything::At::All->install_sub({ name => $code_ref });
  
  The installed installers are similar, but not identical, to those provided by
  Sub::Installer.  They accept a single hash as an argument.  The key/value pairs
  are used as the C<as> and C<code> parameters to the C<install_sub> routine
  detailed above.  The package name on which the method is called is used as the
  C<into> parameter.
  
  Unlike Sub::Installer's C<install_sub> will not eval strings into code, but
  will look for named code in the calling package.
  
  =head1 EXPORTS
  
  Sub::Install exports C<install_sub> and C<reinstall_sub> only if they are
  requested.
  
  =head2 exporter
  
  Sub::Install has a never-exported subroutine called C<exporter>, which is used
  to implement its C<import> routine.  It takes a hashref of named arguments,
  only one of which is currently recognize: C<exports>.  This must be an arrayref
  of subroutines to offer for export.
  
  This routine is mainly for Sub::Install's own consumption.  Instead, consider
  L<Sub::Exporter>.
  
  =head1 SEE ALSO
  
  =over
  
  =item L<Sub::Installer>
  
  This module is (obviously) a reaction to Damian Conway's Sub::Installer, which
  does the same thing, but does it by getting its greasy fingers all over
  UNIVERSAL.  I was really happy about the idea of making the installation of
  coderefs less ugly, but I couldn't bring myself to replace the ugliness of
  typeglobs and loosened strictures with the ugliness of UNIVERSAL methods.
  
  =item L<Sub::Exporter>
  
  This is a complete Exporter.pm replacement, built atop Sub::Install.
  
  =back
  
  =head1 EXTRA CREDITS
  
  Several of the tests are adapted from tests that shipped with Damian Conway's
  Sub-Installer distribution.
  
  =head1 AUTHOR
  
  Ricardo SIGNES <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2005 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_INSTALL

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny; # git description: v0.29-2-g3b23a06
  use 5.006;
  # ABSTRACT: Minimal try/catch with proper preservation of $@
  
  our $VERSION = '0.30';
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT = our @EXPORT_OK = qw(try catch finally);
  
  use Carp;
  $Carp::Internal{+__PACKAGE__}++;
  
  BEGIN {
    my $su = $INC{'Sub/Util.pm'} && defined &Sub::Util::set_subname;
    my $sn = $INC{'Sub/Name.pm'} && eval { Sub::Name->VERSION(0.08) };
    unless ($su || $sn) {
      $su = eval { require Sub::Util; } && defined &Sub::Util::set_subname;
      unless ($su) {
        $sn = eval { require Sub::Name; Sub::Name->VERSION(0.08) };
      }
    }
  
    *_subname = $su ? \&Sub::Util::set_subname
              : $sn ? \&Sub::Name::subname
              : sub { $_[1] };
    *_HAS_SUBNAME = ($su || $sn) ? sub(){1} : sub(){0};
  }
  
  my %_finally_guards;
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
    my ( $try, @code_refs ) = @_;
  
    # we need to save this here, the eval block will be in scalar context due
    # to $failed
    my $wantarray = wantarray;
  
    # work around perl bug by explicitly initializing these, due to the likelyhood
    # this will be used in global destruction (perl rt#119311)
    my ( $catch, @finally ) = ();
  
    # find labeled blocks in the argument list.
    # catch and finally tag the blocks by blessing a scalar reference to them.
    foreach my $code_ref (@code_refs) {
  
      if ( ref($code_ref) eq 'Try::Tiny::Catch' ) {
        croak 'A try() may not be followed by multiple catch() blocks'
          if $catch;
        $catch = ${$code_ref};
      } elsif ( ref($code_ref) eq 'Try::Tiny::Finally' ) {
        push @finally, ${$code_ref};
      } else {
        croak(
          'try() encountered an unexpected argument ('
        . ( defined $code_ref ? $code_ref : 'undef' )
        . ') - perhaps a missing semi-colon before or'
        );
      }
    }
  
    # FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
    # not perfect, but we could provide a list of additional errors for
    # $catch->();
  
    # name the blocks if we have Sub::Name installed
    _subname(caller().'::try {...} ' => $try)
      if _HAS_SUBNAME;
  
    # set up scope guards to invoke the finally blocks at the end.
    # this should really be a function scope lexical variable instead of
    # file scope + local but that causes issues with perls < 5.20 due to
    # perl rt#119311
    local $_finally_guards{guards} = [
      map { Try::Tiny::ScopeGuard->_new($_) }
      @finally
    ];
  
    # save the value of $@ so we can set $@ back to it in the beginning of the eval
    # and restore $@ after the eval finishes
    my $prev_error = $@;
  
    my ( @ret, $error );
  
    # failed will be true if the eval dies, because 1 will not be returned
    # from the eval body
    my $failed = not eval {
      $@ = $prev_error;
  
      # evaluate the try block in the correct context
      if ( $wantarray ) {
        @ret = $try->();
      } elsif ( defined $wantarray ) {
        $ret[0] = $try->();
      } else {
        $try->();
      };
  
      return 1; # properly set $failed to false
    };
  
    # preserve the current error and reset the original value of $@
    $error = $@;
    $@ = $prev_error;
  
    # at this point $failed contains a true value if the eval died, even if some
    # destructor overwrote $@ as the eval was unwinding.
    if ( $failed ) {
      # pass $error to the finally blocks
      push @$_, $error for @{$_finally_guards{guards}};
  
      # if we got an error, invoke the catch block.
      if ( $catch ) {
        # This works like given($error), but is backwards compatible and
        # sets $_ in the dynamic scope for the body of C<$catch>
        for ($error) {
          return $catch->($error);
        }
  
        # in case when() was used without an explicit return, the C<for>
        # loop will be aborted and there's no useful return value
      }
  
      return;
    } else {
      # no failure, $@ is back to what it was, everything is fine
      return $wantarray ? @ret : $ret[0];
    }
  }
  
  sub catch (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare catch()' unless wantarray;
  
    _subname(caller().'::catch {...} ' => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Catch'),
      @rest,
    );
  }
  
  sub finally (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare finally()' unless wantarray;
  
    _subname(caller().'::finally {...} ' => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Finally'),
      @rest,
    );
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    use constant UNSTABLE_DOLLARAT => ("$]" < '5.013002') ? 1 : 0;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my ($code, @args) = @{ $_[0] };
  
      local $@ if UNSTABLE_DOLLARAT;
      eval {
        $code->(@args);
        1;
      } or do {
        warn
          "Execution of finally() block $code resulted in an exception, which "
        . '*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. '
        . 'Your program will continue as if this event never took place. '
        . "Original exception text follows:\n\n"
        . (defined $@ ? $@ : '$@ left undefined...')
        . "\n"
        ;
      }
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Try::Tiny - Minimal try/catch with proper preservation of $@
  
  =head1 VERSION
  
  version 0.30
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
    # handle errors with a catch handler
    try {
      die "foo";
    } catch {
      warn "caught error: $_"; # not $@
    };
  
  You can also use it like a standalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
    # just silence errors
    try {
      die "foo";
    };
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the C<try> block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L</BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the C<try> block dies, it returns the value of the last statement executed in
  the C<catch> block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following examples all
  assign C<"bar"> to C<$x>:
  
    my $x = try { die "foo" } catch { "bar" };
    my $x = try { die "foo" } || "bar";
    my $x = (try { die "foo" }) // "bar";
  
    my $x = eval { die "foo" } || "bar";
  
  You can add C<finally> blocks, yielding the following:
  
    my $x;
    try { die 'foo' } finally { $x = 'bar' };
    try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  C<finally> blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many C<finally> blocks to a
  given C<try> block as you like.
  
  Note that adding a C<finally> block without a preceding C<catch> block
  suppresses any errors. This behaviour is consistent with using a standalone
  C<eval>, but it is not consistent with C<try>/C<finally> patterns found in
  other programming languages, such as Java, Python, Javascript or C#. If you
  learnt the C<try>/C<finally> pattern from one of these languages, watch out for
  this.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory C<try> subroutine, an optional C<catch> subroutine and C<finally>
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the C<finally> block, if given, will execute.
  
  =item catch (&;@)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
    catch { ... }
  
  Inside the C<catch> block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
    local $@ = $_;
  
  =item finally (&;@)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. C<finally> blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the C<finally> block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the C<finally> block does not
  localize C<$_> with the error, since unlike in a C<catch> block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the C<finally> block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  Furthermore B<exceptions in C<finally> blocks are not trappable and are unable
  to influence the execution of your program>. This is due to limitation of
  C<DESTROY>-based scope guards, which C<finally> is implemented on top of. This
  may change in a future version of Try::Tiny.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an C<eval> block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically,
  L<before Perl version 5.14.0|perl5140delta/"Exception Handling">
  C<$@> was clobbered at the beginning of the C<eval>, which
  also made it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (the one
  available before entering the C<try> block) in the beginning of the C<eval>
  block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an C<eval> block, C<die> behaves sort of like:
  
    sub die {
      $@ = $_[0];
      return_undef_from_eval();
    }
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
    my $error = do {
      local $@;
      eval { ... };
      $@;
    };
  
    ...
    die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
    if ( $@ ) {
      ...
    }
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode (fixed in L<Perl 5.14.0|perl5140delta/"Exception Handling">) is:
  
    sub Object::DESTROY {
      eval { ... }
    }
  
    eval {
      my $obj = Object->new;
  
      die "foo";
    };
  
    if ( $@ ) {
  
    }
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the C<eval> was aborted due to an error:
  
    my $failed = not eval {
      ...
  
      return 1;
    };
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 ALTERNATE SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements"> (but please don't,
  because that syntax has since been deprecated because there was too much
  unexpected magical behaviour).
  
  =for stopwords topicalizer
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
    try {
      require Foo;
    } catch {
      when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
      default { die $_ }
    };
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  argument list. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
    sub foo {
      my ( $self, @args ) = @_;
      try { $self->bar(@args) }
    }
  
  or
  
    sub bar_in_place {
      my $self = shift;
      my $args = \@_;
      try { $_ = $self->bar($_) for @$args }
    }
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
      try {
        die;
      }
      catch {
        return;
      };
  
      say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
      my $success = try {
        die;
        1;
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
    # OR
    sub parent_sub_with_catch {
      my $success = try {
        die;
        1;
      }
      catch {
        # do something with $_
        return undef; #see note
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
  
  Note that if you have a C<catch> block, it must return C<undef> for this to work,
  since if a C<catch> block exists, its return value is returned in place of C<undef>
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =for stopwords unhygienically
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygienically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
    my $obj = try {
      MightFail->new;
    } catch {
      ...
  
      return; # avoid returning a true value;
    };
  
    return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
    given ($foo) {
      when (...) {
        try {
          ...
        } catch {
          warn $_; # will print $foo, not the error
          warn $_[0]; # instead, get the error like this
        }
      }
    }
  
  Note that this behavior was changed once again in
  L<Perl5 version 18|https://metacpan.org/module/perldelta#given-now-aliases-the-global-_>.
  However, since the entirety of lexical C<$_> is now L<considered experimental
  |https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental>, it
  is unclear whether the new version 18 behavior is final.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul>
  
  Or read the source:
  
  L<http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Try-Tiny>
  (or L<bug-Try-Tiny@rt.cpan.org|mailto:bug-Try-Tiny@rt.cpan.org>).
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Karen Etheridge Peter Rabbitson Ricardo Signes Mark Fowler Graham Knop Lukas Mai Aristotle Pagaltzis Dagfinn Ilmari Mannsåker Paul Howarth Rudolf Leermakers anaxagoras awalker chromatic Alex cm-perl Andrew Yates David Lowe Glenn Hans Dieter Pearcey Jens Berthold Jonathan Yu Marc Mims Stosberg Pali
  
  =over 4
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Mark Fowler <mark@twoshortplanks.com>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Lukas Mai <l.mai@web.de>
  
  =item *
  
  Aristotle Pagaltzis <pagaltzis@gmx.de>
  
  =item *
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =item *
  
  Paul Howarth <paul@city-fan.org>
  
  =item *
  
  Rudolf Leermakers <rudolf@hatsuseno.org>
  
  =item *
  
  anaxagoras <walkeraj@gmail.com>
  
  =item *
  
  awalker <awalker@sourcefire.com>
  
  =item *
  
  chromatic <chromatic@wgz.org>
  
  =item *
  
  Alex <alex@koban.(none)>
  
  =item *
  
  cm-perl <cm-perl@users.noreply.github.com>
  
  =item *
  
  Andrew Yates <ayates@haddock.local>
  
  =item *
  
  David Lowe <davidl@lokku.com>
  
  =item *
  
  Glenn Fowler <cebjyre@cpan.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Jens Berthold <jens@jebecs.de>
  
  =item *
  
  Jonathan Yu <JAWNSY@cpan.org>
  
  =item *
  
  Marc Mims <marc@questright.com>
  
  =item *
  
  Mark Stosberg <mark@stosberg.com>
  
  =item *
  
  Pali <pali@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is Copyright (c) 2009 by יובל קוג'מן (Yuval Kogman).
  
  This is free software, licensed under:
  
    The MIT (X11) License
  
  =cut
TRY_TINY

$fatpacked{"darwin-2level/Params/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_PARAMS_UTIL';
  package Params::Util;
  
  =pod
  
  =head1 NAME
  
  Params::Util - Simple, compact and correct param-checking functions
  
  =head1 SYNOPSIS
  
    # Import some functions
    use Params::Util qw{_SCALAR _HASH _INSTANCE};
    
    # If you are lazy, or need a lot of them...
    use Params::Util ':ALL';
    
    sub foo {
        my $object  = _INSTANCE(shift, 'Foo') or return undef;
        my $image   = _SCALAR(shift)          or return undef;
        my $options = _HASH(shift)            or return undef;
        # etc...
    }
  
  =head1 DESCRIPTION
  
  C<Params::Util> provides a basic set of importable functions that makes
  checking parameters a hell of a lot easier
  
  While they can be (and are) used in other contexts, the main point
  behind this module is that the functions B<both> Do What You Mean,
  and Do The Right Thing, so they are most useful when you are getting
  params passed into your code from someone and/or somewhere else
  and you can't really trust the quality.
  
  Thus, C<Params::Util> is of most use at the edges of your API, where
  params and data are coming in from outside your code.
  
  The functions provided by C<Params::Util> check in the most strictly
  correct manner known, are documented as thoroughly as possible so their
  exact behaviour is clear, and heavily tested so make sure they are not
  fooled by weird data and Really Bad Things.
  
  To use, simply load the module providing the functions you want to use
  as arguments (as shown in the SYNOPSIS).
  
  To aid in maintainability, C<Params::Util> will B<never> export by
  default.
  
  You must explicitly name the functions you want to export, or use the
  C<:ALL> param to just have it export everything (although this is not
  recommended if you have any _FOO functions yourself with which future
  additions to C<Params::Util> may clash)
  
  =head1 FUNCTIONS
  
  =cut
  
  use 5.00503;
  use strict;
  require overload;
  require Exporter;
  require Scalar::Util;
  require DynaLoader;
  
  use vars qw{$VERSION @ISA @EXPORT_OK %EXPORT_TAGS};
  
  $VERSION   = '1.07';
  @ISA       = qw{
  	Exporter
  	DynaLoader
  };
  @EXPORT_OK = qw{
  	_STRING     _IDENTIFIER
  	_CLASS      _CLASSISA   _SUBCLASS  _DRIVER  _CLASSDOES
  	_NUMBER     _POSINT     _NONNEGINT
  	_SCALAR     _SCALAR0
  	_ARRAY      _ARRAY0     _ARRAYLIKE
  	_HASH       _HASH0      _HASHLIKE
  	_CODE       _CODELIKE
  	_INVOCANT   _REGEX      _INSTANCE  _INSTANCEDOES
  	_SET        _SET0
  	_HANDLE
  };
  %EXPORT_TAGS = ( ALL => \@EXPORT_OK );
  
  eval {
  	local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
  	bootstrap Params::Util $VERSION;
  	1;
  } unless $ENV{PERL_PARAMS_UTIL_PP};
  
  # Use a private pure-perl copy of looks_like_number if the version of
  # Scalar::Util is old (for whatever reason).
  my $SU = eval "$Scalar::Util::VERSION" || 0;
  if ( $SU >= 1.18 ) { 
  	Scalar::Util->import('looks_like_number');
  } else {
  	eval <<'END_PERL';
  sub looks_like_number {
  	local $_ = shift;
  
  	# checks from perlfaq4
  	return 0 if !defined($_);
  	if (ref($_)) {
  		return overload::Overloaded($_) ? defined(0 + $_) : 0;
  	}
  	return 1 if (/^[+-]?[0-9]+$/); # is a +/- integer
  	return 1 if (/^([+-]?)(?=[0-9]|\.[0-9])[0-9]*(\.[0-9]*)?([Ee]([+-]?[0-9]+))?$/); # a C float
  	return 1 if ($] >= 5.008 and /^(Inf(inity)?|NaN)$/i) or ($] >= 5.006001 and /^Inf$/i);
  
  	0;
  }
  END_PERL
  }
  
  
  
  
  
  #####################################################################
  # Param Checking Functions
  
  =pod
  
  =head2 _STRING $string
  
  The C<_STRING> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a normal non-false string of non-zero length.
  
  Note that this will NOT do anything magic to deal with the special
  C<'0'> false negative case, but will return it.
  
    # '0' not considered valid data
    my $name = _STRING(shift) or die "Bad name";
    
    # '0' is considered valid data
    my $string = _STRING($_[0]) ? shift : die "Bad string";
  
  Please also note that this function expects a normal string. It does
  not support overloading or other magic techniques to get a string.
  
  Returns the string as a conveince if it is a valid string, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_STRING;
  sub _STRING ($) {
  	(defined $_[0] and ! ref $_[0] and length($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _IDENTIFIER $string
  
  The C<_IDENTIFIER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl identifier.
  
  Returns the string as a convenience if it is a valid identifier, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_IDENTIFIER;
  sub _IDENTIFIER ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASS $string
  
  The C<_CLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl class.
  
  This function only checks that the format is valid, not that the
  class is actually loaded. It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASS;
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASSISA $string, $class
  
  The C<_CLASSISA> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a particularly class, or a subclass of it.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSISA;
  sub _CLASSISA ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =head2 _CLASSDOES $string, $role
  
  This routine behaves exactly like C<L</_CLASSISA>>, but checks with C<< ->DOES
  >> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
  5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
  implemented.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSDOES;
  sub _CLASSDOES ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SUBCLASS $string, $class
  
  The C<_SUBCLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a subclass of a specified class.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SUBCLASS;
  sub _SUBCLASS ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0] ne $_[1] and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NUMBER $scalar
  
  The C<_NUMBER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a number. That is, it is defined and perl thinks it's a number.
  
  This function is basically a Params::Util-style wrapper around the
  L<Scalar::Util> C<looks_like_number> function.
  
  Returns the value as a convience, or C<undef> if the value is not a
  number.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NUMBER;
  sub _NUMBER ($) {
  	( defined $_[0] and ! ref $_[0] and looks_like_number($_[0]) )
  	? $_[0]
  	: undef;
  }
  END_PERL
  
  =pod
  
  =head2 _POSINT $integer
  
  The C<_POSINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a positive integer (of any length).
  
  Returns the value as a convience, or C<undef> if the value is not a
  positive integer.
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_POSINT;
  sub _POSINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[1-9]\d*$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NONNEGINT $integer
  
  The C<_NONNEGINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a non-negative integer (of any length). That is, a positive integer,
  or zero.
  
  Returns the value as a convience, or C<undef> if the value is not a
  non-negative integer.
  
  As with other tests that may return false values, care should be taken
  to test via "defined" in boolean validy contexts.
  
    unless ( defined _NONNEGINT($value) ) {
       die "Invalid value";
    }
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NONNEGINT;
  sub _NONNEGINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^(?:0|[1-9]\d*)$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR \$scalar
  
  The C<_SCALAR> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR> reference, with content of non-zero length.
  
  For a version that allows zero length C<SCALAR> references, see
  the C<_SCALAR0> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR;
  sub _SCALAR ($) {
  	(ref $_[0] eq 'SCALAR' and defined ${$_[0]} and ${$_[0]} ne '') ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR0 \$scalar
  
  The C<_SCALAR0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR0> reference, allowing content of zero-length.
  
  For a simpler "give me some content" version that requires non-zero
  length, C<_SCALAR> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR0;
  sub _SCALAR0 ($) {
  	ref $_[0] eq 'SCALAR' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY $value
  
  The C<_ARRAY> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference containing B<at least> one element of any kind.
  
  For a more basic form that allows zero length ARRAY references, see
  the C<_ARRAY0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY;
  sub _ARRAY ($) {
  	(ref $_[0] eq 'ARRAY' and @{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY0 $value
  
  The C<_ARRAY0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference, allowing C<ARRAY> references that contain no
  elements.
  
  For a more basic "An array of something" form that also requires at
  least one element, see the C<_ARRAY> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY0;
  sub _ARRAY0 ($) {
  	ref $_[0] eq 'ARRAY' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAYLIKE $value
  
  The C<_ARRAYLIKE> function tests whether a given scalar value can respond to
  array dereferencing.  If it can, the value is returned.  If it cannot,
  C<_ARRAYLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAYLIKE;
  sub _ARRAYLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'ARRAY')
  		or
  		overload::Method($_[0], '@{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH $value
  
  The C<_HASH> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference with at least one entry.
  
  For a version of this function that allows the C<HASH> to be empty,
  see the C<_HASH0> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH;
  sub _HASH ($) {
  	(ref $_[0] eq 'HASH' and scalar %{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH0 $value
  
  The C<_HASH0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference, regardless of the C<HASH> content.
  
  For a simpler "A hash of something" version that requires at least one
  element, see the C<_HASH> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH0;
  sub _HASH0 ($) {
  	ref $_[0] eq 'HASH' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASHLIKE $value
  
  The C<_HASHLIKE> function tests whether a given scalar value can respond to
  hash dereferencing.  If it can, the value is returned.  If it cannot,
  C<_HASHLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASHLIKE;
  sub _HASHLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'HASH')
  		or
  		overload::Method($_[0], '%{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODE $value
  
  The C<_CODE> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<CODE> reference.
  
  Returns the C<CODE> reference itself as a convenience, or C<undef>
  if the value provided is not an C<CODE> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODE;
  sub _CODE ($) {
  	ref $_[0] eq 'CODE' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODELIKE $value
  
  The C<_CODELIKE> is the more generic version of C<_CODE>. Unlike C<_CODE>,
  which checks for an explicit C<CODE> reference, the C<_CODELIKE> function
  also includes things that act like them, such as blessed objects that
  overload C<'&{}'>.
  
  Please note that in the case of objects overloaded with '&{}', you will
  almost always end up also testing it in 'bool' context at some stage.
  
  For example:
  
    sub foo {
        my $code1 = _CODELIKE(shift) or die "No code param provided";
        my $code2 = _CODELIKE(shift);
        if ( $code2 ) {
             print "Got optional second code param";
        }
    }
  
  As such, you will most likely always want to make sure your class has
  at least the following to allow it to evaluate to true in boolean
  context.
  
    # Always evaluate to true in boolean context
    use overload 'bool' => sub () { 1 };
  
  Returns the callable value as a convenience, or C<undef> if the
  value provided is not callable.
  
  Note - This function was formerly known as _CALLABLE but has been renamed
  for greater symmetry with the other _XXXXLIKE functions.
  
  The use of _CALLABLE has been deprecated. It will continue to work, but
  with a warning, until end-2006, then will be removed.
  
  I apologise for any inconvenience caused.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODELIKE;
  sub _CODELIKE($) {
  	(
  		(Scalar::Util::reftype($_[0])||'') eq 'CODE'
  		or
  		Scalar::Util::blessed($_[0]) and overload::Method($_[0],'&{}')
  	)
  	? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INVOCANT $value
  
  This routine tests whether the given value is a valid method invocant.
  This can be either an instance of an object, or a class name.
  
  If so, the value itself is returned.  Otherwise, C<_INVOCANT>
  returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INVOCANT;
  sub _INVOCANT($) {
  	(defined $_[0] and
  		(defined Scalar::Util::blessed($_[0])
  		or      
  		# We used to check for stash definedness, but any class-like name is a
  		# valid invocant for UNIVERSAL methods, so we stopped. -- rjbs, 2006-07-02
  		Params::Util::_CLASS($_[0]))
  	) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INSTANCE $object, $class
  
  The C<_INSTANCE> function is intended to be imported into your package,
  and provides a convenient way to test for an object of a particular class
  in a strictly correct manner.
  
  Returns the object itself as a convenience, or C<undef> if the value
  provided is not an object of that type.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCE;
  sub _INSTANCE ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =head2 _INSTANCEDOES $object, $role
  
  This routine behaves exactly like C<L</_INSTANCE>>, but checks with C<< ->DOES
  >> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
  5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
  implemented.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCEDOES;
  sub _INSTANCEDOES ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _REGEX $value
  
  The C<_REGEX> function is intended to be imported into your package,
  and provides a convenient way to test for a regular expression.
  
  Returns the value itself as a convenience, or C<undef> if the value
  provided is not a regular expression.
  
  =cut
  
  eval <<'END_PERL' unless defined &_REGEX;
  sub _REGEX ($) {
  	(defined $_[0] and 'Regexp' eq ref($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SET \@array, $class
  
  The C<_SET> function is intended to be imported into your package,
  and provides a convenient way to test for set of at least one object of
  a particular class in a strictly correct manner.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that allows zero-length sets, see the
  C<_SET0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET;
  sub _SET ($$) {
  	my $set = shift;
  	_ARRAY($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _SET0 \@array, $class
  
  The C<_SET0> function is intended to be imported into your package,
  and provides a convenient way to test for a set of objects of a
  particular class in a strictly correct manner, allowing for zero objects.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that requires at least one object, see the
  C<_SET> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET0;
  sub _SET0 ($$) {
  	my $set = shift;
  	_ARRAY0($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _HANDLE
  
  The C<_HANDLE> function is intended to be imported into your package,
  and provides a convenient way to test whether or not a single scalar
  value is a file handle.
  
  Unfortunately, in Perl the definition of a file handle can be a little
  bit fuzzy, so this function is likely to be somewhat imperfect (at first
  anyway).
  
  That said, it is implement as well or better than the other file handle
  detectors in existance (and we stole from the best of them).
  
  =cut
  
  # We're doing this longhand for now. Once everything is perfect,
  # we'll compress this into something that compiles more efficiently.
  # Further, testing file handles is not something that is generally
  # done millions of times, so doing it slowly is not a big speed hit.
  eval <<'END_PERL' unless defined &_HANDLE;
  sub _HANDLE {
  	my $it = shift;
  
  	# It has to be defined, of course
  	unless ( defined $it ) {
  		return undef;
  	}
  
  	# Normal globs are considered to be file handles
  	if ( ref $it eq 'GLOB' ) {
  		return $it;
  	}
  
  	# Check for a normal tied filehandle
  	# Side Note: 5.5.4's tied() and can() doesn't like getting undef
  	if ( tied($it) and tied($it)->can('TIEHANDLE') ) {
  		return $it;
  	}
  
  	# There are no other non-object handles that we support
  	unless ( Scalar::Util::blessed($it) ) {
  		return undef;
  	}
  
  	# Check for a common base classes for conventional IO::Handle object
  	if ( $it->isa('IO::Handle') ) {
  		return $it;
  	}
  
  
  	# Check for tied file handles using Tie::Handle
  	if ( $it->isa('Tie::Handle') ) {
  		return $it;
  	}
  
  	# IO::Scalar is not a proper seekable, but it is valid is a
  	# regular file handle
  	if ( $it->isa('IO::Scalar') ) {
  		return $it;
  	}
  
  	# Yet another special case for IO::String, which refuses (for now
  	# anyway) to become a subclass of IO::Handle.
  	if ( $it->isa('IO::String') ) {
  		return $it;
  	}
  
  	# This is not any sort of object we know about
  	return undef;
  }
  END_PERL
  
  =pod
  
  =head2 _DRIVER $string
  
    sub foo {
      my $class = _DRIVER(shift, 'My::Driver::Base') or die "Bad driver";
      ...
    }
  
  The C<_DRIVER> function is intended to be imported into your
  package, and provides a convenient way to load and validate
  a driver class.
  
  The most common pattern when taking a driver class as a parameter
  is to check that the name is a class (i.e. check against _CLASS)
  and then to load the class (if it exists) and then ensure that
  the class returns true for the isa method on some base driver name.
  
  Return the value as a convenience, or C<undef> if the value is not
  a class name, the module does not exist, the module does not load,
  or the class fails the isa test.
  
  =cut
  
  eval <<'END_PERL' unless defined &_DRIVER;
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  END_PERL
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Add _CAN to help resolve the UNIVERSAL::can debacle
  
  - Would be even nicer if someone would demonstrate how the hell to
  build a Module::Install dist of the ::Util dual Perl/XS type. :/
  
  - Implement an assertion-like version of this module, that dies on
  error.
  
  - Implement a Test:: version of this module, for use in testing
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params-Util>
  
  For other issues, contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Params::Validate>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2012 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
DARWIN-2LEVEL_PARAMS_UTIL

$fatpacked{"darwin-2level/Sub/Name.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_SUB_NAME';
  package Sub::Name; # git description: v0.20-2-gc0a0e62
  # ABSTRACT: (Re)name a sub
  # KEYWORDS: subroutine function utility name rename symbol
  
  #pod =pod
  #pod
  #pod =head1 SYNOPSIS
  #pod
  #pod     use Sub::Name;
  #pod
  #pod     subname $name, $subref;
  #pod
  #pod     $subref = subname foo => sub { ... };
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod This module has only one function, which is also exported by default:
  #pod
  #pod =for stopwords subname
  #pod
  #pod =head2 subname NAME, CODEREF
  #pod
  #pod Assigns a new name to referenced sub.  If package specification is omitted in
  #pod the name, then the current package is used.  The return value is the sub.
  #pod
  #pod The name is only used for informative routines (caller, Carp, etc).  You won't
  #pod be able to actually invoke the sub by the given name.  To allow that, you need
  #pod to do glob-assignment yourself.
  #pod
  #pod Note that for anonymous closures (subs that reference lexicals declared outside
  #pod the sub itself) you can name each instance of the closure differently, which
  #pod can be very useful for debugging.
  #pod
  #pod =head1 SEE ALSO
  #pod
  #pod =for :list
  #pod * L<Sub::Identify> - for getting information about subs
  #pod * L<Sub::Util> - set_subname is another implementation of C<subname>
  #pod
  #pod =for stopwords cPanel
  #pod
  #pod =head1 COPYRIGHT AND LICENSE
  #pod
  #pod This software is copyright (c) 2004, 2008 by Matthijs van Duin, all rights reserved;
  #pod copyright (c) 2014 cPanel Inc., all rights reserved.
  #pod
  #pod This program is free software; you can redistribute it and/or modify
  #pod it under the same terms as Perl itself.
  #pod
  #pod =cut
  
  use 5.006;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.21';
  
  use Exporter 5.57 'import';
  
  our @EXPORT = qw(subname);
  our @EXPORT_OK = @EXPORT;
  
  use XSLoader;
  XSLoader::load(
      __PACKAGE__,
      $VERSION,
  );
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Sub::Name - (Re)name a sub
  
  =head1 VERSION
  
  version 0.21
  
  =head1 SYNOPSIS
  
      use Sub::Name;
  
      subname $name, $subref;
  
      $subref = subname foo => sub { ... };
  
  =head1 DESCRIPTION
  
  This module has only one function, which is also exported by default:
  
  =for stopwords subname
  
  =head2 subname NAME, CODEREF
  
  Assigns a new name to referenced sub.  If package specification is omitted in
  the name, then the current package is used.  The return value is the sub.
  
  The name is only used for informative routines (caller, Carp, etc).  You won't
  be able to actually invoke the sub by the given name.  To allow that, you need
  to do glob-assignment yourself.
  
  Note that for anonymous closures (subs that reference lexicals declared outside
  the sub itself) you can name each instance of the closure differently, which
  can be very useful for debugging.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<Sub::Identify> - for getting information about subs
  
  =item *
  
  L<Sub::Util> - set_subname is another implementation of C<subname>
  
  =back
  
  =for stopwords cPanel
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Sub-Name>
  (or L<bug-Sub-Name@rt.cpan.org|mailto:bug-Sub-Name@rt.cpan.org>).
  
  There is also an irc channel available for users of this distribution, at
  L<C<#toolchain> on C<irc.perl.org>|irc://irc.perl.org/#toolchain>.
  
  =head1 AUTHOR
  
  Matthijs van Duin <xmath@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Karen Etheridge Leon Timmermans Florian Ragwitz Reini Urban Matthijs van Duin gfx Dagfinn Ilmari Mannsåker Aristotle Pagaltzis J.R. Mash Alexander Bluhm
  
  =over 4
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Leon Timmermans <fawaka@gmail.com>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Reini Urban <rurban@cpanel.net>
  
  =item *
  
  Matthijs van Duin <xmath-no-spam@nospam.cpan.org>
  
  =item *
  
  gfx <gfuji@cpan.org>
  
  =item *
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =item *
  
  Aristotle Pagaltzis <pagaltzis@gmx.de>
  
  =item *
  
  J.R. Mash <jmash.code@gmail.com>
  
  =item *
  
  Alexander Bluhm <alexander.bluhm@gmx.net>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2004, 2008 by Matthijs van Duin, all rights reserved;
  copyright (c) 2014 cPanel Inc., all rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DARWIN-2LEVEL_SUB_NAME

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

package Perl::PrereqScanner::App;
# ABSTRACT: scan your working dir for likely prereqs
$Perl::PrereqScanner::App::VERSION = '1.023';
use strict;
use warnings;

use File::Find;
use File::Spec::Functions qw{ catdir updir };
use FindBin qw{ $Bin };
use lib catdir( $Bin, updir, 'lib' );

use List::Util qw{ max };
use Perl::PrereqScanner;
use CPAN::Meta::Requirements ();

use Getopt::Long qw{ GetOptions };
my %options;
GetOptions(
  \%options,
  'combine!',
);
my $combined = $options{combine} && CPAN::Meta::Requirements->new;

foreach my $file ( @ARGV ? @ARGV : '.' ) {
    -d $file ? scan_dir( $file ) : scan_file( $file );
}

sub scan_dir {
    find( {
        no_chdir => 1, 
        wanted => sub { scan_file($_) if /\.(pl|pm|psgi|t)$/ && -f $_; }
    }, shift );
}

sub scan_file {
    my $file = shift;
    my $prereqs = Perl::PrereqScanner->new->scan_file($file);
    if( $options{combine} ){
        $combined->add_requirements($prereqs);
    }
    else {
        print "* $file\n";
        print_prereqs($prereqs);
    }
}

if( $options{combine} ){
    print_prereqs($combined);
}

sub print_prereqs {
    my $prereqs = shift->as_string_hash;
    my $max = max map { length } keys %$prereqs;
    printf( "%-${max}s = %s\n", $_, $prereqs->{$_} )
        for sort keys %$prereqs;
}

exit;

#pod =head1 SYNOPSIS
#pod
#pod     scan_prereqs [--combine] [DIRS|FILES]
#pod
#pod Directories are traversed with L<File::Find> to collect all C<.pl>, C<.pm>,
#pod C<.psgi> and C<.t> files. If no directories or files are specified, the current
#pod working directory is scanned.
#pod
#pod =cut

__END__

=pod

=encoding UTF-8

=head1 NAME

Perl::PrereqScanner::App - scan your working dir for likely prereqs

=head1 VERSION

version 1.023

=head1 SYNOPSIS

    scan_prereqs [--combine] [DIRS|FILES]

Directories are traversed with L<File::Find> to collect all C<.pl>, C<.pm>,
C<.psgi> and C<.t> files. If no directories or files are specified, the current
working directory is scanned.

=head1 AUTHORS

=over 4

=item *

Jerome Quelin

=item *

Ricardo Signes <rjbs@cpan.org>

=back

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2009 by Jerome Quelin.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut
